//# 1 ".ppm_dump.eobjs/jsoo/ppm_dump.bc.runtime.js"
// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=unknown, use-js-string=true, version=5.8.2+5.8.2
//# 3 ".ppm_dump.eobjs/jsoo/ppm_dump.bc.runtime.js"

//# 7 ".ppm_dump.eobjs/jsoo/ppm_dump.bc.runtime.js"
(function
  (Object){
   typeof globalThis !== "object"
   &&
    (this
      ? get()
      : (Object.defineProperty
         (Object.prototype, "_T_", {configurable: true, get: get}),
        _T_));
   function get(){
    var global = this || self;
    global.globalThis = global;
    delete Object.prototype._T_;
   }
  }
  (Object));
(function(globalThis){
   "use strict";
   var
    joo_global_object = globalThis,
    BUTTON =
      {NONE: 0, LEFT: 1, MIDDLE: 2, RIGHT: 3, WHEEL_UP: 4, WHEEL_DOWN: 5},
    BUTTON_STATE = {UP: 0, DOWN: 1},
    BUTTON_STATE_TAG = {UP: 0, DOWN: 1},
    BUTTON_TAG =
      {NONE: 0, LEFT: 1, MIDDLE: 2, RIGHT: 3, WHEEL_UP: 4, WHEEL_DOWN: 5};
   function caml_subarray_to_jsbytes(a, i, len){
    var f = String.fromCharCode;
    if(i == 0 && len <= 4096 && len == a.length) return f.apply(null, a);
    var s = "";
    for(; 0 < len; i += 1024, len -= 1024)
     s += f.apply(null, a.slice(i, i + Math.min(len, 1024)));
    return s;
   }
   function caml_string_of_jsbytes(x){return x;}
   function caml_string_of_array(a){
    return caml_string_of_jsbytes(caml_subarray_to_jsbytes(a, 0, a.length));
   }
   function caml_ba_get_1(ba, i0){return ba.get(ba.offset(i0));}
   function BigStringReader(bs, i){this.s = bs; this.i = i;}
   BigStringReader.prototype =
    {read8u: function(){return caml_ba_get_1(this.s, this.i++);},
     read8s: function(){return caml_ba_get_1(this.s, this.i++) << 24 >> 24;},
     read16u:
     function(){
      var s = this.s, i = this.i;
      this.i = i + 2;
      return caml_ba_get_1(s, i) << 8 | caml_ba_get_1(s, i + 1);
     },
     read16s:
     function(){
      var s = this.s, i = this.i;
      this.i = i + 2;
      return caml_ba_get_1(s, i) << 24 >> 16 | caml_ba_get_1(s, i + 1);
     },
     read32u:
     function(){
      var s = this.s, i = this.i;
      this.i = i + 4;
      return (caml_ba_get_1(s, i) << 24 | caml_ba_get_1(s, i + 1) << 16
             | caml_ba_get_1(s, i + 2) << 8
             | caml_ba_get_1(s, i + 3))
             >>> 0;
     },
     read32s:
     function(){
      var s = this.s, i = this.i;
      this.i = i + 4;
      return caml_ba_get_1(s, i) << 24 | caml_ba_get_1(s, i + 1) << 16
             | caml_ba_get_1(s, i + 2) << 8
             | caml_ba_get_1(s, i + 3);
     },
     readstr:
     function(len){
      var i = this.i, arr = new Array(len);
      for(var j = 0; j < len; j++) arr[j] = caml_ba_get_1(this.s, i + j);
      this.i = i + len;
      return caml_string_of_array(arr);
     },
     readuint8array:
     function(len){
      var i = this.i, offset = this.offset(i);
      this.i = i + len;
      return this.s.data.subarray(offset, offset + len);
     }};
   var
    CAP_TYPE_TAG = {BUTT: 0, SQUARE: 1, ROUND: 2},
    COMPOP_TAG =
      {SOURCE_OVER: 0,
       SOURCE_IN: 1,
       SOURCE_OUT: 2,
       SOURCE_ATOP: 3,
       DESTINATION_OVER: 4,
       DESTINATION_IN: 5,
       DESTINATION_OUT: 6,
       DESTINATION_ATOP: 7,
       LIGHTER: 8,
       COPY: 9,
       XOR: 10,
       MULTIPLY: 11,
       SCREEN: 12,
       OVERLAY: 13,
       DARKEN: 14,
       LIGHTEN: 15,
       COLOR_DODGE: 16,
       COLOR_BURN: 17,
       HARD_LIGHT: 18,
       SOFT_LIGHT: 19,
       DIFFERENCE: 20,
       EXCLUSION: 21,
       HUE: 22,
       SATURATION: 23,
       COLOR: 24,
       LUMINOSITY: 25},
    tag_to_cap_type =
      new
       joo_global_object.Map
       ([[CAP_TYPE_TAG.BUTT, "butt"],
         [CAP_TYPE_TAG.SQUARE, "square"],
         [CAP_TYPE_TAG.ROUND, "round"]]);
   function Cap_type_val(cap){return tag_to_cap_type.get(cap);}
   var
    tag_to_compop =
      new
       joo_global_object.Map
       ([[COMPOP_TAG.SOURCE_OVER, "source-over"],
         [COMPOP_TAG.SOURCE_IN, "source-in"],
         [COMPOP_TAG.SOURCE_OUT, "source-out"],
         [COMPOP_TAG.SOURCE_ATOP, "source-atop"],
         [COMPOP_TAG.DESTINATION_OVER, "destination-over"],
         [COMPOP_TAG.DESTINATION_IN, "destination-in"],
         [COMPOP_TAG.DESTINATION_OUT, "destination-out"],
         [COMPOP_TAG.DESTINATION_ATOP, "destination-atop"],
         [COMPOP_TAG.LIGHTER, "lighter"],
         [COMPOP_TAG.COPY, "copy"],
         [COMPOP_TAG.XOR, "xor"],
         [COMPOP_TAG.MULTIPLY, "multiply"],
         [COMPOP_TAG.SCREEN, "screen"],
         [COMPOP_TAG.OVERLAY, "overlay"],
         [COMPOP_TAG.DARKEN, "darken"],
         [COMPOP_TAG.LIGHTEN, "lighten"],
         [COMPOP_TAG.COLOR_DODGE, "color-dodge"],
         [COMPOP_TAG.COLOR_BURN, "color-burn"],
         [COMPOP_TAG.HARD_LIGHT, "hard-light"],
         [COMPOP_TAG.SOFT_LIGHT, "soft-light"],
         [COMPOP_TAG.DIFFERENCE, "difference"],
         [COMPOP_TAG.EXCLUSION, "exclusion"],
         [COMPOP_TAG.HUE, "hue"],
         [COMPOP_TAG.SATURATION, "saturation"],
         [COMPOP_TAG.COLOR, "color"],
         [COMPOP_TAG.LUMINOSITY, "luminosity"]]);
   function Compop_val(cap){return tag_to_compop.get(cap);}
   var STYLE_TAG = {COLOR: 0, GRADIENT: 1, PATTERN: 2};
   function Draw_style_val(style){
    var s = [];
    s[1] = style;
    switch(typeof style){
      case "string":
       s[0] = STYLE_TAG.COLOR; break;
      case "CanvasGradient":
       s[0] = STYLE_TAG.GRADIENT; break;
      case "CanvasPattern":
       s[0] = STYLE_TAG.PATTERN; break;
    }
    return s;
   }
   var
    EVENT_TAG =
      {FRAME_CYCLE: 0,
       FRAME: 1,
       CANVAS_FOCUSED: 2,
       CANVAS_RESIZED: 3,
       CANVAS_MOVED: 4,
       CANVAS_CLOSED: 5,
       KEY_ACTION: 6,
       BUTTON_ACTION: 7,
       MOUSE_MOVE: 8},
    FOCUS = {OUT: 0, IN: 1},
    FOCUS_TAG = {OUT: 0, IN: 1},
    JOIN_TYPE_TAG = {ROUND: 0, MITER: 1, BEVEL: 2},
    tag_to_join_type =
      new
       joo_global_object.Map
       ([[JOIN_TYPE_TAG.ROUND, "round"],
         [JOIN_TYPE_TAG.MITER, "miter"],
         [JOIN_TYPE_TAG.BEVEL, "bevel"]]);
   function Join_type_val(join){return tag_to_join_type.get(join);}
   var
    KEY =
      {UNDEFINED: 0x03,
       ESCAPE: 0x29,
       F1: 0x3A,
       F2: 0x3B,
       F3: 0x3C,
       F4: 0x3D,
       F5: 0x3E,
       F6: 0x3F,
       F7: 0x40,
       F8: 0x41,
       F9: 0x42,
       F10: 0x43,
       F11: 0x44,
       F12: 0x45,
       PRINTSCREEN: 0x46,
       SCROLLLOCK: 0x47,
       PAUSE: 0x48,
       GRAVE_TILDE: 0x35,
       _1_EXCLAMATION: 0x1E,
       _2_AT: 0x1F,
       _3_NUMBER: 0x20,
       _4_DOLLAR: 0x21,
       _5_PERCENT: 0x22,
       _6_CARET: 0x23,
       _7_AMPERSAND: 0x24,
       _8_ASTERISK: 0x25,
       _9_LPARENTHESIS: 0x26,
       _0_RPARENTHESIS: 0x27,
       MINUS_UNDERSCORE: 0x2D,
       EQUAL_PLUS: 0x2E,
       BACKSPACE: 0x2A,
       TAB: 0x2B,
       Q: 0x14,
       W: 0x1A,
       E: 0x08,
       R: 0x15,
       T: 0x17,
       Y: 0x1C,
       U: 0x18,
       I: 0x0C,
       O: 0x12,
       P: 0x13,
       LBRACKET_CURLY: 0x2F,
       RBRACKET_CURLY: 0x30,
       BACKSLASH_PIPE: 0x31,
       CAPSLOCK: 0x39,
       A: 0x04,
       S: 0x16,
       D: 0x07,
       F: 0x09,
       G: 0x0A,
       H: 0x0B,
       J: 0x0D,
       K: 0x0E,
       L: 0x0F,
       SEMICOLON_COLON: 0x33,
       QUOTE_DOUBLEQUOTE: 0x34,
       NONUS_NUMBER_TILDE: 0x32,
       RETURN: 0x28,
       LSHIFT: 0xE1,
       NONUS_BACKSLASH_PIPE: 0x64,
       Z: 0x1D,
       X: 0x1B,
       C: 0x06,
       V: 0x19,
       B: 0x05,
       N: 0x11,
       M: 0x10,
       COMMA_LESS: 0x36,
       PERIOD_GREATER: 0x37,
       SLASH_QUESTION: 0x38,
       RSHIFT: 0xE5,
       LCONTROL: 0xE0,
       LMETA: 0xE3,
       LALT: 0xE2,
       SPACEBAR: 0x2C,
       RALT: 0xE6,
       RMETA: 0xE7,
       MENU: 0x76,
       RCONTROL: 0xE4,
       INSERT: 0x49,
       HOME: 0x4A,
       PAGEUP: 0x4B,
       DELETEFORWARD: 0x4C,
       END: 0x4D,
       PAGEDOWN: 0x4E,
       UPARROW: 0x52,
       LEFTARROW: 0x50,
       DOWNARROW: 0x51,
       RIGHTARROW: 0x4F,
       PAD_NUMLOCK_CLEAR: 0x53,
       PAD_EQUALS: 0x67,
       PAD_DIVIDE: 0x54,
       PAD_MULTIPLY: 0x55,
       PAD_MINUS: 0x56,
       PAD_7_HOME: 0x5F,
       PAD_8_UPARROW: 0x60,
       PAD_9_PAGEUP: 0x61,
       PAD_PLUS: 0x57,
       PAD_4_LEFTARROW: 0x5C,
       PAD_5: 0x5D,
       PAD_6_RIGHTARROW: 0x5E,
       PAD_COMMA: 0x85,
       PAD_1_END: 0x59,
       PAD_2_DOWNARROW: 0x5A,
       PAD_3_PAGEDOWN: 0x5B,
       PAD_0_INSERT: 0x62,
       PAD_DECIMAL_DELETE: 0x63,
       PAD_ENTER: 0x58,
       F13: 0x68,
       F14: 0x69,
       F15: 0x6A,
       F16: 0x6B,
       F17: 0x6C,
       F18: 0x6D,
       F19: 0x6E,
       F20: 0x6F,
       F21: 0x70,
       F22: 0x71,
       F23: 0x72,
       F24: 0x73,
       INTERNATIONAL1: 0x87,
       INTERNATIONAL2: 0x88,
       INTERNATIONAL3: 0x89,
       INTERNATIONAL4: 0x8A,
       INTERNATIONAL5: 0x8B,
       INTERNATIONAL6: 0x8C,
       INTERNATIONAL7: 0x8D,
       INTERNATIONAL8: 0x8E,
       INTERNATIONAL9: 0x8F,
       LANG1: 0x90,
       LANG2: 0x91,
       LANG3: 0x92,
       LANG4: 0x93,
       LANG5: 0x94,
       HELP: 0x75,
       MUTE: 0x7F,
       VOLUMEUP: 0x80,
       VOLUMEDOWN: 0x81},
    KEY_STATE = {UP: 0, DOWN: 1},
    KEY_STATE_TAG = {UP: 0, DOWN: 1},
    KEY_TAG =
      {ESCAPE: 0,
       F1: 1,
       F2: 2,
       F3: 3,
       F4: 4,
       F5: 5,
       F6: 6,
       F7: 7,
       F8: 8,
       F9: 9,
       F10: 10,
       F11: 11,
       F12: 12,
       PRINTSCREEN: 13,
       SCROLLLOCK: 14,
       PAUSE: 15,
       GRAVE_TILDE: 16,
       _1_EXCLAMATION: 17,
       _2_AT: 18,
       _3_NUMBER: 19,
       _4_DOLLAR: 20,
       _5_PERCENT: 21,
       _6_CARET: 22,
       _7_AMPERSAND: 23,
       _8_ASTERISK: 24,
       _9_LPARENTHESIS: 25,
       _0_RPARENTHESIS: 26,
       MINUS_UNDERSCORE: 27,
       EQUAL_PLUS: 28,
       BACKSPACE: 29,
       TAB: 30,
       Q: 31,
       W: 32,
       E: 33,
       R: 34,
       T: 35,
       Y: 36,
       U: 37,
       I: 38,
       O: 39,
       P: 40,
       LBRACKET_CURLY: 41,
       RBRACKET_CURLY: 42,
       BACKSLASH_PIPE: 43,
       CAPSLOCK: 44,
       A: 45,
       S: 46,
       D: 47,
       F: 48,
       G: 49,
       H: 50,
       J: 51,
       K: 52,
       L: 53,
       SEMICOLON_COLON: 54,
       QUOTE_DOUBLEQUOTE: 55,
       NONUS_NUMBER_TILDE: 56,
       RETURN: 57,
       LSHIFT: 58,
       NONUS_BACKSLASH_PIPE: 59,
       Z: 60,
       X: 61,
       C: 62,
       V: 63,
       B: 64,
       N: 65,
       M: 66,
       COMMA_LESS: 67,
       PERIOD_GREATER: 68,
       SLASH_QUESTION: 69,
       RSHIFT: 70,
       LCONTROL: 71,
       LMETA: 72,
       LALT: 73,
       SPACEBAR: 74,
       RALT: 75,
       RMETA: 76,
       MENU: 77,
       RCONTROL: 78,
       INSERT: 79,
       HOME: 80,
       PAGEUP: 81,
       DELETEFORWARD: 82,
       END: 83,
       PAGEDOWN: 84,
       UPARROW: 85,
       LEFTARROW: 86,
       DOWNARROW: 87,
       RIGHTARROW: 88,
       PAD_NUMLOCK_CLEAR: 89,
       PAD_EQUALS: 90,
       PAD_DIVIDE: 91,
       PAD_MULTIPLY: 92,
       PAD_MINUS: 93,
       PAD_7_HOME: 94,
       PAD_8_UPARROW: 95,
       PAD_9_PAGEUP: 96,
       PAD_PLUS: 97,
       PAD_4_LEFTARROW: 98,
       PAD_5: 99,
       PAD_6_RIGHTARROW: 100,
       PAD_COMMA: 101,
       PAD_1_END: 102,
       PAD_2_DOWNARROW: 103,
       PAD_3_PAGEDOWN: 104,
       PAD_0_INSERT: 105,
       PAD_DECIMAL_DELETE: 106,
       PAD_ENTER: 107,
       F13: 108,
       F14: 109,
       F15: 110,
       F16: 111,
       F17: 112,
       F18: 113,
       F19: 114,
       F20: 115,
       F21: 116,
       F22: 117,
       F23: 118,
       F24: 119,
       INTERNATIONAL1: 120,
       INTERNATIONAL2: 121,
       INTERNATIONAL3: 122,
       INTERNATIONAL4: 123,
       INTERNATIONAL5: 124,
       INTERNATIONAL6: 125,
       INTERNATIONAL7: 126,
       INTERNATIONAL8: 127,
       INTERNATIONAL9: 128,
       LANG1: 129,
       LANG2: 130,
       LANG3: 131,
       LANG4: 132,
       LANG5: 133,
       HELP: 134,
       MUTE: 135,
       VOLUMEUP: 136,
       VOLUMEDOWN: 137},
    tag_to_kc =
      new
       joo_global_object.Map
       ([[KEY_TAG.ESCAPE, KEY.ESCAPE],
         [KEY_TAG.F1, KEY.F1],
         [KEY_TAG.F2, KEY.F2],
         [KEY_TAG.F3, KEY.F3],
         [KEY_TAG.F4, KEY.F4],
         [KEY_TAG.F5, KEY.F5],
         [KEY_TAG.F6, KEY.F6],
         [KEY_TAG.F7, KEY.F7],
         [KEY_TAG.F8, KEY.F8],
         [KEY_TAG.F9, KEY.F9],
         [KEY_TAG.F10, KEY.F10],
         [KEY_TAG.F11, KEY.F11],
         [KEY_TAG.F12, KEY.F12],
         [KEY_TAG.PRINTSCREEN, KEY.PRINTSCREEN],
         [KEY_TAG.SCROLLLOCK, KEY.SCROLLLOCK],
         [KEY_TAG.PAUSE, KEY.PAUSE],
         [KEY_TAG.GRAVE_TILDE, KEY.GRAVE_TILDE],
         [KEY_TAG._1_EXCLAMATION, KEY._1_EXCLAMATION],
         [KEY_TAG._2_AT, KEY._2_AT],
         [KEY_TAG._3_NUMBER, KEY._3_NUMBER],
         [KEY_TAG._4_DOLLAR, KEY._4_DOLLAR],
         [KEY_TAG._5_PERCENT, KEY._5_PERCENT],
         [KEY_TAG._6_CARET, KEY._6_CARET],
         [KEY_TAG._7_AMPERSAND, KEY._7_AMPERSAND],
         [KEY_TAG._8_ASTERISK, KEY._8_ASTERISK],
         [KEY_TAG._9_LPARENTHESIS, KEY._9_LPARENTHESIS],
         [KEY_TAG._0_RPARENTHESIS, KEY._0_RPARENTHESIS],
         [KEY_TAG.MINUS_UNDERSCORE, KEY.MINUS_UNDERSCORE],
         [KEY_TAG.EQUAL_PLUS, KEY.EQUAL_PLUS],
         [KEY_TAG.BACKSPACE, KEY.BACKSPACE],
         [KEY_TAG.TAB, KEY.TAB],
         [KEY_TAG.Q, KEY.Q],
         [KEY_TAG.W, KEY.W],
         [KEY_TAG.E, KEY.E],
         [KEY_TAG.R, KEY.R],
         [KEY_TAG.T, KEY.T],
         [KEY_TAG.Y, KEY.Y],
         [KEY_TAG.U, KEY.U],
         [KEY_TAG.I, KEY.I],
         [KEY_TAG.O, KEY.O],
         [KEY_TAG.P, KEY.P],
         [KEY_TAG.LBRACKET_CURLY, KEY.LBRACKET_CURLY],
         [KEY_TAG.RBRACKET_CURLY, KEY.RBRACKET_CURLY],
         [KEY_TAG.BACKSLASH_PIPE, KEY.BACKSLASH_PIPE],
         [KEY_TAG.CAPSLOCK, KEY.CAPSLOCK],
         [KEY_TAG.A, KEY.A],
         [KEY_TAG.S, KEY.S],
         [KEY_TAG.D, KEY.D],
         [KEY_TAG.F, KEY.F],
         [KEY_TAG.G, KEY.G],
         [KEY_TAG.H, KEY.H],
         [KEY_TAG.J, KEY.J],
         [KEY_TAG.K, KEY.K],
         [KEY_TAG.L, KEY.L],
         [KEY_TAG.SEMICOLON_COLON, KEY.SEMICOLON_COLON],
         [KEY_TAG.QUOTE_DOUBLEQUOTE, KEY.QUOTE_DOUBLEQUOTE],
         [KEY_TAG.NONUS_NUMBER_TILDE, KEY.NONUS_NUMBER_TILDE],
         [KEY_TAG.RETURN, KEY.RETURN],
         [KEY_TAG.LSHIFT, KEY.LSHIFT],
         [KEY_TAG.NONUS_BACKSLASH_PIPE, KEY.NONUS_BACKSLASH_PIPE],
         [KEY_TAG.Z, KEY.Z],
         [KEY_TAG.X, KEY.X],
         [KEY_TAG.C, KEY.C],
         [KEY_TAG.V, KEY.V],
         [KEY_TAG.B, KEY.B],
         [KEY_TAG.N, KEY.N],
         [KEY_TAG.M, KEY.M],
         [KEY_TAG.COMMA_LESS, KEY.COMMA_LESS],
         [KEY_TAG.PERIOD_GREATER, KEY.PERIOD_GREATER],
         [KEY_TAG.SLASH_QUESTION, KEY.SLASH_QUESTION],
         [KEY_TAG.RSHIFT, KEY.RSHIFT],
         [KEY_TAG.LCONTROL, KEY.LCONTROL],
         [KEY_TAG.LMETA, KEY.LMETA],
         [KEY_TAG.LALT, KEY.LALT],
         [KEY_TAG.SPACEBAR, KEY.SPACEBAR],
         [KEY_TAG.RALT, KEY.RALT],
         [KEY_TAG.RMETA, KEY.RMETA],
         [KEY_TAG.MENU, KEY.MENU],
         [KEY_TAG.RCONTROL, KEY.RCONTROL],
         [KEY_TAG.INSERT, KEY.INSERT],
         [KEY_TAG.HOME, KEY.HOME],
         [KEY_TAG.PAGEUP, KEY.PAGEUP],
         [KEY_TAG.DELETEFORWARD, KEY.DELETEFORWARD],
         [KEY_TAG.END, KEY.END],
         [KEY_TAG.PAGEDOWN, KEY.PAGEDOWN],
         [KEY_TAG.UPARROW, KEY.UPARROW],
         [KEY_TAG.LEFTARROW, KEY.LEFTARROW],
         [KEY_TAG.DOWNARROW, KEY.DOWNARROW],
         [KEY_TAG.RIGHTARROW, KEY.RIGHTARROW],
         [KEY_TAG.PAD_NUMLOCK_CLEAR, KEY.PAD_NUMLOCK_CLEAR],
         [KEY_TAG.PAD_EQUALS, KEY.PAD_EQUALS],
         [KEY_TAG.PAD_DIVIDE, KEY.PAD_DIVIDE],
         [KEY_TAG.PAD_MULTIPLY, KEY.PAD_MULTIPLY],
         [KEY_TAG.PAD_MINUS, KEY.PAD_MINUS],
         [KEY_TAG.PAD_7_HOME, KEY.PAD_7_HOME],
         [KEY_TAG.PAD_8_UPARROW, KEY.PAD_8_UPARROW],
         [KEY_TAG.PAD_9_PAGEUP, KEY.PAD_9_PAGEUP],
         [KEY_TAG.PAD_PLUS, KEY.PAD_PLUS],
         [KEY_TAG.PAD_4_LEFTARROW, KEY.PAD_4_LEFTARROW],
         [KEY_TAG.PAD_5, KEY.PAD_5],
         [KEY_TAG.PAD_6_RIGHTARROW, KEY.PAD_6_RIGHTARROW],
         [KEY_TAG.PAD_COMMA, KEY.PAD_COMMA],
         [KEY_TAG.PAD_1_END, KEY.PAD_1_END],
         [KEY_TAG.PAD_2_DOWNARROW, KEY.PAD_2_DOWNARROW],
         [KEY_TAG.PAD_3_PAGEDOWN, KEY.PAD_3_PAGEDOWN],
         [KEY_TAG.PAD_0_INSERT, KEY.PAD_0_INSERT],
         [KEY_TAG.PAD_DECIMAL_DELETE, KEY.PAD_DECIMAL_DELETE],
         [KEY_TAG.PAD_ENTER, KEY.PAD_ENTER],
         [KEY_TAG.F13, KEY.F13],
         [KEY_TAG.F14, KEY.F14],
         [KEY_TAG.F15, KEY.F15],
         [KEY_TAG.F16, KEY.F16],
         [KEY_TAG.F17, KEY.F17],
         [KEY_TAG.F18, KEY.F18],
         [KEY_TAG.F19, KEY.F19],
         [KEY_TAG.F20, KEY.F20],
         [KEY_TAG.F21, KEY.F21],
         [KEY_TAG.F22, KEY.F22],
         [KEY_TAG.F23, KEY.F23],
         [KEY_TAG.F24, KEY.F24],
         [KEY_TAG.INTERNATIONAL1, KEY.INTERNATIONAL1],
         [KEY_TAG.INTERNATIONAL2, KEY.INTERNATIONAL2],
         [KEY_TAG.INTERNATIONAL3, KEY.INTERNATIONAL3],
         [KEY_TAG.INTERNATIONAL4, KEY.INTERNATIONAL4],
         [KEY_TAG.INTERNATIONAL5, KEY.INTERNATIONAL5],
         [KEY_TAG.INTERNATIONAL6, KEY.INTERNATIONAL6],
         [KEY_TAG.INTERNATIONAL7, KEY.INTERNATIONAL7],
         [KEY_TAG.INTERNATIONAL8, KEY.INTERNATIONAL8],
         [KEY_TAG.INTERNATIONAL9, KEY.INTERNATIONAL9],
         [KEY_TAG.LANG1, KEY.LANG1],
         [KEY_TAG.LANG2, KEY.LANG2],
         [KEY_TAG.LANG3, KEY.LANG3],
         [KEY_TAG.LANG4, KEY.LANG4],
         [KEY_TAG.LANG5, KEY.LANG5],
         [KEY_TAG.HELP, KEY.HELP],
         [KEY_TAG.MUTE, KEY.MUTE],
         [KEY_TAG.VOLUMEUP, KEY.VOLUMEUP],
         [KEY_TAG.VOLUMEDOWN, KEY.VOLUMEDOWN]]);
   function Key_code_val(keycode){return tag_to_kc.get(keycode);}
   function caml_str_repeat(n, s){
    if(n == 0) return "";
    if(s.repeat) return s.repeat(n);
    var r = "", l = 0;
    for(;;){
     if(n & 1) r += s;
     n >>= 1;
     if(n == 0) return r;
     s += s;
     l++;
     if(l == 9) s.slice(0, 1);
    }
   }
   function caml_convert_string_to_bytes(s){
    if(s.t == 2)
     s.c += caml_str_repeat(s.l - s.c.length, "\0");
    else
     s.c = caml_subarray_to_jsbytes(s.c, 0, s.c.length);
    s.t = 0;
   }
   function jsoo_is_ascii(s){
    if(s.length < 24){
     for(var i = 0; i < s.length; i++) if(s.charCodeAt(i) > 127) return false;
     return true;
    }
    else
     return ! /[^\x00-\x7f]/.test(s);
   }
   function caml_utf16_of_utf8(s){
    for(var b = "", t = "", c, c1, c2, v, i = 0, l = s.length; i < l; i++){
     c1 = s.charCodeAt(i);
     if(c1 < 0x80){
      for(var j = i + 1; j < l && (c1 = s.charCodeAt(j)) < 0x80; j++) ;
      if(j - i > 512){
       t.substr(0, 1);
       b += t;
       t = "";
       b += s.slice(i, j);
      }
      else
       t += s.slice(i, j);
      if(j == l) break;
      i = j;
     }
     v = 1;
     if(++i < l && ((c2 = s.charCodeAt(i)) & - 64) == 128){
      c = c2 + (c1 << 6);
      if(c1 < 0xe0){
       v = c - 0x3080;
       if(v < 0x80) v = 1;
      }
      else{
       v = 2;
       if(++i < l && ((c2 = s.charCodeAt(i)) & - 64) == 128){
        c = c2 + (c << 6);
        if(c1 < 0xf0){
         v = c - 0xe2080;
         if(v < 0x800 || v >= 0xd7ff && v < 0xe000) v = 2;
        }
        else{
         v = 3;
         if(++i < l && ((c2 = s.charCodeAt(i)) & - 64) == 128 && c1 < 0xf5){
          v = c2 - 0x3c82080 + (c << 6);
          if(v < 0x10000 || v > 0x10ffff) v = 3;
         }
        }
       }
      }
     }
     if(v < 4){
      i -= v;
      t += "\ufffd";
     }
     else if(v > 0xffff)
      t += String.fromCharCode(0xd7c0 + (v >> 10), 0xdc00 + (v & 0x3FF));
     else
      t += String.fromCharCode(v);
     if(t.length > 1024){t.substr(0, 1); b += t; t = "";}
    }
    return b + t;
   }
   function MlBytes(tag, contents, length){
    this.t = tag;
    this.c = contents;
    this.l = length;
   }
   MlBytes.prototype.toString =
    function(){
     switch(this.t){
       case 9:
        return this.c;
       default: caml_convert_string_to_bytes(this);
       case 0:
        if(jsoo_is_ascii(this.c)){this.t = 9; return this.c;} this.t = 8;
       case 8:
        return this.c;
     }
    };
   MlBytes.prototype.toUtf16 =
    function(){
     var r = this.toString();
     if(this.t == 9) return r;
     return caml_utf16_of_utf8(r);
    };
   MlBytes.prototype.slice =
    function(){
     var content = this.t == 4 ? this.c.slice() : this.c;
     return new MlBytes(this.t, content, this.l);
    };
   function caml_utf8_of_utf16(s){
    for(var b = "", t = b, c, d, i = 0, l = s.length; i < l; i++){
     c = s.charCodeAt(i);
     if(c < 0x80){
      for(var j = i + 1; j < l && (c = s.charCodeAt(j)) < 0x80; j++) ;
      if(j - i > 512){
       t.substr(0, 1);
       b += t;
       t = "";
       b += s.slice(i, j);
      }
      else
       t += s.slice(i, j);
      if(j == l) break;
      i = j;
     }
     if(c < 0x800){
      t += String.fromCharCode(0xc0 | c >> 6);
      t += String.fromCharCode(0x80 | c & 0x3f);
     }
     else if(c < 0xd800 || c >= 0xdfff)
      t +=
       String.fromCharCode
        (0xe0 | c >> 12, 0x80 | c >> 6 & 0x3f, 0x80 | c & 0x3f);
     else if
      (c >= 0xdbff || i + 1 == l || (d = s.charCodeAt(i + 1)) < 0xdc00
       || d > 0xdfff)
      t += "\xef\xbf\xbd";
     else{
      i++;
      c = (c << 10) + d - 0x35fdc00;
      t +=
       String.fromCharCode
        (0xf0 | c >> 18,
         0x80 | c >> 12 & 0x3f,
         0x80 | c >> 6 & 0x3f,
         0x80 | c & 0x3f);
     }
     if(t.length > 1024){t.substr(0, 1); b += t; t = "";}
    }
    return b + t;
   }
   function caml_string_of_jsstring(s){
    return jsoo_is_ascii(s)
            ? caml_string_of_jsbytes(s)
            : caml_string_of_jsbytes(caml_utf8_of_utf16(s));
   }
   var
    unix_error =
      ["E2BIG",
       "EACCES",
       "EAGAIN",
       "EBADF",
       "EBUSY",
       "ECHILD",
       "EDEADLK",
       "EDOM",
       "EEXIST",
       "EFAULT",
       "EFBIG",
       "EINTR",
       "EINVAL",
       "EIO",
       "EISDIR",
       "EMFILE",
       "EMLINK",
       "ENAMETOOLONG",
       "ENFILE",
       "ENODEV",
       "ENOENT",
       "ENOEXEC",
       "ENOLCK",
       "ENOMEM",
       "ENOSPC",
       "ENOSYS",
       "ENOTDIR",
       "ENOTEMPTY",
       "ENOTTY",
       "ENXIO",
       "EPERM",
       "EPIPE",
       "ERANGE",
       "EROFS",
       "ESPIPE",
       "ESRCH",
       "EXDEV",
       "EWOULDBLOCK",
       "EINPROGRESS",
       "EALREADY",
       "ENOTSOCK",
       "EDESTADDRREQ",
       "EMSGSIZE",
       "EPROTOTYPE",
       "ENOPROTOOPT",
       "EPROTONOSUPPORT",
       "ESOCKTNOSUPPORT",
       "EOPNOTSUPP",
       "EPFNOSUPPORT",
       "EAFNOSUPPORT",
       "EADDRINUSE",
       "EADDRNOTAVAIL",
       "ENETDOWN",
       "ENETUNREACH",
       "ENETRESET",
       "ECONNABORTED",
       "ECONNRESET",
       "ENOBUFS",
       "EISCONN",
       "ENOTCONN",
       "ESHUTDOWN",
       "ETOOMANYREFS",
       "ETIMEDOUT",
       "ECONNREFUSED",
       "EHOSTDOWN",
       "EHOSTUNREACH",
       "ELOOP",
       "EOVERFLOW"];
   function make_unix_err_args(code, syscall, path, errno){
    var variant = unix_error.indexOf(code);
    if(variant < 0){if(errno == null) errno = - 9999; variant = [0, errno];}
    var
     args =
       [variant,
        caml_string_of_jsstring(syscall || ""),
        caml_string_of_jsstring(path || "")];
    return args;
   }
   var caml_named_values = {};
   function caml_named_value(nm){return caml_named_values[nm];}
   function jsoo_sys_getenv(n){
    var process = globalThis.process;
    if(process && process.env && process.env[n] != undefined)
     return process.env[n];
    if(globalThis.jsoo_static_env && globalThis.jsoo_static_env[n])
     return globalThis.jsoo_static_env[n];
   }
   var caml_record_backtrace_flag = 0;
   (function(){
      var r = jsoo_sys_getenv("OCAMLRUNPARAM");
      if(r !== undefined){
       var l = r.split(",");
       for(var i = 0; i < l.length; i++)
        if(l[i] == "b"){
         caml_record_backtrace_flag = 1;
         break;
        }
        else if(l[i].startsWith("b="))
         caml_record_backtrace_flag = + l[i].slice(2);
        else
         continue;
      }
     }
     ());
   var caml_global_data = [0];
   function caml_exn_with_js_backtrace(exn, force){
    if(! exn.js_error || force || exn[0] == 248)
     exn.js_error = new globalThis.Error("Js exception containing backtrace");
    return exn;
   }
   function caml_maybe_attach_backtrace(exn, force){
    return caml_record_backtrace_flag
            ? caml_exn_with_js_backtrace(exn, force)
            : exn;
   }
   function caml_raise_with_args(tag, args){
    throw caml_maybe_attach_backtrace([0, tag].concat(args));
   }
   function caml_is_ml_bytes(s){return s instanceof MlBytes;}
   function caml_is_ml_string(s){
    return typeof s === "string" && ! /[^\x00-\xff]/.test(s);
   }
   function caml_bytes_of_array(a){
    if(! (a instanceof Uint8Array)) a = new Uint8Array(a);
    return new MlBytes(4, a, a.length);
   }
   function caml_bytes_of_jsbytes(s){return new MlBytes(0, s, s.length);}
   function caml_jsbytes_of_string(x){return x;}
   function caml_bytes_of_string(s){
    return caml_bytes_of_jsbytes(caml_jsbytes_of_string(s));
   }
   function caml_raise_with_arg(tag, arg){
    throw caml_maybe_attach_backtrace([0, tag, arg]);
   }
   function caml_raise_with_string(tag, msg){
    caml_raise_with_arg(tag, caml_string_of_jsbytes(msg));
   }
   function caml_raise_sys_error(msg){
    caml_raise_with_string(caml_global_data.Sys_error, msg);
   }
   function caml_raise_no_such_file(name){
    caml_raise_sys_error(name + ": No such file or directory");
   }
   function caml_convert_bytes_to_array(s){
    var a = new Uint8Array(s.l), b = s.c, l = b.length, i = 0;
    for(; i < l; i++) a[i] = b.charCodeAt(i);
    for(l = s.l; i < l; i++) a[i] = 0;
    s.c = a;
    s.t = 4;
    return a;
   }
   function caml_uint8_array_of_bytes(s){
    if(s.t != 4) caml_convert_bytes_to_array(s);
    return s.c;
   }
   function caml_invalid_argument(msg){
    caml_raise_with_string(caml_global_data.Invalid_argument, msg);
   }
   function caml_create_bytes(len){
    if(len < 0) caml_invalid_argument("Bytes.create");
    return new MlBytes(len ? 2 : 9, "", len);
   }
   function caml_ml_bytes_length(s){return s.l;}
   function caml_blit_bytes(s1, i1, s2, i2, len){
    if(len == 0) return 0;
    if(i2 == 0 && (len >= s2.l || s2.t == 2 && len >= s2.c.length)){
     s2.c =
      s1.t == 4
       ? caml_subarray_to_jsbytes(s1.c, i1, len)
       : i1 == 0 && s1.c.length == len ? s1.c : s1.c.substr(i1, len);
     s2.t = s2.c.length == s2.l ? 0 : 2;
    }
    else if(s2.t == 2 && i2 == s2.c.length){
     s2.c +=
      s1.t == 4
       ? caml_subarray_to_jsbytes(s1.c, i1, len)
       : i1 == 0 && s1.c.length == len ? s1.c : s1.c.substr(i1, len);
     s2.t = s2.c.length == s2.l ? 0 : 2;
    }
    else{
     if(s2.t != 4) caml_convert_bytes_to_array(s2);
     var c1 = s1.c, c2 = s2.c;
     if(s1.t == 4)
      if(i2 <= i1)
       for(var i = 0; i < len; i++) c2[i2 + i] = c1[i1 + i];
      else
       for(var i = len - 1; i >= 0; i--) c2[i2 + i] = c1[i1 + i];
     else{
      var l = Math.min(len, c1.length - i1);
      for(var i = 0; i < l; i++) c2[i2 + i] = c1.charCodeAt(i1 + i);
      for(; i < len; i++) c2[i2 + i] = 0;
     }
    }
    return 0;
   }
   function MlFile(){}
   function MlFakeFile(content){this.data = content;}
   MlFakeFile.prototype = new MlFile();
   MlFakeFile.prototype.constructor = MlFakeFile;
   MlFakeFile.prototype.truncate =
    function(len){
     var old = this.data;
     this.data = caml_create_bytes(len | 0);
     caml_blit_bytes(old, 0, this.data, 0, len);
    };
   MlFakeFile.prototype.length =
    function(){return caml_ml_bytes_length(this.data);};
   MlFakeFile.prototype.write =
    function(offset, buf, pos, len){
     var clen = this.length();
     if(offset + len >= clen){
      var new_str = caml_create_bytes(offset + len), old_data = this.data;
      this.data = new_str;
      caml_blit_bytes(old_data, 0, this.data, 0, clen);
     }
     caml_blit_bytes(caml_bytes_of_array(buf), pos, this.data, offset, len);
     return 0;
    };
   MlFakeFile.prototype.read =
    function(offset, buf, pos, len){
     var clen = this.length();
     if(offset + len >= clen) len = clen - offset;
     if(len){
      var data = caml_create_bytes(len | 0);
      caml_blit_bytes(this.data, offset, data, 0, len);
      buf.set(caml_uint8_array_of_bytes(data), pos);
     }
     return len;
    };
   function MlFakeFd(name, file, flags){
    this.file = file;
    this.name = name;
    this.flags = flags;
   }
   MlFakeFd.prototype.err_closed =
    function(){
     caml_raise_sys_error(this.name + ": file descriptor already closed");
    };
   MlFakeFd.prototype.length =
    function(){if(this.file) return this.file.length(); this.err_closed();};
   MlFakeFd.prototype.write =
    function(offset, buf, pos, len){
     if(this.file) return this.file.write(offset, buf, pos, len);
     this.err_closed();
    };
   MlFakeFd.prototype.read =
    function(offset, buf, pos, len){
     if(this.file) return this.file.read(offset, buf, pos, len);
     this.err_closed();
    };
   MlFakeFd.prototype.close = function(){this.file = undefined;};
   function MlFakeDevice(root, f){
    this.content = {};
    this.root = root;
    this.lookupFun = f;
   }
   MlFakeDevice.prototype.nm = function(name){return this.root + name;};
   MlFakeDevice.prototype.create_dir_if_needed =
    function(name){
     var comp = name.split("/"), res = "";
     for(var i = 0; i < comp.length - 1; i++){
      res += comp[i] + "/";
      if(this.content[res]) continue;
      this.content[res] = Symbol("directory");
     }
    };
   MlFakeDevice.prototype.slash =
    function(name){return /\/$/.test(name) ? name : name + "/";};
   MlFakeDevice.prototype.lookup =
    function(name){
     if(! this.content[name] && this.lookupFun){
      var
       res =
         this.lookupFun
          (caml_string_of_jsbytes(this.root), caml_string_of_jsbytes(name));
      if(res !== 0){
       this.create_dir_if_needed(name);
       this.content[name] = new MlFakeFile(caml_bytes_of_string(res[1]));
      }
     }
    };
   MlFakeDevice.prototype.exists =
    function(name){
     if(name == "") return 1;
     var name_slash = this.slash(name);
     if(this.content[name_slash]) return 1;
     this.lookup(name);
     return this.content[name] ? 1 : 0;
    };
   MlFakeDevice.prototype.isFile =
    function(name){return this.exists(name) && ! this.is_dir(name) ? 1 : 0;};
   MlFakeDevice.prototype.mkdir =
    function(name, mode, raise_unix){
     var unix_error = raise_unix && caml_named_value("Unix.Unix_error");
     if(this.exists(name))
      if(unix_error)
       caml_raise_with_args
        (unix_error, make_unix_err_args("EEXIST", "mkdir", this.nm(name)));
      else
       caml_raise_sys_error(name + ": File exists");
     var parent = /^(.*)\/[^/]+/.exec(name);
     parent = parent && parent[1] || "";
     if(! this.exists(parent))
      if(unix_error)
       caml_raise_with_args
        (unix_error, make_unix_err_args("ENOENT", "mkdir", this.nm(parent)));
      else
       caml_raise_sys_error(parent + ": No such file or directory");
     if(! this.is_dir(parent))
      if(unix_error)
       caml_raise_with_args
        (unix_error, make_unix_err_args("ENOTDIR", "mkdir", this.nm(parent)));
      else
       caml_raise_sys_error(parent + ": Not a directory");
     this.create_dir_if_needed(this.slash(name));
    };
   MlFakeDevice.prototype.rmdir =
    function(name, raise_unix){
     var
      unix_error = raise_unix && caml_named_value("Unix.Unix_error"),
      name_slash = name == "" ? "" : this.slash(name),
      r = new RegExp("^" + name_slash + "([^/]+)");
     if(! this.exists(name))
      if(unix_error)
       caml_raise_with_args
        (unix_error, make_unix_err_args("ENOENT", "rmdir", this.nm(name)));
      else
       caml_raise_sys_error(name + ": No such file or directory");
     if(! this.is_dir(name))
      if(unix_error)
       caml_raise_with_args
        (unix_error, make_unix_err_args("ENOTDIR", "rmdir", this.nm(name)));
      else
       caml_raise_sys_error(name + ": Not a directory");
     for(var n in this.content)
      if(n.match(r))
       if(unix_error)
        caml_raise_with_args
         (unix_error, make_unix_err_args("ENOTEMPTY", "rmdir", this.nm(name)));
       else
        caml_raise_sys_error(this.nm(name) + ": Directory not empty");
     delete this.content[name_slash];
    };
   MlFakeDevice.prototype.readdir =
    function(name){
     var name_slash = name == "" ? "" : this.slash(name);
     if(! this.exists(name))
      caml_raise_sys_error(name + ": No such file or directory");
     if(! this.is_dir(name)) caml_raise_sys_error(name + ": Not a directory");
     var r = new RegExp("^" + name_slash + "([^/]+)"), seen = {}, a = [];
     for(var n in this.content){
      var m = n.match(r);
      if(m && ! seen[m[1]]){seen[m[1]] = true; a.push(m[1]);}
     }
     return a;
    };
   MlFakeDevice.prototype.opendir =
    function(name, raise_unix){
     var
      unix_error = raise_unix && caml_named_value("Unix.Unix_error"),
      a = this.readdir(name),
      c = false,
      i = 0;
     return {readSync:
             function(){
              if(c)
               if(unix_error)
                caml_raise_with_args
                 (unix_error,
                  make_unix_err_args("EBADF", "closedir", this.nm(name)));
               else
                caml_raise_sys_error(name + ": closedir failed");
              if(i == a.length) return null;
              var entry = a[i];
              i++;
              return {name: entry};
             },
             closeSync:
             function(){
              if(c)
               if(unix_error)
                caml_raise_with_args
                 (unix_error,
                  make_unix_err_args("EBADF", "closedir", this.nm(name)));
               else
                caml_raise_sys_error(name + ": closedir failed");
              c = true;
              a = [];
             }};
    };
   MlFakeDevice.prototype.is_dir =
    function(name){
     if(name == "") return true;
     var name_slash = this.slash(name);
     return this.content[name_slash] ? 1 : 0;
    };
   MlFakeDevice.prototype.unlink =
    function(name){
     var ok = this.content[name] ? true : false;
     delete this.content[name];
     return ok;
    };
   MlFakeDevice.prototype.open =
    function(name, f){
     var file;
     if(f.rdonly && f.wronly)
      caml_raise_sys_error
       (this.nm(name)
        + " : flags Open_rdonly and Open_wronly are not compatible");
     if(f.text && f.binary)
      caml_raise_sys_error
       (this.nm(name)
        + " : flags Open_text and Open_binary are not compatible");
     this.lookup(name);
     if(this.content[name]){
      if(this.is_dir(name))
       caml_raise_sys_error(this.nm(name) + " : is a directory");
      if(f.create && f.excl)
       caml_raise_sys_error(this.nm(name) + " : file already exists");
      file = this.content[name];
      if(f.truncate) file.truncate();
     }
     else if(f.create){
      this.create_dir_if_needed(name);
      this.content[name] = new MlFakeFile(caml_create_bytes(0));
      file = this.content[name];
     }
     else
      caml_raise_no_such_file(this.nm(name));
     return new MlFakeFd(this.nm(name), file, f);
    };
   MlFakeDevice.prototype.open =
    function(name, f){
     var file;
     if(f.rdonly && f.wronly)
      caml_raise_sys_error
       (this.nm(name)
        + " : flags Open_rdonly and Open_wronly are not compatible");
     if(f.text && f.binary)
      caml_raise_sys_error
       (this.nm(name)
        + " : flags Open_text and Open_binary are not compatible");
     this.lookup(name);
     if(this.content[name]){
      if(this.is_dir(name))
       caml_raise_sys_error(this.nm(name) + " : is a directory");
      if(f.create && f.excl)
       caml_raise_sys_error(this.nm(name) + " : file already exists");
      file = this.content[name];
      if(f.truncate) file.truncate();
     }
     else if(f.create){
      this.create_dir_if_needed(name);
      this.content[name] = new MlFakeFile(caml_create_bytes(0));
      file = this.content[name];
     }
     else
      caml_raise_no_such_file(this.nm(name));
     return new MlFakeFd(this.nm(name), file, f);
    };
   MlFakeDevice.prototype.register =
    function(name, content){
     var file;
     if(this.content[name])
      caml_raise_sys_error(this.nm(name) + " : file already exists");
     if(caml_is_ml_bytes(content)) file = new MlFakeFile(content);
     if(caml_is_ml_string(content))
      file = new MlFakeFile(caml_bytes_of_string(content));
     else if(content instanceof Array)
      file = new MlFakeFile(caml_bytes_of_array(content));
     else if(typeof content === "string")
      file = new MlFakeFile(caml_bytes_of_jsbytes(content));
     else if(content.toString){
      var
       bytes =
         caml_bytes_of_string(caml_string_of_jsstring(content.toString()));
      file = new MlFakeFile(bytes);
     }
     if(file){
      this.create_dir_if_needed(name);
      this.content[name] = file;
     }
     else
      caml_raise_sys_error
       (this.nm(name) + " : registering file with invalid content type");
    };
   MlFakeDevice.prototype.constructor = MlFakeDevice;
   function MlFakeFd_out(fd, flags){
    MlFakeFile.call(this, caml_create_bytes(0));
    this.log = function(s){return 0;};
    if(fd == 1 && typeof console.log == "function")
     this.log = console.log;
    else if(fd == 2 && typeof console.error == "function")
     this.log = console.error;
    else if(typeof console.log == "function") this.log = console.log;
    this.flags = flags;
   }
   MlFakeFd_out.prototype.length = function(){return 0;};
   MlFakeFd_out.prototype.write =
    function(offset, buf, pos, len){
     if(this.log){
      if
       (len > 0 && pos >= 0 && pos + len <= buf.length
        && buf[pos + len - 1] == 10)
       len--;
      var src = caml_create_bytes(len);
      caml_blit_bytes(caml_bytes_of_array(buf), pos, src, 0, len);
      this.log(src.toUtf16());
      return 0;
     }
     caml_raise_sys_error(this.fd + ": file descriptor already closed");
    };
   MlFakeFd_out.prototype.read =
    function(offset, buf, pos, len){
     caml_raise_sys_error(this.fd + ": file descriptor is write only");
    };
   MlFakeFd_out.prototype.close = function(){this.log = undefined;};
   var caml_int64_offset = Math.pow(2, - 24);
   function caml_raise_constant(tag){throw tag;}
   function caml_raise_zero_divide(){
    caml_raise_constant(caml_global_data.Division_by_zero);
   }
   function MlInt64(lo, mi, hi){
    this.lo = lo & 0xffffff;
    this.mi = mi & 0xffffff;
    this.hi = hi & 0xffff;
   }
   MlInt64.prototype.caml_custom = "_j";
   MlInt64.prototype.copy =
    function(){return new MlInt64(this.lo, this.mi, this.hi);};
   MlInt64.prototype.ucompare =
    function(x){
     if(this.hi > x.hi) return 1;
     if(this.hi < x.hi) return - 1;
     if(this.mi > x.mi) return 1;
     if(this.mi < x.mi) return - 1;
     if(this.lo > x.lo) return 1;
     if(this.lo < x.lo) return - 1;
     return 0;
    };
   MlInt64.prototype.compare =
    function(x){
     var hi = this.hi << 16, xhi = x.hi << 16;
     if(hi > xhi) return 1;
     if(hi < xhi) return - 1;
     if(this.mi > x.mi) return 1;
     if(this.mi < x.mi) return - 1;
     if(this.lo > x.lo) return 1;
     if(this.lo < x.lo) return - 1;
     return 0;
    };
   MlInt64.prototype.neg =
    function(){
     var
      lo = - this.lo,
      mi = - this.mi + (lo >> 24),
      hi = - this.hi + (mi >> 24);
     return new MlInt64(lo, mi, hi);
    };
   MlInt64.prototype.add =
    function(x){
     var
      lo = this.lo + x.lo,
      mi = this.mi + x.mi + (lo >> 24),
      hi = this.hi + x.hi + (mi >> 24);
     return new MlInt64(lo, mi, hi);
    };
   MlInt64.prototype.sub =
    function(x){
     var
      lo = this.lo - x.lo,
      mi = this.mi - x.mi + (lo >> 24),
      hi = this.hi - x.hi + (mi >> 24);
     return new MlInt64(lo, mi, hi);
    };
   MlInt64.prototype.mul =
    function(x){
     var
      lo = this.lo * x.lo,
      mi = (lo * caml_int64_offset | 0) + this.mi * x.lo + this.lo * x.mi,
      hi =
        (mi * caml_int64_offset | 0) + this.hi * x.lo + this.mi * x.mi
        + this.lo * x.hi;
     return new MlInt64(lo, mi, hi);
    };
   MlInt64.prototype.isZero =
    function(){return (this.lo | this.mi | this.hi) == 0;};
   MlInt64.prototype.isNeg = function(){return this.hi << 16 < 0;};
   MlInt64.prototype.and =
    function(x){
     return new MlInt64(this.lo & x.lo, this.mi & x.mi, this.hi & x.hi);
    };
   MlInt64.prototype.or =
    function(x){
     return new MlInt64(this.lo | x.lo, this.mi | x.mi, this.hi | x.hi);
    };
   MlInt64.prototype.xor =
    function(x){
     return new MlInt64(this.lo ^ x.lo, this.mi ^ x.mi, this.hi ^ x.hi);
    };
   MlInt64.prototype.shift_left =
    function(s){
     s = s & 63;
     if(s == 0) return this;
     if(s < 24)
      return new
              MlInt64
              (this.lo << s,
               this.mi << s | this.lo >> 24 - s,
               this.hi << s | this.mi >> 24 - s);
     if(s < 48)
      return new
              MlInt64
              (0, this.lo << s - 24, this.mi << s - 24 | this.lo >> 48 - s);
     return new MlInt64(0, 0, this.lo << s - 48);
    };
   MlInt64.prototype.shift_right_unsigned =
    function(s){
     s = s & 63;
     if(s == 0) return this;
     if(s < 24)
      return new
              MlInt64
              (this.lo >> s | this.mi << 24 - s,
               this.mi >> s | this.hi << 24 - s,
               this.hi >> s);
     if(s < 48)
      return new
              MlInt64
              (this.mi >> s - 24 | this.hi << 48 - s, this.hi >> s - 24, 0);
     return new MlInt64(this.hi >> s - 48, 0, 0);
    };
   MlInt64.prototype.shift_right =
    function(s){
     s = s & 63;
     if(s == 0) return this;
     var h = this.hi << 16 >> 16;
     if(s < 24)
      return new
              MlInt64
              (this.lo >> s | this.mi << 24 - s,
               this.mi >> s | h << 24 - s,
               this.hi << 16 >> s >>> 16);
     var sign = this.hi << 16 >> 31;
     if(s < 48)
      return new
              MlInt64
              (this.mi >> s - 24 | this.hi << 48 - s,
               this.hi << 16 >> s - 24 >> 16,
               sign & 0xffff);
     return new MlInt64(this.hi << 16 >> s - 32, sign, sign);
    };
   MlInt64.prototype.lsl1 =
    function(){
     this.hi = this.hi << 1 | this.mi >> 23;
     this.mi = (this.mi << 1 | this.lo >> 23) & 0xffffff;
     this.lo = this.lo << 1 & 0xffffff;
    };
   MlInt64.prototype.lsr1 =
    function(){
     this.lo = (this.lo >>> 1 | this.mi << 23) & 0xffffff;
     this.mi = (this.mi >>> 1 | this.hi << 23) & 0xffffff;
     this.hi = this.hi >>> 1;
    };
   MlInt64.prototype.udivmod =
    function(x){
     var
      offset = 0,
      modulus = this.copy(),
      divisor = x.copy(),
      quotient = new MlInt64(0, 0, 0);
     while(modulus.ucompare(divisor) > 0){offset++; divisor.lsl1();}
     while(offset >= 0){
      offset--;
      quotient.lsl1();
      if(modulus.ucompare(divisor) >= 0){
       quotient.lo++;
       modulus = modulus.sub(divisor);
      }
      divisor.lsr1();
     }
     return {quotient: quotient, modulus: modulus};
    };
   MlInt64.prototype.div =
    function(y){
     var x = this;
     if(y.isZero()) caml_raise_zero_divide();
     var sign = x.hi ^ y.hi;
     if(x.hi & 0x8000) x = x.neg();
     if(y.hi & 0x8000) y = y.neg();
     var q = x.udivmod(y).quotient;
     if(sign & 0x8000) q = q.neg();
     return q;
    };
   MlInt64.prototype.mod =
    function(y){
     var x = this;
     if(y.isZero()) caml_raise_zero_divide();
     var sign = x.hi;
     if(x.hi & 0x8000) x = x.neg();
     if(y.hi & 0x8000) y = y.neg();
     var r = x.udivmod(y).modulus;
     if(sign & 0x8000) r = r.neg();
     return r;
    };
   MlInt64.prototype.toInt = function(){return this.lo | this.mi << 24;};
   MlInt64.prototype.toFloat =
    function(){
     return (this.hi << 16) * Math.pow(2, 32) + this.mi * Math.pow(2, 24)
            + this.lo;
    };
   MlInt64.prototype.toArray =
    function(){
     return [this.hi >> 8,
             this.hi & 0xff,
             this.mi >> 16,
             this.mi >> 8 & 0xff,
             this.mi & 0xff,
             this.lo >> 16,
             this.lo >> 8 & 0xff,
             this.lo & 0xff];
    };
   MlInt64.prototype.lo32 =
    function(){return this.lo | (this.mi & 0xff) << 24;};
   MlInt64.prototype.hi32 =
    function(){return this.mi >>> 8 & 0xffff | this.hi << 16;};
   function MlMutex(){this.locked = false;}
   function MlNat(x){
    this.data = new Int32Array(x);
    this.length = this.data.length + 2;
   }
   MlNat.prototype.caml_custom = "_nat";
   function caml_ml_string_length(s){return s.length;}
   function caml_string_unsafe_get(s, i){return s.charCodeAt(i);}
   function caml_uint8_array_of_string(s){
    var l = caml_ml_string_length(s), a = new Uint8Array(l), i = 0;
    for(; i < l; i++) a[i] = caml_string_unsafe_get(s, i);
    return a;
   }
   function caml_bytes_bound_error(){
    caml_invalid_argument("index out of bounds");
   }
   function caml_bytes_unsafe_set(s, i, c){
    c &= 0xff;
    if(s.t != 4){
     if(i == s.c.length){
      s.c += String.fromCharCode(c);
      if(i + 1 == s.l) s.t = 0;
      return 0;
     }
     caml_convert_bytes_to_array(s);
    }
    s.c[i] = c;
    return 0;
   }
   function caml_bytes_set(s, i, c){
    if(i >>> 0 >= s.l) caml_bytes_bound_error();
    return caml_bytes_unsafe_set(s, i, c);
   }
   function MlNodeFd(fd, flags){
    this.fs = require("fs");
    this.fd = fd;
    this.flags = flags;
   }
   MlNodeFd.prototype = new MlFile();
   MlNodeFd.prototype.constructor = MlNodeFd;
   MlNodeFd.prototype.truncate =
    function(len){
     try{this.fs.ftruncateSync(this.fd, len | 0);}
     catch(err){caml_raise_sys_error(err.toString());}
    };
   MlNodeFd.prototype.length =
    function(){
     try{return this.fs.fstatSync(this.fd).size;}
     catch(err){caml_raise_sys_error(err.toString());}
    };
   MlNodeFd.prototype.write =
    function(offset, buf, buf_offset, len){
     try{
      if(this.flags.isCharacterDevice)
       this.fs.writeSync(this.fd, buf, buf_offset, len);
      else
       this.fs.writeSync(this.fd, buf, buf_offset, len, offset);
     }
     catch(err){caml_raise_sys_error(err.toString());}
     return 0;
    };
   MlNodeFd.prototype.read =
    function(offset, a, buf_offset, len){
     try{
      if(this.flags.isCharacterDevice)
       var read = this.fs.readSync(this.fd, a, buf_offset, len);
      else
       var read = this.fs.readSync(this.fd, a, buf_offset, len, offset);
      return read;
     }
     catch(err){caml_raise_sys_error(err.toString());}
    };
   MlNodeFd.prototype.close =
    function(){
     try{this.fs.closeSync(this.fd); return 0;}
     catch(err){caml_raise_sys_error(err.toString());}
    };
   function MlNodeDevice(root){this.fs = require("fs"); this.root = root;}
   MlNodeDevice.prototype.nm = function(name){return this.root + name;};
   MlNodeDevice.prototype.exists =
    function(name){
     try{return this.fs.existsSync(this.nm(name)) ? 1 : 0;}
     catch(err){return 0;}
    };
   MlNodeDevice.prototype.isFile =
    function(name){
     try{return this.fs.statSync(this.nm(name)).isFile() ? 1 : 0;}
     catch(err){caml_raise_sys_error(err.toString());}
    };
   MlNodeDevice.prototype.mkdir =
    function(name, mode, raise_unix){
     try{this.fs.mkdirSync(this.nm(name), {mode: mode}); return 0;}
     catch(err){this.raise_nodejs_error(err, raise_unix);}
    };
   MlNodeDevice.prototype.rmdir =
    function(name, raise_unix){
     try{this.fs.rmdirSync(this.nm(name)); return 0;}
     catch(err){this.raise_nodejs_error(err, raise_unix);}
    };
   MlNodeDevice.prototype.readdir =
    function(name, raise_unix){
     try{return this.fs.readdirSync(this.nm(name));}
     catch(err){this.raise_nodejs_error(err, raise_unix);}
    };
   MlNodeDevice.prototype.is_dir =
    function(name){
     try{return this.fs.statSync(this.nm(name)).isDirectory() ? 1 : 0;}
     catch(err){caml_raise_sys_error(err.toString());}
    };
   MlNodeDevice.prototype.unlink =
    function(name, raise_unix){
     try{
      var b = this.fs.existsSync(this.nm(name)) ? 1 : 0;
      this.fs.unlinkSync(this.nm(name));
      return b;
     }
     catch(err){this.raise_nodejs_error(err, raise_unix);}
    };
   MlNodeDevice.prototype.open =
    function(name, f, raise_unix){
     var consts = require("constants"), res = 0;
     for(var key in f)
      switch(key){
        case "rdonly":
         res |= consts.O_RDONLY; break;
        case "wronly":
         res |= consts.O_WRONLY; break;
        case "append":
         res |= consts.O_WRONLY | consts.O_APPEND; break;
        case "create":
         res |= consts.O_CREAT; break;
        case "truncate":
         res |= consts.O_TRUNC; break;
        case "excl":
         res |= consts.O_EXCL; break;
        case "binary":
         res |= consts.O_BINARY; break;
        case "text":
         res |= consts.O_TEXT; break;
        case "nonblock":
         res |= consts.O_NONBLOCK; break;
      }
     try{
      var
       fd = this.fs.openSync(this.nm(name), res),
       isCharacterDevice =
         this.fs.lstatSync(this.nm(name)).isCharacterDevice();
      f.isCharacterDevice = isCharacterDevice;
      return new MlNodeFd(fd, f);
     }
     catch(err){this.raise_nodejs_error(err, raise_unix);}
    };
   MlNodeDevice.prototype.rename =
    function(o, n, raise_unix){
     try{this.fs.renameSync(this.nm(o), this.nm(n));}
     catch(err){this.raise_nodejs_error(err, raise_unix);}
    };
   MlNodeDevice.prototype.stat =
    function(name, raise_unix){
     try{
      var js_stats = this.fs.statSync(this.nm(name));
      return this.stats_from_js(js_stats);
     }
     catch(err){this.raise_nodejs_error(err, raise_unix);}
    };
   MlNodeDevice.prototype.lstat =
    function(name, raise_unix){
     try{
      var js_stats = this.fs.lstatSync(this.nm(name));
      return this.stats_from_js(js_stats);
     }
     catch(err){this.raise_nodejs_error(err, raise_unix);}
    };
   MlNodeDevice.prototype.symlink =
    function(to_dir, target, path, raise_unix){
     try{
      this.fs.symlinkSync
       (this.nm(target), this.nm(path), to_dir ? "dir" : "file");
      return 0;
     }
     catch(err){this.raise_nodejs_error(err, raise_unix);}
    };
   MlNodeDevice.prototype.readlink =
    function(name, raise_unix){
     try{
      var link = this.fs.readlinkSync(this.nm(name), "utf8");
      return caml_string_of_jsstring(link);
     }
     catch(err){this.raise_nodejs_error(err, raise_unix);}
    };
   MlNodeDevice.prototype.opendir =
    function(name, raise_unix){
     try{return this.fs.opendirSync(this.nm(name));}
     catch(err){this.raise_nodejs_error(err, raise_unix);}
    };
   MlNodeDevice.prototype.raise_nodejs_error =
    function(err, raise_unix){
     var unix_error = caml_named_value("Unix.Unix_error");
     if(raise_unix && unix_error){
      var
       args = make_unix_err_args(err.code, err.syscall, err.path, err.errno);
      caml_raise_with_args(unix_error, args);
     }
     else
      caml_raise_sys_error(err.toString());
    };
   MlNodeDevice.prototype.stats_from_js =
    function(js_stats){
     var file_kind;
     if(js_stats.isFile())
      file_kind = 0;
     else if(js_stats.isDirectory())
      file_kind = 1;
     else if(js_stats.isCharacterDevice())
      file_kind = 2;
     else if(js_stats.isBlockDevice())
      file_kind = 3;
     else if(js_stats.isSymbolicLink())
      file_kind = 4;
     else if(js_stats.isFIFO())
      file_kind = 5;
     else if(js_stats.isSocket()) file_kind = 6;
     return [0,
             js_stats.dev,
             js_stats.ino,
             file_kind,
             js_stats.mode,
             js_stats.nlink,
             js_stats.uid,
             js_stats.gid,
             js_stats.rdev,
             js_stats.size,
             js_stats.atimeMs,
             js_stats.mtimeMs,
             js_stats.ctimeMs];
    };
   MlNodeDevice.prototype.constructor = MlNodeDevice;
   var MlObjectTable;
   if(typeof globalThis.Map === "undefined")
    MlObjectTable =
     function(){
       function NaiveLookup(objs){this.objs = objs;}
       NaiveLookup.prototype.get =
        function(v){
         for(var i = 0; i < this.objs.length; i++)
          if(this.objs[i] === v) return i;
        };
       NaiveLookup.prototype.set = function(){};
       return function(){
        this.objs = [];
        this.lookup = new NaiveLookup(this.objs);};
      }
      ();
   else
    MlObjectTable =
     function(){this.objs = []; this.lookup = new globalThis.Map();};
   MlObjectTable.prototype.store =
    function(v){this.lookup.set(v, this.objs.length); this.objs.push(v);};
   MlObjectTable.prototype.recall =
    function(v){
     var i = this.lookup.get(v);
     return i === undefined ? undefined : this.objs.length - i;
    };
   function MlStringReader(s, i){
    this.s = caml_jsbytes_of_string(s);
    this.i = i;
   }
   MlStringReader.prototype =
    {read8u: function(){return this.s.charCodeAt(this.i++);},
     read8s: function(){return this.s.charCodeAt(this.i++) << 24 >> 24;},
     read16u:
     function(){
      var s = this.s, i = this.i;
      this.i = i + 2;
      return s.charCodeAt(i) << 8 | s.charCodeAt(i + 1);
     },
     read16s:
     function(){
      var s = this.s, i = this.i;
      this.i = i + 2;
      return s.charCodeAt(i) << 24 >> 16 | s.charCodeAt(i + 1);
     },
     read32u:
     function(){
      var s = this.s, i = this.i;
      this.i = i + 4;
      return (s.charCodeAt(i) << 24 | s.charCodeAt(i + 1) << 16
             | s.charCodeAt(i + 2) << 8
             | s.charCodeAt(i + 3))
             >>> 0;
     },
     read32s:
     function(){
      var s = this.s, i = this.i;
      this.i = i + 4;
      return s.charCodeAt(i) << 24 | s.charCodeAt(i + 1) << 16
             | s.charCodeAt(i + 2) << 8
             | s.charCodeAt(i + 3);
     },
     readstr:
     function(len){
      var i = this.i;
      this.i = i + len;
      return caml_string_of_jsbytes(this.s.substring(i, i + len));
     },
     readuint8array:
     function(len){
      var b = new Uint8Array(len), s = this.s, i = this.i;
      for(var j = 0; j < len; j++) b[j] = s.charCodeAt(i + j);
      this.i = i + len;
      return b;
     }};
   function caml_int64_create_lo_hi(lo, hi){
    return new
            MlInt64
            (lo & 0xffffff,
             lo >>> 24 & 0xff | (hi & 0xffff) << 8,
             hi >>> 16 & 0xffff);
   }
   function caml_int64_hi32(v){return v.hi32();}
   function caml_int64_lo32(v){return v.lo32();}
   function caml_array_bound_error(){
    caml_invalid_argument("index out of bounds");
   }
   var caml_ba_custom_name = "_bigarr02";
   function Ml_Bigarray(kind, layout, dims, buffer){
    this.kind = kind;
    this.layout = layout;
    this.dims = dims;
    this.data = buffer;
   }
   Ml_Bigarray.prototype.caml_custom = caml_ba_custom_name;
   Ml_Bigarray.prototype.offset =
    function(arg){
     var ofs = 0;
     if(typeof arg === "number") arg = [arg];
     if(! (arg instanceof Array))
      caml_invalid_argument("bigarray.js: invalid offset");
     if(this.dims.length != arg.length)
      caml_invalid_argument("Bigarray.get/set: bad number of dimensions");
     if(this.layout == 0)
      for(var i = 0; i < this.dims.length; i++){
       if(arg[i] < 0 || arg[i] >= this.dims[i]) caml_array_bound_error();
       ofs = ofs * this.dims[i] + arg[i];
      }
     else
      for(var i = this.dims.length - 1; i >= 0; i--){
       if(arg[i] < 1 || arg[i] > this.dims[i]) caml_array_bound_error();
       ofs = ofs * this.dims[i] + (arg[i] - 1);
      }
     return ofs;
    };
   Ml_Bigarray.prototype.get =
    function(ofs){
     switch(this.kind){
       case 7:
        var l = this.data[ofs * 2 + 0], h = this.data[ofs * 2 + 1];
        return caml_int64_create_lo_hi(l, h);
       case 10:
       case 11:
        var r = this.data[ofs * 2 + 0], i = this.data[ofs * 2 + 1];
        return [254, r, i];
       default: return this.data[ofs];
     }
    };
   Ml_Bigarray.prototype.set =
    function(ofs, v){
     switch(this.kind){
       case 7:
        this.data[ofs * 2 + 0] = caml_int64_lo32(v);
        this.data[ofs * 2 + 1] = caml_int64_hi32(v);
        break;
       case 10:
       case 11:
        this.data[ofs * 2 + 0] = v[1]; this.data[ofs * 2 + 1] = v[2]; break;
       default: this.data[ofs] = v; break;
     }
     return 0;
    };
   Ml_Bigarray.prototype.fill =
    function(v){
     switch(this.kind){
       case 7:
        var a = caml_int64_lo32(v), b = caml_int64_hi32(v);
        if(a == b)
         this.data.fill(a);
        else
         for(var i = 0; i < this.data.length; i++)
          this.data[i] = i % 2 == 0 ? a : b;
        break;
       case 10:
       case 11:
        var im = v[1], re = v[2];
        if(im == re)
         this.data.fill(im);
        else
         for(var i = 0; i < this.data.length; i++)
          this.data[i] = i % 2 == 0 ? im : re;
        break;
       default: this.data.fill(v); break;
     }
    };
   Ml_Bigarray.prototype.compare =
    function(b, total){
     if(this.layout != b.layout || this.kind != b.kind){
      var k1 = this.kind | this.layout << 8, k2 = b.kind | b.layout << 8;
      return k2 - k1;
     }
     if(this.dims.length != b.dims.length)
      return b.dims.length - this.dims.length;
     for(var i = 0; i < this.dims.length; i++)
      if(this.dims[i] != b.dims[i]) return this.dims[i] < b.dims[i] ? - 1 : 1;
     switch(this.kind){
       case 0:
       case 1:
       case 10:
       case 11:
        var x, y;
        for(var i = 0; i < this.data.length; i++){
         x = this.data[i];
         y = b.data[i];
         if(x < y) return - 1;
         if(x > y) return 1;
         if(x != y){
          if(! total) return NaN;
          if(x == x) return 1;
          if(y == y) return - 1;
         }
        }
        break;
       case 7:
        for(var i = 0; i < this.data.length; i += 2){
         if(this.data[i + 1] < b.data[i + 1]) return - 1;
         if(this.data[i + 1] > b.data[i + 1]) return 1;
         if(this.data[i] >>> 0 < b.data[i] >>> 0) return - 1;
         if(this.data[i] >>> 0 > b.data[i] >>> 0) return 1;
        }
        break;
       case 2:
       case 3:
       case 4:
       case 5:
       case 6:
       case 8:
       case 9:
       case 12:
        for(var i = 0; i < this.data.length; i++){
         if(this.data[i] < b.data[i]) return - 1;
         if(this.data[i] > b.data[i]) return 1;
        }
        break;
     }
     return 0;
    };
   function Ml_Bigarray_c_1_1(kind, layout, dims, buffer){
    this.kind = kind;
    this.layout = layout;
    this.dims = dims;
    this.data = buffer;
   }
   Ml_Bigarray_c_1_1.prototype = new Ml_Bigarray();
   Ml_Bigarray_c_1_1.prototype.offset =
    function(arg){
     if(typeof arg !== "number")
      if(arg instanceof Array && arg.length == 1)
       arg = arg[0];
      else
       caml_invalid_argument("Ml_Bigarray_c_1_1.offset");
     if(arg < 0 || arg >= this.dims[0]) caml_array_bound_error();
     return arg;
    };
   Ml_Bigarray_c_1_1.prototype.get = function(ofs){return this.data[ofs];};
   Ml_Bigarray_c_1_1.prototype.set =
    function(ofs, v){this.data[ofs] = v; return 0;};
   Ml_Bigarray_c_1_1.prototype.fill =
    function(v){this.data.fill(v); return 0;};
   function Optional_bool_val(mlOptBool, def){
    return typeof mlOptBool == "object" ? mlOptBool[1] !== 0 : def;
   }
   function Optional_val(mlOptVal, def){
    return typeof mlOptVal == "object" ? mlOptVal[1] : def;
   }
   var
    REPEAT_TAG = {NO_REPEAT: 0, REPEAT_X: 1, REPEAT_Y: 2, REPEAT_XY: 3},
    tag_to_repeat =
      new
       joo_global_object.Map
       ([[REPEAT_TAG.NO_REPEAT, "no-repeat"],
         [REPEAT_TAG.REPEAT_X, "repeat-x"],
         [REPEAT_TAG.REPEAT_Y, "repeat-y"],
         [REPEAT_TAG.REPEAT_XY, "repeat"]]);
   function Repeat_val(repeat){return tag_to_repeat.get(repeat);}
   var
    SLANT = {ROMAN: "normal", ITALIC: "italic", OBLIQUE: "oblique"},
    SLANT_TAG = {ROMAN: 0, ITALIC: 1, OBLIQUE: 2},
    tag_to_slant =
      new
       joo_global_object.Map
       ([[SLANT_TAG.ROMAN, SLANT.ROMAN],
         [SLANT_TAG.ITALIC, SLANT.ITALIC],
         [SLANT_TAG.OBLIQUE, SLANT.OBLIQUE]]);
   function Slant_val(slant){return tag_to_slant.get(slant);}
   function UInt8ArrayReader(s, i){this.s = s; this.i = i;}
   UInt8ArrayReader.prototype =
    {read8u: function(){return this.s[this.i++];},
     read8s: function(){return this.s[this.i++] << 24 >> 24;},
     read16u:
     function(){
      var s = this.s, i = this.i;
      this.i = i + 2;
      return s[i] << 8 | s[i + 1];
     },
     read16s:
     function(){
      var s = this.s, i = this.i;
      this.i = i + 2;
      return s[i] << 24 >> 16 | s[i + 1];
     },
     read32u:
     function(){
      var s = this.s, i = this.i;
      this.i = i + 4;
      return (s[i] << 24 | s[i + 1] << 16 | s[i + 2] << 8 | s[i + 3]) >>> 0;
     },
     read32s:
     function(){
      var s = this.s, i = this.i;
      this.i = i + 4;
      return s[i] << 24 | s[i + 1] << 16 | s[i + 2] << 8 | s[i + 3];
     },
     readstr:
     function(len){
      var i = this.i;
      this.i = i + len;
      return caml_string_of_array(this.s.subarray(i, i + len));
     },
     readuint8array:
     function(len){
      var i = this.i;
      this.i = i + len;
      return this.s.subarray(i, i + len);
     }};
   var
    button_to_tag =
      new
       joo_global_object.Map
       ([[BUTTON.NONE, BUTTON_TAG.NONE],
         [BUTTON.LEFT, BUTTON_TAG.LEFT],
         [BUTTON.MIDDLE, BUTTON_TAG.MIDDLE],
         [BUTTON.MIDDLE, BUTTON_TAG.RIGHT],
         [BUTTON.WHEEL_UP, BUTTON_TAG.WHEEL_UP],
         [BUTTON.WHEEL_DOWN, BUTTON_TAG.WHEEL_DOWN]]);
   function Val_button(button){return button_to_tag.get(button);}
   var
    button_state_to_tag =
      new
       joo_global_object.Map
       ([[BUTTON_STATE.UP, BUTTON_STATE_TAG.UP],
         [BUTTON_STATE.DOWN, BUTTON_STATE_TAG.DOWN]]);
   function Val_button_state(state){return button_state_to_tag.get(state);}
   var
    cap_type_to_tag =
      new
       joo_global_object.Map
       ([["butt", CAP_TYPE_TAG.BUTT],
         ["square", CAP_TYPE_TAG.SQUARE],
         ["round", CAP_TYPE_TAG.ROUND]]);
   function Val_cap_type(cap){return cap_type_to_tag.get(cap);}
   var
    compop_to_tag =
      new
       joo_global_object.Map
       ([["source-over", COMPOP_TAG.SOURCE_OVER],
         ["source-in", COMPOP_TAG.SOURCE_IN],
         ["source-out", COMPOP_TAG.SOURCE_OUT],
         ["source-atop", COMPOP_TAG.SOURCE_ATOP],
         ["destination-over", COMPOP_TAG.DESTINATION_OVER],
         ["destination-in", COMPOP_TAG.DESTINATION_IN],
         ["destination-out", COMPOP_TAG.DESTINATION_OUT],
         ["destination-atop", COMPOP_TAG.DESTINATION_ATOP],
         ["lighter", COMPOP_TAG.LIGHTER],
         ["copy", COMPOP_TAG.COPY],
         ["xor", COMPOP_TAG.XOR],
         ["multiply", COMPOP_TAG.MULTIPLY],
         ["screen", COMPOP_TAG.SCREEN],
         ["overlay", COMPOP_TAG.OVERLAY],
         ["darken", COMPOP_TAG.DARKEN],
         ["lighten", COMPOP_TAG.LIGHTEN],
         ["color-dodge", COMPOP_TAG.COLOR_DODGE],
         ["color-burn", COMPOP_TAG.COLOR_BURN],
         ["hard-light", COMPOP_TAG.HARD_LIGHT],
         ["soft-light", COMPOP_TAG.SOFT_LIGHT],
         ["difference", COMPOP_TAG.DIFFERENCE],
         ["exclusion", COMPOP_TAG.EXCLUSION],
         ["hue", COMPOP_TAG.HUE],
         ["saturation", COMPOP_TAG.SATURATION],
         ["color", COMPOP_TAG.COLOR],
         ["luminosity", COMPOP_TAG.LUMINOSITY]]);
   function Val_compop(compop){return compop_to_tag.get(compop);}
   function _color_of_int(i){
    var a = (i & 0xFF000000) >>> 24;
    if(a == 255) return "#" + (i & 0x00FFFFFF).toString(16).padStart(6, "0");
    var
     b = i & 0x000000FF,
     g = (i & 0x0000FF00) >>> 8,
     r = (i & 0x00FF0000) >>> 16;
    return "rgba(" + r + "," + g + "," + b + "," + a / 255.0 + ")";
   }
   function Val_draw_style(style){
    var s = 0;
    switch(style[0]){
      case STYLE_TAG.COLOR:
       s = _color_of_int(style[1]); break;
      case STYLE_TAG.GRADIENT:
      case STYLE_TAG.PATTERN: s = style[1]; break;
      default: break;
    }
    return s;
   }
   var
    focus_to_tag =
      new
       joo_global_object.Map
       ([[FOCUS.OUT, FOCUS_TAG.OUT], [FOCUS.IN, FOCUS_TAG.IN]]);
   function Val_focus_in_out(focus){return focus_to_tag.get(focus);}
   var
    join_type_to_tag =
      new
       joo_global_object.Map
       ([["round", JOIN_TYPE_TAG.ROUND],
         ["miter", JOIN_TYPE_TAG.MITER],
         ["bevel", JOIN_TYPE_TAG.BEVEL]]);
   function Val_join_type(join){return join_type_to_tag.get(join);}
   var
    kc_to_tag =
      new
       joo_global_object.Map
       ([[KEY.ESCAPE, KEY_TAG.ESCAPE],
         [KEY.F1, KEY_TAG.F1],
         [KEY.F2, KEY_TAG.F2],
         [KEY.F3, KEY_TAG.F3],
         [KEY.F4, KEY_TAG.F4],
         [KEY.F5, KEY_TAG.F5],
         [KEY.F6, KEY_TAG.F6],
         [KEY.F7, KEY_TAG.F7],
         [KEY.F8, KEY_TAG.F8],
         [KEY.F9, KEY_TAG.F9],
         [KEY.F10, KEY_TAG.F10],
         [KEY.F11, KEY_TAG.F11],
         [KEY.F12, KEY_TAG.F12],
         [KEY.PRINTSCREEN, KEY_TAG.PRINTSCREEN],
         [KEY.SCROLLLOCK, KEY_TAG.SCROLLLOCK],
         [KEY.PAUSE, KEY_TAG.PAUSE],
         [KEY.GRAVE_TILDE, KEY_TAG.GRAVE_TILDE],
         [KEY._1_EXCLAMATION, KEY_TAG._1_EXCLAMATION],
         [KEY._2_AT, KEY_TAG._2_AT],
         [KEY._3_NUMBER, KEY_TAG._3_NUMBER],
         [KEY._4_DOLLAR, KEY_TAG._4_DOLLAR],
         [KEY._5_PERCENT, KEY_TAG._5_PERCENT],
         [KEY._6_CARET, KEY_TAG._6_CARET],
         [KEY._7_AMPERSAND, KEY_TAG._7_AMPERSAND],
         [KEY._8_ASTERISK, KEY_TAG._8_ASTERISK],
         [KEY._9_LPARENTHESIS, KEY_TAG._9_LPARENTHESIS],
         [KEY._0_RPARENTHESIS, KEY_TAG._0_RPARENTHESIS],
         [KEY.MINUS_UNDERSCORE, KEY_TAG.MINUS_UNDERSCORE],
         [KEY.EQUAL_PLUS, KEY_TAG.EQUAL_PLUS],
         [KEY.BACKSPACE, KEY_TAG.BACKSPACE],
         [KEY.TAB, KEY_TAG.TAB],
         [KEY.Q, KEY_TAG.Q],
         [KEY.W, KEY_TAG.W],
         [KEY.E, KEY_TAG.E],
         [KEY.R, KEY_TAG.R],
         [KEY.T, KEY_TAG.T],
         [KEY.Y, KEY_TAG.Y],
         [KEY.U, KEY_TAG.U],
         [KEY.I, KEY_TAG.I],
         [KEY.O, KEY_TAG.O],
         [KEY.P, KEY_TAG.P],
         [KEY.LBRACKET_CURLY, KEY_TAG.LBRACKET_CURLY],
         [KEY.RBRACKET_CURLY, KEY_TAG.RBRACKET_CURLY],
         [KEY.BACKSLASH_PIPE, KEY_TAG.BACKSLASH_PIPE],
         [KEY.CAPSLOCK, KEY_TAG.CAPSLOCK],
         [KEY.A, KEY_TAG.A],
         [KEY.S, KEY_TAG.S],
         [KEY.D, KEY_TAG.D],
         [KEY.F, KEY_TAG.F],
         [KEY.G, KEY_TAG.G],
         [KEY.H, KEY_TAG.H],
         [KEY.J, KEY_TAG.J],
         [KEY.K, KEY_TAG.K],
         [KEY.L, KEY_TAG.L],
         [KEY.SEMICOLON_COLON, KEY_TAG.SEMICOLON_COLON],
         [KEY.QUOTE_DOUBLEQUOTE, KEY_TAG.QUOTE_DOUBLEQUOTE],
         [KEY.NONUS_NUMBER_TILDE, KEY_TAG.NONUS_NUMBER_TILDE],
         [KEY.RETURN, KEY_TAG.RETURN],
         [KEY.LSHIFT, KEY_TAG.LSHIFT],
         [KEY.NONUS_BACKSLASH_PIPE, KEY_TAG.NONUS_BACKSLASH_PIPE],
         [KEY.Z, KEY_TAG.Z],
         [KEY.X, KEY_TAG.X],
         [KEY.C, KEY_TAG.C],
         [KEY.V, KEY_TAG.V],
         [KEY.B, KEY_TAG.B],
         [KEY.N, KEY_TAG.N],
         [KEY.M, KEY_TAG.M],
         [KEY.COMMA_LESS, KEY_TAG.COMMA_LESS],
         [KEY.PERIOD_GREATER, KEY_TAG.PERIOD_GREATER],
         [KEY.SLASH_QUESTION, KEY_TAG.SLASH_QUESTION],
         [KEY.RSHIFT, KEY_TAG.RSHIFT],
         [KEY.LCONTROL, KEY_TAG.LCONTROL],
         [KEY.LMETA, KEY_TAG.LMETA],
         [KEY.LALT, KEY_TAG.LALT],
         [KEY.SPACEBAR, KEY_TAG.SPACEBAR],
         [KEY.RALT, KEY_TAG.RALT],
         [KEY.RMETA, KEY_TAG.RMETA],
         [KEY.MENU, KEY_TAG.MENU],
         [KEY.RCONTROL, KEY_TAG.RCONTROL],
         [KEY.INSERT, KEY_TAG.INSERT],
         [KEY.HOME, KEY_TAG.HOME],
         [KEY.PAGEUP, KEY_TAG.PAGEUP],
         [KEY.DELETEFORWARD, KEY_TAG.DELETEFORWARD],
         [KEY.END, KEY_TAG.END],
         [KEY.PAGEDOWN, KEY_TAG.PAGEDOWN],
         [KEY.UPARROW, KEY_TAG.UPARROW],
         [KEY.LEFTARROW, KEY_TAG.LEFTARROW],
         [KEY.DOWNARROW, KEY_TAG.DOWNARROW],
         [KEY.RIGHTARROW, KEY_TAG.RIGHTARROW],
         [KEY.PAD_NUMLOCK_CLEAR, KEY_TAG.PAD_NUMLOCK_CLEAR],
         [KEY.PAD_EQUALS, KEY_TAG.PAD_EQUALS],
         [KEY.PAD_DIVIDE, KEY_TAG.PAD_DIVIDE],
         [KEY.PAD_MULTIPLY, KEY_TAG.PAD_MULTIPLY],
         [KEY.PAD_MINUS, KEY_TAG.PAD_MINUS],
         [KEY.PAD_7_HOME, KEY_TAG.PAD_7_HOME],
         [KEY.PAD_8_UPARROW, KEY_TAG.PAD_8_UPARROW],
         [KEY.PAD_9_PAGEUP, KEY_TAG.PAD_9_PAGEUP],
         [KEY.PAD_PLUS, KEY_TAG.PAD_PLUS],
         [KEY.PAD_4_LEFTARROW, KEY_TAG.PAD_4_LEFTARROW],
         [KEY.PAD_5, KEY_TAG.PAD_5],
         [KEY.PAD_6_RIGHTARROW, KEY_TAG.PAD_6_RIGHTARROW],
         [KEY.PAD_COMMA, KEY_TAG.PAD_COMMA],
         [KEY.PAD_1_END, KEY_TAG.PAD_1_END],
         [KEY.PAD_2_DOWNARROW, KEY_TAG.PAD_2_DOWNARROW],
         [KEY.PAD_3_PAGEDOWN, KEY_TAG.PAD_3_PAGEDOWN],
         [KEY.PAD_0_INSERT, KEY_TAG.PAD_0_INSERT],
         [KEY.PAD_DECIMAL_DELETE, KEY_TAG.PAD_DECIMAL_DELETE],
         [KEY.PAD_ENTER, KEY_TAG.PAD_ENTER],
         [KEY.F13, KEY_TAG.F13],
         [KEY.F14, KEY_TAG.F14],
         [KEY.F15, KEY_TAG.F15],
         [KEY.F16, KEY_TAG.F16],
         [KEY.F17, KEY_TAG.F17],
         [KEY.F18, KEY_TAG.F18],
         [KEY.F19, KEY_TAG.F19],
         [KEY.F20, KEY_TAG.F20],
         [KEY.F21, KEY_TAG.F21],
         [KEY.F22, KEY_TAG.F22],
         [KEY.F23, KEY_TAG.F23],
         [KEY.F24, KEY_TAG.F24],
         [KEY.INTERNATIONAL1, KEY_TAG.INTERNATIONAL1],
         [KEY.INTERNATIONAL2, KEY_TAG.INTERNATIONAL2],
         [KEY.INTERNATIONAL3, KEY_TAG.INTERNATIONAL3],
         [KEY.INTERNATIONAL4, KEY_TAG.INTERNATIONAL4],
         [KEY.INTERNATIONAL5, KEY_TAG.INTERNATIONAL5],
         [KEY.INTERNATIONAL6, KEY_TAG.INTERNATIONAL6],
         [KEY.INTERNATIONAL7, KEY_TAG.INTERNATIONAL7],
         [KEY.INTERNATIONAL8, KEY_TAG.INTERNATIONAL8],
         [KEY.INTERNATIONAL9, KEY_TAG.INTERNATIONAL9],
         [KEY.LANG1, KEY_TAG.LANG1],
         [KEY.LANG2, KEY_TAG.LANG2],
         [KEY.LANG3, KEY_TAG.LANG3],
         [KEY.LANG4, KEY_TAG.LANG4],
         [KEY.LANG5, KEY_TAG.LANG5],
         [KEY.HELP, KEY_TAG.HELP],
         [KEY.MUTE, KEY_TAG.MUTE],
         [KEY.VOLUMEUP, KEY_TAG.VOLUMEUP],
         [KEY.VOLUMEDOWN, KEY_TAG.VOLUMEDOWN]]);
   function Val_key_code(keycode){return kc_to_tag.get(keycode);}
   var
    key_state_to_tag =
      new
       joo_global_object.Map
       ([[KEY_STATE.UP, KEY_STATE_TAG.UP],
         [KEY_STATE.DOWN, KEY_STATE_TAG.DOWN]]);
   function Val_key_state(state){return key_state_to_tag.get(state);}
   var
    repeat_to_tag =
      new
       joo_global_object.Map
       ([["no-repeat", REPEAT_TAG.NO_REPEAT],
         ["repeat-x", REPEAT_TAG.REPEAT_X],
         ["repeat-y", REPEAT_TAG.REPEAT_Y],
         ["repeat", REPEAT_TAG.REPEAT_XY]]);
   function Val_repeat(repeat){return repeat_to_tag.get(repeat);}
   function _event_canvas_scale(e){
    return {scaleX: e.target.canvas.width / e.target.clientWidth,
            scaleY: e.target.canvas.height / e.target.clientHeight};
   }
   var _focus = null;
   function caml_int64_of_float(x){
    if(x < 0) x = Math.ceil(x);
    return new
            MlInt64
            (x & 0xffffff,
             Math.floor(x * caml_int64_offset) & 0xffffff,
             Math.floor(x * caml_int64_offset * caml_int64_offset) & 0xffff);
   }
   var
    _ml_canvas_mlProcessEvent = null,
    _ml_canvas_mlException = null,
    _ml_canvas_initialized = false;
   function _ml_canvas_ensure_initialized(){
    if(_ml_canvas_initialized == false)
     caml_raise_constant(caml_named_value("Not_initialized"));
   }
   var _ml_canvas_mlContinuation = null;
   function ml_canvas_stop(){
    _ml_canvas_ensure_initialized();
    _ml_canvas_mlProcessEvent = null;
    if(_ml_canvas_mlException !== null){
     var exn = _ml_canvas_mlException;
     _ml_canvas_mlContinuation = null;
     _ml_canvas_mlException = null;
     throw exn;
    }
    else if(_ml_canvas_mlContinuation !== null)
     try{_ml_canvas_mlContinuation(); _ml_canvas_mlContinuation = null;}
     catch(exn){_ml_canvas_mlContinuation = null; throw exn;}
    return 0;
   }
   function _ml_canvas_process_event(mlEvent){
    if(_ml_canvas_mlProcessEvent === null) return false;
    try{_ml_canvas_mlProcessEvent(mlEvent); return true;}
    catch(exn){_ml_canvas_mlException = exn; ml_canvas_stop(); return false;}
   }
   function _frame_handler(timestamp){
    var surfaces = document.getElementsByTagName("canvas");
    for(var i = 0; i < surfaces.length; ++i){
     var
      evt =
        [EVENT_TAG.FRAME,
         [0, surfaces[i].canvas, caml_int64_of_float(timestamp * 1000.0)]];
     _ml_canvas_process_event(evt);
    }
    window.requestAnimationFrame(_frame_handler);
   }
   var _move = {moving: false, target: null, prev_x: 0, prev_y: 0};
   function ml_canvas_hide(canvas){
    if(canvas.frame !== null){
     if(_focus === canvas) _focus = null;
     canvas.frame.style.visibility = "hidden";
    }
    return 0;
   }
   function ml_canvas_close(canvas){
    if(canvas.frame !== null){
     ml_canvas_hide(canvas);
     canvas.name = null;
     if(canvas.surface != null){
      canvas.surface.canvas = null;
      if(canvas.surface.parentNode !== null)
       canvas.surface.parentNode.removeChild(canvas.surface);
     }
     if(canvas.header != null){
      canvas.header.canvas = null;
      if(canvas.header.parentNode !== null)
       canvas.header.parentNode.removeChild(canvas.header);
      canvas.header = null;
     }
     if(canvas.frame !== null){
      canvas.frame.canvas = null;
      if(canvas.frame.parentNode !== null)
       canvas.frame.parentNode.removeChild(canvas.frame);
      canvas.frame = null;
     }
    }
    return 0;
   }
   function _header_down_handler(e){
    if(e.target !== null){
     _focus = e.target.canvas;
     if
      (e.offsetX >= e.target.canvas.width - 20
       && e.offsetX <= e.target.canvas.width - 10
       && e.offsetY >= 10
       && e.offsetY <= 20){
      var
       evt =
         [EVENT_TAG.CANVAS_CLOSED,
          [0, e.target.canvas, caml_int64_of_float(e.timeStamp * 1000.0)]];
      _ml_canvas_process_event(evt);
      ml_canvas_close(e.target.canvas);
      _focus = null;
      return false;
     }
     _move.moving = true;
     _move.target = e.target.canvas.frame;
     _move.prev_x = e.pageX;
     _move.prev_y = e.pageY;
     e.target.canvas.target.insertBefore(_move.target, null);
    }
    return false;
   }
   function _int_of_color(c){
    if(c[0] == "#")
     return parseInt(c.substr(1, c.length - 1), 16);
    else{
     var
      rgba = c.replace(/^rgba?\(|\s+|\)$/g, "").split(","),
      r = parseInt(rgba[0]),
      g = parseInt(rgba[1]),
      b = parseInt(rgba[2]),
      a = parseFloat(rgba[3]) * 255;
     return b | g << 8 | r << 16 | a << 24;
    }
   }
   var
    _internal_canvas = document.createElement("canvas"),
    _internal_ctxt = _internal_canvas.getContext("2d"),
    kn_to_kc =
      new
       joo_global_object.Map
       ([["", KEY.UNDEFINED],
         ["Unidentified", KEY.UNDEFINED],
         ["Escape", KEY.ESCAPE],
         ["F1", KEY.F1],
         ["F2", KEY.F2],
         ["F3", KEY.F3],
         ["F4", KEY.F4],
         ["F5", KEY.F5],
         ["F6", KEY.F6],
         ["F7", KEY.F7],
         ["F8", KEY.F8],
         ["F9", KEY.F9],
         ["F10", KEY.F10],
         ["F11", KEY.F11],
         ["F12", KEY.F12],
         ["PrintScreen", KEY.PRINTSCREEN],
         ["ScrollLock", KEY.SCROLLLOCK],
         ["Pause", KEY.PAUSE],
         ["Backquote", KEY.GRAVE_TILDE],
         ["Digit1", KEY._1_EXCLAMATION],
         ["Digit2", KEY._2_AT],
         ["Digit3", KEY._3_NUMBER],
         ["Digit4", KEY._4_DOLLAR],
         ["Digit5", KEY._5_PERCENT],
         ["Digit6", KEY._6_CARET],
         ["Digit7", KEY._7_AMPERSAND],
         ["Digit8", KEY._8_ASTERISK],
         ["Digit9", KEY._9_LPARENTHESIS],
         ["Digit0", KEY._0_RPARENTHESIS],
         ["Minus", KEY.MINUS_UNDERSCORE],
         ["Equal", KEY.EQUAL_PLUS],
         ["IntlYen", KEY.INTERNATIONAL3],
         ["Backspace", KEY.BACKSPACE],
         ["Tab", KEY.TAB],
         ["KeyQ", KEY.Q],
         ["KeyW", KEY.W],
         ["KeyE", KEY.E],
         ["KeyR", KEY.R],
         ["KeyT", KEY.T],
         ["KeyY", KEY.Y],
         ["KeyU", KEY.U],
         ["KeyI", KEY.I],
         ["KeyO", KEY.O],
         ["KeyP", KEY.P],
         ["BracketLeft", KEY.LBRACKET_CURLY],
         ["BracketRight", KEY.RBRACKET_CURLY],
         ["Backslash", KEY.BACKSLASH_PIPE],
         ["CapsLock", KEY.CAPSLOCK],
         ["KeyA", KEY.A],
         ["KeyS", KEY.S],
         ["KeyD", KEY.D],
         ["KeyF", KEY.F],
         ["KeyG", KEY.G],
         ["KeyH", KEY.H],
         ["KeyJ", KEY.J],
         ["KeyK", KEY.K],
         ["KeyL", KEY.L],
         ["Semicolon", KEY.SEMICOLON_COLON],
         ["Quote", KEY.QUOTE_DOUBLEQUOTE],
         ["Enter", KEY.RETURN],
         ["ShiftLeft", KEY.LSHIFT],
         ["IntlBackslash", KEY.NONUS_BACKSLASH_PIPE],
         ["KeyZ", KEY.Z],
         ["KeyX", KEY.X],
         ["KeyC", KEY.C],
         ["KeyV", KEY.V],
         ["KeyB", KEY.B],
         ["KeyN", KEY.N],
         ["KeyM", KEY.M],
         ["Comma", KEY.COMMA_LESS],
         ["Period", KEY.PERIOD_GREATER],
         ["Slash", KEY.SLASH_QUESTION],
         ["IntlRo", KEY.INTERNATIONAL1],
         ["ShiftRight", KEY.RSHIFT],
         ["ControlLeft", KEY.LCONTROL],
         ["MetaLeft", KEY.LMETA],
         ["AltLeft", KEY.LALT],
         ["NonConvert", KEY.INTERNATIONAL5],
         ["Lang2", KEY.LANG2],
         ["Space", KEY.SPACEBAR],
         ["Lang1", KEY.LANG1],
         ["Convert", KEY.INTERNATIONAL4],
         ["KanaMode", KEY.INTERNATIONAL2],
         ["AltRight", KEY.RALT],
         ["MetaRight", KEY.RMETA],
         ["ContextMenu", KEY.MENU],
         ["ControlRight", KEY.RCONTROL],
         ["Help", KEY.HELP],
         ["Insert", KEY.INSERT],
         ["Home", KEY.HOME],
         ["PageUp", KEY.PAGEUP],
         ["Delete", KEY.DELETEFORWARD],
         ["End", KEY.END],
         ["PageDown", KEY.PAGEDOWN],
         ["ArrowUp", KEY.UPARROW],
         ["ArrowLeft", KEY.LEFTARROW],
         ["ArrowDown", KEY.DOWNARROW],
         ["ArrowRight", KEY.RIGHTARROW],
         ["NumpadLock", KEY.PAD_NUMLOCK_CLEAR],
         ["NumpadEqual", KEY.PAD_EQUALS],
         ["NumpadDivide", KEY.PAD_DIVIDE],
         ["NumpadMultiply", KEY.PAD_MULTIPLY],
         ["NumpadSubtract", KEY.PAD_MINUS],
         ["Numpad7", KEY.PAD_7_HOME],
         ["Numpad8", KEY.PAD_8_UPARROW],
         ["Numpad9", KEY.PAD_9_PAGEUP],
         ["NumpadAdd", KEY.PAD_PLUS],
         ["Numpad4", KEY.PAD_4_LEFTARROW],
         ["Numpad5", KEY.PAD_5],
         ["Numpad6", KEY.PAD_6_RIGHTARROW],
         ["NumpadComma", KEY.PAD_COMMA],
         ["Numpad1", KEY.PAD_1_END],
         ["Numpad2", KEY.PAD_2_DOWNARROW],
         ["Numpad3", KEY.PAD_3_PAGEDOWN],
         ["Numpad0", KEY.PAD_0_INSERT],
         ["NumpadDecimal", KEY.PAD_DECIMAL_DELETE],
         ["NumpadEnter", KEY.PAD_ENTER],
         ["F13", KEY.F13],
         ["F14", KEY.F14],
         ["F15", KEY.F15],
         ["F16", KEY.F16],
         ["F17", KEY.F17],
         ["F18", KEY.F18],
         ["F19", KEY.F19],
         ["F20", KEY.F20],
         ["F21", KEY.F21],
         ["F22", KEY.F22],
         ["F23", KEY.F23],
         ["F24", KEY.F24],
         ["Lang3", KEY.LANG3],
         ["Lang4", KEY.LANG4],
         ["Lang5", KEY.LANG5],
         ["Katakana", KEY.LANG3],
         ["Hiragana", KEY.LANG4],
         ["AudioVolumeDown", KEY.VOLUMEDOWN],
         ["AudioVolumeUp", KEY.VOLUMEUP],
         ["AudioVolumeMute", KEY.MUTE]]);
   function keyname_to_keycode(keyname){return kn_to_kc.get(keyname);}
   function _make_key_event(e, state){
    var
     char = e.key.length === 1 ? e.key.charCodeAt(0) : 0,
     flags =
       [0,
        e.shiftKey,
        e.altKey,
        e.ctrlKey,
        e.metaKey,
        e.getModifierState("CapsLock"),
        e.getModifierState("NumLock"),
        e.key === "Dead"],
     evt =
       [EVENT_TAG.KEY_ACTION,
        [0,
         _focus,
         caml_int64_of_float(e.timeStamp * 1000.0),
         Val_key_code(keyname_to_keycode(e.code)),
         char,
         flags,
         Val_key_state(state)]];
    return evt;
   }
   function _key_down_handler(e){
    if(_focus !== null){
     var evt = _make_key_event(e, KEY_STATE.DOWN);
     _ml_canvas_process_event(evt);
    }
    return false;
   }
   function _key_up_handler(e){
    if(_focus !== null){
     var evt = _make_key_event(e, KEY_STATE.UP);
     _ml_canvas_process_event(evt);
    }
    return false;
   }
   function _ml_canvas_adjust_blit_info
   (dwidth, dheight, dx, dy, swidth, sheight, sx, sy, width, height){
    if(dx < 0){sx -= dx; width += dx; dx = 0;}
    if(dy < 0){sy -= dy; height += dy; dy = 0;}
    if(sx < 0){dx -= sx; width += sx; sx = 0;}
    if(sy < 0){dy -= sy; height += sy; sy = 0;}
    if(dx + width > dwidth) width = dwidth - dx;
    if(dy + height > dheight) height = dheight - dy;
    if(sx + width > swidth) width = swidth - sx;
    if(sy + height > sheight) height = sheight - sy;
    return [dx, dy, sx, sy, width, height];
   }
   function caml_ba_get_size(dims){
    var n_dims = dims.length, size = 1;
    for(var i = 0; i < n_dims; i++){
     if(dims[i] < 0)
      caml_invalid_argument("Bigarray.create: negative dimension");
     size = size * dims[i];
    }
    return size;
   }
   function caml_ba_get_size_per_element(kind){
    switch(kind){case 7:case 10:case 11: return 2;default: return 1;
    }
   }
   function caml_ba_create_unsafe(kind, layout, dims, data){
    var size_per_element = caml_ba_get_size_per_element(kind);
    if(caml_ba_get_size(dims) * size_per_element != data.length)
     caml_invalid_argument("length doesn't match dims");
    if(layout == 0 && dims.length == 1 && size_per_element == 1)
     return new Ml_Bigarray_c_1_1(kind, layout, dims, data);
    return new Ml_Bigarray(kind, layout, dims, data);
   }
   function _ml_canvas_ba_of_img(img){
    var surface = document.createElement("canvas");
    surface.width = img.width;
    surface.height = img.height;
    var ctxt = surface.getContext("2d");
    ctxt.drawImage(img, 0, 0);
    var
     image = ctxt.getImageData(0, 0, img.width, img.height),
     sta = new window.Uint8Array(image.data.buffer),
     dta = new window.Uint8Array(sta.length);
    for(var i = 0; i < sta.length; i += 4){
     dta[i + 0] = sta[i + 2];
     dta[i + 1] = sta[i + 1];
     dta[i + 2] = sta[i + 0];
     dta[i + 3] = sta[i + 3];
    }
    return caml_ba_create_unsafe(3, 0, [img.height, img.width, 4], dta);
   }
   function caml_jsstring_of_string(s){
    if(jsoo_is_ascii(s)) return s;
    return caml_utf16_of_utf8(s);
   }
   function _ml_canvas_decorate(header, minimize, maximize, close, title){
    var width = header.width, ctxt = header.getContext("2d");
    ctxt.fillStyle = "#585858";
    ctxt.fillRect(0, 0, width, 30);
    if(title !== null){
     ctxt.fillStyle = "#F0F0F0F0";
     ctxt.font = "bold 16px Arial";
     ctxt.textAlign = "center";
     ctxt.fillText(caml_jsstring_of_string(title), width / 2, 21);
    }
    ctxt.strokeStyle = "#F0F0F0F0";
    ctxt.lineWidth = 2.0;
    if(close == true){
     ctxt.beginPath();
     ctxt.moveTo(width - 20, 10);
     ctxt.lineTo(width - 10, 20);
     ctxt.moveTo(width - 20, 20);
     ctxt.lineTo(width - 10, 10);
     ctxt.stroke();
    }
   }
   function fs_node_supported(){
    return typeof globalThis.process !== "undefined"
           && typeof globalThis.process.versions !== "undefined"
           && typeof globalThis.process.versions.node !== "undefined";
   }
   function make_path_is_absolute(){
    function posix(path){
     if(path.charAt(0) === "/") return ["", path.substring(1)];
     return;
    }
    function win32(path){
     var
      splitDeviceRe =
        /^([a-zA-Z]:|[\\/]{2}[^\\/]+[\\/]+[^\\/]+)?([\\/])?([\s\S]*?)$/,
      result = splitDeviceRe.exec(path),
      device = result[1] || "",
      isUnc = Boolean(device && device.charAt(1) !== ":");
     if(Boolean(result[2] || isUnc)){
      var root = result[1] || "", sep = result[2] || "";
      return [root, path.substring(root.length + sep.length)];
     }
     return;
    }
    return fs_node_supported() && globalThis.process
            && globalThis.process.platform
            ? globalThis.process.platform === "win32" ? win32 : posix
            : posix;
   }
   var path_is_absolute = make_path_is_absolute();
   function caml_trailing_slash(name){
    return name.slice(- 1) !== "/" ? name + "/" : name;
   }
   if(fs_node_supported() && globalThis.process && globalThis.process.cwd)
    var caml_current_dir = globalThis.process.cwd().replace(/\\/g, "/");
   else
    var caml_current_dir = "/static";
   caml_current_dir = caml_trailing_slash(caml_current_dir);
   function caml_make_path(name){
    name = caml_jsstring_of_string(name);
    if(! path_is_absolute(name)) name = caml_current_dir + name;
    var
     comp0 = path_is_absolute(name),
     comp = comp0[1].split("/"),
     ncomp = [];
    for(var i = 0; i < comp.length; i++)
     switch(comp[i]){
       case "..":
        if(ncomp.length > 1) ncomp.pop(); break;
       case ".": break;
       case "": break;
       default: ncomp.push(comp[i]); break;
     }
    ncomp.unshift(comp0[0]);
    ncomp.orig = name;
    return ncomp;
   }
   function caml_get_root(path){
    var x = path_is_absolute(path);
    if(! x) return;
    return x[0] + "/";
   }
   function caml_failwith(msg){
    if(! caml_global_data.Failure)
     caml_global_data.Failure = [248, caml_string_of_jsbytes("Failure"), - 3];
    caml_raise_with_string(caml_global_data.Failure, msg);
   }
   var
    caml_root =
      caml_get_root(caml_current_dir)
      || caml_failwith("unable to compute caml_root"),
    jsoo_mount_point = [];
   if(fs_node_supported())
    jsoo_mount_point.push
     ({path: caml_root, device: new MlNodeDevice(caml_root)});
   else
    jsoo_mount_point.push
     ({path: caml_root, device: new MlFakeDevice(caml_root)});
   jsoo_mount_point.push
    ({path: "/static/", device: new MlFakeDevice("/static/")});
   function resolve_fs_device(name){
    var
     path = caml_make_path(name),
     name = path.join("/"),
     name_slash = caml_trailing_slash(name),
     res;
    for(var i = 0; i < jsoo_mount_point.length; i++){
     var m = jsoo_mount_point[i];
     if
      (name_slash.search(m.path) == 0
       && (! res || res.path.length < m.path.length))
      res =
       {path: m.path,
        device: m.device,
        rest: name.substring(m.path.length, name.length)};
    }
    if(! res && fs_node_supported()){
     var root = caml_get_root(name);
     if(root && root.match(/^[a-zA-Z]:\/$/)){
      var m = {path: root, device: new MlNodeDevice(root)};
      jsoo_mount_point.push(m);
      res =
       {path: m.path,
        device: m.device,
        rest: name.substring(m.path.length, name.length)};
     }
    }
    if(res) return res;
    caml_raise_sys_error("no device found for " + name_slash);
   }
   function caml_read_file_content(name){
    var
     name = typeof name == "string" ? caml_string_of_jsbytes(name) : name,
     root = resolve_fs_device(name);
    if(root.device.exists(root.rest)){
     var
      file = root.device.open(root.rest, {rdonly: 1}),
      len = file.length(),
      buf = new Uint8Array(len);
     file.read(0, buf, 0, len);
     return caml_string_of_array(buf);
    }
    caml_raise_no_such_file(caml_jsbytes_of_string(name));
   }
   function _ml_canvas_image_of_png_file(filename){
    var file = caml_read_file_content(filename);
    if(file === null) return null;
    var
     fc = caml_read_file_content(filename),
     data = window.btoa(fc.c === undefined ? fc : fc.c),
     img = new window.Image();
    img.loading = "eager";
    img.decoding = "sync";
    img.src = "data:image/png;base64," + data;
    return [img.decode(), img];
   }
   function caml_ba_dim(ba, i){
    if(i < 0 || i >= ba.dims.length) caml_invalid_argument("Bigarray.dim");
    return ba.dims[i];
   }
   function caml_ba_to_typed_array(ba){return ba.data;}
   function _ml_canvas_surface_of_ba(data){
    var surface = document.createElement("canvas");
    surface.width = caml_ba_dim(data, 1);
    surface.height = caml_ba_dim(data, 0);
    var
     ctxt = surface.getContext("2d"),
     sta = new window.Uint8Array(caml_ba_to_typed_array(data).buffer),
     dta = new window.Uint8ClampedArray(sta.length);
    for(var i = 0; i < sta.length; i += 4){
     dta[i + 0] = sta[i + 2];
     dta[i + 1] = sta[i + 1];
     dta[i + 2] = sta[i + 0];
     dta[i + 3] = sta[i + 3];
    }
    if(window.ImageData === undefined){
     var image = ctxt.createImageData(surface.width, surface.height);
     image.data.set(dta);
    }
    else
     var image = new window.ImageData(dta, surface.width, surface.height);
    ctxt.putImageData(image, 0, 0);
    return surface;
   }
   function _ml_canvas_valid_canvas_size(width, height){
    return 0 < width && width <= 32767 && 0 < height && height <= 32767;
   }
   function _move_handler(e){
    if(_move.moving){
     var
      new_x = e.pageX,
      new_y = e.pageY,
      dx = new_x - _move.prev_x,
      dy = new_y - _move.prev_y;
     _move.prev_x = new_x;
     _move.prev_y = new_y;
     var canvas = _move.target.canvas;
     canvas.x += dx;
     canvas.y += dy;
     _move.target.style.left = canvas.x + "px";
     _move.target.style.top = canvas.y + "px";
    }
    else if(e.target.canvas !== undefined){
     var
      s = _event_canvas_scale(e),
      evt =
        [EVENT_TAG.MOUSE_MOVE,
         [0,
          e.target.canvas,
          caml_int64_of_float(e.timeStamp * 1000.0),
          [0, e.offsetX * s.scaleX, e.offsetY * s.scaleY]]];
     _ml_canvas_process_event(evt);
    }
    return false;
   }
   var _next_id = 0;
   function _resize_handler(entries){
    entries.forEach
     (function(e){
       var
        evt =
          [EVENT_TAG.CANVAS_RESIZED,
           [0,
            e.target.canvas,
            caml_int64_of_float(e.timeStamp * 1000.0),
            [0, e.target.clientWidth, e.target.clientHeight]]];
       _ml_canvas_process_event(evt);
      });
    return false;
   }
   var _resize = new window.ResizeObserver(_resize_handler);
   function _surface_down_handler(e){
    if(e.target !== null){
     _focus = e.target.canvas;
     e.target.canvas.target.insertBefore(e.target.canvas.frame, null);
     var
      s = _event_canvas_scale(e),
      evt =
        [EVENT_TAG.BUTTON_ACTION,
         [0,
          e.target.canvas,
          caml_int64_of_float(e.timeStamp * 1000.0),
          [0, e.offsetX * s.scaleX, e.offsetY * s.scaleY],
          e.button + 1,
          1]];
     _ml_canvas_process_event(evt);
    }
    return false;
   }
   function _up_handler(e){
    _move.moving = false;
    if(e.target.canvas !== undefined){
     var
      s = _event_canvas_scale(e),
      evt =
        [EVENT_TAG.BUTTON_ACTION,
         [0,
          e.target.canvas,
          caml_int64_of_float(e.timeStamp * 1000.0),
          [0, e.offsetX * s.scaleX, e.offsetY * s.scaleY],
          e.button + 1,
          0]];
     _ml_canvas_process_event(evt);
    }
    return false;
   }
   function incr_nat(nat, ofs, len, carry_in){
    var carry = carry_in;
    for(var i = 0; i < len; i++){
     var x = (nat.data[ofs + i] >>> 0) + carry;
     nat.data[ofs + i] = x | 0;
     if(x == x >>> 0){carry = 0; break;} else carry = 1;
    }
    return carry;
   }
   function add_nat(nat1, ofs1, len1, nat2, ofs2, len2, carry_in){
    var carry = carry_in;
    for(var i = 0; i < len2; i++){
     var
      x = (nat1.data[ofs1 + i] >>> 0) + (nat2.data[ofs2 + i] >>> 0) + carry;
     nat1.data[ofs1 + i] = x;
     if(x == x >>> 0) carry = 0; else carry = 1;
    }
    return incr_nat(nat1, ofs1 + len2, len1 - len2, carry);
   }
   function bigstring_of_array_buffer(ab){
    var ta = new Uint8Array(ab);
    return caml_ba_create_unsafe(12, 0, [ta.length], ta);
   }
   function bigstring_of_typed_array(ba){
    var
     ta =
       new
        Uint8Array
        (ba.buffer, ba.byteOffset, ba.length * ba.BYTES_PER_ELEMENT);
    return caml_ba_create_unsafe(12, 0, [ta.length], ta);
   }
   function bigstring_to_array_buffer(bs){return bs.data.buffer;}
   function bigstring_to_typed_array(bs){return bs.data;}
   function blit_nat(nat1, ofs1, nat2, ofs2, len){
    for(var i = 0; i < len; i++) nat1.data[ofs1 + i] = nat2.data[ofs2 + i];
    return 0;
   }
   var
    caml_MD5Transform =
      function(){
        function add(x, y){return x + y | 0;}
        function xx(q, a, b, x, s, t){
         a = add(add(a, q), add(x, t));
         return add(a << s | a >>> 32 - s, b);
        }
        function ff(a, b, c, d, x, s, t){
         return xx(b & c | ~ b & d, a, b, x, s, t);
        }
        function gg(a, b, c, d, x, s, t){
         return xx(b & d | c & ~ d, a, b, x, s, t);
        }
        function hh(a, b, c, d, x, s, t){return xx(b ^ c ^ d, a, b, x, s, t);}
        function ii(a, b, c, d, x, s, t){
         return xx(c ^ (b | ~ d), a, b, x, s, t);
        }
        return function(w, buffer){
         var a = w[0], b = w[1], c = w[2], d = w[3];
         a = ff(a, b, c, d, buffer[0], 7, 0xD76AA478);
         d = ff(d, a, b, c, buffer[1], 12, 0xE8C7B756);
         c = ff(c, d, a, b, buffer[2], 17, 0x242070DB);
         b = ff(b, c, d, a, buffer[3], 22, 0xC1BDCEEE);
         a = ff(a, b, c, d, buffer[4], 7, 0xF57C0FAF);
         d = ff(d, a, b, c, buffer[5], 12, 0x4787C62A);
         c = ff(c, d, a, b, buffer[6], 17, 0xA8304613);
         b = ff(b, c, d, a, buffer[7], 22, 0xFD469501);
         a = ff(a, b, c, d, buffer[8], 7, 0x698098D8);
         d = ff(d, a, b, c, buffer[9], 12, 0x8B44F7AF);
         c = ff(c, d, a, b, buffer[10], 17, 0xFFFF5BB1);
         b = ff(b, c, d, a, buffer[11], 22, 0x895CD7BE);
         a = ff(a, b, c, d, buffer[12], 7, 0x6B901122);
         d = ff(d, a, b, c, buffer[13], 12, 0xFD987193);
         c = ff(c, d, a, b, buffer[14], 17, 0xA679438E);
         b = ff(b, c, d, a, buffer[15], 22, 0x49B40821);
         a = gg(a, b, c, d, buffer[1], 5, 0xF61E2562);
         d = gg(d, a, b, c, buffer[6], 9, 0xC040B340);
         c = gg(c, d, a, b, buffer[11], 14, 0x265E5A51);
         b = gg(b, c, d, a, buffer[0], 20, 0xE9B6C7AA);
         a = gg(a, b, c, d, buffer[5], 5, 0xD62F105D);
         d = gg(d, a, b, c, buffer[10], 9, 0x02441453);
         c = gg(c, d, a, b, buffer[15], 14, 0xD8A1E681);
         b = gg(b, c, d, a, buffer[4], 20, 0xE7D3FBC8);
         a = gg(a, b, c, d, buffer[9], 5, 0x21E1CDE6);
         d = gg(d, a, b, c, buffer[14], 9, 0xC33707D6);
         c = gg(c, d, a, b, buffer[3], 14, 0xF4D50D87);
         b = gg(b, c, d, a, buffer[8], 20, 0x455A14ED);
         a = gg(a, b, c, d, buffer[13], 5, 0xA9E3E905);
         d = gg(d, a, b, c, buffer[2], 9, 0xFCEFA3F8);
         c = gg(c, d, a, b, buffer[7], 14, 0x676F02D9);
         b = gg(b, c, d, a, buffer[12], 20, 0x8D2A4C8A);
         a = hh(a, b, c, d, buffer[5], 4, 0xFFFA3942);
         d = hh(d, a, b, c, buffer[8], 11, 0x8771F681);
         c = hh(c, d, a, b, buffer[11], 16, 0x6D9D6122);
         b = hh(b, c, d, a, buffer[14], 23, 0xFDE5380C);
         a = hh(a, b, c, d, buffer[1], 4, 0xA4BEEA44);
         d = hh(d, a, b, c, buffer[4], 11, 0x4BDECFA9);
         c = hh(c, d, a, b, buffer[7], 16, 0xF6BB4B60);
         b = hh(b, c, d, a, buffer[10], 23, 0xBEBFBC70);
         a = hh(a, b, c, d, buffer[13], 4, 0x289B7EC6);
         d = hh(d, a, b, c, buffer[0], 11, 0xEAA127FA);
         c = hh(c, d, a, b, buffer[3], 16, 0xD4EF3085);
         b = hh(b, c, d, a, buffer[6], 23, 0x04881D05);
         a = hh(a, b, c, d, buffer[9], 4, 0xD9D4D039);
         d = hh(d, a, b, c, buffer[12], 11, 0xE6DB99E5);
         c = hh(c, d, a, b, buffer[15], 16, 0x1FA27CF8);
         b = hh(b, c, d, a, buffer[2], 23, 0xC4AC5665);
         a = ii(a, b, c, d, buffer[0], 6, 0xF4292244);
         d = ii(d, a, b, c, buffer[7], 10, 0x432AFF97);
         c = ii(c, d, a, b, buffer[14], 15, 0xAB9423A7);
         b = ii(b, c, d, a, buffer[5], 21, 0xFC93A039);
         a = ii(a, b, c, d, buffer[12], 6, 0x655B59C3);
         d = ii(d, a, b, c, buffer[3], 10, 0x8F0CCC92);
         c = ii(c, d, a, b, buffer[10], 15, 0xFFEFF47D);
         b = ii(b, c, d, a, buffer[1], 21, 0x85845DD1);
         a = ii(a, b, c, d, buffer[8], 6, 0x6FA87E4F);
         d = ii(d, a, b, c, buffer[15], 10, 0xFE2CE6E0);
         c = ii(c, d, a, b, buffer[6], 15, 0xA3014314);
         b = ii(b, c, d, a, buffer[13], 21, 0x4E0811A1);
         a = ii(a, b, c, d, buffer[4], 6, 0xF7537E82);
         d = ii(d, a, b, c, buffer[11], 10, 0xBD3AF235);
         c = ii(c, d, a, b, buffer[2], 15, 0x2AD7D2BB);
         b = ii(b, c, d, a, buffer[9], 21, 0xEB86D391);
         w[0] = add(a, w[0]);
         w[1] = add(b, w[1]);
         w[2] = add(c, w[2]);
         w[3] = add(d, w[3]);};
       }
       ();
   function caml_MD5Final(ctx){
    var in_buf = ctx.len & 0x3f;
    ctx.b8[in_buf] = 0x80;
    in_buf++;
    if(in_buf > 56){
     for(var j = in_buf; j < 64; j++) ctx.b8[j] = 0;
     caml_MD5Transform(ctx.w, ctx.b32);
     for(var j = 0; j < 56; j++) ctx.b8[j] = 0;
    }
    else
     for(var j = in_buf; j < 56; j++) ctx.b8[j] = 0;
    ctx.b32[14] = ctx.len << 3;
    ctx.b32[15] = ctx.len >> 29 & 0x1FFFFFFF;
    caml_MD5Transform(ctx.w, ctx.b32);
    var t = new Uint8Array(16);
    for(var i = 0; i < 4; i++)
     for(var j = 0; j < 4; j++) t[i * 4 + j] = ctx.w[i] >> 8 * j & 0xFF;
    return t;
   }
   function caml_MD5Init(){
    var
     buffer = new ArrayBuffer(64),
     b32 = new Uint32Array(buffer),
     b8 = new Uint8Array(buffer);
    return {len: 0,
            w:
            new Uint32Array([0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476]),
            b32: b32,
            b8: b8};
   }
   function caml_MD5Update(ctx, input, input_len){
    var in_buf = ctx.len & 0x3f, input_pos = 0;
    ctx.len += input_len;
    if(in_buf){
     var missing = 64 - in_buf;
     if(input_len < missing){
      ctx.b8.set(input.subarray(0, input_len), in_buf);
      return;
     }
     ctx.b8.set(input.subarray(0, missing), in_buf);
     caml_MD5Transform(ctx.w, ctx.b32);
     input_len -= missing;
     input_pos += missing;
    }
    while(input_len >= 64){
     ctx.b8.set(input.subarray(input_pos, input_pos + 64), 0);
     caml_MD5Transform(ctx.w, ctx.b32);
     input_len -= 64;
     input_pos += 64;
    }
    if(input_len)
     ctx.b8.set(input.subarray(input_pos, input_pos + input_len), 0);
   }
   function caml_acosh_float(x){return Math.acosh(x);}
   function caml_call_gen(f, args){
    var
     n = f.l >= 0 ? f.l : f.l = f.length,
     argsLen = args.length,
     d = n - argsLen;
    if(d == 0)
     return f.apply(null, args);
    else if(d < 0){
     var g = f.apply(null, args.slice(0, n));
     if(typeof g !== "function") return g;
     return caml_call_gen(g, args.slice(n));
    }
    else{
     switch(d){
       case 1:
        {
         var
          g =
            function(x){
             var nargs = new Array(argsLen + 1);
             for(var i = 0; i < argsLen; i++) nargs[i] = args[i];
             nargs[argsLen] = x;
             return f.apply(null, nargs);
            };
         break;
        }
       case 2:
        {
         var
          g =
            function(x, y){
             var nargs = new Array(argsLen + 2);
             for(var i = 0; i < argsLen; i++) nargs[i] = args[i];
             nargs[argsLen] = x;
             nargs[argsLen + 1] = y;
             return f.apply(null, nargs);
            };
         break;
        }
       default:
        var
         g =
           function(){
            var
             extra_args = arguments.length == 0 ? 1 : arguments.length,
             nargs = new Array(args.length + extra_args);
            for(var i = 0; i < args.length; i++) nargs[i] = args[i];
            for(var i = 0; i < arguments.length; i++)
             nargs[args.length + i] = arguments[i];
            return caml_call_gen(f, nargs);
           };
     }
     g.l = d;
     return g;
    }
   }
   function caml_alloc_dummy_infix(){
    return function f(x){return caml_call_gen(f.fun, [x]);};
   }
   function caml_alloc_stack(hv, hx, hf){return 0;}
   var
    caml_argv =
      function(){
        var process = globalThis.process, main = "a.out", args = [];
        if(process && process.argv && process.argv.length > 1){
         var argv = process.argv;
         main = argv[1];
         args = argv.slice(2);
        }
        var p = caml_string_of_jsstring(main), args2 = [0, p];
        for(var i = 0; i < args.length; i++)
         args2.push(caml_string_of_jsstring(args[i]));
        return args2;
       }
       ();
   function caml_array_append(a1, a2){
    var l1 = a1.length, l2 = a2.length, l = l1 + l2 - 1, a = new Array(l);
    a[0] = 0;
    var i = 1, j = 1;
    for(; i < l1; i++) a[i] = a1[i];
    for(; i < l; i++, j++) a[i] = a2[j];
    return a;
   }
   function caml_array_blit(a1, i1, a2, i2, len){
    if(i2 <= i1)
     for(var j = 1; j <= len; j++) a2[i2 + j] = a1[i1 + j];
    else
     for(var j = len; j >= 1; j--) a2[i2 + j] = a1[i1 + j];
    return 0;
   }
   function caml_array_concat(l){
    var a = [0];
    while(l !== 0){
     var b = l[1];
     for(var i = 1; i < b.length; i++) a.push(b[i]);
     l = l[2];
    }
    return a;
   }
   function caml_array_fill(array, ofs, len, v){
    for(var i = 0; i < len; i++) array[ofs + i + 1] = v;
    return 0;
   }
   function caml_array_get(array, index){
    if(index < 0 || index >= array.length - 1) caml_array_bound_error();
    return array[index + 1];
   }
   function caml_array_of_bytes(x){return caml_uint8_array_of_bytes(x);}
   function caml_array_of_string(x){return caml_uint8_array_of_string(x);}
   function caml_array_set(array, index, newval){
    if(index < 0 || index >= array.length - 1) caml_array_bound_error();
    array[index + 1] = newval;
    return 0;
   }
   function caml_array_sub(a, i, len){
    var a2 = new Array(len + 1);
    a2[0] = 0;
    for(var i2 = 1, i1 = i + 1; i2 <= len; i2++, i1++) a2[i2] = a[i1];
    return a2;
   }
   function caml_asinh_float(x){return Math.asinh(x);}
   function caml_atanh_float(x){return Math.atanh(x);}
   function caml_atomic_cas(ref, o, n){
    if(ref[1] === o){ref[1] = n; return 1;}
    return 0;
   }
   function caml_atomic_exchange(ref, v){
    var r = ref[1];
    ref[1] = v;
    return r;
   }
   function caml_atomic_fetch_add(ref, i){
    var old = ref[1];
    ref[1] += i;
    return old;
   }
   function caml_atomic_load(ref){return ref[1];}
   function caml_atomic_make_contended(a){return [0, a];}
   function caml_ba_blit(src, dst){
    if(dst.dims.length != src.dims.length)
     caml_invalid_argument("Bigarray.blit: dimension mismatch");
    for(var i = 0; i < dst.dims.length; i++)
     if(dst.dims[i] != src.dims[i])
      caml_invalid_argument("Bigarray.blit: dimension mismatch");
    dst.data.set(src.data);
    return 0;
   }
   function caml_ba_change_layout(ba, layout){
    if(ba.layout == layout) return ba;
    var new_dims = [];
    for(var i = 0; i < ba.dims.length; i++)
     new_dims[i] = ba.dims[ba.dims.length - i - 1];
    return caml_ba_create_unsafe(ba.kind, layout, new_dims, ba.data);
   }
   function caml_ba_compare(a, b, total){return a.compare(b, total);}
   function caml_ba_create_buffer(kind, size){
    var view;
    switch(kind){
      case 0:
       view = Float32Array; break;
      case 1:
       view = Float64Array; break;
      case 2:
       view = Int8Array; break;
      case 3:
       view = Uint8Array; break;
      case 4:
       view = Int16Array; break;
      case 5:
       view = Uint16Array; break;
      case 6:
       view = Int32Array; break;
      case 7:
       view = Int32Array; break;
      case 8:
       view = Int32Array; break;
      case 9:
       view = Int32Array; break;
      case 10:
       view = Float32Array; break;
      case 11:
       view = Float64Array; break;
      case 12:
       view = Uint8Array; break;
    }
    if(! view) caml_invalid_argument("Bigarray.create: unsupported kind");
    var data = new view(size * caml_ba_get_size_per_element(kind));
    return data;
   }
   function caml_js_from_array(a){return a.slice(1);}
   function caml_ba_create(kind, layout, dims_ml){
    var
     dims = caml_js_from_array(dims_ml),
     data = caml_ba_create_buffer(kind, caml_ba_get_size(dims));
    return caml_ba_create_unsafe(kind, layout, dims, data);
   }
   function caml_ba_create_from(data1, data2, jstyp, kind, layout, dims){
    if(data2 || caml_ba_get_size_per_element(kind) == 2)
     caml_invalid_argument
      ("caml_ba_create_from: use return caml_ba_create_unsafe");
    return caml_ba_create_unsafe(kind, layout, dims, data1);
   }
   function caml_int32_float_of_bits(x){
    var int32a = new Int32Array(1);
    int32a[0] = x;
    var float32a = new Float32Array(int32a.buffer);
    return float32a[0];
   }
   function caml_int64_of_bytes(a){
    return new
            MlInt64
            (a[7] << 0 | a[6] << 8 | a[5] << 16,
             a[4] << 0 | a[3] << 8 | a[2] << 16,
             a[1] << 0 | a[0] << 8);
   }
   function caml_int64_float_of_bits(x){
    var lo = x.lo, mi = x.mi, hi = x.hi, exp = (hi & 0x7fff) >> 4;
    if(exp == 2047)
     return (lo | mi | hi & 0xf) == 0
             ? hi & 0x8000 ? - Infinity : Infinity
             : NaN;
    var k = Math.pow(2, - 24), res = (lo * k + mi) * k + (hi & 0xf);
    if(exp > 0){
     res += 16;
     res *= Math.pow(2, exp - 1027);
    }
    else
     res *= Math.pow(2, - 1026);
    if(hi & 0x8000) res = - res;
    return res;
   }
   function caml_ba_deserialize(reader, sz, name){
    var num_dims = reader.read32s();
    if(num_dims < 0 || num_dims > 16)
     caml_failwith("input_value: wrong number of bigarray dimensions");
    var
     tag = reader.read32s(),
     kind = tag & 0xff,
     layout = tag >> 8 & 1,
     dims = [];
    if(name == "_bigarr02")
     for(var i = 0; i < num_dims; i++){
      var size_dim = reader.read16u();
      if(size_dim == 0xffff){
       var size_dim_hi = reader.read32u(), size_dim_lo = reader.read32u();
       if(size_dim_hi != 0)
        caml_failwith("input_value: bigarray dimension overflow in 32bit");
       size_dim = size_dim_lo;
      }
      dims.push(size_dim);
     }
    else
     for(var i = 0; i < num_dims; i++) dims.push(reader.read32u());
    var
     size = caml_ba_get_size(dims),
     data = caml_ba_create_buffer(kind, size),
     ba = caml_ba_create_unsafe(kind, layout, dims, data);
    switch(kind){
      case 2:
       for(var i = 0; i < size; i++) data[i] = reader.read8s(); break;
      case 3:
      case 12:
       for(var i = 0; i < size; i++) data[i] = reader.read8u(); break;
      case 4:
       for(var i = 0; i < size; i++) data[i] = reader.read16s(); break;
      case 5:
       for(var i = 0; i < size; i++) data[i] = reader.read16u(); break;
      case 6:
       for(var i = 0; i < size; i++) data[i] = reader.read32s(); break;
      case 8:
      case 9:
       var sixty = reader.read8u();
       if(sixty)
        caml_failwith
         ("input_value: cannot read bigarray with 64-bit OCaml ints");
       for(var i = 0; i < size; i++) data[i] = reader.read32s();
       break;
      case 7:
       var t = new Array(8);
       for(var i = 0; i < size; i++){
        for(var j = 0; j < 8; j++) t[j] = reader.read8u();
        var int64 = caml_int64_of_bytes(t);
        ba.set(i, int64);
       }
       break;
      case 1:
       var t = new Array(8);
       for(var i = 0; i < size; i++){
        for(var j = 0; j < 8; j++) t[j] = reader.read8u();
        var f = caml_int64_float_of_bits(caml_int64_of_bytes(t));
        ba.set(i, f);
       }
       break;
      case 0:
       for(var i = 0; i < size; i++){
        var f = caml_int32_float_of_bits(reader.read32s());
        ba.set(i, f);
       }
       break;
      case 10:
       for(var i = 0; i < size; i++){
        var
         re = caml_int32_float_of_bits(reader.read32s()),
         im = caml_int32_float_of_bits(reader.read32s());
        ba.set(i, [254, re, im]);
       }
       break;
      case 11:
       var t = new Array(8);
       for(var i = 0; i < size; i++){
        for(var j = 0; j < 8; j++) t[j] = reader.read8u();
        var re = caml_int64_float_of_bits(caml_int64_of_bytes(t));
        for(var j = 0; j < 8; j++) t[j] = reader.read8u();
        var im = caml_int64_float_of_bits(caml_int64_of_bytes(t));
        ba.set(i, [254, re, im]);
       }
       break;
    }
    sz[0] = (4 + num_dims) * 4;
    return caml_ba_create_unsafe(kind, layout, dims, data);
   }
   function caml_ba_dim_1(ba){return caml_ba_dim(ba, 0);}
   function caml_ba_dim_2(ba){return caml_ba_dim(ba, 1);}
   function caml_ba_dim_3(ba){return caml_ba_dim(ba, 2);}
   function caml_ba_fill(ba, v){ba.fill(v); return 0;}
   function caml_ba_kind_of_typed_array(ta){
    var kind;
    if(ta instanceof Float32Array)
     kind = 0;
    else if(ta instanceof Float64Array)
     kind = 1;
    else if(ta instanceof Int8Array)
     kind = 2;
    else if(ta instanceof Uint8Array)
     kind = 3;
    else if(ta instanceof Uint8ClampedArray)
     kind = 3;
    else if(ta instanceof Int16Array)
     kind = 4;
    else if(ta instanceof Uint16Array)
     kind = 5;
    else if(ta instanceof Int32Array)
     kind = 6;
    else if(ta instanceof Uint32Array)
     kind = 6;
    else
     caml_invalid_argument("caml_ba_kind_of_typed_array: unsupported kind");
    return kind;
   }
   function caml_ba_from_typed_array(ta){
    var
     kind = caml_ba_kind_of_typed_array(ta),
     ta =
       ta instanceof Uint32Array
        ? new Int32Array(ta.buffer, ta.byteOffset, ta.length)
        : ta;
    return caml_ba_create_unsafe(kind, 0, [ta.length], ta);
   }
   function caml_ba_get_2(ba, i0, i1){return ba.get(ba.offset([i0, i1]));}
   function caml_ba_get_3(ba, i0, i1, i2){
    return ba.get(ba.offset([i0, i1, i2]));
   }
   function caml_ba_get_generic(ba, i){
    var ofs = ba.offset(caml_js_from_array(i));
    return ba.get(ofs);
   }
   function caml_mul(a, b){return Math.imul(a, b);}
   function caml_hash_mix_int(h, d){
    d = caml_mul(d, 0xcc9e2d51 | 0);
    d = d << 15 | d >>> 32 - 15;
    d = caml_mul(d, 0x1b873593);
    h ^= d;
    h = h << 13 | h >>> 32 - 13;
    return (h + (h << 2) | 0) + (0xe6546b64 | 0) | 0;
   }
   var log2_ok = Math.log2 && Math.log2(1.1235582092889474E+307) == 1020;
   function jsoo_floor_log2(x){
    if(log2_ok) return Math.floor(Math.log2(x));
    var i = 0;
    if(x == 0) return - Infinity;
    if(x >= 1) while(x >= 2){x /= 2; i++;} else while(x < 1){x *= 2; i--;}
    return i;
   }
   function caml_int64_create_lo_mi_hi(lo, mi, hi){return new MlInt64(lo, mi, hi);
   }
   function caml_int64_bits_of_float(x){
    if(! isFinite(x)){
     if(isNaN(x)) return caml_int64_create_lo_mi_hi(1, 0, 0x7ff0);
     return x > 0
             ? caml_int64_create_lo_mi_hi(0, 0, 0x7ff0)
             : caml_int64_create_lo_mi_hi(0, 0, 0xfff0);
    }
    var sign = x == 0 && 1 / x == - Infinity ? 0x8000 : x >= 0 ? 0 : 0x8000;
    if(sign) x = - x;
    var exp = jsoo_floor_log2(x) + 1023;
    if(exp <= 0){
     exp = 0;
     x /= Math.pow(2, - 1026);
    }
    else{
     x /= Math.pow(2, exp - 1027);
     if(x < 16){x *= 2; exp -= 1;}
     if(exp == 0) x /= 2;
    }
    var k = Math.pow(2, 24), r3 = x | 0;
    x = (x - r3) * k;
    var r2 = x | 0;
    x = (x - r2) * k;
    var r1 = x | 0;
    r3 = r3 & 0xf | sign | exp << 4;
    return caml_int64_create_lo_mi_hi(r1, r2, r3);
   }
   function caml_hash_mix_int64(h, v){
    h = caml_hash_mix_int(h, caml_int64_lo32(v));
    h = caml_hash_mix_int(h, caml_int64_hi32(v));
    return h;
   }
   function caml_hash_mix_float(h, v0){
    return caml_hash_mix_int64(h, caml_int64_bits_of_float(v0));
   }
   function caml_ba_hash(ba){
    var num_elts = caml_ba_get_size(ba.dims), h = 0;
    switch(ba.kind){
      case 2:
      case 3:
      case 12:
       if(num_elts > 256) num_elts = 256;
       var w = 0, i = 0;
       for(i = 0; i + 4 <= ba.data.length; i += 4){
        w =
         ba.data[i + 0] | ba.data[i + 1] << 8 | ba.data[i + 2] << 16
         | ba.data[i + 3] << 24;
        h = caml_hash_mix_int(h, w);
       }
       w = 0;
       switch(num_elts & 3){
         case 3:
          w = ba.data[i + 2] << 16;
         case 2:
          w |= ba.data[i + 1] << 8;
         case 1:
          w |= ba.data[i + 0]; h = caml_hash_mix_int(h, w);
       }
       break;
      case 4:
      case 5:
       if(num_elts > 128) num_elts = 128;
       var w = 0, i = 0;
       for(i = 0; i + 2 <= ba.data.length; i += 2){
        w = ba.data[i + 0] | ba.data[i + 1] << 16;
        h = caml_hash_mix_int(h, w);
       }
       if((num_elts & 1) != 0) h = caml_hash_mix_int(h, ba.data[i]);
       break;
      case 6:
       if(num_elts > 64) num_elts = 64;
       for(var i = 0; i < num_elts; i++) h = caml_hash_mix_int(h, ba.data[i]);
       break;
      case 8:
      case 9:
       if(num_elts > 64) num_elts = 64;
       for(var i = 0; i < num_elts; i++) h = caml_hash_mix_int(h, ba.data[i]);
       break;
      case 7:
       if(num_elts > 32) num_elts = 32;
       num_elts *= 2;
       for(var i = 0; i < num_elts; i++) h = caml_hash_mix_int(h, ba.data[i]);
       break;
      case 10:
       num_elts *= 2;
      case 0:
       if(num_elts > 64) num_elts = 64;
       for(var i = 0; i < num_elts; i++)
        h = caml_hash_mix_float(h, ba.data[i]);
       break;
      case 11:
       num_elts *= 2;
      case 1:
       if(num_elts > 32) num_elts = 32;
       for(var i = 0; i < num_elts; i++)
        h = caml_hash_mix_float(h, ba.data[i]);
       break;
    }
    return h;
   }
   function caml_ba_init(){return 0;}
   function caml_ba_kind(ba){return ba.kind;}
   function caml_ba_layout(ba){return ba.layout;}
   function caml_ba_map_file(vfd, kind, layout, shared, dims, pos){caml_failwith("caml_ba_map_file not implemented");
   }
   function caml_ba_map_file_bytecode(argv, argn){
    return caml_ba_map_file
            (argv[0], argv[1], argv[2], argv[3], argv[4], argv[5]);
   }
   function caml_ba_num_dims(ba){return ba.dims.length;}
   function caml_ba_reshape(ba, vind){
    vind = caml_js_from_array(vind);
    var new_dim = [], num_dims = vind.length;
    if(num_dims < 0 || num_dims > 16)
     caml_invalid_argument("Bigarray.reshape: bad number of dimensions");
    var num_elts = 1;
    for(var i = 0; i < num_dims; i++){
     new_dim[i] = vind[i];
     if(new_dim[i] < 0)
      caml_invalid_argument("Bigarray.reshape: negative dimension");
     num_elts = num_elts * new_dim[i];
    }
    var size = caml_ba_get_size(ba.dims);
    if(num_elts != size)
     caml_invalid_argument("Bigarray.reshape: size mismatch");
    return caml_ba_create_unsafe(ba.kind, ba.layout, new_dim, ba.data);
   }
   function caml_int32_bits_of_float(x){
    var float32a = new Float32Array(1);
    float32a[0] = x;
    var int32a = new Int32Array(float32a.buffer);
    return int32a[0] | 0;
   }
   function caml_int64_to_bytes(x){return x.toArray();}
   function caml_ba_serialize(writer, ba, sz){
    writer.write(32, ba.dims.length);
    writer.write(32, ba.kind | ba.layout << 8);
    if(ba.caml_custom == "_bigarr02")
     for(var i = 0; i < ba.dims.length; i++)
      if(ba.dims[i] < 0xffff)
       writer.write(16, ba.dims[i]);
      else{
       writer.write(16, 0xffff);
       writer.write(32, 0);
       writer.write(32, ba.dims[i]);
      }
    else
     for(var i = 0; i < ba.dims.length; i++) writer.write(32, ba.dims[i]);
    switch(ba.kind){
      case 2:
      case 3:
      case 12:
       for(var i = 0; i < ba.data.length; i++) writer.write(8, ba.data[i]);
       break;
      case 4:
      case 5:
       for(var i = 0; i < ba.data.length; i++) writer.write(16, ba.data[i]);
       break;
      case 6:
       for(var i = 0; i < ba.data.length; i++) writer.write(32, ba.data[i]);
       break;
      case 8:
      case 9:
       writer.write(8, 0);
       for(var i = 0; i < ba.data.length; i++) writer.write(32, ba.data[i]);
       break;
      case 7:
       for(var i = 0; i < ba.data.length / 2; i++){
        var b = caml_int64_to_bytes(ba.get(i));
        for(var j = 0; j < 8; j++) writer.write(8, b[j]);
       }
       break;
      case 1:
       for(var i = 0; i < ba.data.length; i++){
        var b = caml_int64_to_bytes(caml_int64_bits_of_float(ba.get(i)));
        for(var j = 0; j < 8; j++) writer.write(8, b[j]);
       }
       break;
      case 0:
       for(var i = 0; i < ba.data.length; i++){
        var b = caml_int32_bits_of_float(ba.get(i));
        writer.write(32, b);
       }
       break;
      case 10:
       for(var i = 0; i < ba.data.length / 2; i++){
        var j = ba.get(i);
        writer.write(32, caml_int32_bits_of_float(j[1]));
        writer.write(32, caml_int32_bits_of_float(j[2]));
       }
       break;
      case 11:
       for(var i = 0; i < ba.data.length / 2; i++){
        var
         complex = ba.get(i),
         b = caml_int64_to_bytes(caml_int64_bits_of_float(complex[1]));
        for(var j = 0; j < 8; j++) writer.write(8, b[j]);
        var b = caml_int64_to_bytes(caml_int64_bits_of_float(complex[2]));
        for(var j = 0; j < 8; j++) writer.write(8, b[j]);
       }
       break;
    }
    sz[0] = (4 + ba.dims.length) * 4;
    sz[1] = (4 + ba.dims.length) * 8;
   }
   function caml_ba_set_1(ba, i0, v){ba.set(ba.offset(i0), v); return 0;}
   function caml_ba_set_2(ba, i0, i1, v){
    ba.set(ba.offset([i0, i1]), v);
    return 0;
   }
   function caml_ba_set_3(ba, i0, i1, i2, v){
    ba.set(ba.offset([i0, i1, i2]), v);
    return 0;
   }
   function caml_ba_set_generic(ba, i, v){
    ba.set(ba.offset(caml_js_from_array(i)), v);
    return 0;
   }
   function caml_ba_slice(ba, vind){
    vind = caml_js_from_array(vind);
    var num_inds = vind.length, index = [], sub_dims = [], ofs;
    if(num_inds > ba.dims.length)
     caml_invalid_argument("Bigarray.slice: too many indices");
    if(ba.layout == 0){
     for(var i = 0; i < num_inds; i++) index[i] = vind[i];
     for(; i < ba.dims.length; i++) index[i] = 0;
     sub_dims = ba.dims.slice(num_inds);
    }
    else{
     for(var i = 0; i < num_inds; i++)
      index[ba.dims.length - num_inds + i] = vind[i];
     for(var i = 0; i < ba.dims.length - num_inds; i++) index[i] = 1;
     sub_dims = ba.dims.slice(0, ba.dims.length - num_inds);
    }
    ofs = ba.offset(index);
    var
     size = caml_ba_get_size(sub_dims),
     size_per_element = caml_ba_get_size_per_element(ba.kind),
     new_data =
       ba.data.subarray
        (ofs * size_per_element, (ofs + size) * size_per_element);
    return caml_ba_create_unsafe(ba.kind, ba.layout, sub_dims, new_data);
   }
   function caml_ba_sub(ba, ofs, len){
    var changed_dim, mul = 1;
    if(ba.layout == 0){
     for(var i = 1; i < ba.dims.length; i++) mul = mul * ba.dims[i];
     changed_dim = 0;
    }
    else{
     for(var i = 0; i < ba.dims.length - 1; i++) mul = mul * ba.dims[i];
     changed_dim = ba.dims.length - 1;
     ofs = ofs - 1;
    }
    if(ofs < 0 || len < 0 || ofs + len > ba.dims[changed_dim])
     caml_invalid_argument("Bigarray.sub: bad sub-array");
    var new_dims = [];
    for(var i = 0; i < ba.dims.length; i++) new_dims[i] = ba.dims[i];
    new_dims[changed_dim] = len;
    mul *= caml_ba_get_size_per_element(ba.kind);
    var new_data = ba.data.subarray(ofs * mul, (ofs + len) * mul);
    return caml_ba_create_unsafe(ba.kind, ba.layout, new_dims, new_data);
   }
   function caml_ba_uint8_get16(ba, i0){
    var ofs = ba.offset(i0);
    if(ofs + 1 >= ba.data.length) caml_array_bound_error();
    var b1 = ba.get(ofs), b2 = ba.get(ofs + 1);
    return b1 | b2 << 8;
   }
   function caml_ba_uint8_get32(ba, i0){
    var ofs = ba.offset(i0);
    if(ofs + 3 >= ba.data.length) caml_array_bound_error();
    var
     b1 = ba.get(ofs + 0),
     b2 = ba.get(ofs + 1),
     b3 = ba.get(ofs + 2),
     b4 = ba.get(ofs + 3);
    return b1 << 0 | b2 << 8 | b3 << 16 | b4 << 24;
   }
   function caml_ba_uint8_get64(ba, i0){
    var ofs = ba.offset(i0);
    if(ofs + 7 >= ba.data.length) caml_array_bound_error();
    var
     b1 = ba.get(ofs + 0),
     b2 = ba.get(ofs + 1),
     b3 = ba.get(ofs + 2),
     b4 = ba.get(ofs + 3),
     b5 = ba.get(ofs + 4),
     b6 = ba.get(ofs + 5),
     b7 = ba.get(ofs + 6),
     b8 = ba.get(ofs + 7);
    return caml_int64_of_bytes([b8, b7, b6, b5, b4, b3, b2, b1]);
   }
   function caml_ba_uint8_set16(ba, i0, v){
    var ofs = ba.offset(i0);
    if(ofs + 1 >= ba.data.length) caml_array_bound_error();
    ba.set(ofs + 0, v & 0xff);
    ba.set(ofs + 1, v >>> 8 & 0xff);
    return 0;
   }
   function caml_ba_uint8_set32(ba, i0, v){
    var ofs = ba.offset(i0);
    if(ofs + 3 >= ba.data.length) caml_array_bound_error();
    ba.set(ofs + 0, v & 0xff);
    ba.set(ofs + 1, v >>> 8 & 0xff);
    ba.set(ofs + 2, v >>> 16 & 0xff);
    ba.set(ofs + 3, v >>> 24 & 0xff);
    return 0;
   }
   function caml_ba_uint8_set64(ba, i0, v){
    var ofs = ba.offset(i0);
    if(ofs + 7 >= ba.data.length) caml_array_bound_error();
    var v = caml_int64_to_bytes(v);
    for(var i = 0; i < 8; i++) ba.set(ofs + i, v[7 - i]);
    return 0;
   }
   function caml_backtrace_status(_unit){
    return caml_record_backtrace_flag ? 1 : 0;
   }
   function caml_bigstring_blit_ba_to_ba(ba1, pos1, ba2, pos2, len){
    if(12 != ba1.kind)
     caml_invalid_argument("caml_bigstring_blit_ba_to_ba: kind mismatch");
    if(12 != ba2.kind)
     caml_invalid_argument("caml_bigstring_blit_ba_to_ba: kind mismatch");
    if(len == 0) return 0;
    var ofs1 = ba1.offset(pos1), ofs2 = ba2.offset(pos2);
    if(ofs1 + len > ba1.data.length) caml_array_bound_error();
    if(ofs2 + len > ba2.data.length) caml_array_bound_error();
    var slice = ba1.data.subarray(ofs1, ofs1 + len);
    ba2.data.set(slice, pos2);
    return 0;
   }
   function caml_bigstring_blit_ba_to_bytes(ba1, pos1, bytes2, pos2, len){
    if(12 != ba1.kind)
     caml_invalid_argument("caml_bigstring_blit_string_to_ba: kind mismatch");
    if(len == 0) return 0;
    var ofs1 = ba1.offset(pos1);
    if(ofs1 + len > ba1.data.length) caml_array_bound_error();
    if(pos2 + len > caml_ml_bytes_length(bytes2)) caml_array_bound_error();
    var slice = ba1.data.slice(ofs1, ofs1 + len);
    caml_blit_bytes(caml_bytes_of_array(slice), 0, bytes2, pos2, len);
    return 0;
   }
   function caml_bigstring_blit_bytes_to_ba(str1, pos1, ba2, pos2, len){
    if(12 != ba2.kind)
     caml_invalid_argument("caml_bigstring_blit_string_to_ba: kind mismatch");
    if(len == 0) return 0;
    var ofs2 = ba2.offset(pos2);
    if(pos1 + len > caml_ml_bytes_length(str1)) caml_array_bound_error();
    if(ofs2 + len > ba2.data.length) caml_array_bound_error();
    var slice = caml_uint8_array_of_bytes(str1).slice(pos1, pos1 + len);
    ba2.data.set(slice, ofs2);
    return 0;
   }
   function caml_bigstring_blit_string_to_ba(str1, pos1, ba2, pos2, len){
    if(12 != ba2.kind)
     caml_invalid_argument("caml_bigstring_blit_string_to_ba: kind mismatch");
    if(len == 0) return 0;
    var ofs2 = ba2.offset(pos2);
    if(pos1 + len > caml_ml_string_length(str1)) caml_array_bound_error();
    if(ofs2 + len > ba2.data.length) caml_array_bound_error();
    var slice = caml_uint8_array_of_string(str1).slice(pos1, pos1 + len);
    ba2.data.set(slice, ofs2);
    return 0;
   }
   function caml_bigstring_memcmp(s1, pos1, s2, pos2, len){
    for(var i = 0; i < len; i++){
     var a = caml_ba_get_1(s1, pos1 + i), b = caml_ba_get_1(s2, pos2 + i);
     if(a < b) return - 1;
     if(a > b) return 1;
    }
    return 0;
   }
   function caml_blit_string(a, b, c, d, e){
    caml_blit_bytes(caml_bytes_of_string(a), b, c, d, e);
    return 0;
   }
   function caml_bswap16(x){return (x & 0x00FF) << 8 | (x & 0xFF00) >> 8;}
   function caml_build_symbols(symb){
    var r = {};
    if(symb)
     for(var i = 1; i < symb.length; i++)
      r[caml_jsstring_of_string(symb[i][1])] = symb[i][2];
    return r;
   }
   function caml_bytes_compare(s1, s2){
    s1.t & 6 && caml_convert_string_to_bytes(s1);
    s2.t & 6 && caml_convert_string_to_bytes(s2);
    return s1.c < s2.c ? - 1 : s1.c > s2.c ? 1 : 0;
   }
   function caml_bytes_equal(s1, s2){
    if(s1 === s2) return 1;
    s1.t & 6 && caml_convert_string_to_bytes(s1);
    s2.t & 6 && caml_convert_string_to_bytes(s2);
    return s1.c == s2.c ? 1 : 0;
   }
   function caml_bytes_unsafe_get(s, i){
    switch(s.t & 6){
      default: if(i >= s.c.length) return 0;
      case 0:
       return s.c.charCodeAt(i);
      case 4:
       return s.c[i];
    }
   }
   function caml_bytes_get(s, i){
    if(i >>> 0 >= s.l) caml_bytes_bound_error();
    return caml_bytes_unsafe_get(s, i);
   }
   function caml_bytes_get16(s, i){
    if(i >>> 0 >= s.l - 1) caml_bytes_bound_error();
    var
     b1 = caml_bytes_unsafe_get(s, i),
     b2 = caml_bytes_unsafe_get(s, i + 1);
    return b2 << 8 | b1;
   }
   function caml_bytes_get32(s, i){
    if(i >>> 0 >= s.l - 3) caml_bytes_bound_error();
    var
     b1 = caml_bytes_unsafe_get(s, i),
     b2 = caml_bytes_unsafe_get(s, i + 1),
     b3 = caml_bytes_unsafe_get(s, i + 2),
     b4 = caml_bytes_unsafe_get(s, i + 3);
    return b4 << 24 | b3 << 16 | b2 << 8 | b1;
   }
   function caml_bytes_get64(s, i){
    if(i >>> 0 >= s.l - 7) caml_bytes_bound_error();
    var a = new Array(8);
    for(var j = 0; j < 8; j++) a[7 - j] = caml_bytes_unsafe_get(s, i + j);
    return caml_int64_of_bytes(a);
   }
   function caml_bytes_lessequal(s1, s2){
    s1.t & 6 && caml_convert_string_to_bytes(s1);
    s2.t & 6 && caml_convert_string_to_bytes(s2);
    return s1.c <= s2.c ? 1 : 0;
   }
   function caml_bytes_greaterequal(s1, s2){return caml_bytes_lessequal(s2, s1);
   }
   function caml_bytes_lessthan(s1, s2){
    s1.t & 6 && caml_convert_string_to_bytes(s1);
    s2.t & 6 && caml_convert_string_to_bytes(s2);
    return s1.c < s2.c ? 1 : 0;
   }
   function caml_bytes_greaterthan(s1, s2){return caml_bytes_lessthan(s2, s1);
   }
   function caml_bytes_notequal(s1, s2){return 1 - caml_bytes_equal(s1, s2);}
   function caml_bytes_of_utf16_jsstring(s){
    var tag = 9;
    if(! jsoo_is_ascii(s)) tag = 8, s = caml_utf8_of_utf16(s);
    return new MlBytes(tag, s, s.length);
   }
   function caml_bytes_set16(s, i, i16){
    if(i >>> 0 >= s.l - 1) caml_bytes_bound_error();
    var b2 = 0xFF & i16 >> 8, b1 = 0xFF & i16;
    caml_bytes_unsafe_set(s, i + 0, b1);
    caml_bytes_unsafe_set(s, i + 1, b2);
    return 0;
   }
   function caml_bytes_set32(s, i, i32){
    if(i >>> 0 >= s.l - 3) caml_bytes_bound_error();
    var
     b4 = 0xFF & i32 >> 24,
     b3 = 0xFF & i32 >> 16,
     b2 = 0xFF & i32 >> 8,
     b1 = 0xFF & i32;
    caml_bytes_unsafe_set(s, i + 0, b1);
    caml_bytes_unsafe_set(s, i + 1, b2);
    caml_bytes_unsafe_set(s, i + 2, b3);
    caml_bytes_unsafe_set(s, i + 3, b4);
    return 0;
   }
   function caml_bytes_set64(s, i, i64){
    if(i >>> 0 >= s.l - 7) caml_bytes_bound_error();
    var a = caml_int64_to_bytes(i64);
    for(var j = 0; j < 8; j++) caml_bytes_unsafe_set(s, i + 7 - j, a[j]);
    return 0;
   }
   var caml_callback = caml_call_gen;
   function caml_cbrt_float(x){return Math.cbrt(x);}
   var caml_ml_channels = new Array();
   function caml_ml_channel_get(id){return caml_ml_channels[id];}
   function caml_channel_descriptor(chanid){
    var chan = caml_ml_channel_get(chanid);
    return chan.fd;
   }
   function caml_check_bound(array, index){
    if(index >>> 0 >= array.length - 1) caml_array_bound_error();
    return array;
   }
   function caml_classify_float(x){
    if(isFinite(x)){
     if(Math.abs(x) >= 2.2250738585072014e-308) return 0;
     if(x != 0) return 1;
     return 2;
    }
    return isNaN(x) ? 4 : 3;
   }
   function caml_is_continuation_tag(t){return 0;}
   function caml_int32_unmarshal(reader, size){size[0] = 4; return reader.read32s();
   }
   function caml_nativeint_unmarshal(reader, size){
    switch(reader.read8u()){
      case 1:
       size[0] = 4; return reader.read32s();
      case 2:
       caml_failwith("input_value: native integer value too large");
      default: caml_failwith("input_value: ill-formed native integer");
    }
   }
   function caml_int64_unmarshal(reader, size){
    var t = new Array(8);
    for(var j = 0; j < 8; j++) t[j] = reader.read8u();
    size[0] = 8;
    return caml_int64_of_bytes(t);
   }
   function caml_int64_marshal(writer, v, sizes){
    var b = caml_int64_to_bytes(v);
    for(var i = 0; i < 8; i++) writer.write(8, b[i]);
    sizes[0] = 8;
    sizes[1] = 8;
   }
   function caml_int64_compare(x, y, total){return x.compare(y);}
   function caml_int64_hash(v){return v.lo32() ^ v.hi32();}
   var
    caml_custom_ops =
      {"_j":
       {deserialize: caml_int64_unmarshal,
        serialize: caml_int64_marshal,
        fixed_length: 8,
        compare: caml_int64_compare,
        hash: caml_int64_hash},
       "_i": {deserialize: caml_int32_unmarshal, fixed_length: 4},
       "_n": {deserialize: caml_nativeint_unmarshal, fixed_length: 4},
       "_bigarray":
       {deserialize:
        function(reader, sz){
         return caml_ba_deserialize(reader, sz, "_bigarray");
        },
        serialize: caml_ba_serialize,
        compare: caml_ba_compare,
        hash: caml_ba_hash},
       "_bigarr02":
       {deserialize:
        function(reader, sz){
         return caml_ba_deserialize(reader, sz, "_bigarr02");
        },
        serialize: caml_ba_serialize,
        compare: caml_ba_compare,
        hash: caml_ba_hash}};
   function caml_compare_val_get_custom(a){
    return caml_custom_ops[a.caml_custom]
           && caml_custom_ops[a.caml_custom].compare;
   }
   function caml_compare_val_number_custom(num, custom, swap, total){
    var comp = caml_compare_val_get_custom(custom);
    if(comp){
     var x = swap > 0 ? comp(custom, num, total) : comp(num, custom, total);
     if(total && x != x) return swap;
     if(+ x != + x) return + x;
     if((x | 0) != 0) return x | 0;
    }
    return swap;
   }
   function caml_compare_val_tag(a){
    if(typeof a === "number")
     return 1000;
    else if(caml_is_ml_bytes(a))
     return 252;
    else if(caml_is_ml_string(a))
     return 1252;
    else if(a instanceof Array && a[0] === a[0] >>> 0 && a[0] <= 255){var tag = a[0] | 0; return tag == 254 ? 0 : tag;}
    else if(a instanceof String)
     return 12520;
    else if(typeof a == "string")
     return 12520;
    else if(a instanceof Number)
     return 1000;
    else if(a && a.caml_custom)
     return 1255;
    else if(a && a.compare)
     return 1256;
    else if(typeof a == "function")
     return 1247;
    else if(typeof a == "symbol") return 1251;
    return 1001;
   }
   function caml_int_compare(a, b){
    if(a < b) return - 1;
    if(a == b) return 0;
    return 1;
   }
   function caml_string_compare(s1, s2){
    return s1 < s2 ? - 1 : s1 > s2 ? 1 : 0;
   }
   function caml_compare_val(a, b, total){
    var stack = [];
    for(;;){
     if(! (total && a === b)){
      var tag_a = caml_compare_val_tag(a);
      if(tag_a == 250){a = a[1]; continue;}
      var tag_b = caml_compare_val_tag(b);
      if(tag_b == 250){b = b[1]; continue;}
      if(tag_a !== tag_b){
       if(tag_a == 1000){
        if(tag_b == 1255)
         return caml_compare_val_number_custom(a, b, - 1, total);
        return - 1;
       }
       if(tag_b == 1000){
        if(tag_a == 1255)
         return caml_compare_val_number_custom(b, a, 1, total);
        return 1;
       }
       return tag_a < tag_b ? - 1 : 1;
      }
      switch(tag_a){
        case 247:
         caml_invalid_argument("compare: functional value"); break;
        case 248:
         var x = caml_int_compare(a[2], b[2]); if(x != 0) return x | 0; break;
        case 249:
         caml_invalid_argument("compare: functional value"); break;
        case 250:
         caml_invalid_argument("equal: got Forward_tag, should not happen");
         break;
        case 251:
         caml_invalid_argument("equal: abstract value"); break;
        case 252:
         if(a !== b){
          var x = caml_bytes_compare(a, b);
          if(x != 0) return x | 0;
         }
         break;
        case 253:
         caml_invalid_argument("equal: got Double_tag, should not happen");
         break;
        case 254:
         caml_invalid_argument
          ("equal: got Double_array_tag, should not happen");
         break;
        case 255:
         caml_invalid_argument("equal: got Custom_tag, should not happen");
         break;
        case 1247:
         caml_invalid_argument("compare: functional value"); break;
        case 1255:
         var comp = caml_compare_val_get_custom(a);
         if(comp != caml_compare_val_get_custom(b))
          return a.caml_custom < b.caml_custom ? - 1 : 1;
         if(! comp) caml_invalid_argument("compare: abstract value");
         var x = comp(a, b, total);
         if(x != x) return total ? - 1 : x;
         if(x !== (x | 0)) return - 1;
         if(x != 0) return x | 0;
         break;
        case 1256:
         var x = a.compare(b, total);
         if(x != x) return total ? - 1 : x;
         if(x !== (x | 0)) return - 1;
         if(x != 0) return x | 0;
         break;
        case 1000:
         a = + a;
         b = + b;
         if(a < b) return - 1;
         if(a > b) return 1;
         if(a != b){
          if(! total) return NaN;
          if(a == a) return 1;
          if(b == b) return - 1;
         }
         break;
        case 1001:
         if(a < b) return - 1;
         if(a > b) return 1;
         if(a != b){
          if(! total) return NaN;
          if(a == a) return 1;
          if(b == b) return - 1;
         }
         break;
        case 1251:
         if(a !== b){if(! total) return NaN; return 1;} break;
        case 1252:
         var a = caml_jsbytes_of_string(a), b = caml_jsbytes_of_string(b);
         if(a !== b){if(a < b) return - 1; if(a > b) return 1;}
         break;
        case 12520:
         var a = a.toString(), b = b.toString();
         if(a !== b){if(a < b) return - 1; if(a > b) return 1;}
         break;
        case 246:
        case 254:
        default:
         if(caml_is_continuation_tag(tag_a)){
          caml_invalid_argument("compare: continuation value");
          break;
         }
         if(a.length != b.length) return a.length < b.length ? - 1 : 1;
         if(a.length > 1) stack.push(a, b, 1);
         break;
      }
     }
     if(stack.length == 0) return 0;
     var i = stack.pop();
     b = stack.pop();
     a = stack.pop();
     if(i + 1 < a.length) stack.push(a, b, i + 1);
     a = a[i];
     b = b[i];
    }
   }
   function caml_compare(a, b){return caml_compare_val(a, b, true);}
   function caml_continuation_use_noexc(cont){
    var stack = cont[1];
    cont[1] = 0;
    return stack;
   }
   function caml_continuation_use_and_update_handler_noexc
   (cont, hval, hexn, heff){
    var stack = caml_continuation_use_noexc(cont);
    stack[3] = [0, hval, hexn, heff];
    return stack;
   }
   function caml_convert_raw_backtrace(){return [0];}
   function caml_convert_raw_backtrace_slot(){
    caml_failwith("caml_convert_raw_backtrace_slot");
   }
   function caml_copysign_float(x, y){
    if(y == 0) y = 1 / y;
    x = Math.abs(x);
    return y < 0 ? - x : x;
   }
   function caml_cosh_float(x){return Math.cosh(x);}
   function caml_create_file(name, content){
    var root = resolve_fs_device(name);
    if(! root.device.register) caml_failwith("cannot register file");
    root.device.register(root.rest, content);
    return 0;
   }
   function caml_create_string(len){caml_invalid_argument("String.create");}
   var caml_custom_event_index = 0, caml_decompress_input = null;
   function caml_div(x, y){
    if(y == 0) caml_raise_zero_divide();
    return x / y | 0;
   }
   var caml_domain_dls = [0];
   function caml_domain_dls_get(unit){return caml_domain_dls;}
   function caml_domain_dls_set(a){caml_domain_dls = a;}
   var caml_domain_id = 0;
   function caml_ml_mutex_unlock(t){t.locked = false; return 0;}
   var caml_domain_latest_idx = 1;
   function caml_domain_spawn(f, mutex){
    var id = caml_domain_latest_idx++, old = caml_domain_id;
    caml_domain_id = id;
    var res = caml_callback(f, [0]);
    caml_domain_id = old;
    caml_ml_mutex_unlock(mutex);
    return id;
   }
   var caml_ephe_data_offset = 2, caml_ephe_key_offset = 3;
   function caml_ephe_unset_data(x){
    if(globalThis.FinalizationRegistry && globalThis.WeakRef)
     if(x[1] instanceof globalThis.FinalizationRegistry)
      for(var j = caml_ephe_key_offset; j < x.length; j++){
       var key = x[j];
       if(key instanceof globalThis.WeakRef){
        key = key.deref();
        if(key) x[1].unregister(key);
       }
      }
    x[caml_ephe_data_offset] = undefined;
    return 0;
   }
   function caml_ephe_set_data(x, data){
    if(globalThis.FinalizationRegistry && globalThis.WeakRef)
     if(! (x[1] instanceof globalThis.FinalizationRegistry)){
      x[1] =
       new
        globalThis.FinalizationRegistry
        (function(){caml_ephe_unset_data(x);});
      for(var j = caml_ephe_key_offset; j < x.length; j++){
       var key = x[j];
       if(key instanceof globalThis.WeakRef){
        key = key.deref();
        if(key) x[1].register(key, undefined, key);
       }
      }
     }
    x[caml_ephe_data_offset] = data;
    return 0;
   }
   function caml_ephe_blit_data(src, dst){
    var n = src[caml_ephe_data_offset];
    if(n === undefined)
     caml_ephe_unset_data(dst);
    else
     caml_ephe_set_data(dst, n);
    return 0;
   }
   function caml_ephe_blit_key(a1, i1, a2, i2, len){
    caml_array_blit
     (a1,
      caml_ephe_key_offset + i1 - 1,
      a2,
      caml_ephe_key_offset + i2 - 1,
      len);
    return 0;
   }
   function caml_ephe_check_data(x){
    return x[caml_ephe_data_offset] === undefined ? 0 : 1;
   }
   function caml_ephe_check_key(x, i){
    var weak = x[caml_ephe_key_offset + i];
    if(globalThis.WeakRef && weak instanceof globalThis.WeakRef)
     weak = weak.deref();
    return weak === undefined ? 0 : 1;
   }
   function caml_weak_create(n){
    if(n < 0) caml_invalid_argument("Weak.create");
    var x = [251, "caml_ephe_list_head"];
    x.length = caml_ephe_key_offset + n;
    return x;
   }
   function caml_ephe_create(n){var x = caml_weak_create(n); return x;}
   function caml_ephe_get_data(x){
    return x[caml_ephe_data_offset] === undefined
            ? 0
            : [0, x[caml_ephe_data_offset]];
   }
   function caml_obj_dup(x){
    var l = x.length, a = new Array(l);
    for(var i = 0; i < l; i++) a[i] = x[i];
    return a;
   }
   function caml_ephe_get_data_copy(x){
    return x[caml_ephe_data_offset] === undefined
            ? 0
            : [0, caml_obj_dup(x[caml_ephe_data_offset])];
   }
   function caml_ephe_get_key(x, i){
    if(i < 0 || caml_ephe_key_offset + i >= x.length)
     caml_invalid_argument("Weak.get_key");
    var weak = x[caml_ephe_key_offset + i];
    if(globalThis.WeakRef && weak instanceof globalThis.WeakRef)
     weak = weak.deref();
    return weak === undefined ? 0 : [0, weak];
   }
   function caml_ephe_get_key_copy(x, i){
    if(i < 0 || caml_ephe_key_offset + i >= x.length)
     caml_invalid_argument("Weak.get_copy");
    var y = caml_ephe_get_key(x, i);
    if(y === 0) return y;
    var z = y[1];
    if(z instanceof Array) return [0, caml_obj_dup(z)];
    return y;
   }
   function caml_ephe_set_key(x, i, v){
    if(i < 0 || caml_ephe_key_offset + i >= x.length)
     caml_invalid_argument("Weak.set");
    if(v instanceof Object && globalThis.WeakRef){
     if(x[1].register) x[1].register(v, undefined, v);
     x[caml_ephe_key_offset + i] = new globalThis.WeakRef(v);
    }
    else
     x[caml_ephe_key_offset + i] = v;
    return 0;
   }
   function caml_ephe_unset_key(x, i){
    if(i < 0 || caml_ephe_key_offset + i >= x.length)
     caml_invalid_argument("Weak.set");
    if
     (globalThis.WeakRef
      && x[caml_ephe_key_offset + i] instanceof globalThis.WeakRef
      && x[1].unregister){
     var old = x[caml_ephe_key_offset + i].deref();
     if(old !== undefined){
      var count = 0;
      for(var j = caml_ephe_key_offset; j < x.length; j++){
       var key = x[j];
       if(key instanceof globalThis.WeakRef){
        key = key.deref();
        if(key === old) count++;
       }
      }
      if(count == 1) x[1].unregister(old);
     }
    }
    x[caml_ephe_key_offset + i] = undefined;
    return 0;
   }
   function caml_equal(x, y){return + (caml_compare_val(x, y, false) == 0);}
   function caml_erf_float(x){
    var
     a1 = 0.254829592,
     a2 = - 0.284496736,
     a3 = 1.421413741,
     a4 = - 1.453152027,
     a5 = 1.061405429,
     p = 0.3275911,
     sign = 1;
    if(x < 0) sign = - 1;
    x = Math.abs(x);
    var
     t = 1.0 / (1.0 + p * x),
     y =
       1.0
       -
        ((((a5 * t + a4) * t + a3) * t + a2) * t + a1) * t
        * Math.exp(- (x * x));
    return sign * y;
   }
   function caml_erfc_float(x){return 1 - caml_erf_float(x);}
   function caml_eventlog_pause(unit){return 0;}
   function caml_eventlog_resume(unit){return 0;}
   var caml_executable_name = caml_argv[1];
   function caml_exp2_float(x){return Math.pow(2, x);}
   function caml_expm1_float(x){return Math.expm1(x);}
   function caml_is_special_exception(exn){
    switch(exn[2]){case - 8:case - 11:case - 12: return 1;default: return 0;
    }
   }
   function caml_format_exception(exn){
    var r = "";
    if(exn[0] == 0){
     r += exn[1][1];
     if
      (exn.length == 3 && exn[2][0] == 0 && caml_is_special_exception(exn[1]))
      var bucket = exn[2], start = 1;
     else
      var start = 2, bucket = exn;
     r += "(";
     for(var i = start; i < bucket.length; i++){
      if(i > start) r += ", ";
      var v = bucket[i];
      if(typeof v == "number")
       r += v.toString();
      else if(v instanceof MlBytes)
       r += '"' + v.toString() + '"';
      else if(typeof v == "string")
       r += '"' + v.toString() + '"';
      else
       r += "_";
     }
     r += ")";
    }
    else if(exn[0] == 248) r += exn[1];
    return r;
   }
   function caml_fatal_uncaught_exception(err){
    if(err instanceof Array && (err[0] == 0 || err[0] == 248)){
     var handler = caml_named_value("Printexc.handle_uncaught_exception");
     if(handler)
      caml_callback(handler, [err, false]);
     else{
      var
       msg = caml_format_exception(err),
       at_exit = caml_named_value("Pervasives.do_at_exit");
      if(at_exit) caml_callback(at_exit, [0]);
      console.error("Fatal error: exception " + msg);
      if(err.js_error) throw err.js_error;
     }
    }
    else
     throw err;
   }
   function caml_fill_bytes(s, i, l, c){
    if(l > 0)
     if(i == 0 && (l >= s.l || s.t == 2 && l >= s.c.length))
      if(c == 0){
       s.c = "";
       s.t = 2;
      }
      else{
       s.c = caml_str_repeat(l, String.fromCharCode(c));
       s.t = l == s.l ? 0 : 2;
      }
     else{
      if(s.t != 4) caml_convert_bytes_to_array(s);
      for(l += i; i < l; i++) s.c[i] = c;
     }
    return 0;
   }
   function caml_final_register(){return 0;}
   var all_finalizers = new globalThis.Set();
   function caml_final_register_called_without_value(cb, a){
    if(globalThis.FinalizationRegistry && a instanceof Object){
     var
      x =
        new
         globalThis.FinalizationRegistry
         (function(x){all_finalizers.delete(x); cb(0); return;});
     x.register(a, x);
     all_finalizers.add(x);
    }
    return 0;
   }
   function caml_final_release(){return 0;}
   function caml_finish_formatting(f, rawbuffer){
    if(f.uppercase) rawbuffer = rawbuffer.toUpperCase();
    var len = rawbuffer.length;
    if(f.signedconv && (f.sign < 0 || f.signstyle != "-")) len++;
    if(f.alternate){if(f.base == 8) len += 1; if(f.base == 16) len += 2;}
    var buffer = "";
    if(f.justify == "+" && f.filler == " ")
     for(var i = len; i < f.width; i++) buffer += " ";
    if(f.signedconv)
     if(f.sign < 0)
      buffer += "-";
     else if(f.signstyle != "-") buffer += f.signstyle;
    if(f.alternate && f.base == 8) buffer += "0";
    if(f.alternate && f.base == 16) buffer += f.uppercase ? "0X" : "0x";
    if(f.justify == "+" && f.filler == "0")
     for(var i = len; i < f.width; i++) buffer += "0";
    buffer += rawbuffer;
    if(f.justify == "-") for(var i = len; i < f.width; i++) buffer += " ";
    return caml_string_of_jsbytes(buffer);
   }
   function caml_float_compare(x, y){
    if(x === y) return 0;
    if(x < y) return - 1;
    if(x > y) return 1;
    if(x === x) return 1;
    if(y === y) return - 1;
    return 0;
   }
   function caml_float_of_bytes(a){
    return caml_int64_float_of_bits(caml_int64_of_bytes(a));
   }
   function caml_float_of_string(s){
    var res;
    s = caml_jsbytes_of_string(s);
    res = + s;
    if(s.length > 0 && res === res) return res;
    s = s.replace(/_/g, "");
    res = + s;
    if(s.length > 0 && res === res || /^[+-]?nan$/i.test(s)) return res;
    var m = /^ *([+-]?)0x([0-9a-f]+)\.?([0-9a-f]*)(p([+-]?[0-9]+))?/i.exec(s);
    if(m){
     var
      m3 = m[3].replace(/0+$/, ""),
      mantissa = parseInt(m[1] + m[2] + m3, 16),
      exponent = (m[5] | 0) - 4 * m3.length;
     res = mantissa * Math.pow(2, exponent);
     return res;
    }
    if(/^\+?inf(inity)?$/i.test(s)) return Infinity;
    if(/^-inf(inity)?$/i.test(s)) return - Infinity;
    caml_failwith("float_of_string");
   }
   function caml_floatarray_blit(a1, i1, a2, i2, len){
    if(i2 <= i1)
     for(var j = 1; j <= len; j++) a2[i2 + j] = a1[i1 + j];
    else
     for(var j = len; j >= 1; j--) a2[i2 + j] = a1[i1 + j];
    return 0;
   }
   function caml_floatarray_create(len){
    if(len < 0) caml_array_bound_error();
    var len = len + 1 | 0, b = new Array(len);
    b[0] = 254;
    for(var i = 1; i < len; i++) b[i] = 0;
    return b;
   }
   function caml_fma_float(x, y, z){
    var
     SPLIT = Math.pow(2, 27) + 1,
     MIN_VALUE = Math.pow(2, - 1022),
     EPSILON = Math.pow(2, - 52),
     C = 416,
     A = Math.pow(2, + C),
     B = Math.pow(2, - C);
    function multiply(a, b){
     var
      at = SPLIT * a,
      ahi = at - (at - a),
      alo = a - ahi,
      bt = SPLIT * b,
      bhi = bt - (bt - b),
      blo = b - bhi,
      p = a * b,
      e = ahi * bhi - p + ahi * blo + alo * bhi + alo * blo;
     return {p: p, e: e};
    }
    function add(a, b){
     var s = a + b, v = s - a, e = a - (s - v) + (b - v);
     return {s: s, e: e};
    }
    function adjust(x, y){
     return x !== 0 && y !== 0 && SPLIT * x - (SPLIT * x - x) === x
             ? x * (1 + (x < 0 ? - 1 : + 1) * (y < 0 ? - 1 : + 1) * EPSILON)
             : x;
    }
    if
     (x === 0 || x !== x || x === + (1 / 0) || x === - (1 / 0) || y === 0
      || y !== y
      || y === + (1 / 0)
      || y === - (1 / 0))
     return x * y + z;
    if(z === 0) return x * y;
    if(z !== z || z === + (1 / 0) || z === - (1 / 0)) return z;
    var scale = 1;
    while(Math.abs(x) > A){scale *= A; x *= B;}
    while(Math.abs(y) > A){scale *= A; y *= B;}
    if(scale === 1 / 0) return x * y * scale;
    while(Math.abs(x) < B){scale *= B; x *= A;}
    while(Math.abs(y) < B){scale *= B; y *= A;}
    if(scale === 0) return z;
    var xs = x, ys = y, zs = z / scale;
    if(Math.abs(zs) > Math.abs(xs * ys) * 4 / EPSILON) return z;
    if(Math.abs(zs) < Math.abs(xs * ys) * EPSILON / 4 * EPSILON / 4)
     zs = (z < 0 ? - 1 : + 1) * MIN_VALUE;
    var
     xy = multiply(xs, ys),
     s = add(xy.p, zs),
     u = add(xy.e, s.e),
     i = add(s.s, u.s),
     f = i.s + adjust(i.e, u.e);
    if(f === 0) return f;
    var fs = f * scale;
    if(Math.abs(fs) > MIN_VALUE) return fs;
    return fs + adjust(f - fs / scale, i.e) * scale;
   }
   function caml_parse_format(fmt){
    fmt = caml_jsbytes_of_string(fmt);
    var len = fmt.length;
    if(len > 31) caml_invalid_argument("format_int: format too long");
    var
     f =
       {justify: "+",
        signstyle: "-",
        filler: " ",
        alternate: false,
        base: 0,
        signedconv: false,
        width: 0,
        uppercase: false,
        sign: 1,
        prec: - 1,
        conv: "f"};
    for(var i = 0; i < len; i++){
     var c = fmt.charAt(i);
     switch(c){
       case "-":
        f.justify = "-"; break;
       case "+":
       case " ":
        f.signstyle = c; break;
       case "0":
        f.filler = "0"; break;
       case "#":
        f.alternate = true; break;
       case "1":
       case "2":
       case "3":
       case "4":
       case "5":
       case "6":
       case "7":
       case "8":
       case "9":
        f.width = 0;
        while(c = fmt.charCodeAt(i) - 48, c >= 0 && c <= 9){f.width = f.width * 10 + c; i++;}
        i--;
        break;
       case ".":
        f.prec = 0;
        i++;
        while(c = fmt.charCodeAt(i) - 48, c >= 0 && c <= 9){f.prec = f.prec * 10 + c; i++;}
        i--;
       case "d":
       case "i":
        f.signedconv = true;
       case "u":
        f.base = 10; break;
       case "x":
        f.base = 16; break;
       case "X":
        f.base = 16; f.uppercase = true; break;
       case "o":
        f.base = 8; break;
       case "e":
       case "f":
       case "g":
        f.signedconv = true; f.conv = c; break;
       case "E":
       case "F":
       case "G":
        f.signedconv = true;
        f.uppercase = true;
        f.conv = c.toLowerCase();
        break;
     }
    }
    return f;
   }
   function caml_format_float(fmt, x){
    function toFixed(x, dp){
     if(Math.abs(x) < 1.0)
      return x.toFixed(dp);
     else{
      var e = parseInt(x.toString().split("+")[1]);
      if(e > 20){
       e -= 20;
       x /= Math.pow(10, e);
       x += new Array(e + 1).join("0");
       if(dp > 0) x = x + "." + new Array(dp + 1).join("0");
       return x;
      }
      else
       return x.toFixed(dp);
     }
    }
    var s, f = caml_parse_format(fmt), prec = f.prec < 0 ? 6 : f.prec;
    if(x < 0 || x == 0 && 1 / x == - Infinity){f.sign = - 1; x = - x;}
    if(isNaN(x)){
     s = "nan";
     f.filler = " ";
    }
    else if(! isFinite(x)){
     s = "inf";
     f.filler = " ";
    }
    else
     switch(f.conv){
       case "e":
        var s = x.toExponential(prec), i = s.length;
        if(s.charAt(i - 3) == "e")
         s = s.slice(0, i - 1) + "0" + s.slice(i - 1);
        break;
       case "f":
        s = toFixed(x, prec); break;
       case "g":
        prec = prec ? prec : 1;
        s = x.toExponential(prec - 1);
        var j = s.indexOf("e"), exp = + s.slice(j + 1);
        if(exp < - 4 || x >= 1e21 || x.toFixed(0).length > prec){
         var i = j - 1;
         while(s.charAt(i) == "0") i--;
         if(s.charAt(i) == ".") i--;
         s = s.slice(0, i + 1) + s.slice(j);
         i = s.length;
         if(s.charAt(i - 3) == "e")
          s = s.slice(0, i - 1) + "0" + s.slice(i - 1);
         break;
        }
        else{
         var p = prec;
         if(exp < 0){
          p -= exp + 1;
          s = x.toFixed(p);
         }
         else
          while(s = x.toFixed(p), s.length > prec + 1) p--;
         if(p){
          var i = s.length - 1;
          while(s.charAt(i) == "0") i--;
          if(s.charAt(i) == ".") i--;
          s = s.slice(0, i + 1);
         }
        }
        break;
     }
    return caml_finish_formatting(f, s);
   }
   function caml_format_int(fmt, i){
    if(caml_jsbytes_of_string(fmt) == "%d")
     return caml_string_of_jsbytes("" + i);
    var f = caml_parse_format(fmt);
    if(i < 0) if(f.signedconv){f.sign = - 1; i = - i;} else i >>>= 0;
    var s = i.toString(f.base);
    if(f.prec >= 0){
     f.filler = " ";
     var n = f.prec - s.length;
     if(n > 0) s = caml_str_repeat(n, "0") + s;
    }
    return caml_finish_formatting(f, s);
   }
   var caml_oo_last_id = 0;
   function caml_fresh_oo_id(){return caml_oo_last_id++;}
   function caml_frexp_float(x){
    if(x == 0 || ! isFinite(x)) return [0, x, 0];
    var neg = x < 0;
    if(neg) x = - x;
    var exp = Math.max(- 1023, jsoo_floor_log2(x) + 1);
    x *= Math.pow(2, - exp);
    while(x < 0.5){x *= 2; exp--;}
    while(x >= 1){x *= 0.5; exp++;}
    if(neg) x = - x;
    return [0, x, exp];
   }
   function jsoo_create_file(name, content){
    var
     name = caml_string_of_jsbytes(name),
     content = caml_string_of_jsbytes(content);
    return caml_create_file(name, content);
   }
   function caml_fs_init(){
    var tmp = globalThis.caml_fs_tmp;
    if(tmp)
     for(var i = 0; i < tmp.length; i++)
      jsoo_create_file(tmp[i].name, tmp[i].content);
    globalThis.jsoo_create_file = jsoo_create_file;
    globalThis.caml_fs_tmp = [];
    return 0;
   }
   function caml_gc_compaction(){return 0;}
   function caml_gc_counters(){return [254, 0, 0, 0];}
   function caml_gc_full_major(unit){
    if(typeof globalThis.gc == "function") globalThis.gc();
    return 0;
   }
   function caml_gc_get(){return [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];}
   function caml_gc_huge_fallback_count(unit){return 0;}
   function caml_gc_major(unit){
    if(typeof globalThis.gc == "function") globalThis.gc();
    return 0;
   }
   function caml_gc_major_slice(work){return 0;}
   function caml_gc_minor(unit){
    if(typeof globalThis.gc == "function") globalThis.gc(true);
    return 0;
   }
   function caml_gc_minor_words(unit){return 0;}
   function caml_gc_quick_stat(){
    return [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
   }
   function caml_gc_set(_control){return 0;}
   function caml_gc_stat(){return caml_gc_quick_stat();}
   function caml_get_continuation_callstack(){return [0];}
   function caml_get_current_callstack(){return [0];}
   function caml_get_exception_backtrace(){return 0;}
   function caml_get_exception_raw_backtrace(){return [0];}
   function caml_get_global_data(){return caml_global_data;}
   function caml_get_major_bucket(n){return 0;}
   function caml_get_major_credit(n){return 0;}
   function caml_get_minor_free(unit){return 0;}
   var caml_method_cache = [];
   function caml_get_public_method(obj, tag, cacheid){
    var meths = obj[1], ofs = caml_method_cache[cacheid];
    if(ofs === undefined)
     for(var i = caml_method_cache.length; i < cacheid; i++)
      caml_method_cache[i] = 0;
    else if(meths[ofs] === tag) return meths[ofs - 1];
    var li = 3, hi = meths[1] * 2 + 1, mi;
    while(li < hi){
     mi = li + hi >> 1 | 1;
     if(tag < meths[mi + 1]) hi = mi - 2; else li = mi;
    }
    caml_method_cache[cacheid] = li + 1;
    return tag == meths[li + 1] ? meths[li] : 0;
   }
   function caml_gr_arc_aux(ctx, cx, cy, ry, rx, a1, a2){
    while(a1 > a2) a2 += 360;
    a1 /= 180;
    a2 /= 180;
    var
     rot = 0,
     xPos,
     yPos,
     xPos_prev,
     yPos_prev,
     space = 2,
     num = (a2 - a1) * Math.PI * ((rx + ry) / 2) / space | 0,
     delta = (a2 - a1) * Math.PI / num,
     i = a1 * Math.PI;
    for(var j = 0; j <= num; j++){
     xPos =
      cx - rx * Math.sin(i) * Math.sin(rot * Math.PI)
      + ry * Math.cos(i) * Math.cos(rot * Math.PI);
     xPos = xPos.toFixed(2);
     yPos =
      cy + ry * Math.cos(i) * Math.sin(rot * Math.PI)
      + rx * Math.sin(i) * Math.cos(rot * Math.PI);
     yPos = yPos.toFixed(2);
     if(j == 0)
      ctx.moveTo(xPos, yPos);
     else if(xPos_prev != xPos || yPos_prev != yPos) ctx.lineTo(xPos, yPos);
     xPos_prev = xPos;
     yPos_prev = yPos;
     i -= delta;
    }
    return 0;
   }
   var caml_gr_state;
   function caml_gr_state_get(){
    if(caml_gr_state) return caml_gr_state;
    throw caml_maybe_attach_backtrace
           ([0,
             caml_named_value("Graphics.Graphic_failure"),
             caml_string_of_jsbytes("Not initialized")]);
   }
   function caml_gr_blit_image(im, x, y){
    var
     s = caml_gr_state_get(),
     im2 =
       s.context.getImageData
        (x, s.height - im.height - y, im.width, im.height);
    for(var i = 0; i < im2.data.length; i += 4){
     im.data[i] = im2.data[i];
     im.data[i + 1] = im2.data[i + 1];
     im.data[i + 2] = im2.data[i + 2];
     im.data[i + 3] = im2.data[i + 3];
    }
    return 0;
   }
   function caml_gr_clear_graph(){
    var s = caml_gr_state_get();
    s.canvas.width = s.width;
    s.canvas.height = s.height;
    return 0;
   }
   function caml_gr_close_graph(){
    var s = caml_gr_state_get();
    s.canvas.width = 0;
    s.canvas.height = 0;
    return 0;
   }
   function caml_gr_close_subwindow(a){
    caml_failwith("caml_gr_close_subwindow not Implemented");
   }
   function caml_gr_create_image(x, y){
    var s = caml_gr_state_get();
    return s.context.createImageData(x, y);
   }
   function caml_gr_current_x(){var s = caml_gr_state_get(); return s.x;}
   function caml_gr_current_y(){var s = caml_gr_state_get(); return s.y;}
   function caml_gr_display_mode(){
    caml_failwith("caml_gr_display_mode not Implemented");
   }
   function caml_gr_doc_of_state(state){
    if(state.canvas.ownerDocument) return state.canvas.ownerDocument;
   }
   function caml_gr_draw_arc(x, y, rx, ry, a1, a2){
    var s = caml_gr_state_get();
    s.context.beginPath();
    caml_gr_arc_aux(s.context, x, s.height - y, rx, ry, a1, a2);
    s.context.stroke();
    return 0;
   }
   function caml_gr_draw_str(str){
    var s = caml_gr_state_get(), m = s.context.measureText(str), dx = m.width;
    s.context.fillText(str, s.x, s.height - s.y);
    s.x += dx | 0;
    return 0;
   }
   function caml_gr_draw_char(c){
    caml_gr_draw_str(String.fromCharCode(c));
    return 0;
   }
   function caml_gr_draw_image(im, x, y){
    var s = caml_gr_state_get();
    if(! im.image){
     var canvas = document.createElement("canvas");
     canvas.width = s.width;
     canvas.height = s.height;
     canvas.getContext("2d").putImageData(im, 0, 0);
     var image = new globalThis.Image();
     image.onload =
      function(){
       s.context.drawImage(image, x, s.height - im.height - y);
       im.image = image;
      };
     image.src = canvas.toDataURL("image/png");
    }
    else
     s.context.drawImage(im.image, x, s.height - im.height - y);
    return 0;
   }
   function caml_gr_draw_rect(x, y, w, h){
    var s = caml_gr_state_get();
    s.context.strokeRect(x, s.height - y, w, - h);
    return 0;
   }
   function caml_gr_draw_string(str){
    caml_gr_draw_str(caml_jsstring_of_string(str));
    return 0;
   }
   function caml_gr_dump_image(im){
    var data = [0];
    for(var i = 0; i < im.height; i++){
     data[i + 1] = [0];
     for(var j = 0; j < im.width; j++){
      var
       o = i * (im.width * 4) + j * 4,
       r = im.data[o + 0],
       g = im.data[o + 1],
       b = im.data[o + 2];
      data[i + 1][j + 1] = (r << 16) + (g << 8) + b;
     }
    }
    return data;
   }
   function caml_gr_fill_arc(x, y, rx, ry, a1, a2){
    var s = caml_gr_state_get();
    s.context.beginPath();
    caml_gr_arc_aux(s.context, x, s.height - y, rx, ry, a1, a2);
    s.context.fill();
    return 0;
   }
   function caml_gr_fill_poly(ar){
    var s = caml_gr_state_get();
    s.context.beginPath();
    s.context.moveTo(ar[1][1], s.height - ar[1][2]);
    for(var i = 2; i < ar.length; i++)
     s.context.lineTo(ar[i][1], s.height - ar[i][2]);
    s.context.lineTo(ar[1][1], s.height - ar[1][2]);
    s.context.fill();
    return 0;
   }
   function caml_gr_fill_rect(x, y, w, h){
    var s = caml_gr_state_get();
    s.context.fillRect(x, s.height - y, w, - h);
    return 0;
   }
   function caml_gr_lineto(x, y){
    var s = caml_gr_state_get();
    s.context.beginPath();
    s.context.moveTo(s.x, s.height - s.y);
    s.context.lineTo(x, s.height - y);
    s.context.stroke();
    s.x = x;
    s.y = y;
    return 0;
   }
   function caml_gr_make_image(arr){
    var
     s = caml_gr_state_get(),
     h = arr.length - 1,
     w = arr[1].length - 1,
     im = s.context.createImageData(w, h);
    for(var i = 0; i < h; i++)
     for(var j = 0; j < w; j++){
      var c = arr[i + 1][j + 1], o = i * (w * 4) + j * 4;
      if(c == - 1){
       im.data[o + 0] = 0;
       im.data[o + 1] = 0;
       im.data[o + 2] = 0;
       im.data[o + 3] = 0;
      }
      else{
       im.data[o + 0] = c >> 16 & 0xff;
       im.data[o + 1] = c >> 8 & 0xff;
       im.data[o + 2] = c >> 0 & 0Xff;
       im.data[o + 3] = 0xff;
      }
     }
    return im;
   }
   function caml_gr_moveto(x, y){
    var s = caml_gr_state_get();
    s.x = x;
    s.y = y;
    return 0;
   }
   function caml_gr_set_window_title(name){
    var s = caml_gr_state_get();
    s.title = name;
    var jsname = caml_jsstring_of_string(name);
    if(s.set_title) s.set_title(jsname);
    return 0;
   }
   function caml_gr_set_line_width(w){
    var s = caml_gr_state_get();
    s.line_width = w;
    s.context.lineWidth = w;
    return 0;
   }
   function caml_gr_set_text_size(size){
    var s = caml_gr_state_get();
    s.text_size = size;
    s.context.font = s.text_size + "px " + caml_jsstring_of_string(s.font);
    return 0;
   }
   function caml_gr_set_font(f){
    var s = caml_gr_state_get();
    s.font = f;
    s.context.font = s.text_size + "px " + caml_jsstring_of_string(s.font);
    return 0;
   }
   function caml_gr_set_color(color){
    var s = caml_gr_state_get();
    function convert(number){
     var str = "" + number.toString(16);
     while(str.length < 2) str = "0" + str;
     return str;
    }
    var r = color >> 16 & 0xff, g = color >> 8 & 0xff, b = color >> 0 & 0xff;
    s.color = color;
    var c_str = "#" + convert(r) + convert(g) + convert(b);
    s.context.fillStyle = c_str;
    s.context.strokeStyle = c_str;
    return 0;
   }
   function caml_gr_resize_window(w, h){
    var s = caml_gr_state_get();
    s.width = w;
    s.height = h;
    s.canvas.width = w;
    s.canvas.height = h;
    return 0;
   }
   function caml_gr_state_init(){
    caml_gr_moveto(caml_gr_state.x, caml_gr_state.y);
    caml_gr_resize_window(caml_gr_state.width, caml_gr_state.height);
    caml_gr_set_line_width(caml_gr_state.line_width);
    caml_gr_set_text_size(caml_gr_state.text_size);
    caml_gr_set_font(caml_gr_state.font);
    caml_gr_set_color(caml_gr_state.color);
    caml_gr_set_window_title(caml_gr_state.title);
    caml_gr_state.context.textBaseline = "bottom";
   }
   function caml_gr_state_set(ctx){
    caml_gr_state = ctx;
    caml_gr_state_init();
    return 0;
   }
   function caml_gr_state_create(canvas, w, h){
    var context = canvas.getContext("2d");
    return {context: context,
            canvas: canvas,
            x: 0,
            y: 0,
            width: w,
            height: h,
            line_width: 1,
            font: caml_string_of_jsbytes("fixed"),
            text_size: 26,
            color: 0x000000,
            title: caml_string_of_jsbytes("")};
   }
   function caml_gr_open_graph(info){
    var info = caml_jsstring_of_string(info);
    function get(name){
     var res = info.match("(^|,) *" + name + " *= *([a-zA-Z0-9_]+) *(,|$)");
     if(res) return res[2];
    }
    var specs = [];
    if(! (info == "")) specs.push(info);
    var target = get("target");
    if(! target) target = "";
    var status = get("status");
    if(! status) specs.push("status=1");
    var w = get("width");
    w = w ? parseInt(w) : 200;
    specs.push("width=" + w);
    var h = get("height");
    h = h ? parseInt(h) : 200;
    specs.push("height=" + h);
    var win = globalThis.open("about:blank", target, specs.join(","));
    if(! win) caml_failwith("Graphics.open_graph: cannot open the window");
    var doc = win.document, canvas = doc.createElement("canvas");
    canvas.width = w;
    canvas.height = h;
    var ctx = caml_gr_state_create(canvas, w, h);
    ctx.set_title = function(title){doc.title = title;};
    caml_gr_state_set(ctx);
    var body = doc.body;
    body.style.margin = "0px";
    body.appendChild(canvas);
    return 0;
   }
   function caml_gr_open_subwindow(a, b, c, d){
    caml_failwith("caml_gr_open_subwindow not Implemented");
   }
   function caml_gr_plot(x, y){
    var
     s = caml_gr_state_get(),
     im = s.context.createImageData(1, 1),
     d = im.data,
     color = s.color;
    d[0] = color >> 16 & 0xff;
    d[1] = color >> 8 & 0xff, d[2] = color >> 0 & 0xff;
    d[3] = 0xFF;
    s.x = x;
    s.y = y;
    s.context.putImageData(im, x, s.height - y);
    return 0;
   }
   function caml_gr_point_color(x, y){
    var
     s = caml_gr_state_get(),
     im = s.context.getImageData(x, s.height - y, 1, 1),
     d = im.data;
    return (d[0] << 16) + (d[1] << 8) + d[2];
   }
   function caml_gr_remember_mode(){
    caml_failwith("caml_gr_remember_mode not Implemented");
   }
   function caml_gr_sigio_handler(){return 0;}
   function caml_gr_sigio_signal(){return 0;}
   function caml_gr_size_x(){var s = caml_gr_state_get(); return s.width;}
   function caml_gr_size_y(){var s = caml_gr_state_get(); return s.height;}
   function caml_gr_synchronize(){
    caml_failwith("caml_gr_synchronize not Implemented");
   }
   function caml_gr_text_size(txt){
    var
     s = caml_gr_state_get(),
     w = s.context.measureText(caml_jsstring_of_string(txt)).width;
    return [0, w, s.text_size];
   }
   function caml_gr_wait_event(_evl){
    caml_failwith
     ("caml_gr_wait_event not Implemented: use Graphics_js instead");
   }
   function caml_gr_window_id(a){
    caml_failwith("caml_gr_window_id not Implemented");
   }
   function caml_greaterequal(x, y){
    return + (caml_compare_val(x, y, false) >= 0);
   }
   function caml_greaterthan(x, y){
    return + (caml_compare_val(x, y, false) > 0);
   }
   function caml_hash_mix_jsbytes(h, s){
    var len = s.length, i, w;
    for(i = 0; i + 4 <= len; i += 4){
     w =
      s.charCodeAt(i) | s.charCodeAt(i + 1) << 8 | s.charCodeAt(i + 2) << 16
      | s.charCodeAt(i + 3) << 24;
     h = caml_hash_mix_int(h, w);
    }
    w = 0;
    switch(len & 3){
      case 3:
       w = s.charCodeAt(i + 2) << 16;
      case 2:
       w |= s.charCodeAt(i + 1) << 8;
      case 1:
       w |= s.charCodeAt(i); h = caml_hash_mix_int(h, w);
    }
    h ^= len;
    return h;
   }
   function caml_hash_mix_string(h, v){
    return caml_hash_mix_jsbytes(h, caml_jsbytes_of_string(v));
   }
   function caml_hash_mix_bytes_arr(h, s){
    var len = s.length, i, w;
    for(i = 0; i + 4 <= len; i += 4){
     w = s[i] | s[i + 1] << 8 | s[i + 2] << 16 | s[i + 3] << 24;
     h = caml_hash_mix_int(h, w);
    }
    w = 0;
    switch(len & 3){
      case 3:
       w = s[i + 2] << 16;
      case 2:
       w |= s[i + 1] << 8;
      case 1:
       w |= s[i]; h = caml_hash_mix_int(h, w);
    }
    h ^= len;
    return h;
   }
   function caml_ml_bytes_content(s){
    switch(s.t & 6){
      default: caml_convert_string_to_bytes(s);
      case 0:
       return s.c;
      case 4:
       return s.c;
    }
   }
   function caml_hash_mix_bytes(h, v){
    var content = caml_ml_bytes_content(v);
    return typeof content === "string"
            ? caml_hash_mix_jsbytes(h, content)
            : caml_hash_mix_bytes_arr(h, content);
   }
   function caml_hash_mix_final(h){
    h ^= h >>> 16;
    h = caml_mul(h, 0x85ebca6b | 0);
    h ^= h >>> 13;
    h = caml_mul(h, 0xc2b2ae35 | 0);
    h ^= h >>> 16;
    return h;
   }
   function caml_hash(count, limit, seed, obj){
    var queue, rd, wr, sz, num, h, v, i, len;
    sz = limit;
    if(sz < 0 || sz > 256) sz = 256;
    num = count;
    h = seed;
    queue = [obj];
    rd = 0;
    wr = 1;
    while(rd < wr && num > 0){
     v = queue[rd++];
     if(v && v.caml_custom){
      if
       (caml_custom_ops[v.caml_custom] && caml_custom_ops[v.caml_custom].hash){
       var hh = caml_custom_ops[v.caml_custom].hash(v);
       h = caml_hash_mix_int(h, hh);
       num--;
      }
     }
     else if(v instanceof Array && v[0] === (v[0] | 0))
      switch(v[0]){
        case 248:
         h = caml_hash_mix_int(h, v[2]); num--; break;
        case 250:
         queue[--rd] = v[1]; break;
        default:
         if(caml_is_continuation_tag(v[0])) break;
         var tag = v.length - 1 << 10 | v[0];
         h = caml_hash_mix_int(h, tag);
         for(i = 1, len = v.length; i < len; i++){if(wr >= sz) break; queue[wr++] = v[i];
         }
         break;
      }
     else if(caml_is_ml_bytes(v)){
      h = caml_hash_mix_bytes(h, v);
      num--;
     }
     else if(caml_is_ml_string(v)){
      h = caml_hash_mix_string(h, v);
      num--;
     }
     else if(typeof v === "string"){
      h = caml_hash_mix_jsbytes(h, v);
      num--;
     }
     else if(v === (v | 0)){
      h = caml_hash_mix_int(h, v + v + 1);
      num--;
     }
     else if(typeof v === "number"){h = caml_hash_mix_float(h, v); num--;}
    }
    h = caml_hash_mix_final(h);
    return h & 0x3FFFFFFF;
   }
   function caml_hash_mix_bigstring(h, bs){
    return caml_hash_mix_bytes_arr(h, bs.data);
   }
   function num_digits_nat(nat, ofs, len){
    for(var i = len - 1; i >= 0; i--) if(nat.data[ofs + i] != 0) return i + 1;
    return 1;
   }
   function caml_hash_nat(x){
    var len = num_digits_nat(x, 0, x.data.length), h = 0;
    for(var i = 0; i < len; i++) h = caml_hash_mix_int(h, x.data[i]);
    return h;
   }
   function caml_hexstring_of_float(x, prec, style){
    if(! isFinite(x)){
     if(isNaN(x)) return caml_string_of_jsstring("nan");
     return caml_string_of_jsstring(x > 0 ? "infinity" : "-infinity");
    }
    var sign = x == 0 && 1 / x == - Infinity ? 1 : x >= 0 ? 0 : 1;
    if(sign) x = - x;
    var exp = 0;
    if(x == 0)
     ;
    else if(x < 1)
     while(x < 1 && exp > - 1022){x *= 2; exp--;}
    else
     while(x >= 2){x /= 2; exp++;}
    var exp_sign = exp < 0 ? "" : "+", sign_str = "";
    if(sign)
     sign_str = "-";
    else
     switch(style){
       case 43:
        sign_str = "+"; break;
       case 32:
        sign_str = " "; break;
       default: break;
     }
    if(prec >= 0 && prec < 13){
     var cst = Math.pow(2, prec * 4);
     x = Math.round(x * cst) / cst;
    }
    var x_str = x.toString(16);
    if(prec >= 0){
     var idx = x_str.indexOf(".");
     if(idx < 0)
      x_str += "." + caml_str_repeat(prec, "0");
     else{
      var size = idx + 1 + prec;
      if(x_str.length < size)
       x_str += caml_str_repeat(size - x_str.length, "0");
      else
       x_str = x_str.substr(0, size);
     }
    }
    return caml_string_of_jsstring
            (sign_str + "0x" + x_str + "p" + exp_sign + exp.toString(10));
   }
   function caml_hypot_float(x, y){return Math.hypot(x, y);}
   var caml_marshal_header_size = 20;
   function caml_refill(chan){
    if(chan.refill != null){
     var str = chan.refill(), str_a = caml_uint8_array_of_string(str);
     if(str_a.length == 0)
      chan.refill = null;
     else{
      if(chan.buffer.length < chan.buffer_max + str_a.length){
       var b = new Uint8Array(chan.buffer_max + str_a.length);
       b.set(chan.buffer);
       chan.buffer = b;
      }
      chan.buffer.set(str_a, chan.buffer_max);
      chan.offset += str_a.length;
      chan.buffer_max += str_a.length;
     }
    }
    else{
     var
      nread =
        chan.file.read
         (chan.offset,
          chan.buffer,
          chan.buffer_max,
          chan.buffer.length - chan.buffer_max);
     chan.offset += nread;
     chan.buffer_max += nread;
    }
   }
   function caml_raise_end_of_file(){
    caml_raise_constant(caml_global_data.End_of_file);
   }
   function caml_marshal_data_size(s, ofs){
    var r = new UInt8ArrayReader(caml_uint8_array_of_bytes(s), ofs);
    function readvlq(overflow){
     var c = r.read8u(), n = c & 0x7F;
     while((c & 0x80) != 0){
      c = r.read8u();
      var n7 = n << 7;
      if(n != n7 >> 7) overflow[0] = true;
      n = n7 | c & 0x7F;
     }
     return n;
    }
    switch(r.read32u()){
      case 0x8495A6BE:
       var header_len = 20, data_len = r.read32u(); break;
      case 0x8495A6BD:
       var
        header_len = r.read8u() & 0x3F,
        overflow = [false],
        data_len = readvlq(overflow);
       if(overflow[0])
        caml_failwith
         ("Marshal.data_size: object too large to be read back on this platform");
       break;
      case 0x8495A6BF:
      default: caml_failwith("Marshal.data_size: bad object"); break;
    }
    return header_len - caml_marshal_header_size + data_len;
   }
   function caml_input_value_from_reader(reader, ofs){
    function readvlq(overflow){
     var c = reader.read8u(), n = c & 0x7F;
     while((c & 0x80) != 0){
      c = reader.read8u();
      var n7 = n << 7;
      if(n != n7 >> 7) overflow[0] = true;
      n = n7 | c & 0x7F;
     }
     return n;
    }
    var magic = reader.read32u();
    switch(magic){
      case 0x8495A6BE:
       var
        header_len = 20,
        compressed = 0,
        data_len = reader.read32u(),
        uncompressed_data_len = data_len,
        num_objects = reader.read32u(),
        _size_32 = reader.read32u(),
        _size_64 = reader.read32u();
       break;
      case 0x8495A6BD:
       var
        header_len = reader.read8u() & 0x3F,
        compressed = 1,
        overflow = [false],
        data_len = readvlq(overflow),
        uncompressed_data_len = readvlq(overflow),
        num_objects = readvlq(overflow),
        _size_32 = readvlq(overflow),
        _size_64 = readvlq(overflow);
       if(overflow[0])
        caml_failwith
         ("caml_input_value_from_reader: object too large to be read back on this platform");
       break;
      case 0x8495A6BF:
       caml_failwith
        ("caml_input_value_from_reader: object too large to be read back on a 32-bit platform");
       break;
      default:
       caml_failwith("caml_input_value_from_reader: bad object"); break;
    }
    var
     stack = [],
     intern_obj_table = num_objects > 0 ? [] : null,
     obj_counter = 0;
    function intern_rec(reader){
     var code = reader.read8u();
     if(code >= 0x40)
      if(code >= 0x80){
       var tag = code & 0xF, size = code >> 4 & 0x7, v = [tag];
       if(size == 0) return v;
       if(intern_obj_table) intern_obj_table[obj_counter++] = v;
       stack.push(v, size);
       return v;
      }
      else
       return code & 0x3F;
     else if(code >= 0x20){
      var len = code & 0x1F, v = reader.readstr(len);
      if(intern_obj_table) intern_obj_table[obj_counter++] = v;
      return v;
     }
     else
      switch(code){
        case 0x00:
         return reader.read8s();
        case 0x01:
         return reader.read16s();
        case 0x02:
         return reader.read32s();
        case 0x03:
         caml_failwith("input_value: integer too large"); break;
        case 0x04:
         var offset = reader.read8u();
         if(compressed == 0) offset = obj_counter - offset;
         return intern_obj_table[offset];
        case 0x05:
         var offset = reader.read16u();
         if(compressed == 0) offset = obj_counter - offset;
         return intern_obj_table[offset];
        case 0x06:
         var offset = reader.read32u();
         if(compressed == 0) offset = obj_counter - offset;
         return intern_obj_table[offset];
        case 0x08:
         var
          header = reader.read32u(),
          tag = header & 0xFF,
          size = header >> 10,
          v = [tag];
         if(size == 0) return v;
         if(intern_obj_table) intern_obj_table[obj_counter++] = v;
         stack.push(v, size);
         return v;
        case 0x13:
         caml_failwith("input_value: data block too large"); break;
        case 0x09:
         var len = reader.read8u(), v = reader.readstr(len);
         if(intern_obj_table) intern_obj_table[obj_counter++] = v;
         return v;
        case 0x0A:
         var len = reader.read32u(), v = reader.readstr(len);
         if(intern_obj_table) intern_obj_table[obj_counter++] = v;
         return v;
        case 0x0C:
         var t = new Array(8);
         for(var i = 0; i < 8; i++) t[7 - i] = reader.read8u();
         var v = caml_float_of_bytes(t);
         if(intern_obj_table) intern_obj_table[obj_counter++] = v;
         return v;
        case 0x0B:
         var t = new Array(8);
         for(var i = 0; i < 8; i++) t[i] = reader.read8u();
         var v = caml_float_of_bytes(t);
         if(intern_obj_table) intern_obj_table[obj_counter++] = v;
         return v;
        case 0x0E:
         var len = reader.read8u(), v = new Array(len + 1);
         v[0] = 254;
         var t = new Array(8);
         if(intern_obj_table) intern_obj_table[obj_counter++] = v;
         for(var i = 1; i <= len; i++){
          for(var j = 0; j < 8; j++) t[7 - j] = reader.read8u();
          v[i] = caml_float_of_bytes(t);
         }
         return v;
        case 0x0D:
         var len = reader.read8u(), v = new Array(len + 1);
         v[0] = 254;
         var t = new Array(8);
         if(intern_obj_table) intern_obj_table[obj_counter++] = v;
         for(var i = 1; i <= len; i++){
          for(var j = 0; j < 8; j++) t[j] = reader.read8u();
          v[i] = caml_float_of_bytes(t);
         }
         return v;
        case 0x07:
         var len = reader.read32u(), v = new Array(len + 1);
         v[0] = 254;
         if(intern_obj_table) intern_obj_table[obj_counter++] = v;
         var t = new Array(8);
         for(var i = 1; i <= len; i++){
          for(var j = 0; j < 8; j++) t[7 - j] = reader.read8u();
          v[i] = caml_float_of_bytes(t);
         }
         return v;
        case 0x0F:
         var len = reader.read32u(), v = new Array(len + 1);
         v[0] = 254;
         var t = new Array(8);
         for(var i = 1; i <= len; i++){
          for(var j = 0; j < 8; j++) t[j] = reader.read8u();
          v[i] = caml_float_of_bytes(t);
         }
         return v;
        case 0x10:
        case 0x11:
         caml_failwith("input_value: code pointer"); break;
        case 0x12:
        case 0x18:
        case 0x19:
         var c, s = "";
         while((c = reader.read8u()) != 0) s += String.fromCharCode(c);
         var ops = caml_custom_ops[s], expected_size;
         if(! ops)
          caml_failwith("input_value: unknown custom block identifier");
         switch(code){
           case 0x12: break;
           case 0x19:
            if(! ops.fixed_length)
             caml_failwith("input_value: expected a fixed-size custom block");
            expected_size = ops.fixed_length;
            break;
           case 0x18:
            expected_size = reader.read32u();
            reader.read32s();
            reader.read32s();
            break;
         }
         var
          old_pos = reader.i,
          size = [0],
          v = ops.deserialize(reader, size);
         if(expected_size != undefined)
          if(expected_size != size[0])
           caml_failwith
            ("input_value: incorrect length of serialized custom block");
         if(intern_obj_table) intern_obj_table[obj_counter++] = v;
         return v;
        default: caml_failwith("input_value: ill-formed message");
      }
    }
    if(compressed)
     if(caml_decompress_input)
      var
       data = reader.readuint8array(data_len),
       res = new Uint8Array(uncompressed_data_len),
       res = caml_decompress_input(data, res),
       reader = new UInt8ArrayReader(res, 0);
     else
      caml_failwith("input_value: compressed object, cannot decompress");
    var res = intern_rec(reader);
    while(stack.length > 0){
     var size = stack.pop(), v = stack.pop(), d = v.length;
     if(d < size) stack.push(v, size);
     v[d] = intern_rec(reader);
    }
    if(typeof ofs != "number") ofs[0] = reader.i;
    return res;
   }
   function caml_string_of_bytes(s){
    s.t & 6 && caml_convert_string_to_bytes(s);
    return caml_string_of_jsbytes(s.c);
   }
   function caml_input_value_from_bytes(s, ofs){
    var
     reader =
       new
        MlStringReader
        (caml_string_of_bytes(s), typeof ofs == "number" ? ofs : ofs[0]);
    return caml_input_value_from_reader(reader, ofs);
   }
   function caml_input_value(chanid){
    var
     chan = caml_ml_channel_get(chanid),
     header = new Uint8Array(caml_marshal_header_size);
    function block(buffer, offset, n){
     var r = 0;
     while(r < n){
      if(chan.buffer_curr >= chan.buffer_max){
       chan.buffer_curr = 0;
       chan.buffer_max = 0;
       caml_refill(chan);
      }
      if(chan.buffer_curr >= chan.buffer_max) break;
      buffer[offset + r] = chan.buffer[chan.buffer_curr];
      chan.buffer_curr++;
      r++;
     }
     return r;
    }
    var r = block(header, 0, caml_marshal_header_size);
    if(r == 0)
     caml_raise_end_of_file();
    else if(r < caml_marshal_header_size)
     caml_failwith("input_value: truncated object");
    var
     len = caml_marshal_data_size(caml_bytes_of_array(header), 0),
     buf = new Uint8Array(len + caml_marshal_header_size);
    buf.set(header, 0);
    var r = block(buf, caml_marshal_header_size, len);
    if(r < len)
     caml_failwith("input_value: truncated object " + r + "  " + len);
    var
     offset = [0],
     res = caml_input_value_from_bytes(caml_bytes_of_array(buf), offset);
    chan.offset = chan.offset + offset[0];
    return res;
   }
   function caml_input_value_from_string(s, ofs){
    var reader = new MlStringReader(s, typeof ofs == "number" ? ofs : ofs[0]);
    return caml_input_value_from_reader(reader, ofs);
   }
   function caml_input_value_to_outside_heap(c){return caml_input_value(c);}
   function caml_install_signal_handler(){return 0;}
   function caml_int32_bswap(x){
    return (x & 0x000000FF) << 24 | (x & 0x0000FF00) << 8
           | (x & 0x00FF0000) >>> 8
           | (x & 0xFF000000) >>> 24;
   }
   function caml_int64_add(x, y){return x.add(y);}
   function caml_int64_and(x, y){return x.and(y);}
   function caml_int64_bswap(x){
    var y = caml_int64_to_bytes(x);
    return caml_int64_of_bytes
            ([y[7], y[6], y[5], y[4], y[3], y[2], y[1], y[0]]);
   }
   function caml_int64_div(x, y){return x.div(y);}
   function caml_int64_is_zero(x){return + x.isZero();}
   function caml_int64_of_int32(x){
    return new MlInt64(x & 0xffffff, x >> 24 & 0xffffff, x >> 31 & 0xffff);
   }
   function caml_int64_to_int32(x){return x.toInt();}
   function caml_int64_is_negative(x){return + x.isNeg();}
   function caml_int64_neg(x){return x.neg();}
   function caml_int64_format(fmt, x){
    var f = caml_parse_format(fmt);
    if(f.signedconv && caml_int64_is_negative(x)){f.sign = - 1; x = caml_int64_neg(x);}
    var
     buffer = "",
     wbase = caml_int64_of_int32(f.base),
     cvtbl = "0123456789abcdef";
    do{
     var p = x.udivmod(wbase);
     x = p.quotient;
     buffer = cvtbl.charAt(caml_int64_to_int32(p.modulus)) + buffer;
    }
    while
     (! caml_int64_is_zero(x));
    if(f.prec >= 0){
     f.filler = " ";
     var n = f.prec - buffer.length;
     if(n > 0) buffer = caml_str_repeat(n, "0") + buffer;
    }
    return caml_finish_formatting(f, buffer);
   }
   function caml_int64_mod(x, y){return x.mod(y);}
   function caml_int64_mul(x, y){return x.mul(y);}
   function caml_int64_ult(x, y){return x.ucompare(y) < 0;}
   function caml_parse_sign_and_base(s){
    var i = 0, len = caml_ml_string_length(s), base = 10, sign = 1;
    if(len > 0)
     switch(caml_string_unsafe_get(s, i)){
       case 45:
        i++; sign = - 1; break;
       case 43:
        i++; sign = 1; break;
     }
    if(i + 1 < len && caml_string_unsafe_get(s, i) == 48)
     switch(caml_string_unsafe_get(s, i + 1)){
       case 120:
       case 88:
        base = 16; i += 2; break;
       case 111:
       case 79:
        base = 8; i += 2; break;
       case 98:
       case 66:
        base = 2; i += 2; break;
       case 117:
       case 85:
        i += 2; break;
     }
    return [i, sign, base];
   }
   function caml_parse_digit(c){
    if(c >= 48 && c <= 57) return c - 48;
    if(c >= 65 && c <= 90) return c - 55;
    if(c >= 97 && c <= 122) return c - 87;
    return - 1;
   }
   function caml_int64_of_string(s){
    var
     r = caml_parse_sign_and_base(s),
     i = r[0],
     sign = r[1],
     base = r[2],
     base64 = caml_int64_of_int32(base),
     threshold =
       new MlInt64(0xffffff, 0xfffffff, 0xffff).udivmod(base64).quotient,
     c = caml_string_unsafe_get(s, i),
     d = caml_parse_digit(c);
    if(d < 0 || d >= base) caml_failwith("int_of_string");
    var res = caml_int64_of_int32(d);
    for(;;){
     i++;
     c = caml_string_unsafe_get(s, i);
     if(c == 95) continue;
     d = caml_parse_digit(c);
     if(d < 0 || d >= base) break;
     if(caml_int64_ult(threshold, res)) caml_failwith("int_of_string");
     d = caml_int64_of_int32(d);
     res = caml_int64_add(caml_int64_mul(base64, res), d);
     if(caml_int64_ult(res, d)) caml_failwith("int_of_string");
    }
    if(i != caml_ml_string_length(s)) caml_failwith("int_of_string");
    if(base == 10 && caml_int64_ult(new MlInt64(0, 0, 0x8000), res))
     caml_failwith("int_of_string");
    if(sign < 0) res = caml_int64_neg(res);
    return res;
   }
   function caml_int64_or(x, y){return x.or(y);}
   function caml_int64_shift_left(x, s){return x.shift_left(s);}
   function caml_int64_shift_right(x, s){return x.shift_right(s);}
   function caml_int64_shift_right_unsigned(x, s){return x.shift_right_unsigned(s);
   }
   function caml_int64_sub(x, y){return x.sub(y);}
   function caml_int64_to_float(x){return x.toFloat();}
   function caml_int64_xor(x, y){return x.xor(y);}
   function caml_int_of_string(s){
    var
     r = caml_parse_sign_and_base(s),
     i = r[0],
     sign = r[1],
     base = r[2],
     len = caml_ml_string_length(s),
     threshold = - 1 >>> 0,
     c = i < len ? caml_string_unsafe_get(s, i) : 0,
     d = caml_parse_digit(c);
    if(d < 0 || d >= base) caml_failwith("int_of_string");
    var res = d;
    for(i++; i < len; i++){
     c = caml_string_unsafe_get(s, i);
     if(c == 95) continue;
     d = caml_parse_digit(c);
     if(d < 0 || d >= base) break;
     res = base * res + d;
     if(res > threshold) caml_failwith("int_of_string");
    }
    if(i != len) caml_failwith("int_of_string");
    res = sign * res;
    if(base == 10 && (res | 0) != res) caml_failwith("int_of_string");
    return res | 0;
   }
   function caml_is_js(){return 1;}
   function caml_is_printable(c){return + (c > 31 && c < 127);}
   function caml_js_call(f, o, args){
    return f.apply(o, caml_js_from_array(args));
   }
   function caml_js_delete(o, f){delete o[f]; return 0;}
   function caml_js_equals(x, y){return + (x == y);}
   function caml_js_error_of_exception(exn){
    if(exn.js_error) return exn.js_error;
    return null;
   }
   function caml_js_error_option_of_exception(exn){
    if(exn.js_error) return [0, exn.js_error];
    return 0;
   }
   function caml_js_eval_string(s){return eval(caml_jsstring_of_string(s));}
   function caml_js_expr(s){
    console.error("caml_js_expr: fallback to runtime evaluation\n");
    return eval(caml_jsstring_of_string(s));
   }
   function caml_js_from_bool(x){return ! ! x;}
   function caml_js_from_float(x){return x;}
   function caml_js_from_string(s){return caml_jsstring_of_string(s);}
   function caml_js_fun_call(f, a){
    switch(a.length){
      case 1:
       return f();
      case 2:
       return f(a[1]);
      case 3:
       return f(a[1], a[2]);
      case 4:
       return f(a[1], a[2], a[3]);
      case 5:
       return f(a[1], a[2], a[3], a[4]);
      case 6:
       return f(a[1], a[2], a[3], a[4], a[5]);
      case 7:
       return f(a[1], a[2], a[3], a[4], a[5], a[6]);
      case 8:
       return f(a[1], a[2], a[3], a[4], a[5], a[6], a[7]);
    }
    return f.apply(null, caml_js_from_array(a));
   }
   function caml_js_function_arity(f){return f.l >= 0 ? f.l : f.l = f.length;}
   function caml_js_get(o, f){return o[f];}
   function caml_js_get_console(){
    var
     c = console,
     m =
       ["log",
        "debug",
        "info",
        "warn",
        "error",
        "assert",
        "dir",
        "dirxml",
        "trace",
        "group",
        "groupCollapsed",
        "groupEnd",
        "time",
        "timeEnd"];
    function f(){}
    for(var i = 0; i < m.length; i++) if(! c[m[i]]) c[m[i]] = f;
    return c;
   }
   function caml_js_html_entities(s){
    var entity = /^&#?[0-9a-zA-Z]+;$/;
    if(s.match(entity)){
     var str, temp = document.createElement("p");
     temp.innerHTML = s;
     str = temp.textContent || temp.innerText;
     temp = null;
     return str;
    }
    else
     caml_failwith("Invalid entity " + s);
   }
   var caml_js_regexps = {amp: /&/g, lt: /</g, quot: /\"/g, all: /[&<\"]/};
   function caml_js_html_escape(s){
    if(! caml_js_regexps.all.test(s)) return s;
    return s.replace(caml_js_regexps.amp, "&amp;").replace
             (caml_js_regexps.lt, "&lt;").replace
            (caml_js_regexps.quot, "&quot;");
   }
   function caml_js_instanceof(o, c){return o instanceof c ? 1 : 0;}
   function caml_js_meth_call(o, f, args){
    return o[caml_jsstring_of_string(f)].apply(o, caml_js_from_array(args));
   }
   function caml_js_new(c, a){
    switch(a.length){
      case 1:
       return new c;
      case 2:
       return new c(a[1]);
      case 3:
       return new c(a[1], a[2]);
      case 4:
       return new c(a[1], a[2], a[3]);
      case 5:
       return new c(a[1], a[2], a[3], a[4]);
      case 6:
       return new c(a[1], a[2], a[3], a[4], a[5]);
      case 7:
       return new c(a[1], a[2], a[3], a[4], a[5], a[6]);
      case 8:
       return new c(a[1], a[2], a[3], a[4], a[5], a[6], a[7]);
    }
    function F(){return c.apply(this, caml_js_from_array(a));}
    F.prototype = c.prototype;
    return new F;
   }
   function caml_js_object(a){
    var o = {};
    for(var i = 1; i < a.length; i++){
     var p = a[i];
     o[caml_jsstring_of_string(p[1])] = p[2];
    }
    return o;
   }
   function caml_js_on_ie(){
    var
     ua =
       globalThis.navigator && globalThis.navigator.userAgent
        ? globalThis.navigator.userAgent
        : "";
    return ua.indexOf("MSIE") != - 1 && ua.indexOf("Opera") != 0;
   }
   function caml_js_pure_expr(f){return caml_callback(f, [0]);}
   function caml_js_set(o, f, v){o[f] = v; return 0;}
   function caml_js_strict_equals(x, y){return + (x === y);}
   function caml_js_to_array(a){
    var len = a.length, b = new Array(len + 1);
    b[0] = 0;
    for(var i = 0; i < len; i++) b[i + 1] = a[i];
    return b;
   }
   function caml_js_to_bool(x){return + x;}
   function caml_js_to_byte_string(s){return caml_string_of_jsbytes(s);}
   function caml_js_to_float(x){return x;}
   function caml_js_to_int32(x){return x | 0;}
   function caml_js_to_string(s){return caml_string_of_jsstring(s);}
   function caml_js_typeof(o){return typeof o;}
   function caml_js_var(x){
    var x = caml_jsstring_of_string(x);
    if(! x.match(/^[a-zA-Z_$][a-zA-Z_$0-9]*(\.[a-zA-Z_$][a-zA-Z_$0-9]*)*$/))
     console.error
      ('caml_js_var: "' + x
       + '" is not a valid JavaScript variable. continuing ..');
    return eval(x);
   }
   function caml_js_wrap_callback(f){
    return function(){
     var len = arguments.length;
     if(len > 0){
      var args = new Array(len);
      for(var i = 0; i < len; i++) args[i] = arguments[i];
     }
     else
      args = [undefined];
     var res = caml_callback(f, args);
     return res instanceof Function ? caml_js_wrap_callback(res) : res;};
   }
   function caml_js_wrap_callback_arguments(f){
    return function(){
     var len = arguments.length, args = new Array(len);
     for(var i = 0; i < len; i++) args[i] = arguments[i];
     return caml_callback(f, [args]);};
   }
   function caml_js_wrap_callback_strict(arity, f){
    return function(){
     var
      n = arguments.length,
      args = new Array(arity),
      len = Math.min(arguments.length, arity);
     for(var i = 0; i < len; i++) args[i] = arguments[i];
     return caml_callback(f, args);};
   }
   function caml_js_wrap_callback_unsafe(f){
    return function(){
     var len = caml_js_function_arity(f), args = new Array(len);
     for(var i = 0; i < len; i++) args[i] = arguments[i];
     return caml_callback(f, args);};
   }
   function caml_js_wrap_meth_callback(f){
    return function(){
     var len = arguments.length, args = new Array(len + 1);
     args[0] = this;
     for(var i = 0; i < len; i++) args[i + 1] = arguments[i];
     var res = caml_callback(f, args);
     return res instanceof Function ? caml_js_wrap_callback(res) : res;};
   }
   function caml_js_wrap_meth_callback_arguments(f){
    return function(){
     var len = arguments.length, args = new Array(len);
     for(var i = 0; i < len; i++) args[i] = arguments[i];
     return caml_callback(f, [this, args]);};
   }
   function caml_js_wrap_meth_callback_strict(arity, f){
    return function(){
     var args = new Array(arity + 1), len = Math.min(arguments.length, arity);
     args[0] = this;
     for(var i = 0; i < len; i++) args[i + 1] = arguments[i];
     return caml_callback(f, args);};
   }
   function caml_js_wrap_meth_callback_unsafe(f){
    return function(){
     var len = caml_js_function_arity(f) - 1, args = new Array(len + 1);
     args[0] = this;
     for(var i = 0; i < len; i++) args[i + 1] = arguments[i];
     return caml_callback(f, args);};
   }
   function caml_jsoo_flags_effects(unit){return 0;}
   function caml_jsoo_flags_use_js_string(unit){return 1;}
   function caml_lazy_make_forward(v){return [250, v];}
   function caml_obj_tag(x){
    if(x instanceof Array && x[0] == x[0] >>> 0)
     return x[0];
    else if(caml_is_ml_bytes(x))
     return 252;
    else if(caml_is_ml_string(x))
     return 252;
    else if(x instanceof Function || typeof x == "function")
     return 247;
    else if(x && x.caml_custom) return 255; else return 1000;
   }
   function caml_lazy_read_result(o){
    return caml_obj_tag(o) == 250 ? o[1] : o;
   }
   function caml_obj_update_tag(b, o, n){
    if(b[0] == o){b[0] = n; return 1;}
    return 0;
   }
   function caml_lazy_reset_to_lazy(o){
    caml_obj_update_tag(o, 244, 246);
    return 0;
   }
   function caml_lazy_update_to_forcing(o){
    return o instanceof Array && o[0] == o[0] >>> 0
            && caml_obj_update_tag(o, 246, 244)
            ? 0
            : 1;
   }
   function caml_lazy_update_to_forward(o){
    caml_obj_update_tag(o, 244, 250);
    return 0;
   }
   function caml_ldexp_float(x, exp){
    exp |= 0;
    if(exp > 1023){
     exp -= 1023;
     x *= Math.pow(2, 1023);
     if(exp > 1023){exp -= 1023; x *= Math.pow(2, 1023);}
    }
    if(exp < - 1023){exp += 1023; x *= Math.pow(2, - 1023);}
    x *= Math.pow(2, exp);
    return x;
   }
   function caml_lessequal(x, y){
    return + (caml_compare_val(x, y, false) <= 0);
   }
   function caml_lessthan(x, y){return + (caml_compare_val(x, y, false) < 0);}
   function caml_lex_array(s){
    s = caml_jsbytes_of_string(s);
    var l = s.length / 2, a = new Array(l);
    for(var i = 0; i < l; i++)
     a[i] = (s.charCodeAt(2 * i) | s.charCodeAt(2 * i + 1) << 8) << 16 >> 16;
    return a;
   }
   function caml_lex_engine(tbl, start_state, lexbuf){
    var
     lex_buffer = 2,
     lex_buffer_len = 3,
     lex_start_pos = 5,
     lex_curr_pos = 6,
     lex_last_pos = 7,
     lex_last_action = 8,
     lex_eof_reached = 9,
     lex_base = 1,
     lex_backtrk = 2,
     lex_default = 3,
     lex_trans = 4,
     lex_check = 5;
    if(! tbl.lex_default){
     tbl.lex_base = caml_lex_array(tbl[lex_base]);
     tbl.lex_backtrk = caml_lex_array(tbl[lex_backtrk]);
     tbl.lex_check = caml_lex_array(tbl[lex_check]);
     tbl.lex_trans = caml_lex_array(tbl[lex_trans]);
     tbl.lex_default = caml_lex_array(tbl[lex_default]);
    }
    var
     c,
     state = start_state,
     buffer = caml_uint8_array_of_bytes(lexbuf[lex_buffer]);
    if(state >= 0){
     lexbuf[lex_last_pos] = lexbuf[lex_start_pos] = lexbuf[lex_curr_pos];
     lexbuf[lex_last_action] = - 1;
    }
    else
     state = - state - 1;
    for(;;){
     var base = tbl.lex_base[state];
     if(base < 0) return - base - 1;
     var backtrk = tbl.lex_backtrk[state];
     if(backtrk >= 0){
      lexbuf[lex_last_pos] = lexbuf[lex_curr_pos];
      lexbuf[lex_last_action] = backtrk;
     }
     if(lexbuf[lex_curr_pos] >= lexbuf[lex_buffer_len])
      if(lexbuf[lex_eof_reached] == 0) return - state - 1; else c = 256;
     else{c = buffer[lexbuf[lex_curr_pos]]; lexbuf[lex_curr_pos]++;}
     if(tbl.lex_check[base + c] == state)
      state = tbl.lex_trans[base + c];
     else
      state = tbl.lex_default[state];
     if(state < 0){
      lexbuf[lex_curr_pos] = lexbuf[lex_last_pos];
      if(lexbuf[lex_last_action] == - 1)
       caml_failwith("lexing: empty token");
      else
       return lexbuf[lex_last_action];
     }
     else if(c == 256) lexbuf[lex_eof_reached] = 0;
    }
   }
   function caml_list_mount_point(){
    var prev = 0;
    for(var i = 0; i < jsoo_mount_point.length; i++){
     var old = prev;
     prev = [0, caml_string_of_jsbytes(jsoo_mount_point[i].path), old];
    }
    return prev;
   }
   function caml_list_of_js_array(a){
    var l = 0;
    for(var i = a.length - 1; i >= 0; i--){var e = a[i]; l = [0, e, l];}
    return l;
   }
   function caml_list_to_js_array(l){
    var a = [];
    for(; l !== 0; l = l[2]) a.push(l[1]);
    return a;
   }
   function caml_log10_float(x){return Math.log10(x);}
   function caml_log1p_float(x){return Math.log1p(x);}
   function caml_log2_float(x){return Math.log2(x);}
   function caml_new_string(s){return caml_string_of_jsbytes(s);}
   function caml_lxm_next(v){
    function shift_l(x, k){return caml_int64_shift_left(x, k);}
    function shift_r(x, k){return caml_int64_shift_right_unsigned(x, k);}
    function or(a, b){return caml_int64_or(a, b);}
    function xor(a, b){return caml_int64_xor(a, b);}
    function add(a, b){return caml_int64_add(a, b);}
    function mul(a, b){return caml_int64_mul(a, b);}
    function rotl(x, k){return or(shift_l(x, k), shift_r(x, 64 - k));}
    function get(a, i){return caml_ba_get_1(a, i);}
    function set(a, i, x){return caml_ba_set_1(a, i, x);}
    var
     M = caml_int64_of_string(caml_new_string("0xd1342543de82ef95")),
     daba = caml_int64_of_string(caml_new_string("0xdaba0b6eb09322e3")),
     z,
     q0,
     q1,
     st = v,
     a = get(st, 0),
     s = get(st, 1),
     x0 = get(st, 2),
     x1 = get(st, 3);
    z = add(s, x0);
    z = mul(xor(z, shift_r(z, 32)), daba);
    z = mul(xor(z, shift_r(z, 32)), daba);
    z = xor(z, shift_r(z, 32));
    set(st, 1, add(mul(s, M), a));
    var q0 = x0, q1 = x1;
    q1 = xor(q1, q0);
    q0 = rotl(q0, 24);
    q0 = xor(xor(q0, q1), shift_l(q1, 16));
    q1 = rotl(q1, 37);
    set(st, 2, q0);
    set(st, 3, q1);
    return z;
   }
   function caml_make_float_vect(len){
    if(len < 0) caml_array_bound_error();
    var len = len + 1 | 0, b = new Array(len);
    b[0] = 254;
    for(var i = 1; i < len; i++) b[i] = 0;
    return b;
   }
   function caml_make_vect(len, init){
    if(len < 0) caml_array_bound_error();
    var len = len + 1 | 0, b = new Array(len);
    b[0] = 0;
    for(var i = 1; i < len; i++) b[i] = init;
    return b;
   }
   var
    caml_marshal_constants =
      {PREFIX_SMALL_BLOCK: 0x80,
       PREFIX_SMALL_INT: 0x40,
       PREFIX_SMALL_STRING: 0x20,
       CODE_INT8: 0x00,
       CODE_INT16: 0x01,
       CODE_INT32: 0x02,
       CODE_INT64: 0x03,
       CODE_SHARED8: 0x04,
       CODE_SHARED16: 0x05,
       CODE_SHARED32: 0x06,
       CODE_BLOCK32: 0x08,
       CODE_BLOCK64: 0x13,
       CODE_STRING8: 0x09,
       CODE_STRING32: 0x0A,
       CODE_DOUBLE_BIG: 0x0B,
       CODE_DOUBLE_LITTLE: 0x0C,
       CODE_DOUBLE_ARRAY8_BIG: 0x0D,
       CODE_DOUBLE_ARRAY8_LITTLE: 0x0E,
       CODE_DOUBLE_ARRAY32_BIG: 0x0F,
       CODE_DOUBLE_ARRAY32_LITTLE: 0x07,
       CODE_CODEPOINTER: 0x10,
       CODE_INFIXPOINTER: 0x11,
       CODE_CUSTOM: 0x12,
       CODE_CUSTOM_LEN: 0x18,
       CODE_CUSTOM_FIXED: 0x19};
   function caml_maybe_print_stats(unit){return 0;}
   function caml_md5_bytes(s, ofs, len){
    var ctx = caml_MD5Init(), a = caml_uint8_array_of_bytes(s);
    caml_MD5Update(ctx, a.subarray(ofs, ofs + len), len);
    return caml_string_of_array(caml_MD5Final(ctx));
   }
   function caml_ml_input_block(chanid, ba, i, l){
    var
     chan = caml_ml_channel_get(chanid),
     n = l,
     avail = chan.buffer_max - chan.buffer_curr;
    if(l <= avail){
     ba.set(chan.buffer.subarray(chan.buffer_curr, chan.buffer_curr + l), i);
     chan.buffer_curr += l;
    }
    else if(avail > 0){
     ba.set
      (chan.buffer.subarray(chan.buffer_curr, chan.buffer_curr + avail), i);
     chan.buffer_curr += avail;
     n = avail;
    }
    else{
     chan.buffer_curr = 0;
     chan.buffer_max = 0;
     caml_refill(chan);
     var avail = chan.buffer_max - chan.buffer_curr;
     if(n > avail) n = avail;
     ba.set(chan.buffer.subarray(chan.buffer_curr, chan.buffer_curr + n), i);
     chan.buffer_curr += n;
    }
    return n | 0;
   }
   function caml_md5_chan(chanid, toread){
    var ctx = caml_MD5Init(), buffer = new Uint8Array(4096);
    if(toread < 0)
     while(true){
      var read = caml_ml_input_block(chanid, buffer, 0, buffer.length);
      if(read == 0) break;
      caml_MD5Update(ctx, buffer.subarray(0, read), read);
     }
    else
     while(toread > 0){
      var
       read =
         caml_ml_input_block
          (chanid, buffer, 0, toread > buffer.length ? buffer.length : toread);
      if(read == 0) caml_raise_end_of_file();
      caml_MD5Update(ctx, buffer.subarray(0, read), read);
      toread -= read;
     }
    return caml_string_of_array(caml_MD5Final(ctx));
   }
   function caml_md5_string(s, ofs, len){
    return caml_md5_bytes(caml_bytes_of_string(s), ofs, len);
   }
   function caml_memprof_discard(t){return 0;}
   function caml_memprof_set(_control){return 0;}
   function caml_memprof_start(rate, stack_size, tracker){return 0;}
   function caml_memprof_stop(unit){return 0;}
   function caml_ml_channel_redirect(captured, into){
    var
     to_restore = caml_ml_channel_get(captured),
     new_ = caml_ml_channel_get(into);
    caml_ml_channels[captured] = new_;
    return to_restore;
   }
   function caml_ml_channel_restore(captured, to_restore){caml_ml_channels[captured] = to_restore; return 0;
   }
   function caml_ml_channel_size(chanid){
    var chan = caml_ml_channel_get(chanid);
    return chan.file.length();
   }
   function caml_ml_channel_size_64(chanid){
    var chan = caml_ml_channel_get(chanid);
    return caml_int64_of_float(chan.file.length());
   }
   var caml_sys_fds = new Array(3);
   function caml_sys_close(fd){
    var file = caml_sys_fds[fd];
    if(file) file.close();
    delete caml_sys_fds[fd];
    return 0;
   }
   function caml_ml_flush(chanid){
    var chan = caml_ml_channel_get(chanid);
    if(! chan.opened) caml_raise_sys_error("Cannot flush a closed channel");
    if(! chan.buffer || chan.buffer_curr == 0) return 0;
    if(chan.output)
     chan.output(caml_subarray_to_jsbytes(chan.buffer, 0, chan.buffer_curr));
    else
     chan.file.write(chan.offset, chan.buffer, 0, chan.buffer_curr);
    chan.offset += chan.buffer_curr;
    chan.buffer_curr = 0;
    return 0;
   }
   function caml_ml_close_channel(chanid){
    var chan = caml_ml_channel_get(chanid);
    if(chan.opened){
     chan.opened = false;
     caml_sys_close(chan.fd);
     chan.fd = - 1;
     chan.buffer = new Uint8Array(0);
     chan.buffer_curr = 0;
     chan.buffer_max = 0;
    }
    return 0;
   }
   function caml_ml_condition_broadcast(t){return 0;}
   function caml_ml_condition_new(unit){return {condition: 1};}
   function caml_ml_condition_signal(t){return 0;}
   function caml_ml_condition_wait(t, mutext){return 0;}
   function caml_ml_debug_info_status(){return 0;}
   function caml_ml_domain_cpu_relax(unit){return 0;}
   function caml_ml_domain_id(unit){return caml_domain_id;}
   function caml_ml_domain_set_name(_name){return 0;}
   var caml_ml_domain_unique_token_ = [0];
   function caml_ml_domain_unique_token(unit){return caml_ml_domain_unique_token_;
   }
   var caml_runtime_warnings = 0;
   function caml_ml_enable_runtime_warnings(bool){caml_runtime_warnings = bool; return 0;
   }
   function caml_ml_input(chanid, b, i, l){
    var ba = caml_uint8_array_of_bytes(b);
    return caml_ml_input_block(chanid, ba, i, l);
   }
   function caml_ml_input_bigarray(chanid, b, i, l){
    var ba = caml_ba_to_typed_array(b);
    return caml_ml_input_block(chanid, ba, i, l);
   }
   function caml_ml_input_char(chanid){
    var chan = caml_ml_channel_get(chanid);
    if(chan.buffer_curr >= chan.buffer_max){
     chan.buffer_curr = 0;
     chan.buffer_max = 0;
     caml_refill(chan);
    }
    if(chan.buffer_curr >= chan.buffer_max) caml_raise_end_of_file();
    var res = chan.buffer[chan.buffer_curr];
    chan.buffer_curr++;
    return res;
   }
   function caml_ml_input_int(chanid){
    var chan = caml_ml_channel_get(chanid), res = 0;
    for(var i = 0; i < 4; i++)
     res = (res << 8) + caml_ml_input_char(chanid) | 0;
    return res | 0;
   }
   function caml_ml_input_scan_line(chanid){
    var chan = caml_ml_channel_get(chanid), p = chan.buffer_curr;
    do
     if(p >= chan.buffer_max){
      if(chan.buffer_curr > 0){
       chan.buffer.set(chan.buffer.subarray(chan.buffer_curr), 0);
       p -= chan.buffer_curr;
       chan.buffer_max -= chan.buffer_curr;
       chan.buffer_curr = 0;
      }
      if(chan.buffer_max >= chan.buffer.length) return - chan.buffer_max | 0;
      var prev_max = chan.buffer_max;
      caml_refill(chan);
      if(prev_max == chan.buffer_max) return - chan.buffer_max | 0;
     }
    while
     (chan.buffer[p++] != 10);
    return p - chan.buffer_curr | 0;
   }
   function caml_ml_is_buffered(chanid){
    return caml_ml_channel_get(chanid).buffered ? 1 : 0;
   }
   function caml_ml_mutex_lock(t){
    if(t.locked)
     caml_failwith("Mutex.lock: mutex already locked. Cannot wait.");
    else
     t.locked = true;
    return 0;
   }
   function caml_ml_mutex_new(unit){return new MlMutex();}
   function caml_ml_mutex_try_lock(t){
    if(! t.locked){t.locked = true; return 1;}
    return 0;
   }
   function caml_sys_open_for_node(fd, flags){
    if(flags.name)
     try{
      var fs = require("fs"), fd2 = fs.openSync(flags.name, "rs");
      return new MlNodeFd(fd2, flags);
     }
     catch(e){}
    return new MlNodeFd(fd, flags);
   }
   function caml_sys_open_internal(file, idx){
    if(idx == undefined) idx = caml_sys_fds.length;
    caml_sys_fds[idx] = file;
    return idx | 0;
   }
   function caml_sys_open(name, flags, _perms){
    var f = {};
    while(flags){
     switch(flags[1]){
       case 0:
        f.rdonly = 1; break;
       case 1:
        f.wronly = 1; break;
       case 2:
        f.append = 1; break;
       case 3:
        f.create = 1; break;
       case 4:
        f.truncate = 1; break;
       case 5:
        f.excl = 1; break;
       case 6:
        f.binary = 1; break;
       case 7:
        f.text = 1; break;
       case 8:
        f.nonblock = 1; break;
     }
     flags = flags[2];
    }
    if(f.rdonly && f.wronly)
     caml_raise_sys_error
      (caml_jsbytes_of_string(name)
       + " : flags Open_rdonly and Open_wronly are not compatible");
    if(f.text && f.binary)
     caml_raise_sys_error
      (caml_jsbytes_of_string(name)
       + " : flags Open_text and Open_binary are not compatible");
    var root = resolve_fs_device(name), file = root.device.open(root.rest, f);
    return caml_sys_open_internal(file, undefined);
   }
   (function(){
      function file(fd, flags){
       return fs_node_supported()
               ? caml_sys_open_for_node(fd, flags)
               : new MlFakeFd_out(fd, flags);
      }
      caml_sys_open_internal
       (file(0, {rdonly: 1, altname: "/dev/stdin", isCharacterDevice: true}),
        0);
      caml_sys_open_internal
       (file(1, {buffered: 2, wronly: 1, isCharacterDevice: true}), 1);
      caml_sys_open_internal
       (file(2, {buffered: 2, wronly: 1, isCharacterDevice: true}), 2);
     }
     ());
   function caml_ml_open_descriptor_in(fd){
    var file = caml_sys_fds[fd];
    if(file.flags.wronly) caml_raise_sys_error("fd " + fd + " is writeonly");
    var
     refill = null,
     channel =
       {file: file,
        offset: file.flags.append ? file.length() : 0,
        fd: fd,
        opened: true,
        out: false,
        buffer_curr: 0,
        buffer_max: 0,
        buffer: new Uint8Array(65536),
        refill: refill};
    caml_ml_channels[channel.fd] = channel;
    return channel.fd;
   }
   function caml_ml_open_descriptor_out(fd){
    var file = caml_sys_fds[fd];
    if(file.flags.rdonly) caml_raise_sys_error("fd " + fd + " is readonly");
    var
     buffered = file.flags.buffered !== undefined ? file.flags.buffered : 1,
     channel =
       {file: file,
        offset: file.flags.append ? file.length() : 0,
        fd: fd,
        opened: true,
        out: true,
        buffer_curr: 0,
        buffer: new Uint8Array(65536),
        buffered: buffered};
    caml_ml_channels[channel.fd] = channel;
    return channel.fd;
   }
   function caml_ml_out_channels_list(){
    var l = 0;
    for(var c = 0; c < caml_ml_channels.length; c++)
     if
      (caml_ml_channels[c] && caml_ml_channels[c].opened
       && caml_ml_channels[c].out)
      l = [0, caml_ml_channels[c].fd, l];
    return l;
   }
   function caml_ml_output_ta(chanid, buffer, offset, len){
    var chan = caml_ml_channel_get(chanid);
    if(! chan.opened)
     caml_raise_sys_error("Cannot output to a closed channel");
    buffer = buffer.subarray(offset, offset + len);
    if(chan.buffer_curr + buffer.length > chan.buffer.length){
     var b = new Uint8Array(chan.buffer_curr + buffer.length);
     b.set(chan.buffer);
     chan.buffer = b;
    }
    switch(chan.buffered){
      case 0:
       chan.buffer.set(buffer, chan.buffer_curr);
       chan.buffer_curr += buffer.length;
       caml_ml_flush(chanid);
       break;
      case 1:
       chan.buffer.set(buffer, chan.buffer_curr);
       chan.buffer_curr += buffer.length;
       if(chan.buffer_curr >= chan.buffer.length) caml_ml_flush(chanid);
       break;
      case 2:
       var id = buffer.lastIndexOf(10);
       if(id < 0){
        chan.buffer.set(buffer, chan.buffer_curr);
        chan.buffer_curr += buffer.length;
        if(chan.buffer_curr >= chan.buffer.length) caml_ml_flush(chanid);
       }
       else{
        chan.buffer.set(buffer.subarray(0, id + 1), chan.buffer_curr);
        chan.buffer_curr += id + 1;
        caml_ml_flush(chanid);
        chan.buffer.set(buffer.subarray(id + 1), chan.buffer_curr);
        chan.buffer_curr += buffer.length - id - 1;
       }
       break;
    }
    return 0;
   }
   function caml_ml_output_bytes(chanid, buffer, offset, len){
    var buffer = caml_uint8_array_of_bytes(buffer);
    return caml_ml_output_ta(chanid, buffer, offset, len);
   }
   function caml_ml_output(chanid, buffer, offset, len){
    return caml_ml_output_bytes
            (chanid, caml_bytes_of_string(buffer), offset, len);
   }
   function caml_ml_output_bigarray(chanid, buffer, offset, len){
    var buffer = caml_ba_to_typed_array(buffer);
    return caml_ml_output_ta(chanid, buffer, offset, len);
   }
   function caml_ml_output_char(chanid, c){
    var s = caml_string_of_jsbytes(String.fromCharCode(c));
    caml_ml_output(chanid, s, 0, 1);
    return 0;
   }
   function caml_ml_output_int(chanid, i){
    var
     arr = [i >> 24 & 0xFF, i >> 16 & 0xFF, i >> 8 & 0xFF, i & 0xFF],
     s = caml_string_of_array(arr);
    caml_ml_output(chanid, s, 0, 4);
    return 0;
   }
   function caml_pos_in(chanid){
    var chan = caml_ml_channel_get(chanid);
    return chan.offset - (chan.buffer_max - chan.buffer_curr) | 0;
   }
   function caml_ml_pos_in(chanid){return caml_pos_in(chanid);}
   function caml_ml_pos_in_64(chanid){
    return caml_int64_of_float(caml_pos_in(chanid));
   }
   function caml_pos_out(chanid){
    var chan = caml_ml_channel_get(chanid);
    return chan.offset + chan.buffer_curr;
   }
   function caml_ml_pos_out(chanid){return caml_pos_out(chanid);}
   function caml_ml_pos_out_64(chanid){
    return caml_int64_of_float(caml_pos_out(chanid));
   }
   function caml_ml_runtime_events_pause(){return 0;}
   function caml_ml_runtime_events_resume(){return 0;}
   function caml_ml_runtime_events_start(){return 0;}
   function caml_ml_runtime_warnings_enabled(_unit){return caml_runtime_warnings;
   }
   function caml_seek_in(chanid, pos){
    var chan = caml_ml_channel_get(chanid);
    if(chan.refill != null) caml_raise_sys_error("Illegal seek");
    if
     (pos >= chan.offset - chan.buffer_max && pos <= chan.offset
      && chan.file.flags.binary)
     chan.buffer_curr = chan.buffer_max - (chan.offset - pos);
    else{chan.offset = pos; chan.buffer_curr = 0; chan.buffer_max = 0;}
    return 0;
   }
   function caml_ml_seek_in(chanid, pos){return caml_seek_in(chanid, pos);}
   function caml_ml_seek_in_64(chanid, pos){
    var pos = caml_int64_to_float(pos);
    return caml_seek_in(chanid, pos);
   }
   function caml_seek_out(chanid, pos){
    caml_ml_flush(chanid);
    var chan = caml_ml_channel_get(chanid);
    chan.offset = pos;
    return 0;
   }
   function caml_ml_seek_out(chanid, pos){return caml_seek_out(chanid, pos);}
   function caml_ml_seek_out_64(chanid, pos){
    var pos = caml_int64_to_float(pos);
    return caml_seek_out(chanid, pos);
   }
   function caml_ml_set_binary_mode(chanid, mode){
    var chan = caml_ml_channel_get(chanid);
    chan.file.flags.text = ! mode;
    chan.file.flags.binary = mode;
    return 0;
   }
   function caml_ml_set_buffered(chanid, v){
    caml_ml_channel_get(chanid).buffered = v;
    if(! v) caml_ml_flush(chanid);
    return 0;
   }
   function caml_ml_set_channel_name(chanid, name){
    var chan = caml_ml_channel_get(chanid);
    chan.name = name;
    return 0;
   }
   function caml_ml_set_channel_output(chanid, f){
    var chan = caml_ml_channel_get(chanid);
    chan.output = function(s){f(s);};
    return 0;
   }
   function caml_ml_set_channel_refill(chanid, f){
    caml_ml_channel_get(chanid).refill = f;
    return 0;
   }
   function caml_mod(x, y){if(y == 0) caml_raise_zero_divide(); return x % y;}
   function caml_modf_float(x){
    if(isFinite(x)){
     var neg = 1 / x < 0;
     x = Math.abs(x);
     var i = Math.floor(x), f = x - i;
     if(neg){i = - i; f = - f;}
     return [0, f, i];
    }
    if(isNaN(x)) return [0, NaN, NaN];
    return [0, 1 / x, x];
   }
   function caml_mount_autoload(name, f){
    var
     path = caml_make_path(name),
     name = caml_trailing_slash(path.join("/"));
    jsoo_mount_point.push({path: name, device: new MlFakeDevice(name, f)});
    return 0;
   }
   function caml_lex_run_mem(s, i, mem, curr_pos){
    for(;;){
     var dst = s.charCodeAt(i);
     i++;
     if(dst == 0xff) return;
     var src = s.charCodeAt(i);
     i++;
     if(src == 0xff)
      mem[dst + 1] = curr_pos;
     else
      mem[dst + 1] = mem[src + 1];
    }
   }
   function caml_lex_run_tag(s, i, mem){
    for(;;){
     var dst = s.charCodeAt(i);
     i++;
     if(dst == 0xff) return;
     var src = s.charCodeAt(i);
     i++;
     if(src == 0xff) mem[dst + 1] = - 1; else mem[dst + 1] = mem[src + 1];
    }
   }
   function caml_new_lex_engine(tbl, start_state, lexbuf){
    var
     lex_buffer = 2,
     lex_buffer_len = 3,
     lex_start_pos = 5,
     lex_curr_pos = 6,
     lex_last_pos = 7,
     lex_last_action = 8,
     lex_eof_reached = 9,
     lex_mem = 10,
     lex_base = 1,
     lex_backtrk = 2,
     lex_default = 3,
     lex_trans = 4,
     lex_check = 5,
     lex_base_code = 6,
     lex_backtrk_code = 7,
     lex_default_code = 8,
     lex_trans_code = 9,
     lex_check_code = 10,
     lex_code = 11;
    if(! tbl.lex_default){
     tbl.lex_base = caml_lex_array(tbl[lex_base]);
     tbl.lex_backtrk = caml_lex_array(tbl[lex_backtrk]);
     tbl.lex_check = caml_lex_array(tbl[lex_check]);
     tbl.lex_trans = caml_lex_array(tbl[lex_trans]);
     tbl.lex_default = caml_lex_array(tbl[lex_default]);
    }
    if(! tbl.lex_default_code){
     tbl.lex_base_code = caml_lex_array(tbl[lex_base_code]);
     tbl.lex_backtrk_code = caml_lex_array(tbl[lex_backtrk_code]);
     tbl.lex_check_code = caml_lex_array(tbl[lex_check_code]);
     tbl.lex_trans_code = caml_lex_array(tbl[lex_trans_code]);
     tbl.lex_default_code = caml_lex_array(tbl[lex_default_code]);
    }
    if(tbl.lex_code == null)
     tbl.lex_code = caml_jsbytes_of_string(tbl[lex_code]);
    var
     c,
     state = start_state,
     buffer = caml_uint8_array_of_bytes(lexbuf[lex_buffer]);
    if(state >= 0){
     lexbuf[lex_last_pos] = lexbuf[lex_start_pos] = lexbuf[lex_curr_pos];
     lexbuf[lex_last_action] = - 1;
    }
    else
     state = - state - 1;
    for(;;){
     var base = tbl.lex_base[state];
     if(base < 0){
      var pc_off = tbl.lex_base_code[state];
      caml_lex_run_tag(tbl.lex_code, pc_off, lexbuf[lex_mem]);
      return - base - 1;
     }
     var backtrk = tbl.lex_backtrk[state];
     if(backtrk >= 0){
      var pc_off = tbl.lex_backtrk_code[state];
      caml_lex_run_tag(tbl.lex_code, pc_off, lexbuf[lex_mem]);
      lexbuf[lex_last_pos] = lexbuf[lex_curr_pos];
      lexbuf[lex_last_action] = backtrk;
     }
     if(lexbuf[lex_curr_pos] >= lexbuf[lex_buffer_len])
      if(lexbuf[lex_eof_reached] == 0) return - state - 1; else c = 256;
     else{c = buffer[lexbuf[lex_curr_pos]]; lexbuf[lex_curr_pos]++;}
     var pstate = state;
     if(tbl.lex_check[base + c] == state)
      state = tbl.lex_trans[base + c];
     else
      state = tbl.lex_default[state];
     if(state < 0){
      lexbuf[lex_curr_pos] = lexbuf[lex_last_pos];
      if(lexbuf[lex_last_action] == - 1)
       caml_failwith("lexing: empty token");
      else
       return lexbuf[lex_last_action];
     }
     else{
      var base_code = tbl.lex_base_code[pstate], pc_off;
      if(tbl.lex_check_code[base_code + c] == pstate)
       pc_off = tbl.lex_trans_code[base_code + c];
      else
       pc_off = tbl.lex_default_code[pstate];
      if(pc_off > 0)
       caml_lex_run_mem
        (tbl.lex_code, pc_off, lexbuf[lex_mem], lexbuf[lex_curr_pos]);
      if(c == 256) lexbuf[lex_eof_reached] = 0;
     }
    }
   }
   function caml_nextafter_float(x, y){
    if(isNaN(x) || isNaN(y)) return NaN;
    if(x == y) return y;
    if(x == 0) return y < 0 ? - Math.pow(2, - 1074) : Math.pow(2, - 1074);
    var bits = caml_int64_bits_of_float(x), one = caml_int64_of_int32(1);
    if(x < y == x > 0)
     bits = caml_int64_add(bits, one);
    else
     bits = caml_int64_sub(bits, one);
    return caml_int64_float_of_bits(bits);
   }
   function caml_notequal(x, y){
    return + (caml_compare_val(x, y, false) != 0);
   }
   function caml_obj_add_offset(v, offset){
    caml_failwith("Obj.add_offset is not supported");
   }
   function caml_obj_block(tag, size){
    var o = new Array(size + 1);
    o[0] = tag;
    for(var i = 1; i <= size; i++) o[i] = 0;
    return o;
   }
   function caml_obj_compare_and_swap(x, i, old, n){
    if(x[i + 1] == old){x[i + 1] = n; return 1;}
    return 0;
   }
   function caml_obj_is_block(x){return + (x instanceof Array);}
   function caml_obj_is_shared(x){return 1;}
   function caml_obj_make_forward(b, v){b[0] = 250; b[1] = v; return 0;}
   function caml_obj_raw_field(o, i){return o[i + 1];}
   function caml_obj_reachable_words(o){return 0;}
   function caml_obj_set_raw_field(o, i, v){return o[i + 1] = v;}
   function caml_obj_set_tag(x, tag){x[0] = tag; return 0;}
   function caml_obj_truncate(x, s){
    if(s <= 0 || s + 1 > x.length) caml_invalid_argument("Obj.truncate");
    if(x.length != s + 1) x.length = s + 1;
    return 0;
   }
   function caml_obj_with_tag(tag, x){
    var l = x.length, a = new Array(l);
    a[0] = tag;
    for(var i = 1; i < l; i++) a[i] = x[i];
    return a;
   }
   function caml_ojs_new_arr(c, a){
    switch(a.length){
      case 0:
       return new c;
      case 1:
       return new c(a[0]);
      case 2:
       return new c(a[0], a[1]);
      case 3:
       return new c(a[0], a[1], a[2]);
      case 4:
       return new c(a[0], a[1], a[2], a[3]);
      case 5:
       return new c(a[0], a[1], a[2], a[3], a[4]);
      case 6:
       return new c(a[0], a[1], a[2], a[3], a[4], a[5]);
      case 7:
       return new c(a[0], a[1], a[2], a[3], a[4], a[5], a[6]);
    }
    function F(){return c.apply(this, a);}
    F.prototype = c.prototype;
    return new F;
   }
   var
    caml_output_val =
      function(){
        function Writer(){this.chunk = [];}
        Writer.prototype =
         {chunk_idx: 20,
          block_len: 0,
          obj_counter: 0,
          size_32: 0,
          size_64: 0,
          write:
          function(size, value){
           for(var i = size - 8; i >= 0; i -= 8)
            this.chunk[this.chunk_idx++] = value >> i & 0xFF;
          },
          write_at:
          function(pos, size, value){
           var pos = pos;
           for(var i = size - 8; i >= 0; i -= 8)
            this.chunk[pos++] = value >> i & 0xFF;
          },
          write_code:
          function(size, code, value){
           this.chunk[this.chunk_idx++] = code;
           for(var i = size - 8; i >= 0; i -= 8)
            this.chunk[this.chunk_idx++] = value >> i & 0xFF;
          },
          write_shared:
          function(offset){
           if(offset < 1 << 8)
            this.write_code(8, 0x04, offset);
           else if(offset < 1 << 16)
            this.write_code(16, 0x05, offset);
           else
            this.write_code(32, 0x06, offset);
          },
          pos: function(){return this.chunk_idx;},
          finalize:
          function(){
           this.block_len = this.chunk_idx - 20;
           this.chunk_idx = 0;
           this.write(32, 0x8495A6BE);
           this.write(32, this.block_len);
           this.write(32, this.obj_counter);
           this.write(32, this.size_32);
           this.write(32, this.size_64);
           return this.chunk;
          }};
        return function(v, flags){
         flags = caml_list_to_js_array(flags);
         var
          no_sharing = flags.indexOf(0) !== - 1,
          closures = flags.indexOf(1) !== - 1;
         if(closures)
          console.warn
           ("in caml_output_val: flag Marshal.Closures is not supported.");
         var
          writer = new Writer(),
          stack = [],
          intern_obj_table = no_sharing ? null : new MlObjectTable();
         function memo(v){
          if(no_sharing) return false;
          var existing_offset = intern_obj_table.recall(v);
          if(existing_offset){
           writer.write_shared(existing_offset);
           return true;
          }
          else{intern_obj_table.store(v); return false;}
         }
         function extern_rec(v){
          if(v.caml_custom){
           if(memo(v)) return;
           var
            name = v.caml_custom,
            ops = caml_custom_ops[name],
            sz_32_64 = [0, 0];
           if(! ops.serialize)
            caml_invalid_argument("output_value: abstract value (Custom)");
           if(ops.fixed_length == undefined){
            writer.write(8, 0x18);
            for(var i = 0; i < name.length; i++)
             writer.write(8, name.charCodeAt(i));
            writer.write(8, 0);
            var header_pos = writer.pos();
            for(var i = 0; i < 12; i++) writer.write(8, 0);
            ops.serialize(writer, v, sz_32_64);
            writer.write_at(header_pos, 32, sz_32_64[0]);
            writer.write_at(header_pos + 4, 32, 0);
            writer.write_at(header_pos + 8, 32, sz_32_64[1]);
           }
           else{
            writer.write(8, 0x19);
            for(var i = 0; i < name.length; i++)
             writer.write(8, name.charCodeAt(i));
            writer.write(8, 0);
            var old_pos = writer.pos();
            ops.serialize(writer, v, sz_32_64);
            if(ops.fixed_length != writer.pos() - old_pos)
             caml_failwith
              ("output_value: incorrect fixed sizes specified by " + name);
           }
           writer.size_32 += 2 + (sz_32_64[0] + 3 >> 2);
           writer.size_64 += 2 + (sz_32_64[1] + 7 >> 3);
          }
          else if(v instanceof Array && v[0] === (v[0] | 0)){
           if(v[0] == 251)
            caml_failwith("output_value: abstract value (Abstract)");
           if(caml_is_continuation_tag(v[0]))
            caml_invalid_argument("output_value: continuation value");
           if(v.length > 1 && memo(v)) return;
           if(v[0] < 16 && v.length - 1 < 8)
            writer.write(8, 0x80 + v[0] + (v.length - 1 << 4));
           else
            writer.write_code(32, 0x08, v.length - 1 << 10 | v[0]);
           writer.size_32 += v.length;
           writer.size_64 += v.length;
           if(v.length > 1) stack.push(v, 1);
          }
          else if(caml_is_ml_bytes(v)){
           if(! caml_is_ml_bytes(caml_string_of_jsbytes("")))
            caml_failwith
             ("output_value: [Bytes.t] cannot safely be marshaled with [--enable use-js-string]");
           if(memo(v)) return;
           var len = caml_ml_bytes_length(v);
           if(len < 0x20)
            writer.write(8, 0x20 + len);
           else if(len < 0x100)
            writer.write_code(8, 0x09, len);
           else
            writer.write_code(32, 0x0A, len);
           for(var i = 0; i < len; i++)
            writer.write(8, caml_bytes_unsafe_get(v, i));
           writer.size_32 += 1 + ((len + 4) / 4 | 0);
           writer.size_64 += 1 + ((len + 8) / 8 | 0);
          }
          else if(caml_is_ml_string(v)){
           if(memo(v)) return;
           var len = caml_ml_string_length(v);
           if(len < 0x20)
            writer.write(8, 0x20 + len);
           else if(len < 0x100)
            writer.write_code(8, 0x09, len);
           else
            writer.write_code(32, 0x0A, len);
           for(var i = 0; i < len; i++)
            writer.write(8, caml_string_unsafe_get(v, i));
           writer.size_32 += 1 + ((len + 4) / 4 | 0);
           writer.size_64 += 1 + ((len + 8) / 8 | 0);
          }
          else if(v != (v | 0)){
           var type_of_v = typeof v;
           if(type_of_v != "number")
            caml_failwith("output_value: abstract value (" + type_of_v + ")");
           if(memo(v)) return;
           var t = caml_int64_to_bytes(caml_int64_bits_of_float(v));
           writer.write(8, 0x0C);
           for(var i = 0; i < 8; i++) writer.write(8, t[7 - i]);
           writer.size_32 += 3;
           writer.size_64 += 2;
          }
          else if(v >= 0 && v < 0x40)
           writer.write(8, 0X40 + v);
          else if(v >= - (1 << 7) && v < 1 << 7)
           writer.write_code(8, 0x00, v);
          else if(v >= - (1 << 15) && v < 1 << 15)
           writer.write_code(16, 0x01, v);
          else
           writer.write_code(32, 0x02, v);
         }
         extern_rec(v);
         while(stack.length > 0){
          var i = stack.pop(), v = stack.pop();
          if(i + 1 < v.length) stack.push(v, i + 1);
          extern_rec(v[i]);
         }
         if(intern_obj_table)
          writer.obj_counter = intern_obj_table.objs.length;
         writer.finalize();
         return writer.chunk;};
       }
       ();
   function caml_output_value_to_string(v, flags){
    return caml_string_of_array(caml_output_val(v, flags));
   }
   function caml_output_value(chanid, v, flags){
    var s = caml_output_value_to_string(v, flags);
    caml_ml_output(chanid, s, 0, caml_ml_string_length(s));
    return 0;
   }
   function caml_output_value_to_buffer(s, ofs, len, v, flags){
    var t = caml_output_val(v, flags);
    if(t.length > len) caml_failwith("Marshal.to_buffer: buffer overflow");
    caml_blit_bytes(t, 0, s, ofs, t.length);
    return 0;
   }
   function caml_output_value_to_bytes(v, flags){
    return caml_bytes_of_array(caml_output_val(v, flags));
   }
   var caml_parser_trace = 0;
   function caml_parse_engine(tables, env, cmd, arg){
    var
     ERRCODE = 256,
     loop = 6,
     testshift = 7,
     shift = 8,
     shift_recover = 9,
     reduce = 10,
     READ_TOKEN = 0,
     RAISE_PARSE_ERROR = 1,
     GROW_STACKS_1 = 2,
     GROW_STACKS_2 = 3,
     COMPUTE_SEMANTIC_ACTION = 4,
     CALL_ERROR_FUNCTION = 5,
     env_s_stack = 1,
     env_v_stack = 2,
     env_symb_start_stack = 3,
     env_symb_end_stack = 4,
     env_stacksize = 5,
     env_stackbase = 6,
     env_curr_char = 7,
     env_lval = 8,
     env_symb_start = 9,
     env_symb_end = 10,
     env_asp = 11,
     env_rule_len = 12,
     env_rule_number = 13,
     env_sp = 14,
     env_state = 15,
     env_errflag = 16,
     tbl_transl_const = 2,
     tbl_transl_block = 3,
     tbl_lhs = 4,
     tbl_len = 5,
     tbl_defred = 6,
     tbl_dgoto = 7,
     tbl_sindex = 8,
     tbl_rindex = 9,
     tbl_gindex = 10,
     tbl_tablesize = 11,
     tbl_table = 12,
     tbl_check = 13,
     tbl_names_const = 15,
     tbl_names_block = 16;
    function log(x){
     var s = caml_string_of_jsbytes(x + "\n");
     caml_ml_output(2, s, 0, caml_ml_string_length(s));
    }
    function token_name(names, number){
     var str = caml_jsstring_of_string(names);
     if(str[0] == "\x00") return "<unknown token>";
     return str.split("\x00")[number];
    }
    function print_token(state, tok){
     var token, kind;
     if(tok instanceof Array){
      token = token_name(tables[tbl_names_block], tok[0]);
      if(typeof tok[1] == "number")
       kind = "" + tok[1];
      else if(typeof tok[1] == "string")
       kind = tok[1];
      else if(tok[1] instanceof MlBytes)
       kind = caml_jsbytes_of_string(tok[1]);
      else
       kind = "_";
      log("State " + state + ": read token " + token + "(" + kind + ")");
     }
     else{
      token = token_name(tables[tbl_names_const], tok);
      log("State " + state + ": read token " + token);
     }
    }
    if(! tables.dgoto){
     tables.defred = caml_lex_array(tables[tbl_defred]);
     tables.sindex = caml_lex_array(tables[tbl_sindex]);
     tables.check = caml_lex_array(tables[tbl_check]);
     tables.rindex = caml_lex_array(tables[tbl_rindex]);
     tables.table = caml_lex_array(tables[tbl_table]);
     tables.len = caml_lex_array(tables[tbl_len]);
     tables.lhs = caml_lex_array(tables[tbl_lhs]);
     tables.gindex = caml_lex_array(tables[tbl_gindex]);
     tables.dgoto = caml_lex_array(tables[tbl_dgoto]);
    }
    var
     res = 0,
     n,
     n1,
     n2,
     state1,
     sp = env[env_sp],
     state = env[env_state],
     errflag = env[env_errflag];
    exit:
    for(;;)
     next:
     switch(cmd){
       case 0:
        state = 0; errflag = 0;
       case 6:
        n = tables.defred[state];
        if(n != 0){cmd = reduce; break;}
        if(env[env_curr_char] >= 0){cmd = testshift; break;}
        res = READ_TOKEN;
        break exit;
       case 1:
        if(arg instanceof Array){
         env[env_curr_char] = tables[tbl_transl_block][arg[0] + 1];
         env[env_lval] = arg[1];
        }
        else{
         env[env_curr_char] = tables[tbl_transl_const][arg + 1];
         env[env_lval] = 0;
        }
        if(caml_parser_trace) print_token(state, arg);
       case 7:
        n1 = tables.sindex[state];
        n2 = n1 + env[env_curr_char];
        if
         (n1 != 0 && n2 >= 0 && n2 <= tables[tbl_tablesize]
          && tables.check[n2] == env[env_curr_char]){cmd = shift; break;}
        n1 = tables.rindex[state];
        n2 = n1 + env[env_curr_char];
        if
         (n1 != 0 && n2 >= 0 && n2 <= tables[tbl_tablesize]
          && tables.check[n2] == env[env_curr_char]){
         n = tables.table[n2];
         cmd = reduce;
         break;
        }
        if(errflag <= 0){res = CALL_ERROR_FUNCTION; break exit;}
       case 5:
        if(errflag < 3){
         errflag = 3;
         for(;;){
          state1 = env[env_s_stack][sp + 1];
          n1 = tables.sindex[state1];
          n2 = n1 + ERRCODE;
          if
           (n1 != 0 && n2 >= 0 && n2 <= tables[tbl_tablesize]
            && tables.check[n2] == ERRCODE){
           if(caml_parser_trace) log("Recovering in state " + state1);
           cmd = shift_recover;
           break next;
          }
          else{
           if(caml_parser_trace) log("Discarding state " + state1);
           if(sp <= env[env_stackbase]){
            if(caml_parser_trace) log("No more states to discard");
            return RAISE_PARSE_ERROR;
           }
           sp--;
          }
         }
        }
        else{
         if(env[env_curr_char] == 0) return RAISE_PARSE_ERROR;
         if(caml_parser_trace) log("Discarding last token read");
         env[env_curr_char] = - 1;
         cmd = loop;
         break;
        }
       case 8:
        env[env_curr_char] = - 1; if(errflag > 0) errflag--;
       case 9:
        if(caml_parser_trace)
         log("State " + state + ": shift to state " + tables.table[n2]);
        state = tables.table[n2];
        sp++;
        if(sp >= env[env_stacksize]){res = GROW_STACKS_1; break exit;}
       case 2:
        env[env_s_stack][sp + 1] = state;
        env[env_v_stack][sp + 1] = env[env_lval];
        env[env_symb_start_stack][sp + 1] = env[env_symb_start];
        env[env_symb_end_stack][sp + 1] = env[env_symb_end];
        cmd = loop;
        break;
       case 10:
        if(caml_parser_trace) log("State " + state + ": reduce by rule " + n);
        var m = tables.len[n];
        env[env_asp] = sp;
        env[env_rule_number] = n;
        env[env_rule_len] = m;
        sp = sp - m + 1;
        m = tables.lhs[n];
        state1 = env[env_s_stack][sp];
        n1 = tables.gindex[m];
        n2 = n1 + state1;
        if
         (n1 != 0 && n2 >= 0 && n2 <= tables[tbl_tablesize]
          && tables.check[n2] == state1)
         state = tables.table[n2];
        else
         state = tables.dgoto[m];
        if(sp >= env[env_stacksize]){res = GROW_STACKS_2; break exit;}
       case 3:
        res = COMPUTE_SEMANTIC_ACTION; break exit;
       case 4:
        env[env_s_stack][sp + 1] = state;
        env[env_v_stack][sp + 1] = arg;
        var asp = env[env_asp];
        env[env_symb_end_stack][sp + 1] = env[env_symb_end_stack][asp + 1];
        if(sp > asp)
         env[env_symb_start_stack][sp + 1] = env[env_symb_end_stack][asp + 1];
        cmd = loop;
        break;
       default: return RAISE_PARSE_ERROR;
     }
    env[env_sp] = sp;
    env[env_state] = state;
    env[env_errflag] = errflag;
    return res;
   }
   function caml_pure_js_expr(s){
    console.error("caml_pure_js_expr: fallback to runtime evaluation\n");
    return eval(caml_jsstring_of_string(s));
   }
   function caml_raise_not_a_dir(name){
    caml_raise_sys_error(name + ": Not a directory");
   }
   function caml_raise_not_found(){
    caml_raise_constant(caml_global_data.Not_found);
   }
   function caml_raw_backtrace_length(){return 0;}
   function caml_raw_backtrace_next_slot(){return 0;}
   function caml_raw_backtrace_slot(){
    caml_invalid_argument
     ("Printexc.get_raw_backtrace_slot: index out of bounds");
   }
   function caml_recommended_domain_count(unit){return 1;}
   function caml_record_backtrace(b){
    caml_record_backtrace_flag = b;
    return 0;
   }
   function caml_register_channel_for_spacetime(_channel){return 0;}
   function caml_register_global(n, v, name_opt){
    if(name_opt){
     var name = name_opt;
     if(globalThis.toplevelReloc)
      n = caml_callback(globalThis.toplevelReloc, [name]);
     else if(caml_global_data.symbols){
      if(! caml_global_data.symidx)
       caml_global_data.symidx = caml_build_symbols(caml_global_data.symbols);
      var nid = caml_global_data.symidx[name];
      if(nid >= 0)
       n = nid;
      else
       caml_failwith("caml_register_global: cannot locate " + name);
     }
    }
    caml_global_data[n + 1] = v;
    if(name_opt) caml_global_data[name_opt] = v;
   }
   function caml_register_named_value(nm, v){
    caml_named_values[caml_jsbytes_of_string(nm)] = v;
    return 0;
   }
   function caml_restore_raw_backtrace(exn, bt){return 0;}
   function caml_round_float(x){
    if(x >= 0){
     var y = Math.floor(x);
     return x - y >= 0.5 ? y + 1 : y;
    }
    else{var y = Math.ceil(x); return y - x >= 0.5 ? y - 1 : y;}
   }
   function caml_runtime_events_create_cursor(target){return {};}
   function caml_runtime_events_free_cursor(cursor){return 0;}
   function caml_runtime_events_read_poll(cursor, callbacks, num){return 0;}
   function caml_runtime_events_user_register
   (event_name, event_tag, event_type){
    caml_custom_event_index += 1;
    return [0, caml_custom_event_index, event_name, event_type, event_tag];
   }
   function caml_runtime_events_user_resolve(){return 0;}
   function caml_runtime_events_user_write(event, event_content){return 0;}
   function caml_runtime_parameters(_unit){return caml_string_of_jsbytes("");}
   function caml_runtime_variant(_unit){return caml_string_of_jsbytes("");}
   function caml_set_oo_id(b){b[2] = caml_oo_last_id++; return b;}
   function caml_set_parser_trace(bool){
    var oldflag = caml_parser_trace;
    caml_parser_trace = bool;
    return oldflag;
   }
   function caml_set_static_env(k, v){
    if(! globalThis.jsoo_static_env) globalThis.jsoo_static_env = {};
    globalThis.jsoo_static_env[k] = v;
    return 0;
   }
   function caml_signbit_float(x){if(x == 0) x = 1 / x; return x < 0 ? 1 : 0;}
   function caml_sinh_float(x){return Math.sinh(x);}
   function caml_spacetime_enabled(_unit){return 0;}
   function caml_spacetime_only_works_for_native_code(){
    caml_failwith("Spacetime profiling only works for native code");
   }
   function caml_str_initialize(unit){return 0;}
   function caml_string_bound_error(){
    caml_invalid_argument("index out of bounds");
   }
   function caml_string_concat(a, b){return a + b;}
   function caml_string_equal(s1, s2){if(s1 === s2) return 1; return 0;}
   function caml_string_get(s, i){
    if(i >>> 0 >= caml_ml_string_length(s)) caml_string_bound_error();
    return caml_string_unsafe_get(s, i);
   }
   function caml_string_get16(s, i){
    if(i >>> 0 >= caml_ml_string_length(s) - 1) caml_string_bound_error();
    var
     b1 = caml_string_unsafe_get(s, i),
     b2 = caml_string_unsafe_get(s, i + 1);
    return b2 << 8 | b1;
   }
   function caml_string_get32(s, i){
    if(i >>> 0 >= caml_ml_string_length(s) - 3) caml_string_bound_error();
    var
     b1 = caml_string_unsafe_get(s, i),
     b2 = caml_string_unsafe_get(s, i + 1),
     b3 = caml_string_unsafe_get(s, i + 2),
     b4 = caml_string_unsafe_get(s, i + 3);
    return b4 << 24 | b3 << 16 | b2 << 8 | b1;
   }
   function caml_string_get64(s, i){
    if(i >>> 0 >= caml_ml_string_length(s) - 7) caml_string_bound_error();
    var a = new Array(8);
    for(var j = 0; j < 8; j++) a[7 - j] = caml_string_unsafe_get(s, i + j);
    return caml_int64_of_bytes(a);
   }
   function caml_string_lessequal(s1, s2){return s1 <= s2 ? 1 : 0;}
   function caml_string_greaterequal(s1, s2){return caml_string_lessequal(s2, s1);
   }
   function caml_string_lessthan(s1, s2){return s1 < s2 ? 1 : 0;}
   function caml_string_greaterthan(s1, s2){return caml_string_lessthan(s2, s1);
   }
   function caml_string_hash(h, v){
    var h = caml_hash_mix_string(h, v), h = caml_hash_mix_final(h);
    return h & 0x3FFFFFFF;
   }
   function caml_string_notequal(s1, s2){
    return 1 - caml_string_equal(s1, s2);
   }
   function caml_string_set(s, i, c){caml_failwith("caml_string_set");}
   function caml_string_set16(s, i, i16){caml_failwith("caml_string_set16");}
   function caml_string_set32(s, i, i32){caml_failwith("caml_string_set32");}
   function caml_string_set64(s, i, i64){caml_failwith("caml_string_set64");}
   function caml_string_unsafe_set(s, i, c){
    caml_failwith("caml_string_unsafe_set");
   }
   function caml_sys_argv(a){return caml_argv;}
   function caml_sys_chdir(dir){
    var root = resolve_fs_device(dir);
    if(root.device.exists(root.rest)){
     if(root.rest)
      caml_current_dir = caml_trailing_slash(root.path + root.rest);
     else
      caml_current_dir = root.path;
     return 0;
    }
    else
     caml_raise_no_such_file(caml_jsbytes_of_string(dir));
   }
   function caml_sys_const_backend_type(){
    return [0, caml_string_of_jsbytes("js_of_ocaml")];
   }
   function caml_sys_const_big_endian(){return 0;}
   function caml_sys_const_int_size(){return 32;}
   function caml_sys_const_max_wosize(){return 0x7FFFFFFF / 4 | 0;}
   function caml_sys_const_naked_pointers_checked(_unit){return 0;}
   var
    os_type =
      globalThis.process && globalThis.process.platform
       && globalThis.process.platform == "win32"
       ? "Cygwin"
       : "Unix";
   function caml_sys_const_ostype_cygwin(){return os_type == "Cygwin" ? 1 : 0;
   }
   function caml_sys_const_ostype_unix(){return os_type == "Unix" ? 1 : 0;}
   function caml_sys_const_ostype_win32(){return os_type == "Win32" ? 1 : 0;}
   function caml_sys_const_word_size(){return 32;}
   function caml_sys_executable_name(a){return caml_executable_name;}
   function caml_sys_exit(code){
    if(globalThis.quit) globalThis.quit(code);
    if(globalThis.process && globalThis.process.exit)
     globalThis.process.exit(code);
    caml_invalid_argument("Function 'exit' not implemented");
   }
   function caml_sys_file_exists(name){
    var root = resolve_fs_device(name);
    return root.device.exists(root.rest);
   }
   function caml_sys_get_argv(a){return [0, caml_argv[1], caml_argv];}
   function caml_sys_get_config(){
    return [0, caml_string_of_jsbytes(os_type), 32, 0];
   }
   function caml_sys_getcwd(){
    return caml_string_of_jsbytes(caml_current_dir);
   }
   function caml_sys_getenv(name){
    var r = jsoo_sys_getenv(caml_jsstring_of_string(name));
    if(r === undefined) caml_raise_not_found();
    return caml_string_of_jsstring(r);
   }
   function caml_sys_is_directory(name){
    var root = resolve_fs_device(name), a = root.device.is_dir(root.rest);
    return a ? 1 : 0;
   }
   function caml_sys_is_regular_file(name){
    var root = resolve_fs_device(name);
    return root.device.isFile(root.rest);
   }
   function caml_sys_isatty(_chan){return 0;}
   function caml_sys_mkdir(name, perm){
    var root = resolve_fs_device(name);
    root.device.mkdir(root.rest, perm);
    return 0;
   }
   function caml_sys_modify_argv(arg){caml_argv = arg; return 0;}
   function caml_sys_random_seed(){
    if(globalThis.crypto)
     if(globalThis.crypto.getRandomValues){
      var a = globalThis.crypto.getRandomValues(new Int32Array(4));
      return [0, a[0], a[1], a[2], a[3]];
     }
     else if(globalThis.crypto.randomBytes){
      var a = new Int32Array(globalThis.crypto.randomBytes(16).buffer);
      return [0, a[0], a[1], a[2], a[3]];
     }
    var now = new Date().getTime(), x = now ^ 0xffffffff * Math.random();
    return [0, x];
   }
   function caml_sys_read_directory(name){
    var
     root = resolve_fs_device(name),
     a = root.device.readdir(root.rest),
     l = new Array(a.length + 1);
    l[0] = 0;
    for(var i = 0; i < a.length; i++) l[i + 1] = caml_string_of_jsbytes(a[i]);
    return l;
   }
   function caml_sys_remove(name){
    var root = resolve_fs_device(name), ok = root.device.unlink(root.rest);
    if(ok == 0) caml_raise_no_such_file(caml_jsbytes_of_string(name));
    return 0;
   }
   function caml_sys_rename(o, n){
    var o_root = resolve_fs_device(o), n_root = resolve_fs_device(n);
    if(o_root.device != n_root.device)
     caml_failwith("caml_sys_rename: cannot move file between two filesystem");
    if(! o_root.device.rename)
     caml_failwith("caml_sys_rename: no implemented");
    o_root.device.rename(o_root.rest, n_root.rest);
   }
   function caml_sys_rmdir(name){
    var root = resolve_fs_device(name);
    root.device.rmdir(root.rest);
    return 0;
   }
   function caml_sys_system_command(cmd){
    var cmd = caml_jsstring_of_string(cmd);
    if(typeof require != "undefined"){
     var child_process = require("child_process");
     if(child_process && child_process.execSync)
      try{child_process.execSync(cmd, {stdio: "inherit"}); return 0;}
      catch(e){return 1;}
    }
    else
     return 127;
   }
   var caml_initial_time = new Date().getTime() * 0.001;
   function caml_sys_time(){
    var now = new Date().getTime();
    return now * 0.001 - caml_initial_time;
   }
   function caml_sys_time_include_children(b){return caml_sys_time();}
   function caml_sys_unsafe_getenv(name){return caml_sys_getenv(name);}
   function caml_tanh_float(x){return Math.tanh(x);}
   function caml_to_js_string(s){return caml_jsstring_of_string(s);}
   function caml_trampoline(res){
    var c = 1;
    while(res && res.joo_tramp){
     res = res.joo_tramp.apply(null, res.joo_args);
     c++;
    }
    return res;
   }
   function caml_trampoline_return(f, args){return {joo_tramp: f, joo_args: args};
   }
   function caml_trunc_float(x){return Math.trunc(x);}
   function caml_unix_cleanup(){}
   function caml_unix_closedir(dir_handle){
    try{dir_handle.pointer.closeSync();}
    catch(e){
     var unix_error = caml_named_value("Unix.Unix_error");
     caml_raise_with_args
      (unix_error, make_unix_err_args("EBADF", "closedir", dir_handle.path));
    }
   }
   function caml_unix_filedescr_of_fd(x){return x;}
   function caml_unix_findclose(dir_handle){return caml_unix_closedir(dir_handle);
   }
   function caml_unix_opendir(path){
    var root = resolve_fs_device(path);
    if(! root.device.opendir)
     caml_failwith("caml_unix_opendir: not implemented");
    var dir_handle = root.device.opendir(root.rest, true);
    return {pointer: dir_handle, path: path};
   }
   function caml_unix_readdir(dir_handle){
    var entry;
    try{entry = dir_handle.pointer.readSync();}
    catch(e){
     var unix_error = caml_named_value("Unix.Unix_error");
     caml_raise_with_args
      (unix_error, make_unix_err_args("EBADF", "readdir", dir_handle.path));
    }
    if(entry === null)
     caml_raise_end_of_file();
    else
     return caml_string_of_jsstring(entry.name);
   }
   function caml_unix_findfirst(path){
    var path_js = caml_jsstring_of_string(path);
    path_js = path_js.replace(/(^|[\\\/])\*\.\*$/, "");
    path = caml_string_of_jsstring(path_js);
    var
     dir_handle = caml_unix_opendir(path),
     first_entry = caml_unix_readdir(dir_handle);
    return [0, first_entry, dir_handle];
   }
   function caml_unix_findnext(dir_handle){return caml_unix_readdir(dir_handle);
   }
   function caml_unix_getpwuid(unit){caml_raise_not_found();}
   function caml_unix_gettimeofday(){return new Date().getTime() / 1000;}
   function caml_unix_getuid(unit){
    if(globalThis.process && globalThis.process.getuid)
     return globalThis.process.getuid();
    caml_raise_not_found();
   }
   function caml_unix_gmtime(t){
    var
     d = new Date(t * 1000),
     d_num = d.getTime(),
     januaryfirst = new Date(Date.UTC(d.getUTCFullYear(), 0, 1)).getTime(),
     doy = Math.floor((d_num - januaryfirst) / 86400000);
    return [0,
            d.getUTCSeconds(),
            d.getUTCMinutes(),
            d.getUTCHours(),
            d.getUTCDate(),
            d.getUTCMonth(),
            d.getUTCFullYear() - 1900,
            d.getUTCDay(),
            doy,
            false | 0];
   }
   function caml_unix_has_symlink(unit){return fs_node_supported() ? 1 : 0;}
   function caml_unix_inet_addr_of_string(){return 0;}
   function caml_unix_isatty(fileDescriptor){
    if(fs_node_supported()){
     var tty = require("tty");
     return tty.isatty(fileDescriptor) ? 1 : 0;
    }
    else
     return 0;
   }
   function caml_unix_localtime(t){
    var
     d = new Date(t * 1000),
     d_num = d.getTime(),
     januaryfirst = new Date(d.getFullYear(), 0, 1).getTime(),
     doy = Math.floor((d_num - januaryfirst) / 86400000),
     jan = new Date(d.getFullYear(), 0, 1),
     jul = new Date(d.getFullYear(), 6, 1),
     stdTimezoneOffset =
       Math.max(jan.getTimezoneOffset(), jul.getTimezoneOffset());
    return [0,
            d.getSeconds(),
            d.getMinutes(),
            d.getHours(),
            d.getDate(),
            d.getMonth(),
            d.getFullYear() - 1900,
            d.getDay(),
            doy,
            d.getTimezoneOffset() < stdTimezoneOffset | 0];
   }
   function caml_unix_lstat(name){
    var root = resolve_fs_device(name);
    if(! root.device.lstat) caml_failwith("caml_unix_lstat: not implemented");
    return root.device.lstat(root.rest, true);
   }
   function caml_unix_lstat_64(name){
    var r = caml_unix_lstat(name);
    r[9] = caml_int64_of_int32(r[9]);
    return r;
   }
   function caml_unix_mkdir(name, perm){
    var root = resolve_fs_device(name);
    if(! root.device.mkdir) caml_failwith("caml_unix_mkdir: not implemented");
    return root.device.mkdir(root.rest, perm, true);
   }
   function caml_unix_mktime(tm){
    var
     d = new Date(tm[6] + 1900, tm[5], tm[4], tm[3], tm[2], tm[1]).getTime(),
     t = Math.floor(d / 1000),
     tm2 = caml_unix_localtime(t);
    return [0, t, tm2];
   }
   function caml_unix_readlink(name){
    var root = resolve_fs_device(name);
    if(! root.device.readlink)
     caml_failwith("caml_unix_readlink: not implemented");
    return root.device.readlink(root.rest, true);
   }
   function caml_unix_rewinddir(dir_handle){
    caml_unix_closedir(dir_handle);
    var new_dir_handle = caml_unix_opendir(dir_handle.path);
    dir_handle.pointer = new_dir_handle.pointer;
    return 0;
   }
   function caml_unix_rmdir(name){
    var root = resolve_fs_device(name);
    if(! root.device.rmdir) caml_failwith("caml_unix_rmdir: not implemented");
    return root.device.rmdir(root.rest, true);
   }
   function caml_unix_startup(){}
   function caml_unix_stat(name){
    var root = resolve_fs_device(name);
    if(! root.device.stat) caml_failwith("caml_unix_stat: not implemented");
    return root.device.stat(root.rest, true);
   }
   function caml_unix_stat_64(name){
    var r = caml_unix_stat(name);
    r[9] = caml_int64_of_int32(r[9]);
    return r;
   }
   function caml_unix_symlink(to_dir, src, dst){
    var src_root = resolve_fs_device(src), dst_root = resolve_fs_device(dst);
    if(src_root.device != dst_root.device)
     caml_failwith
      ("caml_unix_symlink: cannot symlink between two filesystems");
    if(! src_root.device.symlink)
     caml_failwith("caml_unix_symlink: not implemented");
    return src_root.device.symlink(to_dir, src_root.rest, dst_root.rest, true);
   }
   function caml_unix_time(){return Math.floor(caml_unix_gettimeofday());}
   function caml_unix_unlink(name){
    var root = resolve_fs_device(name);
    if(! root.device.unlink)
     caml_failwith("caml_unix_unlink: not implemented");
    return root.device.unlink(root.rest, true);
   }
   function caml_unmount(name){
    var
     path = caml_make_path(name),
     name = caml_trailing_slash(path.join("/")),
     idx = - 1;
    for(var i = 0; i < jsoo_mount_point.length; i++)
     if(jsoo_mount_point[i].path == name) idx = i;
    if(idx > - 1) jsoo_mount_point.splice(idx, 1);
    return 0;
   }
   function caml_update_dummy(x, y){
    if(y.fun){x.fun = y.fun; return 0;}
    if(typeof y === "function"){x.fun = y; return 0;}
    var i = y.length;
    while(i--) x[i] = y[i];
    return 0;
   }
   function caml_weak_set(x, i, v){
    if(v == 0) caml_ephe_unset_key(x, i); else caml_ephe_set_key(x, i, v[1]);
    return 0;
   }
   function caml_wrap_exception(e){
    {
     if(e instanceof Array) return e;
     var exn;
     if
      (globalThis.RangeError && e instanceof globalThis.RangeError
       && e.message
       && e.message.match(/maximum call stack/i))
      exn = caml_global_data.Stack_overflow;
     else if
      (globalThis.InternalError && e instanceof globalThis.InternalError
       && e.message
       && e.message.match(/too much recursion/i))
      exn = caml_global_data.Stack_overflow;
     else if(e instanceof globalThis.Error && caml_named_value("jsError"))
      exn = [0, caml_named_value("jsError"), e];
     else
      exn = [0, caml_global_data.Failure, caml_string_of_jsstring(String(e))];
     if(e instanceof globalThis.Error) exn.js_error = e;
     return exn;
    }
   }
   function caml_xmlhttprequest_create(unit){
    if(typeof globalThis.XMLHttpRequest !== "undefined")
     try{return new globalThis.XMLHttpRequest;}catch(e){}
    if(typeof globalThis.activeXObject !== "undefined"){
     try{return new globalThis.activeXObject("Msxml2.XMLHTTP");}catch(e){}
     try{return new globalThis.activeXObject("Msxml3.XMLHTTP");}catch(e){}
     try{return new globalThis.activeXObject("Microsoft.XMLHTTP");}catch(e){}
    }
    caml_failwith("Cannot create a XMLHttpRequest");
   }
   function compare_digits_nat(nat1, ofs1, nat2, ofs2){
    if(nat1.data[ofs1] > nat2.data[ofs2]) return 1;
    if(nat1.data[ofs1] < nat2.data[ofs2]) return - 1;
    return 0;
   }
   function compare_nat(nat1, ofs1, len1, nat2, ofs2, len2){
    var
     a = num_digits_nat(nat1, ofs1, len1),
     b = num_digits_nat(nat2, ofs2, len2);
    if(a > b) return 1;
    if(a < b) return - 1;
    for(var i = len1 - 1; i >= 0; i--){
     if(nat1.data[ofs1 + i] >>> 0 > nat2.data[ofs2 + i] >>> 0) return 1;
     if(nat1.data[ofs1 + i] >>> 0 < nat2.data[ofs2 + i] >>> 0) return - 1;
    }
    return 0;
   }
   function compare_nat_real(nat1, nat2){
    return compare_nat(nat1, 0, nat1.data.length, nat2, 0, nat2.data.length);
   }
   function complement_nat(nat, ofs, len){
    for(var i = 0; i < len; i++)
     nat.data[ofs + i] = (- 1 >>> 0) - (nat.data[ofs + i] >>> 0);
   }
   function create_nat(size){
    var arr = new MlNat(size);
    for(var i = 0; i < size; i++) arr.data[i] = - 1;
    return arr;
   }
   function decr_nat(nat, ofs, len, carry_in){
    var borrow = carry_in == 1 ? 0 : 1;
    for(var i = 0; i < len; i++){
     var x = (nat.data[ofs + i] >>> 0) - borrow;
     nat.data[ofs + i] = x;
     if(x >= 0){borrow = 0; break;} else borrow = 1;
    }
    return borrow == 1 ? 0 : 1;
   }
   function deserialize_nat(reader, sz){
    var len = reader.read32s(), nat = new MlNat(len);
    for(var i = 0; i < len; i++) nat.data[i] = reader.read32s();
    sz[0] = len * 4;
    return nat;
   }
   function div_helper(a, b, c){
    var
     x = a * 65536 + (b >>> 16),
     y = Math.floor(x / c) * 65536,
     z = x % c * 65536,
     w = z + (b & 0x0000FFFF);
    return [y + Math.floor(w / c), w % c];
   }
   function div_digit_nat(natq, ofsq, natr, ofsr, nat1, ofs1, len, nat2, ofs2){
    var rem = nat1.data[ofs1 + len - 1] >>> 0;
    for(var i = len - 2; i >= 0; i--){
     var
      x = div_helper(rem, nat1.data[ofs1 + i] >>> 0, nat2.data[ofs2] >>> 0);
     natq.data[ofsq + i] = x[0];
     rem = x[1];
    }
    natr.data[ofsr] = rem;
    return 0;
   }
   function num_leading_zero_bits_in_digit(nat, ofs){
    var a = nat.data[ofs], b = 0;
    if(a & 0xFFFF0000){b += 16; a >>>= 16;}
    if(a & 0xFF00){b += 8; a >>>= 8;}
    if(a & 0xF0){b += 4; a >>>= 4;}
    if(a & 12){b += 2; a >>>= 2;}
    if(a & 2){b += 1; a >>>= 1;}
    if(a & 1) b += 1;
    return 32 - b;
   }
   function shift_left_nat(nat1, ofs1, len1, nat2, ofs2, nbits){
    if(nbits == 0){nat2.data[ofs2] = 0; return 0;}
    var wrap = 0;
    for(var i = 0; i < len1; i++){
     var a = nat1.data[ofs1 + i] >>> 0;
     nat1.data[ofs1 + i] = a << nbits | wrap;
     wrap = a >>> 32 - nbits;
    }
    nat2.data[ofs2] = wrap;
    return 0;
   }
   function shift_right_nat(nat1, ofs1, len1, nat2, ofs2, nbits){
    if(nbits == 0){nat2.data[ofs2] = 0; return 0;}
    var wrap = 0;
    for(var i = len1 - 1; i >= 0; i--){
     var a = nat1.data[ofs1 + i] >>> 0;
     nat1.data[ofs1 + i] = a >>> nbits | wrap;
     wrap = a << 32 - nbits;
    }
    nat2.data[ofs2] = wrap;
    return 0;
   }
   function set_to_zero_nat(nat, ofs, len){
    for(var i = 0; i < len; i++) nat.data[ofs + i] = 0;
    return 0;
   }
   function nat_of_array(l){return new MlNat(l);}
   function mult_digit_nat(nat1, ofs1, len1, nat2, ofs2, len2, nat3, ofs3){
    var carry = 0, a = nat3.data[ofs3] >>> 0;
    for(var i = 0; i < len2; i++){
     var
      x1 =
        (nat1.data[ofs1 + i] >>> 0)
        + (nat2.data[ofs2 + i] >>> 0) * (a & 0x0000FFFF)
        + carry,
      x2 = (nat2.data[ofs2 + i] >>> 0) * (a >>> 16);
     carry = Math.floor(x2 / 65536);
     var x3 = x1 + x2 % 65536 * 65536;
     nat1.data[ofs1 + i] = x3;
     carry += Math.floor(x3 / 4294967296);
    }
    return len2 < len1 && carry
            ? add_nat
              (nat1, ofs1 + len2, len1 - len2, nat_of_array([carry]), 0, 1, 0)
            : carry;
   }
   function sub_nat(nat1, ofs1, len1, nat2, ofs2, len2, carry_in){
    var borrow = carry_in == 1 ? 0 : 1;
    for(var i = 0; i < len2; i++){
     var
      x = (nat1.data[ofs1 + i] >>> 0) - (nat2.data[ofs2 + i] >>> 0) - borrow;
     nat1.data[ofs1 + i] = x;
     if(x >= 0) borrow = 0; else borrow = 1;
    }
    return decr_nat(nat1, ofs1 + len2, len1 - len2, borrow == 1 ? 0 : 1);
   }
   function div_nat(nat1, ofs1, len1, nat2, ofs2, len2){
    if(len2 == 1){
     div_digit_nat(nat1, ofs1 + 1, nat1, ofs1, nat1, ofs1, len1, nat2, ofs2);
     return 0;
    }
    var s = num_leading_zero_bits_in_digit(nat2, ofs2 + len2 - 1);
    shift_left_nat(nat2, ofs2, len2, nat_of_array([0]), 0, s);
    shift_left_nat(nat1, ofs1, len1, nat_of_array([0]), 0, s);
    var d = (nat2.data[ofs2 + len2 - 1] >>> 0) + 1, a = create_nat(len2 + 1);
    for(var i = len1 - 1; i >= len2; i--){
     var
      quo =
        d == 4294967296
         ? nat1.data[ofs1 + i] >>> 0
         : div_helper
            (nat1.data[ofs1 + i] >>> 0, nat1.data[ofs1 + i - 1] >>> 0, d)
           [0];
     set_to_zero_nat(a, 0, len2 + 1);
     mult_digit_nat(a, 0, len2 + 1, nat2, ofs2, len2, nat_of_array([quo]), 0);
     sub_nat(nat1, ofs1 + i - len2, len2 + 1, a, 0, len2 + 1, 1);
     while
     (nat1.data[ofs1 + i] != 0
      || compare_nat(nat1, ofs1 + i - len2, len2, nat2, ofs2, len2) >= 0){
      quo = quo + 1;
      sub_nat(nat1, ofs1 + i - len2, len2 + 1, nat2, ofs2, len2, 1);
     }
     nat1.data[ofs1 + i] = quo;
    }
    shift_right_nat(nat1, ofs1, len2, nat_of_array([0]), 0, s);
    shift_right_nat(nat2, ofs2, len2, nat_of_array([0]), 0, s);
    return 0;
   }
   function serialize_nat(writer, nat, sz){
    var len = nat.data.length;
    writer.write(32, len);
    for(var i = 0; i < len; i++) writer.write(32, nat.data[i]);
    sz[0] = len * 4;
    sz[1] = len * 8;
   }
   function initialize_nat(){
    caml_custom_ops["_nat"] =
     {deserialize: deserialize_nat,
      serialize: serialize_nat,
      hash: caml_hash_nat};
   }
   function is_digit_int(nat, ofs){if(nat.data[ofs] >= 0) return 1; return 0;}
   function is_digit_odd(nat, ofs){if(nat.data[ofs] & 1) return 1; return 0;}
   function is_digit_zero(nat, ofs){
    if(nat.data[ofs] == 0) return 1;
    return 0;
   }
   function jsoo_create_file_extern(name, content){
    if(globalThis.jsoo_create_file)
     globalThis.jsoo_create_file(name, content);
    else{
     if(! globalThis.caml_fs_tmp) globalThis.caml_fs_tmp = [];
     globalThis.caml_fs_tmp.push({name: name, content: content});
    }
    return 0;
   }
   function jsoo_effect_not_supported(){
    caml_failwith("Effect handlers are not supported");
   }
   function land_digit_nat(nat1, ofs1, nat2, ofs2){nat1.data[ofs1] &= nat2.data[ofs2]; return 0;
   }
   function length_nat(x){return x.data.length;}
   function lor_digit_nat(nat1, ofs1, nat2, ofs2){nat1.data[ofs1] |= nat2.data[ofs2]; return 0;
   }
   function lxor_digit_nat(nat1, ofs1, nat2, ofs2){nat1.data[ofs1] ^= nat2.data[ofs2]; return 0;
   }
   function ml_canvas_arc(canvas, p, radius, theta1, theta2, ccw){
    canvas.ctxt.arc(p[1], p[2], radius, theta1, theta2, ccw);
    return 0;
   }
   function ml_canvas_arc_to(canvas, p1, p2, radius){
    canvas.ctxt.arcTo(p1[1], p1[2], p2[1], p2[2], radius);
    return 0;
   }
   function ml_canvas_bezier_curve_to(canvas, p1, p2, p3){
    canvas.ctxt.bezierCurveTo(p1[1], p1[2], p2[1], p2[2], p3[1], p3[2]);
    return 0;
   }
   function ml_canvas_blit(dst_canvas, dpos, src_canvas, spos, size){
    var width = size[1], height = size[2];
    if(! _ml_canvas_valid_canvas_size(width, height))
     caml_invalid_argument("Canvas.blit: invalid dimensions");
    dst_canvas.ctxt.drawImage
     (src_canvas.surface,
      spos[1],
      spos[2],
      width,
      height,
      dpos[1],
      dpos[2],
      width,
      height);
    return 0;
   }
   function ml_canvas_clear_path(canvas){canvas.ctxt.beginPath(); return 0;}
   function ml_canvas_clip(canvas, nonzero){
    if(nonzero) canvas.ctxt.clip("nonzero"); else canvas.ctxt.clip();
    return 0;
   }
   function ml_canvas_clip_path(canvas, path, nonzero){
    if(nonzero)
     canvas.ctxt.clip(path, "nonzero");
    else
     canvas.ctxt.clip(path);
    return 0;
   }
   function ml_canvas_close_path(canvas){canvas.ctxt.closePath(); return 0;}
   function ml_canvas_commit(canvas){return 0;}
   function ml_canvas_compare(canvas1, canvas2){
    if(canvas1.id < canvas2.id)
     return - 1;
    else if(canvas1.id > canvas2.id) return 1; else return 0;
   }
   function ml_canvas_create_offscreen(size){
    _ml_canvas_ensure_initialized();
    var width = size[1], height = size[2];
    if(! _ml_canvas_valid_canvas_size(width, height))
     caml_invalid_argument("Canvas.createOffscreen: invalid dimensions");
    var
     id = ++_next_id,
     canvas =
       {name: null,
        frame: null,
        header: null,
        surface: surface,
        ctxt: ctxt,
        x: 0,
        y: 0,
        width: width,
        height: height,
        id: id,
        autocommit: false,
        resizeable: false,
        minimize: false,
        maximize: false,
        close: false},
     surface = document.createElement("canvas");
    surface.id = "s" + id;
    surface.width = width;
    surface.height = height;
    surface.style.position = "absolute";
    surface.canvas = canvas;
    canvas.surface = surface;
    var ctxt = surface.getContext("2d");
    ctxt.globalAlpha = 1.0;
    ctxt.lineWidth = 2.0;
    ctxt.fillStyle = "white";
    ctxt.strokeStyle = "black";
    canvas.ctxt = ctxt;
    return canvas;
   }
   function ml_canvas_create_offscreen_from_image_data(data){
    _ml_canvas_ensure_initialized();
    var
     width = caml_ba_dim(data, 1),
     height = caml_ba_dim(data, 0),
     canvas = ml_canvas_create_offscreen([0, width, height]);
    if(canvas === null) return null;
    var
     sta = new window.Uint8Array(caml_ba_to_typed_array(data).buffer),
     dta = new window.Uint8ClampedArray(sta.length);
    for(var i = 0; i < sta.length; i += 4){
     dta[i + 0] = sta[i + 2];
     dta[i + 1] = sta[i + 1];
     dta[i + 2] = sta[i + 0];
     dta[i + 3] = sta[i + 3];
    }
    if(window.ImageData === undefined){
     var image = canvas.ctxt.createImageData(width, height);
     image.data.set(dta);
    }
    else
     var image = new window.ImageData(dta, width, height);
    canvas.ctxt.putImageData(image, 0, 0);
    return canvas;
   }
   function ml_canvas_create_offscreen_from_png(filename, onload){
    _ml_canvas_ensure_initialized();
    var img = _ml_canvas_image_of_png_file(filename);
    if(img === null){
     caml_raise_with_string(caml_named_value("Read_png_failed"), filename);
     return 0;
    }
    img[0].then
     (function(__img){
       var
        canvas = ml_canvas_create_offscreen([0, img[1].width, img[1].height]);
       if(canvas === null) return 0;
       canvas.ctxt.drawImage(img[1], 0, 0);
       onload(canvas);
       return 0;
      });
    return 0;
   }
   function ml_canvas_create_onscreen
   (autocommit,
    decorated,
    resizeable,
    minimize,
    maximize,
    close,
    title,
    target,
    pos,
    size){
    _ml_canvas_ensure_initialized();
    var width = size[1], height = size[2];
    if(! _ml_canvas_valid_canvas_size(width, height))
     caml_invalid_argument("Canvas.blit: invalid dimensions");
    var
     pos = Optional_val(pos, [0, 0, 0]),
     x = pos[1],
     y = pos[2],
     autocommit = Optional_bool_val(autocommit, true),
     decorated = false,
     resizeable = Optional_bool_val(resizeable, true),
     minimize = Optional_bool_val(minimize, true),
     maximize = Optional_bool_val(maximize, true),
     close = Optional_bool_val(close, true),
     title = Optional_val(title, null),
     target = Optional_val(target, null);
    target = document.getElementById(target);
    if(target == null) target = document.body;
    var
     id = ++_next_id,
     canvas =
       {name: title,
        target: target,
        frame: null,
        header: null,
        surface: null,
        ctxt: null,
        x: x,
        y: y,
        width: width,
        height: height,
        id: id,
        autocommit: autocommit,
        resizeable: resizeable,
        minimize: minimize,
        maximize: maximize,
        close: close},
     header_height = decorated == true ? 30 : 0,
     frame = document.createElement("div");
    frame.id = "f" + id;
    if(resizeable == true){
     frame.style.width = "100%";
     frame.style.height = "100%";
    }
    else{
     frame.style.width = width + "px";
     frame.style.height = height + header_height + "px";
    }
    frame.style.visibility = "hidden";
    frame.oncontextmenu = function(){return false;};
    frame.canvas = canvas;
    canvas.frame = frame;
    target.appendChild(frame);
    var header = null;
    if(decorated === true){
     frame.style.border = "1px solid black";
     header = document.createElement("canvas");
     header.id = "h" + id;
     header.width = width;
     header.height = 30;
     _ml_canvas_decorate(header, minimize, maximize, close, title);
     header.onmousedown = _header_down_handler;
     header.canvas = canvas;
     canvas.header = header;
     frame.appendChild(header);
    }
    var surface = document.createElement("canvas");
    surface.id = "s" + id;
    surface.width = width;
    surface.height = height;
    surface.onmousedown = _surface_down_handler;
    surface.canvas = canvas;
    canvas.surface = surface;
    frame.appendChild(surface);
    if(resizeable === true){
     surface.style.width = "100%";
     surface.style.height = "100%";
     _resize.observe(surface);
    }
    var ctxt = surface.getContext("2d");
    ctxt.globalAlpha = 1.0;
    ctxt.lineWidth = 1.0;
    ctxt.fillStyle = "white";
    ctxt.strokeStyle = "black";
    canvas.ctxt = ctxt;
    ctxt.fillRect(0, 0, width, height);
    return canvas;
   }
   function ml_canvas_ellipse
   (canvas, p, radius, rotation, theta1, theta2, ccw){
    canvas.ctxt.ellipse
     (p[1], p[2], radius[1], radius[2], rotation, theta1, theta2, ccw);
    return 0;
   }
   function ml_canvas_export_png(canvas, filename){
    try{
     var data = canvas.surface.toDataURL("image/png").substring(22);
     caml_create_file(filename, window.atob(data));
    }
    catch(exn){
     caml_raise_with_string(caml_named_value("Write_png_failed"), filename);
    }
    return 0;
   }
   function ml_canvas_fill(canvas, nonzero){
    if(nonzero) canvas.ctxt.fill("nonzero"); else canvas.ctxt.fill();
    return 0;
   }
   function ml_canvas_fill_path(canvas, path, nonzero){
    if(nonzero)
     canvas.ctxt.fill(path, "nonzero");
    else
     canvas.ctxt.fill(path);
    return 0;
   }
   function ml_canvas_fill_rect(canvas, pos, size){
    canvas.ctxt.fillRect(pos[1], pos[2], size[1], size[2]);
    return 0;
   }
   function ml_canvas_fill_text(canvas, text, pos){
    canvas.ctxt.fillText(caml_jsstring_of_string(text), pos[1], pos[2]);
    return 0;
   }
   function ml_canvas_get_canvas(id){
    _ml_canvas_ensure_initialized();
    var surface = document.getElementById("s" + id);
    if(surface === null){caml_raise_not_found(); return 0;}
    return surface.canvas;
   }
   function ml_canvas_get_current_timestamp(){
    _ml_canvas_ensure_initialized();
    var e = new window.Event("dummy");
    return caml_int64_of_float(e.timeStamp * 1000.0);
   }
   function ml_canvas_get_fill_color(canvas){
    return typeof canvas.ctxt.fillStyle == "string"
            ? _int_of_color(canvas.ctxt.fillStyle)
            : 0;
   }
   function ml_canvas_get_fill_style(canvas){
    return Draw_style_val(canvas.ctxt.fillStyle);
   }
   function ml_canvas_get_global_alpha(canvas){return canvas.ctxt.globalAlpha;
   }
   function ml_canvas_get_global_composite_operation(canvas){return Val_compop(canvas.ctxt.globalCompositeOperation);
   }
   function ml_canvas_get_id(canvas){return canvas.id;}
   function ml_canvas_get_image_data(canvas, pos, size){
    var width = size[1], height = size[2];
    if(! _ml_canvas_valid_canvas_size(width, height))
     caml_invalid_argument("Canvas.getImageData: invalid dimensions");
    var
     image = canvas.ctxt.getImageData(pos[1], pos[2], width, height),
     sta = new window.Uint8Array(image.data.buffer),
     dta = new window.Uint8Array(sta.length);
    for(var i = 0; i < sta.length; i += 4){
     dta[i + 0] = sta[i + 2];
     dta[i + 1] = sta[i + 1];
     dta[i + 2] = sta[i + 0];
     dta[i + 3] = sta[i + 3];
    }
    return caml_ba_create_unsafe(3, 0, [height, width, 4], dta);
   }
   function ml_canvas_get_line_cap(canvas){return Val_cap_type(canvas.lineCap);
   }
   function ml_canvas_get_line_dash(canvas){
    var arr = canvas.ctxt.getLineDash();
    arr.unshift(254);
    return arr;
   }
   function ml_canvas_get_line_dash_offset(canvas){return canvas.ctxt.lineDashOffset;
   }
   function ml_canvas_get_line_join(canvas){return Val_join_type(canvas.lineJoin);
   }
   function ml_canvas_get_line_width(canvas){return canvas.ctxt.lineWidth;}
   function ml_canvas_get_miter_limit(canvas){return canvas.ctxt.miterLimit;}
   function ml_canvas_get_pixel(canvas, pos){
    var image = canvas.ctxt.getImageData(pos[1], pos[2], 1, 1);
    return image.data[3] << 24 >>> 0 | image.data[0] << 16
           | image.data[1] << 8
           | image.data[2] << 0;
   }
   function ml_canvas_get_position(canvas){
    return canvas.frame !== null ? [0, canvas.x, canvas.y] : [0, 0, 0];
   }
   function ml_canvas_get_shadow_blur(canvas){return canvas.ctxt.shadowBlur;}
   function ml_canvas_get_shadow_color(canvas){
    return _int_of_color(canvas.ctxt.shadowColor);
   }
   function ml_canvas_get_shadow_offset(canvas, offset){
    return [0, canvas.ctxt.shadowOffsetX, canvas.ctxt.shadowOffsetY];
   }
   function ml_canvas_get_size(canvas){
    return [0, canvas.width, canvas.height];
   }
   function ml_canvas_get_stroke_color(canvas){
    return typeof canvas.ctxt.strokeStyle == "string"
            ? _int_of_color(canvas.ctxt.strokeStyle)
            : 0;
   }
   function ml_canvas_get_stroke_style(canvas){
    return Draw_style_val(canvas.ctxt.strokeStyle);
    return 0;
   }
   function ml_canvas_gradient_add_color_stop(gradient, color, pos){gradient.addColorStop(pos, _color_of_int(color)); return 0;
   }
   function ml_canvas_gradient_create_conic(center, angle){
    return _internal_ctxt.createConicGradient(angle, center[1], center[2]);
   }
   function ml_canvas_gradient_create_linear(pos1, pos2){
    return _internal_ctxt.createLinearGradient
            (pos1[1], pos1[2], pos2[1], pos2[2]);
   }
   function ml_canvas_gradient_create_radial(center1, rad1, center2, rad2){
    return _internal_ctxt.createRadialGradient
            (center1[1], center1[2], rad1, center2[1], center2[2], rad2);
   }
   function ml_canvas_hash(canvas){
    var hash = caml_named_value("Hashtbl.hash");
    return hash(canvas.id);
   }
   function ml_canvas_image_data_blit(dst_data, dpos, src_data, spos, size){
    var width = size[1], height = size[2];
    if(! _ml_canvas_valid_canvas_size(width, height))
     caml_invalid_argument("ImageData.blit: invalid dimensions");
    var
     dwidth = caml_ba_dim(dst_data, 1),
     dheight = caml_ba_dim(dst_data, 0),
     swidth = caml_ba_dim(src_data, 1),
     sheight = caml_ba_dim(src_data, 0),
     blit_info =
       _ml_canvas_adjust_blit_info
        (dwidth,
         dheight,
         dpos[1],
         dpos[2],
         swidth,
         sheight,
         spos[1],
         spos[2],
         width,
         height),
     dx = blit_info[0],
     dy = blit_info[1],
     sx = blit_info[2],
     sy = blit_info[3],
     width = blit_info[4],
     height = blit_info[5];
    if(width > 0 && height > 0){
     var
      dta = new window.Uint32Array(caml_ba_to_typed_array(dst_data).buffer),
      sta = new window.Uint32Array(caml_ba_to_typed_array(src_data).buffer);
     for(var y = 0; y < height; ++y)
      for(var x = 0; x < width; ++x)
       dta[(dy + y) * dwidth + (dx + x)] = sta[(sy + y) * swidth + (sx + x)];
    }
    return 0;
   }
   function ml_canvas_image_data_create_from_png(filename, onload){
    _ml_canvas_ensure_initialized();
    var img = _ml_canvas_image_of_png_file(filename);
    if(img === null){
     caml_raise_with_string(caml_named_value("Read_png_failed"), filename);
     return 0;
    }
    img[0].then
     (function(__img){
       var ba = _ml_canvas_ba_of_img(img[1]);
       onload(ba);
       return 0;
      });
    return 0;
   }
   function ml_canvas_image_data_export_png(data, filename){
    _ml_canvas_ensure_initialized();
    try{
     var surface = _ml_canvas_surface_of_ba(data);
     if(surface !== null){
      var data = surface.toDataURL("image/png").substring(22);
      caml_create_file(filename, window.atob(data));
     }
    }
    catch(exn){
     caml_raise_with_string(caml_named_value("Write_png_failed"), filename);
    }
    return 0;
   }
   function ml_canvas_image_data_fill(data, color){
    var ta = new window.Uint32Array(caml_ba_to_typed_array(data).buffer);
    for(var i = 0; i < ta.length; i++) ta[i] = color;
    return 0;
   }
   function ml_canvas_image_data_get_pixel(data, pos){
    var ta = new window.Uint32Array(caml_ba_to_typed_array(data).buffer);
    return ta[pos[2] * caml_ba_dim(data, 1) + pos[1]];
   }
   function ml_canvas_image_data_get_size(data){
    return [0, caml_ba_dim(data, 1), caml_ba_dim(data, 0)];
   }
   function ml_canvas_image_data_import_png(data, pos, filename, onload){
    _ml_canvas_ensure_initialized();
    var
     img = _ml_canvas_image_of_png_file(filename),
     surface = _ml_canvas_surface_of_ba(data);
    if(img === null || surface === null){
     caml_raise_with_string(caml_named_value("Read_png_failed"), filename);
     return 0;
    }
    img[0].then
     (function(__img){
       var ctxt = surface.getContext("2d");
       ctxt.drawImage(img[1], pos[1], pos[2]);
       var
        image = ctxt.getImageData(0, 0, surface.width, surface.height),
        sta = new window.Uint8Array(image.data.buffer),
        dta = caml_ba_to_typed_array(data);
       for(var i = 0; i < dta.length; i++) dta[i] = sta[i];
       onload(data);
       return 0;
      });
    return 0;
   }
   function ml_canvas_image_data_put_pixel(data, pos, color){
    var ta = new window.Uint32Array(caml_ba_to_typed_array(data).buffer);
    ta[pos[2] * caml_ba_dim(data, 1) + pos[1]] = color;
    return 0;
   }
   function ml_canvas_image_data_sub(src_data, spos, size){
    var dwidth = size[1], dheight = size[2];
    if(! _ml_canvas_valid_canvas_size(dwidth, dheight))
     caml_invalid_argument("ImageData.blit: invalid dimensions");
    var
     swidth = caml_ba_dim(src_data, 1),
     sheight = caml_ba_dim(src_data, 0),
     ta = new window.Uint8Array(dwidth * dheight * 4),
     dst_data = caml_ba_create_unsafe(3, 0, [dheight, dwidth, 4], ta),
     blit_info =
       _ml_canvas_adjust_blit_info
        (dwidth,
         dheight,
         0,
         0,
         swidth,
         sheight,
         spos[1],
         spos[2],
         dwidth,
         dheight),
     dx = blit_info[0],
     dy = blit_info[1],
     sx = blit_info[2],
     sy = blit_info[3],
     width = blit_info[4],
     height = blit_info[5];
    if(width > 0 && height > 0){
     var
      dta = new window.Uint32Array(caml_ba_to_typed_array(dst_data).buffer),
      sta = new window.Uint32Array(caml_ba_to_typed_array(src_data).buffer);
     for(var y = 0; y < height; ++y)
      for(var x = 0; x < width; ++x)
       dta[(dy + y) * dwidth + (dx + x)] = sta[(sy + y) * swidth + (sx + x)];
    }
    return dst_data;
   }
   function ml_canvas_import_png(canvas, pos, filename, onload){
    var img = _ml_canvas_image_of_png_file(filename);
    if(img === null){
     caml_raise_with_string(caml_named_value("Read_png_failed"), filename);
     return 0;
    }
    img[0].then
     (function(__img){
       canvas.ctxt.drawImage(img[1], pos[1], pos[2]);
       onload(canvas);
       return 0;
      });
    return 0;
   }
   function ml_canvas_init(){
    if(_ml_canvas_initialized === true) return 0;
    document.addEventListener("keydown", _key_down_handler, {passive: true});
    document.addEventListener("keyup", _key_up_handler, {passive: true});
    document.addEventListener("mouseup", _up_handler, {passive: true});
    document.addEventListener("mousemove", _move_handler, {passive: true});
    window.requestAnimationFrame(_frame_handler);
    _ml_canvas_initialized = true;
    return 0;
   }
   function ml_canvas_int_of_key(keycode){return Key_code_val(keycode);}
   function ml_canvas_key_of_int(keycode){
    caml_invalid_argument("key_of_int: i must be in the 0-255 range");
    return Val_key_code(keycode);
   }
   function ml_canvas_line_to(canvas, p){
    canvas.ctxt.lineTo(p[1], p[2]);
    return 0;
   }
   function ml_canvas_move_to(canvas, p){
    canvas.ctxt.moveTo(p[1], p[2]);
    return 0;
   }
   function ml_canvas_path_add(path1, path2){path1.addPath(path2); return 0;}
   function ml_canvas_path_add_transformed(path1, path2, t){
    var m = new window.DOMMatrix([[1], t[2], t[3], t[4], t[5], t[6]]);
    path1.addPath(path2, m);
    return 0;
   }
   function ml_canvas_path_arc(path, p, radius, theta1, theta2, ccw){path.arc(p[1], p[2], radius, theta1, theta2, ccw); return 0;
   }
   function ml_canvas_path_arc_to(path, p1, p2, radius){
    path.arcTo(p1[1], p1[2], p2[1], p2[2], radius);
    return 0;
   }
   function ml_canvas_path_bezier_curve_to(path, cp1, cp2, p){
    path.bezierCurveTo(cp1[1], cp1[2], cp2[1], cp2[2], p[1], p[2]);
    return 0;
   }
   function ml_canvas_path_close(path){path.closePath(); return 0;}
   function ml_canvas_path_create(){return new window.Path2D();}
   function ml_canvas_path_ellipse
   (path, p, radius, rotation, theta1, theta2, ccw){
    path.ellipse
     (p[1], p[2], radius[1], radius[2], rotation, theta1, theta2, ccw);
    return 0;
   }
   function ml_canvas_path_line_to(path, p){path.lineTo(p[1], p[2]); return 0;
   }
   function ml_canvas_path_move_to(path, p){path.moveTo(p[1], p[2]); return 0;
   }
   function ml_canvas_path_quadratic_curve_to(path, cp, p){
    path.quadraticCurveTo(cp[1], cp[2], p[1], p[2]);
    return 0;
   }
   function ml_canvas_path_rect(path, pos, size){
    path.rect(pos[1], pos[2], size[1], size[2]);
    return 0;
   }
   function ml_canvas_pattern_create(image, repeat){
    var img_canv = _ml_canvas_surface_of_ba(image);
    return _internal_ctxt.createPattern(img_canv, Repeat_val(repeat));
   }
   function ml_canvas_put_image_data(canvas, dpos, data, spos, size){
    var width = size[1], height = size[2];
    if(! _ml_canvas_valid_canvas_size(width, height))
     caml_invalid_argument("Canvas.putImageData: invalid dimensions");
    var
     sta = new window.Uint8Array(caml_ba_to_typed_array(data).buffer),
     dta = new window.Uint8ClampedArray(sta.length);
    for(var i = 0; i < sta.length; i += 4){
     dta[i + 0] = sta[i + 2];
     dta[i + 1] = sta[i + 1];
     dta[i + 2] = sta[i + 0];
     dta[i + 3] = sta[i + 3];
    }
    if(window.ImageData === undefined){
     var
      image =
        canvas.ctxt.createImageData
         (caml_ba_dim(data, 1), caml_ba_dim(data, 0));
     image.data.set(dta);
    }
    else
     var
      image =
        new window.ImageData(dta, caml_ba_dim(data, 1), caml_ba_dim(data, 0));
    canvas.ctxt.putImageData
     (image, dpos[1], dpos[2], spos[1], spos[2], width, height);
    return 0;
   }
   function ml_canvas_put_pixel(canvas, pos, color){
    var image = canvas.ctxt.createImageData(1, 1);
    image.data[3] = (color & 0xFF000000) >>> 24;
    image.data[0] = (color & 0x00FF0000) >>> 16;
    image.data[1] = (color & 0x0000FF00) >>> 8;
    image.data[2] = (color & 0x000000FF) >>> 0;
    canvas.ctxt.putImageData(image, pos[1], pos[2]);
    return 0;
   }
   function ml_canvas_quadratic_curve_to(canvas, p1, p2){
    canvas.ctxt.quadraticCurveTo(p1[1], p1[2], p2[1], p2[2]);
    return 0;
   }
   function ml_canvas_rect(canvas, pos, size){
    canvas.ctxt.rect(pos[1], pos[2], size[1], size[2]);
    return 0;
   }
   function ml_canvas_restore(canvas){canvas.ctxt.restore(); return 0;}
   function ml_canvas_rotate(canvas, theta){canvas.ctxt.rotate(theta); return 0;
   }
   function ml_canvas_run(mlProcessEvent, mlContinuation){
    _ml_canvas_ensure_initialized();
    if(_ml_canvas_mlProcessEvent !== null) return 0;
    _ml_canvas_mlProcessEvent = mlProcessEvent;
    _ml_canvas_mlContinuation = mlContinuation;
    _ml_canvas_mlException = null;
    return 0;
   }
   function ml_canvas_save(canvas){canvas.ctxt.save(); return 0;}
   function ml_canvas_scale(canvas, vec){
    canvas.ctxt.scale(vec[1], vec[2]);
    return 0;
   }
   function ml_canvas_set_fill_color(canvas, color){
    canvas.ctxt.fillStyle = _color_of_int(color);
    return 0;
   }
   function ml_canvas_set_fill_gradient(canvas, grad){canvas.ctxt.fillStyle = grad; return 0;
   }
   function ml_canvas_set_fill_pattern(canvas, pattern){canvas.ctxt.fillStyle = pattern; return 0;
   }
   function ml_canvas_set_fill_style(canvas, style){
    canvas.ctxt.fillStyle = Val_draw_style(style);
    return 0;
   }
   function ml_canvas_set_font(canvas, family, size, slant, weight){
    canvas.ctxt.font =
     Slant_val(slant) + " " + weight + " " + size + "pt "
     + caml_jsstring_of_string(family);
    return 0;
   }
   function ml_canvas_set_global_alpha(canvas, global_alpha){canvas.ctxt.globalAlpha = global_alpha; return 0;
   }
   function ml_canvas_set_global_composite_operation(canvas, op){
    canvas.ctxt.globalCompositeOperation = Compop_val(op);
    return 0;
   }
   function ml_canvas_set_line_cap(canvas, cap){
    canvas.ctxt.lineCap = Cap_type_val(cap);
    return 0;
   }
   function ml_canvas_set_line_dash(canvas, dash){
    dash.shift();
    canvas.ctxt.setLineDash(dash);
    return 0;
   }
   function ml_canvas_set_line_dash_offset(canvas, offset){canvas.ctxt.lineDashOffset = offset; return 0;
   }
   function ml_canvas_set_line_join(canvas, join){
    canvas.ctxt.lineJoin = Join_type_val(join);
    return 0;
   }
   function ml_canvas_set_line_width(canvas, width){canvas.ctxt.lineWidth = width; return 0;
   }
   function ml_canvas_set_miter_limit(canvas, limit){canvas.ctxt.miterLimit = limit; return 0;
   }
   function ml_canvas_set_position(canvas, pos){
    if(canvas.frame !== null){
     var x = pos[1], y = pos[2];
     canvas.x = x;
     canvas.y = y;
     canvas.frame.style.left = x + "px";
     canvas.frame.style.top = y + "px";
    }
    return 0;
   }
   function ml_canvas_set_shadow_blur(canvas, blur){canvas.ctxt.shadowBlur = blur; return 0;
   }
   function ml_canvas_set_shadow_color(canvas, color){
    canvas.ctxt.shadowColor = _color_of_int(color);
    return 0;
   }
   function ml_canvas_set_shadow_offset(canvas, offset){
    canvas.ctxt.shadowOffsetX = offset[1];
    canvas.ctxt.shadowOffsetY = offset[2];
    return 0;
   }
   function ml_canvas_set_size(canvas, size){
    var width = size[1], height = size[2];
    if(! _ml_canvas_valid_canvas_size(width, height))
     caml_invalid_argument("Canvas.setSize: invalid dimensions");
    var img = canvas.ctxt.getImageData(0, 0, canvas.width, canvas.height);
    if(canvas.header !== null){
     canvas.header.width = width;
     _ml_canvas_decorate
      (canvas.header,
       canvas.minimize,
       canvas.maximize,
       canvas.close,
       canvas.name);
    }
    canvas.surface.width = canvas.width = width;
    canvas.surface.height = canvas.height = height;
    canvas.ctxt.fillRect(0, 0, width, height);
    canvas.ctxt.putImageData(img, 0, 0);
    return 0;
   }
   function ml_canvas_set_stroke_color(canvas, color){
    canvas.ctxt.strokeStyle = _color_of_int(color);
    return 0;
   }
   function ml_canvas_set_stroke_gradient(canvas, grad){canvas.ctxt.strokeStyle = grad; return 0;
   }
   function ml_canvas_set_stroke_pattern(canvas, pattern){canvas.ctxt.strokeStyle = pattern; return 0;
   }
   function ml_canvas_set_stroke_style(canvas, style){
    canvas.ctxt.strokeStyle = Val_draw_style(style);
    return 0;
   }
   function ml_canvas_set_transform(canvas, t){
    canvas.ctxt.setTransform(t[1], t[2], t[3], t[4], t[5], t[6]);
    return 0;
   }
   function ml_canvas_shear(canvas, vec){
    canvas.ctxt.transform(1.0, vec[2], vec[1], 1.0, 0.0, 0.0);
    return 0;
   }
   function ml_canvas_show(canvas){
    if(canvas.frame !== null){
     _focus = canvas;
     canvas.frame.style.visibility = "visible";
    }
    return 0;
   }
   function ml_canvas_stroke(canvas){canvas.ctxt.stroke(); return 0;}
   function ml_canvas_stroke_path(canvas, path){canvas.ctxt.stroke(path); return 0;
   }
   function ml_canvas_stroke_rect(canvas, pos, size){
    canvas.ctxt.strokeRect(pos[1], pos[2], size[1], size[2]);
    return 0;
   }
   function ml_canvas_stroke_text(canvas, text, pos){
    canvas.ctxt.strokeText(caml_jsstring_of_string(text), pos[1], pos[2]);
    return 0;
   }
   function ml_canvas_transform(canvas, t){
    canvas.ctxt.transform(t[1], t[2], t[3], t[4], t[5], t[6]);
    return 0;
   }
   function ml_canvas_translate(canvas, vec){
    canvas.ctxt.translate(vec[1], vec[2]);
    return 0;
   }
   function mult_nat(nat1, ofs1, len1, nat2, ofs2, len2, nat3, ofs3, len3){
    var carry = 0;
    for(var i = 0; i < len3; i++)
     carry +=
      mult_digit_nat
       (nat1, ofs1 + i, len1 - i, nat2, ofs2, len2, nat3, ofs3 + i);
    return carry;
   }
   function nth_digit_nat(nat, ofs){return nat.data[ofs];}
   function nth_digit_nat_native(nat, ofs){return nat.data[ofs];}
   var
    re_match =
      function(){
        var
         re_word_letters =
           [0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0xFF,
            0x03,
            0xFE,
            0xFF,
            0xFF,
            0x87,
            0xFE,
            0xFF,
            0xFF,
            0x07,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0xFF,
            0xFF,
            0x7F,
            0xFF,
            0xFF,
            0xFF,
            0x7F,
            0xFF],
         opcodes =
           {CHAR: 0,
            CHARNORM: 1,
            STRING: 2,
            STRINGNORM: 3,
            CHARCLASS: 4,
            BOL: 5,
            EOL: 6,
            WORDBOUNDARY: 7,
            BEGGROUP: 8,
            ENDGROUP: 9,
            REFGROUP: 10,
            ACCEPT: 11,
            SIMPLEOPT: 12,
            SIMPLESTAR: 13,
            SIMPLEPLUS: 14,
            GOTO: 15,
            PUSHBACK: 16,
            SETMARK: 17,
            CHECKPROGRESS: 18};
        function is_word_letter(c){
         return re_word_letters[c >> 3] >> (c & 7) & 1;
        }
        function in_bitset(s, i){
         return caml_string_get(s, i >> 3) >> (i & 7) & 1;
        }
        function re_match_impl(re, s, pos, partial){
         var
          prog = caml_js_from_array(re[1]),
          cpool = caml_js_from_array(re[2]),
          normtable = caml_jsbytes_of_string(re[3]),
          numgroups = re[4] | 0,
          numregisters = re[5] | 0,
          startchars = re[6] | 0,
          s = caml_uint8_array_of_string(s),
          pc = 0,
          quit = false,
          stack = [],
          groups = new Array(numgroups),
          re_register = new Array(numregisters);
         for(var i = 0; i < groups.length; i++)
          groups[i] = {start: - 1, end: - 1};
         groups[0].start = pos;
         function backtrack(){
          while(stack.length){
           var item = stack.pop();
           if(item.undo)
            item.undo.obj[item.undo.prop] = item.undo.value;
           else if(item.pos){pc = item.pos.pc; pos = item.pos.txt; return;}
          }
          quit = true;
         }
         function push(item){stack.push(item);}
         function accept(){
          groups[0].end = pos;
          var result = new Array(1 + groups.length * 2);
          result[0] = 0;
          for(var i = 0; i < groups.length; i++){
           var g = groups[i];
           if(g.start < 0 || g.end < 0) g.start = g.end = - 1;
           result[2 * i + 1] = g.start;
           result[2 * i + 1 + 1] = g.end;
          }
          return result;
         }
         function prefix_match(){
          if(partial) return accept(); else backtrack();
         }
         while(! quit){
          var
           op = prog[pc] & 0xff,
           sarg = prog[pc] >> 8,
           uarg = sarg & 0xff,
           c = s[pos],
           group;
          pc++;
          switch(op){
            case opcodes.CHAR:
             if(pos === s.length){prefix_match(); break;}
             if(c === uarg) pos++; else backtrack();
             break;
            case opcodes.CHARNORM:
             if(pos === s.length){prefix_match(); break;}
             if(normtable.charCodeAt(c) === uarg) pos++; else backtrack();
             break;
            case opcodes.STRING:
             for
             (var arg = caml_jsbytes_of_string(cpool[uarg]), i = 0;
              i < arg.length;
              i++){
              if(pos === s.length){prefix_match(); break;}
              if(c === arg.charCodeAt(i))
               c = s[++pos];
              else{backtrack(); break;}
             }
             break;
            case opcodes.STRINGNORM:
             for
             (var arg = caml_jsbytes_of_string(cpool[uarg]), i = 0;
              i < arg.length;
              i++){
              if(pos === s.length){prefix_match(); break;}
              if(normtable.charCodeAt(c) === arg.charCodeAt(i))
               c = s[++pos];
              else{backtrack(); break;}
             }
             break;
            case opcodes.CHARCLASS:
             if(pos === s.length){prefix_match(); break;}
             if(in_bitset(cpool[uarg], c)) pos++; else backtrack();
             break;
            case opcodes.BOL:
             if(pos > 0 && s[pos - 1] != 10) backtrack(); break;
            case opcodes.EOL:
             if(pos < s.length && s[pos] != 10) backtrack(); break;
            case opcodes.WORDBOUNDARY:
             if(pos == 0){
              if(pos === s.length){prefix_match(); break;}
              if(is_word_letter(s[0])) break;
              backtrack();
             }
             else if(pos === s.length){
              if(is_word_letter(s[pos - 1])) break;
              backtrack();
             }
             else{
              if(is_word_letter(s[pos - 1]) != is_word_letter(s[pos])) break;
              backtrack();
             }
             break;
            case opcodes.BEGGROUP:
             group = groups[uarg];
             push({undo: {obj: group, prop: "start", value: group.start}});
             group.start = pos;
             break;
            case opcodes.ENDGROUP:
             group = groups[uarg];
             push({undo: {obj: group, prop: "end", value: group.end}});
             group.end = pos;
             break;
            case opcodes.REFGROUP:
             group = groups[uarg];
             if(group.start < 0 || group.end < 0){backtrack(); break;}
             for(var i = group.start; i < group.end; i++){
              if(pos === s.length){prefix_match(); break;}
              if(s[i] != s[pos]){backtrack(); break;}
              pos++;
             }
             break;
            case opcodes.SIMPLEOPT:
             if(in_bitset(cpool[uarg], c)) pos++; break;
            case opcodes.SIMPLESTAR:
             while(in_bitset(cpool[uarg], c)) c = s[++pos]; break;
            case opcodes.SIMPLEPLUS:
             if(pos === s.length){prefix_match(); break;}
             if(in_bitset(cpool[uarg], c))
              do c = s[++pos];while(in_bitset(cpool[uarg], c));
             else
              backtrack();
             break;
            case opcodes.ACCEPT: return accept();
            case opcodes.GOTO:
             pc = pc + sarg; break;
            case opcodes.PUSHBACK:
             push({pos: {pc: pc + sarg, txt: pos}}); break;
            case opcodes.SETMARK:
             push
              ({undo: {obj: re_register, prop: uarg, value: re_register[uarg]}});
             re_register[uarg] = pos;
             break;
            case opcodes.CHECKPROGRESS:
             if(re_register[uarg] === pos) backtrack(); break;
            default: throw new Error("Invalid bytecode");
          }
         }
         return 0;
        }
        return re_match_impl;
       }
       ();
   function re_partial_match(re, s, pos){
    if(pos < 0 || pos > caml_ml_string_length(s))
     caml_invalid_argument("Str.partial_match");
    var res = re_match(re, s, pos, 1);
    return res ? res : [0];
   }
   function re_replacement_text(repl, groups, orig){
    var
     repl = caml_jsbytes_of_string(repl),
     len = repl.length,
     orig = caml_jsbytes_of_string(orig),
     res = "",
     n = 0,
     cur,
     start,
     end,
     c;
    while(n < len){
     cur = repl.charAt(n++);
     if(cur != "\\")
      res += cur;
     else{
      if(n == len) caml_failwith("Str.replace: illegal backslash sequence");
      cur = repl.charAt(n++);
      switch(cur){
        case "\\":
         res += cur; break;
        case "0":
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
         c = + cur;
         if(c * 2 >= groups.length - 1)
          caml_failwith("Str.replace: reference to unmatched group");
         start = caml_array_get(groups, c * 2);
         end = caml_array_get(groups, c * 2 + 1);
         if(start == - 1)
          caml_failwith("Str.replace: reference to unmatched group");
         res += orig.slice(start, end);
         break;
        default: res += "\\" + cur;
      }
     }
    }
    return caml_string_of_jsbytes(res);
   }
   function re_search_backward(re, s, pos){
    if(pos < 0 || pos > caml_ml_string_length(s))
     caml_invalid_argument("Str.search_backward");
    while(pos >= 0){
     var res = re_match(re, s, pos, 0);
     if(res) return res;
     pos--;
    }
    return [0];
   }
   function re_search_forward(re, s, pos){
    if(pos < 0 || pos > caml_ml_string_length(s))
     caml_invalid_argument("Str.search_forward");
    while(pos <= caml_ml_string_length(s)){
     var res = re_match(re, s, pos, 0);
     if(res) return res;
     pos++;
    }
    return [0];
   }
   function re_string_match(re, s, pos){
    if(pos < 0 || pos > caml_ml_string_length(s))
     caml_invalid_argument("Str.string_match");
    var res = re_match(re, s, pos, 0);
    return res ? res : [0];
   }
   function set_digit_nat(nat, ofs, digit){nat.data[ofs] = digit; return 0;}
   function set_digit_nat_native(nat, ofs, digit){nat.data[ofs] = digit; return 0;
   }
   function square_nat(nat1, ofs1, len1, nat2, ofs2, len2){
    var carry = 0;
    carry += add_nat(nat1, ofs1, len1, nat1, ofs1, len1, 0);
    carry += mult_nat(nat1, ofs1, len1, nat2, ofs2, len2, nat2, ofs2, len2);
    return carry;
   }
   function caml_setup_uncaught_exception_handler(){
    var process = globalThis.process;
    if(process && process.on)
     process.on
      ("uncaughtException",
       function(err, origin){
        caml_fatal_uncaught_exception(err);
        process.exit(2);
       });
    else if(globalThis.addEventListener)
     globalThis.addEventListener
      ("error",
       function(event){
        if(event.error) caml_fatal_uncaught_exception(event.error);
       });
   }
   caml_setup_uncaught_exception_handler();
   globalThis.jsoo_runtime =
    {ml_canvas_get_current_timestamp: ml_canvas_get_current_timestamp,
     ml_canvas_get_canvas: ml_canvas_get_canvas,
     ml_canvas_stop: ml_canvas_stop,
     ml_canvas_run: ml_canvas_run,
     _ml_canvas_process_event: _ml_canvas_process_event,
     _ml_canvas_mlException: _ml_canvas_mlException,
     _ml_canvas_mlContinuation: _ml_canvas_mlContinuation,
     _ml_canvas_mlProcessEvent: _ml_canvas_mlProcessEvent,
     ml_canvas_init: ml_canvas_init,
     ml_canvas_key_of_int: ml_canvas_key_of_int,
     ml_canvas_int_of_key: ml_canvas_int_of_key,
     ml_canvas_export_png: ml_canvas_export_png,
     ml_canvas_import_png: ml_canvas_import_png,
     ml_canvas_put_image_data: ml_canvas_put_image_data,
     ml_canvas_get_image_data: ml_canvas_get_image_data,
     ml_canvas_put_pixel: ml_canvas_put_pixel,
     ml_canvas_get_pixel: ml_canvas_get_pixel,
     ml_canvas_blit: ml_canvas_blit,
     ml_canvas_stroke_text: ml_canvas_stroke_text,
     ml_canvas_fill_text: ml_canvas_fill_text,
     ml_canvas_stroke_rect: ml_canvas_stroke_rect,
     ml_canvas_fill_rect: ml_canvas_fill_rect,
     ml_canvas_clip_path: ml_canvas_clip_path,
     ml_canvas_clip: ml_canvas_clip,
     ml_canvas_stroke_path: ml_canvas_stroke_path,
     ml_canvas_stroke: ml_canvas_stroke,
     ml_canvas_fill_path: ml_canvas_fill_path,
     ml_canvas_fill: ml_canvas_fill,
     ml_canvas_ellipse: ml_canvas_ellipse,
     ml_canvas_rect: ml_canvas_rect,
     ml_canvas_bezier_curve_to: ml_canvas_bezier_curve_to,
     ml_canvas_quadratic_curve_to: ml_canvas_quadratic_curve_to,
     ml_canvas_arc_to: ml_canvas_arc_to,
     ml_canvas_arc: ml_canvas_arc,
     ml_canvas_line_to: ml_canvas_line_to,
     ml_canvas_move_to: ml_canvas_move_to,
     ml_canvas_close_path: ml_canvas_close_path,
     ml_canvas_clear_path: ml_canvas_clear_path,
     ml_canvas_set_font: ml_canvas_set_font,
     ml_canvas_set_shadow_offset: ml_canvas_set_shadow_offset,
     ml_canvas_get_shadow_offset: ml_canvas_get_shadow_offset,
     ml_canvas_set_shadow_blur: ml_canvas_set_shadow_blur,
     ml_canvas_get_shadow_blur: ml_canvas_get_shadow_blur,
     ml_canvas_set_shadow_color: ml_canvas_set_shadow_color,
     ml_canvas_get_shadow_color: ml_canvas_get_shadow_color,
     ml_canvas_set_global_composite_operation:
     ml_canvas_set_global_composite_operation,
     ml_canvas_get_global_composite_operation:
     ml_canvas_get_global_composite_operation,
     ml_canvas_get_fill_style: ml_canvas_get_fill_style,
     ml_canvas_set_fill_style: ml_canvas_set_fill_style,
     ml_canvas_set_fill_pattern: ml_canvas_set_fill_pattern,
     ml_canvas_set_fill_gradient: ml_canvas_set_fill_gradient,
     ml_canvas_set_global_alpha: ml_canvas_set_global_alpha,
     ml_canvas_get_global_alpha: ml_canvas_get_global_alpha,
     ml_canvas_set_fill_color: ml_canvas_set_fill_color,
     ml_canvas_get_fill_color: ml_canvas_get_fill_color,
     ml_canvas_get_stroke_style: ml_canvas_get_stroke_style,
     ml_canvas_set_stroke_style: ml_canvas_set_stroke_style,
     ml_canvas_set_stroke_pattern: ml_canvas_set_stroke_pattern,
     ml_canvas_set_stroke_gradient: ml_canvas_set_stroke_gradient,
     ml_canvas_set_stroke_color: ml_canvas_set_stroke_color,
     ml_canvas_get_stroke_color: ml_canvas_get_stroke_color,
     ml_canvas_set_miter_limit: ml_canvas_set_miter_limit,
     ml_canvas_get_miter_limit: ml_canvas_get_miter_limit,
     ml_canvas_set_line_join: ml_canvas_set_line_join,
     ml_canvas_get_line_join: ml_canvas_get_line_join,
     ml_canvas_set_line_dash: ml_canvas_set_line_dash,
     ml_canvas_get_line_dash: ml_canvas_get_line_dash,
     ml_canvas_set_line_dash_offset: ml_canvas_set_line_dash_offset,
     ml_canvas_get_line_dash_offset: ml_canvas_get_line_dash_offset,
     ml_canvas_set_line_cap: ml_canvas_set_line_cap,
     ml_canvas_get_line_cap: ml_canvas_get_line_cap,
     ml_canvas_set_line_width: ml_canvas_set_line_width,
     ml_canvas_get_line_width: ml_canvas_get_line_width,
     _int_of_color: _int_of_color,
     _color_of_int: _color_of_int,
     ml_canvas_restore: ml_canvas_restore,
     ml_canvas_save: ml_canvas_save,
     ml_canvas_rotate: ml_canvas_rotate,
     ml_canvas_shear: ml_canvas_shear,
     ml_canvas_scale: ml_canvas_scale,
     ml_canvas_translate: ml_canvas_translate,
     ml_canvas_transform: ml_canvas_transform,
     ml_canvas_set_transform: ml_canvas_set_transform,
     ml_canvas_set_position: ml_canvas_set_position,
     ml_canvas_get_position: ml_canvas_get_position,
     ml_canvas_set_size: ml_canvas_set_size,
     ml_canvas_get_size: ml_canvas_get_size,
     ml_canvas_get_id: ml_canvas_get_id,
     ml_canvas_commit: ml_canvas_commit,
     ml_canvas_close: ml_canvas_close,
     ml_canvas_hide: ml_canvas_hide,
     ml_canvas_show: ml_canvas_show,
     ml_canvas_create_offscreen_from_png: ml_canvas_create_offscreen_from_png,
     ml_canvas_create_offscreen_from_image_data:
     ml_canvas_create_offscreen_from_image_data,
     ml_canvas_create_offscreen: ml_canvas_create_offscreen,
     ml_canvas_create_onscreen: ml_canvas_create_onscreen,
     _ml_canvas_decorate: _ml_canvas_decorate,
     _next_id: _next_id,
     ml_canvas_compare: ml_canvas_compare,
     ml_canvas_hash: ml_canvas_hash,
     ml_canvas_pattern_create: ml_canvas_pattern_create,
     ml_canvas_gradient_add_color_stop: ml_canvas_gradient_add_color_stop,
     ml_canvas_gradient_create_conic: ml_canvas_gradient_create_conic,
     ml_canvas_gradient_create_radial: ml_canvas_gradient_create_radial,
     ml_canvas_gradient_create_linear: ml_canvas_gradient_create_linear,
     ml_canvas_path_add_transformed: ml_canvas_path_add_transformed,
     ml_canvas_path_add: ml_canvas_path_add,
     ml_canvas_path_ellipse: ml_canvas_path_ellipse,
     ml_canvas_path_rect: ml_canvas_path_rect,
     ml_canvas_path_bezier_curve_to: ml_canvas_path_bezier_curve_to,
     ml_canvas_path_quadratic_curve_to: ml_canvas_path_quadratic_curve_to,
     ml_canvas_path_arc_to: ml_canvas_path_arc_to,
     ml_canvas_path_arc: ml_canvas_path_arc,
     ml_canvas_path_line_to: ml_canvas_path_line_to,
     ml_canvas_path_move_to: ml_canvas_path_move_to,
     ml_canvas_path_close: ml_canvas_path_close,
     ml_canvas_path_create: ml_canvas_path_create,
     ml_canvas_image_data_export_png: ml_canvas_image_data_export_png,
     ml_canvas_image_data_import_png: ml_canvas_image_data_import_png,
     ml_canvas_image_data_put_pixel: ml_canvas_image_data_put_pixel,
     ml_canvas_image_data_get_pixel: ml_canvas_image_data_get_pixel,
     ml_canvas_image_data_blit: ml_canvas_image_data_blit,
     ml_canvas_image_data_sub: ml_canvas_image_data_sub,
     _ml_canvas_adjust_blit_info: _ml_canvas_adjust_blit_info,
     ml_canvas_image_data_fill: ml_canvas_image_data_fill,
     ml_canvas_image_data_get_size: ml_canvas_image_data_get_size,
     ml_canvas_image_data_create_from_png:
     ml_canvas_image_data_create_from_png,
     _ml_canvas_surface_of_ba: _ml_canvas_surface_of_ba,
     _ml_canvas_ba_of_img: _ml_canvas_ba_of_img,
     _ml_canvas_image_of_png_file: _ml_canvas_image_of_png_file,
     _frame_handler: _frame_handler,
     _resize_handler: _resize_handler,
     _move_handler: _move_handler,
     _up_handler: _up_handler,
     _surface_down_handler: _surface_down_handler,
     _header_down_handler: _header_down_handler,
     _key_up_handler: _key_up_handler,
     _key_down_handler: _key_down_handler,
     _make_key_event: _make_key_event,
     _event_canvas_scale: _event_canvas_scale,
     _resize: _resize,
     _move: _move,
     _focus: _focus,
     _internal_ctxt: _internal_ctxt,
     _internal_canvas: _internal_canvas,
     _ml_canvas_valid_canvas_size: _ml_canvas_valid_canvas_size,
     _ml_canvas_ensure_initialized: _ml_canvas_ensure_initialized,
     _ml_canvas_initialized: _ml_canvas_initialized,
     Compop_val: Compop_val,
     Val_compop: Val_compop,
     Cap_type_val: Cap_type_val,
     Val_cap_type: Val_cap_type,
     Join_type_val: Join_type_val,
     Val_join_type: Val_join_type,
     Slant_val: Slant_val,
     Draw_style_val: Draw_style_val,
     Val_draw_style: Val_draw_style,
     Repeat_val: Repeat_val,
     Val_repeat: Val_repeat,
     Val_button_state: Val_button_state,
     Val_button: Val_button,
     Val_key_state: Val_key_state,
     Key_code_val: Key_code_val,
     Val_key_code: Val_key_code,
     Val_focus_in_out: Val_focus_in_out,
     Optional_val: Optional_val,
     Optional_bool_val: Optional_bool_val,
     COMPOP_TAG: COMPOP_TAG,
     CAP_TYPE_TAG: CAP_TYPE_TAG,
     JOIN_TYPE_TAG: JOIN_TYPE_TAG,
     SLANT_TAG: SLANT_TAG,
     REPEAT_TAG: REPEAT_TAG,
     STYLE_TAG: STYLE_TAG,
     EVENT_TAG: EVENT_TAG,
     BUTTON_STATE_TAG: BUTTON_STATE_TAG,
     BUTTON_TAG: BUTTON_TAG,
     KEY_STATE_TAG: KEY_STATE_TAG,
     KEY_TAG: KEY_TAG,
     FOCUS_TAG: FOCUS_TAG,
     keyname_to_keycode: keyname_to_keycode,
     BUTTON_STATE: BUTTON_STATE,
     BUTTON: BUTTON,
     KEY_STATE: KEY_STATE,
     KEY: KEY,
     FOCUS: FOCUS,
     SLANT: SLANT,
     caml_runtime_events_read_poll: caml_runtime_events_read_poll,
     caml_runtime_events_free_cursor: caml_runtime_events_free_cursor,
     caml_runtime_events_create_cursor: caml_runtime_events_create_cursor,
     caml_ml_runtime_events_resume: caml_ml_runtime_events_resume,
     caml_ml_runtime_events_pause: caml_ml_runtime_events_pause,
     caml_ml_runtime_events_start: caml_ml_runtime_events_start,
     caml_runtime_events_user_resolve: caml_runtime_events_user_resolve,
     caml_runtime_events_user_write: caml_runtime_events_user_write,
     caml_runtime_events_user_register: caml_runtime_events_user_register,
     caml_custom_event_index: caml_custom_event_index,
     caml_decompress_input: caml_decompress_input,
     jsoo_effect_not_supported: jsoo_effect_not_supported,
     caml_ml_condition_signal: caml_ml_condition_signal,
     caml_ml_condition_broadcast: caml_ml_condition_broadcast,
     caml_ml_condition_wait: caml_ml_condition_wait,
     caml_ml_condition_new: caml_ml_condition_new,
     caml_get_continuation_callstack: caml_get_continuation_callstack,
     caml_continuation_use_and_update_handler_noexc:
     caml_continuation_use_and_update_handler_noexc,
     caml_continuation_use_noexc: caml_continuation_use_noexc,
     caml_alloc_stack: caml_alloc_stack,
     caml_ml_mutex_unlock: caml_ml_mutex_unlock,
     caml_ml_mutex_try_lock: caml_ml_mutex_try_lock,
     caml_ml_mutex_lock: caml_ml_mutex_lock,
     caml_ml_mutex_new: caml_ml_mutex_new,
     MlMutex: MlMutex,
     caml_lxm_next: caml_lxm_next,
     caml_ml_domain_cpu_relax: caml_ml_domain_cpu_relax,
     caml_ml_domain_id: caml_ml_domain_id,
     caml_domain_spawn: caml_domain_spawn,
     caml_domain_id: caml_domain_id,
     caml_recommended_domain_count: caml_recommended_domain_count,
     caml_ml_domain_set_name: caml_ml_domain_set_name,
     caml_ml_domain_unique_token: caml_ml_domain_unique_token,
     caml_atomic_make_contended: caml_atomic_make_contended,
     caml_atomic_exchange: caml_atomic_exchange,
     caml_atomic_fetch_add: caml_atomic_fetch_add,
     caml_atomic_cas: caml_atomic_cas,
     caml_atomic_load: caml_atomic_load,
     caml_domain_dls_get: caml_domain_dls_get,
     caml_domain_dls_set: caml_domain_dls_set,
     caml_domain_dls: caml_domain_dls,
     caml_ephe_check_data: caml_ephe_check_data,
     caml_ephe_unset_data: caml_ephe_unset_data,
     caml_ephe_set_data: caml_ephe_set_data,
     caml_ephe_get_data_copy: caml_ephe_get_data_copy,
     caml_ephe_get_data: caml_ephe_get_data,
     caml_ephe_blit_data: caml_ephe_blit_data,
     caml_ephe_blit_key: caml_ephe_blit_key,
     caml_ephe_check_key: caml_ephe_check_key,
     caml_ephe_get_key_copy: caml_ephe_get_key_copy,
     caml_ephe_get_key: caml_ephe_get_key,
     caml_weak_set: caml_weak_set,
     caml_weak_create: caml_weak_create,
     caml_ephe_create: caml_ephe_create,
     caml_ephe_unset_key: caml_ephe_unset_key,
     caml_ephe_set_key: caml_ephe_set_key,
     caml_ephe_data_offset: caml_ephe_data_offset,
     caml_ephe_key_offset: caml_ephe_key_offset,
     caml_unix_inet_addr_of_string: caml_unix_inet_addr_of_string,
     caml_unix_findclose: caml_unix_findclose,
     caml_unix_findnext: caml_unix_findnext,
     caml_unix_findfirst: caml_unix_findfirst,
     caml_unix_rewinddir: caml_unix_rewinddir,
     caml_unix_closedir: caml_unix_closedir,
     caml_unix_readdir: caml_unix_readdir,
     caml_unix_opendir: caml_unix_opendir,
     caml_unix_has_symlink: caml_unix_has_symlink,
     caml_unix_getpwuid: caml_unix_getpwuid,
     caml_unix_getuid: caml_unix_getuid,
     caml_unix_unlink: caml_unix_unlink,
     caml_unix_readlink: caml_unix_readlink,
     caml_unix_symlink: caml_unix_symlink,
     caml_unix_rmdir: caml_unix_rmdir,
     caml_unix_mkdir: caml_unix_mkdir,
     caml_unix_lstat_64: caml_unix_lstat_64,
     caml_unix_lstat: caml_unix_lstat,
     caml_unix_stat_64: caml_unix_stat_64,
     caml_unix_stat: caml_unix_stat,
     make_unix_err_args: make_unix_err_args,
     caml_unix_isatty: caml_unix_isatty,
     caml_unix_filedescr_of_fd: caml_unix_filedescr_of_fd,
     caml_unix_cleanup: caml_unix_cleanup,
     caml_unix_startup: caml_unix_startup,
     caml_unix_mktime: caml_unix_mktime,
     caml_unix_localtime: caml_unix_localtime,
     caml_unix_gmtime: caml_unix_gmtime,
     caml_unix_time: caml_unix_time,
     caml_unix_gettimeofday: caml_unix_gettimeofday,
     caml_str_initialize: caml_str_initialize,
     re_replacement_text: re_replacement_text,
     re_partial_match: re_partial_match,
     re_string_match: re_string_match,
     re_search_backward: re_search_backward,
     re_search_forward: re_search_forward,
     re_match: re_match,
     caml_sys_is_regular_file: caml_sys_is_regular_file,
     caml_spacetime_only_works_for_native_code:
     caml_spacetime_only_works_for_native_code,
     caml_register_channel_for_spacetime: caml_register_channel_for_spacetime,
     caml_sys_const_naked_pointers_checked:
     caml_sys_const_naked_pointers_checked,
     caml_spacetime_enabled: caml_spacetime_enabled,
     caml_ml_runtime_warnings_enabled: caml_ml_runtime_warnings_enabled,
     caml_ml_enable_runtime_warnings: caml_ml_enable_runtime_warnings,
     caml_runtime_warnings: caml_runtime_warnings,
     caml_install_signal_handler: caml_install_signal_handler,
     caml_runtime_parameters: caml_runtime_parameters,
     caml_runtime_variant: caml_runtime_variant,
     caml_sys_isatty: caml_sys_isatty,
     caml_sys_get_config: caml_sys_get_config,
     os_type: os_type,
     caml_sys_const_backend_type: caml_sys_const_backend_type,
     caml_sys_const_ostype_cygwin: caml_sys_const_ostype_cygwin,
     caml_sys_const_ostype_win32: caml_sys_const_ostype_win32,
     caml_sys_const_ostype_unix: caml_sys_const_ostype_unix,
     caml_sys_const_max_wosize: caml_sys_const_max_wosize,
     caml_sys_const_int_size: caml_sys_const_int_size,
     caml_sys_const_word_size: caml_sys_const_word_size,
     caml_sys_const_big_endian: caml_sys_const_big_endian,
     caml_sys_random_seed: caml_sys_random_seed,
     caml_sys_time_include_children: caml_sys_time_include_children,
     caml_sys_time: caml_sys_time,
     caml_sys_system_command: caml_sys_system_command,
     caml_sys_executable_name: caml_sys_executable_name,
     caml_sys_modify_argv: caml_sys_modify_argv,
     caml_sys_argv: caml_sys_argv,
     caml_sys_get_argv: caml_sys_get_argv,
     caml_executable_name: caml_executable_name,
     caml_argv: caml_argv,
     caml_sys_unsafe_getenv: caml_sys_unsafe_getenv,
     caml_sys_getenv: caml_sys_getenv,
     jsoo_sys_getenv: jsoo_sys_getenv,
     caml_set_static_env: caml_set_static_env,
     caml_fatal_uncaught_exception: caml_fatal_uncaught_exception,
     caml_format_exception: caml_format_exception,
     caml_is_special_exception: caml_is_special_exception,
     caml_sys_exit: caml_sys_exit,
     caml_raise_sys_error: caml_raise_sys_error,
     caml_maybe_print_stats: caml_maybe_print_stats,
     caml_is_printable: caml_is_printable,
     caml_get_global_data: caml_get_global_data,
     caml_register_global: caml_register_global,
     caml_build_symbols: caml_build_symbols,
     caml_global_data: caml_global_data,
     caml_named_value: caml_named_value,
     caml_register_named_value: caml_register_named_value,
     caml_named_values: caml_named_values,
     caml_call_gen: caml_call_gen,
     caml_set_parser_trace: caml_set_parser_trace,
     caml_parse_engine: caml_parse_engine,
     caml_parser_trace: caml_parser_trace,
     caml_is_continuation_tag: caml_is_continuation_tag,
     caml_lazy_read_result: caml_lazy_read_result,
     caml_lazy_reset_to_lazy: caml_lazy_reset_to_lazy,
     caml_lazy_update_to_forward: caml_lazy_update_to_forward,
     caml_lazy_update_to_forcing: caml_lazy_update_to_forcing,
     caml_obj_update_tag: caml_obj_update_tag,
     caml_obj_add_offset: caml_obj_add_offset,
     caml_obj_reachable_words: caml_obj_reachable_words,
     caml_obj_set_raw_field: caml_obj_set_raw_field,
     caml_obj_raw_field: caml_obj_raw_field,
     caml_fresh_oo_id: caml_fresh_oo_id,
     caml_set_oo_id: caml_set_oo_id,
     caml_oo_last_id: caml_oo_last_id,
     caml_get_public_method: caml_get_public_method,
     caml_lazy_make_forward: caml_lazy_make_forward,
     caml_obj_is_shared: caml_obj_is_shared,
     caml_obj_compare_and_swap: caml_obj_compare_and_swap,
     caml_obj_make_forward: caml_obj_make_forward,
     caml_obj_truncate: caml_obj_truncate,
     caml_obj_dup: caml_obj_dup,
     caml_obj_with_tag: caml_obj_with_tag,
     caml_obj_block: caml_obj_block,
     caml_obj_set_tag: caml_obj_set_tag,
     caml_obj_tag: caml_obj_tag,
     caml_obj_is_block: caml_obj_is_block,
     caml_alloc_dummy_infix: caml_alloc_dummy_infix,
     caml_update_dummy: caml_update_dummy,
     deserialize_nat: deserialize_nat,
     serialize_nat: serialize_nat,
     lxor_digit_nat: lxor_digit_nat,
     lor_digit_nat: lor_digit_nat,
     land_digit_nat: land_digit_nat,
     compare_nat_real: compare_nat_real,
     compare_nat: compare_nat,
     compare_digits_nat: compare_digits_nat,
     shift_right_nat: shift_right_nat,
     div_nat: div_nat,
     div_digit_nat: div_digit_nat,
     div_helper: div_helper,
     shift_left_nat: shift_left_nat,
     square_nat: square_nat,
     mult_nat: mult_nat,
     mult_digit_nat: mult_digit_nat,
     sub_nat: sub_nat,
     decr_nat: decr_nat,
     complement_nat: complement_nat,
     add_nat: add_nat,
     incr_nat: incr_nat,
     is_digit_odd: is_digit_odd,
     is_digit_zero: is_digit_zero,
     is_digit_int: is_digit_int,
     num_leading_zero_bits_in_digit: num_leading_zero_bits_in_digit,
     num_digits_nat: num_digits_nat,
     nth_digit_nat_native: nth_digit_nat_native,
     set_digit_nat_native: set_digit_nat_native,
     nth_digit_nat: nth_digit_nat,
     set_digit_nat: set_digit_nat,
     blit_nat: blit_nat,
     set_to_zero_nat: set_to_zero_nat,
     create_nat: create_nat,
     nat_of_array: nat_of_array,
     length_nat: length_nat,
     caml_hash_nat: caml_hash_nat,
     MlNat: MlNat,
     initialize_nat: initialize_nat,
     caml_array_of_bytes: caml_array_of_bytes,
     caml_array_of_string: caml_array_of_string,
     caml_js_to_string: caml_js_to_string,
     caml_to_js_string: caml_to_js_string,
     caml_js_from_string: caml_js_from_string,
     caml_new_string: caml_new_string,
     caml_js_to_byte_string: caml_js_to_byte_string,
     caml_is_ml_string: caml_is_ml_string,
     caml_ml_bytes_content: caml_ml_bytes_content,
     caml_is_ml_bytes: caml_is_ml_bytes,
     caml_bytes_of_jsbytes: caml_bytes_of_jsbytes,
     caml_string_of_jsstring: caml_string_of_jsstring,
     caml_jsstring_of_string: caml_jsstring_of_string,
     caml_jsbytes_of_string: caml_jsbytes_of_string,
     caml_string_of_jsbytes: caml_string_of_jsbytes,
     caml_bytes_of_string: caml_bytes_of_string,
     caml_string_of_bytes: caml_string_of_bytes,
     caml_string_lessthan: caml_string_lessthan,
     caml_string_lessequal: caml_string_lessequal,
     caml_string_equal: caml_string_equal,
     caml_string_compare: caml_string_compare,
     caml_ml_string_length: caml_ml_string_length,
     caml_string_unsafe_set: caml_string_unsafe_set,
     caml_string_unsafe_get: caml_string_unsafe_get,
     caml_string_concat: caml_string_concat,
     caml_ml_bytes_length: caml_ml_bytes_length,
     caml_blit_string: caml_blit_string,
     caml_blit_bytes: caml_blit_bytes,
     caml_fill_bytes: caml_fill_bytes,
     caml_bytes_greaterthan: caml_bytes_greaterthan,
     caml_string_greaterthan: caml_string_greaterthan,
     caml_bytes_greaterequal: caml_bytes_greaterequal,
     caml_string_greaterequal: caml_string_greaterequal,
     caml_bytes_lessthan: caml_bytes_lessthan,
     caml_bytes_lessequal: caml_bytes_lessequal,
     caml_bytes_notequal: caml_bytes_notequal,
     caml_string_notequal: caml_string_notequal,
     caml_bytes_equal: caml_bytes_equal,
     caml_bytes_compare: caml_bytes_compare,
     caml_bytes_of_array: caml_bytes_of_array,
     caml_string_of_array: caml_string_of_array,
     caml_create_bytes: caml_create_bytes,
     caml_create_string: caml_create_string,
     caml_uint8_array_of_string: caml_uint8_array_of_string,
     caml_uint8_array_of_bytes: caml_uint8_array_of_bytes,
     caml_convert_bytes_to_array: caml_convert_bytes_to_array,
     caml_convert_string_to_bytes: caml_convert_string_to_bytes,
     MlBytes: MlBytes,
     caml_bytes_of_utf16_jsstring: caml_bytes_of_utf16_jsstring,
     caml_bytes_set: caml_bytes_set,
     caml_string_set64: caml_string_set64,
     caml_bytes_set64: caml_bytes_set64,
     caml_string_set32: caml_string_set32,
     caml_bytes_set32: caml_bytes_set32,
     caml_string_set16: caml_string_set16,
     caml_bytes_set16: caml_bytes_set16,
     caml_string_set: caml_string_set,
     caml_bytes_get: caml_bytes_get,
     caml_bytes_get64: caml_bytes_get64,
     caml_string_get64: caml_string_get64,
     caml_bytes_get32: caml_bytes_get32,
     caml_string_get32: caml_string_get32,
     caml_bytes_get16: caml_bytes_get16,
     caml_string_get16: caml_string_get16,
     caml_string_get: caml_string_get,
     caml_bytes_bound_error: caml_bytes_bound_error,
     caml_string_bound_error: caml_string_bound_error,
     caml_bytes_unsafe_set: caml_bytes_unsafe_set,
     caml_bytes_unsafe_get: caml_bytes_unsafe_get,
     jsoo_is_ascii: jsoo_is_ascii,
     caml_utf16_of_utf8: caml_utf16_of_utf8,
     caml_utf8_of_utf16: caml_utf8_of_utf16,
     caml_subarray_to_jsbytes: caml_subarray_to_jsbytes,
     caml_str_repeat: caml_str_repeat,
     caml_md5_bytes: caml_md5_bytes,
     caml_MD5Final: caml_MD5Final,
     caml_MD5Update: caml_MD5Update,
     caml_MD5Init: caml_MD5Init,
     caml_MD5Transform: caml_MD5Transform,
     caml_md5_string: caml_md5_string,
     caml_md5_chan: caml_md5_chan,
     caml_output_value_to_buffer: caml_output_value_to_buffer,
     caml_output_value_to_bytes: caml_output_value_to_bytes,
     caml_output_value_to_string: caml_output_value_to_string,
     caml_output_val: caml_output_val,
     MlObjectTable: MlObjectTable,
     caml_marshal_data_size: caml_marshal_data_size,
     caml_marshal_header_size: caml_marshal_header_size,
     caml_input_value_from_reader: caml_input_value_from_reader,
     caml_custom_ops: caml_custom_ops,
     caml_nativeint_unmarshal: caml_nativeint_unmarshal,
     caml_int32_unmarshal: caml_int32_unmarshal,
     caml_int64_marshal: caml_int64_marshal,
     caml_int64_unmarshal: caml_int64_unmarshal,
     caml_input_value_from_bytes: caml_input_value_from_bytes,
     caml_input_value_from_string: caml_input_value_from_string,
     caml_float_of_bytes: caml_float_of_bytes,
     BigStringReader: BigStringReader,
     MlStringReader: MlStringReader,
     UInt8ArrayReader: UInt8ArrayReader,
     caml_marshal_constants: caml_marshal_constants,
     caml_new_lex_engine: caml_new_lex_engine,
     caml_lex_engine: caml_lex_engine,
     caml_lex_array: caml_lex_array,
     caml_js_error_of_exception: caml_js_error_of_exception,
     caml_xmlhttprequest_create: caml_xmlhttprequest_create,
     caml_js_get_console: caml_js_get_console,
     caml_js_html_entities: caml_js_html_entities,
     caml_js_html_escape: caml_js_html_escape,
     caml_js_on_ie: caml_js_on_ie,
     caml_js_object: caml_js_object,
     caml_pure_js_expr: caml_pure_js_expr,
     caml_js_expr: caml_js_expr,
     caml_js_eval_string: caml_js_eval_string,
     caml_js_strict_equals: caml_js_strict_equals,
     caml_js_equals: caml_js_equals,
     caml_js_function_arity: caml_js_function_arity,
     caml_js_wrap_meth_callback_unsafe: caml_js_wrap_meth_callback_unsafe,
     caml_js_wrap_meth_callback_strict: caml_js_wrap_meth_callback_strict,
     caml_js_wrap_meth_callback_arguments:
     caml_js_wrap_meth_callback_arguments,
     caml_js_wrap_meth_callback: caml_js_wrap_meth_callback,
     caml_js_wrap_callback_unsafe: caml_js_wrap_callback_unsafe,
     caml_js_wrap_callback_strict: caml_js_wrap_callback_strict,
     caml_js_wrap_callback_arguments: caml_js_wrap_callback_arguments,
     caml_js_wrap_callback: caml_js_wrap_callback,
     caml_ojs_new_arr: caml_ojs_new_arr,
     caml_js_new: caml_js_new,
     caml_js_meth_call: caml_js_meth_call,
     caml_js_fun_call: caml_js_fun_call,
     caml_js_call: caml_js_call,
     caml_js_var: caml_js_var,
     caml_list_to_js_array: caml_list_to_js_array,
     caml_list_of_js_array: caml_list_of_js_array,
     caml_js_to_array: caml_js_to_array,
     caml_js_from_array: caml_js_from_array,
     caml_js_to_int32: caml_js_to_int32,
     caml_js_to_float: caml_js_to_float,
     caml_js_from_float: caml_js_from_float,
     caml_js_to_bool: caml_js_to_bool,
     caml_js_from_bool: caml_js_from_bool,
     caml_js_error_option_of_exception: caml_js_error_option_of_exception,
     caml_exn_with_js_backtrace: caml_exn_with_js_backtrace,
     caml_maybe_attach_backtrace: caml_maybe_attach_backtrace,
     caml_wrap_exception: caml_wrap_exception,
     caml_jsoo_flags_effects: caml_jsoo_flags_effects,
     caml_jsoo_flags_use_js_string: caml_jsoo_flags_use_js_string,
     caml_is_js: caml_is_js,
     caml_callback: caml_callback,
     caml_trampoline_return: caml_trampoline_return,
     caml_trampoline: caml_trampoline,
     caml_js_typeof: caml_js_typeof,
     caml_js_instanceof: caml_js_instanceof,
     caml_js_delete: caml_js_delete,
     caml_js_get: caml_js_get,
     caml_js_set: caml_js_set,
     caml_js_pure_expr: caml_js_pure_expr,
     caml_ml_set_buffered: caml_ml_set_buffered,
     caml_ml_is_buffered: caml_ml_is_buffered,
     caml_ml_output_int: caml_ml_output_int,
     caml_ml_pos_out_64: caml_ml_pos_out_64,
     caml_ml_pos_out: caml_ml_pos_out,
     caml_pos_out: caml_pos_out,
     caml_ml_seek_out_64: caml_ml_seek_out_64,
     caml_ml_seek_out: caml_ml_seek_out,
     caml_seek_out: caml_seek_out,
     caml_output_value: caml_output_value,
     caml_ml_output_char: caml_ml_output_char,
     caml_ml_output: caml_ml_output,
     caml_ml_output_bigarray: caml_ml_output_bigarray,
     caml_ml_output_bytes: caml_ml_output_bytes,
     caml_ml_output_ta: caml_ml_output_ta,
     caml_ml_flush: caml_ml_flush,
     caml_ml_input_scan_line: caml_ml_input_scan_line,
     caml_ml_pos_in_64: caml_ml_pos_in_64,
     caml_ml_pos_in: caml_ml_pos_in,
     caml_pos_in: caml_pos_in,
     caml_ml_seek_in_64: caml_ml_seek_in_64,
     caml_ml_seek_in: caml_ml_seek_in,
     caml_seek_in: caml_seek_in,
     caml_ml_input_int: caml_ml_input_int,
     caml_ml_input_char: caml_ml_input_char,
     caml_input_value_to_outside_heap: caml_input_value_to_outside_heap,
     caml_input_value: caml_input_value,
     caml_ml_input_block: caml_ml_input_block,
     caml_ml_input_bigarray: caml_ml_input_bigarray,
     caml_ml_input: caml_ml_input,
     caml_refill: caml_refill,
     caml_ml_set_channel_refill: caml_ml_set_channel_refill,
     caml_ml_set_channel_output: caml_ml_set_channel_output,
     caml_ml_channel_size_64: caml_ml_channel_size_64,
     caml_ml_channel_size: caml_ml_channel_size,
     caml_ml_close_channel: caml_ml_close_channel,
     caml_ml_set_binary_mode: caml_ml_set_binary_mode,
     caml_channel_descriptor: caml_channel_descriptor,
     caml_ml_open_descriptor_in: caml_ml_open_descriptor_in,
     caml_ml_open_descriptor_out: caml_ml_open_descriptor_out,
     caml_ml_out_channels_list: caml_ml_out_channels_list,
     caml_ml_channel_get: caml_ml_channel_get,
     caml_ml_channel_restore: caml_ml_channel_restore,
     caml_ml_channel_redirect: caml_ml_channel_redirect,
     caml_ml_channels: caml_ml_channels,
     caml_ml_set_channel_name: caml_ml_set_channel_name,
     caml_sys_open: caml_sys_open,
     caml_sys_close: caml_sys_close,
     caml_sys_fds: caml_sys_fds,
     caml_int64_bswap: caml_int64_bswap,
     caml_int32_bswap: caml_int32_bswap,
     caml_bswap16: caml_bswap16,
     caml_mod: caml_mod,
     caml_div: caml_div,
     caml_mul: caml_mul,
     caml_int_of_string: caml_int_of_string,
     caml_parse_digit: caml_parse_digit,
     caml_parse_sign_and_base: caml_parse_sign_and_base,
     caml_format_int: caml_format_int,
     caml_int64_hash: caml_int64_hash,
     caml_int64_to_bytes: caml_int64_to_bytes,
     caml_int64_of_bytes: caml_int64_of_bytes,
     caml_int64_hi32: caml_int64_hi32,
     caml_int64_lo32: caml_int64_lo32,
     caml_int64_create_lo_hi: caml_int64_create_lo_hi,
     caml_int64_create_lo_mi_hi: caml_int64_create_lo_mi_hi,
     caml_int64_of_string: caml_int64_of_string,
     caml_int64_format: caml_int64_format,
     caml_int64_of_float: caml_int64_of_float,
     caml_int64_to_float: caml_int64_to_float,
     caml_int64_to_int32: caml_int64_to_int32,
     caml_int64_of_int32: caml_int64_of_int32,
     caml_int64_mod: caml_int64_mod,
     caml_int64_div: caml_int64_div,
     caml_int64_shift_right: caml_int64_shift_right,
     caml_int64_shift_right_unsigned: caml_int64_shift_right_unsigned,
     caml_int64_shift_left: caml_int64_shift_left,
     caml_int64_xor: caml_int64_xor,
     caml_int64_or: caml_int64_or,
     caml_int64_and: caml_int64_and,
     caml_int64_is_negative: caml_int64_is_negative,
     caml_int64_is_zero: caml_int64_is_zero,
     caml_int64_mul: caml_int64_mul,
     caml_int64_sub: caml_int64_sub,
     caml_int64_add: caml_int64_add,
     caml_int64_neg: caml_int64_neg,
     caml_int64_compare: caml_int64_compare,
     caml_int64_ult: caml_int64_ult,
     MlInt64: MlInt64,
     caml_int64_offset: caml_int64_offset,
     caml_float_of_string: caml_float_of_string,
     caml_format_float: caml_format_float,
     caml_fma_float: caml_fma_float,
     caml_erfc_float: caml_erfc_float,
     caml_erf_float: caml_erf_float,
     caml_cbrt_float: caml_cbrt_float,
     caml_round_float: caml_round_float,
     caml_atanh_float: caml_atanh_float,
     caml_tanh_float: caml_tanh_float,
     caml_asinh_float: caml_asinh_float,
     caml_sinh_float: caml_sinh_float,
     caml_acosh_float: caml_acosh_float,
     caml_cosh_float: caml_cosh_float,
     caml_log10_float: caml_log10_float,
     caml_hypot_float: caml_hypot_float,
     caml_log2_float: caml_log2_float,
     caml_log1p_float: caml_log1p_float,
     caml_exp2_float: caml_exp2_float,
     caml_expm1_float: caml_expm1_float,
     caml_signbit_float: caml_signbit_float,
     caml_copysign_float: caml_copysign_float,
     caml_float_compare: caml_float_compare,
     caml_frexp_float: caml_frexp_float,
     caml_ldexp_float: caml_ldexp_float,
     caml_modf_float: caml_modf_float,
     caml_classify_float: caml_classify_float,
     caml_int32_float_of_bits: caml_int32_float_of_bits,
     caml_trunc_float: caml_trunc_float,
     caml_nextafter_float: caml_nextafter_float,
     caml_int64_float_of_bits: caml_int64_float_of_bits,
     caml_hexstring_of_float: caml_hexstring_of_float,
     caml_int32_bits_of_float: caml_int32_bits_of_float,
     caml_int64_bits_of_float: caml_int64_bits_of_float,
     jsoo_floor_log2: jsoo_floor_log2,
     caml_string_hash: caml_string_hash,
     caml_hash: caml_hash,
     caml_hash_mix_string: caml_hash_mix_string,
     caml_hash_mix_bytes: caml_hash_mix_bytes,
     caml_hash_mix_bytes_arr: caml_hash_mix_bytes_arr,
     caml_hash_mix_jsbytes: caml_hash_mix_jsbytes,
     caml_hash_mix_int64: caml_hash_mix_int64,
     caml_hash_mix_float: caml_hash_mix_float,
     caml_hash_mix_final: caml_hash_mix_final,
     caml_hash_mix_int: caml_hash_mix_int,
     caml_gr_close_subwindow: caml_gr_close_subwindow,
     caml_gr_open_subwindow: caml_gr_open_subwindow,
     caml_gr_window_id: caml_gr_window_id,
     caml_gr_display_mode: caml_gr_display_mode,
     caml_gr_remember_mode: caml_gr_remember_mode,
     caml_gr_synchronize: caml_gr_synchronize,
     caml_gr_wait_event: caml_gr_wait_event,
     caml_gr_sigio_signal: caml_gr_sigio_signal,
     caml_gr_sigio_handler: caml_gr_sigio_handler,
     caml_gr_blit_image: caml_gr_blit_image,
     caml_gr_create_image: caml_gr_create_image,
     caml_gr_draw_image: caml_gr_draw_image,
     caml_gr_dump_image: caml_gr_dump_image,
     caml_gr_make_image: caml_gr_make_image,
     caml_gr_text_size: caml_gr_text_size,
     caml_gr_set_text_size: caml_gr_set_text_size,
     caml_gr_set_font: caml_gr_set_font,
     caml_gr_draw_string: caml_gr_draw_string,
     caml_gr_draw_char: caml_gr_draw_char,
     caml_gr_draw_str: caml_gr_draw_str,
     caml_gr_fill_arc: caml_gr_fill_arc,
     caml_gr_fill_poly: caml_gr_fill_poly,
     caml_gr_fill_rect: caml_gr_fill_rect,
     caml_gr_set_line_width: caml_gr_set_line_width,
     caml_gr_draw_arc: caml_gr_draw_arc,
     caml_gr_arc_aux: caml_gr_arc_aux,
     caml_gr_draw_rect: caml_gr_draw_rect,
     caml_gr_lineto: caml_gr_lineto,
     caml_gr_current_y: caml_gr_current_y,
     caml_gr_current_x: caml_gr_current_x,
     caml_gr_moveto: caml_gr_moveto,
     caml_gr_point_color: caml_gr_point_color,
     caml_gr_plot: caml_gr_plot,
     caml_gr_set_color: caml_gr_set_color,
     caml_gr_size_y: caml_gr_size_y,
     caml_gr_size_x: caml_gr_size_x,
     caml_gr_clear_graph: caml_gr_clear_graph,
     caml_gr_resize_window: caml_gr_resize_window,
     caml_gr_set_window_title: caml_gr_set_window_title,
     caml_gr_close_graph: caml_gr_close_graph,
     caml_gr_doc_of_state: caml_gr_doc_of_state,
     caml_gr_state_create: caml_gr_state_create,
     caml_gr_state_init: caml_gr_state_init,
     caml_gr_open_graph: caml_gr_open_graph,
     caml_gr_state_set: caml_gr_state_set,
     caml_gr_state_get: caml_gr_state_get,
     caml_gr_state: caml_gr_state,
     caml_get_major_credit: caml_get_major_credit,
     caml_get_major_bucket: caml_get_major_bucket,
     caml_get_minor_free: caml_get_minor_free,
     caml_gc_minor_words: caml_gc_minor_words,
     caml_gc_major_slice: caml_gc_major_slice,
     caml_gc_huge_fallback_count: caml_gc_huge_fallback_count,
     caml_eventlog_pause: caml_eventlog_pause,
     caml_eventlog_resume: caml_eventlog_resume,
     caml_memprof_discard: caml_memprof_discard,
     caml_memprof_stop: caml_memprof_stop,
     caml_memprof_start: caml_memprof_start,
     caml_final_release: caml_final_release,
     caml_final_register_called_without_value:
     caml_final_register_called_without_value,
     caml_final_register: caml_final_register,
     caml_memprof_set: caml_memprof_set,
     caml_gc_get: caml_gc_get,
     caml_gc_set: caml_gc_set,
     caml_gc_stat: caml_gc_stat,
     caml_gc_quick_stat: caml_gc_quick_stat,
     caml_gc_counters: caml_gc_counters,
     caml_gc_compaction: caml_gc_compaction,
     caml_gc_full_major: caml_gc_full_major,
     caml_gc_major: caml_gc_major,
     caml_gc_minor: caml_gc_minor,
     caml_sys_open_for_node: caml_sys_open_for_node,
     MlNodeFd: MlNodeFd,
     MlNodeDevice: MlNodeDevice,
     fs_node_supported: fs_node_supported,
     MlFakeFd: MlFakeFd,
     MlFakeFd_out: MlFakeFd_out,
     MlFakeFile: MlFakeFile,
     MlFakeDevice: MlFakeDevice,
     caml_read_file_content: caml_read_file_content,
     jsoo_create_file: jsoo_create_file,
     caml_create_file: caml_create_file,
     caml_fs_init: caml_fs_init,
     jsoo_create_file_extern: jsoo_create_file_extern,
     caml_ba_map_file_bytecode: caml_ba_map_file_bytecode,
     caml_ba_map_file: caml_ba_map_file,
     caml_sys_rmdir: caml_sys_rmdir,
     caml_sys_mkdir: caml_sys_mkdir,
     caml_sys_rename: caml_sys_rename,
     caml_sys_is_directory: caml_sys_is_directory,
     caml_sys_remove: caml_sys_remove,
     caml_sys_read_directory: caml_sys_read_directory,
     caml_sys_file_exists: caml_sys_file_exists,
     caml_raise_not_a_dir: caml_raise_not_a_dir,
     caml_raise_no_such_file: caml_raise_no_such_file,
     caml_sys_chdir: caml_sys_chdir,
     caml_sys_getcwd: caml_sys_getcwd,
     caml_unmount: caml_unmount,
     caml_mount_autoload: caml_mount_autoload,
     resolve_fs_device: resolve_fs_device,
     caml_list_mount_point: caml_list_mount_point,
     jsoo_mount_point: jsoo_mount_point,
     caml_make_path: caml_make_path,
     path_is_absolute: path_is_absolute,
     MlFile: MlFile,
     caml_root: caml_root,
     caml_get_root: caml_get_root,
     caml_current_dir: caml_current_dir,
     caml_trailing_slash: caml_trailing_slash,
     caml_finish_formatting: caml_finish_formatting,
     caml_parse_format: caml_parse_format,
     caml_array_bound_error: caml_array_bound_error,
     caml_raise_not_found: caml_raise_not_found,
     caml_raise_zero_divide: caml_raise_zero_divide,
     caml_raise_end_of_file: caml_raise_end_of_file,
     caml_invalid_argument: caml_invalid_argument,
     caml_failwith: caml_failwith,
     caml_raise_with_string: caml_raise_with_string,
     caml_raise_with_args: caml_raise_with_args,
     caml_raise_with_arg: caml_raise_with_arg,
     caml_raise_constant: caml_raise_constant,
     caml_lessthan: caml_lessthan,
     caml_lessequal: caml_lessequal,
     caml_greaterthan: caml_greaterthan,
     caml_greaterequal: caml_greaterequal,
     caml_notequal: caml_notequal,
     caml_equal: caml_equal,
     caml_int_compare: caml_int_compare,
     caml_compare: caml_compare,
     caml_compare_val: caml_compare_val,
     caml_compare_val_number_custom: caml_compare_val_number_custom,
     caml_compare_val_get_custom: caml_compare_val_get_custom,
     caml_compare_val_tag: caml_compare_val_tag,
     caml_bigstring_blit_ba_to_bytes: caml_bigstring_blit_ba_to_bytes,
     caml_bigstring_blit_bytes_to_ba: caml_bigstring_blit_bytes_to_ba,
     caml_bigstring_blit_string_to_ba: caml_bigstring_blit_string_to_ba,
     caml_bigstring_blit_ba_to_ba: caml_bigstring_blit_ba_to_ba,
     caml_bigstring_memcmp: caml_bigstring_memcmp,
     bigstring_of_typed_array: bigstring_of_typed_array,
     bigstring_of_array_buffer: bigstring_of_array_buffer,
     bigstring_to_typed_array: bigstring_to_typed_array,
     bigstring_to_array_buffer: bigstring_to_array_buffer,
     caml_hash_mix_bigstring: caml_hash_mix_bigstring,
     caml_ba_from_typed_array: caml_ba_from_typed_array,
     caml_ba_kind_of_typed_array: caml_ba_kind_of_typed_array,
     caml_ba_to_typed_array: caml_ba_to_typed_array,
     caml_ba_hash: caml_ba_hash,
     caml_ba_create_from: caml_ba_create_from,
     caml_ba_deserialize: caml_ba_deserialize,
     caml_ba_serialize: caml_ba_serialize,
     caml_ba_reshape: caml_ba_reshape,
     caml_ba_slice: caml_ba_slice,
     caml_ba_sub: caml_ba_sub,
     caml_ba_blit: caml_ba_blit,
     caml_ba_fill: caml_ba_fill,
     caml_ba_set_3: caml_ba_set_3,
     caml_ba_set_2: caml_ba_set_2,
     caml_ba_set_1: caml_ba_set_1,
     caml_ba_uint8_set64: caml_ba_uint8_set64,
     caml_ba_uint8_set32: caml_ba_uint8_set32,
     caml_ba_uint8_set16: caml_ba_uint8_set16,
     caml_ba_set_generic: caml_ba_set_generic,
     caml_ba_get_3: caml_ba_get_3,
     caml_ba_get_2: caml_ba_get_2,
     caml_ba_get_1: caml_ba_get_1,
     caml_ba_uint8_get64: caml_ba_uint8_get64,
     caml_ba_uint8_get32: caml_ba_uint8_get32,
     caml_ba_uint8_get16: caml_ba_uint8_get16,
     caml_ba_get_generic: caml_ba_get_generic,
     caml_ba_dim_3: caml_ba_dim_3,
     caml_ba_dim_2: caml_ba_dim_2,
     caml_ba_dim_1: caml_ba_dim_1,
     caml_ba_dim: caml_ba_dim,
     caml_ba_num_dims: caml_ba_num_dims,
     caml_ba_layout: caml_ba_layout,
     caml_ba_kind: caml_ba_kind,
     caml_ba_change_layout: caml_ba_change_layout,
     caml_ba_create: caml_ba_create,
     caml_ba_create_unsafe: caml_ba_create_unsafe,
     caml_ba_compare: caml_ba_compare,
     Ml_Bigarray_c_1_1: Ml_Bigarray_c_1_1,
     Ml_Bigarray: Ml_Bigarray,
     caml_ba_custom_name: caml_ba_custom_name,
     caml_ba_create_buffer: caml_ba_create_buffer,
     caml_ba_get_size_per_element: caml_ba_get_size_per_element,
     caml_ba_get_size: caml_ba_get_size,
     caml_ba_init: caml_ba_init,
     caml_convert_raw_backtrace_slot: caml_convert_raw_backtrace_slot,
     caml_get_current_callstack: caml_get_current_callstack,
     caml_restore_raw_backtrace: caml_restore_raw_backtrace,
     caml_raw_backtrace_slot: caml_raw_backtrace_slot,
     caml_raw_backtrace_next_slot: caml_raw_backtrace_next_slot,
     caml_raw_backtrace_length: caml_raw_backtrace_length,
     caml_convert_raw_backtrace: caml_convert_raw_backtrace,
     caml_record_backtrace: caml_record_backtrace,
     caml_get_exception_raw_backtrace: caml_get_exception_raw_backtrace,
     caml_get_exception_backtrace: caml_get_exception_backtrace,
     caml_backtrace_status: caml_backtrace_status,
     caml_ml_debug_info_status: caml_ml_debug_info_status,
     caml_record_backtrace_flag: caml_record_backtrace_flag,
     caml_floatarray_create: caml_floatarray_create,
     caml_make_float_vect: caml_make_float_vect,
     caml_make_vect: caml_make_vect,
     caml_check_bound: caml_check_bound,
     caml_array_fill: caml_array_fill,
     caml_array_get: caml_array_get,
     caml_array_set: caml_array_set,
     caml_floatarray_blit: caml_floatarray_blit,
     caml_array_blit: caml_array_blit,
     caml_array_concat: caml_array_concat,
     caml_array_append: caml_array_append,
     caml_array_sub: caml_array_sub};
   var
    cst_Assert_failure = "Assert_failure",
    cst_Division_by_zero = "Division_by_zero",
    cst_End_of_file = "End_of_file",
    cst_Failure = "Failure",
    cst_Invalid_argument = "Invalid_argument",
    cst_Match_failure = "Match_failure",
    cst_Not_found = "Not_found",
    cst_Out_of_memory = "Out_of_memory",
    cst_Stack_overflow = "Stack_overflow",
    cst_Sys_blocked_io = "Sys_blocked_io",
    cst_Sys_error = "Sys_error",
    cst_Undefined_recursive_module = "Undefined_recursive_module";
   caml_fs_init();
   caml_register_global(0, [248, cst_Out_of_memory, -1], cst_Out_of_memory);
   caml_register_global(1, [248, cst_Sys_error, -2], cst_Sys_error);
   caml_register_global(2, [248, cst_Failure, -3], cst_Failure);
   caml_register_global
    (3, [248, cst_Invalid_argument, -4], cst_Invalid_argument);
   caml_register_global(4, [248, cst_End_of_file, -5], cst_End_of_file);
   caml_register_global
    (5, [248, cst_Division_by_zero, -6], cst_Division_by_zero);
   caml_register_global(6, [248, cst_Not_found, -7], cst_Not_found);
   caml_register_global(7, [248, cst_Match_failure, -8], cst_Match_failure);
   caml_register_global(8, [248, cst_Stack_overflow, -9], cst_Stack_overflow);
   caml_register_global(9, [248, cst_Sys_blocked_io, -10], cst_Sys_blocked_io);
   caml_register_global
    (10, [248, cst_Assert_failure, -11], cst_Assert_failure);
   caml_register_global
    (11,
     [248, cst_Undefined_recursive_module, -12],
     cst_Undefined_recursive_module);
   return;
  }
  (globalThis));


(function(a){"use strict";var
t="Sys_error",ao="Stdlib__Obj",ap="Stdlib__Unit",ay="Stdlib__Nativeint",l="Stdlib__Gc",ax="Stdlib__Stack",s="CamlinternalFormat",S="Stdlib__Genlex",av="Stdlib__Random",r="Stdlib__Pervasives",q="Dune__exe__Ppm_dump",B="Stack_overflow",ac="Stdlib__ArrayLabels",af="Stdlib__Either",aj="Stdlib__Printexc",x="Stdlib__Map",A="Stdlib__Arg",R="Undefined_recursive_module",au="Stdlib__Array",G="Assert_failure",Q="CamlinternalFormatBasics",k="Stdlib__Lazy",P="Stdlib__Queue",w="Stdlib__Format",W="Stdlib__In_channel",f="Stdlib__Bool",F="Stdlib__BytesLabels",aF="Stdlib__Bytes",ah="Division_by_zero",ai="Unix",v="End_of_file",O="CamlinternalMod",E="Stdlib__Marshal",ab="React",aE="Out_of_memory",N="Stdlib__Parsing",ag="Stdlib__Weak",ae="Not_found",aD="Failure",e="Stdlib__Int",p="Stdlib__StdLabels",d="Stdlib__Oo",L="Stdlib__Bigarray",M="Stdlib__List",aa="Stdlib__Ephemeron",at="Stdlib__String",aC="Stdlib__Printf",V="Stdlib",as="Bigarray",an="Stdlib__Callback",U="Stdlib__Filename",am="Stdlib__Hashtbl",j="Invalid_argument",$="Stdlib__Fun",u="Stdlib__Option",z="Stdlib__Lexing",aB="Stdlib__ListLabels",al="CamlinternalAtomic",aw="Stdlib__Atomic",ak="Stdlib__MoreLabels",_="Stdlib__Result",i="Std_exit",K="Stdlib__Set",Y="OcamlCanvas",Z="Stdlib__Buffer",aA="Match_failure",h="Stdlib__StringLabels",ar="Stdlib__Complex",T="Stdlib__Int64",X="Stdlib__Out_channel",o="Stdlib__Seq",J="UnixLabels",aq="Stdlib__Sys",ad="CamlinternalLazy",I="Sys_blocked_io",y="Stdlib__Float",H="Stdlib__Uchar",g="Stdlib__Scanf",n="CamlinternalOO",az="Stdlib__Digest",m="Stdlib__Stream",D="Stdlib__Char",C="Stdlib__Int32",c=a.jsoo_runtime,b=c.caml_get_global_data();b.prim_count=902;b.symbols=[0,[0,J,77],[0,ai,76],[0,R,11],[0,t,10],[0,I,9],[0,ag,56],[0,ap,31],[0,H,26],[0,aq,17],[0,h,70],[0,at,30],[0,m,44],[0,p,72],[0,ax,42],[0,K,40],[0,o,21],[0,g,58],[0,_,23],[0,av,54],[0,P,43],[0,aC,47],[0,aj,50],[0,r,15],[0,N,39],[0,X,75],[0,u,22],[0,d,61],[0,ao,18],[0,ay,37],[0,ak,71],[0,E,32],[0,x,41],[0,aB,68],[0,M,27],[0,z,38],[0,k,20],[0,T,36],[0,C,35],[0,e,28],[0,W,74],[0,am,55],[0,S,63],[0,l,52],[0,$,51],[0,w,57],[0,y,34],[0,U,65],[0,aa,64],[0,af,16],[0,az,53],[0,ar,66],[0,D,25],[0,an,59],[0,F,69],[0,aF,29],[0,Z,45],[0,f,24],[0,L,73],[0,aw,49],[0,ac,67],[0,au,33],[0,A,48],[0,V,14],[0,i,82],[0,B,8],[0,ab,79],[0,aE,7],[0,Y,80],[0,ae,6],[0,aA,5],[0,j,4],[0,aD,3],[0,v,2],[0,q,81],[0,ah,1],[0,n,60],[0,O,62],[0,ad,19],[0,Q,12],[0,s,46],[0,al,13],[0,as,78],[0,G,0]];b.sections=[0,[0,83,[0,[0,[0,[0,[0,0,[2,G],0,[0,0,[2,as],78,0,1],2],[2,al],13,[0,0,[2,s],46,0,1],3],[2,Q],12,[0,[0,0,[2,ad],19,[0,[0,0,[2,O],62,0,1],[2,n],60,0,2],3],[2,ah],1,[0,[0,0,[2,q],81,0,1],[2,v],2,0,2],4],5],[2,aD],3,[0,[0,[0,[0,0,[2,j],4,0,1],[2,aA],5,[0,0,[2,ae],6,[0,0,[2,Y],80,0,1],2],3],[2,aE],7,[0,[0,0,[2,ab],79,0,1],[2,B],8,[0,0,[2,i],82,0,1],2],4],[2,V],14,[0,[0,[0,0,[2,A],48,0,1],[2,au],33,[0,[0,0,[2,ac],67,0,1],[2,aw],49,[0,0,[2,L],73,0,1],2],3],[2,f],24,[0,[0,[0,0,[2,Z],45,0,1],[2,aF],29,[0,[0,0,[2,F],69,0,1],[2,an],59,0,2],3],[2,D],25,[0,[0,0,[2,ar],66,0,1],[2,az],53,0,2],4],5],6],7],[2,af],16,[0,[0,[0,[0,[0,[0,0,[2,aa],64,[0,0,[2,U],65,0,1],2],[2,y],34,[0,0,[2,w],57,0,1],3],[2,$],51,[0,0,[2,l],52,[0,[0,0,[2,S],63,0,1],[2,am],55,[0,0,[2,W],74,0,1],2],3],4],[2,e],28,[0,0,[2,C],35,[0,0,[2,T],36,0,1],2],5],[2,k],20,[0,[0,[0,0,[2,z],38,0,1],[2,M],27,[0,[0,[0,0,[2,aB],68,0,1],[2,x],41,0,2],[2,E],32,[0,[0,0,[2,ak],71,0,1],[2,ay],37,0,2],3],4],[2,ao],18,[0,[0,0,[2,d],61,0,1],[2,u],22,[0,[0,0,[2,X],75,0,1],[2,N],39,0,2],3],5],6],[2,r],15,[0,[0,[0,[0,[0,0,[2,aj],50,0,1],[2,aC],47,0,2],[2,P],43,[0,[0,0,[2,av],54,0,1],[2,_],23,[0,0,[2,g],58,0,1],2],3],[2,o],21,[0,[0,0,[2,K],40,0,1],[2,ax],42,[0,[0,[0,0,[2,p],72,0,1],[2,m],44,0,2],[2,at],30,[0,0,[2,h],70,0,1],3],4],5],[2,aq],17,[0,[0,0,[2,H],26,[0,0,[2,ap],31,[0,0,[2,ag],56,0,1],2],3],[2,I],9,[0,[0,0,[2,t],10,0,1],[2,R],11,[0,0,[2,ai],76,[0,0,[2,J],77,0,1],2],3],4],6],7],8]],0,c.caml_list_of_js_array(["BUTTON","BUTTON_STATE","BUTTON_STATE_TAG","BUTTON_TAG","BigStringReader","CAP_TYPE_TAG","COMPOP_TAG","Cap_type_val","Compop_val","Draw_style_val","EVENT_TAG","FOCUS","FOCUS_TAG","JOIN_TYPE_TAG","Join_type_val","KEY","KEY_STATE","KEY_STATE_TAG","KEY_TAG","Key_code_val","MlBytes","MlFakeDevice","MlFakeFd","MlFakeFd_out","MlFakeFile","MlFile","MlInt64","MlMutex","MlNat","MlNodeDevice","MlNodeFd","MlObjectTable","MlStringReader","Ml_Bigarray","Ml_Bigarray_c_1_1","Optional_bool_val","Optional_val","REPEAT_TAG","Repeat_val","SLANT","SLANT_TAG","STYLE_TAG","Slant_val","UInt8ArrayReader","Val_button","Val_button_state","Val_cap_type","Val_compop","Val_draw_style","Val_focus_in_out","Val_join_type","Val_key_code","Val_key_state","Val_repeat","_color_of_int","_event_canvas_scale","_focus","_frame_handler","_header_down_handler","_int_of_color","_internal_canvas","_internal_ctxt","_key_down_handler","_key_up_handler","_make_key_event","_ml_canvas_adjust_blit_info","_ml_canvas_ba_of_img","_ml_canvas_decorate","_ml_canvas_ensure_initialized","_ml_canvas_image_of_png_file","_ml_canvas_initialized","_ml_canvas_mlContinuation","_ml_canvas_mlException","_ml_canvas_mlProcessEvent","_ml_canvas_process_event","_ml_canvas_surface_of_ba","_ml_canvas_valid_canvas_size","_move","_move_handler","_next_id","_resize","_resize_handler","_surface_down_handler","_up_handler","add_nat","bigstring_of_array_buffer","bigstring_of_typed_array","bigstring_to_array_buffer","bigstring_to_typed_array","blit_nat","caml_MD5Final","caml_MD5Init","caml_MD5Transform","caml_MD5Update","caml_acosh_float","caml_alloc_dummy_infix","caml_alloc_stack","caml_argv","caml_array_append","caml_array_blit","caml_array_bound_error","caml_array_concat","caml_array_fill","caml_array_get","caml_array_of_bytes","caml_array_of_string","caml_array_set","caml_array_sub","caml_asinh_float","caml_atanh_float","caml_atomic_cas","caml_atomic_exchange","caml_atomic_fetch_add","caml_atomic_load","caml_atomic_make_contended","caml_ba_blit","caml_ba_change_layout","caml_ba_compare","caml_ba_create","caml_ba_create_buffer","caml_ba_create_from","caml_ba_create_unsafe","caml_ba_custom_name","caml_ba_deserialize","caml_ba_dim","caml_ba_dim_1","caml_ba_dim_2","caml_ba_dim_3","caml_ba_fill","caml_ba_from_typed_array","caml_ba_get_1","caml_ba_get_2","caml_ba_get_3","caml_ba_get_generic","caml_ba_get_size","caml_ba_get_size_per_element","caml_ba_hash","caml_ba_init","caml_ba_kind","caml_ba_kind_of_typed_array","caml_ba_layout","caml_ba_map_file","caml_ba_map_file_bytecode","caml_ba_num_dims","caml_ba_reshape","caml_ba_serialize","caml_ba_set_1","caml_ba_set_2","caml_ba_set_3","caml_ba_set_generic","caml_ba_slice","caml_ba_sub","caml_ba_to_typed_array","caml_ba_uint8_get16","caml_ba_uint8_get32","caml_ba_uint8_get64","caml_ba_uint8_set16","caml_ba_uint8_set32","caml_ba_uint8_set64","caml_backtrace_status","caml_bigstring_blit_ba_to_ba","caml_bigstring_blit_ba_to_bytes","caml_bigstring_blit_bytes_to_ba","caml_bigstring_blit_string_to_ba","caml_bigstring_memcmp","caml_blit_bytes","caml_blit_string","caml_bswap16","caml_build_symbols","caml_bytes_bound_error","caml_bytes_compare","caml_bytes_equal","caml_bytes_get","caml_bytes_get16","caml_bytes_get32","caml_bytes_get64","caml_bytes_greaterequal","caml_bytes_greaterthan","caml_bytes_lessequal","caml_bytes_lessthan","caml_bytes_notequal","caml_bytes_of_array","caml_bytes_of_jsbytes","caml_bytes_of_string","caml_bytes_of_utf16_jsstring","caml_bytes_set","caml_bytes_set16","caml_bytes_set32","caml_bytes_set64","caml_bytes_unsafe_get","caml_bytes_unsafe_set","caml_call_gen","caml_callback","caml_cbrt_float","caml_channel_descriptor","caml_check_bound","caml_classify_float","caml_compare","caml_compare_val","caml_compare_val_get_custom","caml_compare_val_number_custom","caml_compare_val_tag","caml_continuation_use_and_update_handler_noexc","caml_continuation_use_noexc","caml_convert_bytes_to_array","caml_convert_raw_backtrace","caml_convert_raw_backtrace_slot","caml_convert_string_to_bytes","caml_copysign_float","caml_cosh_float","caml_create_bytes","caml_create_file","caml_create_string","caml_current_dir","caml_custom_event_index","caml_custom_ops","caml_decompress_input","caml_div","caml_domain_dls","caml_domain_dls_get","caml_domain_dls_set","caml_domain_id","caml_domain_spawn","caml_ephe_blit_data","caml_ephe_blit_key","caml_ephe_check_data","caml_ephe_check_key","caml_ephe_create","caml_ephe_data_offset","caml_ephe_get_data","caml_ephe_get_data_copy","caml_ephe_get_key","caml_ephe_get_key_copy","caml_ephe_key_offset","caml_ephe_set_data","caml_ephe_set_key","caml_ephe_unset_data","caml_ephe_unset_key","caml_equal","caml_erf_float","caml_erfc_float","caml_eventlog_pause","caml_eventlog_resume","caml_executable_name","caml_exn_with_js_backtrace","caml_exp2_float","caml_expm1_float","caml_failwith","caml_fatal_uncaught_exception","caml_fill_bytes","caml_final_register","caml_final_register_called_without_value","caml_final_release","caml_finish_formatting","caml_float_compare","caml_float_of_bytes","caml_float_of_string","caml_floatarray_blit","caml_floatarray_create","caml_fma_float","caml_format_exception","caml_format_float","caml_format_int","caml_fresh_oo_id","caml_frexp_float","caml_fs_init","caml_gc_compaction","caml_gc_counters","caml_gc_full_major","caml_gc_get","caml_gc_huge_fallback_count","caml_gc_major","caml_gc_major_slice","caml_gc_minor","caml_gc_minor_words","caml_gc_quick_stat","caml_gc_set","caml_gc_stat","caml_get_continuation_callstack","caml_get_current_callstack","caml_get_exception_backtrace","caml_get_exception_raw_backtrace","caml_get_global_data","caml_get_major_bucket","caml_get_major_credit","caml_get_minor_free","caml_get_public_method","caml_get_root","caml_global_data","caml_gr_arc_aux","caml_gr_blit_image","caml_gr_clear_graph","caml_gr_close_graph","caml_gr_close_subwindow","caml_gr_create_image","caml_gr_current_x","caml_gr_current_y","caml_gr_display_mode","caml_gr_doc_of_state","caml_gr_draw_arc","caml_gr_draw_char","caml_gr_draw_image","caml_gr_draw_rect","caml_gr_draw_str","caml_gr_draw_string","caml_gr_dump_image","caml_gr_fill_arc","caml_gr_fill_poly","caml_gr_fill_rect","caml_gr_lineto","caml_gr_make_image","caml_gr_moveto","caml_gr_open_graph","caml_gr_open_subwindow","caml_gr_plot","caml_gr_point_color","caml_gr_remember_mode","caml_gr_resize_window","caml_gr_set_color","caml_gr_set_font","caml_gr_set_line_width","caml_gr_set_text_size","caml_gr_set_window_title","caml_gr_sigio_handler","caml_gr_sigio_signal","caml_gr_size_x","caml_gr_size_y","caml_gr_state","caml_gr_state_create","caml_gr_state_get","caml_gr_state_init","caml_gr_state_set","caml_gr_synchronize","caml_gr_text_size","caml_gr_wait_event","caml_gr_window_id","caml_greaterequal","caml_greaterthan","caml_hash","caml_hash_mix_bigstring","caml_hash_mix_bytes","caml_hash_mix_bytes_arr","caml_hash_mix_final","caml_hash_mix_float","caml_hash_mix_int","caml_hash_mix_int64","caml_hash_mix_jsbytes","caml_hash_mix_string","caml_hash_nat","caml_hexstring_of_float","caml_hypot_float","caml_input_value","caml_input_value_from_bytes","caml_input_value_from_reader","caml_input_value_from_string","caml_input_value_to_outside_heap","caml_install_signal_handler","caml_int32_bits_of_float","caml_int32_bswap","caml_int32_float_of_bits","caml_int32_unmarshal","caml_int64_add","caml_int64_and","caml_int64_bits_of_float","caml_int64_bswap","caml_int64_compare","caml_int64_create_lo_hi","caml_int64_create_lo_mi_hi","caml_int64_div","caml_int64_float_of_bits","caml_int64_format","caml_int64_hash","caml_int64_hi32","caml_int64_is_negative","caml_int64_is_zero","caml_int64_lo32","caml_int64_marshal","caml_int64_mod","caml_int64_mul","caml_int64_neg","caml_int64_of_bytes","caml_int64_of_float","caml_int64_of_int32","caml_int64_of_string","caml_int64_offset","caml_int64_or","caml_int64_shift_left","caml_int64_shift_right","caml_int64_shift_right_unsigned","caml_int64_sub","caml_int64_to_bytes","caml_int64_to_float","caml_int64_to_int32","caml_int64_ult","caml_int64_unmarshal","caml_int64_xor","caml_int_compare","caml_int_of_string","caml_invalid_argument","caml_is_continuation_tag","caml_is_js","caml_is_ml_bytes","caml_is_ml_string","caml_is_printable","caml_is_special_exception","caml_js_call","caml_js_delete","caml_js_equals","caml_js_error_of_exception","caml_js_error_option_of_exception","caml_js_eval_string","caml_js_expr","caml_js_from_array","caml_js_from_bool","caml_js_from_float","caml_js_from_string","caml_js_fun_call","caml_js_function_arity","caml_js_get","caml_js_get_console","caml_js_html_entities","caml_js_html_escape","caml_js_instanceof","caml_js_meth_call","caml_js_new","caml_js_object","caml_js_on_ie","caml_js_pure_expr","caml_js_set","caml_js_strict_equals","caml_js_to_array","caml_js_to_bool","caml_js_to_byte_string","caml_js_to_float","caml_js_to_int32","caml_js_to_string","caml_js_typeof","caml_js_var","caml_js_wrap_callback","caml_js_wrap_callback_arguments","caml_js_wrap_callback_strict","caml_js_wrap_callback_unsafe","caml_js_wrap_meth_callback","caml_js_wrap_meth_callback_arguments","caml_js_wrap_meth_callback_strict","caml_js_wrap_meth_callback_unsafe","caml_jsbytes_of_string","caml_jsoo_flags_effects","caml_jsoo_flags_use_js_string","caml_jsstring_of_string","caml_lazy_make_forward","caml_lazy_read_result","caml_lazy_reset_to_lazy","caml_lazy_update_to_forcing","caml_lazy_update_to_forward","caml_ldexp_float","caml_lessequal","caml_lessthan","caml_lex_array","caml_lex_engine","caml_list_mount_point","caml_list_of_js_array","caml_list_to_js_array","caml_log10_float","caml_log1p_float","caml_log2_float","caml_lxm_next","caml_make_float_vect","caml_make_path","caml_make_vect","caml_marshal_constants","caml_marshal_data_size","caml_marshal_header_size","caml_maybe_attach_backtrace","caml_maybe_print_stats","caml_md5_bytes","caml_md5_chan","caml_md5_string","caml_memprof_discard","caml_memprof_set","caml_memprof_start","caml_memprof_stop","caml_ml_bytes_content","caml_ml_bytes_length","caml_ml_channel_get","caml_ml_channel_redirect","caml_ml_channel_restore","caml_ml_channel_size","caml_ml_channel_size_64","caml_ml_channels","caml_ml_close_channel","caml_ml_condition_broadcast","caml_ml_condition_new","caml_ml_condition_signal","caml_ml_condition_wait","caml_ml_debug_info_status","caml_ml_domain_cpu_relax","caml_ml_domain_id","caml_ml_domain_set_name","caml_ml_domain_unique_token","caml_ml_enable_runtime_warnings","caml_ml_flush","caml_ml_input","caml_ml_input_bigarray","caml_ml_input_block","caml_ml_input_char","caml_ml_input_int","caml_ml_input_scan_line","caml_ml_is_buffered","caml_ml_mutex_lock","caml_ml_mutex_new","caml_ml_mutex_try_lock","caml_ml_mutex_unlock","caml_ml_open_descriptor_in","caml_ml_open_descriptor_out","caml_ml_out_channels_list","caml_ml_output","caml_ml_output_bigarray","caml_ml_output_bytes","caml_ml_output_char","caml_ml_output_int","caml_ml_output_ta","caml_ml_pos_in","caml_ml_pos_in_64","caml_ml_pos_out","caml_ml_pos_out_64","caml_ml_runtime_events_pause","caml_ml_runtime_events_resume","caml_ml_runtime_events_start","caml_ml_runtime_warnings_enabled","caml_ml_seek_in","caml_ml_seek_in_64","caml_ml_seek_out","caml_ml_seek_out_64","caml_ml_set_binary_mode","caml_ml_set_buffered","caml_ml_set_channel_name","caml_ml_set_channel_output","caml_ml_set_channel_refill","caml_ml_string_length","caml_mod","caml_modf_float","caml_mount_autoload","caml_mul","caml_named_value","caml_named_values","caml_nativeint_unmarshal","caml_new_lex_engine","caml_new_string","caml_nextafter_float","caml_notequal","caml_obj_add_offset","caml_obj_block","caml_obj_compare_and_swap","caml_obj_dup","caml_obj_is_block","caml_obj_is_shared","caml_obj_make_forward","caml_obj_raw_field","caml_obj_reachable_words","caml_obj_set_raw_field","caml_obj_set_tag","caml_obj_tag","caml_obj_truncate","caml_obj_update_tag","caml_obj_with_tag","caml_ojs_new_arr","caml_oo_last_id","caml_output_val","caml_output_value","caml_output_value_to_buffer","caml_output_value_to_bytes","caml_output_value_to_string","caml_parse_digit","caml_parse_engine","caml_parse_format","caml_parse_sign_and_base","caml_parser_trace","caml_pos_in","caml_pos_out","caml_pure_js_expr","caml_raise_constant","caml_raise_end_of_file","caml_raise_no_such_file","caml_raise_not_a_dir","caml_raise_not_found","caml_raise_sys_error","caml_raise_with_arg","caml_raise_with_args","caml_raise_with_string","caml_raise_zero_divide","caml_raw_backtrace_length","caml_raw_backtrace_next_slot","caml_raw_backtrace_slot","caml_read_file_content","caml_recommended_domain_count","caml_record_backtrace","caml_record_backtrace_flag","caml_refill","caml_register_channel_for_spacetime","caml_register_global","caml_register_named_value","caml_restore_raw_backtrace","caml_root","caml_round_float","caml_runtime_events_create_cursor","caml_runtime_events_free_cursor","caml_runtime_events_read_poll","caml_runtime_events_user_register","caml_runtime_events_user_resolve","caml_runtime_events_user_write","caml_runtime_parameters","caml_runtime_variant","caml_runtime_warnings","caml_seek_in","caml_seek_out","caml_set_oo_id","caml_set_parser_trace","caml_set_static_env","caml_signbit_float","caml_sinh_float","caml_spacetime_enabled","caml_spacetime_only_works_for_native_code","caml_str_initialize","caml_str_repeat","caml_string_bound_error","caml_string_compare","caml_string_concat","caml_string_equal","caml_string_get","caml_string_get16","caml_string_get32","caml_string_get64","caml_string_greaterequal","caml_string_greaterthan","caml_string_hash","caml_string_lessequal","caml_string_lessthan","caml_string_notequal","caml_string_of_array","caml_string_of_bytes","caml_string_of_jsbytes","caml_string_of_jsstring","caml_string_set","caml_string_set16","caml_string_set32","caml_string_set64","caml_string_unsafe_get","caml_string_unsafe_set","caml_subarray_to_jsbytes","caml_sys_argv","caml_sys_chdir","caml_sys_close","caml_sys_const_backend_type","caml_sys_const_big_endian","caml_sys_const_int_size","caml_sys_const_max_wosize","caml_sys_const_naked_pointers_checked","caml_sys_const_ostype_cygwin","caml_sys_const_ostype_unix","caml_sys_const_ostype_win32","caml_sys_const_word_size","caml_sys_executable_name","caml_sys_exit","caml_sys_fds","caml_sys_file_exists","caml_sys_get_argv","caml_sys_get_config","caml_sys_getcwd","caml_sys_getenv","caml_sys_is_directory","caml_sys_is_regular_file","caml_sys_isatty","caml_sys_mkdir","caml_sys_modify_argv","caml_sys_open","caml_sys_open_for_node","caml_sys_random_seed","caml_sys_read_directory","caml_sys_remove","caml_sys_rename","caml_sys_rmdir","caml_sys_system_command","caml_sys_time","caml_sys_time_include_children","caml_sys_unsafe_getenv","caml_tanh_float","caml_to_js_string","caml_trailing_slash","caml_trampoline","caml_trampoline_return","caml_trunc_float","caml_uint8_array_of_bytes","caml_uint8_array_of_string","caml_unix_cleanup","caml_unix_closedir","caml_unix_filedescr_of_fd","caml_unix_findclose","caml_unix_findfirst","caml_unix_findnext","caml_unix_getpwuid","caml_unix_gettimeofday","caml_unix_getuid","caml_unix_gmtime","caml_unix_has_symlink","caml_unix_inet_addr_of_string","caml_unix_isatty","caml_unix_localtime","caml_unix_lstat","caml_unix_lstat_64","caml_unix_mkdir","caml_unix_mktime","caml_unix_opendir","caml_unix_readdir","caml_unix_readlink","caml_unix_rewinddir","caml_unix_rmdir","caml_unix_startup","caml_unix_stat","caml_unix_stat_64","caml_unix_symlink","caml_unix_time","caml_unix_unlink","caml_unmount","caml_update_dummy","caml_utf16_of_utf8","caml_utf8_of_utf16","caml_weak_create","caml_weak_set","caml_wrap_exception","caml_xmlhttprequest_create","compare_digits_nat","compare_nat","compare_nat_real","complement_nat","create_nat","decr_nat","deserialize_nat","div_digit_nat","div_helper","div_nat","fs_node_supported","incr_nat","initialize_nat","is_digit_int","is_digit_odd","is_digit_zero","jsoo_create_file","jsoo_create_file_extern","jsoo_effect_not_supported","jsoo_floor_log2","jsoo_is_ascii","jsoo_mount_point","jsoo_sys_getenv","keyname_to_keycode","land_digit_nat","length_nat","lor_digit_nat","lxor_digit_nat","make_unix_err_args","ml_canvas_arc","ml_canvas_arc_to","ml_canvas_bezier_curve_to","ml_canvas_blit","ml_canvas_clear_path","ml_canvas_clip","ml_canvas_clip_path","ml_canvas_close","ml_canvas_close_path","ml_canvas_commit","ml_canvas_compare","ml_canvas_create_offscreen","ml_canvas_create_offscreen_from_image_data","ml_canvas_create_offscreen_from_png","ml_canvas_create_onscreen","ml_canvas_ellipse","ml_canvas_export_png","ml_canvas_fill","ml_canvas_fill_path","ml_canvas_fill_rect","ml_canvas_fill_text","ml_canvas_get_canvas","ml_canvas_get_current_timestamp","ml_canvas_get_fill_color","ml_canvas_get_fill_style","ml_canvas_get_global_alpha","ml_canvas_get_global_composite_operation","ml_canvas_get_id","ml_canvas_get_image_data","ml_canvas_get_line_cap","ml_canvas_get_line_dash","ml_canvas_get_line_dash_offset","ml_canvas_get_line_join","ml_canvas_get_line_width","ml_canvas_get_miter_limit","ml_canvas_get_pixel","ml_canvas_get_position","ml_canvas_get_shadow_blur","ml_canvas_get_shadow_color","ml_canvas_get_shadow_offset","ml_canvas_get_size","ml_canvas_get_stroke_color","ml_canvas_get_stroke_style","ml_canvas_gradient_add_color_stop","ml_canvas_gradient_create_conic","ml_canvas_gradient_create_linear","ml_canvas_gradient_create_radial","ml_canvas_hash","ml_canvas_hide","ml_canvas_image_data_blit","ml_canvas_image_data_create_from_png","ml_canvas_image_data_export_png","ml_canvas_image_data_fill","ml_canvas_image_data_get_pixel","ml_canvas_image_data_get_size","ml_canvas_image_data_import_png","ml_canvas_image_data_put_pixel","ml_canvas_image_data_sub","ml_canvas_import_png","ml_canvas_init","ml_canvas_int_of_key","ml_canvas_key_of_int","ml_canvas_line_to","ml_canvas_move_to","ml_canvas_path_add","ml_canvas_path_add_transformed","ml_canvas_path_arc","ml_canvas_path_arc_to","ml_canvas_path_bezier_curve_to","ml_canvas_path_close","ml_canvas_path_create","ml_canvas_path_ellipse","ml_canvas_path_line_to","ml_canvas_path_move_to","ml_canvas_path_quadratic_curve_to","ml_canvas_path_rect","ml_canvas_pattern_create","ml_canvas_put_image_data","ml_canvas_put_pixel","ml_canvas_quadratic_curve_to","ml_canvas_rect","ml_canvas_restore","ml_canvas_rotate","ml_canvas_run","ml_canvas_save","ml_canvas_scale","ml_canvas_set_fill_color","ml_canvas_set_fill_gradient","ml_canvas_set_fill_pattern","ml_canvas_set_fill_style","ml_canvas_set_font","ml_canvas_set_global_alpha","ml_canvas_set_global_composite_operation","ml_canvas_set_line_cap","ml_canvas_set_line_dash","ml_canvas_set_line_dash_offset","ml_canvas_set_line_join","ml_canvas_set_line_width","ml_canvas_set_miter_limit","ml_canvas_set_position","ml_canvas_set_shadow_blur","ml_canvas_set_shadow_color","ml_canvas_set_shadow_offset","ml_canvas_set_size","ml_canvas_set_stroke_color","ml_canvas_set_stroke_gradient","ml_canvas_set_stroke_pattern","ml_canvas_set_stroke_style","ml_canvas_set_transform","ml_canvas_shear","ml_canvas_show","ml_canvas_stop","ml_canvas_stroke","ml_canvas_stroke_path","ml_canvas_stroke_rect","ml_canvas_stroke_text","ml_canvas_transform","ml_canvas_translate","mult_digit_nat","mult_nat","nat_of_array","nth_digit_nat","nth_digit_nat_native","num_digits_nat","num_leading_zero_bits_in_digit","os_type","path_is_absolute","re_match","re_partial_match","re_replacement_text","re_search_backward","re_search_forward","re_string_match","resolve_fs_device","serialize_nat","set_digit_nat","set_digit_nat_native","set_to_zero_nat","shift_left_nat","shift_right_nat","square_nat","sub_nat"]),0];return}(globalThis));
//# 1 "../.js/default/stdlib/stdlib.cma.js"
// Generated by js_of_ocaml
//# 3 "../.js/default/stdlib/stdlib.cma.js"

//# 5 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function erase_rel(param){
    if(typeof param === "number") return 0;
    switch(param[0]){
      case 0:
       var rest = param[1]; return [0, erase_rel(rest)];
      case 1:
       var rest$0 = param[1]; return [1, erase_rel(rest$0)];
      case 2:
       var rest$1 = param[1]; return [2, erase_rel(rest$1)];
      case 3:
       var rest$2 = param[1]; return [3, erase_rel(rest$2)];
      case 4:
       var rest$3 = param[1]; return [4, erase_rel(rest$3)];
      case 5:
       var rest$4 = param[1]; return [5, erase_rel(rest$4)];
      case 6:
       var rest$5 = param[1]; return [6, erase_rel(rest$5)];
      case 7:
       var rest$6 = param[1]; return [7, erase_rel(rest$6)];
      case 8:
       var rest$7 = param[2], ty = param[1];
       return [8, ty, erase_rel(rest$7)];
      case 9:
       var rest$8 = param[3], ty1 = param[1];
       return [9, ty1, ty1, erase_rel(rest$8)];
      case 10:
       var rest$9 = param[1]; return [10, erase_rel(rest$9)];
      case 11:
       var rest$10 = param[1]; return [11, erase_rel(rest$10)];
      case 12:
       var rest$11 = param[1]; return [12, erase_rel(rest$11)];
      case 13:
       var rest$12 = param[1]; return [13, erase_rel(rest$12)];
      default: var rest$13 = param[1]; return [14, erase_rel(rest$13)];
    }
   }
   function concat_fmtty(fmtty1, fmtty2){
    if(typeof fmtty1 === "number") return fmtty2;
    switch(fmtty1[0]){
      case 0:
       var rest = fmtty1[1]; return [0, concat_fmtty(rest, fmtty2)];
      case 1:
       var rest$0 = fmtty1[1]; return [1, concat_fmtty(rest$0, fmtty2)];
      case 2:
       var rest$1 = fmtty1[1]; return [2, concat_fmtty(rest$1, fmtty2)];
      case 3:
       var rest$2 = fmtty1[1]; return [3, concat_fmtty(rest$2, fmtty2)];
      case 4:
       var rest$3 = fmtty1[1]; return [4, concat_fmtty(rest$3, fmtty2)];
      case 5:
       var rest$4 = fmtty1[1]; return [5, concat_fmtty(rest$4, fmtty2)];
      case 6:
       var rest$5 = fmtty1[1]; return [6, concat_fmtty(rest$5, fmtty2)];
      case 7:
       var rest$6 = fmtty1[1]; return [7, concat_fmtty(rest$6, fmtty2)];
      case 8:
       var rest$7 = fmtty1[2], ty = fmtty1[1];
       return [8, ty, concat_fmtty(rest$7, fmtty2)];
      case 9:
       var rest$8 = fmtty1[3], ty2 = fmtty1[2], ty1 = fmtty1[1];
       return [9, ty1, ty2, concat_fmtty(rest$8, fmtty2)];
      case 10:
       var rest$9 = fmtty1[1]; return [10, concat_fmtty(rest$9, fmtty2)];
      case 11:
       var rest$10 = fmtty1[1]; return [11, concat_fmtty(rest$10, fmtty2)];
      case 12:
       var rest$11 = fmtty1[1]; return [12, concat_fmtty(rest$11, fmtty2)];
      case 13:
       var rest$12 = fmtty1[1]; return [13, concat_fmtty(rest$12, fmtty2)];
      default:
       var rest$13 = fmtty1[1]; return [14, concat_fmtty(rest$13, fmtty2)];
    }
   }
   function concat_fmt(fmt1, fmt2){
    if(typeof fmt1 === "number") return fmt2;
    switch(fmt1[0]){
      case 0:
       var rest = fmt1[1]; return [0, concat_fmt(rest, fmt2)];
      case 1:
       var rest$0 = fmt1[1]; return [1, concat_fmt(rest$0, fmt2)];
      case 2:
       var rest$1 = fmt1[2], pad = fmt1[1];
       return [2, pad, concat_fmt(rest$1, fmt2)];
      case 3:
       var rest$2 = fmt1[2], pad$0 = fmt1[1];
       return [3, pad$0, concat_fmt(rest$2, fmt2)];
      case 4:
       var rest$3 = fmt1[4], prec = fmt1[3], pad$1 = fmt1[2], iconv = fmt1[1];
       return [4, iconv, pad$1, prec, concat_fmt(rest$3, fmt2)];
      case 5:
       var
        rest$4 = fmt1[4],
        prec$0 = fmt1[3],
        pad$2 = fmt1[2],
        iconv$0 = fmt1[1];
       return [5, iconv$0, pad$2, prec$0, concat_fmt(rest$4, fmt2)];
      case 6:
       var
        rest$5 = fmt1[4],
        prec$1 = fmt1[3],
        pad$3 = fmt1[2],
        iconv$1 = fmt1[1];
       return [6, iconv$1, pad$3, prec$1, concat_fmt(rest$5, fmt2)];
      case 7:
       var
        rest$6 = fmt1[4],
        prec$2 = fmt1[3],
        pad$4 = fmt1[2],
        iconv$2 = fmt1[1];
       return [7, iconv$2, pad$4, prec$2, concat_fmt(rest$6, fmt2)];
      case 8:
       var
        rest$7 = fmt1[4],
        prec$3 = fmt1[3],
        pad$5 = fmt1[2],
        fconv = fmt1[1];
       return [8, fconv, pad$5, prec$3, concat_fmt(rest$7, fmt2)];
      case 9:
       var rest$8 = fmt1[2], pad$6 = fmt1[1];
       return [9, pad$6, concat_fmt(rest$8, fmt2)];
      case 10:
       var rest$9 = fmt1[1]; return [10, concat_fmt(rest$9, fmt2)];
      case 11:
       var rest$10 = fmt1[2], str = fmt1[1];
       return [11, str, concat_fmt(rest$10, fmt2)];
      case 12:
       var rest$11 = fmt1[2], chr = fmt1[1];
       return [12, chr, concat_fmt(rest$11, fmt2)];
      case 13:
       var rest$12 = fmt1[3], fmtty = fmt1[2], pad$7 = fmt1[1];
       return [13, pad$7, fmtty, concat_fmt(rest$12, fmt2)];
      case 14:
       var rest$13 = fmt1[3], fmtty$0 = fmt1[2], pad$8 = fmt1[1];
       return [14, pad$8, fmtty$0, concat_fmt(rest$13, fmt2)];
      case 15:
       var rest$14 = fmt1[1]; return [15, concat_fmt(rest$14, fmt2)];
      case 16:
       var rest$15 = fmt1[1]; return [16, concat_fmt(rest$15, fmt2)];
      case 17:
       var rest$16 = fmt1[2], fmting_lit = fmt1[1];
       return [17, fmting_lit, concat_fmt(rest$16, fmt2)];
      case 18:
       var rest$17 = fmt1[2], fmting_gen = fmt1[1];
       return [18, fmting_gen, concat_fmt(rest$17, fmt2)];
      case 19:
       var rest$18 = fmt1[1]; return [19, concat_fmt(rest$18, fmt2)];
      case 20:
       var rest$19 = fmt1[3], char_set = fmt1[2], width_opt = fmt1[1];
       return [20, width_opt, char_set, concat_fmt(rest$19, fmt2)];
      case 21:
       var rest$20 = fmt1[2], counter = fmt1[1];
       return [21, counter, concat_fmt(rest$20, fmt2)];
      case 22:
       var rest$21 = fmt1[1]; return [22, concat_fmt(rest$21, fmt2)];
      case 23:
       var rest$22 = fmt1[2], ign = fmt1[1];
       return [23, ign, concat_fmt(rest$22, fmt2)];
      default:
       var rest$23 = fmt1[3], f = fmt1[2], arity = fmt1[1];
       return [24, arity, f, concat_fmt(rest$23, fmt2)];
    }
   }
   var CamlinternalFormatBasics = [0, concat_fmtty, erase_rel, concat_fmt];
   runtime.caml_register_global
    (0, CamlinternalFormatBasics, "CamlinternalFormatBasics");
   return;
  }
  (globalThis));

//# 179 "../.js/default/stdlib/stdlib.cma.js"
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function make(v){return [0, v];}
   function get(r){return r[1];}
   function set(r, v){r[1] = v; return 0;}
   function exchange(r, v){var cur = r[1]; r[1] = v; return cur;}
   function compare_and_set(r, seen, v){
    var cur = r[1];
    return cur === seen ? (r[1] = v, 1) : 0;
   }
   function fetch_and_add(r, n){
    var cur = r[1];
    r[1] = cur + n | 0;
    return cur;
   }
   function incr(r){fetch_and_add(r, 1); return 0;}
   function decr(r){fetch_and_add(r, -1); return 0;}
   var
    CamlinternalAtomic =
      [0,
       make,
       get,
       set,
       exchange,
       compare_and_set,
       fetch_and_add,
       incr,
       decr];
   runtime.caml_register_global(0, CamlinternalAtomic, "CamlinternalAtomic");
   return;
  }
  (globalThis));

//# 215 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_false$0 = "false",
    cst_true$0 = "true",
    caml_create_bytes = runtime.caml_create_bytes,
    caml_float_of_string = runtime.caml_float_of_string,
    caml_int64_float_of_bits = runtime.caml_int64_float_of_bits,
    caml_int_of_string = runtime.caml_int_of_string,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_bytes_length = runtime.caml_ml_bytes_length,
    caml_ml_channel_size = runtime.caml_ml_channel_size,
    caml_ml_channel_size_64 = runtime.caml_ml_channel_size_64,
    caml_ml_close_channel = runtime.caml_ml_close_channel,
    caml_ml_flush = runtime.caml_ml_flush,
    caml_ml_input = runtime.caml_ml_input,
    caml_ml_input_char = runtime.caml_ml_input_char,
    caml_ml_open_descriptor_in = runtime.caml_ml_open_descriptor_in,
    caml_ml_open_descriptor_out = runtime.caml_ml_open_descriptor_out,
    caml_ml_output = runtime.caml_ml_output,
    caml_ml_output_bytes = runtime.caml_ml_output_bytes,
    caml_ml_output_char = runtime.caml_ml_output_char,
    caml_ml_set_binary_mode = runtime.caml_ml_set_binary_mode,
    caml_ml_set_channel_name = runtime.caml_ml_set_channel_name,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_concat = runtime.caml_string_concat,
    caml_string_of_bytes = runtime.caml_string_of_bytes,
    caml_sys_open = runtime.caml_sys_open,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    CamlinternalAtomic = global_data.CamlinternalAtomic,
    CamlinternalFormatBasics = global_data.CamlinternalFormatBasics,
    Invalid_argument = global_data.Invalid_argument,
    Failure = global_data.Failure,
    Match_failure = global_data.Match_failure,
    Assert_failure = global_data.Assert_failure,
    Not_found = global_data.Not_found,
    Out_of_memory = global_data.Out_of_memory,
    Stack_overflow = global_data.Stack_overflow,
    Sys_error = global_data.Sys_error,
    End_of_file = global_data.End_of_file,
    Division_by_zero = global_data.Division_by_zero,
    Sys_blocked_io = global_data.Sys_blocked_io,
    Undefined_recursive_module = global_data.Undefined_recursive_module;
   function failwith(s){
    throw caml_maybe_attach_backtrace([0, Failure, s], 1);
   }
   function invalid_arg(s){
    throw caml_maybe_attach_backtrace([0, Invalid_argument, s], 1);
   }
   var Exit = [248, "Stdlib.Exit", runtime.caml_fresh_oo_id(0)];
   function min(x, y){return runtime.caml_lessequal(x, y) ? x : y;}
   function max(x, y){return runtime.caml_greaterequal(x, y) ? x : y;}
   function abs(x){return 0 <= x ? x : - x | 0;}
   function lnot(x){return x ^ -1;}
   var
    infinity =
      caml_int64_float_of_bits
       (runtime.caml_int64_create_lo_mi_hi(0, 0, 32752)),
    neg_infinity =
      caml_int64_float_of_bits
       (runtime.caml_int64_create_lo_mi_hi(0, 0, 65520)),
    nan =
      caml_int64_float_of_bits
       (runtime.caml_int64_create_lo_mi_hi(1, 0, 32752)),
    max_float =
      caml_int64_float_of_bits
       (runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 32751)),
    min_float =
      caml_int64_float_of_bits(runtime.caml_int64_create_lo_mi_hi(0, 0, 16)),
    epsilon_float =
      caml_int64_float_of_bits
       (runtime.caml_int64_create_lo_mi_hi(0, 0, 15536)),
    symbol_concat = caml_string_concat,
    cst_char_of_int = "char_of_int",
    cst_true = cst_true$0,
    cst_false = cst_false$0,
    cst_bool_of_string = "bool_of_string",
    _a_ = [0, 1],
    _b_ = [0, 0];
   function char_of_int(n){
    if(0 <= n && 255 >= n) return n;
    return invalid_arg(cst_char_of_int);
   }
   function string_of_bool(b){return b ? cst_true : cst_false;}
   function bool_of_string(param){
    return param !== cst_false$0
            ? param !== cst_true$0 ? invalid_arg(cst_bool_of_string) : 1
            : 0;
   }
   function bool_of_string_opt(param){
    return param !== cst_false$0 ? param !== cst_true$0 ? 0 : _a_ : _b_;
   }
   function string_of_int(n){return "" + n;}
   function int_of_string_opt(s){
    try{var _u_ = [0, caml_int_of_string(s)]; return _u_;}
    catch(_v_){
     var _t_ = caml_wrap_exception(_v_);
     if(_t_[1] === Failure) return 0;
     throw caml_maybe_attach_backtrace(_t_, 0);
    }
   }
   function valid_float_lexem(s1){
    var l = caml_ml_string_length(s1), i = 0;
    for(;;){
     if(l <= i) return s1 + ".";
     var match = runtime.caml_string_get(s1, i);
     a:
     {
      if(48 <= match){if(58 > match) break a;} else if(45 === match) break a;
      return s1;
     }
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function string_of_float(f){
    return valid_float_lexem(runtime.caml_format_float("%.12g", f));
   }
   function float_of_string_opt(s){
    try{var _r_ = [0, caml_float_of_string(s)]; return _r_;}
    catch(_s_){
     var _q_ = caml_wrap_exception(_s_);
     if(_q_[1] === Failure) return 0;
     throw caml_maybe_attach_backtrace(_q_, 0);
    }
   }
   function symbol(l1, l2){
    if(! l1) return l2;
    var tl = l1[2], hd = l1[1];
    return [0, hd, symbol(tl, l2)];
   }
   var
    stdin = caml_ml_open_descriptor_in(0),
    stdout = caml_ml_open_descriptor_out(1),
    stderr = caml_ml_open_descriptor_out(2),
    _c_ = [0, 1, [0, 3, [0, 4, [0, 7, 0]]]],
    _d_ = [0, 1, [0, 3, [0, 4, [0, 6, 0]]]],
    cst_output = "output",
    cst_output_substring = "output_substring",
    _e_ = [0, 0, [0, 7, 0]],
    _f_ = [0, 0, [0, 6, 0]],
    cst_input = "input",
    cst_really_input = "really_input";
   function open_out_gen(mode, perm, name){
    var c = caml_ml_open_descriptor_out(caml_sys_open(name, mode, perm));
    caml_ml_set_channel_name(c, name);
    return c;
   }
   function open_out(name){return open_out_gen(_c_, 438, name);}
   function open_out_bin(name){return open_out_gen(_d_, 438, name);}
   function flush_all(param){
    var param$0 = runtime.caml_ml_out_channels_list(0);
    for(;;){
     if(! param$0) return 0;
     var l = param$0[2], a = param$0[1];
     try{caml_ml_flush(a);}
     catch(_p_){
      var _o_ = caml_wrap_exception(_p_);
      if(_o_[1] !== Sys_error) throw caml_maybe_attach_backtrace(_o_, 0);
     }
     param$0 = l;
    }
   }
   function output_bytes(oc, s){
    return caml_ml_output_bytes(oc, s, 0, caml_ml_bytes_length(s));
   }
   function output_string(oc, s){
    return caml_ml_output(oc, s, 0, caml_ml_string_length(s));
   }
   function output(oc, s, ofs, len){
    if(0 <= ofs && 0 <= len && (caml_ml_bytes_length(s) - len | 0) >= ofs)
     return caml_ml_output_bytes(oc, s, ofs, len);
    return invalid_arg(cst_output);
   }
   function output_substring(oc, s, ofs, len){
    if(0 <= ofs && 0 <= len && (caml_ml_string_length(s) - len | 0) >= ofs)
     return caml_ml_output(oc, s, ofs, len);
    return invalid_arg(cst_output_substring);
   }
   function output_value(chan, v){
    return runtime.caml_output_value(chan, v, 0);
   }
   function close_out(oc){
    caml_ml_flush(oc);
    return caml_ml_close_channel(oc);
   }
   function close_out_noerr(oc){
    try{caml_ml_flush(oc);}catch(_n_){}
    try{var _l_ = caml_ml_close_channel(oc); return _l_;}catch(_m_){return 0;}
   }
   function open_in_gen(mode, perm, name){
    var c = caml_ml_open_descriptor_in(caml_sys_open(name, mode, perm));
    caml_ml_set_channel_name(c, name);
    return c;
   }
   function open_in(name){return open_in_gen(_e_, 0, name);}
   function open_in_bin(name){return open_in_gen(_f_, 0, name);}
   function input(ic, s, ofs, len){
    if(0 <= ofs && 0 <= len && (caml_ml_bytes_length(s) - len | 0) >= ofs)
     return caml_ml_input(ic, s, ofs, len);
    return invalid_arg(cst_input);
   }
   function unsafe_really_input(ic, s, ofs, len){
    var ofs$0 = ofs, len$0 = len;
    for(;;){
     if(0 >= len$0) return 0;
     var r = caml_ml_input(ic, s, ofs$0, len$0);
     if(0 === r) throw caml_maybe_attach_backtrace(End_of_file, 1);
     var len$1 = len$0 - r | 0, ofs$1 = ofs$0 + r | 0;
     ofs$0 = ofs$1;
     len$0 = len$1;
    }
   }
   function really_input(ic, s, ofs, len){
    if(0 <= ofs && 0 <= len && (caml_ml_bytes_length(s) - len | 0) >= ofs)
     return unsafe_really_input(ic, s, ofs, len);
    return invalid_arg(cst_really_input);
   }
   function really_input_string(ic, len){
    var s = caml_create_bytes(len);
    really_input(ic, s, 0, len);
    return caml_string_of_bytes(s);
   }
   function input_line(chan){
    function build_result(buf, pos, param){
     var pos$0 = pos, param$0 = param;
     for(;;){
      if(! param$0) return buf;
      var tl = param$0[2], hd = param$0[1], len = caml_ml_bytes_length(hd);
      runtime.caml_blit_bytes(hd, 0, buf, pos$0 - len | 0, len);
      var pos$1 = pos$0 - len | 0;
      pos$0 = pos$1;
      param$0 = tl;
     }
    }
    var accu = 0, len = 0;
    for(;;){
     var n = runtime.caml_ml_input_scan_line(chan);
     if(0 === n){
      if(! accu) throw caml_maybe_attach_backtrace(End_of_file, 1);
      var _k_ = build_result(caml_create_bytes(len), len, accu);
     }
     else{
      if(0 >= n){
       var beg = caml_create_bytes(- n | 0);
       caml_ml_input(chan, beg, 0, - n | 0);
       var len$1 = len - n | 0, accu$0 = [0, beg, accu];
       accu = accu$0;
       len = len$1;
       continue;
      }
      var res = caml_create_bytes(n - 1 | 0);
      caml_ml_input(chan, res, 0, n - 1 | 0);
      caml_ml_input_char(chan);
      if(accu)
       var
        len$0 = (len + n | 0) - 1 | 0,
        _k_ = build_result(caml_create_bytes(len$0), len$0, [0, res, accu]);
      else
       var _k_ = res;
     }
     return caml_string_of_bytes(_k_);
    }
   }
   function close_in_noerr(ic){
    try{var _i_ = caml_ml_close_channel(ic); return _i_;}catch(_j_){return 0;}
   }
   function print_char(c){return caml_ml_output_char(stdout, c);}
   function print_string(s){return output_string(stdout, s);}
   function print_bytes(s){return output_bytes(stdout, s);}
   function print_int(i){return output_string(stdout, "" + i);}
   function print_float(f){return output_string(stdout, string_of_float(f));}
   function print_endline(s){
    output_string(stdout, s);
    caml_ml_output_char(stdout, 10);
    return caml_ml_flush(stdout);
   }
   function print_newline(param){
    caml_ml_output_char(stdout, 10);
    return caml_ml_flush(stdout);
   }
   function prerr_char(c){return caml_ml_output_char(stderr, c);}
   function prerr_string(s){return output_string(stderr, s);}
   function prerr_bytes(s){return output_bytes(stderr, s);}
   function prerr_int(i){return output_string(stderr, "" + i);}
   function prerr_float(f){return output_string(stderr, string_of_float(f));}
   function prerr_endline(s){
    output_string(stderr, s);
    caml_ml_output_char(stderr, 10);
    return caml_ml_flush(stderr);
   }
   function prerr_newline(param){
    caml_ml_output_char(stderr, 10);
    return caml_ml_flush(stderr);
   }
   function read_line(param){caml_ml_flush(stdout); return input_line(stdin);}
   function read_int(param){return caml_int_of_string(read_line(0));}
   function read_int_opt(param){return int_of_string_opt(read_line(0));}
   function read_float(param){return caml_float_of_string(read_line(0));}
   function read_float_opt(param){return float_of_string_opt(read_line(0));}
   function string_of_format(param){var str = param[2]; return str;}
   function symbol$0(param, _h_){
    var
     str2 = _h_[2],
     fmt2 = _h_[1],
     str1 = param[2],
     fmt1 = param[1],
     s2 = "%," + str2;
    return [0, caml_call2(CamlinternalFormatBasics[3], fmt1, fmt2), str1 + s2];
   }
   var exit_function = caml_call1(CamlinternalAtomic[1], flush_all);
   function at_exit(f){
    for(;;){
     var
      f_yet_to_run = caml_call1(CamlinternalAtomic[1], 1),
      old_exit = caml_call1(CamlinternalAtomic[2], exit_function);
     let f_yet_to_run$0 = f_yet_to_run, old_exit$0 = old_exit;
     var
      new_exit =
        function(param){
         if(caml_call3(CamlinternalAtomic[5], f_yet_to_run$0, 1, 0))
          caml_call1(f, 0);
         return caml_call1(old_exit$0, 0);
        },
      success =
        caml_call3(CamlinternalAtomic[5], exit_function, old_exit, new_exit),
      _g_ = 1 - success;
     if(! _g_) return _g_;
    }
   }
   function do_at_exit(param){
    return caml_call1(caml_call1(CamlinternalAtomic[2], exit_function), 0);
   }
   function exit(retcode){
    do_at_exit(0);
    return runtime.caml_sys_exit(retcode);
   }
   runtime.caml_register_named_value("Pervasives.do_at_exit", do_at_exit);
   var
    Stdlib =
      [0,
       invalid_arg,
       failwith,
       Exit,
       Match_failure,
       Assert_failure,
       Invalid_argument,
       Failure,
       Not_found,
       Out_of_memory,
       Stack_overflow,
       Sys_error,
       End_of_file,
       Division_by_zero,
       Sys_blocked_io,
       Undefined_recursive_module,
       min,
       max,
       abs,
       2147483647,
       -2147483648,
       lnot,
       infinity,
       neg_infinity,
       nan,
       max_float,
       min_float,
       epsilon_float,
       symbol_concat,
       char_of_int,
       string_of_bool,
       bool_of_string_opt,
       bool_of_string,
       string_of_int,
       int_of_string_opt,
       string_of_float,
       float_of_string_opt,
       symbol,
       stdin,
       stdout,
       stderr,
       print_char,
       print_string,
       print_bytes,
       print_int,
       print_float,
       print_endline,
       print_newline,
       prerr_char,
       prerr_string,
       prerr_bytes,
       prerr_int,
       prerr_float,
       prerr_endline,
       prerr_newline,
       read_line,
       read_int_opt,
       read_int,
       read_float_opt,
       read_float,
       open_out,
       open_out_bin,
       open_out_gen,
       caml_ml_flush,
       flush_all,
       caml_ml_output_char,
       output_string,
       output_bytes,
       output,
       output_substring,
       caml_ml_output_char,
       runtime.caml_ml_output_int,
       output_value,
       runtime.caml_ml_seek_out,
       runtime.caml_ml_pos_out,
       caml_ml_channel_size,
       close_out,
       close_out_noerr,
       caml_ml_set_binary_mode,
       open_in,
       open_in_bin,
       open_in_gen,
       caml_ml_input_char,
       input_line,
       input,
       really_input,
       really_input_string,
       caml_ml_input_char,
       runtime.caml_ml_input_int,
       runtime.caml_input_value,
       runtime.caml_ml_seek_in,
       runtime.caml_ml_pos_in,
       caml_ml_channel_size,
       caml_ml_close_channel,
       close_in_noerr,
       caml_ml_set_binary_mode,
       [0,
        runtime.caml_ml_seek_out_64,
        runtime.caml_ml_pos_out_64,
        caml_ml_channel_size_64,
        runtime.caml_ml_seek_in_64,
        runtime.caml_ml_pos_in_64,
        caml_ml_channel_size_64],
       string_of_format,
       symbol$0,
       exit,
       at_exit,
       valid_float_lexem,
       unsafe_really_input,
       do_at_exit];
   runtime.caml_register_global(46, Stdlib, "Stdlib");
   return;
  }
  (globalThis));

//# 978 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception,
    global_data = runtime.caml_get_global_data(),
    ocaml_version = "4.14.0",
    ocaml_release = [0, 4, 14, 0, 0],
    Stdlib = global_data.Stdlib,
    executable_name = runtime.caml_sys_executable_name(0),
    os_type = runtime.caml_sys_get_config(0)[1],
    backend_type = [0, "js_of_ocaml"],
    unix = runtime.caml_sys_const_ostype_unix(0),
    win32 = runtime.caml_sys_const_ostype_win32(0),
    cygwin = runtime.caml_sys_const_ostype_cygwin(0),
    max_array_length = runtime.caml_sys_const_max_wosize(0),
    max_floatarray_length = max_array_length / 2 | 0,
    max_string_length = (4 * max_array_length | 0) - 1 | 0;
   function getenv_opt(s){
    try{var _d_ = [0, runtime.caml_sys_getenv(s)]; return _d_;}
    catch(_e_){
     var _c_ = caml_wrap_exception(_e_);
     if(_c_ === Stdlib[8]) return 0;
     throw caml_maybe_attach_backtrace(_c_, 0);
    }
   }
   var interactive = [0, 0];
   function set_signal(sig_num, sig_beh){return 0;}
   var Break = [248, "Stdlib.Sys.Break", runtime.caml_fresh_oo_id(0)];
   function catch_break(on){return on ? 0 : 0;}
   function Make(_b_, _a_){return [0, 1];}
   var
    Immediate64 = [0, Make],
    Stdlib_Sys =
      [0,
       executable_name,
       getenv_opt,
       interactive,
       os_type,
       backend_type,
       unix,
       win32,
       cygwin,
       32,
       32,
       0,
       max_string_length,
       max_array_length,
       max_floatarray_length,
       set_signal,
       -1,
       -2,
       -3,
       -4,
       -5,
       -6,
       -7,
       -8,
       -9,
       -10,
       -11,
       -12,
       -13,
       -14,
       -15,
       -16,
       -17,
       -18,
       -19,
       -20,
       -21,
       -22,
       -23,
       -24,
       -25,
       -26,
       -27,
       -28,
       Break,
       catch_break,
       ocaml_version,
       0,
       ocaml_release,
       runtime.caml_ml_enable_runtime_warnings,
       runtime.caml_ml_runtime_warnings_enabled,
       Immediate64];
   runtime.caml_register_global(4, Stdlib_Sys, "Stdlib__Sys");
   return;
  }
  (globalThis));

//# 1073 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Obj_extension_constructor$1 = "Obj.extension_constructor",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_obj_tag = runtime.caml_obj_tag;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Sys = global_data.Stdlib__Sys;
   function is_block(a){return 1 - (typeof a === "number" ? 1 : 0);}
   var
    double_field = runtime.caml_array_get,
    set_double_field = runtime.caml_array_set,
    custom_tag = 255,
    _a_ = [0, "obj.ml", 95, 4],
    cst_Obj_extension_constructor = cst_Obj_extension_constructor$1,
    cst_Obj_extension_constructor$0 = cst_Obj_extension_constructor$1;
   function info(obj){
    if(caml_obj_tag(obj) !== 247)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
    var
     info = runtime.caml_obj_raw_field(obj, 1),
     arity = 64 === Stdlib_Sys[9] ? info >> 56 : info >> 24,
     start_env = info << 8 >>> 9 | 0;
    return [0, arity, start_env];
   }
   function of_val(x){
    a:
    {
     if(is_block(x) && caml_obj_tag(x) !== 248 && 1 <= x.length - 1){var slot = x[1]; break a;}
     var slot = x;
    }
    a:
    {
     if(is_block(slot) && caml_obj_tag(slot) === 248){var name = slot[1]; break a;}
     var name = caml_call1(Stdlib[1], cst_Obj_extension_constructor$0);
    }
    return caml_obj_tag(name) === 252
            ? slot
            : caml_call1(Stdlib[1], cst_Obj_extension_constructor);
   }
   function name(slot){return slot[1];}
   function id(slot){return slot[2];}
   var
    Extension_constructor = [0, of_val, name, id],
    extension_constructor = Extension_constructor[1],
    extension_name = Extension_constructor[2],
    extension_id = Extension_constructor[3],
    max_ephe_length = Stdlib_Sys[13] - 2 | 0,
    cst_Obj_Ephemeron_create = "Obj.Ephemeron.create",
    cst_Obj_Ephemeron_get_key = "Obj.Ephemeron.get_key",
    cst_Obj_Ephemeron_get_key_copy = "Obj.Ephemeron.get_key_copy",
    cst_Obj_Ephemeron_set_key = "Obj.Ephemeron.set_key",
    cst_Obj_Ephemeron_unset_key = "Obj.Ephemeron.unset_key",
    cst_Obj_Ephemeron_check_key = "Obj.Ephemeron.check_key",
    cst_Obj_Ephemeron_blit_key = "Obj.Ephemeron.blit_key";
   function create(l){
    var _g_ = 0 <= l ? 1 : 0, _h_ = _g_ ? l <= max_ephe_length ? 1 : 0 : _g_;
    if(1 - _h_) caml_call1(Stdlib[1], cst_Obj_Ephemeron_create);
    return runtime.caml_ephe_create(l);
   }
   function length(x){return x.length - 3 | 0;}
   function raise_if_invalid_offset(e, o, msg){
    var
     _d_ = 0 <= o ? 1 : 0,
     _e_ = _d_ ? o < length(e) ? 1 : 0 : _d_,
     _f_ = 1 - _e_;
    return _f_ ? caml_call1(Stdlib[1], msg) : _f_;
   }
   function get_key(e, o){
    raise_if_invalid_offset(e, o, cst_Obj_Ephemeron_get_key);
    return runtime.caml_ephe_get_key(e, o);
   }
   function get_key_copy(e, o){
    raise_if_invalid_offset(e, o, cst_Obj_Ephemeron_get_key_copy);
    return runtime.caml_ephe_get_key_copy(e, o);
   }
   function set_key(e, o, x){
    raise_if_invalid_offset(e, o, cst_Obj_Ephemeron_set_key);
    return runtime.caml_ephe_set_key(e, o, x);
   }
   function unset_key(e, o){
    raise_if_invalid_offset(e, o, cst_Obj_Ephemeron_unset_key);
    return runtime.caml_ephe_unset_key(e, o);
   }
   function check_key(e, o){
    raise_if_invalid_offset(e, o, cst_Obj_Ephemeron_check_key);
    return runtime.caml_ephe_check_key(e, o);
   }
   function blit_key(e1, o1, e2, o2, l){
    if
     (0 <= l
      &&
       0 <= o1
       && (length(e1) - l | 0) >= o1 && 0 <= o2 && (length(e2) - l | 0) >= o2){
     var
      _b_ = 0 !== l ? 1 : 0,
      _c_ = _b_ ? runtime.caml_ephe_blit_key(e1, o1, e2, o2, l) : _b_;
     return _c_;
    }
    return caml_call1(Stdlib[1], cst_Obj_Ephemeron_blit_key);
   }
   var
    Stdlib_Obj =
      [0,
       is_block,
       double_field,
       set_double_field,
       0,
       245,
       246,
       247,
       248,
       249,
       250,
       251,
       251,
       252,
       253,
       254,
       custom_tag,
       custom_tag,
       1000,
       1001,
       1002,
       [0, info],
       Extension_constructor,
       extension_constructor,
       extension_name,
       extension_id,
       [0,
        create,
        length,
        get_key,
        get_key_copy,
        set_key,
        unset_key,
        check_key,
        blit_key,
        runtime.caml_ephe_get_data,
        runtime.caml_ephe_get_data_copy,
        runtime.caml_ephe_set_data,
        runtime.caml_ephe_unset_data,
        runtime.caml_ephe_check_data,
        runtime.caml_ephe_blit_data,
        max_ephe_length]];
   runtime.caml_register_global(13, Stdlib_Obj, "Stdlib__Obj");
   return;
  }
  (globalThis));

//# 1235 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_obj_make_forward = runtime.caml_obj_make_forward,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Obj = global_data.Stdlib__Obj,
    Undefined =
      [248, "CamlinternalLazy.Undefined", runtime.caml_fresh_oo_id(0)];
   function raise_undefined(param){
    throw caml_maybe_attach_backtrace(Undefined, 1);
   }
   function force_lazy_block(blk){
    var closure = blk[1];
    blk[1] = raise_undefined;
    try{
     var result = caml_call1(closure, 0);
     caml_obj_make_forward(blk, result);
     return result;
    }
    catch(e$0){
     var e = caml_wrap_exception(e$0);
     blk[1] = function(param){throw caml_maybe_attach_backtrace(e, 0);};
     throw caml_maybe_attach_backtrace(e, 0);
    }
   }
   function force_val_lazy_block(blk){
    var closure = blk[1];
    blk[1] = raise_undefined;
    var result = caml_call1(closure, 0);
    caml_obj_make_forward(blk, result);
    return result;
   }
   function force(lzv){
    var t = caml_obj_tag(lzv);
    return t === Stdlib_Obj[10]
            ? lzv[1]
            : t !== Stdlib_Obj[6] ? lzv : force_lazy_block(lzv);
   }
   function force_val(lzv){
    var t = caml_obj_tag(lzv);
    return t === Stdlib_Obj[10]
            ? lzv[1]
            : t !== Stdlib_Obj[6] ? lzv : force_val_lazy_block(lzv);
   }
   var
    CamlinternalLazy =
      [0, Undefined, force_lazy_block, force_val_lazy_block, force, force_val];
   runtime.caml_register_global(2, CamlinternalLazy, "CamlinternalLazy");
   return;
  }
  (globalThis));

//# 1300 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, caml_obj_tag = runtime.caml_obj_tag;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    CamlinternalLazy = global_data.CamlinternalLazy,
    Stdlib_Obj = global_data.Stdlib__Obj,
    Undefined = CamlinternalLazy[1],
    force_val = CamlinternalLazy[5];
   function from_fun(f){
    var x = runtime.caml_obj_block(Stdlib_Obj[6], 1);
    x[1] = f;
    return x;
   }
   function from_val(v){
    var t = caml_obj_tag(v);
    if(t !== Stdlib_Obj[10] && t !== Stdlib_Obj[6] && t !== Stdlib_Obj[14])
     return v;
    return runtime.caml_lazy_make_forward(v);
   }
   function is_val(l){
    var _i_ = Stdlib_Obj[6];
    return caml_obj_tag(l) !== _i_ ? 1 : 0;
   }
   function map(f, x){
    return [246,
            function(_f_){
             var
              _g_ = caml_obj_tag(x),
              _h_ =
                250 === _g_
                 ? x[1]
                 : 246 === _g_ ? caml_call1(CamlinternalLazy[2], x) : x;
             return caml_call1(f, _h_);
            }];
   }
   function map_val(f, x){
    if(! is_val(x))
     return [246,
             function(_c_){
              var
               _d_ = caml_obj_tag(x),
               _e_ =
                 250 === _d_
                  ? x[1]
                  : 246 === _d_ ? caml_call1(CamlinternalLazy[2], x) : x;
              return caml_call1(f, _e_);
             }];
    var
     _a_ = caml_obj_tag(x),
     _b_ =
       250 === _a_
        ? x[1]
        : 246 === _a_ ? caml_call1(CamlinternalLazy[2], x) : x;
    return from_val(caml_call1(f, _b_));
   }
   var
    Stdlib_Lazy =
      [0,
       Undefined,
       map,
       is_val,
       from_val,
       map_val,
       from_fun,
       force_val,
       from_fun,
       from_val,
       is_val];
   runtime.caml_register_global(2, Stdlib_Lazy, "Stdlib__Lazy");
   return;
  }
  (globalThis));

//# 1382 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Assert_failure = global_data.Assert_failure,
    CamlinternalAtomic = global_data.CamlinternalAtomic,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Stdlib = global_data.Stdlib,
    Stdlib_Lazy = global_data.Stdlib__Lazy,
    cst_Seq_init = "Seq.init",
    cst_Seq_take = "Seq.take",
    cst_Seq_drop = "Seq.drop";
   function empty(param){return 0;}
   function return$0(x, param){return [0, x, empty];}
   function cons(x, next, param){return [0, x, next];}
   function append(seq1, seq2, param){
    var match = caml_call1(seq1, 0);
    if(! match) return caml_call1(seq2, 0);
    var next = match[2], x = match[1];
    return [0, x, function(_av_){return append(next, seq2, _av_);}];
   }
   function map(f, seq, param){
    var match = caml_call1(seq, 0);
    if(! match) return 0;
    var next = match[2], x = match[1];
    return [0, caml_call1(f, x), function(_au_){return map(f, next, _au_);}];
   }
   function filter_map(f, seq, param){
    var seq$0 = seq;
    for(;;){
     var match = caml_call1(seq$0, 0);
     if(! match) return 0;
     var next = match[2], x = match[1], match$0 = caml_call1(f, x);
     if(match$0){
      var y = match$0[1];
      return [0, y, function(_at_){return filter_map(f, next, _at_);}];
     }
     seq$0 = next;
    }
   }
   function filter(f, seq, param){
    var seq$0 = seq;
    for(;;){
     var match = caml_call1(seq$0, 0);
     if(! match) return 0;
     var next = match[2], x = match[1];
     if(caml_call1(f, x))
      return [0, x, function(_as_){return filter(f, next, _as_);}];
     seq$0 = next;
    }
   }
   function concat(seq, param){
    var match = caml_call1(seq, 0);
    if(! match) return 0;
    var next = match[2], x = match[1];
    return append(x, function(_ar_){return concat(next, _ar_);}, 0);
   }
   function flat_map(f, seq, param){
    var match = caml_call1(seq, 0);
    if(! match) return 0;
    var next = match[2], x = match[1];
    return append
            (caml_call1(f, x),
             function(_aq_){return flat_map(f, next, _aq_);},
             0);
   }
   function fold_left(f, acc, seq){
    var acc$0 = acc, seq$0 = seq;
    for(;;){
     var match = caml_call1(seq$0, 0);
     if(! match) return acc$0;
     var next = match[2], x = match[1], acc$1 = caml_call2(f, acc$0, x);
     acc$0 = acc$1;
     seq$0 = next;
    }
   }
   function iter(f, seq){
    var seq$0 = seq;
    for(;;){
     var match = caml_call1(seq$0, 0);
     if(! match) return 0;
     var next = match[2], x = match[1];
     caml_call1(f, x);
     seq$0 = next;
    }
   }
   function unfold(f, u, param){
    var match = caml_call1(f, u);
    if(! match) return 0;
    var match$0 = match[1], u$0 = match$0[2], x = match$0[1];
    return [0, x, function(_ap_){return unfold(f, u$0, _ap_);}];
   }
   function is_empty(xs){return caml_call1(xs, 0) ? 0 : 1;}
   function uncons(xs){
    var match = caml_call1(xs, 0);
    if(! match) return 0;
    var xs$0 = match[2], x = match[1];
    return [0, [0, x, xs$0]];
   }
   function length(xs$1){
    var accu = 0, xs = xs$1;
    for(;;){
     var match = caml_call1(xs, 0);
     if(! match) return accu;
     var xs$0 = match[2], accu$0 = accu + 1 | 0;
     accu = accu$0;
     xs = xs$0;
    }
   }
   function iteri(f, xs$1){
    var i = 0, xs = xs$1;
    for(;;){
     var match = caml_call1(xs, 0);
     if(! match) return 0;
     var xs$0 = match[2], x = match[1];
     caml_call2(f, i, x);
     var i$0 = i + 1 | 0;
     i = i$0;
     xs = xs$0;
    }
   }
   function fold_lefti(f, accu$1, xs$1){
    var accu = accu$1, i = 0, xs = xs$1;
    for(;;){
     var match = caml_call1(xs, 0);
     if(! match) return accu;
     var
      xs$0 = match[2],
      x = match[1],
      accu$0 = caml_call3(f, accu, i, x),
      i$0 = i + 1 | 0;
     accu = accu$0;
     i = i$0;
     xs = xs$0;
    }
   }
   function for_all(p, xs){
    var xs$0 = xs;
    for(;;){
     var match = caml_call1(xs$0, 0);
     if(! match) return 1;
     var xs$1 = match[2], x = match[1], _ao_ = caml_call1(p, x);
     if(! _ao_) return _ao_;
     xs$0 = xs$1;
    }
   }
   function exists(p, xs){
    var xs$0 = xs;
    for(;;){
     var match = caml_call1(xs$0, 0);
     if(! match) return 0;
     var xs$1 = match[2], x = match[1], _an_ = caml_call1(p, x);
     if(_an_) return _an_;
     xs$0 = xs$1;
    }
   }
   function find(p, xs){
    var xs$0 = xs;
    for(;;){
     var match = caml_call1(xs$0, 0);
     if(! match) return 0;
     var xs$1 = match[2], x = match[1];
     if(caml_call1(p, x)) return [0, x];
     xs$0 = xs$1;
    }
   }
   function find_map(f, xs){
    var xs$0 = xs;
    for(;;){
     var match = caml_call1(xs$0, 0);
     if(! match) return 0;
     var xs$1 = match[2], x = match[1], result = caml_call1(f, x);
     if(result) return result;
     xs$0 = xs$1;
    }
   }
   function iter2(f, xs, ys){
    var xs$0 = xs, ys$0 = ys;
    for(;;){
     var match = caml_call1(xs$0, 0);
     if(! match) return 0;
     var xs$1 = match[2], x = match[1], match$0 = caml_call1(ys$0, 0);
     if(! match$0) return 0;
     var ys$1 = match$0[2], y = match$0[1];
     caml_call2(f, x, y);
     xs$0 = xs$1;
     ys$0 = ys$1;
    }
   }
   function fold_left2(f, accu, xs, ys){
    var accu$0 = accu, xs$0 = xs, ys$0 = ys;
    for(;;){
     var match = caml_call1(xs$0, 0);
     if(! match) return accu$0;
     var xs$1 = match[2], x = match[1], match$0 = caml_call1(ys$0, 0);
     if(! match$0) return accu$0;
     var
      ys$1 = match$0[2],
      y = match$0[1],
      accu$1 = caml_call3(f, accu$0, x, y);
     accu$0 = accu$1;
     xs$0 = xs$1;
     ys$0 = ys$1;
    }
   }
   function for_all2(f, xs, ys){
    var xs$0 = xs, ys$0 = ys;
    for(;;){
     var match = caml_call1(xs$0, 0);
     if(! match) return 1;
     var xs$1 = match[2], x = match[1], match$0 = caml_call1(ys$0, 0);
     if(! match$0) return 1;
     var ys$1 = match$0[2], y = match$0[1], _am_ = caml_call2(f, x, y);
     if(! _am_) return _am_;
     xs$0 = xs$1;
     ys$0 = ys$1;
    }
   }
   function exists2(f, xs, ys){
    var xs$0 = xs, ys$0 = ys;
    for(;;){
     var match = caml_call1(xs$0, 0);
     if(! match) return 0;
     var xs$1 = match[2], x = match[1], match$0 = caml_call1(ys$0, 0);
     if(! match$0) return 0;
     var ys$1 = match$0[2], y = match$0[1], _al_ = caml_call2(f, x, y);
     if(_al_) return _al_;
     xs$0 = xs$1;
     ys$0 = ys$1;
    }
   }
   function equal(eq, xs, ys){
    var xs$0 = xs, ys$0 = ys;
    for(;;){
     var match = caml_call1(xs$0, 0), match$0 = caml_call1(ys$0, 0);
     if(match){
      if(match$0){
       var
        ys$1 = match$0[2],
        y = match$0[1],
        xs$1 = match[2],
        x = match[1],
        _ak_ = caml_call2(eq, x, y);
       if(! _ak_) return _ak_;
       xs$0 = xs$1;
       ys$0 = ys$1;
       continue;
      }
     }
     else if(! match$0) return 1;
     return 0;
    }
   }
   function compare(cmp, xs, ys){
    var xs$0 = xs, ys$0 = ys;
    for(;;){
     var match = caml_call1(xs$0, 0), match$0 = caml_call1(ys$0, 0);
     if(! match) return match$0 ? -1 : 0;
     var xs$1 = match[2], x = match[1];
     if(! match$0) return 1;
     var ys$1 = match$0[2], y = match$0[1], c = caml_call2(cmp, x, y);
     if(0 !== c) return c;
     xs$0 = xs$1;
     ys$0 = ys$1;
    }
   }
   function init_aux(f, i, j, param){
    if(i >= j) return 0;
    var _ai_ = i + 1 | 0;
    return [0,
            caml_call1(f, i),
            function(_aj_){return init_aux(f, _ai_, j, _aj_);}];
   }
   function init(n, f){
    if(0 > n) return caml_call1(Stdlib[1], cst_Seq_init);
    var _ag_ = 0;
    return function(_ah_){return init_aux(f, _ag_, n, _ah_);};
   }
   function repeat(x, param){
    return [0, x, function(_af_){return repeat(x, _af_);}];
   }
   function forever(f, param){
    return [0, caml_call1(f, 0), function(_ae_){return forever(f, _ae_);}];
   }
   function cycle_nonempty(xs, param){
    return append(xs, function(_ad_){return cycle_nonempty(xs, _ad_);}, 0);
   }
   function cycle(xs, param){
    var match = caml_call1(xs, 0);
    if(! match) return 0;
    var xs$0 = match[2], x = match[1];
    function _aa_(_ac_){return cycle_nonempty(xs, _ac_);}
    return [0, x, function(_ab_){return append(xs$0, _aa_, _ab_);}];
   }
   function iterate1(f, x, param){
    var y = caml_call1(f, x);
    return [0, y, function(_$_){return iterate1(f, y, _$_);}];
   }
   function iterate(f, x){
    function next(___){return iterate1(f, x, ___);}
    return function(_Z_){return [0, x, next];};
   }
   function mapi_aux(f, i, xs, param){
    var match = caml_call1(xs, 0);
    if(! match) return 0;
    var xs$0 = match[2], x = match[1], _X_ = i + 1 | 0;
    return [0,
            caml_call2(f, i, x),
            function(_Y_){return mapi_aux(f, _X_, xs$0, _Y_);}];
   }
   function mapi(f, xs){
    var _V_ = 0;
    return function(_W_){return mapi_aux(f, _V_, xs, _W_);};
   }
   function tail_scan(f, s, xs, param){
    var match = caml_call1(xs, 0);
    if(! match) return 0;
    var xs$0 = match[2], x = match[1], s$0 = caml_call2(f, s, x);
    return [0, s$0, function(_U_){return tail_scan(f, s$0, xs$0, _U_);}];
   }
   function scan(f, s, xs){
    function next(_T_){return tail_scan(f, s, xs, _T_);}
    return function(_S_){return [0, s, next];};
   }
   function take_aux(n, xs){
    return 0 === n
            ? empty
            : function
             (param){
              var match = caml_call1(xs, 0);
              if(! match) return 0;
              var xs$0 = match[2], x = match[1];
              return [0, x, take_aux(n - 1 | 0, xs$0)];
             };
   }
   function take(n, xs){
    if(n < 0) caml_call1(Stdlib[1], cst_Seq_take);
    return take_aux(n, xs);
   }
   function drop(n, xs){
    return 0 <= n
            ? 0
              === n
              ? xs
              : function
               (param){
                var n$0 = n, xs$0 = xs;
                for(;;){
                 var match = caml_call1(xs$0, 0);
                 if(! match) return 0;
                 var xs$1 = match[2], n$1 = n$0 - 1 | 0;
                 if(0 === n$1) return caml_call1(xs$1, 0);
                 n$0 = n$1;
                 xs$0 = xs$1;
                }
               }
            : caml_call1(Stdlib[1], cst_Seq_drop);
   }
   function take_while(p, xs, param){
    var match = caml_call1(xs, 0);
    if(! match) return 0;
    var xs$0 = match[2], x = match[1];
    return caml_call1(p, x)
            ? [0, x, function(_R_){return take_while(p, xs$0, _R_);}]
            : 0;
   }
   function drop_while(p, xs, param){
    var xs$0 = xs;
    for(;;){
     var node = caml_call1(xs$0, 0);
     if(! node) return 0;
     var xs$1 = node[2], x = node[1];
     if(! caml_call1(p, x)) return node;
     xs$0 = xs$1;
    }
   }
   function group(eq, xs, param){
    var match = caml_call1(xs, 0);
    if(! match) return 0;
    var xs$0 = match[2], x = match[1], _K_ = caml_call1(eq, x);
    function _L_(_Q_){return drop_while(_K_, xs$0, _Q_);}
    var _M_ = caml_call1(eq, x);
    function next(_P_){return take_while(_M_, xs$0, _P_);}
    return [0,
            function(_O_){return [0, x, next];},
            function(_N_){return group(eq, _L_, _N_);}];
   }
   var
    Forced_twice =
      [248, "Stdlib.Seq.Forced_twice", runtime.caml_fresh_oo_id(0)],
    to_lazy = Stdlib_Lazy[6],
    _a_ = [0, "seq.ml", 596, 4];
   function failure(param){
    throw caml_maybe_attach_backtrace(Forced_twice, 1);
   }
   function memoize(xs){
    function s$0(param){
     var match = caml_call1(xs, 0);
     if(! match) return 0;
     var xs$0 = match[2], x = match[1];
     return [0, x, memoize(xs$0)];
    }
    var s = caml_call1(to_lazy, s$0);
    return function(_J_){
     var _I_ = runtime.caml_obj_tag(s);
     return 250 === _I_
             ? s[1]
             : 246 === _I_ ? caml_call1(CamlinternalLazy[2], s) : s;};
   }
   function once(xs){
    function f(param){
     var match = caml_call1(xs, 0);
     if(! match) return 0;
     var xs$0 = match[2], x = match[1];
     return [0, x, once(xs$0)];
    }
    var action = caml_call1(CamlinternalAtomic[1], f);
    return function(param){
     var f = caml_call2(CamlinternalAtomic[4], action, failure);
     return caml_call1(f, 0);};
   }
   function zip(xs, ys, param){
    var match = caml_call1(xs, 0);
    if(! match) return 0;
    var xs$0 = match[2], x = match[1], match$0 = caml_call1(ys, 0);
    if(! match$0) return 0;
    var ys$0 = match$0[2], y = match$0[1];
    return [0, [0, x, y], function(_H_){return zip(xs$0, ys$0, _H_);}];
   }
   function map2(f, xs, ys, param){
    var match = caml_call1(xs, 0);
    if(! match) return 0;
    var xs$0 = match[2], x = match[1], match$0 = caml_call1(ys, 0);
    if(! match$0) return 0;
    var ys$0 = match$0[2], y = match$0[1];
    return [0,
            caml_call2(f, x, y),
            function(_G_){return map2(f, xs$0, ys$0, _G_);}];
   }
   function interleave(xs, ys, param){
    var match = caml_call1(xs, 0);
    if(! match) return caml_call1(ys, 0);
    var xs$0 = match[2], x = match[1];
    return [0, x, function(_F_){return interleave(ys, xs$0, _F_);}];
   }
   function sorted_merge1(cmp, x, xs, y, ys){
    return 0 < caml_call2(cmp, x, y)
            ? [0,
              y,
              function(_D_){
               var match = caml_call1(ys, 0);
               if(! match) return [0, x, xs];
               var ys$0 = match[2], y = match[1];
               return sorted_merge1(cmp, x, xs, y, ys$0);
              }]
            : [0,
              x,
              function(_E_){
               var match = caml_call1(xs, 0);
               if(! match) return [0, y, ys];
               var xs$0 = match[2], x = match[1];
               return sorted_merge1(cmp, x, xs$0, y, ys);
              }];
   }
   function sorted_merge(cmp, xs, ys, param){
    var match = caml_call1(xs, 0), match$0 = caml_call1(ys, 0);
    if(match){
     if(match$0){
      var ys$0 = match$0[2], y = match$0[1], xs$0 = match[2], x = match[1];
      return sorted_merge1(cmp, x, xs$0, y, ys$0);
     }
     var c = match;
    }
    else{if(! match$0) return 0; var c = match$0;}
    return c;
   }
   function map_fst(xys, param){
    var match = caml_call1(xys, 0);
    if(! match) return 0;
    var xys$0 = match[2], x = match[1][1];
    return [0, x, function(_C_){return map_fst(xys$0, _C_);}];
   }
   function map_snd(xys, param){
    var match = caml_call1(xys, 0);
    if(! match) return 0;
    var xys$0 = match[2], y = match[1][2];
    return [0, y, function(_B_){return map_snd(xys$0, _B_);}];
   }
   function unzip(xys){
    return [0,
            function(_A_){return map_fst(xys, _A_);},
            function(_z_){return map_snd(xys, _z_);}];
   }
   function filter_map_find_left_map(f, xs, param){
    var xs$0 = xs;
    for(;;){
     var match = caml_call1(xs$0, 0);
     if(! match) return 0;
     var xs$1 = match[2], x = match[1], match$0 = caml_call1(f, x);
     if(0 === match$0[0]){
      var y = match$0[1];
      return [0,
              y,
              function(_y_){return filter_map_find_left_map(f, xs$1, _y_);}];
     }
     xs$0 = xs$1;
    }
   }
   function filter_map_find_right_map(f, xs, param){
    var xs$0 = xs;
    for(;;){
     var match = caml_call1(xs$0, 0);
     if(! match) return 0;
     var xs$1 = match[2], x = match[1], match$0 = caml_call1(f, x);
     if(0 !== match$0[0]){
      var z = match$0[1];
      return [0,
              z,
              function(_x_){return filter_map_find_right_map(f, xs$1, _x_);}];
     }
     xs$0 = xs$1;
    }
   }
   function partition_map(f, xs){
    return [0,
            function(_w_){return filter_map_find_left_map(f, xs, _w_);},
            function(_v_){return filter_map_find_right_map(f, xs, _v_);}];
   }
   function partition(p, xs){
    function _s_(x){return 1 - caml_call1(p, x);}
    return [0,
            function(_u_){return filter(p, xs, _u_);},
            function(_t_){return filter(_s_, xs, _t_);}];
   }
   function peel(xss){
    return unzip(function(_r_){return filter_map(uncons, xss, _r_);});
   }
   function transpose(xss, param){
    var match = peel(xss), tails = match[2], heads = match[1];
    if(! is_empty(heads))
     return [0, heads, function(_q_){return transpose(tails, _q_);}];
    if(is_empty(tails)) return 0;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
   }
   function _b_(remainders, xss, param){
    var match = caml_call1(xss, 0);
    if(! match) return transpose(remainders, 0);
    var xss$0 = match[2], xs = match[1], match$0 = caml_call1(xs, 0);
    if(match$0){
     var
      xs$0 = match$0[2],
      x = match$0[1],
      match$1 = peel(remainders),
      tails = match$1[2],
      heads = match$1[1],
      _l_ = function(_p_){return [0, xs$0, tails];};
     return [0,
             function(_o_){return [0, x, heads];},
             function(_n_){return _b_(_l_, xss$0, _n_);}];
    }
    var
     match$2 = peel(remainders),
     tails$0 = match$2[2],
     heads$0 = match$2[1];
    return [0, heads$0, function(_m_){return _b_(tails$0, xss$0, _m_);}];
   }
   function map_product(f, xs, ys){
    function _f_(x){
     function _j_(y){return caml_call2(f, x, y);}
     return function(_k_){return map(_j_, ys, _k_);};
    }
    function xss(_i_){return map(_f_, xs, _i_);}
    function _e_(_h_){return _b_(empty, xss, _h_);}
    return function(_g_){return concat(_e_, _g_);};
   }
   function product(xs, ys){
    return map_product(function(x, y){return [0, x, y];}, xs, ys);
   }
   function of_dispenser(it){
    function c(param){
     var match = caml_call1(it, 0);
     if(! match) return 0;
     var x = match[1];
     return [0, x, c];
    }
    return c;
   }
   function to_dispenser(xs){
    var s = [0, xs];
    return function(param){
     var match = caml_call1(s[1], 0);
     if(! match) return 0;
     var xs = match[2], x = match[1];
     s[1] = xs;
     return [0, x];};
   }
   function ints(i, param){
    var _c_ = i + 1 | 0;
    return [0, i, function(_d_){return ints(_c_, _d_);}];
   }
   var
    Stdlib_Seq =
      [0,
       is_empty,
       uncons,
       length,
       iter,
       fold_left,
       iteri,
       fold_lefti,
       for_all,
       exists,
       find,
       find_map,
       iter2,
       fold_left2,
       for_all2,
       exists2,
       equal,
       compare,
       empty,
       return$0,
       cons,
       init,
       unfold,
       repeat,
       forever,
       cycle,
       iterate,
       map,
       mapi,
       filter,
       filter_map,
       scan,
       take,
       drop,
       take_while,
       drop_while,
       group,
       memoize,
       Forced_twice,
       once,
       transpose,
       append,
       concat,
       flat_map,
       flat_map,
       zip,
       map2,
       interleave,
       sorted_merge,
       product,
       map_product,
       unzip,
       unzip,
       partition_map,
       partition,
       of_dispenser,
       to_dispenser,
       ints];
   runtime.caml_register_global(10, Stdlib_Seq, "Stdlib__Seq");
   return;
  }
  (globalThis));

//# 2338 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_bytes_unsafe_set = runtime.caml_bytes_unsafe_set,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_string_of_bytes = runtime.caml_string_of_bytes;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "\\\\",
    cst$0 = "\\'",
    Stdlib = global_data.Stdlib,
    cst_Char_chr = "Char.chr",
    cst_b = "\\b",
    cst_t = "\\t",
    cst_n = "\\n",
    cst_r = "\\r";
   function chr(n){
    if(0 <= n && 255 >= n) return n;
    return caml_call1(Stdlib[1], cst_Char_chr);
   }
   function escaped(c){
    a:
    {
     if(40 <= c){
      if(92 === c) return cst;
      if(127 > c) break a;
     }
     else{
      if(32 <= c){if(39 <= c) return cst$0; break a;}
      if(14 > c)
       switch(c){
         case 8:
          return cst_b;
         case 9:
          return cst_t;
         case 10:
          return cst_n;
         case 13:
          return cst_r;
       }
     }
     var s = caml_create_bytes(4);
     caml_bytes_unsafe_set(s, 0, 92);
     caml_bytes_unsafe_set(s, 1, 48 + (c / 100 | 0) | 0);
     caml_bytes_unsafe_set(s, 2, 48 + ((c / 10 | 0) % 10 | 0) | 0);
     caml_bytes_unsafe_set(s, 3, 48 + (c % 10 | 0) | 0);
     return caml_string_of_bytes(s);
    }
    var s$0 = caml_create_bytes(1);
    caml_bytes_unsafe_set(s$0, 0, c);
    return caml_string_of_bytes(s$0);
   }
   function lowercase(c){
    var _b_ = c - 192 | 0;
    a:
    {
     if(30 < _b_ >>> 0){
      if(25 < _b_ + 127 >>> 0) break a;
     }
     else if(23 === _b_) break a;
     return c + 32 | 0;
    }
    return c;
   }
   function uppercase(c){
    var _a_ = c - 224 | 0;
    a:
    {
     if(30 < _a_ >>> 0){
      if(25 < _a_ + 127 >>> 0) break a;
     }
     else if(23 === _a_) break a;
     return c - 32 | 0;
    }
    return c;
   }
   function lowercase_ascii(c){return 25 < c - 65 >>> 0 ? c : c + 32 | 0;}
   function uppercase_ascii(c){return 25 < c - 97 >>> 0 ? c : c - 32 | 0;}
   function compare(c1, c2){return c1 - c2 | 0;}
   function equal(c1, c2){return 0 === (c1 - c2 | 0) ? 1 : 0;}
   var
    Stdlib_Char =
      [0,
       chr,
       escaped,
       lowercase,
       uppercase,
       lowercase_ascii,
       uppercase_ascii,
       compare,
       equal];
   runtime.caml_register_global(8, Stdlib_Char, "Stdlib__Char");
   return;
  }
  (globalThis));

//# 2443 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_uchar_ml = "uchar.ml",
    caml_format_int = runtime.caml_format_int,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    err_no_pred = "U+0000 has no predecessor",
    err_no_succ = "U+10FFFF has no successor",
    Assert_failure = global_data.Assert_failure,
    Stdlib = global_data.Stdlib,
    cst_is_not_an_Unicode_scalar_v = " is not an Unicode scalar value",
    cst_is_not_a_latin1_character = " is not a latin1 character",
    cst_U = "U+",
    lo_bound = 55295,
    hi_bound = 57344;
   function succ(u){
    return u === 55295
            ? hi_bound
            : u === 1114111 ? caml_call1(Stdlib[1], err_no_succ) : u + 1 | 0;
   }
   function pred(u){
    return u === 57344
            ? lo_bound
            : u === 0 ? caml_call1(Stdlib[1], err_no_pred) : u - 1 | 0;
   }
   function is_valid(i){
    var _n_ = 0 <= i ? 1 : 0, _o_ = _n_ ? i <= 55295 ? 1 : 0 : _n_;
    if(_o_)
     var _p_ = _o_;
    else
     var _q_ = 57344 <= i ? 1 : 0, _p_ = _q_ ? i <= 1114111 ? 1 : 0 : _q_;
    return _p_;
   }
   function of_int(i){
    if(is_valid(i)) return i;
    var
     _m_ =
       caml_call2
        (Stdlib[28], caml_format_int("%X", i), cst_is_not_an_Unicode_scalar_v);
    return caml_call1(Stdlib[1], _m_);
   }
   function is_char(u){return u < 256 ? 1 : 0;}
   function of_char(c){return c;}
   function to_char(u){
    if(255 >= u) return u;
    var
     _k_ =
       caml_call2
        (Stdlib[28],
         caml_format_int("%04X", u),
         cst_is_not_a_latin1_character),
     _l_ = caml_call2(Stdlib[28], cst_U, _k_);
    return caml_call1(Stdlib[1], _l_);
   }
   function unsafe_to_char(_j_){return _j_;}
   function equal(_i_, _h_){return _i_ === _h_ ? 1 : 0;}
   var
    compare = runtime.caml_int_compare,
    _a_ = [0, cst_uchar_ml, 85, 7],
    _b_ = [0, cst_uchar_ml, 80, 18],
    _c_ = [0, cst_uchar_ml, 91, 7],
    _d_ = [0, cst_uchar_ml, 88, 18];
   function hash(_g_){return _g_;}
   function utf_decode_is_valid(d){return 1 === (d >>> 27 | 0) ? 1 : 0;}
   function utf_decode_length(d){return (d >>> 24 | 0) & 7;}
   function utf_decode_uchar(d){return d & 16777215;}
   function utf_decode(n, u){return (8 | n) << 24 | u;}
   function utf_decode_invalid(n){return n << 24 | 65533;}
   function utf_8_byte_length(u){
    if(0 > u) throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
    if(127 >= u) return 1;
    if(2047 >= u) return 2;
    if(65535 >= u) return 3;
    if(1114111 < u)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
    return 4;
   }
   function utf_16_byte_length(u){
    if(0 > u) throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
    if(65535 >= u) return 2;
    if(1114111 < u)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
    return 4;
   }
   var
    Stdlib_Uchar =
      [0,
       0,
       1114111,
       65279,
       65533,
       succ,
       pred,
       is_valid,
       of_int,
       function(_f_){return _f_;},
       function(_e_){return _e_;},
       is_char,
       of_char,
       to_char,
       unsafe_to_char,
       equal,
       compare,
       hash,
       utf_decode_is_valid,
       utf_decode_uchar,
       utf_decode_length,
       utf_decode,
       utf_decode_invalid,
       utf_8_byte_length,
       utf_16_byte_length];
   runtime.caml_register_global(13, Stdlib_Uchar, "Stdlib__Uchar");
   return;
  }
  (globalThis));

//# 2575 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_List_nth$1 = "List.nth",
    caml_compare = runtime.caml_compare,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Stdlib_Seq = global_data.Stdlib__Seq,
    Stdlib_Sys = global_data.Stdlib__Sys,
    cst_hd = "hd",
    cst_tl = "tl",
    cst_nth = "nth",
    cst_List_nth = cst_List_nth$1,
    cst_List_nth$0 = cst_List_nth$1;
   function length(l$0){
    var len = 0, param = l$0;
    for(;;){
     if(! param) return len;
     var l = param[2], len$0 = len + 1 | 0;
     len = len$0;
     param = l;
    }
   }
   function cons(a, l){return [0, a, l];}
   function hd(param){
    if(! param) return caml_call1(Stdlib[2], cst_hd);
    var a = param[1];
    return a;
   }
   function tl(param){
    if(! param) return caml_call1(Stdlib[2], cst_tl);
    var l = param[2];
    return l;
   }
   function nth(l, n){
    if(0 > n) return caml_call1(Stdlib[1], cst_List_nth);
    var l$0 = l, n$0 = n;
    for(;;){
     if(! l$0) return caml_call1(Stdlib[2], cst_nth);
     var l$1 = l$0[2], a = l$0[1];
     if(0 === n$0) return a;
     var n$1 = n$0 - 1 | 0;
     l$0 = l$1;
     n$0 = n$1;
    }
   }
   function nth_opt(l, n){
    if(0 > n) return caml_call1(Stdlib[1], cst_List_nth$0);
    var l$0 = l, n$0 = n;
    for(;;){
     if(! l$0) return 0;
     var l$1 = l$0[2], a = l$0[1];
     if(0 === n$0) return [0, a];
     var n$1 = n$0 - 1 | 0;
     l$0 = l$1;
     n$0 = n$1;
    }
   }
   var append = Stdlib[37];
   function rev_append(l1, l2){
    var l1$0 = l1, l2$0 = l2;
    for(;;){
     if(! l1$0) return l2$0;
     var l1$1 = l1$0[2], a = l1$0[1], l2$1 = [0, a, l2$0];
     l1$0 = l1$1;
     l2$0 = l2$1;
    }
   }
   function rev(l){return rev_append(l, 0);}
   function init_aux(i, n, f){
    if(n <= i) return 0;
    var r = caml_call1(f, i);
    return [0, r, init_aux(i + 1 | 0, n, f)];
   }
   var
    cst_List_map2 = "List.map2",
    cst_List_iter2 = "List.iter2",
    cst_List_fold_left2 = "List.fold_left2",
    cst_List_fold_right2 = "List.fold_right2",
    cst_List_for_all2 = "List.for_all2",
    cst_List_exists2 = "List.exists2",
    _b_ = [0, 0, 0],
    cst_List_combine = "List.combine",
    cst_List_rev_map2 = "List.rev_map2",
    cst_List_init = "List.init",
    rev_init_threshold = typeof Stdlib_Sys[5] === "number" ? 10000 : 50;
   function init(len, f){
    if(0 > len) return caml_call1(Stdlib[1], cst_List_init);
    if(rev_init_threshold >= len) return init_aux(0, len, f);
    var acc = 0, i = 0;
    for(;;){
     if(len <= i) return rev(acc);
     var i$0 = i + 1 | 0, acc$0 = [0, caml_call1(f, i), acc];
     acc = acc$0;
     i = i$0;
    }
   }
   function flatten(param){
    if(! param) return 0;
    var r = param[2], l = param[1], _H_ = flatten(r);
    return caml_call2(Stdlib[37], l, _H_);
   }
   function map(f, param){
    if(! param) return 0;
    var l = param[2], a = param[1], r = caml_call1(f, a);
    return [0, r, map(f, l)];
   }
   function _a_(i, f, param){
    if(! param) return 0;
    var l = param[2], a = param[1], r = caml_call2(f, i, a);
    return [0, r, _a_(i + 1 | 0, f, l)];
   }
   function mapi(f, l){return _a_(0, f, l);}
   function rev_map(f, l){
    var accu = 0, param = l;
    for(;;){
     if(! param) return accu;
     var l$0 = param[2], a = param[1], accu$0 = [0, caml_call1(f, a), accu];
     accu = accu$0;
     param = l$0;
    }
   }
   function iter(f, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var l = param$0[2], a = param$0[1];
     caml_call1(f, a);
     param$0 = l;
    }
   }
   function iteri(f, l$0){
    var i = 0, param = l$0;
    for(;;){
     if(! param) return 0;
     var l = param[2], a = param[1];
     caml_call2(f, i, a);
     var i$0 = i + 1 | 0;
     i = i$0;
     param = l;
    }
   }
   function fold_left(f, accu, l){
    var accu$0 = accu, l$0 = l;
    for(;;){
     if(! l$0) return accu$0;
     var l$1 = l$0[2], a = l$0[1], accu$1 = caml_call2(f, accu$0, a);
     accu$0 = accu$1;
     l$0 = l$1;
    }
   }
   function fold_right(f, l, accu){
    if(! l) return accu;
    var l$0 = l[2], a = l[1];
    return caml_call2(f, a, fold_right(f, l$0, accu));
   }
   function map2(f, l1, l2){
    if(l1){
     if(l2){
      var
       l2$0 = l2[2],
       a2 = l2[1],
       l1$0 = l1[2],
       a1 = l1[1],
       r = caml_call2(f, a1, a2);
      return [0, r, map2(f, l1$0, l2$0)];
     }
    }
    else if(! l2) return 0;
    return caml_call1(Stdlib[1], cst_List_map2);
   }
   function rev_map2(f, l1, l2){
    var accu = 0, l1$0 = l1, l2$0 = l2;
    for(;;){
     if(l1$0){
      if(l2$0){
       var
        l2$1 = l2$0[2],
        a2 = l2$0[1],
        l1$1 = l1$0[2],
        a1 = l1$0[1],
        accu$0 = [0, caml_call2(f, a1, a2), accu];
       accu = accu$0;
       l1$0 = l1$1;
       l2$0 = l2$1;
       continue;
      }
     }
     else if(! l2$0) return accu;
     return caml_call1(Stdlib[1], cst_List_rev_map2);
    }
   }
   function iter2(f, l1, l2){
    var l1$0 = l1, l2$0 = l2;
    for(;;){
     if(l1$0){
      if(l2$0){
       var l2$1 = l2$0[2], a2 = l2$0[1], l1$1 = l1$0[2], a1 = l1$0[1];
       caml_call2(f, a1, a2);
       l1$0 = l1$1;
       l2$0 = l2$1;
       continue;
      }
     }
     else if(! l2$0) return 0;
     return caml_call1(Stdlib[1], cst_List_iter2);
    }
   }
   function fold_left2(f, accu, l1, l2){
    var accu$0 = accu, l1$0 = l1, l2$0 = l2;
    for(;;){
     if(l1$0){
      if(l2$0){
       var
        l2$1 = l2$0[2],
        a2 = l2$0[1],
        l1$1 = l1$0[2],
        a1 = l1$0[1],
        accu$1 = caml_call3(f, accu$0, a1, a2);
       accu$0 = accu$1;
       l1$0 = l1$1;
       l2$0 = l2$1;
       continue;
      }
     }
     else if(! l2$0) return accu$0;
     return caml_call1(Stdlib[1], cst_List_fold_left2);
    }
   }
   function fold_right2(f, l1, l2, accu){
    if(l1){
     if(l2){
      var l2$0 = l2[2], a2 = l2[1], l1$0 = l1[2], a1 = l1[1];
      return caml_call3(f, a1, a2, fold_right2(f, l1$0, l2$0, accu));
     }
    }
    else if(! l2) return accu;
    return caml_call1(Stdlib[1], cst_List_fold_right2);
   }
   function for_all(p, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 1;
     var l = param$0[2], a = param$0[1], _G_ = caml_call1(p, a);
     if(! _G_) return _G_;
     param$0 = l;
    }
   }
   function exists(p, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var l = param$0[2], a = param$0[1], _F_ = caml_call1(p, a);
     if(_F_) return _F_;
     param$0 = l;
    }
   }
   function for_all2(p, l1, l2){
    var l1$0 = l1, l2$0 = l2;
    for(;;){
     if(l1$0){
      if(l2$0){
       var
        l2$1 = l2$0[2],
        a2 = l2$0[1],
        l1$1 = l1$0[2],
        a1 = l1$0[1],
        _E_ = caml_call2(p, a1, a2);
       if(! _E_) return _E_;
       l1$0 = l1$1;
       l2$0 = l2$1;
       continue;
      }
     }
     else if(! l2$0) return 1;
     return caml_call1(Stdlib[1], cst_List_for_all2);
    }
   }
   function exists2(p, l1, l2){
    var l1$0 = l1, l2$0 = l2;
    for(;;){
     if(l1$0){
      if(l2$0){
       var
        l2$1 = l2$0[2],
        a2 = l2$0[1],
        l1$1 = l1$0[2],
        a1 = l1$0[1],
        _D_ = caml_call2(p, a1, a2);
       if(_D_) return _D_;
       l1$0 = l1$1;
       l2$0 = l2$1;
       continue;
      }
     }
     else if(! l2$0) return 0;
     return caml_call1(Stdlib[1], cst_List_exists2);
    }
   }
   function mem(x, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var
      l = param$0[2],
      a = param$0[1],
      _C_ = 0 === caml_compare(a, x) ? 1 : 0;
     if(_C_) return _C_;
     param$0 = l;
    }
   }
   function memq(x, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var l = param$0[2], a = param$0[1], _B_ = a === x ? 1 : 0;
     if(_B_) return _B_;
     param$0 = l;
    }
   }
   function assoc(x, param){
    var param$0 = param;
    for(;;){
     if(! param$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     var l = param$0[2], match = param$0[1], b = match[2], a = match[1];
     if(0 === caml_compare(a, x)) return b;
     param$0 = l;
    }
   }
   function assoc_opt(x, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var l = param$0[2], match = param$0[1], b = match[2], a = match[1];
     if(0 === caml_compare(a, x)) return [0, b];
     param$0 = l;
    }
   }
   function assq(x, param){
    var param$0 = param;
    for(;;){
     if(! param$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     var l = param$0[2], match = param$0[1], b = match[2], a = match[1];
     if(a === x) return b;
     param$0 = l;
    }
   }
   function assq_opt(x, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var l = param$0[2], match = param$0[1], b = match[2], a = match[1];
     if(a === x) return [0, b];
     param$0 = l;
    }
   }
   function mem_assoc(x, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var
      l = param$0[2],
      a = param$0[1][1],
      _A_ = 0 === caml_compare(a, x) ? 1 : 0;
     if(_A_) return _A_;
     param$0 = l;
    }
   }
   function mem_assq(x, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var l = param$0[2], a = param$0[1][1], _z_ = a === x ? 1 : 0;
     if(_z_) return _z_;
     param$0 = l;
    }
   }
   function remove_assoc(x, param){
    if(! param) return 0;
    var l = param[2], pair = param[1], a = pair[1];
    return 0 === caml_compare(a, x) ? l : [0, pair, remove_assoc(x, l)];
   }
   function remove_assq(x, param){
    if(! param) return 0;
    var l = param[2], pair = param[1], a = pair[1];
    return a === x ? l : [0, pair, remove_assq(x, l)];
   }
   function find(p, param){
    var param$0 = param;
    for(;;){
     if(! param$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     var l = param$0[2], x = param$0[1];
     if(caml_call1(p, x)) return x;
     param$0 = l;
    }
   }
   function find_opt(p, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var l = param$0[2], x = param$0[1];
     if(caml_call1(p, x)) return [0, x];
     param$0 = l;
    }
   }
   function find_map(f, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var l = param$0[2], x = param$0[1], result = caml_call1(f, x);
     if(result) return result;
     param$0 = l;
    }
   }
   function find_all(p){
    var accu = 0;
    return function(param$0){
     var accu$0 = accu, param = param$0;
     for(;;){
      if(! param) return rev(accu$0);
      var l = param[2], x = param[1];
      if(caml_call1(p, x)){
       var accu$1 = [0, x, accu$0];
       accu$0 = accu$1;
       param = l;
      }
      else
       param = l;
     }};
   }
   function filteri(p, l){
    var i = 0, acc = 0, param = l;
    for(;;){
     if(! param) return rev(acc);
     var
      l$0 = param[2],
      x = param[1],
      acc$0 = caml_call2(p, i, x) ? [0, x, acc] : acc,
      i$0 = i + 1 | 0;
     i = i$0;
     acc = acc$0;
     param = l$0;
    }
   }
   function filter_map(f){
    var accu = 0;
    return function(param$0){
     var accu$0 = accu, param = param$0;
     for(;;){
      if(! param) return rev(accu$0);
      var l = param[2], x = param[1], match = caml_call1(f, x);
      if(match){
       var v = match[1], accu$1 = [0, v, accu$0];
       accu$0 = accu$1;
       param = l;
      }
      else
       param = l;
     }};
   }
   function concat_map(f, l){
    var acc = 0, param = l;
    for(;;){
     if(! param) return rev(acc);
     var
      l$0 = param[2],
      x = param[1],
      xs = caml_call1(f, x),
      acc$0 = rev_append(xs, acc);
     acc = acc$0;
     param = l$0;
    }
   }
   function fold_left_map(f, accu, l){
    var accu$0 = accu, l_accu = 0, param = l;
    for(;;){
     if(! param) return [0, accu$0, rev(l_accu)];
     var
      l$0 = param[2],
      x = param[1],
      match = caml_call2(f, accu$0, x),
      x$0 = match[2],
      accu$1 = match[1],
      l_accu$0 = [0, x$0, l_accu];
     accu$0 = accu$1;
     l_accu = l_accu$0;
     param = l$0;
    }
   }
   function partition(p, l){
    var yes = 0, no = 0, param = l;
    for(;;){
     if(! param){var _y_ = rev(no); return [0, rev(yes), _y_];}
     var l$0 = param[2], x = param[1];
     if(caml_call1(p, x)){
      var yes$0 = [0, x, yes];
      yes = yes$0;
      param = l$0;
     }
     else{var no$0 = [0, x, no]; no = no$0; param = l$0;}
    }
   }
   function partition_map(p, l){
    var left = 0, right = 0, param = l;
    for(;;){
     if(! param){var _x_ = rev(right); return [0, rev(left), _x_];}
     var l$0 = param[2], x = param[1], match = caml_call1(p, x);
     if(0 === match[0]){
      var v = match[1], left$0 = [0, v, left];
      left = left$0;
      param = l$0;
     }
     else{
      var v$0 = match[1], right$0 = [0, v$0, right];
      right = right$0;
      param = l$0;
     }
    }
   }
   function split(param){
    if(! param) return _b_;
    var
     l = param[2],
     match = param[1],
     y = match[2],
     x = match[1],
     match$0 = split(l),
     ry = match$0[2],
     rx = match$0[1];
    return [0, [0, x, rx], [0, y, ry]];
   }
   function combine(l1, l2){
    if(l1){
     if(l2){
      var l2$0 = l2[2], a2 = l2[1], l1$0 = l1[2], a1 = l1[1];
      return [0, [0, a1, a2], combine(l1$0, l2$0)];
     }
    }
    else if(! l2) return 0;
    return caml_call1(Stdlib[1], cst_List_combine);
   }
   function merge(cmp, l1, l2){
    if(! l1) return l2;
    if(! l2) return l1;
    var t2 = l2[2], h2 = l2[1], t1 = l1[2], h1 = l1[1];
    return 0 < caml_call2(cmp, h1, h2)
            ? [0, h2, merge(cmp, l1, t2)]
            : [0, h1, merge(cmp, t1, l2)];
   }
   function stable_sort(cmp, l){
    function sort(n, l){
     if(2 === n){
      if(l){
       var match = l[2];
       if(match){
        var
         tl = match[2],
         x2 = match[1],
         x1 = l[1],
         s =
           0 < caml_call2(cmp, x1, x2)
            ? [0, x2, [0, x1, 0]]
            : [0, x1, [0, x2, 0]];
        return [0, s, tl];
       }
      }
     }
     else if(3 === n && l){
      var _w_ = l[2];
      if(_w_){
       var match$2 = _w_[2];
       if(match$2){
        var
         tl$1 = match$2[2],
         x3 = match$2[1],
         x2$0 = _w_[1],
         x1$0 = l[1],
         s$0 =
           0 < caml_call2(cmp, x1$0, x2$0)
            ? 0
              < caml_call2(cmp, x1$0, x3)
              ? 0
                < caml_call2(cmp, x2$0, x3)
                ? [0, x3, [0, x2$0, [0, x1$0, 0]]]
                : [0, x2$0, [0, x3, [0, x1$0, 0]]]
              : [0, x2$0, [0, x1$0, [0, x3, 0]]]
            : 0
              < caml_call2(cmp, x2$0, x3)
              ? 0
                < caml_call2(cmp, x1$0, x3)
                ? [0, x3, [0, x1$0, [0, x2$0, 0]]]
                : [0, x1$0, [0, x3, [0, x2$0, 0]]]
              : [0, x1$0, [0, x2$0, [0, x3, 0]]];
        return [0, s$0, tl$1];
       }
      }
     }
     var
      n1 = n >> 1,
      n2 = n - n1 | 0,
      match$0 = rev_sort(n1, l),
      l2$0 = match$0[2],
      s1 = match$0[1],
      match$1 = rev_sort(n2, l2$0),
      tl$0 = match$1[2],
      s2 = match$1[1],
      l1 = s1,
      l2 = s2,
      accu = 0;
     for(;;){
      if(l1){
       if(l2){
        var t2 = l2[2], h2 = l2[1], t1 = l1[2], h1 = l1[1];
        if(0 < caml_call2(cmp, h1, h2)){
         var accu$0 = [0, h1, accu];
         l1 = t1;
         accu = accu$0;
         continue;
        }
        var accu$1 = [0, h2, accu];
        l2 = t2;
        accu = accu$1;
        continue;
       }
       var _v_ = rev_append(l1, accu);
      }
      else
       var _v_ = rev_append(l2, accu);
      return [0, _v_, tl$0];
     }
    }
    function rev_sort(n, l){
     if(2 === n){
      if(l){
       var match = l[2];
       if(match){
        var
         tl = match[2],
         x2 = match[1],
         x1 = l[1],
         s =
           0 < caml_call2(cmp, x1, x2)
            ? [0, x1, [0, x2, 0]]
            : [0, x2, [0, x1, 0]];
        return [0, s, tl];
       }
      }
     }
     else if(3 === n && l){
      var _u_ = l[2];
      if(_u_){
       var match$2 = _u_[2];
       if(match$2){
        var
         tl$1 = match$2[2],
         x3 = match$2[1],
         x2$0 = _u_[1],
         x1$0 = l[1],
         s$0 =
           0 < caml_call2(cmp, x1$0, x2$0)
            ? 0
              < caml_call2(cmp, x2$0, x3)
              ? [0, x1$0, [0, x2$0, [0, x3, 0]]]
              : 0
                < caml_call2(cmp, x1$0, x3)
                ? [0, x1$0, [0, x3, [0, x2$0, 0]]]
                : [0, x3, [0, x1$0, [0, x2$0, 0]]]
            : 0
              < caml_call2(cmp, x1$0, x3)
              ? [0, x2$0, [0, x1$0, [0, x3, 0]]]
              : 0
                < caml_call2(cmp, x2$0, x3)
                ? [0, x2$0, [0, x3, [0, x1$0, 0]]]
                : [0, x3, [0, x2$0, [0, x1$0, 0]]];
        return [0, s$0, tl$1];
       }
      }
     }
     var
      n1 = n >> 1,
      n2 = n - n1 | 0,
      match$0 = sort(n1, l),
      l2$0 = match$0[2],
      s1 = match$0[1],
      match$1 = sort(n2, l2$0),
      tl$0 = match$1[2],
      s2 = match$1[1],
      l1 = s1,
      l2 = s2,
      accu = 0;
     for(;;){
      if(l1){
       if(l2){
        var t2 = l2[2], h2 = l2[1], t1 = l1[2], h1 = l1[1];
        if(0 < caml_call2(cmp, h1, h2)){
         var accu$0 = [0, h2, accu];
         l2 = t2;
         accu = accu$0;
         continue;
        }
        var accu$1 = [0, h1, accu];
        l1 = t1;
        accu = accu$1;
        continue;
       }
       var _t_ = rev_append(l1, accu);
      }
      else
       var _t_ = rev_append(l2, accu);
      return [0, _t_, tl$0];
     }
    }
    var len = length(l);
    return 2 <= len ? sort(len, l)[1] : l;
   }
   function sort_uniq(cmp, l){
    function sort(n, l){
     if(2 === n){
      if(l){
       var match = l[2];
       if(match){
        var
         tl = match[2],
         x2 = match[1],
         x1 = l[1],
         c$0 = caml_call2(cmp, x1, x2),
         s =
           0 === c$0
            ? [0, x1, 0]
            : 0 <= c$0 ? [0, x2, [0, x1, 0]] : [0, x1, [0, x2, 0]];
        return [0, s, tl];
       }
      }
     }
     else if(3 === n && l){
      var _n_ = l[2];
      if(_n_){
       var match$2 = _n_[2];
       if(match$2){
        var
         tl$1 = match$2[2],
         x3 = match$2[1],
         x2$0 = _n_[1],
         x1$0 = l[1],
         c$1 = caml_call2(cmp, x1$0, x2$0);
        if(0 === c$1)
         var
          c$2 = caml_call2(cmp, x2$0, x3),
          _o_ =
            0 === c$2
             ? [0, x2$0, 0]
             : 0 <= c$2 ? [0, x3, [0, x2$0, 0]] : [0, x2$0, [0, x3, 0]],
          s$0 = _o_;
        else if(0 <= c$1){
         var c$3 = caml_call2(cmp, x1$0, x3);
         if(0 === c$3)
          var _p_ = [0, x2$0, [0, x1$0, 0]];
         else if(0 <= c$3)
          var
           c$4 = caml_call2(cmp, x2$0, x3),
           _q_ =
             0 === c$4
              ? [0, x2$0, [0, x1$0, 0]]
              : 0
                <= c$4
                ? [0, x3, [0, x2$0, [0, x1$0, 0]]]
                : [0, x2$0, [0, x3, [0, x1$0, 0]]],
           _p_ = _q_;
         else
          var _p_ = [0, x2$0, [0, x1$0, [0, x3, 0]]];
         var s$0 = _p_;
        }
        else{
         var c$5 = caml_call2(cmp, x2$0, x3);
         if(0 === c$5)
          var _r_ = [0, x1$0, [0, x2$0, 0]];
         else if(0 <= c$5)
          var
           c$6 = caml_call2(cmp, x1$0, x3),
           _s_ =
             0 === c$6
              ? [0, x1$0, [0, x2$0, 0]]
              : 0
                <= c$6
                ? [0, x3, [0, x1$0, [0, x2$0, 0]]]
                : [0, x1$0, [0, x3, [0, x2$0, 0]]],
           _r_ = _s_;
         else
          var _r_ = [0, x1$0, [0, x2$0, [0, x3, 0]]];
         var s$0 = _r_;
        }
        return [0, s$0, tl$1];
       }
      }
     }
     var
      n1 = n >> 1,
      n2 = n - n1 | 0,
      match$0 = rev_sort(n1, l),
      l2$0 = match$0[2],
      s1 = match$0[1],
      match$1 = rev_sort(n2, l2$0),
      tl$0 = match$1[2],
      s2 = match$1[1],
      l1 = s1,
      l2 = s2,
      accu = 0;
     for(;;){
      if(l1){
       if(l2){
        var
         t2 = l2[2],
         h2 = l2[1],
         t1 = l1[2],
         h1 = l1[1],
         c = caml_call2(cmp, h1, h2);
        if(0 === c){
         var accu$0 = [0, h1, accu];
         l1 = t1;
         l2 = t2;
         accu = accu$0;
         continue;
        }
        if(0 < c){
         var accu$1 = [0, h1, accu];
         l1 = t1;
         accu = accu$1;
         continue;
        }
        var accu$2 = [0, h2, accu];
        l2 = t2;
        accu = accu$2;
        continue;
       }
       var _m_ = rev_append(l1, accu);
      }
      else
       var _m_ = rev_append(l2, accu);
      return [0, _m_, tl$0];
     }
    }
    function rev_sort(n, l){
     if(2 === n){
      if(l){
       var match = l[2];
       if(match){
        var
         tl = match[2],
         x2 = match[1],
         x1 = l[1],
         c$0 = caml_call2(cmp, x1, x2),
         s =
           0 === c$0
            ? [0, x1, 0]
            : 0 < c$0 ? [0, x1, [0, x2, 0]] : [0, x2, [0, x1, 0]];
        return [0, s, tl];
       }
      }
     }
     else if(3 === n && l){
      var _g_ = l[2];
      if(_g_){
       var match$2 = _g_[2];
       if(match$2){
        var
         tl$1 = match$2[2],
         x3 = match$2[1],
         x2$0 = _g_[1],
         x1$0 = l[1],
         c$1 = caml_call2(cmp, x1$0, x2$0);
        if(0 === c$1)
         var
          c$2 = caml_call2(cmp, x2$0, x3),
          _h_ =
            0 === c$2
             ? [0, x2$0, 0]
             : 0 < c$2 ? [0, x2$0, [0, x3, 0]] : [0, x3, [0, x2$0, 0]],
          s$0 = _h_;
        else if(0 < c$1){
         var c$3 = caml_call2(cmp, x2$0, x3);
         if(0 === c$3)
          var _i_ = [0, x1$0, [0, x2$0, 0]];
         else if(0 < c$3)
          var _i_ = [0, x1$0, [0, x2$0, [0, x3, 0]]];
         else
          var
           c$4 = caml_call2(cmp, x1$0, x3),
           _j_ =
             0 === c$4
              ? [0, x1$0, [0, x2$0, 0]]
              : 0
                < c$4
                ? [0, x1$0, [0, x3, [0, x2$0, 0]]]
                : [0, x3, [0, x1$0, [0, x2$0, 0]]],
           _i_ = _j_;
         var s$0 = _i_;
        }
        else{
         var c$5 = caml_call2(cmp, x1$0, x3);
         if(0 === c$5)
          var _k_ = [0, x2$0, [0, x1$0, 0]];
         else if(0 < c$5)
          var _k_ = [0, x2$0, [0, x1$0, [0, x3, 0]]];
         else
          var
           c$6 = caml_call2(cmp, x2$0, x3),
           _l_ =
             0 === c$6
              ? [0, x2$0, [0, x1$0, 0]]
              : 0
                < c$6
                ? [0, x2$0, [0, x3, [0, x1$0, 0]]]
                : [0, x3, [0, x2$0, [0, x1$0, 0]]],
           _k_ = _l_;
         var s$0 = _k_;
        }
        return [0, s$0, tl$1];
       }
      }
     }
     var
      n1 = n >> 1,
      n2 = n - n1 | 0,
      match$0 = sort(n1, l),
      l2$0 = match$0[2],
      s1 = match$0[1],
      match$1 = sort(n2, l2$0),
      tl$0 = match$1[2],
      s2 = match$1[1],
      l1 = s1,
      l2 = s2,
      accu = 0;
     for(;;){
      if(l1){
       if(l2){
        var
         t2 = l2[2],
         h2 = l2[1],
         t1 = l1[2],
         h1 = l1[1],
         c = caml_call2(cmp, h1, h2);
        if(0 === c){
         var accu$0 = [0, h1, accu];
         l1 = t1;
         l2 = t2;
         accu = accu$0;
         continue;
        }
        if(0 <= c){
         var accu$1 = [0, h2, accu];
         l2 = t2;
         accu = accu$1;
         continue;
        }
        var accu$2 = [0, h1, accu];
        l1 = t1;
        accu = accu$2;
        continue;
       }
       var _f_ = rev_append(l1, accu);
      }
      else
       var _f_ = rev_append(l2, accu);
      return [0, _f_, tl$0];
     }
    }
    var len = length(l);
    return 2 <= len ? sort(len, l)[1] : l;
   }
   function compare_lengths(l1, l2){
    var l1$0 = l1, l2$0 = l2;
    for(;;){
     if(! l1$0) return l2$0 ? -1 : 0;
     if(! l2$0) return 1;
     var l2$1 = l2$0[2], l1$1 = l1$0[2];
     l1$0 = l1$1;
     l2$0 = l2$1;
    }
   }
   function compare_length_with(l, n){
    var l$0 = l, n$0 = n;
    for(;;){
     if(! l$0) return 0 === n$0 ? 0 : 0 < n$0 ? -1 : 1;
     var l$1 = l$0[2];
     if(0 >= n$0) return 1;
     var n$1 = n$0 - 1 | 0;
     l$0 = l$1;
     n$0 = n$1;
    }
   }
   function equal(eq, l1, l2){
    var l1$0 = l1, l2$0 = l2;
    for(;;){
     if(l1$0){
      if(l2$0){
       var
        l2$1 = l2$0[2],
        a2 = l2$0[1],
        l1$1 = l1$0[2],
        a1 = l1$0[1],
        _e_ = caml_call2(eq, a1, a2);
       if(! _e_) return _e_;
       l1$0 = l1$1;
       l2$0 = l2$1;
       continue;
      }
     }
     else if(! l2$0) return 1;
     return 0;
    }
   }
   function compare(cmp, l1, l2){
    var l1$0 = l1, l2$0 = l2;
    for(;;){
     if(! l1$0) return l2$0 ? -1 : 0;
     var l1$1 = l1$0[2], a1 = l1$0[1];
     if(! l2$0) return 1;
     var l2$1 = l2$0[2], a2 = l2$0[1], c = caml_call2(cmp, a1, a2);
     if(0 !== c) return c;
     l1$0 = l1$1;
     l2$0 = l2$1;
    }
   }
   function to_seq(l){
    function aux(l, param){
     if(! l) return 0;
     var tail = l[2], x = l[1];
     return [0, x, function(_d_){return aux(tail, _d_);}];
    }
    return function(_c_){return aux(l, _c_);};
   }
   function of_seq(seq){
    function direct(depth, seq){
     if(0 === depth)
      return rev
              (caml_call3
                (Stdlib_Seq[5], function(acc, x){return [0, x, acc];}, 0, seq));
     var match = caml_call1(seq, 0);
     if(! match) return 0;
     var next = match[2], x = match[1];
     return [0, x, direct(depth - 1 | 0, next)];
    }
    return direct(500, seq);
   }
   var
    Stdlib_List =
      [0,
       length,
       compare_lengths,
       compare_length_with,
       cons,
       hd,
       tl,
       nth,
       nth_opt,
       rev,
       init,
       append,
       rev_append,
       flatten,
       flatten,
       equal,
       compare,
       iter,
       iteri,
       map,
       mapi,
       rev_map,
       filter_map,
       concat_map,
       fold_left_map,
       fold_left,
       fold_right,
       iter2,
       map2,
       rev_map2,
       fold_left2,
       fold_right2,
       for_all,
       exists,
       for_all2,
       exists2,
       mem,
       memq,
       find,
       find_opt,
       find_map,
       find_all,
       find_all,
       filteri,
       partition,
       partition_map,
       assoc,
       assoc_opt,
       assq,
       assq_opt,
       mem_assoc,
       mem_assq,
       remove_assoc,
       remove_assq,
       split,
       combine,
       stable_sort,
       stable_sort,
       stable_sort,
       sort_uniq,
       merge,
       to_seq,
       of_seq];
   runtime.caml_register_global(18, Stdlib_List, "Stdlib__List");
   return;
  }
  (globalThis));

//# 3709 "../.js/default/stdlib/stdlib.cma.js"
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function abs(x){return 0 <= x ? x : - x | 0;}
   function lognot(x){return x ^ -1;}
   function equal(_b_, _a_){return _b_ === _a_ ? 1 : 0;}
   var compare = runtime.caml_int_compare;
   function min(x, y){return x <= y ? x : y;}
   function max(x, y){return y <= x ? x : y;}
   function to_string(x){return "" + x;}
   var
    Stdlib_Int =
      [0,
       0,
       1,
       -1,
       abs,
       2147483647,
       -2147483648,
       lognot,
       equal,
       compare,
       min,
       max,
       to_string];
   runtime.caml_register_global(1, Stdlib_Int, "Stdlib__Int");
   return;
  }
  (globalThis));

//# 3741 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_bytes_ml = "bytes.ml",
    cst_index_out_of_bounds$3 = "index out of bounds",
    caml_blit_bytes = runtime.caml_blit_bytes,
    caml_bswap16 = runtime.caml_bswap16,
    caml_bytes_get = runtime.caml_bytes_get,
    caml_bytes_get16 = runtime.caml_bytes_get16,
    caml_bytes_get32 = runtime.caml_bytes_get32,
    caml_bytes_get64 = runtime.caml_bytes_get64,
    caml_bytes_of_string = runtime.caml_bytes_of_string,
    caml_bytes_set = runtime.caml_bytes_set,
    caml_bytes_set16 = runtime.caml_bytes_set16,
    caml_bytes_set32 = runtime.caml_bytes_set32,
    caml_bytes_set64 = runtime.caml_bytes_set64,
    caml_bytes_unsafe_get = runtime.caml_bytes_unsafe_get,
    caml_bytes_unsafe_set = runtime.caml_bytes_unsafe_set,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_fill_bytes = runtime.caml_fill_bytes,
    caml_int32_bswap = runtime.caml_int32_bswap,
    caml_int64_bswap = runtime.caml_int64_bswap,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_bytes_length = runtime.caml_ml_bytes_length,
    caml_string_of_bytes = runtime.caml_string_of_bytes,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Stdlib_Uchar = global_data.Stdlib__Uchar,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Sys = global_data.Stdlib__Sys,
    Stdlib_Int = global_data.Stdlib__Int,
    Stdlib_Seq = global_data.Stdlib__Seq,
    Stdlib_Char = global_data.Stdlib__Char;
   function make(n, c){
    var s = caml_create_bytes(n);
    caml_fill_bytes(s, 0, n, c);
    return s;
   }
   function init(n, f){
    var s = caml_create_bytes(n), _ap_ = n - 1 | 0, _ao_ = 0;
    if(_ap_ >= 0){
     var i = _ao_;
     for(;;){
      caml_bytes_unsafe_set(s, i, caml_call1(f, i));
      var _aq_ = i + 1 | 0;
      if(_ap_ === i) break;
      i = _aq_;
     }
    }
    return s;
   }
   var
    empty = caml_create_bytes(0),
    cst_String_sub_Bytes_sub = "String.sub / Bytes.sub",
    cst_Bytes_extend = "Bytes.extend",
    cst_String_fill_Bytes_fill = "String.fill / Bytes.fill",
    cst_Bytes_blit = "Bytes.blit",
    cst_String_blit_Bytes_blit_str = "String.blit / Bytes.blit_string",
    cst_Bytes_concat = "Bytes.concat",
    cst_String_index_from_Bytes_in = "String.index_from / Bytes.index_from",
    cst_String_index_from_opt_Byte =
      "String.index_from_opt / Bytes.index_from_opt",
    cst_String_rindex_from_Bytes_r = "String.rindex_from / Bytes.rindex_from",
    cst_String_rindex_from_opt_Byt =
      "String.rindex_from_opt / Bytes.rindex_from_opt",
    cst_String_contains_from_Bytes =
      "String.contains_from / Bytes.contains_from",
    cst_String_rcontains_from_Byte =
      "String.rcontains_from / Bytes.rcontains_from";
   function copy(s){
    var len = caml_ml_bytes_length(s), r = caml_create_bytes(len);
    caml_blit_bytes(s, 0, r, 0, len);
    return r;
   }
   function to_string(b){return caml_string_of_bytes(copy(b));}
   function of_string(s){return copy(caml_bytes_of_string(s));}
   function sub(s, ofs, len){
    if(0 <= ofs && 0 <= len && (caml_ml_bytes_length(s) - len | 0) >= ofs){
     var r = caml_create_bytes(len);
     caml_blit_bytes(s, ofs, r, 0, len);
     return r;
    }
    return caml_call1(Stdlib[1], cst_String_sub_Bytes_sub);
   }
   function sub_string(b, ofs, len){
    return caml_string_of_bytes(sub(b, ofs, len));
   }
   function symbol(a, b){
    var c = a + b | 0, _an_ = b < 0 ? 1 : 0, match = c < 0 ? 1 : 0;
    a:
    {
     if(a < 0){if(_an_ && ! match) break a;} else if(! _an_ && match) break a;
     return c;
    }
    return caml_call1(Stdlib[1], cst_Bytes_extend);
   }
   function extend(s, left, right){
    var
     len = symbol(symbol(caml_ml_bytes_length(s), left), right),
     r = caml_create_bytes(len);
    if(0 <= left)
     var dstoff = left, srcoff = 0;
    else
     var dstoff = 0, srcoff = - left | 0;
    var
     cpylen =
       caml_call2
        (Stdlib_Int[10],
         caml_ml_bytes_length(s) - srcoff | 0,
         len - dstoff | 0);
    if(0 < cpylen) caml_blit_bytes(s, srcoff, r, dstoff, cpylen);
    return r;
   }
   function fill(s, ofs, len, c){
    if(0 <= ofs && 0 <= len && (caml_ml_bytes_length(s) - len | 0) >= ofs)
     return caml_fill_bytes(s, ofs, len, c);
    return caml_call1(Stdlib[1], cst_String_fill_Bytes_fill);
   }
   function blit(s1, ofs1, s2, ofs2, len){
    if
     (0 <= len
      &&
       0 <= ofs1
       &&
        (caml_ml_bytes_length(s1) - len | 0) >= ofs1
        && 0 <= ofs2 && (caml_ml_bytes_length(s2) - len | 0) >= ofs2)
     return caml_blit_bytes(s1, ofs1, s2, ofs2, len);
    return caml_call1(Stdlib[1], cst_Bytes_blit);
   }
   function blit_string(s1, ofs1, s2, ofs2, len){
    if
     (0 <= len
      &&
       0 <= ofs1
       &&
        (runtime.caml_ml_string_length(s1) - len | 0) >= ofs1
        && 0 <= ofs2 && (caml_ml_bytes_length(s2) - len | 0) >= ofs2)
     return runtime.caml_blit_string(s1, ofs1, s2, ofs2, len);
    return caml_call1(Stdlib[1], cst_String_blit_Bytes_blit_str);
   }
   function iter(f, a){
    var _al_ = caml_ml_bytes_length(a) - 1 | 0, _ak_ = 0;
    if(_al_ >= 0){
     var i = _ak_;
     for(;;){
      caml_call1(f, caml_bytes_unsafe_get(a, i));
      var _am_ = i + 1 | 0;
      if(_al_ === i) break;
      i = _am_;
     }
    }
    return 0;
   }
   function iteri(f, a){
    var _ai_ = caml_ml_bytes_length(a) - 1 | 0, _ah_ = 0;
    if(_ai_ >= 0){
     var i = _ah_;
     for(;;){
      caml_call2(f, i, caml_bytes_unsafe_get(a, i));
      var _aj_ = i + 1 | 0;
      if(_ai_ === i) break;
      i = _aj_;
     }
    }
    return 0;
   }
   function concat(sep, l){
    if(! l) return empty;
    var seplen = caml_ml_bytes_length(sep);
    a:
    {
     b:
     {
      var acc = 0, param = l, pos$1 = 0;
      for(;;){
       if(! param) break;
       var hd = param[1];
       if(! param[2]) break b;
       var
        tl = param[2],
        x = (caml_ml_bytes_length(hd) + seplen | 0) + acc | 0,
        acc$0 = acc <= x ? x : caml_call1(Stdlib[1], cst_Bytes_concat);
       acc = acc$0;
       param = tl;
      }
      var _ag_ = acc;
      break a;
     }
     var _ag_ = caml_ml_bytes_length(hd) + acc | 0;
    }
    var dst = caml_create_bytes(_ag_), pos = pos$1, param$0 = l;
    for(;;){
     if(! param$0) return dst;
     var hd$0 = param$0[1];
     if(! param$0[2]){
      caml_blit_bytes(hd$0, 0, dst, pos, caml_ml_bytes_length(hd$0));
      return dst;
     }
     var tl$0 = param$0[2];
     caml_blit_bytes(hd$0, 0, dst, pos, caml_ml_bytes_length(hd$0));
     caml_blit_bytes
      (sep, 0, dst, pos + caml_ml_bytes_length(hd$0) | 0, seplen);
     var pos$0 = (pos + caml_ml_bytes_length(hd$0) | 0) + seplen | 0;
     pos = pos$0;
     param$0 = tl$0;
    }
   }
   function cat(s1, s2){
    var
     l1 = caml_ml_bytes_length(s1),
     l2 = caml_ml_bytes_length(s2),
     r = caml_create_bytes(l1 + l2 | 0);
    caml_blit_bytes(s1, 0, r, 0, l1);
    caml_blit_bytes(s2, 0, r, l1, l2);
    return r;
   }
   function is_space(param){
    var _af_ = param - 9 | 0;
    a:
    {
     if(4 < _af_ >>> 0){if(23 !== _af_) break a;} else if(2 === _af_) break a;
     return 1;
    }
    return 0;
   }
   function trim(s){
    var len = caml_ml_bytes_length(s), i = [0, 0];
    for(;;){
     if(i[1] >= len) break;
     if(! is_space(caml_bytes_unsafe_get(s, i[1]))) break;
     i[1]++;
    }
    var j = [0, len - 1 | 0];
    for(;;){
     if(i[1] <= j[1] && is_space(caml_bytes_unsafe_get(s, j[1]))){j[1]--; continue;}
     return i[1] <= j[1] ? sub(s, i[1], (j[1] - i[1] | 0) + 1 | 0) : empty;
    }
   }
   function escaped(s){
    var n = [0, 0], ___ = caml_ml_bytes_length(s) - 1 | 0, _Z_ = 0;
    if(___ >= 0){
     var i$0 = _Z_;
     for(;;){
      var match = caml_bytes_unsafe_get(s, i$0);
      a:
      {
       b:
       {
        c:
        {
         if(32 <= match){
          var _ac_ = match - 34 | 0;
          if(58 < _ac_ >>> 0){
           if(93 <= _ac_) break c;
          }
          else if(56 < _ac_ - 1 >>> 0) break b;
          var _ad_ = 1;
          break a;
         }
         if(11 <= match){
          if(13 === match) break b;
         }
         else if(8 <= match) break b;
        }
        var _ad_ = 4;
        break a;
       }
       var _ad_ = 2;
      }
      n[1] = n[1] + _ad_ | 0;
      var _ae_ = i$0 + 1 | 0;
      if(___ === i$0) break;
      i$0 = _ae_;
     }
    }
    if(n[1] === caml_ml_bytes_length(s)) return copy(s);
    var s$0 = caml_create_bytes(n[1]);
    n[1] = 0;
    var _aa_ = caml_ml_bytes_length(s) - 1 | 0, _$_ = 0;
    if(_aa_ >= 0){
     var i = _$_;
     for(;;){
      var c = caml_bytes_unsafe_get(s, i);
      a:
      {
       b:
       {
        c:
        {
         if(35 <= c){
          if(92 !== c){if(127 <= c) break c; break b;}
         }
         else{
          if(32 > c){
           if(14 <= c) break c;
           switch(c){
             case 8:
              caml_bytes_unsafe_set(s$0, n[1], 92);
              n[1]++;
              caml_bytes_unsafe_set(s$0, n[1], 98);
              break a;
             case 9:
              caml_bytes_unsafe_set(s$0, n[1], 92);
              n[1]++;
              caml_bytes_unsafe_set(s$0, n[1], 116);
              break a;
             case 10:
              caml_bytes_unsafe_set(s$0, n[1], 92);
              n[1]++;
              caml_bytes_unsafe_set(s$0, n[1], 110);
              break a;
             case 13:
              caml_bytes_unsafe_set(s$0, n[1], 92);
              n[1]++;
              caml_bytes_unsafe_set(s$0, n[1], 114);
              break a;
             default: break c;
           }
          }
          if(34 > c) break b;
         }
         caml_bytes_unsafe_set(s$0, n[1], 92);
         n[1]++;
         caml_bytes_unsafe_set(s$0, n[1], c);
         break a;
        }
        caml_bytes_unsafe_set(s$0, n[1], 92);
        n[1]++;
        caml_bytes_unsafe_set(s$0, n[1], 48 + (c / 100 | 0) | 0);
        n[1]++;
        caml_bytes_unsafe_set(s$0, n[1], 48 + ((c / 10 | 0) % 10 | 0) | 0);
        n[1]++;
        caml_bytes_unsafe_set(s$0, n[1], 48 + (c % 10 | 0) | 0);
        break a;
       }
       caml_bytes_unsafe_set(s$0, n[1], c);
      }
      n[1]++;
      var _ab_ = i + 1 | 0;
      if(_aa_ === i) break;
      i = _ab_;
     }
    }
    return s$0;
   }
   function map(f, s){
    var l = caml_ml_bytes_length(s);
    if(0 === l) return s;
    var r = caml_create_bytes(l), _X_ = l - 1 | 0, _W_ = 0;
    if(_X_ >= 0){
     var i = _W_;
     for(;;){
      caml_bytes_unsafe_set(r, i, caml_call1(f, caml_bytes_unsafe_get(s, i)));
      var _Y_ = i + 1 | 0;
      if(_X_ === i) break;
      i = _Y_;
     }
    }
    return r;
   }
   function mapi(f, s){
    var l = caml_ml_bytes_length(s);
    if(0 === l) return s;
    var r = caml_create_bytes(l), _U_ = l - 1 | 0, _T_ = 0;
    if(_U_ >= 0){
     var i = _T_;
     for(;;){
      caml_bytes_unsafe_set
       (r, i, caml_call2(f, i, caml_bytes_unsafe_get(s, i)));
      var _V_ = i + 1 | 0;
      if(_U_ === i) break;
      i = _V_;
     }
    }
    return r;
   }
   function fold_left(f, x, a){
    var r = [0, x], _R_ = caml_ml_bytes_length(a) - 1 | 0, _Q_ = 0;
    if(_R_ >= 0){
     var i = _Q_;
     for(;;){
      r[1] = caml_call2(f, r[1], caml_bytes_unsafe_get(a, i));
      var _S_ = i + 1 | 0;
      if(_R_ === i) break;
      i = _S_;
     }
    }
    return r[1];
   }
   function fold_right(f, a, x){
    var r = [0, x], _O_ = caml_ml_bytes_length(a) - 1 | 0;
    if(_O_ >= 0){
     var i = _O_;
     for(;;){
      r[1] = caml_call2(f, caml_bytes_unsafe_get(a, i), r[1]);
      var _P_ = i - 1 | 0;
      if(0 === i) break;
      i = _P_;
     }
    }
    return r[1];
   }
   function exists(p, s){
    var n = caml_ml_bytes_length(s), i = 0;
    for(;;){
     if(i === n) return 0;
     if(caml_call1(p, caml_bytes_unsafe_get(s, i))) return 1;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function for_all(p, s){
    var n = caml_ml_bytes_length(s), i = 0;
    for(;;){
     if(i === n) return 1;
     if(! caml_call1(p, caml_bytes_unsafe_get(s, i))) return 0;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function uppercase_ascii(s){return map(Stdlib_Char[6], s);}
   function lowercase_ascii(s){return map(Stdlib_Char[5], s);}
   function apply1(f, s){
    if(0 === caml_ml_bytes_length(s)) return s;
    var r = copy(s);
    caml_bytes_unsafe_set(r, 0, caml_call1(f, caml_bytes_unsafe_get(s, 0)));
    return r;
   }
   function capitalize_ascii(s){return apply1(Stdlib_Char[6], s);}
   function uncapitalize_ascii(s){return apply1(Stdlib_Char[5], s);}
   function starts_with(prefix, s){
    var
     len_s = caml_ml_bytes_length(s),
     len_pre = caml_ml_bytes_length(prefix),
     _N_ = len_pre <= len_s ? 1 : 0;
    if(! _N_) return _N_;
    var i = 0;
    for(;;){
     if(i === len_pre) return 1;
     if(caml_bytes_unsafe_get(s, i) !== caml_bytes_unsafe_get(prefix, i))
      return 0;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function ends_with(suffix, s){
    var
     len_s = caml_ml_bytes_length(s),
     len_suf = caml_ml_bytes_length(suffix),
     diff = len_s - len_suf | 0,
     _M_ = 0 <= diff ? 1 : 0;
    if(! _M_) return _M_;
    var i = 0;
    for(;;){
     if(i === len_suf) return 1;
     if
      (caml_bytes_unsafe_get(s, diff + i | 0)
       !== caml_bytes_unsafe_get(suffix, i))
      return 0;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function index_rec(s, lim, i, c){
    var i$0 = i;
    for(;;){
     if(lim <= i$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     if(caml_bytes_unsafe_get(s, i$0) === c) return i$0;
     var i$1 = i$0 + 1 | 0;
     i$0 = i$1;
    }
   }
   function index(s, c){return index_rec(s, caml_ml_bytes_length(s), 0, c);}
   function index_rec_opt(s, lim, i, c){
    var i$0 = i;
    for(;;){
     if(lim <= i$0) return 0;
     if(caml_bytes_unsafe_get(s, i$0) === c) return [0, i$0];
     var i$1 = i$0 + 1 | 0;
     i$0 = i$1;
    }
   }
   function index_opt(s, c){
    return index_rec_opt(s, caml_ml_bytes_length(s), 0, c);
   }
   function index_from(s, i, c){
    var l = caml_ml_bytes_length(s);
    if(0 <= i && l >= i) return index_rec(s, l, i, c);
    return caml_call1(Stdlib[1], cst_String_index_from_Bytes_in);
   }
   function index_from_opt(s, i, c){
    var l = caml_ml_bytes_length(s);
    if(0 <= i && l >= i) return index_rec_opt(s, l, i, c);
    return caml_call1(Stdlib[1], cst_String_index_from_opt_Byte);
   }
   function rindex_rec(s, i, c){
    var i$0 = i;
    for(;;){
     if(0 > i$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     if(caml_bytes_unsafe_get(s, i$0) === c) return i$0;
     var i$1 = i$0 - 1 | 0;
     i$0 = i$1;
    }
   }
   function rindex(s, c){
    return rindex_rec(s, caml_ml_bytes_length(s) - 1 | 0, c);
   }
   function rindex_from(s, i, c){
    if(-1 <= i && caml_ml_bytes_length(s) > i) return rindex_rec(s, i, c);
    return caml_call1(Stdlib[1], cst_String_rindex_from_Bytes_r);
   }
   function rindex_rec_opt(s, i, c){
    var i$0 = i;
    for(;;){
     if(0 > i$0) return 0;
     if(caml_bytes_unsafe_get(s, i$0) === c) return [0, i$0];
     var i$1 = i$0 - 1 | 0;
     i$0 = i$1;
    }
   }
   function rindex_opt(s, c){
    return rindex_rec_opt(s, caml_ml_bytes_length(s) - 1 | 0, c);
   }
   function rindex_from_opt(s, i, c){
    if(-1 <= i && caml_ml_bytes_length(s) > i) return rindex_rec_opt(s, i, c);
    return caml_call1(Stdlib[1], cst_String_rindex_from_opt_Byt);
   }
   function contains_from(s, i, c){
    var l = caml_ml_bytes_length(s);
    if(0 <= i && l >= i)
     try{index_rec(s, l, i, c); var _K_ = 1; return _K_;}
     catch(_L_){
      var _J_ = caml_wrap_exception(_L_);
      if(_J_ === Stdlib[8]) return 0;
      throw caml_maybe_attach_backtrace(_J_, 0);
     }
    return caml_call1(Stdlib[1], cst_String_contains_from_Bytes);
   }
   function contains(s, c){return contains_from(s, 0, c);}
   function rcontains_from(s, i, c){
    if(0 <= i && caml_ml_bytes_length(s) > i)
     try{rindex_rec(s, i, c); var _H_ = 1; return _H_;}
     catch(_I_){
      var _G_ = caml_wrap_exception(_I_);
      if(_G_ === Stdlib[8]) return 0;
      throw caml_maybe_attach_backtrace(_G_, 0);
     }
    return caml_call1(Stdlib[1], cst_String_rcontains_from_Byte);
   }
   var
    compare = runtime.caml_bytes_compare,
    cst_Bytes_of_seq_cannot_grow_b = "Bytes.of_seq: cannot grow bytes";
   function split_on_char(sep, s){
    var
     r = [0, 0],
     j = [0, caml_ml_bytes_length(s)],
     _C_ = caml_ml_bytes_length(s) - 1 | 0;
    if(_C_ >= 0){
     var i = _C_;
     for(;;){
      if(caml_bytes_unsafe_get(s, i) === sep){
       var _E_ = r[1];
       r[1] = [0, sub(s, i + 1 | 0, (j[1] - i | 0) - 1 | 0), _E_];
       j[1] = i;
      }
      var _F_ = i - 1 | 0;
      if(0 === i) break;
      i = _F_;
     }
    }
    var _D_ = r[1];
    return [0, sub(s, 0, j[1]), _D_];
   }
   function uppercase(s){return map(Stdlib_Char[4], s);}
   function lowercase(s){return map(Stdlib_Char[3], s);}
   function capitalize(s){return apply1(Stdlib_Char[4], s);}
   function uncapitalize(s){return apply1(Stdlib_Char[3], s);}
   function to_seq(s){
    function aux(i, param){
     if(i === caml_ml_bytes_length(s)) return 0;
     var x = caml_bytes_get(s, i), _A_ = i + 1 | 0;
     return [0, x, function(_B_){return aux(_A_, _B_);}];
    }
    var _y_ = 0;
    return function(_z_){return aux(_y_, _z_);};
   }
   function to_seqi(s){
    function aux(i, param){
     if(i === caml_ml_bytes_length(s)) return 0;
     var x = caml_bytes_get(s, i), _w_ = i + 1 | 0;
     return [0, [0, i, x], function(_x_){return aux(_w_, _x_);}];
    }
    var _u_ = 0;
    return function(_v_){return aux(_u_, _v_);};
   }
   function of_seq(i){
    var n = [0, 0], buf = [0, make(256, 0)];
    caml_call2
     (Stdlib_Seq[4],
      function(c){
       if(n[1] === caml_ml_bytes_length(buf[1])){
        var
         new_len =
           caml_call2
            (Stdlib_Int[10],
             2 * caml_ml_bytes_length(buf[1]) | 0,
             Stdlib_Sys[12]);
        if(caml_ml_bytes_length(buf[1]) === new_len)
         caml_call1(Stdlib[2], cst_Bytes_of_seq_cannot_grow_b);
        var new_buf = make(new_len, 0);
        blit(buf[1], 0, new_buf, 0, n[1]);
        buf[1] = new_buf;
       }
       caml_bytes_set(buf[1], n[1], c);
       n[1]++;
       return 0;
      },
      i);
    return sub(buf[1], 0, n[1]);
   }
   function unsafe_get_uint16_le(b, i){
    return Stdlib_Sys[11]
            ? caml_bswap16(caml_bytes_get16(b, i))
            : caml_bytes_get16(b, i);
   }
   function unsafe_get_uint16_be(b, i){
    return Stdlib_Sys[11]
            ? caml_bytes_get16(b, i)
            : caml_bswap16(caml_bytes_get16(b, i));
   }
   function get_int8(b, i){
    var _s_ = Stdlib_Sys[10] - 8 | 0, _t_ = Stdlib_Sys[10] - 8 | 0;
    return caml_bytes_get(b, i) << _t_ >> _s_;
   }
   function get_uint16_le(b, i){
    return Stdlib_Sys[11]
            ? caml_bswap16(caml_bytes_get16(b, i))
            : caml_bytes_get16(b, i);
   }
   function get_uint16_be(b, i){
    return Stdlib_Sys[11]
            ? caml_bytes_get16(b, i)
            : caml_bswap16(caml_bytes_get16(b, i));
   }
   function get_int16_ne(b, i){
    var _q_ = Stdlib_Sys[10] - 16 | 0, _r_ = Stdlib_Sys[10] - 16 | 0;
    return caml_bytes_get16(b, i) << _r_ >> _q_;
   }
   function get_int16_le(b, i){
    var _o_ = Stdlib_Sys[10] - 16 | 0, _p_ = Stdlib_Sys[10] - 16 | 0;
    return get_uint16_le(b, i) << _p_ >> _o_;
   }
   function get_int16_be(b, i){
    var _m_ = Stdlib_Sys[10] - 16 | 0, _n_ = Stdlib_Sys[10] - 16 | 0;
    return get_uint16_be(b, i) << _n_ >> _m_;
   }
   function get_int32_le(b, i){
    return Stdlib_Sys[11]
            ? caml_int32_bswap(caml_bytes_get32(b, i))
            : caml_bytes_get32(b, i);
   }
   function get_int32_be(b, i){
    return Stdlib_Sys[11]
            ? caml_bytes_get32(b, i)
            : caml_int32_bswap(caml_bytes_get32(b, i));
   }
   function get_int64_le(b, i){
    return Stdlib_Sys[11]
            ? caml_int64_bswap(caml_bytes_get64(b, i))
            : caml_bytes_get64(b, i);
   }
   function get_int64_be(b, i){
    return Stdlib_Sys[11]
            ? caml_bytes_get64(b, i)
            : caml_int64_bswap(caml_bytes_get64(b, i));
   }
   function unsafe_set_uint16_le(b, i, x){
    if(Stdlib_Sys[11]){caml_bytes_set16(b, i, caml_bswap16(x)); return;}
    caml_bytes_set16(b, i, x);
    return;
   }
   function unsafe_set_uint16_be(b, i, x){
    if(Stdlib_Sys[11]){caml_bytes_set16(b, i, x); return;}
    caml_bytes_set16(b, i, caml_bswap16(x));
    return;
   }
   function set_int16_le(b, i, x){
    return Stdlib_Sys[11]
            ? caml_bytes_set16(b, i, caml_bswap16(x))
            : caml_bytes_set16(b, i, x);
   }
   function set_int16_be(b, i, x){
    return Stdlib_Sys[11]
            ? caml_bytes_set16(b, i, x)
            : caml_bytes_set16(b, i, caml_bswap16(x));
   }
   function set_int32_le(b, i, x){
    return Stdlib_Sys[11]
            ? caml_bytes_set32(b, i, caml_int32_bswap(x))
            : caml_bytes_set32(b, i, x);
   }
   function set_int32_be(b, i, x){
    return Stdlib_Sys[11]
            ? caml_bytes_set32(b, i, x)
            : caml_bytes_set32(b, i, caml_int32_bswap(x));
   }
   function set_int64_le(b, i, x){
    return Stdlib_Sys[11]
            ? caml_bytes_set64(b, i, caml_int64_bswap(x))
            : caml_bytes_set64(b, i, x);
   }
   function set_int64_be(b, i, x){
    return Stdlib_Sys[11]
            ? caml_bytes_set64(b, i, x)
            : caml_bytes_set64(b, i, caml_int64_bswap(x));
   }
   var
    set_uint8 = caml_bytes_set,
    set_uint16_ne = caml_bytes_set16,
    dec_invalid = Stdlib_Uchar[22],
    _a_ = [0, cst_bytes_ml, 667, 9],
    _b_ = [0, cst_bytes_ml, 642, 20],
    cst_index_out_of_bounds = cst_index_out_of_bounds$3,
    cst_index_out_of_bounds$0 = cst_index_out_of_bounds$3,
    _c_ = [0, cst_bytes_ml, 765, 9],
    _d_ = [0, cst_bytes_ml, 754, 20],
    cst_index_out_of_bounds$1 = cst_index_out_of_bounds$3,
    cst_index_out_of_bounds$2 = cst_index_out_of_bounds$3,
    _e_ = [0, cst_bytes_ml, 819, 9],
    _f_ = [0, cst_bytes_ml, 808, 20];
   function dec_ret(n, u){
    var _l_ = caml_call1(Stdlib_Uchar[9], u);
    return caml_call2(Stdlib_Uchar[21], n, _l_);
   }
   function not_in_x80_to_xBF(b){return 2 !== (b >>> 6 | 0) ? 1 : 0;}
   function not_in_xA0_to_xBF(b){return 5 !== (b >>> 5 | 0) ? 1 : 0;}
   function not_in_x80_to_x9F(b){return 4 !== (b >>> 5 | 0) ? 1 : 0;}
   function not_in_x90_to_xBF(b){
    var _j_ = b < 144 ? 1 : 0, _k_ = _j_ || (191 < b ? 1 : 0);
    return _k_;
   }
   function not_in_x80_to_x8F(b){return 8 !== (b >>> 4 | 0) ? 1 : 0;}
   function utf_8_uchar_3(b0, b1, b2){
    return (b0 & 15) << 12 | (b1 & 63) << 6 | b2 & 63;
   }
   function utf_8_uchar_4(b0, b1, b2, b3){
    return (b0 & 7) << 18 | (b1 & 63) << 12 | (b2 & 63) << 6 | b3 & 63;
   }
   function get_utf_8_uchar(b, i){
    var b0 = caml_bytes_get(b, i), max = caml_ml_bytes_length(b) - 1 | 0;
    a:
    {
     if(224 <= b0){
      if(237 <= b0){
       if(245 <= b0) break a;
       switch(b0 - 237 | 0){
         case 0:
          var i$0 = i + 1 | 0;
          if(max < i$0) return caml_call1(dec_invalid, 1);
          var b1$4 = caml_bytes_unsafe_get(b, i$0);
          if(not_in_x80_to_x9F(b1$4)) return caml_call1(dec_invalid, 1);
          var i$1 = i$0 + 1 | 0;
          if(max < i$1) return caml_call1(dec_invalid, 2);
          var b2$3 = caml_bytes_unsafe_get(b, i$1);
          return not_in_x80_to_xBF(b2$3)
                  ? caml_call1(dec_invalid, 2)
                  : dec_ret(3, utf_8_uchar_3(b0, b1$4, b2$3));
         case 3:
          var i$4 = i + 1 | 0;
          if(max < i$4) return caml_call1(dec_invalid, 1);
          var b1$2 = caml_bytes_unsafe_get(b, i$4);
          if(not_in_x90_to_xBF(b1$2)) return caml_call1(dec_invalid, 1);
          var i$5 = i$4 + 1 | 0;
          if(max < i$5) return caml_call1(dec_invalid, 2);
          var b2$1 = caml_bytes_unsafe_get(b, i$5);
          if(not_in_x80_to_xBF(b2$1)) return caml_call1(dec_invalid, 2);
          var i$6 = i$5 + 1 | 0;
          if(max < i$6) return caml_call1(dec_invalid, 3);
          var b3$1 = caml_bytes_unsafe_get(b, i$6);
          return not_in_x80_to_xBF(b3$1)
                  ? caml_call1(dec_invalid, 3)
                  : dec_ret(4, utf_8_uchar_4(b0, b1$2, b2$1, b3$1));
         case 7:
          var i$10 = i + 1 | 0;
          if(max < i$10) return caml_call1(dec_invalid, 1);
          var b1$0 = caml_bytes_unsafe_get(b, i$10);
          if(not_in_x80_to_x8F(b1$0)) return caml_call1(dec_invalid, 1);
          var i$11 = i$10 + 1 | 0;
          if(max < i$11) return caml_call1(dec_invalid, 2);
          var b2 = caml_bytes_unsafe_get(b, i$11);
          if(not_in_x80_to_xBF(b2)) return caml_call1(dec_invalid, 2);
          var i$12 = i$11 + 1 | 0;
          if(max < i$12) return caml_call1(dec_invalid, 3);
          var b3 = caml_bytes_unsafe_get(b, i$12);
          return not_in_x80_to_xBF(b3)
                  ? caml_call1(dec_invalid, 3)
                  : dec_ret(4, utf_8_uchar_4(b0, b1$0, b2, b3));
         case 1:
         case 2: break;
         default:
          var i$7 = i + 1 | 0;
          if(max < i$7) return caml_call1(dec_invalid, 1);
          var b1$1 = caml_bytes_unsafe_get(b, i$7);
          if(not_in_x80_to_xBF(b1$1)) return caml_call1(dec_invalid, 1);
          var i$8 = i$7 + 1 | 0;
          if(max < i$8) return caml_call1(dec_invalid, 2);
          var b2$0 = caml_bytes_unsafe_get(b, i$8);
          if(not_in_x80_to_xBF(b2$0)) return caml_call1(dec_invalid, 2);
          var i$9 = i$8 + 1 | 0;
          if(max < i$9) return caml_call1(dec_invalid, 3);
          var b3$0 = caml_bytes_unsafe_get(b, i$9);
          return not_in_x80_to_xBF(b3$0)
                  ? caml_call1(dec_invalid, 3)
                  : dec_ret(4, utf_8_uchar_4(b0, b1$1, b2$0, b3$0));
       }
      }
      else if(225 > b0){
       var i$13 = i + 1 | 0;
       if(max < i$13) return caml_call1(dec_invalid, 1);
       var b1$5 = caml_bytes_unsafe_get(b, i$13);
       if(not_in_xA0_to_xBF(b1$5)) return caml_call1(dec_invalid, 1);
       var i$14 = i$13 + 1 | 0;
       if(max < i$14) return caml_call1(dec_invalid, 2);
       var b2$4 = caml_bytes_unsafe_get(b, i$14);
       return not_in_x80_to_xBF(b2$4)
               ? caml_call1(dec_invalid, 2)
               : dec_ret(3, utf_8_uchar_3(b0, b1$5, b2$4));
      }
      var i$2 = i + 1 | 0;
      if(max < i$2) return caml_call1(dec_invalid, 1);
      var b1$3 = caml_bytes_unsafe_get(b, i$2);
      if(not_in_x80_to_xBF(b1$3)) return caml_call1(dec_invalid, 1);
      var i$3 = i$2 + 1 | 0;
      if(max < i$3) return caml_call1(dec_invalid, 2);
      var b2$2 = caml_bytes_unsafe_get(b, i$3);
      return not_in_x80_to_xBF(b2$2)
              ? caml_call1(dec_invalid, 2)
              : dec_ret(3, utf_8_uchar_3(b0, b1$3, b2$2));
     }
     if(128 > b0) return dec_ret(1, b0);
     if(194 <= b0){
      var i$15 = i + 1 | 0;
      if(max < i$15) return caml_call1(dec_invalid, 1);
      var b1 = caml_bytes_unsafe_get(b, i$15);
      return not_in_x80_to_xBF(b1)
              ? caml_call1(dec_invalid, 1)
              : dec_ret(2, (b0 & 31) << 6 | b1 & 63);
     }
    }
    return caml_call1(dec_invalid, 1);
   }
   function set_utf_8_uchar(b, i, u){
    function set(_i_, _h_, _g_){caml_bytes_unsafe_set(_i_, _h_, _g_); return;}
    var
     max = caml_ml_bytes_length(b) - 1 | 0,
     u$0 = caml_call1(Stdlib_Uchar[10], u);
    if(0 > u$0)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
    if(127 >= u$0){caml_bytes_set(b, i, u$0); return 1;}
    if(2047 >= u$0){
     var last$1 = i + 1 | 0;
     return max < last$1
             ? 0
             : (caml_bytes_set
                (b, i, 192 | u$0 >>> 6 | 0),
               set(b, last$1, 128 | u$0 & 63),
               2);
    }
    if(65535 >= u$0){
     var last$0 = i + 2 | 0;
     return max < last$0
             ? 0
             : (caml_bytes_set
                (b, i, 224 | u$0 >>> 12 | 0),
               set(b, i + 1 | 0, 128 | (u$0 >>> 6 | 0) & 63),
               set(b, last$0, 128 | u$0 & 63),
               3);
    }
    if(1114111 < u$0)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
    var last = i + 3 | 0;
    return max < last
            ? 0
            : (caml_bytes_set
               (b, i, 240 | u$0 >>> 18 | 0),
              set(b, i + 1 | 0, 128 | (u$0 >>> 12 | 0) & 63),
              set(b, i + 2 | 0, 128 | (u$0 >>> 6 | 0) & 63),
              set(b, last, 128 | u$0 & 63),
              4);
   }
   function is_valid_utf_8(b){
    var max = caml_ml_bytes_length(b) - 1 | 0, i = 0;
    for(;;){
     if(max < i) return 1;
     var match = caml_bytes_unsafe_get(b, i);
     a:
     {
      if(224 <= match){
       if(237 <= match){
        if(245 <= match) break a;
        switch(match - 237 | 0){
          case 0:
           var last = i + 2 | 0;
           if
            (max >= last
             &&
              !
              not_in_x80_to_x9F(caml_bytes_unsafe_get(b, i + 1 | 0))
              && ! not_in_x80_to_xBF(caml_bytes_unsafe_get(b, last))){var i$0 = last + 1 | 0; i = i$0; continue;}
           return 0;
          case 3:
           var last$1 = i + 3 | 0;
           if
            (max >= last$1
             &&
              !
              not_in_x90_to_xBF(caml_bytes_unsafe_get(b, i + 1 | 0))
              &&
               !
               not_in_x80_to_xBF(caml_bytes_unsafe_get(b, i + 2 | 0))
               && ! not_in_x80_to_xBF(caml_bytes_unsafe_get(b, last$1))){var i$2 = last$1 + 1 | 0; i = i$2; continue;}
           return 0;
          case 7:
           var last$3 = i + 3 | 0;
           if
            (max >= last$3
             &&
              !
              not_in_x80_to_x8F(caml_bytes_unsafe_get(b, i + 1 | 0))
              &&
               !
               not_in_x80_to_xBF(caml_bytes_unsafe_get(b, i + 2 | 0))
               && ! not_in_x80_to_xBF(caml_bytes_unsafe_get(b, last$3))){var i$4 = last$3 + 1 | 0; i = i$4; continue;}
           return 0;
          case 1:
          case 2: break;
          default:
           var last$2 = i + 3 | 0;
           if
            (max >= last$2
             &&
              !
              not_in_x80_to_xBF(caml_bytes_unsafe_get(b, i + 1 | 0))
              &&
               !
               not_in_x80_to_xBF(caml_bytes_unsafe_get(b, i + 2 | 0))
               && ! not_in_x80_to_xBF(caml_bytes_unsafe_get(b, last$2))){var i$3 = last$2 + 1 | 0; i = i$3; continue;}
           return 0;
        }
       }
       else if(225 > match){
        var last$4 = i + 2 | 0;
        if
         (max >= last$4
          &&
           !
           not_in_xA0_to_xBF(caml_bytes_unsafe_get(b, i + 1 | 0))
           && ! not_in_x80_to_xBF(caml_bytes_unsafe_get(b, last$4))){var i$5 = last$4 + 1 | 0; i = i$5; continue;}
        return 0;
       }
       var last$0 = i + 2 | 0;
       if
        (max >= last$0
         &&
          !
          not_in_x80_to_xBF(caml_bytes_unsafe_get(b, i + 1 | 0))
          && ! not_in_x80_to_xBF(caml_bytes_unsafe_get(b, last$0))){var i$1 = last$0 + 1 | 0; i = i$1; continue;}
       return 0;
      }
      if(128 > match){var i$7 = i + 1 | 0; i = i$7; continue;}
      if(194 <= match){
       var last$5 = i + 1 | 0;
       if
        (max >= last$5
         && ! not_in_x80_to_xBF(caml_bytes_unsafe_get(b, last$5))){var i$6 = last$5 + 1 | 0; i = i$6; continue;}
       return 0;
      }
     }
     return 0;
    }
   }
   function get_utf_16be_uchar(b, i){
    var max = caml_ml_bytes_length(b) - 1 | 0;
    if(0 <= i && max >= i){
     if(i === max) return caml_call1(dec_invalid, 1);
     var hi = unsafe_get_uint16_be(b, i);
     if(55296 <= hi && 57343 >= hi){
      if(56319 < hi) return caml_call1(dec_invalid, 2);
      var last = i + 3 | 0;
      if(max < last) return caml_call1(dec_invalid, (max - i | 0) + 1 | 0);
      var lo = unsafe_get_uint16_be(b, i + 2 | 0);
      if(56320 <= lo && 57343 >= lo){
       var u = ((hi & 1023) << 10 | lo & 1023) + 65536 | 0;
       return dec_ret(4, u);
      }
      return caml_call1(dec_invalid, 2);
     }
     return dec_ret(2, hi);
    }
    return caml_call1(Stdlib[1], cst_index_out_of_bounds);
   }
   function set_utf_16be_uchar(b, i, u){
    var max = caml_ml_bytes_length(b) - 1 | 0;
    if(0 <= i && max >= i){
     var u$0 = caml_call1(Stdlib_Uchar[10], u);
     if(0 > u$0)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
     if(65535 >= u$0){
      var last$0 = i + 1 | 0;
      return max < last$0 ? 0 : (unsafe_set_uint16_be(b, i, u$0), 2);
     }
     if(1114111 < u$0)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
     var last = i + 3 | 0;
     if(max < last) return 0;
     var
      u$1 = u$0 - 65536 | 0,
      hi = 55296 | u$1 >>> 10 | 0,
      lo = 56320 | u$1 & 1023;
     unsafe_set_uint16_be(b, i, hi);
     unsafe_set_uint16_be(b, i + 2 | 0, lo);
     return 4;
    }
    return caml_call1(Stdlib[1], cst_index_out_of_bounds$0);
   }
   function is_valid_utf_16be(b){
    var max = caml_ml_bytes_length(b) - 1 | 0, i = 0;
    for(;;){
     if(max < i) return 1;
     if(i === max) return 0;
     var u = unsafe_get_uint16_be(b, i);
     if(55296 <= u && 57343 >= u){
      if(56319 < u) return 0;
      var last = i + 3 | 0;
      if(max < last) return 0;
      var u$0 = unsafe_get_uint16_be(b, i + 2 | 0);
      if(56320 <= u$0 && 57343 >= u$0){
       var i$1 = i + 4 | 0;
       i = i$1;
       continue;
      }
      return 0;
     }
     var i$0 = i + 2 | 0;
     i = i$0;
    }
   }
   function get_utf_16le_uchar(b, i){
    var max = caml_ml_bytes_length(b) - 1 | 0;
    if(0 <= i && max >= i){
     if(i === max) return caml_call1(dec_invalid, 1);
     var hi = unsafe_get_uint16_le(b, i);
     if(55296 <= hi && 57343 >= hi){
      if(56319 < hi) return caml_call1(dec_invalid, 2);
      var last = i + 3 | 0;
      if(max < last) return caml_call1(dec_invalid, (max - i | 0) + 1 | 0);
      var lo = unsafe_get_uint16_le(b, i + 2 | 0);
      if(56320 <= lo && 57343 >= lo){
       var u = ((hi & 1023) << 10 | lo & 1023) + 65536 | 0;
       return dec_ret(4, u);
      }
      return caml_call1(dec_invalid, 2);
     }
     return dec_ret(2, hi);
    }
    return caml_call1(Stdlib[1], cst_index_out_of_bounds$1);
   }
   function set_utf_16le_uchar(b, i, u){
    var max = caml_ml_bytes_length(b) - 1 | 0;
    if(0 <= i && max >= i){
     var u$0 = caml_call1(Stdlib_Uchar[10], u);
     if(0 > u$0)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
     if(65535 >= u$0){
      var last$0 = i + 1 | 0;
      return max < last$0 ? 0 : (unsafe_set_uint16_le(b, i, u$0), 2);
     }
     if(1114111 < u$0)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
     var last = i + 3 | 0;
     if(max < last) return 0;
     var
      u$1 = u$0 - 65536 | 0,
      hi = 55296 | u$1 >>> 10 | 0,
      lo = 56320 | u$1 & 1023;
     unsafe_set_uint16_le(b, i, hi);
     unsafe_set_uint16_le(b, i + 2 | 0, lo);
     return 4;
    }
    return caml_call1(Stdlib[1], cst_index_out_of_bounds$2);
   }
   function is_valid_utf_16le(b){
    var max = caml_ml_bytes_length(b) - 1 | 0, i = 0;
    for(;;){
     if(max < i) return 1;
     if(i === max) return 0;
     var u = unsafe_get_uint16_le(b, i);
     if(55296 <= u && 57343 >= u){
      if(56319 < u) return 0;
      var last = i + 3 | 0;
      if(max < last) return 0;
      var u$0 = unsafe_get_uint16_le(b, i + 2 | 0);
      if(56320 <= u$0 && 57343 >= u$0){
       var i$1 = i + 4 | 0;
       i = i$1;
       continue;
      }
      return 0;
     }
     var i$0 = i + 2 | 0;
     i = i$0;
    }
   }
   var
    Stdlib_Bytes =
      [0,
       make,
       init,
       empty,
       copy,
       of_string,
       to_string,
       sub,
       sub_string,
       extend,
       fill,
       blit,
       blit_string,
       concat,
       cat,
       iter,
       iteri,
       map,
       mapi,
       fold_left,
       fold_right,
       for_all,
       exists,
       trim,
       escaped,
       index,
       index_opt,
       rindex,
       rindex_opt,
       index_from,
       index_from_opt,
       rindex_from,
       rindex_from_opt,
       contains,
       contains_from,
       rcontains_from,
       uppercase,
       lowercase,
       capitalize,
       uncapitalize,
       uppercase_ascii,
       lowercase_ascii,
       capitalize_ascii,
       uncapitalize_ascii,
       compare,
       runtime.caml_bytes_equal,
       starts_with,
       ends_with,
       caml_string_of_bytes,
       caml_bytes_of_string,
       split_on_char,
       to_seq,
       to_seqi,
       of_seq,
       get_utf_8_uchar,
       set_utf_8_uchar,
       is_valid_utf_8,
       get_utf_16be_uchar,
       set_utf_16be_uchar,
       is_valid_utf_16be,
       get_utf_16le_uchar,
       set_utf_16le_uchar,
       is_valid_utf_16le,
       caml_bytes_get,
       get_int8,
       caml_bytes_get16,
       get_uint16_be,
       get_uint16_le,
       get_int16_ne,
       get_int16_be,
       get_int16_le,
       caml_bytes_get32,
       get_int32_be,
       get_int32_le,
       caml_bytes_get64,
       get_int64_be,
       get_int64_le,
       set_uint8,
       caml_bytes_set,
       set_uint16_ne,
       set_int16_be,
       set_int16_le,
       caml_bytes_set16,
       set_int16_be,
       set_int16_le,
       caml_bytes_set32,
       set_int32_be,
       set_int32_le,
       caml_bytes_set64,
       set_int64_be,
       set_int64_le];
   runtime.caml_register_global(30, Stdlib_Bytes, "Stdlib__Bytes");
   return;
  }
  (globalThis));

//# 4969 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$0 = "",
    caml_blit_string = runtime.caml_blit_string,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_equal = runtime.caml_string_equal,
    caml_string_unsafe_get = runtime.caml_string_unsafe_get,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = cst$0,
    empty = cst$0,
    Stdlib = global_data.Stdlib,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    bts = Stdlib_Bytes[48],
    bos = Stdlib_Bytes[49];
   function make(n, c){
    return caml_call1(bts, caml_call2(Stdlib_Bytes[1], n, c));
   }
   function init(n, f){
    return caml_call1(bts, caml_call2(Stdlib_Bytes[2], n, f));
   }
   function copy(s){
    var _ac_ = caml_call1(bos, s);
    return caml_call1(bts, caml_call1(Stdlib_Bytes[4], _ac_));
   }
   var of_bytes = Stdlib_Bytes[6], to_bytes = Stdlib_Bytes[5];
   function sub(s, ofs, len){
    var _ab_ = caml_call1(bos, s);
    return caml_call1(bts, caml_call3(Stdlib_Bytes[7], _ab_, ofs, len));
   }
   var
    fill = Stdlib_Bytes[10],
    blit = Stdlib_Bytes[12],
    cst_String_concat = "String.concat";
   function concat(sep, l){
    if(! l) return cst;
    var seplen = caml_ml_string_length(sep);
    a:
    {
     b:
     {
      var acc = 0, param = l, pos$1 = 0;
      for(;;){
       if(! param) break;
       var hd = param[1];
       if(! param[2]) break b;
       var
        tl = param[2],
        x = (caml_ml_string_length(hd) + seplen | 0) + acc | 0,
        acc$0 = acc <= x ? x : caml_call1(Stdlib[1], cst_String_concat);
       acc = acc$0;
       param = tl;
      }
      var _aa_ = acc;
      break a;
     }
     var _aa_ = caml_ml_string_length(hd) + acc | 0;
    }
    var dst = runtime.caml_create_bytes(_aa_), pos = pos$1, param$0 = l;
    for(;;){
     if(param$0){
      var hd$0 = param$0[1];
      if(param$0[2]){
       var tl$0 = param$0[2];
       caml_blit_string(hd$0, 0, dst, pos, caml_ml_string_length(hd$0));
       caml_blit_string
        (sep, 0, dst, pos + caml_ml_string_length(hd$0) | 0, seplen);
       var pos$0 = (pos + caml_ml_string_length(hd$0) | 0) + seplen | 0;
       pos = pos$0;
       param$0 = tl$0;
       continue;
      }
      caml_blit_string(hd$0, 0, dst, pos, caml_ml_string_length(hd$0));
     }
     return caml_call1(bts, dst);
    }
   }
   var
    cat = Stdlib[28],
    cst_String_index_from_Bytes_in = "String.index_from / Bytes.index_from",
    cst_String_index_from_opt_Byte =
      "String.index_from_opt / Bytes.index_from_opt",
    cst_String_rindex_from_Bytes_r = "String.rindex_from / Bytes.rindex_from",
    cst_String_rindex_from_opt_Byt =
      "String.rindex_from_opt / Bytes.rindex_from_opt",
    cst_String_contains_from_Bytes =
      "String.contains_from / Bytes.contains_from",
    cst_String_rcontains_from_Byte =
      "String.rcontains_from / Bytes.rcontains_from";
   function iter(f, s){
    var ___ = caml_ml_string_length(s) - 1 | 0, _Z_ = 0;
    if(___ >= 0){
     var i = _Z_;
     for(;;){
      caml_call1(f, caml_string_unsafe_get(s, i));
      var _$_ = i + 1 | 0;
      if(___ === i) break;
      i = _$_;
     }
    }
    return 0;
   }
   function iteri(f, s){
    var _X_ = caml_ml_string_length(s) - 1 | 0, _W_ = 0;
    if(_X_ >= 0){
     var i = _W_;
     for(;;){
      caml_call2(f, i, caml_string_unsafe_get(s, i));
      var _Y_ = i + 1 | 0;
      if(_X_ === i) break;
      i = _Y_;
     }
    }
    return 0;
   }
   function map(f, s){
    var _V_ = caml_call1(bos, s);
    return caml_call1(bts, caml_call2(Stdlib_Bytes[17], f, _V_));
   }
   function mapi(f, s){
    var _U_ = caml_call1(bos, s);
    return caml_call1(bts, caml_call2(Stdlib_Bytes[18], f, _U_));
   }
   function fold_right(f, x, a){
    var _T_ = caml_call1(bos, x);
    return caml_call3(Stdlib_Bytes[20], f, _T_, a);
   }
   function fold_left(f, a, x){
    var _S_ = caml_call1(bos, x);
    return caml_call3(Stdlib_Bytes[19], f, a, _S_);
   }
   function exists(f, s){
    var _R_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[22], f, _R_);
   }
   function for_all(f, s){
    var _Q_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[21], f, _Q_);
   }
   function is_space(param){
    var _P_ = param - 9 | 0;
    a:
    {
     if(4 < _P_ >>> 0){if(23 !== _P_) break a;} else if(2 === _P_) break a;
     return 1;
    }
    return 0;
   }
   function trim(s){
    if(s == cst$0) return s;
    if
     (!
      is_space(caml_string_unsafe_get(s, 0))
      &&
       !
       is_space(caml_string_unsafe_get(s, caml_ml_string_length(s) - 1 | 0)))
     return s;
    var _O_ = caml_call1(bos, s);
    return caml_call1(bts, caml_call1(Stdlib_Bytes[23], _O_));
   }
   function escaped(s){
    var n = caml_ml_string_length(s), i = 0;
    for(;;){
     if(n <= i) return s;
     var _M_ = caml_string_unsafe_get(s, i) - 32 | 0;
     a:
     {
      if(59 < _M_ >>> 0){
       if(33 < _M_ - 61 >>> 0) break a;
      }
      else if(2 === _M_) break a;
      var i$0 = i + 1 | 0;
      i = i$0;
      continue;
     }
     var _N_ = caml_call1(bos, s);
     return caml_call1(bts, caml_call1(Stdlib_Bytes[24], _N_));
    }
   }
   function index_rec(s, lim, i, c){
    var i$0 = i;
    for(;;){
     if(lim <= i$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     if(caml_string_unsafe_get(s, i$0) === c) return i$0;
     var i$1 = i$0 + 1 | 0;
     i$0 = i$1;
    }
   }
   function index(s, c){return index_rec(s, caml_ml_string_length(s), 0, c);}
   function index_rec_opt(s, lim, i, c){
    var i$0 = i;
    for(;;){
     if(lim <= i$0) return 0;
     if(caml_string_unsafe_get(s, i$0) === c) return [0, i$0];
     var i$1 = i$0 + 1 | 0;
     i$0 = i$1;
    }
   }
   function index_opt(s, c){
    return index_rec_opt(s, caml_ml_string_length(s), 0, c);
   }
   function index_from(s, i, c){
    var l = caml_ml_string_length(s);
    if(0 <= i && l >= i) return index_rec(s, l, i, c);
    return caml_call1(Stdlib[1], cst_String_index_from_Bytes_in);
   }
   function index_from_opt(s, i, c){
    var l = caml_ml_string_length(s);
    if(0 <= i && l >= i) return index_rec_opt(s, l, i, c);
    return caml_call1(Stdlib[1], cst_String_index_from_opt_Byte);
   }
   function rindex_rec(s, i, c){
    var i$0 = i;
    for(;;){
     if(0 > i$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     if(caml_string_unsafe_get(s, i$0) === c) return i$0;
     var i$1 = i$0 - 1 | 0;
     i$0 = i$1;
    }
   }
   function rindex(s, c){
    return rindex_rec(s, caml_ml_string_length(s) - 1 | 0, c);
   }
   function rindex_from(s, i, c){
    if(-1 <= i && caml_ml_string_length(s) > i) return rindex_rec(s, i, c);
    return caml_call1(Stdlib[1], cst_String_rindex_from_Bytes_r);
   }
   function rindex_rec_opt(s, i, c){
    var i$0 = i;
    for(;;){
     if(0 > i$0) return 0;
     if(caml_string_unsafe_get(s, i$0) === c) return [0, i$0];
     var i$1 = i$0 - 1 | 0;
     i$0 = i$1;
    }
   }
   function rindex_opt(s, c){
    return rindex_rec_opt(s, caml_ml_string_length(s) - 1 | 0, c);
   }
   function rindex_from_opt(s, i, c){
    if(-1 <= i && caml_ml_string_length(s) > i)
     return rindex_rec_opt(s, i, c);
    return caml_call1(Stdlib[1], cst_String_rindex_from_opt_Byt);
   }
   function contains_from(s, i, c){
    var l = caml_ml_string_length(s);
    if(0 <= i && l >= i)
     try{index_rec(s, l, i, c); var _K_ = 1; return _K_;}
     catch(_L_){
      var _J_ = caml_wrap_exception(_L_);
      if(_J_ === Stdlib[8]) return 0;
      throw caml_maybe_attach_backtrace(_J_, 0);
     }
    return caml_call1(Stdlib[1], cst_String_contains_from_Bytes);
   }
   function contains(s, c){return contains_from(s, 0, c);}
   function rcontains_from(s, i, c){
    if(0 <= i && caml_ml_string_length(s) > i)
     try{rindex_rec(s, i, c); var _H_ = 1; return _H_;}
     catch(_I_){
      var _G_ = caml_wrap_exception(_I_);
      if(_G_ === Stdlib[8]) return 0;
      throw caml_maybe_attach_backtrace(_G_, 0);
     }
    return caml_call1(Stdlib[1], cst_String_rcontains_from_Byte);
   }
   function uppercase_ascii(s){
    var _F_ = caml_call1(bos, s);
    return caml_call1(bts, caml_call1(Stdlib_Bytes[40], _F_));
   }
   function lowercase_ascii(s){
    var _E_ = caml_call1(bos, s);
    return caml_call1(bts, caml_call1(Stdlib_Bytes[41], _E_));
   }
   function capitalize_ascii(s){
    var _D_ = caml_call1(bos, s);
    return caml_call1(bts, caml_call1(Stdlib_Bytes[42], _D_));
   }
   function uncapitalize_ascii(s){
    var _C_ = caml_call1(bos, s);
    return caml_call1(bts, caml_call1(Stdlib_Bytes[43], _C_));
   }
   function starts_with(prefix, s){
    var
     len_s = caml_ml_string_length(s),
     len_pre = caml_ml_string_length(prefix),
     _B_ = len_pre <= len_s ? 1 : 0;
    if(! _B_) return _B_;
    var i = 0;
    for(;;){
     if(i === len_pre) return 1;
     if(caml_string_unsafe_get(s, i) !== caml_string_unsafe_get(prefix, i))
      return 0;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function ends_with(suffix, s){
    var
     len_s = caml_ml_string_length(s),
     len_suf = caml_ml_string_length(suffix),
     diff = len_s - len_suf | 0,
     _A_ = 0 <= diff ? 1 : 0;
    if(! _A_) return _A_;
    var i = 0;
    for(;;){
     if(i === len_suf) return 1;
     if
      (caml_string_unsafe_get(s, diff + i | 0)
       !== caml_string_unsafe_get(suffix, i))
      return 0;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function split_on_char(sep, s){
    var
     r = [0, 0],
     j = [0, caml_ml_string_length(s)],
     _w_ = caml_ml_string_length(s) - 1 | 0;
    if(_w_ >= 0){
     var i = _w_;
     for(;;){
      if(caml_string_unsafe_get(s, i) === sep){
       var _y_ = r[1];
       r[1] = [0, sub(s, i + 1 | 0, (j[1] - i | 0) - 1 | 0), _y_];
       j[1] = i;
      }
      var _z_ = i - 1 | 0;
      if(0 === i) break;
      i = _z_;
     }
    }
    var _x_ = r[1];
    return [0, sub(s, 0, j[1]), _x_];
   }
   function uppercase(s){
    var _v_ = caml_call1(bos, s);
    return caml_call1(bts, caml_call1(Stdlib_Bytes[36], _v_));
   }
   function lowercase(s){
    var _u_ = caml_call1(bos, s);
    return caml_call1(bts, caml_call1(Stdlib_Bytes[37], _u_));
   }
   function capitalize(s){
    var _t_ = caml_call1(bos, s);
    return caml_call1(bts, caml_call1(Stdlib_Bytes[38], _t_));
   }
   function uncapitalize(s){
    var _s_ = caml_call1(bos, s);
    return caml_call1(bts, caml_call1(Stdlib_Bytes[39], _s_));
   }
   var compare = runtime.caml_string_compare;
   function to_seq(s){
    var _r_ = caml_call1(bos, s);
    return caml_call1(Stdlib_Bytes[51], _r_);
   }
   function to_seqi(s){
    var _q_ = caml_call1(bos, s);
    return caml_call1(Stdlib_Bytes[52], _q_);
   }
   function of_seq(g){
    return caml_call1(bts, caml_call1(Stdlib_Bytes[53], g));
   }
   function get_utf_8_uchar(s, i){
    var _p_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[54], _p_, i);
   }
   function is_valid_utf_8(s){
    var _o_ = caml_call1(bos, s);
    return caml_call1(Stdlib_Bytes[56], _o_);
   }
   function get_utf_16be_uchar(s, i){
    var _n_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[57], _n_, i);
   }
   function is_valid_utf_16be(s){
    var _m_ = caml_call1(bos, s);
    return caml_call1(Stdlib_Bytes[59], _m_);
   }
   function get_utf_16le_uchar(s, i){
    var _l_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[60], _l_, i);
   }
   function is_valid_utf_16le(s){
    var _k_ = caml_call1(bos, s);
    return caml_call1(Stdlib_Bytes[62], _k_);
   }
   function get_int8(s, i){
    var _j_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[64], _j_, i);
   }
   function get_uint16_le(s, i){
    var _i_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[67], _i_, i);
   }
   function get_uint16_be(s, i){
    var _h_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[66], _h_, i);
   }
   function get_int16_ne(s, i){
    var _g_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[68], _g_, i);
   }
   function get_int16_le(s, i){
    var _f_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[70], _f_, i);
   }
   function get_int16_be(s, i){
    var _e_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[69], _e_, i);
   }
   function get_int32_le(s, i){
    var _d_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[73], _d_, i);
   }
   function get_int32_be(s, i){
    var _c_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[72], _c_, i);
   }
   function get_int64_le(s, i){
    var _b_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[76], _b_, i);
   }
   function get_int64_be(s, i){
    var _a_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[75], _a_, i);
   }
   var
    Stdlib_String =
      [0,
       make,
       init,
       empty,
       of_bytes,
       to_bytes,
       concat,
       cat,
       caml_string_equal,
       compare,
       starts_with,
       ends_with,
       contains_from,
       rcontains_from,
       contains,
       sub,
       split_on_char,
       map,
       mapi,
       fold_left,
       fold_right,
       for_all,
       exists,
       trim,
       escaped,
       uppercase_ascii,
       lowercase_ascii,
       capitalize_ascii,
       uncapitalize_ascii,
       iter,
       iteri,
       index_from,
       index_from_opt,
       rindex_from,
       rindex_from_opt,
       index,
       index_opt,
       rindex,
       rindex_opt,
       to_seq,
       to_seqi,
       of_seq,
       get_utf_8_uchar,
       is_valid_utf_8,
       get_utf_16be_uchar,
       is_valid_utf_16be,
       get_utf_16le_uchar,
       is_valid_utf_16le,
       blit,
       copy,
       fill,
       uppercase,
       lowercase,
       capitalize,
       uncapitalize,
       runtime.caml_string_get,
       get_int8,
       runtime.caml_string_get16,
       get_uint16_be,
       get_uint16_le,
       get_int16_ne,
       get_int16_be,
       get_int16_le,
       runtime.caml_string_get32,
       get_int32_be,
       get_int32_le,
       runtime.caml_string_get64,
       get_int64_be,
       get_int64_le];
   runtime.caml_register_global(12, Stdlib_String, "Stdlib__String");
   return;
  }
  (globalThis));

//# 5572 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_array_sub = runtime.caml_array_sub,
    caml_check_bound = runtime.caml_check_bound,
    caml_make_vect = runtime.caml_make_vect,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Seq = global_data.Stdlib__Seq,
    Assert_failure = global_data.Assert_failure,
    Stdlib = global_data.Stdlib,
    make_float = runtime.caml_make_float_vect,
    Floatarray = [0],
    cst_Array_init = "Array.init",
    cst_Array_sub = "Array.sub",
    cst_Array_fill = "Array.fill",
    cst_Array_blit = "Array.blit",
    cst_Array_iter2_arrays_must_ha =
      "Array.iter2: arrays must have the same length",
    cst_Array_map2_arrays_must_hav =
      "Array.map2: arrays must have the same length",
    cst_Array_for_all2 = "Array.for_all2",
    cst_Array_exists2 = "Array.exists2",
    cst_Array_combine = "Array.combine";
   function init(l, f){
    if(0 === l) return [0];
    if(0 > l) return caml_call1(Stdlib[1], cst_Array_init);
    var res = caml_make_vect(l, caml_call1(f, 0)), _aq_ = l - 1 | 0, _ap_ = 1;
    if(_aq_ >= 1){
     var i = _ap_;
     for(;;){
      res[1 + i] = caml_call1(f, i);
      var _ar_ = i + 1 | 0;
      if(_aq_ === i) break;
      i = _ar_;
     }
    }
    return res;
   }
   function make_matrix(sx, sy, init){
    var res = caml_make_vect(sx, [0]), _an_ = sx - 1 | 0, _am_ = 0;
    if(_an_ >= 0){
     var x = _am_;
     for(;;){
      res[1 + x] = caml_make_vect(sy, init);
      var _ao_ = x + 1 | 0;
      if(_an_ === x) break;
      x = _ao_;
     }
    }
    return res;
   }
   function copy(a){
    var l = a.length - 1;
    return 0 === l ? [0] : caml_array_sub(a, 0, l);
   }
   function append(a1, a2){
    var l1 = a1.length - 1;
    return 0 === l1
            ? copy(a2)
            : 0
              === a2.length - 1
              ? caml_array_sub(a1, 0, l1)
              : runtime.caml_array_append(a1, a2);
   }
   function sub(a, ofs, len){
    if(0 <= ofs && 0 <= len && (a.length - 1 - len | 0) >= ofs)
     return caml_array_sub(a, ofs, len);
    return caml_call1(Stdlib[1], cst_Array_sub);
   }
   function fill(a, ofs, len, v){
    if(0 <= ofs && 0 <= len && (a.length - 1 - len | 0) >= ofs)
     return runtime.caml_array_fill(a, ofs, len, v);
    return caml_call1(Stdlib[1], cst_Array_fill);
   }
   function blit(a1, ofs1, a2, ofs2, len){
    if
     (0 <= len
      &&
       0 <= ofs1
       &&
        (a1.length - 1 - len | 0) >= ofs1
        && 0 <= ofs2 && (a2.length - 1 - len | 0) >= ofs2)
     return runtime.caml_array_blit(a1, ofs1, a2, ofs2, len);
    return caml_call1(Stdlib[1], cst_Array_blit);
   }
   function iter(f, a){
    var _ak_ = a.length - 2 | 0, _aj_ = 0;
    if(_ak_ >= 0){
     var i = _aj_;
     for(;;){
      caml_call1(f, a[1 + i]);
      var _al_ = i + 1 | 0;
      if(_ak_ === i) break;
      i = _al_;
     }
    }
    return 0;
   }
   function iter2(f, a, b){
    if(a.length - 1 !== b.length - 1)
     return caml_call1(Stdlib[1], cst_Array_iter2_arrays_must_ha);
    var _ah_ = a.length - 2 | 0, _ag_ = 0;
    if(_ah_ >= 0){
     var i = _ag_;
     for(;;){
      caml_call2(f, a[1 + i], b[1 + i]);
      var _ai_ = i + 1 | 0;
      if(_ah_ === i) break;
      i = _ai_;
     }
    }
    return 0;
   }
   function map(f, a){
    var l = a.length - 1;
    if(0 === l) return [0];
    var
     r = caml_make_vect(l, caml_call1(f, a[1])),
     _ae_ = l - 1 | 0,
     _ad_ = 1;
    if(_ae_ >= 1){
     var i = _ad_;
     for(;;){
      r[1 + i] = caml_call1(f, a[1 + i]);
      var _af_ = i + 1 | 0;
      if(_ae_ === i) break;
      i = _af_;
     }
    }
    return r;
   }
   function map2(f, a, b){
    var la = a.length - 1, lb = b.length - 1;
    if(la !== lb)
     return caml_call1(Stdlib[1], cst_Array_map2_arrays_must_hav);
    if(0 === la) return [0];
    var
     r = caml_make_vect(la, caml_call2(f, a[1], b[1])),
     _ab_ = la - 1 | 0,
     _aa_ = 1;
    if(_ab_ >= 1){
     var i = _aa_;
     for(;;){
      r[1 + i] = caml_call2(f, a[1 + i], b[1 + i]);
      var _ac_ = i + 1 | 0;
      if(_ab_ === i) break;
      i = _ac_;
     }
    }
    return r;
   }
   function iteri(f, a){
    var ___ = a.length - 2 | 0, _Z_ = 0;
    if(___ >= 0){
     var i = _Z_;
     for(;;){
      caml_call2(f, i, a[1 + i]);
      var _$_ = i + 1 | 0;
      if(___ === i) break;
      i = _$_;
     }
    }
    return 0;
   }
   function mapi(f, a){
    var l = a.length - 1;
    if(0 === l) return [0];
    var
     r = caml_make_vect(l, caml_call2(f, 0, a[1])),
     _X_ = l - 1 | 0,
     _W_ = 1;
    if(_X_ >= 1){
     var i = _W_;
     for(;;){
      r[1 + i] = caml_call2(f, i, a[1 + i]);
      var _Y_ = i + 1 | 0;
      if(_X_ === i) break;
      i = _Y_;
     }
    }
    return r;
   }
   function to_list(a){
    var i$1 = a.length - 2 | 0, i = i$1, res = 0;
    for(;;){
     if(0 > i) return res;
     var res$0 = [0, a[1 + i], res], i$0 = i - 1 | 0;
     i = i$0;
     res = res$0;
    }
   }
   function list_length(accu, param){
    var accu$0 = accu, param$0 = param;
    for(;;){
     if(! param$0) return accu$0;
     var t = param$0[2], accu$1 = accu$0 + 1 | 0;
     accu$0 = accu$1;
     param$0 = t;
    }
   }
   function of_list(l){
    if(! l) return [0];
    var
     tl = l[2],
     hd = l[1],
     a = caml_make_vect(list_length(0, l), hd),
     i = 1,
     param = tl;
    for(;;){
     if(! param) return a;
     var tl$0 = param[2], hd$0 = param[1];
     a[1 + i] = hd$0;
     var i$0 = i + 1 | 0;
     i = i$0;
     param = tl$0;
    }
   }
   function fold_left(f, x, a){
    var r = [0, x], _U_ = a.length - 2 | 0, _T_ = 0;
    if(_U_ >= 0){
     var i = _T_;
     for(;;){
      r[1] = caml_call2(f, r[1], a[1 + i]);
      var _V_ = i + 1 | 0;
      if(_U_ === i) break;
      i = _V_;
     }
    }
    return r[1];
   }
   function fold_left_map(f, acc, input_array){
    var len = input_array.length - 1;
    if(0 === len) return [0, acc, [0]];
    var
     match = caml_call2(f, acc, input_array[1]),
     elt = match[2],
     acc$0 = match[1],
     output_array = caml_make_vect(len, elt),
     acc$1 = [0, acc$0],
     _R_ = len - 1 | 0,
     _Q_ = 1;
    if(_R_ >= 1){
     var i = _Q_;
     for(;;){
      var
       match$0 = caml_call2(f, acc$1[1], input_array[1 + i]),
       elt$0 = match$0[2],
       acc$2 = match$0[1];
      acc$1[1] = acc$2;
      output_array[1 + i] = elt$0;
      var _S_ = i + 1 | 0;
      if(_R_ === i) break;
      i = _S_;
     }
    }
    return [0, acc$1[1], output_array];
   }
   function fold_right(f, a, x){
    var r = [0, x], _O_ = a.length - 2 | 0;
    if(_O_ >= 0){
     var i = _O_;
     for(;;){
      r[1] = caml_call2(f, a[1 + i], r[1]);
      var _P_ = i - 1 | 0;
      if(0 === i) break;
      i = _P_;
     }
    }
    return r[1];
   }
   function exists(p, a){
    var n = a.length - 1, i = 0;
    for(;;){
     if(i === n) return 0;
     if(caml_call1(p, a[1 + i])) return 1;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function for_all(p, a){
    var n = a.length - 1, i = 0;
    for(;;){
     if(i === n) return 1;
     if(! caml_call1(p, a[1 + i])) return 0;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function for_all2(p, l1, l2){
    var n1 = l1.length - 1, n2 = l2.length - 1;
    if(n1 !== n2) return caml_call1(Stdlib[1], cst_Array_for_all2);
    var i = 0;
    for(;;){
     if(i === n1) return 1;
     if(! caml_call2(p, l1[1 + i], l2[1 + i])) return 0;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function exists2(p, l1, l2){
    var n1 = l1.length - 1, n2 = l2.length - 1;
    if(n1 !== n2) return caml_call1(Stdlib[1], cst_Array_exists2);
    var i = 0;
    for(;;){
     if(i === n1) return 0;
     if(caml_call2(p, l1[1 + i], l2[1 + i])) return 1;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function mem(x, a){
    var n = a.length - 1, i = 0;
    for(;;){
     if(i === n) return 0;
     if(0 === runtime.caml_compare(a[1 + i], x)) return 1;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function memq(x, a){
    var n = a.length - 1, i = 0;
    for(;;){
     if(i === n) return 0;
     if(x === a[1 + i]) return 1;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function find_opt(p, a){
    var n = a.length - 1, i = 0;
    for(;;){
     if(i === n) return 0;
     var x = a[1 + i];
     if(caml_call1(p, x)) return [0, x];
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function find_map(f, a){
    var n = a.length - 1, i = 0;
    for(;;){
     if(i === n) return 0;
     var r = caml_call1(f, a[1 + i]);
     if(r) return r;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function split(x){
    if(runtime.caml_equal(x, [0])) return [0, [0], [0]];
    var
     match = x[1],
     b0 = match[2],
     a0 = match[1],
     n = x.length - 1,
     a = caml_make_vect(n, a0),
     b = caml_make_vect(n, b0),
     _M_ = n - 1 | 0,
     _L_ = 1;
    if(_M_ >= 1){
     var i = _L_;
     for(;;){
      var match$0 = x[1 + i], bi = match$0[2], ai = match$0[1];
      a[1 + i] = ai;
      b[1 + i] = bi;
      var _N_ = i + 1 | 0;
      if(_M_ === i) break;
      i = _N_;
     }
    }
    return [0, a, b];
   }
   function combine(a, b){
    var na = a.length - 1, nb = b.length - 1;
    if(na !== nb) caml_call1(Stdlib[1], cst_Array_combine);
    if(0 === na) return [0];
    var x = caml_make_vect(na, [0, a[1], b[1]]), _J_ = na - 1 | 0, _I_ = 1;
    if(_J_ >= 1){
     var i = _I_;
     for(;;){
      x[1 + i] = [0, a[1 + i], b[1 + i]];
      var _K_ = i + 1 | 0;
      if(_J_ === i) break;
      i = _K_;
     }
    }
    return x;
   }
   var
    Bottom = [248, "Stdlib.Array.Bottom", runtime.caml_fresh_oo_id(0)],
    _a_ = [0, "array.ml", 322, 4];
   function sort(cmp, a){
    function maxson(l, i){
     var i31 = ((i + i | 0) + i | 0) + 1 | 0, x = [0, i31];
     if((i31 + 2 | 0) < l){
      var _B_ = i31 + 1 | 0, _C_ = caml_check_bound(a, _B_)[1 + _B_];
      if(caml_call2(cmp, caml_check_bound(a, i31)[1 + i31], _C_) < 0)
       x[1] = i31 + 1 | 0;
      var
       _D_ = i31 + 2 | 0,
       _E_ = caml_check_bound(a, _D_)[1 + _D_],
       _F_ = x[1];
      if(caml_call2(cmp, caml_check_bound(a, _F_)[1 + _F_], _E_) < 0)
       x[1] = i31 + 2 | 0;
      return x[1];
     }
     if((i31 + 1 | 0) < l){
      var _G_ = i31 + 1 | 0, _H_ = caml_check_bound(a, _G_)[1 + _G_];
      if(0 > caml_call2(cmp, caml_check_bound(a, i31)[1 + i31], _H_))
       return i31 + 1 | 0;
     }
     if(i31 < l) return i31;
     throw caml_maybe_attach_backtrace([0, Bottom, i], 1);
    }
    var l = a.length - 1, _v_ = ((l + 1 | 0) / 3 | 0) - 1 | 0;
    if(_v_ >= 0){
     var i$6 = _v_;
     for(;;){
      var e$1 = caml_check_bound(a, i$6)[1 + i$6];
      try{
       var i = i$6;
       for(;;){
        var j = maxson(l, i);
        if(0 >= caml_call2(cmp, caml_check_bound(a, j)[1 + j], e$1)) break;
        var _s_ = caml_check_bound(a, j)[1 + j];
        caml_check_bound(a, i)[1 + i] = _s_;
        i = j;
       }
       caml_check_bound(a, i)[1 + i] = e$1;
      }
      catch(exn$0){
       var exn = caml_wrap_exception(exn$0);
       if(exn[1] !== Bottom) throw caml_maybe_attach_backtrace(exn, 0);
       var i$0 = exn[2];
       caml_check_bound(a, i$0)[1 + i$0] = e$1;
      }
      var _A_ = i$6 - 1 | 0;
      if(0 === i$6) break;
      i$6 = _A_;
     }
    }
    var _w_ = l - 1 | 0;
    if(_w_ >= 2){
     var i$4 = _w_;
     for(;;){
      var e$0 = caml_check_bound(a, i$4)[1 + i$4];
      a[1 + i$4] = caml_check_bound(a, 0)[1];
      var i$5 = 0;
      try{
       var i$1 = i$5;
       for(;;){
        var j$0 = maxson(i$4, i$1), _t_ = caml_check_bound(a, j$0)[1 + j$0];
        caml_check_bound(a, i$1)[1 + i$1] = _t_;
        i$1 = j$0;
       }
      }
      catch(exn){
       var exn$0 = caml_wrap_exception(exn);
       if(exn$0[1] !== Bottom) throw caml_maybe_attach_backtrace(exn$0, 0);
       var i$2 = exn$0[2];
       a:
       {
        b:
        {
         var i$3 = i$2;
         for(;;){
          var father = (i$3 - 1 | 0) / 3 | 0;
          if(i$3 === father)
           throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
          if
           (0 <= caml_call2(cmp, caml_check_bound(a, father)[1 + father], e$0))
           break;
          var _u_ = caml_check_bound(a, father)[1 + father];
          caml_check_bound(a, i$3)[1 + i$3] = _u_;
          if(0 >= father) break b;
          i$3 = father;
         }
         caml_check_bound(a, i$3)[1 + i$3] = e$0;
         break a;
        }
        caml_check_bound(a, 0)[1] = e$0;
       }
       var _z_ = i$4 - 1 | 0;
       if(2 === i$4) break;
       i$4 = _z_;
      }
     }
    }
    var _x_ = 1 < l ? 1 : 0;
    if(_x_){
     var e = caml_check_bound(a, 1)[2];
     a[2] = caml_check_bound(a, 0)[1];
     a[1] = e;
     var _y_ = 0;
    }
    else
     var _y_ = _x_;
    return _y_;
   }
   function stable_sort(cmp, a){
    function merge(src1ofs, src1len, src2, src2ofs, src2len, dst, dstofs){
     var
      src1r = src1ofs + src1len | 0,
      src2r = src2ofs + src2len | 0,
      s2$1 = caml_check_bound(src2, src2ofs)[1 + src2ofs],
      s1$1 = caml_check_bound(a, src1ofs)[1 + src1ofs],
      i1 = src1ofs,
      s1 = s1$1,
      i2 = src2ofs,
      s2 = s2$1,
      d = dstofs;
     for(;;)
      if(0 < caml_call2(cmp, s1, s2)){
       caml_check_bound(dst, d)[1 + d] = s2;
       var i2$0 = i2 + 1 | 0;
       if(i2$0 >= src2r) return blit(a, i1, dst, d + 1 | 0, src1r - i1 | 0);
       var d$0 = d + 1 | 0, s2$0 = caml_check_bound(src2, i2$0)[1 + i2$0];
       i2 = i2$0;
       s2 = s2$0;
       d = d$0;
      }
      else{
       caml_check_bound(dst, d)[1 + d] = s1;
       var i1$0 = i1 + 1 | 0;
       if(i1$0 >= src1r)
        return blit(src2, i2, dst, d + 1 | 0, src2r - i2 | 0);
       var d$1 = d + 1 | 0, s1$0 = caml_check_bound(a, i1$0)[1 + i1$0];
       i1 = i1$0;
       s1 = s1$0;
       d = d$1;
      }
    }
    function isortto(srcofs, dst, dstofs, len){
     var _k_ = len - 1 | 0, _j_ = 0;
     if(_k_ >= 0){
      var i = _j_;
      for(;;){
       var
        _l_ = srcofs + i | 0,
        e = caml_check_bound(a, _l_)[1 + _l_],
        j = [0, (dstofs + i | 0) - 1 | 0];
       for(;;){
        if(dstofs > j[1]) break;
        var _m_ = j[1];
        if(0 >= caml_call2(cmp, caml_check_bound(dst, _m_)[1 + _m_], e))
         break;
        var
         _n_ = j[1],
         _o_ = caml_check_bound(dst, _n_)[1 + _n_],
         _p_ = j[1] + 1 | 0;
        caml_check_bound(dst, _p_)[1 + _p_] = _o_;
        j[1]--;
       }
       var _q_ = j[1] + 1 | 0;
       caml_check_bound(dst, _q_)[1 + _q_] = e;
       var _r_ = i + 1 | 0;
       if(_k_ === i) break;
       i = _r_;
      }
     }
     return 0;
    }
    function sortto(srcofs, dst, dstofs, len){
     if(len <= 5) return isortto(srcofs, dst, dstofs, len);
     var l1 = len / 2 | 0, l2 = len - l1 | 0;
     sortto(srcofs + l1 | 0, dst, dstofs + l1 | 0, l2);
     sortto(srcofs, a, srcofs + l2 | 0, l1);
     return merge(srcofs + l2 | 0, l1, dst, dstofs + l1 | 0, l2, dst, dstofs);
    }
    var l = a.length - 1;
    if(l <= 5) return isortto(0, a, 0, l);
    var
     l1 = l / 2 | 0,
     l2 = l - l1 | 0,
     t = caml_make_vect(l2, caml_check_bound(a, 0)[1]);
    sortto(l1, t, 0, l2);
    sortto(0, a, l2, l1);
    return merge(l2, l1, t, 0, l2, a, 0);
   }
   function to_seq(a){
    function aux(i, param){
     if(i >= a.length - 1) return 0;
     var x = a[1 + i], _h_ = i + 1 | 0;
     return [0, x, function(_i_){return aux(_h_, _i_);}];
    }
    var _f_ = 0;
    return function(_g_){return aux(_f_, _g_);};
   }
   function to_seqi(a){
    function aux(i, param){
     if(i >= a.length - 1) return 0;
     var x = a[1 + i], _d_ = i + 1 | 0;
     return [0, [0, i, x], function(_e_){return aux(_d_, _e_);}];
    }
    var _b_ = 0;
    return function(_c_){return aux(_b_, _c_);};
   }
   function of_seq(i$2){
    var
     l =
       caml_call3
        (Stdlib_Seq[5], function(acc, x){return [0, x, acc];}, 0, i$2);
    if(! l) return [0];
    var
     tl = l[2],
     hd = l[1],
     len = list_length(0, l),
     a = caml_make_vect(len, hd),
     i$1 = len - 2 | 0,
     i = i$1,
     param = tl;
    for(;;){
     if(! param) return a;
     var tl$0 = param[2], hd$0 = param[1];
     a[1 + i] = hd$0;
     var i$0 = i - 1 | 0;
     i = i$0;
     param = tl$0;
    }
   }
   var
    Stdlib_Array =
      [0,
       make_float,
       init,
       make_matrix,
       make_matrix,
       append,
       runtime.caml_array_concat,
       sub,
       copy,
       fill,
       blit,
       to_list,
       of_list,
       iter,
       iteri,
       map,
       mapi,
       fold_left,
       fold_left_map,
       fold_right,
       iter2,
       map2,
       for_all,
       exists,
       for_all2,
       exists2,
       mem,
       memq,
       find_opt,
       find_map,
       split,
       combine,
       sort,
       stable_sort,
       stable_sort,
       to_seq,
       to_seqi,
       of_seq,
       Floatarray];
   runtime.caml_register_global(14, Stdlib_Array, "Stdlib__Array");
   return;
  }
  (globalThis));

//# 7011 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_greaterequal = runtime.caml_greaterequal,
    caml_int_compare = runtime.caml_int_compare,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_mul = runtime.caml_mul,
    caml_wrap_exception = runtime.caml_wrap_exception,
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Stdlib_Sys = global_data.Stdlib__Sys,
    Assert_failure = global_data.Assert_failure,
    zero = 0,
    one = 1;
   function succ(n){return n + 1 | 0;}
   function pred(n){return n - 1 | 0;}
   function abs(n){return caml_greaterequal(n, 0) ? n : - n | 0;}
   function lognot(n){return n ^ -1;}
   var
    _a_ = Stdlib_Sys[9],
    _b_ = [0, "int32.ml", 69, 6],
    minus_one = -1,
    min_int = -2147483648,
    max_int = 2147483647;
   if(32 === _a_)
    var
     max_int$0 = Stdlib[19],
     unsigned_to_int =
       function(n){
        if(0 >= caml_int_compare(0, n) && 0 >= caml_int_compare(n, max_int$0))
         return [0, n];
        return 0;
       };
   else{
    if(64 !== _a_)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
    var unsigned_to_int = function(n){return [0, n & -1];};
   }
   function to_string(n){return runtime.caml_format_int("%d", n);}
   function of_string_opt(s){
    try{var _d_ = [0, runtime.caml_int_of_string(s)]; return _d_;}
    catch(_e_){
     var _c_ = caml_wrap_exception(_e_);
     if(_c_[1] === Stdlib[7]) return 0;
     throw caml_maybe_attach_backtrace(_c_, 0);
    }
   }
   var compare = caml_int_compare;
   function equal(x, y){return 0 === caml_int_compare(x, y) ? 1 : 0;}
   function unsigned_compare(n, m){
    var y = m + 2147483648 | 0, x = n + 2147483648 | 0;
    return caml_int_compare(x, y);
   }
   function min(x, y){return runtime.caml_lessequal(x, y) ? x : y;}
   function max(x, y){return caml_greaterequal(x, y) ? x : y;}
   function unsigned_div(n, d){
    if(runtime.caml_lessthan(d, 0))
     return 0 <= unsigned_compare(n, d) ? one : zero;
    var q = runtime.caml_div(n >>> 1 | 0, d) << 1, r = n - caml_mul(q, d) | 0;
    return 0 <= unsigned_compare(r, d) ? q + 1 | 0 : q;
   }
   function unsigned_rem(n, d){
    return n - caml_mul(unsigned_div(n, d), d) | 0;
   }
   var
    Stdlib_Int32 =
      [0,
       zero,
       one,
       minus_one,
       unsigned_div,
       unsigned_rem,
       succ,
       pred,
       abs,
       max_int,
       min_int,
       lognot,
       unsigned_to_int,
       of_string_opt,
       to_string,
       compare,
       unsigned_compare,
       equal,
       min,
       max];
   runtime.caml_register_global(14, Stdlib_Int32, "Stdlib__Int32");
   return;
  }
  (globalThis));

//# 7106 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_greaterequal = runtime.caml_greaterequal,
    caml_int64_add = runtime.caml_int64_add,
    caml_int64_compare = runtime.caml_int64_compare,
    caml_int64_mul = runtime.caml_int64_mul,
    caml_int64_sub = runtime.caml_int64_sub,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception,
    global_data = runtime.caml_get_global_data(),
    _a_ = runtime.caml_int64_create_lo_mi_hi(1, 0, 0),
    zero = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    one = runtime.caml_int64_create_lo_mi_hi(1, 0, 0),
    minus_one = runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 65535),
    min_int = runtime.caml_int64_create_lo_mi_hi(0, 0, 32768),
    max_int = runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 32767),
    Stdlib = global_data.Stdlib,
    _b_ = runtime.caml_int64_create_lo_mi_hi(1, 0, 0),
    _c_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    _d_ = runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 65535);
   function succ(n){return caml_int64_add(n, _a_);}
   function pred(n){return caml_int64_sub(n, _b_);}
   function abs(n){
    return caml_greaterequal(n, _c_) ? n : runtime.caml_int64_neg(n);
   }
   function lognot(n){return runtime.caml_int64_xor(n, _d_);}
   var max_int$0 = runtime.caml_int64_of_int32(Stdlib[19]);
   function unsigned_to_int(n){
    if
     (0 >= caml_int64_compare(zero, n)
      && 0 >= caml_int64_compare(n, max_int$0))
     return [0, runtime.caml_int64_to_int32(n)];
    return 0;
   }
   function to_string(n){return runtime.caml_int64_format("%d", n);}
   function of_string_opt(s){
    try{var _f_ = [0, runtime.caml_int64_of_string(s)]; return _f_;}
    catch(_g_){
     var _e_ = caml_wrap_exception(_g_);
     if(_e_[1] === Stdlib[7]) return 0;
     throw caml_maybe_attach_backtrace(_e_, 0);
    }
   }
   function compare(x, y){return caml_int64_compare(x, y);}
   function equal(x, y){return 0 === caml_int64_compare(x, y) ? 1 : 0;}
   function unsigned_compare(n, m){
    var y = caml_int64_sub(m, min_int), x = caml_int64_sub(n, min_int);
    return caml_int64_compare(x, y);
   }
   function min(x, y){return runtime.caml_lessequal(x, y) ? x : y;}
   function max(x, y){return caml_greaterequal(x, y) ? x : y;}
   function unsigned_div(n, d){
    if(runtime.caml_lessthan(d, zero))
     return 0 <= unsigned_compare(n, d) ? one : zero;
    var
     q =
       runtime.caml_int64_shift_left
        (runtime.caml_int64_div
          (runtime.caml_int64_shift_right_unsigned(n, 1), d),
         1),
     r = caml_int64_sub(n, caml_int64_mul(q, d));
    return 0 <= unsigned_compare(r, d) ? caml_int64_add(q, _a_) : q;
   }
   function unsigned_rem(n, d){
    return caml_int64_sub(n, caml_int64_mul(unsigned_div(n, d), d));
   }
   var
    Stdlib_Int64 =
      [0,
       zero,
       one,
       minus_one,
       unsigned_div,
       unsigned_rem,
       succ,
       pred,
       abs,
       max_int,
       min_int,
       lognot,
       unsigned_to_int,
       of_string_opt,
       to_string,
       compare,
       unsigned_compare,
       equal,
       min,
       max];
   runtime.caml_register_global(11, Stdlib_Int64, "Stdlib__Int64");
   return;
  }
  (globalThis));

//# 7204 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_greaterequal = runtime.caml_greaterequal,
    caml_int_compare = runtime.caml_int_compare,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_mul = runtime.caml_mul,
    caml_wrap_exception = runtime.caml_wrap_exception,
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Stdlib_Sys = global_data.Stdlib__Sys,
    zero = 0,
    one = 1;
   function succ(n){return n + 1 | 0;}
   function pred(n){return n - 1 | 0;}
   function abs(n){return caml_greaterequal(n, 0) ? n : - n | 0;}
   var
    size = Stdlib_Sys[9],
    min_int = 1 << (size - 1 | 0),
    max_int = min_int - 1 | 0;
   function lognot(n){return n ^ -1;}
   var max_int$0 = Stdlib[19];
   function unsigned_to_int(n){
    if(0 >= caml_int_compare(0, n) && 0 >= caml_int_compare(n, max_int$0))
     return [0, n];
    return 0;
   }
   function to_string(n){return runtime.caml_format_int("%d", n);}
   function of_string_opt(s){
    try{var _b_ = [0, runtime.caml_int_of_string(s)]; return _b_;}
    catch(_c_){
     var _a_ = caml_wrap_exception(_c_);
     if(_a_[1] === Stdlib[7]) return 0;
     throw caml_maybe_attach_backtrace(_a_, 0);
    }
   }
   var compare = caml_int_compare;
   function equal(x, y){return 0 === caml_int_compare(x, y) ? 1 : 0;}
   function unsigned_compare(n, m){
    var y = m - min_int | 0, x = n - min_int | 0;
    return caml_int_compare(x, y);
   }
   function min(x, y){return runtime.caml_lessequal(x, y) ? x : y;}
   function max(x, y){return caml_greaterequal(x, y) ? x : y;}
   function unsigned_div(n, d){
    if(runtime.caml_lessthan(d, 0))
     return 0 <= unsigned_compare(n, d) ? one : zero;
    var q = runtime.caml_div(n >>> 1 | 0, d) << 1, r = n - caml_mul(q, d) | 0;
    return 0 <= unsigned_compare(r, d) ? q + 1 | 0 : q;
   }
   function unsigned_rem(n, d){
    return n - caml_mul(unsigned_div(n, d), d) | 0;
   }
   var
    Stdlib_Nativeint =
      [0,
       zero,
       one,
       -1,
       unsigned_div,
       unsigned_rem,
       succ,
       pred,
       abs,
       size,
       max_int,
       min_int,
       lognot,
       unsigned_to_int,
       of_string_opt,
       to_string,
       compare,
       unsigned_compare,
       equal,
       min,
       max];
   runtime.caml_register_global(12, Stdlib_Nativeint, "Stdlib__Nativeint");
   return;
  }
  (globalThis));

//# 8582 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Map_bal$3 = "Map.bal",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Seq = global_data.Stdlib__Seq,
    cst_Map_bal = cst_Map_bal$3,
    cst_Map_bal$0 = cst_Map_bal$3,
    cst_Map_bal$1 = cst_Map_bal$3,
    cst_Map_bal$2 = cst_Map_bal$3,
    cst_Map_remove_min_elt = "Map.remove_min_elt",
    _a_ = [0, 0, 0, 0],
    _b_ = [0, "map.ml", 400, 10],
    _c_ = [0, 0, 0],
    Stdlib_Map =
      [0,
       function(Ord){
        function height(param){
         if(! param) return 0;
         var h = param[5];
         return h;
        }
        function create(l, x, d, r){
         var
          hl = height(l),
          hr = height(r),
          _K_ = hr <= hl ? hl + 1 | 0 : hr + 1 | 0;
         return [0, l, x, d, r, _K_];
        }
        function singleton(x, d){return [0, 0, x, d, 0, 1];}
        function bal(l, x, d, r){
         if(l) var h = l[5], hl = h; else var hl = 0;
         if(r) var h$0 = r[5], hr = h$0; else var hr = 0;
         if((hr + 2 | 0) < hl){
          if(! l) return caml_call1(Stdlib[1], cst_Map_bal$0);
          var lr = l[4], ld = l[3], lv = l[2], ll = l[1], _F_ = height(lr);
          if(_F_ <= height(ll))
           return create(ll, lv, ld, create(lr, x, d, r));
          if(! lr) return caml_call1(Stdlib[1], cst_Map_bal);
          var
           lrr = lr[4],
           lrd = lr[3],
           lrv = lr[2],
           lrl = lr[1],
           _G_ = create(lrr, x, d, r);
          return create(create(ll, lv, ld, lrl), lrv, lrd, _G_);
         }
         if((hl + 2 | 0) >= hr){
          var _J_ = hr <= hl ? hl + 1 | 0 : hr + 1 | 0;
          return [0, l, x, d, r, _J_];
         }
         if(! r) return caml_call1(Stdlib[1], cst_Map_bal$2);
         var rr = r[4], rd = r[3], rv = r[2], rl = r[1], _H_ = height(rl);
         if(_H_ <= height(rr)) return create(create(l, x, d, rl), rv, rd, rr);
         if(! rl) return caml_call1(Stdlib[1], cst_Map_bal$1);
         var
          rlr = rl[4],
          rld = rl[3],
          rlv = rl[2],
          rll = rl[1],
          _I_ = create(rlr, rv, rd, rr);
         return create(create(l, x, d, rll), rlv, rld, _I_);
        }
        var empty = 0;
        function is_empty(param){return param ? 0 : 1;}
        function add(x, data, m){
         if(! m) return [0, 0, x, data, 0, 1];
         var
          h = m[5],
          r = m[4],
          d = m[3],
          v = m[2],
          l = m[1],
          c = caml_call2(Ord[1], x, v);
         if(0 === c) return d === data ? m : [0, l, x, data, r, h];
         if(0 <= c){
          var rr = add(x, data, r);
          return r === rr ? m : bal(l, v, d, rr);
         }
         var ll = add(x, data, l);
         return l === ll ? m : bal(ll, v, d, r);
        }
        function find(x, param){
         var param$0 = param;
         for(;;){
          if(! param$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
          var
           r = param$0[4],
           d = param$0[3],
           v = param$0[2],
           l = param$0[1],
           c = caml_call2(Ord[1], x, v);
          if(0 === c) return d;
          var r$0 = 0 <= c ? r : l;
          param$0 = r$0;
         }
        }
        function find_first(f, param$0){
         var param$1 = param$0;
         for(;;){
          if(! param$1) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
          var
           r$0 = param$1[4],
           d0$1 = param$1[3],
           v0$1 = param$1[2],
           l$0 = param$1[1];
          if(caml_call1(f, v0$1)){
           var v0 = v0$1, d0 = d0$1, param = l$0;
           for(;;){
            if(! param) return [0, v0, d0];
            var r = param[4], d0$0 = param[3], v0$0 = param[2], l = param[1];
            if(caml_call1(f, v0$0)){
             v0 = v0$0;
             d0 = d0$0;
             param = l;
            }
            else
             param = r;
           }
          }
          else
           param$1 = r$0;
         }
        }
        function find_first_opt(f, param$0){
         var param$1 = param$0;
         for(;;){
          if(! param$1) return 0;
          var
           r$0 = param$1[4],
           d0$1 = param$1[3],
           v0$1 = param$1[2],
           l$0 = param$1[1];
          if(caml_call1(f, v0$1)){
           var v0 = v0$1, d0 = d0$1, param = l$0;
           for(;;){
            if(! param) return [0, [0, v0, d0]];
            var r = param[4], d0$0 = param[3], v0$0 = param[2], l = param[1];
            if(caml_call1(f, v0$0)){
             v0 = v0$0;
             d0 = d0$0;
             param = l;
            }
            else
             param = r;
           }
          }
          else
           param$1 = r$0;
         }
        }
        function find_last(f, param$0){
         var param$1 = param$0;
         for(;;){
          if(! param$1) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
          var
           r$0 = param$1[4],
           d0$1 = param$1[3],
           v0$1 = param$1[2],
           l$0 = param$1[1];
          if(caml_call1(f, v0$1)){
           var v0 = v0$1, d0 = d0$1, param = r$0;
           for(;;){
            if(! param) return [0, v0, d0];
            var r = param[4], d0$0 = param[3], v0$0 = param[2], l = param[1];
            if(caml_call1(f, v0$0)){
             v0 = v0$0;
             d0 = d0$0;
             param = r;
            }
            else
             param = l;
           }
          }
          else
           param$1 = l$0;
         }
        }
        function find_last_opt(f, param$0){
         var param$1 = param$0;
         for(;;){
          if(! param$1) return 0;
          var
           r$0 = param$1[4],
           d0$1 = param$1[3],
           v0$1 = param$1[2],
           l$0 = param$1[1];
          if(caml_call1(f, v0$1)){
           var v0 = v0$1, d0 = d0$1, param = r$0;
           for(;;){
            if(! param) return [0, [0, v0, d0]];
            var r = param[4], d0$0 = param[3], v0$0 = param[2], l = param[1];
            if(caml_call1(f, v0$0)){
             v0 = v0$0;
             d0 = d0$0;
             param = r;
            }
            else
             param = l;
           }
          }
          else
           param$1 = l$0;
         }
        }
        function find_opt(x, param){
         var param$0 = param;
         for(;;){
          if(! param$0) return 0;
          var
           r = param$0[4],
           d = param$0[3],
           v = param$0[2],
           l = param$0[1],
           c = caml_call2(Ord[1], x, v);
          if(0 === c) return [0, d];
          var r$0 = 0 <= c ? r : l;
          param$0 = r$0;
         }
        }
        function mem(x, param){
         var param$0 = param;
         for(;;){
          if(! param$0) return 0;
          var
           r = param$0[4],
           v = param$0[2],
           l = param$0[1],
           c = caml_call2(Ord[1], x, v),
           _E_ = 0 === c ? 1 : 0;
          if(_E_) return _E_;
          var r$0 = 0 <= c ? r : l;
          param$0 = r$0;
         }
        }
        function min_binding(param){
         var param$0 = param;
         for(;;){
          if(! param$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
          var l = param$0[1];
          if(! l){var d = param$0[3], v = param$0[2]; return [0, v, d];}
          param$0 = l;
         }
        }
        function min_binding_opt(param){
         var param$0 = param;
         for(;;){
          if(! param$0) return 0;
          var l = param$0[1];
          if(! l){var d = param$0[3], v = param$0[2]; return [0, [0, v, d]];}
          param$0 = l;
         }
        }
        function max_binding(param){
         var param$0 = param;
         for(;;){
          if(! param$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
          if(! param$0[4]){
           var d = param$0[3], v = param$0[2];
           return [0, v, d];
          }
          var r = param$0[4];
          param$0 = r;
         }
        }
        function max_binding_opt(param){
         var param$0 = param;
         for(;;){
          if(! param$0) return 0;
          if(! param$0[4]){
           var d = param$0[3], v = param$0[2];
           return [0, [0, v, d]];
          }
          var r = param$0[4];
          param$0 = r;
         }
        }
        function remove_min_binding(param){
         if(! param) return caml_call1(Stdlib[1], cst_Map_remove_min_elt);
         var l = param[1];
         if(l){
          var r = param[4], d = param[3], v = param[2];
          return bal(remove_min_binding(l), v, d, r);
         }
         var r$0 = param[4];
         return r$0;
        }
        function _d_(t1, t2){
         if(! t1) return t2;
         if(! t2) return t1;
         var match = min_binding(t2), d = match[2], x = match[1];
         return bal(t1, x, d, remove_min_binding(t2));
        }
        function remove(x, m){
         if(! m) return 0;
         var
          r = m[4],
          d = m[3],
          v = m[2],
          l = m[1],
          c = caml_call2(Ord[1], x, v);
         if(0 === c) return _d_(l, r);
         if(0 <= c){
          var rr = remove(x, r);
          return r === rr ? m : bal(l, v, d, rr);
         }
         var ll = remove(x, l);
         return l === ll ? m : bal(ll, v, d, r);
        }
        function update(x, f, m){
         if(! m){
          var match$0 = caml_call1(f, 0);
          if(! match$0) return 0;
          var data$0 = match$0[1];
          return [0, 0, x, data$0, 0, 1];
         }
         var
          h = m[5],
          r = m[4],
          d = m[3],
          v = m[2],
          l = m[1],
          c = caml_call2(Ord[1], x, v);
         if(0 === c){
          var match = caml_call1(f, [0, d]);
          if(! match) return _d_(l, r);
          var data = match[1];
          return d === data ? m : [0, l, x, data, r, h];
         }
         if(0 <= c){
          var rr = update(x, f, r);
          return r === rr ? m : bal(l, v, d, rr);
         }
         var ll = update(x, f, l);
         return l === ll ? m : bal(ll, v, d, r);
        }
        function iter(f, param){
         var param$0 = param;
         for(;;){
          if(! param$0) return 0;
          var r = param$0[4], d = param$0[3], v = param$0[2], l = param$0[1];
          iter(f, l);
          caml_call2(f, v, d);
          param$0 = r;
         }
        }
        function map(f, param){
         if(! param) return 0;
         var
          h = param[5],
          r = param[4],
          d = param[3],
          v = param[2],
          l = param[1],
          l$0 = map(f, l),
          d$0 = caml_call1(f, d),
          r$0 = map(f, r);
         return [0, l$0, v, d$0, r$0, h];
        }
        function mapi(f, param){
         if(! param) return 0;
         var
          h = param[5],
          r = param[4],
          d = param[3],
          v = param[2],
          l = param[1],
          l$0 = mapi(f, l),
          d$0 = caml_call2(f, v, d),
          r$0 = mapi(f, r);
         return [0, l$0, v, d$0, r$0, h];
        }
        function fold(f, m, accu){
         var m$0 = m, accu$0 = accu;
         for(;;){
          if(! m$0) return accu$0;
          var
           r = m$0[4],
           d = m$0[3],
           v = m$0[2],
           l = m$0[1],
           accu$1 = caml_call3(f, v, d, fold(f, l, accu$0));
          m$0 = r;
          accu$0 = accu$1;
         }
        }
        function for_all(p, param){
         var param$0 = param;
         for(;;){
          if(! param$0) return 1;
          var
           r = param$0[4],
           d = param$0[3],
           v = param$0[2],
           l = param$0[1],
           _B_ = caml_call2(p, v, d);
          if(_B_){
           var _C_ = for_all(p, l);
           if(_C_){param$0 = r; continue;}
           var _D_ = _C_;
          }
          else
           var _D_ = _B_;
          return _D_;
         }
        }
        function exists(p, param){
         var param$0 = param;
         for(;;){
          if(! param$0) return 0;
          var
           r = param$0[4],
           d = param$0[3],
           v = param$0[2],
           l = param$0[1],
           _y_ = caml_call2(p, v, d);
          if(_y_)
           var _z_ = _y_;
          else{
           var _A_ = exists(p, l);
           if(! _A_){param$0 = r; continue;}
           var _z_ = _A_;
          }
          return _z_;
         }
        }
        function add_min_binding(k, x, param){
         if(! param) return singleton(k, x);
         var r = param[4], d = param[3], v = param[2], l = param[1];
         return bal(add_min_binding(k, x, l), v, d, r);
        }
        function add_max_binding(k, x, param){
         if(! param) return singleton(k, x);
         var r = param[4], d = param[3], v = param[2], l = param[1];
         return bal(l, v, d, add_max_binding(k, x, r));
        }
        function join(l, v, d, r){
         if(! l) return add_min_binding(v, d, r);
         if(! r) return add_max_binding(v, d, l);
         var
          rh = r[5],
          rr = r[4],
          rd = r[3],
          rv = r[2],
          rl = r[1],
          lh = l[5],
          lr = l[4],
          ld = l[3],
          lv = l[2],
          ll = l[1];
         return (rh + 2 | 0) < lh
                 ? bal(ll, lv, ld, join(lr, v, d, r))
                 : (lh
                   + 2
                   | 0)
                   < rh
                   ? bal(join(l, v, d, rl), rv, rd, rr)
                   : create(l, v, d, r);
        }
        function concat(t1, t2){
         if(! t1) return t2;
         if(! t2) return t1;
         var match = min_binding(t2), d = match[2], x = match[1];
         return join(t1, x, d, remove_min_binding(t2));
        }
        function concat_or_join(t1, v, d, t2){
         if(! d) return concat(t1, t2);
         var d$0 = d[1];
         return join(t1, v, d$0, t2);
        }
        function split(x, param){
         if(! param) return _a_;
         var
          r = param[4],
          d = param[3],
          v = param[2],
          l = param[1],
          c = caml_call2(Ord[1], x, v);
         if(0 === c) return [0, l, [0, d], r];
         if(0 <= c){
          var
           match = split(x, r),
           rr = match[3],
           pres = match[2],
           lr = match[1];
          return [0, join(l, v, d, lr), pres, rr];
         }
         var
          match$0 = split(x, l),
          rl = match$0[3],
          pres$0 = match$0[2],
          ll = match$0[1];
         return [0, ll, pres$0, join(rl, v, d, r)];
        }
        function merge(f, s1, s2){
         if(s1){
          var h1 = s1[5], r1 = s1[4], d1 = s1[3], v1 = s1[2], l1 = s1[1];
          if(height(s2) <= h1){
           var
            match = split(v1, s2),
            r2 = match[3],
            d2 = match[2],
            l2 = match[1],
            _u_ = merge(f, r1, r2),
            _v_ = caml_call3(f, v1, [0, d1], d2);
           return concat_or_join(merge(f, l1, l2), v1, _v_, _u_);
          }
         }
         else if(! s2) return 0;
         if(! s2)
          throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
         var
          r2$0 = s2[4],
          d2$0 = s2[3],
          v2 = s2[2],
          l2$0 = s2[1],
          match$0 = split(v2, s1),
          r1$0 = match$0[3],
          d1$0 = match$0[2],
          l1$0 = match$0[1],
          _w_ = merge(f, r1$0, r2$0),
          _x_ = caml_call3(f, v2, d1$0, [0, d2$0]);
         return concat_or_join(merge(f, l1$0, l2$0), v2, _x_, _w_);
        }
        function union(f, s1, s2){
         if(s1){
          if(s2){
           var
            h2 = s2[5],
            r2 = s2[4],
            d2 = s2[3],
            v2 = s2[2],
            l2 = s2[1],
            h1 = s1[5],
            r1 = s1[4],
            d1 = s1[3],
            v1 = s1[2],
            l1 = s1[1];
           if(h2 <= h1){
            var
             match = split(v1, s2),
             r2$0 = match[3],
             d2$0 = match[2],
             l2$0 = match[1],
             l = union(f, l1, l2$0),
             r = union(f, r1, r2$0);
            if(! d2$0) return join(l, v1, d1, r);
            var d2$1 = d2$0[1];
            return concat_or_join(l, v1, caml_call3(f, v1, d1, d2$1), r);
           }
           var
            match$0 = split(v2, s1),
            r1$0 = match$0[3],
            d1$0 = match$0[2],
            l1$0 = match$0[1],
            l$0 = union(f, l1$0, l2),
            r$0 = union(f, r1$0, r2);
           if(! d1$0) return join(l$0, v2, d2, r$0);
           var d1$1 = d1$0[1];
           return concat_or_join(l$0, v2, caml_call3(f, v2, d1$1, d2), r$0);
          }
          var s = s1;
         }
         else
          var s = s2;
         return s;
        }
        function filter(p, m){
         if(! m) return 0;
         var
          r = m[4],
          d = m[3],
          v = m[2],
          l = m[1],
          l$0 = filter(p, l),
          pvd = caml_call2(p, v, d),
          r$0 = filter(p, r);
         if(! pvd) return concat(l$0, r$0);
         if(l === l$0 && r === r$0) return m;
         return join(l$0, v, d, r$0);
        }
        function filter_map(f, param){
         if(! param) return 0;
         var
          r = param[4],
          d = param[3],
          v = param[2],
          l = param[1],
          l$0 = filter_map(f, l),
          fvd = caml_call2(f, v, d),
          r$0 = filter_map(f, r);
         if(! fvd) return concat(l$0, r$0);
         var d$0 = fvd[1];
         return join(l$0, v, d$0, r$0);
        }
        function partition(p, param){
         if(! param) return _c_;
         var
          r = param[4],
          d = param[3],
          v = param[2],
          l = param[1],
          match = partition(p, l),
          lf = match[2],
          lt = match[1],
          pvd = caml_call2(p, v, d),
          match$0 = partition(p, r),
          rf = match$0[2],
          rt = match$0[1];
         if(pvd){
          var _s_ = concat(lf, rf);
          return [0, join(lt, v, d, rt), _s_];
         }
         var _t_ = join(lf, v, d, rf);
         return [0, concat(lt, rt), _t_];
        }
        function cons_enum(m, e){
         var m$0 = m, e$0 = e;
         for(;;){
          if(! m$0) return e$0;
          var
           r = m$0[4],
           d = m$0[3],
           v = m$0[2],
           l = m$0[1],
           e$1 = [0, v, d, r, e$0];
          m$0 = l;
          e$0 = e$1;
         }
        }
        function compare(cmp, m1, m2){
         var
          e2$2 = cons_enum(m2, 0),
          e1$2 = cons_enum(m1, 0),
          e1 = e1$2,
          e2 = e2$2;
         for(;;){
          if(! e1) return e2 ? -1 : 0;
          if(! e2) return 1;
          var
           e2$0 = e2[4],
           r2 = e2[3],
           d2 = e2[2],
           v2 = e2[1],
           e1$0 = e1[4],
           r1 = e1[3],
           d1 = e1[2],
           v1 = e1[1],
           c = caml_call2(Ord[1], v1, v2);
          if(0 !== c) return c;
          var c$0 = caml_call2(cmp, d1, d2);
          if(0 !== c$0) return c$0;
          var e2$1 = cons_enum(r2, e2$0), e1$1 = cons_enum(r1, e1$0);
          e1 = e1$1;
          e2 = e2$1;
         }
        }
        function equal(cmp, m1, m2){
         var
          e2$2 = cons_enum(m2, 0),
          e1$2 = cons_enum(m1, 0),
          e1 = e1$2,
          e2 = e2$2;
         for(;;){
          if(! e1) return e2 ? 0 : 1;
          if(! e2) return 0;
          var
           e2$0 = e2[4],
           r2 = e2[3],
           d2 = e2[2],
           v2 = e2[1],
           e1$0 = e1[4],
           r1 = e1[3],
           d1 = e1[2],
           v1 = e1[1],
           _p_ = 0 === caml_call2(Ord[1], v1, v2) ? 1 : 0;
          if(_p_){
           var _q_ = caml_call2(cmp, d1, d2);
           if(_q_){
            var e2$1 = cons_enum(r2, e2$0), e1$1 = cons_enum(r1, e1$0);
            e1 = e1$1;
            e2 = e2$1;
            continue;
           }
           var _r_ = _q_;
          }
          else
           var _r_ = _p_;
          return _r_;
         }
        }
        function cardinal(param){
         if(! param) return 0;
         var r = param[4], l = param[1], _o_ = cardinal(r);
         return (cardinal(l) + 1 | 0) + _o_ | 0;
        }
        function bindings_aux(accu, param){
         var accu$0 = accu, param$0 = param;
         for(;;){
          if(! param$0) return accu$0;
          var
           r = param$0[4],
           d = param$0[3],
           v = param$0[2],
           l = param$0[1],
           accu$1 = [0, [0, v, d], bindings_aux(accu$0, r)];
          accu$0 = accu$1;
          param$0 = l;
         }
        }
        function bindings(s){return bindings_aux(0, s);}
        function add_seq(i, m){
         return caml_call3
                 (Stdlib_Seq[5],
                  function(m, param){
                   var v = param[2], k = param[1];
                   return add(k, v, m);
                  },
                  m,
                  i);
        }
        function of_seq(i){return add_seq(i, empty);}
        function seq_of_enum(c, param){
         if(! c) return 0;
         var
          rest = c[4],
          t = c[3],
          v = c[2],
          k = c[1],
          _m_ = cons_enum(t, rest);
         return [0, [0, k, v], function(_n_){return seq_of_enum(_m_, _n_);}];
        }
        function to_seq(m){
         var _k_ = cons_enum(m, 0);
         return function(_l_){return seq_of_enum(_k_, _l_);};
        }
        function snoc_enum(s, e){
         var s$0 = s, e$0 = e;
         for(;;){
          if(! s$0) return e$0;
          var
           r = s$0[4],
           d = s$0[3],
           v = s$0[2],
           l = s$0[1],
           e$1 = [0, v, d, l, e$0];
          s$0 = r;
          e$0 = e$1;
         }
        }
        function rev_seq_of_enum(c, param){
         if(! c) return 0;
         var
          rest = c[4],
          t = c[3],
          v = c[2],
          k = c[1],
          _i_ = snoc_enum(t, rest);
         return [0,
                 [0, k, v],
                 function(_j_){return rev_seq_of_enum(_i_, _j_);}];
        }
        function to_rev_seq(c){
         var _g_ = snoc_enum(c, 0);
         return function(_h_){return rev_seq_of_enum(_g_, _h_);};
        }
        function to_seq_from(low, m){
         a:
         {
          b:
          {
           var m$0 = m, c = 0;
           for(;;){
            if(! m$0) break;
            var
             r = m$0[4],
             d = m$0[3],
             v = m$0[2],
             l = m$0[1],
             n = caml_call2(Ord[1], v, low);
            if(0 === n) break b;
            if(0 <= n){
             var c$0 = [0, v, d, r, c];
             m$0 = l;
             c = c$0;
            }
            else
             m$0 = r;
           }
           var _e_ = c;
           break a;
          }
          var _e_ = [0, v, d, r, c];
         }
         return function(_f_){return seq_of_enum(_e_, _f_);};
        }
        return [0,
                empty,
                is_empty,
                mem,
                add,
                update,
                singleton,
                remove,
                merge,
                union,
                compare,
                equal,
                iter,
                fold,
                for_all,
                exists,
                filter,
                filter_map,
                partition,
                cardinal,
                bindings,
                min_binding,
                min_binding_opt,
                max_binding,
                max_binding_opt,
                min_binding,
                min_binding_opt,
                split,
                find,
                find_opt,
                find_first,
                find_first_opt,
                find_last,
                find_last_opt,
                map,
                mapi,
                to_seq,
                to_rev_seq,
                to_seq_from,
                add_seq,
                of_seq];
       }];
   runtime.caml_register_global(11, Stdlib_Map, "Stdlib__Map");
   return;
  }
  (globalThis));

//# 9448 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Seq = global_data.Stdlib__Seq,
    Stdlib_List = global_data.Stdlib__List,
    Empty = [248, "Stdlib.Stack.Empty", runtime.caml_fresh_oo_id(0)];
   function create(param){return [0, 0, 0];}
   function clear(s){s[1] = 0; s[2] = 0; return 0;}
   function copy(s){return [0, s[1], s[2]];}
   function push(x, s){s[1] = [0, x, s[1]]; s[2] = s[2] + 1 | 0; return 0;}
   function pop(s){
    var match = s[1];
    if(! match) throw caml_maybe_attach_backtrace(Empty, 1);
    var tl = match[2], hd = match[1];
    s[1] = tl;
    s[2] = s[2] - 1 | 0;
    return hd;
   }
   function pop_opt(s){
    var match = s[1];
    if(! match) return 0;
    var tl = match[2], hd = match[1];
    s[1] = tl;
    s[2] = s[2] - 1 | 0;
    return [0, hd];
   }
   function top(s){
    var match = s[1];
    if(! match) throw caml_maybe_attach_backtrace(Empty, 1);
    var hd = match[1];
    return hd;
   }
   function top_opt(s){
    var match = s[1];
    if(! match) return 0;
    var hd = match[1];
    return [0, hd];
   }
   function is_empty(s){return 0 === s[1] ? 1 : 0;}
   function length(s){return s[2];}
   function iter(f, s){return caml_call2(Stdlib_List[17], f, s[1]);}
   function fold(f, acc, s){return caml_call3(Stdlib_List[25], f, acc, s[1]);}
   function to_seq(s){return caml_call1(Stdlib_List[61], s[1]);}
   function add_seq(q, i){
    return caml_call2(Stdlib_Seq[4], function(x){return push(x, q);}, i);
   }
   function of_seq(g){var s = create(0); add_seq(s, g); return s;}
   var
    Stdlib_Stack =
      [0,
       Empty,
       create,
       push,
       pop,
       pop_opt,
       top,
       top_opt,
       clear,
       copy,
       is_empty,
       length,
       iter,
       fold,
       to_seq,
       add_seq,
       of_seq];
   runtime.caml_register_global(3, Stdlib_Stack, "Stdlib__Stack");
   return;
  }
  (globalThis));

//# 9541 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Seq = global_data.Stdlib__Seq,
    Empty = [248, "Stdlib.Queue.Empty", runtime.caml_fresh_oo_id(0)];
   function create(param){return [0, 0, 0, 0];}
   function clear(q){q[1] = 0; q[2] = 0; q[3] = 0; return 0;}
   function add(x, q){
    var cell = [0, x, 0], match = q[3];
    return match
            ? (q[1] = q[1] + 1 | 0, match[2] = cell, q[3] = cell, 0)
            : (q[1] = 1, q[2] = cell, q[3] = cell, 0);
   }
   function peek(q){
    var match = q[2];
    if(! match) throw caml_maybe_attach_backtrace(Empty, 1);
    var content = match[1];
    return content;
   }
   function peek_opt(q){
    var match = q[2];
    if(! match) return 0;
    var content = match[1];
    return [0, content];
   }
   function take(q){
    var _f_ = q[2];
    if(! _f_) throw caml_maybe_attach_backtrace(Empty, 1);
    var content = _f_[1];
    if(_f_[2]){
     var next = _f_[2];
     q[1] = q[1] - 1 | 0;
     q[2] = next;
     return content;
    }
    clear(q);
    return content;
   }
   function take_opt(q){
    var _e_ = q[2];
    if(! _e_) return 0;
    var content = _e_[1];
    if(_e_[2]){
     var next = _e_[2];
     q[1] = q[1] - 1 | 0;
     q[2] = next;
     return [0, content];
    }
    clear(q);
    return [0, content];
   }
   function copy(q){
    var cell$0 = q[2], q_res = [0, q[1], 0, 0], prev = 0, cell = cell$0;
    for(;;){
     if(! cell){q_res[3] = prev; return q_res;}
     var content = cell[1], next = cell[2], prev$0 = [0, content, 0];
     if(prev) prev[2] = prev$0; else q_res[2] = prev$0;
     prev = prev$0;
     cell = next;
    }
   }
   function is_empty(q){return 0 === q[1] ? 1 : 0;}
   function length(q){return q[1];}
   function iter(f, q){
    var cell$0 = q[2], cell = cell$0;
    for(;;){
     if(! cell) return 0;
     var content = cell[1], next = cell[2];
     caml_call1(f, content);
     cell = next;
    }
   }
   function fold(f, accu$1, q){
    var cell$0 = q[2], accu = accu$1, cell = cell$0;
    for(;;){
     if(! cell) return accu;
     var
      content = cell[1],
      next = cell[2],
      accu$0 = caml_call2(f, accu, content);
     accu = accu$0;
     cell = next;
    }
   }
   function transfer(q1, q2){
    var _d_ = 0 < q1[1] ? 1 : 0;
    if(! _d_) return _d_;
    var match = q2[3];
    return match
            ? (q2
               [1]
              = q2[1] + q1[1] | 0,
              match[2] = q1[2],
              q2[3] = q1[3],
              clear(q1))
            : (q2[1] = q1[1], q2[2] = q1[2], q2[3] = q1[3], clear(q1));
   }
   function to_seq(q){
    function aux(c, param){
     if(! c) return 0;
     var x = c[1], next = c[2];
     return [0, x, function(_c_){return aux(next, _c_);}];
    }
    var _a_ = q[2];
    return function(_b_){return aux(_a_, _b_);};
   }
   function add_seq(q, i){
    return caml_call2(Stdlib_Seq[4], function(x){return add(x, q);}, i);
   }
   function of_seq(g){var q = create(0); add_seq(q, g); return q;}
   var
    Stdlib_Queue =
      [0,
       Empty,
       create,
       add,
       add,
       take,
       take_opt,
       take,
       peek,
       peek_opt,
       peek,
       clear,
       copy,
       is_empty,
       length,
       iter,
       fold,
       transfer,
       to_seq,
       add_seq,
       of_seq];
   runtime.caml_register_global(2, Stdlib_Queue, "Stdlib__Queue");
   return;
  }
  (globalThis));

//# 10064 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_buffer_ml = "buffer.ml",
    caml_blit_string = runtime.caml_blit_string,
    caml_bswap16 = runtime.caml_bswap16,
    caml_bytes_unsafe_get = runtime.caml_bytes_unsafe_get,
    caml_bytes_unsafe_set = runtime.caml_bytes_unsafe_set,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_int32_bswap = runtime.caml_int32_bswap,
    caml_int64_bswap = runtime.caml_int64_bswap,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_bytes_length = runtime.caml_ml_bytes_length,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_get = runtime.caml_string_get;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Stdlib_Sys = global_data.Stdlib__Sys,
    Stdlib_Seq = global_data.Stdlib__Seq,
    Stdlib = global_data.Stdlib,
    Stdlib_String = global_data.Stdlib__String,
    Assert_failure = global_data.Assert_failure,
    cst_Buffer_sub = "Buffer.sub",
    cst_Buffer_blit = "Buffer.blit",
    cst_Buffer_nth = "Buffer.nth",
    _a_ = [0, cst_buffer_ml, 94, 2],
    _b_ = [0, cst_buffer_ml, 93, 2],
    cst_Buffer_add_cannot_grow_buf = "Buffer.add: cannot grow buffer";
   function create(n){
    var
     n$0 = 1 <= n ? n : 1,
     n$1 = Stdlib_Sys[12] < n$0 ? Stdlib_Sys[12] : n$0,
     s = caml_create_bytes(n$1);
    return [0, s, 0, n$1, s];
   }
   function contents(b){return caml_call3(Stdlib_Bytes[8], b[1], 0, b[2]);}
   function to_bytes(b){return caml_call3(Stdlib_Bytes[7], b[1], 0, b[2]);}
   function sub(b, ofs, len){
    if(0 <= ofs && 0 <= len && (b[2] - len | 0) >= ofs)
     return caml_call3(Stdlib_Bytes[8], b[1], ofs, len);
    return caml_call1(Stdlib[1], cst_Buffer_sub);
   }
   function blit(src, srcoff, dst, dstoff, len){
    if
     (0 <= len
      &&
       0 <= srcoff
       &&
        (src[2] - len | 0) >= srcoff
        && 0 <= dstoff && (caml_ml_bytes_length(dst) - len | 0) >= dstoff)
     return runtime.caml_blit_bytes(src[1], srcoff, dst, dstoff, len);
    return caml_call1(Stdlib[1], cst_Buffer_blit);
   }
   function nth(b, ofs){
    if(0 <= ofs && b[2] > ofs) return caml_bytes_unsafe_get(b[1], ofs);
    return caml_call1(Stdlib[1], cst_Buffer_nth);
   }
   function length(b){return b[2];}
   function clear(b){b[2] = 0; return 0;}
   function reset(b){
    b[2] = 0;
    b[1] = b[4];
    b[3] = caml_ml_bytes_length(b[1]);
    return 0;
   }
   function resize(b, more){
    var old_pos = b[2], old_len = b[3], new_len = [0, old_len];
    for(;;){
     if(new_len[1] >= (old_pos + more | 0)) break;
     new_len[1] = 2 * new_len[1] | 0;
    }
    if(Stdlib_Sys[12] < new_len[1])
     if((old_pos + more | 0) <= Stdlib_Sys[12])
      new_len[1] = Stdlib_Sys[12];
     else
      caml_call1(Stdlib[2], cst_Buffer_add_cannot_grow_buf);
    var new_buffer = caml_create_bytes(new_len[1]);
    caml_call5(Stdlib_Bytes[11], b[1], 0, new_buffer, 0, b[2]);
    b[1] = new_buffer;
    b[3] = new_len[1];
    if((b[2] + more | 0) > b[3])
     throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
    if((old_pos + more | 0) <= b[3]) return;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
   }
   function add_char(b, c){
    var pos = b[2];
    if(b[3] <= pos) resize(b, 1);
    caml_bytes_unsafe_set(b[1], pos, c);
    b[2] = pos + 1 | 0;
    return 0;
   }
   var
    uchar_utf_8_byte_length_max = 4,
    uchar_utf_16_byte_length_max = 4,
    cst_Buffer_add_substring_add_s = "Buffer.add_substring/add_subbytes",
    _c_ = [0, cst_buffer_ml, 212, 2],
    cst_Buffer_add_channel = "Buffer.add_channel",
    _d_ = [0, cst_buffer_ml, 231, 9],
    cst_Buffer_truncate = "Buffer.truncate";
   function add_utf_8_uchar(b, u){
    for(;;){
     var pos = b[2];
     if(b[3] <= pos) resize(b, uchar_utf_8_byte_length_max);
     var n = caml_call3(Stdlib_Bytes[55], b[1], pos, u);
     if(0 !== n){b[2] = pos + n | 0; return 0;}
     resize(b, uchar_utf_8_byte_length_max);
    }
   }
   function add_utf_16be_uchar(b, u){
    for(;;){
     var pos = b[2];
     if(b[3] <= pos) resize(b, uchar_utf_16_byte_length_max);
     var n = caml_call3(Stdlib_Bytes[58], b[1], pos, u);
     if(0 !== n){b[2] = pos + n | 0; return 0;}
     resize(b, uchar_utf_16_byte_length_max);
    }
   }
   function add_utf_16le_uchar(b, u){
    for(;;){
     var pos = b[2];
     if(b[3] <= pos) resize(b, uchar_utf_16_byte_length_max);
     var n = caml_call3(Stdlib_Bytes[61], b[1], pos, u);
     if(0 !== n){b[2] = pos + n | 0; return 0;}
     resize(b, uchar_utf_16_byte_length_max);
    }
   }
   function add_substring(b, s, offset, len){
    var _t_ = offset < 0 ? 1 : 0;
    if(_t_)
     var _u_ = _t_;
    else
     var
      _v_ = len < 0 ? 1 : 0,
      _u_ = _v_ || ((caml_ml_string_length(s) - len | 0) < offset ? 1 : 0);
    if(_u_) caml_call1(Stdlib[1], cst_Buffer_add_substring_add_s);
    var new_position = b[2] + len | 0;
    if(b[3] < new_position) resize(b, len);
    caml_blit_string(s, offset, b[1], b[2], len);
    b[2] = new_position;
    return 0;
   }
   function add_subbytes(b, s, offset, len){
    return add_substring(b, caml_call1(Stdlib_Bytes[48], s), offset, len);
   }
   function add_string(b, s){
    var len = caml_ml_string_length(s), new_position = b[2] + len | 0;
    if(b[3] < new_position) resize(b, len);
    caml_blit_string(s, 0, b[1], b[2], len);
    b[2] = new_position;
    return 0;
   }
   function add_bytes(b, s){
    return add_string(b, caml_call1(Stdlib_Bytes[48], s));
   }
   function add_buffer(b, bs){return add_subbytes(b, bs[1], 0, bs[2]);}
   function add_channel(b, ic, to_read$1){
    var
     _r_ = to_read$1 < 0 ? 1 : 0,
     _s_ = _r_ || (Stdlib_Sys[12] < to_read$1 ? 1 : 0);
    if(_s_) caml_call1(Stdlib[1], cst_Buffer_add_channel);
    if(b[3] < (b[2] + to_read$1 | 0)) resize(b, to_read$1);
    var
     ofs$1 = b[2],
     buf = b[1],
     already_read = 0,
     ofs = ofs$1,
     to_read = to_read$1;
    for(;;){
     if(0 !== to_read){
      var r = caml_call4(Stdlib[84], ic, buf, ofs, to_read);
      if(0 !== r){
       var
        already_read$0 = already_read + r | 0,
        ofs$0 = ofs + r | 0,
        to_read$0 = to_read - r | 0;
       already_read = already_read$0;
       ofs = ofs$0;
       to_read = to_read$0;
       continue;
      }
     }
     if((b[2] + already_read | 0) > b[3])
      throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
     b[2] = b[2] + already_read | 0;
     if(already_read < to_read$1)
      throw caml_maybe_attach_backtrace(Stdlib[12], 1);
     return 0;
    }
   }
   function output_buffer(oc, b){
    return caml_call4(Stdlib[68], oc, b[1], 0, b[2]);
   }
   function add_substitute(b, f, s){
    var lim$1 = caml_ml_string_length(s), previous = 32, i$4 = 0;
    for(;;){
     if(i$4 >= lim$1){
      var _q_ = 92 === previous ? 1 : 0;
      return _q_ ? add_char(b, previous) : _q_;
     }
     var previous$0 = caml_string_get(s, i$4);
     if(36 === previous$0)
      if(92 === previous){
       add_char(b, previous$0);
       var i$5 = i$4 + 1 | 0;
       previous = 32;
       i$4 = i$5;
      }
      else{
       var start$0 = i$4 + 1 | 0;
       if(lim$1 <= start$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
       var opening = caml_string_get(s, start$0);
       a:
       {
        if(40 !== opening && 123 !== opening){
         var start = start$0 + 1 | 0, lim$0 = caml_ml_string_length(s);
         b:
         {
          c:
          {
           d:
           {
            var i$2 = start;
            for(;;){
             if(lim$0 <= i$2) break c;
             var match = caml_string_get(s, i$2);
             if(91 <= match){
              if(97 <= match){
               if(123 <= match) break d;
              }
              else if(95 !== match) break d;
             }
             else
              if(58 <= match){
               if(65 > match) break;
              }
              else if(48 > match) break d;
             var i$3 = i$2 + 1 | 0;
             i$2 = i$3;
            }
           }
           var stop$0 = i$2;
           break b;
          }
          var stop$0 = lim$0;
         }
         var
          match$0 =
            [0,
             caml_call3(Stdlib_String[15], s, start$0, stop$0 - start$0 | 0),
             stop$0];
         break a;
        }
        var new_start = start$0 + 1 | 0, k$2 = 0;
        if(40 === opening)
         var closing = 41;
        else{
         if(123 !== opening)
          throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
         var closing = 125;
        }
        var lim = caml_ml_string_length(s), k = k$2, stop = new_start;
        for(;;){
         if(lim <= stop) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
         if(caml_string_get(s, stop) === opening){
          var i = stop + 1 | 0, k$0 = k + 1 | 0;
          k = k$0;
          stop = i;
         }
         else if(caml_string_get(s, stop) === closing){
          if(0 === k) break;
          var i$0 = stop + 1 | 0, k$1 = k - 1 | 0;
          k = k$1;
          stop = i$0;
         }
         else{var i$1 = stop + 1 | 0; stop = i$1;}
        }
        var
         match$0 =
           [0,
            caml_call3
             (Stdlib_String[15], s, new_start, (stop - start$0 | 0) - 1 | 0),
            stop + 1 | 0];
       }
       var next_i = match$0[2], ident = match$0[1];
       add_string(b, caml_call1(f, ident));
       previous = 32;
       i$4 = next_i;
      }
     else if(92 === previous){
      add_char(b, 92);
      add_char(b, previous$0);
      var i$6 = i$4 + 1 | 0;
      previous = 32;
      i$4 = i$6;
     }
     else if(92 === previous$0){
      var i$7 = i$4 + 1 | 0;
      previous = previous$0;
      i$4 = i$7;
     }
     else{
      add_char(b, previous$0);
      var i$8 = i$4 + 1 | 0;
      previous = previous$0;
      i$4 = i$8;
     }
    }
   }
   function truncate(b, len){
    if(0 <= len && b[2] >= len){b[2] = len; return 0;}
    return caml_call1(Stdlib[1], cst_Buffer_truncate);
   }
   function to_seq(b){
    function aux(i, param){
     if(b[2] <= i) return 0;
     var x = caml_bytes_unsafe_get(b[1], i), _o_ = i + 1 | 0;
     return [0, x, function(_p_){return aux(_o_, _p_);}];
    }
    var _m_ = 0;
    return function(_n_){return aux(_m_, _n_);};
   }
   function to_seqi(b){
    function aux(i, param){
     if(b[2] <= i) return 0;
     var x = caml_bytes_unsafe_get(b[1], i), _k_ = i + 1 | 0;
     return [0, [0, i, x], function(_l_){return aux(_k_, _l_);}];
    }
    var _i_ = 0;
    return function(_j_){return aux(_i_, _j_);};
   }
   function add_seq(b, seq){
    return caml_call2
            (Stdlib_Seq[4], function(_h_){return add_char(b, _h_);}, seq);
   }
   function of_seq(i){var b = create(32); add_seq(b, i); return b;}
   function add_int8(b, x){
    var new_position = b[2] + 1 | 0;
    if(b[3] < new_position) resize(b, 1);
    caml_bytes_unsafe_set(b[1], b[2], x);
    b[2] = new_position;
    return 0;
   }
   function add_int16_ne(b, x){
    var new_position = b[2] + 2 | 0;
    if(b[3] < new_position) resize(b, 2);
    runtime.caml_bytes_set16(b[1], b[2], x);
    b[2] = new_position;
    return 0;
   }
   function add_int32_ne(b, x){
    var new_position = b[2] + 4 | 0;
    if(b[3] < new_position) resize(b, 4);
    runtime.caml_bytes_set32(b[1], b[2], x);
    b[2] = new_position;
    return 0;
   }
   function add_int64_ne(b, x){
    var new_position = b[2] + 8 | 0;
    if(b[3] < new_position) resize(b, 8);
    runtime.caml_bytes_set64(b[1], b[2], x);
    b[2] = new_position;
    return 0;
   }
   function add_int16_le(b, x){
    var _g_ = Stdlib_Sys[11] ? caml_bswap16(x) : x;
    return add_int16_ne(b, _g_);
   }
   function add_int16_be(b, x){
    var x$0 = Stdlib_Sys[11] ? x : caml_bswap16(x);
    return add_int16_ne(b, x$0);
   }
   function add_int32_le(b, x){
    var _f_ = Stdlib_Sys[11] ? caml_int32_bswap(x) : x;
    return add_int32_ne(b, _f_);
   }
   function add_int32_be(b, x){
    var x$0 = Stdlib_Sys[11] ? x : caml_int32_bswap(x);
    return add_int32_ne(b, x$0);
   }
   function add_int64_le(b, x){
    var _e_ = Stdlib_Sys[11] ? caml_int64_bswap(x) : x;
    return add_int64_ne(b, _e_);
   }
   function add_int64_be(b, x){
    var x$0 = Stdlib_Sys[11] ? x : caml_int64_bswap(x);
    return add_int64_ne(b, x$0);
   }
   var
    Stdlib_Buffer =
      [0,
       create,
       contents,
       to_bytes,
       sub,
       blit,
       nth,
       length,
       clear,
       reset,
       output_buffer,
       truncate,
       add_char,
       add_utf_8_uchar,
       add_utf_16le_uchar,
       add_utf_16be_uchar,
       add_string,
       add_bytes,
       add_substring,
       add_subbytes,
       add_substitute,
       add_buffer,
       add_channel,
       to_seq,
       to_seqi,
       add_seq,
       of_seq,
       add_int8,
       add_int8,
       add_int16_ne,
       add_int16_be,
       add_int16_le,
       add_int16_ne,
       add_int16_be,
       add_int16_le,
       add_int32_ne,
       add_int32_be,
       add_int32_le,
       add_int64_ne,
       add_int64_be,
       add_int64_le];
   runtime.caml_register_global(17, Stdlib_Buffer, "Stdlib__Buffer");
   return;
  }
  (globalThis));

//# 10531 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$43 = "",
    cst_and = " and ",
    cst_Li$3 = "%Li",
    cst_i$3 = "%i",
    cst_li$3 = "%li",
    cst_ni$3 = "%ni",
    cst_u$0 = "%u",
    cst$42 = "' '",
    cst$41 = "'#'",
    cst$39 = "'*'",
    cst$40 = "'+'",
    cst$44 = ", ",
    cst_0$3 = "0",
    cst_at_character_number = ": at character number ",
    cst$38 = "@[",
    cst$37 = "@{",
    cst_bad_input_format_type_mism =
      "bad input: format type mismatch between ",
    cst_bad_input_format_type_mism$0 =
      "bad input: format type mismatch between %S and %S",
    cst_camlinternalFormat_ml = "camlinternalFormat.ml",
    cst_invalid_format = "invalid format ",
    cst_precision$3 = "precision",
    caml_blit_string = runtime.caml_blit_string,
    caml_bytes_set = runtime.caml_bytes_set,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_format_float = runtime.caml_format_float,
    caml_format_int = runtime.caml_format_int,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_notequal = runtime.caml_notequal,
    caml_string_get = runtime.caml_string_get,
    caml_string_unsafe_get = runtime.caml_string_unsafe_get,
    caml_trampoline = runtime.caml_trampoline,
    caml_trampoline_return = runtime.caml_trampoline_return,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    cst$9 = "%{",
    cst$10 = "%}",
    cst$11 = "%(",
    cst$12 = "%)",
    cst$13 = "%?",
    cst$18 = cst$37,
    cst$19 = cst$38,
    cst$20 = cst$37,
    cst$21 = cst$38,
    cst$22 = cst$37,
    cst$23 = cst$38,
    cst$26 = cst$39,
    cst$24 = "'-'",
    cst$25 = cst$39,
    cst$27 = cst$40,
    cst$28 = cst$41,
    cst$29 = cst$42,
    cst$30 = cst$40,
    cst$31 = "'_'",
    sub_format = [0, 0, cst$43],
    formatting_lit = [0, "@;", 1, 0],
    cst$35 = cst$41,
    cst$32 = cst$40,
    cst$33 = cst$40,
    cst$34 = cst$42,
    cst$36 = cst$40,
    cst_unexpected_end_of_format = "unexpected end of format",
    cst$17 = ".",
    cst$14 = "%!",
    cst$15 = cst$37,
    cst$16 = cst$38,
    cst$8 = "%%",
    cst$0 = "@]",
    cst$1 = "@}",
    cst$2 = "@?",
    cst$3 = "@\n",
    cst$4 = "@.",
    cst$5 = "@@",
    cst$6 = "@%",
    cst$7 = "@",
    cst = ".*",
    Assert_failure = global_data.Assert_failure,
    CamlinternalFormatBasics = global_data.CamlinternalFormatBasics,
    Stdlib = global_data.Stdlib,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib_Sys = global_data.Stdlib__Sys,
    Stdlib_Char = global_data.Stdlib__Char,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Stdlib_Int = global_data.Stdlib__Int,
    _a_ = [0, 0, 0],
    cst_c = "%c",
    cst_s = "%s",
    cst_i = cst_i$3,
    cst_li = cst_li$3,
    cst_ni = cst_ni$3,
    cst_Li = cst_Li$3,
    cst_f = "%f",
    cst_B = "%B",
    cst_a = "%a",
    cst_t = "%t",
    cst_r = "%r",
    cst_r$0 = "%_r",
    cst_0c = "0c",
    _b_ = [0, cst_camlinternalFormat_ml, 850, 23],
    _c_ = [0, cst_camlinternalFormat_ml, 837, 26],
    _d_ = [0, cst_camlinternalFormat_ml, 847, 28],
    _e_ = [0, cst_camlinternalFormat_ml, 815, 21],
    _f_ = [0, cst_camlinternalFormat_ml, 819, 21],
    _g_ = [0, cst_camlinternalFormat_ml, 823, 19],
    _h_ = [0, cst_camlinternalFormat_ml, 827, 22],
    _i_ = [0, cst_camlinternalFormat_ml, 832, 30],
    _j_ = [0, cst_camlinternalFormat_ml, 851, 23],
    _k_ = [0, cst_camlinternalFormat_ml, 836, 26],
    _l_ = [0, cst_camlinternalFormat_ml, 846, 28],
    _m_ = [0, cst_camlinternalFormat_ml, 814, 21],
    _n_ = [0, cst_camlinternalFormat_ml, 818, 21],
    _o_ = [0, cst_camlinternalFormat_ml, 822, 19],
    _p_ = [0, cst_camlinternalFormat_ml, 826, 22],
    _q_ = [0, cst_camlinternalFormat_ml, 831, 30];
   function create_char_set(param){return caml_call2(Stdlib_Bytes[1], 32, 0);}
   function add_in_char_set(char_set, c){
    var
     str_ind = c >>> 3 | 0,
     mask = 1 << (c & 7),
     _cU_ = runtime.caml_bytes_get(char_set, str_ind) | mask;
    return caml_bytes_set(char_set, str_ind, caml_call1(Stdlib[29], _cU_));
   }
   function freeze_char_set(char_set){
    return caml_call1(Stdlib_Bytes[6], char_set);
   }
   function rev_char_set(char_set){
    var char_set$0 = create_char_set(0), i = 0;
    for(;;){
     var _cS_ = caml_string_get(char_set, i) ^ 255;
     caml_bytes_set(char_set$0, i, caml_call1(Stdlib[29], _cS_));
     var _cT_ = i + 1 | 0;
     if(31 === i) return caml_call1(Stdlib_Bytes[48], char_set$0);
     i = _cT_;
    }
   }
   function is_in_char_set(char_set, c){
    var str_ind = c >>> 3 | 0, mask = 1 << (c & 7);
    return 0 !== (caml_string_get(char_set, str_ind) & mask) ? 1 : 0;
   }
   function pad_of_pad_opt(pad_opt){
    if(! pad_opt) return 0;
    var width = pad_opt[1];
    return [0, 1, width];
   }
   function param_format_of_ignored_format(ign, fmt){
    if(typeof ign === "number")
     switch(ign){
       case 0:
        return [0, [0, fmt]];
       case 1:
        return [0, [1, fmt]];
       case 2:
        return [0, [19, fmt]];
       default: return [0, [22, fmt]];
     }
    switch(ign[0]){
      case 0:
       var pad_opt = ign[1]; return [0, [2, pad_of_pad_opt(pad_opt), fmt]];
      case 1:
       var pad_opt$0 = ign[1];
       return [0, [3, pad_of_pad_opt(pad_opt$0), fmt]];
      case 2:
       var pad_opt$1 = ign[2], iconv = ign[1];
       return [0, [4, iconv, pad_of_pad_opt(pad_opt$1), 0, fmt]];
      case 3:
       var pad_opt$2 = ign[2], iconv$0 = ign[1];
       return [0, [5, iconv$0, pad_of_pad_opt(pad_opt$2), 0, fmt]];
      case 4:
       var pad_opt$3 = ign[2], iconv$1 = ign[1];
       return [0, [6, iconv$1, pad_of_pad_opt(pad_opt$3), 0, fmt]];
      case 5:
       var pad_opt$4 = ign[2], iconv$2 = ign[1];
       return [0, [7, iconv$2, pad_of_pad_opt(pad_opt$4), 0, fmt]];
      case 6:
       var prec_opt = ign[2], pad_opt$5 = ign[1];
       if(prec_opt)
        var ndec = prec_opt[1], _cR_ = [0, ndec];
       else
        var _cR_ = 0;
       return [0, [8, _a_, pad_of_pad_opt(pad_opt$5), _cR_, fmt]];
      case 7:
       var pad_opt$6 = ign[1];
       return [0, [9, pad_of_pad_opt(pad_opt$6), fmt]];
      case 8:
       var fmtty = ign[2], pad_opt$7 = ign[1];
       return [0, [13, pad_opt$7, fmtty, fmt]];
      case 9:
       var fmtty$0 = ign[2], pad_opt$8 = ign[1];
       return [0, [14, pad_opt$8, fmtty$0, fmt]];
      case 10:
       var char_set = ign[2], width_opt = ign[1];
       return [0, [20, width_opt, char_set, fmt]];
      default: var counter = ign[1]; return [0, [21, counter, fmt]];
    }
   }
   function default_float_precision(fconv){return 5 === fconv[2] ? 12 : -6;}
   function buffer_create(init_size){
    return [0, 0, caml_create_bytes(init_size)];
   }
   function buffer_check_size(buf, overhead){
    var
     len = runtime.caml_ml_bytes_length(buf[2]),
     min_len = buf[1] + overhead | 0;
    if(len < min_len){
     var
      new_len = caml_call2(Stdlib_Int[11], len * 2 | 0, min_len),
      new_str = caml_create_bytes(new_len);
     caml_call5(Stdlib_Bytes[11], buf[2], 0, new_str, 0, len);
     buf[2] = new_str;
    }
    return;
   }
   function buffer_add_char(buf, c){
    buffer_check_size(buf, 1);
    caml_bytes_set(buf[2], buf[1], c);
    buf[1] = buf[1] + 1 | 0;
    return;
   }
   function buffer_add_string(buf, s){
    var str_len = caml_ml_string_length(s);
    buffer_check_size(buf, str_len);
    caml_call5(Stdlib_String[48], s, 0, buf[2], buf[1], str_len);
    buf[1] = buf[1] + str_len | 0;
    return;
   }
   function buffer_contents(buf){
    return caml_call3(Stdlib_Bytes[8], buf[2], 0, buf[1]);
   }
   function char_of_iconv(iconv){
    switch(iconv){
      case 6:
      case 7:
       return 120;
      case 8:
      case 9:
       return 88;
      case 10:
      case 11:
       return 111;
      case 12:
      case 15:
       return 117;
      case 0:
      case 1:
      case 2:
      case 13:
       return 100;
      default: return 105;
    }
   }
   function char_of_fconv(opt, fconv){
    if(opt) var sth = opt[1], cF = sth; else var cF = 70;
    switch(fconv[2]){
      case 0:
       return 102;
      case 1:
       return 101;
      case 2:
       return 69;
      case 3:
       return 103;
      case 4:
       return 71;
      case 5:
       return cF;
      case 6:
       return 104;
      case 7:
       return 72;
      default: return 70;
    }
   }
   function bprint_padty(buf, padty){
    switch(padty){
      case 0:
       return buffer_add_char(buf, 45);
      case 1:
       return;
      default: return buffer_add_char(buf, 48);
    }
   }
   function bprint_ignored_flag(buf, ign_flag){
    return ign_flag ? buffer_add_char(buf, 95) : ign_flag;
   }
   function bprint_pad_opt(buf, pad_opt){
    if(! pad_opt) return;
    var width = pad_opt[1];
    return buffer_add_string(buf, caml_call1(Stdlib_Int[12], width));
   }
   function bprint_padding(buf, pad){
    if(typeof pad === "number") return;
    if(0 === pad[0]){
     var n = pad[2], padty = pad[1];
     bprint_padty(buf, padty);
     return buffer_add_string(buf, caml_call1(Stdlib_Int[12], n));
    }
    var padty$0 = pad[1];
    bprint_padty(buf, padty$0);
    return buffer_add_char(buf, 42);
   }
   function bprint_precision(buf, prec){
    if(typeof prec !== "number"){
     var n = prec[1];
     buffer_add_char(buf, 46);
     return buffer_add_string(buf, caml_call1(Stdlib_Int[12], n));
    }
    if(prec) return buffer_add_string(buf, cst);
    return;
   }
   function bprint_iconv_flag(buf, iconv){
    switch(iconv){
      case 1:
      case 4:
       return buffer_add_char(buf, 43);
      case 2:
      case 5:
       return buffer_add_char(buf, 32);
      case 7:
      case 9:
      case 11:
      case 13:
      case 14:
      case 15:
       return buffer_add_char(buf, 35);
      default: return;
    }
   }
   function bprint_altint_fmt(buf, ign_flag, iconv, pad, prec, c){
    buffer_add_char(buf, 37);
    bprint_ignored_flag(buf, ign_flag);
    bprint_iconv_flag(buf, iconv);
    bprint_padding(buf, pad);
    bprint_precision(buf, prec);
    buffer_add_char(buf, c);
    return buffer_add_char(buf, char_of_iconv(iconv));
   }
   function bprint_fconv_flag(buf, fconv){
    switch(fconv[1]){
      case 0: break;
      case 1:
       buffer_add_char(buf, 43); break;
      default: buffer_add_char(buf, 32);
    }
    if(8 <= fconv[2]) return buffer_add_char(buf, 35);
    return;
   }
   function string_of_formatting_lit(formatting_lit){
    if(typeof formatting_lit === "number")
     switch(formatting_lit){
       case 0:
        return cst$0;
       case 1:
        return cst$1;
       case 2:
        return cst$2;
       case 3:
        return cst$3;
       case 4:
        return cst$4;
       case 5:
        return cst$5;
       default: return cst$6;
     }
    switch(formatting_lit[0]){
      case 0:
       var str = formatting_lit[1]; return str;
      case 1:
       var str$0 = formatting_lit[1]; return str$0;
      default:
       var c = formatting_lit[1], _cQ_ = caml_call2(Stdlib_String[1], 1, c);
       return caml_call2(Stdlib[28], cst$7, _cQ_);
    }
   }
   function bprint_char_literal(buf, chr){
    return 37 === chr
            ? buffer_add_string(buf, cst$8)
            : buffer_add_char(buf, chr);
   }
   function bprint_string_literal(buf, str){
    var _cO_ = caml_ml_string_length(str) - 1 | 0, _cN_ = 0;
    if(_cO_ >= 0){
     var i = _cN_;
     for(;;){
      bprint_char_literal(buf, caml_string_get(str, i));
      var _cP_ = i + 1 | 0;
      if(_cO_ === i) break;
      i = _cP_;
     }
    }
    return;
   }
   function bprint_fmtty(buf, fmtty){
    var fmtty$0 = fmtty;
    for(;;){
     if(typeof fmtty$0 === "number") return;
     switch(fmtty$0[0]){
       case 0:
        var fmtty$1 = fmtty$0[1];
        buffer_add_string(buf, cst_c);
        fmtty$0 = fmtty$1;
        break;
       case 1:
        var fmtty$2 = fmtty$0[1];
        buffer_add_string(buf, cst_s);
        fmtty$0 = fmtty$2;
        break;
       case 2:
        var fmtty$3 = fmtty$0[1];
        buffer_add_string(buf, cst_i);
        fmtty$0 = fmtty$3;
        break;
       case 3:
        var fmtty$4 = fmtty$0[1];
        buffer_add_string(buf, cst_li);
        fmtty$0 = fmtty$4;
        break;
       case 4:
        var fmtty$5 = fmtty$0[1];
        buffer_add_string(buf, cst_ni);
        fmtty$0 = fmtty$5;
        break;
       case 5:
        var fmtty$6 = fmtty$0[1];
        buffer_add_string(buf, cst_Li);
        fmtty$0 = fmtty$6;
        break;
       case 6:
        var fmtty$7 = fmtty$0[1];
        buffer_add_string(buf, cst_f);
        fmtty$0 = fmtty$7;
        break;
       case 7:
        var fmtty$8 = fmtty$0[1];
        buffer_add_string(buf, cst_B);
        fmtty$0 = fmtty$8;
        break;
       case 8:
        var fmtty$9 = fmtty$0[2], sub_fmtty = fmtty$0[1];
        buffer_add_string(buf, cst$9);
        bprint_fmtty(buf, sub_fmtty);
        buffer_add_string(buf, cst$10);
        fmtty$0 = fmtty$9;
        break;
       case 9:
        var fmtty$10 = fmtty$0[3], sub_fmtty$0 = fmtty$0[1];
        buffer_add_string(buf, cst$11);
        bprint_fmtty(buf, sub_fmtty$0);
        buffer_add_string(buf, cst$12);
        fmtty$0 = fmtty$10;
        break;
       case 10:
        var fmtty$11 = fmtty$0[1];
        buffer_add_string(buf, cst_a);
        fmtty$0 = fmtty$11;
        break;
       case 11:
        var fmtty$12 = fmtty$0[1];
        buffer_add_string(buf, cst_t);
        fmtty$0 = fmtty$12;
        break;
       case 12:
        var fmtty$13 = fmtty$0[1];
        buffer_add_string(buf, cst$13);
        fmtty$0 = fmtty$13;
        break;
       case 13:
        var fmtty$14 = fmtty$0[1];
        buffer_add_string(buf, cst_r);
        fmtty$0 = fmtty$14;
        break;
       default:
        var fmtty$15 = fmtty$0[1];
        buffer_add_string(buf, cst_r$0);
        fmtty$0 = fmtty$15;
     }
    }
   }
   function int_of_custom_arity(param){
    if(! param) return 0;
    var x = param[1];
    return 1 + int_of_custom_arity(x) | 0;
   }
   function string_of_fmt(fmt){
    var buf = buffer_create(16);
    function fmtiter(fmt, ign_flag){
     var fmt$0 = fmt, ign_flag$0 = ign_flag;
     for(;;){
      if(typeof fmt$0 === "number") return;
      switch(fmt$0[0]){
        case 0:
         var rest = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         buffer_add_char(buf, 99);
         fmt$0 = rest;
         ign_flag$0 = 0;
         break;
        case 1:
         var rest$0 = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         buffer_add_char(buf, 67);
         fmt$0 = rest$0;
         ign_flag$0 = 0;
         break;
        case 2:
         var rest$1 = fmt$0[2], pad = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         bprint_padding(buf, pad);
         buffer_add_char(buf, 115);
         fmt$0 = rest$1;
         ign_flag$0 = 0;
         break;
        case 3:
         var rest$2 = fmt$0[2], pad$0 = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         bprint_padding(buf, pad$0);
         buffer_add_char(buf, 83);
         fmt$0 = rest$2;
         ign_flag$0 = 0;
         break;
        case 4:
         var
          rest$3 = fmt$0[4],
          prec = fmt$0[3],
          pad$1 = fmt$0[2],
          iconv = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         bprint_iconv_flag(buf, iconv);
         bprint_padding(buf, pad$1);
         bprint_precision(buf, prec);
         buffer_add_char(buf, char_of_iconv(iconv));
         fmt$0 = rest$3;
         ign_flag$0 = 0;
         break;
        case 5:
         var
          rest$4 = fmt$0[4],
          prec$0 = fmt$0[3],
          pad$2 = fmt$0[2],
          iconv$0 = fmt$0[1];
         bprint_altint_fmt(buf, ign_flag$0, iconv$0, pad$2, prec$0, 108);
         fmt$0 = rest$4;
         ign_flag$0 = 0;
         break;
        case 6:
         var
          rest$5 = fmt$0[4],
          prec$1 = fmt$0[3],
          pad$3 = fmt$0[2],
          iconv$1 = fmt$0[1];
         bprint_altint_fmt(buf, ign_flag$0, iconv$1, pad$3, prec$1, 110);
         fmt$0 = rest$5;
         ign_flag$0 = 0;
         break;
        case 7:
         var
          rest$6 = fmt$0[4],
          prec$2 = fmt$0[3],
          pad$4 = fmt$0[2],
          iconv$2 = fmt$0[1];
         bprint_altint_fmt(buf, ign_flag$0, iconv$2, pad$4, prec$2, 76);
         fmt$0 = rest$6;
         ign_flag$0 = 0;
         break;
        case 8:
         var
          rest$7 = fmt$0[4],
          prec$3 = fmt$0[3],
          pad$5 = fmt$0[2],
          fconv = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         bprint_fconv_flag(buf, fconv);
         bprint_padding(buf, pad$5);
         bprint_precision(buf, prec$3);
         buffer_add_char(buf, char_of_fconv(0, fconv));
         fmt$0 = rest$7;
         ign_flag$0 = 0;
         break;
        case 9:
         var rest$8 = fmt$0[2], pad$6 = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         bprint_padding(buf, pad$6);
         buffer_add_char(buf, 66);
         fmt$0 = rest$8;
         ign_flag$0 = 0;
         break;
        case 10:
         var rest$9 = fmt$0[1];
         buffer_add_string(buf, cst$14);
         fmt$0 = rest$9;
         break;
        case 11:
         var rest$10 = fmt$0[2], str = fmt$0[1];
         bprint_string_literal(buf, str);
         fmt$0 = rest$10;
         break;
        case 12:
         var rest$11 = fmt$0[2], chr = fmt$0[1];
         bprint_char_literal(buf, chr);
         fmt$0 = rest$11;
         break;
        case 13:
         var rest$12 = fmt$0[3], fmtty = fmt$0[2], pad_opt = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         bprint_pad_opt(buf, pad_opt);
         buffer_add_char(buf, 123);
         bprint_fmtty(buf, fmtty);
         buffer_add_char(buf, 37);
         buffer_add_char(buf, 125);
         fmt$0 = rest$12;
         ign_flag$0 = 0;
         break;
        case 14:
         var rest$13 = fmt$0[3], fmtty$0 = fmt$0[2], pad_opt$0 = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         bprint_pad_opt(buf, pad_opt$0);
         buffer_add_char(buf, 40);
         bprint_fmtty(buf, fmtty$0);
         buffer_add_char(buf, 37);
         buffer_add_char(buf, 41);
         fmt$0 = rest$13;
         ign_flag$0 = 0;
         break;
        case 15:
         var rest$14 = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         buffer_add_char(buf, 97);
         fmt$0 = rest$14;
         ign_flag$0 = 0;
         break;
        case 16:
         var rest$15 = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         buffer_add_char(buf, 116);
         fmt$0 = rest$15;
         ign_flag$0 = 0;
         break;
        case 17:
         var rest$16 = fmt$0[2], fmting_lit = fmt$0[1];
         bprint_string_literal(buf, string_of_formatting_lit(fmting_lit));
         fmt$0 = rest$16;
         break;
        case 18:
         var rest$17 = fmt$0[2], fmting_gen = fmt$0[1];
         if(0 === fmting_gen[0]){
          var str$0 = fmting_gen[1][2];
          buffer_add_string(buf, cst$15);
          buffer_add_string(buf, str$0);
         }
         else{
          var str$1 = fmting_gen[1][2];
          buffer_add_string(buf, cst$16);
          buffer_add_string(buf, str$1);
         }
         fmt$0 = rest$17;
         break;
        case 19:
         var rest$18 = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         buffer_add_char(buf, 114);
         fmt$0 = rest$18;
         ign_flag$0 = 0;
         break;
        case 20:
         var rest$19 = fmt$0[3], char_set = fmt$0[2], width_opt = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         bprint_pad_opt(buf, width_opt);
         var
          print_char =
            function(buf, i){
             var c = caml_call1(Stdlib[29], i);
             return 37 === c
                     ? (buffer_add_char(buf, 37), buffer_add_char(buf, 37))
                     : 64
                       === c
                       ? (buffer_add_char(buf, 37), buffer_add_char(buf, 64))
                       : buffer_add_char(buf, c);
            };
         buffer_add_char(buf, 91);
         var
          set =
            is_in_char_set(char_set, 0)
             ? (buffer_add_char(buf, 94), rev_char_set(char_set))
             : char_set;
         let set$0 = set;
         var
          is_alone =
            function(c){
             var
              after = caml_call1(Stdlib_Char[1], c + 1 | 0),
              before = caml_call1(Stdlib_Char[1], c - 1 | 0),
              _cJ_ = is_in_char_set(set$0, c);
             if(_cJ_)
              var
               _cK_ = is_in_char_set(set$0, before),
               _cL_ = _cK_ ? is_in_char_set(set$0, after) : _cK_,
               _cM_ = 1 - _cL_;
             else
              var _cM_ = _cJ_;
             return _cM_;
            };
         if(is_alone(93)) buffer_add_char(buf, 93);
         a:
         b:
         {
          c:
          {
           d:
           {
            var i = 1;
            for(;;){
             if(i >= 256) break;
             if(is_in_char_set(set, caml_call1(Stdlib[29], i))){
              var switcher = caml_call1(Stdlib[29], i) - 45 | 0;
              if(48 < switcher >>> 0){
               if(210 <= switcher) break d;
              }
              else if(46 < switcher - 1 >>> 0){
               var i$2 = i + 1 | 0;
               i = i$2;
               continue;
              }
              var i$1 = i + 1 | 0;
              if(is_in_char_set(set, caml_call1(Stdlib[29], i$1))){
               var switcher$0 = caml_call1(Stdlib[29], i$1) - 45 | 0;
               if(48 < switcher$0 >>> 0){
                if(210 <= switcher$0) break c;
               }
               else if
                (46 < switcher$0 - 1 >>> 0
                 && ! is_in_char_set(set, caml_call1(Stdlib[29], i$1 + 1 | 0))){
                print_char(buf, i$1 - 1 | 0);
                var i$5 = i$1 + 1 | 0;
                i = i$5;
                continue;
               }
               if(is_in_char_set(set, caml_call1(Stdlib[29], i$1 + 1 | 0))){
                var j = i$1 + 2 | 0, i$3 = i$1 - 1 | 0, j$0 = j;
                for(;;){
                 if(256 === j$0) break;
                 if(! is_in_char_set(set, caml_call1(Stdlib[29], j$0))) break;
                 var j$1 = j$0 + 1 | 0;
                 j$0 = j$1;
                }
                print_char(buf, i$3);
                print_char(buf, 45);
                print_char(buf, j$0 - 1 | 0);
                if(j$0 >= 256) break b;
                var i$7 = j$0 + 1 | 0;
                i = i$7;
               }
               else{
                print_char(buf, i$1 - 1 | 0);
                print_char(buf, i$1);
                var i$4 = i$1 + 2 | 0;
                i = i$4;
               }
              }
              else{
               print_char(buf, i$1 - 1 | 0);
               var i$6 = i$1 + 1 | 0;
               i = i$6;
              }
             }
             else{var i$0 = i + 1 | 0; i = i$0;}
            }
            break a;
           }
           print_char(buf, 255);
           break a;
          }
          print_char(buf, 254);
          print_char(buf, 255);
          break a;
         }
         if(is_alone(45)) buffer_add_char(buf, 45);
         buffer_add_char(buf, 93);
         fmt$0 = rest$19;
         ign_flag$0 = 0;
         break;
        case 21:
         var rest$20 = fmt$0[2], counter = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         switch(counter){
           case 0:
            var _cF_ = 108; break;
           case 1:
            var _cF_ = 110; break;
           default: var _cF_ = 78;
         }
         buffer_add_char(buf, _cF_);
         fmt$0 = rest$20;
         ign_flag$0 = 0;
         break;
        case 22:
         var rest$21 = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         bprint_string_literal(buf, cst_0c);
         fmt$0 = rest$21;
         ign_flag$0 = 0;
         break;
        case 23:
         var
          rest$22 = fmt$0[2],
          ign = fmt$0[1],
          fmt$1 = param_format_of_ignored_format(ign, rest$22)[1];
         fmt$0 = fmt$1;
         ign_flag$0 = 1;
         break;
        default:
         var
          rest$23 = fmt$0[3],
          arity = fmt$0[1],
          _cH_ = int_of_custom_arity(arity),
          _cG_ = 1;
         if(_cH_ >= 1){
          var i$8 = _cG_;
          for(;;){
           buffer_add_char(buf, 37);
           bprint_ignored_flag(buf, ign_flag$0);
           buffer_add_char(buf, 63);
           var _cI_ = i$8 + 1 | 0;
           if(_cH_ === i$8) break;
           i$8 = _cI_;
          }
         }
         fmt$0 = rest$23;
         ign_flag$0 = 0;
      }
     }
    }
    fmtiter(fmt, 0);
    return buffer_contents(buf);
   }
   function symm(param){
    if(typeof param === "number") return 0;
    switch(param[0]){
      case 0:
       var rest = param[1]; return [0, symm(rest)];
      case 1:
       var rest$0 = param[1]; return [1, symm(rest$0)];
      case 2:
       var rest$1 = param[1]; return [2, symm(rest$1)];
      case 3:
       var rest$2 = param[1]; return [3, symm(rest$2)];
      case 4:
       var rest$3 = param[1]; return [4, symm(rest$3)];
      case 5:
       var rest$4 = param[1]; return [5, symm(rest$4)];
      case 6:
       var rest$5 = param[1]; return [6, symm(rest$5)];
      case 7:
       var rest$6 = param[1]; return [7, symm(rest$6)];
      case 8:
       var rest$7 = param[2], ty = param[1]; return [8, ty, symm(rest$7)];
      case 9:
       var rest$8 = param[3], ty2 = param[2], ty1 = param[1];
       return [9, ty2, ty1, symm(rest$8)];
      case 10:
       var rest$9 = param[1]; return [10, symm(rest$9)];
      case 11:
       var rest$10 = param[1]; return [11, symm(rest$10)];
      case 12:
       var rest$11 = param[1]; return [12, symm(rest$11)];
      case 13:
       var rest$12 = param[1]; return [13, symm(rest$12)];
      default: var rest$13 = param[1]; return [14, symm(rest$13)];
    }
   }
   function fmtty_rel_det(param){
    if(typeof param === "number")
     return [0,
             function(param){return;},
             function(param){return;},
             function(param){return;},
             function(param){return;}];
    switch(param[0]){
      case 0:
       var
        rest = param[1],
        match = fmtty_rel_det(rest),
        de = match[4],
        ed = match[3],
        af = match[2],
        fa = match[1];
       return [0,
               function(param){fa(0); return;},
               function(param){af(0); return;},
               ed,
               de];
      case 1:
       var
        rest$0 = param[1],
        match$0 = fmtty_rel_det(rest$0),
        de$0 = match$0[4],
        ed$0 = match$0[3],
        af$0 = match$0[2],
        fa$0 = match$0[1];
       return [0,
               function(param){fa$0(0); return;},
               function(param){af$0(0); return;},
               ed$0,
               de$0];
      case 2:
       var
        rest$1 = param[1],
        match$1 = fmtty_rel_det(rest$1),
        de$1 = match$1[4],
        ed$1 = match$1[3],
        af$1 = match$1[2],
        fa$1 = match$1[1];
       return [0,
               function(param){fa$1(0); return;},
               function(param){af$1(0); return;},
               ed$1,
               de$1];
      case 3:
       var
        rest$2 = param[1],
        match$2 = fmtty_rel_det(rest$2),
        de$2 = match$2[4],
        ed$2 = match$2[3],
        af$2 = match$2[2],
        fa$2 = match$2[1];
       return [0,
               function(param){fa$2(0); return;},
               function(param){af$2(0); return;},
               ed$2,
               de$2];
      case 4:
       var
        rest$3 = param[1],
        match$3 = fmtty_rel_det(rest$3),
        de$3 = match$3[4],
        ed$3 = match$3[3],
        af$3 = match$3[2],
        fa$3 = match$3[1];
       return [0,
               function(param){fa$3(0); return;},
               function(param){af$3(0); return;},
               ed$3,
               de$3];
      case 5:
       var
        rest$4 = param[1],
        match$4 = fmtty_rel_det(rest$4),
        de$4 = match$4[4],
        ed$4 = match$4[3],
        af$4 = match$4[2],
        fa$4 = match$4[1];
       return [0,
               function(param){fa$4(0); return;},
               function(param){af$4(0); return;},
               ed$4,
               de$4];
      case 6:
       var
        rest$5 = param[1],
        match$5 = fmtty_rel_det(rest$5),
        de$5 = match$5[4],
        ed$5 = match$5[3],
        af$5 = match$5[2],
        fa$5 = match$5[1];
       return [0,
               function(param){fa$5(0); return;},
               function(param){af$5(0); return;},
               ed$5,
               de$5];
      case 7:
       var
        rest$6 = param[1],
        match$6 = fmtty_rel_det(rest$6),
        de$6 = match$6[4],
        ed$6 = match$6[3],
        af$6 = match$6[2],
        fa$6 = match$6[1];
       return [0,
               function(param){fa$6(0); return;},
               function(param){af$6(0); return;},
               ed$6,
               de$6];
      case 8:
       var
        rest$7 = param[2],
        match$7 = fmtty_rel_det(rest$7),
        de$7 = match$7[4],
        ed$7 = match$7[3],
        af$7 = match$7[2],
        fa$7 = match$7[1];
       return [0,
               function(param){fa$7(0); return;},
               function(param){af$7(0); return;},
               ed$7,
               de$7];
      case 9:
       var
        rest$8 = param[3],
        ty2 = param[2],
        ty1 = param[1],
        match$8 = fmtty_rel_det(rest$8),
        de$8 = match$8[4],
        ed$8 = match$8[3],
        af$8 = match$8[2],
        fa$8 = match$8[1],
        ty = trans(symm(ty1), ty2),
        match$9 = fmtty_rel_det(ty),
        jd = match$9[4],
        dj = match$9[3],
        ga = match$9[2],
        ag = match$9[1];
       return [0,
               function(param){fa$8(0); ag(0); return;},
               function(param){ga(0); af$8(0); return;},
               function(param){ed$8(0); dj(0); return;},
               function(param){jd(0); de$8(0); return;}];
      case 10:
       var
        rest$9 = param[1],
        match$10 = fmtty_rel_det(rest$9),
        de$9 = match$10[4],
        ed$9 = match$10[3],
        af$9 = match$10[2],
        fa$9 = match$10[1];
       return [0,
               function(param){fa$9(0); return;},
               function(param){af$9(0); return;},
               ed$9,
               de$9];
      case 11:
       var
        rest$10 = param[1],
        match$11 = fmtty_rel_det(rest$10),
        de$10 = match$11[4],
        ed$10 = match$11[3],
        af$10 = match$11[2],
        fa$10 = match$11[1];
       return [0,
               function(param){fa$10(0); return;},
               function(param){af$10(0); return;},
               ed$10,
               de$10];
      case 12:
       var
        rest$11 = param[1],
        match$12 = fmtty_rel_det(rest$11),
        de$11 = match$12[4],
        ed$11 = match$12[3],
        af$11 = match$12[2],
        fa$11 = match$12[1];
       return [0,
               function(param){fa$11(0); return;},
               function(param){af$11(0); return;},
               ed$11,
               de$11];
      case 13:
       var
        rest$12 = param[1],
        match$13 = fmtty_rel_det(rest$12),
        de$12 = match$13[4],
        ed$12 = match$13[3],
        af$12 = match$13[2],
        fa$12 = match$13[1];
       return [0,
               function(param){fa$12(0); return;},
               function(param){af$12(0); return;},
               function(param){ed$12(0); return;},
               function(param){de$12(0); return;}];
      default:
       var
        rest$13 = param[1],
        match$14 = fmtty_rel_det(rest$13),
        de$13 = match$14[4],
        ed$13 = match$14[3],
        af$13 = match$14[2],
        fa$13 = match$14[1];
       return [0,
               function(param){fa$13(0); return;},
               function(param){af$13(0); return;},
               function(param){ed$13(0); return;},
               function(param){de$13(0); return;}];
    }
   }
   function trans(ty1, ty2){
    a:
    {
     b:
     {
      c:
      {
       d:
       {
        e:
        {
         f:
         {
          g:
          {
           if(typeof ty1 !== "number"){
            switch(ty1[0]){
              case 0:
               var rest1 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 0:
                   var rest2 = ty2[1]; return [0, trans(rest1, rest2)];
                  case 8:
                   break f;
                  case 9:
                   break g;
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   break e;
                }
               break;
              case 1:
               var rest1$0 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 1:
                   var rest2$0 = ty2[1]; return [1, trans(rest1$0, rest2$0)];
                  case 8:
                   break f;
                  case 9:
                   break g;
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   break e;
                }
               break;
              case 2:
               var rest1$1 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 2:
                   var rest2$1 = ty2[1]; return [2, trans(rest1$1, rest2$1)];
                  case 8:
                   break f;
                  case 9:
                   break g;
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   break e;
                }
               break;
              case 3:
               var rest1$2 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 3:
                   var rest2$2 = ty2[1]; return [3, trans(rest1$2, rest2$2)];
                  case 8:
                   break f;
                  case 9:
                   break g;
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   break e;
                }
               break;
              case 4:
               var rest1$3 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 4:
                   var rest2$3 = ty2[1]; return [4, trans(rest1$3, rest2$3)];
                  case 8:
                   break f;
                  case 9:
                   break g;
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   break e;
                }
               break;
              case 5:
               var rest1$4 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 5:
                   var rest2$4 = ty2[1]; return [5, trans(rest1$4, rest2$4)];
                  case 8:
                   break f;
                  case 9:
                   break g;
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   break e;
                }
               break;
              case 6:
               var rest1$5 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 6:
                   var rest2$5 = ty2[1]; return [6, trans(rest1$5, rest2$5)];
                  case 8:
                   break f;
                  case 9:
                   break g;
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   break e;
                }
               break;
              case 7:
               var rest1$6 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 7:
                   var rest2$6 = ty2[1]; return [7, trans(rest1$6, rest2$6)];
                  case 8:
                   break f;
                  case 9:
                   break g;
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   break e;
                }
               break;
              case 8:
               var rest1$7 = ty1[2], ty1$0 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 8:
                   var
                    rest2$7 = ty2[2],
                    ty2$0 = ty2[1],
                    _cE_ = trans(rest1$7, rest2$7);
                   return [8, trans(ty1$0, ty2$0), _cE_];
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   break e;
                }
               throw caml_maybe_attach_backtrace([0, Assert_failure, _k_], 1);
              case 9:
               var rest1$8 = ty1[3], ty12 = ty1[2], ty11 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 8:
                   break f;
                  case 9:
                   var
                    rest2$8 = ty2[3],
                    ty22 = ty2[2],
                    ty21 = ty2[1],
                    ty = trans(symm(ty12), ty21),
                    match = fmtty_rel_det(ty),
                    f4 = match[4],
                    f2 = match[2];
                   f2(0);
                   f4(0);
                   return [9, ty11, ty22, trans(rest1$8, rest2$8)];
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   break e;
                }
               throw caml_maybe_attach_backtrace([0, Assert_failure, _l_], 1);
              case 10:
               var rest1$9 = ty1[1];
               if(typeof ty2 !== "number" && 10 === ty2[0]){
                var rest2$9 = ty2[1];
                return [10, trans(rest1$9, rest2$9)];
               }
               throw caml_maybe_attach_backtrace([0, Assert_failure, _m_], 1);
              case 11:
               var rest1$10 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 10:
                   break a;
                  case 11:
                   var rest2$10 = ty2[1];
                   return [11, trans(rest1$10, rest2$10)];
                }
               throw caml_maybe_attach_backtrace([0, Assert_failure, _n_], 1);
              case 12:
               var rest1$11 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   var rest2$11 = ty2[1];
                   return [12, trans(rest1$11, rest2$11)];
                }
               throw caml_maybe_attach_backtrace([0, Assert_failure, _o_], 1);
              case 13:
               var rest1$12 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   var rest2$12 = ty2[1];
                   return [13, trans(rest1$12, rest2$12)];
                }
               throw caml_maybe_attach_backtrace([0, Assert_failure, _p_], 1);
              default:
               var rest1$13 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   var rest2$13 = ty2[1];
                   return [14, trans(rest1$13, rest2$13)];
                }
               throw caml_maybe_attach_backtrace([0, Assert_failure, _q_], 1);
            }
            throw caml_maybe_attach_backtrace([0, Assert_failure, _j_], 1);
           }
           if(typeof ty2 === "number") return 0;
           switch(ty2[0]){
             case 10:
              break a;
             case 11:
              break b;
             case 12:
              break c;
             case 13:
              break d;
             case 14:
              break e;
             case 8:
              break f;
             case 9: break;
             default:
              throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
           }
          }
          throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
         }
         throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
        }
        throw caml_maybe_attach_backtrace([0, Assert_failure, _i_], 1);
       }
       throw caml_maybe_attach_backtrace([0, Assert_failure, _h_], 1);
      }
      throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
     }
     throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
    }
    throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
   }
   function fmtty_of_fmt(fmtty){
    var fmtty$0 = fmtty;
    for(;;){
     if(typeof fmtty$0 === "number") return 0;
     switch(fmtty$0[0]){
       case 0:
        var rest = fmtty$0[1]; return [0, fmtty_of_fmt(rest)];
       case 1:
        var rest$0 = fmtty$0[1]; return [0, fmtty_of_fmt(rest$0)];
       case 2:
        var rest$1 = fmtty$0[2], pad = fmtty$0[1];
        return fmtty_of_padding_fmtty(pad, [1, fmtty_of_fmt(rest$1)]);
       case 3:
        var rest$2 = fmtty$0[2], pad$0 = fmtty$0[1];
        return fmtty_of_padding_fmtty(pad$0, [1, fmtty_of_fmt(rest$2)]);
       case 4:
        var
         rest$3 = fmtty$0[4],
         prec = fmtty$0[3],
         pad$1 = fmtty$0[2],
         ty_rest = fmtty_of_fmt(rest$3),
         prec_ty = fmtty_of_precision_fmtty(prec, [2, ty_rest]);
        return fmtty_of_padding_fmtty(pad$1, prec_ty);
       case 5:
        var
         rest$4 = fmtty$0[4],
         prec$0 = fmtty$0[3],
         pad$2 = fmtty$0[2],
         ty_rest$0 = fmtty_of_fmt(rest$4),
         prec_ty$0 = fmtty_of_precision_fmtty(prec$0, [3, ty_rest$0]);
        return fmtty_of_padding_fmtty(pad$2, prec_ty$0);
       case 6:
        var
         rest$5 = fmtty$0[4],
         prec$1 = fmtty$0[3],
         pad$3 = fmtty$0[2],
         ty_rest$1 = fmtty_of_fmt(rest$5),
         prec_ty$1 = fmtty_of_precision_fmtty(prec$1, [4, ty_rest$1]);
        return fmtty_of_padding_fmtty(pad$3, prec_ty$1);
       case 7:
        var
         rest$6 = fmtty$0[4],
         prec$2 = fmtty$0[3],
         pad$4 = fmtty$0[2],
         ty_rest$2 = fmtty_of_fmt(rest$6),
         prec_ty$2 = fmtty_of_precision_fmtty(prec$2, [5, ty_rest$2]);
        return fmtty_of_padding_fmtty(pad$4, prec_ty$2);
       case 8:
        var
         rest$7 = fmtty$0[4],
         prec$3 = fmtty$0[3],
         pad$5 = fmtty$0[2],
         ty_rest$3 = fmtty_of_fmt(rest$7),
         prec_ty$3 = fmtty_of_precision_fmtty(prec$3, [6, ty_rest$3]);
        return fmtty_of_padding_fmtty(pad$5, prec_ty$3);
       case 9:
        var rest$8 = fmtty$0[2], pad$6 = fmtty$0[1];
        return fmtty_of_padding_fmtty(pad$6, [7, fmtty_of_fmt(rest$8)]);
       case 10:
        var fmtty$1 = fmtty$0[1]; fmtty$0 = fmtty$1; break;
       case 11:
        var fmtty$2 = fmtty$0[2]; fmtty$0 = fmtty$2; break;
       case 12:
        var fmtty$3 = fmtty$0[2]; fmtty$0 = fmtty$3; break;
       case 13:
        var rest$9 = fmtty$0[3], ty = fmtty$0[2];
        return [8, ty, fmtty_of_fmt(rest$9)];
       case 14:
        var rest$10 = fmtty$0[3], ty$0 = fmtty$0[2];
        return [9, ty$0, ty$0, fmtty_of_fmt(rest$10)];
       case 15:
        var rest$11 = fmtty$0[1]; return [10, fmtty_of_fmt(rest$11)];
       case 16:
        var rest$12 = fmtty$0[1]; return [11, fmtty_of_fmt(rest$12)];
       case 17:
        var fmtty$4 = fmtty$0[2]; fmtty$0 = fmtty$4; break;
       case 18:
        var
         rest$13 = fmtty$0[2],
         formatting_gen = fmtty$0[1],
         _cB_ = fmtty_of_fmt(rest$13);
        if(0 === formatting_gen[0])
         var fmt = formatting_gen[1][1], _cC_ = fmtty_of_fmt(fmt);
        else
         var fmt$0 = formatting_gen[1][1], _cC_ = fmtty_of_fmt(fmt$0);
        return caml_call2(CamlinternalFormatBasics[1], _cC_, _cB_);
       case 19:
        var rest$14 = fmtty$0[1]; return [13, fmtty_of_fmt(rest$14)];
       case 20:
        var rest$15 = fmtty$0[3]; return [1, fmtty_of_fmt(rest$15)];
       case 21:
        var rest$16 = fmtty$0[2]; return [2, fmtty_of_fmt(rest$16)];
       case 22:
        var rest$17 = fmtty$0[1]; return [0, fmtty_of_fmt(rest$17)];
       case 23:
        var fmtty$5 = fmtty$0[2], ign = fmtty$0[1];
        if(typeof ign === "number")
         switch(ign){
           case 0:
            fmtty$0 = fmtty$5; break;
           case 1:
            fmtty$0 = fmtty$5; break;
           case 2:
            return [14, fmtty_of_fmt(fmtty$5)];
           default: fmtty$0 = fmtty$5;
         }
        else
         switch(ign[0]){
           case 0:
            fmtty$0 = fmtty$5; break;
           case 1:
            fmtty$0 = fmtty$5; break;
           case 2:
            fmtty$0 = fmtty$5; break;
           case 3:
            fmtty$0 = fmtty$5; break;
           case 4:
            fmtty$0 = fmtty$5; break;
           case 5:
            fmtty$0 = fmtty$5; break;
           case 6:
            fmtty$0 = fmtty$5; break;
           case 7:
            fmtty$0 = fmtty$5; break;
           case 8:
            fmtty$0 = fmtty$5; break;
           case 9:
            var fmtty$6 = ign[2], _cD_ = fmtty_of_fmt(fmtty$5);
            return caml_call2(CamlinternalFormatBasics[1], fmtty$6, _cD_);
           case 10:
            fmtty$0 = fmtty$5; break;
           default: fmtty$0 = fmtty$5;
         }
        break;
       default:
        var rest$18 = fmtty$0[3], arity = fmtty$0[1];
        return fmtty_of_custom(arity, fmtty_of_fmt(rest$18));
     }
    }
   }
   function fmtty_of_custom(arity, fmtty){
    if(! arity) return fmtty;
    var arity$0 = arity[1];
    return [12, fmtty_of_custom(arity$0, fmtty)];
   }
   function fmtty_of_padding_fmtty(pad, fmtty){
    return typeof pad === "number" ? fmtty : 0 === pad[0] ? fmtty : [2, fmtty];
   }
   function fmtty_of_precision_fmtty(prec, fmtty){
    return typeof prec === "number" ? prec ? [2, fmtty] : fmtty : fmtty;
   }
   var
    Type_mismatch =
      [248, "CamlinternalFormat.Type_mismatch", runtime.caml_fresh_oo_id(0)],
    cst_d = "%d",
    cst_d$0 = "%+d",
    cst_d$1 = "% d",
    cst_i$0 = cst_i$3,
    cst_i$1 = "%+i",
    cst_i$2 = "% i",
    cst_x = "%x",
    cst_x$0 = "%#x",
    cst_X = "%X",
    cst_X$0 = "%#X",
    cst_o = "%o",
    cst_o$0 = "%#o",
    cst_u = cst_u$0,
    cst_Ld = "%Ld",
    cst_Ld$0 = "%+Ld",
    cst_Ld$1 = "% Ld",
    cst_Li$0 = cst_Li$3,
    cst_Li$1 = "%+Li",
    cst_Li$2 = "% Li",
    cst_Lx = "%Lx",
    cst_Lx$0 = "%#Lx",
    cst_LX = "%LX",
    cst_LX$0 = "%#LX",
    cst_Lo = "%Lo",
    cst_Lo$0 = "%#Lo",
    cst_Lu = "%Lu",
    cst_ld = "%ld",
    cst_ld$0 = "%+ld",
    cst_ld$1 = "% ld",
    cst_li$0 = cst_li$3,
    cst_li$1 = "%+li",
    cst_li$2 = "% li",
    cst_lx = "%lx",
    cst_lx$0 = "%#lx",
    cst_lX = "%lX",
    cst_lX$0 = "%#lX",
    cst_lo = "%lo",
    cst_lo$0 = "%#lo",
    cst_lu = "%lu",
    cst_nd = "%nd",
    cst_nd$0 = "%+nd",
    cst_nd$1 = "% nd",
    cst_ni$0 = cst_ni$3,
    cst_ni$1 = "%+ni",
    cst_ni$2 = "% ni",
    cst_nx = "%nx",
    cst_nx$0 = "%#nx",
    cst_nX = "%nX",
    cst_nX$0 = "%#nX",
    cst_no = "%no",
    cst_no$0 = "%#no",
    cst_nu = "%nu",
    _r_ = [0, 103],
    cst_neg_infinity = "neg_infinity",
    cst_infinity = "infinity",
    cst_nan = "nan",
    _s_ = [0, cst_camlinternalFormat_ml, 1558, 4],
    cst_Printf_bad_conversion = "Printf: bad conversion %[",
    _t_ = [0, cst_camlinternalFormat_ml, 1626, 39],
    _u_ = [0, cst_camlinternalFormat_ml, 1649, 31],
    _v_ = [0, cst_camlinternalFormat_ml, 1650, 31],
    cst_Printf_bad_conversion$0 = "Printf: bad conversion %_",
    _w_ = [0, cst_camlinternalFormat_ml, 1830, 8],
    _x_ = [0, 0, 4],
    _y_ =
      [0,
       [11, "invalid box description ", [3, 0, 0]],
       "invalid box description %S"],
    _z_ =
      [0,
       [11,
        cst_invalid_format,
        [3,
         0,
         [11, cst_at_character_number, [4, 0, 0, 0, [11, cst$44, [2, 0, 0]]]]]],
       "invalid format %S: at character number %d, %s"],
    cst_non_zero_widths_are_unsupp =
      "non-zero widths are unsupported for %c conversions",
    _A_ =
      [0,
       [11,
        cst_invalid_format,
        [3,
         0,
         [11,
          cst_at_character_number,
          [4, 0, 0, 0, [11, ", '", [0, [11, "' without ", [2, 0, 0]]]]]]]],
       "invalid format %S: at character number %d, '%c' without %s"],
    _B_ =
      [0,
       [11,
        cst_invalid_format,
        [3,
         0,
         [11,
          cst_at_character_number,
          [4, 0, 0, 0, [11, cst$44, [2, 0, [11, " expected, read ", [1, 0]]]]]]]],
       "invalid format %S: at character number %d, %s expected, read %C"],
    _C_ =
      [0,
       [11,
        cst_invalid_format,
        [3,
         0,
         [11,
          cst_at_character_number,
          [4, 0, 0, 0, [11, ", duplicate flag ", [1, 0]]]]]],
       "invalid format %S: at character number %d, duplicate flag %C"],
    cst_padding = "padding",
    _D_ = [0, 1, 0],
    cst_0 = cst_0$3,
    _E_ = [0, 0],
    cst_precision = cst_precision$3,
    _F_ = [1, 0],
    _G_ = [1, 1],
    cst_precision$0 = cst_precision$3,
    _H_ = [1, 1],
    cst_precision$1 = cst_precision$3,
    cst_0$0 = cst_0$3,
    _I_ = [1, 1],
    cst_0$1 = cst_0$3,
    cst_0$2 = "'0'",
    _J_ =
      [0,
       [11,
        cst_invalid_format,
        [3,
         0,
         [11,
          cst_at_character_number,
          [4,
           0,
           0,
           0,
           [11, ', invalid conversion "', [12, 37, [0, [12, 34, 0]]]]]]]],
       'invalid format %S: at character number %d, invalid conversion "%%%c"'],
    _K_ = [0, 0],
    cst_padding$0 = "`padding'",
    _L_ = [0, 0],
    cst_precision$2 = "`precision'",
    _M_ =
      [0,
       [11,
        cst_invalid_format,
        [3,
         0,
         [11,
          cst_at_character_number,
          [4,
           0,
           0,
           0,
           [11,
            ", flag ",
            [1,
             [11,
              " is only allowed after the '",
              [12, 37, [11, "', before padding and precision", 0]]]]]]]]],
       "invalid format %S: at character number %d, flag %C is only allowed after the '%%', before padding and precision"],
    _N_ = [0, [12, 64, 0]],
    _O_ = [0, "@ ", 1, 0],
    _P_ = [0, "@,", 0, 0],
    _Q_ = [2, 60],
    _R_ =
      [0,
       [11,
        cst_invalid_format,
        [3,
         0,
         [11,
          ": '",
          [12,
           37,
           [11,
            "' alone is not accepted in character sets, use ",
            [12,
             37,
             [12,
              37,
              [11, " instead at position ", [4, 0, 0, 0, [12, 46, 0]]]]]]]]]],
       "invalid format %S: '%%' alone is not accepted in character sets, use %%%% instead at position %d."],
    _S_ =
      [0,
       [11,
        cst_invalid_format,
        [3,
         0,
         [11,
          ": integer ",
          [4, 0, 0, 0, [11, " is greater than the limit ", [4, 0, 0, 0, 0]]]]]],
       "invalid format %S: integer %d is greater than the limit %d"],
    _T_ = [0, cst_camlinternalFormat_ml, 2837, 11],
    cst_digit = "digit",
    _U_ =
      [0,
       [11,
        cst_invalid_format,
        [3,
         0,
         [11,
          ': unclosed sub-format, expected "',
          [12, 37, [0, [11, '" at character number ', [4, 0, 0, 0, 0]]]]]]],
       'invalid format %S: unclosed sub-format, expected "%%%c" at character number %d'],
    cst_character = "character ')'",
    cst_character$0 = "character '}'",
    _V_ = [0, cst_camlinternalFormat_ml, 2899, 34],
    _W_ = [0, cst_camlinternalFormat_ml, 2935, 28],
    _X_ = [0, cst_camlinternalFormat_ml, 2957, 11],
    _Y_ =
      [0,
       [11,
        cst_invalid_format,
        [3,
         0,
         [11,
          cst_at_character_number,
          [4,
           0,
           0,
           0,
           [11,
            cst$44,
            [2,
             0,
             [11,
              " is incompatible with '",
              [0, [11, "' in sub-format ", [3, 0, 0]]]]]]]]]],
       "invalid format %S: at character number %d, %s is incompatible with '%c' in sub-format %S"],
    _Z_ =
      [0,
       [11, cst_bad_input_format_type_mism, [3, 0, [11, cst_and, [3, 0, 0]]]],
       cst_bad_input_format_type_mism$0],
    ___ =
      [0,
       [11, cst_bad_input_format_type_mism, [3, 0, [11, cst_and, [3, 0, 0]]]],
       cst_bad_input_format_type_mism$0];
   function type_padding(pad, fmtty){
    if(typeof pad === "number") return [0, 0, fmtty];
    if(0 === pad[0]){
     var w = pad[2], padty = pad[1];
     return [0, [0, padty, w], fmtty];
    }
    if(typeof fmtty !== "number" && 2 === fmtty[0]){
     var rest = fmtty[1], padty$0 = pad[1];
     return [0, [1, padty$0], rest];
    }
    throw caml_maybe_attach_backtrace(Type_mismatch, 1);
   }
   function type_padprec(pad, prec, fmtty){
    var match = type_padding(pad, fmtty);
    if(typeof prec !== "number"){
     var rest$1 = match[2], pad$2 = match[1], p = prec[1];
     return [0, pad$2, [0, p], rest$1];
    }
    if(! prec){
     var rest$0 = match[2], pad$1 = match[1];
     return [0, pad$1, 0, rest$0];
    }
    var match$0 = match[2];
    if(typeof match$0 !== "number" && 2 === match$0[0]){
     var rest = match$0[1], pad$0 = match[1];
     return [0, pad$0, 1, rest];
    }
    throw caml_maybe_attach_backtrace(Type_mismatch, 1);
   }
   function type_format(fmt, fmtty){
    var _cA_ = type_format_gen(fmt, fmtty);
    if(typeof _cA_[2] !== "number")
     throw caml_maybe_attach_backtrace(Type_mismatch, 1);
    var fmt$0 = _cA_[1];
    return fmt$0;
   }
   function type_format_gen(fmt, fmtty0){
    if(typeof fmt === "number") return [0, 0, fmtty0];
    switch(fmt[0]){
      case 0:
       if(typeof fmtty0 !== "number" && 0 === fmtty0[0]){
        var
         fmtty_rest = fmtty0[1],
         fmt_rest = fmt[1],
         match = type_format_gen(fmt_rest, fmtty_rest),
         fmtty = match[2],
         fmt$0 = match[1];
        return [0, [0, fmt$0], fmtty];
       }
       break;
      case 1:
       if(typeof fmtty0 !== "number" && 0 === fmtty0[0]){
        var
         fmtty_rest$0 = fmtty0[1],
         fmt_rest$0 = fmt[1],
         match$0 = type_format_gen(fmt_rest$0, fmtty_rest$0),
         fmtty$0 = match$0[2],
         fmt$1 = match$0[1];
        return [0, [1, fmt$1], fmtty$0];
       }
       break;
      case 2:
       var
        fmt_rest$1 = fmt[2],
        pad = fmt[1],
        match$1 = type_padding(pad, fmtty0),
        pad$0 = match$1[1],
        match$2 = match$1[2];
       if(typeof match$2 !== "number" && 1 === match$2[0]){
        var
         fmtty_rest$1 = match$2[1],
         match$3 = type_format_gen(fmt_rest$1, fmtty_rest$1),
         fmtty$1 = match$3[2],
         fmt$2 = match$3[1];
        return [0, [2, pad$0, fmt$2], fmtty$1];
       }
       throw caml_maybe_attach_backtrace(Type_mismatch, 1);
      case 3:
       var
        fmt_rest$2 = fmt[2],
        pad$1 = fmt[1],
        match$4 = type_padding(pad$1, fmtty0),
        pad$2 = match$4[1],
        match$5 = match$4[2];
       if(typeof match$5 !== "number" && 1 === match$5[0]){
        var
         fmtty_rest$2 = match$5[1],
         match$6 = type_format_gen(fmt_rest$2, fmtty_rest$2),
         fmtty$2 = match$6[2],
         fmt$3 = match$6[1];
        return [0, [3, pad$2, fmt$3], fmtty$2];
       }
       throw caml_maybe_attach_backtrace(Type_mismatch, 1);
      case 4:
       var
        fmt_rest$3 = fmt[4],
        prec = fmt[3],
        pad$3 = fmt[2],
        iconv = fmt[1],
        match$7 = type_padprec(pad$3, prec, fmtty0),
        pad$4 = match$7[1],
        match$8 = match$7[3];
       if(typeof match$8 !== "number" && 2 === match$8[0]){
        var
         fmtty_rest$3 = match$8[1],
         prec$0 = match$7[2],
         match$9 = type_format_gen(fmt_rest$3, fmtty_rest$3),
         fmtty$3 = match$9[2],
         fmt$4 = match$9[1];
        return [0, [4, iconv, pad$4, prec$0, fmt$4], fmtty$3];
       }
       throw caml_maybe_attach_backtrace(Type_mismatch, 1);
      case 5:
       var
        fmt_rest$4 = fmt[4],
        prec$1 = fmt[3],
        pad$5 = fmt[2],
        iconv$0 = fmt[1],
        match$10 = type_padprec(pad$5, prec$1, fmtty0),
        pad$6 = match$10[1],
        match$11 = match$10[3];
       if(typeof match$11 !== "number" && 3 === match$11[0]){
        var
         fmtty_rest$4 = match$11[1],
         prec$2 = match$10[2],
         match$12 = type_format_gen(fmt_rest$4, fmtty_rest$4),
         fmtty$4 = match$12[2],
         fmt$5 = match$12[1];
        return [0, [5, iconv$0, pad$6, prec$2, fmt$5], fmtty$4];
       }
       throw caml_maybe_attach_backtrace(Type_mismatch, 1);
      case 6:
       var
        fmt_rest$5 = fmt[4],
        prec$3 = fmt[3],
        pad$7 = fmt[2],
        iconv$1 = fmt[1],
        match$13 = type_padprec(pad$7, prec$3, fmtty0),
        pad$8 = match$13[1],
        match$14 = match$13[3];
       if(typeof match$14 !== "number" && 4 === match$14[0]){
        var
         fmtty_rest$5 = match$14[1],
         prec$4 = match$13[2],
         match$15 = type_format_gen(fmt_rest$5, fmtty_rest$5),
         fmtty$5 = match$15[2],
         fmt$6 = match$15[1];
        return [0, [6, iconv$1, pad$8, prec$4, fmt$6], fmtty$5];
       }
       throw caml_maybe_attach_backtrace(Type_mismatch, 1);
      case 7:
       var
        fmt_rest$6 = fmt[4],
        prec$5 = fmt[3],
        pad$9 = fmt[2],
        iconv$2 = fmt[1],
        match$16 = type_padprec(pad$9, prec$5, fmtty0),
        pad$10 = match$16[1],
        match$17 = match$16[3];
       if(typeof match$17 !== "number" && 5 === match$17[0]){
        var
         fmtty_rest$6 = match$17[1],
         prec$6 = match$16[2],
         match$18 = type_format_gen(fmt_rest$6, fmtty_rest$6),
         fmtty$6 = match$18[2],
         fmt$7 = match$18[1];
        return [0, [7, iconv$2, pad$10, prec$6, fmt$7], fmtty$6];
       }
       throw caml_maybe_attach_backtrace(Type_mismatch, 1);
      case 8:
       var
        fmt_rest$7 = fmt[4],
        prec$7 = fmt[3],
        pad$11 = fmt[2],
        fconv = fmt[1],
        match$19 = type_padprec(pad$11, prec$7, fmtty0),
        pad$12 = match$19[1],
        match$20 = match$19[3];
       if(typeof match$20 !== "number" && 6 === match$20[0]){
        var
         fmtty_rest$7 = match$20[1],
         prec$8 = match$19[2],
         match$21 = type_format_gen(fmt_rest$7, fmtty_rest$7),
         fmtty$7 = match$21[2],
         fmt$8 = match$21[1];
        return [0, [8, fconv, pad$12, prec$8, fmt$8], fmtty$7];
       }
       throw caml_maybe_attach_backtrace(Type_mismatch, 1);
      case 9:
       var
        fmt_rest$8 = fmt[2],
        pad$13 = fmt[1],
        match$22 = type_padding(pad$13, fmtty0),
        pad$14 = match$22[1],
        match$23 = match$22[2];
       if(typeof match$23 !== "number" && 7 === match$23[0]){
        var
         fmtty_rest$8 = match$23[1],
         match$24 = type_format_gen(fmt_rest$8, fmtty_rest$8),
         fmtty$8 = match$24[2],
         fmt$9 = match$24[1];
        return [0, [9, pad$14, fmt$9], fmtty$8];
       }
       throw caml_maybe_attach_backtrace(Type_mismatch, 1);
      case 10:
       var
        fmt_rest$9 = fmt[1],
        match$25 = type_format_gen(fmt_rest$9, fmtty0),
        fmtty$9 = match$25[2],
        fmt$10 = match$25[1];
       return [0, [10, fmt$10], fmtty$9];
      case 11:
       var
        fmt_rest$10 = fmt[2],
        str = fmt[1],
        match$26 = type_format_gen(fmt_rest$10, fmtty0),
        fmtty$10 = match$26[2],
        fmt$11 = match$26[1];
       return [0, [11, str, fmt$11], fmtty$10];
      case 12:
       var
        fmt_rest$11 = fmt[2],
        chr = fmt[1],
        match$27 = type_format_gen(fmt_rest$11, fmtty0),
        fmtty$11 = match$27[2],
        fmt$12 = match$27[1];
       return [0, [12, chr, fmt$12], fmtty$11];
      case 13:
       if(typeof fmtty0 !== "number" && 8 === fmtty0[0]){
        var
         fmtty_rest$9 = fmtty0[2],
         sub_fmtty = fmtty0[1],
         fmt_rest$12 = fmt[3],
         sub_fmtty$0 = fmt[2],
         pad_opt = fmt[1];
        if(caml_notequal([0, sub_fmtty$0], [0, sub_fmtty]))
         throw caml_maybe_attach_backtrace(Type_mismatch, 1);
        var
         match$28 = type_format_gen(fmt_rest$12, fmtty_rest$9),
         fmtty$12 = match$28[2],
         fmt$13 = match$28[1];
        return [0, [13, pad_opt, sub_fmtty, fmt$13], fmtty$12];
       }
       break;
      case 14:
       if(typeof fmtty0 !== "number" && 9 === fmtty0[0]){
        var
         fmtty_rest$10 = fmtty0[3],
         sub_fmtty1 = fmtty0[1],
         fmt_rest$13 = fmt[3],
         sub_fmtty$1 = fmt[2],
         pad_opt$0 = fmt[1],
         _cy_ = [0, caml_call1(CamlinternalFormatBasics[2], sub_fmtty1)];
        if
         (caml_notequal
           ([0, caml_call1(CamlinternalFormatBasics[2], sub_fmtty$1)], _cy_))
         throw caml_maybe_attach_backtrace(Type_mismatch, 1);
        var
         match$29 =
           type_format_gen
            (fmt_rest$13,
             caml_call1(CamlinternalFormatBasics[2], fmtty_rest$10)),
         fmtty$13 = match$29[2],
         fmt$14 = match$29[1];
        return [0, [14, pad_opt$0, sub_fmtty1, fmt$14], fmtty$13];
       }
       break;
      case 15:
       if(typeof fmtty0 !== "number" && 10 === fmtty0[0]){
        var
         fmtty_rest$11 = fmtty0[1],
         fmt_rest$14 = fmt[1],
         match$30 = type_format_gen(fmt_rest$14, fmtty_rest$11),
         fmtty$14 = match$30[2],
         fmt$15 = match$30[1];
        return [0, [15, fmt$15], fmtty$14];
       }
       break;
      case 16:
       if(typeof fmtty0 !== "number" && 11 === fmtty0[0]){
        var
         fmtty_rest$12 = fmtty0[1],
         fmt_rest$15 = fmt[1],
         match$31 = type_format_gen(fmt_rest$15, fmtty_rest$12),
         fmtty$15 = match$31[2],
         fmt$16 = match$31[1];
        return [0, [16, fmt$16], fmtty$15];
       }
       break;
      case 17:
       var
        fmt_rest$16 = fmt[2],
        formatting_lit = fmt[1],
        match$32 = type_format_gen(fmt_rest$16, fmtty0),
        fmtty$16 = match$32[2],
        fmt$17 = match$32[1];
       return [0, [17, formatting_lit, fmt$17], fmtty$16];
      case 18:
       var fmt_rest$17 = fmt[2], formatting_gen = fmt[1];
       if(0 === formatting_gen[0]){
        var
         match$36 = formatting_gen[1],
         str$0 = match$36[2],
         fmt1 = match$36[1],
         match$37 = type_format_gen(fmt1, fmtty0),
         fmtty2 = match$37[2],
         fmt2 = match$37[1],
         match$38 = type_format_gen(fmt_rest$17, fmtty2),
         fmtty3 = match$38[2],
         fmt3 = match$38[1];
        return [0, [18, [0, [0, fmt2, str$0]], fmt3], fmtty3];
       }
       var
        match$39 = formatting_gen[1],
        str$1 = match$39[2],
        fmt1$0 = match$39[1],
        match$40 = type_format_gen(fmt1$0, fmtty0),
        fmtty2$0 = match$40[2],
        fmt2$0 = match$40[1],
        match$41 = type_format_gen(fmt_rest$17, fmtty2$0),
        fmtty3$0 = match$41[2],
        fmt3$0 = match$41[1];
       return [0, [18, [1, [0, fmt2$0, str$1]], fmt3$0], fmtty3$0];
      case 19:
       if(typeof fmtty0 !== "number" && 13 === fmtty0[0]){
        var
         fmtty_rest$13 = fmtty0[1],
         fmt_rest$18 = fmt[1],
         match$33 = type_format_gen(fmt_rest$18, fmtty_rest$13),
         fmtty$17 = match$33[2],
         fmt$18 = match$33[1];
        return [0, [19, fmt$18], fmtty$17];
       }
       break;
      case 20:
       if(typeof fmtty0 !== "number" && 1 === fmtty0[0]){
        var
         fmtty_rest$14 = fmtty0[1],
         fmt_rest$19 = fmt[3],
         char_set = fmt[2],
         width_opt = fmt[1],
         match$34 = type_format_gen(fmt_rest$19, fmtty_rest$14),
         fmtty$18 = match$34[2],
         fmt$19 = match$34[1];
        return [0, [20, width_opt, char_set, fmt$19], fmtty$18];
       }
       break;
      case 21:
       if(typeof fmtty0 !== "number" && 2 === fmtty0[0]){
        var
         fmtty_rest$15 = fmtty0[1],
         fmt_rest$20 = fmt[2],
         counter = fmt[1],
         match$35 = type_format_gen(fmt_rest$20, fmtty_rest$15),
         fmtty$19 = match$35[2],
         fmt$20 = match$35[1];
        return [0, [21, counter, fmt$20], fmtty$19];
       }
       break;
      case 23:
       var rest = fmt[2], ign = fmt[1];
       if(typeof ign !== "number")
        switch(ign[0]){
          case 0:
           return type_ignored_param_one(ign, rest, fmtty0);
          case 1:
           return type_ignored_param_one(ign, rest, fmtty0);
          case 2:
           return type_ignored_param_one(ign, rest, fmtty0);
          case 3:
           return type_ignored_param_one(ign, rest, fmtty0);
          case 4:
           return type_ignored_param_one(ign, rest, fmtty0);
          case 5:
           return type_ignored_param_one(ign, rest, fmtty0);
          case 6:
           return type_ignored_param_one(ign, rest, fmtty0);
          case 7:
           return type_ignored_param_one(ign, rest, fmtty0);
          case 8:
           var sub_fmtty$2 = ign[2], pad_opt$1 = ign[1];
           return type_ignored_param_one
                   ([8, pad_opt$1, sub_fmtty$2], rest, fmtty0);
          case 9:
           var
            sub_fmtty$3 = ign[2],
            pad_opt$2 = ign[1],
            _cz_ = type_ignored_format_substituti(sub_fmtty$3, rest, fmtty0),
            match$43 = _cz_[2],
            fmtty$21 = match$43[2],
            fmt$22 = match$43[1],
            sub_fmtty$4 = _cz_[1];
           return [0, [23, [9, pad_opt$2, sub_fmtty$4], fmt$22], fmtty$21];
          case 10:
           return type_ignored_param_one(ign, rest, fmtty0);
          default: return type_ignored_param_one(ign, rest, fmtty0);
        }
       switch(ign){
         case 0:
          return type_ignored_param_one(ign, rest, fmtty0);
         case 1:
          return type_ignored_param_one(ign, rest, fmtty0);
         case 2:
          if(typeof fmtty0 !== "number" && 14 === fmtty0[0]){
           var
            fmtty_rest$16 = fmtty0[1],
            match$42 = type_format_gen(rest, fmtty_rest$16),
            fmtty$20 = match$42[2],
            fmt$21 = match$42[1];
           return [0, [23, 2, fmt$21], fmtty$20];
          }
          throw caml_maybe_attach_backtrace(Type_mismatch, 1);
         default: return type_ignored_param_one(ign, rest, fmtty0);
       }
    }
    throw caml_maybe_attach_backtrace(Type_mismatch, 1);
   }
   function type_ignored_param_one(ign, fmt, fmtty){
    var
     match = type_format_gen(fmt, fmtty),
     fmtty$0 = match[2],
     fmt$0 = match[1];
    return [0, [23, ign, fmt$0], fmtty$0];
   }
   function type_ignored_format_substituti(sub_fmtty, fmt, fmtty){
    if(typeof sub_fmtty === "number")
     return [0, 0, type_format_gen(fmt, fmtty)];
    switch(sub_fmtty[0]){
      case 0:
       if(typeof fmtty !== "number" && 0 === fmtty[0]){
        var
         fmtty_rest = fmtty[1],
         sub_fmtty_rest = sub_fmtty[1],
         match =
           type_ignored_format_substituti(sub_fmtty_rest, fmt, fmtty_rest),
         fmt$0 = match[2],
         sub_fmtty_rest$0 = match[1];
        return [0, [0, sub_fmtty_rest$0], fmt$0];
       }
       break;
      case 1:
       if(typeof fmtty !== "number" && 1 === fmtty[0]){
        var
         fmtty_rest$0 = fmtty[1],
         sub_fmtty_rest$1 = sub_fmtty[1],
         match$0 =
           type_ignored_format_substituti(sub_fmtty_rest$1, fmt, fmtty_rest$0),
         fmt$1 = match$0[2],
         sub_fmtty_rest$2 = match$0[1];
        return [0, [1, sub_fmtty_rest$2], fmt$1];
       }
       break;
      case 2:
       if(typeof fmtty !== "number" && 2 === fmtty[0]){
        var
         fmtty_rest$1 = fmtty[1],
         sub_fmtty_rest$3 = sub_fmtty[1],
         match$1 =
           type_ignored_format_substituti(sub_fmtty_rest$3, fmt, fmtty_rest$1),
         fmt$2 = match$1[2],
         sub_fmtty_rest$4 = match$1[1];
        return [0, [2, sub_fmtty_rest$4], fmt$2];
       }
       break;
      case 3:
       if(typeof fmtty !== "number" && 3 === fmtty[0]){
        var
         fmtty_rest$2 = fmtty[1],
         sub_fmtty_rest$5 = sub_fmtty[1],
         match$2 =
           type_ignored_format_substituti(sub_fmtty_rest$5, fmt, fmtty_rest$2),
         fmt$3 = match$2[2],
         sub_fmtty_rest$6 = match$2[1];
        return [0, [3, sub_fmtty_rest$6], fmt$3];
       }
       break;
      case 4:
       if(typeof fmtty !== "number" && 4 === fmtty[0]){
        var
         fmtty_rest$3 = fmtty[1],
         sub_fmtty_rest$7 = sub_fmtty[1],
         match$3 =
           type_ignored_format_substituti(sub_fmtty_rest$7, fmt, fmtty_rest$3),
         fmt$4 = match$3[2],
         sub_fmtty_rest$8 = match$3[1];
        return [0, [4, sub_fmtty_rest$8], fmt$4];
       }
       break;
      case 5:
       if(typeof fmtty !== "number" && 5 === fmtty[0]){
        var
         fmtty_rest$4 = fmtty[1],
         sub_fmtty_rest$9 = sub_fmtty[1],
         match$4 =
           type_ignored_format_substituti(sub_fmtty_rest$9, fmt, fmtty_rest$4),
         fmt$5 = match$4[2],
         sub_fmtty_rest$10 = match$4[1];
        return [0, [5, sub_fmtty_rest$10], fmt$5];
       }
       break;
      case 6:
       if(typeof fmtty !== "number" && 6 === fmtty[0]){
        var
         fmtty_rest$5 = fmtty[1],
         sub_fmtty_rest$11 = sub_fmtty[1],
         match$5 =
           type_ignored_format_substituti
            (sub_fmtty_rest$11, fmt, fmtty_rest$5),
         fmt$6 = match$5[2],
         sub_fmtty_rest$12 = match$5[1];
        return [0, [6, sub_fmtty_rest$12], fmt$6];
       }
       break;
      case 7:
       if(typeof fmtty !== "number" && 7 === fmtty[0]){
        var
         fmtty_rest$6 = fmtty[1],
         sub_fmtty_rest$13 = sub_fmtty[1],
         match$6 =
           type_ignored_format_substituti
            (sub_fmtty_rest$13, fmt, fmtty_rest$6),
         fmt$7 = match$6[2],
         sub_fmtty_rest$14 = match$6[1];
        return [0, [7, sub_fmtty_rest$14], fmt$7];
       }
       break;
      case 8:
       if(typeof fmtty !== "number" && 8 === fmtty[0]){
        var
         fmtty_rest$7 = fmtty[2],
         sub2_fmtty = fmtty[1],
         sub_fmtty_rest$15 = sub_fmtty[2],
         sub2_fmtty$0 = sub_fmtty[1];
        if(caml_notequal([0, sub2_fmtty$0], [0, sub2_fmtty]))
         throw caml_maybe_attach_backtrace(Type_mismatch, 1);
        var
         match$7 =
           type_ignored_format_substituti
            (sub_fmtty_rest$15, fmt, fmtty_rest$7),
         fmt$8 = match$7[2],
         sub_fmtty_rest$16 = match$7[1];
        return [0, [8, sub2_fmtty, sub_fmtty_rest$16], fmt$8];
       }
       break;
      case 9:
       if(typeof fmtty !== "number" && 9 === fmtty[0]){
        var
         fmtty_rest$8 = fmtty[3],
         sub2_fmtty$1 = fmtty[2],
         sub1_fmtty = fmtty[1],
         sub_fmtty_rest$17 = sub_fmtty[3],
         sub2_fmtty$2 = sub_fmtty[2],
         sub1_fmtty$0 = sub_fmtty[1],
         _cw_ = [0, caml_call1(CamlinternalFormatBasics[2], sub1_fmtty)];
        if
         (caml_notequal
           ([0, caml_call1(CamlinternalFormatBasics[2], sub1_fmtty$0)], _cw_))
         throw caml_maybe_attach_backtrace(Type_mismatch, 1);
        var _cx_ = [0, caml_call1(CamlinternalFormatBasics[2], sub2_fmtty$1)];
        if
         (caml_notequal
           ([0, caml_call1(CamlinternalFormatBasics[2], sub2_fmtty$2)], _cx_))
         throw caml_maybe_attach_backtrace(Type_mismatch, 1);
        var
         sub_fmtty$0 = trans(symm(sub1_fmtty), sub2_fmtty$1),
         match$8 = fmtty_rel_det(sub_fmtty$0),
         f4 = match$8[4],
         f2 = match$8[2];
        f2(0);
        f4(0);
        var
         match$9 =
           type_ignored_format_substituti
            (caml_call1(CamlinternalFormatBasics[2], sub_fmtty_rest$17),
             fmt,
             fmtty_rest$8),
         fmt$9 = match$9[2],
         sub_fmtty_rest$18 = match$9[1];
        return [0,
                [9, sub1_fmtty, sub2_fmtty$1, symm(sub_fmtty_rest$18)],
                fmt$9];
       }
       break;
      case 10:
       if(typeof fmtty !== "number" && 10 === fmtty[0]){
        var
         fmtty_rest$9 = fmtty[1],
         sub_fmtty_rest$19 = sub_fmtty[1],
         match$10 =
           type_ignored_format_substituti
            (sub_fmtty_rest$19, fmt, fmtty_rest$9),
         fmt$10 = match$10[2],
         sub_fmtty_rest$20 = match$10[1];
        return [0, [10, sub_fmtty_rest$20], fmt$10];
       }
       break;
      case 11:
       if(typeof fmtty !== "number" && 11 === fmtty[0]){
        var
         fmtty_rest$10 = fmtty[1],
         sub_fmtty_rest$21 = sub_fmtty[1],
         match$11 =
           type_ignored_format_substituti
            (sub_fmtty_rest$21, fmt, fmtty_rest$10),
         fmt$11 = match$11[2],
         sub_fmtty_rest$22 = match$11[1];
        return [0, [11, sub_fmtty_rest$22], fmt$11];
       }
       break;
      case 13:
       if(typeof fmtty !== "number" && 13 === fmtty[0]){
        var
         fmtty_rest$11 = fmtty[1],
         sub_fmtty_rest$23 = sub_fmtty[1],
         match$12 =
           type_ignored_format_substituti
            (sub_fmtty_rest$23, fmt, fmtty_rest$11),
         fmt$12 = match$12[2],
         sub_fmtty_rest$24 = match$12[1];
        return [0, [13, sub_fmtty_rest$24], fmt$12];
       }
       break;
      case 14:
       if(typeof fmtty !== "number" && 14 === fmtty[0]){
        var
         fmtty_rest$12 = fmtty[1],
         sub_fmtty_rest$25 = sub_fmtty[1],
         match$13 =
           type_ignored_format_substituti
            (sub_fmtty_rest$25, fmt, fmtty_rest$12),
         fmt$13 = match$13[2],
         sub_fmtty_rest$26 = match$13[1];
        return [0, [14, sub_fmtty_rest$26], fmt$13];
       }
       break;
    }
    throw caml_maybe_attach_backtrace(Type_mismatch, 1);
   }
   function recast(fmt, fmtty){
    var _cv_ = symm(fmtty);
    return type_format(fmt, caml_call1(CamlinternalFormatBasics[2], _cv_));
   }
   function fix_padding(padty, width, str){
    var
     len = caml_ml_string_length(str),
     padty$0 = 0 <= width ? padty : 0,
     width$0 = caml_call1(Stdlib[18], width);
    if(width$0 <= len) return str;
    var
     _cu_ = 2 === padty$0 ? 48 : 32,
     res = caml_call2(Stdlib_Bytes[1], width$0, _cu_);
    switch(padty$0){
      case 0:
       caml_call5(Stdlib_String[48], str, 0, res, 0, len); break;
      case 1:
       caml_call5(Stdlib_String[48], str, 0, res, width$0 - len | 0, len);
       break;
      default:
       a:
       if(0 < len){
        if
         (43 !== caml_string_get(str, 0)
          && 45 !== caml_string_get(str, 0) && 32 !== caml_string_get(str, 0))
         break a;
        caml_bytes_set(res, 0, caml_string_get(str, 0));
        caml_call5
         (Stdlib_String[48],
          str,
          1,
          res,
          (width$0 - len | 0) + 1 | 0,
          len - 1 | 0);
        break;
       }
       a:
       if(1 < len && 48 === caml_string_get(str, 0)){
        if(120 !== caml_string_get(str, 1) && 88 !== caml_string_get(str, 1))
         break a;
        caml_bytes_set(res, 1, caml_string_get(str, 1));
        caml_call5
         (Stdlib_String[48],
          str,
          2,
          res,
          (width$0 - len | 0) + 2 | 0,
          len - 2 | 0);
        break;
       }
       caml_call5(Stdlib_String[48], str, 0, res, width$0 - len | 0, len);
    }
    return caml_call1(Stdlib_Bytes[48], res);
   }
   function fix_int_precision(prec, str){
    var
     prec$0 = caml_call1(Stdlib[18], prec),
     len = caml_ml_string_length(str),
     c = caml_string_get(str, 0);
    a:
    {
     b:
     {
      if(58 > c){
       if(32 !== c){
        if(43 > c) break a;
        switch(c - 43 | 0){
          case 5:
           c:
           if(len < (prec$0 + 2 | 0) && 1 < len){
            if
             (120 !== caml_string_get(str, 1)
              && 88 !== caml_string_get(str, 1))
             break c;
            var res$1 = caml_call2(Stdlib_Bytes[1], prec$0 + 2 | 0, 48);
            caml_bytes_set(res$1, 1, caml_string_get(str, 1));
            caml_call5
             (Stdlib_String[48],
              str,
              2,
              res$1,
              (prec$0 - len | 0) + 4 | 0,
              len - 2 | 0);
            return caml_call1(Stdlib_Bytes[48], res$1);
           }
           break b;
          case 0:
          case 2: break;
          case 1:
          case 3:
          case 4:
           break a;
          default: break b;
        }
       }
       if(len >= (prec$0 + 1 | 0)) break a;
       var res$0 = caml_call2(Stdlib_Bytes[1], prec$0 + 1 | 0, 48);
       caml_bytes_set(res$0, 0, c);
       caml_call5
        (Stdlib_String[48],
         str,
         1,
         res$0,
         (prec$0 - len | 0) + 2 | 0,
         len - 1 | 0);
       return caml_call1(Stdlib_Bytes[48], res$0);
      }
      if(71 <= c){if(5 < c - 97 >>> 0) break a;} else if(65 > c) break a;
     }
     if(len < prec$0){
      var res = caml_call2(Stdlib_Bytes[1], prec$0, 48);
      caml_call5(Stdlib_String[48], str, 0, res, prec$0 - len | 0, len);
      return caml_call1(Stdlib_Bytes[48], res);
     }
    }
    return str;
   }
   function string_to_caml_string(str){
    var
     str$0 = caml_call1(Stdlib_String[24], str),
     l = caml_ml_string_length(str$0),
     res = caml_call2(Stdlib_Bytes[1], l + 2 | 0, 34);
    caml_blit_string(str$0, 0, res, 1, l);
    return caml_call1(Stdlib_Bytes[48], res);
   }
   function format_of_fconv(fconv, prec){
    var
     prec$0 = caml_call1(Stdlib[18], prec),
     symb = char_of_fconv(_r_, fconv),
     buf = buffer_create(16);
    buffer_add_char(buf, 37);
    bprint_fconv_flag(buf, fconv);
    buffer_add_char(buf, 46);
    buffer_add_string(buf, caml_call1(Stdlib_Int[12], prec$0));
    buffer_add_char(buf, symb);
    return buffer_contents(buf);
   }
   function transform_int_alt(iconv, s){
    if(13 > iconv) return s;
    var n = [0, 0], _cp_ = caml_ml_string_length(s) - 1 | 0, _co_ = 0;
    if(_cp_ >= 0){
     var i$0 = _co_;
     for(;;){
      if(9 >= caml_string_unsafe_get(s, i$0) - 48 >>> 0) n[1]++;
      var _ct_ = i$0 + 1 | 0;
      if(_cp_ === i$0) break;
      i$0 = _ct_;
     }
    }
    var
     digits = n[1],
     buf =
       caml_create_bytes
        (caml_ml_string_length(s) + ((digits - 1 | 0) / 3 | 0) | 0),
     pos = [0, 0];
    function put(c){caml_bytes_set(buf, pos[1], c); pos[1]++; return;}
    var
     left = [0, ((digits - 1 | 0) % 3 | 0) + 1 | 0],
     _cr_ = caml_ml_string_length(s) - 1 | 0,
     _cq_ = 0;
    if(_cr_ >= 0){
     var i = _cq_;
     for(;;){
      var c = caml_string_unsafe_get(s, i);
      if(9 < c - 48 >>> 0)
       put(c);
      else{if(0 === left[1]){put(95); left[1] = 3;} left[1]--; put(c);}
      var _cs_ = i + 1 | 0;
      if(_cr_ === i) break;
      i = _cs_;
     }
    }
    return caml_call1(Stdlib_Bytes[48], buf);
   }
   function convert_int(iconv, n){
    switch(iconv){
      case 1:
       var _cn_ = cst_d$0; break;
      case 2:
       var _cn_ = cst_d$1; break;
      case 4:
       var _cn_ = cst_i$1; break;
      case 5:
       var _cn_ = cst_i$2; break;
      case 6:
       var _cn_ = cst_x; break;
      case 7:
       var _cn_ = cst_x$0; break;
      case 8:
       var _cn_ = cst_X; break;
      case 9:
       var _cn_ = cst_X$0; break;
      case 10:
       var _cn_ = cst_o; break;
      case 11:
       var _cn_ = cst_o$0; break;
      case 0:
      case 13:
       var _cn_ = cst_d; break;
      case 3:
      case 14:
       var _cn_ = cst_i$0; break;
      default: var _cn_ = cst_u;
    }
    return transform_int_alt(iconv, caml_format_int(_cn_, n));
   }
   function convert_int32(iconv, n){
    switch(iconv){
      case 1:
       var _cm_ = cst_ld$0; break;
      case 2:
       var _cm_ = cst_ld$1; break;
      case 4:
       var _cm_ = cst_li$1; break;
      case 5:
       var _cm_ = cst_li$2; break;
      case 6:
       var _cm_ = cst_lx; break;
      case 7:
       var _cm_ = cst_lx$0; break;
      case 8:
       var _cm_ = cst_lX; break;
      case 9:
       var _cm_ = cst_lX$0; break;
      case 10:
       var _cm_ = cst_lo; break;
      case 11:
       var _cm_ = cst_lo$0; break;
      case 0:
      case 13:
       var _cm_ = cst_ld; break;
      case 3:
      case 14:
       var _cm_ = cst_li$0; break;
      default: var _cm_ = cst_lu;
    }
    return transform_int_alt(iconv, caml_format_int(_cm_, n));
   }
   function convert_nativeint(iconv, n){
    switch(iconv){
      case 1:
       var _cl_ = cst_nd$0; break;
      case 2:
       var _cl_ = cst_nd$1; break;
      case 4:
       var _cl_ = cst_ni$1; break;
      case 5:
       var _cl_ = cst_ni$2; break;
      case 6:
       var _cl_ = cst_nx; break;
      case 7:
       var _cl_ = cst_nx$0; break;
      case 8:
       var _cl_ = cst_nX; break;
      case 9:
       var _cl_ = cst_nX$0; break;
      case 10:
       var _cl_ = cst_no; break;
      case 11:
       var _cl_ = cst_no$0; break;
      case 0:
      case 13:
       var _cl_ = cst_nd; break;
      case 3:
      case 14:
       var _cl_ = cst_ni$0; break;
      default: var _cl_ = cst_nu;
    }
    return transform_int_alt(iconv, caml_format_int(_cl_, n));
   }
   function convert_int64(iconv, n){
    switch(iconv){
      case 1:
       var _ck_ = cst_Ld$0; break;
      case 2:
       var _ck_ = cst_Ld$1; break;
      case 4:
       var _ck_ = cst_Li$1; break;
      case 5:
       var _ck_ = cst_Li$2; break;
      case 6:
       var _ck_ = cst_Lx; break;
      case 7:
       var _ck_ = cst_Lx$0; break;
      case 8:
       var _ck_ = cst_LX; break;
      case 9:
       var _ck_ = cst_LX$0; break;
      case 10:
       var _ck_ = cst_Lo; break;
      case 11:
       var _ck_ = cst_Lo$0; break;
      case 0:
      case 13:
       var _ck_ = cst_Ld; break;
      case 3:
      case 14:
       var _ck_ = cst_Li$0; break;
      default: var _ck_ = cst_Lu;
    }
    return transform_int_alt(iconv, runtime.caml_int64_format(_ck_, n));
   }
   function convert_float(fconv, prec, x){
    function hex(param){
     switch(fconv[1]){
       case 0:
        var sign = 45; break;
       case 1:
        var sign = 43; break;
       default: var sign = 32;
     }
     return runtime.caml_hexstring_of_float(x, prec, sign);
    }
    function caml_special_val(str){
     var match = runtime.caml_classify_float(x);
     return 3 === match
             ? x < 0. ? cst_neg_infinity : cst_infinity
             : 4 <= match ? cst_nan : str;
    }
    switch(fconv[2]){
      case 5:
       var
        str = caml_format_float(format_of_fconv(fconv, prec), x),
        len = caml_ml_string_length(str),
        i = 0;
       for(;;){
        if(i === len)
         var _ch_ = 0;
        else{
         var _cg_ = caml_string_get(str, i) - 46 | 0;
         a:
         {
          if(23 < _cg_ >>> 0){
           if(55 === _cg_) break a;
          }
          else if(21 < _cg_ - 1 >>> 0) break a;
          var i$0 = i + 1 | 0;
          i = i$0;
          continue;
         }
         var _ch_ = 1;
        }
        var _ci_ = _ch_ ? str : caml_call2(Stdlib[28], str, cst$17);
        return caml_special_val(_ci_);
       }
      case 6:
       return hex(0);
      case 7:
       var _cj_ = hex(0); return caml_call1(Stdlib_String[25], _cj_);
      case 8:
       return caml_special_val(hex(0));
      default: return caml_format_float(format_of_fconv(fconv, prec), x);
    }
   }
   function string_of_fmtty(fmtty){
    var buf = buffer_create(16);
    bprint_fmtty(buf, fmtty);
    return buffer_contents(buf);
   }
   function make_printf$0(counter, k, acc, fmt){
    var k$0 = k, acc$0 = acc, fmt$0 = fmt;
    for(;;){
     if(typeof fmt$0 === "number") return caml_call1(k$0, acc$0);
     switch(fmt$0[0]){
       case 0:
        var rest = fmt$0[1];
        return function(c){
         var new_acc = [5, acc$0, c];
         return make_printf(k$0, new_acc, rest);};
       case 1:
        var rest$0 = fmt$0[1];
        return function(c){
         var
          str = caml_call1(Stdlib_Char[2], c),
          l = caml_ml_string_length(str),
          res = caml_call2(Stdlib_Bytes[1], l + 2 | 0, 39);
         caml_blit_string(str, 0, res, 1, l);
         var new_acc = [4, acc$0, caml_call1(Stdlib_Bytes[48], res)];
         return make_printf(k$0, new_acc, rest$0);};
       case 2:
        var rest$1 = fmt$0[2], pad = fmt$0[1];
        return make_padding
                (k$0, acc$0, rest$1, pad, function(str){return str;});
       case 3:
        var rest$2 = fmt$0[2], pad$0 = fmt$0[1];
        return make_padding(k$0, acc$0, rest$2, pad$0, string_to_caml_string);
       case 4:
        var
         rest$3 = fmt$0[4],
         prec = fmt$0[3],
         pad$1 = fmt$0[2],
         iconv = fmt$0[1];
        return make_int_padding_precision
                (k$0, acc$0, rest$3, pad$1, prec, convert_int, iconv);
       case 5:
        var
         rest$4 = fmt$0[4],
         prec$0 = fmt$0[3],
         pad$2 = fmt$0[2],
         iconv$0 = fmt$0[1];
        return make_int_padding_precision
                (k$0, acc$0, rest$4, pad$2, prec$0, convert_int32, iconv$0);
       case 6:
        var
         rest$5 = fmt$0[4],
         prec$1 = fmt$0[3],
         pad$3 = fmt$0[2],
         iconv$1 = fmt$0[1];
        return make_int_padding_precision
                (k$0,
                 acc$0,
                 rest$5,
                 pad$3,
                 prec$1,
                 convert_nativeint,
                 iconv$1);
       case 7:
        var
         rest$6 = fmt$0[4],
         prec$2 = fmt$0[3],
         pad$4 = fmt$0[2],
         iconv$2 = fmt$0[1];
        return make_int_padding_precision
                (k$0, acc$0, rest$6, pad$4, prec$2, convert_int64, iconv$2);
       case 8:
        var
         rest$7 = fmt$0[4],
         prec$3 = fmt$0[3],
         pad$5 = fmt$0[2],
         fconv = fmt$0[1];
        if(typeof pad$5 === "number"){
         if(typeof prec$3 === "number")
          return prec$3
                  ? function
                   (p, x){
                    var str = convert_float(fconv, p, x);
                    return make_printf(k$0, [4, acc$0, str], rest$7);
                   }
                  : function
                   (x){
                    var
                     str =
                       convert_float(fconv, default_float_precision(fconv), x);
                    return make_printf(k$0, [4, acc$0, str], rest$7);
                   };
         var p = prec$3[1];
         return function(x){
          var str = convert_float(fconv, p, x);
          return make_printf(k$0, [4, acc$0, str], rest$7);};
        }
        if(0 === pad$5[0]){
         var w = pad$5[2], padty = pad$5[1];
         if(typeof prec$3 === "number")
          return prec$3
                  ? function
                   (p, x){
                    var str = fix_padding(padty, w, convert_float(fconv, p, x));
                    return make_printf(k$0, [4, acc$0, str], rest$7);
                   }
                  : function
                   (x){
                    var
                     str =
                       convert_float(fconv, default_float_precision(fconv), x),
                     str$0 = fix_padding(padty, w, str);
                    return make_printf(k$0, [4, acc$0, str$0], rest$7);
                   };
         var p$0 = prec$3[1];
         return function(x){
          var str = fix_padding(padty, w, convert_float(fconv, p$0, x));
          return make_printf(k$0, [4, acc$0, str], rest$7);};
        }
        var padty$0 = pad$5[1];
        if(typeof prec$3 === "number")
         return prec$3
                 ? function
                  (w, p, x){
                   var
                    str = fix_padding(padty$0, w, convert_float(fconv, p, x));
                   return make_printf(k$0, [4, acc$0, str], rest$7);
                  }
                 : function
                  (w, x){
                   var
                    str =
                      convert_float(fconv, default_float_precision(fconv), x),
                    str$0 = fix_padding(padty$0, w, str);
                   return make_printf(k$0, [4, acc$0, str$0], rest$7);
                  };
        var p$1 = prec$3[1];
        return function(w, x){
         var str = fix_padding(padty$0, w, convert_float(fconv, p$1, x));
         return make_printf(k$0, [4, acc$0, str], rest$7);};
       case 9:
        var rest$8 = fmt$0[2], pad$6 = fmt$0[1];
        return make_padding(k$0, acc$0, rest$8, pad$6, Stdlib[30]);
       case 10:
        var rest$9 = fmt$0[1], acc$1 = [7, acc$0];
        acc$0 = acc$1;
        fmt$0 = rest$9;
        break;
       case 11:
        var rest$10 = fmt$0[2], str = fmt$0[1], acc$2 = [2, acc$0, str];
        acc$0 = acc$2;
        fmt$0 = rest$10;
        break;
       case 12:
        var rest$11 = fmt$0[2], chr = fmt$0[1], acc$3 = [3, acc$0, chr];
        acc$0 = acc$3;
        fmt$0 = rest$11;
        break;
       case 13:
        var
         rest$12 = fmt$0[3],
         sub_fmtty = fmt$0[2],
         ty = string_of_fmtty(sub_fmtty);
        return function(str){
         return make_printf(k$0, [4, acc$0, ty], rest$12);};
       case 14:
        var rest$13 = fmt$0[3], fmtty = fmt$0[2];
        return function(param){
         var fmt = param[1], _cf_ = recast(fmt, fmtty);
         return make_printf
                 (k$0,
                  acc$0,
                  caml_call2(CamlinternalFormatBasics[3], _cf_, rest$13));};
       case 15:
        var rest$14 = fmt$0[1];
        return function(f, x){
         return make_printf
                 (k$0,
                  [6, acc$0, function(o){return caml_call2(f, o, x);}],
                  rest$14);};
       case 16:
        var rest$15 = fmt$0[1];
        return function(f){return make_printf(k$0, [6, acc$0, f], rest$15);};
       case 17:
        var
         rest$16 = fmt$0[2],
         fmting_lit = fmt$0[1],
         acc$4 = [0, acc$0, fmting_lit];
        acc$0 = acc$4;
        fmt$0 = rest$16;
        break;
       case 18:
        var _cd_ = fmt$0[1];
        if(0 === _cd_[0]){
         var rest$17 = fmt$0[2], fmt$1 = _cd_[1][1];
         let acc = acc$0, k = k$0, rest = rest$17;
         var
          k$1 =
            function(kacc){return make_printf(k, [1, acc, [0, kacc]], rest);};
         k$0 = k$1;
         acc$0 = 0;
         fmt$0 = fmt$1;
        }
        else{
         var rest$18 = fmt$0[2], fmt$2 = _cd_[1][1];
         let acc = acc$0, k = k$0, rest = rest$18;
         var
          k$2 =
            function(kacc){return make_printf(k, [1, acc, [1, kacc]], rest);};
         k$0 = k$2;
         acc$0 = 0;
         fmt$0 = fmt$2;
        }
        break;
       case 19:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _s_], 1);
       case 20:
        var
         rest$19 = fmt$0[3],
         new_acc = [8, acc$0, cst_Printf_bad_conversion];
        return function(param){return make_printf(k$0, new_acc, rest$19);};
       case 21:
        var rest$20 = fmt$0[2];
        return function(n){
         var new_acc = [4, acc$0, caml_format_int(cst_u$0, n)];
         return make_printf(k$0, new_acc, rest$20);};
       case 22:
        var rest$21 = fmt$0[1];
        return function(c){
         var new_acc = [5, acc$0, c];
         return make_printf(k$0, new_acc, rest$21);};
       case 23:
        var rest$22 = fmt$0[2], ign = fmt$0[1];
        if(counter >= 50)
         return caml_trampoline_return
                 (make_ignored_param$0, [0, k$0, acc$0, ign, rest$22]);
        var counter$1 = counter + 1 | 0;
        return make_ignored_param$0(counter$1, k$0, acc$0, ign, rest$22);
       default:
        var
         rest$23 = fmt$0[3],
         f = fmt$0[2],
         arity = fmt$0[1],
         _ce_ = caml_call1(f, 0);
        if(counter >= 50)
         return caml_trampoline_return
                 (make_custom$0, [0, k$0, acc$0, rest$23, arity, _ce_]);
        var counter$0 = counter + 1 | 0;
        return make_custom$0(counter$0, k$0, acc$0, rest$23, arity, _ce_);
     }
    }
   }
   function make_printf(k, acc, fmt){
    return caml_trampoline(make_printf$0(0, k, acc, fmt));
   }
   function make_ignored_param$0(counter, k, acc, ign, fmt){
    if(typeof ign === "number")
     switch(ign){
       case 0:
        if(counter >= 50)
         return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
        var counter$0 = counter + 1 | 0;
        return make_invalid_arg(counter$0, k, acc, fmt);
       case 1:
        if(counter >= 50)
         return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
        var counter$1 = counter + 1 | 0;
        return make_invalid_arg(counter$1, k, acc, fmt);
       case 2:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _t_], 1);
       default:
        if(counter >= 50)
         return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
        var counter$2 = counter + 1 | 0;
        return make_invalid_arg(counter$2, k, acc, fmt);
     }
    switch(ign[0]){
      case 0:
       if(counter >= 50)
        return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
       var counter$3 = counter + 1 | 0;
       return make_invalid_arg(counter$3, k, acc, fmt);
      case 1:
       if(counter >= 50)
        return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
       var counter$4 = counter + 1 | 0;
       return make_invalid_arg(counter$4, k, acc, fmt);
      case 2:
       if(counter >= 50)
        return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
       var counter$5 = counter + 1 | 0;
       return make_invalid_arg(counter$5, k, acc, fmt);
      case 3:
       if(counter >= 50)
        return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
       var counter$6 = counter + 1 | 0;
       return make_invalid_arg(counter$6, k, acc, fmt);
      case 4:
       if(counter >= 50)
        return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
       var counter$7 = counter + 1 | 0;
       return make_invalid_arg(counter$7, k, acc, fmt);
      case 5:
       if(counter >= 50)
        return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
       var counter$8 = counter + 1 | 0;
       return make_invalid_arg(counter$8, k, acc, fmt);
      case 6:
       if(counter >= 50)
        return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
       var counter$9 = counter + 1 | 0;
       return make_invalid_arg(counter$9, k, acc, fmt);
      case 7:
       if(counter >= 50)
        return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
       var counter$10 = counter + 1 | 0;
       return make_invalid_arg(counter$10, k, acc, fmt);
      case 8:
       if(counter >= 50)
        return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
       var counter$11 = counter + 1 | 0;
       return make_invalid_arg(counter$11, k, acc, fmt);
      case 9:
       var fmtty = ign[2];
       if(counter >= 50)
        return caml_trampoline_return
                (make_from_fmtty$0, [0, k, acc, fmtty, fmt]);
       var counter$14 = counter + 1 | 0;
       return make_from_fmtty$0(counter$14, k, acc, fmtty, fmt);
      case 10:
       if(counter >= 50)
        return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
       var counter$12 = counter + 1 | 0;
       return make_invalid_arg(counter$12, k, acc, fmt);
      default:
       if(counter >= 50)
        return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
       var counter$13 = counter + 1 | 0;
       return make_invalid_arg(counter$13, k, acc, fmt);
    }
   }
   function make_ignored_param(k, acc, ign, fmt){
    return caml_trampoline(make_ignored_param$0(0, k, acc, ign, fmt));
   }
   function make_from_fmtty$0(counter, k, acc, fmtty, fmt){
    if(typeof fmtty !== "number")
     switch(fmtty[0]){
       case 0:
        var rest = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest, fmt);};
       case 1:
        var rest$0 = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest$0, fmt);};
       case 2:
        var rest$1 = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest$1, fmt);};
       case 3:
        var rest$2 = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest$2, fmt);};
       case 4:
        var rest$3 = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest$3, fmt);};
       case 5:
        var rest$4 = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest$4, fmt);};
       case 6:
        var rest$5 = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest$5, fmt);};
       case 7:
        var rest$6 = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest$6, fmt);};
       case 8:
        var rest$7 = fmtty[2];
        return function(param){return make_from_fmtty(k, acc, rest$7, fmt);};
       case 9:
        var
         rest$8 = fmtty[3],
         ty2 = fmtty[2],
         ty1 = fmtty[1],
         ty = trans(symm(ty1), ty2);
        return function(param){
         return make_from_fmtty
                 (k,
                  acc,
                  caml_call2(CamlinternalFormatBasics[1], ty, rest$8),
                  fmt);};
       case 10:
        var rest$9 = fmtty[1];
        return function(param, _cc_){
         return make_from_fmtty(k, acc, rest$9, fmt);};
       case 11:
        var rest$10 = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest$10, fmt);};
       case 12:
        var rest$11 = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest$11, fmt);};
       case 13:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _u_], 1);
       default:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _v_], 1);
     }
    if(counter >= 50)
     return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
    var counter$0 = counter + 1 | 0;
    return make_invalid_arg(counter$0, k, acc, fmt);
   }
   function make_from_fmtty(k, acc, fmtty, fmt){
    return caml_trampoline(make_from_fmtty$0(0, k, acc, fmtty, fmt));
   }
   function make_invalid_arg(counter, k, acc, fmt){
    var _cb_ = [8, acc, cst_Printf_bad_conversion$0];
    if(counter >= 50)
     return caml_trampoline_return(make_printf$0, [0, k, _cb_, fmt]);
    var counter$0 = counter + 1 | 0;
    return make_printf$0(counter$0, k, _cb_, fmt);
   }
   function make_padding(k, acc, fmt, pad, trans){
    if(typeof pad === "number")
     return function(x){
      var new_acc = [4, acc, caml_call1(trans, x)];
      return make_printf(k, new_acc, fmt);};
    if(0 === pad[0]){
     var width = pad[2], padty = pad[1];
     return function(x){
      var new_acc = [4, acc, fix_padding(padty, width, caml_call1(trans, x))];
      return make_printf(k, new_acc, fmt);};
    }
    var padty$0 = pad[1];
    return function(w, x){
     var new_acc = [4, acc, fix_padding(padty$0, w, caml_call1(trans, x))];
     return make_printf(k, new_acc, fmt);};
   }
   function make_int_padding_precision(k, acc, fmt, pad, prec, trans, iconv){
    if(typeof pad === "number"){
     if(typeof prec === "number")
      return prec
              ? function
               (p, x){
                var str = fix_int_precision(p, caml_call2(trans, iconv, x));
                return make_printf(k, [4, acc, str], fmt);
               }
              : function
               (x){
                var str = caml_call2(trans, iconv, x);
                return make_printf(k, [4, acc, str], fmt);
               };
     var p = prec[1];
     return function(x){
      var str = fix_int_precision(p, caml_call2(trans, iconv, x));
      return make_printf(k, [4, acc, str], fmt);};
    }
    if(0 === pad[0]){
     var w = pad[2], padty = pad[1];
     if(typeof prec === "number")
      return prec
              ? function
               (p, x){
                var
                 str =
                   fix_padding
                    (padty,
                     w,
                     fix_int_precision(p, caml_call2(trans, iconv, x)));
                return make_printf(k, [4, acc, str], fmt);
               }
              : function
               (x){
                var str = fix_padding(padty, w, caml_call2(trans, iconv, x));
                return make_printf(k, [4, acc, str], fmt);
               };
     var p$0 = prec[1];
     return function(x){
      var
       str =
         fix_padding
          (padty, w, fix_int_precision(p$0, caml_call2(trans, iconv, x)));
      return make_printf(k, [4, acc, str], fmt);};
    }
    var padty$0 = pad[1];
    if(typeof prec === "number")
     return prec
             ? function
              (w, p, x){
               var
                str =
                  fix_padding
                   (padty$0,
                    w,
                    fix_int_precision(p, caml_call2(trans, iconv, x)));
               return make_printf(k, [4, acc, str], fmt);
              }
             : function
              (w, x){
               var str = fix_padding(padty$0, w, caml_call2(trans, iconv, x));
               return make_printf(k, [4, acc, str], fmt);
              };
    var p$1 = prec[1];
    return function(w, x){
     var
      str =
        fix_padding
         (padty$0, w, fix_int_precision(p$1, caml_call2(trans, iconv, x)));
     return make_printf(k, [4, acc, str], fmt);};
   }
   function make_custom$0(counter, k, acc, rest, arity, f){
    if(arity){
     var arity$0 = arity[1];
     return function(x){
      return make_custom(k, acc, rest, arity$0, caml_call1(f, x));};
    }
    var _ca_ = [4, acc, f];
    if(counter >= 50)
     return caml_trampoline_return(make_printf$0, [0, k, _ca_, rest]);
    var counter$0 = counter + 1 | 0;
    return make_printf$0(counter$0, k, _ca_, rest);
   }
   function make_custom(k, acc, rest, arity, f){
    return caml_trampoline(make_custom$0(0, k, acc, rest, arity, f));
   }
   function make_iprintf$0(counter, k, o, fmt){
    var k$0 = k, fmt$0 = fmt;
    for(;;){
     if(typeof fmt$0 === "number") return caml_call1(k$0, o);
     switch(fmt$0[0]){
       case 0:
        var rest = fmt$0[1], x = make_iprintf(k$0, o, rest);
        return function(_b$_){return x;};
       case 1:
        var rest$0 = fmt$0[1], x$0 = make_iprintf(k$0, o, rest$0);
        return function(_b__){return x$0;};
       case 2:
        var _bM_ = fmt$0[1];
        if(typeof _bM_ === "number"){
         var rest$1 = fmt$0[2], x$1 = make_iprintf(k$0, o, rest$1);
         return function(_b9_){return x$1;};
        }
        if(0 === _bM_[0]){
         var rest$2 = fmt$0[2], x$2 = make_iprintf(k$0, o, rest$2);
         return function(_b8_){return x$2;};
        }
        var
         rest$3 = fmt$0[2],
         x$3 = make_iprintf(k$0, o, rest$3),
         x$4 = function(_b7_){return x$3;};
        return function(_b6_){return x$4;};
       case 3:
        var _bN_ = fmt$0[1];
        if(typeof _bN_ === "number"){
         var rest$4 = fmt$0[2], x$5 = make_iprintf(k$0, o, rest$4);
         return function(_b5_){return x$5;};
        }
        if(0 === _bN_[0]){
         var rest$5 = fmt$0[2], x$6 = make_iprintf(k$0, o, rest$5);
         return function(_b4_){return x$6;};
        }
        var
         rest$6 = fmt$0[2],
         x$7 = make_iprintf(k$0, o, rest$6),
         x$8 = function(_b3_){return x$7;};
        return function(_b2_){return x$8;};
       case 4:
        var rest$7 = fmt$0[4], prec = fmt$0[3], pad = fmt$0[2];
        return fn_of_padding_precision(k$0, o, rest$7, pad, prec);
       case 5:
        var rest$8 = fmt$0[4], prec$0 = fmt$0[3], pad$0 = fmt$0[2];
        return fn_of_padding_precision(k$0, o, rest$8, pad$0, prec$0);
       case 6:
        var rest$9 = fmt$0[4], prec$1 = fmt$0[3], pad$1 = fmt$0[2];
        return fn_of_padding_precision(k$0, o, rest$9, pad$1, prec$1);
       case 7:
        var rest$10 = fmt$0[4], prec$2 = fmt$0[3], pad$2 = fmt$0[2];
        return fn_of_padding_precision(k$0, o, rest$10, pad$2, prec$2);
       case 8:
        var rest$11 = fmt$0[4], prec$3 = fmt$0[3], pad$3 = fmt$0[2];
        return fn_of_padding_precision(k$0, o, rest$11, pad$3, prec$3);
       case 9:
        var _bO_ = fmt$0[1];
        if(typeof _bO_ === "number"){
         var rest$12 = fmt$0[2], x$9 = make_iprintf(k$0, o, rest$12);
         return function(_b1_){return x$9;};
        }
        if(0 === _bO_[0]){
         var rest$13 = fmt$0[2], x$10 = make_iprintf(k$0, o, rest$13);
         return function(_b0_){return x$10;};
        }
        var
         rest$14 = fmt$0[2],
         x$11 = make_iprintf(k$0, o, rest$14),
         x$12 = function(_bZ_){return x$11;};
        return function(_bY_){return x$12;};
       case 10:
        var rest$15 = fmt$0[1]; fmt$0 = rest$15; break;
       case 11:
        var rest$16 = fmt$0[2]; fmt$0 = rest$16; break;
       case 12:
        var rest$17 = fmt$0[2]; fmt$0 = rest$17; break;
       case 13:
        var rest$18 = fmt$0[3], x$13 = make_iprintf(k$0, o, rest$18);
        return function(_bX_){return x$13;};
       case 14:
        var rest$19 = fmt$0[3], fmtty = fmt$0[2];
        return function(param){
         var fmt = param[1], _bW_ = recast(fmt, fmtty);
         return make_iprintf
                 (k$0,
                  o,
                  caml_call2(CamlinternalFormatBasics[3], _bW_, rest$19));};
       case 15:
        var
         rest$20 = fmt$0[1],
         x$14 = make_iprintf(k$0, o, rest$20),
         x$15 = function(_bV_){return x$14;};
        return function(_bU_){return x$15;};
       case 16:
        var rest$21 = fmt$0[1], x$16 = make_iprintf(k$0, o, rest$21);
        return function(_bT_){return x$16;};
       case 17:
        var rest$22 = fmt$0[2]; fmt$0 = rest$22; break;
       case 18:
        var _bP_ = fmt$0[1];
        if(0 === _bP_[0]){
         var rest$23 = fmt$0[2], fmt$1 = _bP_[1][1];
         let k = k$0, rest = rest$23;
         var k$1 = function(koc){return make_iprintf(k, koc, rest);};
         k$0 = k$1;
         fmt$0 = fmt$1;
        }
        else{
         var rest$24 = fmt$0[2], fmt$2 = _bP_[1][1];
         let k = k$0, rest = rest$24;
         var k$2 = function(koc){return make_iprintf(k, koc, rest);};
         k$0 = k$2;
         fmt$0 = fmt$2;
        }
        break;
       case 19:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _w_], 1);
       case 20:
        var rest$25 = fmt$0[3], x$17 = make_iprintf(k$0, o, rest$25);
        return function(_bS_){return x$17;};
       case 21:
        var rest$26 = fmt$0[2], x$18 = make_iprintf(k$0, o, rest$26);
        return function(_bR_){return x$18;};
       case 22:
        var rest$27 = fmt$0[1], x$19 = make_iprintf(k$0, o, rest$27);
        return function(_bQ_){return x$19;};
       case 23:
        var rest$28 = fmt$0[2], ign = fmt$0[1];
        return make_ignored_param
                (function(param){return caml_call1(k$0, o);}, 0, ign, rest$28);
       default:
        var rest$29 = fmt$0[3], arity = fmt$0[1];
        if(counter >= 50)
         return caml_trampoline_return
                 (fn_of_custom_arity$0, [0, k$0, o, rest$29, arity]);
        var counter$0 = counter + 1 | 0;
        return fn_of_custom_arity$0(counter$0, k$0, o, rest$29, arity);
     }
    }
   }
   function make_iprintf(k, o, fmt){
    return caml_trampoline(make_iprintf$0(0, k, o, fmt));
   }
   function fn_of_padding_precision(k, o, fmt, pad, prec){
    if(typeof pad === "number"){
     if(typeof prec !== "number"){
      var x$2 = make_iprintf(k, o, fmt);
      return function(_bL_){return x$2;};
     }
     if(prec){
      var x = make_iprintf(k, o, fmt), x$0 = function(_bK_){return x;};
      return function(_bJ_){return x$0;};
     }
     var x$1 = make_iprintf(k, o, fmt);
     return function(_bI_){return x$1;};
    }
    if(0 === pad[0]){
     if(typeof prec !== "number"){
      var x$6 = make_iprintf(k, o, fmt);
      return function(_bH_){return x$6;};
     }
     if(prec){
      var x$3 = make_iprintf(k, o, fmt), x$4 = function(_bG_){return x$3;};
      return function(_bF_){return x$4;};
     }
     var x$5 = make_iprintf(k, o, fmt);
     return function(_bE_){return x$5;};
    }
    if(typeof prec !== "number"){
     var x$12 = make_iprintf(k, o, fmt), x$13 = function(_bD_){return x$12;};
     return function(_bC_){return x$13;};
    }
    if(prec){
     var
      x$7 = make_iprintf(k, o, fmt),
      x$8 = function(_bB_){return x$7;},
      x$9 = function(_bA_){return x$8;};
     return function(_bz_){return x$9;};
    }
    var x$10 = make_iprintf(k, o, fmt);
    function x$11(_by_){return x$10;}
    return function(_bx_){return x$11;};
   }
   function fn_of_custom_arity$0(counter, k, o, fmt, param){
    if(param){
     var arity = param[1], x = fn_of_custom_arity(k, o, fmt, arity);
     return function(_bw_){return x;};
    }
    if(counter >= 50)
     return caml_trampoline_return(make_iprintf$0, [0, k, o, fmt]);
    var counter$0 = counter + 1 | 0;
    return make_iprintf$0(counter$0, k, o, fmt);
   }
   function fn_of_custom_arity(k, o, fmt, param){
    return caml_trampoline(fn_of_custom_arity$0(0, k, o, fmt, param));
   }
   function output_acc(o, acc){
    var acc$0 = acc;
    for(;;){
     if(typeof acc$0 === "number") return 0;
     switch(acc$0[0]){
       case 0:
        var
         fmting_lit = acc$0[2],
         p = acc$0[1],
         s = string_of_formatting_lit(fmting_lit);
        output_acc(o, p);
        return caml_call2(Stdlib[66], o, s);
       case 1:
        var match = acc$0[2], p$0 = acc$0[1];
        if(0 === match[0]){
         var acc$1 = match[1];
         output_acc(o, p$0);
         caml_call2(Stdlib[66], o, cst$18);
         acc$0 = acc$1;
        }
        else{
         var acc$2 = match[1];
         output_acc(o, p$0);
         caml_call2(Stdlib[66], o, cst$19);
         acc$0 = acc$2;
        }
        break;
       case 6:
        var f = acc$0[2], p$3 = acc$0[1];
        output_acc(o, p$3);
        return caml_call1(f, o);
       case 7:
        var p$4 = acc$0[1];
        output_acc(o, p$4);
        return caml_call1(Stdlib[63], o);
       case 8:
        var msg = acc$0[2], p$5 = acc$0[1];
        output_acc(o, p$5);
        return caml_call1(Stdlib[1], msg);
       case 2:
       case 4:
        var s$0 = acc$0[2], p$1 = acc$0[1];
        output_acc(o, p$1);
        return caml_call2(Stdlib[66], o, s$0);
       default:
        var c = acc$0[2], p$2 = acc$0[1];
        output_acc(o, p$2);
        return caml_call2(Stdlib[65], o, c);
     }
    }
   }
   function bufput_acc(b, acc){
    var acc$0 = acc;
    for(;;){
     if(typeof acc$0 === "number") return 0;
     switch(acc$0[0]){
       case 0:
        var
         fmting_lit = acc$0[2],
         p = acc$0[1],
         s = string_of_formatting_lit(fmting_lit);
        bufput_acc(b, p);
        return caml_call2(Stdlib_Buffer[16], b, s);
       case 1:
        var match = acc$0[2], p$0 = acc$0[1];
        if(0 === match[0]){
         var acc$1 = match[1];
         bufput_acc(b, p$0);
         caml_call2(Stdlib_Buffer[16], b, cst$20);
         acc$0 = acc$1;
        }
        else{
         var acc$2 = match[1];
         bufput_acc(b, p$0);
         caml_call2(Stdlib_Buffer[16], b, cst$21);
         acc$0 = acc$2;
        }
        break;
       case 6:
        var f = acc$0[2], p$3 = acc$0[1];
        bufput_acc(b, p$3);
        return caml_call1(f, b);
       case 7:
        var acc$3 = acc$0[1]; acc$0 = acc$3; break;
       case 8:
        var msg = acc$0[2], p$4 = acc$0[1];
        bufput_acc(b, p$4);
        return caml_call1(Stdlib[1], msg);
       case 2:
       case 4:
        var s$0 = acc$0[2], p$1 = acc$0[1];
        bufput_acc(b, p$1);
        return caml_call2(Stdlib_Buffer[16], b, s$0);
       default:
        var c = acc$0[2], p$2 = acc$0[1];
        bufput_acc(b, p$2);
        return caml_call2(Stdlib_Buffer[12], b, c);
     }
    }
   }
   function strput_acc(b, acc){
    var acc$0 = acc;
    for(;;){
     if(typeof acc$0 === "number") return 0;
     switch(acc$0[0]){
       case 0:
        var
         fmting_lit = acc$0[2],
         p = acc$0[1],
         s = string_of_formatting_lit(fmting_lit);
        strput_acc(b, p);
        return caml_call2(Stdlib_Buffer[16], b, s);
       case 1:
        var match = acc$0[2], p$0 = acc$0[1];
        if(0 === match[0]){
         var acc$1 = match[1];
         strput_acc(b, p$0);
         caml_call2(Stdlib_Buffer[16], b, cst$22);
         acc$0 = acc$1;
        }
        else{
         var acc$2 = match[1];
         strput_acc(b, p$0);
         caml_call2(Stdlib_Buffer[16], b, cst$23);
         acc$0 = acc$2;
        }
        break;
       case 6:
        var f = acc$0[2], p$3 = acc$0[1];
        strput_acc(b, p$3);
        var _bv_ = caml_call1(f, 0);
        return caml_call2(Stdlib_Buffer[16], b, _bv_);
       case 7:
        var acc$3 = acc$0[1]; acc$0 = acc$3; break;
       case 8:
        var msg = acc$0[2], p$4 = acc$0[1];
        strput_acc(b, p$4);
        return caml_call1(Stdlib[1], msg);
       case 2:
       case 4:
        var s$0 = acc$0[2], p$1 = acc$0[1];
        strput_acc(b, p$1);
        return caml_call2(Stdlib_Buffer[16], b, s$0);
       default:
        var c = acc$0[2], p$2 = acc$0[1];
        strput_acc(b, p$2);
        return caml_call2(Stdlib_Buffer[12], b, c);
     }
    }
   }
   function failwith_message(param){
    var fmt = param[1], buf = caml_call1(Stdlib_Buffer[1], 256);
    function k(acc){
     strput_acc(buf, acc);
     var _bu_ = caml_call1(Stdlib_Buffer[2], buf);
     return caml_call1(Stdlib[2], _bu_);
    }
    return make_printf(k, 0, fmt);
   }
   function open_box_of_string(str){
    if(str == cst$43) return _x_;
    var len = caml_ml_string_length(str);
    function invalid_box(param){
     return caml_call1(failwith_message(_y_), str);
    }
    function parse_spaces(i){
     var i$0 = i;
     for(;;){
      if(i$0 === len) return i$0;
      var match = caml_string_get(str, i$0);
      if(9 !== match && 32 !== match) return i$0;
      var i$1 = i$0 + 1 | 0;
      i$0 = i$1;
     }
    }
    var wstart = parse_spaces(0);
    a:
    b:
    {
     var wend = wstart;
     for(;;){
      if(wend === len) break b;
      if(25 < caml_string_get(str, wend) - 97 >>> 0) break;
      var j = wend + 1 | 0;
      wend = j;
     }
     break a;
    }
    var
     box_name = caml_call3(Stdlib_String[15], str, wstart, wend - wstart | 0),
     nstart = parse_spaces(wend);
    a:
    b:
    {
     var nend = nstart;
     for(;;){
      if(nend === len) break b;
      var match = caml_string_get(str, nend);
      if(48 <= match){if(58 <= match) break;} else if(45 !== match) break;
      var j$0 = nend + 1 | 0;
      nend = j$0;
     }
     break a;
    }
    if(nstart === nend)
     var indent = 0;
    else
     try{
      var
       _bs_ =
         runtime.caml_int_of_string
          (caml_call3(Stdlib_String[15], str, nstart, nend - nstart | 0)),
       indent = _bs_;
     }
     catch(_bt_){
      var _br_ = caml_wrap_exception(_bt_);
      if(_br_[1] !== Stdlib[7]) throw caml_maybe_attach_backtrace(_br_, 0);
      var indent = invalid_box(0);
     }
    var exp_end = parse_spaces(nend);
    if(exp_end !== len) invalid_box(0);
    a:
    {
     if(box_name !== cst$43 && box_name !== "b"){
      if(box_name === "h"){var box_type = 0; break a;}
      if(box_name === "hov"){var box_type = 3; break a;}
      if(box_name === "hv"){var box_type = 2; break a;}
      if(box_name !== "v"){var box_type = invalid_box(0); break a;}
      var box_type = 1;
      break a;
     }
     var box_type = 4;
    }
    return [0, indent, box_type];
   }
   function make_padding_fmt_ebb(pad, fmt){
    if(typeof pad === "number") return [0, 0, fmt];
    if(0 === pad[0]){var w = pad[2], s = pad[1]; return [0, [0, s, w], fmt];}
    var s$0 = pad[1];
    return [0, [1, s$0], fmt];
   }
   function make_padprec_fmt_ebb(pad, prec, fmt){
    if(typeof prec === "number")
     var match = prec ? [0, 1] : [0, 0];
    else
     var p = prec[1], match = [0, [0, p]];
    var prec$0 = match[1];
    if(typeof pad === "number") return [0, 0, prec$0, fmt];
    if(0 === pad[0]){
     var w = pad[2], s = pad[1];
     return [0, [0, s, w], prec$0, fmt];
    }
    var s$0 = pad[1];
    return [0, [1, s$0], prec$0, fmt];
   }
   function fmt_ebb_of_string(legacy_behavior, str){
    if(legacy_behavior)
     var flag = legacy_behavior[1], legacy_behavior$0 = flag;
    else
     var legacy_behavior$0 = 1;
    function invalid_format_message(str_ind, msg){
     return caml_call3(failwith_message(_z_), str, str_ind, msg);
    }
    function invalid_format_without(str_ind, c, s){
     return caml_call4(failwith_message(_A_), str, str_ind, c, s);
    }
    function expected_character(str_ind, expected, read){
     return caml_call4(failwith_message(_B_), str, str_ind, expected, read);
    }
    function parse(lit_start, end_ind){
     a:
     {
      var str_ind = lit_start;
      for(;;){
       if(str_ind === end_ind) return add_literal(lit_start, str_ind, 0);
       var match = caml_string_get(str, str_ind);
       if(37 === match) break;
       if(64 === match) break a;
       var str_ind$1 = str_ind + 1 | 0;
       str_ind = str_ind$1;
      }
      var str_ind$2 = str_ind + 1 | 0;
      if(str_ind$2 === end_ind)
       invalid_format_message(end_ind, cst_unexpected_end_of_format);
      var
       match$1 =
         95 === caml_string_get(str, str_ind$2)
          ? parse_flags(str_ind, str_ind$2 + 1 | 0, end_ind, 1)
          : parse_flags(str_ind, str_ind$2, end_ind, 0),
       fmt_rest = match$1[1];
      return add_literal(lit_start, str_ind, fmt_rest);
     }
     var str_ind$0 = str_ind + 1 | 0;
     a:
     if(str_ind$0 === end_ind)
      var match$0 = _N_;
     else{
      var c = caml_string_get(str, str_ind$0);
      if(65 <= c){
       if(94 <= c){
        var switcher = c - 123 | 0;
        if(2 >= switcher >>> 0)
         switch(switcher){
           case 0:
            var match$0 = parse_tag(1, str_ind$0 + 1 | 0, end_ind); break a;
           case 1: break;
           default:
            var
             fmt_rest$2 = parse(str_ind$0 + 1 | 0, end_ind)[1],
             match$0 = [0, [17, 1, fmt_rest$2]];
            break a;
         }
       }
       else if(91 <= c)
        switch(c - 91 | 0){
          case 0:
           var match$0 = parse_tag(0, str_ind$0 + 1 | 0, end_ind); break a;
          case 1: break;
          default:
           var
            fmt_rest$3 = parse(str_ind$0 + 1 | 0, end_ind)[1],
            match$0 = [0, [17, 0, fmt_rest$3]];
           break a;
        }
      }
      else{
       if(10 === c){
        var
         fmt_rest$4 = parse(str_ind$0 + 1 | 0, end_ind)[1],
         match$0 = [0, [17, 3, fmt_rest$4]];
        break a;
       }
       if(32 <= c)
        switch(c - 32 | 0){
          case 0:
           var
            fmt_rest$5 = parse(str_ind$0 + 1 | 0, end_ind)[1],
            match$0 = [0, [17, _O_, fmt_rest$5]];
           break a;
          case 5:
           if
            ((str_ind$0 + 1 | 0) < end_ind
             && 37 === caml_string_get(str, str_ind$0 + 1 | 0)){
            var
             fmt_rest$6 = parse(str_ind$0 + 2 | 0, end_ind)[1],
             match$0 = [0, [17, 6, fmt_rest$6]];
            break a;
           }
           var
            fmt_rest$7 = parse(str_ind$0, end_ind)[1],
            match$0 = [0, [12, 64, fmt_rest$7]];
           break a;
          case 12:
           var
            fmt_rest$8 = parse(str_ind$0 + 1 | 0, end_ind)[1],
            match$0 = [0, [17, _P_, fmt_rest$8]];
           break a;
          case 14:
           var
            fmt_rest$9 = parse(str_ind$0 + 1 | 0, end_ind)[1],
            match$0 = [0, [17, 4, fmt_rest$9]];
           break a;
          case 27:
           var str_ind$3 = str_ind$0 + 1 | 0;
           b:
           try{
            var
             _bg_ = str_ind$3 === end_ind ? 1 : 0,
             _bh_ = _bg_ || (60 !== caml_string_get(str, str_ind$3) ? 1 : 0);
            if(_bh_) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
            var
             str_ind_1 = parse_spaces(str_ind$3 + 1 | 0, end_ind),
             match$2 = caml_string_get(str, str_ind_1);
            c:
            {
             if(48 <= match$2){
              if(58 > match$2) break c;
             }
             else if(45 === match$2) break c;
             throw caml_maybe_attach_backtrace(Stdlib[8], 1);
            }
            var
             match$3 = parse_integer(str_ind_1, end_ind),
             width = match$3[2],
             str_ind_2 = match$3[1],
             str_ind_3 = parse_spaces(str_ind_2, end_ind),
             switcher$0 = caml_string_get(str, str_ind_3) - 45 | 0;
            if(12 < switcher$0 >>> 0){
             if(17 === switcher$0){
              var
               s =
                 caml_call3
                  (Stdlib_String[15],
                   str,
                   str_ind$3 - 2 | 0,
                   (str_ind_3 - str_ind$3 | 0) + 3 | 0),
               _bi_ = [0, s, width, 0],
               _bj_ = str_ind_3 + 1 | 0,
               formatting_lit$0 = _bi_,
               next_ind = _bj_;
              break b;
             }
            }
            else if(1 < switcher$0 - 1 >>> 0){
             var
              match$4 = parse_integer(str_ind_3, end_ind),
              offset = match$4[2],
              str_ind_4 = match$4[1],
              str_ind_5 = parse_spaces(str_ind_4, end_ind);
             if(62 !== caml_string_get(str, str_ind_5))
              throw caml_maybe_attach_backtrace(Stdlib[8], 1);
             var
              s$0 =
                caml_call3
                 (Stdlib_String[15],
                  str,
                  str_ind$3 - 2 | 0,
                  (str_ind_5 - str_ind$3 | 0) + 3 | 0),
              _bk_ = [0, s$0, width, offset],
              _bl_ = str_ind_5 + 1 | 0,
              formatting_lit$0 = _bk_,
              next_ind = _bl_;
             break b;
            }
            throw caml_maybe_attach_backtrace(Stdlib[8], 1);
           }
           catch(_bq_){
            var _bf_ = caml_wrap_exception(_bq_);
            if(_bf_ !== Stdlib[8] && _bf_[1] !== Stdlib[7])
             throw caml_maybe_attach_backtrace(_bf_, 0);
            var formatting_lit$0 = formatting_lit, next_ind = str_ind$3;
           }
           var
            fmt_rest$12 = parse(next_ind, end_ind)[1],
            match$0 = [0, [17, formatting_lit$0, fmt_rest$12]];
           break a;
          case 28:
           var str_ind$4 = str_ind$0 + 1 | 0;
           try{
            var
             str_ind_1$0 = parse_spaces(str_ind$4, end_ind),
             match$6 = caml_string_get(str, str_ind_1$0);
            b:
            {
             c:
             {
              if(48 <= match$6){
               if(58 > match$6) break c;
              }
              else if(45 === match$6) break c;
              var _bo_ = 0;
              break b;
             }
             var
              match$7 = parse_integer(str_ind_1$0, end_ind),
              size = match$7[2],
              str_ind_2$0 = match$7[1],
              str_ind_3$0 = parse_spaces(str_ind_2$0, end_ind);
             if(62 !== caml_string_get(str, str_ind_3$0))
              throw caml_maybe_attach_backtrace(Stdlib[8], 1);
             var
              s$1 =
                caml_call3
                 (Stdlib_String[15],
                  str,
                  str_ind$4 - 2 | 0,
                  (str_ind_3$0 - str_ind$4 | 0) + 3 | 0),
              _bo_ = [0, [0, str_ind_3$0 + 1 | 0, [1, s$1, size]]];
            }
            var _bn_ = _bo_;
           }
           catch(_bp_){
            var _bm_ = caml_wrap_exception(_bp_);
            if(_bm_ !== Stdlib[8] && _bm_[1] !== Stdlib[7])
             throw caml_maybe_attach_backtrace(_bm_, 0);
            var _bn_ = 0;
           }
           if(_bn_)
            var
             match$5 = _bn_[1],
             formatting_lit$1 = match$5[2],
             next_ind$0 = match$5[1],
             fmt_rest$13 = parse(next_ind$0, end_ind)[1],
             _be_ = [0, [17, formatting_lit$1, fmt_rest$13]];
           else
            var
             fmt_rest$14 = parse(str_ind$4, end_ind)[1],
             _be_ = [0, [17, _Q_, fmt_rest$14]];
           var match$0 = _be_;
           break a;
          case 31:
           var
            fmt_rest$10 = parse(str_ind$0 + 1 | 0, end_ind)[1],
            match$0 = [0, [17, 2, fmt_rest$10]];
           break a;
          case 32:
           var
            fmt_rest$11 = parse(str_ind$0 + 1 | 0, end_ind)[1],
            match$0 = [0, [17, 5, fmt_rest$11]];
           break a;
        }
      }
      var
       fmt_rest$1 = parse(str_ind$0 + 1 | 0, end_ind)[1],
       match$0 = [0, [17, [2, c], fmt_rest$1]];
     }
     var fmt_rest$0 = match$0[1];
     return add_literal(lit_start, str_ind, fmt_rest$0);
    }
    function parse_flags(pct_ind, str_ind, end_ind, ign){
     var
      zero = [0, 0],
      minus = [0, 0],
      plus = [0, 0],
      space = [0, 0],
      hash = [0, 0];
     function set_flag(str_ind, flag){
      var _bb_ = flag[1], _bc_ = _bb_ ? 1 - legacy_behavior$0 : _bb_;
      if(_bc_){
       var _bd_ = caml_string_get(str, str_ind);
       caml_call3(failwith_message(_C_), str, str_ind, _bd_);
      }
      flag[1] = 1;
      return;
     }
     a:
     b:
     {
      var str_ind$0 = str_ind;
      c:
      for(;;){
       if(str_ind$0 === end_ind)
        invalid_format_message(end_ind, cst_unexpected_end_of_format);
       var switcher = caml_string_get(str, str_ind$0) - 32 | 0;
       if(16 < switcher >>> 0) break b;
       switch(switcher){
         case 0:
          set_flag(str_ind$0, space);
          var str_ind$1 = str_ind$0 + 1 | 0;
          str_ind$0 = str_ind$1;
          break;
         case 3:
          set_flag(str_ind$0, hash);
          var str_ind$2 = str_ind$0 + 1 | 0;
          str_ind$0 = str_ind$2;
          break;
         case 11:
          set_flag(str_ind$0, plus);
          var str_ind$3 = str_ind$0 + 1 | 0;
          str_ind$0 = str_ind$3;
          break;
         case 13:
          set_flag(str_ind$0, minus);
          var str_ind$4 = str_ind$0 + 1 | 0;
          str_ind$0 = str_ind$4;
          break;
         case 16:
          set_flag(str_ind$0, zero);
          var str_ind$5 = str_ind$0 + 1 | 0;
          str_ind$0 = str_ind$5;
          break;
         default: break c;
       }
      }
      break a;
     }
     var
      space$0 = space[1],
      hash$0 = hash[1],
      plus$0 = plus[1],
      minus$0 = minus[1],
      zero$0 = zero[1];
     if(str_ind$0 === end_ind)
      invalid_format_message(end_ind, cst_unexpected_end_of_format);
     var
      padty =
        zero$0
         ? minus$0
           ? legacy_behavior$0
             ? 0
             : incompatible_flag(pct_ind, str_ind$0, 45, cst_0)
           : 2
         : minus$0 ? 0 : 1,
      match = caml_string_get(str, str_ind$0);
     if(48 <= match){
      if(58 > match){
       var
        match$0 = parse_positive(str_ind$0, end_ind, 0),
        width = match$0[2],
        new_ind = match$0[1];
       return parse_after_padding
               (pct_ind,
                new_ind,
                end_ind,
                minus$0,
                plus$0,
                hash$0,
                space$0,
                ign,
                [0, padty, width]);
      }
     }
     else if(42 === match)
      return parse_after_padding
              (pct_ind,
               str_ind$0 + 1 | 0,
               end_ind,
               minus$0,
               plus$0,
               hash$0,
               space$0,
               ign,
               [1, padty]);
     switch(padty){
       case 0:
        if(1 - legacy_behavior$0)
         invalid_format_without(str_ind$0 - 1 | 0, 45, cst_padding);
        return parse_after_padding
                (pct_ind,
                 str_ind$0,
                 end_ind,
                 minus$0,
                 plus$0,
                 hash$0,
                 space$0,
                 ign,
                 0);
       case 1:
        return parse_after_padding
                (pct_ind,
                 str_ind$0,
                 end_ind,
                 minus$0,
                 plus$0,
                 hash$0,
                 space$0,
                 ign,
                 0);
       default:
        return parse_after_padding
                (pct_ind,
                 str_ind$0,
                 end_ind,
                 minus$0,
                 plus$0,
                 hash$0,
                 space$0,
                 ign,
                 _D_);
     }
    }
    function parse_after_padding
    (pct_ind, str_ind, end_ind, minus, plus, hash, space, ign, pad){
     if(str_ind === end_ind)
      invalid_format_message(end_ind, cst_unexpected_end_of_format);
     var symb = caml_string_get(str, str_ind);
     if(46 !== symb)
      return parse_conversion
              (pct_ind,
               str_ind + 1 | 0,
               end_ind,
               plus,
               hash,
               space,
               ign,
               pad,
               0,
               pad,
               symb);
     var str_ind$0 = str_ind + 1 | 0;
     if(str_ind$0 === end_ind)
      invalid_format_message(end_ind, cst_unexpected_end_of_format);
     function parse_literal(minus, str_ind){
      var
       match = parse_positive(str_ind, end_ind, 0),
       prec = match[2],
       new_ind = match[1];
      return parse_after_precision
              (pct_ind,
               new_ind,
               end_ind,
               minus,
               plus,
               hash,
               space,
               ign,
               pad,
               [0, prec]);
     }
     var symb$0 = caml_string_get(str, str_ind$0);
     if(48 <= symb$0){
      if(58 > symb$0) return parse_literal(minus, str_ind$0);
     }
     else if(42 <= symb$0)
      switch(symb$0 - 42 | 0){
        case 0:
         return parse_after_precision
                 (pct_ind,
                  str_ind$0 + 1 | 0,
                  end_ind,
                  minus,
                  plus,
                  hash,
                  space,
                  ign,
                  pad,
                  1);
        case 1:
        case 3:
         if(legacy_behavior$0){
          var
           _ba_ = str_ind$0 + 1 | 0,
           minus$0 = minus || (45 === symb$0 ? 1 : 0);
          return parse_literal(minus$0, _ba_);
         }
         break;
      }
     return legacy_behavior$0
             ? parse_after_precision
               (pct_ind,
                str_ind$0,
                end_ind,
                minus,
                plus,
                hash,
                space,
                ign,
                pad,
                _E_)
             : invalid_format_without(str_ind$0 - 1 | 0, 46, cst_precision);
    }
    function parse_after_precision
    (pct_ind, str_ind, end_ind, minus, plus, hash, space, ign, pad, prec){
     if(str_ind === end_ind)
      invalid_format_message(end_ind, cst_unexpected_end_of_format);
     function parse_conv(padprec){
      return parse_conversion
              (pct_ind,
               str_ind + 1 | 0,
               end_ind,
               plus,
               hash,
               space,
               ign,
               pad,
               prec,
               padprec,
               caml_string_get(str, str_ind));
     }
     if(typeof pad !== "number") return parse_conv(pad);
     if(typeof prec === "number" && ! prec) return parse_conv(0);
     if(minus){
      if(typeof prec === "number") return parse_conv(_F_);
      var n = prec[1];
      return parse_conv([0, 0, n]);
     }
     if(typeof prec === "number") return parse_conv(_G_);
     var n$0 = prec[1];
     return parse_conv([0, 1, n$0]);
    }
    function parse_conversion
    (pct_ind,
     str_ind,
     end_ind,
     plus,
     hash,
     space,
     ign,
     pad,
     prec,
     padprec,
     symb){
     var
      plus_used = [0, 0],
      hash_used = [0, 0],
      space_used = [0, 0],
      ign_used = [0, 0],
      pad_used = [0, 0],
      prec_used = [0, 0];
     function get_plus(param){plus_used[1] = 1; return plus;}
     function get_hash(param){hash_used[1] = 1; return hash;}
     function get_space(param){space_used[1] = 1; return space;}
     function get_ign(param){ign_used[1] = 1; return ign;}
     function get_pad(param){pad_used[1] = 1; return pad;}
     function get_prec(param){prec_used[1] = 1; return prec;}
     function get_padprec(param){pad_used[1] = 1; return padprec;}
     function get_int_pad(param){
      var pad = get_pad(0), match = get_prec(0);
      if(typeof match === "number" && ! match) return pad;
      if(typeof pad === "number") return 0;
      if(0 !== pad[0])
       return 2 <= pad[1]
               ? legacy_behavior$0
                 ? _H_
                 : incompatible_flag(pct_ind, str_ind, 48, cst_precision$1)
               : pad;
      if(2 > pad[1]) return pad;
      var n = pad[2];
      return legacy_behavior$0
              ? [0, 1, n]
              : incompatible_flag(pct_ind, str_ind, 48, cst_precision$0);
     }
     function check_no_0(symb, pad){
      if(typeof pad === "number") return pad;
      if(0 !== pad[0])
       return 2 <= pad[1]
               ? legacy_behavior$0
                 ? _I_
                 : incompatible_flag(pct_ind, str_ind, symb, cst_0$1)
               : pad;
      if(2 > pad[1]) return pad;
      var width = pad[2];
      return legacy_behavior$0
              ? [0, 1, width]
              : incompatible_flag(pct_ind, str_ind, symb, cst_0$0);
     }
     function opt_of_pad(c, pad){
      if(typeof pad === "number") return 0;
      if(0 === pad[0])
       switch(pad[1]){
         case 0:
          var width = pad[2];
          return legacy_behavior$0
                  ? [0, width]
                  : incompatible_flag(pct_ind, str_ind, c, cst$24);
         case 1:
          var width$0 = pad[2]; return [0, width$0];
         default:
          var width$1 = pad[2];
          return legacy_behavior$0
                  ? [0, width$1]
                  : incompatible_flag(pct_ind, str_ind, c, cst_0$2);
       }
      return incompatible_flag(pct_ind, str_ind, c, cst$25);
     }
     function get_pad_opt(c){return opt_of_pad(c, get_pad(0));}
     function get_padprec_opt(c){return opt_of_pad(c, get_padprec(0));}
     a:
     {
      if(124 > symb)
       switch(symb){
         case 33:
          var
           fmt_rest$5 = parse(str_ind, end_ind)[1],
           fmt_result = [0, [10, fmt_rest$5]];
          break a;
         case 40:
          var
           sub_end = search_subformat_end(str_ind, end_ind, 41),
           fmt_rest$7 = parse(sub_end + 2 | 0, end_ind)[1],
           sub_fmt = parse(str_ind, sub_end)[1],
           sub_fmtty = fmtty_of_fmt(sub_fmt);
          if(get_ign(0))
           var
            ignored$2 = [9, get_pad_opt(95), sub_fmtty],
            _aJ_ = [0, [23, ignored$2, fmt_rest$7]];
          else
           var _aJ_ = [0, [14, get_pad_opt(40), sub_fmtty, fmt_rest$7]];
          var fmt_result = _aJ_;
          break a;
         case 44:
          var fmt_result = parse(str_ind, end_ind); break a;
         case 67:
          var
           fmt_rest$10 = parse(str_ind, end_ind)[1],
           _aL_ =
             get_ign(0) ? [0, [23, 1, fmt_rest$10]] : [0, [1, fmt_rest$10]],
           fmt_result = _aL_;
          break a;
         case 78:
          var fmt_rest$14 = parse(str_ind, end_ind)[1], counter$0 = 2;
          if(get_ign(0))
           var
            ignored$6 = [11, counter$0],
            _aR_ = [0, [23, ignored$6, fmt_rest$14]];
          else
           var _aR_ = [0, [21, counter$0, fmt_rest$14]];
          var fmt_result = _aR_;
          break a;
         case 83:
          var
           pad$6 = check_no_0(symb, get_padprec(0)),
           fmt_rest$15 = parse(str_ind, end_ind)[1];
          if(get_ign(0))
           var
            ignored$7 = [1, get_padprec_opt(95)],
            _aS_ = [0, [23, ignored$7, fmt_rest$15]];
          else
           var
            match$5 = make_padding_fmt_ebb(pad$6, fmt_rest$15),
            fmt_rest$16 = match$5[2],
            pad$7 = match$5[1],
            _aS_ = [0, [3, pad$7, fmt_rest$16]];
          var fmt_result = _aS_;
          break a;
         case 91:
          if(str_ind === end_ind)
           invalid_format_message(end_ind, cst_unexpected_end_of_format);
          var
           char_set = create_char_set(0),
           add_range =
             function(c$0, c){
              if(c >= c$0){
               var i = c$0;
               for(;;){
                add_in_char_set(char_set, caml_call1(Stdlib[29], i));
                var _a$_ = i + 1 | 0;
                if(c === i) break;
                i = _a$_;
               }
              }
              return;
             },
           fail_single_percent =
             function(str_ind){
              return caml_call2(failwith_message(_R_), str, str_ind);
             },
           parse_char_set_content =
             function(counter, str_ind, end_ind){
              var str_ind$0 = str_ind;
              for(;;){
               if(str_ind$0 === end_ind)
                invalid_format_message(end_ind, cst_unexpected_end_of_format);
               var c = caml_string_get(str, str_ind$0);
               if(45 !== c){
                if(93 === c) return str_ind$0 + 1 | 0;
                var _a__ = str_ind$0 + 1 | 0;
                if(counter >= 50)
                 return caml_trampoline_return
                         (parse_char_set_after_char$0, [0, _a__, end_ind, c]);
                var counter$0 = counter + 1 | 0;
                return parse_char_set_after_char$0
                        (counter$0, _a__, end_ind, c);
               }
               add_in_char_set(char_set, 45);
               var str_ind$1 = str_ind$0 + 1 | 0;
               str_ind$0 = str_ind$1;
              }
             },
           parse_char_set_after_char$0 =
             function(counter, str_ind, end_ind, c){
              var str_ind$0 = str_ind, c$0 = c;
              for(;;){
               if(str_ind$0 === end_ind)
                invalid_format_message(end_ind, cst_unexpected_end_of_format);
               var c$1 = caml_string_get(str, str_ind$0);
               a:
               {
                if(46 <= c$1){
                 if(64 !== c$1){
                  if(93 !== c$1) break a;
                  add_in_char_set(char_set, c$0);
                  return str_ind$0 + 1 | 0;
                 }
                }
                else if(37 !== c$1){
                 if(45 > c$1) break a;
                 var str_ind$2 = str_ind$0 + 1 | 0;
                 if(str_ind$2 === end_ind)
                  invalid_format_message
                   (end_ind, cst_unexpected_end_of_format);
                 var c$2 = caml_string_get(str, str_ind$2);
                 if(37 === c$2){
                  if((str_ind$2 + 1 | 0) === end_ind)
                   invalid_format_message
                    (end_ind, cst_unexpected_end_of_format);
                  var c$3 = caml_string_get(str, str_ind$2 + 1 | 0);
                  if(37 !== c$3 && 64 !== c$3)
                   return fail_single_percent(str_ind$2);
                  add_range(c$0, c$3);
                  var _a8_ = str_ind$2 + 2 | 0;
                  if(counter >= 50)
                   return caml_trampoline_return
                           (parse_char_set_content, [0, _a8_, end_ind]);
                  var counter$1 = counter + 1 | 0;
                  return parse_char_set_content(counter$1, _a8_, end_ind);
                 }
                 if(93 === c$2){
                  add_in_char_set(char_set, c$0);
                  add_in_char_set(char_set, 45);
                  return str_ind$2 + 1 | 0;
                 }
                 add_range(c$0, c$2);
                 var _a9_ = str_ind$2 + 1 | 0;
                 if(counter >= 50)
                  return caml_trampoline_return
                          (parse_char_set_content, [0, _a9_, end_ind]);
                 var counter$0 = counter + 1 | 0;
                 return parse_char_set_content(counter$0, _a9_, end_ind);
                }
                if(37 === c$0){
                 add_in_char_set(char_set, c$1);
                 var _a7_ = str_ind$0 + 1 | 0;
                 if(counter >= 50)
                  return caml_trampoline_return
                          (parse_char_set_content, [0, _a7_, end_ind]);
                 var counter$2 = counter + 1 | 0;
                 return parse_char_set_content(counter$2, _a7_, end_ind);
                }
               }
               if(37 === c$0) fail_single_percent(str_ind$0);
               add_in_char_set(char_set, c$0);
               var str_ind$1 = str_ind$0 + 1 | 0;
               str_ind$0 = str_ind$1;
               c$0 = c$1;
              }
             },
           parse_char_set_after_char =
             function(str_ind, end_ind, c){
              return caml_trampoline
                      (parse_char_set_after_char$0(0, str_ind, end_ind, c));
             };
          if(str_ind === end_ind)
           invalid_format_message(end_ind, cst_unexpected_end_of_format);
          if(94 === caml_string_get(str, str_ind))
           var
            str_ind$0 = str_ind + 1 | 0,
            reverse = 1,
            str_ind$1 = str_ind$0;
          else
           var reverse = 0, str_ind$1 = str_ind;
          if(str_ind$1 === end_ind)
           invalid_format_message(end_ind, cst_unexpected_end_of_format);
          var
           c = caml_string_get(str, str_ind$1),
           next_ind = parse_char_set_after_char(str_ind$1 + 1 | 0, end_ind, c),
           char_set$0 = freeze_char_set(char_set),
           char_set$1 = reverse ? rev_char_set(char_set$0) : char_set$0,
           fmt_rest$19 = parse(next_ind, end_ind)[1];
          if(get_ign(0))
           var
            ignored$9 = [10, get_pad_opt(95), char_set$1],
            _aX_ = [0, [23, ignored$9, fmt_rest$19]];
          else
           var _aX_ = [0, [20, get_pad_opt(91), char_set$1, fmt_rest$19]];
          var fmt_result = _aX_;
          break a;
         case 97:
          var
           fmt_rest$20 = parse(str_ind, end_ind)[1],
           fmt_result = [0, [15, fmt_rest$20]];
          break a;
         case 99:
          var
           char_format =
             function(fmt_rest){
              return get_ign(0) ? [0, [23, 0, fmt_rest]] : [0, [0, fmt_rest]];
             },
           fmt_rest$21 = parse(str_ind, end_ind)[1],
           match$7 = get_pad_opt(99);
          if(match$7){
           if(0 === match$7[1])
            var
             _aY_ =
               get_ign(0) ? [0, [23, 3, fmt_rest$21]] : [0, [22, fmt_rest$21]],
             _aZ_ = _aY_;
           else
            var
             _aZ_ =
               legacy_behavior$0
                ? char_format(fmt_rest$21)
                : invalid_format_message
                  (str_ind, cst_non_zero_widths_are_unsupp);
           var _a0_ = _aZ_;
          }
          else
           var _a0_ = char_format(fmt_rest$21);
          var fmt_result = _a0_;
          break a;
         case 114:
          var
           fmt_rest$22 = parse(str_ind, end_ind)[1],
           _a1_ =
             get_ign(0) ? [0, [23, 2, fmt_rest$22]] : [0, [19, fmt_rest$22]],
           fmt_result = _a1_;
          break a;
         case 115:
          var
           pad$9 = check_no_0(symb, get_padprec(0)),
           fmt_rest$23 = parse(str_ind, end_ind)[1];
          if(get_ign(0))
           var
            ignored$10 = [0, get_padprec_opt(95)],
            _a2_ = [0, [23, ignored$10, fmt_rest$23]];
          else
           var
            match$8 = make_padding_fmt_ebb(pad$9, fmt_rest$23),
            fmt_rest$24 = match$8[2],
            pad$10 = match$8[1],
            _a2_ = [0, [2, pad$10, fmt_rest$24]];
          var fmt_result = _a2_;
          break a;
         case 116:
          var
           fmt_rest$25 = parse(str_ind, end_ind)[1],
           fmt_result = [0, [16, fmt_rest$25]];
          break a;
         case 123:
          var
           sub_end$0 = search_subformat_end(str_ind, end_ind, 125),
           sub_fmt$0 = parse(str_ind, sub_end$0)[1],
           fmt_rest$26 = parse(sub_end$0 + 2 | 0, end_ind)[1],
           sub_fmtty$0 = fmtty_of_fmt(sub_fmt$0);
          if(get_ign(0))
           var
            ignored$11 = [8, get_pad_opt(95), sub_fmtty$0],
            _a3_ = [0, [23, ignored$11, fmt_rest$26]];
          else
           var _a3_ = [0, [13, get_pad_opt(123), sub_fmtty$0, fmt_rest$26]];
          var fmt_result = _a3_;
          break a;
         case 66:
         case 98:
          var
           pad$3 = check_no_0(symb, get_padprec(0)),
           fmt_rest$8 = parse(str_ind, end_ind)[1];
          if(get_ign(0))
           var
            ignored$3 = [7, get_padprec_opt(95)],
            _aK_ = [0, [23, ignored$3, fmt_rest$8]];
          else
           var
            match$3 = make_padding_fmt_ebb(pad$3, fmt_rest$8),
            fmt_rest$9 = match$3[2],
            pad$4 = match$3[1],
            _aK_ = [0, [9, pad$4, fmt_rest$9]];
          var fmt_result = _aK_;
          break a;
         case 37:
         case 64:
          var
           fmt_rest$6 = parse(str_ind, end_ind)[1],
           fmt_result = [0, [12, symb, fmt_rest$6]];
          break a;
         case 76:
         case 108:
         case 110:
          if(str_ind !== end_ind){
           var symb$0 = caml_string_get(str, str_ind), _a4_ = symb$0 - 88 | 0;
           b:
           {
            if(32 >= _a4_ >>> 0)
             switch(_a4_){
               case 0:
               case 12:
               case 17:
               case 23:
               case 29:
               case 32:
                var _aQ_ = 1; break b;
             }
            var _aQ_ = 0;
           }
           if(_aQ_) break;
          }
          var fmt_rest$13 = parse(str_ind, end_ind)[1];
          b:
          {
           if(108 <= symb){
            if(111 > symb)
             switch(symb - 108 | 0){
               case 0:
                var counter = 0; break b;
               case 1: break;
               default: var counter = 1; break b;
             }
           }
           else if(76 === symb){var counter = 2; break b;}
           throw caml_maybe_attach_backtrace([0, Assert_failure, _V_], 1);
          }
          if(get_ign(0))
           var
            ignored$5 = [11, counter],
            _aP_ = [0, [23, ignored$5, fmt_rest$13]];
          else
           var _aP_ = [0, [21, counter, fmt_rest$13]];
          var fmt_result = _aP_;
          break a;
         case 32:
         case 35:
         case 43:
         case 45:
         case 95:
          var
           fmt_result = caml_call3(failwith_message(_M_), str, pct_ind, symb);
          break a;
         case 88:
         case 100:
         case 105:
         case 111:
         case 117:
         case 120:
          var
           _aT_ = get_space(0),
           _aU_ = get_hash(0),
           iconv$2 =
             compute_int_conv(pct_ind, str_ind, get_plus(0), _aU_, _aT_, symb),
           fmt_rest$17 = parse(str_ind, end_ind)[1];
          if(get_ign(0))
           var
            ignored$8 = [2, iconv$2, get_pad_opt(95)],
            _aV_ = [0, [23, ignored$8, fmt_rest$17]];
          else
           var
            _aW_ = get_prec(0),
            match$6 = make_padprec_fmt_ebb(get_int_pad(0), _aW_, fmt_rest$17),
            fmt_rest$18 = match$6[3],
            prec$4 = match$6[2],
            pad$8 = match$6[1],
            _aV_ = [0, [4, iconv$2, pad$8, prec$4, fmt_rest$18]];
          var fmt_result = _aV_;
          break a;
         case 69:
         case 70:
         case 71:
         case 72:
         case 101:
         case 102:
         case 103:
         case 104:
          var
           space$1 = get_space(0),
           hash$1 = get_hash(0),
           plus$2 = get_plus(0),
           flag =
             plus$2
              ? space$1
                ? legacy_behavior$0
                  ? 1
                  : incompatible_flag(pct_ind, str_ind, 32, cst$36)
                : 1
              : space$1 ? 2 : 0;
          b:
          {
           c:
           if(73 <= symb){
            var switcher = symb - 101 | 0;
            if(3 >= switcher >>> 0){
             switch(switcher){
               case 0:
                var _a5_ = 1; break;
               case 1:
                var _a5_ = 0; break;
               case 2:
                var _a5_ = 3; break;
               default: var _a5_ = 6;
             }
             var kind = _a5_;
             break b;
            }
           }
           else if(69 <= symb){
            switch(symb - 69 | 0){
              case 0:
               var _a6_ = 2; break;
              case 1:
               break c;
              case 2:
               var _a6_ = 4; break;
              default: var _a6_ = 7;
            }
            var kind = _a6_;
            break b;
           }
           if(hash$1){
            if(70 === symb){var kind = 8; break b;}
           }
           else if(70 === symb){var kind = 5; break b;}
           throw caml_maybe_attach_backtrace([0, Assert_failure, _X_], 1);
          }
          var
           fconv = [0, flag, kind],
           fmt_rest$11 = parse(str_ind, end_ind)[1];
          if(get_ign(0)){
           var match = get_prec(0);
           if(typeof match === "number")
            var
             _aM_ =
               match ? incompatible_flag(pct_ind, str_ind, 95, cst$26) : 0;
           else
            var ndec = match[1], _aM_ = [0, ndec];
           var
            ignored$4 = [6, get_pad_opt(95), _aM_],
            _aN_ = [0, [23, ignored$4, fmt_rest$11]];
          }
          else
           var
            _aO_ = get_prec(0),
            match$4 = make_padprec_fmt_ebb(get_pad(0), _aO_, fmt_rest$11),
            fmt_rest$12 = match$4[3],
            prec$3 = match$4[2],
            pad$5 = match$4[1],
            _aN_ = [0, [8, fconv, pad$5, prec$3, fmt_rest$12]];
          var fmt_result = _aN_;
          break a;
       }
      b:
      if(108 <= symb){
       if(111 > symb){
        switch(symb - 108 | 0){
          case 0:
           var
            _at_ = caml_string_get(str, str_ind),
            _au_ = get_space(0),
            _av_ = get_hash(0),
            iconv =
              compute_int_conv
               (pct_ind, str_ind + 1 | 0, get_plus(0), _av_, _au_, _at_),
            fmt_rest = parse(str_ind + 1 | 0, end_ind)[1];
           if(get_ign(0))
            var
             ignored = [3, iconv, get_pad_opt(95)],
             _aw_ = [0, [23, ignored, fmt_rest]];
           else
            var
             _ay_ = get_prec(0),
             match$0 = make_padprec_fmt_ebb(get_int_pad(0), _ay_, fmt_rest),
             fmt_rest$0 = match$0[3],
             prec$0 = match$0[2],
             pad$0 = match$0[1],
             _aw_ = [0, [5, iconv, pad$0, prec$0, fmt_rest$0]];
           var _ax_ = _aw_;
           break;
          case 1:
           break b;
          default:
           var
            _az_ = caml_string_get(str, str_ind),
            _aA_ = get_space(0),
            _aB_ = get_hash(0),
            iconv$0 =
              compute_int_conv
               (pct_ind, str_ind + 1 | 0, get_plus(0), _aB_, _aA_, _az_),
            fmt_rest$1 = parse(str_ind + 1 | 0, end_ind)[1];
           if(get_ign(0))
            var
             ignored$0 = [4, iconv$0, get_pad_opt(95)],
             _aC_ = [0, [23, ignored$0, fmt_rest$1]];
           else
            var
             _aD_ = get_prec(0),
             match$1 = make_padprec_fmt_ebb(get_int_pad(0), _aD_, fmt_rest$1),
             fmt_rest$2 = match$1[3],
             prec$1 = match$1[2],
             pad$1 = match$1[1],
             _aC_ = [0, [6, iconv$0, pad$1, prec$1, fmt_rest$2]];
           var _ax_ = _aC_;
        }
        var fmt_result = _ax_;
        break a;
       }
      }
      else if(76 === symb){
       var
        _aE_ = caml_string_get(str, str_ind),
        _aF_ = get_space(0),
        _aG_ = get_hash(0),
        iconv$1 =
          compute_int_conv
           (pct_ind, str_ind + 1 | 0, get_plus(0), _aG_, _aF_, _aE_),
        fmt_rest$3 = parse(str_ind + 1 | 0, end_ind)[1];
       if(get_ign(0))
        var
         ignored$1 = [5, iconv$1, get_pad_opt(95)],
         _aH_ = [0, [23, ignored$1, fmt_rest$3]];
       else
        var
         _aI_ = get_prec(0),
         match$2 = make_padprec_fmt_ebb(get_int_pad(0), _aI_, fmt_rest$3),
         fmt_rest$4 = match$2[3],
         prec$2 = match$2[2],
         pad$2 = match$2[1],
         _aH_ = [0, [7, iconv$1, pad$2, prec$2, fmt_rest$4]];
       var fmt_result = _aH_;
       break a;
      }
      var
       fmt_result =
         caml_call3(failwith_message(_J_), str, str_ind - 1 | 0, symb);
     }
     if(1 - legacy_behavior$0){
      var _ak_ = 1 - plus_used[1], plus$0 = _ak_ ? plus : _ak_;
      if(plus$0) incompatible_flag(pct_ind, str_ind, symb, cst$27);
      var _al_ = 1 - hash_used[1], hash$0 = _al_ ? hash : _al_;
      if(hash$0) incompatible_flag(pct_ind, str_ind, symb, cst$28);
      var _am_ = 1 - space_used[1], space$0 = _am_ ? space : _am_;
      if(space$0) incompatible_flag(pct_ind, str_ind, symb, cst$29);
      var
       _an_ = 1 - pad_used[1],
       _ao_ = _an_ ? caml_notequal([0, pad], _K_) : _an_;
      if(_ao_) incompatible_flag(pct_ind, str_ind, symb, cst_padding$0);
      var
       _ap_ = 1 - prec_used[1],
       _aq_ = _ap_ ? caml_notequal([0, prec], _L_) : _ap_;
      if(_aq_){
       var _ar_ = ign ? 95 : symb;
       incompatible_flag(pct_ind, str_ind, _ar_, cst_precision$2);
      }
      var plus$1 = ign ? plus : ign;
      if(plus$1) incompatible_flag(pct_ind, str_ind, 95, cst$30);
     }
     var _as_ = 1 - ign_used[1], ign$0 = _as_ ? ign : _as_;
     a:
     if(ign$0){
      b:
      {
       if(38 <= symb){
        if(44 !== symb && 64 !== symb) break b;
       }
       else if(33 !== symb && 37 > symb) break b;
       if(legacy_behavior$0) break a;
      }
      incompatible_flag(pct_ind, str_ind, symb, cst$31);
     }
     return fmt_result;
    }
    function parse_tag(is_open_tag, str_ind, end_ind){
     try{
      if(str_ind === end_ind) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
      if(60 !== caml_string_get(str, str_ind))
       throw caml_maybe_attach_backtrace(Stdlib[8], 1);
      var ind = caml_call3(Stdlib_String[31], str, str_ind + 1 | 0, 62);
      if(end_ind <= ind) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
      var
       sub_str =
         caml_call3
          (Stdlib_String[15], str, str_ind, (ind - str_ind | 0) + 1 | 0),
       fmt_rest$0 = parse(ind + 1 | 0, end_ind)[1],
       sub_fmt = parse(str_ind, ind + 1 | 0)[1],
       sub_format$0 = [0, sub_fmt, sub_str],
       formatting$0 = is_open_tag ? [0, sub_format$0] : [1, sub_format$0],
       _ai_ = [0, [18, formatting$0, fmt_rest$0]];
      return _ai_;
     }
     catch(_aj_){
      var _ah_ = caml_wrap_exception(_aj_);
      if(_ah_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_ah_, 0);
      var
       fmt_rest = parse(str_ind, end_ind)[1],
       formatting = is_open_tag ? [0, sub_format] : [1, sub_format];
      return [0, [18, formatting, fmt_rest]];
     }
    }
    function parse_spaces(str_ind, end_ind){
     var str_ind$0 = str_ind;
     for(;;){
      if(str_ind$0 === end_ind)
       invalid_format_message(end_ind, cst_unexpected_end_of_format);
      if(32 !== caml_string_get(str, str_ind$0)) return str_ind$0;
      var str_ind$1 = str_ind$0 + 1 | 0;
      str_ind$0 = str_ind$1;
     }
    }
    function parse_positive(str_ind, end_ind, acc){
     var str_ind$0 = str_ind, acc$0 = acc;
     for(;;){
      if(str_ind$0 === end_ind)
       invalid_format_message(end_ind, cst_unexpected_end_of_format);
      var c = caml_string_get(str, str_ind$0);
      if(9 < c - 48 >>> 0) return [0, str_ind$0, acc$0];
      var new_acc = (acc$0 * 10 | 0) + (c - 48 | 0) | 0;
      if(Stdlib_Sys[12] < new_acc){
       var _ag_ = Stdlib_Sys[12];
       return caml_call3(failwith_message(_S_), str, new_acc, _ag_);
      }
      var str_ind$1 = str_ind$0 + 1 | 0;
      str_ind$0 = str_ind$1;
      acc$0 = new_acc;
     }
    }
    function parse_integer(str_ind, end_ind){
     if(str_ind === end_ind)
      invalid_format_message(end_ind, cst_unexpected_end_of_format);
     var match = caml_string_get(str, str_ind);
     if(48 <= match){
      if(58 > match) return parse_positive(str_ind, end_ind, 0);
     }
     else if(45 === match){
      if((str_ind + 1 | 0) === end_ind)
       invalid_format_message(end_ind, cst_unexpected_end_of_format);
      var c = caml_string_get(str, str_ind + 1 | 0);
      if(9 < c - 48 >>> 0)
       return expected_character(str_ind + 1 | 0, cst_digit, c);
      var
       match$0 = parse_positive(str_ind + 1 | 0, end_ind, 0),
       n = match$0[2],
       next_ind = match$0[1];
      return [0, next_ind, - n | 0];
     }
     throw caml_maybe_attach_backtrace([0, Assert_failure, _T_], 1);
    }
    function add_literal(lit_start, str_ind, fmt){
     var size = str_ind - lit_start | 0;
     return 0 === size
             ? [0, fmt]
             : 1
               === size
               ? [0, [12, caml_string_get(str, lit_start), fmt]]
               : [0,
                 [11,
                  caml_call3(Stdlib_String[15], str, lit_start, size),
                  fmt]];
    }
    function search_subformat_end(str_ind, end_ind, c){
     var str_ind$0 = str_ind;
     for(;;){
      if(str_ind$0 === end_ind)
       caml_call3(failwith_message(_U_), str, c, end_ind);
      if(37 === caml_string_get(str, str_ind$0)){
       if((str_ind$0 + 1 | 0) === end_ind)
        invalid_format_message(end_ind, cst_unexpected_end_of_format);
       if(caml_string_get(str, str_ind$0 + 1 | 0) === c) return str_ind$0;
       var match = caml_string_get(str, str_ind$0 + 1 | 0);
       if(95 <= match){
        if(123 <= match){
         if(126 > match)
          switch(match - 123 | 0){
            case 0:
             var
              sub_end = search_subformat_end(str_ind$0 + 2 | 0, end_ind, 125),
              str_ind$2 = sub_end + 2 | 0;
             str_ind$0 = str_ind$2;
             continue;
            case 1: break;
            default:
             return expected_character(str_ind$0 + 1 | 0, cst_character, 125);
          }
        }
        else if(96 > match){
         if((str_ind$0 + 2 | 0) === end_ind)
          invalid_format_message(end_ind, cst_unexpected_end_of_format);
         var match$0 = caml_string_get(str, str_ind$0 + 2 | 0);
         if(40 === match$0){
          var
           sub_end$0 = search_subformat_end(str_ind$0 + 3 | 0, end_ind, 41),
           str_ind$3 = sub_end$0 + 2 | 0;
          str_ind$0 = str_ind$3;
          continue;
         }
         if(123 === match$0){
          var
           sub_end$1 = search_subformat_end(str_ind$0 + 3 | 0, end_ind, 125),
           str_ind$4 = sub_end$1 + 2 | 0;
          str_ind$0 = str_ind$4;
          continue;
         }
         var str_ind$5 = str_ind$0 + 3 | 0;
         str_ind$0 = str_ind$5;
         continue;
        }
       }
       else{
        if(40 === match){
         var
          sub_end$2 = search_subformat_end(str_ind$0 + 2 | 0, end_ind, 41),
          str_ind$6 = sub_end$2 + 2 | 0;
         str_ind$0 = str_ind$6;
         continue;
        }
        if(41 === match)
         return expected_character(str_ind$0 + 1 | 0, cst_character$0, 41);
       }
       var str_ind$1 = str_ind$0 + 2 | 0;
       str_ind$0 = str_ind$1;
      }
      else{var str_ind$7 = str_ind$0 + 1 | 0; str_ind$0 = str_ind$7;}
     }
    }
    function compute_int_conv(pct_ind, str_ind, plus, hash, space, symb){
     var plus$0 = plus, hash$0 = hash, space$0 = space;
     for(;;){
      a:
      {
       if(plus$0){
        if(! hash$0){
         if(space$0) break a;
         if(100 === symb) return 1;
         if(105 === symb) return 4;
         break a;
        }
       }
       else{
        if(! hash$0){
         if(space$0){
          if(100 === symb) return 2;
          if(105 === symb) return 5;
          break a;
         }
         var switcher$1 = symb - 88 | 0;
         if(32 < switcher$1 >>> 0) break a;
         switch(switcher$1){
           case 0:
            return 8;
           case 12:
            return 0;
           case 17:
            return 3;
           case 23:
            return 10;
           case 29:
            return 12;
           case 32:
            return 6;
           default: break a;
         }
        }
        if(! space$0){
         var switcher$0 = symb - 88 | 0;
         if(32 >= switcher$0 >>> 0)
          switch(switcher$0){
            case 0:
             return 9;
            case 12:
             return 13;
            case 17:
             return 14;
            case 23:
             return 11;
            case 29:
             return 15;
            case 32:
             return 7;
          }
        }
       }
       var switcher = symb - 88 | 0;
       if(32 >= switcher >>> 0)
        switch(switcher){
          case 0:
           if(legacy_behavior$0) return 9; break;
          case 23:
           if(legacy_behavior$0) return 11; break;
          case 32:
           if(legacy_behavior$0) return 7; break;
          case 12:
          case 17:
          case 29:
           if(! legacy_behavior$0)
            return incompatible_flag(pct_ind, str_ind, symb, cst$35);
           hash$0 = 0;
           continue;
        }
      }
      if(plus$0)
       if(space$0){
        if(! legacy_behavior$0)
         return incompatible_flag(pct_ind, str_ind, 32, cst$32);
        space$0 = 0;
       }
       else{
        if(! legacy_behavior$0)
         return incompatible_flag(pct_ind, str_ind, symb, cst$33);
        plus$0 = 0;
       }
      else{
       if(! space$0)
        throw caml_maybe_attach_backtrace([0, Assert_failure, _W_], 1);
       if(! legacy_behavior$0)
        return incompatible_flag(pct_ind, str_ind, symb, cst$34);
       space$0 = 0;
      }
     }
    }
    function incompatible_flag(pct_ind, str_ind, symb, option){
     var
      subfmt =
        caml_call3(Stdlib_String[15], str, pct_ind, str_ind - pct_ind | 0);
     return caml_call5
             (failwith_message(_Y_), str, pct_ind, option, symb, subfmt);
    }
    return parse(0, caml_ml_string_length(str));
   }
   function format_of_string_fmtty(str, fmtty){
    var fmt = fmt_ebb_of_string(0, str)[1];
    try{var _ae_ = [0, type_format(fmt, fmtty), str]; return _ae_;}
    catch(_af_){
     var _ac_ = caml_wrap_exception(_af_);
     if(_ac_ !== Type_mismatch) throw caml_maybe_attach_backtrace(_ac_, 0);
     var _ad_ = string_of_fmtty(fmtty);
     return caml_call2(failwith_message(_Z_), str, _ad_);
    }
   }
   function format_of_string_format(str, param){
    var
     str$0 = param[2],
     fmt = param[1],
     fmt$0 = fmt_ebb_of_string(0, str)[1];
    try{
     var _aa_ = [0, type_format(fmt$0, fmtty_of_fmt(fmt)), str];
     return _aa_;
    }
    catch(_ab_){
     var _$_ = caml_wrap_exception(_ab_);
     if(_$_ === Type_mismatch)
      return caml_call2(failwith_message(___), str, str$0);
     throw caml_maybe_attach_backtrace(_$_, 0);
    }
   }
   var
    CamlinternalFormat =
      [0,
       is_in_char_set,
       rev_char_set,
       create_char_set,
       add_in_char_set,
       freeze_char_set,
       param_format_of_ignored_format,
       make_printf,
       make_iprintf,
       output_acc,
       bufput_acc,
       strput_acc,
       type_format,
       fmt_ebb_of_string,
       format_of_string_fmtty,
       format_of_string_format,
       char_of_iconv,
       string_of_formatting_lit,
       string_of_fmtty,
       string_of_fmt,
       open_box_of_string,
       symm,
       trans,
       recast];
   runtime.caml_register_global(197, CamlinternalFormat, "CamlinternalFormat");
   return;
  }
  (globalThis));

//# 15834 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    CamlinternalFormat = global_data.CamlinternalFormat,
    Stdlib = global_data.Stdlib;
   function kfprintf(k, o, param){
    var fmt = param[1];
    return caml_call3
            (CamlinternalFormat[7],
             function(acc){
              caml_call2(CamlinternalFormat[9], o, acc);
              return caml_call1(k, o);
             },
             0,
             fmt);
   }
   function kbprintf(k, b, param){
    var fmt = param[1];
    return caml_call3
            (CamlinternalFormat[7],
             function(acc){
              caml_call2(CamlinternalFormat[10], b, acc);
              return caml_call1(k, b);
             },
             0,
             fmt);
   }
   function ikfprintf(k, oc, param){
    var fmt = param[1];
    return caml_call3(CamlinternalFormat[8], k, oc, fmt);
   }
   function fprintf(oc, fmt){
    return kfprintf(function(_d_){return 0;}, oc, fmt);
   }
   function bprintf(b, fmt){
    return kbprintf(function(_c_){return 0;}, b, fmt);
   }
   function ifprintf(oc, fmt){
    return ikfprintf(function(_b_){return 0;}, oc, fmt);
   }
   function ibprintf(b, fmt){
    return ikfprintf(function(_a_){return 0;}, b, fmt);
   }
   function printf(fmt){return fprintf(Stdlib[39], fmt);}
   function eprintf(fmt){return fprintf(Stdlib[40], fmt);}
   function ksprintf(k, param){
    var fmt = param[1];
    function k$0(acc){
     var buf = caml_call1(Stdlib_Buffer[1], 64);
     caml_call2(CamlinternalFormat[11], buf, acc);
     return caml_call1(k, caml_call1(Stdlib_Buffer[2], buf));
    }
    return caml_call3(CamlinternalFormat[7], k$0, 0, fmt);
   }
   function sprintf(fmt){return ksprintf(function(s){return s;}, fmt);}
   var
    Stdlib_Printf =
      [0,
       fprintf,
       printf,
       eprintf,
       sprintf,
       bprintf,
       ifprintf,
       ibprintf,
       kfprintf,
       ikfprintf,
       ksprintf,
       kbprintf,
       ikfprintf,
       ksprintf];
   runtime.caml_register_global(3, Stdlib_Printf, "Stdlib__Printf");
   return;
  }
  (globalThis));

//# 16644 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    CamlinternalAtomic = global_data.CamlinternalAtomic,
    make = CamlinternalAtomic[1],
    get = CamlinternalAtomic[2],
    set = CamlinternalAtomic[3],
    exchange = CamlinternalAtomic[4],
    compare_and_set = CamlinternalAtomic[5],
    fetch_and_add = CamlinternalAtomic[6],
    incr = CamlinternalAtomic[7],
    decr = CamlinternalAtomic[8],
    Stdlib_Atomic =
      [0,
       make,
       get,
       set,
       exchange,
       compare_and_set,
       fetch_and_add,
       incr,
       decr];
   runtime.caml_register_global(1, Stdlib_Atomic, "Stdlib__Atomic");
   return;
  }
  (globalThis));

//# 16676 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$4 = "",
    cst_s = "%s\n",
    cst_Program_not_linked_with_g_$0 =
      "(Program not linked with -g, cannot print stack backtrace)\n",
    cst_characters = ", characters ",
    cst_Fatal_error_exception = "Fatal error: exception ",
    cst_Fatal_error_exception_s = "Fatal error: exception %s\n",
    cst_Uncaught_exception = "Uncaught exception: ",
    cst_Uncaught_exception_s = "Uncaught exception: %s\n",
    caml_check_bound = runtime.caml_check_bound,
    caml_get_exception_raw_backtra = runtime.caml_get_exception_raw_backtrace,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$0 = cst$4,
    cst$3 = cst$4,
    partial = [4, 0, 0, 0, [12, 45, [4, 0, 0, 0, 0]]],
    cst$1 = cst$4,
    cst$2 = cst$4,
    cst = "_",
    locfmt =
      [0,
       [11,
        'File "',
        [2,
         0,
         [11,
          '", line ',
          [4,
           0,
           0,
           0,
           [11,
            cst_characters,
            [4, 0, 0, 0, [12, 45, [4, 0, 0, 0, [11, ": ", [2, 0, 0]]]]]]]]]],
       'File "%s", line %d, characters %d-%d: %s'],
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib_Atomic = global_data.Stdlib__Atomic,
    Stdlib = global_data.Stdlib,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Stdlib_Obj = global_data.Stdlib__Obj,
    printers = caml_call1(Stdlib_Atomic[1], 0),
    _a_ = [0, [3, 0, 0], "%S"],
    _b_ = [0, [4, 0, 0, 0, 0], "%d"],
    _c_ = [0, [11, ", ", [2, 0, [2, 0, 0]]], ", %s%s"],
    _d_ = [0, [12, 40, [2, 0, [2, 0, [12, 41, 0]]]], "(%s%s)"],
    _e_ = [0, [12, 40, [2, 0, [12, 41, 0]]], "(%s)"],
    cst_Out_of_memory = "Out of memory",
    cst_Stack_overflow = "Stack overflow",
    cst_Pattern_matching_failed = "Pattern matching failed",
    cst_Assertion_failed = "Assertion failed",
    cst_Undefined_recursive_module = "Undefined recursive module",
    _f_ =
      [0,
       [11, cst_Uncaught_exception, [2, 0, [12, 10, 0]]],
       cst_Uncaught_exception_s],
    _g_ =
      [0,
       [11, cst_Uncaught_exception, [2, 0, [12, 10, 0]]],
       cst_Uncaught_exception_s],
    cst_Raised_at = "Raised at",
    cst_Re_raised_at = "Re-raised at",
    cst_Raised_by_primitive_operat = "Raised by primitive operation at",
    cst_Called_from = "Called from",
    cst_inlined = " (inlined)",
    _h_ =
      [0,
       [2,
        0,
        [12,
         32,
         [2,
          0,
          [11,
           ' in file "',
           [2,
            0,
            [12,
             34,
             [2,
              0,
              [11, ", line ", [4, 0, 0, 0, [11, cst_characters, partial]]]]]]]]]],
       '%s %s in file "%s"%s, line %d, characters %d-%d'],
    _i_ = [0, [2, 0, [11, " unknown location", 0]], "%s unknown location"],
    _j_ = [0, [2, 0, [12, 10, 0]], cst_s],
    _k_ =
      [0,
       [11, cst_Program_not_linked_with_g_$0, 0],
       cst_Program_not_linked_with_g_$0],
    _l_ = [0, [2, 0, [12, 10, 0]], cst_s],
    cst_Program_not_linked_with_g_ = cst_Program_not_linked_with_g_$0;
   function field(x, i){
    var f = x[1 + i];
    if(! caml_call1(Stdlib_Obj[1], f))
     return caml_call2(Stdlib_Printf[4], _b_, f);
    var _ag_ = Stdlib_Obj[13];
    if(caml_obj_tag(f) === _ag_) return caml_call2(Stdlib_Printf[4], _a_, f);
    var _ah_ = Stdlib_Obj[14];
    return caml_obj_tag(f) === _ah_ ? caml_call1(Stdlib[35], f) : cst;
   }
   function other_fields(x, i){
    if(x.length - 1 <= i) return cst$0;
    var _ae_ = other_fields(x, i + 1 | 0), _af_ = field(x, i);
    return caml_call3(Stdlib_Printf[4], _c_, _af_, _ae_);
   }
   function use_printers(x){
    var param = caml_call1(Stdlib_Atomic[2], printers);
    for(;;){
     if(! param) return 0;
     var tl = param[2], hd = param[1];
     a:
     {
      try{var val = caml_call1(hd, x);}catch(_ad_){break a;}
      if(val){var s = val[1]; return [0, s];}
     }
     param = tl;
    }
   }
   function to_string_default(x){
    if(x === Stdlib[9]) return cst_Out_of_memory;
    if(x === Stdlib[10]) return cst_Stack_overflow;
    if(x[1] === Stdlib[4]){
     var
      match$0 = x[2],
      char$0 = match$0[3],
      line = match$0[2],
      file = match$0[1];
     return caml_call6
             (Stdlib_Printf[4],
              locfmt,
              file,
              line,
              char$0,
              char$0 + 5 | 0,
              cst_Pattern_matching_failed);
    }
    if(x[1] === Stdlib[5]){
     var
      match$1 = x[2],
      char$1 = match$1[3],
      line$0 = match$1[2],
      file$0 = match$1[1];
     return caml_call6
             (Stdlib_Printf[4],
              locfmt,
              file$0,
              line$0,
              char$1,
              char$1 + 6 | 0,
              cst_Assertion_failed);
    }
    if(x[1] === Stdlib[15]){
     var
      match$2 = x[2],
      char$2 = match$2[3],
      line$1 = match$2[2],
      file$1 = match$2[1];
     return caml_call6
             (Stdlib_Printf[4],
              locfmt,
              file$1,
              line$1,
              char$2,
              char$2 + 6 | 0,
              cst_Undefined_recursive_module);
    }
    if(0 !== caml_obj_tag(x)) return x[1];
    var constructor = x[1][1], match = x.length - 1;
    if(2 < match >>> 0)
     var
      _$_ = other_fields(x, 2),
      _aa_ = field(x, 1),
      _ac_ = caml_call3(Stdlib_Printf[4], _d_, _aa_, _$_);
    else
     switch(match){
       case 0:
        var _ac_ = cst$1; break;
       case 1:
        var _ac_ = cst$2; break;
       default:
        var
         _ab_ = field(x, 1),
         _ac_ = caml_call2(Stdlib_Printf[4], _e_, _ab_);
     }
    return caml_call2(Stdlib[28], constructor, _ac_);
   }
   function to_string(e){
    var match = use_printers(e);
    if(! match) return to_string_default(e);
    var s = match[1];
    return s;
   }
   function print(fct, arg){
    try{var ___ = caml_call1(fct, arg); return ___;}
    catch(x$0){
     var x = caml_wrap_exception(x$0), _Z_ = to_string(x);
     caml_call2(Stdlib_Printf[3], _f_, _Z_);
     caml_call1(Stdlib[63], Stdlib[40]);
     throw caml_maybe_attach_backtrace(x, 0);
    }
   }
   function catch$0(fct, arg){
    try{var _Y_ = caml_call1(fct, arg); return _Y_;}
    catch(x$0){
     var x = caml_wrap_exception(x$0);
     caml_call1(Stdlib[63], Stdlib[39]);
     var _X_ = to_string(x);
     caml_call2(Stdlib_Printf[3], _g_, _X_);
     return caml_call1(Stdlib[99], 2);
    }
   }
   function raw_backtrace_entries(bt){return bt;}
   function convert_raw_backtrace(bt){
    return [0, runtime.caml_convert_raw_backtrace(bt)];
   }
   function format_backtrace_slot(pos, slot){
    function info(is_raise){
     return is_raise
             ? 0 === pos ? cst_Raised_at : cst_Re_raised_at
             : 0 === pos ? cst_Raised_by_primitive_operat : cst_Called_from;
    }
    if(0 === slot[0]){
     var
      _P_ = slot[5],
      _Q_ = slot[4],
      _R_ = slot[3],
      _S_ = slot[6] ? cst_inlined : cst$3,
      _T_ = slot[2],
      _U_ = slot[7],
      _V_ = info(slot[1]);
     return [0,
             caml_call8
              (Stdlib_Printf[4], _h_, _V_, _U_, _T_, _S_, _R_, _Q_, _P_)];
    }
    if(slot[1]) return 0;
    var _W_ = info(0);
    return [0, caml_call2(Stdlib_Printf[4], _i_, _W_)];
   }
   function print_raw_backtrace(outchan, raw_backtrace){
    var backtrace = convert_raw_backtrace(raw_backtrace);
    if(! backtrace) return caml_call2(Stdlib_Printf[1], outchan, _k_);
    var a = backtrace[1], _N_ = a.length - 2 | 0, _M_ = 0;
    if(_N_ >= 0){
     var i = _M_;
     for(;;){
      var match = format_backtrace_slot(i, caml_check_bound(a, i)[1 + i]);
      if(match){
       var str = match[1];
       caml_call3(Stdlib_Printf[1], outchan, _j_, str);
      }
      var _O_ = i + 1 | 0;
      if(_N_ === i) break;
      i = _O_;
     }
    }
    return 0;
   }
   function print_backtrace(outchan){
    return print_raw_backtrace(outchan, caml_get_exception_raw_backtra(0));
   }
   function raw_backtrace_to_string(raw_backtrace){
    var backtrace = convert_raw_backtrace(raw_backtrace);
    if(! backtrace) return cst_Program_not_linked_with_g_;
    var
     a = backtrace[1],
     b = caml_call1(Stdlib_Buffer[1], 1024),
     _K_ = a.length - 2 | 0,
     _J_ = 0;
    if(_K_ >= 0){
     var i = _J_;
     for(;;){
      var match = format_backtrace_slot(i, caml_check_bound(a, i)[1 + i]);
      if(match){
       var str = match[1];
       caml_call3(Stdlib_Printf[5], b, _l_, str);
      }
      var _L_ = i + 1 | 0;
      if(_K_ === i) break;
      i = _L_;
     }
    }
    return caml_call1(Stdlib_Buffer[2], b);
   }
   function backtrace_slot_is_raise(param){
    return 0 === param[0] ? param[1] : param[1];
   }
   function backtrace_slot_is_inline(param){return 0 === param[0] ? param[6] : 0;
   }
   function backtrace_slot_location(param){
    return 0 === param[0]
            ? [0, [0, param[2], param[3], param[4], param[5]]]
            : 0;
   }
   function backtrace_slot_defname(param){
    if(0 === param[0] && param[7] !== cst$4) return [0, param[7]];
    return 0;
   }
   function backtrace_slots(raw_backtrace){
    var match = convert_raw_backtrace(raw_backtrace);
    if(! match) return 0;
    var backtrace = match[1], i$1 = backtrace.length - 2 | 0, i = i$1;
    for(;;){
     if(-1 === i)
      var _I_ = 0;
     else{
      var _H_ = 0 === caml_check_bound(backtrace, i)[1 + i][0] ? 1 : 0;
      if(! _H_){var i$0 = i - 1 | 0; i = i$0; continue;}
      var _I_ = _H_;
     }
     return _I_ ? [0, backtrace] : 0;
    }
   }
   function backtrace_slots_of_raw_entry(entry){return backtrace_slots([0, entry]);
   }
   function raw_backtrace_length(bt){return bt.length - 1;}
   function get_backtrace(param){
    return raw_backtrace_to_string(caml_get_exception_raw_backtra(0));
   }
   function register_printer(fn){
    for(;;){
     var
      old_printers = caml_call1(Stdlib_Atomic[2], printers),
      new_printers = [0, fn, old_printers],
      success =
        caml_call3(Stdlib_Atomic[5], printers, old_printers, new_printers),
      _G_ = 1 - success;
     if(! _G_) return _G_;
    }
   }
   function exn_slot(x){return 0 === caml_obj_tag(x) ? x[1] : x;}
   function exn_slot_id(x){var slot = exn_slot(x); return slot[2];}
   function exn_slot_name(x){var slot = exn_slot(x); return slot[1];}
   var
    errors =
      [0,
        cst$4,
        "(Cannot print locations:\n bytecode executable program file not found)",
        "(Cannot print locations:\n bytecode executable program file appears to be corrupt)",
        "(Cannot print locations:\n bytecode executable program file has wrong magic number)",
        "(Cannot print locations:\n bytecode executable program file cannot be opened;\n -- too many open files. Try running with OCAMLRUNPARAM=b=2)"].slice
       (),
    _m_ =
      [0,
       [11, cst_Fatal_error_exception, [2, 0, [12, 10, 0]]],
       cst_Fatal_error_exception_s];
   function default_uncaught_exception_han(exn, raw_backtrace){
    var _D_ = to_string(exn);
    caml_call2(Stdlib_Printf[3], _m_, _D_);
    print_raw_backtrace(Stdlib[40], raw_backtrace);
    var status = runtime.caml_ml_debug_info_status(0);
    if(status < 0){
     var
      _E_ = caml_call1(Stdlib[18], status),
      _F_ = caml_check_bound(errors, _E_)[1 + _E_];
     caml_call1(Stdlib[53], _F_);
    }
    return caml_call1(Stdlib[63], Stdlib[40]);
   }
   var uncaught_exception_handler = [0, default_uncaught_exception_han];
   function set_uncaught_exception_handler(fn){
    uncaught_exception_handler[1] = fn;
    return 0;
   }
   var
    empty_backtrace = [0],
    cst_Fatal_error_out_of_memory_ =
      "Fatal error: out of memory in uncaught exception handler",
    _n_ =
      [0,
       [11, cst_Fatal_error_exception, [2, 0, [12, 10, 0]]],
       cst_Fatal_error_exception_s],
    _o_ =
      [0,
       [11,
        "Fatal error in uncaught exception handler: exception ",
        [2, 0, [12, 10, 0]]],
       "Fatal error in uncaught exception handler: exception %s\n"];
   function handle_uncaught_exception(exn$0, debugger_in_use){
    try{
     try{
      var
       raw_backtrace =
         debugger_in_use ? empty_backtrace : caml_get_exception_raw_backtra(0);
      try{caml_call1(Stdlib[103], 0);}catch(_C_){}
      try{
       var
        _y_ = caml_call2(uncaught_exception_handler[1], exn$0, raw_backtrace),
        _x_ = _y_;
      }
      catch(exn$1){
       var
        exn = caml_wrap_exception(exn$1),
        raw_backtrace$0 = caml_get_exception_raw_backtra(0),
        _v_ = to_string(exn$0);
       caml_call2(Stdlib_Printf[3], _n_, _v_);
       print_raw_backtrace(Stdlib[40], raw_backtrace);
       var _w_ = to_string(exn);
       caml_call2(Stdlib_Printf[3], _o_, _w_);
       print_raw_backtrace(Stdlib[40], raw_backtrace$0);
       var _x_ = caml_call1(Stdlib[63], Stdlib[40]);
      }
      var _z_ = _x_;
     }
     catch(_B_){
      var _u_ = caml_wrap_exception(_B_);
      if(_u_ !== Stdlib[9]) throw caml_maybe_attach_backtrace(_u_, 0);
      var _z_ = caml_call1(Stdlib[53], cst_Fatal_error_out_of_memory_);
     }
     return _z_;
    }
    catch(_A_){return 0;}
   }
   runtime.caml_register_named_value
    ("Printexc.handle_uncaught_exception", handle_uncaught_exception);
   var
    Stdlib_Printexc =
      [0,
       to_string,
       to_string_default,
       print,
       catch$0,
       print_backtrace,
       get_backtrace,
       runtime.caml_record_backtrace,
       runtime.caml_backtrace_status,
       register_printer,
       use_printers,
       raw_backtrace_entries,
       function(_t_){return caml_get_exception_raw_backtra(_t_);},
       print_raw_backtrace,
       raw_backtrace_to_string,
       default_uncaught_exception_han,
       set_uncaught_exception_handler,
       backtrace_slots,
       backtrace_slots_of_raw_entry,
       [0,
        backtrace_slot_is_raise,
        backtrace_slot_is_inline,
        backtrace_slot_location,
        backtrace_slot_defname,
        format_backtrace_slot],
       raw_backtrace_length,
       function(_s_, _r_){return runtime.caml_raw_backtrace_slot(_s_, _r_);},
       function(_q_){return runtime.caml_convert_raw_backtrace_slot(_q_);},
       function(_p_){return runtime.caml_raw_backtrace_next_slot(_p_);},
       exn_slot_id,
       exn_slot_name];
   runtime.caml_register_global(42, Stdlib_Printexc, "Stdlib__Printexc");
   return;
  }
  (globalThis));

//# 17162 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_restore_raw_backtrace = runtime.caml_restore_raw_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Stdlib_Printexc = global_data.Stdlib__Printexc,
    Stdlib = global_data.Stdlib;
   function const$0(c, param){return c;}
   function flip(f, x, y){return caml_call2(f, y, x);}
   function negate(p, v){return 1 - caml_call1(p, v);}
   var
    Finally_raised =
      [248, "Stdlib.Fun.Finally_raised", runtime.caml_fresh_oo_id(0)],
    cst_Fun_Finally_raised = "Fun.Finally_raised: ";
   caml_call1
    (Stdlib_Printexc[9],
     function(param){
      if(param[1] !== Finally_raised) return 0;
      var exn = param[2], _a_ = caml_call1(Stdlib_Printexc[1], exn);
      return [0, caml_call2(Stdlib[28], cst_Fun_Finally_raised, _a_)];
     });
   function protect(finally$0, work){
    function finally_no_exn(param){
     try{caml_call1(finally$0, 0); return;}
     catch(e$0){
      var
       e = caml_wrap_exception(e$0),
       bt = caml_call1(Stdlib_Printexc[12], 0),
       exn = [0, Finally_raised, e];
      caml_restore_raw_backtrace(exn, bt);
      throw caml_maybe_attach_backtrace(exn, 0);
     }
    }
    try{var result = caml_call1(work, 0);}
    catch(work_exn$0){
     var
      work_exn = caml_wrap_exception(work_exn$0),
      work_bt = caml_call1(Stdlib_Printexc[12], 0);
     finally_no_exn(0);
     caml_restore_raw_backtrace(work_exn, work_bt);
     throw caml_maybe_attach_backtrace(work_exn, 0);
    }
    finally_no_exn(0);
    return result;
   }
   var Stdlib_Fun = [0, const$0, flip, negate, protect, Finally_raised];
   runtime.caml_register_global(4, Stdlib_Fun, "Stdlib__Fun");
   return;
  }
  (globalThis));

//# 17394 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Digest_from_hex$1 = "Digest.from_hex",
    caml_bytes_unsafe_set = runtime.caml_bytes_unsafe_set,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_md5_string = runtime.caml_md5_string,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_get = runtime.caml_string_get,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Stdlib_Char = global_data.Stdlib__Char,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Stdlib_String = global_data.Stdlib__String,
    compare = Stdlib_String[9],
    equal = Stdlib_String[8],
    cst_Digest_substring = "Digest.substring",
    cst_Digest_to_hex = "Digest.to_hex",
    cst_Digest_from_hex = cst_Digest_from_hex$1,
    cst_Digest_from_hex$0 = cst_Digest_from_hex$1;
   function string(str){
    return caml_md5_string(str, 0, caml_ml_string_length(str));
   }
   function bytes(b){return string(caml_call1(Stdlib_Bytes[48], b));}
   function substring(str, ofs, len){
    if(0 <= ofs && 0 <= len && (caml_ml_string_length(str) - len | 0) >= ofs)
     return caml_md5_string(str, ofs, len);
    return caml_call1(Stdlib[1], cst_Digest_substring);
   }
   function subbytes(b, ofs, len){
    return substring(caml_call1(Stdlib_Bytes[48], b), ofs, len);
   }
   function file(filename){
    var ic = caml_call1(Stdlib[80], filename);
    try{var d = runtime.caml_md5_chan(ic, -1);}
    catch(e$0){
     var e = caml_wrap_exception(e$0);
     caml_call1(Stdlib[93], ic);
     throw caml_maybe_attach_backtrace(e, 0);
    }
    caml_call1(Stdlib[93], ic);
    return d;
   }
   function output(chan, digest){return caml_call2(Stdlib[66], chan, digest);}
   function input(chan){return caml_call2(Stdlib[86], chan, 16);}
   function char_hex(n){var _e_ = 10 <= n ? 87 : 48; return n + _e_ | 0;}
   function to_hex(d){
    if(16 !== caml_ml_string_length(d))
     caml_call1(Stdlib[1], cst_Digest_to_hex);
    var result = caml_create_bytes(32), i = 0;
    for(;;){
     var x = caml_string_get(d, i);
     caml_bytes_unsafe_set(result, i * 2 | 0, char_hex(x >>> 4 | 0));
     caml_bytes_unsafe_set(result, (i * 2 | 0) + 1 | 0, char_hex(x & 15));
     var _d_ = i + 1 | 0;
     if(15 === i) return caml_call1(Stdlib_Bytes[48], result);
     i = _d_;
    }
   }
   function from_hex(s){
    if(32 !== caml_ml_string_length(s))
     caml_call1(Stdlib[1], cst_Digest_from_hex);
    function digit(c){
     if(65 <= c){
      if(97 <= c){
       if(103 > c) return (c - 97 | 0) + 10 | 0;
      }
      else if(71 > c) return (c - 65 | 0) + 10 | 0;
     }
     else if(9 >= c - 48 >>> 0) return c - 48 | 0;
     throw caml_maybe_attach_backtrace
            ([0, Stdlib[6], cst_Digest_from_hex$0], 1);
    }
    var result = caml_create_bytes(16), i = 0;
    for(;;){
     var
      i$0 = 2 * i | 0,
      _a_ = digit(caml_string_get(s, i$0 + 1 | 0)),
      _b_ = (digit(caml_string_get(s, i$0)) << 4) + _a_ | 0;
     runtime.caml_bytes_set(result, i, caml_call1(Stdlib_Char[1], _b_));
     var _c_ = i + 1 | 0;
     if(15 === i) return caml_call1(Stdlib_Bytes[48], result);
     i = _c_;
    }
   }
   var
    Stdlib_Digest =
      [0,
       compare,
       equal,
       string,
       bytes,
       substring,
       subbytes,
       file,
       output,
       input,
       to_hex,
       from_hex];
   runtime.caml_register_global(8, Stdlib_Digest, "Stdlib__Digest");
   return;
  }
  (globalThis));

//# 17515 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_check_bound = runtime.caml_check_bound,
    caml_greaterthan = runtime.caml_greaterthan,
    caml_int64_of_int32 = runtime.caml_int64_of_int32,
    caml_int64_or = runtime.caml_int64_or,
    caml_int64_shift_left = runtime.caml_int64_shift_left,
    caml_int64_shift_right_unsigne = runtime.caml_int64_shift_right_unsigned,
    caml_int64_sub = runtime.caml_int64_sub,
    caml_int64_to_int32 = runtime.caml_int64_to_int32,
    caml_lessequal = runtime.caml_lessequal,
    caml_mod = runtime.caml_mod,
    caml_string_get = runtime.caml_string_get,
    caml_sys_random_seed = runtime.caml_sys_random_seed;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Stdlib_Int32 = global_data.Stdlib__Int32,
    Stdlib_Int64 = global_data.Stdlib__Int64,
    Stdlib_Int = global_data.Stdlib__Int,
    Stdlib_Digest = global_data.Stdlib__Digest,
    Stdlib_Array = global_data.Stdlib__Array,
    Stdlib_Nativeint = global_data.Stdlib__Nativeint,
    cst_x = "x",
    cst_Random_int = "Random.int",
    cst_Random_full_int = "Random.full_int",
    cst_Random_int32 = "Random.int32",
    _a_ = runtime.caml_int64_create_lo_mi_hi(1, 0, 0),
    _b_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    cst_Random_int64 = "Random.int64";
   function new_state(param){return [0, runtime.caml_make_vect(55, 0), 0];}
   function assign(st1, st2){
    caml_call5(Stdlib_Array[10], st2[1], 0, st1[1], 0, 55);
    st1[2] = st2[2];
    return 0;
   }
   function full_init(s, seed){
    var
     seed$0 = 0 === seed.length - 1 ? [0, 0] : seed,
     l = seed$0.length - 1,
     i$0 = 0;
    for(;;){
     caml_check_bound(s[1], i$0)[1 + i$0] = i$0;
     var _q_ = i$0 + 1 | 0;
     if(54 === i$0) break;
     i$0 = _q_;
    }
    var
     accu = [0, cst_x],
     _n_ = 54 + caml_call2(Stdlib_Int[11], 55, l) | 0,
     _m_ = 0;
    if(_n_ >= 0){
     var i = _m_;
     for(;;){
      var
       j = i % 55 | 0,
       k = caml_mod(i, l),
       x = caml_check_bound(seed$0, k)[1 + k],
       accu$0 = accu[1],
       _g_ = caml_call1(Stdlib_Int[12], x),
       _h_ = caml_call2(Stdlib[28], accu$0, _g_);
      accu[1] = caml_call1(Stdlib_Digest[3], _h_);
      var
       d = accu[1],
       _i_ = caml_string_get(d, 3) << 24,
       _j_ = caml_string_get(d, 2) << 16,
       _k_ = caml_string_get(d, 1) << 8,
       _l_ = ((caml_string_get(d, 0) + _k_ | 0) + _j_ | 0) + _i_ | 0,
       _o_ = (caml_check_bound(s[1], j)[1 + j] ^ _l_) & 1073741823;
      caml_check_bound(s[1], j)[1 + j] = _o_;
      var _p_ = i + 1 | 0;
      if(_n_ === i) break;
      i = _p_;
     }
    }
    s[2] = 0;
    return 0;
   }
   function make(seed){
    var result = new_state(0);
    full_init(result, seed);
    return result;
   }
   function make_self_init(param){return make(caml_sys_random_seed(0));}
   function copy(s){
    var result = new_state(0);
    assign(result, s);
    return result;
   }
   function bits(s){
    s[2] = (s[2] + 1 | 0) % 55 | 0;
    var
     _d_ = s[2],
     curval = caml_check_bound(s[1], _d_)[1 + _d_],
     _e_ = (s[2] + 24 | 0) % 55 | 0,
     newval =
       caml_check_bound(s[1], _e_)[1 + _e_]
       + (curval ^ (curval >>> 25 | 0) & 31)
       | 0,
     newval30 = newval & 1073741823,
     _f_ = s[2];
    caml_check_bound(s[1], _f_)[1 + _f_] = newval30;
    return newval30;
   }
   function intaux(s, n){
    for(;;){
     var r = bits(s), v = caml_mod(r, n);
     if(((1073741823 - n | 0) + 1 | 0) >= (r - v | 0)) return v;
    }
   }
   function int$0(s, bound){
    if(1073741823 >= bound && 0 < bound) return intaux(s, bound);
    return caml_call1(Stdlib[1], cst_Random_int);
   }
   function full_int(s, bound){
    if(0 >= bound) return caml_call1(Stdlib[1], cst_Random_full_int);
    if(1073741823 >= bound) return intaux(s, bound);
    for(;;){
     var b1 = bits(s), b2 = bits(s), max_int_32 = 2147483647;
     if(bound <= 2147483647)
      var
       bpos = (b2 & 1073725440) << 1 | b1 >>> 15 | 0,
       max_int = max_int_32,
       r = bpos;
     else
      var
       b3 = bits(s),
       r$0 = ((b3 & 1073741312) << 12 | b2 >>> 9 | 0) << 20 | b1 >>> 10 | 0,
       max_int$0 = Stdlib[19],
       max_int = max_int$0,
       r = r$0;
     var v = caml_mod(r, bound);
     if(((max_int - bound | 0) + 1 | 0) >= (r - v | 0)) return v;
    }
   }
   function int32(s, bound){
    if(caml_lessequal(bound, 0))
     return caml_call1(Stdlib[1], cst_Random_int32);
    for(;;){
     var
      b1 = bits(s),
      b2 = (bits(s) & 1) << 30,
      r = b1 | b2,
      v = caml_mod(r, bound);
     if(! caml_greaterthan(r - v | 0, (Stdlib_Int32[9] - bound | 0) + 1 | 0))
      return v;
    }
   }
   function int64(s, bound){
    if(caml_lessequal(bound, _b_))
     return caml_call1(Stdlib[1], cst_Random_int64);
    for(;;){
     var
      b1 = caml_int64_of_int32(bits(s)),
      b2 = caml_int64_shift_left(caml_int64_of_int32(bits(s)), 30),
      b3 = caml_int64_shift_left(caml_int64_of_int32(bits(s) & 7), 60),
      r = caml_int64_or(b1, caml_int64_or(b2, b3)),
      v = runtime.caml_int64_mod(r, bound);
     if
      (!
       caml_greaterthan
        (caml_int64_sub(r, v),
         runtime.caml_int64_add(caml_int64_sub(Stdlib_Int64[9], bound), _a_)))
      return v;
    }
   }
   var
    _c_ =
      [0,
       987910699,
       495797812,
       364182224,
       414272206,
       318284740,
       990407751,
       383018966,
       270373319,
       840823159,
       24560019,
       536292337,
       512266505,
       189156120,
       730249596,
       143776328,
       51606627,
       140166561,
       366354223,
       1003410265,
       700563762,
       981890670,
       913149062,
       526082594,
       1021425055,
       784300257,
       667753350,
       630144451,
       949649812,
       48546892,
       415514493,
       258888527,
       511570777,
       89983870,
       283659902,
       308386020,
       242688715,
       482270760,
       865188196,
       1027664170,
       207196989,
       193777847,
       619708188,
       671350186,
       149669678,
       257044018,
       87658204,
       558145612,
       183450813,
       28133145,
       901332182,
       710253903,
       510646120,
       652377910,
       409934019,
       801085050],
    nativeint =
      32 === Stdlib_Nativeint[9]
       ? function(s, bound){return int32(s, bound);}
       : function
        (s, bound){
         return caml_int64_to_int32(int64(s, caml_int64_of_int32(bound)));
        };
   function float$0(s, bound){
    var r1 = bits(s), r2 = bits(s);
    return (r1 / 1073741824. + r2) / 1073741824. * bound;
   }
   function bool(s){return 0 === (bits(s) & 1) ? 1 : 0;}
   function bits32(s){
    var b1 = bits(s) >>> 14 | 0, b2 = bits(s) >>> 14 | 0;
    return b1 | b2 << 16;
   }
   function bits64(s){
    var
     b1 = caml_int64_shift_right_unsigne(caml_int64_of_int32(bits(s)), 9),
     b2 = caml_int64_shift_right_unsigne(caml_int64_of_int32(bits(s)), 9),
     b3 = caml_int64_shift_right_unsigne(caml_int64_of_int32(bits(s)), 8);
    return caml_int64_or
            (b1,
             caml_int64_or
              (caml_int64_shift_left(b2, 21), caml_int64_shift_left(b3, 42)));
   }
   var
    nativebits =
      32 === Stdlib_Nativeint[9]
       ? function(s){return bits32(s);}
       : function(s){return caml_int64_to_int32(bits64(s));},
    default$0 = [0, _c_.slice(), 0];
   function bits$0(param){return bits(default$0);}
   function int$1(bound){return int$0(default$0, bound);}
   function full_int$0(bound){return full_int(default$0, bound);}
   function int32$0(bound){return int32(default$0, bound);}
   function nativeint$0(bound){return nativeint(default$0, bound);}
   function int64$0(bound){return int64(default$0, bound);}
   function float$1(scale){return float$0(default$0, scale);}
   function bool$0(param){return bool(default$0);}
   function bits32$0(param){return bits32(default$0);}
   function bits64$0(param){return bits64(default$0);}
   function nativebits$0(param){return nativebits(default$0);}
   function full_init$0(seed){return full_init(default$0, seed);}
   function init(seed){return full_init(default$0, [0, seed]);}
   function self_init(param){
    var seed = caml_sys_random_seed(0);
    return full_init(default$0, seed);
   }
   function get_state(param){return copy(default$0);}
   function set_state(s){return assign(default$0, s);}
   var
    Stdlib_Random =
      [0,
       init,
       full_init$0,
       self_init,
       bits$0,
       int$1,
       full_int$0,
       int32$0,
       nativeint$0,
       int64$0,
       float$1,
       bool$0,
       bits32$0,
       bits64$0,
       nativebits$0,
       [0,
        make,
        make_self_init,
        copy,
        bits,
        int$0,
        full_int,
        int32,
        nativeint,
        int64,
        float$0,
        bool,
        bits32,
        bits64,
        nativebits],
       get_state,
       set_state];
   runtime.caml_register_global(18, Stdlib_Random, "Stdlib__Random");
   return;
  }
  (globalThis));

//# 17849 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_check_bound = runtime.caml_check_bound,
    caml_compare = runtime.caml_compare,
    caml_hash = runtime.caml_hash,
    caml_make_vect = runtime.caml_make_vect,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_sys_getenv = runtime.caml_sys_getenv,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    _d_ = [0, 0],
    cst = "",
    Stdlib_Sys = global_data.Stdlib__Sys,
    Stdlib = global_data.Stdlib,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Stdlib_Random = global_data.Stdlib__Random,
    Stdlib_Seq = global_data.Stdlib__Seq,
    Stdlib_Int = global_data.Stdlib__Int,
    Stdlib_Array = global_data.Stdlib__Array;
   global_data.Assert_failure;
   var Stdlib_String = global_data.Stdlib__String;
   function ongoing_traversal(h){
    var _aq_ = h.length - 1 < 4 ? 1 : 0, _ar_ = _aq_ || (h[4] < 0 ? 1 : 0);
    return _ar_;
   }
   function flip_ongoing_traversal(h){h[4] = - h[4] | 0; return 0;}
   var
    cst_Hashtbl_unsupported_hash_t = "Hashtbl: unsupported hash table format";
   try{var _f_ = caml_sys_getenv("OCAMLRUNPARAM"), params = _f_;}
   catch(_ao_){
    var _a_ = caml_wrap_exception(_ao_);
    if(_a_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_a_, 0);
    try{var _e_ = caml_sys_getenv("CAMLRUNPARAM"), _c_ = _e_;}
    catch(_ap_){
     var _b_ = caml_wrap_exception(_ap_);
     if(_b_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_b_, 0);
     var _c_ = cst;
    }
    var params = _c_;
   }
   var
    randomized_default = caml_call2(Stdlib_String[14], params, 82),
    randomized = [0, randomized_default];
   function randomize(param){randomized[1] = 1; return 0;}
   function is_randomized(param){return randomized[1];}
   var
    prng = [246, function(_an_){return caml_call1(Stdlib_Random[15][2], 0);}];
   function power_2_above(x, n){
    var x$0 = x;
    for(;;){
     if(n <= x$0) return x$0;
     if(Stdlib_Sys[13] < (x$0 * 2 | 0)) return x$0;
     var x$1 = x$0 * 2 | 0;
     x$0 = x$1;
    }
   }
   function create(opt, initial_size){
    if(opt) var sth = opt[1], random = sth; else var random = randomized[1];
    var s = power_2_above(16, initial_size);
    if(random)
     var
      _al_ = caml_obj_tag(prng),
      _am_ =
        250 === _al_
         ? prng[1]
         : 246 === _al_ ? caml_call1(CamlinternalLazy[2], prng) : prng,
      seed = caml_call1(Stdlib_Random[15][4], _am_);
    else
     var seed = 0;
    return [0, 0, caml_make_vect(s, 0), seed, s];
   }
   function clear(h){
    var _ak_ = 0 < h[1] ? 1 : 0;
    return _ak_
            ? (h
               [1]
              = 0,
              caml_call4(Stdlib_Array[9], h[2], 0, h[2].length - 1, 0))
            : _ak_;
   }
   function reset(h){
    var len = h[2].length - 1;
    if(4 <= h.length - 1 && len !== caml_call1(Stdlib[18], h[4])){
     h[1] = 0;
     h[2] = caml_make_vect(caml_call1(Stdlib[18], h[4]), 0);
     return 0;
    }
    return clear(h);
   }
   function copy_bucketlist(param){
    if(! param) return 0;
    var
     key = param[1],
     data = param[2],
     next = param[3],
     prec$1 = [0, key, data, next],
     prec = prec$1,
     param$0 = next;
    for(;;){
     if(! param$0) return prec$1;
     var
      key$0 = param$0[1],
      data$0 = param$0[2],
      next$0 = param$0[3],
      prec$0 = [0, key$0, data$0, next$0];
     prec[3] = prec$0;
     prec = prec$0;
     param$0 = next$0;
    }
   }
   function copy(h){
    var
     _ah_ = h[4],
     _ai_ = h[3],
     _aj_ = caml_call2(Stdlib_Array[15], copy_bucketlist, h[2]);
    return [0, h[1], _aj_, _ai_, _ah_];
   }
   function length(h){return h[1];}
   function insert_all_buckets(indexfun, inplace, odata, ndata){
    var
     nsize = ndata.length - 1,
     ndata_tail = caml_make_vect(nsize, 0),
     _ab_ = odata.length - 2 | 0,
     _aa_ = 0;
    if(_ab_ >= 0){
     var i$0 = _aa_;
     for(;;){
      var cell$1 = caml_check_bound(odata, i$0)[1 + i$0], cell = cell$1;
      for(;;){
       if(! cell) break;
       var
        key = cell[1],
        data = cell[2],
        next = cell[3],
        cell$0 = inplace ? cell : [0, key, data, 0],
        nidx = caml_call1(indexfun, key),
        match = caml_check_bound(ndata_tail, nidx)[1 + nidx];
       if(match)
        match[3] = cell$0;
       else
        caml_check_bound(ndata, nidx)[1 + nidx] = cell$0;
       caml_check_bound(ndata_tail, nidx)[1 + nidx] = cell$0;
       cell = next;
      }
      var _ag_ = i$0 + 1 | 0;
      if(_ab_ === i$0) break;
      i$0 = _ag_;
     }
    }
    if(inplace){
     var _ad_ = nsize - 1 | 0, _ac_ = 0;
     if(_ad_ >= 0){
      var i = _ac_;
      for(;;){
       var match$0 = caml_check_bound(ndata_tail, i)[1 + i];
       if(match$0) match$0[3] = 0;
       var _af_ = i + 1 | 0;
       if(_ad_ === i) break;
       i = _af_;
      }
     }
     var _ae_ = 0;
    }
    else
     var _ae_ = inplace;
    return _ae_;
   }
   function resize(indexfun, h){
    var
     odata = h[2],
     osize = odata.length - 1,
     nsize = osize * 2 | 0,
     _$_ = nsize < Stdlib_Sys[13] ? 1 : 0;
    if(! _$_) return _$_;
    var ndata = caml_make_vect(nsize, 0), inplace = 1 - ongoing_traversal(h);
    h[2] = ndata;
    return insert_all_buckets(caml_call1(indexfun, h), inplace, odata, ndata);
   }
   function iter(f, h){
    var old_trav = ongoing_traversal(h);
    if(1 - old_trav) flip_ongoing_traversal(h);
    try{
     var d = h[2], _X_ = d.length - 2 | 0, _W_ = 0;
     if(_X_ >= 0){
      var i = _W_;
      for(;;){
       var param = caml_check_bound(d, i)[1 + i];
       for(;;){
        if(! param) break;
        var key = param[1], data = param[2], next = param[3];
        caml_call2(f, key, data);
        param = next;
       }
       var ___ = i + 1 | 0;
       if(_X_ === i) break;
       i = ___;
      }
     }
     var _Y_ = 1 - old_trav, _Z_ = _Y_ ? flip_ongoing_traversal(h) : _Y_;
     return _Z_;
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(old_trav) throw caml_maybe_attach_backtrace(exn, 0);
     flip_ongoing_traversal(h);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function filter_map_inplace(f, h){
    var d = h[2], old_trav = ongoing_traversal(h);
    if(1 - old_trav) flip_ongoing_traversal(h);
    try{
     var _S_ = d.length - 2 | 0, _R_ = 0;
     if(_S_ >= 0){
      var i = _R_;
      for(;;){
       var slot$0 = caml_check_bound(h[2], i)[1 + i], prec = 0, slot = slot$0;
       for(;;){
        if(! slot) break;
        var
         key = slot[1],
         data = slot[2],
         next = slot[3],
         match = caml_call2(f, key, data);
        if(match){
         var data$0 = match[1];
         if(prec)
          prec[3] = slot;
         else
          caml_check_bound(h[2], i)[1 + i] = slot;
         slot[2] = data$0;
         prec = slot;
         slot = next;
        }
        else{h[1] = h[1] - 1 | 0; slot = next;}
       }
       if(prec) prec[3] = 0; else caml_check_bound(h[2], i)[1 + i] = 0;
       var _V_ = i + 1 | 0;
       if(_S_ === i) break;
       i = _V_;
      }
     }
     var _T_ = 1 - old_trav, _U_ = _T_ ? flip_ongoing_traversal(h) : _T_;
     return _U_;
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(old_trav) throw caml_maybe_attach_backtrace(exn, 0);
     flip_ongoing_traversal(h);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function fold(f, h, init){
    var old_trav = ongoing_traversal(h);
    if(1 - old_trav) flip_ongoing_traversal(h);
    try{
     var d = h[2], accu$1 = [0, init], _O_ = d.length - 2 | 0, _N_ = 0;
     if(_O_ >= 0){
      var i = _N_;
      for(;;){
       var
        accu$2 = accu$1[1],
        b$0 = caml_check_bound(d, i)[1 + i],
        b = b$0,
        accu = accu$2;
       for(;;){
        if(! b) break;
        var
         key = b[1],
         data = b[2],
         next = b[3],
         accu$0 = caml_call3(f, key, data, accu);
        b = next;
        accu = accu$0;
       }
       accu$1[1] = accu;
       var _Q_ = i + 1 | 0;
       if(_O_ === i) break;
       i = _Q_;
      }
     }
     if(1 - old_trav) flip_ongoing_traversal(h);
     var _P_ = accu$1[1];
     return _P_;
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(old_trav) throw caml_maybe_attach_backtrace(exn, 0);
     flip_ongoing_traversal(h);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function bucket_length(accu, param){
    var accu$0 = accu, param$0 = param;
    for(;;){
     if(! param$0) return accu$0;
     var next = param$0[3], accu$1 = accu$0 + 1 | 0;
     accu$0 = accu$1;
     param$0 = next;
    }
   }
   function stats(h){
    var
     mbl =
       caml_call3
        (Stdlib_Array[17],
         function(m, b){
          var _M_ = bucket_length(0, b);
          return caml_call2(Stdlib_Int[11], m, _M_);
         },
         0,
         h[2]),
     histo = caml_make_vect(mbl + 1 | 0, 0);
    caml_call2
     (Stdlib_Array[13],
      function(b){
       var l = bucket_length(0, b);
       histo[1 + l] = caml_check_bound(histo, l)[1 + l] + 1 | 0;
       return 0;
      },
      h[2]);
    return [0, h[1], h[2].length - 1, mbl, histo];
   }
   function to_seq(tbl){
    var tbl_data = tbl[2];
    function aux(i, buck, param){
     var i$0 = i, buck$0 = buck;
     for(;;){
      if(buck$0){
       var key = buck$0[1], data = buck$0[2], next = buck$0[3];
       return [0, [0, key, data], function(_L_){return aux(i$0, next, _L_);}];
      }
      if(i$0 === tbl_data.length - 1) return 0;
      var
       buck$1 = caml_check_bound(tbl_data, i$0)[1 + i$0],
       i$1 = i$0 + 1 | 0;
      i$0 = i$1;
      buck$0 = buck$1;
     }
    }
    var _I_ = 0, _J_ = 0;
    return function(_K_){return aux(_J_, _I_, _K_);};
   }
   function to_seq_keys(m){
    var _G_ = to_seq(m);
    return caml_call2(Stdlib_Seq[27], function(_H_){return _H_[1];}, _G_);
   }
   function to_seq_values(m){
    var _E_ = to_seq(m);
    return caml_call2(Stdlib_Seq[27], function(_F_){return _F_[2];}, _E_);
   }
   function MakeSeeded(H){
    function key_index(h, key){
     var _D_ = h[2].length - 2 | 0;
     return caml_call2(H[2], h[3], key) & _D_;
    }
    function add(h, key, data){
     var
      i = key_index(h, key),
      bucket = [0, key, data, caml_check_bound(h[2], i)[1 + i]];
     caml_check_bound(h[2], i)[1 + i] = bucket;
     h[1] = h[1] + 1 | 0;
     var _C_ = h[2].length - 1 << 1 < h[1] ? 1 : 0;
     return _C_ ? resize(key_index, h) : _C_;
    }
    function remove(h, key){
     var
      i = key_index(h, key),
      c = caml_check_bound(h[2], i)[1 + i],
      prec$0 = 0,
      prec = c;
     for(;;){
      if(! prec) return 0;
      var k = prec[1], next = prec[3];
      if(caml_call2(H[1], k, key)){
       h[1] = h[1] - 1 | 0;
       return prec$0
               ? (prec$0[3] = next, 0)
               : (caml_check_bound(h[2], i)[1 + i] = next, 0);
      }
      prec$0 = prec;
      prec = next;
     }
    }
    function find(h, key){
     var
      _B_ = key_index(h, key),
      match = caml_check_bound(h[2], _B_)[1 + _B_];
     if(! match) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     var k1 = match[1], d1 = match[2], next1 = match[3];
     if(caml_call2(H[1], key, k1)) return d1;
     if(! next1) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     var k2 = next1[1], d2 = next1[2], next2 = next1[3];
     if(caml_call2(H[1], key, k2)) return d2;
     if(! next2) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     var k3 = next2[1], d3 = next2[2], next3 = next2[3];
     if(caml_call2(H[1], key, k3)) return d3;
     var param = next3;
     for(;;){
      if(! param) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
      var k = param[1], data = param[2], next = param[3];
      if(caml_call2(H[1], key, k)) return data;
      param = next;
     }
    }
    function find_opt(h, key){
     var
      _A_ = key_index(h, key),
      match = caml_check_bound(h[2], _A_)[1 + _A_];
     if(! match) return 0;
     var k1 = match[1], d1 = match[2], next1 = match[3];
     if(caml_call2(H[1], key, k1)) return [0, d1];
     if(! next1) return 0;
     var k2 = next1[1], d2 = next1[2], next2 = next1[3];
     if(caml_call2(H[1], key, k2)) return [0, d2];
     if(! next2) return 0;
     var k3 = next2[1], d3 = next2[2], next3 = next2[3];
     if(caml_call2(H[1], key, k3)) return [0, d3];
     var param = next3;
     for(;;){
      if(! param) return 0;
      var k = param[1], data = param[2], next = param[3];
      if(caml_call2(H[1], key, k)) return [0, data];
      param = next;
     }
    }
    function find_all(h, key){
     function find_in_bucket(param){
      var param$0 = param;
      for(;;){
       if(! param$0) return 0;
       var k = param$0[1], d = param$0[2], next = param$0[3];
       if(caml_call2(H[1], k, key)) return [0, d, find_in_bucket(next)];
       param$0 = next;
      }
     }
     var _z_ = key_index(h, key);
     return find_in_bucket(caml_check_bound(h[2], _z_)[1 + _z_]);
    }
    function replace(h, key, data){
     var
      i = key_index(h, key),
      l = caml_check_bound(h[2], i)[1 + i],
      slot = l;
     for(;;){
      if(slot){
       var k = slot[1], next = slot[3];
       if(! caml_call2(H[1], k, key)){slot = next; continue;}
       slot[1] = key;
       slot[2] = data;
       var _w_ = 0;
      }
      else
       var _w_ = 1;
      if(_w_){
       caml_check_bound(h[2], i)[1 + i] = [0, key, data, l];
       h[1] = h[1] + 1 | 0;
       var _x_ = h[2].length - 1 << 1 < h[1] ? 1 : 0;
       if(_x_) return resize(key_index, h);
       var _y_ = _x_;
      }
      else
       var _y_ = _w_;
      return _y_;
     }
    }
    function mem(h, key){
     var
      _v_ = key_index(h, key),
      param = caml_check_bound(h[2], _v_)[1 + _v_];
     for(;;){
      if(! param) return 0;
      var k = param[1], next = param[3], _u_ = caml_call2(H[1], k, key);
      if(_u_) return _u_;
      param = next;
     }
    }
    function add_seq(tbl, i){
     return caml_call2
             (Stdlib_Seq[4],
              function(param){
               var v = param[2], k = param[1];
               return add(tbl, k, v);
              },
              i);
    }
    function replace_seq(tbl, i){
     return caml_call2
             (Stdlib_Seq[4],
              function(param){
               var v = param[2], k = param[1];
               return replace(tbl, k, v);
              },
              i);
    }
    function of_seq(i){
     var tbl = create(0, 16);
     replace_seq(tbl, i);
     return tbl;
    }
    return [0,
            create,
            clear,
            reset,
            copy,
            add,
            remove,
            find,
            find_opt,
            find_all,
            replace,
            mem,
            iter,
            filter_map_inplace,
            fold,
            length,
            stats,
            to_seq,
            to_seq_keys,
            to_seq_values,
            add_seq,
            replace_seq,
            of_seq];
   }
   function Make(H){
    var equal = H[1];
    function hash(seed, x){return caml_call1(H[2], x);}
    var
     include = MakeSeeded([0, equal, hash]),
     _t_ = include[1],
     clear = include[2],
     reset = include[3],
     copy = include[4],
     add = include[5],
     remove = include[6],
     find = include[7],
     find_opt = include[8],
     find_all = include[9],
     replace = include[10],
     mem = include[11],
     iter = include[12],
     filter_map_inplace = include[13],
     fold = include[14],
     length = include[15],
     stats = include[16],
     to_seq = include[17],
     to_seq_keys = include[18],
     to_seq_values = include[19],
     add_seq = include[20],
     replace_seq = include[21];
    function create(sz){return caml_call2(_t_, _d_, sz);}
    function of_seq(i){
     var tbl = caml_call2(_t_, _d_, 16);
     caml_call2(replace_seq, tbl, i);
     return tbl;
    }
    return [0,
            create,
            clear,
            reset,
            copy,
            add,
            remove,
            find,
            find_opt,
            find_all,
            replace,
            mem,
            iter,
            filter_map_inplace,
            fold,
            length,
            stats,
            to_seq,
            to_seq_keys,
            to_seq_values,
            add_seq,
            replace_seq,
            of_seq];
   }
   function hash(x){return caml_hash(10, 100, 0, x);}
   function hash_param(n1, n2, x){return caml_hash(n1, n2, 0, x);}
   function seeded_hash(seed, x){return caml_hash(10, 100, seed, x);}
   function key_index(h, key){
    return 4 <= h.length - 1
            ? caml_hash(10, 100, h[3], key) & (h[2].length - 2 | 0)
            : caml_call1(Stdlib[1], cst_Hashtbl_unsupported_hash_t);
   }
   function add(h, key, data){
    var
     i = key_index(h, key),
     bucket = [0, key, data, caml_check_bound(h[2], i)[1 + i]];
    caml_check_bound(h[2], i)[1 + i] = bucket;
    h[1] = h[1] + 1 | 0;
    var _s_ = h[2].length - 1 << 1 < h[1] ? 1 : 0;
    return _s_ ? resize(key_index, h) : _s_;
   }
   function remove(h, key){
    var
     i = key_index(h, key),
     c = caml_check_bound(h[2], i)[1 + i],
     prec$0 = 0,
     prec = c;
    for(;;){
     if(! prec) return 0;
     var k = prec[1], next = prec[3];
     if(0 === caml_compare(k, key)){
      h[1] = h[1] - 1 | 0;
      return prec$0
              ? (prec$0[3] = next, 0)
              : (caml_check_bound(h[2], i)[1 + i] = next, 0);
     }
     prec$0 = prec;
     prec = next;
    }
   }
   function find(h, key){
    var _r_ = key_index(h, key), match = caml_check_bound(h[2], _r_)[1 + _r_];
    if(! match) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
    var k1 = match[1], d1 = match[2], next1 = match[3];
    if(0 === caml_compare(key, k1)) return d1;
    if(! next1) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
    var k2 = next1[1], d2 = next1[2], next2 = next1[3];
    if(0 === caml_compare(key, k2)) return d2;
    if(! next2) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
    var k3 = next2[1], d3 = next2[2], next3 = next2[3];
    if(0 === caml_compare(key, k3)) return d3;
    var param = next3;
    for(;;){
     if(! param) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     var k = param[1], data = param[2], next = param[3];
     if(0 === caml_compare(key, k)) return data;
     param = next;
    }
   }
   function find_opt(h, key){
    var _q_ = key_index(h, key), match = caml_check_bound(h[2], _q_)[1 + _q_];
    if(! match) return 0;
    var k1 = match[1], d1 = match[2], next1 = match[3];
    if(0 === caml_compare(key, k1)) return [0, d1];
    if(! next1) return 0;
    var k2 = next1[1], d2 = next1[2], next2 = next1[3];
    if(0 === caml_compare(key, k2)) return [0, d2];
    if(! next2) return 0;
    var k3 = next2[1], d3 = next2[2], next3 = next2[3];
    if(0 === caml_compare(key, k3)) return [0, d3];
    var param = next3;
    for(;;){
     if(! param) return 0;
     var k = param[1], data = param[2], next = param[3];
     if(0 === caml_compare(key, k)) return [0, data];
     param = next;
    }
   }
   function find_all(h, key){
    function find_in_bucket(param){
     var param$0 = param;
     for(;;){
      if(! param$0) return 0;
      var k = param$0[1], data = param$0[2], next = param$0[3];
      if(0 === caml_compare(k, key)) return [0, data, find_in_bucket(next)];
      param$0 = next;
     }
    }
    var _p_ = key_index(h, key);
    return find_in_bucket(caml_check_bound(h[2], _p_)[1 + _p_]);
   }
   function replace(h, key, data){
    var i = key_index(h, key), l = caml_check_bound(h[2], i)[1 + i], slot = l;
    for(;;){
     if(slot){
      var k = slot[1], next = slot[3];
      if(0 !== caml_compare(k, key)){slot = next; continue;}
      slot[1] = key;
      slot[2] = data;
      var _m_ = 0;
     }
     else
      var _m_ = 1;
     if(_m_){
      caml_check_bound(h[2], i)[1 + i] = [0, key, data, l];
      h[1] = h[1] + 1 | 0;
      var _n_ = h[2].length - 1 << 1 < h[1] ? 1 : 0;
      if(_n_) return resize(key_index, h);
      var _o_ = _n_;
     }
     else
      var _o_ = _m_;
     return _o_;
    }
   }
   function mem(h, key){
    var _l_ = key_index(h, key), param = caml_check_bound(h[2], _l_)[1 + _l_];
    for(;;){
     if(! param) return 0;
     var
      k = param[1],
      next = param[3],
      _k_ = 0 === caml_compare(k, key) ? 1 : 0;
     if(_k_) return _k_;
     param = next;
    }
   }
   function add_seq(tbl, i){
    return caml_call2
            (Stdlib_Seq[4],
             function(param){
              var v = param[2], k = param[1];
              return add(tbl, k, v);
             },
             i);
   }
   function replace_seq(tbl, i){
    return caml_call2
            (Stdlib_Seq[4],
             function(param){
              var v = param[2], k = param[1];
              return replace(tbl, k, v);
             },
             i);
   }
   function of_seq(i){
    var tbl = create(0, 16);
    replace_seq(tbl, i);
    return tbl;
   }
   function rebuild(opt, h){
    if(opt) var sth = opt[1], random = sth; else var random = randomized[1];
    var s = power_2_above(16, h[2].length - 1);
    if(random)
     var
      _g_ = caml_obj_tag(prng),
      _h_ =
        250 === _g_
         ? prng[1]
         : 246 === _g_ ? caml_call1(CamlinternalLazy[2], prng) : prng,
      seed = caml_call1(Stdlib_Random[15][4], _h_);
    else
     var seed = 4 <= h.length - 1 ? h[3] : 0;
    var
     _i_ = 4 <= h.length - 1 ? h[4] : s,
     h$0 = [0, h[1], caml_make_vect(s, 0), seed, _i_];
    insert_all_buckets
     (function(_j_){return key_index(h$0, _j_);}, 0, h[2], h$0[2]);
    return h$0;
   }
   var
    Stdlib_Hashtbl =
      [0,
       create,
       clear,
       reset,
       copy,
       add,
       find,
       find_opt,
       find_all,
       mem,
       remove,
       replace,
       iter,
       filter_map_inplace,
       fold,
       length,
       randomize,
       is_randomized,
       rebuild,
       stats,
       to_seq,
       to_seq_keys,
       to_seq_values,
       add_seq,
       replace_seq,
       of_seq,
       Make,
       MakeSeeded,
       hash,
       seeded_hash,
       hash_param,
       caml_hash];
   runtime.caml_register_global(15, Stdlib_Hashtbl, "Stdlib__Hashtbl");
   return;
  }
  (globalThis));

//# 18661 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_check_bound = runtime.caml_check_bound,
    caml_make_vect = runtime.caml_make_vect,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_mod = runtime.caml_mod;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Stdlib_Sys = global_data.Stdlib__Sys,
    Stdlib_Int = global_data.Stdlib__Int,
    Stdlib_Array = global_data.Stdlib__Array,
    Stdlib_Obj = global_data.Stdlib__Obj,
    cst_Weak_create = "Weak.create",
    cst_Weak_set = "Weak.set",
    cst_Weak_get = "Weak.get",
    cst_Weak_get_copy = "Weak.get_copy",
    cst_Weak_check = "Weak.check",
    cst_Weak_blit = "Weak.blit",
    cst_Weak_fill = "Weak.fill",
    cst_Weak_Make_hash_bucket_cann = "Weak.Make: hash bucket cannot grow more";
   function create(l){
    var
     _J_ = 0 <= l ? 1 : 0,
     _K_ = _J_ ? l <= Stdlib_Obj[26][15] ? 1 : 0 : _J_;
    if(1 - _K_) caml_call1(Stdlib[1], cst_Weak_create);
    return runtime.caml_weak_create(l);
   }
   function length(x){return x.length - 3 | 0;}
   function raise_if_invalid_offset(e, o, msg){
    var
     _G_ = 0 <= o ? 1 : 0,
     _H_ = _G_ ? o < length(e) ? 1 : 0 : _G_,
     _I_ = 1 - _H_;
    return _I_ ? caml_call1(Stdlib[1], msg) : _I_;
   }
   function set(e, o, x){
    raise_if_invalid_offset(e, o, cst_Weak_set);
    if(! x) return runtime.caml_ephe_unset_key(e, o);
    var x$0 = x[1];
    return runtime.caml_ephe_set_key(e, o, x$0);
   }
   function get(e, o){
    raise_if_invalid_offset(e, o, cst_Weak_get);
    return runtime.caml_ephe_get_key(e, o);
   }
   function get_copy(e, o){
    raise_if_invalid_offset(e, o, cst_Weak_get_copy);
    return runtime.caml_ephe_get_key_copy(e, o);
   }
   function check(e, o){
    raise_if_invalid_offset(e, o, cst_Weak_check);
    return runtime.caml_ephe_check_key(e, o);
   }
   function blit(e1, o1, e2, o2, l){
    if
     (0 <= l
      &&
       0 <= o1
       && (length(e1) - l | 0) >= o1 && 0 <= o2 && (length(e2) - l | 0) >= o2){
     var
      _E_ = 0 !== l ? 1 : 0,
      _F_ = _E_ ? runtime.caml_ephe_blit_key(e1, o1, e2, o2, l) : _E_;
     return _F_;
    }
    return caml_call1(Stdlib[1], cst_Weak_blit);
   }
   function fill(ar, ofs, len, x){
    if(0 <= ofs && 0 <= len && (length(ar) - len | 0) >= ofs){
     var _C_ = (ofs + len | 0) - 1 | 0;
     if(_C_ >= ofs){
      var i = ofs;
      for(;;){
       set(ar, i, x);
       var _D_ = i + 1 | 0;
       if(_C_ === i) break;
       i = _D_;
      }
     }
     return 0;
    }
    throw caml_maybe_attach_backtrace([0, Stdlib[6], cst_Weak_fill], 1);
   }
   function Make(H){
    var emptybucket = create(0);
    function get_index(t, h){
     return caml_mod(h & Stdlib[19], t[1].length - 1);
    }
    var limit = 7;
    function create$0(sz){
     var
      sz$0 = 7 <= sz ? sz : 7,
      sz$1 = Stdlib_Sys[13] < sz$0 ? Stdlib_Sys[13] : sz$0;
     return [0,
             caml_make_vect(sz$1, emptybucket),
             caml_make_vect(sz$1, [0]),
             limit,
             0,
             0];
    }
    function clear(t){
     var _A_ = t[1].length - 2 | 0, _z_ = 0;
     if(_A_ >= 0){
      var i = _z_;
      for(;;){
       caml_check_bound(t[1], i)[1 + i] = emptybucket;
       caml_check_bound(t[2], i)[1 + i] = [0];
       var _B_ = i + 1 | 0;
       if(_A_ === i) break;
       i = _B_;
      }
     }
     t[3] = limit;
     t[4] = 0;
     return 0;
    }
    function fold(f, t, init){
     var i = 0;
     return caml_call3
             (Stdlib_Array[19],
              function(b, accu$1){
               var i$0 = i, accu = accu$1;
               for(;;){
                if(length(b) <= i$0) return accu;
                var match = get(b, i$0);
                if(match){
                 var
                  v = match[1],
                  accu$0 = caml_call2(f, v, accu),
                  i$1 = i$0 + 1 | 0;
                 i$0 = i$1;
                 accu = accu$0;
                }
                else{var i$2 = i$0 + 1 | 0; i$0 = i$2;}
               }
              },
              t[1],
              init);
    }
    function iter(f, t){
     var i = 0;
     return caml_call2
             (Stdlib_Array[13],
              function(b){
               var i$0 = i;
               for(;;){
                if(length(b) <= i$0) return 0;
                var match = get(b, i$0);
                if(match){
                 var v = match[1];
                 caml_call1(f, v);
                 var i$1 = i$0 + 1 | 0;
                 i$0 = i$1;
                }
                else{var i$2 = i$0 + 1 | 0; i$0 = i$2;}
               }
              },
              t[1]);
    }
    function count_bucket(i, b, accu){
     var i$0 = i, accu$0 = accu;
     for(;;){
      if(length(b) <= i$0) return accu$0;
      var
       _y_ = check(b, i$0) ? 1 : 0,
       accu$1 = accu$0 + _y_ | 0,
       i$1 = i$0 + 1 | 0;
      i$0 = i$1;
      accu$0 = accu$1;
     }
    }
    function count(t){
     var _v_ = 0;
     return caml_call3
             (Stdlib_Array[19],
              function(_w_, _x_){return count_bucket(_v_, _w_, _x_);},
              t[1],
              0);
    }
    function add_aux(t, setter, d, h, index){
     var
      bucket$0 = caml_check_bound(t[1], index)[1 + index],
      hashes = caml_check_bound(t[2], index)[1 + index],
      sz = length(bucket$0),
      i$3 = 0;
     for(;;){
      if(sz <= i$3) break;
      if(! check(bucket$0, i$3)){
       caml_call3(setter, bucket$0, i$3, d);
       caml_check_bound(hashes, i$3)[1 + i$3] = h;
       return 0;
      }
      var i$5 = i$3 + 1 | 0;
      i$3 = i$5;
     }
     var
      newsz =
        caml_call2
         (Stdlib_Int[10],
          ((3 * sz | 0) / 2 | 0) + 3 | 0,
          Stdlib_Sys[13] - 2 | 0);
     if(newsz <= sz) caml_call1(Stdlib[2], cst_Weak_Make_hash_bucket_cann);
     var newbucket$0 = create(newsz), newhashes = caml_make_vect(newsz, 0);
     blit(bucket$0, 0, newbucket$0, 0, sz);
     caml_call5(Stdlib_Array[10], hashes, 0, newhashes, 0, sz);
     caml_call3(setter, newbucket$0, sz, d);
     caml_check_bound(newhashes, sz)[1 + sz] = h;
     caml_check_bound(t[1], index)[1 + index] = newbucket$0;
     caml_check_bound(t[2], index)[1 + index] = newhashes;
     var _r_ = sz <= t[3] ? 1 : 0, _s_ = _r_ ? t[3] < newsz ? 1 : 0 : _r_;
     if(_s_){
      t[4] = t[4] + 1 | 0;
      var i$4 = 0;
      for(;;){
       var
        _h_ = t[5],
        bucket = caml_check_bound(t[1], _h_)[1 + _h_],
        _i_ = t[5],
        hbucket = caml_check_bound(t[2], _i_)[1 + _i_],
        len = length(bucket),
        prev_len = (((len - 3 | 0) * 2 | 0) + 2 | 0) / 3 | 0,
        live = count_bucket(0, bucket, 0);
       if(live <= prev_len){
        var j$2 = length(bucket) - 1 | 0, i$0 = 0, j = j$2;
        for(;;){
         if(prev_len > j) break;
         if(check(bucket, i$0)){
          var i$1 = i$0 + 1 | 0;
          i$0 = i$1;
         }
         else if(check(bucket, j)){
          blit(bucket, j, bucket, i$0, 1);
          var _j_ = caml_check_bound(hbucket, j)[1 + j];
          caml_check_bound(hbucket, i$0)[1 + i$0] = _j_;
          var j$0 = j - 1 | 0, i$2 = i$0 + 1 | 0;
          i$0 = i$2;
          j = j$0;
         }
         else{var j$1 = j - 1 | 0; j = j$1;}
        }
        if(0 === prev_len){
         var _k_ = t[5];
         caml_check_bound(t[1], _k_)[1 + _k_] = emptybucket;
         var _l_ = t[5];
         caml_check_bound(t[2], _l_)[1 + _l_] = [0];
        }
        else{
         var newbucket = create(prev_len);
         blit(bucket, 0, newbucket, 0, prev_len);
         var _o_ = t[5];
         caml_check_bound(t[1], _o_)[1 + _o_] = newbucket;
         var
          _p_ = caml_call3(Stdlib_Array[7], hbucket, 0, prev_len),
          _q_ = t[5];
         caml_check_bound(t[2], _q_)[1 + _q_] = _p_;
        }
        var
         _m_ = t[3] < len ? 1 : 0,
         _n_ = _m_ ? prev_len <= t[3] ? 1 : 0 : _m_;
        if(_n_) t[4] = t[4] - 1 | 0;
       }
       t[5] = caml_mod(t[5] + 1 | 0, t[1].length - 1);
       var _u_ = i$4 + 1 | 0;
       if(2 === i$4) break;
       i$4 = _u_;
      }
     }
     var _t_ = ((t[1].length - 1) / 2 | 0) < t[4] ? 1 : 0;
     if(! _t_) return _t_;
     var
      oldlen = t[1].length - 1,
      newlen =
        caml_call2
         (Stdlib_Int[10], ((3 * oldlen | 0) / 2 | 0) + 3 | 0, Stdlib_Sys[13]);
     if(oldlen < newlen){
      var newt = create$0(newlen), i = 0;
      caml_call2
       (Stdlib_Array[14],
        function(j, ob){
         var oi = i;
         for(;;){
          if(length(ob) <= oi) return 0;
          if(check(ob, oi)){
           var oh = caml_check_bound(t[2], j)[1 + j];
           let oi$0 = oi;
           var
            setter =
              function(nb, ni, param){return blit(ob, oi$0, nb, ni, 1);},
            h = caml_check_bound(oh, oi)[1 + oi];
           add_aux(newt, setter, 0, h, get_index(newt, h));
           var i$0 = oi + 1 | 0;
           oi = i$0;
          }
          else{var i$1 = oi + 1 | 0; oi = i$1;}
         }
        },
        t[1]);
      t[1] = newt[1];
      t[2] = newt[2];
      t[3] = newt[3];
      t[4] = newt[4];
      t[5] = caml_mod(t[5], newt[1].length - 1);
      return 0;
     }
     t[3] = Stdlib[19];
     t[4] = 0;
     return 0;
    }
    function add(t, d){
     var h = caml_call1(H[2], d);
     return add_aux(t, set, [0, d], h, get_index(t, h));
    }
    function find_or(t, d, ifnotfound){
     var
      h = caml_call1(H[2], d),
      index = get_index(t, h),
      bucket = caml_check_bound(t[1], index)[1 + index],
      hashes = caml_check_bound(t[2], index)[1 + index],
      sz = length(bucket),
      i = 0;
     for(;;){
      if(sz <= i) return caml_call2(ifnotfound, h, index);
      if(h === caml_check_bound(hashes, i)[1 + i]){
       var match = get_copy(bucket, i);
       if(match){
        var v = match[1];
        if(caml_call2(H[1], v, d)){
         var match$0 = get(bucket, i);
         if(match$0){var v$0 = match$0[1]; return v$0;}
         var i$0 = i + 1 | 0;
         i = i$0;
         continue;
        }
       }
       var i$1 = i + 1 | 0;
       i = i$1;
      }
      else{var i$2 = i + 1 | 0; i = i$2;}
     }
    }
    function merge(t, d){
     return find_or
             (t,
              d,
              function(h, index){add_aux(t, set, [0, d], h, index); return d;});
    }
    function find(t, d){
     return find_or
             (t,
              d,
              function(h, index){
               throw caml_maybe_attach_backtrace(Stdlib[8], 1);
              });
    }
    function find_opt(t, d){
     var
      h = caml_call1(H[2], d),
      index = get_index(t, h),
      bucket = caml_check_bound(t[1], index)[1 + index],
      hashes = caml_check_bound(t[2], index)[1 + index],
      sz = length(bucket),
      i = 0;
     for(;;){
      if(sz <= i) return 0;
      if(h === caml_check_bound(hashes, i)[1 + i]){
       var match = get_copy(bucket, i);
       if(match){
        var v = match[1];
        if(caml_call2(H[1], v, d)){
         var v$0 = get(bucket, i);
         if(v$0) return v$0;
         var i$0 = i + 1 | 0;
         i = i$0;
         continue;
        }
       }
       var i$1 = i + 1 | 0;
       i = i$1;
      }
      else{var i$2 = i + 1 | 0; i = i$2;}
     }
    }
    function find_shadow(t, d, iffound, ifnotfound){
     var
      h = caml_call1(H[2], d),
      index = get_index(t, h),
      bucket = caml_check_bound(t[1], index)[1 + index],
      hashes = caml_check_bound(t[2], index)[1 + index],
      sz = length(bucket),
      i = 0;
     for(;;){
      if(sz <= i) return ifnotfound;
      if(h === caml_check_bound(hashes, i)[1 + i]){
       var match = get_copy(bucket, i);
       if(match){
        var v = match[1];
        if(caml_call2(H[1], v, d)) return caml_call2(iffound, bucket, i);
       }
       var i$0 = i + 1 | 0;
       i = i$0;
      }
      else{var i$1 = i + 1 | 0; i = i$1;}
     }
    }
    function remove(t, d){
     return find_shadow(t, d, function(w, i){return set(w, i, 0);}, 0);
    }
    function mem(t, d){
     return find_shadow(t, d, function(w, i){return 1;}, 0);
    }
    function find_all(t, d){
     var
      h = caml_call1(H[2], d),
      index = get_index(t, h),
      bucket = caml_check_bound(t[1], index)[1 + index],
      hashes = caml_check_bound(t[2], index)[1 + index],
      sz = length(bucket),
      i = 0,
      accu = 0;
     for(;;){
      if(sz <= i) return accu;
      if(h === caml_check_bound(hashes, i)[1 + i]){
       var match = get_copy(bucket, i);
       if(match){
        var v = match[1];
        if(caml_call2(H[1], v, d)){
         var match$0 = get(bucket, i);
         if(match$0){
          var v$0 = match$0[1], accu$0 = [0, v$0, accu], i$0 = i + 1 | 0;
          i = i$0;
          accu = accu$0;
          continue;
         }
         var i$1 = i + 1 | 0;
         i = i$1;
         continue;
        }
       }
       var i$2 = i + 1 | 0;
       i = i$2;
      }
      else{var i$3 = i + 1 | 0; i = i$3;}
     }
    }
    function stats(t){
     var
      len = t[1].length - 1,
      lens = caml_call2(Stdlib_Array[15], length, t[1]);
     caml_call2(Stdlib_Array[32], runtime.caml_int_compare, lens);
     var
      totlen =
        caml_call3
         (Stdlib_Array[17],
          function(_g_, _f_){return _g_ + _f_ | 0;},
          0,
          lens),
      _a_ = len - 1 | 0,
      _c_ = len / 2 | 0,
      _b_ = caml_check_bound(lens, _a_)[1 + _a_],
      _d_ = caml_check_bound(lens, _c_)[1 + _c_],
      _e_ = caml_check_bound(lens, 0)[1];
     return [0, len, count(t), totlen, _e_, _d_, _b_];
    }
    return [0,
            create$0,
            clear,
            merge,
            add,
            remove,
            find,
            find_opt,
            find_all,
            mem,
            iter,
            fold,
            count,
            stats];
   }
   var
    Stdlib_Weak =
      [0, create, length, set, get, get_copy, check, fill, blit, Make];
   runtime.caml_register_global(13, Stdlib_Weak, "Stdlib__Weak");
   return;
  }
  (globalThis));

//# 19172 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$17 = "",
    cst$18 = ">",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    cst$15 = cst$17,
    cst$16 = cst$17,
    cst$14 = ".",
    cst$11 = cst$18,
    cst$12 = "<\/",
    cst$13 = cst$17,
    cst$8 = cst$18,
    cst$9 = "<",
    cst$10 = cst$17,
    cst$7 = "\n",
    cst$3 = cst$17,
    cst$4 = cst$17,
    cst$5 = cst$17,
    cst$6 = cst$17,
    cst = cst$17,
    cst$0 = cst$17,
    cst$1 = cst$17,
    cst$2 = cst$17,
    _a_ = [0, cst$17, 0, cst$17],
    Stdlib_Queue = global_data.Stdlib__Queue,
    CamlinternalFormat = global_data.CamlinternalFormat,
    Stdlib = global_data.Stdlib,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Stack = global_data.Stdlib__Stack,
    Stdlib_Int = global_data.Stdlib__Int,
    Stdlib_Bytes = global_data.Stdlib__Bytes;
   function id(x){return x;}
   var
    zero = 0,
    unknown = -1,
    String_tag =
      [248, "Stdlib.Format.String_tag", runtime.caml_fresh_oo_id(0)];
   function pp_enqueue(state, token){
    state[13] = state[13] + token[3] | 0;
    return caml_call2(Stdlib_Queue[3], token, state[28]);
   }
   var
    pp_infinity = 1000000010,
    _b_ = [0, cst$17],
    _c_ = [1, "margin <= max_indent"],
    _d_ = [0, 0],
    _e_ = [1, "max_indent < 2"],
    cst_Format_pp_set_geometry = "Format.pp_set_geometry: ";
   function pp_output_string(state, s){
    return caml_call3(state[17], s, 0, caml_ml_string_length(s));
   }
   function pp_output_newline(state){return caml_call1(state[19], 0);}
   function format_pp_text(state, size, text){
    state[9] = state[9] - size | 0;
    pp_output_string(state, text);
    state[11] = 0;
    return;
   }
   function format_string(state, s){
    var _bG_ = s !== cst$17 ? 1 : 0;
    return _bG_ ? format_pp_text(state, caml_ml_string_length(s), s) : _bG_;
   }
   function break_new_line(state, param, width){
    var after = param[3], offset = param[2], before = param[1];
    format_string(state, before);
    pp_output_newline(state);
    state[11] = 1;
    var
     indent = (state[6] - width | 0) + offset | 0,
     real_indent = caml_call2(Stdlib_Int[10], state[8], indent);
    state[10] = real_indent;
    state[9] = state[6] - state[10] | 0;
    var n = state[10];
    caml_call1(state[21], n);
    return format_string(state, after);
   }
   function break_same_line(state, param){
    var after = param[3], width = param[2], before = param[1];
    format_string(state, before);
    state[9] = state[9] - width | 0;
    caml_call1(state[20], width);
    return format_string(state, after);
   }
   function format_pp_token(state, size$0, param){
    if(typeof param === "number")
     switch(param){
       case 0:
        var match$3 = caml_call1(Stdlib_Stack[7], state[3]);
        if(! match$3) return;
        var
         tabs = match$3[1][1],
         add_tab =
           function(n, ls){
            if(! ls) return [0, n, 0];
            var l = ls[2], x = ls[1];
            return runtime.caml_lessthan(n, x)
                    ? [0, n, ls]
                    : [0, x, add_tab(n, l)];
           };
        tabs[1] = add_tab(state[6] - state[9] | 0, tabs[1]);
        return;
       case 1:
        caml_call1(Stdlib_Stack[5], state[2]); return;
       case 2:
        caml_call1(Stdlib_Stack[5], state[3]); return;
       case 3:
        var match$4 = caml_call1(Stdlib_Stack[7], state[2]);
        if(! match$4) return pp_output_newline(state);
        var width$0 = match$4[1][2];
        return break_new_line(state, _a_, width$0);
       case 4:
        var _bE_ = state[10] !== (state[6] - state[9] | 0) ? 1 : 0;
        if(! _bE_) return _bE_;
        var match$1 = caml_call1(Stdlib_Queue[6], state[28]);
        if(! match$1) return;
        var match$2 = match$1[1], size = match$2[1], length = match$2[3];
        state[12] = state[12] - length | 0;
        state[9] = state[9] + size | 0;
        return;
       default:
        var match$5 = caml_call1(Stdlib_Stack[5], state[5]);
        if(! match$5) return;
        var tag_name = match$5[1], marker = caml_call1(state[25], tag_name);
        return pp_output_string(state, marker);
     }
    switch(param[0]){
      case 0:
       var s = param[1]; return format_pp_text(state, size$0, s);
      case 1:
       var
        breaks = param[2],
        fits = param[1],
        off = breaks[2],
        before = breaks[1],
        match$6 = caml_call1(Stdlib_Stack[7], state[2]);
       if(! match$6) return;
       var
        match$7 = match$6[1],
        width$1 = match$7[2],
        box_type$0 = match$7[1];
       switch(box_type$0){
         case 0:
          return break_same_line(state, fits);
         case 1:
          return break_new_line(state, breaks, width$1);
         case 2:
          return break_new_line(state, breaks, width$1);
         case 3:
          return state[9] < (size$0 + caml_ml_string_length(before) | 0)
                  ? break_new_line(state, breaks, width$1)
                  : break_same_line(state, fits);
         case 4:
          return state[11]
                  ? break_same_line(state, fits)
                  : state
                     [9]
                    < (size$0 + caml_ml_string_length(before) | 0)
                    ? break_new_line(state, breaks, width$1)
                    : ((state
                       [6]
                      - width$1
                      | 0)
                      + off
                      | 0)
                      < state[10]
                      ? break_new_line(state, breaks, width$1)
                      : break_same_line(state, fits);
         default: return break_same_line(state, fits);
       }
      case 2:
       var
        off$0 = param[2],
        n = param[1],
        insertion_point = state[6] - state[9] | 0,
        match$8 = caml_call1(Stdlib_Stack[7], state[3]);
       if(! match$8) return;
       var tabs$0 = match$8[1][1], match$9 = tabs$0[1];
       if(match$9){
        var first = match$9[1], param$0 = tabs$0[1];
        for(;;){
         if(param$0){
          var tail = param$0[2], head = param$0[1];
          if(insertion_point > head){param$0 = tail; continue;}
          var _bF_ = head;
         }
         else
          var _bF_ = first;
         var tab = _bF_;
         break;
        }
       }
       else
        var tab = insertion_point;
       var offset = tab - insertion_point | 0;
       return 0 <= offset
               ? break_same_line(state, [0, cst$0, offset + n | 0, cst])
               : break_new_line
                 (state, [0, cst$2, tab + off$0 | 0, cst$1], state[6]);
      case 3:
       var
        ty = param[2],
        off$1 = param[1],
        insertion_point$0 = state[6] - state[9] | 0;
       if(state[8] < insertion_point$0){
        var match = caml_call1(Stdlib_Stack[7], state[2]);
        if(match){
         var match$0 = match[1], width = match$0[2], box_type = match$0[1];
         if(state[9] < width && 3 >= box_type - 1 >>> 0)
          break_new_line(state, _a_, width);
        }
        else
         pp_output_newline(state);
       }
       var
        width$2 = state[9] - off$1 | 0,
        box_type$1 = 1 === ty ? 1 : state[9] < size$0 ? ty : 5;
       return caml_call2(Stdlib_Stack[3], [0, box_type$1, width$2], state[2]);
      case 4:
       var tbox = param[1];
       return caml_call2(Stdlib_Stack[3], tbox, state[3]);
      default:
       var
        tag_name$0 = param[1],
        marker$0 = caml_call1(state[24], tag_name$0);
       pp_output_string(state, marker$0);
       return caml_call2(Stdlib_Stack[3], tag_name$0, state[5]);
    }
   }
   function advance_left(state){
    for(;;){
     var match = caml_call1(Stdlib_Queue[9], state[28]);
     if(! match) return 0;
     var
      match$0 = match[1],
      size = match$0[1],
      length = match$0[3],
      token = match$0[2],
      pending_count = state[13] - state[12] | 0,
      _bC_ = 0 <= size ? 1 : 0,
      _bD_ = _bC_ || (state[9] <= pending_count ? 1 : 0);
     if(! _bD_) return _bD_;
     caml_call1(Stdlib_Queue[5], state[28]);
     var size$0 = 0 <= size ? size : pp_infinity;
     format_pp_token(state, size$0, token);
     state[12] = length + state[12] | 0;
    }
   }
   function enqueue_advance(state, tok){
    pp_enqueue(state, tok);
    return advance_left(state);
   }
   function enqueue_string_as(state, size, s){
    return enqueue_advance(state, [0, size, [0, s], size]);
   }
   function initialize_scan_stack(stack){
    caml_call1(Stdlib_Stack[8], stack);
    var queue_elem = [0, unknown, _b_, 0];
    return caml_call2(Stdlib_Stack[3], [0, -1, queue_elem], stack);
   }
   function set_size(state, ty){
    var match = caml_call1(Stdlib_Stack[7], state[1]);
    if(! match) return;
    var
     match$0 = match[1],
     queue_elem = match$0[2],
     left_total = match$0[1],
     size = queue_elem[1];
    if(left_total < state[12]) return initialize_scan_stack(state[1]);
    var _bB_ = queue_elem[2];
    if(typeof _bB_ !== "number")
     switch(_bB_[0]){
       case 3:
        if(1 - ty){
         var x$0 = state[13] + size | 0;
         queue_elem[1] = x$0;
         caml_call1(Stdlib_Stack[5], state[1]);
        }
        return;
       case 1:
       case 2:
        if(ty){
         var x = state[13] + size | 0;
         queue_elem[1] = x;
         caml_call1(Stdlib_Stack[5], state[1]);
        }
        return;
     }
    return;
   }
   function scan_push(state, b, token){
    pp_enqueue(state, token);
    if(b) set_size(state, 1);
    var elem = [0, state[13], token];
    return caml_call2(Stdlib_Stack[3], elem, state[1]);
   }
   function pp_open_box_gen(state, indent, br_ty){
    state[14] = state[14] + 1 | 0;
    if(state[14] < state[15]){
     var size = - state[13] | 0, elem = [0, size, [3, indent, br_ty], 0];
     return scan_push(state, 0, elem);
    }
    var _bA_ = state[14] === state[15] ? 1 : 0;
    if(! _bA_) return _bA_;
    var s = state[16], x = caml_ml_string_length(s);
    return enqueue_string_as(state, x, s);
   }
   function pp_close_box(state, param){
    var _by_ = 1 < state[14] ? 1 : 0;
    if(_by_){
     if(state[14] < state[15]){
      pp_enqueue(state, [0, zero, 1, 0]);
      set_size(state, 1);
      set_size(state, 0);
     }
     state[14] = state[14] - 1 | 0;
     var _bz_ = 0;
    }
    else
     var _bz_ = _by_;
    return _bz_;
   }
   function pp_open_stag(state, tag_name){
    if(state[22]){
     caml_call2(Stdlib_Stack[3], tag_name, state[4]);
     caml_call1(state[26], tag_name);
    }
    var _bx_ = state[23];
    if(! _bx_) return _bx_;
    var token = [5, tag_name];
    return pp_enqueue(state, [0, zero, token, 0]);
   }
   function pp_close_stag(state, param){
    if(state[23]) pp_enqueue(state, [0, zero, 5, 0]);
    var _bv_ = state[22];
    if(_bv_){
     var match = caml_call1(Stdlib_Stack[5], state[4]);
     if(match){
      var tag_name = match[1];
      return caml_call1(state[27], tag_name);
     }
     var _bw_ = 0;
    }
    else
     var _bw_ = _bv_;
    return _bw_;
   }
   function pp_open_tag(state, s){
    return pp_open_stag(state, [0, String_tag, s]);
   }
   function pp_close_tag(state, param){return pp_close_stag(state, 0);}
   function pp_set_print_tags(state, b){state[22] = b; return 0;}
   function pp_set_mark_tags(state, b){state[23] = b; return 0;}
   function pp_get_print_tags(state, param){return state[22];}
   function pp_get_mark_tags(state, param){return state[23];}
   function pp_set_tags(state, b){
    pp_set_print_tags(state, b);
    return pp_set_mark_tags(state, b);
   }
   function pp_get_formatter_stag_function(state, param){
    return [0, state[24], state[25], state[26], state[27]];
   }
   function pp_set_formatter_stag_function(state, param){
    var pct = param[4], pot = param[3], mct = param[2], mot = param[1];
    state[24] = mot;
    state[25] = mct;
    state[26] = pot;
    state[27] = pct;
    return 0;
   }
   function pp_rinit(state){
    state[12] = 1;
    state[13] = 1;
    caml_call1(Stdlib_Queue[11], state[28]);
    initialize_scan_stack(state[1]);
    caml_call1(Stdlib_Stack[8], state[2]);
    caml_call1(Stdlib_Stack[8], state[3]);
    caml_call1(Stdlib_Stack[8], state[4]);
    caml_call1(Stdlib_Stack[8], state[5]);
    state[10] = 0;
    state[14] = 0;
    state[9] = state[6];
    return pp_open_box_gen(state, 0, 3);
   }
   function pp_flush_queue(state, b){
    caml_call2
     (Stdlib_Stack[12],
      function(param){return pp_close_tag(state, 0);},
      state[4]);
    for(;;){
     if(1 >= state[14]){
      state[13] = pp_infinity;
      advance_left(state);
      if(b) pp_output_newline(state);
      return pp_rinit(state);
     }
     pp_close_box(state, 0);
    }
   }
   function pp_print_as_size(state, size, s){
    var _bu_ = state[14] < state[15] ? 1 : 0;
    return _bu_ ? enqueue_string_as(state, size, s) : _bu_;
   }
   function pp_print_as(state, isize, s){
    return pp_print_as_size(state, isize, s);
   }
   function pp_print_string(state, s){
    var isize = caml_ml_string_length(s);
    return pp_print_as_size(state, isize, s);
   }
   function pp_print_bytes(state, s){
    var
     s$0 = caml_call1(Stdlib_Bytes[6], s),
     isize = runtime.caml_ml_bytes_length(s);
    return pp_print_as_size(state, isize, s$0);
   }
   function pp_print_int(state, i){
    return pp_print_string(state, caml_call1(Stdlib_Int[12], i));
   }
   function pp_print_float(state, f){
    return pp_print_string(state, caml_call1(Stdlib[35], f));
   }
   function pp_print_bool(state, b){
    return pp_print_string(state, caml_call1(Stdlib[30], b));
   }
   function pp_print_char(state, c){
    var s = caml_call2(Stdlib_String[1], 1, c);
    return pp_print_as_size(state, 1, s);
   }
   function pp_open_hbox(state, param){return pp_open_box_gen(state, 0, 0);}
   function pp_open_vbox(state, indent){
    return pp_open_box_gen(state, indent, 1);
   }
   function pp_open_hvbox(state, indent){
    return pp_open_box_gen(state, indent, 2);
   }
   function pp_open_hovbox(state, indent){
    return pp_open_box_gen(state, indent, 3);
   }
   function pp_open_box(state, indent){
    return pp_open_box_gen(state, indent, 4);
   }
   function pp_print_newline(state, param){
    pp_flush_queue(state, 1);
    return caml_call1(state[18], 0);
   }
   function pp_print_flush(state, param){
    pp_flush_queue(state, 0);
    return caml_call1(state[18], 0);
   }
   function pp_force_newline(state, param){
    var _bt_ = state[14] < state[15] ? 1 : 0;
    return _bt_ ? enqueue_advance(state, [0, zero, 3, 0]) : _bt_;
   }
   function pp_print_if_newline(state, param){
    var _bs_ = state[14] < state[15] ? 1 : 0;
    return _bs_ ? enqueue_advance(state, [0, zero, 4, 0]) : _bs_;
   }
   function pp_print_custom_break(state, fits, breaks){
    var
     after = fits[3],
     width = fits[2],
     before = fits[1],
     _br_ = state[14] < state[15] ? 1 : 0;
    if(! _br_) return _br_;
    var
     size = - state[13] | 0,
     token = [1, fits, breaks],
     length =
       (caml_ml_string_length(before) + width | 0)
       + caml_ml_string_length(after)
       | 0,
     elem = [0, size, token, length];
    return scan_push(state, 1, elem);
   }
   function pp_print_break(state, width, offset){
    return pp_print_custom_break
            (state, [0, cst$6, width, cst$5], [0, cst$4, offset, cst$3]);
   }
   function pp_print_space(state, param){return pp_print_break(state, 1, 0);}
   function pp_print_cut(state, param){return pp_print_break(state, 0, 0);}
   function pp_open_tbox(state, param){
    state[14] = state[14] + 1 | 0;
    var _bq_ = state[14] < state[15] ? 1 : 0;
    if(! _bq_) return _bq_;
    var elem = [0, zero, [4, [0, [0, 0]]], 0];
    return enqueue_advance(state, elem);
   }
   function pp_close_tbox(state, param){
    var _bn_ = 1 < state[14] ? 1 : 0;
    if(_bn_){
     var _bo_ = state[14] < state[15] ? 1 : 0;
     if(_bo_){
      var elem = [0, zero, 2, 0];
      enqueue_advance(state, elem);
      state[14] = state[14] - 1 | 0;
      var _bp_ = 0;
     }
     else
      var _bp_ = _bo_;
    }
    else
     var _bp_ = _bn_;
    return _bp_;
   }
   function pp_print_tbreak(state, width, offset){
    var _bm_ = state[14] < state[15] ? 1 : 0;
    if(! _bm_) return _bm_;
    var size = - state[13] | 0, elem = [0, size, [2, width, offset], width];
    return scan_push(state, 1, elem);
   }
   function pp_print_tab(state, param){return pp_print_tbreak(state, 0, 0);}
   function pp_set_tab(state, param){
    var _bl_ = state[14] < state[15] ? 1 : 0;
    if(! _bl_) return _bl_;
    var elem = [0, zero, 0, 0];
    return enqueue_advance(state, elem);
   }
   function pp_set_max_boxes(state, n){
    var _bj_ = 1 < n ? 1 : 0, _bk_ = _bj_ ? (state[15] = n, 0) : _bj_;
    return _bk_;
   }
   function pp_get_max_boxes(state, param){return state[15];}
   function pp_over_max_boxes(state, param){return state[14] === state[15] ? 1 : 0;
   }
   function pp_set_ellipsis_text(state, s){state[16] = s; return 0;}
   function pp_get_ellipsis_text(state, param){return state[16];}
   function pp_limit(n){return n < 1000000010 ? n : 1000000009;}
   function pp_set_max_indent(state, n$0){
    var _bi_ = 1 < n$0 ? 1 : 0;
    if(! _bi_) return _bi_;
    var n$1 = state[6] - n$0 | 0, _bh_ = 1 <= n$1 ? 1 : 0;
    if(! _bh_) return _bh_;
    var n = pp_limit(n$1);
    state[7] = n;
    state[8] = state[6] - state[7] | 0;
    return pp_rinit(state);
   }
   function pp_get_max_indent(state, param){return state[8];}
   function pp_set_margin(state, n){
    var _bf_ = 1 <= n ? 1 : 0;
    if(! _bf_) return _bf_;
    var n$0 = pp_limit(n);
    state[6] = n$0;
    if(state[8] <= state[6])
     var new_max_indent = state[8];
    else
     var
      _bg_ =
        caml_call2(Stdlib_Int[11], state[6] - state[7] | 0, state[6] / 2 | 0),
      new_max_indent = caml_call2(Stdlib_Int[11], _bg_, 1);
    return pp_set_max_indent(state, new_max_indent);
   }
   function validate_geometry(param){
    var margin = param[2], max_indent = param[1];
    return 2 <= max_indent ? margin <= max_indent ? _c_ : _d_ : _e_;
   }
   function check_geometry(geometry){
    return 0 === validate_geometry(geometry)[0] ? 1 : 0;
   }
   function pp_get_margin(state, param){return state[6];}
   function pp_set_full_geometry(state, param){
    var margin = param[2], max_indent = param[1];
    pp_set_margin(state, margin);
    pp_set_max_indent(state, max_indent);
    return 0;
   }
   function pp_set_geometry(state, max_indent, margin){
    var
     geometry = [0, max_indent, margin],
     match = validate_geometry(geometry);
    if(0 === match[0]) return pp_set_full_geometry(state, geometry);
    var
     msg = match[1],
     _be_ = caml_call2(Stdlib[28], cst_Format_pp_set_geometry, msg);
    throw caml_maybe_attach_backtrace([0, Stdlib[6], _be_], 1);
   }
   function pp_safe_set_geometry(state, max_indent, margin){
    var geometry = [0, max_indent, margin];
    return 0 === validate_geometry(geometry)[0]
            ? pp_set_full_geometry(state, geometry)
            : 0;
   }
   function pp_get_geometry(state, param){return [0, state[8], state[6]];}
   function pp_update_geometry(state, update){
    var geometry = pp_get_geometry(state, 0);
    return pp_set_full_geometry(state, caml_call1(update, geometry));
   }
   function pp_set_formatter_out_functions(state, param){
    var j = param[5], i = param[4], h = param[3], g = param[2], f = param[1];
    state[17] = f;
    state[18] = g;
    state[19] = h;
    state[20] = i;
    state[21] = j;
    return 0;
   }
   function pp_get_formatter_out_functions(state, param){
    return [0, state[17], state[18], state[19], state[20], state[21]];
   }
   function pp_set_formatter_output_functi(state, f, g){state[17] = f; state[18] = g; return 0;
   }
   function pp_get_formatter_output_functi(state, param){return [0, state[17], state[18]];
   }
   function display_newline(state, param){
    return caml_call3(state[17], cst$7, 0, 1);
   }
   var blank_line = caml_call2(Stdlib_String[1], 80, 32), _f_ = [3, 0, 3];
   function display_blanks(state, n){
    var n$0 = n;
    for(;;){
     var _bd_ = 0 < n$0 ? 1 : 0;
     if(! _bd_) return _bd_;
     if(80 >= n$0) return caml_call3(state[17], blank_line, 0, n$0);
     caml_call3(state[17], blank_line, 0, 80);
     var n$1 = n$0 - 80 | 0;
     n$0 = n$1;
    }
   }
   function pp_set_formatter_out_channel(state, oc){
    state[17] = caml_call1(Stdlib[69], oc);
    state[18] = function(param){return caml_call1(Stdlib[63], oc);};
    state[19] = function(_bc_){return display_newline(state, _bc_);};
    state[20] = function(_bb_){return display_blanks(state, _bb_);};
    state[21] = function(_ba_){return display_blanks(state, _ba_);};
    return 0;
   }
   function default_pp_mark_open_tag(param){
    if(param[1] !== String_tag) return cst$10;
    var s = param[2], _a$_ = caml_call2(Stdlib[28], s, cst$8);
    return caml_call2(Stdlib[28], cst$9, _a$_);
   }
   function default_pp_mark_close_tag(param){
    if(param[1] !== String_tag) return cst$13;
    var s = param[2], _a__ = caml_call2(Stdlib[28], s, cst$11);
    return caml_call2(Stdlib[28], cst$12, _a__);
   }
   function default_pp_print_open_tag(_a9_){return 0;}
   function default_pp_print_close_tag(_a8_){return 0;}
   function pp_make_formatter(f, g, h, i, j){
    var
     pp_queue = caml_call1(Stdlib_Queue[2], 0),
     sys_tok = [0, unknown, _f_, 0];
    caml_call2(Stdlib_Queue[3], sys_tok, pp_queue);
    var scan_stack = caml_call1(Stdlib_Stack[2], 0);
    initialize_scan_stack(scan_stack);
    caml_call2(Stdlib_Stack[3], [0, 1, sys_tok], scan_stack);
    var
     pp_margin = 78,
     _a4_ = Stdlib[19],
     _a5_ = caml_call1(Stdlib_Stack[2], 0),
     _a6_ = caml_call1(Stdlib_Stack[2], 0),
     _a7_ = caml_call1(Stdlib_Stack[2], 0);
    return [0,
            scan_stack,
            caml_call1(Stdlib_Stack[2], 0),
            _a7_,
            _a6_,
            _a5_,
            pp_margin,
            10,
            68,
            pp_margin,
            0,
            1,
            1,
            1,
            1,
            _a4_,
            cst$14,
            f,
            g,
            h,
            i,
            j,
            0,
            0,
            default_pp_mark_open_tag,
            default_pp_mark_close_tag,
            default_pp_print_open_tag,
            default_pp_print_close_tag,
            pp_queue];
   }
   function formatter_of_out_functions(out_funs){
    return pp_make_formatter
            (out_funs[1], out_funs[2], out_funs[3], out_funs[4], out_funs[5]);
   }
   function make_formatter(output, flush){
    var
     ppf =
       pp_make_formatter
        (output,
         flush,
         function(_a3_){return 0;},
         function(_a2_){return 0;},
         function(_a1_){return 0;});
    ppf[19] = function(_a0_){return display_newline(ppf, _a0_);};
    ppf[20] = function(_aZ_){return display_blanks(ppf, _aZ_);};
    ppf[21] = function(_aY_){return display_blanks(ppf, _aY_);};
    return ppf;
   }
   function formatter_of_out_channel(oc){
    return make_formatter
            (caml_call1(Stdlib[69], oc),
             function(param){return caml_call1(Stdlib[63], oc);});
   }
   function formatter_of_buffer(b){
    return make_formatter
            (caml_call1(Stdlib_Buffer[18], b), function(_aX_){return 0;});
   }
   var pp_buffer_size = 512;
   function pp_make_buffer(param){
    return caml_call1(Stdlib_Buffer[1], pp_buffer_size);
   }
   var
    stdbuf = pp_make_buffer(0),
    std_formatter = formatter_of_out_channel(Stdlib[39]),
    err_formatter = formatter_of_out_channel(Stdlib[40]),
    str_formatter = formatter_of_buffer(stdbuf);
   function flush_buffer_formatter(buf, ppf){
    pp_flush_queue(ppf, 0);
    var s = caml_call1(Stdlib_Buffer[2], buf);
    caml_call1(Stdlib_Buffer[9], buf);
    return s;
   }
   function flush_str_formatter(param){
    return flush_buffer_formatter(stdbuf, str_formatter);
   }
   function make_symbolic_output_buffer(param){return [0, 0];}
   function clear_symbolic_output_buffer(sob){sob[1] = 0; return 0;}
   function get_symbolic_output_buffer(sob){
    return caml_call1(Stdlib_List[9], sob[1]);
   }
   function flush_symbolic_output_buffer(sob){
    var items = get_symbolic_output_buffer(sob);
    clear_symbolic_output_buffer(sob);
    return items;
   }
   function add_symbolic_output_item(sob, item){sob[1] = [0, item, sob[1]]; return 0;
   }
   function formatter_of_symbolic_output_b(sob){
    function f(s, i, n){
     return add_symbolic_output_item
             (sob, [0, caml_call3(Stdlib_String[15], s, i, n)]);
    }
    function g(_aW_){return add_symbolic_output_item(sob, 0);}
    function h(_aV_){return add_symbolic_output_item(sob, 1);}
    function i(n){return add_symbolic_output_item(sob, [1, n]);}
    function j(n){return add_symbolic_output_item(sob, [2, n]);}
    return pp_make_formatter(f, g, h, i, j);
   }
   function open_hbox(_aU_){return pp_open_hbox(std_formatter, _aU_);}
   function open_vbox(_aT_){return pp_open_vbox(std_formatter, _aT_);}
   function open_hvbox(_aS_){return pp_open_hvbox(std_formatter, _aS_);}
   function open_hovbox(_aR_){return pp_open_hovbox(std_formatter, _aR_);}
   function open_box(_aQ_){return pp_open_box(std_formatter, _aQ_);}
   function close_box(_aP_){return pp_close_box(std_formatter, _aP_);}
   function open_tag(_aO_){return pp_open_tag(std_formatter, _aO_);}
   function close_tag(_aN_){return pp_close_tag(std_formatter, _aN_);}
   function open_stag(_aM_){return pp_open_stag(std_formatter, _aM_);}
   function close_stag(_aL_){return pp_close_stag(std_formatter, _aL_);}
   function print_as(isize, s){
    return pp_print_as_size(std_formatter, isize, s);
   }
   function print_string(_aK_){return pp_print_string(std_formatter, _aK_);}
   function print_bytes(_aJ_){return pp_print_bytes(std_formatter, _aJ_);}
   function print_int(_aI_){return pp_print_int(std_formatter, _aI_);}
   function print_float(_aH_){return pp_print_float(std_formatter, _aH_);}
   function print_char(_aG_){return pp_print_char(std_formatter, _aG_);}
   function print_bool(_aF_){return pp_print_bool(std_formatter, _aF_);}
   function print_break(_aD_, _aE_){
    return pp_print_break(std_formatter, _aD_, _aE_);
   }
   function print_cut(_aC_){return pp_print_cut(std_formatter, _aC_);}
   function print_space(_aB_){return pp_print_space(std_formatter, _aB_);}
   function force_newline(_aA_){return pp_force_newline(std_formatter, _aA_);}
   function print_flush(_az_){return pp_print_flush(std_formatter, _az_);}
   function print_newline(_ay_){return pp_print_newline(std_formatter, _ay_);}
   function print_if_newline(_ax_){
    return pp_print_if_newline(std_formatter, _ax_);
   }
   function open_tbox(_aw_){return pp_open_tbox(std_formatter, _aw_);}
   function close_tbox(_av_){return pp_close_tbox(std_formatter, _av_);}
   function print_tbreak(_at_, _au_){
    return pp_print_tbreak(std_formatter, _at_, _au_);
   }
   function set_tab(_as_){return pp_set_tab(std_formatter, _as_);}
   function print_tab(_ar_){return pp_print_tab(std_formatter, _ar_);}
   function set_margin(_aq_){return pp_set_margin(std_formatter, _aq_);}
   function get_margin(_ap_){return std_formatter[6];}
   function set_max_indent(_ao_){
    return pp_set_max_indent(std_formatter, _ao_);
   }
   function get_max_indent(_an_){return std_formatter[8];}
   function set_geometry(_al_, _am_){
    return pp_set_geometry(std_formatter, _al_, _am_);
   }
   function safe_set_geometry(_aj_, _ak_){
    return pp_safe_set_geometry(std_formatter, _aj_, _ak_);
   }
   function get_geometry(_ai_){return pp_get_geometry(std_formatter, _ai_);}
   function update_geometry(_ah_){
    return pp_update_geometry(std_formatter, _ah_);
   }
   function set_max_boxes(_ag_){return pp_set_max_boxes(std_formatter, _ag_);}
   function get_max_boxes(_af_){return std_formatter[15];}
   function over_max_boxes(_ae_){
    return pp_over_max_boxes(std_formatter, _ae_);
   }
   function set_ellipsis_text(_ad_){
    return pp_set_ellipsis_text(std_formatter, _ad_);
   }
   function get_ellipsis_text(_ac_){return std_formatter[16];}
   function set_formatter_out_channel(_ab_){
    return pp_set_formatter_out_channel(std_formatter, _ab_);
   }
   function set_formatter_out_functions(_aa_){
    return pp_set_formatter_out_functions(std_formatter, _aa_);
   }
   function get_formatter_out_functions(_$_){
    return pp_get_formatter_out_functions(std_formatter, _$_);
   }
   function set_formatter_output_functions(_Z_, ___){
    return pp_set_formatter_output_functi(std_formatter, _Z_, ___);
   }
   function get_formatter_output_functions(_Y_){
    return pp_get_formatter_output_functi(std_formatter, _Y_);
   }
   function set_formatter_stag_functions(_X_){
    return pp_set_formatter_stag_function(std_formatter, _X_);
   }
   function get_formatter_stag_functions(_W_){
    return pp_get_formatter_stag_function(std_formatter, _W_);
   }
   function set_print_tags(_V_){return pp_set_print_tags(std_formatter, _V_);}
   function get_print_tags(_U_){return std_formatter[22];}
   function set_mark_tags(_T_){return pp_set_mark_tags(std_formatter, _T_);}
   function get_mark_tags(_S_){return std_formatter[23];}
   function set_tags(_R_){return pp_set_tags(std_formatter, _R_);}
   function pp_print_list(opt, pp_v, ppf, param){
    var opt$0 = opt, param$0 = param;
    for(;;){
     if(opt$0)
      var sth = opt$0[1], pp_sep = sth;
     else
      var pp_sep = pp_print_cut;
     if(! param$0) return 0;
     var v = param$0[1];
     if(! param$0[2]) return caml_call2(pp_v, ppf, v);
     var vs = param$0[2];
     caml_call2(pp_v, ppf, v);
     caml_call2(pp_sep, ppf, 0);
     var opt$1 = [0, pp_sep];
     opt$0 = opt$1;
     param$0 = vs;
    }
   }
   function pp_print_seq(opt, pp_v, ppf, seq$1){
    if(opt) var sth = opt[1], pp_sep = sth; else var pp_sep = pp_print_cut;
    var match$0 = caml_call1(seq$1, 0);
    if(! match$0) return 0;
    var seq$2 = match$0[2], v$0 = match$0[1];
    caml_call2(pp_v, ppf, v$0);
    var seq = seq$2;
    for(;;){
     var match = caml_call1(seq, 0);
     if(! match) return 0;
     var seq$0 = match[2], v = match[1];
     caml_call2(pp_sep, ppf, 0);
     caml_call2(pp_v, ppf, v);
     seq = seq$0;
    }
   }
   function pp_print_text(ppf, s){
    var len = caml_ml_string_length(s), left = [0, 0], right = [0, 0];
    function flush(param){
     pp_print_string
      (ppf, caml_call3(Stdlib_String[15], s, left[1], right[1] - left[1] | 0));
     right[1]++;
     left[1] = right[1];
     return 0;
    }
    for(;;){
     if(right[1] === len){
      var _Q_ = left[1] !== len ? 1 : 0;
      return _Q_ ? flush(0) : _Q_;
     }
     var match = runtime.caml_string_get(s, right[1]);
     if(10 === match){
      flush(0);
      pp_force_newline(ppf, 0);
     }
     else if(32 === match){flush(0); pp_print_space(ppf, 0);} else right[1]++;
    }
   }
   function pp_print_option(opt, pp_v, ppf, param){
    if(opt)
     var sth = opt[1], none = sth;
    else
     var none = function(param, _P_){return 0;};
    if(! param) return caml_call2(none, ppf, 0);
    var v = param[1];
    return caml_call2(pp_v, ppf, v);
   }
   function pp_print_result(ok, error, ppf, param){
    if(0 === param[0]){var v = param[1]; return caml_call2(ok, ppf, v);}
    var e = param[1];
    return caml_call2(error, ppf, e);
   }
   function pp_print_either(left, right, ppf, param){
    if(0 === param[0]){var l = param[1]; return caml_call2(left, ppf, l);}
    var r = param[1];
    return caml_call2(right, ppf, r);
   }
   function compute_tag(output, tag_acc){
    var
     buf = caml_call1(Stdlib_Buffer[1], 16),
     ppf = formatter_of_buffer(buf);
    caml_call2(output, ppf, tag_acc);
    pp_print_flush(ppf, 0);
    var len = caml_call1(Stdlib_Buffer[7], buf);
    return 2 <= len
            ? caml_call3(Stdlib_Buffer[4], buf, 1, len - 2 | 0)
            : caml_call1(Stdlib_Buffer[2], buf);
   }
   function output_formatting_lit(ppf, fmting_lit){
    if(typeof fmting_lit === "number")
     switch(fmting_lit){
       case 0:
        return pp_close_box(ppf, 0);
       case 1:
        return pp_close_tag(ppf, 0);
       case 2:
        return pp_print_flush(ppf, 0);
       case 3:
        return pp_force_newline(ppf, 0);
       case 4:
        return pp_print_newline(ppf, 0);
       case 5:
        return pp_print_char(ppf, 64);
       default: return pp_print_char(ppf, 37);
     }
    switch(fmting_lit[0]){
      case 0:
       var offset = fmting_lit[3], width = fmting_lit[2];
       return pp_print_break(ppf, width, offset);
      case 1:
       return 0;
      default:
       var c = fmting_lit[1];
       pp_print_char(ppf, 64);
       return pp_print_char(ppf, c);
    }
   }
   function output_acc(ppf, acc){
    if(typeof acc === "number") return 0;
    a:
    {
     b:
     {
      c:
      {
       switch(acc[0]){
         case 0:
          var f = acc[2], p = acc[1];
          output_acc(ppf, p);
          return output_formatting_lit(ppf, f);
         case 1:
          var match = acc[2], p$0 = acc[1];
          if(0 === match[0]){
           var acc$0 = match[1];
           output_acc(ppf, p$0);
           return pp_open_stag
                   (ppf, [0, String_tag, compute_tag(output_acc, acc$0)]);
          }
          var acc$1 = match[1];
          output_acc(ppf, p$0);
          var
           _G_ = compute_tag(output_acc, acc$1),
           match$0 = caml_call1(CamlinternalFormat[20], _G_),
           bty = match$0[2],
           indent = match$0[1];
          return pp_open_box_gen(ppf, indent, bty);
         case 2:
          var _H_ = acc[1];
          if(typeof _H_ !== "number" && 0 === _H_[0]){
           var _I_ = _H_[2];
           if(typeof _I_ !== "number" && 1 === _I_[0]){
            var s$0 = acc[2], size = _I_[2], p$2 = _H_[1];
            break b;
           }
          }
          var s = acc[2], p$1 = _H_;
          break a;
         case 3:
          var _J_ = acc[1];
          if(typeof _J_ !== "number" && 0 === _J_[0]){
           var _K_ = _J_[2];
           if(typeof _K_ !== "number" && 1 === _K_[0]){
            var c$0 = acc[2], size$0 = _K_[2], p$4 = _J_[1];
            break;
           }
          }
          var c = acc[2], p$3 = _J_;
          break c;
         case 4:
          var _L_ = acc[1];
          if(typeof _L_ !== "number" && 0 === _L_[0]){
           var _M_ = _L_[2];
           if(typeof _M_ !== "number" && 1 === _M_[0]){
            var s$0 = acc[2], size = _M_[2], p$2 = _L_[1];
            break b;
           }
          }
          var s = acc[2], p$1 = _L_;
          break a;
         case 5:
          var _N_ = acc[1];
          if(typeof _N_ !== "number" && 0 === _N_[0]){
           var _O_ = _N_[2];
           if(typeof _O_ !== "number" && 1 === _O_[0]){
            var c$0 = acc[2], size$0 = _O_[2], p$4 = _N_[1];
            break;
           }
          }
          var c = acc[2], p$3 = _N_;
          break c;
         case 6:
          var f$0 = acc[2], p$5 = acc[1];
          output_acc(ppf, p$5);
          return caml_call1(f$0, ppf);
         case 7:
          var p$6 = acc[1];
          output_acc(ppf, p$6);
          return pp_print_flush(ppf, 0);
         default:
          var msg = acc[2], p$7 = acc[1];
          output_acc(ppf, p$7);
          return caml_call1(Stdlib[1], msg);
       }
       output_acc(ppf, p$4);
       return pp_print_as_size
               (ppf, size$0, caml_call2(Stdlib_String[1], 1, c$0));
      }
      output_acc(ppf, p$3);
      return pp_print_char(ppf, c);
     }
     output_acc(ppf, p$2);
     return pp_print_as_size(ppf, size, s$0);
    }
    output_acc(ppf, p$1);
    return pp_print_string(ppf, s);
   }
   function strput_acc(ppf, acc){
    if(typeof acc === "number") return 0;
    a:
    {
     b:
     {
      c:
      {
       switch(acc[0]){
         case 0:
          var f = acc[2], p = acc[1];
          strput_acc(ppf, p);
          return output_formatting_lit(ppf, f);
         case 1:
          var match = acc[2], p$0 = acc[1];
          if(0 === match[0]){
           var acc$0 = match[1];
           strput_acc(ppf, p$0);
           return pp_open_stag
                   (ppf, [0, String_tag, compute_tag(strput_acc, acc$0)]);
          }
          var acc$1 = match[1];
          strput_acc(ppf, p$0);
          var
           _x_ = compute_tag(strput_acc, acc$1),
           match$0 = caml_call1(CamlinternalFormat[20], _x_),
           bty = match$0[2],
           indent = match$0[1];
          return pp_open_box_gen(ppf, indent, bty);
         case 2:
          var _y_ = acc[1];
          if(typeof _y_ !== "number" && 0 === _y_[0]){
           var _z_ = _y_[2];
           if(typeof _z_ !== "number" && 1 === _z_[0]){
            var s$0 = acc[2], size = _z_[2], p$2 = _y_[1];
            break b;
           }
          }
          var s = acc[2], p$1 = _y_;
          break a;
         case 3:
          var _A_ = acc[1];
          if(typeof _A_ !== "number" && 0 === _A_[0]){
           var _B_ = _A_[2];
           if(typeof _B_ !== "number" && 1 === _B_[0]){
            var c$0 = acc[2], size$0 = _B_[2], p$4 = _A_[1];
            break;
           }
          }
          var c = acc[2], p$3 = _A_;
          break c;
         case 4:
          var _C_ = acc[1];
          if(typeof _C_ !== "number" && 0 === _C_[0]){
           var _D_ = _C_[2];
           if(typeof _D_ !== "number" && 1 === _D_[0]){
            var s$0 = acc[2], size = _D_[2], p$2 = _C_[1];
            break b;
           }
          }
          var s = acc[2], p$1 = _C_;
          break a;
         case 5:
          var _E_ = acc[1];
          if(typeof _E_ !== "number" && 0 === _E_[0]){
           var _F_ = _E_[2];
           if(typeof _F_ !== "number" && 1 === _F_[0]){
            var c$0 = acc[2], size$0 = _F_[2], p$4 = _E_[1];
            break;
           }
          }
          var c = acc[2], p$3 = _E_;
          break c;
         case 6:
          var p$5 = acc[1];
          if(typeof p$5 !== "number" && 0 === p$5[0]){
           var match$1 = p$5[2];
           if(typeof match$1 !== "number" && 1 === match$1[0]){
            var f$1 = acc[2], size$1 = match$1[2], p$6 = p$5[1];
            strput_acc(ppf, p$6);
            return pp_print_as_size(ppf, size$1, caml_call1(f$1, 0));
           }
          }
          var f$0 = acc[2];
          strput_acc(ppf, p$5);
          return pp_print_string(ppf, caml_call1(f$0, 0));
         case 7:
          var p$7 = acc[1];
          strput_acc(ppf, p$7);
          return pp_print_flush(ppf, 0);
         default:
          var msg = acc[2], p$8 = acc[1];
          strput_acc(ppf, p$8);
          return caml_call1(Stdlib[1], msg);
       }
       strput_acc(ppf, p$4);
       return pp_print_as_size
               (ppf, size$0, caml_call2(Stdlib_String[1], 1, c$0));
      }
      strput_acc(ppf, p$3);
      return pp_print_char(ppf, c);
     }
     strput_acc(ppf, p$2);
     return pp_print_as_size(ppf, size, s$0);
    }
    strput_acc(ppf, p$1);
    return pp_print_string(ppf, s);
   }
   function kfprintf(k, ppf, param){
    var fmt = param[1];
    return caml_call3
            (CamlinternalFormat[7],
             function(acc){output_acc(ppf, acc); return caml_call1(k, ppf);},
             0,
             fmt);
   }
   function ikfprintf(k, ppf, param){
    var fmt = param[1];
    return caml_call3(CamlinternalFormat[8], k, ppf, fmt);
   }
   function ifprintf(ppf, param){
    var fmt = param[1];
    return caml_call3(CamlinternalFormat[8], function(_w_){return 0;}, 0, fmt);
   }
   function fprintf(ppf){
    function _t_(_v_){return 0;}
    return function(_u_){return kfprintf(_t_, ppf, _u_);};
   }
   function printf(fmt){return fprintf(std_formatter)(fmt);}
   function eprintf(fmt){return fprintf(err_formatter)(fmt);}
   function kdprintf(k, param){
    var fmt = param[1];
    return caml_call3
            (CamlinternalFormat[7],
             function(acc){
              return caml_call1
                      (k, function(ppf){return output_acc(ppf, acc);});
             },
             0,
             fmt);
   }
   function dprintf(fmt){return kdprintf(function(i){return i;}, fmt);}
   function ksprintf(k, param){
    var fmt = param[1], b = pp_make_buffer(0), ppf = formatter_of_buffer(b);
    function k$0(acc){
     strput_acc(ppf, acc);
     return caml_call1(k, flush_buffer_formatter(b, ppf));
    }
    return caml_call3(CamlinternalFormat[7], k$0, 0, fmt);
   }
   function sprintf(fmt){return ksprintf(id, fmt);}
   function kasprintf(k, param){
    var fmt = param[1], b = pp_make_buffer(0), ppf = formatter_of_buffer(b);
    function k$0(acc){
     output_acc(ppf, acc);
     return caml_call1(k, flush_buffer_formatter(b, ppf));
    }
    return caml_call3(CamlinternalFormat[7], k$0, 0, fmt);
   }
   function asprintf(fmt){return kasprintf(id, fmt);}
   function flush_standard_formatters(param){
    pp_print_flush(std_formatter, 0);
    return pp_print_flush(err_formatter, 0);
   }
   caml_call1(Stdlib[100], flush_standard_formatters);
   function pp_set_all_formatter_output_fu(state, f, g, h, i){
    pp_set_formatter_output_functi(state, f, g);
    state[19] = h;
    state[20] = i;
    return 0;
   }
   function pp_get_all_formatter_output_fu(state, param){
    return [0, state[17], state[18], state[19], state[20]];
   }
   function set_all_formatter_output_funct(_p_, _q_, _r_, _s_){
    return pp_set_all_formatter_output_fu(std_formatter, _p_, _q_, _r_, _s_);
   }
   function get_all_formatter_output_funct(_o_){
    return pp_get_all_formatter_output_fu(std_formatter, _o_);
   }
   function bprintf(b, param){
    var fmt = param[1], ppf = formatter_of_buffer(b);
    function k(acc){output_acc(ppf, acc); return pp_flush_queue(ppf, 0);}
    return caml_call3(CamlinternalFormat[7], k, 0, fmt);
   }
   function pp_set_formatter_tag_functions(state, param){
    var pct = param[4], pot = param[3], mct = param[2], mot = param[1];
    function stringify(f, e, param){
     if(param[1] !== String_tag) return e;
     var s = param[2];
     return caml_call1(f, s);
    }
    state[24] = function(_n_){return stringify(mot, cst$15, _n_);};
    state[25] = function(_m_){return stringify(mct, cst$16, _m_);};
    var _i_ = 0;
    state[26] = function(_l_){return stringify(pot, _i_, _l_);};
    var _j_ = 0;
    state[27] = function(_k_){return stringify(pct, _j_, _k_);};
    return 0;
   }
   function pp_get_formatter_tag_functions(fmt, param){
    var funs = pp_get_formatter_stag_function(fmt, 0);
    function mark_open_tag(s){return caml_call1(funs[1], [0, String_tag, s]);}
    function mark_close_tag(s){
     return caml_call1(funs[2], [0, String_tag, s]);
    }
    function print_open_tag(s){
     return caml_call1(funs[3], [0, String_tag, s]);
    }
    function print_close_tag(s){
     return caml_call1(funs[4], [0, String_tag, s]);
    }
    return [0, mark_open_tag, mark_close_tag, print_open_tag, print_close_tag];
   }
   function set_formatter_tag_functions(_h_){
    return pp_set_formatter_tag_functions(std_formatter, _h_);
   }
   function get_formatter_tag_functions(_g_){
    return pp_get_formatter_tag_functions(std_formatter, _g_);
   }
   var
    Stdlib_Format =
      [0,
       pp_open_box,
       open_box,
       pp_close_box,
       close_box,
       pp_open_hbox,
       open_hbox,
       pp_open_vbox,
       open_vbox,
       pp_open_hvbox,
       open_hvbox,
       pp_open_hovbox,
       open_hovbox,
       pp_print_string,
       print_string,
       pp_print_bytes,
       print_bytes,
       pp_print_as,
       print_as,
       pp_print_int,
       print_int,
       pp_print_float,
       print_float,
       pp_print_char,
       print_char,
       pp_print_bool,
       print_bool,
       pp_print_space,
       print_space,
       pp_print_cut,
       print_cut,
       pp_print_break,
       print_break,
       pp_print_custom_break,
       pp_force_newline,
       force_newline,
       pp_print_if_newline,
       print_if_newline,
       pp_print_flush,
       print_flush,
       pp_print_newline,
       print_newline,
       pp_set_margin,
       set_margin,
       pp_get_margin,
       get_margin,
       pp_set_max_indent,
       set_max_indent,
       pp_get_max_indent,
       get_max_indent,
       check_geometry,
       pp_set_geometry,
       set_geometry,
       pp_safe_set_geometry,
       safe_set_geometry,
       pp_update_geometry,
       update_geometry,
       pp_get_geometry,
       get_geometry,
       pp_set_max_boxes,
       set_max_boxes,
       pp_get_max_boxes,
       get_max_boxes,
       pp_over_max_boxes,
       over_max_boxes,
       pp_open_tbox,
       open_tbox,
       pp_close_tbox,
       close_tbox,
       pp_set_tab,
       set_tab,
       pp_print_tab,
       print_tab,
       pp_print_tbreak,
       print_tbreak,
       pp_set_ellipsis_text,
       set_ellipsis_text,
       pp_get_ellipsis_text,
       get_ellipsis_text,
       String_tag,
       pp_open_stag,
       open_stag,
       pp_close_stag,
       close_stag,
       pp_set_tags,
       set_tags,
       pp_set_print_tags,
       set_print_tags,
       pp_set_mark_tags,
       set_mark_tags,
       pp_get_print_tags,
       get_print_tags,
       pp_get_mark_tags,
       get_mark_tags,
       pp_set_formatter_out_channel,
       set_formatter_out_channel,
       pp_set_formatter_output_functi,
       set_formatter_output_functions,
       pp_get_formatter_output_functi,
       get_formatter_output_functions,
       pp_set_formatter_out_functions,
       set_formatter_out_functions,
       pp_get_formatter_out_functions,
       get_formatter_out_functions,
       pp_set_formatter_stag_function,
       set_formatter_stag_functions,
       pp_get_formatter_stag_function,
       get_formatter_stag_functions,
       formatter_of_out_channel,
       std_formatter,
       err_formatter,
       formatter_of_buffer,
       stdbuf,
       str_formatter,
       flush_str_formatter,
       make_formatter,
       formatter_of_out_functions,
       make_symbolic_output_buffer,
       clear_symbolic_output_buffer,
       get_symbolic_output_buffer,
       flush_symbolic_output_buffer,
       add_symbolic_output_item,
       formatter_of_symbolic_output_b,
       pp_print_list,
       pp_print_seq,
       pp_print_text,
       pp_print_option,
       pp_print_result,
       pp_print_either,
       fprintf,
       printf,
       eprintf,
       sprintf,
       asprintf,
       dprintf,
       ifprintf,
       kfprintf,
       kdprintf,
       ikfprintf,
       ksprintf,
       kasprintf,
       bprintf,
       ksprintf,
       set_all_formatter_output_funct,
       get_all_formatter_output_funct,
       pp_set_all_formatter_output_fu,
       pp_get_all_formatter_output_fu,
       pp_open_tag,
       open_tag,
       pp_close_tag,
       close_tag,
       pp_set_formatter_tag_functions,
       set_formatter_tag_functions,
       pp_get_formatter_tag_functions,
       get_formatter_tag_functions];
   runtime.caml_register_global(36, Stdlib_Format, "Stdlib__Format");
   return;
  }
  (globalThis));

//# 22408 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_register_named_value = runtime.caml_register_named_value,
    global_data = runtime.caml_get_global_data(),
    Stdlib_Obj = global_data.Stdlib__Obj,
    register = caml_register_named_value;
   function register_exception(name, exn){
    var
     _a_ = Stdlib_Obj[8],
     slot = runtime.caml_obj_tag(exn) === _a_ ? exn : exn[1];
    return caml_register_named_value(name, slot);
   }
   var Stdlib_Callback = [0, register, register_exception];
   runtime.caml_register_global(1, Stdlib_Callback, "Stdlib__Callback");
   return;
  }
  (globalThis));

//# 26624 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Bigarray_Array3_of_array_n$1 =
      "Bigarray.Array3.of_array: non-cubic data",
    caml_ba_change_layout = runtime.caml_ba_change_layout,
    caml_ba_create = runtime.caml_ba_create,
    caml_ba_dim_1 = runtime.caml_ba_dim_1,
    caml_ba_dim_2 = runtime.caml_ba_dim_2,
    caml_ba_kind = runtime.caml_ba_kind,
    caml_ba_num_dims = runtime.caml_ba_num_dims,
    caml_ba_reshape = runtime.caml_ba_reshape,
    caml_ba_set_1 = runtime.caml_ba_set_1,
    caml_ba_set_2 = runtime.caml_ba_set_2,
    caml_ba_set_3 = runtime.caml_ba_set_3,
    caml_ba_set_generic = runtime.caml_ba_set_generic,
    caml_ba_slice = runtime.caml_ba_slice,
    caml_check_bound = runtime.caml_check_bound,
    caml_make_vect = runtime.caml_make_vect,
    caml_mul = runtime.caml_mul;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Stdlib_Array = global_data.Stdlib__Array,
    Stdlib_Sys = global_data.Stdlib__Sys;
   function kind_size_in_bytes(param){
    switch(param){
      case 0:
       return 4;
      case 1:
       return 8;
      case 2:
       return 1;
      case 3:
       return 1;
      case 4:
       return 2;
      case 5:
       return 2;
      case 6:
       return 4;
      case 7:
       return 8;
      case 8:
       return Stdlib_Sys[9] / 8 | 0;
      case 9:
       return Stdlib_Sys[9] / 8 | 0;
      case 10:
       return 8;
      case 11:
       return 16;
      default: return 1;
    }
   }
   var
    cst_Bigarray_Array2_of_array_n =
      "Bigarray.Array2.of_array: non-rectangular data",
    cst_Bigarray_Array3_of_array_n = cst_Bigarray_Array3_of_array_n$1,
    cst_Bigarray_Array3_of_array_n$0 = cst_Bigarray_Array3_of_array_n$1,
    cst_Bigarray_array0_of_genarra = "Bigarray.array0_of_genarray",
    cst_Bigarray_array1_of_genarra = "Bigarray.array1_of_genarray",
    cst_Bigarray_array2_of_genarra = "Bigarray.array2_of_genarray",
    cst_Bigarray_array3_of_genarra = "Bigarray.array3_of_genarray";
   function cloop(arr, idx, f, col, max){
    if(col === idx.length - 1){
     caml_ba_set_generic(arr, idx, caml_call1(f, idx));
     return;
    }
    var _am_ = caml_check_bound(max, col)[1 + col] - 1 | 0, _al_ = 0;
    if(_am_ >= 0){
     var j = _al_;
     for(;;){
      caml_check_bound(idx, col)[1 + col] = j;
      cloop(arr, idx, f, col + 1 | 0, max);
      var _an_ = j + 1 | 0;
      if(_am_ === j) break;
      j = _an_;
     }
    }
    return;
   }
   function floop(arr, idx, f, col, max){
    if(0 > col){caml_ba_set_generic(arr, idx, caml_call1(f, idx)); return;}
    var _aj_ = caml_check_bound(max, col)[1 + col], _ai_ = 1;
    if(_aj_ >= 1){
     var j = _ai_;
     for(;;){
      caml_check_bound(idx, col)[1 + col] = j;
      floop(arr, idx, f, col - 1 | 0, max);
      var _ak_ = j + 1 | 0;
      if(_aj_ === j) break;
      j = _ak_;
     }
    }
    return;
   }
   function init(kind, layout, dims, f){
    var arr = caml_ba_create(kind, layout, dims), match = dims.length - 1;
    return 0 === match
            ? arr
            : layout
              ? (floop
                 (arr, caml_make_vect(match, 1), f, match - 1 | 0, dims),
                arr)
              : (cloop(arr, caml_make_vect(match, 0), f, 0, dims), arr);
   }
   function dims(a){
    var
     n = caml_ba_num_dims(a),
     d = caml_make_vect(n, 0),
     _af_ = n - 1 | 0,
     _ae_ = 0;
    if(_af_ >= 0){
     var i = _ae_;
     for(;;){
      var _ag_ = runtime.caml_ba_dim(a, i);
      caml_check_bound(d, i)[1 + i] = _ag_;
      var _ah_ = i + 1 | 0;
      if(_af_ === i) break;
      i = _ah_;
     }
    }
    return d;
   }
   function size_in_bytes(arr){
    var
     _ac_ = dims(arr),
     _ad_ = caml_call3(Stdlib_Array[17], caml_mul, 1, _ac_);
    return caml_mul(kind_size_in_bytes(caml_ba_kind(arr)), _ad_);
   }
   function create(kind, layout){return caml_ba_create(kind, layout, [0]);}
   function get(arr){return runtime.caml_ba_get_generic(arr, [0]);}
   function set(arr){
    var _aa_ = [0];
    return function(_ab_){return caml_ba_set_generic(arr, _aa_, _ab_);};
   }
   function size_in_bytes$0(arr){
    return kind_size_in_bytes(caml_ba_kind(arr));
   }
   function of_value(kind, layout, v){
    var a = create(kind, layout);
    set(a)(v);
    return a;
   }
   function create$0(kind, layout, dim){
    return caml_ba_create(kind, layout, [0, dim]);
   }
   function size_in_bytes$1(arr){
    var _$_ = caml_ba_dim_1(arr);
    return caml_mul(kind_size_in_bytes(caml_ba_kind(arr)), _$_);
   }
   function slice(a, n){
    return runtime.caml_ba_layout(a)
            ? caml_ba_slice(a, [0, n])
            : caml_ba_slice(a, [0, n]);
   }
   function init$0(kind, layout, dim, f){
    var arr = create$0(kind, layout, dim);
    if(layout){
     var _Z_ = 1;
     if(dim >= 1){
      var i$0 = _Z_;
      for(;;){
       caml_ba_set_1(arr, i$0, caml_call1(f, i$0));
       var ___ = i$0 + 1 | 0;
       if(dim === i$0) break;
       i$0 = ___;
      }
     }
     return arr;
    }
    var _X_ = dim - 1 | 0, _W_ = 0;
    if(_X_ >= 0){
     var i = _W_;
     for(;;){
      caml_ba_set_1(arr, i, caml_call1(f, i));
      var _Y_ = i + 1 | 0;
      if(_X_ === i) break;
      i = _Y_;
     }
    }
    return arr;
   }
   function of_array(kind, layout, data){
    var
     ba = create$0(kind, layout, data.length - 1),
     ofs = layout ? 1 : 0,
     _U_ = data.length - 2 | 0,
     _T_ = 0;
    if(_U_ >= 0){
     var i = _T_;
     for(;;){
      caml_ba_set_1(ba, i + ofs | 0, caml_check_bound(data, i)[1 + i]);
      var _V_ = i + 1 | 0;
      if(_U_ === i) break;
      i = _V_;
     }
    }
    return ba;
   }
   function create$1(kind, layout, dim1, dim2){
    return caml_ba_create(kind, layout, [0, dim1, dim2]);
   }
   function size_in_bytes$2(arr){
    var _R_ = caml_ba_dim_2(arr), _S_ = caml_ba_dim_1(arr);
    return caml_mul(caml_mul(kind_size_in_bytes(caml_ba_kind(arr)), _S_), _R_);
   }
   function slice_left(a, n){return caml_ba_slice(a, [0, n]);}
   function slice_right(a, n){return caml_ba_slice(a, [0, n]);}
   function init$1(kind, layout, dim1, dim2, f){
    var arr = create$1(kind, layout, dim1, dim2);
    if(layout){
     var _N_ = 1;
     if(dim2 >= 1){
      var j$0 = _N_;
      for(;;){
       var _O_ = 1;
       if(dim1 >= 1){
        var i$0 = _O_;
        for(;;){
         caml_ba_set_2(arr, i$0, j$0, caml_call2(f, i$0, j$0));
         var _Q_ = i$0 + 1 | 0;
         if(dim1 === i$0) break;
         i$0 = _Q_;
        }
       }
       var _P_ = j$0 + 1 | 0;
       if(dim2 === j$0) break;
       j$0 = _P_;
      }
     }
     return arr;
    }
    var _I_ = dim1 - 1 | 0, _H_ = 0;
    if(_I_ >= 0){
     var i = _H_;
     for(;;){
      var _K_ = dim2 - 1 | 0, _J_ = 0;
      if(_K_ >= 0){
       var j = _J_;
       for(;;){
        caml_ba_set_2(arr, i, j, caml_call2(f, i, j));
        var _M_ = j + 1 | 0;
        if(_K_ === j) break;
        j = _M_;
       }
      }
      var _L_ = i + 1 | 0;
      if(_I_ === i) break;
      i = _L_;
     }
    }
    return arr;
   }
   function of_array$0(kind, layout, data){
    var
     dim1 = data.length - 1,
     dim2 = 0 === dim1 ? 0 : caml_check_bound(data, 0)[1].length - 1,
     ba = create$1(kind, layout, dim1, dim2),
     ofs = layout ? 1 : 0,
     _C_ = dim1 - 1 | 0,
     _B_ = 0;
    if(_C_ >= 0){
     var i = _B_;
     for(;;){
      var row = caml_check_bound(data, i)[1 + i];
      if(row.length - 1 !== dim2)
       caml_call1(Stdlib[1], cst_Bigarray_Array2_of_array_n);
      var _E_ = dim2 - 1 | 0, _D_ = 0;
      if(_E_ >= 0){
       var j = _D_;
       for(;;){
        caml_ba_set_2
         (ba, i + ofs | 0, j + ofs | 0, caml_check_bound(row, j)[1 + j]);
        var _G_ = j + 1 | 0;
        if(_E_ === j) break;
        j = _G_;
       }
      }
      var _F_ = i + 1 | 0;
      if(_C_ === i) break;
      i = _F_;
     }
    }
    return ba;
   }
   function create$2(kind, layout, dim1, dim2, dim3){
    return caml_ba_create(kind, layout, [0, dim1, dim2, dim3]);
   }
   function size_in_bytes$3(arr){
    var
     _y_ = runtime.caml_ba_dim_3(arr),
     _z_ = caml_ba_dim_2(arr),
     _A_ = caml_ba_dim_1(arr);
    return caml_mul
            (caml_mul
              (caml_mul(kind_size_in_bytes(caml_ba_kind(arr)), _A_), _z_),
             _y_);
   }
   function slice_left_1(a, n, m){return caml_ba_slice(a, [0, n, m]);}
   function slice_right_1(a, n, m){return caml_ba_slice(a, [0, n, m]);}
   function slice_left_2(a, n){return caml_ba_slice(a, [0, n]);}
   function slice_right_2(a, n){return caml_ba_slice(a, [0, n]);}
   function init$2(kind, layout, dim1, dim2, dim3, f){
    var arr = create$2(kind, layout, dim1, dim2, dim3);
    if(layout){
     var _s_ = 1;
     if(dim3 >= 1){
      var k$0 = _s_;
      for(;;){
       var _t_ = 1;
       if(dim2 >= 1){
        var j$0 = _t_;
        for(;;){
         var _v_ = 1;
         if(dim1 >= 1){
          var i$0 = _v_;
          for(;;){
           caml_ba_set_3(arr, i$0, j$0, k$0, caml_call3(f, i$0, j$0, k$0));
           var _x_ = i$0 + 1 | 0;
           if(dim1 === i$0) break;
           i$0 = _x_;
          }
         }
         var _w_ = j$0 + 1 | 0;
         if(dim2 === j$0) break;
         j$0 = _w_;
        }
       }
       var _u_ = k$0 + 1 | 0;
       if(dim3 === k$0) break;
       k$0 = _u_;
      }
     }
     return arr;
    }
    var _k_ = dim1 - 1 | 0, _j_ = 0;
    if(_k_ >= 0){
     var i = _j_;
     for(;;){
      var _m_ = dim2 - 1 | 0, _l_ = 0;
      if(_m_ >= 0){
       var j = _l_;
       for(;;){
        var _p_ = dim3 - 1 | 0, _o_ = 0;
        if(_p_ >= 0){
         var k = _o_;
         for(;;){
          caml_ba_set_3(arr, i, j, k, caml_call3(f, i, j, k));
          var _r_ = k + 1 | 0;
          if(_p_ === k) break;
          k = _r_;
         }
        }
        var _q_ = j + 1 | 0;
        if(_m_ === j) break;
        j = _q_;
       }
      }
      var _n_ = i + 1 | 0;
      if(_k_ === i) break;
      i = _n_;
     }
    }
    return arr;
   }
   function of_array$1(kind, layout, data){
    var
     dim1 = data.length - 1,
     dim2 = 0 === dim1 ? 0 : caml_check_bound(data, 0)[1].length - 1,
     dim3 =
       0 === dim2
        ? 0
        : caml_check_bound(caml_check_bound(data, 0)[1], 0)[1].length - 1,
     ba = create$2(kind, layout, dim1, dim2, dim3),
     ofs = layout ? 1 : 0,
     _b_ = dim1 - 1 | 0,
     _a_ = 0;
    if(_b_ >= 0){
     var i = _a_;
     for(;;){
      var row = caml_check_bound(data, i)[1 + i];
      if(row.length - 1 !== dim2)
       caml_call1(Stdlib[1], cst_Bigarray_Array3_of_array_n);
      var _d_ = dim2 - 1 | 0, _c_ = 0;
      if(_d_ >= 0){
       var j = _c_;
       for(;;){
        var col = caml_check_bound(row, j)[1 + j];
        if(col.length - 1 !== dim3)
         caml_call1(Stdlib[1], cst_Bigarray_Array3_of_array_n$0);
        var _g_ = dim3 - 1 | 0, _f_ = 0;
        if(_g_ >= 0){
         var k = _f_;
         for(;;){
          caml_ba_set_3
           (ba,
            i + ofs | 0,
            j + ofs | 0,
            k + ofs | 0,
            caml_check_bound(col, k)[1 + k]);
          var _i_ = k + 1 | 0;
          if(_g_ === k) break;
          k = _i_;
         }
        }
        var _h_ = j + 1 | 0;
        if(_d_ === j) break;
        j = _h_;
       }
      }
      var _e_ = i + 1 | 0;
      if(_b_ === i) break;
      i = _e_;
     }
    }
    return ba;
   }
   function array0_of_genarray(a){
    return 0 === caml_ba_num_dims(a)
            ? a
            : caml_call1(Stdlib[1], cst_Bigarray_array0_of_genarra);
   }
   function array1_of_genarray(a){
    return 1 === caml_ba_num_dims(a)
            ? a
            : caml_call1(Stdlib[1], cst_Bigarray_array1_of_genarra);
   }
   function array2_of_genarray(a){
    return 2 === caml_ba_num_dims(a)
            ? a
            : caml_call1(Stdlib[1], cst_Bigarray_array2_of_genarra);
   }
   function array3_of_genarray(a){
    return 3 === caml_ba_num_dims(a)
            ? a
            : caml_call1(Stdlib[1], cst_Bigarray_array3_of_genarra);
   }
   function reshape_0(a){return caml_ba_reshape(a, [0]);}
   function reshape_1(a, dim1){return caml_ba_reshape(a, [0, dim1]);}
   function reshape_2(a, dim1, dim2){
    return caml_ba_reshape(a, [0, dim1, dim2]);
   }
   function reshape_3(a, dim1, dim2, dim3){
    return caml_ba_reshape(a, [0, dim1, dim2, dim3]);
   }
   var
    Stdlib_Bigarray =
      [0,
       0,
       1,
       10,
       11,
       2,
       3,
       4,
       5,
       8,
       6,
       7,
       9,
       12,
       kind_size_in_bytes,
       0,
       1,
       [0, init, dims, size_in_bytes],
       [0,
        create,
        of_value,
        caml_ba_change_layout,
        size_in_bytes$0,
        get,
        set,
        of_value],
       [0,
        create$0,
        init$0,
        caml_ba_change_layout,
        size_in_bytes$1,
        slice,
        of_array],
       [0,
        create$1,
        init$1,
        caml_ba_change_layout,
        size_in_bytes$2,
        slice_left,
        slice_right,
        of_array$0],
       [0,
        create$2,
        init$2,
        caml_ba_change_layout,
        size_in_bytes$3,
        slice_left_1,
        slice_right_1,
        slice_left_2,
        slice_right_2,
        of_array$1],
       array0_of_genarray,
       array1_of_genarray,
       array2_of_genarray,
       array3_of_genarray,
       caml_ba_reshape,
       reshape_0,
       reshape_1,
       reshape_2,
       reshape_3];
   runtime.caml_register_global(10, Stdlib_Bigarray, "Stdlib__Bigarray");
   return;
  }
  (globalThis));


//# 1 "../.js/default/unix/unix.cma.js"
// Generated by js_of_ocaml
//# 3 "../.js/default/unix/unix.cma.js"

//# 7 "../.js/default/unix/unix.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$6 = "",
    cst$7 = ", ",
    cst_c$1 = "-c",
    cst_bin_sh = "/bin/sh",
    cst_0_0_0_0$0 = "0.0.0.0",
    cst_127_0_0_1$0 = "127.0.0.1",
    cst_Unix_Unix_error = "Unix.Unix_error",
    cst_tcp$2 = "tcp",
    cst_udp$2 = "udp",
    caml_channel_descriptor = runtime.caml_channel_descriptor,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_bytes_length = runtime.caml_ml_bytes_length,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_unix_inet_addr_of_string = runtime.caml_unix_inet_addr_of_string,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$5 = cst$6,
    cst$4 = cst$6,
    cst$1 = ': "',
    cst$2 = '"',
    cst$3 = ": ",
    shell = cst_bin_sh,
    cst = cst$6,
    cst$0 = cst$6,
    Stdlib = global_data.Stdlib,
    Stdlib_Hashtbl = global_data.Stdlib__Hashtbl,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Fun = global_data.Stdlib__Fun,
    Stdlib_Int = global_data.Stdlib__Int;
   global_data.Stdlib__Array;
   var
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib_Callback = global_data.Stdlib__Callback,
    Stdlib_Printexc = global_data.Stdlib__Printexc,
    Unix_error = [248, cst_Unix_Unix_error, runtime.caml_fresh_oo_id(0)];
   caml_call2
    (Stdlib_Callback[2], cst_Unix_Unix_error, [0, Unix_error, 0, cst$0, cst]);
   var
    cst_E2BIG = "E2BIG",
    _a_ =
      [0,
       [11,
        "Unix.Unix_error(Unix.",
        [2, 0, [11, cst$7, [3, 0, [11, cst$7, [3, 0, [12, 41, 0]]]]]]],
       "Unix.Unix_error(Unix.%s, %S, %S)"],
    cst_EACCES = "EACCES",
    cst_EAGAIN = "EAGAIN",
    cst_EBADF = "EBADF",
    cst_EBUSY = "EBUSY",
    cst_ECHILD = "ECHILD",
    cst_EDEADLK = "EDEADLK",
    cst_EDOM = "EDOM",
    cst_EEXIST = "EEXIST",
    cst_EFAULT = "EFAULT",
    cst_EFBIG = "EFBIG",
    cst_EINTR = "EINTR",
    cst_EINVAL = "EINVAL",
    cst_EIO = "EIO",
    cst_EISDIR = "EISDIR",
    cst_EMFILE = "EMFILE",
    cst_EMLINK = "EMLINK",
    cst_ENAMETOOLONG = "ENAMETOOLONG",
    cst_ENFILE = "ENFILE",
    cst_ENODEV = "ENODEV",
    cst_ENOENT = "ENOENT",
    cst_ENOEXEC = "ENOEXEC",
    cst_ENOLCK = "ENOLCK",
    cst_ENOMEM = "ENOMEM",
    cst_ENOSPC = "ENOSPC",
    cst_ENOSYS = "ENOSYS",
    cst_ENOTDIR = "ENOTDIR",
    cst_ENOTEMPTY = "ENOTEMPTY",
    cst_ENOTTY = "ENOTTY",
    cst_ENXIO = "ENXIO",
    cst_EPERM = "EPERM",
    cst_EPIPE = "EPIPE",
    cst_ERANGE = "ERANGE",
    cst_EROFS = "EROFS",
    cst_ESPIPE = "ESPIPE",
    cst_ESRCH = "ESRCH",
    cst_EXDEV = "EXDEV",
    cst_EWOULDBLOCK = "EWOULDBLOCK",
    cst_EINPROGRESS = "EINPROGRESS",
    cst_EALREADY = "EALREADY",
    cst_ENOTSOCK = "ENOTSOCK",
    cst_EDESTADDRREQ = "EDESTADDRREQ",
    cst_EMSGSIZE = "EMSGSIZE",
    cst_EPROTOTYPE = "EPROTOTYPE",
    cst_ENOPROTOOPT = "ENOPROTOOPT",
    cst_EPROTONOSUPPORT = "EPROTONOSUPPORT",
    cst_ESOCKTNOSUPPORT = "ESOCKTNOSUPPORT",
    cst_EOPNOTSUPP = "EOPNOTSUPP",
    cst_EPFNOSUPPORT = "EPFNOSUPPORT",
    cst_EAFNOSUPPORT = "EAFNOSUPPORT",
    cst_EADDRINUSE = "EADDRINUSE",
    cst_EADDRNOTAVAIL = "EADDRNOTAVAIL",
    cst_ENETDOWN = "ENETDOWN",
    cst_ENETUNREACH = "ENETUNREACH",
    cst_ENETRESET = "ENETRESET",
    cst_ECONNABORTED = "ECONNABORTED",
    cst_ECONNRESET = "ECONNRESET",
    cst_ENOBUFS = "ENOBUFS",
    cst_EISCONN = "EISCONN",
    cst_ENOTCONN = "ENOTCONN",
    cst_ESHUTDOWN = "ESHUTDOWN",
    cst_ETOOMANYREFS = "ETOOMANYREFS",
    cst_ETIMEDOUT = "ETIMEDOUT",
    cst_ECONNREFUSED = "ECONNREFUSED",
    cst_EHOSTDOWN = "EHOSTDOWN",
    cst_EHOSTUNREACH = "EHOSTUNREACH",
    cst_ELOOP = "ELOOP",
    cst_EOVERFLOW = "EOVERFLOW",
    _b_ = [0, [11, "EUNKNOWNERR ", [4, 0, 0, 0, 0]], "EUNKNOWNERR %d"];
   caml_call1
    (Stdlib_Printexc[9],
     function(param){
      if(param[1] !== Unix_error) return 0;
      var s = param[4], s$0 = param[3], e = param[2];
      if(typeof e === "number"){
       var _cS_ = e;
       if(34 <= _cS_)
        switch(_cS_){
          case 34:
           var msg = cst_ESPIPE; break;
          case 35:
           var msg = cst_ESRCH; break;
          case 36:
           var msg = cst_EXDEV; break;
          case 37:
           var msg = cst_EWOULDBLOCK; break;
          case 38:
           var msg = cst_EINPROGRESS; break;
          case 39:
           var msg = cst_EALREADY; break;
          case 40:
           var msg = cst_ENOTSOCK; break;
          case 41:
           var msg = cst_EDESTADDRREQ; break;
          case 42:
           var msg = cst_EMSGSIZE; break;
          case 43:
           var msg = cst_EPROTOTYPE; break;
          case 44:
           var msg = cst_ENOPROTOOPT; break;
          case 45:
           var msg = cst_EPROTONOSUPPORT; break;
          case 46:
           var msg = cst_ESOCKTNOSUPPORT; break;
          case 47:
           var msg = cst_EOPNOTSUPP; break;
          case 48:
           var msg = cst_EPFNOSUPPORT; break;
          case 49:
           var msg = cst_EAFNOSUPPORT; break;
          case 50:
           var msg = cst_EADDRINUSE; break;
          case 51:
           var msg = cst_EADDRNOTAVAIL; break;
          case 52:
           var msg = cst_ENETDOWN; break;
          case 53:
           var msg = cst_ENETUNREACH; break;
          case 54:
           var msg = cst_ENETRESET; break;
          case 55:
           var msg = cst_ECONNABORTED; break;
          case 56:
           var msg = cst_ECONNRESET; break;
          case 57:
           var msg = cst_ENOBUFS; break;
          case 58:
           var msg = cst_EISCONN; break;
          case 59:
           var msg = cst_ENOTCONN; break;
          case 60:
           var msg = cst_ESHUTDOWN; break;
          case 61:
           var msg = cst_ETOOMANYREFS; break;
          case 62:
           var msg = cst_ETIMEDOUT; break;
          case 63:
           var msg = cst_ECONNREFUSED; break;
          case 64:
           var msg = cst_EHOSTDOWN; break;
          case 65:
           var msg = cst_EHOSTUNREACH; break;
          case 66:
           var msg = cst_ELOOP; break;
          default: var msg = cst_EOVERFLOW;
        }
       else
        switch(_cS_){
          case 0:
           var msg = cst_E2BIG; break;
          case 1:
           var msg = cst_EACCES; break;
          case 2:
           var msg = cst_EAGAIN; break;
          case 3:
           var msg = cst_EBADF; break;
          case 4:
           var msg = cst_EBUSY; break;
          case 5:
           var msg = cst_ECHILD; break;
          case 6:
           var msg = cst_EDEADLK; break;
          case 7:
           var msg = cst_EDOM; break;
          case 8:
           var msg = cst_EEXIST; break;
          case 9:
           var msg = cst_EFAULT; break;
          case 10:
           var msg = cst_EFBIG; break;
          case 11:
           var msg = cst_EINTR; break;
          case 12:
           var msg = cst_EINVAL; break;
          case 13:
           var msg = cst_EIO; break;
          case 14:
           var msg = cst_EISDIR; break;
          case 15:
           var msg = cst_EMFILE; break;
          case 16:
           var msg = cst_EMLINK; break;
          case 17:
           var msg = cst_ENAMETOOLONG; break;
          case 18:
           var msg = cst_ENFILE; break;
          case 19:
           var msg = cst_ENODEV; break;
          case 20:
           var msg = cst_ENOENT; break;
          case 21:
           var msg = cst_ENOEXEC; break;
          case 22:
           var msg = cst_ENOLCK; break;
          case 23:
           var msg = cst_ENOMEM; break;
          case 24:
           var msg = cst_ENOSPC; break;
          case 25:
           var msg = cst_ENOSYS; break;
          case 26:
           var msg = cst_ENOTDIR; break;
          case 27:
           var msg = cst_ENOTEMPTY; break;
          case 28:
           var msg = cst_ENOTTY; break;
          case 29:
           var msg = cst_ENXIO; break;
          case 30:
           var msg = cst_EPERM; break;
          case 31:
           var msg = cst_EPIPE; break;
          case 32:
           var msg = cst_ERANGE; break;
          default: var msg = cst_EROFS;
        }
      }
      else
       var x = e[1], msg = caml_call2(Stdlib_Printf[4], _b_, x);
      return [0, caml_call4(Stdlib_Printf[4], _a_, msg, s$0, s)];
     });
   var cst_failed = '" failed', cst_on = ' on "';
   function handle_unix_error(f, arg){
    try{var _cR_ = caml_call1(f, arg); return _cR_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn[1] !== Unix_error) throw caml_maybe_attach_backtrace(exn, 0);
     var
      arg$0 = exn[4],
      fun_name = exn[3],
      err = exn[2],
      _cP_ = runtime.caml_check_bound(runtime.caml_sys_argv(0), 0)[1];
     caml_call1(Stdlib[49], _cP_);
     caml_call1(Stdlib[49], cst$1);
     caml_call1(Stdlib[49], fun_name);
     caml_call1(Stdlib[49], cst_failed);
     if(0 < caml_ml_string_length(arg$0)){
      caml_call1(Stdlib[49], cst_on);
      caml_call1(Stdlib[49], arg$0);
      caml_call1(Stdlib[49], cst$2);
     }
     caml_call1(Stdlib[49], cst$3);
     var _cQ_ = runtime.unix_error_message(err);
     caml_call1(Stdlib[53], _cQ_);
     return caml_call1(Stdlib[99], 2);
    }
   }
   var
    stdin = 0,
    stdout = 1,
    stderr = 2,
    cst_Unix_read = "Unix.read",
    cst_Unix_write = "Unix.write",
    cst_Unix_single_write = "Unix.single_write",
    _c_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0);
   function read(fd, buf, ofs, len){
    if(0 <= ofs && 0 <= len && (caml_ml_bytes_length(buf) - len | 0) >= ofs)
     return runtime.unix_read(fd, buf, ofs, len);
    return caml_call1(Stdlib[1], cst_Unix_read);
   }
   function write(fd, buf, ofs, len){
    if(0 <= ofs && 0 <= len && (caml_ml_bytes_length(buf) - len | 0) >= ofs)
     return runtime.unix_write(fd, buf, ofs, len);
    return caml_call1(Stdlib[1], cst_Unix_write);
   }
   function single_write(fd, buf, ofs, len){
    if(0 <= ofs && 0 <= len && (caml_ml_bytes_length(buf) - len | 0) >= ofs)
     return runtime.unix_single_write(fd, buf, ofs, len);
    return caml_call1(Stdlib[1], cst_Unix_single_write);
   }
   function write_substring(fd, buf, ofs, len){
    return write(fd, caml_call1(Stdlib_Bytes[49], buf), ofs, len);
   }
   function single_write_substring(fd, buf, ofs, len){
    return single_write(fd, caml_call1(Stdlib_Bytes[49], buf), ofs, len);
   }
   function map_file(fd, opt, kind, layout, shared, dims){
    if(opt) var sth = opt[1], pos = sth; else var pos = _c_;
    return runtime.caml_unix_map_file_bytecode
            (fd, kind, layout, shared, dims, pos);
   }
   function pause(param){
    var sigs = runtime.unix_sigprocmask(1, 0);
    return runtime.unix_sigsuspend(sigs);
   }
   function sleep(duration){return runtime.unix_sleep(duration);}
   function is_inet6_addr(s){return 16 === caml_ml_string_length(s) ? 1 : 0;}
   var
    inet_addr_any = caml_unix_inet_addr_of_string(cst_0_0_0_0$0),
    inet_addr_loopback = caml_unix_inet_addr_of_string(cst_127_0_0_1$0),
    inet6_addr_any = caml_unix_inet_addr_of_string("::"),
    inet6_addr_loopback = caml_unix_inet_addr_of_string("::1"),
    cst_Unix_recv = "Unix.recv",
    cst_Unix_recvfrom = "Unix.recvfrom",
    cst_Unix_send = "Unix.send",
    cst_Unix_sendto = "Unix.sendto",
    cst_udp = cst_udp$2,
    cst_0_0_0_0 = cst_0_0_0_0$0,
    cst_127_0_0_1 = cst_127_0_0_1$0,
    cst_tcp = cst_tcp$2,
    cst_udp$0 = cst_udp$2,
    cst_tcp$0 = cst_tcp$2,
    cst_udp$1 = cst_udp$2,
    cst_tcp$1 = cst_tcp$2,
    cst_c = cst_c$1,
    _d_ = [0, 1];
   function domain_of_sockaddr(param){
    if(0 === param[0]) return 0;
    var a = param[1];
    return is_inet6_addr(a) ? 2 : 1;
   }
   function recv(fd, buf, ofs, len, flags){
    if(0 <= ofs && 0 <= len && (caml_ml_bytes_length(buf) - len | 0) >= ofs)
     return runtime.unix_recv(fd, buf, ofs, len, flags);
    return caml_call1(Stdlib[1], cst_Unix_recv);
   }
   function recvfrom(fd, buf, ofs, len, flags){
    if(0 <= ofs && 0 <= len && (caml_ml_bytes_length(buf) - len | 0) >= ofs)
     return runtime.unix_recvfrom(fd, buf, ofs, len, flags);
    return caml_call1(Stdlib[1], cst_Unix_recvfrom);
   }
   function send(fd, buf, ofs, len, flags){
    if(0 <= ofs && 0 <= len && (caml_ml_bytes_length(buf) - len | 0) >= ofs)
     return runtime.unix_send(fd, buf, ofs, len, flags);
    return caml_call1(Stdlib[1], cst_Unix_send);
   }
   function sendto(fd, buf, ofs, len, flags, addr){
    if(0 <= ofs && 0 <= len && (caml_ml_bytes_length(buf) - len | 0) >= ofs)
     return runtime.unix_sendto(fd, buf, ofs, len, flags, addr);
    return caml_call1(Stdlib[1], cst_Unix_sendto);
   }
   function send_substring(fd, buf, ofs, len, flags){
    return send(fd, caml_call1(Stdlib_Bytes[49], buf), ofs, len, flags);
   }
   function sendto_substring(fd, buf, ofs, len, flags, addr){
    return sendto
            (fd, caml_call1(Stdlib_Bytes[49], buf), ofs, len, flags, addr);
   }
   function getsockopt(fd, opt){return runtime.unix_getsockopt(0, fd, opt);}
   function setsockopt(fd, opt, v){
    return runtime.unix_setsockopt(0, fd, opt, v);
   }
   function getsockopt_int(fd, opt){
    return runtime.unix_getsockopt(1, fd, opt);
   }
   function setsockopt_int(fd, opt, v){
    return runtime.unix_setsockopt(1, fd, opt, v);
   }
   function getsockopt_optint(fd, opt){
    return runtime.unix_getsockopt(2, fd, opt);
   }
   function setsockopt_optint(fd, opt, v){
    return runtime.unix_setsockopt(2, fd, opt, v);
   }
   function getsockopt_float(fd, opt){
    return runtime.unix_getsockopt(3, fd, opt);
   }
   function setsockopt_float(fd, opt, v){
    return runtime.unix_setsockopt(3, fd, opt, v);
   }
   function getsockopt_error(fd){return runtime.unix_getsockopt(4, fd, 0);}
   function getaddrinfo(node, service, opts){
    try{
     var
      _cG_ = runtime.unix_getaddrinfo(node, service, opts),
      _cH_ = caml_call1(Stdlib_List[9], _cG_);
     return _cH_;
    }
    catch(_cI_){
     var _cF_ = caml_wrap_exception(_cI_);
     if(_cF_[1] !== Stdlib[6]) throw caml_maybe_attach_backtrace(_cF_, 0);
     var opt_socktype = [0, 0], opt_protocol = [0, 0];
     caml_call2
      (Stdlib_List[17],
       function(param){
        if(typeof param === "number"){if(2 === param) return 0;}
        else
         switch(param[0]){
           case 1:
            var s = param[1]; opt_socktype[1] = [0, s]; return 0;
           case 2:
            var p = param[1]; opt_protocol[1] = p; return 0;
         }
        return 0;
       },
       opts);
     var
      get_port =
        function(ty, kind){
         if(service == cst$6) return [0, [0, ty, 0], 0];
         try{
          var _cM_ = [0, [0, ty, runtime.caml_int_of_string(service)], 0];
          return _cM_;
         }
         catch(_cN_){
          var _cJ_ = caml_wrap_exception(_cN_);
          if(_cJ_[1] !== Stdlib[7])
           throw caml_maybe_attach_backtrace(_cJ_, 0);
          try{
           var
            _cL_ =
              [0, [0, ty, runtime.unix_getservbyname(service, kind)[3]], 0];
           return _cL_;
          }
          catch(_cO_){
           var _cK_ = caml_wrap_exception(_cO_);
           if(_cK_ === Stdlib[8]) return 0;
           throw caml_maybe_attach_backtrace(_cK_, 0);
          }
         }
        },
      _cA_ = opt_socktype[1];
     if(_cA_)
      var
       ty = _cA_[1],
       _cB_ =
         1 === ty
          ? get_port(1, cst_udp)
          : ty
            ? service == cst$6 ? [0, [0, ty, 0], 0] : 0
            : get_port(0, cst_tcp),
       ports = _cB_;
     else
      var
       _cD_ = get_port(1, cst_udp$0),
       _cE_ = get_port(0, cst_tcp$0),
       ports = caml_call2(Stdlib[37], _cE_, _cD_);
     var
      addresses =
        node == cst$6
         ? caml_call2
            (Stdlib_List[36], 2, opts)
           ? [0, [0, inet_addr_any, cst_0_0_0_0], 0]
           : [0, [0, inet_addr_loopback, cst_127_0_0_1], 0]
         : [0, [0, caml_unix_inet_addr_of_string(node), node], 0],
      _cC_ =
        caml_call2
         (Stdlib_List[19],
          function(param){
           var port = param[2], ty = param[1];
           return caml_call2
                   (Stdlib_List[19],
                    function(param){
                     var name = param[2], addr = param[1];
                     return [0, 1, ty, opt_protocol[1], [1, addr, port], name];
                    },
                    addresses);
          },
          ports);
     return caml_call1(Stdlib_List[14], _cC_);
    }
   }
   function getnameinfo(addr, opts){
    try{var _cw_ = runtime.unix_getnameinfo(addr, opts); return _cw_;}
    catch(_cx_){
     var _cv_ = caml_wrap_exception(_cx_);
     if(_cv_[1] !== Stdlib[6]) throw caml_maybe_attach_backtrace(_cv_, 0);
     if(0 === addr[0]){var f = addr[1]; return [0, cst$4, f];}
     var p = addr[2], a = addr[1];
     try{
      if(caml_call2(Stdlib_List[36], 1, opts))
       throw caml_maybe_attach_backtrace(Stdlib[8], 1);
      var _cu_ = runtime.unix_gethostbyaddr(a)[1], hostname = _cu_;
     }
     catch(_cz_){
      var _cr_ = caml_wrap_exception(_cz_);
      if(_cr_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_cr_, 0);
      if(caml_call2(Stdlib_List[36], 2, opts))
       throw caml_maybe_attach_backtrace(Stdlib[8], 1);
      var hostname = runtime.unix_string_of_inet_addr(a);
     }
     try{
      if(caml_call2(Stdlib_List[36], 3, opts))
       throw caml_maybe_attach_backtrace(Stdlib[8], 1);
      var
       kind = caml_call2(Stdlib_List[36], 4, opts) ? cst_udp$1 : cst_tcp$1,
       _ct_ = runtime.unix_getservbyport(p, kind)[1],
       service = _ct_;
     }
     catch(_cy_){
      var _cs_ = caml_wrap_exception(_cy_);
      if(_cs_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_cs_, 0);
      var service = caml_call1(Stdlib_Int[12], p);
     }
     return [0, hostname, service];
    }
   }
   function waitpid_non_intr(pid){
    for(;;)
     try{var _cp_ = runtime.unix_waitpid(0, pid); return _cp_;}
     catch(_cq_){
      var _cn_ = caml_wrap_exception(_cq_);
      if(_cn_[1] === Unix_error){
       var _co_ = _cn_[2];
       if(typeof _co_ === "number" && 11 === _co_) continue;
      }
      throw caml_maybe_attach_backtrace(_cn_, 0);
     }
   }
   function system(cmd){
    var
     pid =
       runtime.unix_spawn
        (cst_bin_sh, [0, shell, cst_c, cmd], 0, 0, [0, 0, 1, 2]);
    return waitpid_non_intr(pid)[2];
   }
   function create_process_gen
   (cmd, args, optenv, new_stdin, new_stdout, new_stderr){
    var toclose = [0, 0];
    function close_after(param){
     return caml_call2
             (Stdlib_List[17],
              function(fd){
               try{var _cl_ = runtime.unix_close(fd); return _cl_;}
               catch(_cm_){
                var _ck_ = caml_wrap_exception(_cm_);
                if(_ck_[1] === Unix_error) return 0;
                throw caml_maybe_attach_backtrace(_ck_, 0);
               }
              },
              toclose[1]);
    }
    function file_descr_not_standard(fd){
     var fd$0 = fd;
     for(;;){
      if(3 <= fd$0) return fd$0;
      var fd$1 = runtime.unix_dup(_d_, fd$0);
      toclose[1] = [0, fd$1, toclose[1]];
      fd$0 = fd$1;
     }
    }
    var
     _ch_ = 2 === new_stderr ? 2 : file_descr_not_standard(new_stderr),
     _ci_ = 1 === new_stdout ? 1 : file_descr_not_standard(new_stdout),
     _cj_ = 0 === new_stdin ? 0 : file_descr_not_standard(new_stdin),
     redirections = [0, _cj_, _ci_, _ch_];
    return caml_call2
            (Stdlib_Fun[4],
             close_after,
             function(param){
              return runtime.unix_spawn(cmd, args, optenv, 1, redirections);
             });
   }
   function create_process(cmd, args, new_stdin, new_stdout, new_stderr){
    return create_process_gen(cmd, args, 0, new_stdin, new_stdout, new_stderr);
   }
   function create_process_env
   (cmd, args, env, new_stdin, new_stdout, new_stderr){
    return create_process_gen
            (cmd, args, [0, env], new_stdin, new_stdout, new_stderr);
   }
   var
    popen_processes = caml_call2(Stdlib_Hashtbl[1], 0, 7),
    _e_ = [0, 1],
    _f_ = [0, 1],
    _g_ = [0, 1],
    _h_ = [0, 1],
    _i_ = [0, 1],
    _j_ = [0, 1],
    _k_ = [0, 1],
    cst_c$0 = cst_c$1,
    cst_process_in_pid = "process_in_pid",
    cst_process_out_pid = "process_out_pid",
    cst_process_pid = "process_pid",
    cst_process_full_pid = "process_full_pid",
    cst_close_process_in = "close_process_in",
    cst_close_process_out = "close_process_out",
    cst_close_process = "close_process",
    cst_close_process_full = "close_process_full",
    _l_ = [0, 1],
    _m_ = [0, 1],
    _n_ = [0, 1];
   function open_proc(prog, args, envopt, proc, input, output, error){
    var pid = create_process_gen(prog, args, envopt, input, output, error);
    return caml_call3(Stdlib_Hashtbl[5], popen_processes, proc, pid);
   }
   function open_process_args_in(prog, args){
    var
     match = runtime.unix_pipe(_e_, 0),
     in_write = match[2],
     in_read = match[1],
     inchan = runtime.unix_inchannel_of_filedescr(in_read);
    try{open_proc(prog, args, 0, [1, inchan], stdin, in_write, stderr);}
    catch(e$0){
     var e = caml_wrap_exception(e$0);
     caml_call1(Stdlib[93], inchan);
     runtime.unix_close(in_write);
     throw caml_maybe_attach_backtrace(e, 0);
    }
    runtime.unix_close(in_write);
    return inchan;
   }
   function open_process_args_out(prog, args){
    var
     match = runtime.unix_pipe(_f_, 0),
     out_write = match[2],
     out_read = match[1],
     outchan = runtime.unix_outchannel_of_filedescr(out_write);
    try{open_proc(prog, args, 0, [2, outchan], out_read, stdout, stderr);}
    catch(e$0){
     var e = caml_wrap_exception(e$0);
     caml_call1(Stdlib[76], outchan);
     runtime.unix_close(out_read);
     throw caml_maybe_attach_backtrace(e, 0);
    }
    runtime.unix_close(out_read);
    return outchan;
   }
   function open_process_args(prog, args){
    var
     match = runtime.unix_pipe(_g_, 0),
     in_write = match[2],
     in_read = match[1];
    try{var match$0 = runtime.unix_pipe(_h_, 0);}
    catch(e$0){
     var e = caml_wrap_exception(e$0);
     runtime.unix_close(in_read);
     runtime.unix_close(in_write);
     throw caml_maybe_attach_backtrace(e, 0);
    }
    var
     out_write = match$0[2],
     out_read = match$0[1],
     inchan = runtime.unix_inchannel_of_filedescr(in_read),
     outchan = runtime.unix_outchannel_of_filedescr(out_write);
    try{
     open_proc
      (prog, args, 0, [0, inchan, outchan], out_read, in_write, stderr);
    }
    catch(e){
     var e$0 = caml_wrap_exception(e);
     runtime.unix_close(out_read);
     runtime.unix_close(out_write);
     runtime.unix_close(in_read);
     runtime.unix_close(in_write);
     throw caml_maybe_attach_backtrace(e$0, 0);
    }
    runtime.unix_close(out_read);
    runtime.unix_close(in_write);
    return [0, inchan, outchan];
   }
   function open_process_args_full(prog, args, env){
    var
     match = runtime.unix_pipe(_i_, 0),
     in_write = match[2],
     in_read = match[1];
    try{var match$0 = runtime.unix_pipe(_j_, 0);}
    catch(e$0){
     var e = caml_wrap_exception(e$0);
     runtime.unix_close(in_read);
     runtime.unix_close(in_write);
     throw caml_maybe_attach_backtrace(e, 0);
    }
    var out_write = match$0[2], out_read = match$0[1];
    try{var match$1 = runtime.unix_pipe(_k_, 0);}
    catch(e){
     var e$0 = caml_wrap_exception(e);
     runtime.unix_close(in_read);
     runtime.unix_close(in_write);
     runtime.unix_close(out_read);
     runtime.unix_close(out_write);
     throw caml_maybe_attach_backtrace(e$0, 0);
    }
    var
     err_write = match$1[2],
     err_read = match$1[1],
     inchan = runtime.unix_inchannel_of_filedescr(in_read),
     outchan = runtime.unix_outchannel_of_filedescr(out_write),
     errchan = runtime.unix_inchannel_of_filedescr(err_read);
    try{
     open_proc
      (prog,
       args,
       [0, env],
       [3, inchan, outchan, errchan],
       out_read,
       in_write,
       err_write);
    }
    catch(e){
     var e$1 = caml_wrap_exception(e);
     runtime.unix_close(out_read);
     runtime.unix_close(out_write);
     runtime.unix_close(in_read);
     runtime.unix_close(in_write);
     runtime.unix_close(err_read);
     runtime.unix_close(err_write);
     throw caml_maybe_attach_backtrace(e$1, 0);
    }
    runtime.unix_close(out_read);
    runtime.unix_close(in_write);
    runtime.unix_close(err_write);
    return [0, inchan, outchan, errchan];
   }
   function open_process_shell(fn, cmd){
    return caml_call2(fn, shell, [0, shell, cst_c$0, cmd]);
   }
   function open_process_in(cmd){
    return open_process_shell(open_process_args_in, cmd);
   }
   function open_process_out(cmd){
    return open_process_shell(open_process_args_out, cmd);
   }
   function open_process(cmd){
    return open_process_shell(open_process_args, cmd);
   }
   function open_process_full(cmd){
    return open_process_shell(open_process_args_full, cmd);
   }
   function find_proc_id(fun_name, proc){
    try{
     var _cf_ = caml_call2(Stdlib_Hashtbl[6], popen_processes, proc);
     return _cf_;
    }
    catch(_cg_){
     var _ce_ = caml_wrap_exception(_cg_);
     if(_ce_ === Stdlib[8])
      throw caml_maybe_attach_backtrace
             ([0, Unix_error, 3, fun_name, cst$5], 1);
     throw caml_maybe_attach_backtrace(_ce_, 0);
    }
   }
   function remove_proc_id(proc){
    return caml_call2(Stdlib_Hashtbl[10], popen_processes, proc);
   }
   function process_in_pid(inchan){
    return find_proc_id(cst_process_in_pid, [1, inchan]);
   }
   function process_out_pid(outchan){
    return find_proc_id(cst_process_out_pid, [2, outchan]);
   }
   function process_pid(param){
    var outchan = param[2], inchan = param[1];
    return find_proc_id(cst_process_pid, [0, inchan, outchan]);
   }
   function process_full_pid(param){
    var errchan = param[3], outchan = param[2], inchan = param[1];
    return find_proc_id(cst_process_full_pid, [3, inchan, outchan, errchan]);
   }
   function close_process_in(inchan){
    var proc = [1, inchan], pid = find_proc_id(cst_close_process_in, proc);
    remove_proc_id(proc);
    caml_call1(Stdlib[93], inchan);
    return waitpid_non_intr(pid)[2];
   }
   function close_process_out(outchan){
    var proc = [2, outchan], pid = find_proc_id(cst_close_process_out, proc);
    remove_proc_id(proc);
    try{caml_call1(Stdlib[76], outchan);}
    catch(_cd_){
     var _cc_ = caml_wrap_exception(_cd_);
     if(_cc_[1] !== Stdlib[11]) throw caml_maybe_attach_backtrace(_cc_, 0);
    }
    return waitpid_non_intr(pid)[2];
   }
   function close_process(param){
    var
     outchan = param[2],
     inchan = param[1],
     proc = [0, inchan, outchan],
     pid = find_proc_id(cst_close_process, proc);
    remove_proc_id(proc);
    caml_call1(Stdlib[93], inchan);
    try{caml_call1(Stdlib[76], outchan);}
    catch(_cb_){
     var _ca_ = caml_wrap_exception(_cb_);
     if(_ca_[1] !== Stdlib[11]) throw caml_maybe_attach_backtrace(_ca_, 0);
    }
    return waitpid_non_intr(pid)[2];
   }
   function close_process_full(param){
    var
     errchan = param[3],
     outchan = param[2],
     inchan = param[1],
     proc = [3, inchan, outchan, errchan],
     pid = find_proc_id(cst_close_process_full, proc);
    remove_proc_id(proc);
    caml_call1(Stdlib[93], inchan);
    try{caml_call1(Stdlib[76], outchan);}
    catch(_b$_){
     var _b__ = caml_wrap_exception(_b$_);
     if(_b__[1] !== Stdlib[11]) throw caml_maybe_attach_backtrace(_b__, 0);
    }
    caml_call1(Stdlib[93], errchan);
    return waitpid_non_intr(pid)[2];
   }
   function open_connection(sockaddr){
    var sock = runtime.unix_socket(_l_, domain_of_sockaddr(sockaddr), 0, 0);
    try{
     runtime.unix_connect(sock, sockaddr);
     var
      _b8_ = runtime.unix_outchannel_of_filedescr(sock),
      _b9_ = [0, runtime.unix_inchannel_of_filedescr(sock), _b8_];
     return _b9_;
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     runtime.unix_close(sock);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function shutdown_connection(inchan){
    return runtime.unix_shutdown(caml_channel_descriptor(inchan), 1);
   }
   function establish_server(server_fun, sockaddr){
    var sock = runtime.unix_socket(_n_, domain_of_sockaddr(sockaddr), 0, 0);
    runtime.unix_setsockopt(0, sock, 2, 1);
    runtime.unix_bind(sock, sockaddr);
    runtime.unix_listen(sock, 5);
    for(;;){
     for(;;)
      try{var match = runtime.unix_accept(_m_, sock); break;}
      catch(_b7_){
       var _b5_ = caml_wrap_exception(_b7_);
       if(_b5_[1] === Unix_error){
        var _b6_ = _b5_[2];
        if(typeof _b6_ === "number" && 11 === _b6_) continue;
       }
       throw caml_maybe_attach_backtrace(_b5_, 0);
      }
     var s = match[1], id = runtime.unix_fork(0);
     if(0 === id){
      if(0 !== runtime.unix_fork(0)) runtime.unix_exit(0);
      runtime.unix_close(sock);
      var
       inchan = runtime.unix_inchannel_of_filedescr(s),
       outchan = runtime.unix_outchannel_of_filedescr(s);
      caml_call2(server_fun, inchan, outchan);
      caml_call1(Stdlib[99], 0);
     }
     else{runtime.unix_close(s); waitpid_non_intr(id);}
    }
   }
   var
    Unix =
      [0,
       Unix_error,
       function(_b4_){return runtime.unix_error_message(_b4_);},
       handle_unix_error,
       function(_b3_){return runtime.unix_environment(_b3_);},
       function(_b2_){return runtime.unix_environment_unsafe(_b2_);},
       runtime.caml_sys_getenv,
       runtime.caml_sys_unsafe_getenv,
       function(_b1_, _b0_){return runtime.unix_putenv(_b1_, _b0_);},
       function(_bZ_, _bY_){return runtime.unix_execv(_bZ_, _bY_);},
       function(_bX_, _bW_, _bV_){
        return runtime.unix_execve(_bX_, _bW_, _bV_);
       },
       function(_bU_, _bT_){return runtime.unix_execvp(_bU_, _bT_);},
       function(_bS_, _bR_, _bQ_){
        return runtime.unix_execvpe(_bS_, _bR_, _bQ_);
       },
       function(_bP_){return runtime.unix_fork(_bP_);},
       function(_bO_){return runtime.unix_wait(_bO_);},
       function(_bN_, _bM_){return runtime.unix_waitpid(_bN_, _bM_);},
       system,
       function(_bL_){return runtime.unix_exit(_bL_);},
       function(_bK_){return runtime.unix_getpid(_bK_);},
       function(_bJ_){return runtime.unix_getppid(_bJ_);},
       function(_bI_){return runtime.unix_nice(_bI_);},
       stdin,
       stdout,
       stderr,
       function(_bH_, _bG_, _bF_){return runtime.unix_open(_bH_, _bG_, _bF_);},
       function(_bE_){return runtime.unix_close(_bE_);},
       function(_bD_){return runtime.unix_fsync(_bD_);},
       read,
       write,
       single_write,
       write_substring,
       single_write_substring,
       function(_bC_){return runtime.unix_inchannel_of_filedescr(_bC_);},
       function(_bB_){return runtime.unix_outchannel_of_filedescr(_bB_);},
       caml_channel_descriptor,
       caml_channel_descriptor,
       function(_bA_, _bz_, _by_){
        return runtime.unix_lseek(_bA_, _bz_, _by_);
       },
       function(_bx_, _bw_){return runtime.unix_truncate(_bx_, _bw_);},
       function(_bv_, _bu_){return runtime.unix_ftruncate(_bv_, _bu_);},
       runtime.caml_unix_stat,
       runtime.caml_unix_lstat,
       function(_bt_){return runtime.unix_fstat(_bt_);},
       runtime.caml_unix_isatty,
       [0,
        function(_bs_, _br_, _bq_){
         return runtime.unix_lseek_64(_bs_, _br_, _bq_);
        },
        function(_bp_, _bo_){return runtime.unix_truncate_64(_bp_, _bo_);},
        function(_bn_, _bm_){return runtime.unix_ftruncate_64(_bn_, _bm_);},
        runtime.caml_unix_stat_64,
        runtime.caml_unix_lstat_64,
        function(_bl_){return runtime.unix_fstat_64(_bl_);}],
       map_file,
       runtime.caml_unix_unlink,
       function(_bk_, _bj_){return runtime.unix_rename(_bk_, _bj_);},
       function(_bi_, _bh_, _bg_){return runtime.unix_link(_bi_, _bh_, _bg_);},
       function(_bf_){return runtime.unix_realpath(_bf_);},
       function(_be_, _bd_){return runtime.unix_chmod(_be_, _bd_);},
       function(_bc_, _bb_){return runtime.unix_fchmod(_bc_, _bb_);},
       function(_ba_, _a$_, _a__){
        return runtime.unix_chown(_ba_, _a$_, _a__);
       },
       function(_a9_, _a8_, _a7_){
        return runtime.unix_fchown(_a9_, _a8_, _a7_);
       },
       function(_a6_){return runtime.unix_umask(_a6_);},
       function(_a5_, _a4_){return runtime.unix_access(_a5_, _a4_);},
       function(_a3_, _a2_){return runtime.unix_dup(_a3_, _a2_);},
       function(_a1_, _a0_, _aZ_){return runtime.unix_dup2(_a1_, _a0_, _aZ_);},
       function(_aY_){return runtime.unix_set_nonblock(_aY_);},
       function(_aX_){return runtime.unix_clear_nonblock(_aX_);},
       function(_aW_){return runtime.unix_set_close_on_exec(_aW_);},
       function(_aV_){return runtime.unix_clear_close_on_exec(_aV_);},
       runtime.caml_unix_mkdir,
       runtime.caml_unix_rmdir,
       function(_aU_){return runtime.unix_chdir(_aU_);},
       function(_aT_){return runtime.unix_getcwd(_aT_);},
       function(_aS_){return runtime.unix_chroot(_aS_);},
       runtime.caml_unix_opendir,
       runtime.caml_unix_readdir,
       runtime.caml_unix_rewinddir,
       runtime.caml_unix_closedir,
       function(_aR_, _aQ_){return runtime.unix_pipe(_aR_, _aQ_);},
       function(_aP_, _aO_){return runtime.unix_mkfifo(_aP_, _aO_);},
       create_process,
       create_process_env,
       open_process_in,
       open_process_out,
       open_process,
       open_process_full,
       open_process_args_in,
       open_process_args_out,
       open_process_args,
       open_process_args_full,
       process_in_pid,
       process_out_pid,
       process_pid,
       process_full_pid,
       close_process_in,
       close_process_out,
       close_process,
       close_process_full,
       runtime.caml_unix_symlink,
       runtime.caml_unix_has_symlink,
       runtime.caml_unix_readlink,
       function(_aN_, _aM_, _aL_, _aK_){
        return runtime.unix_select(_aN_, _aM_, _aL_, _aK_);
       },
       function(_aJ_, _aI_, _aH_){
        return runtime.unix_lockf(_aJ_, _aI_, _aH_);
       },
       function(_aG_, _aF_){return runtime.unix_kill(_aG_, _aF_);},
       function(_aE_, _aD_){return runtime.unix_sigprocmask(_aE_, _aD_);},
       function(_aC_){return runtime.unix_sigpending(_aC_);},
       function(_aB_){return runtime.unix_sigsuspend(_aB_);},
       pause,
       function(_aA_){return runtime.caml_unix_time(_aA_);},
       function(_az_){return runtime.caml_unix_gettimeofday(_az_);},
       runtime.caml_unix_gmtime,
       runtime.caml_unix_localtime,
       runtime.caml_unix_mktime,
       function(_ay_){return runtime.unix_alarm(_ay_);},
       sleep,
       function(_ax_){return runtime.unix_sleep(_ax_);},
       function(_aw_){return runtime.unix_times(_aw_);},
       function(_av_, _au_, _at_){
        return runtime.unix_utimes(_av_, _au_, _at_);
       },
       function(_as_){return runtime.unix_getitimer(_as_);},
       function(_ar_, _aq_){return runtime.unix_setitimer(_ar_, _aq_);},
       runtime.caml_unix_getuid,
       function(_ap_){return runtime.unix_geteuid(_ap_);},
       function(_ao_){return runtime.unix_setuid(_ao_);},
       function(_an_){return runtime.unix_getgid(_an_);},
       function(_am_){return runtime.unix_getegid(_am_);},
       function(_al_){return runtime.unix_setgid(_al_);},
       function(_ak_){return runtime.unix_getgroups(_ak_);},
       function(_aj_){return runtime.unix_setgroups(_aj_);},
       function(_ai_, _ah_){return runtime.unix_initgroups(_ai_, _ah_);},
       function(_ag_){return runtime.unix_getlogin(_ag_);},
       function(_af_){return runtime.unix_getpwnam(_af_);},
       function(_ae_){return runtime.unix_getgrnam(_ae_);},
       runtime.caml_unix_getpwuid,
       function(_ad_){return runtime.unix_getgrgid(_ad_);},
       function(_ac_){return caml_unix_inet_addr_of_string(_ac_);},
       function(_ab_){return runtime.unix_string_of_inet_addr(_ab_);},
       inet_addr_any,
       inet_addr_loopback,
       inet6_addr_any,
       inet6_addr_loopback,
       is_inet6_addr,
       function(_aa_, _$_, ___, _Z_){
        return runtime.unix_socket(_aa_, _$_, ___, _Z_);
       },
       domain_of_sockaddr,
       function(_Y_, _X_, _W_, _V_){
        return runtime.unix_socketpair(_Y_, _X_, _W_, _V_);
       },
       function(_U_, _T_){return runtime.unix_accept(_U_, _T_);},
       function(_S_, _R_){return runtime.unix_bind(_S_, _R_);},
       function(_Q_, _P_){return runtime.unix_connect(_Q_, _P_);},
       function(_O_, _N_){return runtime.unix_listen(_O_, _N_);},
       function(_M_, _L_){return runtime.unix_shutdown(_M_, _L_);},
       function(_K_){return runtime.unix_getsockname(_K_);},
       function(_J_){return runtime.unix_getpeername(_J_);},
       recv,
       recvfrom,
       send,
       send_substring,
       sendto,
       sendto_substring,
       getsockopt,
       setsockopt,
       getsockopt_int,
       setsockopt_int,
       getsockopt_optint,
       setsockopt_optint,
       getsockopt_float,
       setsockopt_float,
       getsockopt_error,
       open_connection,
       shutdown_connection,
       establish_server,
       function(_I_){return runtime.unix_gethostname(_I_);},
       function(_H_){return runtime.unix_gethostbyname(_H_);},
       function(_G_){return runtime.unix_gethostbyaddr(_G_);},
       function(_F_){return runtime.unix_getprotobyname(_F_);},
       function(_E_){return runtime.unix_getprotobynumber(_E_);},
       function(_D_, _C_){return runtime.unix_getservbyname(_D_, _C_);},
       function(_B_, _A_){return runtime.unix_getservbyport(_B_, _A_);},
       getaddrinfo,
       getnameinfo,
       function(_z_){return runtime.unix_tcgetattr(_z_);},
       function(_y_, _x_, _w_){return runtime.unix_tcsetattr(_y_, _x_, _w_);},
       function(_v_, _u_){return runtime.unix_tcsendbreak(_v_, _u_);},
       function(_t_){return runtime.unix_tcdrain(_t_);},
       function(_s_, _r_){return runtime.unix_tcflush(_s_, _r_);},
       function(_q_, _p_){return runtime.unix_tcflow(_q_, _p_);},
       function(_o_){return runtime.unix_setsid(_o_);}];
   runtime.caml_register_global(136, Unix, "Unix");
   return;
  }
  (globalThis));

//# 1127 "../.js/default/unix/unix.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Unix = global_data.Unix,
    Unix_error = Unix[1],
    error_message = Unix[2],
    handle_unix_error = Unix[3],
    environment = Unix[4],
    unsafe_environment = Unix[5],
    getenv = Unix[6],
    unsafe_getenv = Unix[7],
    putenv = Unix[8],
    execv = Unix[9],
    execve = Unix[10],
    execvp = Unix[11],
    execvpe = Unix[12],
    fork = Unix[13],
    wait = Unix[14],
    waitpid = Unix[15],
    system = Unix[16],
    exit = Unix[17],
    getpid = Unix[18],
    getppid = Unix[19],
    nice = Unix[20],
    stdin = Unix[21],
    stdout = Unix[22],
    stderr = Unix[23],
    openfile = Unix[24],
    close = Unix[25],
    fsync = Unix[26],
    read = Unix[27],
    write = Unix[28],
    single_write = Unix[29],
    write_substring = Unix[30],
    single_write_substring = Unix[31],
    in_channel_of_descr = Unix[32],
    out_channel_of_descr = Unix[33],
    descr_of_in_channel = Unix[34],
    descr_of_out_channel = Unix[35],
    lseek = Unix[36],
    truncate = Unix[37],
    ftruncate = Unix[38],
    stat = Unix[39],
    lstat = Unix[40],
    fstat = Unix[41],
    isatty = Unix[42],
    LargeFile = Unix[43],
    map_file = Unix[44],
    unlink = Unix[45],
    rename = Unix[46],
    link = Unix[47],
    realpath = Unix[48],
    chmod = Unix[49],
    fchmod = Unix[50],
    chown = Unix[51],
    fchown = Unix[52],
    umask = Unix[53],
    access = Unix[54],
    dup = Unix[55],
    dup2 = Unix[56],
    set_nonblock = Unix[57],
    clear_nonblock = Unix[58],
    set_close_on_exec = Unix[59],
    clear_close_on_exec = Unix[60],
    mkdir = Unix[61],
    rmdir = Unix[62],
    chdir = Unix[63],
    getcwd = Unix[64],
    chroot = Unix[65],
    opendir = Unix[66],
    readdir = Unix[67],
    rewinddir = Unix[68],
    closedir = Unix[69],
    pipe = Unix[70],
    mkfifo = Unix[71],
    create_process = Unix[72],
    create_process_env = Unix[73],
    open_process_in = Unix[74],
    open_process_out = Unix[75],
    open_process = Unix[76],
    open_process_full = Unix[77],
    open_process_args_in = Unix[78],
    open_process_args_out = Unix[79],
    open_process_args = Unix[80],
    open_process_args_full = Unix[81],
    process_in_pid = Unix[82],
    process_out_pid = Unix[83],
    process_pid = Unix[84],
    process_full_pid = Unix[85],
    close_process_in = Unix[86],
    close_process_out = Unix[87],
    close_process = Unix[88],
    close_process_full = Unix[89],
    symlink = Unix[90],
    has_symlink = Unix[91],
    readlink = Unix[92],
    select = Unix[93],
    lockf = Unix[94],
    kill = Unix[95],
    sigprocmask = Unix[96],
    sigpending = Unix[97],
    sigsuspend = Unix[98],
    pause = Unix[99],
    time = Unix[100],
    gettimeofday = Unix[101],
    gmtime = Unix[102],
    localtime = Unix[103],
    mktime = Unix[104],
    alarm = Unix[105],
    sleep = Unix[106],
    sleepf = Unix[107],
    times = Unix[108],
    utimes = Unix[109],
    getitimer = Unix[110],
    setitimer = Unix[111],
    getuid = Unix[112],
    geteuid = Unix[113],
    setuid = Unix[114],
    getgid = Unix[115],
    getegid = Unix[116],
    setgid = Unix[117],
    getgroups = Unix[118],
    setgroups = Unix[119],
    initgroups = Unix[120],
    getlogin = Unix[121],
    getpwnam = Unix[122],
    getgrnam = Unix[123],
    getpwuid = Unix[124],
    getgrgid = Unix[125],
    inet_addr_of_string = Unix[126],
    string_of_inet_addr = Unix[127],
    inet_addr_any = Unix[128],
    inet_addr_loopback = Unix[129],
    inet6_addr_any = Unix[130],
    inet6_addr_loopback = Unix[131],
    is_inet6_addr = Unix[132],
    socket = Unix[133],
    domain_of_sockaddr = Unix[134],
    socketpair = Unix[135],
    accept = Unix[136],
    bind = Unix[137],
    connect = Unix[138],
    listen = Unix[139],
    shutdown = Unix[140],
    getsockname = Unix[141],
    getpeername = Unix[142],
    recv = Unix[143],
    recvfrom = Unix[144],
    send = Unix[145],
    send_substring = Unix[146],
    sendto = Unix[147],
    sendto_substring = Unix[148],
    getsockopt = Unix[149],
    setsockopt = Unix[150],
    getsockopt_int = Unix[151],
    setsockopt_int = Unix[152],
    getsockopt_optint = Unix[153],
    setsockopt_optint = Unix[154],
    getsockopt_float = Unix[155],
    setsockopt_float = Unix[156],
    getsockopt_error = Unix[157],
    open_connection = Unix[158],
    shutdown_connection = Unix[159],
    establish_server = Unix[160],
    gethostname = Unix[161],
    gethostbyname = Unix[162],
    gethostbyaddr = Unix[163],
    getprotobyname = Unix[164],
    getprotobynumber = Unix[165],
    getservbyname = Unix[166],
    getservbyport = Unix[167],
    getaddrinfo = Unix[168],
    getnameinfo = Unix[169],
    tcgetattr = Unix[170],
    tcsetattr = Unix[171],
    tcsendbreak = Unix[172],
    tcdrain = Unix[173],
    tcflush = Unix[174],
    tcflow = Unix[175],
    setsid = Unix[176],
    UnixLabels =
      [0,
       Unix_error,
       error_message,
       handle_unix_error,
       environment,
       unsafe_environment,
       getenv,
       unsafe_getenv,
       putenv,
       execv,
       execve,
       execvp,
       execvpe,
       fork,
       wait,
       waitpid,
       system,
       exit,
       getpid,
       getppid,
       nice,
       stdin,
       stdout,
       stderr,
       openfile,
       close,
       fsync,
       read,
       write,
       single_write,
       write_substring,
       single_write_substring,
       in_channel_of_descr,
       out_channel_of_descr,
       descr_of_in_channel,
       descr_of_out_channel,
       lseek,
       truncate,
       ftruncate,
       stat,
       lstat,
       fstat,
       isatty,
       LargeFile,
       map_file,
       unlink,
       rename,
       link,
       realpath,
       chmod,
       fchmod,
       chown,
       fchown,
       umask,
       access,
       dup,
       dup2,
       set_nonblock,
       clear_nonblock,
       set_close_on_exec,
       clear_close_on_exec,
       mkdir,
       rmdir,
       chdir,
       getcwd,
       chroot,
       opendir,
       readdir,
       rewinddir,
       closedir,
       pipe,
       mkfifo,
       create_process,
       create_process_env,
       open_process_in,
       open_process_out,
       open_process,
       open_process_full,
       open_process_args_in,
       open_process_args_out,
       open_process_args,
       open_process_args_full,
       process_in_pid,
       process_out_pid,
       process_pid,
       process_full_pid,
       close_process_in,
       close_process_out,
       close_process,
       close_process_full,
       symlink,
       has_symlink,
       readlink,
       select,
       lockf,
       kill,
       sigprocmask,
       sigpending,
       sigsuspend,
       pause,
       time,
       gettimeofday,
       gmtime,
       localtime,
       mktime,
       alarm,
       sleep,
       sleepf,
       times,
       utimes,
       getitimer,
       setitimer,
       getuid,
       geteuid,
       setuid,
       getgid,
       getegid,
       setgid,
       getgroups,
       setgroups,
       initgroups,
       getlogin,
       getpwnam,
       getgrnam,
       getpwuid,
       getgrgid,
       inet_addr_of_string,
       string_of_inet_addr,
       inet_addr_any,
       inet_addr_loopback,
       inet6_addr_any,
       inet6_addr_loopback,
       is_inet6_addr,
       socket,
       domain_of_sockaddr,
       socketpair,
       accept,
       bind,
       connect,
       listen,
       shutdown,
       getsockname,
       getpeername,
       recv,
       recvfrom,
       send,
       send_substring,
       sendto,
       sendto_substring,
       getsockopt,
       setsockopt,
       getsockopt_int,
       setsockopt_int,
       getsockopt_optint,
       setsockopt_optint,
       getsockopt_float,
       setsockopt_float,
       getsockopt_error,
       open_connection,
       shutdown_connection,
       establish_server,
       gethostname,
       gethostbyname,
       gethostbyaddr,
       getprotobyname,
       getprotobynumber,
       getservbyname,
       getservbyport,
       getaddrinfo,
       getnameinfo,
       tcgetattr,
       tcsetattr,
       tcsendbreak,
       tcdrain,
       tcflush,
       tcflow,
       setsid];
   runtime.caml_register_global(1, UnixLabels, "UnixLabels");
   return;
  }
  (globalThis));


//# 1 "../.js/default/bigarray/bigarray.cma.js"
// Generated by js_of_ocaml
//# 3 "../.js/default/bigarray/bigarray.cma.js"

//# 7 "../.js/default/bigarray/bigarray.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Stdlib_Bigarray = global_data.Stdlib__Bigarray,
    float32 = Stdlib_Bigarray[1],
    float64 = Stdlib_Bigarray[2],
    complex32 = Stdlib_Bigarray[3],
    complex64 = Stdlib_Bigarray[4],
    int8_signed = Stdlib_Bigarray[5],
    int8_unsigned = Stdlib_Bigarray[6],
    int16_signed = Stdlib_Bigarray[7],
    int16_unsigned = Stdlib_Bigarray[8],
    int$0 = Stdlib_Bigarray[9],
    int32 = Stdlib_Bigarray[10],
    int64 = Stdlib_Bigarray[11],
    nativeint = Stdlib_Bigarray[12],
    char$0 = Stdlib_Bigarray[13],
    kind_size_in_bytes = Stdlib_Bigarray[14],
    c_layout = Stdlib_Bigarray[15],
    fortran_layout = Stdlib_Bigarray[16],
    array0_of_genarray = Stdlib_Bigarray[22],
    array1_of_genarray = Stdlib_Bigarray[23],
    array2_of_genarray = Stdlib_Bigarray[24],
    array3_of_genarray = Stdlib_Bigarray[25],
    reshape = Stdlib_Bigarray[26],
    reshape_0 = Stdlib_Bigarray[27],
    reshape_1 = Stdlib_Bigarray[28],
    reshape_2 = Stdlib_Bigarray[29],
    reshape_3 = Stdlib_Bigarray[30],
    Bigarray =
      [0,
       float32,
       float64,
       complex32,
       complex64,
       int8_signed,
       int8_unsigned,
       int16_signed,
       int16_unsigned,
       int$0,
       int32,
       int64,
       nativeint,
       char$0,
       kind_size_in_bytes,
       c_layout,
       fortran_layout,
       array0_of_genarray,
       array1_of_genarray,
       array2_of_genarray,
       array3_of_genarray,
       reshape,
       reshape_0,
       reshape_1,
       reshape_2,
       reshape_3];
   runtime.caml_register_global(1, Bigarray, "Bigarray");
   return;
  }
  (globalThis));


//# 1 "../.js/default/react/react.cma.js"
// Generated by js_of_ocaml
//# 3 "../.js/default/react/react.cma.js"

//# 6 "../.js/default/react/react.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_src_react_ml = "src/react.ml",
    caml_equal = runtime.caml_equal,
    caml_int_compare = runtime.caml_int_compare,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    err_max_rank = "maximal rank exceeded",
    err_sig_undef = "signal value undefined yet",
    err_fix = "trying to fix a delayed value",
    err_retain_never = "E.never cannot retain a closure",
    err_retain_cst_sig = "constant signals cannot retain a closure",
    err_step_executed = "step already executed",
    err_event_scheduled = "event already scheduled on a step",
    err_signal_scheduled = "signal already scheduled on a step",
    one = [0, 1],
    zero = [0, 0],
    zero$0 = [0, 0],
    one$0 = [0, 1],
    minus_one = [0, -1],
    zero$1 = [0, 0.],
    one$1 = [0, 1.],
    minus_one$0 = [0, -1.],
    none = [0, 0],
    Assert_failure = global_data.Assert_failure,
    Stdlib = global_data.Stdlib,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Weak = global_data.Stdlib__Weak;
   function create(size){return [0, caml_call1(Stdlib_Weak[1], size), 0];}
   function clear(a){
    a[1] = caml_call1(Stdlib_Weak[1], 0);
    a[2] = 0;
    return 0;
   }
   function get(a, i){return caml_call2(Stdlib_Weak[4], a[1], i);}
   function swap(a, i$0, i){
    var v = caml_call2(Stdlib_Weak[4], a[1], i);
    caml_call5(Stdlib_Weak[8], a[1], i$0, a[1], i, 1);
    return caml_call3(Stdlib_Weak[3], a[1], i$0, v);
   }
   function add(a, v){
    var _cy_ = caml_call1(Stdlib_Weak[2], a[1]);
    if(a[2] === _cy_){
     var arr = caml_call1(Stdlib_Weak[1], 2 * (a[2] + 1 | 0) | 0);
     caml_call5(Stdlib_Weak[8], a[1], 0, arr, 0, a[2]);
     a[1] = arr;
    }
    caml_call3(Stdlib_Weak[3], a[1], a[2], [0, v]);
    a[2] = a[2] + 1 | 0;
    return 0;
   }
   function rem_last(a){
    var l = a[2] - 1 | 0;
    a[2] = l;
    return caml_call3(Stdlib_Weak[3], a[1], l, 0);
   }
   function fold(f, acc, a){
    var acc$0 = [0, acc], _cw_ = a[2] - 1 | 0, _cv_ = 0;
    if(_cw_ >= 0){
     var i = _cv_;
     for(;;){
      var match = caml_call2(Stdlib_Weak[4], a[1], i);
      if(match){var v = match[1]; acc$0[1] = caml_call2(f, acc$0[1], v);}
      var _cx_ = i + 1 | 0;
      if(_cw_ === i) break;
      i = _cx_;
     }
    }
    return acc$0[1];
   }
   function compare_down(h, i$0, i){
    var match = get(h, i$0), match$0 = get(h, i);
    if(! match) return match$0 ? -1 : 0;
    var n = match[1];
    if(! match$0) return 1;
    var n$0 = match$0[1];
    return caml_int_compare(n[1], n$0[1]);
   }
   function down(h, i){
    var i$0 = i;
    for(;;){
     var
      last = h[2] - 1 | 0,
      start = 2 * i$0 | 0,
      l = start + 1 | 0,
      r = start + 2 | 0;
     if(last < l) return 0;
     var
      child = last < r ? l : 0 <= compare_down(h, l, r) ? r : l,
      _cu_ = 0 < compare_down(h, i$0, child) ? 1 : 0;
     if(! _cu_) return _cu_;
     swap(h, i$0, child);
     i$0 = child;
    }
   }
   var delayed_rank = Stdlib[19], nil = [0, 1, create(0), 0, 0];
   function create$0(param){var h = create(11); return [0, 0, h, 0, 0];}
   function add$0(c, n$1){
    if(n$1[2] === c) return 0;
    n$1[2] = c;
    var h = c[2];
    add(h, n$1);
    var i$0 = h[2] - 1 | 0, i = i$0, last_none = 0;
    for(;;){
     if(0 === i) return last_none ? down(h, 0) : last_none;
     var p = (i - 1 | 0) / 2 | 0, match = get(h, i), match$0 = get(h, p);
     if(! match) return 0;
     var n = match[1];
     if(match$0){
      var n$0 = match$0[1];
      if(0 <= caml_int_compare(n[1], n$0[1]))
       return last_none ? down(h, i) : last_none;
      swap(h, i, p);
      i = p;
      last_none = 0;
     }
     else{swap(h, i, p); i = p; last_none = 1;}
    }
   }
   function add_deps(c, n){
    var a = n[6], _cs_ = a[2] - 1 | 0, _cr_ = 0;
    if(_cs_ >= 0){
     var i = _cr_;
     for(;;){
      var match = caml_call2(Stdlib_Weak[4], a[1], i);
      if(match){var v = match[1]; add$0(c, v);}
      var _ct_ = i + 1 | 0;
      if(_cs_ === i) break;
      i = _ct_;
     }
    }
    return 0;
   }
   function add_eop(c, op){c[3] = [0, op, c[3]]; return 0;}
   function allow_reschedule(n){n[2] = nil; return;}
   function rebuild(c){
    var h = c[2], _cp_ = (h[2] - 2 | 0) / 2 | 0;
    if(_cp_ >= 0){
     var i = _cp_;
     for(;;){down(h, i); var _cq_ = i - 1 | 0; if(0 === i) break; i = _cq_;}
    }
    return 0;
   }
   function execute(c$1){
    if(c$1[1]) return caml_call1(Stdlib[1], err_step_executed);
    var c = c$1;
    for(;;){
     var
      eops =
        function(c){
         caml_call2
          (Stdlib_List[17], function(op){return caml_call1(op, 0);}, c[3]);
         c[3] = 0;
         return;
        },
      cops =
        function(c){
         caml_call2
          (Stdlib_List[17], function(op){return caml_call1(op, 0);}, c[4]);
         c[4] = 0;
         return;
        },
      finish = function(c){c[1] = 1; c[2] = create(0); return 0;};
     for(;;){
      var a = c[2];
      a:
      {
       b:
       {
        for(;;){
         var s = a[2];
         if(0 === s) break b;
         var v = get(a, 0);
         if(1 < s){
          var _cn_ = get(a, s - 1 | 0);
          caml_call1(caml_call2(Stdlib_Weak[3], a[1], 0), _cn_);
          rem_last(a);
          down(a, 0);
         }
         else
          rem_last(a);
         if(v) break;
        }
        var match = v;
        break a;
       }
       var match = 0;
      }
      if(! match){eops(c); cops(c); return finish(c);}
      var n = match[1];
      if(n[1] === delayed_rank) break;
      caml_call1(n[5], c);
     }
     var c$0 = create$0(0);
     eops(c);
     var h = c[2];
     let c$1 = c$0;
     var _co_ = [0, n, fold(function(acc, e){return [0, e, acc];}, 0, h)];
     caml_call2
      (Stdlib_List[17], function(n){return caml_call1(n[5], c$1);}, _co_);
     cops(c);
     finish(c);
     c = c$0;
    }
   }
   function find_unfinished(nl){
    var next = 0, param = [0, nl, 0];
    for(;;)
     if(param){
      var nl$0 = param[1];
      if(nl$0){
       var todo = param[2], next$0 = next, param$0 = nl$0;
       for(;;){
        if(! param$0) break;
        var nl$1 = param$0[2], n = param$0[1];
        if(! n[2][1]) return n[2];
        var next$1 = [0, caml_call1(n[4], 0), next$0];
        next$0 = next$1;
        param$0 = nl$1;
       }
       next = next$0;
       param = todo;
      }
      else{var todo$0 = param[2]; param = todo$0;}
     }
     else{if(0 === next) return nil; param = next; next = 0;}
   }
   var min_rank = Stdlib[20], max_rank = delayed_rank - 1 | 0;
   function nop(param){return 0;}
   function no_producers(param){return 0;}
   function create$1(r){
    return [0, r, nil, nop, no_producers, nop, create(0)];
   }
   function rem_dep(n$0, n){
    var a = n$0[6];
    try{
     var _ck_ = a[2] - 1 | 0, _cj_ = 0;
     if(_ck_ >= 0){
      var i = _cj_;
      for(;;){
       var match = caml_call2(Stdlib_Weak[4], a[1], i);
       if(match){
        var v = match[1];
        if(n === v){
         caml_call3(Stdlib_Weak[3], a[1], i, 0);
         throw caml_maybe_attach_backtrace(Stdlib[3], 1);
        }
       }
       var _cl_ = i + 1 | 0;
       if(_ck_ === i) break;
       i = _cl_;
      }
     }
     return;
    }
    catch(_cm_){
     var _ci_ = caml_wrap_exception(_cm_);
     if(_ci_ === Stdlib[3]) return;
     throw caml_maybe_attach_backtrace(_ci_, 0);
    }
   }
   function add_dep(n$0, n){
    var a = n$0[6];
    try{
     var _ce_ = a[2] - 1 | 0, _cd_ = 0;
     if(_ce_ >= 0){
      var i = _cd_;
      for(;;){
       if(! caml_call2(Stdlib_Weak[4], a[1], i)){
        caml_call3(Stdlib_Weak[3], a[1], i, [0, n]);
        throw caml_maybe_attach_backtrace(Stdlib[3], 1);
       }
       var _cg_ = i + 1 | 0;
       if(_ce_ === i) break;
       i = _cg_;
      }
     }
     var _cf_ = add(a, n);
     return _cf_;
    }
    catch(_ch_){
     var _cc_ = caml_wrap_exception(_ch_);
     if(_cc_ === Stdlib[3]) return 0;
     throw caml_maybe_attach_backtrace(_cc_, 0);
    }
   }
   function deps(n){
    return fold(function(acc, d){return [0, d, acc];}, 0, n[6]);
   }
   function bind(n, p, u){n[4] = p; n[5] = u; return 0;}
   function stop(opt, to_rem){
    if(opt) var sth = opt[1], strong = sth; else var strong = 0;
    if(! strong){
     to_rem[4] = no_producers;
     to_rem[5] = nop;
     return clear(to_rem[6]);
    }
    var producers = caml_call1(to_rem[4], 0);
    to_rem[4] = no_producers;
    to_rem[5] = nop;
    clear(to_rem[6]);
    var next = 0, to_rem$0 = to_rem, param = producers;
    for(;;)
     if(param){
      var todo = param[2], n = param[1];
      rem_dep(n, to_rem$0);
      if(n[1] !== min_rank){
       var a = n[6];
       try{
        var _b9_ = a[2] - 1 | 0, _b8_ = 0;
        if(_b9_ >= 0){
         var i = _b8_;
         for(;;){
          if(caml_call2(Stdlib_Weak[6], a[1], i))
           throw caml_maybe_attach_backtrace(Stdlib[3], 1);
          var _b$_ = i + 1 | 0;
          if(_b9_ === i) break;
          i = _b$_;
         }
        }
        var _b__ = 1, _ca_ = _b__;
       }
       catch(_cb_){
        var _b7_ = caml_wrap_exception(_cb_);
        if(_b7_ !== Stdlib[3]) throw caml_maybe_attach_backtrace(_b7_, 0);
        var _ca_ = 0;
       }
       if(! (1 - _ca_)){
        var prods = caml_call1(n[4], 0);
        n[4] = no_producers;
        n[5] = nop;
        clear(n[6]);
        var next$0 = [0, [0, n, prods], next];
        next = next$0;
        param = todo;
        continue;
       }
      }
      param = todo;
     }
     else{
      if(! next) return 0;
      var
       next$1 = next[2],
       match = next[1],
       prods$0 = match[2],
       to_rem$1 = match[1];
      next = next$1;
      to_rem$0 = to_rem$1;
      param = prods$0;
     }
   }
   var
    rmin = create$1(min_rank),
    _a_ = [0, cst_src_react_ml, 410, 54],
    _b_ = [0, cst_src_react_ml, 421, 51];
   function rmax(n$0, n){return n[1] < n$0[1] ? n$0 : n;}
   function rsucc(n){
    return n[1] === delayed_rank
            ? min_rank
            : n
               [1]
              < max_rank
              ? n[1] + 1 | 0
              : caml_call1(Stdlib[1], err_max_rank);
   }
   function rsucc2(n$0, n){
    var r = rsucc(n$0), r$0 = rsucc(n);
    return r$0 < r ? r : r$0;
   }
   function update_rank(n, r){
    if(n[1] >= r) return 0;
    n[1] = r;
    var param = [0, n, 0];
    for(;;){
     if(! param) return 1;
     var todo = param[2], n$0 = param[1];
     let n = n$0;
     var
      update =
        function(todo, d){
         if(n[1] >= d[1] && n[1] !== delayed_rank){d[1] = rsucc(n); return [0, d, todo];}
         return todo;
        };
     param = fold(update, todo, n$0[6]);
    }
   }
   function eval$0(m){
    var match = m[1][1];
    if(! match)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
    var v = match[1];
    return v;
   }
   function emut(rank){return [0, [0, 0], create$1(rank)];}
   function event(m, p, u){bind(m[2], p, u); return [0, m];}
   function eupdate(v, m, c){
    m[1][1] = [0, v];
    var v$0 = m[1];
    function op(_b6_){v$0[1] = 0; return 0;}
    c[4] = [0, op, c[4]];
    return add_deps(c, m[2]);
   }
   function sval(m){
    var match = m[1];
    if(! match)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
    var v = match[1];
    return v;
   }
   function smut(rank, eq){return [0, 0, eq, create$1(rank)];}
   function signal(i, m, p, u){
    bind(m[3], p, u);
    if(i) m[1] = i;
    var c = find_unfinished(caml_call1(m[3][4], 0));
    if(c === nil) caml_call1(m[3][5], nil); else add$0(c, m[3]);
    return [1, m];
   }
   function supdate(v, m, c){
    var match = m[1];
    if(! match){m[1] = [0, v]; return 0;}
    var v$0 = match[1];
    if(caml_call2(m[2], v, v$0)) return 0;
    m[1] = [0, v];
    var _b5_ = c !== nil ? 1 : 0;
    return _b5_ ? add_deps(c, m[3]) : _b5_;
   }
   function add_dep$0(m, n){
    add_dep(m[2], n);
    var _b4_ = 0 !== m[1][1] ? 1 : 0;
    return _b4_ ? add$0(m[2][2], n) : _b4_;
   }
   var
    _c_ = [0, 1],
    _d_ = [0, cst_src_react_ml, 701, 19],
    _e_ = [0, cst_src_react_ml, 731, 53],
    _f_ = [0, cst_src_react_ml, 760, 45];
   function create$2(param){
    var m = emut(min_rank);
    return [0,
            [0, m],
            function(step, v){
             if(! step){
              var c$0 = create$0(0);
              m[2][2] = c$0;
              eupdate(v, m, c$0);
              return execute(c$0);
             }
             var c = step[1];
             if(c[1])
              caml_call1(Stdlib[1], err_step_executed);
             else if(m[2][2][1])
              m[2][2] = c;
             else
              caml_call1(Stdlib[1], err_event_scheduled);
             return eupdate(v, m, c);
            }];
   }
   function retain(e, c){
    if(! e) return caml_call1(Stdlib[1], err_retain_never);
    var m = e[1], c$0 = m[2][3];
    m[2][3] = c;
    return [0, 82, c$0];
   }
   function stop$0(strong, param){
    if(! param) return 0;
    var m = param[1];
    return stop(strong, m[2]);
   }
   function equal(e$0, e){
    if(e$0){
     if(e){var m = e[1], m$0 = e$0[1]; return m$0 === m ? 1 : 0;}
    }
    else if(! e) return 1;
    return 0;
   }
   function trace(opt, t, e){
    if(opt) var sth = opt[1], iff = sth; else var iff = _c_;
    if(0 === iff[0]){
     if(! iff[1]) return e;
     if(! e) return e;
     var
      m = e[1],
      m$0 = emut(rsucc(m[2])),
      p = function(param){return [0, m[2], 0];},
      u =
        function(c){
         var v = eval$0(m);
         caml_call1(t, v);
         return eupdate(v, m$0, c);
        };
     add_dep$0(m, m$0[2]);
     return event(m$0, p, u);
    }
    var mc = iff[1];
    if(! e) return 0;
    var m$1 = e[1], m$2 = emut(rsucc2(mc[3], m$1[2]));
    function p$0(param){return [0, mc[3], [0, m$1[2], 0]];}
    function u$0(c){
     var match = m$1[1][1];
     if(! match) return 0;
     var v = match[1];
     if(sval(mc)) caml_call1(t, v);
     return eupdate(v, m$2, c);
    }
    add_dep(mc[3], m$2[2]);
    add_dep$0(m$1, m$2[2]);
    return event(m$2, p$0, u$0);
   }
   function once(param){
    if(! param) return 0;
    var m = param[1], m$0 = emut(rsucc(m[2]));
    function p(param){return [0, m[2], 0];}
    function u(c){
     rem_dep(m[2], m$0[2]);
     eupdate(eval$0(m), m$0, c);
     return stop(0, m$0[2]);
    }
    add_dep$0(m, m$0[2]);
    return event(m$0, p, u);
   }
   function drop_once(param){
    if(! param) return 0;
    var m = param[1], m$0 = emut(rsucc(m[2]));
    function p(param){return [0, m[2], 0];}
    function u(c){
     function u(c){return eupdate(eval$0(m), m$0, c);}
     return bind(m$0[2], p, u);
    }
    add_dep$0(m, m$0[2]);
    return event(m$0, p, u);
   }
   function app(ef, param){
    if(! param) return 0;
    var m = param[1];
    if(! ef) return 0;
    var mf = ef[1], m$0 = emut(rsucc2(m[2], mf[2]));
    function p(param){return [0, m[2], [0, mf[2], 0]];}
    function u(c){
     var _b3_ = mf[1][1], match = m[1][1];
     if(_b3_ && match){
      var v = match[1], f = _b3_[1];
      return eupdate(caml_call1(f, v), m$0, c);
     }
     return 0;
    }
    add_dep$0(m, m$0[2]);
    add_dep$0(mf, m$0[2]);
    return event(m$0, p, u);
   }
   function map(f, param){
    if(! param) return 0;
    var m = param[1], m$0 = emut(rsucc(m[2]));
    function p(param){return [0, m[2], 0];}
    function u(c){return eupdate(caml_call1(f, eval$0(m)), m$0, c);}
    add_dep$0(m, m$0[2]);
    return event(m$0, p, u);
   }
   function stamp(e, v){
    if(! e) return 0;
    var m = e[1], m$0 = emut(rsucc(m[2]));
    function p(param){return [0, m[2], 0];}
    function u(c){return eupdate(v, m$0, c);}
    add_dep$0(m, m$0[2]);
    return event(m$0, p, u);
   }
   function filter(pred, param){
    if(! param) return 0;
    var m = param[1], m$0 = emut(rsucc(m[2]));
    function p(param){return [0, m[2], 0];}
    function u(c){
     var v = eval$0(m);
     return caml_call1(pred, v) ? eupdate(v, m$0, c) : 0;
    }
    add_dep$0(m, m$0[2]);
    return event(m$0, p, u);
   }
   function fmap(fm, param){
    if(! param) return 0;
    var m = param[1], m$0 = emut(rsucc(m[2]));
    function p(param){return [0, m[2], 0];}
    function u(c){
     var match = caml_call1(fm, eval$0(m));
     if(! match) return 0;
     var v = match[1];
     return eupdate(v, m$0, c);
    }
    add_dep$0(m, m$0[2]);
    return event(m$0, p, u);
   }
   function diff(d, param){
    if(! param) return 0;
    var m = param[1], m$0 = emut(rsucc(m[2])), last = [0, 0];
    function p(param){return [0, m[2], 0];}
    function u(c){
     var v = eval$0(m), match = last[1];
     if(match){
      var v$0 = match[1];
      last[1] = [0, v];
      return eupdate(caml_call2(d, v, v$0), m$0, c);
     }
     last[1] = [0, v];
     return 0;
    }
    add_dep$0(m, m$0[2]);
    return event(m$0, p, u);
   }
   function changes(opt, param){
    if(opt) var sth = opt[1], eq = sth; else var eq = caml_equal;
    if(! param) return 0;
    var m = param[1], m$0 = emut(rsucc(m[2])), last = [0, 0];
    function p(param){return [0, m[2], 0];}
    function u(c){
     var v = eval$0(m), match = last[1];
     if(match){
      var v$0 = match[1];
      last[1] = [0, v];
      return caml_call2(eq, v, v$0) ? 0 : eupdate(v, m$0, c);
     }
     last[1] = [0, v];
     return eupdate(v, m$0, c);
    }
    add_dep$0(m, m$0[2]);
    return event(m$0, p, u);
   }
   function on(c, e){
    if(! e) return 0;
    var m = e[1];
    if(0 === c[0]) return c[1] ? e : 0;
    var mc = c[1], m$0 = emut(rsucc2(m[2], mc[3]));
    function p(param){return [0, m[2], [0, mc[3], 0]];}
    function u(c){
     return m[1][1] ? sval(mc) ? eupdate(eval$0(m), m$0, c) : 0 : 0;
    }
    add_dep$0(m, m$0[2]);
    add_dep(mc[3], m$0[2]);
    return event(m$0, p, u);
   }
   function dismiss(c, e){
    if(! e) return 0;
    var m = e[1];
    if(! c) return e;
    var mc = c[1], m$0 = emut(rsucc2(mc[2], m[2]));
    function p(param){return [0, mc[2], [0, m[2], 0]];}
    function u(c){return mc[1][1] ? 0 : eupdate(eval$0(m), m$0, c);}
    add_dep$0(mc, m$0[2]);
    add_dep$0(m, m$0[2]);
    return event(m$0, p, u);
   }
   function until(c, e){
    if(! e) return 0;
    var m = e[1];
    if(! c) return e;
    var mc = c[1], m$0 = emut(rsucc2(m[2], mc[2]));
    function p(param){return [0, m[2], [0, mc[2], 0]];}
    function u(c){
     return mc[1][1]
             ? (rem_dep
                (m[2], m$0[2]),
               rem_dep(mc[2], m$0[2]),
               stop(0, m$0[2]))
             : eupdate(eval$0(m), m$0, c);
    }
    add_dep$0(m, m$0[2]);
    add_dep$0(mc, m$0[2]);
    return event(m$0, p, u);
   }
   function accum(ef, i){
    if(! ef) return 0;
    var m = ef[1], m$0 = emut(rsucc(m[2])), acc = [0, i];
    function p(param){return [0, m[2], 0];}
    function u(c){
     var _b2_ = acc[1];
     acc[1] = caml_call1(eval$0(m), _b2_);
     return eupdate(acc[1], m$0, c);
    }
    add_dep$0(m, m$0[2]);
    return event(m$0, p, u);
   }
   function fold$0(f, i, param){
    if(! param) return 0;
    var m = param[1], m$0 = emut(rsucc(m[2])), acc = [0, i];
    function p(param){return [0, m[2], 0];}
    function u(c){
     var _b1_ = eval$0(m);
     acc[1] = caml_call2(f, acc[1], _b1_);
     return eupdate(acc[1], m$0, c);
    }
    add_dep$0(m, m$0[2]);
    return event(m$0, p, u);
   }
   function occurs(m){return 0 !== m[1][1] ? 1 : 0;}
   function find_muts_and_next_rank(el){
    var acc = 0, max = rmin, param = el;
    for(;;){
     if(! param){
      var _b0_ = rsucc(max);
      return [0, caml_call1(Stdlib_List[9], acc), _b0_];
     }
     var match = param[1];
     if(match){
      var
       l = param[2],
       m = match[1],
       max$0 = rmax(max, m[2]),
       acc$0 = [0, m, acc];
      acc = acc$0;
      max = max$0;
      param = l;
     }
     else{var l$0 = param[2]; param = l$0;}
    }
   }
   function select(el){
    var
     match = find_muts_and_next_rank(el),
     r = match[2],
     emuts = match[1],
     m = emut(r);
    function p(param){
     return caml_call2(Stdlib_List[21], function(m){return m[2];}, emuts);
    }
    function u(c){
     try{
      var
       _bY_ =
         eupdate(eval$0(caml_call2(Stdlib_List[38], occurs, emuts)), m, c);
      return _bY_;
     }
     catch(_bZ_){
      var _bX_ = caml_wrap_exception(_bZ_);
      if(_bX_ === Stdlib[8])
       throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
      throw caml_maybe_attach_backtrace(_bX_, 0);
     }
    }
    caml_call2
     (Stdlib_List[17], function(m$0){return add_dep$0(m$0, m[2]);}, emuts);
    return event(m, p, u);
   }
   function merge(f, acc, el){
    var
     match = find_muts_and_next_rank(el),
     r = match[2],
     emuts = match[1],
     m = emut(r);
    function p(param){
     return caml_call2(Stdlib_List[21], function(m){return m[2];}, emuts);
    }
    function u(c){
     var acc$0 = acc, param = emuts;
     for(;;){
      if(! param) return eupdate(acc$0, m, c);
      var m$0 = param[1], l = param[2];
      if(occurs(m$0)){
       var acc$1 = caml_call2(f, acc$0, eval$0(m$0));
       acc$0 = acc$1;
       param = l;
      }
      else{var l$0 = param[2]; param = l$0;}
     }
    }
    caml_call2
     (Stdlib_List[17], function(m$0){return add_dep$0(m$0, m[2]);}, emuts);
    return event(m, p, u);
   }
   function switch$0(e, param){
    if(! param) return e;
    var ms = param[1];
    if(e) var m = e[1], r = rsucc2(m[2], ms[2]); else var r = rsucc(ms[2]);
    var m$0 = emut(r), src = [0, e];
    function p(param){
     var match = src[1];
     if(! match) return [0, ms[2], 0];
     var m = match[1];
     return [0, m[2], [0, ms[2], 0]];
    }
    function u(c){
     var match = ms[1][1];
     if(! match){
      var match$2 = src[1];
      if(! match$2)
       throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
      var m$2 = match$2[1];
      return eupdate(eval$0(m$2), m$0, c);
     }
     var e = match[1], match$0 = src[1];
     if(match$0){var m = match$0[1]; rem_dep(m[2], m$0[2]);}
     src[1] = e;
     if(! e){var _bW_ = rsucc(ms[2]); update_rank(m$0[2], _bW_); return 0;}
     var m$1 = e[1];
     add_dep(m$1[2], m$0[2]);
     var _bV_ = rsucc2(m$1[2], ms[2]);
     if(update_rank(m$0[2], _bV_)){
      allow_reschedule(m$0[2]);
      return rebuild(c);
     }
     var match$1 = m$1[1][1];
     if(! match$1) return 0;
     var v = match$1[1];
     return eupdate(v, m$0, c);
    }
    if(e){var m$1 = e[1]; add_dep$0(m$1, m$0[2]);}
    add_dep$0(ms, m$0[2]);
    return event(m$0, p, u);
   }
   function fix(f){
    var
     m = emut(delayed_rank),
     e =
       event
        (m,
         function(param){return 0;},
         function(param){
          throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
         }),
     _bS_ = caml_call1(f, e),
     match = _bS_[1];
    if(! match){var r$0 = _bS_[2]; return r$0;}
    var r = _bS_[2], m$0 = match[1];
    if(m$0[2][1] === delayed_rank) caml_call1(Stdlib[1], err_fix);
    function p(param){return 0;}
    function u(c){
     var _bT_ = [0, eval$0(m$0)];
     m[1][1] = _bT_;
     var v = m[1];
     add_eop(c, function(_bU_){v[1] = 0; return 0;});
     return add_deps(c, m[2]);
    }
    bind(m[2], p, u);
    add_dep$0(m$0, m[2]);
    return r;
   }
   function l2(f, e0, e1){
    if(! e0) return 0;
    if(! e1) return 0;
    var m1 = e1[1], m0 = e0[1], r = rsucc2(m0[2], m1[2]), m = emut(r);
    function p(param){return [0, m0[2], [0, m1[2], 0]];}
    function u(c){
     var _bR_ = m0[1][1], match = m1[1][1];
     if(_bR_ && match){
      var v1 = match[1], v0 = _bR_[1];
      return eupdate(caml_call2(f, v0, v1), m, c);
     }
     return 0;
    }
    add_dep$0(m0, m[2]);
    add_dep$0(m1, m[2]);
    return event(m, p, u);
   }
   function l3(f, e0, e1, e2){
    if(! e0) return 0;
    if(! e1) return 0;
    if(! e2) return 0;
    var
     m2 = e2[1],
     m1 = e1[1],
     m0 = e0[1],
     _bO_ = m2[2],
     r = rsucc(rmax(rmax(m0[2], m1[2]), _bO_)),
     m = emut(r);
    function p(param){return [0, m0[2], [0, m1[2], [0, m2[2], 0]]];}
    function u(c){
     var _bP_ = m0[1][1], _bQ_ = m1[1][1], match = m2[1][1];
     if(_bP_ && _bQ_ && match){
      var v2 = match[1], v1 = _bQ_[1], v0 = _bP_[1];
      return eupdate(caml_call3(f, v0, v1, v2), m, c);
     }
     return 0;
    }
    add_dep$0(m0, m[2]);
    add_dep$0(m1, m[2]);
    add_dep$0(m2, m[2]);
    return event(m, p, u);
   }
   function l4(f, e0, e1, e2, e3){
    if(! e0) return 0;
    if(! e1) return 0;
    if(! e2) return 0;
    if(! e3) return 0;
    var
     m3 = e3[1],
     m2 = e2[1],
     m1 = e1[1],
     m0 = e0[1],
     _bK_ = rmax(m2[2], m3[2]),
     r = rsucc(rmax(rmax(m0[2], m1[2]), _bK_)),
     m = emut(r);
    function p(param){
     return [0, m0[2], [0, m1[2], [0, m2[2], [0, m3[2], 0]]]];
    }
    function u(c){
     var _bL_ = m0[1][1], _bM_ = m1[1][1], _bN_ = m2[1][1], match = m3[1][1];
     if(_bL_ && _bM_ && _bN_ && match){
      var v3 = match[1], v2 = _bN_[1], v1 = _bM_[1], v0 = _bL_[1];
      return eupdate(caml_call4(f, v0, v1, v2, v3), m, c);
     }
     return 0;
    }
    add_dep$0(m0, m[2]);
    add_dep$0(m1, m[2]);
    add_dep$0(m2, m[2]);
    add_dep$0(m3, m[2]);
    return event(m, p, u);
   }
   function l5(f, e0, e1, e2, e3, e4){
    if(! e0) return 0;
    if(! e1) return 0;
    if(! e2) return 0;
    if(! e3) return 0;
    if(! e4) return 0;
    var
     m4 = e4[1],
     m3 = e3[1],
     m2 = e2[1],
     m1 = e1[1],
     m0 = e0[1],
     _bE_ = m4[2],
     _bF_ = rmax(m2[2], m3[2]),
     r = rsucc(rmax(rmax(rmax(m0[2], m1[2]), _bF_), _bE_)),
     m = emut(r);
    function p(param){
     return [0, m0[2], [0, m1[2], [0, m2[2], [0, m3[2], [0, m4[2], 0]]]]];
    }
    function u(c){
     var
      _bG_ = m0[1][1],
      _bH_ = m1[1][1],
      _bI_ = m2[1][1],
      _bJ_ = m3[1][1],
      match = m4[1][1];
     if(_bG_ && _bH_ && _bI_ && _bJ_ && match){
      var
       v4 = match[1],
       v3 = _bJ_[1],
       v2 = _bI_[1],
       v1 = _bH_[1],
       v0 = _bG_[1];
      return eupdate(caml_call5(f, v0, v1, v2, v3, v4), m, c);
     }
     return 0;
    }
    add_dep$0(m0, m[2]);
    add_dep$0(m1, m[2]);
    add_dep$0(m2, m[2]);
    add_dep$0(m3, m[2]);
    add_dep$0(m4, m[2]);
    return event(m, p, u);
   }
   function l6(f, e0, e1, e2, e3, e4, e5){
    if(! e0) return 0;
    if(! e1) return 0;
    if(! e2) return 0;
    if(! e3) return 0;
    if(! e4) return 0;
    if(! e5) return 0;
    var
     m5 = e5[1],
     m4 = e4[1],
     m3 = e3[1],
     m2 = e2[1],
     m1 = e1[1],
     m0 = e0[1],
     _bx_ = rmax(m4[2], m5[2]),
     _by_ = rmax(m2[2], m3[2]),
     r = rsucc(rmax(rmax(rmax(m0[2], m1[2]), _by_), _bx_)),
     m = emut(r);
    function p(param){
     return [0,
             m0[2],
             [0, m1[2], [0, m2[2], [0, m3[2], [0, m4[2], [0, m5[2], 0]]]]]];
    }
    function u(c){
     var
      _bz_ = m0[1][1],
      _bA_ = m1[1][1],
      _bB_ = m2[1][1],
      _bC_ = m3[1][1],
      _bD_ = m4[1][1],
      match = m5[1][1];
     if(_bz_ && _bA_ && _bB_ && _bC_ && _bD_ && match){
      var
       v5 = match[1],
       v4 = _bD_[1],
       v3 = _bC_[1],
       v2 = _bB_[1],
       v1 = _bA_[1],
       v0 = _bz_[1];
      return eupdate(caml_call6(f, v0, v1, v2, v3, v4, v5), m, c);
     }
     return 0;
    }
    add_dep$0(m0, m[2]);
    add_dep$0(m1, m[2]);
    add_dep$0(m2, m[2]);
    add_dep$0(m3, m[2]);
    add_dep$0(m4, m[2]);
    add_dep$0(m5, m[2]);
    return event(m, p, u);
   }
   function some(e){return map(function(v){return [0, v];}, e);}
   function value(default$0, e){
    if(! default$0) return fmap(function(v){return v;}, e);
    var match = default$0[1];
    if(0 === match[0]){
     var dv = match[1];
     return map
             (function(param){
               if(! param) return dv;
               var v = param[1];
               return v;
              },
              e);
    }
    var ms = match[1];
    if(! e) return 0;
    var m = e[1], m$0 = emut(rsucc2(m[2], ms[3]));
    function p(param){return [0, m[2], [0, ms[3], 0]];}
    function u(c){
     var _bw_ = m[1][1];
     if(! _bw_) return 0;
     var match = _bw_[1];
     if(! match) return eupdate(sval(ms), m$0, c);
     var v = match[1];
     return eupdate(v, m$0, c);
    }
    add_dep$0(m, m$0[2]);
    add_dep(ms[3], m$0[2]);
    return event(m$0, p, u);
   }
   var
    Option = [0, some, value],
    _g_ = [0, cst_src_react_ml, 994, 36],
    _h_ = [0, cst_src_react_ml, 1112, 18];
   function end_of_step_add_dep(opt, stop_if_stopped, m$0, m){
    if(opt)
     var sth = opt[1], post_add_op = sth;
    else
     var post_add_op = function(param){return 0;};
    var c = find_unfinished(caml_call1(m$0[3][4], 0));
    if(c === nil){add_dep(m$0[3], m[2]); return caml_call1(post_add_op, 0);}
    function add_dep$0(param){
     if(m$0[3][5] === nop)
      return stop_if_stopped ? stop(0, m[2]) : stop_if_stopped;
     var _bv_ = rsucc(m$0[3]);
     update_rank(m[2], _bv_);
     add_dep(m$0[3], m[2]);
     return caml_call1(post_add_op, 0);
    }
    return add_eop(c, add_dep$0);
   }
   function const$0(v){return [0, v];}
   function create$3(opt, v){
    if(opt) var sth = opt[1], eq = sth; else var eq = caml_equal;
    var m = smut(min_rank, eq);
    m[1] = [0, v];
    return [0,
            [1, m],
            function(step, v){
             var _bu_ = sval(m);
             if(caml_call2(m[2], _bu_, v)) return 0;
             if(! step){
              var c$0 = create$0(0);
              m[3][2] = c$0;
              m[1] = [0, v];
              add_deps(c$0, m[3]);
              return execute(c$0);
             }
             var c = step[1];
             if(c[1])
              caml_call1(Stdlib[1], err_step_executed);
             else if(m[3][2][1])
              m[3][2] = c;
             else
              caml_call1(Stdlib[1], err_signal_scheduled);
             m[1] = [0, v];
             return add_deps(c, m[3]);
            }];
   }
   function retain$0(s, c){
    if(0 === s[0]) return caml_call1(Stdlib[1], err_retain_cst_sig);
    var m = s[1], c$0 = m[3][3];
    m[3][3] = c;
    return [0, 82, c$0];
   }
   function eq_fun(param){
    if(0 === param[0]) return 0;
    var m = param[1];
    return [0, m[2]];
   }
   function value$0(param){
    if(0 === param[0])
     var v = param[1];
    else{
     var _bt_ = param[1][1];
     if(! _bt_) return caml_call1(Stdlib[2], err_sig_undef);
     var v = _bt_[1];
    }
    return v;
   }
   function stop$1(strong, param){
    if(0 === param[0]) return 0;
    var m = param[1];
    if(m[1]) return stop(strong, m[3]);
    var c = find_unfinished(caml_call1(m[3][4], 0));
    if(c === nil)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
    function stop$0(param){return stop(strong, m[3]);}
    return add_eop(c, stop$0);
   }
   function equal$0(opt, s$0, s){
    if(opt) var sth = opt[1], eq = sth; else var eq = caml_equal;
    if(0 === s$0[0]){
     var v = s$0[1];
     if(0 === s[0]){var v$0 = s[1]; return caml_call2(eq, v, v$0);}
    }
    else{
     var m = s$0[1];
     if(0 !== s[0]){var m$0 = s[1]; return m === m$0 ? 1 : 0;}
    }
    return 0;
   }
   function trace$0(opt, t, s){
    if(opt) var sth = opt[1], iff = sth; else var iff = [0, 1];
    if(0 === iff[0]){
     if(! iff[1]) return s;
     if(0 === s[0]){var v = s[1]; caml_call1(t, v); return s;}
     var
      m = s[1],
      _br_ = m[2],
      m$0 = smut(rsucc(m[3]), _br_),
      p = function(param){return [0, m[3], 0];},
      u =
        function(c){
         var v = sval(m);
         caml_call1(t, v);
         return supdate(v, m$0, c);
        };
     add_dep(m[3], m$0[3]);
     return signal(0, m$0, p, u);
    }
    var mc = iff[1];
    if(0 === s[0]){
     var
      v$0 = s[1],
      m$1 = smut(rsucc(mc[3]), caml_equal),
      p$0 = function(param){return [0, mc[3], 0];},
      u$0 =
        function(c){
         if(sval(mc)) caml_call1(t, v$0);
         rem_dep(mc[3], m$1[3]);
         return stop(0, m$1[3]);
        };
     add_dep(mc[3], m$1[3]);
     return signal([0, v$0], m$1, p$0, u$0);
    }
    var m$2 = s[1], _bs_ = m$2[2], m$3 = smut(rsucc2(mc[3], m$2[3]), _bs_);
    function p$1(param){return [0, mc[3], [0, m$2[3], 0]];}
    function u$1(c){
     var v = sval(m$2), match = m$3[1];
     if(match){var v$0 = match[1]; if(caml_call2(m$3[2], v, v$0)) return 0;}
     if(sval(mc)) caml_call1(t, v);
     return supdate(v, m$3, c);
    }
    add_dep(mc[3], m$3[3]);
    add_dep(m$2[3], m$3[3]);
    return signal(0, m$3, p$1, u$1);
   }
   function hold(opt, i, param){
    if(opt) var sth = opt[1], eq = sth; else var eq = caml_equal;
    if(! param) return [0, i];
    var m = param[1], m$0 = smut(rsucc(m[2]), eq);
    function p(param){return [0, m[2], 0];}
    function u(c){
     var match = m[1][1];
     if(! match) return 0;
     var v = match[1];
     return supdate(v, m$0, c);
    }
    add_dep$0(m, m$0[3]);
    return signal([0, i], m$0, p, u);
   }
   function map$0(opt, f, param){
    if(opt) var sth = opt[1], eq = sth; else var eq = caml_equal;
    if(0 === param[0]){var v = param[1]; return [0, caml_call1(f, v)];}
    var m = param[1], m$0 = smut(rsucc(m[3]), eq);
    function p(param){return [0, m[3], 0];}
    function u(c){return supdate(caml_call1(f, sval(m)), m$0, c);}
    add_dep(m[3], m$0[3]);
    return signal(0, m$0, p, u);
   }
   function app$0(opt, sf, sv){
    if(opt) var sth = opt[1], eq = sth; else var eq = caml_equal;
    if(0 === sf[0]){
     var f = sf[1];
     if(0 !== sv[0]) return map$0([0, eq], f, sv);
     var v = sv[1];
     return [0, caml_call1(f, v)];
    }
    var mf = sf[1];
    if(0 === sv[0]){
     var
      v$0 = sv[1],
      m = smut(rsucc(mf[3]), eq),
      p = function(param){return [0, mf[3], 0];},
      u = function(c){return supdate(caml_call1(sval(mf), v$0), m, c);};
     add_dep(mf[3], m[3]);
     return signal(0, m, p, u);
    }
    var mv = sv[1], m$0 = smut(rsucc2(mf[3], mv[3]), eq);
    function p$0(param){return [0, mf[3], [0, mv[3], 0]];}
    function u$0(c){
     var _bq_ = sval(mv);
     return supdate(caml_call1(sval(mf), _bq_), m$0, c);
    }
    add_dep(mf[3], m$0[3]);
    add_dep(mv[3], m$0[3]);
    return signal(0, m$0, p$0, u$0);
   }
   function filter$0(opt, pred, i, s){
    if(opt) var sth = opt[1], eq = sth; else var eq = caml_equal;
    if(0 === s[0]){var v = s[1]; return caml_call1(pred, v) ? s : [0, i];}
    var m = s[1], m$0 = smut(rsucc(m[3]), eq);
    function p(param){return [0, m[3], 0];}
    function u(c){
     var v = sval(m);
     return caml_call1(pred, v) ? supdate(v, m$0, c) : 0;
    }
    add_dep(m[3], m$0[3]);
    return signal([0, i], m$0, p, u);
   }
   function fmap$0(opt, fm, i, param){
    if(opt) var sth = opt[1], eq = sth; else var eq = caml_equal;
    if(0 !== param[0]){
     var
      m = param[1],
      m$0 = smut(rsucc(m[3]), eq),
      p = function(param){return [0, m[3], 0];},
      u =
        function(c){
         var match = caml_call1(fm, sval(m));
         if(! match) return 0;
         var v = match[1];
         return supdate(v, m$0, c);
        };
     add_dep(m[3], m$0[3]);
     return signal([0, i], m$0, p, u);
    }
    var v = param[1], match = caml_call1(fm, v);
    if(! match) return [0, i];
    var v$0 = match[1];
    return [0, v$0];
   }
   function diff$0(d, param){
    if(0 === param[0]) return 0;
    var m = param[1], m$0 = emut(rsucc(m[3])), last = [0, 0];
    function p(param){return [0, m[3], 0];}
    function u(c){
     var v = sval(m), match = last[1];
     if(! match)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _h_], 1);
     var v$0 = match[1];
     last[1] = [0, v];
     return eupdate(caml_call2(d, v, v$0), m$0, c);
    }
    function post_add_op(param){last[1] = [0, sval(m)]; return 0;}
    end_of_step_add_dep([0, post_add_op], 1, m, m$0);
    return event(m$0, p, u);
   }
   function changes$0(param){
    if(0 === param[0]) return 0;
    var m = param[1], m$0 = emut(rsucc(m[3]));
    function p(param){return [0, m[3], 0];}
    function u(c){return eupdate(sval(m), m$0, c);}
    end_of_step_add_dep(0, 1, m, m$0);
    return event(m$0, p, u);
   }
   function sample(f, e, param){
    if(0 === param[0]){
     var v = param[1];
     return map(function(ev){return caml_call2(f, ev, v);}, e);
    }
    var ms = param[1];
    if(! e) return 0;
    var me = e[1], m = emut(rsucc2(me[2], ms[3]));
    function p(param){return [0, me[2], [0, ms[3], 0]];}
    function u(c){
     var match = me[1][1];
     if(! match) return 0;
     var v = match[1];
     return eupdate(caml_call2(f, v, sval(ms)), m, c);
    }
    add_dep$0(me, m[2]);
    add_dep(ms[3], m[2]);
    return event(m, p, u);
   }
   function on$0(opt, c, i, s){
    if(opt) var sth = opt[1], eq = sth; else var eq = caml_equal;
    if(0 === c[0]) return c[1] ? s : [0, i];
    var mc = c[1];
    if(0 === s[0]){
     var
      v = s[1],
      m = smut(rsucc(mc[3]), eq),
      p = function(param){return [0, mc[3], 0];},
      u = function(c){return sval(mc) ? supdate(v, m, c) : 0;};
     add_dep(mc[3], m[3]);
     return signal([0, i], m, p, u);
    }
    var ms = s[1], m$0 = smut(rsucc2(mc[3], ms[3]), eq);
    function p$0(param){return [0, mc[3], [0, ms[3], 0]];}
    function u$0(c){return sval(mc) ? supdate(sval(ms), m$0, c) : 0;}
    add_dep(mc[3], m$0[3]);
    add_dep(ms[3], m$0[3]);
    return signal([0, i], m$0, p$0, u$0);
   }
   function dismiss$0(opt, c, i, s){
    if(opt) var sth = opt[1], eq = sth; else var eq = caml_equal;
    if(! c) return s;
    var mc = c[1];
    if(0 === s[0]){
     var
      v = s[1],
      m = smut(rsucc(mc[2]), eq),
      p = function(param){return [0, mc[2], 0];},
      u = function(c){return mc[1][1] ? 0 : supdate(v, m, c);};
     add_dep(mc[2], m[3]);
     return signal([0, i], m, p, u);
    }
    var ms = s[1], m$0 = smut(rsucc2(mc[2], ms[3]), eq);
    function p$0(param){return [0, mc[2], [0, ms[3], 0]];}
    function u$0(c){return mc[1][1] ? 0 : supdate(sval(ms), m$0, c);}
    add_dep(mc[2], m$0[3]);
    add_dep(ms[3], m$0[3]);
    return signal([0, i], m$0, p$0, u$0);
   }
   function accum$0(opt, ef, i){
    if(opt) var sth = opt[1], eq = sth; else var eq = caml_equal;
    if(! ef) return [0, i];
    var m = ef[1], m$0 = smut(rsucc(m[2]), eq);
    function p(param){return [0, m[2], 0];}
    function u(c){
     var match = m[1][1];
     if(! match) return 0;
     var v = match[1];
     return supdate(caml_call1(v, sval(m$0)), m$0, c);
    }
    add_dep$0(m, m$0[3]);
    return signal([0, i], m$0, p, u);
   }
   function fold$1(opt, f, i, param){
    if(opt) var sth = opt[1], eq = sth; else var eq = caml_equal;
    if(! param) return [0, i];
    var m = param[1], m$0 = smut(rsucc(m[2]), eq);
    function p(param){return [0, m[2], 0];}
    function u(c){
     var match = m[1][1];
     if(! match) return 0;
     var v = match[1];
     return supdate(caml_call2(f, sval(m$0), v), m$0, c);
    }
    add_dep$0(m, m$0[3]);
    return signal([0, i], m$0, p, u);
   }
   function merge$0(opt, f, a, sl){
    if(opt) var sth = opt[1], eq = sth; else var eq = caml_equal;
    function rmax$0(acc, param){
     if(0 === param[0]) return acc;
     var m = param[1];
     return rmax(acc, m[3]);
    }
    function nodes(acc, param){
     if(0 === param[0]) return acc;
     var m = param[1];
     return [0, m[3], acc];
    }
    var m = smut(rsucc(caml_call3(Stdlib_List[25], rmax$0, rmin, sl)), eq);
    function p(param){return caml_call3(Stdlib_List[25], nodes, 0, sl);}
    function u(c){
     return supdate
             (caml_call3
               (Stdlib_List[25],
                function(a, param){
                 if(0 === param[0]){
                  var v = param[1];
                  return caml_call2(f, a, v);
                 }
                 var m = param[1];
                 return caml_call2(f, a, sval(m));
                },
                a,
                sl),
              m,
              c);
    }
    function dep(param){
     if(0 === param[0]) return 0;
     var m$0 = param[1];
     return add_dep(m$0[3], m[3]);
    }
    caml_call2(Stdlib_List[17], dep, sl);
    return signal(0, m, p, u);
   }
   function switch$1(opt, param){
    if(opt) var sth = opt[1], eq = sth; else var eq = caml_equal;
    if(0 === param[0]){var s = param[1]; return s;}
    var
     mss = param[1],
     dummy = smut(min_rank, eq),
     src = [0, [1, dummy]],
     m = smut(rsucc(mss[3]), eq);
    function p(param){
     var match = src[1];
     if(0 === match[0]) return [0, mss[3], 0];
     var m = match[1];
     return [0, mss[3], [0, m[3], 0]];
    }
    function u(c){
     var _bm_ = src[1];
     if(sval(mss) === _bm_){
      var match = src[1];
      if(0 === match[0]) return 0;
      var m$0 = match[1];
      return supdate(sval(m$0), m, c);
     }
     var match$0 = src[1];
     if(0 !== match$0[0]){var m$2 = match$0[1]; rem_dep(m$2[3], m[3]);}
     var new_src = sval(mss);
     src[1] = new_src;
     if(0 === new_src[0]){
      var v = new_src[1], _bn_ = rsucc(mss[3]);
      update_rank(m[3], _bn_);
      return supdate(v, m, c);
     }
     var m$1 = new_src[1];
     add_dep(m$1[3], m[3]);
     if(c === nil){
      var _bo_ = rsucc2(m$1[3], mss[3]);
      update_rank(m[3], _bo_);
      var c$0 = find_unfinished([0, m$1[3], 0]);
      return c$0 === nil ? supdate(sval(m$1), m, c$0) : add$0(c$0, m[3]);
     }
     var _bp_ = rsucc2(m$1[3], mss[3]);
     return update_rank(m[3], _bp_)
             ? (allow_reschedule(m[3]), rebuild(c), add$0(c, m[3]))
             : supdate(sval(m$1), m, c);
    }
    add_dep(mss[3], m[3]);
    add_dep(dummy[3], m[3]);
    return signal(0, m, p, u);
   }
   function bind$0(eq, s, sf){
    return switch$1
            (eq,
             map$0
              ([0, function(_bl_, _bk_){return _bl_ === _bk_ ? 1 : 0;}],
               sf,
               s));
   }
   function fix$0(opt, i, f){
    if(opt) var sth = opt[1], eq = sth; else var eq = caml_equal;
    function update_delayed(n, p, u, nl){
     bind(n, p, u);
     var c = find_unfinished(nl);
     if(c !== nil) return add$0(c, n);
     var c$0 = create$0(0);
     caml_call1(n[5], c$0);
     return execute(c$0);
    }
    var
     m = smut(delayed_rank, eq),
     s =
       signal
        ([0, i], m, function(param){return 0;}, function(param){return 0;}),
     _bh_ = caml_call1(f, s),
     match = _bh_[1];
    if(0 === match[0]){
     var
      r = _bh_[2],
      v = match[1],
      p = function(param){return 0;},
      u = function(c){return supdate(v, m, c);},
      _bi_ = deps(m[3]);
     update_delayed(m[3], p, u, _bi_);
     return r;
    }
    var r$0 = _bh_[2], m$0 = match[1];
    if(m$0[3][1] === delayed_rank) caml_call1(Stdlib[1], err_fix);
    function p$0(param){return 0;}
    function u$0(c){return supdate(sval(m$0), m, c);}
    add_dep(m$0[3], m[3]);
    var _bj_ = deps(m[3]);
    update_delayed(m[3], p$0, u$0, [0, m$0[3], _bj_]);
    return r$0;
   }
   function l2$0(opt, f, s$0, s){
    if(opt) var sth = opt[1], eq = sth; else var eq = caml_equal;
    if(0 === s$0[0]){
     var v = s$0[1];
     if(0 === s[0]){var v$0 = s[1]; return [0, caml_call2(f, v, v$0)];}
     var
      m = s[1],
      m$0 = smut(rsucc(m[3]), eq),
      p = function(param){return [0, m[3], 0];},
      u = function(c){return supdate(caml_call2(f, v, sval(m)), m$0, c);};
     add_dep(m[3], m$0[3]);
     return signal(0, m$0, p, u);
    }
    var m0 = s$0[1];
    if(0 === s[0]){
     var
      v$1 = s[1],
      m$1 = smut(rsucc(m0[3]), eq),
      p$0 = function(param){return [0, m0[3], 0];},
      u$0 = function(c){return supdate(caml_call2(f, sval(m0), v$1), m$1, c);};
     add_dep(m0[3], m$1[3]);
     return signal(0, m$1, p$0, u$0);
    }
    var m1 = s[1], m$2 = smut(rsucc2(m0[3], m1[3]), eq);
    function p$1(param){return [0, m0[3], [0, m1[3], 0]];}
    function u$1(c){
     var _bg_ = sval(m1);
     return supdate(caml_call2(f, sval(m0), _bg_), m$2, c);
    }
    add_dep(m0[3], m$2[3]);
    add_dep(m1[3], m$2[3]);
    return signal(0, m$2, p$1, u$1);
   }
   function l3$0(opt, f, s0, s1, s2){
    if(opt) var sth = opt[1], eq = sth; else var eq = caml_equal;
    if(0 === s0[0]){
     var v0 = s0[1];
     if(0 === s1[0]){
      var v1 = s1[1];
      if(0 === s2[0]){var v2 = s2[1]; return [0, caml_call3(f, v0, v1, v2)];}
     }
    }
    else{
     var m0 = s0[1];
     if(0 !== s1[0]){
      var m1 = s1[1];
      if(0 !== s2[0]){
       var
        m2 = s2[1],
        _bb_ = m2[3],
        r = rsucc(rmax(rmax(m0[3], m1[3]), _bb_)),
        m = smut(r, eq),
        p = function(param){return [0, m0[3], [0, m1[3], [0, m2[3], 0]]];},
        u =
          function(c){
           var _be_ = sval(m2), _bf_ = sval(m1);
           return supdate(caml_call3(f, sval(m0), _bf_, _be_), m, c);
          };
       add_dep(m0[3], m[3]);
       add_dep(m1[3], m[3]);
       add_dep(m2[3], m[3]);
       return signal(0, m, p, u);
      }
     }
    }
    return app$0
            ([0, eq],
             l2$0
              ([0, function(_bd_, _bc_){return _bd_ === _bc_ ? 1 : 0;}],
               f,
               s0,
               s1),
             s2);
   }
   function l4$0(opt, f, s0, s1, s2, s3){
    if(opt) var sth = opt[1], eq = sth; else var eq = caml_equal;
    if(0 === s0[0]){
     var v0 = s0[1];
     if(0 === s1[0]){
      var v1 = s1[1];
      if(0 === s2[0]){
       var v2 = s2[1];
       if(0 === s3[0]){
        var v3 = s3[1];
        return [0, caml_call4(f, v0, v1, v2, v3)];
       }
      }
     }
    }
    else{
     var m0 = s0[1];
     if(0 !== s1[0]){
      var m1 = s1[1];
      if(0 !== s2[0]){
       var m2 = s2[1];
       if(0 !== s3[0]){
        var
         m3 = s3[1],
         _a7_ = rmax(m2[3], m3[3]),
         r = rsucc(rmax(rmax(m0[3], m1[3]), _a7_)),
         m = smut(r, eq),
         p =
           function(param){
            return [0, m0[3], [0, m1[3], [0, m2[3], [0, m3[3], 0]]]];
           },
         u =
           function(c){
            var _a__ = sval(m3), _a$_ = sval(m2), _ba_ = sval(m1);
            return supdate(caml_call4(f, sval(m0), _ba_, _a$_, _a__), m, c);
           };
        add_dep(m0[3], m[3]);
        add_dep(m1[3], m[3]);
        add_dep(m2[3], m[3]);
        add_dep(m3[3], m[3]);
        return signal(0, m, p, u);
       }
      }
     }
    }
    return app$0
            ([0, eq],
             l3$0
              ([0, function(_a9_, _a8_){return _a9_ === _a8_ ? 1 : 0;}],
               f,
               s0,
               s1,
               s2),
             s3);
   }
   function l5$0(opt, f, s0, s1, s2, s3, s4){
    if(opt) var sth = opt[1], eq = sth; else var eq = caml_equal;
    if(0 === s0[0]){
     var v0 = s0[1];
     if(0 === s1[0]){
      var v1 = s1[1];
      if(0 === s2[0]){
       var v2 = s2[1];
       if(0 === s3[0]){
        var v3 = s3[1];
        if(0 === s4[0]){
         var v4 = s4[1];
         return [0, caml_call5(f, v0, v1, v2, v3, v4)];
        }
       }
      }
     }
    }
    else{
     var m0 = s0[1];
     if(0 !== s1[0]){
      var m1 = s1[1];
      if(0 !== s2[0]){
       var m2 = s2[1];
       if(0 !== s3[0]){
        var m3 = s3[1];
        if(0 !== s4[0]){
         var
          m4 = s4[1],
          _aZ_ = rmax(m3[3], m4[3]),
          _a0_ = rmax(m2[3], _aZ_),
          r = rsucc(rmax(rmax(m0[3], m1[3]), _a0_)),
          m = smut(r, eq),
          p =
            function(param){
             return [0,
                     m0[3],
                     [0, m1[3], [0, m2[3], [0, m3[3], [0, m4[3], 0]]]]];
            },
          u =
            function(c){
             var
              _a3_ = sval(m4),
              _a4_ = sval(m3),
              _a5_ = sval(m2),
              _a6_ = sval(m1),
              v = caml_call5(f, sval(m0), _a6_, _a5_, _a4_, _a3_);
             return supdate(v, m, c);
            };
         add_dep(m0[3], m[3]);
         add_dep(m1[3], m[3]);
         add_dep(m2[3], m[3]);
         add_dep(m3[3], m[3]);
         add_dep(m4[3], m[3]);
         return signal(0, m, p, u);
        }
       }
      }
     }
    }
    return app$0
            ([0, eq],
             l4$0
              ([0, function(_a2_, _a1_){return _a2_ === _a1_ ? 1 : 0;}],
               f,
               s0,
               s1,
               s2,
               s3),
             s4);
   }
   function l6$0(opt, f, s0, s1, s2, s3, s4, s5){
    if(opt) var sth = opt[1], eq = sth; else var eq = caml_equal;
    if(0 === s0[0]){
     var v0 = s0[1];
     if(0 === s1[0]){
      var v1 = s1[1];
      if(0 === s2[0]){
       var v2 = s2[1];
       if(0 === s3[0]){
        var v3 = s3[1];
        if(0 === s4[0]){
         var v4 = s4[1];
         if(0 === s5[0]){
          var v5 = s5[1];
          return [0, caml_call6(f, v0, v1, v2, v3, v4, v5)];
         }
        }
       }
      }
     }
    }
    else{
     var m0 = s0[1];
     if(0 !== s1[0]){
      var m1 = s1[1];
      if(0 !== s2[0]){
       var m2 = s2[1];
       if(0 !== s3[0]){
        var m3 = s3[1];
        if(0 !== s4[0]){
         var m4 = s4[1];
         if(0 !== s5[0]){
          var
           m5 = s5[1],
           _aP_ = rmax(m4[3], m5[3]),
           _aQ_ = rmax(m3[3], _aP_),
           _aR_ = rmax(m1[3], m2[3]),
           m = rmax(rmax(m0[3], _aR_), _aQ_),
           m$0 = smut(rsucc(m), eq),
           p =
             function(param){
              return [0,
                      m0[3],
                      [0,
                       m1[3],
                       [0, m2[3], [0, m3[3], [0, m4[3], [0, m5[3], 0]]]]]];
             },
           u =
             function(c){
              var
               _aU_ = sval(m5),
               _aV_ = sval(m4),
               _aW_ = sval(m3),
               _aX_ = sval(m2),
               _aY_ = sval(m1),
               v = caml_call6(f, sval(m0), _aY_, _aX_, _aW_, _aV_, _aU_);
              return supdate(v, m$0, c);
             };
          add_dep(m0[3], m$0[3]);
          add_dep(m1[3], m$0[3]);
          add_dep(m2[3], m$0[3]);
          add_dep(m3[3], m$0[3]);
          add_dep(m4[3], m$0[3]);
          add_dep(m5[3], m$0[3]);
          return signal(0, m$0, p, u);
         }
        }
       }
      }
     }
    }
    return app$0
            ([0, eq],
             l5$0
              ([0, function(_aT_, _aS_){return _aT_ === _aS_ ? 1 : 0;}],
               f,
               s0,
               s1,
               s2,
               s3,
               s4),
             s5);
   }
   function stdlib_not(_aO_){return 1 - _aO_;}
   function equal$1(_aN_, _aM_){return _aN_ === _aM_ ? 1 : 0;}
   function not(s){return map$0([0, equal$1], stdlib_not, s);}
   function symbol(s$0, s){
    return l2$0
            ([0, equal$1],
             function(_aK_, _aJ_){var _aL_ = _aK_ ? _aJ_ : _aK_; return _aL_;},
             s$0,
             s);
   }
   function symbol$0(s$0, s){
    return l2$0
            ([0, equal$1],
             function(_aH_, _aG_){var _aI_ = _aH_ || _aG_; return _aI_;},
             s$0,
             s);
   }
   function edge(s){return changes$0(s);}
   function edge_detect(edge, param){
    if(0 === param[0]) return 0;
    var m = param[1], m$0 = emut(rsucc(m[3]));
    function p(param){return [0, m[3], 0];}
    function u(c){
     var _aF_ = caml_equal(sval(m), edge);
     return _aF_ ? eupdate(0, m$0, c) : _aF_;
    }
    end_of_step_add_dep(0, 1, m, m$0);
    return event(m$0, p, u);
   }
   function rise(s){return edge_detect(1, s);}
   function fall(s){return edge_detect(0, s);}
   function flip(b, param){
    if(! param) return [0, b];
    var
     m = param[1],
     m$0 =
       smut(rsucc(m[2]), function(_aE_, _aD_){return _aE_ === _aD_ ? 1 : 0;});
    function p(param){return [0, m[2], 0];}
    function u(c){return m[1][1] ? supdate(1 - sval(m$0), m$0, c) : 0;}
    add_dep$0(m, m$0[3]);
    return signal([0, b], m$0, p, u);
   }
   function equal$2(_aC_, _aB_){return _aC_ === _aB_ ? 1 : 0;}
   function symbol$1(s){
    return map$0([0, equal$2], function(_aA_){return - _aA_ | 0;}, s);
   }
   function succ(s){
    return map$0([0, equal$2], function(_az_){return _az_ + 1 | 0;}, s);
   }
   function pred(s){
    return map$0([0, equal$2], function(_ay_){return _ay_ - 1 | 0;}, s);
   }
   function symbol$2(s$0, s){
    return l2$0
            ([0, equal$2],
             function(_ax_, _aw_){return _ax_ + _aw_ | 0;},
             s$0,
             s);
   }
   function symbol$3(s$0, s){
    return l2$0
            ([0, equal$2],
             function(_av_, _au_){return _av_ - _au_ | 0;},
             s$0,
             s);
   }
   function symbol$4(s$0, s){
    return l2$0([0, equal$2], runtime.caml_mul, s$0, s);
   }
   function mod(s$0, s){return l2$0([0, equal$2], runtime.caml_mod, s$0, s);}
   function abs(s){return map$0([0, equal$2], Stdlib[18], s);}
   var v = Stdlib[19], max_int = [0, v], v$0 = Stdlib[20], min_int = [0, v$0];
   function land(s$0, s){
    return l2$0
            ([0, equal$2], function(_at_, _as_){return _at_ & _as_;}, s$0, s);
   }
   function lor(s$0, s){
    return l2$0
            ([0, equal$2], function(_ar_, _aq_){return _ar_ | _aq_;}, s$0, s);
   }
   function lxor(s$0, s){
    return l2$0
            ([0, equal$2], function(_ap_, _ao_){return _ap_ ^ _ao_;}, s$0, s);
   }
   function lnot(s){return map$0([0, equal$2], Stdlib[21], s);}
   function lsl(s$0, s){
    return l2$0
            ([0, equal$2], function(_an_, _am_){return _an_ << _am_;}, s$0, s);
   }
   function lsr(s$0, s){
    return l2$0
            ([0, equal$2],
             function(_al_, _ak_){return _al_ >>> _ak_ | 0;},
             s$0,
             s);
   }
   function asr(s$0, s){
    return l2$0
            ([0, equal$2], function(_aj_, _ai_){return _aj_ >> _ai_;}, s$0, s);
   }
   function equal$3(_ah_, _ag_){return _ah_ == _ag_ ? 1 : 0;}
   function symbol$5(s){
    return map$0([0, equal$3], function(_af_){return - _af_;}, s);
   }
   function symbol$6(s$0, s){
    return l2$0
            ([0, equal$3], function(_ae_, _ad_){return _ae_ + _ad_;}, s$0, s);
   }
   function symbol$7(s$0, s){
    return l2$0
            ([0, equal$3], function(_ac_, _ab_){return _ac_ - _ab_;}, s$0, s);
   }
   function symbol$8(s$0, s){
    return l2$0([0, equal$3], function(_aa_, _$_){return _aa_ * _$_;}, s$0, s);
   }
   function symbol$9(s$0, s){
    return l2$0([0, equal$3], function(___, _Z_){return ___ / _Z_;}, s$0, s);
   }
   function symbol$10(s$0, s){
    return l2$0
            ([0, equal$3],
             function(_Y_, _X_){return Math.pow(_Y_, _X_);},
             s$0,
             s);
   }
   function sqrt(s){
    return map$0([0, equal$3], function(_W_){return Math.sqrt(_W_);}, s);
   }
   function exp(s){
    return map$0([0, equal$3], function(_V_){return Math.exp(_V_);}, s);
   }
   function log(s){
    return map$0([0, equal$3], function(_U_){return Math.log(_U_);}, s);
   }
   function log10(s){return map$0([0, equal$3], runtime.caml_log10_float, s);}
   function cos(s){
    return map$0([0, equal$3], function(_T_){return Math.cos(_T_);}, s);
   }
   function sin(s){
    return map$0([0, equal$3], function(_S_){return Math.sin(_S_);}, s);
   }
   function tan(s){
    return map$0([0, equal$3], function(_R_){return Math.tan(_R_);}, s);
   }
   function acos(s){
    return map$0([0, equal$3], function(_Q_){return Math.acos(_Q_);}, s);
   }
   function asin(s){
    return map$0([0, equal$3], function(_P_){return Math.asin(_P_);}, s);
   }
   function atan(s){
    return map$0([0, equal$3], function(_O_){return Math.atan(_O_);}, s);
   }
   function atan2(s$0, s){
    return l2$0
            ([0, equal$3],
             function(_N_, _M_){return Math.atan2(_N_, _M_);},
             s$0,
             s);
   }
   function cosh(s){return map$0([0, equal$3], runtime.caml_cosh_float, s);}
   function sinh(s){return map$0([0, equal$3], runtime.caml_sinh_float, s);}
   function tanh(s){return map$0([0, equal$3], runtime.caml_tanh_float, s);}
   function ceil(s){
    return map$0([0, equal$3], function(_L_){return Math.ceil(_L_);}, s);
   }
   function floor(s){
    return map$0([0, equal$3], function(_K_){return Math.floor(_K_);}, s);
   }
   function abs_float(s){
    return map$0([0, equal$3], function(_J_){return Math.abs(_J_);}, s);
   }
   function mod_float(s$0, s){
    return l2$0([0, equal$3], function(_I_, _H_){return _I_ % _H_;}, s$0, s);
   }
   function frexp(s){
    return map$0([0, caml_equal], runtime.caml_frexp_float, s);
   }
   function ldexp(s$0, s){
    return l2$0([0, equal$3], runtime.caml_ldexp_float, s$0, s);
   }
   function modf(s){
    return map$0([0, caml_equal], runtime.caml_modf_float, s);
   }
   function float$0(s){
    return map$0([0, equal$3], function(_G_){return _G_;}, s);
   }
   function float_of_int(s){
    return map$0([0, equal$3], function(_F_){return _F_;}, s);
   }
   function truncate(s){
    return map$0([0, equal$2], function(_E_){return _E_ | 0;}, s);
   }
   function int_of_float(s){
    return map$0([0, equal$2], function(_D_){return _D_ | 0;}, s);
   }
   var
    v$1 = Stdlib[22],
    infinity = [0, v$1],
    v$2 = Stdlib[23],
    neg_infinity = [0, v$2],
    v$3 = Stdlib[24],
    nan = [0, v$3],
    v$4 = Stdlib[25],
    max_float = [0, v$4],
    v$5 = Stdlib[26],
    min_float = [0, v$5],
    v$6 = Stdlib[27],
    epsilon_float = [0, v$6];
   function classify_float(s){
    return map$0
            ([0, function(_C_, _B_){return _C_ === _B_ ? 1 : 0;}],
             runtime.caml_classify_float,
             s);
   }
   function pair(eq, s$0, s){
    return l2$0(eq, function(x, y){return [0, x, y];}, s$0, s);
   }
   function fst(eq, s){return map$0(eq, function(_A_){return _A_[1];}, s);}
   function snd(eq, s){return map$0(eq, function(_z_){return _z_[2];}, s);}
   var Pair = [0, pair, fst, snd], _i_ = [0, cst_src_react_ml, 1526, 17];
   function some$0(s){
    var match = eq_fun(s);
    if(match)
     var
      eq = match[1],
      eq$0 =
        function(v$0, v){
         if(v$0 && v){
          var v$1 = v[1], v$2 = v$0[1];
          return caml_call2(eq, v$2, v$1);
         }
         throw caml_maybe_attach_backtrace([0, Assert_failure, _i_], 1);
        },
      eq$1 = [0, eq$0];
    else
     var eq$1 = 0;
    return map$0(eq$1, function(v){return [0, v];}, s);
   }
   function value$1(opt, default$0, s){
    if(opt) var sth = opt[1], eq = sth; else var eq = caml_equal;
    if(0 === s[0]){
     var match = s[1];
     if(match){var v = match[1]; return [0, v];}
     if(815032112 > default$0[1]){var d$1 = default$0[2]; return d$1;}
     var d = default$0[2];
     if(0 === d[0]){var d$0 = d[1]; return [0, d$0];}
     var md = d[1], c = find_unfinished([0, md[3], 0]);
     if(c === nil) return [0, sval(md)];
     var
      m = smut(rsucc(md[3]), eq),
      p = function(param){return [0, md[3], 0];},
      u =
        function(c){
         rem_dep(md[3], m[3]);
         supdate(sval(md), m, c);
         return stop(0, m[3]);
        };
     add_dep(md[3], m[3]);
     return signal(0, m, p, u);
    }
    var m$0 = s[1];
    if(815032112 <= default$0[1]){
     var match$0 = default$0[2];
     if(0 === match$0[0]){
      var d$2 = match$0[1];
      return fmap$0([0, eq], function(v){return v;}, d$2, s);
     }
     var md$0 = match$0[1], c$0 = find_unfinished([0, md$0[3], 0]);
     if(c$0 === nil){
      var
       m$1 = smut(rsucc(m$0[3]), eq),
       p$0 = function(param){return [0, m$0[3], 0];},
       u$0 =
         function(c){
          var match = sval(m$0);
          if(! match) return 0;
          var v = match[1];
          return supdate(v, m$1, c);
         };
      add_dep(m$0[3], m$1[3]);
      return signal([0, sval(md$0)], m$1, p$0, u$0);
     }
     var
      m$2 = smut(rsucc2(m$0[3], md$0[3]), eq),
      p$1 = function(param){return [0, m$0[3], 0];},
      u$1 =
        function(c){
         var match = sval(m$0);
         if(! match) return 0;
         var v = match[1];
         return supdate(v, m$2, c);
        },
      p_first = function(param){return [0, m$0[3], [0, md$0[3], 0]];},
      u_first =
        function(c){
         rem_dep(md$0[3], m$2[3]);
         var match = sval(m$0);
         if(match){
          var v = match[1];
          supdate(v, m$2, c);
         }
         else
          supdate(sval(md$0), m$2, c);
         return bind(m$2[3], p$1, u$1);
        };
     add_dep(m$0[3], m$2[3]);
     add_dep(md$0[3], m$2[3]);
     return signal(0, m$2, p_first, u_first);
    }
    var match$1 = default$0[2];
    if(0 === match$1[0]){
     var d$3 = match$1[1];
     return map$0
             ([0, eq],
              function(param){
               if(! param) return d$3;
               var v = param[1];
               return v;
              },
              s);
    }
    var md$1 = match$1[1], m$3 = smut(rsucc2(m$0[3], md$1[3]), eq);
    function p$2(param){return [0, m$0[3], [0, md$1[3], 0]];}
    function u$2(c){
     var match = sval(m$0);
     if(! match) return supdate(sval(md$1), m$3, c);
     var v = match[1];
     return supdate(v, m$3, c);
    }
    add_dep(m$0[3], m$3[3]);
    add_dep(md$1[3], m$3[3]);
    return signal(0, m$3, p$2, u$2);
   }
   var Option$0 = [0, none, some$0, value$1];
   function symbol$11(s$0, s){return l2$0([0, equal$1], caml_equal, s$0, s);}
   function symbol$12(s$0, s){
    return l2$0([0, equal$1], runtime.caml_notequal, s$0, s);
   }
   function symbol$13(s$0, s){
    return l2$0([0, equal$1], runtime.caml_lessthan, s$0, s);
   }
   function symbol$14(s$0, s){
    return l2$0([0, equal$1], runtime.caml_greaterthan, s$0, s);
   }
   function symbol$15(s$0, s){
    return l2$0([0, equal$1], runtime.caml_lessequal, s$0, s);
   }
   function symbol$16(s$0, s){
    return l2$0([0, equal$1], runtime.caml_greaterequal, s$0, s);
   }
   function compare(s$0, s){
    return l2$0([0, equal$2], runtime.caml_compare, s$0, s);
   }
   function symbol$17(s$0, s){
    return l2$0
            ([0, equal$1],
             function(_y_, _x_){return _y_ === _x_ ? 1 : 0;},
             s$0,
             s);
   }
   function symbol$18(s$0, s){
    return l2$0
            ([0, equal$1],
             function(_w_, _v_){return _w_ !== _v_ ? 1 : 0;},
             s$0,
             s);
   }
   function Make(Eq){
    var eq = Eq[1];
    function create(v){return create$3([0, eq], v);}
    function equal(s$0, s){return equal$0([0, eq], s$0, s);}
    function hold$0(v, e){return hold([0, eq], v, e);}
    function app(sf, sv){return app$0([0, eq], sf, sv);}
    function map(f, s){return map$0([0, eq], f, s);}
    function filter(pred, i){
     var _t_ = [0, eq];
     return function(_u_){return filter$0(_t_, pred, i, _u_);};
    }
    function fmap(fm, i){
     var _r_ = [0, eq];
     return function(_s_){return fmap$0(_r_, fm, i, _s_);};
    }
    function when(c, i, s){return on$0([0, eq], c, i, s);}
    function dismiss(c, s){
     var _p_ = [0, eq];
     return function(_q_){return dismiss$0(_p_, c, s, _q_);};
    }
    function accum(ef, i){return accum$0([0, eq], ef, i);}
    function fold(f, i){
     var _n_ = [0, eq];
     return function(_o_){return fold$1(_n_, f, i, _o_);};
    }
    function merge(f, a, sl){return merge$0([0, eq], f, a, sl);}
    function switch$0(s){return switch$1([0, eq], s);}
    function bind(s, sf){return bind$0([0, eq], s, sf);}
    function fix(f){
     var _l_ = [0, eq];
     return function(_m_){return fix$0(_l_, f, _m_);};
    }
    function l2(f, s$0, s){return l2$0([0, eq], f, s$0, s);}
    function l3(f, s0, s1, s2){return l3$0([0, eq], f, s0, s1, s2);}
    function l4(f, s0, s1, s2, s3){return l4$0([0, eq], f, s0, s1, s2, s3);}
    function l5(f, s0, s1, s2, s3, s4){
     return l5$0([0, eq], f, s0, s1, s2, s3, s4);
    }
    function l6(f, s0, s1, s2, s3, s4, s5){
     return l6$0([0, eq], f, s0, s1, s2, s3, s4, s5);
    }
    return [0,
            ,
            create,
            equal,
            hold$0,
            app,
            map,
            filter,
            fmap,
            when,
            dismiss,
            accum,
            fold,
            merge,
            switch$0,
            bind,
            fix,
            map,
            l2,
            l3,
            l4,
            l5,
            l6];
   }
   var
    Sb = Make([0, equal$1]),
    Si = Make([0, equal$2]),
    Sf = Make([0, equal$3]),
    React =
      [0,
       [0,
        0,
        create$2,
        retain,
        stop$0,
        equal,
        trace,
        once,
        drop_once,
        app,
        map,
        stamp,
        filter,
        fmap,
        diff,
        changes,
        on,
        on,
        dismiss,
        until,
        accum,
        fold$0,
        select,
        merge,
        switch$0,
        fix,
        map,
        l2,
        l3,
        l4,
        l5,
        l6,
        Option],
       [0,
        const$0,
        create$3,
        value$0,
        retain$0,
        eq_fun,
        stop$1,
        equal$0,
        trace$0,
        hold,
        app$0,
        map$0,
        filter$0,
        fmap$0,
        diff$0,
        changes$0,
        sample,
        on$0,
        on$0,
        dismiss$0,
        accum$0,
        fold$1,
        merge$0,
        switch$1,
        bind$0,
        fix$0,
        map$0,
        l2$0,
        l3$0,
        l4$0,
        l5$0,
        l6$0,
        [0, zero, one, not, symbol, symbol$0, edge, rise, fall, flip],
        [0,
         zero$0,
         one$0,
         minus_one,
         symbol$1,
         succ,
         pred,
         symbol$2,
         symbol$3,
         symbol$4,
         mod,
         abs,
         max_int,
         min_int,
         land,
         lor,
         lxor,
         lnot,
         lsl,
         lsr,
         asr],
        [0,
         zero$1,
         one$1,
         minus_one$0,
         symbol$5,
         symbol$6,
         symbol$7,
         symbol$8,
         symbol$9,
         symbol$10,
         sqrt,
         exp,
         log,
         log10,
         cos,
         sin,
         tan,
         acos,
         asin,
         atan,
         atan2,
         cosh,
         sinh,
         tanh,
         ceil,
         floor,
         abs_float,
         mod_float,
         frexp,
         ldexp,
         modf,
         float$0,
         float_of_int,
         truncate,
         int_of_float,
         infinity,
         neg_infinity,
         nan,
         max_float,
         min_float,
         epsilon_float,
         classify_float],
        Pair,
        Option$0,
        [0,
         symbol$11,
         symbol$12,
         symbol$13,
         symbol$14,
         symbol$15,
         symbol$16,
         compare,
         symbol$17,
         symbol$18],
        function(_j_){
         var _k_ = Make(_j_);
         return [0,
                 _k_[2],
                 _k_[3],
                 _k_[4],
                 _k_[5],
                 _k_[6],
                 _k_[7],
                 _k_[8],
                 _k_[9],
                 _k_[10],
                 _k_[11],
                 _k_[12],
                 _k_[13],
                 _k_[14],
                 _k_[15],
                 _k_[16],
                 _k_[17],
                 _k_[18],
                 _k_[19],
                 _k_[20],
                 _k_[21],
                 _k_[22]];
        },
        [0,
         [0,
          Sb[2],
          Sb[3],
          Sb[4],
          Sb[5],
          Sb[6],
          Sb[7],
          Sb[8],
          Sb[9],
          Sb[10],
          Sb[11],
          Sb[12],
          Sb[13],
          Sb[14],
          Sb[15],
          Sb[16],
          Sb[17],
          Sb[18],
          Sb[19],
          Sb[20],
          Sb[21],
          Sb[22]],
         [0,
          Si[2],
          Si[3],
          Si[4],
          Si[5],
          Si[6],
          Si[7],
          Si[8],
          Si[9],
          Si[10],
          Si[11],
          Si[12],
          Si[13],
          Si[14],
          Si[15],
          Si[16],
          Si[17],
          Si[18],
          Si[19],
          Si[20],
          Si[21],
          Si[22]],
         [0,
          Sf[2],
          Sf[3],
          Sf[4],
          Sf[5],
          Sf[6],
          Sf[7],
          Sf[8],
          Sf[9],
          Sf[10],
          Sf[11],
          Sf[12],
          Sf[13],
          Sf[14],
          Sf[15],
          Sf[16],
          Sf[17],
          Sf[18],
          Sf[19],
          Sf[20],
          Sf[21],
          Sf[22]]]],
       [0, create$0, execute]];
   runtime.caml_register_global(30, React, "React");
   return;
  }
  (globalThis));


//# 1 "../src/.ocaml_canvas.objs/jsoo/default/ocaml_canvas.cma.js"
// Generated by js_of_ocaml
//# 3 "../src/.ocaml_canvas.objs/jsoo/default/ocaml_canvas.cma.js"

//# 6 "../src/.ocaml_canvas.objs/jsoo/default/ocaml_canvas.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$2 = "",
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = cst$2,
    cst$0 = cst$2,
    cst$1 = cst$2,
    zero = [0, 0., 0.],
    unit = [0, 1., 1.],
    id = [254, 1., 0., 0., 1., 0., 0.],
    React = global_data.React,
    Stdlib = global_data.Stdlib,
    Stdlib_Bigarray = global_data.Stdlib__Bigarray,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib_Callback = global_data.Stdlib__Callback,
    Stdlib_Map = global_data.Stdlib__Map,
    Stdlib_Hashtbl = global_data.Stdlib__Hashtbl;
   function valid_canvas_size(param){
    var height = param[2], width = param[1], _dI_ = 0 < width ? 1 : 0;
    if(_dI_){
     var _dJ_ = width <= 32767 ? 1 : 0;
     if(_dJ_)
      var
       _dK_ = 0 < height ? 1 : 0,
       _dL_ = _dK_ ? height <= 32767 ? 1 : 0 : _dK_;
     else
      var _dL_ = _dJ_;
    }
    else
     var _dL_ = _dI_;
    return _dL_;
   }
   var
    Not_initialized =
      [248, "OcamlCanvas.V1.Exception.Not_initialized", caml_fresh_oo_id(0)],
    File_not_found =
      [248, "OcamlCanvas.V1.Exception.File_not_found", caml_fresh_oo_id(0)],
    Read_png_failed =
      [248, "OcamlCanvas.V1.Exception.Read_png_failed", caml_fresh_oo_id(0)],
    Write_png_failed =
      [248, "OcamlCanvas.V1.Exception.Write_png_failed", caml_fresh_oo_id(0)];
   caml_call2(Stdlib_Callback[2], "Not_initialized", Not_initialized);
   caml_call2(Stdlib_Callback[2], "File_not_found", [0, File_not_found, cst]);
   caml_call2
    (Stdlib_Callback[2], "Read_png_failed", [0, Read_png_failed, cst$0]);
   caml_call2
    (Stdlib_Callback[2], "Write_png_failed", [0, Write_png_failed, cst$1]);
   var
    Exception =
      [0, Not_initialized, File_not_found, Read_png_failed, Write_png_failed],
    Const =
      [0,
       3.141592653589793,
       1.5707963267948966,
       0.7853981633974483,
       0.39269908169872414,
       0.3183098861837907,
       0.6366197723675814,
       1.2732395447351628,
       2.5464790894703255,
       2.718281828459045,
       0.36787944117144233,
       1.4426950408889634,
       0.4342944819032518,
       0.6931471805599453,
       2.302585092994046];
   function add(param, _dH_){
    var y2 = _dH_[2], x2 = _dH_[1], y1 = param[2], x1 = param[1];
    return [0, x1 + x2, y1 + y2];
   }
   function sub(param, _dG_){
    var y2 = _dG_[2], x2 = _dG_[1], y1 = param[2], x1 = param[1];
    return [0, x1 - x2, y1 - y2];
   }
   function mul(param, k){
    var y = param[2], x = param[1];
    return [0, x * k, y * k];
   }
   function dot(param, _dF_){
    var y2 = _dF_[2], x2 = _dF_[1], y1 = param[2], x1 = param[1];
    return x1 * x2 + y1 * y2;
   }
   function norm(param){
    var y = param[2], x = param[1];
    return Math.sqrt(x * x + y * y);
   }
   var
    Vector = [0, zero, unit, add, sub, mul, dot, norm],
    cst_Transform_inverse_the_matr =
      "Transform.inverse: the matrix is not inversible";
   function create(param){
    var
     f = param[6],
     e = param[5],
     d = param[4],
     c = param[3],
     b = param[2],
     a = param[1];
    return [254, a, b, c, d, e, f];
   }
   function mul$0(t1, t2){
    return [254,
            t1[1] * t2[1] + t1[3] * t2[2],
            t1[2] * t2[1] + t1[4] * t2[2],
            t1[1] * t2[3] + t1[3] * t2[4],
            t1[2] * t2[3] + t1[4] * t2[4],
            t1[5] + t1[1] * t2[5] + t1[3] * t2[6],
            t1[6] + t1[2] * t2[5] + t1[4] * t2[6]];
   }
   function translate(t, param){
    var y = param[2], x = param[1];
    return [254,
            t[1],
            t[2],
            t[3],
            t[4],
            x * t[1] + y * t[3],
            x * t[2] + y * t[4]];
   }
   function scale(t, param){
    var y = param[2], x = param[1];
    return [254, t[1] * x, t[2] * x, t[3] * y, t[4] * y, t[5], t[6]];
   }
   function shear(t, param){
    var y = param[2], x = param[1];
    return [254,
            t[1] + t[3] * y,
            t[2] + t[4] * y,
            t[3] + t[1] * x,
            t[4] + t[2] * x,
            t[5],
            t[6]];
   }
   function rotate(t, a){
    var cos_a = Math.cos(- a), sin_a = Math.sin(- a);
    return [254,
            t[1] * cos_a - t[3] * sin_a,
            t[2] * cos_a - t[4] * sin_a,
            t[3] * cos_a + t[1] * sin_a,
            t[4] * cos_a + t[2] * sin_a,
            t[5],
            t[6]];
   }
   function inverse(t){
    var det = t[1] * t[4] - t[2] * t[3];
    if(det == 0.) caml_call1(Stdlib[1], cst_Transform_inverse_the_matr);
    var invdet = 1. / det;
    return [254,
            t[4] * invdet,
            - t[2] * invdet,
            - t[3] * invdet,
            t[1] * invdet,
            (t[3] * t[6] - t[4] * t[5]) * invdet,
            (t[2] * t[5] - t[1] * t[6]) * invdet];
   }
   var
    Transform =
      [0, id, create, mul$0, translate, scale, shear, rotate, inverse],
    cst_Point_barycenter_a_b_must_ = "Point.barycenter: a + b must be non-nul";
   function of_ints(param){var y = param[2], x = param[1]; return [0, x, y];}
   function sub$0(param, _dE_){
    var y2 = _dE_[2], x2 = _dE_[1], y1 = param[2], x1 = param[1];
    return [0, x1 - x2, y1 - y2];
   }
   function translate$0(param, _dD_){
    var b = _dD_[2], a = _dD_[1], y = param[2], x = param[1];
    return [0, x + a, y + b];
   }
   function rotate$0(param, _dC_, theta){
    var cy = _dC_[2], cx = _dC_[1], y = param[2], x = param[1];
    return [0,
            (x - cx) * Math.cos(- theta) + (y - cy) * Math.sin(- theta) + cx,
            (y - cy) * Math.cos(- theta) - (x - cx) * Math.sin(- theta) + cy];
   }
   function transform(param, t){
    var y = param[2], x = param[1];
    return [0, x * t[1] + y * t[3] + t[5], x * t[2] + y * t[4] + t[6]];
   }
   function barycenter(a, param, b, _dB_){
    var
     y2 = _dB_[2],
     x2 = _dB_[1],
     y1 = param[2],
     x1 = param[1],
     sum_ab = a + b;
    if(sum_ab == 0.) caml_call1(Stdlib[1], cst_Point_barycenter_a_b_must_);
    return [0, (a * x1 + b * x2) / sum_ab, (a * y1 + b * y2) / sum_ab];
   }
   function distance(param, _dA_){
    var y2 = _dA_[2], x2 = _dA_[1], y1 = param[2], x1 = param[1];
    return Math.sqrt(Math.pow(x2 - x1, 2.) + Math.pow(y2 - y1, 2.));
   }
   var
    Point =
      [0,
       of_ints,
       sub$0,
       translate$0,
       rotate$0,
       transform,
       barycenter,
       distance];
   function clip_8(i){return 0 <= i ? 255 < i ? 255 : i : 0;}
   function of_rgb(r, g, b){
    var _dy_ = clip_8(b), _dz_ = clip_8(g) << 8;
    return (((clip_8(r) << 16) + _dz_ | 0) + _dy_ | 0) - 16777216 | 0;
   }
   function to_rgb(c){
    return [0, (c >>> 16 | 0) & 255, (c >>> 8 | 0) & 255, c & 255];
   }
   function of_argb(a, r, g, b){
    var
     _dv_ = clip_8(b),
     _dw_ = clip_8(g) << 8,
     _dx_ = ((clip_8(r) << 16) + _dw_ | 0) + _dv_ | 0;
    return (clip_8(a) << 24) + _dx_ | 0;
   }
   function to_argb(c){
    return [0,
            c >>> 24 | 0,
            (c >>> 16 | 0) & 255,
            (c >>> 8 | 0) & 255,
            c & 255];
   }
   function of_int(i){
    return 0 <= i ? 16777215 < i ? -1 : i - 16777216 | 0 : 0;
   }
   function to_int(c){return c & 16777215;}
   function of_int32(i){return i;}
   function to_int32(c){return c;}
   var
    StringMap = caml_call1(Stdlib_Map[1], [0, Stdlib_String[9]]),
    colors = [0, StringMap[1]];
   function define_color(name, c){
    var _dt_ = colors[1], _du_ = caml_call1(Stdlib_String[26], name);
    colors[1] = caml_call3(StringMap[4], _du_, c, _dt_);
    return c;
   }
   var
    transpBlack = define_color("transparent_black", 0),
    transpWhite = define_color("transparent_white", 16777215),
    black = define_color("black", -16777216),
    white = define_color("white", -1),
    blue = define_color("blue", -16776961),
    cyan = define_color("cyan", -16711681),
    green = define_color("green", -16744448),
    lime = define_color("lime", -16711936),
    orange = define_color("orange", -23296),
    pink = define_color("pink", -16181),
    red = define_color("red", -65536),
    cst_0x = "0x";
   function of_string(s){
    if(1 > caml_ml_string_length(s)) return black;
    if(35 === runtime.caml_string_get(s, 0)){
     var
      _dn_ =
        caml_call3(Stdlib_String[15], s, 1, caml_ml_string_length(s) - 1 | 0),
      s$0 = caml_call2(Stdlib[28], cst_0x, _dn_);
     return of_int(runtime.caml_int_of_string(s$0));
    }
    try{
     var
      _dp_ = colors[1],
      _dq_ = caml_call1(Stdlib_String[26], s),
      _dr_ = caml_call2(StringMap[28], _dq_, _dp_);
     return _dr_;
    }
    catch(_ds_){
     var _do_ = caml_wrap_exception(_ds_);
     if(_do_ === Stdlib[8]) return black;
     throw caml_maybe_attach_backtrace(_do_, 0);
    }
   }
   var
    Font = [0, 100, 200, 300, 400, 500, 600, 700, 800, 900],
    list = [0, 0],
    cst_ImageData_create_invalid_i =
      "ImageData.create: invalid image dimensions",
    cst_ImageData_of_bigarray_inva =
      "ImageData.of_bigarray: invalid image dimensions",
    cst_ImageData_of_bigarray_thir =
      "ImageData.of_bigarray: third dimension must be 4";
   function add_image_data(event, send_event, c){
    list[1] = [0, [0, event, send_event, c], list[1]];
    return 0;
   }
   function add_canvas(event, send_event, c){
    list[1] = [0, [1, event, send_event, c], list[1]];
    return 0;
   }
   function create$0(param){
    var height = param[2], width = param[1];
    if(1 - valid_canvas_size([0, width, height]))
     caml_call1(Stdlib[1], cst_ImageData_create_invalid_i);
    var
     a =
       caml_call5
        (Stdlib_Bigarray[21][1],
         Stdlib_Bigarray[6],
         Stdlib_Bigarray[15],
         height,
         width,
         4);
    runtime.caml_ba_fill(a, 0);
    return a;
   }
   function createFromPNG(filename){
    var
     match = caml_call1(React[1][2], 0),
     send_event = match[2],
     event = match[1];
    runtime.ml_canvas_image_data_create_from_png
     (filename, function(id){return add_image_data(event, send_event, id);});
    return event;
   }
   function importPNG(id, pos, filename){
    var
     match = caml_call1(React[1][2], 0),
     send_event = match[2],
     event = match[1];
    runtime.ml_canvas_image_data_import_png
     (id,
      pos,
      filename,
      function(id){return add_image_data(event, send_event, id);});
    return event;
   }
   function of_bigarray(ba){
    var _dm_ = runtime.caml_ba_dim_1(ba);
    if(1 - valid_canvas_size([0, runtime.caml_ba_dim_2(ba), _dm_]))
     caml_call1(Stdlib[1], cst_ImageData_of_bigarray_inva);
    if(4 !== runtime.caml_ba_dim_3(ba))
     caml_call1(Stdlib[1], cst_ImageData_of_bigarray_thir);
    return ba;
   }
   var Join = [0], Cap = [0], Style = [0], CompositeOp = [0];
   caml_call2(Stdlib_Callback[1], "Hashtbl.hash", Stdlib_Hashtbl[28]);
   function createOffscreenFromPNG(filename){
    var
     match = caml_call1(React[1][2], 0),
     send_event = match[2],
     event = match[1];
    runtime.ml_canvas_create_offscreen_from_png
     (filename, function(c){return add_canvas(event, send_event, c);});
    return event;
   }
   function importPNG$0(c, pos, filename){
    var
     match = caml_call1(React[1][2], 0),
     send_event = match[2],
     event = match[1];
    runtime.ml_canvas_import_png
     (c, pos, filename, function(c){return add_canvas(event, send_event, c);});
    return event;
   }
   var
    match = caml_call1(React[1][2], 0),
    send_frame = match[2],
    frame = match[1],
    match$0 = caml_call1(React[1][2], 0),
    send_focus_in = match$0[2],
    focus_in = match$0[1],
    match$1 = caml_call1(React[1][2], 0),
    send_focus_out = match$1[2],
    focus_out = match$1[1],
    match$2 = caml_call1(React[1][2], 0),
    send_resize = match$2[2],
    resize = match$2[1],
    match$3 = caml_call1(React[1][2], 0),
    send_move = match$3[2],
    move = match$3[1],
    match$4 = caml_call1(React[1][2], 0),
    send_close = match$4[2],
    close = match$4[1],
    match$5 = caml_call1(React[1][2], 0),
    send_key_down = match$5[2],
    key_down = match$5[1],
    match$6 = caml_call1(React[1][2], 0),
    send_key_up = match$6[2],
    key_up = match$6[1],
    match$7 = caml_call1(React[1][2], 0),
    send_button_down = match$7[2],
    button_down = match$7[1],
    match$8 = caml_call1(React[1][2], 0),
    send_button_up = match$8[2],
    button_up = match$8[1],
    match$9 = caml_call1(React[1][2], 0),
    send_mouse_move = match$9[2],
    mouse_move = match$9[1],
    match$10 =
      caml_call2(React[2][2], 0, runtime.caml_int64_create_lo_mi_hi(0, 0, 0)),
    set_event_timestamp = match$10[2],
    event_timestamp = match$10[1];
   function run(k){
    function h(e){
     switch(e[0]){
       case 0: break;
       case 1:
        var
         match = e[1],
         timestamp = match[2],
         canvas = match[1],
         e$0 = [0, canvas, timestamp, 0];
        caml_call2(set_event_timestamp, 0, e$0[2]);
        caml_call2(send_frame, 0, e$0);
        break;
       case 2:
        var _dj_ = e[1], timestamp$0 = _dj_[2], canvas$0 = _dj_[1];
        if(_dj_[3]){
         var e$1 = [0, canvas$0, timestamp$0, 0];
         caml_call2(set_event_timestamp, 0, e$1[2]);
         caml_call2(send_focus_in, 0, e$1);
        }
        else{
         var e$2 = [0, canvas$0, timestamp$0, 0];
         caml_call2(set_event_timestamp, 0, e$2[2]);
         caml_call2(send_focus_out, 0, e$2);
        }
        break;
       case 3:
        var
         match$0 = e[1],
         size = match$0[3],
         timestamp$1 = match$0[2],
         canvas$1 = match$0[1],
         e$3 = [0, canvas$1, timestamp$1, size];
        caml_call2(set_event_timestamp, 0, e$3[2]);
        caml_call2(send_resize, 0, e$3);
        break;
       case 4:
        var
         match$1 = e[1],
         position = match$1[3],
         timestamp$2 = match$1[2],
         canvas$2 = match$1[1],
         e$4 = [0, canvas$2, timestamp$2, position];
        caml_call2(set_event_timestamp, 0, e$4[2]);
        caml_call2(send_move, 0, e$4);
        break;
       case 5:
        var
         match$2 = e[1],
         timestamp$3 = match$2[2],
         canvas$3 = match$2[1],
         e$5 = [0, canvas$3, timestamp$3, 0];
        caml_call2(set_event_timestamp, 0, e$5[2]);
        caml_call2(send_close, 0, e$5);
        break;
       case 6:
        var
         _dk_ = e[1],
         flags = _dk_[5],
         char$0 = _dk_[4],
         key = _dk_[3],
         timestamp$4 = _dk_[2],
         canvas$4 = _dk_[1];
        if(_dk_[6]){
         var e$6 = [0, canvas$4, timestamp$4, [0, key, char$0, flags]];
         caml_call2(set_event_timestamp, 0, e$6[2]);
         caml_call2(send_key_down, 0, e$6);
        }
        else{
         var e$7 = [0, canvas$4, timestamp$4, [0, key, char$0, flags]];
         caml_call2(set_event_timestamp, 0, e$7[2]);
         caml_call2(send_key_up, 0, e$7);
        }
        break;
       case 7:
        var
         _dl_ = e[1],
         button = _dl_[4],
         position$0 = _dl_[3],
         timestamp$5 = _dl_[2],
         canvas$5 = _dl_[1];
        if(_dl_[5]){
         var e$8 = [0, canvas$5, timestamp$5, [0, position$0, button]];
         caml_call2(set_event_timestamp, 0, e$8[2]);
         caml_call2(send_button_down, 0, e$8);
        }
        else{
         var e$9 = [0, canvas$5, timestamp$5, [0, position$0, button]];
         caml_call2(set_event_timestamp, 0, e$9[2]);
         caml_call2(send_button_up, 0, e$9);
        }
        break;
       default:
        var
         match$3 = e[1],
         position$1 = match$3[3],
         timestamp$6 = match$3[2],
         canvas$6 = match$3[1],
         e$10 = [0, canvas$6, timestamp$6, position$1];
        caml_call2(set_event_timestamp, 0, e$10[2]);
        caml_call2(send_mouse_move, 0, e$10);
     }
     var l = list[1];
     if(! l) return 0;
     list[1] = 0;
     var _di_ = caml_call1(Stdlib_List[9], l);
     return caml_call2
             (Stdlib_List[17],
              function(param){
               if(0 === param[0]){
                var id = param[3], send_event = param[2], event = param[1];
                caml_call2(send_event, 0, id);
                return caml_call2(React[1][4], 0, event);
               }
               var c = param[3], send_event$0 = param[2], event$0 = param[1];
               caml_call2(send_event$0, 0, c);
               return caml_call2(React[1][4], 0, event$0);
              },
              _di_);
    }
    return runtime.ml_canvas_run(h, k);
   }
   var
    OcamlCanvas =
      [0,
       [0,
        Exception,
        Const,
        Vector,
        Transform,
        Point,
        [0,
         of_rgb,
         to_rgb,
         of_argb,
         to_argb,
         of_int,
         to_int,
         of_int32,
         to_int32,
         transpBlack,
         transpWhite,
         black,
         white,
         blue,
         cyan,
         green,
         lime,
         orange,
         pink,
         red,
         of_string,
         define_color],
        Font,
        [0,
         create$0,
         createFromPNG,
         function(_dh_){return runtime.ml_canvas_image_data_get_size(_dh_);},
         function(_dg_, _df_){
          return runtime.ml_canvas_image_data_fill(_dg_, _df_);
         },
         function(_de_, _dd_, _dc_){
          return runtime.ml_canvas_image_data_sub(_de_, _dd_, _dc_);
         },
         function(_db_, _da_, _c$_, _c__, _c9_){
          return runtime.ml_canvas_image_data_blit
                  (_db_, _da_, _c$_, _c__, _c9_);
         },
         function(_c8_, _c7_){
          return runtime.ml_canvas_image_data_get_pixel(_c8_, _c7_);
         },
         function(_c6_, _c5_, _c4_){
          return runtime.ml_canvas_image_data_put_pixel(_c6_, _c5_, _c4_);
         },
         importPNG,
         function(_c3_, _c2_){
          return runtime.ml_canvas_image_data_export_png(_c3_, _c2_);
         },
         of_bigarray,
         function(_c1_){return _c1_;}],
        [0,
         function(_c0_, _cZ_){
          return runtime.ml_canvas_gradient_create_linear(_c0_, _cZ_);
         },
         function(_cY_, _cX_, _cW_, _cV_){
          return runtime.ml_canvas_gradient_create_radial
                  (_cY_, _cX_, _cW_, _cV_);
         },
         function(_cU_, _cT_){
          return runtime.ml_canvas_gradient_create_conic(_cU_, _cT_);
         },
         function(_cS_, _cR_, _cQ_){
          return runtime.ml_canvas_gradient_add_color_stop(_cS_, _cR_, _cQ_);
         }],
        [0,
         function(_cP_, _cO_){
          return runtime.ml_canvas_pattern_create(_cP_, _cO_);
         }],
        [0,
         function(_cN_){return runtime.ml_canvas_path_create(_cN_);},
         function(_cM_, _cL_){
          return runtime.ml_canvas_path_move_to(_cM_, _cL_);
         },
         function(_cK_){return runtime.ml_canvas_path_close(_cK_);},
         function(_cJ_, _cI_){
          return runtime.ml_canvas_path_line_to(_cJ_, _cI_);
         },
         function(_cH_, _cG_, _cF_, _cE_, _cD_, _cC_){
          return runtime.ml_canvas_path_arc
                  (_cH_, _cG_, _cF_, _cE_, _cD_, _cC_);
         },
         function(_cB_, _cA_, _cz_, _cy_){
          return runtime.ml_canvas_path_arc_to(_cB_, _cA_, _cz_, _cy_);
         },
         function(_cx_, _cw_, _cv_){
          return runtime.ml_canvas_path_quadratic_curve_to(_cx_, _cw_, _cv_);
         },
         function(_cu_, _ct_, _cs_, _cr_){
          return runtime.ml_canvas_path_bezier_curve_to
                  (_cu_, _ct_, _cs_, _cr_);
         },
         function(_cq_, _cp_, _co_){
          return runtime.ml_canvas_path_rect(_cq_, _cp_, _co_);
         },
         function(_cn_, _cm_, _cl_, _ck_, _cj_, _ci_, _ch_){
          return runtime.ml_canvas_path_ellipse
                  (_cn_, _cm_, _cl_, _ck_, _cj_, _ci_, _ch_);
         },
         function(_cg_, _cf_){return runtime.ml_canvas_path_add(_cg_, _cf_);},
         function(_ce_, _cd_, _cc_){
          return runtime.ml_canvas_path_add_transformed(_ce_, _cd_, _cc_);
         }],
        Join,
        Cap,
        Style,
        CompositeOp,
        [0,
         function(_cb_, _ca_){return runtime.ml_canvas_compare(_cb_, _ca_);},
         function(_b$_){return runtime.ml_canvas_hash(_b$_);},
         function
         (_b__, _b9_, _b8_, _b7_, _b6_, _b5_, _b4_, _b3_, _b2_, _b1_, _b0_){
          return runtime.ml_canvas_create_onscreen
                  (_b__,
                   _b9_,
                   _b8_,
                   _b7_,
                   _b6_,
                   _b5_,
                   _b4_,
                   _b3_,
                   _b2_,
                   _b1_,
                   _b0_);
         },
         function(_bZ_, _bY_){
          return runtime.ml_canvas_create_offscreen(_bZ_, _bY_);
         },
         function(_bX_){
          return runtime.ml_canvas_create_offscreen_from_image_data(_bX_);
         },
         createOffscreenFromPNG,
         function(_bW_){return runtime.ml_canvas_show(_bW_);},
         function(_bV_){return runtime.ml_canvas_hide(_bV_);},
         function(_bU_){return runtime.ml_canvas_close(_bU_);},
         function(_bT_){return runtime.ml_canvas_commit(_bT_);},
         function(_bS_){return runtime.ml_canvas_get_id(_bS_);},
         function(_bR_){return runtime.ml_canvas_get_size(_bR_);},
         function(_bQ_, _bP_){return runtime.ml_canvas_set_size(_bQ_, _bP_);},
         function(_bO_){return runtime.ml_canvas_get_position(_bO_);},
         function(_bN_, _bM_){
          return runtime.ml_canvas_set_position(_bN_, _bM_);
         },
         function(_bL_){return runtime.ml_canvas_save(_bL_);},
         function(_bK_){return runtime.ml_canvas_restore(_bK_);},
         function(_bJ_, _bI_){
          return runtime.ml_canvas_set_transform(_bJ_, _bI_);
         },
         function(_bH_, _bG_){return runtime.ml_canvas_transform(_bH_, _bG_);},
         function(_bF_, _bE_){return runtime.ml_canvas_translate(_bF_, _bE_);},
         function(_bD_, _bC_){return runtime.ml_canvas_scale(_bD_, _bC_);},
         function(_bB_, _bA_){return runtime.ml_canvas_shear(_bB_, _bA_);},
         function(_bz_, _by_){return runtime.ml_canvas_rotate(_bz_, _by_);},
         function(_bx_){return runtime.ml_canvas_get_line_width(_bx_);},
         function(_bw_, _bv_){
          return runtime.ml_canvas_set_line_width(_bw_, _bv_);
         },
         function(_bu_){return runtime.ml_canvas_get_line_join(_bu_);},
         function(_bt_, _bs_){
          return runtime.ml_canvas_set_line_join(_bt_, _bs_);
         },
         function(_br_){return runtime.ml_canvas_get_line_cap(_br_);},
         function(_bq_, _bp_){
          return runtime.ml_canvas_set_line_cap(_bq_, _bp_);
         },
         function(_bo_){return runtime.ml_canvas_get_miter_limit(_bo_);},
         function(_bn_, _bm_){
          return runtime.ml_canvas_set_miter_limit(_bn_, _bm_);
         },
         function(_bl_){return runtime.ml_canvas_get_line_dash_offset(_bl_);},
         function(_bk_, _bj_){
          return runtime.ml_canvas_set_line_dash_offset(_bk_, _bj_);
         },
         function(_bi_){return runtime.ml_canvas_get_line_dash(_bi_);},
         function(_bh_, _bg_){
          return runtime.ml_canvas_set_line_dash(_bh_, _bg_);
         },
         function(_bf_){return runtime.ml_canvas_get_stroke_color(_bf_);},
         function(_be_, _bd_){
          return runtime.ml_canvas_set_stroke_color(_be_, _bd_);
         },
         function(_bc_, _bb_){
          return runtime.ml_canvas_set_stroke_gradient(_bc_, _bb_);
         },
         function(_ba_, _a$_){
          return runtime.ml_canvas_set_stroke_pattern(_ba_, _a$_);
         },
         function(_a__){return runtime.ml_canvas_get_stroke_style(_a__);},
         function(_a9_, _a8_){
          return runtime.ml_canvas_set_stroke_style(_a9_, _a8_);
         },
         function(_a7_){return runtime.ml_canvas_get_fill_color(_a7_);},
         function(_a6_, _a5_){
          return runtime.ml_canvas_set_fill_color(_a6_, _a5_);
         },
         function(_a4_, _a3_){
          return runtime.ml_canvas_set_fill_gradient(_a4_, _a3_);
         },
         function(_a2_, _a1_){
          return runtime.ml_canvas_set_fill_pattern(_a2_, _a1_);
         },
         function(_a0_){return runtime.ml_canvas_get_fill_style(_a0_);},
         function(_aZ_, _aY_){
          return runtime.ml_canvas_set_fill_style(_aZ_, _aY_);
         },
         function(_aX_){return runtime.ml_canvas_get_global_alpha(_aX_);},
         function(_aW_, _aV_){
          return runtime.ml_canvas_set_global_alpha(_aW_, _aV_);
         },
         function(_aU_){
          return runtime.ml_canvas_get_global_composite_operation(_aU_);
         },
         function(_aT_, _aS_){
          return runtime.ml_canvas_set_global_composite_operation(_aT_, _aS_);
         },
         function(_aR_){return runtime.ml_canvas_get_shadow_color(_aR_);},
         function(_aQ_, _aP_){
          return runtime.ml_canvas_set_shadow_color(_aQ_, _aP_);
         },
         function(_aO_){return runtime.ml_canvas_get_shadow_blur(_aO_);},
         function(_aN_, _aM_){
          return runtime.ml_canvas_set_shadow_blur(_aN_, _aM_);
         },
         function(_aL_){return runtime.ml_canvas_get_shadow_offset(_aL_);},
         function(_aK_, _aJ_){
          return runtime.ml_canvas_set_shadow_offset(_aK_, _aJ_);
         },
         function(_aI_, _aH_, _aG_, _aF_, _aE_){
          return runtime.ml_canvas_set_font(_aI_, _aH_, _aG_, _aF_, _aE_);
         },
         function(_aD_){return runtime.ml_canvas_clear_path(_aD_);},
         function(_aC_){return runtime.ml_canvas_close_path(_aC_);},
         function(_aB_, _aA_){return runtime.ml_canvas_move_to(_aB_, _aA_);},
         function(_az_, _ay_){return runtime.ml_canvas_line_to(_az_, _ay_);},
         function(_ax_, _aw_, _av_, _au_, _at_, _as_){
          return runtime.ml_canvas_arc(_ax_, _aw_, _av_, _au_, _at_, _as_);
         },
         function(_ar_, _aq_, _ap_, _ao_){
          return runtime.ml_canvas_arc_to(_ar_, _aq_, _ap_, _ao_);
         },
         function(_an_, _am_, _al_){
          return runtime.ml_canvas_quadratic_curve_to(_an_, _am_, _al_);
         },
         function(_ak_, _aj_, _ai_, _ah_){
          return runtime.ml_canvas_bezier_curve_to(_ak_, _aj_, _ai_, _ah_);
         },
         function(_ag_, _af_, _ae_){
          return runtime.ml_canvas_rect(_ag_, _af_, _ae_);
         },
         function(_ad_, _ac_, _ab_, _aa_, _$_, ___, _Z_){
          return runtime.ml_canvas_ellipse
                  (_ad_, _ac_, _ab_, _aa_, _$_, ___, _Z_);
         },
         function(_Y_, _X_){return runtime.ml_canvas_fill(_Y_, _X_);},
         function(_W_, _V_, _U_){
          return runtime.ml_canvas_fill_path(_W_, _V_, _U_);
         },
         function(_T_){return runtime.ml_canvas_stroke(_T_);},
         function(_S_, _R_){return runtime.ml_canvas_stroke_path(_S_, _R_);},
         function(_Q_, _P_){return runtime.ml_canvas_clip(_Q_, _P_);},
         function(_O_, _N_, _M_){
          return runtime.ml_canvas_clip_path(_O_, _N_, _M_);
         },
         function(_L_, _K_, _J_){
          return runtime.ml_canvas_fill_rect(_L_, _K_, _J_);
         },
         function(_I_, _H_, _G_){
          return runtime.ml_canvas_stroke_rect(_I_, _H_, _G_);
         },
         function(_F_, _E_, _D_){
          return runtime.ml_canvas_fill_text(_F_, _E_, _D_);
         },
         function(_C_, _B_, _A_){
          return runtime.ml_canvas_stroke_text(_C_, _B_, _A_);
         },
         function(_z_, _y_, _x_, _w_, _v_){
          return runtime.ml_canvas_blit(_z_, _y_, _x_, _w_, _v_);
         },
         function(_u_, _t_){return runtime.ml_canvas_get_pixel(_u_, _t_);},
         function(_s_, _r_, _q_){
          return runtime.ml_canvas_put_pixel(_s_, _r_, _q_);
         },
         function(_p_, _o_, _n_){
          return runtime.ml_canvas_get_image_data(_p_, _o_, _n_);
         },
         function(_m_, _l_, _k_, _j_, _i_){
          return runtime.ml_canvas_put_image_data(_m_, _l_, _k_, _j_, _i_);
         },
         importPNG$0,
         function(_h_, _g_){return runtime.ml_canvas_export_png(_h_, _g_);}],
        [0,
         frame,
         focus_in,
         focus_out,
         resize,
         move,
         close,
         key_down,
         key_up,
         button_down,
         button_up,
         mouse_move,
         event_timestamp,
         function(_f_){return runtime.ml_canvas_int_of_key(_f_);},
         function(_e_){return runtime.ml_canvas_key_of_int(_e_);}],
        [0,
         function(_d_){return runtime.ml_canvas_init(_d_);},
         run,
         function(_c_){return runtime.ml_canvas_stop(_c_);},
         function(_b_){return runtime.ml_canvas_get_canvas(_b_);},
         function(_a_){return runtime.ml_canvas_get_current_timestamp(_a_);}]]];
   runtime.caml_register_global(82, OcamlCanvas, "OcamlCanvas");
   return;
  }
  (globalThis));


//# 1 ".ppm_dump.eobjs/jsoo/dune__exe__Ppm_dump.cmo.js"
// Generated by js_of_ocaml
//# 3 ".ppm_dump.eobjs/jsoo/dune__exe__Ppm_dump.cmo.js"

//# 6 ".ppm_dump.eobjs/jsoo/dune__exe__Ppm_dump.cmo.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Goodbye = "Goodbye !\n",
    caml_ba_get_3 = runtime.caml_ba_get_3;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   function caml_call11(f, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10){
    return (f.l >= 0 ? f.l : f.l = f.length) == 11
            ? f(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10)
            : runtime.caml_call_gen
              (f, [a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Printf = global_data.Stdlib__Printf,
    OcamlCanvas = global_data.OcamlCanvas,
    Stdlib = global_data.Stdlib,
    Stdlib_Format = global_data.Stdlib__Format,
    React = global_data.React,
    events = [0, 0];
   function retain_event(e){events[1] = [0, e, events[1]]; return 0;}
   function clear_events(param){events[1] = 0; return 0;}
   caml_call1(OcamlCanvas[1][18][1], 0);
   var
    c =
      caml_call11
       (OcamlCanvas[1][16][3],
        0,
        0,
        0,
        0,
        0,
        0,
        [0, "PPM Dump"],
        0,
        [0, [0, 300, 200]],
        [0, 300, 200],
        0);
   caml_call2(OcamlCanvas[1][16][43], c, OcamlCanvas[1][6][17]);
   caml_call3(OcamlCanvas[1][16][75], c, [0, 0., 0.], [0, 300., 200.]);
   caml_call2(OcamlCanvas[1][16][37], c, OcamlCanvas[1][6][14]);
   caml_call2(OcamlCanvas[1][16][25], c, 10.);
   caml_call1(OcamlCanvas[1][16][59], c);
   caml_call2(OcamlCanvas[1][16][61], c, [0, 5., 5.]);
   caml_call2(OcamlCanvas[1][16][62], c, [0, 295., 5.]);
   caml_call2(OcamlCanvas[1][16][62], c, [0, 295., 195.]);
   caml_call2(OcamlCanvas[1][16][62], c, [0, 5., 195.]);
   caml_call1(OcamlCanvas[1][16][60], c);
   caml_call1(OcamlCanvas[1][16][71], c);
   caml_call5
    (OcamlCanvas[1][16][58],
     c,
     "Liberation Sans",
     36.,
     0,
     OcamlCanvas[1][7][7]);
   var _a_ = caml_call3(OcamlCanvas[1][6][1], 0, 64, 255);
   caml_call2(OcamlCanvas[1][16][43], c, _a_);
   caml_call2(OcamlCanvas[1][16][25], c, 1.);
   caml_call1(OcamlCanvas[1][16][16], c);
   caml_call2(OcamlCanvas[1][16][20], c, [0, 150., 100.]);
   caml_call2(OcamlCanvas[1][16][23], c, - OcamlCanvas[1][2][4]);
   caml_call3(OcamlCanvas[1][16][77], c, "Hello world !", [0, -130., 20.]);
   caml_call1(OcamlCanvas[1][16][17], c);
   caml_call1(OcamlCanvas[1][16][7], c);
   var
    img = caml_call3(OcamlCanvas[1][16][82], c, [0, 0, 0], [0, 300, 200]),
    img_ba = caml_call1(OcamlCanvas[1][8][12], img),
    oc = caml_call1(Stdlib[60], "picture.ppm"),
    fmt = caml_call1(Stdlib_Format[108], oc);
   caml_call5
    (Stdlib_Format[129],
     fmt,
     [0,
      [11,
       "P3\n",
       [4,
        0,
        0,
        0,
        [12, 32, [4, 0, 0, 0, [12, 10, [4, 0, 0, 0, [12, 10, 0]]]]]]],
      "P3\n%d %d\n%d\n"],
     300,
     200,
     255);
   var
    i = 0,
    _e_ = [0, [11, cst_Goodbye, 0], cst_Goodbye],
    _g_ =
      [0,
       [4, 0, 0, 0, [12, 32, [4, 0, 0, 0, [12, 32, [4, 0, 0, 0, [0, 0]]]]]],
       "%d %d %d%c"],
    _b_ = [0, 300, 200],
    _c_ = [0, 0, 0],
    _d_ = [0, 0, 0];
   for(;;){
    var j = 0;
    for(;;){
     var
      b = caml_ba_get_3(img_ba, i, j, 0),
      g = caml_ba_get_3(img_ba, i, j, 1),
      r = caml_ba_get_3(img_ba, i, j, 2);
     caml_ba_get_3(img_ba, i, j, 3);
     var sep = 3 === (j & 3) ? 10 : 32;
     caml_call6(Stdlib_Format[129], fmt, _g_, r, g, b, sep);
     var _h_ = j + 1 | 0;
     if(299 === j) break;
     j = _h_;
    }
    var _f_ = i + 1 | 0;
    if(199 === i) break;
    i = _f_;
   }
   caml_call1(Stdlib[76], oc);
   caml_call5(OcamlCanvas[1][16][83], c, _d_, img, _c_, _b_);
   retain_event
    (caml_call2
      (React[1][10],
       function(param){return caml_call1(OcamlCanvas[1][18][3], 0);},
       OcamlCanvas[1][17][6]));
   retain_event
    (caml_call2
      (React[1][10],
       function(param){
        var key = param[3][1], _i_ = 0 === key ? 1 : 0;
        return _i_ ? caml_call1(OcamlCanvas[1][18][3], 0) : _i_;
       },
       OcamlCanvas[1][17][7]));
   retain_event
    (caml_call2
      (React[1][10],
       function(param){
        var match = param[3][1], y = match[2], x = match[1];
        caml_call2(OcamlCanvas[1][16][43], c, OcamlCanvas[1][6][19]);
        caml_call1(OcamlCanvas[1][16][59], c);
        caml_call6
         (OcamlCanvas[1][16][63],
          c,
          [0, x, y],
          5.,
          0.,
          2. * OcamlCanvas[1][2][1],
          0);
        return caml_call2(OcamlCanvas[1][16][69], c, 0);
       },
       OcamlCanvas[1][17][9]));
   caml_call1
    (OcamlCanvas[1][18][2],
     function(param){
      clear_events(0);
      return caml_call1(Stdlib_Printf[2], _e_);
     });
   var Dune_exe_Ppm_dump = [0, events, retain_event, clear_events];
   runtime.caml_register_global(33, Dune_exe_Ppm_dump, "Dune__exe__Ppm_dump");
   return;
  }
  (globalThis));


//# 1 "../.js/default/stdlib/std_exit.cmo.js"
// Generated by js_of_ocaml
//# 3 "../.js/default/stdlib/std_exit.cmo.js"

//# 6 "../.js/default/stdlib/std_exit.cmo.js"
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib;
   caml_call1(Stdlib[103], 0);
   var Std_exit = [0];
   runtime.caml_register_global(1, Std_exit, "Std_exit");
   return;
  }
  (globalThis));


//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJwcG1fZHVtcC5iYy5qcyIsInNvdXJjZVJvb3QiOiIiLCJuYW1lcyI6WyJCVVRUT04iLCJCVVRUT05fU1RBVEUiLCJCVVRUT05fU1RBVEVfVEFHIiwiQlVUVE9OX1RBRyIsImNhbWxfc3ViYXJyYXlfdG9fanNieXRlcyIsImEiLCJpIiwibGVuIiwiZiIsIlN0cmluZyIsIm51bGwiLCJzIiwiTWF0aCIsImNhbWxfc3RyaW5nX29mX2pzYnl0ZXMiLCJ4IiwiY2FtbF9zdHJpbmdfb2ZfYXJyYXkiLCJjYW1sX2JhX2dldF8xIiwiYmEiLCJpMCIsIkJpZ1N0cmluZ1JlYWRlciIsImJzIiwidGhpcyIsImFyciIsIkFycmF5IiwiaiIsIm9mZnNldCIsIkNBUF9UWVBFX1RBRyIsIkNPTVBPUF9UQUciLCJ0YWdfdG9fY2FwX3R5cGUiLCJqb29fZ2xvYmFsX29iamVjdCIsIkNhcF90eXBlX3ZhbCIsImNhcCIsInRhZ190b19jb21wb3AiLCJDb21wb3BfdmFsIiwiU1RZTEVfVEFHIiwiRHJhd19zdHlsZV92YWwiLCJzdHlsZSIsIkVWRU5UX1RBRyIsIkZPQ1VTIiwiRk9DVVNfVEFHIiwiSk9JTl9UWVBFX1RBRyIsInRhZ190b19qb2luX3R5cGUiLCJKb2luX3R5cGVfdmFsIiwiam9pbiIsIktFWSIsIktFWV9TVEFURSIsIktFWV9TVEFURV9UQUciLCJLRVlfVEFHIiwidGFnX3RvX2tjIiwiS2V5X2NvZGVfdmFsIiwia2V5Y29kZSIsImNhbWxfc3RyX3JlcGVhdCIsIm4iLCJyIiwibCIsImNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMiLCJqc29vX2lzX2FzY2lpIiwiY2FtbF91dGYxNl9vZl91dGY4IiwiYiIsInQiLCJjIiwiYzEiLCJjMiIsInYiLCJNbEJ5dGVzIiwidGFnIiwiY29udGVudHMiLCJsZW5ndGgiLCJjb250ZW50IiwiY2FtbF91dGY4X29mX3V0ZjE2IiwiZCIsImNhbWxfc3RyaW5nX29mX2pzc3RyaW5nIiwidW5peF9lcnJvciIsIm1ha2VfdW5peF9lcnJfYXJncyIsImNvZGUiLCJzeXNjYWxsIiwicGF0aCIsImVycm5vIiwidmFyaWFudCIsImFyZ3MiLCJjYW1sX25hbWVkX3ZhbHVlcyIsImNhbWxfbmFtZWRfdmFsdWUiLCJubSIsImpzb29fc3lzX2dldGVudiIsInByb2Nlc3MiLCJnbG9iYWxUaGlzIiwidW5kZWZpbmVkIiwiY2FtbF9yZWNvcmRfYmFja3RyYWNlX2ZsYWciLCJjYW1sX2dsb2JhbF9kYXRhIiwiY2FtbF9leG5fd2l0aF9qc19iYWNrdHJhY2UiLCJleG4iLCJmb3JjZSIsImNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZSIsImNhbWxfcmFpc2Vfd2l0aF9hcmdzIiwiY2FtbF9pc19tbF9ieXRlcyIsImNhbWxfaXNfbWxfc3RyaW5nIiwiY2FtbF9ieXRlc19vZl9hcnJheSIsIlVpbnQ4QXJyYXkiLCJjYW1sX2J5dGVzX29mX2pzYnl0ZXMiLCJjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nIiwiY2FtbF9ieXRlc19vZl9zdHJpbmciLCJjYW1sX3JhaXNlX3dpdGhfYXJnIiwiYXJnIiwiY2FtbF9yYWlzZV93aXRoX3N0cmluZyIsIm1zZyIsImNhbWxfcmFpc2Vfc3lzX2Vycm9yIiwiY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUiLCJuYW1lIiwiY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5IiwiY2FtbF91aW50OF9hcnJheV9vZl9ieXRlcyIsImNhbWxfaW52YWxpZF9hcmd1bWVudCIsImNhbWxfY3JlYXRlX2J5dGVzIiwiY2FtbF9tbF9ieXRlc19sZW5ndGgiLCJjYW1sX2JsaXRfYnl0ZXMiLCJzMSIsImkxIiwiczIiLCJpMiIsIk1sRmlsZSIsIk1sRmFrZUZpbGUiLCJvbGQiLCJidWYiLCJwb3MiLCJjbGVuIiwibmV3X3N0ciIsIm9sZF9kYXRhIiwiZGF0YSIsIk1sRmFrZUZkIiwiZmlsZSIsImZsYWdzIiwiTWxGYWtlRGV2aWNlIiwicm9vdCIsImNvbXAiLCJyZXMiLCJTeW1ib2wiLCJuYW1lX3NsYXNoIiwibW9kZSIsInJhaXNlX3VuaXgiLCJwYXJlbnQiLCJSZWdFeHAiLCJzZWVuIiwibSIsImVudHJ5Iiwib2siLCJieXRlcyIsIk1sRmFrZUZkX291dCIsImZkIiwiY29uc29sZSIsInNyYyIsImNhbWxfaW50NjRfb2Zmc2V0IiwiY2FtbF9yYWlzZV9jb25zdGFudCIsImNhbWxfcmFpc2VfemVyb19kaXZpZGUiLCJNbEludDY0IiwibG8iLCJtaSIsImhpIiwieGhpIiwiaCIsInNpZ24iLCJtb2R1bHVzIiwiZGl2aXNvciIsInF1b3RpZW50IiwieSIsInEiLCJNbE11dGV4IiwiTWxOYXQiLCJJbnQzMkFycmF5IiwiY2FtbF9tbF9zdHJpbmdfbGVuZ3RoIiwiY2FtbF9zdHJpbmdfdW5zYWZlX2dldCIsImNhbWxfdWludDhfYXJyYXlfb2Zfc3RyaW5nIiwiY2FtbF9ieXRlc19ib3VuZF9lcnJvciIsImNhbWxfYnl0ZXNfdW5zYWZlX3NldCIsImNhbWxfYnl0ZXNfc2V0IiwiTWxOb2RlRmQiLCJyZXF1aXJlIiwiZXJyIiwiYnVmX29mZnNldCIsInJlYWQiLCJNbE5vZGVEZXZpY2UiLCJjb25zdHMiLCJrZXkiLCJpc0NoYXJhY3RlckRldmljZSIsIm8iLCJqc19zdGF0cyIsInRvX2RpciIsInRhcmdldCIsImxpbmsiLCJmaWxlX2tpbmQiLCJNbE9iamVjdFRhYmxlIiwiTmFpdmVMb29rdXAiLCJvYmpzIiwiTWxTdHJpbmdSZWFkZXIiLCJjYW1sX2ludDY0X2NyZWF0ZV9sb19oaSIsImNhbWxfaW50NjRfaGkzMiIsImNhbWxfaW50NjRfbG8zMiIsImNhbWxfYXJyYXlfYm91bmRfZXJyb3IiLCJjYW1sX2JhX2N1c3RvbV9uYW1lIiwiTWxfQmlnYXJyYXkiLCJraW5kIiwibGF5b3V0IiwiZGltcyIsImJ1ZmZlciIsIm9mcyIsImltIiwicmUiLCJ0b3RhbCIsImsxIiwiazIiLCJOYU4iLCJNbF9CaWdhcnJheV9jXzFfMSIsIk9wdGlvbmFsX2Jvb2xfdmFsIiwibWxPcHRCb29sIiwiZGVmIiwiT3B0aW9uYWxfdmFsIiwibWxPcHRWYWwiLCJSRVBFQVRfVEFHIiwidGFnX3RvX3JlcGVhdCIsIlJlcGVhdF92YWwiLCJyZXBlYXQiLCJTTEFOVCIsIlNMQU5UX1RBRyIsInRhZ190b19zbGFudCIsIlNsYW50X3ZhbCIsInNsYW50IiwiVUludDhBcnJheVJlYWRlciIsImJ1dHRvbl90b190YWciLCJWYWxfYnV0dG9uIiwiYnV0dG9uIiwiYnV0dG9uX3N0YXRlX3RvX3RhZyIsIlZhbF9idXR0b25fc3RhdGUiLCJzdGF0ZSIsImNhcF90eXBlX3RvX3RhZyIsIlZhbF9jYXBfdHlwZSIsImNvbXBvcF90b190YWciLCJWYWxfY29tcG9wIiwiY29tcG9wIiwiX2NvbG9yX29mX2ludCIsImciLCJWYWxfZHJhd19zdHlsZSIsImZvY3VzX3RvX3RhZyIsIlZhbF9mb2N1c19pbl9vdXQiLCJmb2N1cyIsImpvaW5fdHlwZV90b190YWciLCJWYWxfam9pbl90eXBlIiwia2NfdG9fdGFnIiwiVmFsX2tleV9jb2RlIiwia2V5X3N0YXRlX3RvX3RhZyIsIlZhbF9rZXlfc3RhdGUiLCJyZXBlYXRfdG9fdGFnIiwiVmFsX3JlcGVhdCIsIl9ldmVudF9jYW52YXNfc2NhbGUiLCJlIiwiX2ZvY3VzIiwiY2FtbF9pbnQ2NF9vZl9mbG9hdCIsIl9tbF9jYW52YXNfbWxQcm9jZXNzRXZlbnQiLCJfbWxfY2FudmFzX21sRXhjZXB0aW9uIiwiX21sX2NhbnZhc19pbml0aWFsaXplZCIsIl9tbF9jYW52YXNfZW5zdXJlX2luaXRpYWxpemVkIiwiX21sX2NhbnZhc19tbENvbnRpbnVhdGlvbiIsIm1sX2NhbnZhc19zdG9wIiwiX21sX2NhbnZhc19wcm9jZXNzX2V2ZW50IiwibWxFdmVudCIsIl9mcmFtZV9oYW5kbGVyIiwidGltZXN0YW1wIiwic3VyZmFjZXMiLCJkb2N1bWVudCIsImV2dCIsIndpbmRvdyIsIl9tb3ZlIiwibWxfY2FudmFzX2hpZGUiLCJjYW52YXMiLCJtbF9jYW52YXNfY2xvc2UiLCJfaGVhZGVyX2Rvd25faGFuZGxlciIsIl9pbnRfb2ZfY29sb3IiLCJwYXJzZUludCIsInJnYmEiLCJwYXJzZUZsb2F0IiwiX2ludGVybmFsX2NhbnZhcyIsIl9pbnRlcm5hbF9jdHh0Iiwia25fdG9fa2MiLCJrZXluYW1lX3RvX2tleWNvZGUiLCJrZXluYW1lIiwiX21ha2Vfa2V5X2V2ZW50IiwiY2hhciIsIl9rZXlfZG93bl9oYW5kbGVyIiwiX2tleV91cF9oYW5kbGVyIiwiX21sX2NhbnZhc19hZGp1c3RfYmxpdF9pbmZvIiwiZHdpZHRoIiwiZGhlaWdodCIsImR4IiwiZHkiLCJzd2lkdGgiLCJzaGVpZ2h0Iiwic3giLCJzeSIsIndpZHRoIiwiaGVpZ2h0IiwiY2FtbF9iYV9nZXRfc2l6ZSIsIm5fZGltcyIsInNpemUiLCJjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50IiwiY2FtbF9iYV9jcmVhdGVfdW5zYWZlIiwic2l6ZV9wZXJfZWxlbWVudCIsIl9tbF9jYW52YXNfYmFfb2ZfaW1nIiwiaW1nIiwic3VyZmFjZSIsImN0eHQiLCJpbWFnZSIsInN0YSIsImR0YSIsImNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nIiwiX21sX2NhbnZhc19kZWNvcmF0ZSIsImhlYWRlciIsIm1pbmltaXplIiwibWF4aW1pemUiLCJjbG9zZSIsInRpdGxlIiwiZnNfbm9kZV9zdXBwb3J0ZWQiLCJtYWtlX3BhdGhfaXNfYWJzb2x1dGUiLCJwb3NpeCIsIndpbjMyIiwic3BsaXREZXZpY2VSZSIsInJlc3VsdCIsImRldmljZSIsImlzVW5jIiwiQm9vbGVhbiIsInNlcCIsInBhdGhfaXNfYWJzb2x1dGUiLCJjYW1sX3RyYWlsaW5nX3NsYXNoIiwiY2FtbF9jdXJyZW50X2RpciIsImNhbWxfbWFrZV9wYXRoIiwiY29tcDAiLCJuY29tcCIsImNhbWxfZ2V0X3Jvb3QiLCJjYW1sX2ZhaWx3aXRoIiwiY2FtbF9yb290IiwianNvb19tb3VudF9wb2ludCIsInJlc29sdmVfZnNfZGV2aWNlIiwiY2FtbF9yZWFkX2ZpbGVfY29udGVudCIsIl9tbF9jYW52YXNfaW1hZ2Vfb2ZfcG5nX2ZpbGUiLCJmaWxlbmFtZSIsImZjIiwiY2FtbF9iYV9kaW0iLCJjYW1sX2JhX3RvX3R5cGVkX2FycmF5IiwiX21sX2NhbnZhc19zdXJmYWNlX29mX2JhIiwiX21sX2NhbnZhc192YWxpZF9jYW52YXNfc2l6ZSIsIl9tb3ZlX2hhbmRsZXIiLCJuZXdfeCIsIm5ld195IiwiX25leHRfaWQiLCJfcmVzaXplX2hhbmRsZXIiLCJlbnRyaWVzIiwiX3Jlc2l6ZSIsIl9zdXJmYWNlX2Rvd25faGFuZGxlciIsIl91cF9oYW5kbGVyIiwiaW5jcl9uYXQiLCJuYXQiLCJjYXJyeV9pbiIsImNhcnJ5IiwiYWRkX25hdCIsIm5hdDEiLCJvZnMxIiwibGVuMSIsIm5hdDIiLCJvZnMyIiwibGVuMiIsImJpZ3N0cmluZ19vZl9hcnJheV9idWZmZXIiLCJhYiIsInRhIiwiYmlnc3RyaW5nX29mX3R5cGVkX2FycmF5IiwiYmlnc3RyaW5nX3RvX2FycmF5X2J1ZmZlciIsImJpZ3N0cmluZ190b190eXBlZF9hcnJheSIsImJsaXRfbmF0IiwiY2FtbF9NRDVUcmFuc2Zvcm0iLCJhZGQiLCJ4eCIsImZmIiwiZ2ciLCJoaCIsImlpIiwidyIsImNhbWxfTUQ1RmluYWwiLCJjdHgiLCJpbl9idWYiLCJjYW1sX01ENUluaXQiLCJBcnJheUJ1ZmZlciIsImIzMiIsIlVpbnQzMkFycmF5IiwiYjgiLCJjYW1sX01ENVVwZGF0ZSIsImlucHV0IiwiaW5wdXRfbGVuIiwiaW5wdXRfcG9zIiwibWlzc2luZyIsImNhbWxfYWNvc2hfZmxvYXQiLCJjYW1sX2NhbGxfZ2VuIiwiYXJnc0xlbiIsIm5hcmdzIiwiZXh0cmFfYXJncyIsImFyZ3VtZW50cyIsImNhbWxfYWxsb2NfZHVtbXlfaW5maXgiLCJjYW1sX2FsbG9jX3N0YWNrIiwiaHYiLCJoeCIsImhmIiwiY2FtbF9hcmd2IiwibWFpbiIsImFyZ3YiLCJwIiwiYXJnczIiLCJjYW1sX2FycmF5X2FwcGVuZCIsImExIiwiYTIiLCJsMSIsImwyIiwiY2FtbF9hcnJheV9ibGl0IiwiY2FtbF9hcnJheV9jb25jYXQiLCJjYW1sX2FycmF5X2ZpbGwiLCJhcnJheSIsImNhbWxfYXJyYXlfZ2V0IiwiaW5kZXgiLCJjYW1sX2FycmF5X29mX2J5dGVzIiwiY2FtbF9hcnJheV9vZl9zdHJpbmciLCJjYW1sX2FycmF5X3NldCIsIm5ld3ZhbCIsImNhbWxfYXJyYXlfc3ViIiwiY2FtbF9hc2luaF9mbG9hdCIsImNhbWxfYXRhbmhfZmxvYXQiLCJjYW1sX2F0b21pY19jYXMiLCJyZWYiLCJjYW1sX2F0b21pY19leGNoYW5nZSIsImNhbWxfYXRvbWljX2ZldGNoX2FkZCIsImNhbWxfYXRvbWljX2xvYWQiLCJjYW1sX2F0b21pY19tYWtlX2NvbnRlbmRlZCIsImNhbWxfYmFfYmxpdCIsImRzdCIsImNhbWxfYmFfY2hhbmdlX2xheW91dCIsIm5ld19kaW1zIiwiY2FtbF9iYV9jb21wYXJlIiwiY2FtbF9iYV9jcmVhdGVfYnVmZmVyIiwidmlldyIsIkZsb2F0MzJBcnJheSIsIkZsb2F0NjRBcnJheSIsIkludDhBcnJheSIsIkludDE2QXJyYXkiLCJVaW50MTZBcnJheSIsImNhbWxfanNfZnJvbV9hcnJheSIsImNhbWxfYmFfY3JlYXRlIiwiZGltc19tbCIsImNhbWxfYmFfY3JlYXRlX2Zyb20iLCJkYXRhMSIsImRhdGEyIiwianN0eXAiLCJjYW1sX2ludDMyX2Zsb2F0X29mX2JpdHMiLCJpbnQzMmEiLCJmbG9hdDMyYSIsImNhbWxfaW50NjRfb2ZfYnl0ZXMiLCJjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMiLCJleHAiLCJJbmZpbml0eSIsImsiLCJjYW1sX2JhX2Rlc2VyaWFsaXplIiwicmVhZGVyIiwic3oiLCJudW1fZGltcyIsInNpemVfZGltIiwic2l6ZV9kaW1faGkiLCJzaXplX2RpbV9sbyIsInNpeHR5IiwiaW50NjQiLCJjYW1sX2JhX2RpbV8xIiwiY2FtbF9iYV9kaW1fMiIsImNhbWxfYmFfZGltXzMiLCJjYW1sX2JhX2ZpbGwiLCJjYW1sX2JhX2tpbmRfb2ZfdHlwZWRfYXJyYXkiLCJVaW50OENsYW1wZWRBcnJheSIsImNhbWxfYmFfZnJvbV90eXBlZF9hcnJheSIsImNhbWxfYmFfZ2V0XzIiLCJjYW1sX2JhX2dldF8zIiwiY2FtbF9iYV9nZXRfZ2VuZXJpYyIsImNhbWxfbXVsIiwiY2FtbF9oYXNoX21peF9pbnQiLCJsb2cyX29rIiwianNvb19mbG9vcl9sb2cyIiwiY2FtbF9pbnQ2NF9jcmVhdGVfbG9fbWlfaGkiLCJjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQiLCJpc0Zpbml0ZSIsImlzTmFOIiwicjMiLCJyMiIsInIxIiwiY2FtbF9oYXNoX21peF9pbnQ2NCIsImNhbWxfaGFzaF9taXhfZmxvYXQiLCJ2MCIsImNhbWxfYmFfaGFzaCIsIm51bV9lbHRzIiwiY2FtbF9iYV9pbml0IiwiY2FtbF9iYV9raW5kIiwiY2FtbF9iYV9sYXlvdXQiLCJjYW1sX2JhX21hcF9maWxlIiwidmZkIiwic2hhcmVkIiwiY2FtbF9iYV9tYXBfZmlsZV9ieXRlY29kZSIsImFyZ24iLCJjYW1sX2JhX251bV9kaW1zIiwiY2FtbF9iYV9yZXNoYXBlIiwidmluZCIsIm5ld19kaW0iLCJjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXQiLCJjYW1sX2ludDY0X3RvX2J5dGVzIiwiY2FtbF9iYV9zZXJpYWxpemUiLCJ3cml0ZXIiLCJjb21wbGV4IiwiY2FtbF9iYV9zZXRfMSIsImNhbWxfYmFfc2V0XzIiLCJjYW1sX2JhX3NldF8zIiwiY2FtbF9iYV9zZXRfZ2VuZXJpYyIsImNhbWxfYmFfc2xpY2UiLCJudW1faW5kcyIsInN1Yl9kaW1zIiwibmV3X2RhdGEiLCJjYW1sX2JhX3N1YiIsImNoYW5nZWRfZGltIiwibXVsIiwiY2FtbF9iYV91aW50OF9nZXQxNiIsImIxIiwiYjIiLCJjYW1sX2JhX3VpbnQ4X2dldDMyIiwiYjMiLCJiNCIsImNhbWxfYmFfdWludDhfZ2V0NjQiLCJiNSIsImI2IiwiYjciLCJjYW1sX2JhX3VpbnQ4X3NldDE2IiwiY2FtbF9iYV91aW50OF9zZXQzMiIsImNhbWxfYmFfdWludDhfc2V0NjQiLCJjYW1sX2JhY2t0cmFjZV9zdGF0dXMiLCJfdW5pdCIsImNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYmEiLCJiYTEiLCJwb3MxIiwiYmEyIiwicG9zMiIsInNsaWNlIiwiY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19ieXRlcyIsImJ5dGVzMiIsImNhbWxfYmlnc3RyaW5nX2JsaXRfYnl0ZXNfdG9fYmEiLCJzdHIxIiwiY2FtbF9iaWdzdHJpbmdfYmxpdF9zdHJpbmdfdG9fYmEiLCJjYW1sX2JpZ3N0cmluZ19tZW1jbXAiLCJjYW1sX2JsaXRfc3RyaW5nIiwiY2FtbF9ic3dhcDE2IiwiY2FtbF9idWlsZF9zeW1ib2xzIiwic3ltYiIsImNhbWxfYnl0ZXNfY29tcGFyZSIsImNhbWxfYnl0ZXNfZXF1YWwiLCJjYW1sX2J5dGVzX3Vuc2FmZV9nZXQiLCJjYW1sX2J5dGVzX2dldCIsImNhbWxfYnl0ZXNfZ2V0MTYiLCJjYW1sX2J5dGVzX2dldDMyIiwiY2FtbF9ieXRlc19nZXQ2NCIsImNhbWxfYnl0ZXNfbGVzc2VxdWFsIiwiY2FtbF9ieXRlc19ncmVhdGVyZXF1YWwiLCJjYW1sX2J5dGVzX2xlc3N0aGFuIiwiY2FtbF9ieXRlc19ncmVhdGVydGhhbiIsImNhbWxfYnl0ZXNfbm90ZXF1YWwiLCJjYW1sX2J5dGVzX29mX3V0ZjE2X2pzc3RyaW5nIiwiY2FtbF9ieXRlc19zZXQxNiIsImkxNiIsImNhbWxfYnl0ZXNfc2V0MzIiLCJpMzIiLCJjYW1sX2J5dGVzX3NldDY0IiwiaTY0IiwiY2FtbF9jYWxsYmFjayIsImNhbWxfY2JydF9mbG9hdCIsImNhbWxfbWxfY2hhbm5lbHMiLCJjYW1sX21sX2NoYW5uZWxfZ2V0IiwiaWQiLCJjYW1sX2NoYW5uZWxfZGVzY3JpcHRvciIsImNoYW5pZCIsImNoYW4iLCJjYW1sX2NoZWNrX2JvdW5kIiwiY2FtbF9jbGFzc2lmeV9mbG9hdCIsImNhbWxfaXNfY29udGludWF0aW9uX3RhZyIsImNhbWxfaW50MzJfdW5tYXJzaGFsIiwiY2FtbF9uYXRpdmVpbnRfdW5tYXJzaGFsIiwiY2FtbF9pbnQ2NF91bm1hcnNoYWwiLCJjYW1sX2ludDY0X21hcnNoYWwiLCJzaXplcyIsImNhbWxfaW50NjRfY29tcGFyZSIsImNhbWxfaW50NjRfaGFzaCIsImNhbWxfY3VzdG9tX29wcyIsImNhbWxfY29tcGFyZV92YWxfZ2V0X2N1c3RvbSIsImNhbWxfY29tcGFyZV92YWxfbnVtYmVyX2N1c3RvbSIsIm51bSIsImN1c3RvbSIsInN3YXAiLCJjYW1sX2NvbXBhcmVfdmFsX3RhZyIsIk51bWJlciIsImNhbWxfaW50X2NvbXBhcmUiLCJjYW1sX3N0cmluZ19jb21wYXJlIiwiY2FtbF9jb21wYXJlX3ZhbCIsInN0YWNrIiwidGFnX2EiLCJ0YWdfYiIsImNhbWxfY29tcGFyZSIsImNhbWxfY29udGludWF0aW9uX3VzZV9ub2V4YyIsImNvbnQiLCJjYW1sX2NvbnRpbnVhdGlvbl91c2VfYW5kX3VwZGF0ZV9oYW5kbGVyX25vZXhjIiwiaHZhbCIsImhleG4iLCJoZWZmIiwiY2FtbF9jb252ZXJ0X3Jhd19iYWNrdHJhY2UiLCJjYW1sX2NvbnZlcnRfcmF3X2JhY2t0cmFjZV9zbG90IiwiY2FtbF9jb3B5c2lnbl9mbG9hdCIsImNhbWxfY29zaF9mbG9hdCIsImNhbWxfY3JlYXRlX2ZpbGUiLCJjYW1sX2NyZWF0ZV9zdHJpbmciLCJjYW1sX2N1c3RvbV9ldmVudF9pbmRleCIsImNhbWxfZGVjb21wcmVzc19pbnB1dCIsImNhbWxfZGl2IiwiY2FtbF9kb21haW5fZGxzIiwiY2FtbF9kb21haW5fZGxzX2dldCIsInVuaXQiLCJjYW1sX2RvbWFpbl9kbHNfc2V0IiwiY2FtbF9kb21haW5faWQiLCJjYW1sX21sX211dGV4X3VubG9jayIsImNhbWxfZG9tYWluX2xhdGVzdF9pZHgiLCJjYW1sX2RvbWFpbl9zcGF3biIsIm11dGV4IiwiY2FtbF9lcGhlX2RhdGFfb2Zmc2V0IiwiY2FtbF9lcGhlX2tleV9vZmZzZXQiLCJjYW1sX2VwaGVfdW5zZXRfZGF0YSIsImNhbWxfZXBoZV9zZXRfZGF0YSIsImNhbWxfZXBoZV9ibGl0X2RhdGEiLCJjYW1sX2VwaGVfYmxpdF9rZXkiLCJjYW1sX2VwaGVfY2hlY2tfZGF0YSIsImNhbWxfZXBoZV9jaGVja19rZXkiLCJ3ZWFrIiwiY2FtbF93ZWFrX2NyZWF0ZSIsImNhbWxfZXBoZV9jcmVhdGUiLCJjYW1sX2VwaGVfZ2V0X2RhdGEiLCJjYW1sX29ial9kdXAiLCJjYW1sX2VwaGVfZ2V0X2RhdGFfY29weSIsImNhbWxfZXBoZV9nZXRfa2V5IiwiY2FtbF9lcGhlX2dldF9rZXlfY29weSIsInoiLCJjYW1sX2VwaGVfc2V0X2tleSIsIk9iamVjdCIsImNhbWxfZXBoZV91bnNldF9rZXkiLCJjb3VudCIsImNhbWxfZXF1YWwiLCJjYW1sX2VyZl9mbG9hdCIsImEzIiwiYTQiLCJhNSIsImNhbWxfZXJmY19mbG9hdCIsImNhbWxfZXZlbnRsb2dfcGF1c2UiLCJjYW1sX2V2ZW50bG9nX3Jlc3VtZSIsImNhbWxfZXhlY3V0YWJsZV9uYW1lIiwiY2FtbF9leHAyX2Zsb2F0IiwiY2FtbF9leHBtMV9mbG9hdCIsImNhbWxfaXNfc3BlY2lhbF9leGNlcHRpb24iLCJjYW1sX2Zvcm1hdF9leGNlcHRpb24iLCJidWNrZXQiLCJzdGFydCIsImNhbWxfZmF0YWxfdW5jYXVnaHRfZXhjZXB0aW9uIiwiaGFuZGxlciIsImF0X2V4aXQiLCJjYW1sX2ZpbGxfYnl0ZXMiLCJjYW1sX2ZpbmFsX3JlZ2lzdGVyIiwiYWxsX2ZpbmFsaXplcnMiLCJjYW1sX2ZpbmFsX3JlZ2lzdGVyX2NhbGxlZF93aXRob3V0X3ZhbHVlIiwiY2IiLCJjYW1sX2ZpbmFsX3JlbGVhc2UiLCJjYW1sX2ZpbmlzaF9mb3JtYXR0aW5nIiwicmF3YnVmZmVyIiwiY2FtbF9mbG9hdF9jb21wYXJlIiwiY2FtbF9mbG9hdF9vZl9ieXRlcyIsImNhbWxfZmxvYXRfb2Zfc3RyaW5nIiwibTMiLCJtYW50aXNzYSIsImV4cG9uZW50IiwiY2FtbF9mbG9hdGFycmF5X2JsaXQiLCJjYW1sX2Zsb2F0YXJyYXlfY3JlYXRlIiwiY2FtbF9mbWFfZmxvYXQiLCJTUExJVCIsIk1JTl9WQUxVRSIsIkVQU0lMT04iLCJDIiwiQSIsIkIiLCJtdWx0aXBseSIsImF0IiwiYWhpIiwiYWxvIiwiYnQiLCJiaGkiLCJibG8iLCJhZGp1c3QiLCJzY2FsZSIsInhzIiwieXMiLCJ6cyIsInh5IiwidSIsImZzIiwiY2FtbF9wYXJzZV9mb3JtYXQiLCJmbXQiLCJjYW1sX2Zvcm1hdF9mbG9hdCIsInRvRml4ZWQiLCJkcCIsInByZWMiLCJjYW1sX2Zvcm1hdF9pbnQiLCJjYW1sX29vX2xhc3RfaWQiLCJjYW1sX2ZyZXNoX29vX2lkIiwiY2FtbF9mcmV4cF9mbG9hdCIsIm5lZyIsImpzb29fY3JlYXRlX2ZpbGUiLCJjYW1sX2ZzX2luaXQiLCJ0bXAiLCJjYW1sX2djX2NvbXBhY3Rpb24iLCJjYW1sX2djX2NvdW50ZXJzIiwiY2FtbF9nY19mdWxsX21ham9yIiwiY2FtbF9nY19nZXQiLCJjYW1sX2djX2h1Z2VfZmFsbGJhY2tfY291bnQiLCJjYW1sX2djX21ham9yIiwiY2FtbF9nY19tYWpvcl9zbGljZSIsIndvcmsiLCJjYW1sX2djX21pbm9yIiwiY2FtbF9nY19taW5vcl93b3JkcyIsImNhbWxfZ2NfcXVpY2tfc3RhdCIsImNhbWxfZ2Nfc2V0IiwiX2NvbnRyb2wiLCJjYW1sX2djX3N0YXQiLCJjYW1sX2dldF9jb250aW51YXRpb25fY2FsbHN0YWNrIiwiY2FtbF9nZXRfY3VycmVudF9jYWxsc3RhY2siLCJjYW1sX2dldF9leGNlcHRpb25fYmFja3RyYWNlIiwiY2FtbF9nZXRfZXhjZXB0aW9uX3Jhd19iYWNrdHJhY2UiLCJjYW1sX2dldF9nbG9iYWxfZGF0YSIsImNhbWxfZ2V0X21ham9yX2J1Y2tldCIsImNhbWxfZ2V0X21ham9yX2NyZWRpdCIsImNhbWxfZ2V0X21pbm9yX2ZyZWUiLCJjYW1sX21ldGhvZF9jYWNoZSIsImNhbWxfZ2V0X3B1YmxpY19tZXRob2QiLCJvYmoiLCJjYWNoZWlkIiwibWV0aHMiLCJsaSIsImNhbWxfZ3JfYXJjX2F1eCIsImN4IiwiY3kiLCJyeSIsInJ4Iiwicm90IiwieFBvcyIsInlQb3MiLCJ4UG9zX3ByZXYiLCJ5UG9zX3ByZXYiLCJzcGFjZSIsImRlbHRhIiwiY2FtbF9ncl9zdGF0ZSIsImNhbWxfZ3Jfc3RhdGVfZ2V0IiwiY2FtbF9ncl9ibGl0X2ltYWdlIiwiaW0yIiwiY2FtbF9ncl9jbGVhcl9ncmFwaCIsImNhbWxfZ3JfY2xvc2VfZ3JhcGgiLCJjYW1sX2dyX2Nsb3NlX3N1YndpbmRvdyIsImNhbWxfZ3JfY3JlYXRlX2ltYWdlIiwiY2FtbF9ncl9jdXJyZW50X3giLCJjYW1sX2dyX2N1cnJlbnRfeSIsImNhbWxfZ3JfZGlzcGxheV9tb2RlIiwiY2FtbF9ncl9kb2Nfb2Zfc3RhdGUiLCJjYW1sX2dyX2RyYXdfYXJjIiwiY2FtbF9ncl9kcmF3X3N0ciIsInN0ciIsImNhbWxfZ3JfZHJhd19jaGFyIiwiY2FtbF9ncl9kcmF3X2ltYWdlIiwiY2FtbF9ncl9kcmF3X3JlY3QiLCJjYW1sX2dyX2RyYXdfc3RyaW5nIiwiY2FtbF9ncl9kdW1wX2ltYWdlIiwiY2FtbF9ncl9maWxsX2FyYyIsImNhbWxfZ3JfZmlsbF9wb2x5IiwiYXIiLCJjYW1sX2dyX2ZpbGxfcmVjdCIsImNhbWxfZ3JfbGluZXRvIiwiY2FtbF9ncl9tYWtlX2ltYWdlIiwiY2FtbF9ncl9tb3ZldG8iLCJjYW1sX2dyX3NldF93aW5kb3dfdGl0bGUiLCJqc25hbWUiLCJjYW1sX2dyX3NldF9saW5lX3dpZHRoIiwiY2FtbF9ncl9zZXRfdGV4dF9zaXplIiwiY2FtbF9ncl9zZXRfZm9udCIsImNhbWxfZ3Jfc2V0X2NvbG9yIiwiY29sb3IiLCJjb252ZXJ0IiwibnVtYmVyIiwiY19zdHIiLCJjYW1sX2dyX3Jlc2l6ZV93aW5kb3ciLCJjYW1sX2dyX3N0YXRlX2luaXQiLCJjYW1sX2dyX3N0YXRlX3NldCIsImNhbWxfZ3Jfc3RhdGVfY3JlYXRlIiwiY29udGV4dCIsImNhbWxfZ3Jfb3Blbl9ncmFwaCIsImluZm8iLCJnZXQiLCJzcGVjcyIsInN0YXR1cyIsIndpbiIsImRvYyIsImJvZHkiLCJjYW1sX2dyX29wZW5fc3Vid2luZG93IiwiY2FtbF9ncl9wbG90IiwiY2FtbF9ncl9wb2ludF9jb2xvciIsImNhbWxfZ3JfcmVtZW1iZXJfbW9kZSIsImNhbWxfZ3Jfc2lnaW9faGFuZGxlciIsImNhbWxfZ3Jfc2lnaW9fc2lnbmFsIiwiY2FtbF9ncl9zaXplX3giLCJjYW1sX2dyX3NpemVfeSIsImNhbWxfZ3Jfc3luY2hyb25pemUiLCJjYW1sX2dyX3RleHRfc2l6ZSIsInR4dCIsImNhbWxfZ3Jfd2FpdF9ldmVudCIsIl9ldmwiLCJjYW1sX2dyX3dpbmRvd19pZCIsImNhbWxfZ3JlYXRlcmVxdWFsIiwiY2FtbF9ncmVhdGVydGhhbiIsImNhbWxfaGFzaF9taXhfanNieXRlcyIsImNhbWxfaGFzaF9taXhfc3RyaW5nIiwiY2FtbF9oYXNoX21peF9ieXRlc19hcnIiLCJjYW1sX21sX2J5dGVzX2NvbnRlbnQiLCJjYW1sX2hhc2hfbWl4X2J5dGVzIiwiY2FtbF9oYXNoX21peF9maW5hbCIsImNhbWxfaGFzaCIsImxpbWl0Iiwic2VlZCIsInF1ZXVlIiwicmQiLCJ3ciIsImNhbWxfaGFzaF9taXhfYmlnc3RyaW5nIiwibnVtX2RpZ2l0c19uYXQiLCJjYW1sX2hhc2hfbmF0IiwiY2FtbF9oZXhzdHJpbmdfb2ZfZmxvYXQiLCJleHBfc2lnbiIsInNpZ25fc3RyIiwiY3N0IiwieF9zdHIiLCJpZHgiLCJjYW1sX2h5cG90X2Zsb2F0IiwiY2FtbF9tYXJzaGFsX2hlYWRlcl9zaXplIiwiY2FtbF9yZWZpbGwiLCJzdHJfYSIsIm5yZWFkIiwiY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZSIsImNhbWxfbWFyc2hhbF9kYXRhX3NpemUiLCJyZWFkdmxxIiwib3ZlcmZsb3ciLCJuNyIsImhlYWRlcl9sZW4iLCJkYXRhX2xlbiIsImNhbWxfaW5wdXRfdmFsdWVfZnJvbV9yZWFkZXIiLCJtYWdpYyIsImNvbXByZXNzZWQiLCJ1bmNvbXByZXNzZWRfZGF0YV9sZW4iLCJudW1fb2JqZWN0cyIsIl9zaXplXzMyIiwiX3NpemVfNjQiLCJpbnRlcm5fb2JqX3RhYmxlIiwib2JqX2NvdW50ZXIiLCJpbnRlcm5fcmVjIiwib3BzIiwiZXhwZWN0ZWRfc2l6ZSIsIm9sZF9wb3MiLCJjYW1sX3N0cmluZ19vZl9ieXRlcyIsImNhbWxfaW5wdXRfdmFsdWVfZnJvbV9ieXRlcyIsImNhbWxfaW5wdXRfdmFsdWUiLCJibG9jayIsImNhbWxfaW5wdXRfdmFsdWVfZnJvbV9zdHJpbmciLCJjYW1sX2lucHV0X3ZhbHVlX3RvX291dHNpZGVfaGVhcCIsImNhbWxfaW5zdGFsbF9zaWduYWxfaGFuZGxlciIsImNhbWxfaW50MzJfYnN3YXAiLCJjYW1sX2ludDY0X2FkZCIsImNhbWxfaW50NjRfYW5kIiwiY2FtbF9pbnQ2NF9ic3dhcCIsImNhbWxfaW50NjRfZGl2IiwiY2FtbF9pbnQ2NF9pc196ZXJvIiwiY2FtbF9pbnQ2NF9vZl9pbnQzMiIsImNhbWxfaW50NjRfdG9faW50MzIiLCJjYW1sX2ludDY0X2lzX25lZ2F0aXZlIiwiY2FtbF9pbnQ2NF9uZWciLCJjYW1sX2ludDY0X2Zvcm1hdCIsIndiYXNlIiwiY3Z0YmwiLCJjYW1sX2ludDY0X21vZCIsImNhbWxfaW50NjRfbXVsIiwiY2FtbF9pbnQ2NF91bHQiLCJjYW1sX3BhcnNlX3NpZ25fYW5kX2Jhc2UiLCJiYXNlIiwiY2FtbF9wYXJzZV9kaWdpdCIsImNhbWxfaW50NjRfb2Zfc3RyaW5nIiwiYmFzZTY0IiwidGhyZXNob2xkIiwiY2FtbF9pbnQ2NF9vciIsImNhbWxfaW50NjRfc2hpZnRfbGVmdCIsImNhbWxfaW50NjRfc2hpZnRfcmlnaHQiLCJjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0X3Vuc2lnbmVkIiwiY2FtbF9pbnQ2NF9zdWIiLCJjYW1sX2ludDY0X3RvX2Zsb2F0IiwiY2FtbF9pbnQ2NF94b3IiLCJjYW1sX2ludF9vZl9zdHJpbmciLCJjYW1sX2lzX2pzIiwiY2FtbF9pc19wcmludGFibGUiLCJjYW1sX2pzX2NhbGwiLCJjYW1sX2pzX2RlbGV0ZSIsImNhbWxfanNfZXF1YWxzIiwiY2FtbF9qc19lcnJvcl9vZl9leGNlcHRpb24iLCJjYW1sX2pzX2Vycm9yX29wdGlvbl9vZl9leGNlcHRpb24iLCJjYW1sX2pzX2V2YWxfc3RyaW5nIiwiZXZhbCIsImNhbWxfanNfZXhwciIsImNhbWxfanNfZnJvbV9ib29sIiwiY2FtbF9qc19mcm9tX2Zsb2F0IiwiY2FtbF9qc19mcm9tX3N0cmluZyIsImNhbWxfanNfZnVuX2NhbGwiLCJjYW1sX2pzX2Z1bmN0aW9uX2FyaXR5IiwiY2FtbF9qc19nZXQiLCJjYW1sX2pzX2dldF9jb25zb2xlIiwiY2FtbF9qc19odG1sX2VudGl0aWVzIiwiZW50aXR5IiwidGVtcCIsImNhbWxfanNfcmVnZXhwcyIsImNhbWxfanNfaHRtbF9lc2NhcGUiLCJjYW1sX2pzX2luc3RhbmNlb2YiLCJjYW1sX2pzX21ldGhfY2FsbCIsImNhbWxfanNfbmV3IiwiRiIsImNhbWxfanNfb2JqZWN0IiwiY2FtbF9qc19vbl9pZSIsInVhIiwiY2FtbF9qc19wdXJlX2V4cHIiLCJjYW1sX2pzX3NldCIsImNhbWxfanNfc3RyaWN0X2VxdWFscyIsImNhbWxfanNfdG9fYXJyYXkiLCJjYW1sX2pzX3RvX2Jvb2wiLCJjYW1sX2pzX3RvX2J5dGVfc3RyaW5nIiwiY2FtbF9qc190b19mbG9hdCIsImNhbWxfanNfdG9faW50MzIiLCJjYW1sX2pzX3RvX3N0cmluZyIsImNhbWxfanNfdHlwZW9mIiwiY2FtbF9qc192YXIiLCJjYW1sX2pzX3dyYXBfY2FsbGJhY2siLCJGdW5jdGlvbiIsImNhbWxfanNfd3JhcF9jYWxsYmFja19hcmd1bWVudHMiLCJjYW1sX2pzX3dyYXBfY2FsbGJhY2tfc3RyaWN0IiwiYXJpdHkiLCJjYW1sX2pzX3dyYXBfY2FsbGJhY2tfdW5zYWZlIiwiY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2siLCJjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja19hcmd1bWVudHMiLCJjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja19zdHJpY3QiLCJjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja191bnNhZmUiLCJjYW1sX2pzb29fZmxhZ3NfZWZmZWN0cyIsImNhbWxfanNvb19mbGFnc191c2VfanNfc3RyaW5nIiwiY2FtbF9sYXp5X21ha2VfZm9yd2FyZCIsImNhbWxfb2JqX3RhZyIsImNhbWxfbGF6eV9yZWFkX3Jlc3VsdCIsImNhbWxfb2JqX3VwZGF0ZV90YWciLCJjYW1sX2xhenlfcmVzZXRfdG9fbGF6eSIsImNhbWxfbGF6eV91cGRhdGVfdG9fZm9yY2luZyIsImNhbWxfbGF6eV91cGRhdGVfdG9fZm9yd2FyZCIsImNhbWxfbGRleHBfZmxvYXQiLCJjYW1sX2xlc3NlcXVhbCIsImNhbWxfbGVzc3RoYW4iLCJjYW1sX2xleF9hcnJheSIsImNhbWxfbGV4X2VuZ2luZSIsInRibCIsInN0YXJ0X3N0YXRlIiwibGV4YnVmIiwibGV4X2J1ZmZlciIsImxleF9idWZmZXJfbGVuIiwibGV4X3N0YXJ0X3BvcyIsImxleF9jdXJyX3BvcyIsImxleF9sYXN0X3BvcyIsImxleF9sYXN0X2FjdGlvbiIsImxleF9lb2ZfcmVhY2hlZCIsImxleF9iYXNlIiwibGV4X2JhY2t0cmsiLCJsZXhfZGVmYXVsdCIsImxleF90cmFucyIsImxleF9jaGVjayIsImJhY2t0cmsiLCJjYW1sX2xpc3RfbW91bnRfcG9pbnQiLCJwcmV2IiwiY2FtbF9saXN0X29mX2pzX2FycmF5IiwiY2FtbF9saXN0X3RvX2pzX2FycmF5IiwiY2FtbF9sb2cxMF9mbG9hdCIsImNhbWxfbG9nMXBfZmxvYXQiLCJjYW1sX2xvZzJfZmxvYXQiLCJjYW1sX25ld19zdHJpbmciLCJjYW1sX2x4bV9uZXh0Iiwic2hpZnRfbCIsInNoaWZ0X3IiLCJvciIsInhvciIsInJvdGwiLCJzZXQiLCJNIiwiZGFiYSIsInEwIiwicTEiLCJzdCIsIngwIiwieDEiLCJjYW1sX21ha2VfZmxvYXRfdmVjdCIsImNhbWxfbWFrZV92ZWN0IiwiaW5pdCIsImNhbWxfbWFyc2hhbF9jb25zdGFudHMiLCJjYW1sX21heWJlX3ByaW50X3N0YXRzIiwiY2FtbF9tZDVfYnl0ZXMiLCJjYW1sX21sX2lucHV0X2Jsb2NrIiwiYXZhaWwiLCJjYW1sX21kNV9jaGFuIiwidG9yZWFkIiwiY2FtbF9tZDVfc3RyaW5nIiwiY2FtbF9tZW1wcm9mX2Rpc2NhcmQiLCJjYW1sX21lbXByb2Zfc2V0IiwiY2FtbF9tZW1wcm9mX3N0YXJ0IiwicmF0ZSIsInN0YWNrX3NpemUiLCJ0cmFja2VyIiwiY2FtbF9tZW1wcm9mX3N0b3AiLCJjYW1sX21sX2NoYW5uZWxfcmVkaXJlY3QiLCJjYXB0dXJlZCIsImludG8iLCJ0b19yZXN0b3JlIiwibmV3XyIsImNhbWxfbWxfY2hhbm5lbF9yZXN0b3JlIiwiY2FtbF9tbF9jaGFubmVsX3NpemUiLCJjYW1sX21sX2NoYW5uZWxfc2l6ZV82NCIsImNhbWxfc3lzX2ZkcyIsImNhbWxfc3lzX2Nsb3NlIiwiY2FtbF9tbF9mbHVzaCIsImNhbWxfbWxfY2xvc2VfY2hhbm5lbCIsImNhbWxfbWxfY29uZGl0aW9uX2Jyb2FkY2FzdCIsImNhbWxfbWxfY29uZGl0aW9uX25ldyIsImNhbWxfbWxfY29uZGl0aW9uX3NpZ25hbCIsImNhbWxfbWxfY29uZGl0aW9uX3dhaXQiLCJtdXRleHQiLCJjYW1sX21sX2RlYnVnX2luZm9fc3RhdHVzIiwiY2FtbF9tbF9kb21haW5fY3B1X3JlbGF4IiwiY2FtbF9tbF9kb21haW5faWQiLCJjYW1sX21sX2RvbWFpbl9zZXRfbmFtZSIsIl9uYW1lIiwiY2FtbF9tbF9kb21haW5fdW5pcXVlX3Rva2VuXyIsImNhbWxfbWxfZG9tYWluX3VuaXF1ZV90b2tlbiIsImNhbWxfcnVudGltZV93YXJuaW5ncyIsImNhbWxfbWxfZW5hYmxlX3J1bnRpbWVfd2FybmluZ3MiLCJib29sIiwiY2FtbF9tbF9pbnB1dCIsImNhbWxfbWxfaW5wdXRfYmlnYXJyYXkiLCJjYW1sX21sX2lucHV0X2NoYXIiLCJjYW1sX21sX2lucHV0X2ludCIsImNhbWxfbWxfaW5wdXRfc2Nhbl9saW5lIiwicHJldl9tYXgiLCJjYW1sX21sX2lzX2J1ZmZlcmVkIiwiY2FtbF9tbF9tdXRleF9sb2NrIiwiY2FtbF9tbF9tdXRleF9uZXciLCJjYW1sX21sX211dGV4X3RyeV9sb2NrIiwiY2FtbF9zeXNfb3Blbl9mb3Jfbm9kZSIsImZkMiIsImNhbWxfc3lzX29wZW5faW50ZXJuYWwiLCJjYW1sX3N5c19vcGVuIiwiX3Blcm1zIiwiY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3JfaW4iLCJyZWZpbGwiLCJjaGFubmVsIiwiY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3Jfb3V0IiwiYnVmZmVyZWQiLCJjYW1sX21sX291dF9jaGFubmVsc19saXN0IiwiY2FtbF9tbF9vdXRwdXRfdGEiLCJjYW1sX21sX291dHB1dF9ieXRlcyIsImNhbWxfbWxfb3V0cHV0IiwiY2FtbF9tbF9vdXRwdXRfYmlnYXJyYXkiLCJjYW1sX21sX291dHB1dF9jaGFyIiwiY2FtbF9tbF9vdXRwdXRfaW50IiwiY2FtbF9wb3NfaW4iLCJjYW1sX21sX3Bvc19pbiIsImNhbWxfbWxfcG9zX2luXzY0IiwiY2FtbF9wb3Nfb3V0IiwiY2FtbF9tbF9wb3Nfb3V0IiwiY2FtbF9tbF9wb3Nfb3V0XzY0IiwiY2FtbF9tbF9ydW50aW1lX2V2ZW50c19wYXVzZSIsImNhbWxfbWxfcnVudGltZV9ldmVudHNfcmVzdW1lIiwiY2FtbF9tbF9ydW50aW1lX2V2ZW50c19zdGFydCIsImNhbWxfbWxfcnVudGltZV93YXJuaW5nc19lbmFibGVkIiwiY2FtbF9zZWVrX2luIiwiY2FtbF9tbF9zZWVrX2luIiwiY2FtbF9tbF9zZWVrX2luXzY0IiwiY2FtbF9zZWVrX291dCIsImNhbWxfbWxfc2Vla19vdXQiLCJjYW1sX21sX3NlZWtfb3V0XzY0IiwiY2FtbF9tbF9zZXRfYmluYXJ5X21vZGUiLCJjYW1sX21sX3NldF9idWZmZXJlZCIsImNhbWxfbWxfc2V0X2NoYW5uZWxfbmFtZSIsImNhbWxfbWxfc2V0X2NoYW5uZWxfb3V0cHV0IiwiY2FtbF9tbF9zZXRfY2hhbm5lbF9yZWZpbGwiLCJjYW1sX21vZCIsImNhbWxfbW9kZl9mbG9hdCIsImNhbWxfbW91bnRfYXV0b2xvYWQiLCJjYW1sX2xleF9ydW5fbWVtIiwibWVtIiwiY3Vycl9wb3MiLCJjYW1sX2xleF9ydW5fdGFnIiwiY2FtbF9uZXdfbGV4X2VuZ2luZSIsImxleF9tZW0iLCJsZXhfYmFzZV9jb2RlIiwibGV4X2JhY2t0cmtfY29kZSIsImxleF9kZWZhdWx0X2NvZGUiLCJsZXhfdHJhbnNfY29kZSIsImxleF9jaGVja19jb2RlIiwibGV4X2NvZGUiLCJwY19vZmYiLCJwc3RhdGUiLCJiYXNlX2NvZGUiLCJjYW1sX25leHRhZnRlcl9mbG9hdCIsImJpdHMiLCJvbmUiLCJjYW1sX25vdGVxdWFsIiwiY2FtbF9vYmpfYWRkX29mZnNldCIsImNhbWxfb2JqX2Jsb2NrIiwiY2FtbF9vYmpfY29tcGFyZV9hbmRfc3dhcCIsImNhbWxfb2JqX2lzX2Jsb2NrIiwiY2FtbF9vYmpfaXNfc2hhcmVkIiwiY2FtbF9vYmpfbWFrZV9mb3J3YXJkIiwiY2FtbF9vYmpfcmF3X2ZpZWxkIiwiY2FtbF9vYmpfcmVhY2hhYmxlX3dvcmRzIiwiY2FtbF9vYmpfc2V0X3Jhd19maWVsZCIsImNhbWxfb2JqX3NldF90YWciLCJjYW1sX29ial90cnVuY2F0ZSIsImNhbWxfb2JqX3dpdGhfdGFnIiwiY2FtbF9vanNfbmV3X2FyciIsImNhbWxfb3V0cHV0X3ZhbCIsIldyaXRlciIsInZhbHVlIiwibm9fc2hhcmluZyIsImNsb3N1cmVzIiwibWVtbyIsImV4aXN0aW5nX29mZnNldCIsImV4dGVybl9yZWMiLCJzel8zMl82NCIsImhlYWRlcl9wb3MiLCJ0eXBlX29mX3YiLCJjYW1sX291dHB1dF92YWx1ZV90b19zdHJpbmciLCJjYW1sX291dHB1dF92YWx1ZSIsImNhbWxfb3V0cHV0X3ZhbHVlX3RvX2J1ZmZlciIsImNhbWxfb3V0cHV0X3ZhbHVlX3RvX2J5dGVzIiwiY2FtbF9wYXJzZXJfdHJhY2UiLCJjYW1sX3BhcnNlX2VuZ2luZSIsInRhYmxlcyIsImVudiIsImNtZCIsIkVSUkNPREUiLCJsb29wIiwidGVzdHNoaWZ0Iiwic2hpZnQiLCJzaGlmdF9yZWNvdmVyIiwicmVkdWNlIiwiUkVBRF9UT0tFTiIsIlJBSVNFX1BBUlNFX0VSUk9SIiwiR1JPV19TVEFDS1NfMSIsIkdST1dfU1RBQ0tTXzIiLCJDT01QVVRFX1NFTUFOVElDX0FDVElPTiIsIkNBTExfRVJST1JfRlVOQ1RJT04iLCJlbnZfc19zdGFjayIsImVudl92X3N0YWNrIiwiZW52X3N5bWJfc3RhcnRfc3RhY2siLCJlbnZfc3ltYl9lbmRfc3RhY2siLCJlbnZfc3RhY2tzaXplIiwiZW52X3N0YWNrYmFzZSIsImVudl9jdXJyX2NoYXIiLCJlbnZfbHZhbCIsImVudl9zeW1iX3N0YXJ0IiwiZW52X3N5bWJfZW5kIiwiZW52X2FzcCIsImVudl9ydWxlX2xlbiIsImVudl9ydWxlX251bWJlciIsImVudl9zcCIsImVudl9zdGF0ZSIsImVudl9lcnJmbGFnIiwidGJsX3RyYW5zbF9jb25zdCIsInRibF90cmFuc2xfYmxvY2siLCJ0YmxfbGhzIiwidGJsX2xlbiIsInRibF9kZWZyZWQiLCJ0YmxfZGdvdG8iLCJ0Ymxfc2luZGV4IiwidGJsX3JpbmRleCIsInRibF9naW5kZXgiLCJ0YmxfdGFibGVzaXplIiwidGJsX3RhYmxlIiwidGJsX2NoZWNrIiwidGJsX25hbWVzX2NvbnN0IiwidGJsX25hbWVzX2Jsb2NrIiwibG9nIiwidG9rZW5fbmFtZSIsIm5hbWVzIiwicHJpbnRfdG9rZW4iLCJ0b2siLCJ0b2tlbiIsIm4xIiwibjIiLCJzdGF0ZTEiLCJzcCIsImVycmZsYWciLCJhc3AiLCJjYW1sX3B1cmVfanNfZXhwciIsImNhbWxfcmFpc2Vfbm90X2FfZGlyIiwiY2FtbF9yYWlzZV9ub3RfZm91bmQiLCJjYW1sX3Jhd19iYWNrdHJhY2VfbGVuZ3RoIiwiY2FtbF9yYXdfYmFja3RyYWNlX25leHRfc2xvdCIsImNhbWxfcmF3X2JhY2t0cmFjZV9zbG90IiwiY2FtbF9yZWNvbW1lbmRlZF9kb21haW5fY291bnQiLCJjYW1sX3JlY29yZF9iYWNrdHJhY2UiLCJjYW1sX3JlZ2lzdGVyX2NoYW5uZWxfZm9yX3NwYWNldGltZSIsIl9jaGFubmVsIiwiY2FtbF9yZWdpc3Rlcl9nbG9iYWwiLCJuYW1lX29wdCIsIm5pZCIsImNhbWxfcmVnaXN0ZXJfbmFtZWRfdmFsdWUiLCJjYW1sX3Jlc3RvcmVfcmF3X2JhY2t0cmFjZSIsImNhbWxfcm91bmRfZmxvYXQiLCJjYW1sX3J1bnRpbWVfZXZlbnRzX2NyZWF0ZV9jdXJzb3IiLCJjYW1sX3J1bnRpbWVfZXZlbnRzX2ZyZWVfY3Vyc29yIiwiY3Vyc29yIiwiY2FtbF9ydW50aW1lX2V2ZW50c19yZWFkX3BvbGwiLCJjYWxsYmFja3MiLCJjYW1sX3J1bnRpbWVfZXZlbnRzX3VzZXJfcmVnaXN0ZXIiLCJldmVudF9uYW1lIiwiZXZlbnRfdGFnIiwiZXZlbnRfdHlwZSIsImNhbWxfcnVudGltZV9ldmVudHNfdXNlcl9yZXNvbHZlIiwiY2FtbF9ydW50aW1lX2V2ZW50c191c2VyX3dyaXRlIiwiZXZlbnQiLCJldmVudF9jb250ZW50IiwiY2FtbF9ydW50aW1lX3BhcmFtZXRlcnMiLCJjYW1sX3J1bnRpbWVfdmFyaWFudCIsImNhbWxfc2V0X29vX2lkIiwiY2FtbF9zZXRfcGFyc2VyX3RyYWNlIiwib2xkZmxhZyIsImNhbWxfc2V0X3N0YXRpY19lbnYiLCJjYW1sX3NpZ25iaXRfZmxvYXQiLCJjYW1sX3NpbmhfZmxvYXQiLCJjYW1sX3NwYWNldGltZV9lbmFibGVkIiwiY2FtbF9zcGFjZXRpbWVfb25seV93b3Jrc19mb3JfbmF0aXZlX2NvZGUiLCJjYW1sX3N0cl9pbml0aWFsaXplIiwiY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IiLCJjYW1sX3N0cmluZ19jb25jYXQiLCJjYW1sX3N0cmluZ19lcXVhbCIsImNhbWxfc3RyaW5nX2dldCIsImNhbWxfc3RyaW5nX2dldDE2IiwiY2FtbF9zdHJpbmdfZ2V0MzIiLCJjYW1sX3N0cmluZ19nZXQ2NCIsImNhbWxfc3RyaW5nX2xlc3NlcXVhbCIsImNhbWxfc3RyaW5nX2dyZWF0ZXJlcXVhbCIsImNhbWxfc3RyaW5nX2xlc3N0aGFuIiwiY2FtbF9zdHJpbmdfZ3JlYXRlcnRoYW4iLCJjYW1sX3N0cmluZ19oYXNoIiwiY2FtbF9zdHJpbmdfbm90ZXF1YWwiLCJjYW1sX3N0cmluZ19zZXQiLCJjYW1sX3N0cmluZ19zZXQxNiIsImNhbWxfc3RyaW5nX3NldDMyIiwiY2FtbF9zdHJpbmdfc2V0NjQiLCJjYW1sX3N0cmluZ191bnNhZmVfc2V0IiwiY2FtbF9zeXNfYXJndiIsImNhbWxfc3lzX2NoZGlyIiwiZGlyIiwiY2FtbF9zeXNfY29uc3RfYmFja2VuZF90eXBlIiwiY2FtbF9zeXNfY29uc3RfYmlnX2VuZGlhbiIsImNhbWxfc3lzX2NvbnN0X2ludF9zaXplIiwiY2FtbF9zeXNfY29uc3RfbWF4X3dvc2l6ZSIsImNhbWxfc3lzX2NvbnN0X25ha2VkX3BvaW50ZXJzX2NoZWNrZWQiLCJvc190eXBlIiwiY2FtbF9zeXNfY29uc3Rfb3N0eXBlX2N5Z3dpbiIsImNhbWxfc3lzX2NvbnN0X29zdHlwZV91bml4IiwiY2FtbF9zeXNfY29uc3Rfb3N0eXBlX3dpbjMyIiwiY2FtbF9zeXNfY29uc3Rfd29yZF9zaXplIiwiY2FtbF9zeXNfZXhlY3V0YWJsZV9uYW1lIiwiY2FtbF9zeXNfZXhpdCIsImNhbWxfc3lzX2ZpbGVfZXhpc3RzIiwiY2FtbF9zeXNfZ2V0X2FyZ3YiLCJjYW1sX3N5c19nZXRfY29uZmlnIiwiY2FtbF9zeXNfZ2V0Y3dkIiwiY2FtbF9zeXNfZ2V0ZW52IiwiY2FtbF9zeXNfaXNfZGlyZWN0b3J5IiwiY2FtbF9zeXNfaXNfcmVndWxhcl9maWxlIiwiY2FtbF9zeXNfaXNhdHR5IiwiX2NoYW4iLCJjYW1sX3N5c19ta2RpciIsInBlcm0iLCJjYW1sX3N5c19tb2RpZnlfYXJndiIsImNhbWxfc3lzX3JhbmRvbV9zZWVkIiwibm93IiwiRGF0ZSIsImNhbWxfc3lzX3JlYWRfZGlyZWN0b3J5IiwiY2FtbF9zeXNfcmVtb3ZlIiwiY2FtbF9zeXNfcmVuYW1lIiwib19yb290Iiwibl9yb290IiwiY2FtbF9zeXNfcm1kaXIiLCJjYW1sX3N5c19zeXN0ZW1fY29tbWFuZCIsImNoaWxkX3Byb2Nlc3MiLCJjYW1sX2luaXRpYWxfdGltZSIsImNhbWxfc3lzX3RpbWUiLCJjYW1sX3N5c190aW1lX2luY2x1ZGVfY2hpbGRyZW4iLCJjYW1sX3N5c191bnNhZmVfZ2V0ZW52IiwiY2FtbF90YW5oX2Zsb2F0IiwiY2FtbF90b19qc19zdHJpbmciLCJjYW1sX3RyYW1wb2xpbmUiLCJjYW1sX3RyYW1wb2xpbmVfcmV0dXJuIiwiY2FtbF90cnVuY19mbG9hdCIsImNhbWxfdW5peF9jbGVhbnVwIiwiY2FtbF91bml4X2Nsb3NlZGlyIiwiZGlyX2hhbmRsZSIsImNhbWxfdW5peF9maWxlZGVzY3Jfb2ZfZmQiLCJjYW1sX3VuaXhfZmluZGNsb3NlIiwiY2FtbF91bml4X29wZW5kaXIiLCJjYW1sX3VuaXhfcmVhZGRpciIsImNhbWxfdW5peF9maW5kZmlyc3QiLCJwYXRoX2pzIiwiZmlyc3RfZW50cnkiLCJjYW1sX3VuaXhfZmluZG5leHQiLCJjYW1sX3VuaXhfZ2V0cHd1aWQiLCJjYW1sX3VuaXhfZ2V0dGltZW9mZGF5IiwiY2FtbF91bml4X2dldHVpZCIsImNhbWxfdW5peF9nbXRpbWUiLCJkX251bSIsImphbnVhcnlmaXJzdCIsImRveSIsImNhbWxfdW5peF9oYXNfc3ltbGluayIsImNhbWxfdW5peF9pbmV0X2FkZHJfb2Zfc3RyaW5nIiwiY2FtbF91bml4X2lzYXR0eSIsImZpbGVEZXNjcmlwdG9yIiwidHR5IiwiY2FtbF91bml4X2xvY2FsdGltZSIsImphbiIsImp1bCIsInN0ZFRpbWV6b25lT2Zmc2V0IiwiY2FtbF91bml4X2xzdGF0IiwiY2FtbF91bml4X2xzdGF0XzY0IiwiY2FtbF91bml4X21rZGlyIiwiY2FtbF91bml4X21rdGltZSIsInRtIiwidG0yIiwiY2FtbF91bml4X3JlYWRsaW5rIiwiY2FtbF91bml4X3Jld2luZGRpciIsIm5ld19kaXJfaGFuZGxlIiwiY2FtbF91bml4X3JtZGlyIiwiY2FtbF91bml4X3N0YXJ0dXAiLCJjYW1sX3VuaXhfc3RhdCIsImNhbWxfdW5peF9zdGF0XzY0IiwiY2FtbF91bml4X3N5bWxpbmsiLCJzcmNfcm9vdCIsImRzdF9yb290IiwiY2FtbF91bml4X3RpbWUiLCJjYW1sX3VuaXhfdW5saW5rIiwiY2FtbF91bm1vdW50IiwiY2FtbF91cGRhdGVfZHVtbXkiLCJjYW1sX3dlYWtfc2V0IiwiY2FtbF93cmFwX2V4Y2VwdGlvbiIsImNhbWxfeG1saHR0cHJlcXVlc3RfY3JlYXRlIiwiY29tcGFyZV9kaWdpdHNfbmF0IiwiY29tcGFyZV9uYXQiLCJjb21wYXJlX25hdF9yZWFsIiwiY29tcGxlbWVudF9uYXQiLCJjcmVhdGVfbmF0IiwiZGVjcl9uYXQiLCJib3Jyb3ciLCJkZXNlcmlhbGl6ZV9uYXQiLCJkaXZfaGVscGVyIiwiZGl2X2RpZ2l0X25hdCIsIm5hdHEiLCJvZnNxIiwibmF0ciIsIm9mc3IiLCJyZW0iLCJudW1fbGVhZGluZ196ZXJvX2JpdHNfaW5fZGlnaXQiLCJzaGlmdF9sZWZ0X25hdCIsIm5iaXRzIiwid3JhcCIsInNoaWZ0X3JpZ2h0X25hdCIsInNldF90b196ZXJvX25hdCIsIm5hdF9vZl9hcnJheSIsIm11bHRfZGlnaXRfbmF0IiwibmF0MyIsIm9mczMiLCJ4MiIsIngzIiwic3ViX25hdCIsImRpdl9uYXQiLCJxdW8iLCJzZXJpYWxpemVfbmF0IiwiaW5pdGlhbGl6ZV9uYXQiLCJpc19kaWdpdF9pbnQiLCJpc19kaWdpdF9vZGQiLCJpc19kaWdpdF96ZXJvIiwianNvb19jcmVhdGVfZmlsZV9leHRlcm4iLCJqc29vX2VmZmVjdF9ub3Rfc3VwcG9ydGVkIiwibGFuZF9kaWdpdF9uYXQiLCJsZW5ndGhfbmF0IiwibG9yX2RpZ2l0X25hdCIsImx4b3JfZGlnaXRfbmF0IiwibWxfY2FudmFzX2FyYyIsInJhZGl1cyIsInRoZXRhMSIsInRoZXRhMiIsImNjdyIsIm1sX2NhbnZhc19hcmNfdG8iLCJwMSIsInAyIiwibWxfY2FudmFzX2Jlemllcl9jdXJ2ZV90byIsInAzIiwibWxfY2FudmFzX2JsaXQiLCJkc3RfY2FudmFzIiwiZHBvcyIsInNyY19jYW52YXMiLCJzcG9zIiwibWxfY2FudmFzX2NsZWFyX3BhdGgiLCJtbF9jYW52YXNfY2xpcCIsIm5vbnplcm8iLCJtbF9jYW52YXNfY2xpcF9wYXRoIiwibWxfY2FudmFzX2Nsb3NlX3BhdGgiLCJtbF9jYW52YXNfY29tbWl0IiwibWxfY2FudmFzX2NvbXBhcmUiLCJjYW52YXMxIiwiY2FudmFzMiIsIm1sX2NhbnZhc19jcmVhdGVfb2Zmc2NyZWVuIiwibWxfY2FudmFzX2NyZWF0ZV9vZmZzY3JlZW5fZnJvbV9pbWFnZV9kYXRhIiwibWxfY2FudmFzX2NyZWF0ZV9vZmZzY3JlZW5fZnJvbV9wbmciLCJvbmxvYWQiLCJfX2ltZyIsIm1sX2NhbnZhc19jcmVhdGVfb25zY3JlZW4iLCJhdXRvY29tbWl0IiwiZGVjb3JhdGVkIiwicmVzaXplYWJsZSIsImhlYWRlcl9oZWlnaHQiLCJmcmFtZSIsIm1sX2NhbnZhc19lbGxpcHNlIiwicm90YXRpb24iLCJtbF9jYW52YXNfZXhwb3J0X3BuZyIsIm1sX2NhbnZhc19maWxsIiwibWxfY2FudmFzX2ZpbGxfcGF0aCIsIm1sX2NhbnZhc19maWxsX3JlY3QiLCJtbF9jYW52YXNfZmlsbF90ZXh0IiwidGV4dCIsIm1sX2NhbnZhc19nZXRfY2FudmFzIiwibWxfY2FudmFzX2dldF9jdXJyZW50X3RpbWVzdGFtcCIsIm1sX2NhbnZhc19nZXRfZmlsbF9jb2xvciIsIm1sX2NhbnZhc19nZXRfZmlsbF9zdHlsZSIsIm1sX2NhbnZhc19nZXRfZ2xvYmFsX2FscGhhIiwibWxfY2FudmFzX2dldF9nbG9iYWxfY29tcG9zaXRlX29wZXJhdGlvbiIsIm1sX2NhbnZhc19nZXRfaWQiLCJtbF9jYW52YXNfZ2V0X2ltYWdlX2RhdGEiLCJtbF9jYW52YXNfZ2V0X2xpbmVfY2FwIiwibWxfY2FudmFzX2dldF9saW5lX2Rhc2giLCJtbF9jYW52YXNfZ2V0X2xpbmVfZGFzaF9vZmZzZXQiLCJtbF9jYW52YXNfZ2V0X2xpbmVfam9pbiIsIm1sX2NhbnZhc19nZXRfbGluZV93aWR0aCIsIm1sX2NhbnZhc19nZXRfbWl0ZXJfbGltaXQiLCJtbF9jYW52YXNfZ2V0X3BpeGVsIiwibWxfY2FudmFzX2dldF9wb3NpdGlvbiIsIm1sX2NhbnZhc19nZXRfc2hhZG93X2JsdXIiLCJtbF9jYW52YXNfZ2V0X3NoYWRvd19jb2xvciIsIm1sX2NhbnZhc19nZXRfc2hhZG93X29mZnNldCIsIm1sX2NhbnZhc19nZXRfc2l6ZSIsIm1sX2NhbnZhc19nZXRfc3Ryb2tlX2NvbG9yIiwibWxfY2FudmFzX2dldF9zdHJva2Vfc3R5bGUiLCJtbF9jYW52YXNfZ3JhZGllbnRfYWRkX2NvbG9yX3N0b3AiLCJncmFkaWVudCIsIm1sX2NhbnZhc19ncmFkaWVudF9jcmVhdGVfY29uaWMiLCJjZW50ZXIiLCJhbmdsZSIsIm1sX2NhbnZhc19ncmFkaWVudF9jcmVhdGVfbGluZWFyIiwibWxfY2FudmFzX2dyYWRpZW50X2NyZWF0ZV9yYWRpYWwiLCJjZW50ZXIxIiwicmFkMSIsImNlbnRlcjIiLCJyYWQyIiwibWxfY2FudmFzX2hhc2giLCJoYXNoIiwibWxfY2FudmFzX2ltYWdlX2RhdGFfYmxpdCIsImRzdF9kYXRhIiwic3JjX2RhdGEiLCJibGl0X2luZm8iLCJtbF9jYW52YXNfaW1hZ2VfZGF0YV9jcmVhdGVfZnJvbV9wbmciLCJtbF9jYW52YXNfaW1hZ2VfZGF0YV9leHBvcnRfcG5nIiwibWxfY2FudmFzX2ltYWdlX2RhdGFfZmlsbCIsIm1sX2NhbnZhc19pbWFnZV9kYXRhX2dldF9waXhlbCIsIm1sX2NhbnZhc19pbWFnZV9kYXRhX2dldF9zaXplIiwibWxfY2FudmFzX2ltYWdlX2RhdGFfaW1wb3J0X3BuZyIsIm1sX2NhbnZhc19pbWFnZV9kYXRhX3B1dF9waXhlbCIsIm1sX2NhbnZhc19pbWFnZV9kYXRhX3N1YiIsIm1sX2NhbnZhc19pbXBvcnRfcG5nIiwibWxfY2FudmFzX2luaXQiLCJtbF9jYW52YXNfaW50X29mX2tleSIsIm1sX2NhbnZhc19rZXlfb2ZfaW50IiwibWxfY2FudmFzX2xpbmVfdG8iLCJtbF9jYW52YXNfbW92ZV90byIsIm1sX2NhbnZhc19wYXRoX2FkZCIsInBhdGgxIiwicGF0aDIiLCJtbF9jYW52YXNfcGF0aF9hZGRfdHJhbnNmb3JtZWQiLCJtbF9jYW52YXNfcGF0aF9hcmMiLCJtbF9jYW52YXNfcGF0aF9hcmNfdG8iLCJtbF9jYW52YXNfcGF0aF9iZXppZXJfY3VydmVfdG8iLCJjcDEiLCJjcDIiLCJtbF9jYW52YXNfcGF0aF9jbG9zZSIsIm1sX2NhbnZhc19wYXRoX2NyZWF0ZSIsIm1sX2NhbnZhc19wYXRoX2VsbGlwc2UiLCJtbF9jYW52YXNfcGF0aF9saW5lX3RvIiwibWxfY2FudmFzX3BhdGhfbW92ZV90byIsIm1sX2NhbnZhc19wYXRoX3F1YWRyYXRpY19jdXJ2ZV90byIsImNwIiwibWxfY2FudmFzX3BhdGhfcmVjdCIsIm1sX2NhbnZhc19wYXR0ZXJuX2NyZWF0ZSIsImltZ19jYW52IiwibWxfY2FudmFzX3B1dF9pbWFnZV9kYXRhIiwibWxfY2FudmFzX3B1dF9waXhlbCIsIm1sX2NhbnZhc19xdWFkcmF0aWNfY3VydmVfdG8iLCJtbF9jYW52YXNfcmVjdCIsIm1sX2NhbnZhc19yZXN0b3JlIiwibWxfY2FudmFzX3JvdGF0ZSIsInRoZXRhIiwibWxfY2FudmFzX3J1biIsIm1sUHJvY2Vzc0V2ZW50IiwibWxDb250aW51YXRpb24iLCJtbF9jYW52YXNfc2F2ZSIsIm1sX2NhbnZhc19zY2FsZSIsInZlYyIsIm1sX2NhbnZhc19zZXRfZmlsbF9jb2xvciIsIm1sX2NhbnZhc19zZXRfZmlsbF9ncmFkaWVudCIsImdyYWQiLCJtbF9jYW52YXNfc2V0X2ZpbGxfcGF0dGVybiIsInBhdHRlcm4iLCJtbF9jYW52YXNfc2V0X2ZpbGxfc3R5bGUiLCJtbF9jYW52YXNfc2V0X2ZvbnQiLCJmYW1pbHkiLCJ3ZWlnaHQiLCJtbF9jYW52YXNfc2V0X2dsb2JhbF9hbHBoYSIsImdsb2JhbF9hbHBoYSIsIm1sX2NhbnZhc19zZXRfZ2xvYmFsX2NvbXBvc2l0ZV9vcGVyYXRpb24iLCJvcCIsIm1sX2NhbnZhc19zZXRfbGluZV9jYXAiLCJtbF9jYW52YXNfc2V0X2xpbmVfZGFzaCIsImRhc2giLCJtbF9jYW52YXNfc2V0X2xpbmVfZGFzaF9vZmZzZXQiLCJtbF9jYW52YXNfc2V0X2xpbmVfam9pbiIsIm1sX2NhbnZhc19zZXRfbGluZV93aWR0aCIsIm1sX2NhbnZhc19zZXRfbWl0ZXJfbGltaXQiLCJtbF9jYW52YXNfc2V0X3Bvc2l0aW9uIiwibWxfY2FudmFzX3NldF9zaGFkb3dfYmx1ciIsImJsdXIiLCJtbF9jYW52YXNfc2V0X3NoYWRvd19jb2xvciIsIm1sX2NhbnZhc19zZXRfc2hhZG93X29mZnNldCIsIm1sX2NhbnZhc19zZXRfc2l6ZSIsIm1sX2NhbnZhc19zZXRfc3Ryb2tlX2NvbG9yIiwibWxfY2FudmFzX3NldF9zdHJva2VfZ3JhZGllbnQiLCJtbF9jYW52YXNfc2V0X3N0cm9rZV9wYXR0ZXJuIiwibWxfY2FudmFzX3NldF9zdHJva2Vfc3R5bGUiLCJtbF9jYW52YXNfc2V0X3RyYW5zZm9ybSIsIm1sX2NhbnZhc19zaGVhciIsIm1sX2NhbnZhc19zaG93IiwibWxfY2FudmFzX3N0cm9rZSIsIm1sX2NhbnZhc19zdHJva2VfcGF0aCIsIm1sX2NhbnZhc19zdHJva2VfcmVjdCIsIm1sX2NhbnZhc19zdHJva2VfdGV4dCIsIm1sX2NhbnZhc190cmFuc2Zvcm0iLCJtbF9jYW52YXNfdHJhbnNsYXRlIiwibXVsdF9uYXQiLCJsZW4zIiwibnRoX2RpZ2l0X25hdCIsIm50aF9kaWdpdF9uYXRfbmF0aXZlIiwicmVfbWF0Y2giLCJyZV93b3JkX2xldHRlcnMiLCJvcGNvZGVzIiwiaXNfd29yZF9sZXR0ZXIiLCJpbl9iaXRzZXQiLCJyZV9tYXRjaF9pbXBsIiwicGFydGlhbCIsInByb2ciLCJjcG9vbCIsIm5vcm10YWJsZSIsIm51bWdyb3VwcyIsIm51bXJlZ2lzdGVycyIsInN0YXJ0Y2hhcnMiLCJwYyIsInF1aXQiLCJncm91cHMiLCJyZV9yZWdpc3RlciIsImJhY2t0cmFjayIsIml0ZW0iLCJwdXNoIiwiYWNjZXB0IiwicHJlZml4X21hdGNoIiwic2FyZyIsInVhcmciLCJncm91cCIsIkVycm9yIiwicmVfcGFydGlhbF9tYXRjaCIsInJlX3JlcGxhY2VtZW50X3RleHQiLCJyZXBsIiwib3JpZyIsImN1ciIsImVuZCIsInJlX3NlYXJjaF9iYWNrd2FyZCIsInJlX3NlYXJjaF9mb3J3YXJkIiwicmVfc3RyaW5nX21hdGNoIiwic2V0X2RpZ2l0X25hdCIsImRpZ2l0Iiwic2V0X2RpZ2l0X25hdF9uYXRpdmUiLCJzcXVhcmVfbmF0IiwiY2FtbF9zZXR1cF91bmNhdWdodF9leGNlcHRpb25faGFuZGxlciIsIm9yaWdpbiIsImVyYXNlX3JlbCIsInJlc3QiLCJyZXN0JDAiLCJyZXN0JDEiLCJyZXN0JDIiLCJyZXN0JDMiLCJyZXN0JDQiLCJyZXN0JDUiLCJyZXN0JDYiLCJyZXN0JDciLCJ0eSIsInJlc3QkOCIsInR5MSIsInJlc3QkOSIsInJlc3QkMTAiLCJyZXN0JDExIiwicmVzdCQxMiIsInJlc3QkMTMiLCJjb25jYXRfZm10dHkiLCJmbXR0eTEiLCJmbXR0eTIiLCJ0eTIiLCJjb25jYXRfZm10IiwiZm10MSIsImZtdDIiLCJwYWQiLCJwYWQkMCIsInByZWMiLCJwYWQkMSIsImljb252IiwicHJlYyQwIiwicGFkJDIiLCJpY29udiQwIiwicHJlYyQxIiwicGFkJDMiLCJpY29udiQxIiwicHJlYyQyIiwicGFkJDQiLCJpY29udiQyIiwicHJlYyQzIiwicGFkJDUiLCJmY29udiIsInBhZCQ2Iiwic3RyIiwiY2hyIiwiZm10dHkiLCJwYWQkNyIsImZtdHR5JDAiLCJwYWQkOCIsInJlc3QkMTQiLCJyZXN0JDE1IiwicmVzdCQxNiIsImZtdGluZ19saXQiLCJyZXN0JDE3IiwiZm10aW5nX2dlbiIsInJlc3QkMTgiLCJyZXN0JDE5IiwiY2hhcl9zZXQiLCJ3aWR0aF9vcHQiLCJyZXN0JDIwIiwiY291bnRlciIsInJlc3QkMjEiLCJyZXN0JDIyIiwiaWduIiwicmVzdCQyMyIsImYiLCJhcml0eSIsIm1ha2UiLCJ2IiwiZ2V0IiwiciIsInNldCIsImV4Y2hhbmdlIiwiY3VyIiwiY29tcGFyZV9hbmRfc2V0Iiwic2VlbiIsImZldGNoX2FuZF9hZGQiLCJuIiwiaW5jciIsImRlY3IiLCJmYWlsd2l0aCIsInMiLCJpbnZhbGlkX2FyZyIsIm1pbiIsIngiLCJ5IiwibWF4IiwiYWJzIiwibG5vdCIsImluZmluaXR5IiwibmVnX2luZmluaXR5IiwibmFuIiwibWF4X2Zsb2F0IiwibWluX2Zsb2F0IiwiZXBzaWxvbl9mbG9hdCIsInN5bWJvbF9jb25jYXQiLCJjaGFyX29mX2ludCIsInN0cmluZ19vZl9ib29sIiwiYiIsImJvb2xfb2Zfc3RyaW5nIiwiYm9vbF9vZl9zdHJpbmdfb3B0Iiwic3RyaW5nX29mX2ludCIsImludF9vZl9zdHJpbmdfb3B0IiwidmFsaWRfZmxvYXRfbGV4ZW0iLCJzMSIsImwiLCJpIiwiaSQwIiwic3RyaW5nX29mX2Zsb2F0IiwiZmxvYXRfb2Zfc3RyaW5nX29wdCIsInN5bWJvbCIsImwxIiwibDIiLCJ0bCIsImhkIiwic3RkaW4iLCJzdGRvdXQiLCJzdGRlcnIiLCJvcGVuX291dF9nZW4iLCJtb2RlIiwicGVybSIsIm5hbWUiLCJjIiwib3Blbl9vdXQiLCJvcGVuX291dF9iaW4iLCJmbHVzaF9hbGwiLCJhIiwib3V0cHV0X2J5dGVzIiwib2MiLCJvdXRwdXRfc3RyaW5nIiwib3V0cHV0Iiwib2ZzIiwibGVuIiwib3V0cHV0X3N1YnN0cmluZyIsIm91dHB1dF92YWx1ZSIsImNoYW4iLCJjbG9zZV9vdXQiLCJjbG9zZV9vdXRfbm9lcnIiLCJvcGVuX2luX2dlbiIsIm9wZW5faW4iLCJvcGVuX2luX2JpbiIsImlucHV0IiwiaWMiLCJ1bnNhZmVfcmVhbGx5X2lucHV0Iiwib2ZzJDAiLCJsZW4kMCIsImxlbiQxIiwib2ZzJDEiLCJyZWFsbHlfaW5wdXQiLCJyZWFsbHlfaW5wdXRfc3RyaW5nIiwiaW5wdXRfbGluZSIsImJ1aWxkX3Jlc3VsdCIsImJ1ZiIsInBvcyQwIiwiYWNjdSIsImJlZyIsImFjY3UkMCIsInJlcyIsImNsb3NlX2luX25vZXJyIiwicHJpbnRfY2hhciIsInByaW50X3N0cmluZyIsInByaW50X2J5dGVzIiwicHJpbnRfaW50IiwicHJpbnRfZmxvYXQiLCJwcmludF9lbmRsaW5lIiwicHJpbnRfbmV3bGluZSIsInByZXJyX2NoYXIiLCJwcmVycl9zdHJpbmciLCJwcmVycl9ieXRlcyIsInByZXJyX2ludCIsInByZXJyX2Zsb2F0IiwicHJlcnJfZW5kbGluZSIsInByZXJyX25ld2xpbmUiLCJyZWFkX2xpbmUiLCJyZWFkX2ludCIsInJlYWRfaW50X29wdCIsInJlYWRfZmxvYXQiLCJyZWFkX2Zsb2F0X29wdCIsInN0cmluZ19vZl9mb3JtYXQiLCJzeW1ib2wkMCIsInN0cjIiLCJzdHIxIiwiczIiLCJleGl0X2Z1bmN0aW9uIiwiYXRfZXhpdCIsImZfeWV0X3RvX3J1biIsIm9sZF9leGl0IiwiZl95ZXRfdG9fcnVuJDAiLCJvbGRfZXhpdCQwIiwibmV3X2V4aXQiLCJzdWNjZXNzIiwiZG9fYXRfZXhpdCIsImV4aXQiLCJyZXRjb2RlIiwibWF4X2ludCIsIm1pbl9pbnQiLCJmbHVzaCIsIm91dHB1dF9jaGFyIiwib3V0cHV0X2J5dGUiLCJvdXRwdXRfYmluYXJ5X2ludCIsInNlZWtfb3V0IiwicG9zX291dCIsIm91dF9jaGFubmVsX2xlbmd0aCIsInNldF9iaW5hcnlfbW9kZV9vdXQiLCJpbnB1dF9jaGFyIiwiaW5wdXRfYnl0ZSIsImlucHV0X2JpbmFyeV9pbnQiLCJpbnB1dF92YWx1ZSIsInNlZWtfaW4iLCJwb3NfaW4iLCJpbl9jaGFubmVsX2xlbmd0aCIsImNsb3NlX2luIiwic2V0X2JpbmFyeV9tb2RlX2luIiwibGVmdCIsInJpZ2h0IiwiaXNfbGVmdCIsImlzX3JpZ2h0IiwiZmluZF9sZWZ0IiwiZmluZF9yaWdodCIsIm1hcF9sZWZ0IiwiZSIsIm1hcF9yaWdodCIsIm1hcCIsInYkMCIsImZvbGQiLCJlcXVhbCIsImUxIiwiZTIiLCJ2MSIsInYyIiwidjEkMCIsInYyJDAiLCJjb21wYXJlIiwiaXNfYmxvY2siLCJkb3VibGVfZmllbGQiLCJzZXRfZG91YmxlX2ZpZWxkIiwiY3VzdG9tX3RhZyIsImluZm8iLCJvYmoiLCJzdGFydF9lbnYiLCJvZl92YWwiLCJzbG90IiwiaWQiLCJleHRlbnNpb25fY29uc3RydWN0b3IiLCJleHRlbnNpb25fbmFtZSIsImV4dGVuc2lvbl9pZCIsIm1heF9lcGhlX2xlbmd0aCIsImNyZWF0ZSIsImxlbmd0aCIsInJhaXNlX2lmX2ludmFsaWRfb2Zmc2V0IiwibyIsIm1zZyIsImdldF9rZXkiLCJnZXRfa2V5X2NvcHkiLCJzZXRfa2V5IiwidW5zZXRfa2V5IiwiY2hlY2tfa2V5IiwiYmxpdF9rZXkiLCJvMSIsIm8yIiwicmFpc2VfdW5kZWZpbmVkIiwiZm9yY2VfbGF6eV9ibG9jayIsImJsayIsImNsb3N1cmUiLCJyZXN1bHQiLCJlJDAiLCJmb3JjZV92YWxfbGF6eV9ibG9jayIsImZvcmNlIiwibHp2IiwidCIsImZvcmNlX3ZhbCIsImZyb21fZnVuIiwiZnJvbV92YWwiLCJpc192YWwiLCJtYXBfdmFsIiwiZW1wdHkiLCJyZXR1cm4kMCIsImNvbnMiLCJuZXh0IiwiYXBwZW5kIiwic2VxMSIsInNlcTIiLCJzZXEiLCJmaWx0ZXJfbWFwIiwic2VxJDAiLCJmaWx0ZXIiLCJjb25jYXQiLCJmbGF0X21hcCIsImZvbGRfbGVmdCIsImFjYyIsImFjYyQwIiwiYWNjJDEiLCJpdGVyIiwidW5mb2xkIiwidSIsInUkMCIsImlzX2VtcHR5IiwieHMiLCJ1bmNvbnMiLCJ4cyQwIiwieHMkMSIsIml0ZXJpIiwiZm9sZF9sZWZ0aSIsImFjY3UkMSIsImZvcl9hbGwiLCJwIiwiZXhpc3RzIiwiZmluZCIsImZpbmRfbWFwIiwiaXRlcjIiLCJ5cyIsInlzJDAiLCJ5cyQxIiwiZm9sZF9sZWZ0MiIsImZvcl9hbGwyIiwiZXhpc3RzMiIsImVxIiwiY21wIiwiaW5pdF9hdXgiLCJqIiwiaW5pdCIsInJlcGVhdCIsImZvcmV2ZXIiLCJjeWNsZV9ub25lbXB0eSIsImN5Y2xlIiwiaXRlcmF0ZTEiLCJpdGVyYXRlIiwibWFwaV9hdXgiLCJtYXBpIiwidGFpbF9zY2FuIiwicyQwIiwic2NhbiIsInRha2VfYXV4IiwidGFrZSIsImRyb3AiLCJuJDAiLCJuJDEiLCJ0YWtlX3doaWxlIiwiZHJvcF93aGlsZSIsIm5vZGUiLCJncm91cCIsInRvX2xhenkiLCJmYWlsdXJlIiwibWVtb2l6ZSIsIm9uY2UiLCJhY3Rpb24iLCJ6aXAiLCJtYXAyIiwiaW50ZXJsZWF2ZSIsInNvcnRlZF9tZXJnZTEiLCJzb3J0ZWRfbWVyZ2UiLCJtYXBfZnN0IiwieHlzIiwieHlzJDAiLCJtYXBfc25kIiwidW56aXAiLCJmaWx0ZXJfbWFwX2ZpbmRfbGVmdF9tYXAiLCJmaWx0ZXJfbWFwX2ZpbmRfcmlnaHRfbWFwIiwieiIsInBhcnRpdGlvbl9tYXAiLCJwYXJ0aXRpb24iLCJwZWVsIiwieHNzIiwidHJhbnNwb3NlIiwidGFpbHMiLCJoZWFkcyIsInJlbWFpbmRlcnMiLCJ4c3MkMCIsInRhaWxzJDAiLCJoZWFkcyQwIiwibWFwX3Byb2R1Y3QiLCJwcm9kdWN0Iiwib2ZfZGlzcGVuc2VyIiwiaXQiLCJ0b19kaXNwZW5zZXIiLCJpbnRzIiwic29tZSIsInZhbHVlIiwiZGVmYXVsdCQwIiwiYmluZCIsImpvaW4iLCJub25lIiwiaXNfbm9uZSIsImlzX3NvbWUiLCJvMCIsInYwIiwidG9fcmVzdWx0IiwidG9fbGlzdCIsInRvX3NlcSIsIm9rIiwiZXJyb3IiLCJnZXRfb2siLCJnZXRfZXJyb3IiLCJtYXBfZXJyb3IiLCJpdGVyX2Vycm9yIiwiaXNfb2siLCJpc19lcnJvciIsInIwIiwicjEiLCJlMCIsInRvX29wdGlvbiIsInRvX2Zsb2F0IiwidG9fc3RyaW5nIiwiZXNjYXBlZCIsImxvd2VyY2FzZSIsInVwcGVyY2FzZSIsImxvd2VyY2FzZV9hc2NpaSIsInVwcGVyY2FzZV9hc2NpaSIsImMxIiwiYzIiLCJlcnJfbm9fcHJlZCIsImVycl9ub19zdWNjIiwibG9fYm91bmQiLCJoaV9ib3VuZCIsInN1Y2MiLCJwcmVkIiwiaXNfdmFsaWQiLCJvZl9pbnQiLCJpc19jaGFyIiwib2ZfY2hhciIsInRvX2NoYXIiLCJ1bnNhZmVfdG9fY2hhciIsImhhc2giLCJ1dGZfZGVjb2RlX2lzX3ZhbGlkIiwiZCIsInV0Zl9kZWNvZGVfbGVuZ3RoIiwidXRmX2RlY29kZV91Y2hhciIsInV0Zl9kZWNvZGUiLCJ1dGZfZGVjb2RlX2ludmFsaWQiLCJ1dGZfOF9ieXRlX2xlbmd0aCIsInV0Zl8xNl9ieXRlX2xlbmd0aCIsImwkMCIsIm50aCIsImwkMSIsIm50aF9vcHQiLCJyZXZfYXBwZW5kIiwibDEkMCIsImwyJDAiLCJsMSQxIiwibDIkMSIsInJldiIsInJldl9pbml0X3RocmVzaG9sZCIsImZsYXR0ZW4iLCJyZXZfbWFwIiwiZm9sZF9yaWdodCIsImEyIiwiYTEiLCJyZXZfbWFwMiIsImZvbGRfcmlnaHQyIiwibWVtIiwibWVtcSIsImFzc29jIiwiYXNzb2Nfb3B0IiwiYXNzcSIsImFzc3Ffb3B0IiwibWVtX2Fzc29jIiwibWVtX2Fzc3EiLCJyZW1vdmVfYXNzb2MiLCJwYWlyIiwicmVtb3ZlX2Fzc3EiLCJmaW5kX29wdCIsImZpbmRfYWxsIiwiZmlsdGVyaSIsImNvbmNhdF9tYXAiLCJmb2xkX2xlZnRfbWFwIiwibF9hY2N1IiwieCQwIiwieWVzIiwibm8iLCJzcGxpdCIsInJ5IiwicngiLCJjb21iaW5lIiwibWVyZ2UiLCJ0MiIsImgyIiwidDEiLCJoMSIsInN0YWJsZV9zb3J0Iiwic29ydCIsIngyIiwieDEiLCJ0bCQxIiwieDMiLCJ4MiQwIiwieDEkMCIsIm4xIiwibjIiLCJyZXZfc29ydCIsInRsJDAiLCJzb3J0X3VuaXEiLCJjJDAiLCJjJDEiLCJjJDIiLCJjJDMiLCJjJDQiLCJjJDUiLCJjJDYiLCJhY2N1JDIiLCJjb21wYXJlX2xlbmd0aHMiLCJjb21wYXJlX2xlbmd0aF93aXRoIiwiYXV4IiwidGFpbCIsIm9mX3NlcSIsImRpcmVjdCIsImRlcHRoIiwibG9nbm90IiwiY29weSIsIm9mX3N0cmluZyIsInN1YiIsInN1Yl9zdHJpbmciLCJleHRlbmQiLCJkc3RvZmYiLCJzcmNvZmYiLCJjcHlsZW4iLCJmaWxsIiwiYmxpdCIsIm9mczEiLCJvZnMyIiwiYmxpdF9zdHJpbmciLCJzZXAiLCJzZXBsZW4iLCJkc3QiLCJwb3MiLCJoZCQwIiwiY2F0IiwiaXNfc3BhY2UiLCJ0cmltIiwiYXBwbHkxIiwiY2FwaXRhbGl6ZV9hc2NpaSIsInVuY2FwaXRhbGl6ZV9hc2NpaSIsInN0YXJ0c193aXRoIiwicHJlZml4IiwibGVuX3MiLCJsZW5fcHJlIiwiZW5kc193aXRoIiwic3VmZml4IiwibGVuX3N1ZiIsImRpZmYiLCJpbmRleF9yZWMiLCJsaW0iLCJpJDEiLCJpbmRleCIsImluZGV4X3JlY19vcHQiLCJpbmRleF9vcHQiLCJpbmRleF9mcm9tIiwiaW5kZXhfZnJvbV9vcHQiLCJyaW5kZXhfcmVjIiwicmluZGV4IiwicmluZGV4X2Zyb20iLCJyaW5kZXhfcmVjX29wdCIsInJpbmRleF9vcHQiLCJyaW5kZXhfZnJvbV9vcHQiLCJjb250YWluc19mcm9tIiwiY29udGFpbnMiLCJyY29udGFpbnNfZnJvbSIsInNwbGl0X29uX2NoYXIiLCJjYXBpdGFsaXplIiwidW5jYXBpdGFsaXplIiwidG9fc2VxaSIsIm5ld19sZW4iLCJuZXdfYnVmIiwidW5zYWZlX2dldF91aW50MTZfbGUiLCJ1bnNhZmVfZ2V0X3VpbnQxNl9iZSIsImdldF9pbnQ4IiwiZ2V0X3VpbnQxNl9sZSIsImdldF91aW50MTZfYmUiLCJnZXRfaW50MTZfbmUiLCJnZXRfaW50MTZfbGUiLCJnZXRfaW50MTZfYmUiLCJnZXRfaW50MzJfbGUiLCJnZXRfaW50MzJfYmUiLCJnZXRfaW50NjRfbGUiLCJnZXRfaW50NjRfYmUiLCJ1bnNhZmVfc2V0X3VpbnQxNl9sZSIsInVuc2FmZV9zZXRfdWludDE2X2JlIiwic2V0X2ludDE2X2xlIiwic2V0X2ludDE2X2JlIiwic2V0X2ludDMyX2xlIiwic2V0X2ludDMyX2JlIiwic2V0X2ludDY0X2xlIiwic2V0X2ludDY0X2JlIiwic2V0X3VpbnQ4Iiwic2V0X3VpbnQxNl9uZSIsImRlY19pbnZhbGlkIiwiZGVjX3JldCIsIm5vdF9pbl94ODBfdG9feEJGIiwibm90X2luX3hBMF90b194QkYiLCJub3RfaW5feDgwX3RvX3g5RiIsIm5vdF9pbl94OTBfdG9feEJGIiwibm90X2luX3g4MF90b194OEYiLCJ1dGZfOF91Y2hhcl8zIiwiYjAiLCJiMSIsImIyIiwidXRmXzhfdWNoYXJfNCIsImIzIiwiZ2V0X3V0Zl84X3VjaGFyIiwiYjEkNCIsImIyJDMiLCJpJDQiLCJiMSQyIiwiaSQ1IiwiYjIkMSIsImkkNiIsImIzJDEiLCJpJDEwIiwiYjEkMCIsImkkMTEiLCJpJDEyIiwiaSQ3IiwiYjEkMSIsImkkOCIsImIyJDAiLCJpJDkiLCJiMyQwIiwiaSQxMyIsImIxJDUiLCJpJDE0IiwiYjIkNCIsImkkMiIsImIxJDMiLCJpJDMiLCJiMiQyIiwiaSQxNSIsInNldF91dGZfOF91Y2hhciIsImxhc3QkMSIsImxhc3QkMCIsImxhc3QiLCJpc192YWxpZF91dGZfOCIsImxhc3QkMyIsImxhc3QkMiIsImxhc3QkNCIsImxhc3QkNSIsImdldF91dGZfMTZiZV91Y2hhciIsImhpIiwibG8iLCJzZXRfdXRmXzE2YmVfdWNoYXIiLCJ1JDEiLCJpc192YWxpZF91dGZfMTZiZSIsImdldF91dGZfMTZsZV91Y2hhciIsInNldF91dGZfMTZsZV91Y2hhciIsImlzX3ZhbGlkX3V0Zl8xNmxlIiwiYnRzIiwiYm9zIiwib2ZfYnl0ZXMiLCJ0b19ieXRlcyIsImciLCJ0b19idWZmZXIiLCJidWZmIiwiZmxhZ3MiLCJkYXRhX3NpemUiLCJ0b3RhbF9zaXplIiwiZnJvbV9ieXRlcyIsImZyb21fc3RyaW5nIiwibWFrZV9mbG9hdCIsIm1ha2VfbWF0cml4Iiwic3giLCJzeSIsImxhIiwibGIiLCJyZXMkMCIsImxpc3RfbGVuZ3RoIiwib2ZfbGlzdCIsImlucHV0X2FycmF5IiwiZWx0Iiwib3V0cHV0X2FycmF5IiwiZWx0JDAiLCJhY2MkMiIsImEwIiwiYmkiLCJhaSIsIm5hIiwibmIiLCJtYXhzb24iLCJpMzEiLCJlJDEiLCJqJDAiLCJmYXRoZXIiLCJzcmMxb2ZzIiwic3JjMWxlbiIsInNyYzIiLCJzcmMyb2ZzIiwic3JjMmxlbiIsImRzdG9mcyIsInNyYzFyIiwic3JjMnIiLCJzMiQxIiwiczEkMSIsImkxIiwiaTIiLCJpMiQwIiwiZCQwIiwiczIkMCIsImkxJDAiLCJkJDEiLCJzMSQwIiwiaXNvcnR0byIsInNyY29mcyIsInNvcnR0byIsImlzX2Zpbml0ZSIsImlzX2luZmluaXRlIiwiaXNfbmFuIiwiZXBzaWxvbiIsIm9mX3N0cmluZ19vcHQiLCJpc19pbnRlZ2VyIiwibWluX21heCIsIm1pbl9udW0iLCJtYXhfbnVtIiwibWluX21heF9udW0iLCJ1bnNhZmVfZmlsbCIsImNoZWNrIiwiaGxlbiIsInNyYyIsInNvZnMiLCJkb2ZzIiwiaCIsIm1lbV9pZWVlIiwibWFwX3RvX2FycmF5IiwibWFwX2Zyb21fYXJyYXkiLCJ6ZXJvIiwib25lIiwibWludXNfb25lIiwibWF4X2ludCQwIiwidW5zaWduZWRfdG9faW50IiwidW5zaWduZWRfY29tcGFyZSIsIm0iLCJ1bnNpZ25lZF9kaXYiLCJxIiwidW5zaWduZWRfcmVtIiwic2l6ZSIsImR1bW15X3BvcyIsInplcm9fcG9zIiwiZW5naW5lIiwidGJsIiwic3RhdGUiLCJuZXdfZW5naW5lIiwiZnJvbV9mdW5jdGlvbiIsIm9wdCIsInJlYWRfZnVuIiwic3RoIiwid2l0aF9wb3NpdGlvbnMiLCJhdXhfYnVmZmVyIiwibGV4YnVmIiwicmVhZCIsIm5ld2xlbiIsIm5ld2J1ZiIsImZyb21fY2hhbm5lbCIsInNldF9wb3NpdGlvbiIsInBvc2l0aW9uIiwic2V0X2ZpbGVuYW1lIiwiZm5hbWUiLCJsZXhlbWUiLCJzdWJfbGV4ZW1lIiwic3ViX2xleGVtZV9vcHQiLCJzdWJfbGV4ZW1lX2NoYXIiLCJzdWJfbGV4ZW1lX2NoYXJfb3B0IiwibGV4ZW1lX2NoYXIiLCJsZXhlbWVfc3RhcnQiLCJsZXhlbWVfZW5kIiwibGV4ZW1lX3N0YXJ0X3AiLCJsZXhlbWVfZW5kX3AiLCJuZXdfbGluZSIsImxjcCIsImZsdXNoX2lucHV0IiwiZW52IiwiZ3Jvd19zdGFja3MiLCJvbGRzaXplIiwibmV3c2l6ZSIsIm5ld19zIiwibmV3X3YiLCJuZXdfc3RhcnQiLCJuZXdfZW5kIiwiY2xlYXJfcGFyc2VyIiwiY3VycmVudF9sb29rYWhlYWRfZnVuIiwieXlwYXJzZSIsInRhYmxlcyIsInN0YXJ0IiwibGV4ZXIiLCJpbml0X2FzcCIsImluaXRfc3AiLCJpbml0X3N0YWNrYmFzZSIsImluaXRfc3RhdGUiLCJpbml0X2N1cnJfY2hhciIsImluaXRfbHZhbCIsImluaXRfZXJyZmxhZyIsImNtZCIsImFyZyIsImFyZyQwIiwiZXhuJDAiLCJleG4iLCJjdXJyX2NoYXIiLCJ0b2siLCJwZWVrX3ZhbCIsInN5bWJvbF9zdGFydF9wb3MiLCJzdCIsImVuIiwic3ltYm9sX2VuZF9wb3MiLCJyaHNfc3RhcnRfcG9zIiwicmhzX2VuZF9wb3MiLCJzeW1ib2xfc3RhcnQiLCJzeW1ib2xfZW5kIiwicmhzX3N0YXJ0IiwicmhzX2VuZCIsImlzX2N1cnJlbnRfbG9va2FoZWFkIiwicGFyc2VfZXJyb3IiLCJoZWlnaHQiLCJobCIsImgkMCIsImhyIiwiYmFsIiwibHIiLCJsdiIsImxsIiwibHJyIiwibHJ2IiwibHJsIiwicnIiLCJydiIsInJsIiwicmxyIiwicmx2IiwicmxsIiwiYWRkIiwic2luZ2xldG9uIiwiYWRkX21pbl9lbGVtZW50IiwiYWRkX21heF9lbGVtZW50IiwicmgiLCJsaCIsIm1pbl9lbHQiLCJtaW5fZWx0X29wdCIsIm1heF9lbHQiLCJtYXhfZWx0X29wdCIsInJlbW92ZV9taW5fZWx0IiwiciQwIiwicHJlcyIsInByZXMkMCIsInJlbW92ZSIsInVuaW9uIiwicjIiLCJyMiQwIiwicjEkMCIsImludGVyIiwic3BsaXRfYmlzIiwiZGlzam9pbnQiLCJjb25zX2VudW0iLCJlMiQyIiwiZTEkMiIsImUyJDAiLCJlMSQwIiwiZTIkMSIsImUxJDEiLCJzdWJzZXQiLCJwdiIsImxmIiwibHQiLCJyZiIsInJ0IiwiY2FyZGluYWwiLCJlbGVtZW50c19hdXgiLCJlbGVtZW50cyIsImZpbmRfZmlyc3QiLCJ2MCQxIiwidjAkMCIsImZpbmRfZmlyc3Rfb3B0IiwiZmluZF9sYXN0IiwiZmluZF9sYXN0X29wdCIsInRyeV9qb2luIiwidiQxIiwieDAiLCJsJDMiLCJsJDQiLCJ4MCQwIiwibCQ1IiwieDAkMSIsIm5sIiwibWlkIiwibCQyIiwieDQiLCJhZGRfc2VxIiwic2VxX29mX2VudW0iLCJzbm9jX2VudW0iLCJyZXZfc2VxX29mX2VudW0iLCJ0b19yZXZfc2VxIiwidG9fc2VxX2Zyb20iLCJsb3ciLCJsZCIsImxyZCIsInJkIiwicmxkIiwiZGF0YSIsImQwJDEiLCJkMCIsImQwJDAiLCJtaW5fYmluZGluZyIsIm1pbl9iaW5kaW5nX29wdCIsIm1heF9iaW5kaW5nIiwibWF4X2JpbmRpbmdfb3B0IiwicmVtb3ZlX21pbl9iaW5kaW5nIiwidXBkYXRlIiwiZGF0YSQwIiwibSQwIiwiYWRkX21pbl9iaW5kaW5nIiwiayIsImFkZF9tYXhfYmluZGluZyIsImNvbmNhdF9vcl9qb2luIiwiZDEiLCJkMiIsImQyJDAiLCJkMSQwIiwiZDIkMSIsImQxJDEiLCJwdmQiLCJmdmQiLCJtMSIsIm0yIiwiYmluZGluZ3NfYXV4IiwiYmluZGluZ3MiLCJjbGVhciIsInB1c2giLCJwb3AiLCJwb3Bfb3B0IiwidG9wIiwidG9wX29wdCIsImNlbGwiLCJtYXRjaCIsInBlZWsiLCJjb250ZW50IiwicGVla19vcHQiLCJ0YWtlX29wdCIsImNlbGwkMCIsInFfcmVzIiwicHJldiIsInByZXYkMCIsInRyYW5zZmVyIiwicTEiLCJxMiIsImNvdW50IiwiZmlsbF9idWZmIiwiZ2V0X2RhdGEiLCJkMTEiLCJhJDAiLCJhJDEiLCJwZWVrX2RhdGEiLCJqdW5rX2RhdGEiLCJqdW5rIiwibmdldF9kYXRhIiwiYWwiLCJucGVlayIsInN0cm0iLCJmcm9tIiwib2ZfY2hhbm5lbCIsImlhcHAiLCJpY29ucyIsImlzaW5nIiwibGFwcCIsImxjb25zIiwibHNpbmciLCJzbGF6eSIsImR1bXAiLCJkdW1wX2RhdGEiLCJjb250ZW50cyIsInJlc2V0IiwicmVzaXplIiwibW9yZSIsIm9sZF9wb3MiLCJvbGRfbGVuIiwibmV3X2J1ZmZlciIsImFkZF9jaGFyIiwidWNoYXJfdXRmXzhfYnl0ZV9sZW5ndGhfbWF4IiwidWNoYXJfdXRmXzE2X2J5dGVfbGVuZ3RoX21heCIsImFkZF91dGZfOF91Y2hhciIsImFkZF91dGZfMTZiZV91Y2hhciIsImFkZF91dGZfMTZsZV91Y2hhciIsImFkZF9zdWJzdHJpbmciLCJvZmZzZXQiLCJuZXdfcG9zaXRpb24iLCJhZGRfc3ViYnl0ZXMiLCJhZGRfc3RyaW5nIiwiYWRkX2J5dGVzIiwiYWRkX2J1ZmZlciIsImJzIiwiYWRkX2NoYW5uZWwiLCJ0b19yZWFkJDEiLCJhbHJlYWR5X3JlYWQiLCJ0b19yZWFkIiwiYWxyZWFkeV9yZWFkJDAiLCJ0b19yZWFkJDAiLCJvdXRwdXRfYnVmZmVyIiwiYWRkX3N1YnN0aXR1dGUiLCJsaW0kMSIsInByZXZpb3VzIiwicHJldmlvdXMkMCIsInN0YXJ0JDAiLCJvcGVuaW5nIiwibGltJDAiLCJzdG9wJDAiLCJrJDIiLCJjbG9zaW5nIiwic3RvcCIsImskMCIsImskMSIsIm5leHRfaSIsImlkZW50IiwidHJ1bmNhdGUiLCJhZGRfaW50OCIsImFkZF9pbnQxNl9uZSIsImFkZF9pbnQzMl9uZSIsImFkZF9pbnQ2NF9uZSIsImFkZF9pbnQxNl9sZSIsImFkZF9pbnQxNl9iZSIsImFkZF9pbnQzMl9sZSIsImFkZF9pbnQzMl9iZSIsImFkZF9pbnQ2NF9sZSIsImFkZF9pbnQ2NF9iZSIsInN1Yl9mb3JtYXQiLCJmb3JtYXR0aW5nX2xpdCIsImNyZWF0ZV9jaGFyX3NldCIsImFkZF9pbl9jaGFyX3NldCIsInN0cl9pbmQiLCJtYXNrIiwiZnJlZXplX2NoYXJfc2V0IiwicmV2X2NoYXJfc2V0IiwiY2hhcl9zZXQkMCIsImlzX2luX2NoYXJfc2V0IiwicGFkX29mX3BhZF9vcHQiLCJwYWRfb3B0Iiwid2lkdGgiLCJwYXJhbV9mb3JtYXRfb2ZfaWdub3JlZF9mb3JtYXQiLCJmbXQiLCJwYWRfb3B0JDAiLCJwYWRfb3B0JDEiLCJwYWRfb3B0JDIiLCJwYWRfb3B0JDMiLCJwYWRfb3B0JDQiLCJwcmVjX29wdCIsInBhZF9vcHQkNSIsIm5kZWMiLCJwYWRfb3B0JDYiLCJwYWRfb3B0JDciLCJwYWRfb3B0JDgiLCJkZWZhdWx0X2Zsb2F0X3ByZWNpc2lvbiIsImJ1ZmZlcl9jcmVhdGUiLCJpbml0X3NpemUiLCJidWZmZXJfY2hlY2tfc2l6ZSIsIm92ZXJoZWFkIiwibWluX2xlbiIsIm5ld19zdHIiLCJidWZmZXJfYWRkX2NoYXIiLCJidWZmZXJfYWRkX3N0cmluZyIsInN0cl9sZW4iLCJidWZmZXJfY29udGVudHMiLCJjaGFyX29mX2ljb252IiwiY2hhcl9vZl9mY29udiIsImNGIiwiYnByaW50X3BhZHR5IiwicGFkdHkiLCJicHJpbnRfaWdub3JlZF9mbGFnIiwiaWduX2ZsYWciLCJicHJpbnRfcGFkX29wdCIsImJwcmludF9wYWRkaW5nIiwicGFkdHkkMCIsImJwcmludF9wcmVjaXNpb24iLCJicHJpbnRfaWNvbnZfZmxhZyIsImJwcmludF9hbHRpbnRfZm10IiwiYnByaW50X2Zjb252X2ZsYWciLCJzdHJpbmdfb2ZfZm9ybWF0dGluZ19saXQiLCJzdHIkMCIsImJwcmludF9jaGFyX2xpdGVyYWwiLCJicHJpbnRfc3RyaW5nX2xpdGVyYWwiLCJicHJpbnRfZm10dHkiLCJmbXR0eSQxIiwiZm10dHkkMiIsImZtdHR5JDMiLCJmbXR0eSQ0IiwiZm10dHkkNSIsImZtdHR5JDYiLCJmbXR0eSQ3IiwiZm10dHkkOCIsImZtdHR5JDkiLCJzdWJfZm10dHkiLCJmbXR0eSQxMCIsInN1Yl9mbXR0eSQwIiwiZm10dHkkMTEiLCJmbXR0eSQxMiIsImZtdHR5JDEzIiwiZm10dHkkMTQiLCJmbXR0eSQxNSIsImludF9vZl9jdXN0b21fYXJpdHkiLCJzdHJpbmdfb2ZfZm10IiwiZm10aXRlciIsImZtdCQwIiwiaWduX2ZsYWckMCIsInN0ciQxIiwic2V0JDAiLCJpc19hbG9uZSIsImFmdGVyIiwiYmVmb3JlIiwiaiQxIiwiZm10JDEiLCJzeW1tIiwiZm10dHlfcmVsX2RldCIsImRlIiwiZWQiLCJhZiIsImZhIiwiZGUkMCIsImVkJDAiLCJhZiQwIiwiZmEkMCIsImRlJDEiLCJlZCQxIiwiYWYkMSIsImZhJDEiLCJkZSQyIiwiZWQkMiIsImFmJDIiLCJmYSQyIiwiZGUkMyIsImVkJDMiLCJhZiQzIiwiZmEkMyIsImRlJDQiLCJlZCQ0IiwiYWYkNCIsImZhJDQiLCJkZSQ1IiwiZWQkNSIsImFmJDUiLCJmYSQ1IiwiZGUkNiIsImVkJDYiLCJhZiQ2IiwiZmEkNiIsImRlJDciLCJlZCQ3IiwiYWYkNyIsImZhJDciLCJkZSQ4IiwiZWQkOCIsImFmJDgiLCJmYSQ4IiwidHJhbnMiLCJqZCIsImRqIiwiZ2EiLCJhZyIsImRlJDkiLCJlZCQ5IiwiYWYkOSIsImZhJDkiLCJkZSQxMCIsImVkJDEwIiwiYWYkMTAiLCJmYSQxMCIsImRlJDExIiwiZWQkMTEiLCJhZiQxMSIsImZhJDExIiwiZGUkMTIiLCJlZCQxMiIsImFmJDEyIiwiZmEkMTIiLCJkZSQxMyIsImVkJDEzIiwiYWYkMTMiLCJmYSQxMyIsInJlc3QxIiwicmVzdDIiLCJyZXN0MSQwIiwicmVzdDIkMCIsInJlc3QxJDEiLCJyZXN0MiQxIiwicmVzdDEkMiIsInJlc3QyJDIiLCJyZXN0MSQzIiwicmVzdDIkMyIsInJlc3QxJDQiLCJyZXN0MiQ0IiwicmVzdDEkNSIsInJlc3QyJDUiLCJyZXN0MSQ2IiwicmVzdDIkNiIsInJlc3QxJDciLCJ0eTEkMCIsInJlc3QyJDciLCJ0eTIkMCIsInJlc3QxJDgiLCJ0eTEyIiwidHkxMSIsInJlc3QyJDgiLCJ0eTIyIiwidHkyMSIsImY0IiwiZjIiLCJyZXN0MSQ5IiwicmVzdDIkOSIsInJlc3QxJDEwIiwicmVzdDIkMTAiLCJyZXN0MSQxMSIsInJlc3QyJDExIiwicmVzdDEkMTIiLCJyZXN0MiQxMiIsInJlc3QxJDEzIiwicmVzdDIkMTMiLCJmbXR0eV9vZl9mbXQiLCJmbXR0eV9vZl9wYWRkaW5nX2ZtdHR5IiwidHlfcmVzdCIsInByZWNfdHkiLCJmbXR0eV9vZl9wcmVjaXNpb25fZm10dHkiLCJ0eV9yZXN0JDAiLCJwcmVjX3R5JDAiLCJ0eV9yZXN0JDEiLCJwcmVjX3R5JDEiLCJ0eV9yZXN0JDIiLCJwcmVjX3R5JDIiLCJ0eV9yZXN0JDMiLCJwcmVjX3R5JDMiLCJ0eSQwIiwiZm9ybWF0dGluZ19nZW4iLCJmbXR0eV9vZl9jdXN0b20iLCJhcml0eSQwIiwidHlwZV9wYWRkaW5nIiwidyIsInR5cGVfcGFkcHJlYyIsInR5cGVfZm9ybWF0IiwidHlwZV9mb3JtYXRfZ2VuIiwiZm10dHkwIiwiZm10dHlfcmVzdCIsImZtdF9yZXN0IiwiZm10dHlfcmVzdCQwIiwiZm10X3Jlc3QkMCIsImZtdF9yZXN0JDEiLCJmbXR0eV9yZXN0JDEiLCJmbXQkMiIsImZtdF9yZXN0JDIiLCJmbXR0eV9yZXN0JDIiLCJmbXQkMyIsImZtdF9yZXN0JDMiLCJmbXR0eV9yZXN0JDMiLCJmbXQkNCIsImZtdF9yZXN0JDQiLCJmbXR0eV9yZXN0JDQiLCJmbXQkNSIsImZtdF9yZXN0JDUiLCJmbXR0eV9yZXN0JDUiLCJwcmVjJDQiLCJmbXQkNiIsImZtdF9yZXN0JDYiLCJwcmVjJDUiLCJwYWQkOSIsInBhZCQxMCIsImZtdHR5X3Jlc3QkNiIsInByZWMkNiIsImZtdCQ3IiwiZm10X3Jlc3QkNyIsInByZWMkNyIsInBhZCQxMSIsInBhZCQxMiIsImZtdHR5X3Jlc3QkNyIsInByZWMkOCIsImZtdCQ4IiwiZm10X3Jlc3QkOCIsInBhZCQxMyIsInBhZCQxNCIsImZtdHR5X3Jlc3QkOCIsImZtdCQ5IiwiZm10X3Jlc3QkOSIsImZtdCQxMCIsImZtdF9yZXN0JDEwIiwiZm10JDExIiwiZm10X3Jlc3QkMTEiLCJmbXQkMTIiLCJmbXR0eV9yZXN0JDkiLCJmbXRfcmVzdCQxMiIsImZtdCQxMyIsImZtdHR5X3Jlc3QkMTAiLCJzdWJfZm10dHkxIiwiZm10X3Jlc3QkMTMiLCJzdWJfZm10dHkkMSIsImZtdCQxNCIsImZtdHR5X3Jlc3QkMTEiLCJmbXRfcmVzdCQxNCIsImZtdCQxNSIsImZtdHR5X3Jlc3QkMTIiLCJmbXRfcmVzdCQxNSIsImZtdCQxNiIsImZtdF9yZXN0JDE2IiwiZm10dHkkMTYiLCJmbXQkMTciLCJmbXRfcmVzdCQxNyIsImZtdHR5MyIsImZtdDMiLCJmbXQxJDAiLCJmbXR0eTIkMCIsImZtdDIkMCIsImZtdHR5MyQwIiwiZm10MyQwIiwiZm10dHlfcmVzdCQxMyIsImZtdF9yZXN0JDE4IiwiZm10dHkkMTciLCJmbXQkMTgiLCJmbXR0eV9yZXN0JDE0IiwiZm10X3Jlc3QkMTkiLCJmbXR0eSQxOCIsImZtdCQxOSIsImZtdHR5X3Jlc3QkMTUiLCJmbXRfcmVzdCQyMCIsImZtdHR5JDE5IiwiZm10JDIwIiwidHlwZV9pZ25vcmVkX3BhcmFtX29uZSIsInN1Yl9mbXR0eSQyIiwic3ViX2ZtdHR5JDMiLCJ0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGkiLCJmbXR0eSQyMSIsImZtdCQyMiIsInN1Yl9mbXR0eSQ0IiwiZm10dHlfcmVzdCQxNiIsImZtdHR5JDIwIiwiZm10JDIxIiwic3ViX2ZtdHR5X3Jlc3QiLCJzdWJfZm10dHlfcmVzdCQwIiwic3ViX2ZtdHR5X3Jlc3QkMSIsInN1Yl9mbXR0eV9yZXN0JDIiLCJzdWJfZm10dHlfcmVzdCQzIiwic3ViX2ZtdHR5X3Jlc3QkNCIsInN1Yl9mbXR0eV9yZXN0JDUiLCJzdWJfZm10dHlfcmVzdCQ2Iiwic3ViX2ZtdHR5X3Jlc3QkNyIsInN1Yl9mbXR0eV9yZXN0JDgiLCJzdWJfZm10dHlfcmVzdCQ5Iiwic3ViX2ZtdHR5X3Jlc3QkMTAiLCJzdWJfZm10dHlfcmVzdCQxMSIsInN1Yl9mbXR0eV9yZXN0JDEyIiwic3ViX2ZtdHR5X3Jlc3QkMTMiLCJzdWJfZm10dHlfcmVzdCQxNCIsInN1YjJfZm10dHkiLCJzdWJfZm10dHlfcmVzdCQxNSIsInN1YjJfZm10dHkkMCIsInN1Yl9mbXR0eV9yZXN0JDE2Iiwic3ViMl9mbXR0eSQxIiwic3ViMV9mbXR0eSIsInN1Yl9mbXR0eV9yZXN0JDE3Iiwic3ViMl9mbXR0eSQyIiwic3ViMV9mbXR0eSQwIiwic3ViX2ZtdHR5X3Jlc3QkMTgiLCJzdWJfZm10dHlfcmVzdCQxOSIsInN1Yl9mbXR0eV9yZXN0JDIwIiwic3ViX2ZtdHR5X3Jlc3QkMjEiLCJzdWJfZm10dHlfcmVzdCQyMiIsInN1Yl9mbXR0eV9yZXN0JDIzIiwic3ViX2ZtdHR5X3Jlc3QkMjQiLCJzdWJfZm10dHlfcmVzdCQyNSIsInN1Yl9mbXR0eV9yZXN0JDI2IiwicmVjYXN0IiwiZml4X3BhZGRpbmciLCJ3aWR0aCQwIiwiZml4X2ludF9wcmVjaXNpb24iLCJyZXMkMSIsInN0cmluZ190b19jYW1sX3N0cmluZyIsImZvcm1hdF9vZl9mY29udiIsInN5bWIiLCJ0cmFuc2Zvcm1faW50X2FsdCIsImRpZ2l0cyIsInB1dCIsImNvbnZlcnRfaW50IiwiY29udmVydF9pbnQzMiIsImNvbnZlcnRfbmF0aXZlaW50IiwiY29udmVydF9pbnQ2NCIsImNvbnZlcnRfZmxvYXQiLCJoZXgiLCJzaWduIiwiY2FtbF9zcGVjaWFsX3ZhbCIsInN0cmluZ19vZl9mbXR0eSIsIm1ha2VfcHJpbnRmJDAiLCJuZXdfYWNjIiwibWFrZV9wcmludGYiLCJtYWtlX3BhZGRpbmciLCJtYWtlX2ludF9wYWRkaW5nX3ByZWNpc2lvbiIsInAkMCIsInAkMSIsImFjYyQzIiwiYWNjJDQiLCJrYWNjIiwibWFrZV9pZ25vcmVkX3BhcmFtJDAiLCJtYWtlX2N1c3RvbSQwIiwibWFrZV9pbnZhbGlkX2FyZyIsIm1ha2VfZnJvbV9mbXR0eSQwIiwibWFrZV9pZ25vcmVkX3BhcmFtIiwibWFrZV9mcm9tX2ZtdHR5IiwibWFrZV9jdXN0b20iLCJtYWtlX2lwcmludGYkMCIsIm1ha2VfaXByaW50ZiIsIngkMSIsIngkMiIsIngkMyIsIngkNCIsIngkNSIsIngkNiIsIngkNyIsIngkOCIsImZuX29mX3BhZGRpbmdfcHJlY2lzaW9uIiwieCQ5IiwieCQxMCIsIngkMTEiLCJ4JDEyIiwieCQxMyIsIngkMTQiLCJ4JDE1IiwieCQxNiIsImtvYyIsInJlc3QkMjQiLCJyZXN0JDI1IiwieCQxNyIsInJlc3QkMjYiLCJ4JDE4IiwicmVzdCQyNyIsIngkMTkiLCJyZXN0JDI4IiwicmVzdCQyOSIsImZuX29mX2N1c3RvbV9hcml0eSQwIiwiZm5fb2ZfY3VzdG9tX2FyaXR5Iiwib3V0cHV0X2FjYyIsInAkMyIsInAkNCIsInAkNSIsInAkMiIsImJ1ZnB1dF9hY2MiLCJzdHJwdXRfYWNjIiwiZmFpbHdpdGhfbWVzc2FnZSIsIm9wZW5fYm94X29mX3N0cmluZyIsImludmFsaWRfYm94IiwicGFyc2Vfc3BhY2VzIiwid3N0YXJ0Iiwid2VuZCIsImJveF9uYW1lIiwibnN0YXJ0IiwibmVuZCIsImluZGVudCIsImV4cF9lbmQiLCJib3hfdHlwZSIsIm1ha2VfcGFkZGluZ19mbXRfZWJiIiwibWFrZV9wYWRwcmVjX2ZtdF9lYmIiLCJmbXRfZWJiX29mX3N0cmluZyIsImxlZ2FjeV9iZWhhdmlvciIsImZsYWciLCJsZWdhY3lfYmVoYXZpb3IkMCIsImludmFsaWRfZm9ybWF0X21lc3NhZ2UiLCJpbnZhbGlkX2Zvcm1hdF93aXRob3V0IiwiZXhwZWN0ZWRfY2hhcmFjdGVyIiwiZXhwZWN0ZWQiLCJwYXJzZSIsImxpdF9zdGFydCIsImVuZF9pbmQiLCJhZGRfbGl0ZXJhbCIsInN0cl9pbmQkMSIsInN0cl9pbmQkMiIsInBhcnNlX2ZsYWdzIiwic3RyX2luZCQwIiwicGFyc2VfdGFnIiwic3RyX2luZCQzIiwic3RyX2luZF8xIiwicGFyc2VfaW50ZWdlciIsInN0cl9pbmRfMiIsInN0cl9pbmRfMyIsImZvcm1hdHRpbmdfbGl0JDAiLCJuZXh0X2luZCIsInN0cl9pbmRfNCIsInN0cl9pbmRfNSIsInN0cl9pbmQkNCIsInN0cl9pbmRfMSQwIiwic3RyX2luZF8yJDAiLCJzdHJfaW5kXzMkMCIsInMkMSIsImZvcm1hdHRpbmdfbGl0JDEiLCJuZXh0X2luZCQwIiwicGN0X2luZCIsIm1pbnVzIiwicGx1cyIsInNwYWNlIiwic2V0X2ZsYWciLCJzdHJfaW5kJDUiLCJzcGFjZSQwIiwiaGFzaCQwIiwicGx1cyQwIiwibWludXMkMCIsInplcm8kMCIsImluY29tcGF0aWJsZV9mbGFnIiwicGFyc2VfcG9zaXRpdmUiLCJuZXdfaW5kIiwicGFyc2VfYWZ0ZXJfcGFkZGluZyIsInBhcnNlX2NvbnZlcnNpb24iLCJwYXJzZV9saXRlcmFsIiwicGFyc2VfYWZ0ZXJfcHJlY2lzaW9uIiwic3ltYiQwIiwicGFyc2VfY29udiIsInBhZHByZWMiLCJwbHVzX3VzZWQiLCJoYXNoX3VzZWQiLCJzcGFjZV91c2VkIiwiaWduX3VzZWQiLCJwYWRfdXNlZCIsInByZWNfdXNlZCIsImdldF9wbHVzIiwiZ2V0X2hhc2giLCJnZXRfc3BhY2UiLCJnZXRfaWduIiwiZ2V0X3BhZCIsImdldF9wcmVjIiwiZ2V0X3BhZHByZWMiLCJnZXRfaW50X3BhZCIsImNoZWNrX25vXzAiLCJvcHRfb2ZfcGFkIiwid2lkdGgkMSIsImdldF9wYWRfb3B0IiwiZ2V0X3BhZHByZWNfb3B0IiwiZm10X3Jlc3VsdCIsInN1Yl9lbmQiLCJzZWFyY2hfc3ViZm9ybWF0X2VuZCIsInN1Yl9mbXQiLCJpZ25vcmVkJDIiLCJjb3VudGVyJDAiLCJpZ25vcmVkJDYiLCJpZ25vcmVkJDciLCJhZGRfcmFuZ2UiLCJmYWlsX3NpbmdsZV9wZXJjZW50IiwicGFyc2VfY2hhcl9zZXRfY29udGVudCIsInBhcnNlX2NoYXJfc2V0X2FmdGVyX2NoYXIkMCIsInBhcnNlX2NoYXJfc2V0X2FmdGVyX2NoYXIiLCJyZXZlcnNlIiwiY2hhcl9zZXQkMSIsImlnbm9yZWQkOSIsImNoYXJfZm9ybWF0IiwiZm10X3Jlc3QkMjEiLCJmbXRfcmVzdCQyMiIsImZtdF9yZXN0JDIzIiwiaWdub3JlZCQxMCIsImZtdF9yZXN0JDI0IiwiZm10X3Jlc3QkMjUiLCJzdWJfZW5kJDAiLCJzdWJfZm10JDAiLCJmbXRfcmVzdCQyNiIsImlnbm9yZWQkMTEiLCJpZ25vcmVkJDMiLCJpZ25vcmVkJDUiLCJjb21wdXRlX2ludF9jb252IiwiaWdub3JlZCQ4Iiwic3BhY2UkMSIsImhhc2gkMSIsInBsdXMkMiIsImtpbmQiLCJpZ25vcmVkJDQiLCJpZ25vcmVkIiwiaWdub3JlZCQwIiwiaWdub3JlZCQxIiwicGx1cyQxIiwiaWduJDAiLCJpc19vcGVuX3RhZyIsImluZCIsInN1Yl9zdHIiLCJzdWJfZm9ybWF0JDAiLCJmb3JtYXR0aW5nJDAiLCJmb3JtYXR0aW5nIiwic3ViX2VuZCQxIiwic3ViX2VuZCQyIiwic3RyX2luZCQ2Iiwic3RyX2luZCQ3Iiwib3B0aW9uIiwic3ViZm10IiwiZm9ybWF0X29mX3N0cmluZ19mbXR0eSIsImZvcm1hdF9vZl9zdHJpbmdfZm9ybWF0Iiwia2ZwcmludGYiLCJrYnByaW50ZiIsImlrZnByaW50ZiIsImZwcmludGYiLCJicHJpbnRmIiwiaWZwcmludGYiLCJpYnByaW50ZiIsInByaW50ZiIsImVwcmludGYiLCJrc3ByaW50ZiIsInNwcmludGYiLCJhc3NvYzMiLCJ5MiIsInkxIiwibWFrZV9zeW1saXN0IiwiaGVscF9hY3Rpb24iLCJhZGRfaGVscCIsInNwZWNsaXN0IiwiYWRkMSIsImFkZDIiLCJ1c2FnZV9iIiwiZXJybXNnIiwiZG9jIiwic3BlYyIsImtleSIsInVzYWdlX3N0cmluZyIsInVzYWdlIiwiY3VycmVudCIsInBhcnNlX2FuZF9leHBhbmRfYXJndl9keW5hbWljXyIsImFsbG93X2V4cGFuZCIsImFyZ3YiLCJhbm9uZnVuIiwiaW5pdHBvcyIsImNvbnZlcnRfZXJyb3IiLCJwcm9nbmFtZSIsImZvbGxvdyQwIiwia2V5d29yZCIsImZvbGxvdyQyIiwibm9fYXJnIiwiZ2V0X2FyZyIsImNvbnN1bWVfYXJnIiwidHJlYXRfYWN0aW9uIiwibm9fYXJnJDAiLCJmJDAiLCJnZXRfYXJnJDAiLCJjb25zdW1lX2FyZyQwIiwiZiQxIiwiciQxIiwiZiQyIiwiYXJnJDEiLCJyJDIiLCJhcmckMiIsImYkMyIsImFyZyQzIiwiciQzIiwiYXJnJDQiLCJzcGVjcyIsInRyZWF0X2FjdGlvbiQwIiwiZiQ0IiwiYXJnJDUiLCJmJDUiLCJmJDYiLCJmJDciLCJhcmckNiIsIm5ld2FyZyIsInBhcnNlX2FuZF9leHBhbmRfYXJndl9keW5hbWljIiwicGFyc2VfYXJndl9keW5hbWljIiwiY3VycmVudCQwIiwicGFyc2VfYXJndiIsIm1zZyQwIiwibXNnJDEiLCJwYXJzZV9keW5hbWljIiwicGFyc2VfZXhwYW5kIiwic2Vjb25kX3dvcmQiLCJsb29wIiwibWF4X2FyZ19sZW4iLCJrd2QiLCJyZXBsYWNlX2xlYWRpbmdfdGFiIiwiYWxpZ24iLCJsaW1pdCIsImNvbXBsZXRlZCIsImtzZCIsImN1dGNvbCQwIiwic3BhY2VzJDAiLCJzcGVjJDAiLCJjdXRjb2wiLCJrd2RfbGVuIiwic3BhY2VzIiwicmVhZF9hdXgiLCJmaWxlIiwid29yZHMiLCJzdGFzaCIsIndvcmQiLCJ3b3JkJDAiLCJyZWFkX2FyZyIsInJlYWRfYXJnMCIsIndyaXRlX2F1eCIsImFyZ3MiLCJ3cml0ZV9hcmciLCJ3cml0ZV9hcmcwIiwibG9jZm10IiwicHJpbnRlcnMiLCJmaWVsZCIsIm90aGVyX2ZpZWxkcyIsInVzZV9wcmludGVycyIsInRvX3N0cmluZ19kZWZhdWx0IiwiY2hhciQwIiwibGluZSIsImNoYXIkMSIsImxpbmUkMCIsImZpbGUkMCIsImNoYXIkMiIsImxpbmUkMSIsImZpbGUkMSIsImNvbnN0cnVjdG9yIiwicHJpbnQiLCJmY3QiLCJjYXRjaCQwIiwicmF3X2JhY2t0cmFjZV9lbnRyaWVzIiwiYnQiLCJjb252ZXJ0X3Jhd19iYWNrdHJhY2UiLCJmb3JtYXRfYmFja3RyYWNlX3Nsb3QiLCJpc19yYWlzZSIsInByaW50X3Jhd19iYWNrdHJhY2UiLCJvdXRjaGFuIiwicmF3X2JhY2t0cmFjZSIsImJhY2t0cmFjZSIsInByaW50X2JhY2t0cmFjZSIsInJhd19iYWNrdHJhY2VfdG9fc3RyaW5nIiwiYmFja3RyYWNlX3Nsb3RfaXNfcmFpc2UiLCJwYXJhbSIsImJhY2t0cmFjZV9zbG90X2lzX2lubGluZSIsImJhY2t0cmFjZV9zbG90X2xvY2F0aW9uIiwiYmFja3RyYWNlX3Nsb3RfZGVmbmFtZSIsImJhY2t0cmFjZV9zbG90cyIsImJhY2t0cmFjZV9zbG90c19vZl9yYXdfZW50cnkiLCJlbnRyeSIsInJhd19iYWNrdHJhY2VfbGVuZ3RoIiwiZ2V0X2JhY2t0cmFjZSIsInJlZ2lzdGVyX3ByaW50ZXIiLCJmbiIsIm9sZF9wcmludGVycyIsIm5ld19wcmludGVycyIsImV4bl9zbG90IiwiZXhuX3Nsb3RfaWQiLCJleG5fc2xvdF9uYW1lIiwiZXJyb3JzIiwiZGVmYXVsdF91bmNhdWdodF9leGNlcHRpb25faGFuIiwic3RhdHVzIiwidW5jYXVnaHRfZXhjZXB0aW9uX2hhbmRsZXIiLCJzZXRfdW5jYXVnaHRfZXhjZXB0aW9uX2hhbmRsZXIiLCJlbXB0eV9iYWNrdHJhY2UiLCJoYW5kbGVfdW5jYXVnaHRfZXhjZXB0aW9uIiwiZGVidWdnZXJfaW5fdXNlIiwiZXhuJDEiLCJyYXdfYmFja3RyYWNlJDAiLCJjb25zdCQwIiwiZmxpcCIsIm5lZ2F0ZSIsInByb3RlY3QiLCJmaW5hbGx5JDAiLCJ3b3JrIiwiZmluYWxseV9ub19leG4iLCJ3b3JrX2V4biQwIiwid29ya19leG4iLCJ3b3JrX2J0IiwicHJpbnRfc3RhdCIsImFsbG9jYXRlZF9ieXRlcyIsIm1hIiwicHJvIiwibWkiLCJjcmVhdGVfYWxhcm0iLCJkZWxldGVfYWxhcm0iLCJudWxsX3RyYWNrZXIiLCJzYW1wbGluZ19yYXRlIiwidHJhY2tlciIsImNhbGxzdGFja19zaXplIiwic3RyaW5nIiwiYnl0ZXMiLCJzdWJzdHJpbmciLCJzdWJieXRlcyIsImZpbGVuYW1lIiwiZGlnZXN0IiwiY2hhcl9oZXgiLCJ0b19oZXgiLCJmcm9tX2hleCIsImRpZ2l0IiwibmV3X3N0YXRlIiwiYXNzaWduIiwic3QxIiwic3QyIiwiZnVsbF9pbml0Iiwic2VlZCIsInNlZWQkMCIsIm1ha2Vfc2VsZl9pbml0IiwiYml0cyIsImN1cnZhbCIsIm5ld3ZhbCIsIm5ld3ZhbDMwIiwiaW50YXV4IiwiaW50JDAiLCJib3VuZCIsImZ1bGxfaW50IiwibWF4X2ludF8zMiIsImJwb3MiLCJpbnQzMiIsImludDY0IiwibmF0aXZlaW50IiwiZmxvYXQkMCIsImJvb2wiLCJiaXRzMzIiLCJiaXRzNjQiLCJuYXRpdmViaXRzIiwiYml0cyQwIiwiaW50JDEiLCJmdWxsX2ludCQwIiwiaW50MzIkMCIsIm5hdGl2ZWludCQwIiwiaW50NjQkMCIsImZsb2F0JDEiLCJzY2FsZSIsImJvb2wkMCIsImJpdHMzMiQwIiwiYml0czY0JDAiLCJuYXRpdmViaXRzJDAiLCJmdWxsX2luaXQkMCIsInNlbGZfaW5pdCIsImdldF9zdGF0ZSIsInNldF9zdGF0ZSIsIm9uZ29pbmdfdHJhdmVyc2FsIiwiZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCIsInBhcmFtcyIsInJhbmRvbWl6ZWRfZGVmYXVsdCIsInJhbmRvbWl6ZWQiLCJyYW5kb21pemUiLCJpc19yYW5kb21pemVkIiwicHJuZyIsInBvd2VyXzJfYWJvdmUiLCJpbml0aWFsX3NpemUiLCJyYW5kb20iLCJjb3B5X2J1Y2tldGxpc3QiLCJrZXkkMCIsIm5leHQkMCIsImluc2VydF9hbGxfYnVja2V0cyIsImluZGV4ZnVuIiwiaW5wbGFjZSIsIm9kYXRhIiwibmRhdGEiLCJuc2l6ZSIsIm5kYXRhX3RhaWwiLCJuaWR4IiwibWF0Y2gkMCIsIm9zaXplIiwib2xkX3RyYXYiLCJmaWx0ZXJfbWFwX2lucGxhY2UiLCJiJDAiLCJidWNrZXRfbGVuZ3RoIiwic3RhdHMiLCJtYmwiLCJoaXN0byIsInRibF9kYXRhIiwiYnVjayIsImJ1Y2skMCIsImJ1Y2skMSIsInRvX3NlcV9rZXlzIiwidG9fc2VxX3ZhbHVlcyIsImtleV9pbmRleCIsImJ1Y2tldCIsImsxIiwibmV4dDEiLCJrMiIsIm5leHQyIiwiazMiLCJkMyIsIm5leHQzIiwiZmluZF9pbl9idWNrZXQiLCJyZXBsYWNlIiwicmVwbGFjZV9zZXEiLCJzeiIsImhhc2hfcGFyYW0iLCJzZWVkZWRfaGFzaCIsInJlYnVpbGQiLCJnZXRfY29weSIsImFyIiwiZW1wdHlidWNrZXQiLCJnZXRfaW5kZXgiLCJjcmVhdGUkMCIsInN6JDAiLCJzeiQxIiwiY291bnRfYnVja2V0IiwiYWRkX2F1eCIsInNldHRlciIsImJ1Y2tldCQwIiwiaGFzaGVzIiwibmV3c3oiLCJuZXdidWNrZXQkMCIsIm5ld2hhc2hlcyIsImhidWNrZXQiLCJwcmV2X2xlbiIsImxpdmUiLCJqJDIiLCJuZXdidWNrZXQiLCJvbGRsZW4iLCJuZXd0Iiwib2IiLCJvaSIsIm9oIiwib2kkMCIsIm5pIiwiZmluZF9vciIsImlmbm90Zm91bmQiLCJmaW5kX3NoYWRvdyIsImlmZm91bmQiLCJsZW5zIiwidG90bGVuIiwidW5rbm93biIsInBwX2VucXVldWUiLCJ0b2tlbiIsInBwX2luZmluaXR5IiwicHBfb3V0cHV0X3N0cmluZyIsInBwX291dHB1dF9uZXdsaW5lIiwiZm9ybWF0X3BwX3RleHQiLCJ0ZXh0IiwiZm9ybWF0X3N0cmluZyIsImJyZWFrX25ld19saW5lIiwicmVhbF9pbmRlbnQiLCJicmVha19zYW1lX2xpbmUiLCJmb3JtYXRfcHBfdG9rZW4iLCJzaXplJDAiLCJ0YWJzIiwiYWRkX3RhYiIsImxzIiwidGFnX25hbWUiLCJtYXJrZXIiLCJicmVha3MiLCJmaXRzIiwib2ZmIiwiYm94X3R5cGUkMCIsIm9mZiQwIiwiaW5zZXJ0aW9uX3BvaW50IiwidGFicyQwIiwiZmlyc3QiLCJoZWFkIiwidGFiIiwib2ZmJDEiLCJpbnNlcnRpb25fcG9pbnQkMCIsIndpZHRoJDIiLCJib3hfdHlwZSQxIiwidGJveCIsInRhZ19uYW1lJDAiLCJtYXJrZXIkMCIsImFkdmFuY2VfbGVmdCIsInBlbmRpbmdfY291bnQiLCJlbnF1ZXVlX2FkdmFuY2UiLCJlbnF1ZXVlX3N0cmluZ19hcyIsImluaXRpYWxpemVfc2Nhbl9zdGFjayIsInN0YWNrIiwicXVldWVfZWxlbSIsInNldF9zaXplIiwibGVmdF90b3RhbCIsInNjYW5fcHVzaCIsImVsZW0iLCJwcF9vcGVuX2JveF9nZW4iLCJicl90eSIsInBwX2Nsb3NlX2JveCIsInBwX29wZW5fc3RhZyIsInBwX2Nsb3NlX3N0YWciLCJwcF9vcGVuX3RhZyIsInBwX2Nsb3NlX3RhZyIsInBwX3NldF9wcmludF90YWdzIiwicHBfc2V0X21hcmtfdGFncyIsInBwX2dldF9wcmludF90YWdzIiwicHBfZ2V0X21hcmtfdGFncyIsInBwX3NldF90YWdzIiwicHBfZ2V0X2Zvcm1hdHRlcl9zdGFnX2Z1bmN0aW9uIiwicHBfc2V0X2Zvcm1hdHRlcl9zdGFnX2Z1bmN0aW9uIiwicGN0IiwicG90IiwibWN0IiwibW90IiwicHBfcmluaXQiLCJwcF9mbHVzaF9xdWV1ZSIsInBwX3ByaW50X2FzX3NpemUiLCJwcF9wcmludF9hcyIsImlzaXplIiwicHBfcHJpbnRfc3RyaW5nIiwicHBfcHJpbnRfYnl0ZXMiLCJwcF9wcmludF9pbnQiLCJwcF9wcmludF9mbG9hdCIsInBwX3ByaW50X2Jvb2wiLCJwcF9wcmludF9jaGFyIiwicHBfb3Blbl9oYm94IiwicHBfb3Blbl92Ym94IiwicHBfb3Blbl9odmJveCIsInBwX29wZW5faG92Ym94IiwicHBfb3Blbl9ib3giLCJwcF9wcmludF9uZXdsaW5lIiwicHBfcHJpbnRfZmx1c2giLCJwcF9mb3JjZV9uZXdsaW5lIiwicHBfcHJpbnRfaWZfbmV3bGluZSIsInBwX3ByaW50X2N1c3RvbV9icmVhayIsInBwX3ByaW50X2JyZWFrIiwicHBfcHJpbnRfc3BhY2UiLCJwcF9wcmludF9jdXQiLCJwcF9vcGVuX3Rib3giLCJwcF9jbG9zZV90Ym94IiwicHBfcHJpbnRfdGJyZWFrIiwicHBfcHJpbnRfdGFiIiwicHBfc2V0X3RhYiIsInBwX3NldF9tYXhfYm94ZXMiLCJwcF9nZXRfbWF4X2JveGVzIiwicHBfb3Zlcl9tYXhfYm94ZXMiLCJwcF9zZXRfZWxsaXBzaXNfdGV4dCIsInBwX2dldF9lbGxpcHNpc190ZXh0IiwicHBfbGltaXQiLCJwcF9zZXRfbWF4X2luZGVudCIsInBwX2dldF9tYXhfaW5kZW50IiwicHBfc2V0X21hcmdpbiIsIm5ld19tYXhfaW5kZW50IiwidmFsaWRhdGVfZ2VvbWV0cnkiLCJtYXJnaW4iLCJtYXhfaW5kZW50IiwiY2hlY2tfZ2VvbWV0cnkiLCJnZW9tZXRyeSIsInBwX2dldF9tYXJnaW4iLCJwcF9zZXRfZnVsbF9nZW9tZXRyeSIsInBwX3NldF9nZW9tZXRyeSIsInBwX3NhZmVfc2V0X2dlb21ldHJ5IiwicHBfZ2V0X2dlb21ldHJ5IiwicHBfdXBkYXRlX2dlb21ldHJ5IiwicHBfc2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zIiwicHBfZ2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zIiwicHBfc2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3RpIiwicHBfZ2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3RpIiwiZGlzcGxheV9uZXdsaW5lIiwiYmxhbmtfbGluZSIsImRpc3BsYXlfYmxhbmtzIiwicHBfc2V0X2Zvcm1hdHRlcl9vdXRfY2hhbm5lbCIsImRlZmF1bHRfcHBfbWFya19vcGVuX3RhZyIsImRlZmF1bHRfcHBfbWFya19jbG9zZV90YWciLCJkZWZhdWx0X3BwX3ByaW50X29wZW5fdGFnIiwiZGVmYXVsdF9wcF9wcmludF9jbG9zZV90YWciLCJwcF9tYWtlX2Zvcm1hdHRlciIsInBwX3F1ZXVlIiwic3lzX3RvayIsInNjYW5fc3RhY2siLCJwcF9tYXJnaW4iLCJmb3JtYXR0ZXJfb2Zfb3V0X2Z1bmN0aW9ucyIsIm91dF9mdW5zIiwibWFrZV9mb3JtYXR0ZXIiLCJwcGYiLCJmb3JtYXR0ZXJfb2Zfb3V0X2NoYW5uZWwiLCJmb3JtYXR0ZXJfb2ZfYnVmZmVyIiwicHBfYnVmZmVyX3NpemUiLCJwcF9tYWtlX2J1ZmZlciIsInN0ZGJ1ZiIsInN0ZF9mb3JtYXR0ZXIiLCJlcnJfZm9ybWF0dGVyIiwic3RyX2Zvcm1hdHRlciIsImZsdXNoX2J1ZmZlcl9mb3JtYXR0ZXIiLCJmbHVzaF9zdHJfZm9ybWF0dGVyIiwibWFrZV9zeW1ib2xpY19vdXRwdXRfYnVmZmVyIiwiY2xlYXJfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciIsInNvYiIsImdldF9zeW1ib2xpY19vdXRwdXRfYnVmZmVyIiwiZmx1c2hfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciIsIml0ZW1zIiwiYWRkX3N5bWJvbGljX291dHB1dF9pdGVtIiwiaXRlbSIsImZvcm1hdHRlcl9vZl9zeW1ib2xpY19vdXRwdXRfYiIsIm9wZW5faGJveCIsIm9wZW5fdmJveCIsIm9wZW5faHZib3giLCJvcGVuX2hvdmJveCIsIm9wZW5fYm94IiwiY2xvc2VfYm94Iiwib3Blbl90YWciLCJjbG9zZV90YWciLCJvcGVuX3N0YWciLCJjbG9zZV9zdGFnIiwicHJpbnRfYXMiLCJwcmludF9ib29sIiwicHJpbnRfYnJlYWsiLCJwcmludF9jdXQiLCJwcmludF9zcGFjZSIsImZvcmNlX25ld2xpbmUiLCJwcmludF9mbHVzaCIsInByaW50X2lmX25ld2xpbmUiLCJvcGVuX3Rib3giLCJjbG9zZV90Ym94IiwicHJpbnRfdGJyZWFrIiwic2V0X3RhYiIsInByaW50X3RhYiIsInNldF9tYXJnaW4iLCJnZXRfbWFyZ2luIiwic2V0X21heF9pbmRlbnQiLCJnZXRfbWF4X2luZGVudCIsInNldF9nZW9tZXRyeSIsInNhZmVfc2V0X2dlb21ldHJ5IiwiZ2V0X2dlb21ldHJ5IiwidXBkYXRlX2dlb21ldHJ5Iiwic2V0X21heF9ib3hlcyIsImdldF9tYXhfYm94ZXMiLCJvdmVyX21heF9ib3hlcyIsInNldF9lbGxpcHNpc190ZXh0IiwiZ2V0X2VsbGlwc2lzX3RleHQiLCJzZXRfZm9ybWF0dGVyX291dF9jaGFubmVsIiwic2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zIiwiZ2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zIiwic2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIiwiZ2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIiwic2V0X2Zvcm1hdHRlcl9zdGFnX2Z1bmN0aW9ucyIsImdldF9mb3JtYXR0ZXJfc3RhZ19mdW5jdGlvbnMiLCJzZXRfcHJpbnRfdGFncyIsImdldF9wcmludF90YWdzIiwic2V0X21hcmtfdGFncyIsImdldF9tYXJrX3RhZ3MiLCJzZXRfdGFncyIsInBwX3ByaW50X2xpc3QiLCJwcF92Iiwib3B0JDAiLCJwcF9zZXAiLCJvcHQkMSIsInBwX3ByaW50X3NlcSIsInNlcSQxIiwic2VxJDIiLCJwcF9wcmludF90ZXh0IiwicHBfcHJpbnRfb3B0aW9uIiwicHBfcHJpbnRfcmVzdWx0IiwicHBfcHJpbnRfZWl0aGVyIiwiY29tcHV0ZV90YWciLCJ0YWdfYWNjIiwib3V0cHV0X2Zvcm1hdHRpbmdfbGl0IiwiYnR5IiwicCQ2IiwicCQ3Iiwic2l6ZSQxIiwicCQ4Iiwia2RwcmludGYiLCJkcHJpbnRmIiwia2FzcHJpbnRmIiwiYXNwcmludGYiLCJmbHVzaF9zdGFuZGFyZF9mb3JtYXR0ZXJzIiwicHBfc2V0X2FsbF9mb3JtYXR0ZXJfb3V0cHV0X2Z1IiwicHBfZ2V0X2FsbF9mb3JtYXR0ZXJfb3V0cHV0X2Z1Iiwic2V0X2FsbF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0IiwiZ2V0X2FsbF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0IiwicHBfc2V0X2Zvcm1hdHRlcl90YWdfZnVuY3Rpb25zIiwic3RyaW5naWZ5IiwicHBfZ2V0X2Zvcm1hdHRlcl90YWdfZnVuY3Rpb25zIiwiZnVucyIsIm1hcmtfb3Blbl90YWciLCJtYXJrX2Nsb3NlX3RhZyIsInByaW50X29wZW5fdGFnIiwicHJpbnRfY2xvc2VfdGFnIiwic2V0X2Zvcm1hdHRlcl90YWdfZnVuY3Rpb25zIiwiZ2V0X2Zvcm1hdHRlcl90YWdfZnVuY3Rpb25zIiwibnVsbF9jaGFyIiwibmV4dF9jaGFyIiwiaWIiLCJwZWVrX2NoYXIiLCJjaGVja2VkX3BlZWtfY2hhciIsImVuZF9vZl9pbnB1dCIsImJlZ2lubmluZ19vZl9pbnB1dCIsIm5hbWVfb2ZfaW5wdXQiLCJjaGFyX2NvdW50IiwiaW52YWxpZGF0ZV9jdXJyZW50X2NoYXIiLCJ0b2tlbl9zdHJpbmciLCJ0b2tlbl9idWZmZXIiLCJpZ25vcmVfY2hhciIsInN0b3JlX2NoYXIiLCJkZWZhdWx0X3Rva2VuX2J1ZmZlcl9zaXplIiwiaW5hbWUiLCJzY2FuX2Nsb3NlX2F0X2VuZCIsInNjYW5fcmFpc2VfYXRfZW5kIiwiZnJvbV9pYyIsInNjYW5fY2xvc2VfaWMiLCJlb2YiLCJvcGVuX2luX2ZpbGUiLCJpYyQwIiwibWVtbyIsIm1lbW9fZnJvbV9jaGFubmVsIiwiYmFkX2lucHV0IiwiYmFkX2lucHV0X2VzY2FwZSIsImJhZF90b2tlbl9sZW5ndGgiLCJtZXNzYWdlIiwiYmFkX2hleF9mbG9hdCIsImNoYXJhY3Rlcl9taXNtYXRjaCIsImNpIiwiY2hlY2tfY2hhciIsImNoZWNrX3RoaXNfY2hhciIsInRva2VuX2NoYXIiLCJ0b2tlbl9ib29sIiwiaW50ZWdlcl9jb252ZXJzaW9uX29mX2NoYXIiLCJ0b2tlbl9pbnRfbGl0ZXJhbCIsImNvbnYiLCJ0b2tlbl9mbG9hdCIsInNjYW5fZGVjaW1hbF9kaWdpdF9zdGFyIiwic2Nhbl9kZWNpbWFsX2RpZ2l0X3BsdXMiLCJzY2FuX2RpZ2l0X3BsdXMiLCJiYXNpcyIsImRpZ2l0cCIsIndpZHRoJDMiLCJpc19iaW5hcnlfZGlnaXQiLCJpc19vY3RhbF9kaWdpdCIsImlzX2hleGFfZGlnaXQiLCJzY2FuX3NpZ24iLCJzY2FuX29wdGlvbmFsbHlfc2lnbmVkX2RlY2ltYWwiLCJzY2FuX2ludF9jb252ZXJzaW9uIiwic2Nhbl9mcmFjdGlvbmFsX3BhcnQiLCJzY2FuX2V4cG9uZW50X3BhcnQiLCJzY2FuX2Zsb2F0IiwicHJlY2lzaW9uIiwicHJlY2lzaW9uJDAiLCJjaGVja19jYXNlX2luc2Vuc2l0aXZlX3N0cmluZyIsInNjYW5faGV4X2Zsb2F0Iiwid2lkdGgkNCIsIndpZHRoJDUiLCJ3aWR0aCQ2Iiwid2lkdGgkMTAiLCJ3aWR0aCQ3Iiwid2lkdGgkOCIsIndpZHRoJDkiLCJzY2FuX2NhbWxfZmxvYXRfcmVzdCIsIndpZHRoX3ByZWNpc2lvbiIsImZyYWNfd2lkdGgiLCJzY2FuX2NhbWxfZmxvYXQiLCJzY2FuX3N0cmluZyIsInN0cCIsImhleGFkZWNpbWFsX3ZhbHVlX29mX2NoYXIiLCJjaGVja19uZXh0X2NoYXIiLCJzY2FuX2JhY2tzbGFzaF9jaGFyIiwiYzAiLCJnZXRfZGlnaXQkMCIsImMxJDAiLCJjMiQwIiwiZ2V0X2RpZ2l0Iiwic2Nhbl9jYW1sX3N0cmluZyIsImZpbmRfc3RvcCQwIiwic2tpcF9zcGFjZXMiLCJmaW5kX3N0b3AiLCJzY2FuX2NoYXJzX2luX2NoYXJfc2V0Iiwic2Nhbl9pbmRpYyIsInNjYW5fY2hhcnMiLCJzY2FuZl9iYWRfaW5wdXQiLCJ3aWR0aF9vZl9wYWRfb3B0Iiwic3RvcHBlcl9vZl9mb3JtYXR0aW5nX2xpdCIsImZtdGluZyIsInRha2VfZm9ybWF0X3JlYWRlcnMkMCIsInRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMkMCIsInJlYWRlciIsIm5ld19rIiwicmVhZGVyc19yZXN0IiwidGFrZV9mb3JtYXRfcmVhZGVycyIsInRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMiLCJtYWtlX3NjYW5mIiwicmVhZGVycyIsInNjYW4kMCIsInN0cl9yZXN0IiwicGFkX3ByZWNfc2NhbmYiLCJzY2FuJDEiLCJzY2FuJDIiLCJzY2FuJDMiLCJzY2FuJDQiLCJjb252JDAiLCJzY2FuJDUiLCJjb252JDEiLCJzY2FuJDYiLCJjb252JDIiLCJzY2FuJDciLCJzY2FuJDgiLCJmbXRpbmdfbGl0JDAiLCJzdHAkMCIsInMkMiIsInN0cl9yZXN0JDAiLCJhcmdfcmVzdCIsImtzY2FuZiIsImVmIiwiZXhjJDAiLCJleGMiLCJhcmdzJDEiLCJhcmdzJDAiLCJic2NhbmYiLCJrc3NjYW5mIiwic3NjYW5mIiwic2NhbmYiLCJic2NhbmZfZm9ybWF0IiwiZm9ybWF0Iiwic3NjYW5mX2Zvcm1hdCIsImZvcm1hdF9mcm9tX3N0cmluZyIsInVuZXNjYXBlZCIsImtmc2NhbmYiLCJmc2NhbmYiLCJyZWdpc3RlciIsInJlZ2lzdGVyX2V4Y2VwdGlvbiIsIm8kMCIsInB1YmxpY19tZXRob2RfbGFiZWwiLCJ0YWciLCJjb21wYXJlJDAiLCJjb21wYXJlJDEiLCJkdW1teV90YWJsZSIsInRhYmxlX2NvdW50IiwiZHVtbXlfbWV0IiwiaW5pdGlhbF9vYmplY3Rfc2l6ZSIsImZpdF9zaXplIiwibmV3X3RhYmxlIiwicHViX2xhYmVscyIsIm1ldGhvZHMiLCJhcnJheSIsIm5ld19zaXplIiwib2xkX3NpemUiLCJuZXdfYnVjayIsIm1ldGhvZF9jb3VudCIsImluc3RfdmFyX2NvdW50IiwibmV3X21ldGhvZCIsInRhYmxlIiwiZ2V0X21ldGhvZF9sYWJlbCIsImxhYmVsIiwiZ2V0X21ldGhvZF9sYWJlbHMiLCJuYW1lcyIsInNldF9tZXRob2QiLCJlbGVtZW50IiwiZ2V0X21ldGhvZCIsImFyciIsIm5hcnJvdyIsInZhcnMiLCJ2aXJ0X21ldGhzIiwiY29uY3JfbWV0aHMiLCJ2YXJzJDAiLCJ2aXJ0X21ldGhzJDAiLCJjb25jcl9tZXRocyQwIiwidmlydF9tZXRoX2xhYnMiLCJjb25jcl9tZXRoX2xhYnMiLCJsYWIiLCJ0dmFycyIsImJ5X25hbWUiLCJieV9sYWJlbCIsIm1ldCIsImhtIiwid2lkZW4iLCJzYXZlZF92YXJzIiwic2F2ZWRfaGlkZGVuX21ldGhzIiwibmV3X3ZhcmlhYmxlIiwidG9fYXJyYXkiLCJuZXdfbWV0aG9kc192YXJpYWJsZXMiLCJtZXRocyIsInZhbHMiLCJtZXRocyQwIiwibm1ldGhzIiwibnZhbHMiLCJnZXRfdmFyaWFibGUiLCJnZXRfdmFyaWFibGVzIiwiYWRkX2luaXRpYWxpemVyIiwiY3JlYXRlX3RhYmxlIiwicHVibGljX21ldGhvZHMiLCJ0YWdzIiwiaW5pdF9jbGFzcyIsImluaGVyaXRzIiwiY2xhIiwic3VwZXIkMCIsIm5tIiwibWFrZV9jbGFzcyIsInB1Yl9tZXRocyIsImNsYXNzX2luaXQiLCJlbnZfaW5pdCIsIm1ha2VfY2xhc3Nfc3RvcmUiLCJpbml0X3RhYmxlIiwiZHVtbXlfY2xhc3MiLCJsb2MiLCJ1bmRlZiIsImNyZWF0ZV9vYmplY3QiLCJjcmVhdGVfb2JqZWN0X29wdCIsIm9ial8wIiwiaXRlcl9mIiwicnVuX2luaXRpYWxpemVycyIsImluaXRzIiwicnVuX2luaXRpYWxpemVyc19vcHQiLCJjcmVhdGVfb2JqZWN0X2FuZF9ydW5faW5pdGlhbGkiLCJidWlsZF9wYXRoIiwia2V5cyIsImxvb2t1cF90YWJsZXMiLCJyb290Iiwicm9vdF9kYXRhIiwidGFibGVzJDAiLCJ0YWJsZXMkMSIsInRhYmxlc19kYXRhIiwibmV3X2NhY2hlIiwic2V0X21ldGhvZHMiLCJjbG8iLCJ4JDIwIiwiY2xvJDAiLCJuJDM4IiwiZSQxMCIsIm4kMzciLCJuJDM2IiwibiQyIiwibiQzNSIsImYkMjAiLCJuJDMiLCJmJDE5IiwibiQzNCIsIm4kNCIsImYkMTgiLCJlJDkiLCJuJDMzIiwibiQ1IiwiZiQxNyIsIm4kMzIiLCJmJDE2IiwieSQwIiwibiQ2IiwiZiQxNSIsIm4kMzEiLCJuJDciLCJmJDE0IiwiZSQ4IiwibiQzMCIsIm4kOCIsImYkMTMiLCJuJDI5IiwibiQ5IiwiZiQxMiIsIm4kMjgiLCJmJDgiLCJlJDIiLCJuJDEwIiwiZiQxMSIsImUkNyIsIm4kMjciLCJmJDkiLCJuJDExIiwiZiQxMCIsIm4kMjYiLCJuJDEyIiwibiQyNSIsIm4kMTMiLCJuJDI0IiwibSQxMiIsIm4kMTQiLCJlJDMiLCJuJDIzIiwiZSQ2IiwibSQxMSIsIm4kMTUiLCJtJDEiLCJuJDIyIiwibSQxMCIsIm0kMiIsIm0kOSIsIm0kMyIsIm4kMTYiLCJtJDgiLCJuJDIxIiwibSQ0IiwiZSQ0IiwibiQxNyIsIm0kNyIsImUkNSIsIm4kMjAiLCJtJDUiLCJuJDE4IiwibSQ2IiwibiQxOSIsImluaXRfbW9kX2Jsb2NrIiwiY29tcHMkMCIsIm1vZHUiLCJzaGFwZSIsImZuJDAiLCJjb21wcyIsImluaXRfbW9kIiwidXBkYXRlX21vZF9ibG9jayIsImNsIiwidXBkYXRlX21vZCIsImluaXRpYWxfYnVmZmVyIiwiYnVmZmVyIiwiYnVmcG9zIiwicmVzZXRfYnVmZmVyIiwic3RvcmUiLCJuZXdidWZmZXIiLCJnZXRfc3RyaW5nIiwibWFrZV9sZXhlciIsImtleXdvcmRzIiwia3dkX3RhYmxlIiwiaWRlbnRfb3Jfa2V5d29yZCIsImtleXdvcmRfb3JfZXJyb3IiLCJuZXh0X3Rva2VuIiwiZXNjYXBlIiwiY29tbWVudCIsIm51bWJlciIsImlkZW50MiIsImV4cG9uZW50X3BhcnQiLCJlbmRfZXhwb25lbnRfcGFydCIsImMzIiwiaGtleSIsImNsZWFuIiwiZG9fYnVja2V0IiwiaW5zZXJ0X2J1Y2tldCIsImNvbnRhaW5lciIsInJlbW92ZV9idWNrZXQiLCJoayIsIm5ld19kIiwiYnVja2V0X2xlbmd0aF9hbGl2ZSIsInN0YXRzX2FsaXZlIiwiZ2V0X2RhdGFfY29weSIsInNldF9kYXRhIiwidW5zZXRfZGF0YSIsImNoZWNrX2RhdGEiLCJibGl0X2RhdGEiLCJlcGgiLCJxdWVyeSIsInNldF9rZXlfZGF0YSIsIm1ha2UkMCIsInRlc3Rfa2V5IiwidCQwIiwiZ2V0X2tleTEiLCJnZXRfa2V5MV9jb3B5Iiwic2V0X2tleTEiLCJ1bnNldF9rZXkxIiwiY2hlY2tfa2V5MSIsImdldF9rZXkyIiwiZ2V0X2tleTJfY29weSIsInNldF9rZXkyIiwidW5zZXRfa2V5MiIsImNoZWNrX2tleTIiLCJibGl0X2tleTEiLCJibGl0X2tleTIiLCJibGl0X2tleTEyIiwiZ2V0X2RhdGEkMCIsImdldF9kYXRhX2NvcHkkMCIsInNldF9kYXRhJDAiLCJ1bnNldF9kYXRhJDAiLCJjaGVja19kYXRhJDAiLCJibGl0X2RhdGEkMCIsIm1ha2UkMSIsImtleTEiLCJrZXkyIiwicXVlcnkkMCIsImsyJDAiLCJrMSQwIiwiZXF1YWwkMCIsIm1ha2UkMiIsImFkZCQwIiwidGVzdF9rZXlzIiwicmVtb3ZlJDAiLCJmaW5kJDAiLCJsZW5ndGgkMCIsImNsZWFyJDAiLCJjcmVhdGUkMSIsImxlbmd0aCQxIiwiZ2V0X2tleSQwIiwiZ2V0X2tleV9jb3B5JDAiLCJzZXRfa2V5JDAiLCJ1bnNldF9rZXkkMCIsImNoZWNrX2tleSQwIiwiYmxpdF9rZXkkMCIsImdldF9kYXRhJDEiLCJnZXRfZGF0YV9jb3B5JDEiLCJzZXRfZGF0YSQxIiwidW5zZXRfZGF0YSQxIiwiY2hlY2tfZGF0YSQxIiwiYmxpdF9kYXRhJDEiLCJtYWtlJDMiLCJxdWVyeSQxIiwia2kiLCJrMCIsIm1ha2UkNCIsImFkZCQxIiwidGVzdF9rZXlzJDAiLCJyZW1vdmUkMSIsImZpbmQkMSIsImxlbmd0aCQyIiwiY2xlYXIkMSIsIm51bGwkMCIsImN1cnJlbnRfZGlyX25hbWUiLCJwYXJlbnRfZGlyX25hbWUiLCJkaXJfc2VwIiwicXVvdGVxdW90ZSIsIm51bGwkMSIsImN1cnJlbnRfZGlyX25hbWUkMCIsInBhcmVudF9kaXJfbmFtZSQwIiwiZGlyX3NlcCQwIiwibnVsbCQyIiwiY3VycmVudF9kaXJfbmFtZSQxIiwicGFyZW50X2Rpcl9uYW1lJDEiLCJkaXJfc2VwJDEiLCJnZW5lcmljX2Jhc2VuYW1lIiwiaXNfZGlyX3NlcCIsImdlbmVyaWNfZGlybmFtZSIsImlzX3JlbGF0aXZlIiwiaXNfaW1wbGljaXQiLCJjaGVja19zdWZmaXgiLCJzdWZmIiwiY2hvcF9zdWZmaXhfb3B0IiwibGVuX2YiLCJ0ZW1wX2Rpcl9uYW1lIiwicXVvdGUiLCJxdW90ZV9jb21tYW5kIiwiYmFzZW5hbWUiLCJkaXJuYW1lIiwiaXNfZGlyX3NlcCQwIiwiaXNfcmVsYXRpdmUkMCIsImlzX2ltcGxpY2l0JDAiLCJjaGVja19zdWZmaXgkMCIsImNob3Bfc3VmZml4X29wdCQwIiwidGVtcF9kaXJfbmFtZSQwIiwicXVvdGUkMCIsImxvb3AkMCIsImxvb3BfYnMiLCJhZGRfYnMiLCJxdW90ZV9jbWRfZmlsZW5hbWUiLCJxdW90ZV9jb21tYW5kJDAiLCJkcml2ZV9hbmRfcGF0aCIsImRpcm5hbWUkMCIsInBhdGgiLCJkcml2ZSIsImRpciIsImJhc2VuYW1lJDAiLCJiYXNlbmFtZSQxIiwiZGlybmFtZSQxIiwibnVsbCQzIiwiY3VycmVudF9kaXJfbmFtZSQyIiwicGFyZW50X2Rpcl9uYW1lJDIiLCJkaXJfc2VwJDIiLCJpc19kaXJfc2VwJDEiLCJpc19yZWxhdGl2ZSQxIiwiaXNfaW1wbGljaXQkMSIsImNoZWNrX3N1ZmZpeCQxIiwiY2hvcF9zdWZmaXhfb3B0JDEiLCJ0ZW1wX2Rpcl9uYW1lJDEiLCJxdW90ZSQxIiwicXVvdGVfY29tbWFuZCQxIiwiYmFzZW5hbWUkMiIsImRpcm5hbWUkMiIsImNob3Bfc3VmZml4IiwiZXh0ZW5zaW9uX2xlbiIsImkwIiwiZXh0ZW5zaW9uIiwiY2hvcF9leHRlbnNpb24iLCJyZW1vdmVfZXh0ZW5zaW9uIiwidGVtcF9maWxlX25hbWUiLCJ0ZW1wX2RpciIsInJuZCIsImN1cnJlbnRfdGVtcF9kaXJfbmFtZSIsInNldF90ZW1wX2Rpcl9uYW1lIiwiZ2V0X3RlbXBfZGlyX25hbWUiLCJ0ZW1wX2ZpbGUiLCJvcGVuX3RlbXBfZmlsZSIsInN0aCQwIiwicGVybXMiLCJzdGgkMSIsIm5lZyIsImNvbmoiLCJtdWwiLCJkaXYiLCJpbnYiLCJub3JtMiIsIm5vcm0iLCJxJDAiLCJwb2xhciIsInNxcnQiLCJ3JDAiLCJleHAiLCJsb2ciLCJwb3ciLCJraW5kX3NpemVfaW5fYnl0ZXMiLCJjbG9vcCIsImlkeCIsImNvbCIsImZsb29wIiwibGF5b3V0IiwiZGltcyIsInNpemVfaW5fYnl0ZXMiLCJzaXplX2luX2J5dGVzJDAiLCJvZl92YWx1ZSIsImRpbSIsInNpemVfaW5fYnl0ZXMkMSIsInNsaWNlIiwiaW5pdCQwIiwib2ZfYXJyYXkiLCJiYSIsImRpbTEiLCJkaW0yIiwic2l6ZV9pbl9ieXRlcyQyIiwic2xpY2VfbGVmdCIsInNsaWNlX3JpZ2h0IiwiaW5pdCQxIiwib2ZfYXJyYXkkMCIsInJvdyIsImNyZWF0ZSQyIiwiZGltMyIsInNpemVfaW5fYnl0ZXMkMyIsInNsaWNlX2xlZnRfMSIsInNsaWNlX3JpZ2h0XzEiLCJzbGljZV9sZWZ0XzIiLCJzbGljZV9yaWdodF8yIiwiaW5pdCQyIiwib2ZfYXJyYXkkMSIsImFycmF5MF9vZl9nZW5hcnJheSIsImFycmF5MV9vZl9nZW5hcnJheSIsImFycmF5Ml9vZl9nZW5hcnJheSIsImFycmF5M19vZl9nZW5hcnJheSIsInJlc2hhcGVfMCIsInJlc2hhcGVfMSIsInJlc2hhcGVfMiIsInJlc2hhcGVfMyIsIm9wZW5fYmluIiwib3Blbl90ZXh0Iiwib3Blbl9nZW4iLCJ3aXRoX29wZW4iLCJvcGVuZnVuIiwid2l0aF9vcGVuX2JpbiIsIndpdGhfb3Blbl90ZXh0Iiwid2l0aF9vcGVuX2dlbiIsInNlZWsiLCJjbG9zZSIsImNsb3NlX25vZXJyIiwicmVhZF91cHRvIiwiZW5zdXJlIiwibmV3X2xlbiQwIiwibmV3X2xlbiQxIiwiaW5wdXRfYWxsIiwiY2h1bmtfc2l6ZSIsImluaXRpYWxfc2l6ZSQwIiwiaW5pdGlhbF9zaXplJDEiLCJucmVhZCIsImJ1ZiQyIiwiYnVmJDAiLCJidWYkMSIsInJlbSIsInNldF9iaW5hcnlfbW9kZSIsInplcm8iLCJ1bml0IiwiaWQiLCJ2YWxpZF9jYW52YXNfc2l6ZSIsImhlaWdodCIsIndpZHRoIiwiYWRkIiwieTIiLCJ4MiIsInkxIiwieDEiLCJzdWIiLCJtdWwiLCJrIiwieSIsIngiLCJkb3QiLCJub3JtIiwiY3JlYXRlIiwiZiIsImUiLCJkIiwiYyIsImIiLCJhIiwibXVsJDAiLCJ0MSIsInQyIiwidHJhbnNsYXRlIiwidCIsInNjYWxlIiwic2hlYXIiLCJyb3RhdGUiLCJjb3NfYSIsInNpbl9hIiwiaW52ZXJzZSIsImRldCIsImludmRldCIsIm9mX2ludHMiLCJzdWIkMCIsInRyYW5zbGF0ZSQwIiwicm90YXRlJDAiLCJ0aGV0YSIsImN5IiwiY3giLCJ0cmFuc2Zvcm0iLCJiYXJ5Y2VudGVyIiwic3VtX2FiIiwiZGlzdGFuY2UiLCJjbGlwXzgiLCJpIiwib2ZfcmdiIiwiciIsImciLCJ0b19yZ2IiLCJvZl9hcmdiIiwidG9fYXJnYiIsIm9mX2ludCIsInRvX2ludCIsIm9mX2ludDMyIiwidG9faW50MzIiLCJjb2xvcnMiLCJkZWZpbmVfY29sb3IiLCJuYW1lIiwidHJhbnNwQmxhY2siLCJ0cmFuc3BXaGl0ZSIsImJsYWNrIiwid2hpdGUiLCJibHVlIiwiY3lhbiIsImdyZWVuIiwibGltZSIsIm9yYW5nZSIsInBpbmsiLCJyZWQiLCJvZl9zdHJpbmciLCJzIiwicyQwIiwibGlzdCIsImFkZF9pbWFnZV9kYXRhIiwiZXZlbnQiLCJzZW5kX2V2ZW50IiwiYWRkX2NhbnZhcyIsImNyZWF0ZSQwIiwiY3JlYXRlRnJvbVBORyIsImZpbGVuYW1lIiwiaW1wb3J0UE5HIiwicG9zIiwib2ZfYmlnYXJyYXkiLCJiYSIsImNyZWF0ZU9mZnNjcmVlbkZyb21QTkciLCJpbXBvcnRQTkckMCIsInNlbmRfZnJhbWUiLCJmcmFtZSIsInNlbmRfZm9jdXNfaW4iLCJmb2N1c19pbiIsInNlbmRfZm9jdXNfb3V0IiwiZm9jdXNfb3V0Iiwic2VuZF9yZXNpemUiLCJyZXNpemUiLCJzZW5kX21vdmUiLCJtb3ZlIiwic2VuZF9jbG9zZSIsImNsb3NlIiwic2VuZF9rZXlfZG93biIsImtleV9kb3duIiwic2VuZF9rZXlfdXAiLCJrZXlfdXAiLCJzZW5kX2J1dHRvbl9kb3duIiwiYnV0dG9uX2Rvd24iLCJzZW5kX2J1dHRvbl91cCIsImJ1dHRvbl91cCIsInNlbmRfbW91c2VfbW92ZSIsIm1vdXNlX21vdmUiLCJzZXRfZXZlbnRfdGltZXN0YW1wIiwiZXZlbnRfdGltZXN0YW1wIiwicnVuIiwiaCIsInRpbWVzdGFtcCIsImNhbnZhcyIsImUkMCIsInRpbWVzdGFtcCQwIiwiY2FudmFzJDAiLCJlJDEiLCJlJDIiLCJzaXplIiwidGltZXN0YW1wJDEiLCJjYW52YXMkMSIsImUkMyIsInBvc2l0aW9uIiwidGltZXN0YW1wJDIiLCJjYW52YXMkMiIsImUkNCIsInRpbWVzdGFtcCQzIiwiY2FudmFzJDMiLCJlJDUiLCJmbGFncyIsImNoYXIkMCIsImtleSIsInRpbWVzdGFtcCQ0IiwiY2FudmFzJDQiLCJlJDYiLCJlJDciLCJidXR0b24iLCJwb3NpdGlvbiQwIiwidGltZXN0YW1wJDUiLCJjYW52YXMkNSIsImUkOCIsImUkOSIsInBvc2l0aW9uJDEiLCJ0aW1lc3RhbXAkNiIsImNhbnZhcyQ2IiwiZSQxMCIsImwiLCJzZW5kX2V2ZW50JDAiLCJldmVudCQwIiwiZXZlbnRzIiwicmV0YWluX2V2ZW50IiwiZSIsImNsZWFyX2V2ZW50cyIsImMiLCJpbWciLCJpbWdfYmEiLCJvYyIsImZtdCIsImkiLCJqIiwiYiIsImciLCJyIiwic2VwIiwia2V5IiwieSIsIngiXSwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29yay9vY2FtbC1jYW52YXMvb2NhbWwtY2FudmFzL19idWlsZC9kZWZhdWx0L3NyYy9pbXBsZW0vZXZlbnQuanMiLCIvaG9tZS9ydW5uZXIvd29yay9vY2FtbC1jYW52YXMvb2NhbWwtY2FudmFzL19idWlsZC9kZWZhdWx0L3NyYy9zdHVicy9tbF90YWdzLmpzIiwiL2J1aWx0aW4vK21sQnl0ZXMuanMiLCIvYnVpbHRpbi8rYmlnYXJyYXkuanMiLCIvYnVpbHRpbi8rbWFyc2hhbC5qcyIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWNhbnZhcy9vY2FtbC1jYW52YXMvX2J1aWxkL2RlZmF1bHQvc3JjL3N0dWJzL21sX2NvbnZlcnQuanMiLCIvYnVpbHRpbi8rdW5peC5qcyIsIi9idWlsdGluLytzdGRsaWIuanMiLCIvYnVpbHRpbi8rc3lzLmpzIiwiL2J1aWx0aW4vK2JhY2t0cmFjZS5qcyIsIi9idWlsdGluLytqc2xpYi5qcyIsIi9idWlsdGluLytmYWlsLmpzIiwiL2J1aWx0aW4vK2ZzLmpzIiwiL2J1aWx0aW4vK2ZzX2Zha2UuanMiLCIvYnVpbHRpbi8raW50NjQuanMiLCIvYnVpbHRpbi8rc3luYy5qcyIsIi9idWlsdGluLytuYXQuanMiLCIvYnVpbHRpbi8rZnNfbm9kZS5qcyIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWNhbnZhcy9vY2FtbC1jYW52YXMvX2J1aWxkL2RlZmF1bHQvc3JjL3N0dWJzL21sX2NhbnZhcy5qcyIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWNhbnZhcy9vY2FtbC1jYW52YXMvX2J1aWxkL2RlZmF1bHQvc3JjL2ltcGxlbS90cmFuc2xhdGUuanMiLCIvYnVpbHRpbi8rYmlnc3RyaW5nLmpzIiwiL2J1aWx0aW4vK21kNS5qcyIsIi9idWlsdGluLytpZWVlXzc1NC5qcyIsIi9idWlsdGluLytvYmouanMiLCIvYnVpbHRpbi8rZWZmZWN0LmpzIiwiL2J1aWx0aW4vK2FycmF5LmpzIiwiL2J1aWx0aW4vK2RvbWFpbi5qcyIsIi9idWlsdGluLytpbnRzLmpzIiwiL2J1aWx0aW4vK2hhc2guanMiLCIvYnVpbHRpbi8raW8uanMiLCIvYnVpbHRpbi8rY29tcGFyZS5qcyIsIi9idWlsdGluLytydW50aW1lX2V2ZW50cy5qcyIsIi9idWlsdGluLyt6c3RkLmpzIiwiL2J1aWx0aW4vK3dlYWsuanMiLCIvYnVpbHRpbi8rZ2MuanMiLCIvYnVpbHRpbi8rZm9ybWF0LmpzIiwiL2J1aWx0aW4vK2dyYXBoaWNzLmpzIiwiL2J1aWx0aW4vK2pzbGliX2pzX29mX29jYW1sLmpzIiwiL2J1aWx0aW4vK2xleGluZy5qcyIsIi9idWlsdGluLytwcm5nLmpzIiwiL2J1aWx0aW4vK3BhcnNpbmcuanMiLCIvYnVpbHRpbi8rc3RyLmpzIiwiL2hvbWUvcnVubmVyL3dvcmsvb2NhbWwtY2FudmFzL29jYW1sLWNhbnZhcy9fb3BhbS9saWIvb2NhbWwvY2FtbGludGVybmFsRm9ybWF0QmFzaWNzLm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvb2NhbWwtY2FudmFzL29jYW1sLWNhbnZhcy9fb3BhbS9saWIvb2NhbWwvY2FtbGludGVybmFsQXRvbWljLm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvb2NhbWwtY2FudmFzL29jYW1sLWNhbnZhcy9fb3BhbS9saWIvb2NhbWwvc3RkbGliLm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvb2NhbWwtY2FudmFzL29jYW1sLWNhbnZhcy9fb3BhbS9saWIvb2NhbWwvcGVydmFzaXZlcy5tbCIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWNhbnZhcy9vY2FtbC1jYW52YXMvX29wYW0vbGliL29jYW1sL2VpdGhlci5tbCIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWNhbnZhcy9vY2FtbC1jYW52YXMvX29wYW0vbGliL29jYW1sL29iai5tbCIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWNhbnZhcy9vY2FtbC1jYW52YXMvX29wYW0vbGliL29jYW1sL2NhbWxpbnRlcm5hbExhenkubWwiLCIvaG9tZS9ydW5uZXIvd29yay9vY2FtbC1jYW52YXMvb2NhbWwtY2FudmFzL19vcGFtL2xpYi9vY2FtbC9sYXp5Lm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvb2NhbWwtY2FudmFzL29jYW1sLWNhbnZhcy9fb3BhbS9saWIvb2NhbWwvc2VxLm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvb2NhbWwtY2FudmFzL29jYW1sLWNhbnZhcy9fb3BhbS9saWIvb2NhbWwvb3B0aW9uLm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvb2NhbWwtY2FudmFzL29jYW1sLWNhbnZhcy9fb3BhbS9saWIvb2NhbWwvcmVzdWx0Lm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvb2NhbWwtY2FudmFzL29jYW1sLWNhbnZhcy9fb3BhbS9saWIvb2NhbWwvYm9vbC5tbCIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWNhbnZhcy9vY2FtbC1jYW52YXMvX29wYW0vbGliL29jYW1sL2NoYXIubWwiLCIvaG9tZS9ydW5uZXIvd29yay9vY2FtbC1jYW52YXMvb2NhbWwtY2FudmFzL19vcGFtL2xpYi9vY2FtbC91Y2hhci5tbCIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWNhbnZhcy9vY2FtbC1jYW52YXMvX29wYW0vbGliL29jYW1sL2xpc3QubWwiLCIvaG9tZS9ydW5uZXIvd29yay9vY2FtbC1jYW52YXMvb2NhbWwtY2FudmFzL19vcGFtL2xpYi9vY2FtbC9pbnQubWwiLCIvaG9tZS9ydW5uZXIvd29yay9vY2FtbC1jYW52YXMvb2NhbWwtY2FudmFzL19vcGFtL2xpYi9vY2FtbC9ieXRlcy5tbCIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWNhbnZhcy9vY2FtbC1jYW52YXMvX29wYW0vbGliL29jYW1sL3N0cmluZy5tbCIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWNhbnZhcy9vY2FtbC1jYW52YXMvX29wYW0vbGliL29jYW1sL3VuaXQubWwiLCIvaG9tZS9ydW5uZXIvd29yay9vY2FtbC1jYW52YXMvb2NhbWwtY2FudmFzL19vcGFtL2xpYi9vY2FtbC9tYXJzaGFsLm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvb2NhbWwtY2FudmFzL29jYW1sLWNhbnZhcy9fb3BhbS9saWIvb2NhbWwvYXJyYXkubWwiLCIvaG9tZS9ydW5uZXIvd29yay9vY2FtbC1jYW52YXMvb2NhbWwtY2FudmFzL19vcGFtL2xpYi9vY2FtbC9mbG9hdC5tbCIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWNhbnZhcy9vY2FtbC1jYW52YXMvX29wYW0vbGliL29jYW1sL2ludDMyLm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvb2NhbWwtY2FudmFzL29jYW1sLWNhbnZhcy9fb3BhbS9saWIvb2NhbWwvaW50NjQubWwiLCIvaG9tZS9ydW5uZXIvd29yay9vY2FtbC1jYW52YXMvb2NhbWwtY2FudmFzL19vcGFtL2xpYi9vY2FtbC9uYXRpdmVpbnQubWwiLCIvaG9tZS9ydW5uZXIvd29yay9vY2FtbC1jYW52YXMvb2NhbWwtY2FudmFzL19vcGFtL2xpYi9vY2FtbC9sZXhpbmcubWwiLCIvaG9tZS9ydW5uZXIvd29yay9vY2FtbC1jYW52YXMvb2NhbWwtY2FudmFzL19vcGFtL2xpYi9vY2FtbC9wYXJzaW5nLm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvb2NhbWwtY2FudmFzL29jYW1sLWNhbnZhcy9fb3BhbS9saWIvb2NhbWwvc2V0Lm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvb2NhbWwtY2FudmFzL29jYW1sLWNhbnZhcy9fb3BhbS9saWIvb2NhbWwvbWFwLm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvb2NhbWwtY2FudmFzL29jYW1sLWNhbnZhcy9fb3BhbS9saWIvb2NhbWwvc3RhY2subWwiLCIvaG9tZS9ydW5uZXIvd29yay9vY2FtbC1jYW52YXMvb2NhbWwtY2FudmFzL19vcGFtL2xpYi9vY2FtbC9xdWV1ZS5tbCIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWNhbnZhcy9vY2FtbC1jYW52YXMvX29wYW0vbGliL29jYW1sL3N0cmVhbS5tbCIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWNhbnZhcy9vY2FtbC1jYW52YXMvX29wYW0vbGliL29jYW1sL2J1ZmZlci5tbCIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWNhbnZhcy9vY2FtbC1jYW52YXMvX29wYW0vbGliL29jYW1sL2NhbWxpbnRlcm5hbEZvcm1hdC5tbCIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWNhbnZhcy9vY2FtbC1jYW52YXMvX29wYW0vbGliL29jYW1sL3ByaW50Zi5tbCIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWNhbnZhcy9vY2FtbC1jYW52YXMvX29wYW0vbGliL29jYW1sL2FyZy5tbCIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWNhbnZhcy9vY2FtbC1jYW52YXMvX29wYW0vbGliL29jYW1sL3ByaW50ZXhjLm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvb2NhbWwtY2FudmFzL29jYW1sLWNhbnZhcy9fb3BhbS9saWIvb2NhbWwvZnVuLm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvb2NhbWwtY2FudmFzL29jYW1sLWNhbnZhcy9fb3BhbS9saWIvb2NhbWwvZ2MubWwiLCIvaG9tZS9ydW5uZXIvd29yay9vY2FtbC1jYW52YXMvb2NhbWwtY2FudmFzL19vcGFtL2xpYi9vY2FtbC9kaWdlc3QubWwiLCIvaG9tZS9ydW5uZXIvd29yay9vY2FtbC1jYW52YXMvb2NhbWwtY2FudmFzL19vcGFtL2xpYi9vY2FtbC9yYW5kb20ubWwiLCIvaG9tZS9ydW5uZXIvd29yay9vY2FtbC1jYW52YXMvb2NhbWwtY2FudmFzL19vcGFtL2xpYi9vY2FtbC9oYXNodGJsLm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvb2NhbWwtY2FudmFzL29jYW1sLWNhbnZhcy9fb3BhbS9saWIvb2NhbWwvd2Vhay5tbCIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWNhbnZhcy9vY2FtbC1jYW52YXMvX29wYW0vbGliL29jYW1sL2Zvcm1hdC5tbCIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWNhbnZhcy9vY2FtbC1jYW52YXMvX29wYW0vbGliL29jYW1sL3NjYW5mLm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvb2NhbWwtY2FudmFzL29jYW1sLWNhbnZhcy9fb3BhbS9saWIvb2NhbWwvY2FsbGJhY2subWwiLCIvaG9tZS9ydW5uZXIvd29yay9vY2FtbC1jYW52YXMvb2NhbWwtY2FudmFzL19vcGFtL2xpYi9vY2FtbC9jYW1saW50ZXJuYWxPTy5tbCIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWNhbnZhcy9vY2FtbC1jYW52YXMvX29wYW0vbGliL29jYW1sL2NhbWxpbnRlcm5hbE1vZC5tbCIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWNhbnZhcy9vY2FtbC1jYW52YXMvX29wYW0vbGliL29jYW1sL2dlbmxleC5tbCIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWNhbnZhcy9vY2FtbC1jYW52YXMvX29wYW0vbGliL29jYW1sL2VwaGVtZXJvbi5tbCIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWNhbnZhcy9vY2FtbC1jYW52YXMvX29wYW0vbGliL29jYW1sL2ZpbGVuYW1lLm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvb2NhbWwtY2FudmFzL29jYW1sLWNhbnZhcy9fb3BhbS9saWIvb2NhbWwvY29tcGxleC5tbCIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWNhbnZhcy9vY2FtbC1jYW52YXMvX29wYW0vbGliL29jYW1sL2JpZ2FycmF5Lm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvb2NhbWwtY2FudmFzL29jYW1sLWNhbnZhcy9fb3BhbS9saWIvb2NhbWwvaW5fY2hhbm5lbC5tbCIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWNhbnZhcy9vY2FtbC1jYW52YXMvX29wYW0vbGliL29jYW1sL291dF9jaGFubmVsLm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvb2NhbWwtY2FudmFzL29jYW1sLWNhbnZhcy9fYnVpbGQvZGVmYXVsdC9zcmMvb2NhbWxDYW52YXMubWwiLCIvaG9tZS9ydW5uZXIvd29yay9vY2FtbC1jYW52YXMvb2NhbWwtY2FudmFzL19idWlsZC9kZWZhdWx0L2V4YW1wbGVzL3BwbV9kdW1wLm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvb2NhbWwtY2FudmFzL29jYW1sLWNhbnZhcy9fb3BhbS9saWIvb2NhbWwvc3RkX2V4aXQubWwiXSwibWFwcGluZ3MiOiI7Ozs7OztBLEM7O0c7OztRO1M7OztHO0k7STtJO0c7RTs7OztHQXVNQTs7SUFBSUE7O0lBVUFDO0lDbENBQztJQVZBQzs7R0M3RkosU0FBU0MseUJBQTBCQyxHQUFHQyxHQUFHQztJQUNqQyxJQUFGQyxJQUFJQztJQUNSLEdBQUlILFVBQVVDLGVBQWVBLE9BQU9GLFVBQVUsT0FBT0csUUFBU0UsTUFBTUw7SUFDOUQsSUFBRk07SUFDSixVQUFXSixLQUFLRCxXQUFVQztLQUN4QkksS0FBS0gsUUFBU0UsTUFBTUwsUUFBUUMsR0FBRUEsSUFBSU0sU0FBU0w7SUFDN0MsT0FBT0k7R0FDVDtHQW1vQkEsU0FBU0UsdUJBQXVCQyxHQUFLLE9BQU9BLEVBQUU7R0F6TjlDLFNBQVNDLHFCQUFzQlY7SUFDN0IsT0FBT1EsdUJBQXVCVCx5QkFBeUJDLE1BQUlBO0dBQzdEO0dDbEZBLFNBQVNXLGNBQWNDLElBQUlDLElBQ3pCLE9BQU9ELE9BQU9BLFVBQVVDLEtBQzFCO0dDbFNBLFNBQVNDLGdCQUFpQkMsSUFBSWQsR0FBS2UsU0FBU0QsSUFBSUMsU0FBU2YsRUFBRztHQUM1RGE7d0JBQ3VCLE9BQU9ILGNBQWNLLFFBQU9BLFVBQTFDO3dCQUNjLE9BQU9MLGNBQWNLLFFBQU9BLHNCQUExQzs7O01BRUwsSUFBSVYsSUFBSVUsUUFBUWYsSUFBSWU7TUFDcEJBLFNBQVNmO01BQ1QsT0FBUVUsY0FBY0wsR0FBRUwsVUFBV1UsY0FB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V0FDOztRQXFCQTMxRTtRQWVBNjFFOztRQUxBRDtRQVJBOWdGO1FBQ0FFO1FBWUE2Z0Y7O1FBU0FueEI7UUE0QkF1eEI7O1FBZEFGO1FBSUFDO1FBZUFFOztRQWFBbkk7UUF3Q0EwSTs7UUF4QkFIO1FBUUFDO1FBQ0FDO1FBb0JBRTs7UUFzQkFFO1FBZ0RBTzs7UUE5QkFMO1FBUUFDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBd0JBRTtPQWtDRkM7T0FHQUM7T0FHQUM7T0FHQUM7O09BT0FDO09BQ0FDO09BQ0FDO09BQ0FDOzs7RTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0c7Ozs7O0k7Rzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0c7OztNLDRCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsyQjtNLFc7Szs7O0ksSSxXLG9COzs7O0s7Ozs7TTtLO0s7SztLOztNO007TTs7SztLLFc7SztLLE87O0c7Ozs7Ozs7Ozs7STtLLE87SSxPO0c7O0k7SyxPO0ksTztHOztJO0ssTztJLE87Rzs7SSxpQjtHOztJLHdCO0c7O0k7SSxPOztHOztJLFc7SSxPO0c7NEIsTyw2Qjs2QiwrQztHO0ksZ0I7SSxxQjtJLGlCO0ksc0I7Ozs7Ozs7Ozs7Ozs7Ozs7SSxtQjs7STtHOztJO0ssTztJLE87Rzs7STtLLE87SSxPO0c7O0k7SyxPO0ksTztHOztJO0ssTztJLE87Rzs7SSxnQjtHOztJO2lCO0c7Z0MsMkM7O0k7Rzs7STtHOztJO0c7O0k7Rzs7STtHOztJO0c7O0k7RztpQyx5Qzs7STtLO00sTztNLE87Szs7Ozs7SyxJLHVCO0s7OztROzs7Ozs7OztRO087O0s7OztTLHFCO1M7VSx1QjtVOzs7Ozs7VTtXOzswQjtXOzs7O2tDOzs7O1E7TTs7Ozs7Ozs7Ozs7O007TztPO2U7SztNOztXOzs7O21CO007UTs7O1c7VyxPOzs7cUI7cUI7b0I7O1U7O0ssTzs7Rzs7SSxJLFcsc0M7Ozs7d0M7O0s7TSxHO08sTTtNLEksTzs7Ozs7TSxHO08sTTtxQjs7SztNLEc7TyxNO007TyxPO08sTzs7Ozs7O29COztLOztHOztJO0ssSSxXLDhCOzs7Ozs7Ozs7Rzs7STs7Tzs7STtHOzs7STs7SyxPOzs7ZSxJLFcsd0I7OzsyQzs7O2M7O0k7STtLO0s7b0I7TSxXOzs7O0k7STs7OztLO0ksTzs7OztjLE87YTtHOztJO0c7OztJOztHO0c7SSxrQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0k7SSxPO0c7O0k7SyxROzs7SyxTO0ksSTs7O0s7SztLLE07O0k7STtHOztJO0ssUTs7O0ssVTtJLEk7OztLO0s7SyxNOztJO0k7Rzs7STtLLFE7OztJLEksYzs7O0s7SztLLE07O0k7OztLLFM7SyxVO0k7Szs7Ozs7SztLO0s7SztLLE07O0k7STtJO0c7O0k7SyxROzs7SSxJLGM7OztLO0s7SyxNOzs7SSxJLGM7OztLO0s7SztLO0ssTTs7STs7O0ssUztLLFU7SyxVO0k7Szs7Ozs7Ozs7Ozs7SztLO0s7SztLO0s7SyxNOztJO0k7STtJO0c7O0ksTztHOztJO0c7O0k7Rzs7STtHOztJO0c7O0k7SyxXO0s7Ozs7O00sTTs7OztHOztJLE87Rzs7STtHOztJO0c7OztJOzs7O0k7OztJLEksb0I7STtJO0k7Rzs7SSxJLHFCO0k7SSxJOzs7OztJO0c7O0k7OztLO0s7STtJO0ksSTs7Ozs7STs7O0k7Ozs7SztLO0k7STtJLEk7Ozs7O0k7STs7O0ksVztJO0s7SztNLE87TSxXO0s7Ozs7SztLLE07O0c7O0ksTyxzQjtHOztJLFc7O0k7STs7SztNLEksWTs7Ozs7Ozs7O0ssa0IsSzs7ZSxzQjtNO007TyxTO08sVTtNO007O1UsdUI7O0c7Ozs7O3NCOztzQjtzQjs7OzRCOzRCOztROzs0Qjs7UTs7c0I7c0I7NEI7O3NCO3NCO3NCO3NCOzs7O2tDO3NCO3NCOzs7Ozs7c0I7c0I7Ozs7UTs7NEI7NEI7OztzQjs7OztTOzs2Qjs2Qjs7O3VCOzs7NEI7a0M7c0I7NEI7NEI7O1E7OztROztzQjs0Qjs0QjtrQztzQjtzQjtzQjtzQjs7O3NCO3NCO3NCOzs7Ozs0Qjs0Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7UTs7O1E7OzRCOzRCO3NCO3NCOztzQjtzQjs7OztzQjs7c0I7c0I7O1E7O3NCOzRCOztzQjtzQjtzQjtzQjtzQjtzQjtzQjs0QjtzQjtzQjtzQjs7c0I7c0I7c0I7Ozs7Ozs7UTs7OztROzswQjswQjswQjswQjswQjtxQjtxQjs7Ozs7Ozs7Ozs7Ozs7Ozs7OztxQjtxQjtxQjtxQjtxQjswQjswQjs7O3FCOytCOzBCO3FCOzBCOzBCO3FCOzs7RTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0U7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7eUIsVyxxQzs7SSxPOzs7RztzQixPLG9DOztJLFE7STtJLE87Rzs7SSxXOztLLFU7Szs7O0k7OztHOztJOztJLE87Rzs7SSxJLHVDOzs7O00sWTs2QztNOzs7Ozs7Rzs7SSxJLHFCOzs7a0I7OztHOztJO0k7SztNOztNO007a0I7Ozs7O0s7OztHO0csK0I7NEIsb0IsdUI7O0ksaUI7OztJO0ksSTtJOztLLDZCLG1CO2lCOzs7Ozs7TTs7OztVOztHOztJLG1DOzs7O00sWTs7TTs7Ozs7O0c7MkIsK0I7Z0MsbUI7O0k7OzthLFk7OztHOztJOztJO0s7TTs7Uzt5QyxPLGtCOzs7UTtNOztTO3lDLE8sa0I7OztRO00scUIscUM7Szs7Ozs7O1E7O1M7UztTO1U7VSxXO1U7VTs7O1U7Ozs7Ozs7O2tCLFMsUzs7O007O0s7Szs7O0ssd0MsbUI7SztvQyxPLHNCO0s7Szs7O0c7O0k7Ozs7Ozs7Ozs7USxpQjs7Ozs7Ozs7OztHOzt1QixTO2dDLFM7O0k7Rzs7STtJOzs7OztPLFk7Ozs7UztTLE07Ozs7Ozs7Ozs7Ozs0Qjs7O0c7O0k7STs7Ozs7WTtRO1EsTTs7Ozs7OztLO0s7Ozs7NEI7OztHOztJLDZCLG1CO0c7MEIsNkI7O0k7STs7Ozs7SSxnQjs7O0k7Ozs7O007OztPOzs7OztVLEc7VyxNOzs7Ozs7USxJOzs7Ozs7O087USxZOzs7UTtROzs7Ozs7Ozs7aUI7Ozs7Ozs7Ozs7RztHO0k7Ozt5QiwrQjs7STs7Ozs7OztHOztJLEksZ0I7O0c7O0ksYzs7O0k7aUI7Ozs7OztTLDJEO1M7UTs7O0c7O0k7O0ssTTs7STtHO3VCLG1DOzJCLGtCLGM7O0k7O0ksa0I7OztHOztJOztLLE07O0k7RzsyQixrQzs7STs7SSx3QjtrQiwrQjtJO0c7O0k7OztJLEcsMEI7Ozs7Rzs7STs7O0c7Ozs7Ozs7STtJOzs7YTtjOztjO2M7Ozs7Yzs7OztjO2E7O0c7O0k7OztJO0c7O0ksWTs7STs7O0k7OztpQjtJO0c7O0k7STtrQjthO0s7O007MEIsb0I7OztTO1M7UztRO0s7Szs7O0ksUTtJLGdCO3dCLGtDOztLO2lCOztLLGE7SztJO0k7STtJO0c7O0ksWTtJLGtCO3NCLG9COztLO0s7O0k7STtJO0c7O0ksWTtJLGtCO3NCLG9COzttQixrQztLO0k7STtJO0c7O0ksWTs7SSxTO0ksZ0I7c0IsZ0M7O0s7OztNLGU7O0s7STtJO0k7STs7O0ksWTtJLGtCO3NCLG9CO2tCLGUsa0M7STtJOzs7SSxRO0ksYztzQixvQjtrQiwwQjtJO0k7Rzs7SSxZO0ksa0I7c0Isb0I7O0s7SyxPO0k7STtJOzs7SSxZO0ksa0I7c0Isb0I7O0ssWTtpQjs7SztJO0k7STs7O0ksWTtJLGtCLHlCO3NCLG9COztLLEksZTs7OztNLGU7Ozs7STtJO0k7OztJO0ksWTtJLGtCLHlCO3NCLG9COztLLEksZTs7OztNLE87OztLO0k7STtJOzs7SSxROztJO0ksZTtzQixnQzs7SztJO0k7STtJOzs7SSxROztJLFE7SSxlO3NCLGdDO2tCLGlEO0k7STtJOzs7SSxROztJLFE7SSxlO3NCLGdDOztLOzs7Ozs7STtJO0k7STs7O0ksUztJLGUseUI7c0Isb0I7O0s7YztLO0k7STtJO0c7O0ksWTtJLGtCLHlCO3NCLG9COztLO2M7SztJO0k7STs7c0IsNkI7O0k7OztNO00sVzs7OztNOzs7TztPOzs7Ozs7O0c7O0k7Szs7O0s7O0ssTyx3QyxZO0k7O0s7TTs7d0I7TTs7Ozs7TyxNOzs7STtJO3FDLDRCO0k7Rzs7STtLOzs7Szs7SyxPLHdDLFk7STs7Szs7a0I7O007TyxZOzs7Ozs7STtJO3FDLDRCO0k7Rzs7SSxZOztJO0ksSSxlOztLO2lCOztLO0k7O0s7Ozs7TyxNOztNOztLLGtCO3FDOzthLHlCLDJCOztLO0s7SztNO007OzttQjs7SztJOzBCO0k7STs7O0k7SztLOzs7eUIsUzs7VSxNO1M7SyxPOzttQzs7bUM7c0IsUzs7Szs7O0ssMEI7O0k7STtJO0k7Rzs7SSxTO2E7SSw0QiwwQjtzQixpQzs7Szs7O00sZTs7SztJO0k7STtJO0c7O0ksUzthO2E7STs7OztLO0s7SztzQiw2Qzs7Szs7O00sZTs7SztJO0k7STtJO0k7Rzs7SSxTO2E7YTthO0k7Ozs7O0s7SztLOztLO0k7O0s7OztNLGU7O0s7STtJO0k7STtJO0k7Rzs7SSxTO2E7YTthO2E7STs7Ozs7O0s7SztLO0s7O0s7STs7Szs7Ozs7Ozs7Ozs7OztNLGU7O0s7STtJO0k7STtJO0k7STtHOztJLFM7YTthO2E7YTthO0k7Ozs7Ozs7SztLO0s7Szs7Szs7O0k7O0s7Ozs7Ozs7Ozs7Ozs7OztNLGU7O0s7STtJO0k7STtJO0k7STtJO0c7b0IsdUIsYyxNOztJLGdCLHdCLFM7Ozs7Szs7ZSxZOztlO2M7Ozs7SSxRO0ksYztzQixnQzs7SztnQjs7aUI7O0s7STtJO0k7STtHO0c7STs7OztJOzs7dUMsUztJLHdCO2tCLHVCLE87O0s7O0s7SztLO0ssTztJO0k7Rzt1QixjOztJO0k7O0k7OzthO2EsRywyQjs7Yzs7O2M7Yzs7OztjOzs7O2M7Ozs7Rzs7STs7O0k7Rzs7SSxtQjs7STtHOztJOzs7O2dCLE87OztJO0c7O0ksbUI7OztJLHdCOztLLE07MkIsMEI7STs7O0k7STs7b0MsTzs7Ozs7O0k7Rzs7STtJO2tCO2tDLGtCO0s7O007TTtNLG9CLG9COzs7UztTO1M7UTtLO0s7OztJO0s7O007NEIscUI7OztTLGE7Uzs7UTtLO0s7O0ksZ0IsZTt3QixrQzs7SyxJLGU7bUMsRyw0QjtLLGE7SztJO0k7STtJO0c7O0k7SSxZO0ksa0I7c0Isb0I7O0s7aUI7O0s7STtJO0k7OztJO0kscUMsVztJLGtCO3NCLG9CO2tCLGUsZ0M7STtJOzs7STtJOztxQjs7SyxXOzs7O0s7O007MEIscUI7c0IsZSxpQztLO0s7O0ksZ0I7d0IsaUM7O0s7SyxlO0k7STtJO0k7Rzs7STtJLDZCLE87SSxjO3NCLG9COztLO0ssTztJO0k7STtHOztJO0k7Szs7TTswQixvQjs7O1MsWTtxQjs7UztRO0s7Szs7SSxrQixRO2dCOztJOzs7SSxtQjtJLGtCLHlCO3NCLG9COztLLEksYTs7TSxNOzs7SyxlO0k7Z0MsaUM7STtJOzs7SSxtQjtJLGtCO3NCLG9CO2tCLGdDO0k7STtHOztJOztLLHdCLE8scUI7OztJLFE7SSxlO3NCLGlDOztLO2lCOztLLGU7STtJO0k7STs7O0k7STs7STtLOztNOzBCLHFCO3NCLHVDO0s7Szs7SSxlO3dCLGlDO29CLGdEO0k7STtJO0c7O0k7SSxROztJO0s7O007MEIscUI7c0IsdUM7SztLOztJLGU7d0IsaUM7b0IsZ0Q7STtJO0k7Rzs7STtJLFM7SSxlO3NCLG9COztLO2lCOztLLGU7STtJO0k7Rzs7STtJLFk7SSxrQjtzQixvQjs7SztpQjs7SyxlO0k7STtJOzs7STtJO0ssbUI7O0s7O0k7SyxtQjs7Szs7SSxtQjtzQixpRDs7SztjOzs7aUI7O2tCLE87OztpQixPOzs7Ozs7STs7SyxtQjs7SztJO0k7STtHOztJO0kscUM7STs7SztLO0s7O0s7d0I7O0s7STs7Szs7O3lCOztNOzs7Z0Q7Szs7O00sb0I7TTtNOzs7Szs7TTtNO007OztLO0s7OztJO0k7STtJOzs7STs7O3dDOzs7Rzs7STs7SztLO21CO0s7SztLO0k7STtLO0s7O29DLFMsbUIsUztLLE87OztLOzs7MEIsUztzQix3QjtNO0s7Szs7O21DO3dCLFM7b0IsZ0M7STtJO0k7STtHOztJO0k7O29DLFc7Szs7TTswQixvQjtzQixlLG1DO0s7Szs7OztLOztNOzRCLHFCO3dCLGUsc0M7SztLOztJLGU7d0IsaUM7O0s7SyxlO0k7STtJO0k7Rzs7STtJOzs7O3NDLFc7Ozs7Ozs7O087O1E7UTtROzRCLDZDOzs7VyxJLGlCO1csZTtVO087TztPO087Ozs7STs7O3dDOzs7OztHOztJO0k7Ozs7Ozs7O1EsVzs7Ozs7Ozs7Ozs7O1E7O1M7UztTOzs7WTtXOzs7WSxJLGlCLGlCO1ksZTtXO1E7UTtRO1E7UTs7Ozs7STs7O3dDOzs7Ozs7Rzs7STtJOzs7Ozs7Ozs7O1MsVzs7Ozs7Ozs7Ozs7Ozs7O1M7O1U7VTtVO1U7OzthOzs7WTs7O2E7YztjO2M7YztjLEk7YTtZO1M7UztTO1M7UztTOzs7Ozs7STs7O3dDOzs7Ozs7O0c7O0k7STs7Ozs7Ozs7Ozs7O1UsVzs7Ozs7Ozs7Ozs7Ozs7Ozs7O1U7O1c7VztXO1c7Vzs7O2M7Ozs7O2E7OztjO2U7ZTtlO2U7ZTtlLEk7YzthO1U7VTtVO1U7VTtVO1U7Ozs7Ozs7STs7O3dDOzs7Ozs7OztHOzZCO2dDO21CLDBDOztJOzs7OztHOztJOzs7OztHO29CLG9COztJLG1CO0ksa0I7c0Isb0I7O0ssVztLO0k7STtJOztvQix5QjtvQix5Qjs7SSxZO0k7O0s7OEM7c0Isb0I7a0Isb0Q7STtJOztnQzs7SSwwQztHOztJLDBDO0c7O0ksMEM7Rzs7STs7a0M7OztHOztJOztrQzs7O0c7O0k7Rzt3QixvRDttQiwwQztHLG9CLGtCLGtCOztJO2dEO0c7O0k7Z0Q7Rzs7STtnRDtHO29CLDBDOztJO2dEO0c7O0k7O2tDOzs7Rzs7STtnRDtHO2dDOztJLDBDO0c7O0k7Z0Q7Rzs7STtnRDtHOztJLDhDO0c7O0ksNkM7Rzs7STs7Z0M7OztHOztJLHlDO0c7O0kseUM7Rzs7SSx5QztHO3FCLHdEOztJLHlDO0c7O0kseUM7Rzs7SSx5QztHOztJLHlDO0c7O0kseUM7Rzs7SSx5QztHOztJOztnQzs7O0c7b0IsdUQ7b0IsdUQ7b0IsdUQ7O0kseUM7Rzs7SSx5QztHOztJLHlDO0c7O0ksNkM7Rzs7STtHOztJO0c7O0k7Rzs7SSx5QztHOztJLHlDO0c7O0kseUM7Rzs7SSx5QztHO0c7O0k7STtJO0k7STtJO0k7STtJO0k7STs7STtvQzs7O0c7O0ksK0IsaUI7Rzt1QiwrQixvQjt1QiwrQixvQjtHLEk7O0k7O0s7O007O1M7O1UsTzs7UyxNO1E7Ozs7SSwrQixjO0c7O0k7STs7aUM7MEQ7O0ssK0I7SyxlO21CO0s7TTswQixxQjs7O1M7Uzs7UTtLO0s7Ozs7Ozs7TSxtQyxTOztLLHVCOztNO087NkIsc0I7OztVO3NCOztVO1M7TTtNOztLO007TSxzQixzQjs7O1M7cUI7O1M7UTtnQyxvQzs7O1M7Uzs7O1U7OztVO1M7UTtLO0s7Szs7Ozs7Szs7O2UsWTs7ZTtjOzs7SSx1Qjt3QixvQzs7SztpQjs7SztJO0k7STtJO0c7Rzs4Qiw4Qzs7STtHOztJO0c7O0k7Rzs7STtHOztJO0c7O0k7Rzs7STs7Z0M7OztHOztJOztnQzs7O0c7Ozt1Qiw0QjsyQixnQzswQiwyQjt5Qiw4Qjt1Qiw0Qjs7SztLLHFCO0k7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Ozs7U0FpR0FxQjtTQVdBQzt3Qjs7VTs7O1U7OztVOzs7O1U7OztVOztTQThCQUU7O1U7O1NBV0FFO3dCOzs7VTs7O1U7Ozs7VTs7O1U7Ozs7VTs7O3dCOztVOzt3Qjs7VTs7O1U7Ozs7VTs7O1U7OztVOzs7O1U7OztVOzs7OEI7O1U7Ozs7Ozs7OEI7d0I7OztVOzs7Ozs7Ozs7Ozs7OztVOzs7VTs7U0EwTEFFO3dCO3dCO3dCO3dCO3dCO3dCOzhCO3dCOztVOzt3Qjt3Qjs7VTs7OEI7OEI7OEI7OEI7OEI7d0I7O1U7O3dCOztVOzt3Qjs7VTs7d0I7O1U7O3dCOztVOzt3Qjs7VTs7d0I7O1U7OztVOzs7VTs7d0I7O1U7O3dCOztVOzs7VTs7O1U7O3dCOztVOzt3Qjs7VTs7O1U7OztVOzt3Qjs7VTs7d0I7O1U7O3dCOztVOzs7VTs7d0I7d0I7OEI7OEI7O1U7OztVOzs7VTs7O1U7OztVOzs7VTs7OzRCOztVOzt1Qjs0Qjs0Qjs7VTs7O1U7OztVOzs7VTs7O1U7OztVOzs0Qjs7VTs7O1U7OztVOztTQThRQUM7NEI7O1NBNE5BRTtTQUVBRTtTQUVBRTtTQUVBRTtTQUVBRTtTQUVBRTtTQUVBRTtTQUVBRTtTQUVBRTtTQUVBRTtTQUVBRTtTQUtBRTt1Qjt1Qjs7dUI7U0FnSEFDO3VCO3VCO3VCOzs7RTs7Ozs7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7Ozs7R0NucENLOzs7Ozs7O0lBQVR3QztZQUVBQyxhQUFhQyxHQUZiRixnQkFFYUUsR0FGYkYscUJBR29CO1lBRXBCRyxvQkFMQUgsd0JBTVU7R0FJWjtHQUVRO0lBQUpJO01BQUk7Ozs7Ozs7Ozs7Ozs7R0FHUixtQ0FISUE7R0FJSixtQ0FKSUE7R0FNSixtQ0FOSUE7R0FPSixtQ0FQSUE7R0FRSixtQ0FSSUE7R0FTSixtQ0FUSUE7R0FVSixtQ0FWSUE7R0FXSixtQ0FYSUE7R0FZSixtQ0FaSUE7R0FhSixtQ0FiSUE7R0FjSixtQ0FkSUE7R0FnQko7O0tBaEJJQTs7Ozs7R0FtQmtCLFVBQUE7R0FBdEIsbUNBbkJJQTtHQW9CSixtQ0FwQklBO0dBcUJKLG1DQXJCSUE7R0FzQkosbUNBdEJJQTtHQXVCSixtQ0F2QklBO0dBd0JKLG1DQXhCSUE7R0F5QkosbUNBekJJQTtHQTJCSixrQ0EzQklBO0dBNkJNO0lBQU5DLE1BQU0sbUNBN0JORDtJQThCQUUsU0FBUyxrQ0FEVEQ7SUFHQUUsS0FBSztJQUNMQyxNQUFNLCtCQURORDtHQUVKOztLQURJQzs7Ozs7Ozs7Ozs7Ozs7SUFHSkM7Ozs7Ozs7Ozs7UUFDRUM7O0tBQ1U7TUFBSkMsSUFBSSxjQVJSTCxRQU1KRyxHQUNFQztNQUVNRSxJQUFJLGNBVFJOLFFBTUpHLEdBQ0VDO01BR01HLElBQUksY0FWUlAsUUFNSkcsR0FDRUM7S0FJVyxjQVhUSixRQU1KRyxHQUNFQztTQUtNSSxhQUxOSjtLQU1FLCtCQVZBRixVQU9JSyxHQURBRCxHQURBRCxHQUlBRztLQUxOLFVBQUFKO2dCQUFBQTtLQUFBQTs7SUFIRixVQUVBRDtlQUFBQTtJQUFBQTs7R0FXQSx1QkFmSUY7R0FpQkosbUNBakRJSCxRQTZCQUM7R0F2Q0ZKO0tBOERBOzt1QkFDSSxPQUFBLHFDQUFlOztHQS9EbkJBO0tBbUVBOzs7UUFBWSxJQUFzQmMsK0JBQUFBO3FCQUU1QjtPQUNIOztHQXRFSGQ7S0F5RUE7OztRQUFZLHlCQUNxQ2UsY0FBSEM7UUFDMUMsbUNBakVGYjtRQWtFRSxtQ0FsRUZBO1FBbUVFOztVQW5FRkE7Y0FnRTRDYSxHQUFHRDs7Ozs7UUFHN0MsT0FBQSxtQ0FuRUZaO09Bc0VDOztHQUVMOzs7TUEvRUVEO01BZ0ZFLE9BQUE7S0FDMkI7K0JBdEY3QkgsUUFFQUMsY0FHQUU7OztFOzs7Ozs7Ozs7Ozs7O0c7Ozs7Ozs7O0dDQUk7R0FBQTs7O0UiLCJzb3VyY2VzQ29udGVudCI6WyIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKiAgICBDb3B5cmlnaHQgMjAyMiBPQ2FtbFBybyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKiAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgICovXG4vKiAgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSBzcGVjaWFsICAgICAgICovXG4vKiAgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICAgICAgICAgICovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8vUHJvdmlkZXM6IFNMQU5UXG52YXIgU0xBTlQgPSB7XG4gIFJPTUFOICAgOiBcIm5vcm1hbFwiLFxuICBJVEFMSUMgIDogXCJpdGFsaWNcIixcbiAgT0JMSVFVRSA6IFwib2JsaXF1ZVwiLFxufTtcblxuLy9Qcm92aWRlczogRk9DVVNcbnZhciBGT0NVUyA9IHtcbiAgT1VUIDogMCxcbiAgSU4gIDogMVxufTtcblxuLy9Qcm92aWRlczogS0VZXG52YXIgS0VZID0ge1xuICBVTkRFRklORUQgOiAweDAzLCAvKiB0byBoYW5kbGUgdHJhbnNsYXRpb24gZXJyb3JzICovXG5cbiAgLyogRnVuY3Rpb24gKi9cbiAgRVNDQVBFIDogMHgyOSxcbiAgRjEgOiAweDNBLFxuICBGMiA6IDB4M0IsXG4gIEYzIDogMHgzQyxcbiAgRjQgOiAweDNELFxuICBGNSA6IDB4M0UsXG4gIEY2IDogMHgzRixcbiAgRjcgOiAweDQwLFxuICBGOCA6IDB4NDEsXG4gIEY5IDogMHg0MixcbiAgRjEwIDogMHg0MyxcbiAgRjExIDogMHg0NCxcbiAgRjEyIDogMHg0NSxcbiAgUFJJTlRTQ1JFRU4gOiAweDQ2LFxuICBTQ1JPTExMT0NLIDogMHg0NyxcbiAgUEFVU0UgOiAweDQ4LFxuXG4gIC8qIEFscGhhbnVtZXJpYywgZmlyc3Qgcm93ICovXG4gIEdSQVZFX1RJTERFIDogMHgzNSwgLyogcG9zc2libHkgWmVua2FrdS9IYW5rYWt1IGtleSBvbiBKYXBhbmVzZSBLQiAqL1xuICBfMV9FWENMQU1BVElPTiA6IDB4MUUsXG4gIF8yX0FUIDogMHgxRixcbiAgXzNfTlVNQkVSIDogMHgyMCxcbiAgXzRfRE9MTEFSIDogMHgyMSxcbiAgXzVfUEVSQ0VOVCA6IDB4MjIsXG4gIF82X0NBUkVUIDogMHgyMyxcbiAgXzdfQU1QRVJTQU5EIDogMHgyNCxcbiAgXzhfQVNURVJJU0sgOiAweDI1LFxuICBfOV9MUEFSRU5USEVTSVMgOiAweDI2LFxuICBfMF9SUEFSRU5USEVTSVMgOiAweDI3LFxuICBNSU5VU19VTkRFUlNDT1JFIDogMHgyRCxcbiAgRVFVQUxfUExVUyA6IDB4MkUsXG4gIEJBQ0tTUEFDRSA6IDB4MkEsIC8qIGFsc28gY2FsbGVkIERlbGV0ZSAqL1xuXG4gIC8qIEFscGhhbnVtZXJpYywgc2Vjb25kIHJvdyAqL1xuICBUQUIgOiAweDJCLFxuICBRIDogMHgxNCxcbiAgVyA6IDB4MUEsXG4gIEUgOiAweDA4LFxuICBSIDogMHgxNSxcbiAgVCA6IDB4MTcsXG4gIFkgOiAweDFDLFxuICBVIDogMHgxOCxcbiAgSSA6IDB4MEMsXG4gIE8gOiAweDEyLFxuICBQIDogMHgxMyxcbiAgTEJSQUNLRVRfQ1VSTFkgOiAweDJGLFxuICBSQlJBQ0tFVF9DVVJMWSA6IDB4MzAsXG4gIEJBQ0tTTEFTSF9QSVBFIDogMHgzMSwgLyogcmVwbGFjZWQgYnkgTk9OVVNfTlVNQkVSX1RJTERFIG9uIElTTyBLQiAqL1xuXG4gIC8qIEFscGhhbnVtZXJpYywgdGhpcmQgcm93ICovXG4gIENBUFNMT0NLIDogMHgzOSwgLyogYWxzbyBFaXN1ICjoi7HmlbApIG9uIEpJUyBrZXlib2FyZHMgKi9cbiAgQSA6IDB4MDQsXG4gIFMgOiAweDE2LFxuICBEIDogMHgwNyxcbiAgRiA6IDB4MDksXG4gIEcgOiAweDBBLFxuICBIIDogMHgwQixcbiAgSiA6IDB4MEQsXG4gIEsgOiAweDBFLFxuICBMIDogMHgwRixcbiAgU0VNSUNPTE9OX0NPTE9OIDogMHgzMyxcbiAgUVVPVEVfRE9VQkxFUVVPVEUgOiAweDM0LFxuICBOT05VU19OVU1CRVJfVElMREUgOiAweDMyLCAvKiBleHRyYSBrZXkgbGVmdCBvZiBSZXR1cm4gb24gSVNPIEtCICovXG4gIFJFVFVSTiA6IDB4MjgsIC8qIGFsc28gY2FsbGVkIEVudGVyICovXG5cbiAgLyogQWxwaGFudW1lcmljLCBmb3VydGggcm93ICovXG4gIExTSElGVCA6IDB4RTEsXG4gIE5PTlVTX0JBQ0tTTEFTSF9QSVBFIDogMHg2NCwgLyogZXh0cmEga2V5IHJpZ2h0IG9mIExTaGlmdCBvbiBJU08gS0IgKi9cbiAgWiA6IDB4MUQsXG4gIFggOiAweDFCLFxuICBDIDogMHgwNixcbiAgViA6IDB4MTksXG4gIEIgOiAweDA1LFxuICBOIDogMHgxMSxcbiAgTSA6IDB4MTAsXG4gIENPTU1BX0xFU1MgOiAweDM2LFxuICBQRVJJT0RfR1JFQVRFUiA6IDB4MzcsXG4gIFNMQVNIX1FVRVNUSU9OIDogMHgzOCxcbiAgUlNISUZUIDogMHhFNSxcblxuICAvKiBBbHBoYW51bWVyaWMsIGZpZnRoIHJvdyAqL1xuICBMQ09OVFJPTCA6IDB4RTAsXG4gIExNRVRBIDogMHhFMywgLyogTGVmdCBXaW5kb3dzLCBMZWZ0IENvbW1hbmQgKi9cbiAgTEFMVCA6IDB4RTIsXG4gIFNQQUNFQkFSIDogMHgyQyxcbiAgUkFMVCA6IDB4RTYsXG4gIFJNRVRBIDogMHhFNywgLyogUmlnaHQgV2luZG93cywgUmlnaHQgQ29tbWFuZCAqL1xuICBNRU5VIDogMHg3NixcbiAgUkNPTlRST0wgOiAweEU0LFxuXG4gIC8qIENvbnRyb2wgcGFkICovXG4gIElOU0VSVCA6IDB4NDksIC8qIHJlcGxhY2VkIGJ5IGEgRm4ga2V5IG9uIE1hYyAoZGlmZmVyZW50IGNvZGUpICovXG4gIEhPTUUgOiAweDRBLFxuICBQQUdFVVAgOiAweDRCLFxuICBERUxFVEVGT1JXQVJEIDogMHg0QyxcbiAgRU5EIDogMHg0RCxcbiAgUEFHRURPV04gOiAweDRFLFxuXG4gIC8qIEFycm93IHBhZCAqL1xuICBVUEFSUk9XIDogMHg1MixcbiAgTEVGVEFSUk9XIDogMHg1MCxcbiAgRE9XTkFSUk9XIDogMHg1MSxcbiAgUklHSFRBUlJPVyA6IDB4NEYsXG5cbiAgLyogTnVtZXJpYyBwYWQgKi9cbiAgUEFEX05VTUxPQ0tfQ0xFQVIgOiAweDUzLCAvKiBubyBOdW1Mb2NrIG9uIE1hYyBrZXlib2FyZHMgKi9cbiAgUEFEX0VRVUFMUyA6IDB4NjcsIC8qIG9uIE1hYyBrZXlib2FyZHMgKi9cbiAgUEFEX0RJVklERSA6IDB4NTQsXG4gIFBBRF9NVUxUSVBMWSA6IDB4NTUsXG4gIFBBRF9NSU5VUyA6IDB4NTYsXG4gIFBBRF83X0hPTUUgOiAweDVGLFxuICBQQURfOF9VUEFSUk9XIDogMHg2MCxcbiAgUEFEXzlfUEFHRVVQIDogMHg2MSxcbiAgUEFEX1BMVVMgOiAweDU3LFxuICBQQURfNF9MRUZUQVJST1cgOiAweDVDLFxuICBQQURfNSA6IDB4NUQsXG4gIFBBRF82X1JJR0hUQVJST1cgOiAweDVFLFxuICBQQURfQ09NTUEgOiAweDg1LCAvKiBzcGVjaWZpYyB0byBCcmF6aWxpYW4ga2V5Ym9hcmRzICovXG4gIFBBRF8xX0VORCA6IDB4NTksXG4gIFBBRF8yX0RPV05BUlJPVyA6IDB4NUEsXG4gIFBBRF8zX1BBR0VET1dOIDogMHg1QixcbiAgUEFEXzBfSU5TRVJUIDogMHg2MixcbiAgUEFEX0RFQ0lNQUxfREVMRVRFIDogMHg2MyxcbiAgUEFEX0VOVEVSIDogMHg1OCxcbiAgLy8gQVMvNDAwIGtleWJvYXJkcyBhbHNvIGhhdmUgYW4gZXF1YWxzIHNpZ24gYXQgMHg4NlxuXG4gIC8qIEV4dHJhIGZ1bmN0aW9uIGtleXMgKi9cbiAgRjEzIDogMHg2OCxcbiAgRjE0IDogMHg2OSxcbiAgRjE1IDogMHg2QSxcbiAgRjE2IDogMHg2QixcbiAgRjE3IDogMHg2QyxcbiAgRjE4IDogMHg2RCxcbiAgRjE5IDogMHg2RSxcbiAgRjIwIDogMHg2RixcbiAgRjIxIDogMHg3MCxcbiAgRjIyIDogMHg3MSxcbiAgRjIzIDogMHg3MixcbiAgRjI0IDogMHg3MyxcblxuICAvKiBJbnRlcm5hdGlvbmFsICYgTEFORyBrZXlzICovXG4gIElOVEVSTkFUSU9OQUwxIDogMHg4NywgLyogXyBhbmQgXFwga2V5IGxlZnQgb2YgUlNoaWZ0IG9uIEpJUyBLQiAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBhbHNvIEJyYXppbGlhbiAvIGFuZCA/IGtleSAqL1xuICBJTlRFUk5BVElPTkFMMiA6IDB4ODgsIC8qIEthdGFrYW5hL0hpcmFnYW5hIGtleSByaWdodCBvZiBTcGFjZSBvbiBKSVMgS0IgKi9cbiAgSU5URVJOQVRJT05BTDMgOiAweDg5LCAvKiB8IGFuZCBZZW4ga2V5IGxlZnQgb2YgQmFja3NwYWNlIG9uIEpJUyBLQiAqL1xuICBJTlRFUk5BVElPTkFMNCA6IDB4OEEsIC8qIEhlbmthbiBrZXkgcmlnaHQgb2YgU3BhY2Ugb24gSklTIEtCICsg5YmN5YCZ6KOcICovXG4gIElOVEVSTkFUSU9OQUw1IDogMHg4QiwgLyogTXVoZW5rYW4ga2V5IGxlZnQgb2YgU3BhY2Ugb24gSklTIEtCICovXG4gIElOVEVSTkFUSU9OQUw2IDogMHg4QywgLyogS2FubWEgKGNvbW1hKSwgcmlnaHQgb2YgS1AwIG9uIEpJUyBLQiAqL1xuICBJTlRFUk5BVElPTkFMNyA6IDB4OEQsIC8qIERvdWJsZS1CeXRlL1NpbmdsZS1CeXRlIHRvZ2dsZSBrZXkgKi9cbiAgSU5URVJOQVRJT05BTDggOiAweDhFLCAvKiBVbmRlZmluZWQgKi9cbiAgSU5URVJOQVRJT05BTDkgOiAweDhGLCAvKiBVbmRlZmluZWQgKi9cbiAgTEFORzEgOiAweDkwLCAvKiBIYW5ndWwvRW5nbGlzaCB0b2dnbGUga2V5IChLb3JlYW4pICovXG4gIExBTkcyIDogMHg5MSwgLyogSGFuamEgY29udmVyc2lvbiBrZXkgKEtvcmVhbikgKi9cbiAgTEFORzMgOiAweDkyLCAvKiBLYXRha2FuYSBrZXkgKEphcGFuZXNlKSAqL1xuICBMQU5HNCA6IDB4OTMsIC8qIEhpcmFnYW5hIGtleSAoSmFwYW5lc2UpICovXG4gIExBTkc1IDogMHg5NCwgLyogWmVua2FrdS9IYW5rYWt1IGtleSAoSmFwYW5lc2UpICovXG5cbiAgLyogRXh0ZW5zaW9ucyAqL1xuICBIRUxQIDogMHg3NSxcbiAgTVVURSA6IDB4N0YsXG4gIFZPTFVNRVVQIDogMHg4MCxcbiAgVk9MVU1FRE9XTiA6IDB4ODFcbn07XG5cbi8vUHJvdmlkZXM6IEtFWV9TVEFURVxudmFyIEtFWV9TVEFURSA9IHtcbiAgVVAgOiAwLFxuICBET1dOICA6IDFcbn07XG5cbi8vUHJvdmlkZXM6IEJVVFRPTlxudmFyIEJVVFRPTiA9IHtcbiAgTk9ORSAgICAgICA6IDAsXG4gIExFRlQgICAgICAgOiAxLFxuICBNSURETEUgICAgIDogMixcbiAgUklHSFQgICAgICA6IDMsXG4gIFdIRUVMX1VQICAgOiA0LFxuICBXSEVFTF9ET1dOIDogNVxufTtcblxuLy9Qcm92aWRlczogQlVUVE9OX1NUQVRFXG52YXIgQlVUVE9OX1NUQVRFID0ge1xuICBVUCA6IDAsXG4gIERPV04gIDogMVxufTtcbiIsIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICAgIENvcHlyaWdodCAyMDIyIE9DYW1sUHJvICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICBBbGwgcmlnaHRzIHJlc2VydmVkLiBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSAgKi9cbi8qICBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlIHNwZWNpYWwgICAgICAgKi9cbi8qICBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgICAgICAgICAgKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLy9Qcm92aWRlczogRk9DVVNfVEFHXG52YXIgRk9DVVNfVEFHID0ge1xuICBPVVQgOiAwLFxuICBJTiAgOiAxXG59O1xuXG4vL1Byb3ZpZGVzOiBLRVlfVEFHXG52YXIgS0VZX1RBRyA9IHtcbiAgRVNDQVBFICAgICAgICAgICAgICAgOiAwLFxuICBGMSAgICAgICAgICAgICAgICAgICA6IDEsXG4gIEYyICAgICAgICAgICAgICAgICAgIDogMixcbiAgRjMgICAgICAgICAgICAgICAgICAgOiAzLFxuICBGNCAgICAgICAgICAgICAgICAgICA6IDQsXG4gIEY1ICAgICAgICAgICAgICAgICAgIDogNSxcbiAgRjYgICAgICAgICAgICAgICAgICAgOiA2LFxuICBGNyAgICAgICAgICAgICAgICAgICA6IDcsXG4gIEY4ICAgICAgICAgICAgICAgICAgIDogOCxcbiAgRjkgICAgICAgICAgICAgICAgICAgOiA5LFxuICBGMTAgICAgICAgICAgICAgICAgICA6IDEwLFxuICBGMTEgICAgICAgICAgICAgICAgICA6IDExLFxuICBGMTIgICAgICAgICAgICAgICAgICA6IDEyLFxuICBQUklOVFNDUkVFTiAgICAgICAgICA6IDEzLFxuICBTQ1JPTExMT0NLICAgICAgICAgICA6IDE0LFxuICBQQVVTRSAgICAgICAgICAgICAgICA6IDE1LFxuICBHUkFWRV9USUxERSAgICAgICAgICA6IDE2LFxuICBfMV9FWENMQU1BVElPTiAgICAgICA6IDE3LFxuICBfMl9BVCAgICAgICAgICAgICAgICA6IDE4LFxuICBfM19OVU1CRVIgICAgICAgICAgICA6IDE5LFxuICBfNF9ET0xMQVIgICAgICAgICAgICA6IDIwLFxuICBfNV9QRVJDRU5UICAgICAgICAgICA6IDIxLFxuICBfNl9DQVJFVCAgICAgICAgICAgICA6IDIyLFxuICBfN19BTVBFUlNBTkQgICAgICAgICA6IDIzLFxuICBfOF9BU1RFUklTSyAgICAgICAgICA6IDI0LFxuICBfOV9MUEFSRU5USEVTSVMgICAgICA6IDI1LFxuICBfMF9SUEFSRU5USEVTSVMgICAgICA6IDI2LFxuICBNSU5VU19VTkRFUlNDT1JFICAgICA6IDI3LFxuICBFUVVBTF9QTFVTICAgICAgICAgICA6IDI4LFxuICBCQUNLU1BBQ0UgICAgICAgICAgICA6IDI5LFxuICBUQUIgICAgICAgICAgICAgICAgICA6IDMwLFxuICBRICAgICAgICAgICAgICAgICAgICA6IDMxLFxuICBXICAgICAgICAgICAgICAgICAgICA6IDMyLFxuICBFICAgICAgICAgICAgICAgICAgICA6IDMzLFxuICBSICAgICAgICAgICAgICAgICAgICA6IDM0LFxuICBUICAgICAgICAgICAgICAgICAgICA6IDM1LFxuICBZICAgICAgICAgICAgICAgICAgICA6IDM2LFxuICBVICAgICAgICAgICAgICAgICAgICA6IDM3LFxuICBJICAgICAgICAgICAgICAgICAgICA6IDM4LFxuICBPICAgICAgICAgICAgICAgICAgICA6IDM5LFxuICBQICAgICAgICAgICAgICAgICAgICA6IDQwLFxuICBMQlJBQ0tFVF9DVVJMWSAgICAgICA6IDQxLFxuICBSQlJBQ0tFVF9DVVJMWSAgICAgICA6IDQyLFxuICBCQUNLU0xBU0hfUElQRSAgICAgICA6IDQzLFxuICBDQVBTTE9DSyAgICAgICAgICAgICA6IDQ0LFxuICBBICAgICAgICAgICAgICAgICAgICA6IDQ1LFxuICBTICAgICAgICAgICAgICAgICAgICA6IDQ2LFxuICBEICAgICAgICAgICAgICAgICAgICA6IDQ3LFxuICBGICAgICAgICAgICAgICAgICAgICA6IDQ4LFxuICBHICAgICAgICAgICAgICAgICAgICA6IDQ5LFxuICBIICAgICAgICAgICAgICAgICAgICA6IDUwLFxuICBKICAgICAgICAgICAgICAgICAgICA6IDUxLFxuICBLICAgICAgICAgICAgICAgICAgICA6IDUyLFxuICBMICAgICAgICAgICAgICAgICAgICA6IDUzLFxuICBTRU1JQ09MT05fQ09MT04gICAgICA6IDU0LFxuICBRVU9URV9ET1VCTEVRVU9URSAgICA6IDU1LFxuICBOT05VU19OVU1CRVJfVElMREUgICA6IDU2LFxuICBSRVRVUk4gICAgICAgICAgICAgICA6IDU3LFxuICBMU0hJRlQgICAgICAgICAgICAgICA6IDU4LFxuICBOT05VU19CQUNLU0xBU0hfUElQRSA6IDU5LFxuICBaICAgICAgICAgICAgICAgICAgICA6IDYwLFxuICBYICAgICAgICAgICAgICAgICAgICA6IDYxLFxuICBDICAgICAgICAgICAgICAgICAgICA6IDYyLFxuICBWICAgICAgICAgICAgICAgICAgICA6IDYzLFxuICBCICAgICAgICAgICAgICAgICAgICA6IDY0LFxuICBOICAgICAgICAgICAgICAgICAgICA6IDY1LFxuICBNICAgICAgICAgICAgICAgICAgICA6IDY2LFxuICBDT01NQV9MRVNTICAgICAgICAgICA6IDY3LFxuICBQRVJJT0RfR1JFQVRFUiAgICAgICA6IDY4LFxuICBTTEFTSF9RVUVTVElPTiAgICAgICA6IDY5LFxuICBSU0hJRlQgICAgICAgICAgICAgICA6IDcwLFxuICBMQ09OVFJPTCAgICAgICAgICAgICA6IDcxLFxuICBMTUVUQSAgICAgICAgICAgICAgICA6IDcyLFxuICBMQUxUICAgICAgICAgICAgICAgICA6IDczLFxuICBTUEFDRUJBUiAgICAgICAgICAgICA6IDc0LFxuICBSQUxUICAgICAgICAgICAgICAgICA6IDc1LFxuICBSTUVUQSAgICAgICAgICAgICAgICA6IDc2LFxuICBNRU5VICAgICAgICAgICAgICAgICA6IDc3LFxuICBSQ09OVFJPTCAgICAgICAgICAgICA6IDc4LFxuICBJTlNFUlQgICAgICAgICAgICAgICA6IDc5LFxuICBIT01FICAgICAgICAgICAgICAgICA6IDgwLFxuICBQQUdFVVAgICAgICAgICAgICAgICA6IDgxLFxuICBERUxFVEVGT1JXQVJEICAgICAgICA6IDgyLFxuICBFTkQgICAgICAgICAgICAgICAgICA6IDgzLFxuICBQQUdFRE9XTiAgICAgICAgICAgICA6IDg0LFxuICBVUEFSUk9XICAgICAgICAgICAgICA6IDg1LFxuICBMRUZUQVJST1cgICAgICAgICAgICA6IDg2LFxuICBET1dOQVJST1cgICAgICAgICAgICA6IDg3LFxuICBSSUdIVEFSUk9XICAgICAgICAgICA6IDg4LFxuICBQQURfTlVNTE9DS19DTEVBUiAgICA6IDg5LFxuICBQQURfRVFVQUxTICAgICAgICAgICA6IDkwLFxuICBQQURfRElWSURFICAgICAgICAgICA6IDkxLFxuICBQQURfTVVMVElQTFkgICAgICAgICA6IDkyLFxuICBQQURfTUlOVVMgICAgICAgICAgICA6IDkzLFxuICBQQURfN19IT01FICAgICAgICAgICA6IDk0LFxuICBQQURfOF9VUEFSUk9XICAgICAgICA6IDk1LFxuICBQQURfOV9QQUdFVVAgICAgICAgICA6IDk2LFxuICBQQURfUExVUyAgICAgICAgICAgICA6IDk3LFxuICBQQURfNF9MRUZUQVJST1cgICAgICA6IDk4LFxuICBQQURfNSAgICAgICAgICAgICAgICA6IDk5LFxuICBQQURfNl9SSUdIVEFSUk9XICAgICA6IDEwMCxcbiAgUEFEX0NPTU1BICAgICAgICAgICAgOiAxMDEsXG4gIFBBRF8xX0VORCAgICAgICAgICAgIDogMTAyLFxuICBQQURfMl9ET1dOQVJST1cgICAgICA6IDEwMyxcbiAgUEFEXzNfUEFHRURPV04gICAgICAgOiAxMDQsXG4gIFBBRF8wX0lOU0VSVCAgICAgICAgIDogMTA1LFxuICBQQURfREVDSU1BTF9ERUxFVEUgICA6IDEwNixcbiAgUEFEX0VOVEVSICAgICAgICAgICAgOiAxMDcsXG4gIEYxMyAgICAgICAgICAgICAgICAgIDogMTA4LFxuICBGMTQgICAgICAgICAgICAgICAgICA6IDEwOSxcbiAgRjE1ICAgICAgICAgICAgICAgICAgOiAxMTAsXG4gIEYxNiAgICAgICAgICAgICAgICAgIDogMTExLFxuICBGMTcgICAgICAgICAgICAgICAgICA6IDExMixcbiAgRjE4ICAgICAgICAgICAgICAgICAgOiAxMTMsXG4gIEYxOSAgICAgICAgICAgICAgICAgIDogMTE0LFxuICBGMjAgICAgICAgICAgICAgICAgICA6IDExNSxcbiAgRjIxICAgICAgICAgICAgICAgICAgOiAxMTYsXG4gIEYyMiAgICAgICAgICAgICAgICAgIDogMTE3LFxuICBGMjMgICAgICAgICAgICAgICAgICA6IDExOCxcbiAgRjI0ICAgICAgICAgICAgICAgICAgOiAxMTksXG4gIElOVEVSTkFUSU9OQUwxICAgICAgIDogMTIwLFxuICBJTlRFUk5BVElPTkFMMiAgICAgICA6IDEyMSxcbiAgSU5URVJOQVRJT05BTDMgICAgICAgOiAxMjIsXG4gIElOVEVSTkFUSU9OQUw0ICAgICAgIDogMTIzLFxuICBJTlRFUk5BVElPTkFMNSAgICAgICA6IDEyNCxcbiAgSU5URVJOQVRJT05BTDYgICAgICAgOiAxMjUsXG4gIElOVEVSTkFUSU9OQUw3ICAgICAgIDogMTI2LFxuICBJTlRFUk5BVElPTkFMOCAgICAgICA6IDEyNyxcbiAgSU5URVJOQVRJT05BTDkgICAgICAgOiAxMjgsXG4gIExBTkcxICAgICAgICAgICAgICAgIDogMTI5LFxuICBMQU5HMiAgICAgICAgICAgICAgICA6IDEzMCxcbiAgTEFORzMgICAgICAgICAgICAgICAgOiAxMzEsXG4gIExBTkc0ICAgICAgICAgICAgICAgIDogMTMyLFxuICBMQU5HNSAgICAgICAgICAgICAgICA6IDEzMyxcbiAgSEVMUCAgICAgICAgICAgICAgICAgOiAxMzQsXG4gIE1VVEUgICAgICAgICAgICAgICAgIDogMTM1LFxuICBWT0xVTUVVUCAgICAgICAgICAgICA6IDEzNixcbiAgVk9MVU1FRE9XTiAgICAgICAgICAgOiAxMzdcbn07XG5cbi8vIFByb3ZpZGVzOiBLRVlfU1RBVEVfVEFHXG52YXIgS0VZX1NUQVRFX1RBRyA9IHtcbiAgVVAgICA6IDAsXG4gIERPV04gOiAxXG59O1xuXG4vLyBQcm92aWRlczogQlVUVE9OX1RBR1xudmFyIEJVVFRPTl9UQUcgPSB7XG4gIE5PTkUgICAgICAgOiAwLFxuICBMRUZUICAgICAgIDogMSxcbiAgTUlERExFICAgICA6IDIsXG4gIFJJR0hUICAgICAgOiAzLFxuICBXSEVFTF9VUCAgIDogNCxcbiAgV0hFRUxfRE9XTiA6IDVcbn07XG5cbi8vIFByb3ZpZGVzOiBCVVRUT05fU1RBVEVfVEFHXG52YXIgQlVUVE9OX1NUQVRFX1RBRyA9IHtcbiAgVVAgICA6IDAsXG4gIERPV04gOiAxXG59O1xuXG4vLyBQcm92aWRlczogRVZFTlRfVEFHXG52YXIgRVZFTlRfVEFHID0ge1xuICBGUkFNRV9DWUNMRSAgICA6IDAsXG4gIEZSQU1FICAgICAgICAgIDogMSxcbiAgQ0FOVkFTX0ZPQ1VTRUQgOiAyLFxuICBDQU5WQVNfUkVTSVpFRCA6IDMsXG4gIENBTlZBU19NT1ZFRCAgIDogNCxcbiAgQ0FOVkFTX0NMT1NFRCAgOiA1LFxuICBLRVlfQUNUSU9OICAgICA6IDYsXG4gIEJVVFRPTl9BQ1RJT04gIDogNyxcbiAgTU9VU0VfTU9WRSAgICAgOiA4XG59O1xuXG4vL1Byb3ZpZGVzOiBTVFlMRV9UQUdcbnZhciBTVFlMRV9UQUcgPSB7XG4gIENPTE9SICAgIDogMCxcbiAgR1JBRElFTlQgOiAxLFxuICBQQVRURVJOICA6IDJcbn07XG5cbi8vUHJvdmlkZXM6IFJFUEVBVF9UQUdcbnZhciBSRVBFQVRfVEFHID0ge1xuICBOT19SRVBFQVQgOiAwLFxuICBSRVBFQVRfWCAgOiAxLFxuICBSRVBFQVRfWSAgOiAyLFxuICBSRVBFQVRfWFkgOiAzXG59O1xuXG4vL1Byb3ZpZGVzOiBTTEFOVF9UQUdcbnZhciBTTEFOVF9UQUcgPSB7XG4gIFJPTUFOICAgOiAwLFxuICBJVEFMSUMgIDogMSxcbiAgT0JMSVFVRSA6IDJcbn07XG5cbi8vUHJvdmlkZXM6IEpPSU5fVFlQRV9UQUdcbnZhciBKT0lOX1RZUEVfVEFHID0ge1xuICBST1VORCA6IDAsXG4gIE1JVEVSIDogMSxcbiAgQkVWRUwgOiAyXG59XG5cbi8vUHJvdmlkZXM6IENBUF9UWVBFX1RBR1xudmFyIENBUF9UWVBFX1RBRyA9IHtcbiAgQlVUVCAgIDogMCxcbiAgU1FVQVJFIDogMSxcbiAgUk9VTkQgIDogMlxufTtcblxuLy9Qcm92aWRlcyA6IENPTVBPUF9UQUdcbnZhciBDT01QT1BfVEFHID0ge1xuICBTT1VSQ0VfT1ZFUiAgICAgIDogMCxcbiAgU09VUkNFX0lOICAgICAgICA6IDEsXG4gIFNPVVJDRV9PVVQgICAgICAgOiAyLFxuICBTT1VSQ0VfQVRPUCAgICAgIDogMyxcbiAgREVTVElOQVRJT05fT1ZFUiA6IDQsXG4gIERFU1RJTkFUSU9OX0lOICAgOiA1LFxuICBERVNUSU5BVElPTl9PVVQgIDogNixcbiAgREVTVElOQVRJT05fQVRPUCA6IDcsXG4gIExJR0hURVIgICAgICAgICAgOiA4LFxuICBDT1BZICAgICAgICAgICAgIDogOSxcbiAgWE9SICAgICAgICAgICAgICA6IDEwLFxuICBNVUxUSVBMWSAgICAgICAgIDogMTEsXG4gIFNDUkVFTiAgICAgICAgICAgOiAxMixcbiAgT1ZFUkxBWSAgICAgICAgICA6IDEzLFxuICBEQVJLRU4gICAgICAgICAgIDogMTQsXG4gIExJR0hURU4gICAgICAgICAgOiAxNSxcbiAgQ09MT1JfRE9ER0UgICAgICA6IDE2LFxuICBDT0xPUl9CVVJOICAgICAgIDogMTcsXG4gIEhBUkRfTElHSFQgICAgICAgOiAxOCxcbiAgU09GVF9MSUdIVCAgICAgICA6IDE5LFxuICBESUZGRVJFTkNFICAgICAgIDogMjAsXG4gIEVYQ0xVU0lPTiAgICAgICAgOiAyMSxcbiAgSFVFICAgICAgICAgICAgICA6IDIyLFxuICBTQVRVUkFUSU9OICAgICAgIDogMjMsXG4gIENPTE9SICAgICAgICAgICAgOiAyNCxcbiAgTFVNSU5PU0lUWSAgICAgICA6IDI1XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAtMjAxNCBKw6lyw7RtZSBWb3VpbGxvblxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vLyBBbiBPQ2FtbCBzdHJpbmcgaXMgYW4gb2JqZWN0IHdpdGggdGhyZWUgZmllbGRzOlxuLy8gLSB0YWcgJ3QnXG4vLyAtIGxlbmd0aCAnbCdcbi8vIC0gY29udGVudHMgJ2MnXG4vL1xuLy8gVGhlIGNvbnRlbnRzIG9mIHRoZSBzdHJpbmcgY2FuIGJlIGVpdGhlciBhIEphdmFTY3JpcHQgYXJyYXkgb3Jcbi8vIGEgSmF2YVNjcmlwdCBzdHJpbmcuIFRoZSBsZW5ndGggb2YgdGhpcyBzdHJpbmcgY2FuIGJlIGxlc3MgdGhhbiB0aGVcbi8vIGxlbmd0aCBvZiB0aGUgT0NhbWwgc3RyaW5nLiBJbiB0aGlzIGNhc2UsIHJlbWFpbmluZyBieXRlcyBhcmVcbi8vIGFzc3VtZWQgdG8gYmUgemVyb2VzLiBBcnJheXMgYXJlIG11dGFibGUgYnV0IGNvbnN1bWVzIG1vcmUgbWVtb3J5XG4vLyB0aGFuIHN0cmluZ3MuIEEgY29tbW9uIHBhdHRlcm4gaXMgdG8gc3RhcnQgZnJvbSBhbiBlbXB0eSBzdHJpbmcgYW5kXG4vLyBwcm9ncmVzc2l2ZWx5IGZpbGwgaXQgZnJvbSB0aGUgc3RhcnQuIFBhcnRpYWwgc3RyaW5ncyBtYWtlcyBpdFxuLy8gcG9zc2libGUgdG8gaW1wbGVtZW50IHRoaXMgZWZmaWNpZW50bHkuXG4vL1xuLy8gV2hlbiBjb252ZXJ0aW5nIHRvIGFuZCBmcm9tIFVURi0xNiwgd2Uga2VlcCB0cmFjayBvZiB3aGV0aGVyIHRoZVxuLy8gc3RyaW5nIGlzIGNvbXBvc2VkIG9ubHkgb2YgQVNDSUkgY2hhcmFjdGVycyAoaW4gd2hpY2ggY2FzZSwgbm9cbi8vIGNvbnZlcnNpb24gbmVlZHMgdG8gYmUgcGVyZm9ybWVkKSBvciBub3QuXG4vL1xuLy8gVGhlIHN0cmluZyB0YWcgY2FuIHRodXMgdGFrZSB0aGUgZm9sbG93aW5nIHZhbHVlczpcbi8vICAgZnVsbCBzdHJpbmcgICAgIEJZVEUgfCBVTktOT1dOOiAgICAgIDBcbi8vICAgICAgICAgICAgICAgICAgIEJZVEUgfCBBU0NJSTogICAgICAgIDlcbi8vICAgICAgICAgICAgICAgICAgIEJZVEUgfCBOT1RfQVNDSUk6ICAgIDhcbi8vICAgc3RyaW5nIHByZWZpeCAgIFBBUlRJQUw6ICAgICAgICAgICAgIDJcbi8vICAgYXJyYXkgICAgICAgICAgIEFSUkFZOiAgICAgICAgICAgICAgIDRcbi8vXG4vLyBPbmUgY2FuIHVzZSBiaXQgbWFza2luZyB0byBkaXNjcmltaW5hdGUgdGhlc2UgZGlmZmVyZW50IGNhc2VzOlxuLy8gICBrbm93bl9lbmNvZGluZyh4KSA9IHgmOFxuLy8gICBpc19hc2NpaSh4KSA9ICAgICAgIHgmMVxuLy8gICBraW5kKHgpID0gICAgICAgICAgIHgmNlxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cl9yZXBlYXRcbmZ1bmN0aW9uIGNhbWxfc3RyX3JlcGVhdChuLCBzKSB7XG4gIGlmKG4gPT0gMCkgcmV0dXJuIFwiXCI7XG4gIGlmIChzLnJlcGVhdCkge3JldHVybiBzLnJlcGVhdChuKTt9IC8vIEVDTUFzY3JpcHQgNiBhbmQgRmlyZWZveCAyNCtcbiAgdmFyIHIgPSBcIlwiLCBsID0gMDtcbiAgZm9yKDs7KSB7XG4gICAgaWYgKG4gJiAxKSByICs9IHM7XG4gICAgbiA+Pj0gMTtcbiAgICBpZiAobiA9PSAwKSByZXR1cm4gcjtcbiAgICBzICs9IHM7XG4gICAgbCsrO1xuICAgIGlmIChsID09IDkpIHtcbiAgICAgIHMuc2xpY2UoMCwxKTsgLy8gZmxhdHRlbiB0aGUgc3RyaW5nXG4gICAgICAvLyB0aGVuLCB0aGUgZmxhdHRlbmluZyBvZiB0aGUgd2hvbGUgc3RyaW5nIHdpbGwgYmUgZmFzdGVyLFxuICAgICAgLy8gYXMgaXQgd2lsbCBiZSBjb21wb3NlZCBvZiBsYXJnZXIgcGllY2VzXG4gICAgfVxuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3ViYXJyYXlfdG9fanNieXRlc1xuLy9XZWFrZGVmXG4vLyBQcmUgRUNNQVNjcmlwdCA1LCBbYXBwbHldIHdvdWxkIG5vdCBzdXBwb3J0IGFycmF5LWxpa2Ugb2JqZWN0LlxuLy8gSW4gc3VjaCBzZXR1cCwgVHlwZWRfYXJyYXkgd291bGQgYmUgaW1wbGVtZW50ZWQgYXMgcG9seWZpbGwsIGFuZCBbZi5hcHBseV0gd291bGRcbi8vIGZhaWwgaGVyZS4gTWFyayB0aGUgcHJpbWl0aXZlIGFzIFdlYWtkZWYsIHNvIHRoYXQgcGVvcGxlIGNhbiBvdmVycmlkZSBpdCBlYXNpbHkuXG5mdW5jdGlvbiBjYW1sX3N1YmFycmF5X3RvX2pzYnl0ZXMgKGEsIGksIGxlbikge1xuICB2YXIgZiA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG4gIGlmIChpID09IDAgJiYgbGVuIDw9IDQwOTYgJiYgbGVuID09IGEubGVuZ3RoKSByZXR1cm4gZi5hcHBseSAobnVsbCwgYSk7XG4gIHZhciBzID0gXCJcIjtcbiAgZm9yICg7IDAgPCBsZW47IGkgKz0gMTAyNCxsZW4tPTEwMjQpXG4gICAgcyArPSBmLmFwcGx5IChudWxsLCBhLnNsaWNlKGksaSArIE1hdGgubWluKGxlbiwgMTAyNCkpKTtcbiAgcmV0dXJuIHM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdXRmOF9vZl91dGYxNlxuZnVuY3Rpb24gY2FtbF91dGY4X29mX3V0ZjE2KHMpIHtcbiAgZm9yICh2YXIgYiA9IFwiXCIsIHQgPSBiLCBjLCBkLCBpID0gMCwgbCA9IHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgYyA9IHMuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoYyA8IDB4ODApIHtcbiAgICAgIGZvciAodmFyIGogPSBpICsgMTsgKGogPCBsKSAmJiAoYyA9IHMuY2hhckNvZGVBdChqKSkgPCAweDgwOyBqKyspO1xuICAgICAgaWYgKGogLSBpID4gNTEyKSB7IHQuc3Vic3RyKDAsIDEpOyBiICs9IHQ7IHQgPSBcIlwiOyBiICs9IHMuc2xpY2UoaSwgaikgfVxuICAgICAgZWxzZSB0ICs9IHMuc2xpY2UoaSwgaik7XG4gICAgICBpZiAoaiA9PSBsKSBicmVhaztcbiAgICAgIGkgPSBqO1xuICAgIH1cbiAgICBpZiAoYyA8IDB4ODAwKSB7XG4gICAgICB0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhjMCB8IChjID4+IDYpKTtcbiAgICAgIHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweDgwIHwgKGMgJiAweDNmKSk7XG4gICAgfSBlbHNlIGlmIChjIDwgMHhkODAwIHx8IGMgPj0gMHhkZmZmKSB7XG4gICAgICB0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhlMCB8IChjID4+IDEyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDgwIHwgKChjID4+IDYpICYgMHgzZiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg4MCB8IChjICYgMHgzZikpO1xuICAgIH0gZWxzZSBpZiAoYyA+PSAweGRiZmYgfHwgaSArIDEgPT0gbCB8fFxuICAgICAgICAgICAgICAgKGQgPSBzLmNoYXJDb2RlQXQoaSArIDEpKSA8IDB4ZGMwMCB8fCBkID4gMHhkZmZmKSB7XG4gICAgICAvLyBVbm1hdGNoZWQgc3Vycm9nYXRlIHBhaXIsIHJlcGxhY2VkIGJ5IFxcdWZmZmQgKHJlcGxhY2VtZW50IGNoYXJhY3RlcilcbiAgICAgIHQgKz0gXCJcXHhlZlxceGJmXFx4YmRcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgaSsrO1xuICAgICAgYyA9IChjIDw8IDEwKSArIGQgLSAweDM1ZmRjMDA7XG4gICAgICB0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhmMCB8IChjID4+IDE4KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDgwIHwgKChjID4+IDEyKSAmIDB4M2YpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4ODAgfCAoKGMgPj4gNikgJiAweDNmKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDgwIHwgKGMgJiAweDNmKSk7XG4gICAgfVxuICAgIGlmICh0Lmxlbmd0aCA+IDEwMjQpIHt0LnN1YnN0cigwLCAxKTsgYiArPSB0OyB0ID0gXCJcIjt9XG4gIH1cbiAgcmV0dXJuIGIrdDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91dGYxNl9vZl91dGY4XG5mdW5jdGlvbiBjYW1sX3V0ZjE2X29mX3V0Zjgocykge1xuICBmb3IgKHZhciBiID0gXCJcIiwgdCA9IFwiXCIsIGMsIGMxLCBjMiwgdiwgaSA9IDAsIGwgPSBzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGMxID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjMSA8IDB4ODApIHtcbiAgICAgIGZvciAodmFyIGogPSBpICsgMTsgKGogPCBsKSAmJiAoYzEgPSBzLmNoYXJDb2RlQXQoaikpIDwgMHg4MDsgaisrKTtcbiAgICAgIGlmIChqIC0gaSA+IDUxMikgeyB0LnN1YnN0cigwLCAxKTsgYiArPSB0OyB0ID0gXCJcIjsgYiArPSBzLnNsaWNlKGksIGopIH1cbiAgICAgIGVsc2UgdCArPSBzLnNsaWNlKGksIGopO1xuICAgICAgaWYgKGogPT0gbCkgYnJlYWs7XG4gICAgICBpID0gajtcbiAgICB9XG4gICAgdiA9IDE7XG4gICAgaWYgKCgrK2kgPCBsKSAmJiAoKChjMiA9IHMuY2hhckNvZGVBdChpKSkgJiAtNjQpID09IDEyOCkpIHtcbiAgICAgIGMgPSBjMiArIChjMSA8PCA2KTtcbiAgICAgIGlmIChjMSA8IDB4ZTApIHtcbiAgICAgICAgdiA9IGMgLSAweDMwODA7XG4gICAgICAgIGlmICh2IDwgMHg4MCkgdiA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2ID0gMjtcbiAgICAgICAgaWYgKCgrK2kgPCBsKSAmJiAoKChjMiA9IHMuY2hhckNvZGVBdChpKSkgJiAtNjQpID09IDEyOCkpIHtcbiAgICAgICAgICBjID0gYzIgKyAoYyA8PCA2KTtcbiAgICAgICAgICBpZiAoYzEgPCAweGYwKSB7XG4gICAgICAgICAgICB2ID0gYyAtIDB4ZTIwODA7XG4gICAgICAgICAgICBpZiAoKHYgPCAweDgwMCkgfHwgKCh2ID49IDB4ZDdmZikgJiYgKHYgPCAweGUwMDApKSkgdiA9IDI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHYgPSAzO1xuICAgICAgICAgICAgaWYgKCgrK2kgPCBsKSAmJiAoKChjMiA9IHMuY2hhckNvZGVBdChpKSkgJiAtNjQpID09IDEyOCkgJiZcbiAgICAgICAgICAgICAgICAoYzEgPCAweGY1KSkge1xuICAgICAgICAgICAgICB2ID0gYzIgLSAweDNjODIwODAgKyAoYyA8PCA2KTtcbiAgICAgICAgICAgICAgaWYgKHYgPCAweDEwMDAwIHx8IHYgPiAweDEwZmZmZikgdiA9IDM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh2IDwgNCkgeyAvLyBJbnZhbGlkIHNlcXVlbmNlXG4gICAgICBpIC09IHY7XG4gICAgICB0ICs9IFwiXFx1ZmZmZFwiO1xuICAgIH0gZWxzZSBpZiAodiA+IDB4ZmZmZilcbiAgICAgIHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweGQ3YzAgKyAodiA+PiAxMCksIDB4ZGMwMCArICh2ICYgMHgzRkYpKVxuICAgIGVsc2VcbiAgICAgIHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh2KTtcbiAgICBpZiAodC5sZW5ndGggPiAxMDI0KSB7dC5zdWJzdHIoMCwgMSk7IGIgKz0gdDsgdCA9IFwiXCI7fVxuICB9XG4gIHJldHVybiBiK3Q7XG59XG5cbi8vUHJvdmlkZXM6IGpzb29faXNfYXNjaWlcbmZ1bmN0aW9uIGpzb29faXNfYXNjaWkgKHMpIHtcbiAgLy8gVGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBnZXRzIGJldHRlciBhdCBhcm91bmQgdGhpcyBwb2ludCBmb3IgYWxsIGJyb3dzZXJzXG4gIGlmIChzLmxlbmd0aCA8IDI0KSB7XG4gICAgLy8gU3BpZGVybW9ua2V5IGdldHMgbXVjaCBzbG93ZXIgd2hlbiBzLmxlbmd0aCA+PSAyNCAob24gNjQgYml0IGFyY2hzKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcy5sZW5ndGg7IGkrKykgaWYgKHMuY2hhckNvZGVBdChpKSA+IDEyNykgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2VcbiAgICByZXR1cm4gIS9bXlxceDAwLVxceDdmXS8udGVzdChzKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc191bnNhZmVfZ2V0IG11dGFibGVcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfdW5zYWZlX2dldCAocywgaSkge1xuICBzd2l0Y2ggKHMudCAmIDYpIHtcbiAgZGVmYXVsdDogLyogUEFSVElBTCAqL1xuICAgIGlmIChpID49IHMuYy5sZW5ndGgpIHJldHVybiAwO1xuICBjYXNlIDA6IC8qIEJZVEVTICovXG4gICAgcmV0dXJuIHMuYy5jaGFyQ29kZUF0KGkpO1xuICBjYXNlIDQ6IC8qIEFSUkFZICovXG4gICAgcmV0dXJuIHMuY1tpXVxuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfdW5zYWZlX3NldFxuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5XG5mdW5jdGlvbiBjYW1sX2J5dGVzX3Vuc2FmZV9zZXQgKHMsIGksIGMpIHtcbiAgLy8gVGhlIE9DYW1sIGNvbXBpbGVyIHVzZXMgQ2hhci51bnNhZmVfY2hyIG9uIGludGVnZXJzIGxhcmdlciB0aGFuIDI1NSFcbiAgYyAmPSAweGZmO1xuICBpZiAocy50ICE9IDQgLyogQVJSQVkgKi8pIHtcbiAgICBpZiAoaSA9PSBzLmMubGVuZ3RoKSB7XG4gICAgICBzLmMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSAoYyk7XG4gICAgICBpZiAoaSArIDEgPT0gcy5sKSBzLnQgPSAwOyAvKkJZVEVTIHwgVU5LT1dOKi9cbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXkgKHMpO1xuICB9XG4gIHMuY1tpXSA9IGM7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX3N0cmluZ19ib3VuZF9lcnJvciAoKSB7XG4gIGNhbWxfaW52YWxpZF9hcmd1bWVudCAoXCJpbmRleCBvdXQgb2YgYm91bmRzXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IgKCkge1xuICBjYW1sX2ludmFsaWRfYXJndW1lbnQgKFwiaW5kZXggb3V0IG9mIGJvdW5kc1wiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19ib3VuZF9lcnJvciwgY2FtbF9zdHJpbmdfdW5zYWZlX2dldFxuLy9SZXF1aXJlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19nZXQgKHMsIGkpIHtcbiAgaWYgKGkgPj4+IDAgPj0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpKSBjYW1sX3N0cmluZ19ib3VuZF9lcnJvcigpO1xuICByZXR1cm4gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2dldDE2XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0LCBjYW1sX3N0cmluZ19ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19nZXQxNihzLGkpIHtcbiAgaWYgKGkgPj4+IDAgPj0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpIC0gMSkgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGIxID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSksXG4gICAgICBiMiA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkgKyAxKTtcbiAgcmV0dXJuIChiMiA8PCA4IHwgYjEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2dldDE2XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQsIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfZ2V0MTYocyxpKSB7XG4gIGlmIChpID4+PiAwID49IHMubCAtIDEpIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGIxID0gY2FtbF9ieXRlc191bnNhZmVfZ2V0IChzLCBpKSxcbiAgICAgIGIyID0gY2FtbF9ieXRlc191bnNhZmVfZ2V0IChzLCBpICsgMSk7XG4gIHJldHVybiAoYjIgPDwgOCB8IGIxKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfZ2V0MzJcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQsIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2dldDMyKHMsaSkge1xuICBpZiAoaSA+Pj4gMCA+PSBjYW1sX21sX3N0cmluZ19sZW5ndGgocykgLSAzKSBjYW1sX3N0cmluZ19ib3VuZF9lcnJvcigpO1xuICB2YXIgYjEgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpKSxcbiAgICAgIGIyID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSArIDEpLFxuICAgICAgYjMgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpICsgMiksXG4gICAgICBiNCA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkgKyAzKTtcbiAgcmV0dXJuIChiNCA8PCAyNCB8IGIzIDw8IDE2IHwgYjIgPDwgOCB8IGIxKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19nZXQzMlxuLy9SZXF1aXJlczogY2FtbF9ieXRlc191bnNhZmVfZ2V0LCBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2dldDMyKHMsaSkge1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwgLSAzKSBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yKCk7XG4gIHZhciBiMSA9IGNhbWxfYnl0ZXNfdW5zYWZlX2dldCAocywgaSksXG4gICAgICBiMiA9IGNhbWxfYnl0ZXNfdW5zYWZlX2dldCAocywgaSArIDEpLFxuICAgICAgYjMgPSBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQgKHMsIGkgKyAyKSxcbiAgICAgIGI0ID0gY2FtbF9ieXRlc191bnNhZmVfZ2V0IChzLCBpICsgMyk7XG4gIHJldHVybiAoYjQgPDwgMjQgfCBiMyA8PCAxNiB8IGIyIDw8IDggfCBiMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2dldDY0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0LCBjYW1sX3N0cmluZ19ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZl9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19nZXQ2NChzLGkpIHtcbiAgaWYgKGkgPj4+IDAgPj0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpIC0gNykgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGEgPSBuZXcgQXJyYXkoOCk7XG4gIGZvcih2YXIgaiA9IDA7IGogPCA4OyBqKyspe1xuICAgIGFbNyAtIGpdID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSArIGopO1xuICB9XG4gIHJldHVybiBjYW1sX2ludDY0X29mX2J5dGVzKGEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2dldDY0XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQsIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfZ2V0NjQocyxpKSB7XG4gIGlmIChpID4+PiAwID49IHMubCAtIDcpIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGEgPSBuZXcgQXJyYXkoOCk7XG4gIGZvcih2YXIgaiA9IDA7IGogPCA4OyBqKyspe1xuICAgIGFbNyAtIGpdID0gY2FtbF9ieXRlc191bnNhZmVfZ2V0IChzLCBpICsgaik7XG4gIH1cbiAgcmV0dXJuIGNhbWxfaW50NjRfb2ZfYnl0ZXMoYSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yLCBjYW1sX2J5dGVzX3Vuc2FmZV9nZXRcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfZ2V0IChzLCBpKSB7XG4gIGlmIChpID4+PiAwID49IHMubCkgY2FtbF9ieXRlc19ib3VuZF9lcnJvcigpO1xuICByZXR1cm4gY2FtbF9ieXRlc191bnNhZmVfZ2V0IChzLCBpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3NldCAocywgaSwgYykge1xuICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9zdHJpbmdfc2V0XCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19zZXRcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9zZXQsIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19zZXQgKHMsIGksIGMpIHtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sKSBjYW1sX3N0cmluZ19ib3VuZF9lcnJvcigpO1xuICByZXR1cm4gY2FtbF9zdHJpbmdfdW5zYWZlX3NldCAocywgaSwgYyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfc2V0MTZcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IsIGNhbWxfYnl0ZXNfdW5zYWZlX3NldFxuZnVuY3Rpb24gY2FtbF9ieXRlc19zZXQxNihzLGksaTE2KXtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sIC0gMSkgY2FtbF9ieXRlc19ib3VuZF9lcnJvcigpO1xuICB2YXIgYjIgPSAweEZGICYgaTE2ID4+IDgsXG4gICAgICBiMSA9IDB4RkYgJiBpMTY7XG4gIGNhbWxfYnl0ZXNfdW5zYWZlX3NldCAocywgaSArIDAsIGIxKTtcbiAgY2FtbF9ieXRlc191bnNhZmVfc2V0IChzLCBpICsgMSwgYjIpO1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19zZXQxNlxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19zZXQxNihzLGksaTE2KXtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfc3RyaW5nX3NldDE2XCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19zZXQxNlxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19zZXQxNlxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfc2V0MTYocyxpLGkxNil7XG4gIHJldHVybiBjYW1sX2J5dGVzX3NldDE2KHMsaSxpMTYpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX3NldDMyXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yLCBjYW1sX2J5dGVzX3Vuc2FmZV9zZXRcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfc2V0MzIocyxpLGkzMil7XG4gIGlmIChpID4+PiAwID49IHMubCAtIDMpIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGI0ID0gMHhGRiAmIGkzMiA+PiAyNCxcbiAgICAgIGIzID0gMHhGRiAmIGkzMiA+PiAxNixcbiAgICAgIGIyID0gMHhGRiAmIGkzMiA+PiA4LFxuICAgICAgYjEgPSAweEZGICYgaTMyO1xuICBjYW1sX2J5dGVzX3Vuc2FmZV9zZXQgKHMsIGkgKyAwLCBiMSk7XG4gIGNhbWxfYnl0ZXNfdW5zYWZlX3NldCAocywgaSArIDEsIGIyKTtcbiAgY2FtbF9ieXRlc191bnNhZmVfc2V0IChzLCBpICsgMiwgYjMpO1xuICBjYW1sX2J5dGVzX3Vuc2FmZV9zZXQgKHMsIGkgKyAzLCBiNCk7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3NldDMyXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3NldDMyKHMsaSxpMzIpe1xuICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9zdHJpbmdfc2V0MzJcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3NldDMyXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX3NldDMyXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19zZXQzMihzLGksaTMyKXtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfc2V0MzIocyxpLGkzMik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfc2V0NjRcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IsIGNhbWxfYnl0ZXNfdW5zYWZlX3NldFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF90b19ieXRlc1xuZnVuY3Rpb24gY2FtbF9ieXRlc19zZXQ2NChzLGksaTY0KXtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sIC0gNykgY2FtbF9ieXRlc19ib3VuZF9lcnJvcigpO1xuICB2YXIgYSA9IGNhbWxfaW50NjRfdG9fYnl0ZXMoaTY0KTtcbiAgZm9yKHZhciBqID0gMDsgaiA8IDg7IGorKykge1xuICAgIGNhbWxfYnl0ZXNfdW5zYWZlX3NldCAocywgaSArIDcgLSBqLCBhW2pdKTtcbiAgfVxuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19zZXQ2NFxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19zZXQ2NChzLGksaTY0KXtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfc3RyaW5nX3NldDY0XCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19zZXQ2NFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19zZXQ2NFxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfc2V0NjQocyxpLGk2NCl7XG4gIHJldHVybiBjYW1sX2J5dGVzX3NldDY0KHMsaSxpNjQpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX3NldFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19ib3VuZF9lcnJvciwgY2FtbF9ieXRlc191bnNhZmVfc2V0XG5mdW5jdGlvbiBjYW1sX2J5dGVzX3NldCAocywgaSwgYykge1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwpIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IoKTtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfdW5zYWZlX3NldCAocywgaSwgYyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfb2ZfdXRmMTZfanNzdHJpbmdcbi8vUmVxdWlyZXM6IGpzb29faXNfYXNjaWksIGNhbWxfdXRmOF9vZl91dGYxNiwgTWxCeXRlc1xuZnVuY3Rpb24gY2FtbF9ieXRlc19vZl91dGYxNl9qc3N0cmluZyAocykge1xuICB2YXIgdGFnID0gOSAvKiBCWVRFUyB8IEFTQ0lJICovO1xuICBpZiAoIWpzb29faXNfYXNjaWkocykpXG4gICAgdGFnID0gOCAvKiBCWVRFUyB8IE5PVF9BU0NJSSAqLywgcyA9IGNhbWxfdXRmOF9vZl91dGYxNihzKTtcbiAgcmV0dXJuIG5ldyBNbEJ5dGVzKHRhZywgcywgcy5sZW5ndGgpO1xufVxuXG5cbi8vUHJvdmlkZXM6IE1sQnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMsIGpzb29faXNfYXNjaWksIGNhbWxfdXRmMTZfb2ZfdXRmOFxuZnVuY3Rpb24gTWxCeXRlcyAodGFnLCBjb250ZW50cywgbGVuZ3RoKSB7XG4gIHRoaXMudD10YWc7IHRoaXMuYz1jb250ZW50czsgdGhpcy5sPWxlbmd0aDtcbn1cbk1sQnl0ZXMucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKXtcbiAgc3dpdGNoICh0aGlzLnQpIHtcbiAgY2FzZSA5OiAvKkJZVEVTIHwgQVNDSUkqL1xuICAgIHJldHVybiB0aGlzLmM7XG4gIGRlZmF1bHQ6XG4gICAgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyh0aGlzKTtcbiAgY2FzZSAwOiAvKkJZVEVTIHwgVU5LT1dOKi9cbiAgICBpZiAoanNvb19pc19hc2NpaSh0aGlzLmMpKSB7XG4gICAgICB0aGlzLnQgPSA5OyAvKkJZVEVTIHwgQVNDSUkqL1xuICAgICAgcmV0dXJuIHRoaXMuYztcbiAgICB9XG4gICAgdGhpcy50ID0gODsgLypCWVRFUyB8IE5PVF9BU0NJSSovXG4gIGNhc2UgODogLypCWVRFUyB8IE5PVF9BU0NJSSovXG4gICAgcmV0dXJuIHRoaXMuYztcbiAgfVxufTtcbk1sQnl0ZXMucHJvdG90eXBlLnRvVXRmMTYgPSBmdW5jdGlvbiAoKXtcbiAgdmFyIHIgPSB0aGlzLnRvU3RyaW5nKCk7XG4gIGlmKHRoaXMudCA9PSA5KSByZXR1cm4gclxuICByZXR1cm4gY2FtbF91dGYxNl9vZl91dGY4KHIpO1xufVxuTWxCeXRlcy5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiAoKXtcbiAgdmFyIGNvbnRlbnQgPSB0aGlzLnQgPT0gNCA/IHRoaXMuYy5zbGljZSgpIDogdGhpcy5jO1xuICByZXR1cm4gbmV3IE1sQnl0ZXModGhpcy50LGNvbnRlbnQsdGhpcy5sKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9zdHJfcmVwZWF0LCBjYW1sX3N1YmFycmF5X3RvX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMgKHMpIHtcbiAgLyogQXNzdW1lcyBub3QgQllURVMgKi9cbiAgaWYgKHMudCA9PSAyIC8qIFBBUlRJQUwgKi8pXG4gICAgcy5jICs9IGNhbWxfc3RyX3JlcGVhdChzLmwgLSBzLmMubGVuZ3RoLCAnXFwwJylcbiAgZWxzZVxuICAgIHMuYyA9IGNhbWxfc3ViYXJyYXlfdG9fanNieXRlcyAocy5jLCAwLCBzLmMubGVuZ3RoKTtcbiAgcy50ID0gMDsgLypCWVRFUyB8IFVOS09XTiovXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY29udmVydF9ieXRlc190b19hcnJheVxuZnVuY3Rpb24gY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5IChzKSB7XG4gIC8qIEFzc3VtZXMgbm90IEFSUkFZICovXG4gIHZhciBhID0gbmV3IFVpbnQ4QXJyYXkocy5sKTtcbiAgdmFyIGIgPSBzLmMsIGwgPSBiLmxlbmd0aCwgaSA9IDA7XG4gIGZvciAoOyBpIDwgbDsgaSsrKSBhW2ldID0gYi5jaGFyQ29kZUF0KGkpO1xuICBmb3IgKGwgPSBzLmw7IGkgPCBsOyBpKyspIGFbaV0gPSAwO1xuICBzLmMgPSBhO1xuICBzLnQgPSA0OyAvKiBBUlJBWSAqL1xuICByZXR1cm4gYTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91aW50OF9hcnJheV9vZl9ieXRlcyBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfdWludDhfYXJyYXlfb2ZfYnl0ZXMgKHMpIHtcbiAgaWYgKHMudCAhPSA0IC8qIEFSUkFZICovKSBjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXkocyk7XG4gIHJldHVybiBzLmM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdWludDhfYXJyYXlfb2Zfc3RyaW5nIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9ieXRlc190b19hcnJheVxuLy9SZXF1aXJlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoLCBjYW1sX3N0cmluZ191bnNhZmVfZ2V0XG5mdW5jdGlvbiBjYW1sX3VpbnQ4X2FycmF5X29mX3N0cmluZyAocykge1xuICB2YXIgbCA9IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKTtcbiAgdmFyIGEgPSBuZXcgVWludDhBcnJheShsKTtcbiAgdmFyIGkgPSAwO1xuICBmb3IgKDsgaSA8IGw7IGkrKykgYVtpXSA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQocyxpKTtcbiAgcmV0dXJuIGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY3JlYXRlX3N0cmluZyBjb25zdFxuLy9SZXF1aXJlczogTWxCeXRlcywgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2NyZWF0ZV9zdHJpbmcobGVuKSB7XG4gIGlmKGxlbiA8IDApIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIlN0cmluZy5jcmVhdGVcIik7XG4gIHJldHVybiBuZXcgTWxCeXRlcyhsZW4/Mjo5LFwiXCIsbGVuKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jcmVhdGVfc3RyaW5nIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9jcmVhdGVfc3RyaW5nKGxlbikge1xuICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJTdHJpbmcuY3JlYXRlXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NyZWF0ZV9ieXRlcyBjb25zdFxuLy9SZXF1aXJlczogTWxCeXRlcyxjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfY3JlYXRlX2J5dGVzKGxlbikge1xuICBpZiAobGVuIDwgMCkgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQnl0ZXMuY3JlYXRlXCIpO1xuICByZXR1cm4gbmV3IE1sQnl0ZXMobGVuPzI6OSxcIlwiLGxlbik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX29mX2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX3N1YmFycmF5X3RvX2pzYnl0ZXMsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX29mX2FycmF5IChhKSB7XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKGNhbWxfc3ViYXJyYXlfdG9fanNieXRlcyhhLDAsYS5sZW5ndGgpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19vZl9hcnJheVxuLy9SZXF1aXJlczogTWxCeXRlc1xuZnVuY3Rpb24gY2FtbF9ieXRlc19vZl9hcnJheSAoYSkge1xuICBpZighIChhIGluc3RhbmNlb2YgVWludDhBcnJheSkpIHtcbiAgICBhID0gbmV3IFVpbnQ4QXJyYXkoYSk7XG4gIH1cbiAgcmV0dXJuIG5ldyBNbEJ5dGVzKDQsYSxhLmxlbmd0aCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfY29tcGFyZSBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2NvbXBhcmUoczEsIHMyKSB7XG4gIChzMS50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzMSk7XG4gIChzMi50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzMik7XG4gIHJldHVybiAoczEuYyA8IHMyLmMpPy0xOihzMS5jID4gczIuYyk/MTowO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfZXF1YWwgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlc1xuZnVuY3Rpb24gY2FtbF9ieXRlc19lcXVhbChzMSwgczIpIHtcbiAgaWYoczEgPT09IHMyKSByZXR1cm4gMTtcbiAgKHMxLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMxKTtcbiAgKHMyLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMyKTtcbiAgcmV0dXJuIChzMS5jID09IHMyLmMpPzE6MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfbm90ZXF1YWwgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfZXF1YWxcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX25vdGVxdWFsKHMxLCBzMikgeyByZXR1cm4gMS1jYW1sX3N0cmluZ19lcXVhbChzMSwgczIpOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfbm90ZXF1YWwgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19lcXVhbFxuZnVuY3Rpb24gY2FtbF9ieXRlc19ub3RlcXVhbChzMSwgczIpIHsgcmV0dXJuIDEtY2FtbF9ieXRlc19lcXVhbChzMSwgczIpOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfbGVzc2VxdWFsIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfbGVzc2VxdWFsKHMxLCBzMikge1xuICAoczEudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczEpO1xuICAoczIudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczIpO1xuICByZXR1cm4gKHMxLmMgPD0gczIuYyk/MTowO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2xlc3N0aGFuIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfbGVzc3RoYW4oczEsIHMyKSB7XG4gIChzMS50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzMSk7XG4gIChzMi50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzMik7XG4gIHJldHVybiAoczEuYyA8IHMyLmMpPzE6MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfZ3JlYXRlcmVxdWFsXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19sZXNzZXF1YWxcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2dyZWF0ZXJlcXVhbChzMSwgczIpIHtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX2xlc3NlcXVhbChzMixzMSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2dyZWF0ZXJlcXVhbFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19sZXNzZXF1YWxcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfZ3JlYXRlcmVxdWFsKHMxLCBzMikge1xuICByZXR1cm4gY2FtbF9ieXRlc19sZXNzZXF1YWwoczIsczEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19ncmVhdGVydGhhblxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfbGVzc3RoYW5cbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2dyZWF0ZXJ0aGFuKHMxLCBzMikge1xuICByZXR1cm4gY2FtbF9zdHJpbmdfbGVzc3RoYW4oczIsIHMxKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19ncmVhdGVydGhhblxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19sZXNzdGhhblxuZnVuY3Rpb24gY2FtbF9ieXRlc19ncmVhdGVydGhhbihzMSwgczIpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfbGVzc3RoYW4oczIsIHMxKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9maWxsX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX3N0cl9yZXBlYXQsIGNhbWxfY29udmVydF9ieXRlc190b19hcnJheVxuLy9BbGlhczogY2FtbF9maWxsX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9maWxsX2J5dGVzKHMsIGksIGwsIGMpIHtcbiAgaWYgKGwgPiAwKSB7XG4gICAgaWYgKGkgPT0gMCAmJiAobCA+PSBzLmwgfHwgKHMudCA9PSAyIC8qIFBBUlRJQUwgKi8gJiYgbCA+PSBzLmMubGVuZ3RoKSkpIHtcbiAgICAgIGlmIChjID09IDApIHtcbiAgICAgICAgcy5jID0gXCJcIjtcbiAgICAgICAgcy50ID0gMjsgLyogUEFSVElBTCAqL1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcy5jID0gY2FtbF9zdHJfcmVwZWF0IChsLCBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpKTtcbiAgICAgICAgcy50ID0gKGwgPT0gcy5sKT8wIC8qIEJZVEVTIHwgVU5LT1dOICovIDoyOyAvKiBQQVJUSUFMICovXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzLnQgIT0gNCAvKiBBUlJBWSAqLykgY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5KHMpO1xuICAgICAgZm9yIChsICs9IGk7IGkgPCBsOyBpKyspIHMuY1tpXSA9IGM7XG4gICAgfVxuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JsaXRfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfc3ViYXJyYXlfdG9fanNieXRlcywgY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5XG5mdW5jdGlvbiBjYW1sX2JsaXRfYnl0ZXMoczEsIGkxLCBzMiwgaTIsIGxlbikge1xuICBpZiAobGVuID09IDApIHJldHVybiAwO1xuICBpZiAoKGkyID09IDApICYmXG4gICAgICAobGVuID49IHMyLmwgfHwgKHMyLnQgPT0gMiAvKiBQQVJUSUFMICovICYmIGxlbiA+PSBzMi5jLmxlbmd0aCkpKSB7XG4gICAgczIuYyA9IChzMS50ID09IDQgLyogQVJSQVkgKi8pP1xuICAgICAgY2FtbF9zdWJhcnJheV90b19qc2J5dGVzKHMxLmMsIGkxLCBsZW4pOlxuICAgICAgKGkxID09IDAgJiYgczEuYy5sZW5ndGggPT0gbGVuKT9zMS5jOnMxLmMuc3Vic3RyKGkxLCBsZW4pO1xuICAgIHMyLnQgPSAoczIuYy5sZW5ndGggPT0gczIubCk/MCAvKiBCWVRFUyB8IFVOS09XTiAqLyA6MjsgLyogUEFSVElBTCAqL1xuICB9IGVsc2UgaWYgKHMyLnQgPT0gMiAvKiBQQVJUSUFMICovICYmIGkyID09IHMyLmMubGVuZ3RoKSB7XG4gICAgczIuYyArPSAoczEudCA9PSA0IC8qIEFSUkFZICovKT9cbiAgICAgIGNhbWxfc3ViYXJyYXlfdG9fanNieXRlcyhzMS5jLCBpMSwgbGVuKTpcbiAgICAgIChpMSA9PSAwICYmIHMxLmMubGVuZ3RoID09IGxlbik/czEuYzpzMS5jLnN1YnN0cihpMSwgbGVuKTtcbiAgICBzMi50ID0gKHMyLmMubGVuZ3RoID09IHMyLmwpPzAgLyogQllURVMgfCBVTktPV04gKi8gOjI7IC8qIFBBUlRJQUwgKi9cbiAgfSBlbHNlIHtcbiAgICBpZiAoczIudCAhPSA0IC8qIEFSUkFZICovKSBjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXkoczIpO1xuICAgIHZhciBjMSA9IHMxLmMsIGMyID0gczIuYztcbiAgICBpZiAoczEudCA9PSA0IC8qIEFSUkFZICovKSB7XG4gICAgICBpZiAoaTIgPD0gaTEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgYzIgW2kyICsgaV0gPSBjMSBbaTEgKyBpXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGkgPSBsZW4gLSAxOyBpID49IDA7IGktLSkgYzIgW2kyICsgaV0gPSBjMSBbaTEgKyBpXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGwgPSBNYXRoLm1pbiAobGVuLCBjMS5sZW5ndGggLSBpMSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykgYzIgW2kyICsgaV0gPSBjMS5jaGFyQ29kZUF0KGkxICsgaSk7XG4gICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSBjMiBbaTIgKyBpXSA9IDA7XG4gICAgfVxuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JsaXRfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2JsaXRfYnl0ZXMsIGNhbWxfYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2JsaXRfc3RyaW5nKGEsYixjLGQsZSkge1xuICBjYW1sX2JsaXRfYnl0ZXMoY2FtbF9ieXRlc19vZl9zdHJpbmcoYSksYixjLGQsZSk7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfYnl0ZXNfbGVuZ3RoIGNvbnN0XG5mdW5jdGlvbiBjYW1sX21sX2J5dGVzX2xlbmd0aChzKSB7IHJldHVybiBzLmwgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19jb25jYXRcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfY29uY2F0KGEsYikgeyByZXR1cm4gYSArIGIgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19jb25jYXRcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMsIE1sQnl0ZXNcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2NvbmNhdChzMSxzMil7XG4gIChzMS50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzMSk7XG4gIChzMi50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzMik7XG4gIHJldHVybiBuZXcgTWxCeXRlcyhzMS50LHMxLmMrczIuYyxzMS5sK3MyLmwpXG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfdW5zYWZlX2dldCBjb25zdFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpKSB7XG4gIHJldHVybiBzLmNoYXJDb2RlQXQoaSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9zZXRcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfdW5zYWZlX3NldCAocywgaSwgYykge1xuICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9zdHJpbmdfdW5zYWZlX3NldFwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoIGNvbnN0XG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSB7XG4gIHJldHVybiBzLmxlbmd0aFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19jb21wYXJlIGNvbnN0XG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2NvbXBhcmUoczEsIHMyKSB7XG4gIHJldHVybiAoczEgPCBzMik/LTE6KHMxID4gczIpPzE6MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfZXF1YWwgY29uc3Rcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfZXF1YWwoczEsIHMyKSB7XG4gIGlmKHMxID09PSBzMikgcmV0dXJuIDE7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19sZXNzZXF1YWwgY29uc3Rcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfbGVzc2VxdWFsKHMxLCBzMikge1xuICByZXR1cm4gKHMxIDw9IHMyKT8xOjA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2xlc3N0aGFuIGNvbnN0XG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2xlc3N0aGFuKHMxLCBzMikge1xuICByZXR1cm4gKHMxIDwgczIpPzE6MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfb2ZfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfb2ZfYnl0ZXMocykge1xuICAocy50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzKTtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMocy5jKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19vZl9zdHJpbmcgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfb2ZfanNieXRlcywgY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2J5dGVzX29mX3N0cmluZyhzKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX29mX2pzYnl0ZXMoY2FtbF9qc2J5dGVzX29mX3N0cmluZyhzKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMgY29uc3Rcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyh4KSB7IHJldHVybiB4IH1cblxuLy9Qcm92aWRlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZyBjb25zdFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKHgpIHsgcmV0dXJuIHggfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyBjb25zdFxuLy9SZXF1aXJlczoganNvb19pc19hc2NpaSwgY2FtbF91dGYxNl9vZl91dGY4XG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHMpIHtcbiAgaWYoanNvb19pc19hc2NpaShzKSlcbiAgICByZXR1cm4gcztcbiAgcmV0dXJuIGNhbWxfdXRmMTZfb2ZfdXRmOChzKTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyBjb25zdFxuLy9SZXF1aXJlczoganNvb19pc19hc2NpaSwgY2FtbF91dGY4X29mX3V0ZjE2LCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nIChzKSB7XG4gIGlmIChqc29vX2lzX2FzY2lpKHMpKVxuICAgIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKHMpXG4gIGVsc2UgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoY2FtbF91dGY4X29mX3V0ZjE2KHMpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19vZl9qc2J5dGVzIGNvbnN0XG4vL1JlcXVpcmVzOiBNbEJ5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX29mX2pzYnl0ZXMocykgeyByZXR1cm4gbmV3IE1sQnl0ZXMoMCxzLHMubGVuZ3RoKTsgfVxuXG5cbi8vIFRoZSBzZWN0aW9uIGJlbG93IHNob3VsZCBiZSB1c2VkIHdoZW4gdXNlLWpzLXN0cmluZz1mYWxzZVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX3Vuc2FmZV9nZXRcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfdW5zYWZlX2dldChzLGkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ191bnNhZmVfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX3Vuc2FmZV9zZXRcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3Vuc2FmZV9zZXQgKHMsIGksIGMpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfdW5zYWZlX3NldChzLGksYyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9tbF9ieXRlc19sZW5ndGhcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSB7XG4gIHJldHVybiBjYW1sX21sX2J5dGVzX2xlbmd0aChzKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19jb21wYXJlXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2NvbXBhcmVcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2NvbXBhcmUoczEsIHMyKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX2NvbXBhcmUoczEsczIpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2VxdWFsXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2VxdWFsXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19lcXVhbChzMSwgczIpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfZXF1YWwoczEsczIpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2xlc3NlcXVhbFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19sZXNzZXF1YWxcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2xlc3NlcXVhbChzMSwgczIpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfbGVzc2VxdWFsKHMxLHMyKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19sZXNzdGhhblxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19sZXNzdGhhblxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfbGVzc3RoYW4oczEsIHMyKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX2xlc3N0aGFuKHMxLHMyKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19vZl9ieXRlc1xuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfb2ZfYnl0ZXMocykgeyByZXR1cm4gcyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfb2Zfc3RyaW5nIGNvbnN0XG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2J5dGVzX29mX3N0cmluZyhzKSB7IHJldHVybiBzIH1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlcyBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19vZl9qc2J5dGVzXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKHMpIHsgcmV0dXJuIGNhbWxfYnl0ZXNfb2ZfanNieXRlcyhzKTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKHMpIHtcbiAgKHMudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMocyk7XG4gIHJldHVybiBzLmMgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyBtdXRhYmxlIChjb25zdClcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHMpe1xuICByZXR1cm4gcy50b1V0ZjE2KClcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfb2ZfdXRmMTZfanNzdHJpbmdcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nIChzKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX29mX3V0ZjE2X2pzc3RyaW5nKHMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lzX21sX2J5dGVzXG4vL1JlcXVpcmVzOiBNbEJ5dGVzXG5mdW5jdGlvbiBjYW1sX2lzX21sX2J5dGVzKHMpIHtcbiAgcmV0dXJuIChzIGluc3RhbmNlb2YgTWxCeXRlcyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfYnl0ZXNfY29udGVudFxuLy9SZXF1aXJlczogTWxCeXRlcywgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlc1xuZnVuY3Rpb24gY2FtbF9tbF9ieXRlc19jb250ZW50KHMpIHtcbiAgc3dpdGNoIChzLnQgJiA2KSB7XG4gIGRlZmF1bHQ6IC8qIFBBUlRJQUwgKi9cbiAgICBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMpO1xuICBjYXNlIDA6IC8qIEJZVEVTICovXG4gICAgcmV0dXJuIHMuYztcbiAgY2FzZSA0OlxuICAgIHJldHVybiBzLmNcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lzX21sX3N0cmluZ1xuLy9SZXF1aXJlczoganNvb19pc19hc2NpaVxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2lzX21sX3N0cmluZyhzKSB7XG4gIHJldHVybiAodHlwZW9mIHMgPT09IFwic3RyaW5nXCIgJiYgIS9bXlxceDAwLVxceGZmXS8udGVzdChzKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaXNfbWxfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2lzX21sX2J5dGVzXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2lzX21sX3N0cmluZyhzKSB7XG4gIHJldHVybiBjYW1sX2lzX21sX2J5dGVzKHMpO1xufVxuXG4vLyBUaGUgZnVuY3Rpb25zIGJlbG93IGFyZSBkZXByZWNhdGVkXG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfdG9fYnl0ZV9zdHJpbmcgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfanNfdG9fYnl0ZV9zdHJpbmcocykgeyByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhzKSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfbmV3X3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9uZXdfc3RyaW5nIChzKSB7IHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKHMpIH1cblxuLy9Qcm92aWRlczogY2FtbF9qc19mcm9tX3N0cmluZyBtdXRhYmxlIChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2pzX2Zyb21fc3RyaW5nKHMpIHtcbiAgcmV0dXJuIGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHMpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdG9fanNfc3RyaW5nIG11dGFibGUgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfdG9fanNfc3RyaW5nKHMpIHtcbiAgcmV0dXJuIGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHMpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfdG9fc3RyaW5nIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc190b19zdHJpbmcgKHMpIHtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKHMpO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfYXJyYXlfb2Zfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX3VpbnQ4X2FycmF5X29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9hcnJheV9vZl9zdHJpbmcoeCkgeyByZXR1cm4gY2FtbF91aW50OF9hcnJheV9vZl9zdHJpbmcoeCkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X29mX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX3VpbnQ4X2FycmF5X29mX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2FycmF5X29mX2J5dGVzKHgpIHsgcmV0dXJuIGNhbWxfdWludDhfYXJyYXlfb2ZfYnl0ZXMoeCkgfVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDE0IErDqXLDtG1lIFZvdWlsbG9uLCBIdWdvIEhldXphcmQsIEFuZHkgUmF5XG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG4vL1xuLy8gQmlnYXJyYXkuXG4vL1xuLy8gLSBhbGwgYmlnYXJyYXkgdHlwZXMgaW5jbHVkaW5nIEludDY0IGFuZCBDb21wbGV4LlxuLy8gLSBmb3J0cmFuICsgYyBsYXlvdXRzXG4vLyAtIHN1Yi9zbGljZS9yZXNoYXBlXG4vLyAtIHJldGFpbiBmYXN0IHBhdGggZm9yIDFkIGFycmF5IGFjY2Vzc1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2luaXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfYmFfaW5pdCgpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZ2V0X3NpemVcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9iYV9nZXRfc2l6ZShkaW1zKSB7XG4gIHZhciBuX2RpbXMgPSBkaW1zLmxlbmd0aDtcbiAgdmFyIHNpemUgPSAxO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG5fZGltczsgaSsrKSB7XG4gICAgaWYgKGRpbXNbaV0gPCAwKVxuICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkuY3JlYXRlOiBuZWdhdGl2ZSBkaW1lbnNpb25cIik7XG4gICAgc2l6ZSA9IHNpemUgKiBkaW1zW2ldO1xuICB9XG4gIHJldHVybiBzaXplO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50XG5mdW5jdGlvbiBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50KGtpbmQpe1xuICBzd2l0Y2goa2luZCl7XG4gIGNhc2UgNzogY2FzZSAxMDogY2FzZSAxMTogcmV0dXJuIDI7XG4gIGRlZmF1bHQ6IHJldHVybiAxO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfY3JlYXRlX2J1ZmZlclxuLy9SZXF1aXJlczogY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudFxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX2JhX2NyZWF0ZV9idWZmZXIoa2luZCwgc2l6ZSl7XG4gIHZhciB2aWV3O1xuICBzd2l0Y2goa2luZCl7XG4gIGNhc2UgMDogIHZpZXcgPSBGbG9hdDMyQXJyYXk7IGJyZWFrO1xuICBjYXNlIDE6ICB2aWV3ID0gRmxvYXQ2NEFycmF5OyBicmVhaztcbiAgY2FzZSAyOiAgdmlldyA9IEludDhBcnJheTsgYnJlYWs7XG4gIGNhc2UgMzogIHZpZXcgPSBVaW50OEFycmF5OyBicmVhaztcbiAgY2FzZSA0OiAgdmlldyA9IEludDE2QXJyYXk7IGJyZWFrO1xuICBjYXNlIDU6ICB2aWV3ID0gVWludDE2QXJyYXk7IGJyZWFrO1xuICBjYXNlIDY6ICB2aWV3ID0gSW50MzJBcnJheTsgYnJlYWs7XG4gIGNhc2UgNzogIHZpZXcgPSBJbnQzMkFycmF5OyBicmVhaztcbiAgY2FzZSA4OiAgdmlldyA9IEludDMyQXJyYXk7IGJyZWFrO1xuICBjYXNlIDk6ICB2aWV3ID0gSW50MzJBcnJheTsgYnJlYWs7XG4gIGNhc2UgMTA6IHZpZXcgPSBGbG9hdDMyQXJyYXk7IGJyZWFrO1xuICBjYXNlIDExOiB2aWV3ID0gRmxvYXQ2NEFycmF5OyBicmVhaztcbiAgY2FzZSAxMjogdmlldyA9IFVpbnQ4QXJyYXk7IGJyZWFrO1xuICB9XG4gIGlmICghdmlldykgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkuY3JlYXRlOiB1bnN1cHBvcnRlZCBraW5kXCIpO1xuICB2YXIgZGF0YSA9IG5ldyB2aWV3KHNpemUgKiBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50KGtpbmQpKTtcbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfY3VzdG9tX25hbWVcbi8vVmVyc2lvbjogPCA0LjExXG52YXIgY2FtbF9iYV9jdXN0b21fbmFtZSA9IFwiX2JpZ2FycmF5XCJcblxuLy9Qcm92aWRlczogY2FtbF9iYV9jdXN0b21fbmFtZVxuLy9WZXJzaW9uOiA+PSA0LjExXG52YXIgY2FtbF9iYV9jdXN0b21fbmFtZSA9IFwiX2JpZ2FycjAyXCJcblxuLy9Qcm92aWRlczogTWxfQmlnYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3IsIGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9iYV9jdXN0b21fbmFtZVxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9jcmVhdGVfbG9faGksIGNhbWxfaW50NjRfaGkzMiwgY2FtbF9pbnQ2NF9sbzMyXG5mdW5jdGlvbiBNbF9CaWdhcnJheSAoa2luZCwgbGF5b3V0LCBkaW1zLCBidWZmZXIpIHtcblxuICB0aGlzLmtpbmQgICA9IGtpbmQgO1xuICB0aGlzLmxheW91dCA9IGxheW91dDtcbiAgdGhpcy5kaW1zICAgPSBkaW1zO1xuICB0aGlzLmRhdGEgPSBidWZmZXI7XG59XG5cbk1sX0JpZ2FycmF5LnByb3RvdHlwZS5jYW1sX2N1c3RvbSA9IGNhbWxfYmFfY3VzdG9tX25hbWU7XG5cbk1sX0JpZ2FycmF5LnByb3RvdHlwZS5vZmZzZXQgPSBmdW5jdGlvbiAoYXJnKSB7XG4gIHZhciBvZnMgPSAwO1xuICBpZih0eXBlb2YgYXJnID09PSBcIm51bWJlclwiKSBhcmcgPSBbYXJnXTtcbiAgaWYgKCEgKGFyZyBpbnN0YW5jZW9mIEFycmF5KSkgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiYmlnYXJyYXkuanM6IGludmFsaWQgb2Zmc2V0XCIpO1xuICBpZiAodGhpcy5kaW1zLmxlbmd0aCAhPSBhcmcubGVuZ3RoKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LmdldC9zZXQ6IGJhZCBudW1iZXIgb2YgZGltZW5zaW9uc1wiKTtcbiAgaWYodGhpcy5sYXlvdXQgPT0gMCAvKiBjX2xheW91dCAqLykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kaW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYXJnW2ldIDwgMCB8fCBhcmdbaV0gPj0gdGhpcy5kaW1zW2ldKVxuICAgICAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gICAgICBvZnMgPSAob2ZzICogdGhpcy5kaW1zW2ldKSArIGFyZ1tpXTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMuZGltcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgaWYgKGFyZ1tpXSA8IDEgfHwgYXJnW2ldID4gdGhpcy5kaW1zW2ldKXtcbiAgICAgICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICAgICAgfVxuICAgICAgb2ZzID0gKG9mcyAqIHRoaXMuZGltc1tpXSkgKyAoYXJnW2ldIC0gMSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBvZnM7XG59XG5cbk1sX0JpZ2FycmF5LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAob2ZzKSB7XG4gIHN3aXRjaCh0aGlzLmtpbmQpe1xuICBjYXNlIDc6XG4gICAgLy8gSW50NjRcbiAgICB2YXIgbCA9IHRoaXMuZGF0YVtvZnMgKiAyICsgMF07XG4gICAgdmFyIGggPSB0aGlzLmRhdGFbb2ZzICogMiArIDFdO1xuICAgIHJldHVybiBjYW1sX2ludDY0X2NyZWF0ZV9sb19oaShsLGgpO1xuICBjYXNlIDEwOiBjYXNlIDExOlxuICAgIC8vIENvbXBsZXgzMiwgQ29tcGxleDY0XG4gICAgdmFyIHIgPSB0aGlzLmRhdGFbb2ZzICogMiArIDBdO1xuICAgIHZhciBpID0gdGhpcy5kYXRhW29mcyAqIDIgKyAxXTtcbiAgICByZXR1cm4gWzI1NCwgciwgaV07XG4gIGRlZmF1bHQ6XG4gICAgcmV0dXJuIHRoaXMuZGF0YVtvZnNdXG4gIH1cbn1cblxuTWxfQmlnYXJyYXkucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChvZnMsdikge1xuICBzd2l0Y2godGhpcy5raW5kKXtcbiAgY2FzZSA3OlxuICAgIC8vIEludDY0XG4gICAgdGhpcy5kYXRhW29mcyAqIDIgKyAwXSA9IGNhbWxfaW50NjRfbG8zMih2KTtcbiAgICB0aGlzLmRhdGFbb2ZzICogMiArIDFdID0gY2FtbF9pbnQ2NF9oaTMyKHYpO1xuICAgIGJyZWFrO1xuICBjYXNlIDEwOiBjYXNlIDExOlxuICAgIC8vIENvbXBsZXgzMiwgQ29tcGxleDY0XG4gICAgdGhpcy5kYXRhW29mcyAqIDIgKyAwXSA9IHZbMV07XG4gICAgdGhpcy5kYXRhW29mcyAqIDIgKyAxXSA9IHZbMl07XG4gICAgYnJlYWs7XG4gIGRlZmF1bHQ6XG4gICAgdGhpcy5kYXRhW29mc10gPSB2O1xuICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiAwXG59XG5cblxuTWxfQmlnYXJyYXkucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiAodikge1xuICBzd2l0Y2godGhpcy5raW5kKXtcbiAgY2FzZSA3OlxuICAgIC8vIEludDY0XG4gICAgdmFyIGEgPSBjYW1sX2ludDY0X2xvMzIodik7XG4gICAgdmFyIGIgPSBjYW1sX2ludDY0X2hpMzIodik7XG4gICAgaWYoYSA9PSBiKXtcbiAgICAgIHRoaXMuZGF0YS5maWxsKGEpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGk8dGhpcy5kYXRhLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdGhpcy5kYXRhW2ldID0gKGklMiA9PSAwKSA/IGEgOiBiO1xuICAgICAgfVxuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAxMDogY2FzZSAxMTpcbiAgICAvLyBDb21wbGV4MzIsIENvbXBsZXg2NFxuICAgIHZhciBpbSA9IHZbMV07XG4gICAgdmFyIHJlID0gdlsyXTtcbiAgICBpZihpbSA9PSByZSl7XG4gICAgICB0aGlzLmRhdGEuZmlsbChpbSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZm9yKHZhciBpID0gMDsgaTx0aGlzLmRhdGEubGVuZ3RoOyBpKyspe1xuICAgICAgICB0aGlzLmRhdGFbaV0gPSAoaSUyID09IDApID8gaW0gOiByZTtcbiAgICAgIH1cbiAgICB9XG4gICAgYnJlYWs7XG4gIGRlZmF1bHQ6XG4gICAgdGhpcy5kYXRhLmZpbGwodik7XG4gICAgYnJlYWs7XG4gIH1cbn1cblxuXG5NbF9CaWdhcnJheS5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIChiLCB0b3RhbCkge1xuICBpZiAodGhpcy5sYXlvdXQgIT0gYi5sYXlvdXQgfHwgdGhpcy5raW5kICE9IGIua2luZCkge1xuICAgIHZhciBrMSA9IHRoaXMua2luZCB8ICh0aGlzLmxheW91dCA8PCA4KTtcbiAgICB2YXIgazIgPSAgICBiLmtpbmQgfCAoYi5sYXlvdXQgPDwgOCk7XG4gICAgcmV0dXJuIGsyIC0gazE7XG4gIH1cbiAgaWYgKHRoaXMuZGltcy5sZW5ndGggIT0gYi5kaW1zLmxlbmd0aCkge1xuICAgIHJldHVybiBiLmRpbXMubGVuZ3RoIC0gdGhpcy5kaW1zLmxlbmd0aDtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGltcy5sZW5ndGg7IGkrKylcbiAgICBpZiAodGhpcy5kaW1zW2ldICE9IGIuZGltc1tpXSlcbiAgICAgIHJldHVybiAodGhpcy5kaW1zW2ldIDwgYi5kaW1zW2ldKSA/IC0xIDogMTtcbiAgc3dpdGNoICh0aGlzLmtpbmQpIHtcbiAgY2FzZSAwOlxuICBjYXNlIDE6XG4gIGNhc2UgMTA6XG4gIGNhc2UgMTE6XG4gICAgLy8gRmxvYXRzXG4gICAgdmFyIHgsIHk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIHggPSB0aGlzLmRhdGFbaV07XG4gICAgICB5ID0gYi5kYXRhW2ldO1xuICAgICAgaWYgKHggPCB5KVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgICBpZiAoeCA+IHkpXG4gICAgICAgIHJldHVybiAxO1xuICAgICAgaWYgKHggIT0geSkge1xuICAgICAgICBpZiAoIXRvdGFsKSByZXR1cm4gTmFOO1xuICAgICAgICBpZiAoeCA9PSB4KSByZXR1cm4gMTtcbiAgICAgICAgaWYgKHkgPT0geSkgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSA3OlxuICAgIC8vIEludDY0XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyBpKz0yKSB7XG4gICAgICAvLyBDaGVjayBoaWdoZXN0IGJpdHMgZmlyc3RcbiAgICAgIGlmICh0aGlzLmRhdGFbaSsxXSA8IGIuZGF0YVtpKzFdKVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgICBpZiAodGhpcy5kYXRhW2krMV0gPiBiLmRhdGFbaSsxXSlcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICBpZiAoKHRoaXMuZGF0YVtpXSA+Pj4gMCkgPCAoYi5kYXRhW2ldID4+PiAwKSlcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgaWYgKCh0aGlzLmRhdGFbaV0gPj4+IDApID4gKGIuZGF0YVtpXSA+Pj4gMCkpXG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAyOlxuICBjYXNlIDM6XG4gIGNhc2UgNDpcbiAgY2FzZSA1OlxuICBjYXNlIDY6XG4gIGNhc2UgODpcbiAgY2FzZSA5OlxuICBjYXNlIDEyOlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodGhpcy5kYXRhW2ldIDwgYi5kYXRhW2ldKVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgICBpZiAodGhpcy5kYXRhW2ldID4gYi5kYXRhW2ldKVxuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IE1sX0JpZ2FycmF5X2NfMV8xXG4vL1JlcXVpcmVzOiBNbF9CaWdhcnJheSwgY2FtbF9hcnJheV9ib3VuZF9lcnJvciwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBNbF9CaWdhcnJheV9jXzFfMShraW5kLCBsYXlvdXQsIGRpbXMsIGJ1ZmZlcikge1xuICB0aGlzLmtpbmQgICA9IGtpbmQgO1xuICB0aGlzLmxheW91dCA9IGxheW91dDtcbiAgdGhpcy5kaW1zICAgPSBkaW1zO1xuICB0aGlzLmRhdGEgICA9IGJ1ZmZlcjtcbn1cblxuTWxfQmlnYXJyYXlfY18xXzEucHJvdG90eXBlID0gbmV3IE1sX0JpZ2FycmF5KClcbk1sX0JpZ2FycmF5X2NfMV8xLnByb3RvdHlwZS5vZmZzZXQgPSBmdW5jdGlvbiAoYXJnKSB7XG4gIGlmKHR5cGVvZiBhcmcgIT09IFwibnVtYmVyXCIpe1xuICAgIGlmKChhcmcgaW5zdGFuY2VvZiBBcnJheSkgJiYgYXJnLmxlbmd0aCA9PSAxKVxuICAgICAgYXJnID0gYXJnWzBdO1xuICAgIGVsc2UgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiTWxfQmlnYXJyYXlfY18xXzEub2Zmc2V0XCIpO1xuICB9XG4gIGlmIChhcmcgPCAwIHx8IGFyZyA+PSB0aGlzLmRpbXNbMF0pXG4gICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICByZXR1cm4gYXJnO1xufVxuXG5NbF9CaWdhcnJheV9jXzFfMS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKG9mcykge1xuICByZXR1cm4gdGhpcy5kYXRhW29mc107XG59XG5cbk1sX0JpZ2FycmF5X2NfMV8xLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAob2ZzLHYpIHtcbiAgdGhpcy5kYXRhW29mc10gPSB2O1xuICByZXR1cm4gMFxufVxuXG5NbF9CaWdhcnJheV9jXzFfMS5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uICh2KSB7XG4gIHRoaXMuZGF0YS5maWxsKHYpO1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2NvbXBhcmVcbmZ1bmN0aW9uIGNhbWxfYmFfY29tcGFyZShhLGIsdG90YWwpe1xuICByZXR1cm4gYS5jb21wYXJlKGIsdG90YWwpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfY3JlYXRlX3Vuc2FmZVxuLy9SZXF1aXJlczogTWxfQmlnYXJyYXksIE1sX0JpZ2FycmF5X2NfMV8xLCBjYW1sX2JhX2dldF9zaXplLCBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50XG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZShraW5kLCBsYXlvdXQsIGRpbXMsIGRhdGEpe1xuICB2YXIgc2l6ZV9wZXJfZWxlbWVudCA9IGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnQoa2luZCk7XG4gIGlmKGNhbWxfYmFfZ2V0X3NpemUoZGltcykgKiBzaXplX3Blcl9lbGVtZW50ICE9IGRhdGEubGVuZ3RoKSB7XG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwibGVuZ3RoIGRvZXNuJ3QgbWF0Y2ggZGltc1wiKTtcbiAgfVxuICBpZihsYXlvdXQgPT0gMCAmJiAvLyBjX2xheW91dFxuICAgICBkaW1zLmxlbmd0aCA9PSAxICYmIC8vIEFycmF5MVxuICAgICBzaXplX3Blcl9lbGVtZW50ID09IDEpIC8vIDEtdG8tMSBtYXBwaW5nXG4gICAgcmV0dXJuIG5ldyBNbF9CaWdhcnJheV9jXzFfMShraW5kLCBsYXlvdXQsIGRpbXMsIGRhdGEpO1xuICByZXR1cm4gbmV3IE1sX0JpZ2FycmF5KGtpbmQsIGxheW91dCwgZGltcywgZGF0YSk7XG5cbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2NyZWF0ZVxuLy9SZXF1aXJlczogY2FtbF9qc19mcm9tX2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF9zaXplLCBjYW1sX2JhX2NyZWF0ZV91bnNhZmVcbi8vUmVxdWlyZXM6IGNhbWxfYmFfY3JlYXRlX2J1ZmZlclxuZnVuY3Rpb24gY2FtbF9iYV9jcmVhdGUoa2luZCwgbGF5b3V0LCBkaW1zX21sKSB7XG4gIHZhciBkaW1zID0gY2FtbF9qc19mcm9tX2FycmF5KGRpbXNfbWwpO1xuICB2YXIgZGF0YSA9IGNhbWxfYmFfY3JlYXRlX2J1ZmZlcihraW5kLCBjYW1sX2JhX2dldF9zaXplKGRpbXMpKTtcbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZShraW5kLCBsYXlvdXQsIGRpbXMsIGRhdGEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2NoYW5nZV9sYXlvdXRcbi8vUmVxdWlyZXM6IGNhbWxfYmFfY3JlYXRlX3Vuc2FmZVxuZnVuY3Rpb24gY2FtbF9iYV9jaGFuZ2VfbGF5b3V0KGJhLCBsYXlvdXQpIHtcbiAgaWYoYmEubGF5b3V0ID09IGxheW91dCkgcmV0dXJuIGJhO1xuICB2YXIgbmV3X2RpbXMgPSBbXVxuICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGltcy5sZW5ndGg7IGkrKykgbmV3X2RpbXNbaV0gPSBiYS5kaW1zW2JhLmRpbXMubGVuZ3RoIC0gaSAtIDFdO1xuICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGJhLmtpbmQsIGxheW91dCwgbmV3X2RpbXMsIGJhLmRhdGEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2tpbmRcbmZ1bmN0aW9uIGNhbWxfYmFfa2luZChiYSkge1xuICByZXR1cm4gYmEua2luZDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9sYXlvdXRcbmZ1bmN0aW9uIGNhbWxfYmFfbGF5b3V0KGJhKSB7XG4gIHJldHVybiBiYS5sYXlvdXQ7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfbnVtX2RpbXNcbmZ1bmN0aW9uIGNhbWxfYmFfbnVtX2RpbXMoYmEpIHtcbiAgcmV0dXJuIGJhLmRpbXMubGVuZ3RoO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2RpbVxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX2JhX2RpbShiYSwgaSkge1xuICBpZiAoaSA8IDAgfHwgaSA+PSBiYS5kaW1zLmxlbmd0aClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5kaW1cIik7XG4gIHJldHVybiBiYS5kaW1zW2ldO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2RpbV8xXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2RpbVxuZnVuY3Rpb24gY2FtbF9iYV9kaW1fMShiYSkge1xuICByZXR1cm4gY2FtbF9iYV9kaW0oYmEsIDApO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2RpbV8yXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2RpbVxuZnVuY3Rpb24gY2FtbF9iYV9kaW1fMihiYSkge1xuICByZXR1cm4gY2FtbF9iYV9kaW0oYmEsIDEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2RpbV8zXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2RpbVxuZnVuY3Rpb24gY2FtbF9iYV9kaW1fMyhiYSkge1xuICByZXR1cm4gY2FtbF9iYV9kaW0oYmEsIDIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2dldF9nZW5lcmljXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfYmFfZ2V0X2dlbmVyaWMoYmEsIGkpIHtcbiAgdmFyIG9mcyA9IGJhLm9mZnNldChjYW1sX2pzX2Zyb21fYXJyYXkoaSkpO1xuICByZXR1cm4gYmEuZ2V0KG9mcyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfdWludDhfZ2V0MTZcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfYmFfdWludDhfZ2V0MTYoYmEsIGkwKSB7XG4gIHZhciBvZnMgPSBiYS5vZmZzZXQoaTApO1xuICBpZihvZnMgKyAxID49IGJhLmRhdGEubGVuZ3RoKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHZhciBiMSA9IGJhLmdldChvZnMpO1xuICB2YXIgYjIgPSBiYS5nZXQob2ZzICsgMSk7XG4gIHJldHVybiAoYjEgfCAoYjIgPDwgOCkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3VpbnQ4X2dldDMyXG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX2JhX3VpbnQ4X2dldDMyKGJhLCBpMCkge1xuICB2YXIgb2ZzID0gYmEub2Zmc2V0KGkwKTtcbiAgaWYob2ZzICsgMyA+PSBiYS5kYXRhLmxlbmd0aCkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB2YXIgYjEgPSBiYS5nZXQob2ZzKzApO1xuICB2YXIgYjIgPSBiYS5nZXQob2ZzKzEpO1xuICB2YXIgYjMgPSBiYS5nZXQob2ZzKzIpO1xuICB2YXIgYjQgPSBiYS5nZXQob2ZzKzMpO1xuICByZXR1cm4gKCAoYjEgPDwgMCkgIHxcbiAgICAgICAgICAgKGIyIDw8IDgpICB8XG4gICAgICAgICAgIChiMyA8PCAxNikgfFxuICAgICAgICAgICAoYjQgPDwgMjQpICk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfdWludDhfZ2V0NjRcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3IsIGNhbWxfaW50NjRfb2ZfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYmFfdWludDhfZ2V0NjQoYmEsIGkwKSB7XG4gIHZhciBvZnMgPSBiYS5vZmZzZXQoaTApO1xuICBpZihvZnMgKyA3ID49IGJhLmRhdGEubGVuZ3RoKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHZhciBiMSA9IGJhLmdldChvZnMrMCk7XG4gIHZhciBiMiA9IGJhLmdldChvZnMrMSk7XG4gIHZhciBiMyA9IGJhLmdldChvZnMrMik7XG4gIHZhciBiNCA9IGJhLmdldChvZnMrMyk7XG4gIHZhciBiNSA9IGJhLmdldChvZnMrNCk7XG4gIHZhciBiNiA9IGJhLmdldChvZnMrNSk7XG4gIHZhciBiNyA9IGJhLmdldChvZnMrNik7XG4gIHZhciBiOCA9IGJhLmdldChvZnMrNyk7XG4gIHJldHVybiBjYW1sX2ludDY0X29mX2J5dGVzKFtiOCxiNyxiNixiNSxiNCxiMyxiMixiMV0pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2dldF8xXG5mdW5jdGlvbiBjYW1sX2JhX2dldF8xKGJhLCBpMCkge1xuICByZXR1cm4gYmEuZ2V0KGJhLm9mZnNldChpMCkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2dldF8yXG5mdW5jdGlvbiBjYW1sX2JhX2dldF8yKGJhLCBpMCwgaTEpIHtcbiAgcmV0dXJuIGJhLmdldChiYS5vZmZzZXQoW2kwLGkxXSkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2dldF8zXG5mdW5jdGlvbiBjYW1sX2JhX2dldF8zKGJhLCBpMCwgaTEsIGkyKSB7XG4gIHJldHVybiBiYS5nZXQoYmEub2Zmc2V0KFtpMCxpMSxpMl0pKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9zZXRfZ2VuZXJpY1xuLy9SZXF1aXJlczogY2FtbF9qc19mcm9tX2FycmF5XG5mdW5jdGlvbiBjYW1sX2JhX3NldF9nZW5lcmljKGJhLCBpLCB2KSB7XG4gIGJhLnNldChiYS5vZmZzZXQoY2FtbF9qc19mcm9tX2FycmF5KGkpKSwgdik7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfdWludDhfc2V0MTZcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfYmFfdWludDhfc2V0MTYoYmEsIGkwLCB2KSB7XG4gIHZhciBvZnMgPSBiYS5vZmZzZXQoaTApO1xuICBpZihvZnMgKyAxID49IGJhLmRhdGEubGVuZ3RoKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIGJhLnNldChvZnMrMCwgIHYgICAgICAgICYgMHhmZik7XG4gIGJhLnNldChvZnMrMSwgKHYgPj4+IDgpICYgMHhmZik7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3VpbnQ4X3NldDMyXG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX2JhX3VpbnQ4X3NldDMyKGJhLCBpMCwgdikge1xuICB2YXIgb2ZzID0gYmEub2Zmc2V0KGkwKTtcbiAgaWYob2ZzICsgMyA+PSBiYS5kYXRhLmxlbmd0aCkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICBiYS5zZXQob2ZzKzAsICB2ICAgICAgICAgJiAweGZmKTtcbiAgYmEuc2V0KG9mcysxLCAodiA+Pj4gOCkgICYgMHhmZik7XG4gIGJhLnNldChvZnMrMiwgKHYgPj4+IDE2KSAmIDB4ZmYpO1xuICBiYS5zZXQob2ZzKzMsICh2ID4+PiAyNCkgJiAweGZmKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfdWludDhfc2V0NjRcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3IsIGNhbWxfaW50NjRfdG9fYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYmFfdWludDhfc2V0NjQoYmEsIGkwLCB2KSB7XG4gIHZhciBvZnMgPSBiYS5vZmZzZXQoaTApO1xuICBpZihvZnMgKyA3ID49IGJhLmRhdGEubGVuZ3RoKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHZhciB2ID0gY2FtbF9pbnQ2NF90b19ieXRlcyh2KTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IDg7IGkrKykgYmEuc2V0KG9mcytpLCB2WzctaV0pXG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3NldF8xXG5mdW5jdGlvbiBjYW1sX2JhX3NldF8xKGJhLCBpMCwgdikge1xuICBiYS5zZXQoYmEub2Zmc2V0KGkwKSwgdik7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfc2V0XzJcbmZ1bmN0aW9uIGNhbWxfYmFfc2V0XzIoYmEsIGkwLCBpMSwgdikge1xuICBiYS5zZXQoYmEub2Zmc2V0KFtpMCxpMV0pLCB2KTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfc2V0XzNcbmZ1bmN0aW9uIGNhbWxfYmFfc2V0XzMoYmEsIGkwLCBpMSwgaTIsIHYpIHtcbiAgYmEuc2V0KGJhLm9mZnNldChbaTAsaTEsaTJdKSwgdik7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2ZpbGxcbmZ1bmN0aW9uIGNhbWxfYmFfZmlsbChiYSwgdikge1xuICBiYS5maWxsKHYpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9ibGl0XG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfYmFfYmxpdChzcmMsIGRzdCkge1xuICBpZiAoZHN0LmRpbXMubGVuZ3RoICE9IHNyYy5kaW1zLmxlbmd0aClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5ibGl0OiBkaW1lbnNpb24gbWlzbWF0Y2hcIik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZHN0LmRpbXMubGVuZ3RoOyBpKyspXG4gICAgaWYgKGRzdC5kaW1zW2ldICE9IHNyYy5kaW1zW2ldKVxuICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkuYmxpdDogZGltZW5zaW9uIG1pc21hdGNoXCIpO1xuICBkc3QuZGF0YS5zZXQoc3JjLmRhdGEpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9zdWJcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9iYV9jcmVhdGVfdW5zYWZlLCBjYW1sX2JhX2dldF9zaXplXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50XG5mdW5jdGlvbiBjYW1sX2JhX3N1YihiYSwgb2ZzLCBsZW4pIHtcbiAgdmFyIGNoYW5nZWRfZGltO1xuICB2YXIgbXVsID0gMTtcbiAgaWYgKGJhLmxheW91dCA9PSAwKSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBiYS5kaW1zLmxlbmd0aDsgaSsrKVxuICAgICAgbXVsID0gbXVsICogYmEuZGltc1tpXTtcbiAgICBjaGFuZ2VkX2RpbSA9IDA7XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAoYmEuZGltcy5sZW5ndGggLSAxKTsgaSsrKVxuICAgICAgbXVsID0gbXVsICogYmEuZGltc1tpXTtcbiAgICBjaGFuZ2VkX2RpbSA9IGJhLmRpbXMubGVuZ3RoIC0gMTtcbiAgICBvZnMgPSBvZnMgLSAxO1xuICB9XG4gIGlmIChvZnMgPCAwIHx8IGxlbiA8IDAgfHwgKG9mcyArIGxlbikgPiBiYS5kaW1zW2NoYW5nZWRfZGltXSl7XG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkuc3ViOiBiYWQgc3ViLWFycmF5XCIpO1xuICB9XG4gIHZhciBuZXdfZGltcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJhLmRpbXMubGVuZ3RoOyBpKyspXG4gICAgbmV3X2RpbXNbaV0gPSBiYS5kaW1zW2ldO1xuICBuZXdfZGltc1tjaGFuZ2VkX2RpbV0gPSBsZW47XG4gIG11bCAqPSBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50KGJhLmtpbmQpO1xuICB2YXIgbmV3X2RhdGEgPSBiYS5kYXRhLnN1YmFycmF5KG9mcyAqIG11bCwgKG9mcyArIGxlbikgKiBtdWwpO1xuICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGJhLmtpbmQsIGJhLmxheW91dCwgbmV3X2RpbXMsIG5ld19kYXRhKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9zbGljZVxuLy9SZXF1aXJlczogY2FtbF9qc19mcm9tX2FycmF5LCBjYW1sX2JhX2NyZWF0ZV91bnNhZmUsIGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9iYV9nZXRfc2l6ZVxuLy9SZXF1aXJlczogY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudFxuZnVuY3Rpb24gY2FtbF9iYV9zbGljZShiYSwgdmluZCkge1xuICB2aW5kID0gY2FtbF9qc19mcm9tX2FycmF5KHZpbmQpO1xuICB2YXIgbnVtX2luZHMgPSB2aW5kLmxlbmd0aDtcbiAgdmFyIGluZGV4ID0gW107XG4gIHZhciBzdWJfZGltcyA9IFtdO1xuICB2YXIgb2ZzO1xuXG4gIGlmIChudW1faW5kcyA+IGJhLmRpbXMubGVuZ3RoKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LnNsaWNlOiB0b28gbWFueSBpbmRpY2VzXCIpO1xuXG4gIC8vIENvbXB1dGUgb2Zmc2V0IGFuZCBjaGVjayBib3VuZHNcbiAgaWYgKGJhLmxheW91dCA9PSAwKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1faW5kczsgaSsrKVxuICAgICAgaW5kZXhbaV0gPSB2aW5kW2ldO1xuICAgIGZvciAoOyBpIDwgYmEuZGltcy5sZW5ndGg7IGkrKylcbiAgICAgIGluZGV4W2ldID0gMDtcbiAgICBzdWJfZGltcyA9IGJhLmRpbXMuc2xpY2UobnVtX2luZHMpO1xuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2luZHM7IGkrKylcbiAgICAgIGluZGV4W2JhLmRpbXMubGVuZ3RoIC0gbnVtX2luZHMgKyBpXSA9IHZpbmRbaV07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiYS5kaW1zLmxlbmd0aCAtIG51bV9pbmRzOyBpKyspXG4gICAgICBpbmRleFtpXSA9IDE7XG4gICAgc3ViX2RpbXMgPSBiYS5kaW1zLnNsaWNlKDAsIGJhLmRpbXMubGVuZ3RoIC0gbnVtX2luZHMpO1xuICB9XG4gIG9mcyA9IGJhLm9mZnNldChpbmRleCk7XG4gIHZhciBzaXplID0gY2FtbF9iYV9nZXRfc2l6ZShzdWJfZGltcyk7XG4gIHZhciBzaXplX3Blcl9lbGVtZW50ID0gY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudChiYS5raW5kKTtcbiAgdmFyIG5ld19kYXRhID0gYmEuZGF0YS5zdWJhcnJheShvZnMgKiBzaXplX3Blcl9lbGVtZW50LCAob2ZzICsgc2l6ZSkgKiBzaXplX3Blcl9lbGVtZW50KTtcbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZShiYS5raW5kLCBiYS5sYXlvdXQsIHN1Yl9kaW1zLCBuZXdfZGF0YSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfcmVzaGFwZVxuLy9SZXF1aXJlczogY2FtbF9qc19mcm9tX2FycmF5LCBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZSwgY2FtbF9iYV9nZXRfc2l6ZVxuZnVuY3Rpb24gY2FtbF9iYV9yZXNoYXBlKGJhLCB2aW5kKSB7XG4gIHZpbmQgPSBjYW1sX2pzX2Zyb21fYXJyYXkodmluZCk7XG4gIHZhciBuZXdfZGltID0gW107XG4gIHZhciBudW1fZGltcyA9IHZpbmQubGVuZ3RoO1xuXG4gIGlmIChudW1fZGltcyA8IDAgfHwgbnVtX2RpbXMgPiAxNil7XG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkucmVzaGFwZTogYmFkIG51bWJlciBvZiBkaW1lbnNpb25zXCIpO1xuICB9XG4gIHZhciBudW1fZWx0cyA9IDE7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2RpbXM7IGkrKykge1xuICAgIG5ld19kaW1baV0gPSB2aW5kW2ldO1xuICAgIGlmIChuZXdfZGltW2ldIDwgMClcbiAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LnJlc2hhcGU6IG5lZ2F0aXZlIGRpbWVuc2lvblwiKTtcbiAgICBudW1fZWx0cyA9IG51bV9lbHRzICogbmV3X2RpbVtpXTtcbiAgfVxuXG4gIHZhciBzaXplID0gY2FtbF9iYV9nZXRfc2l6ZShiYS5kaW1zKTtcbiAgLy8gQ2hlY2sgdGhhdCBzaXplcyBhZ3JlZVxuICBpZiAobnVtX2VsdHMgIT0gc2l6ZSlcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5yZXNoYXBlOiBzaXplIG1pc21hdGNoXCIpO1xuICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGJhLmtpbmQsIGJhLmxheW91dCwgbmV3X2RpbSwgYmEuZGF0YSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfc2VyaWFsaXplXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQsIGNhbWxfaW50NjRfdG9fYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfaW50MzJfYml0c19vZl9mbG9hdFxuZnVuY3Rpb24gY2FtbF9iYV9zZXJpYWxpemUod3JpdGVyLCBiYSwgc3opIHtcbiAgd3JpdGVyLndyaXRlKDMyLCBiYS5kaW1zLmxlbmd0aCk7XG4gIHdyaXRlci53cml0ZSgzMiwgKGJhLmtpbmQgfCAoYmEubGF5b3V0IDw8IDgpKSk7XG4gIGlmKGJhLmNhbWxfY3VzdG9tID09IFwiX2JpZ2FycjAyXCIpXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRpbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmKGJhLmRpbXNbaV0gPCAweGZmZmYpXG4gICAgICAgIHdyaXRlci53cml0ZSgxNiwgYmEuZGltc1tpXSk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgd3JpdGVyLndyaXRlKDE2LCAweGZmZmYpO1xuICAgICAgICB3cml0ZXIud3JpdGUoMzIsIDApO1xuICAgICAgICB3cml0ZXIud3JpdGUoMzIsIGJhLmRpbXNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgZWxzZVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kaW1zLmxlbmd0aDsgaSsrKSB3cml0ZXIud3JpdGUoMzIsYmEuZGltc1tpXSlcbiAgc3dpdGNoKGJhLmtpbmQpe1xuICBjYXNlIDI6ICAvL0ludDhBcnJheVxuICBjYXNlIDM6ICAvL1VpbnQ4QXJyYXlcbiAgY2FzZSAxMjogLy9VaW50OEFycmF5XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRhdGEubGVuZ3RoOyBpKyspe1xuICAgICAgd3JpdGVyLndyaXRlKDgsIGJhLmRhdGFbaV0pO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSA0OiAgLy8gSW50MTZBcnJheVxuICBjYXNlIDU6ICAvLyBVaW50MTZBcnJheVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kYXRhLmxlbmd0aDsgaSsrKXtcbiAgICAgIHdyaXRlci53cml0ZSgxNiwgYmEuZGF0YVtpXSk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDY6ICAvLyBJbnQzMkFycmF5IChpbnQzMilcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGF0YS5sZW5ndGg7IGkrKyl7XG4gICAgICB3cml0ZXIud3JpdGUoMzIsIGJhLmRhdGFbaV0pO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSA4OiAgLy8gSW50MzJBcnJheSAoaW50KVxuICBjYXNlIDk6ICAvLyBJbnQzMkFycmF5IChuYXRpdmVpbnQpXG4gICAgd3JpdGVyLndyaXRlKDgsMCk7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRhdGEubGVuZ3RoOyBpKyspe1xuICAgICAgd3JpdGVyLndyaXRlKDMyLCBiYS5kYXRhW2ldKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgNzogIC8vIEludDMyQXJyYXkgKGludDY0KVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kYXRhLmxlbmd0aCAvIDI7IGkrKyl7XG4gICAgICB2YXIgYiA9IGNhbWxfaW50NjRfdG9fYnl0ZXMoYmEuZ2V0KGkpKTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgODsgaisrKSB3cml0ZXIud3JpdGUgKDgsIGJbal0pO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAxOiAgLy8gRmxvYXQ2NEFycmF5XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRhdGEubGVuZ3RoOyBpKyspe1xuICAgICAgdmFyIGIgPSBjYW1sX2ludDY0X3RvX2J5dGVzKGNhbWxfaW50NjRfYml0c19vZl9mbG9hdChiYS5nZXQoaSkpKTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgODsgaisrKSB3cml0ZXIud3JpdGUgKDgsIGJbal0pO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAwOiAgLy8gRmxvYXQzMkFycmF5XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRhdGEubGVuZ3RoOyBpKyspe1xuICAgICAgdmFyIGIgPSBjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXQoYmEuZ2V0KGkpKTtcbiAgICAgIHdyaXRlci53cml0ZSgzMiwgYik7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDEwOiAvLyBGbG9hdDMyQXJyYXkgKGNvbXBsZXgzMilcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGF0YS5sZW5ndGggLyAyOyBpKyspe1xuICAgICAgdmFyIGogPSBiYS5nZXQoaSk7XG4gICAgICB3cml0ZXIud3JpdGUoMzIsIGNhbWxfaW50MzJfYml0c19vZl9mbG9hdChqWzFdKSk7XG4gICAgICB3cml0ZXIud3JpdGUoMzIsIGNhbWxfaW50MzJfYml0c19vZl9mbG9hdChqWzJdKSk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDExOiAvLyBGbG9hdDY0QXJyYXkgKGNvbXBsZXg2NClcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGF0YS5sZW5ndGggLyAyOyBpKyspe1xuICAgICAgdmFyIGNvbXBsZXggPSBiYS5nZXQoaSk7XG4gICAgICB2YXIgYiA9IGNhbWxfaW50NjRfdG9fYnl0ZXMoY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0KGNvbXBsZXhbMV0pKTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgODsgaisrKSB3cml0ZXIud3JpdGUgKDgsIGJbal0pO1xuICAgICAgdmFyIGIgPSBjYW1sX2ludDY0X3RvX2J5dGVzKGNhbWxfaW50NjRfYml0c19vZl9mbG9hdChjb21wbGV4WzJdKSk7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDg7IGorKykgd3JpdGVyLndyaXRlICg4LCBiW2pdKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIH1cbiAgc3pbMF0gPSAoNCArIGJhLmRpbXMubGVuZ3RoKSAqIDQ7XG4gIHN6WzFdID0gKDQgKyBiYS5kaW1zLmxlbmd0aCkgKiA4O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2Rlc2VyaWFsaXplXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUsIGNhbWxfZmFpbHdpdGhcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZ2V0X3NpemVcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfYnl0ZXMsIGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0c1xuLy9SZXF1aXJlczogY2FtbF9pbnQzMl9mbG9hdF9vZl9iaXRzXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2NyZWF0ZV9idWZmZXJcbmZ1bmN0aW9uIGNhbWxfYmFfZGVzZXJpYWxpemUocmVhZGVyLCBzeiwgbmFtZSl7XG4gIHZhciBudW1fZGltcyA9IHJlYWRlci5yZWFkMzJzKCk7XG4gIGlmIChudW1fZGltcyA8IDAgfHwgbnVtX2RpbXMgPiAxNilcbiAgICBjYW1sX2ZhaWx3aXRoKFwiaW5wdXRfdmFsdWU6IHdyb25nIG51bWJlciBvZiBiaWdhcnJheSBkaW1lbnNpb25zXCIpO1xuICB2YXIgdGFnID0gcmVhZGVyLnJlYWQzMnMoKTtcbiAgdmFyIGtpbmQgPSB0YWcgJiAweGZmXG4gIHZhciBsYXlvdXQgPSAodGFnID4+IDgpICYgMTtcbiAgdmFyIGRpbXMgPSBbXVxuICBpZihuYW1lID09IFwiX2JpZ2FycjAyXCIpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1fZGltczsgaSsrKSB7XG4gICAgICB2YXIgc2l6ZV9kaW0gPSByZWFkZXIucmVhZDE2dSgpO1xuICAgICAgaWYoc2l6ZV9kaW0gPT0gMHhmZmZmKXtcbiAgICAgICAgdmFyIHNpemVfZGltX2hpID0gcmVhZGVyLnJlYWQzMnUoKTtcbiAgICAgICAgdmFyIHNpemVfZGltX2xvID0gcmVhZGVyLnJlYWQzMnUoKTtcbiAgICAgICAgaWYoc2l6ZV9kaW1faGkgIT0gMClcbiAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwiaW5wdXRfdmFsdWU6IGJpZ2FycmF5IGRpbWVuc2lvbiBvdmVyZmxvdyBpbiAzMmJpdFwiKTtcbiAgICAgICAgc2l6ZV9kaW0gPSBzaXplX2RpbV9sbztcbiAgICAgIH1cbiAgICAgIGRpbXMucHVzaChzaXplX2RpbSk7XG4gICAgfVxuICBlbHNlXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1fZGltczsgaSsrKSBkaW1zLnB1c2gocmVhZGVyLnJlYWQzMnUoKSk7XG4gIHZhciBzaXplID0gY2FtbF9iYV9nZXRfc2l6ZShkaW1zKTtcbiAgdmFyIGRhdGEgPSBjYW1sX2JhX2NyZWF0ZV9idWZmZXIoa2luZCwgc2l6ZSk7XG4gIHZhciBiYSA9IGNhbWxfYmFfY3JlYXRlX3Vuc2FmZShraW5kLCBsYXlvdXQsIGRpbXMsIGRhdGEpO1xuICBzd2l0Y2goa2luZCl7XG4gIGNhc2UgMjogIC8vSW50OEFycmF5XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICBkYXRhW2ldID0gcmVhZGVyLnJlYWQ4cygpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAzOiAgLy9VaW50OEFycmF5XG4gIGNhc2UgMTI6IC8vVWludDhBcnJheVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspe1xuICAgICAgZGF0YVtpXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgNDogIC8vIEludDE2QXJyYXlcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIGRhdGFbaV0gPSByZWFkZXIucmVhZDE2cygpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSA1OiAgLy8gVWludDE2QXJyYXlcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIGRhdGFbaV0gPSByZWFkZXIucmVhZDE2dSgpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSA2OiAgLy8gSW50MzJBcnJheSAoaW50MzIpXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICBkYXRhW2ldID0gcmVhZGVyLnJlYWQzMnMoKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgODogIC8vIEludDMyQXJyYXkgKGludClcbiAgY2FzZSA5OiAgLy8gSW50MzJBcnJheSAobmF0aXZlaW50KVxuICAgIHZhciBzaXh0eSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICBpZihzaXh0eSkgY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiBjYW5ub3QgcmVhZCBiaWdhcnJheSB3aXRoIDY0LWJpdCBPQ2FtbCBpbnRzXCIpO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspe1xuICAgICAgZGF0YVtpXSA9IHJlYWRlci5yZWFkMzJzKCk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDc6IC8vIChpbnQ2NClcbiAgICB2YXIgdCA9IG5ldyBBcnJheSg4KTs7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICBmb3IgKHZhciBqID0gMDtqIDwgODtqKyspIHRbal0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICB2YXIgaW50NjQgPSBjYW1sX2ludDY0X29mX2J5dGVzKHQpO1xuICAgICAgYmEuc2V0KGksaW50NjQpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAxOiAgLy8gRmxvYXQ2NEFycmF5XG4gICAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7O1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspe1xuICAgICAgZm9yICh2YXIgaiA9IDA7aiA8IDg7aisrKSB0W2pdID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgdmFyIGYgPSBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMoY2FtbF9pbnQ2NF9vZl9ieXRlcyh0KSk7XG4gICAgICBiYS5zZXQoaSxmKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMDogIC8vIEZsb2F0MzJBcnJheVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspe1xuICAgICAgdmFyIGYgPSBjYW1sX2ludDMyX2Zsb2F0X29mX2JpdHMocmVhZGVyLnJlYWQzMnMoKSk7XG4gICAgICBiYS5zZXQoaSxmKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMTA6IC8vIEZsb2F0MzJBcnJheSAoY29tcGxleDMyKVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspe1xuICAgICAgdmFyIHJlID0gY2FtbF9pbnQzMl9mbG9hdF9vZl9iaXRzKHJlYWRlci5yZWFkMzJzKCkpO1xuICAgICAgdmFyIGltID0gY2FtbF9pbnQzMl9mbG9hdF9vZl9iaXRzKHJlYWRlci5yZWFkMzJzKCkpO1xuICAgICAgYmEuc2V0KGksWzI1NCxyZSxpbV0pO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAxMTogLy8gRmxvYXQ2NEFycmF5IChjb21wbGV4NjQpXG4gICAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7O1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspe1xuICAgICAgZm9yICh2YXIgaiA9IDA7aiA8IDg7aisrKSB0W2pdID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgdmFyIHJlID0gY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzKGNhbWxfaW50NjRfb2ZfYnl0ZXModCkpO1xuICAgICAgZm9yICh2YXIgaiA9IDA7aiA8IDg7aisrKSB0W2pdID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgdmFyIGltID0gY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzKGNhbWxfaW50NjRfb2ZfYnl0ZXModCkpO1xuICAgICAgYmEuc2V0KGksWzI1NCxyZSxpbV0pO1xuICAgIH1cbiAgICBicmVha1xuICB9XG4gIHN6WzBdID0gKDQgKyBudW1fZGltcykgKiA0O1xuICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGtpbmQsIGxheW91dCwgZGltcywgZGF0YSk7XG59XG5cbi8vRGVwcmVjYXRlZFxuLy9Qcm92aWRlczogY2FtbF9iYV9jcmVhdGVfZnJvbVxuLy9SZXF1aXJlczogY2FtbF9iYV9jcmVhdGVfdW5zYWZlLCBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnRcbmZ1bmN0aW9uIGNhbWxfYmFfY3JlYXRlX2Zyb20oZGF0YTEsIGRhdGEyLCBqc3R5cCwga2luZCwgbGF5b3V0LCBkaW1zKXtcbiAgaWYoZGF0YTIgfHwgY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudChraW5kKSA9PSAyKXtcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJjYW1sX2JhX2NyZWF0ZV9mcm9tOiB1c2UgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZVwiKTtcbiAgfVxuICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGtpbmQsIGxheW91dCwgZGltcywgZGF0YTEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2hhc2ggY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZ2V0X3NpemUsIGNhbWxfaGFzaF9taXhfaW50LCBjYW1sX2hhc2hfbWl4X2Zsb2F0XG5mdW5jdGlvbiBjYW1sX2JhX2hhc2goYmEpe1xuICB2YXIgbnVtX2VsdHMgPSBjYW1sX2JhX2dldF9zaXplKGJhLmRpbXMpO1xuICB2YXIgaCA9IDA7XG4gIHN3aXRjaChiYS5raW5kKXtcbiAgY2FzZSAyOiAgLy9JbnQ4QXJyYXlcbiAgY2FzZSAzOiAgLy9VaW50OEFycmF5XG4gIGNhc2UgMTI6IC8vVWludDhBcnJheVxuICAgIGlmKG51bV9lbHRzID4gMjU2KSBudW1fZWx0cyA9IDI1NjtcbiAgICB2YXIgdyA9IDAsIGkgPTA7XG4gICAgZm9yKGkgPSAwOyBpICsgNCA8PSBiYS5kYXRhLmxlbmd0aDsgaSs9NCl7XG4gICAgICB3ID0gYmEuZGF0YVtpKzBdIHwgKGJhLmRhdGFbaSsxXSA8PCA4KSB8IChiYS5kYXRhW2krMl0gPDwgMTYpIHwgKGJhLmRhdGFbaSszXSA8PCAyNCk7XG4gICAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCx3KTtcbiAgICB9XG4gICAgdyA9IDA7XG4gICAgc3dpdGNoIChudW1fZWx0cyAmIDMpIHtcbiAgICBjYXNlIDM6IHcgID0gYmEuZGF0YVtpKzJdIDw8IDE2OyAgICAvKiBmYWxsdGhyb3VnaCAqL1xuICAgIGNhc2UgMjogdyB8PSBiYS5kYXRhW2krMV0gPDwgODsgICAgIC8qIGZhbGx0aHJvdWdoICovXG4gICAgY2FzZSAxOiB3IHw9IGJhLmRhdGFbaSswXTtcbiAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCB3KTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgNDogIC8vIEludDE2QXJyYXlcbiAgY2FzZSA1OiAgLy8gVWludDE2QXJyYXlcbiAgICBpZihudW1fZWx0cyA+IDEyOCkgbnVtX2VsdHMgPSAxMjg7XG4gICAgdmFyIHcgPSAwLCBpID0wO1xuICAgIGZvcihpID0gMDsgaSArIDIgPD0gYmEuZGF0YS5sZW5ndGg7IGkrPTIpe1xuICAgICAgdyA9IGJhLmRhdGFbaSswXSB8IChiYS5kYXRhW2krMV0gPDwgMTYpO1xuICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsdyk7XG4gICAgfVxuICAgIGlmICgobnVtX2VsdHMgJiAxKSAhPSAwKVxuICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIGJhLmRhdGFbaV0pO1xuICAgIGJyZWFrO1xuICBjYXNlIDY6ICAvLyBJbnQzMkFycmF5IChpbnQzMilcbiAgICBpZiAobnVtX2VsdHMgPiA2NCkgbnVtX2VsdHMgPSA2NDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9lbHRzOyBpKyspIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCBiYS5kYXRhW2ldKTtcbiAgICBicmVhaztcbiAgY2FzZSA4OiAgLy8gSW50MzJBcnJheSAoaW50KVxuICBjYXNlIDk6ICAvLyBJbnQzMkFycmF5IChuYXRpdmVpbnQpXG4gICAgaWYgKG51bV9lbHRzID4gNjQpIG51bV9lbHRzID0gNjQ7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1fZWx0czsgaSsrKSBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgYmEuZGF0YVtpXSk7XG4gICAgYnJlYWs7XG4gIGNhc2UgNzogIC8vIEludDMyQXJyYXkgKGludDY0KVxuICAgIGlmIChudW1fZWx0cyA+IDMyKSBudW1fZWx0cyA9IDMyO1xuICAgIG51bV9lbHRzICo9IDJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9lbHRzOyBpKyspIHtcbiAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCBiYS5kYXRhW2ldKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMTA6IC8vIEZsb2F0MzJBcnJheSAoY29tcGxleDMyKVxuICAgIG51bV9lbHRzICo9MjsgLyogZmFsbHRocm91Z2ggKi9cbiAgY2FzZSAwOiAgLy8gRmxvYXQzMkFycmF5XG4gICAgaWYgKG51bV9lbHRzID4gNjQpIG51bV9lbHRzID0gNjQ7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1fZWx0czsgaSsrKSBoID0gY2FtbF9oYXNoX21peF9mbG9hdChoLCBiYS5kYXRhW2ldKTtcbiAgICBicmVhaztcbiAgY2FzZSAxMTogLy8gRmxvYXQ2NEFycmF5IChjb21wbGV4NjQpXG4gICAgbnVtX2VsdHMgKj0yOyAvKiBmYWxsdGhyb3VnaCAqL1xuICBjYXNlIDE6ICAvLyBGbG9hdDY0QXJyYXlcbiAgICBpZiAobnVtX2VsdHMgPiAzMikgbnVtX2VsdHMgPSAzMjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9lbHRzOyBpKyspIGggPSBjYW1sX2hhc2hfbWl4X2Zsb2F0KGgsIGJhLmRhdGFbaV0pO1xuICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiBoO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3RvX3R5cGVkX2FycmF5IG11dGFibGVcbmZ1bmN0aW9uIGNhbWxfYmFfdG9fdHlwZWRfYXJyYXkoYmEpe1xuICByZXR1cm4gYmEuZGF0YTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9raW5kX29mX3R5cGVkX2FycmF5IG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9iYV9raW5kX29mX3R5cGVkX2FycmF5KHRhKXtcbiAgdmFyIGtpbmQ7XG4gIGlmICAgICAgKHRhIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KSBraW5kID0gMDtcbiAgZWxzZSBpZiAodGEgaW5zdGFuY2VvZiBGbG9hdDY0QXJyYXkpIGtpbmQgPSAxO1xuICBlbHNlIGlmICh0YSBpbnN0YW5jZW9mIEludDhBcnJheSkga2luZCA9IDI7XG4gIGVsc2UgaWYgKHRhIGluc3RhbmNlb2YgVWludDhBcnJheSkga2luZCA9IDM7XG4gIGVsc2UgaWYgKHRhIGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXkpIGtpbmQgPSAzO1xuICBlbHNlIGlmICh0YSBpbnN0YW5jZW9mIEludDE2QXJyYXkpIGtpbmQgPSA0O1xuICBlbHNlIGlmICh0YSBpbnN0YW5jZW9mIFVpbnQxNkFycmF5KSBraW5kID0gNTtcbiAgZWxzZSBpZiAodGEgaW5zdGFuY2VvZiBJbnQzMkFycmF5KSBraW5kID0gNjtcbiAgZWxzZSBpZiAodGEgaW5zdGFuY2VvZiBVaW50MzJBcnJheSkga2luZCA9IDY7XG4gIGVsc2UgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY2FtbF9iYV9raW5kX29mX3R5cGVkX2FycmF5OiB1bnN1cHBvcnRlZCBraW5kXCIpO1xuICByZXR1cm4ga2luZDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9mcm9tX3R5cGVkX2FycmF5IG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfYmFfa2luZF9vZl90eXBlZF9hcnJheVxuLy9SZXF1aXJlczogY2FtbF9iYV9jcmVhdGVfdW5zYWZlXG5mdW5jdGlvbiBjYW1sX2JhX2Zyb21fdHlwZWRfYXJyYXkodGEpe1xuICB2YXIga2luZCA9IGNhbWxfYmFfa2luZF9vZl90eXBlZF9hcnJheSh0YSk7XG4gIHZhciB0YSA9XG4gICAgICAvKiBOZWVkZWQgdG8gYXZvaWQgdW5zaWduZWQgc2V0dGVycyBvdmVyZmxvd2luZ1xuICAgICAgICAgdGhlIHJhbmdlIG9mIE9DYW1sIFtpbnQzMl0gdmFsdWVzLiAqL1xuICAgICAgdGEgaW5zdGFuY2VvZiBVaW50MzJBcnJheSA/XG4gICAgICBuZXcgSW50MzJBcnJheSh0YS5idWZmZXIgLHRhLmJ5dGVPZmZzZXQsIHRhLmxlbmd0aCkgOiB0YTtcbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZShraW5kLCAwLCBbdGEubGVuZ3RoXSwgdGEpO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwIErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWFyc2hhbF9jb25zdGFudHNcbnZhciBjYW1sX21hcnNoYWxfY29uc3RhbnRzID0ge1xuICBQUkVGSVhfU01BTExfQkxPQ0s6ICAgICAgICAgMHg4MCxcbiAgUFJFRklYX1NNQUxMX0lOVDogICAgICAgICAgIDB4NDAsXG4gIFBSRUZJWF9TTUFMTF9TVFJJTkc6ICAgICAgICAweDIwLFxuICBDT0RFX0lOVDg6ICAgICAgICAgICAgICAgICAgMHgwMCxcbiAgQ09ERV9JTlQxNjogICAgICAgICAgICAgICAgIDB4MDEsXG4gIENPREVfSU5UMzI6ICAgICAgICAgICAgICAgICAweDAyLFxuICBDT0RFX0lOVDY0OiAgICAgICAgICAgICAgICAgMHgwMyxcbiAgQ09ERV9TSEFSRUQ4OiAgICAgICAgICAgICAgIDB4MDQsXG4gIENPREVfU0hBUkVEMTY6ICAgICAgICAgICAgICAweDA1LFxuICBDT0RFX1NIQVJFRDMyOiAgICAgICAgICAgICAgMHgwNixcbiAgQ09ERV9CTE9DSzMyOiAgICAgICAgICAgICAgIDB4MDgsXG4gIENPREVfQkxPQ0s2NDogICAgICAgICAgICAgICAweDEzLFxuICBDT0RFX1NUUklORzg6ICAgICAgICAgICAgICAgMHgwOSxcbiAgQ09ERV9TVFJJTkczMjogICAgICAgICAgICAgIDB4MEEsXG4gIENPREVfRE9VQkxFX0JJRzogICAgICAgICAgICAweDBCLFxuICBDT0RFX0RPVUJMRV9MSVRUTEU6ICAgICAgICAgMHgwQyxcbiAgQ09ERV9ET1VCTEVfQVJSQVk4X0JJRzogICAgIDB4MEQsXG4gIENPREVfRE9VQkxFX0FSUkFZOF9MSVRUTEU6ICAweDBFLFxuICBDT0RFX0RPVUJMRV9BUlJBWTMyX0JJRzogICAgMHgwRixcbiAgQ09ERV9ET1VCTEVfQVJSQVkzMl9MSVRUTEU6IDB4MDcsXG4gIENPREVfQ09ERVBPSU5URVI6ICAgICAgICAgICAweDEwLFxuICBDT0RFX0lORklYUE9JTlRFUjogICAgICAgICAgMHgxMSxcbiAgQ09ERV9DVVNUT006ICAgICAgICAgICAgICAgIDB4MTIsXG4gIENPREVfQ1VTVE9NX0xFTjogICAgICAgICAgICAweDE4LFxuICBDT0RFX0NVU1RPTV9GSVhFRDogICAgICAgICAgMHgxOVxufVxuXG5cbi8vUHJvdmlkZXM6IFVJbnQ4QXJyYXlSZWFkZXJcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2FycmF5LCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBVSW50OEFycmF5UmVhZGVyIChzLCBpKSB7IHRoaXMucyA9IHM7IHRoaXMuaSA9IGk7IH1cblVJbnQ4QXJyYXlSZWFkZXIucHJvdG90eXBlID0ge1xuICByZWFkOHU6ZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5zW3RoaXMuaSsrXTsgfSxcbiAgcmVhZDhzOmZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuc1t0aGlzLmkrK10gPDwgMjQgPj4gMjQ7IH0sXG4gIHJlYWQxNnU6ZnVuY3Rpb24gKCkge1xuICAgIHZhciBzID0gdGhpcy5zLCBpID0gdGhpcy5pO1xuICAgIHRoaXMuaSA9IGkgKyAyO1xuICAgIHJldHVybiAoc1tpXSA8PCA4KSB8IHNbaSArIDFdXG4gIH0sXG4gIHJlYWQxNnM6ZnVuY3Rpb24gKCkge1xuICAgIHZhciBzID0gdGhpcy5zLCBpID0gdGhpcy5pO1xuICAgIHRoaXMuaSA9IGkgKyAyO1xuICAgIHJldHVybiAoc1tpXSA8PCAyNCA+PiAxNikgfCBzW2kgKyAxXTtcbiAgfSxcbiAgcmVhZDMydTpmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDQ7XG4gICAgcmV0dXJuICgoc1tpXSA8PCAyNCkgfCAoc1tpKzFdIDw8IDE2KSB8XG4gICAgICAgICAgICAoc1tpKzJdIDw8IDgpIHwgc1tpKzNdKSA+Pj4gMDtcbiAgfSxcbiAgcmVhZDMyczpmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDQ7XG4gICAgcmV0dXJuIChzW2ldIDw8IDI0KSB8IChzW2krMV0gPDwgMTYpIHxcbiAgICAgIChzW2krMl0gPDwgOCkgfCBzW2krM107XG4gIH0sXG4gIHJlYWRzdHI6ZnVuY3Rpb24gKGxlbikge1xuICAgIHZhciBpID0gdGhpcy5pO1xuICAgIHRoaXMuaSA9IGkgKyBsZW47XG4gICAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2FycmF5KHRoaXMucy5zdWJhcnJheShpLCBpICsgbGVuKSk7XG4gIH0sXG4gIHJlYWR1aW50OGFycmF5OmZ1bmN0aW9uIChsZW4pIHtcbiAgICB2YXIgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgbGVuO1xuICAgIHJldHVybiB0aGlzLnMuc3ViYXJyYXkoaSwgaSArIGxlbik7XG4gIH1cbn1cblxuXG4vL1Byb3ZpZGVzOiBNbFN0cmluZ1JlYWRlclxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlcywgY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gTWxTdHJpbmdSZWFkZXIgKHMsIGkpIHsgdGhpcy5zID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhzKTsgdGhpcy5pID0gaTsgfVxuTWxTdHJpbmdSZWFkZXIucHJvdG90eXBlID0ge1xuICByZWFkOHU6ZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5zLmNoYXJDb2RlQXQodGhpcy5pKyspOyB9LFxuICByZWFkOHM6ZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5zLmNoYXJDb2RlQXQodGhpcy5pKyspIDw8IDI0ID4+IDI0OyB9LFxuICByZWFkMTZ1OmZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IHRoaXMucywgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgMjtcbiAgICByZXR1cm4gKHMuY2hhckNvZGVBdChpKSA8PCA4KSB8IHMuY2hhckNvZGVBdChpICsgMSlcbiAgfSxcbiAgcmVhZDE2czpmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDI7XG4gICAgcmV0dXJuIChzLmNoYXJDb2RlQXQoaSkgPDwgMjQgPj4gMTYpIHwgcy5jaGFyQ29kZUF0KGkgKyAxKTtcbiAgfSxcbiAgcmVhZDMydTpmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDQ7XG4gICAgcmV0dXJuICgocy5jaGFyQ29kZUF0KGkpIDw8IDI0KSB8IChzLmNoYXJDb2RlQXQoaSsxKSA8PCAxNikgfFxuICAgICAgICAgICAgKHMuY2hhckNvZGVBdChpKzIpIDw8IDgpIHwgcy5jaGFyQ29kZUF0KGkrMykpID4+PiAwO1xuICB9LFxuICByZWFkMzJzOmZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IHRoaXMucywgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgNDtcbiAgICByZXR1cm4gKHMuY2hhckNvZGVBdChpKSA8PCAyNCkgfCAocy5jaGFyQ29kZUF0KGkrMSkgPDwgMTYpIHxcbiAgICAgIChzLmNoYXJDb2RlQXQoaSsyKSA8PCA4KSB8IHMuY2hhckNvZGVBdChpKzMpO1xuICB9LFxuICByZWFkc3RyOmZ1bmN0aW9uIChsZW4pIHtcbiAgICB2YXIgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgbGVuO1xuICAgIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKHRoaXMucy5zdWJzdHJpbmcoaSwgaSArIGxlbikpO1xuICB9LFxuICByZWFkdWludDhhcnJheTpmdW5jdGlvbiAobGVuKSB7XG4gICAgdmFyIGIgPSBuZXcgVWludDhBcnJheShsZW4pO1xuICAgIHZhciBzID0gdGhpcy5zO1xuICAgIHZhciBpID0gdGhpcy5pO1xuICAgIGZvcih2YXIgaiA9IDA7IGogPCBsZW47IGorKykge1xuICAgICAgYltqXSA9IHMuY2hhckNvZGVBdChpICsgaik7XG4gICAgfVxuICAgIHRoaXMuaSA9IGkgKyBsZW47XG4gICAgcmV0dXJuIGI7XG4gIH1cbn1cblxuLy9Qcm92aWRlczogQmlnU3RyaW5nUmVhZGVyXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9hcnJheSwgY2FtbF9iYV9nZXRfMVxuZnVuY3Rpb24gQmlnU3RyaW5nUmVhZGVyIChicywgaSkgeyB0aGlzLnMgPSBiczsgdGhpcy5pID0gaTsgfVxuQmlnU3RyaW5nUmVhZGVyLnByb3RvdHlwZSA9IHtcbiAgcmVhZDh1OmZ1bmN0aW9uICgpIHsgcmV0dXJuIGNhbWxfYmFfZ2V0XzEodGhpcy5zLHRoaXMuaSsrKTsgfSxcbiAgcmVhZDhzOmZ1bmN0aW9uICgpIHsgcmV0dXJuIGNhbWxfYmFfZ2V0XzEodGhpcy5zLHRoaXMuaSsrKSA8PCAyNCA+PiAyNDsgfSxcbiAgcmVhZDE2dTpmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDI7XG4gICAgcmV0dXJuIChjYW1sX2JhX2dldF8xKHMsaSkgPDwgOCkgfCBjYW1sX2JhX2dldF8xKHMsaSArIDEpXG4gIH0sXG4gIHJlYWQxNnM6ZnVuY3Rpb24gKCkge1xuICAgIHZhciBzID0gdGhpcy5zLCBpID0gdGhpcy5pO1xuICAgIHRoaXMuaSA9IGkgKyAyO1xuICAgIHJldHVybiAoY2FtbF9iYV9nZXRfMShzLGkpIDw8IDI0ID4+IDE2KSB8IGNhbWxfYmFfZ2V0XzEocyxpICsgMSk7XG4gIH0sXG4gIHJlYWQzMnU6ZnVuY3Rpb24gKCkge1xuICAgIHZhciBzID0gdGhpcy5zLCBpID0gdGhpcy5pO1xuICAgIHRoaXMuaSA9IGkgKyA0O1xuICAgIHJldHVybiAoKGNhbWxfYmFfZ2V0XzEocyxpKSAgIDw8IDI0KSB8IChjYW1sX2JhX2dldF8xKHMsaSsxKSA8PCAxNikgfFxuICAgICAgICAgICAgKGNhbWxfYmFfZ2V0XzEocyxpKzIpIDw8IDgpICB8IGNhbWxfYmFfZ2V0XzEocyxpKzMpICAgICAgICAgKSA+Pj4gMDtcbiAgfSxcbiAgcmVhZDMyczpmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDQ7XG4gICAgcmV0dXJuIChjYW1sX2JhX2dldF8xKHMsaSkgICA8PCAyNCkgfCAoY2FtbF9iYV9nZXRfMShzLGkrMSkgPDwgMTYpIHxcbiAgICAgIChjYW1sX2JhX2dldF8xKHMsaSsyKSA8PCA4KSAgfCBjYW1sX2JhX2dldF8xKHMsaSszKTtcbiAgfSxcbiAgcmVhZHN0cjpmdW5jdGlvbiAobGVuKSB7XG4gICAgdmFyIGkgPSB0aGlzLmk7XG4gICAgdmFyIGFyciA9IG5ldyBBcnJheShsZW4pXG4gICAgZm9yKHZhciBqID0gMDsgaiA8IGxlbjsgaisrKXtcbiAgICAgIGFycltqXSA9IGNhbWxfYmFfZ2V0XzEodGhpcy5zLCBpK2opO1xuICAgIH1cbiAgICB0aGlzLmkgPSBpICsgbGVuO1xuICAgIHJldHVybiBjYW1sX3N0cmluZ19vZl9hcnJheShhcnIpO1xuICB9LFxuICByZWFkdWludDhhcnJheTpmdW5jdGlvbiAobGVuKSB7XG4gICAgdmFyIGkgPSB0aGlzLmk7XG4gICAgdmFyIG9mZnNldCA9IHRoaXMub2Zmc2V0KGkpO1xuICAgIHRoaXMuaSA9IGkgKyBsZW47XG4gICAgcmV0dXJuIHRoaXMucy5kYXRhLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgfVxufVxuXG5cblxuLy9Qcm92aWRlczogY2FtbF9mbG9hdF9vZl9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzLCBjYW1sX2ludDY0X29mX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2Zsb2F0X29mX2J5dGVzIChhKSB7XG4gIHJldHVybiBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMgKGNhbWxfaW50NjRfb2ZfYnl0ZXMgKGEpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3N0cmluZyBtdXRhYmxlXG4vL1JlcXVpcmVzOiBNbFN0cmluZ1JlYWRlciwgY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3JlYWRlclxuZnVuY3Rpb24gY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3N0cmluZyhzLG9mcykge1xuICB2YXIgcmVhZGVyID0gbmV3IE1sU3RyaW5nUmVhZGVyIChzLCB0eXBlb2Ygb2ZzPT1cIm51bWJlclwiP29mczpvZnNbMF0pO1xuICByZXR1cm4gY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3JlYWRlcihyZWFkZXIsIG9mcylcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnB1dF92YWx1ZV9mcm9tX2J5dGVzIG11dGFibGVcbi8vUmVxdWlyZXM6IE1sU3RyaW5nUmVhZGVyLCBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fcmVhZGVyLCBjYW1sX3N0cmluZ19vZl9ieXRlc1xuZnVuY3Rpb24gY2FtbF9pbnB1dF92YWx1ZV9mcm9tX2J5dGVzKHMsb2ZzKSB7XG4gIHZhciByZWFkZXIgPSBuZXcgTWxTdHJpbmdSZWFkZXIgKGNhbWxfc3RyaW5nX29mX2J5dGVzKHMpLCB0eXBlb2Ygb2ZzPT1cIm51bWJlclwiP29mczpvZnNbMF0pO1xuICByZXR1cm4gY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3JlYWRlcihyZWFkZXIsIG9mcylcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF91bm1hcnNoYWxcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfaW50NjRfdW5tYXJzaGFsKHJlYWRlciwgc2l6ZSl7XG4gIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgZm9yICh2YXIgaiA9IDA7aiA8IDg7aisrKSB0W2pdID0gcmVhZGVyLnJlYWQ4dSgpO1xuICBzaXplWzBdID0gODtcbiAgcmV0dXJuIGNhbWxfaW50NjRfb2ZfYnl0ZXMgKHQpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X21hcnNoYWxcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfdG9fYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfaW50NjRfbWFyc2hhbCh3cml0ZXIsIHYsIHNpemVzKSB7XG4gIHZhciBiID0gY2FtbF9pbnQ2NF90b19ieXRlcyAodik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSsrKSB3cml0ZXIud3JpdGUgKDgsIGJbaV0pO1xuICBzaXplc1swXSA9IDg7IHNpemVzWzFdID0gODtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQzMl91bm1hcnNoYWxcbmZ1bmN0aW9uIGNhbWxfaW50MzJfdW5tYXJzaGFsKHJlYWRlciwgc2l6ZSl7XG4gIHNpemVbMF0gPSA0O1xuICByZXR1cm4gcmVhZGVyLnJlYWQzMnMgKCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbmF0aXZlaW50X3VubWFyc2hhbFxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9uYXRpdmVpbnRfdW5tYXJzaGFsKHJlYWRlciwgc2l6ZSl7XG4gIHN3aXRjaCAocmVhZGVyLnJlYWQ4dSAoKSkge1xuICBjYXNlIDE6XG4gICAgc2l6ZVswXSA9IDQ7XG4gICAgcmV0dXJuIHJlYWRlci5yZWFkMzJzICgpO1xuICBjYXNlIDI6XG4gICAgY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiBuYXRpdmUgaW50ZWdlciB2YWx1ZSB0b28gbGFyZ2VcIik7XG4gIGRlZmF1bHQ6IGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogaWxsLWZvcm1lZCBuYXRpdmUgaW50ZWdlclwiKTtcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2N1c3RvbV9vcHNcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfdW5tYXJzaGFsLCBjYW1sX2ludDY0X21hcnNoYWwsIGNhbWxfaW50NjRfY29tcGFyZSwgY2FtbF9pbnQ2NF9oYXNoXG4vL1JlcXVpcmVzOiBjYW1sX2ludDMyX3VubWFyc2hhbCwgY2FtbF9uYXRpdmVpbnRfdW5tYXJzaGFsXG4vL1JlcXVpcmVzOiBjYW1sX2JhX3NlcmlhbGl6ZSwgY2FtbF9iYV9kZXNlcmlhbGl6ZSwgY2FtbF9iYV9jb21wYXJlLCBjYW1sX2JhX2hhc2hcbnZhciBjYW1sX2N1c3RvbV9vcHMgPVxuICAgIHtcIl9qXCI6IHtcbiAgICAgIGRlc2VyaWFsaXplIDogY2FtbF9pbnQ2NF91bm1hcnNoYWwsXG4gICAgICBzZXJpYWxpemUgIDogY2FtbF9pbnQ2NF9tYXJzaGFsLFxuICAgICAgZml4ZWRfbGVuZ3RoIDogOCxcbiAgICAgIGNvbXBhcmUgOiBjYW1sX2ludDY0X2NvbXBhcmUsXG4gICAgICBoYXNoIDogY2FtbF9pbnQ2NF9oYXNoXG4gICAgfSxcbiAgICAgXCJfaVwiOiB7XG4gICAgICAgZGVzZXJpYWxpemUgOiBjYW1sX2ludDMyX3VubWFyc2hhbCxcbiAgICAgICBmaXhlZF9sZW5ndGggOiA0LFxuICAgICB9LFxuICAgICBcIl9uXCI6IHtcbiAgICAgICBkZXNlcmlhbGl6ZSA6IGNhbWxfbmF0aXZlaW50X3VubWFyc2hhbCxcbiAgICAgICBmaXhlZF9sZW5ndGggOiA0LFxuICAgICB9LFxuICAgICBcIl9iaWdhcnJheVwiOntcbiAgICAgICBkZXNlcmlhbGl6ZSA6IChmdW5jdGlvbiAocmVhZGVyLCBzeikge3JldHVybiBjYW1sX2JhX2Rlc2VyaWFsaXplIChyZWFkZXIsc3osXCJfYmlnYXJyYXlcIil9KSxcbiAgICAgICBzZXJpYWxpemUgOiBjYW1sX2JhX3NlcmlhbGl6ZSxcbiAgICAgICBjb21wYXJlIDogY2FtbF9iYV9jb21wYXJlLFxuICAgICAgIGhhc2g6IGNhbWxfYmFfaGFzaCxcbiAgICAgfSxcbiAgICAgXCJfYmlnYXJyMDJcIjp7XG4gICAgICAgZGVzZXJpYWxpemUgOiAoZnVuY3Rpb24gKHJlYWRlciwgc3opIHtyZXR1cm4gY2FtbF9iYV9kZXNlcmlhbGl6ZSAocmVhZGVyLHN6LFwiX2JpZ2FycjAyXCIpfSksXG4gICAgICAgc2VyaWFsaXplIDogY2FtbF9iYV9zZXJpYWxpemUsXG4gICAgICAgY29tcGFyZSA6IGNhbWxfYmFfY29tcGFyZSxcbiAgICAgICBoYXNoOiBjYW1sX2JhX2hhc2gsXG4gICAgIH1cbiAgICB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9yZWFkZXIgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuLy9SZXF1aXJlczogY2FtbF9mbG9hdF9vZl9ieXRlcywgY2FtbF9jdXN0b21fb3BzXG4vL1JlcXVpcmVzOiBVSW50OEFycmF5UmVhZGVyXG4vL1JlcXVpcmVzOiBjYW1sX2RlY29tcHJlc3NfaW5wdXRcbmZ1bmN0aW9uIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9yZWFkZXIocmVhZGVyLCBvZnMpIHtcbiAgZnVuY3Rpb24gcmVhZHZscShvdmVyZmxvdykge1xuICAgIHZhciBjID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgIHZhciBuID0gYyAmIDB4N0Y7XG4gICAgd2hpbGUgKChjICYgMHg4MCkgIT0gMCkge1xuICAgICAgYyA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgIHZhciBuNyA9IG4gPDwgNztcbiAgICAgIGlmIChuICE9IG43ID4+IDcpIG92ZXJmbG93WzBdID0gdHJ1ZTtcbiAgICAgIG4gPSBuNyB8IChjICYgMHg3Rik7XG4gICAgfVxuICAgIHJldHVybiBuO1xuICB9XG4gIHZhciBtYWdpYyA9IHJlYWRlci5yZWFkMzJ1ICgpXG4gIHN3aXRjaChtYWdpYyl7XG4gIGNhc2UgMHg4NDk1QTZCRTogLyogSW50ZXh0X21hZ2ljX251bWJlcl9zbWFsbCAqL1xuICAgIHZhciBoZWFkZXJfbGVuID0gMjA7XG4gICAgdmFyIGNvbXByZXNzZWQgPSAwO1xuICAgIHZhciBkYXRhX2xlbiA9IHJlYWRlci5yZWFkMzJ1ICgpO1xuICAgIHZhciB1bmNvbXByZXNzZWRfZGF0YV9sZW4gPSBkYXRhX2xlbjtcbiAgICB2YXIgbnVtX29iamVjdHMgPSByZWFkZXIucmVhZDMydSAoKTtcbiAgICB2YXIgX3NpemVfMzIgPSByZWFkZXIucmVhZDMydSAoKTtcbiAgICB2YXIgX3NpemVfNjQgPSByZWFkZXIucmVhZDMydSAoKTtcbiAgICBicmVha1xuICBjYXNlIDB4ODQ5NUE2QkQ6IC8qIEludGV4dF9tYWdpY19udW1iZXJfY29tcHJlc3NlZCAqL1xuICAgIHZhciBoZWFkZXJfbGVuID0gcmVhZGVyLnJlYWQ4dSgpICYgMHgzRjtcbiAgICB2YXIgY29tcHJlc3NlZCA9IDE7XG4gICAgdmFyIG92ZXJmbG93ID0gW2ZhbHNlXTtcbiAgICB2YXIgZGF0YV9sZW4gPSByZWFkdmxxKG92ZXJmbG93KTtcbiAgICB2YXIgdW5jb21wcmVzc2VkX2RhdGFfbGVuID0gcmVhZHZscShvdmVyZmxvdyk7XG4gICAgdmFyIG51bV9vYmplY3RzID0gcmVhZHZscShvdmVyZmxvdyk7XG4gICAgdmFyIF9zaXplXzMyID0gcmVhZHZscSAob3ZlcmZsb3cpO1xuICAgIHZhciBfc2l6ZV82NCA9IHJlYWR2bHEgKG92ZXJmbG93KTtcbiAgICBpZihvdmVyZmxvd1swXSl7XG4gICAgICAgIGNhbWxfZmFpbHdpdGgoXCJjYW1sX2lucHV0X3ZhbHVlX2Zyb21fcmVhZGVyOiBvYmplY3QgdG9vIGxhcmdlIHRvIGJlIHJlYWQgYmFjayBvbiB0aGlzIHBsYXRmb3JtXCIpO1xuICAgIH1cbiAgICBicmVha1xuICBjYXNlIDB4ODQ5NUE2QkY6IC8qIEludGV4dF9tYWdpY19udW1iZXJfYmlnICovXG4gICAgY2FtbF9mYWlsd2l0aChcImNhbWxfaW5wdXRfdmFsdWVfZnJvbV9yZWFkZXI6IG9iamVjdCB0b28gbGFyZ2UgdG8gYmUgcmVhZCBiYWNrIG9uIGEgMzItYml0IHBsYXRmb3JtXCIpO1xuICAgIGJyZWFrXG4gIGRlZmF1bHQ6XG4gICAgY2FtbF9mYWlsd2l0aChcImNhbWxfaW5wdXRfdmFsdWVfZnJvbV9yZWFkZXI6IGJhZCBvYmplY3RcIik7XG4gICAgYnJlYWs7XG4gIH1cbiAgdmFyIHN0YWNrID0gW107XG4gIHZhciBpbnRlcm5fb2JqX3RhYmxlID0gKG51bV9vYmplY3RzID4gMCk/W106bnVsbDtcbiAgdmFyIG9ial9jb3VudGVyID0gMDtcbiAgZnVuY3Rpb24gaW50ZXJuX3JlYyAocmVhZGVyKSB7XG4gICAgdmFyIGNvZGUgPSByZWFkZXIucmVhZDh1ICgpO1xuICAgIGlmIChjb2RlID49IDB4NDAgLypjc3QuUFJFRklYX1NNQUxMX0lOVCovKSB7XG4gICAgICBpZiAoY29kZSA+PSAweDgwIC8qY3N0LlBSRUZJWF9TTUFMTF9CTE9DSyovKSB7XG4gICAgICAgIHZhciB0YWcgPSBjb2RlICYgMHhGO1xuICAgICAgICB2YXIgc2l6ZSA9IChjb2RlID4+IDQpICYgMHg3O1xuICAgICAgICB2YXIgdiA9IFt0YWddO1xuICAgICAgICBpZiAoc2l6ZSA9PSAwKSByZXR1cm4gdjtcbiAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICBzdGFjay5wdXNoKHYsIHNpemUpO1xuICAgICAgICByZXR1cm4gdjtcbiAgICAgIH0gZWxzZVxuICAgICAgICByZXR1cm4gKGNvZGUgJiAweDNGKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGNvZGUgPj0gMHgyMC8qY3N0LlBSRUZJWF9TTUFMTF9TVFJJTkcgKi8pIHtcbiAgICAgICAgdmFyIGxlbiA9IGNvZGUgJiAweDFGO1xuICAgICAgICB2YXIgdiA9IHJlYWRlci5yZWFkc3RyIChsZW4pO1xuICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgIHJldHVybiB2O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3dpdGNoKGNvZGUpIHtcbiAgICAgICAgY2FzZSAweDAwOiAvL2NzdC5DT0RFX0lOVDg6XG4gICAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkOHMgKCk7XG4gICAgICAgIGNhc2UgMHgwMTogLy9jc3QuQ09ERV9JTlQxNjpcbiAgICAgICAgICByZXR1cm4gcmVhZGVyLnJlYWQxNnMgKCk7XG4gICAgICAgIGNhc2UgMHgwMjogLy9jc3QuQ09ERV9JTlQzMjpcbiAgICAgICAgICByZXR1cm4gcmVhZGVyLnJlYWQzMnMgKCk7XG4gICAgICAgIGNhc2UgMHgwMzogLy9jc3QuQ09ERV9JTlQ2NDpcbiAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwiaW5wdXRfdmFsdWU6IGludGVnZXIgdG9vIGxhcmdlXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDB4MDQ6IC8vY3N0LkNPREVfU0hBUkVEODpcbiAgICAgICAgICB2YXIgb2Zmc2V0ID0gcmVhZGVyLnJlYWQ4dSAoKTtcbiAgICAgICAgICBpZihjb21wcmVzc2VkID09IDApIG9mZnNldCA9IG9ial9jb3VudGVyIC0gb2Zmc2V0O1xuICAgICAgICAgIHJldHVybiBpbnRlcm5fb2JqX3RhYmxlW29mZnNldF07XG4gICAgICAgIGNhc2UgMHgwNTogLy9jc3QuQ09ERV9TSEFSRUQxNjpcbiAgICAgICAgICB2YXIgb2Zmc2V0ID0gcmVhZGVyLnJlYWQxNnUgKCk7XG4gICAgICAgICAgaWYoY29tcHJlc3NlZCA9PSAwKSBvZmZzZXQgPSBvYmpfY291bnRlciAtIG9mZnNldDtcbiAgICAgICAgICByZXR1cm4gaW50ZXJuX29ial90YWJsZVtvZmZzZXRdO1xuICAgICAgICBjYXNlIDB4MDY6IC8vY3N0LkNPREVfU0hBUkVEMzI6XG4gICAgICAgICAgdmFyIG9mZnNldCA9IHJlYWRlci5yZWFkMzJ1ICgpO1xuICAgICAgICAgIGlmKGNvbXByZXNzZWQgPT0gMCkgb2Zmc2V0ID0gb2JqX2NvdW50ZXIgLSBvZmZzZXQ7XG4gICAgICAgICAgcmV0dXJuIGludGVybl9vYmpfdGFibGVbb2Zmc2V0XTtcbiAgICAgICAgY2FzZSAweDA4OiAvL2NzdC5DT0RFX0JMT0NLMzI6XG4gICAgICAgICAgdmFyIGhlYWRlciA9IHJlYWRlci5yZWFkMzJ1ICgpO1xuICAgICAgICAgIHZhciB0YWcgPSBoZWFkZXIgJiAweEZGO1xuICAgICAgICAgIHZhciBzaXplID0gaGVhZGVyID4+IDEwO1xuICAgICAgICAgIHZhciB2ID0gW3RhZ107XG4gICAgICAgICAgaWYgKHNpemUgPT0gMCkgcmV0dXJuIHY7XG4gICAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICAgIHN0YWNrLnB1c2godiwgc2l6ZSk7XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGNhc2UgMHgxMzogLy9jc3QuQ09ERV9CTE9DSzY0OlxuICAgICAgICAgIGNhbWxfZmFpbHdpdGggKFwiaW5wdXRfdmFsdWU6IGRhdGEgYmxvY2sgdG9vIGxhcmdlXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDB4MDk6IC8vY3N0LkNPREVfU1RSSU5HODpcbiAgICAgICAgICB2YXIgbGVuID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgICAgIHZhciB2ID0gcmVhZGVyLnJlYWRzdHIgKGxlbik7XG4gICAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjYXNlIDB4MEE6IC8vY3N0LkNPREVfU1RSSU5HMzI6XG4gICAgICAgICAgdmFyIGxlbiA9IHJlYWRlci5yZWFkMzJ1KCk7XG4gICAgICAgICAgdmFyIHYgPSByZWFkZXIucmVhZHN0ciAobGVuKTtcbiAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGNhc2UgMHgwQzogLy9jc3QuQ09ERV9ET1VCTEVfTElUVExFOlxuICAgICAgICAgIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDtpIDwgODtpKyspIHRbNyAtIGldID0gcmVhZGVyLnJlYWQ4dSAoKTtcbiAgICAgICAgICB2YXIgdiA9IGNhbWxfZmxvYXRfb2ZfYnl0ZXMgKHQpO1xuICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgY2FzZSAweDBCOiAvL2NzdC5DT0RFX0RPVUJMRV9CSUc6XG4gICAgICAgICAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7O1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwO2kgPCA4O2krKykgdFtpXSA9IHJlYWRlci5yZWFkOHUgKCk7XG4gICAgICAgICAgdmFyIHYgPSBjYW1sX2Zsb2F0X29mX2J5dGVzICh0KTtcbiAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGNhc2UgMHgwRTogLy9jc3QuQ09ERV9ET1VCTEVfQVJSQVk4X0xJVFRMRTpcbiAgICAgICAgICB2YXIgbGVuID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgICAgIHZhciB2ID0gbmV3IEFycmF5KGxlbisxKTtcbiAgICAgICAgICB2WzBdID0gMjU0O1xuICAgICAgICAgIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDE7aSA8PSBsZW47aSsrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDtqIDwgODtqKyspIHRbNyAtIGpdID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgICAgICAgdltpXSA9IGNhbWxfZmxvYXRfb2ZfYnl0ZXMgKHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgY2FzZSAweDBEOiAvL2NzdC5DT0RFX0RPVUJMRV9BUlJBWThfQklHOlxuICAgICAgICAgIHZhciBsZW4gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICAgICAgdmFyIHYgPSBuZXcgQXJyYXkobGVuKzEpO1xuICAgICAgICAgIHZbMF0gPSAyNTQ7XG4gICAgICAgICAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7O1xuICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMTtpIDw9IGxlbjtpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFtqXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgICAgICAgIHYgW2ldID0gY2FtbF9mbG9hdF9vZl9ieXRlcyAodCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjYXNlIDB4MDc6IC8vY3N0LkNPREVfRE9VQkxFX0FSUkFZMzJfTElUVExFOlxuICAgICAgICAgIHZhciBsZW4gPSByZWFkZXIucmVhZDMydSgpO1xuICAgICAgICAgIHZhciB2ID0gbmV3IEFycmF5KGxlbisxKTtcbiAgICAgICAgICB2WzBdID0gMjU0O1xuICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICB2YXIgdCA9IG5ldyBBcnJheSg4KTs7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDE7aSA8PSBsZW47aSsrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDtqIDwgODtqKyspIHRbNyAtIGpdID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgICAgICAgdltpXSA9IGNhbWxfZmxvYXRfb2ZfYnl0ZXMgKHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgY2FzZSAweDBGOiAvL2NzdC5DT0RFX0RPVUJMRV9BUlJBWTMyX0JJRzpcbiAgICAgICAgICB2YXIgbGVuID0gcmVhZGVyLnJlYWQzMnUoKTtcbiAgICAgICAgICB2YXIgdiA9IG5ldyBBcnJheShsZW4rMSk7XG4gICAgICAgICAgdlswXSA9IDI1NDtcbiAgICAgICAgICB2YXIgdCA9IG5ldyBBcnJheSg4KTs7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDE7aSA8PSBsZW47aSsrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDtqIDwgODtqKyspIHRbal0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICAgICAgICB2IFtpXSA9IGNhbWxfZmxvYXRfb2ZfYnl0ZXMgKHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgY2FzZSAweDEwOiAvL2NzdC5DT0RFX0NPREVQT0lOVEVSOlxuICAgICAgICBjYXNlIDB4MTE6IC8vY3N0LkNPREVfSU5GSVhQT0lOVEVSOlxuICAgICAgICAgIGNhbWxfZmFpbHdpdGggKFwiaW5wdXRfdmFsdWU6IGNvZGUgcG9pbnRlclwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAweDEyOiAvL2NzdC5DT0RFX0NVU1RPTTpcbiAgICAgICAgY2FzZSAweDE4OiAvL2NzdC5DT0RFX0NVU1RPTV9MRU46XG4gICAgICAgIGNhc2UgMHgxOTogLy9jc3QuQ09ERV9DVVNUT01fRklYRUQ6XG4gICAgICAgICAgdmFyIGMsIHMgPSBcIlwiO1xuICAgICAgICAgIHdoaWxlICgoYyA9IHJlYWRlci5yZWFkOHUgKCkpICE9IDApIHMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSAoYyk7XG4gICAgICAgICAgdmFyIG9wcyA9IGNhbWxfY3VzdG9tX29wc1tzXTtcbiAgICAgICAgICB2YXIgZXhwZWN0ZWRfc2l6ZTtcbiAgICAgICAgICBpZighb3BzKVxuICAgICAgICAgICAgY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiB1bmtub3duIGN1c3RvbSBibG9jayBpZGVudGlmaWVyXCIpO1xuICAgICAgICAgIHN3aXRjaChjb2RlKXtcbiAgICAgICAgICBjYXNlIDB4MTI6IC8vIGNzdC5DT0RFX0NVU1RPTSAoZGVwcmVjYXRlZClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMHgxOTogLy8gY3N0LkNPREVfQ1VTVE9NX0ZJWEVEXG4gICAgICAgICAgICBpZighb3BzLmZpeGVkX2xlbmd0aClcbiAgICAgICAgICAgICAgY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiBleHBlY3RlZCBhIGZpeGVkLXNpemUgY3VzdG9tIGJsb2NrXCIpO1xuICAgICAgICAgICAgZXhwZWN0ZWRfc2l6ZSA9IG9wcy5maXhlZF9sZW5ndGg7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDB4MTg6IC8vIGNzdC5DT0RFX0NVU1RPTV9MRU5cbiAgICAgICAgICAgIGV4cGVjdGVkX3NpemUgPSByZWFkZXIucmVhZDMydSAoKTtcbiAgICAgICAgICAgIC8vIFNraXAgc2l6ZTY0XG4gICAgICAgICAgICByZWFkZXIucmVhZDMycygpOyByZWFkZXIucmVhZDMycygpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBvbGRfcG9zID0gcmVhZGVyLmk7XG4gICAgICAgICAgdmFyIHNpemUgPSBbMF07XG4gICAgICAgICAgdmFyIHYgPSBvcHMuZGVzZXJpYWxpemUocmVhZGVyLCBzaXplKTtcbiAgICAgICAgICBpZihleHBlY3RlZF9zaXplICE9IHVuZGVmaW5lZCl7XG4gICAgICAgICAgICBpZihleHBlY3RlZF9zaXplICE9IHNpemVbMF0pXG4gICAgICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogaW5jb3JyZWN0IGxlbmd0aCBvZiBzZXJpYWxpemVkIGN1c3RvbSBibG9ja1wiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGNhbWxfZmFpbHdpdGggKFwiaW5wdXRfdmFsdWU6IGlsbC1mb3JtZWQgbWVzc2FnZVwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZihjb21wcmVzc2VkKSB7XG4gICAgaWYoY2FtbF9kZWNvbXByZXNzX2lucHV0KSB7XG4gICAgICB2YXIgZGF0YSA9IHJlYWRlci5yZWFkdWludDhhcnJheShkYXRhX2xlbik7XG4gICAgICB2YXIgcmVzID0gbmV3IFVpbnQ4QXJyYXkodW5jb21wcmVzc2VkX2RhdGFfbGVuKTtcbiAgICAgIHZhciByZXMgPSBjYW1sX2RlY29tcHJlc3NfaW5wdXQoZGF0YSwgcmVzKTtcbiAgICAgIHZhciByZWFkZXIgPSBuZXcgVUludDhBcnJheVJlYWRlcihyZXMsIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYW1sX2ZhaWx3aXRoKFwiaW5wdXRfdmFsdWU6IGNvbXByZXNzZWQgb2JqZWN0LCBjYW5ub3QgZGVjb21wcmVzc1wiKTtcbiAgICB9XG4gIH1cbiAgdmFyIHJlcyA9IGludGVybl9yZWMgKHJlYWRlcik7XG4gIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgdmFyIHNpemUgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgdiA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBkID0gdi5sZW5ndGg7XG4gICAgaWYgKGQgPCBzaXplKSBzdGFjay5wdXNoKHYsIHNpemUpO1xuICAgIHZbZF0gPSBpbnRlcm5fcmVjIChyZWFkZXIpO1xuICB9XG4gIGlmICh0eXBlb2Ygb2ZzIT1cIm51bWJlclwiKSBvZnNbMF0gPSByZWFkZXIuaTtcbiAgcmV0dXJuIHJlcztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tYXJzaGFsX2hlYWRlcl9zaXplXG4vL1ZlcnNpb246IDwgNS4xLjBcbnZhciBjYW1sX21hcnNoYWxfaGVhZGVyX3NpemUgPSAyMFxuXG4vL1Byb3ZpZGVzOiBjYW1sX21hcnNoYWxfaGVhZGVyX3NpemVcbi8vVmVyc2lvbjogPj0gNS4xLjBcbnZhciBjYW1sX21hcnNoYWxfaGVhZGVyX3NpemUgPSAxNlxuXG5cblxuLy9Qcm92aWRlczogY2FtbF9tYXJzaGFsX2RhdGFfc2l6ZSBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoLCBjYW1sX2J5dGVzX3Vuc2FmZV9nZXRcbi8vUmVxdWlyZXM6IGNhbWxfdWludDhfYXJyYXlfb2ZfYnl0ZXNcbi8vUmVxdWlyZXM6IFVJbnQ4QXJyYXlSZWFkZXJcbi8vUmVxdWlyZXM6IGNhbWxfbWFyc2hhbF9oZWFkZXJfc2l6ZVxuZnVuY3Rpb24gY2FtbF9tYXJzaGFsX2RhdGFfc2l6ZSAocywgb2ZzKSB7XG4gIHZhciByID0gbmV3IFVJbnQ4QXJyYXlSZWFkZXIoY2FtbF91aW50OF9hcnJheV9vZl9ieXRlcyhzKSwgb2ZzKTtcbiAgZnVuY3Rpb24gcmVhZHZscShvdmVyZmxvdykge1xuICAgIHZhciBjID0gci5yZWFkOHUoKTtcbiAgICB2YXIgbiA9IGMgJiAweDdGO1xuICAgIHdoaWxlICgoYyAmIDB4ODApICE9IDApIHtcbiAgICAgIGMgPSByLnJlYWQ4dSgpO1xuICAgICAgdmFyIG43ID0gbiA8PCA3O1xuICAgICAgaWYgKG4gIT0gbjcgPj4gNykgb3ZlcmZsb3dbMF0gPSB0cnVlO1xuICAgICAgbiA9IG43IHwgKGMgJiAweDdGKTtcbiAgICB9XG4gICAgcmV0dXJuIG47XG4gIH1cblxuICBzd2l0Y2goci5yZWFkMzJ1KCkpe1xuICBjYXNlIDB4ODQ5NUE2QkU6IC8qIEludGV4dF9tYWdpY19udW1iZXJfc21hbGwgKi9cbiAgICB2YXIgaGVhZGVyX2xlbiA9IDIwO1xuICAgIHZhciBkYXRhX2xlbiA9IHIucmVhZDMydSgpO1xuICAgIGJyZWFrO1xuICBjYXNlIDB4ODQ5NUE2QkQ6IC8qIEludGV4dF9tYWdpY19udW1iZXJfY29tcHJlc3NlZCAqL1xuICAgIHZhciBoZWFkZXJfbGVuID0gci5yZWFkOHUoKSAmIDB4M0Y7XG4gICAgdmFyIG92ZXJmbG93ID0gW2ZhbHNlXTtcbiAgICB2YXIgZGF0YV9sZW4gPSByZWFkdmxxKG92ZXJmbG93KTtcbiAgICBpZihvdmVyZmxvd1swXSl7XG4gICAgICBjYW1sX2ZhaWx3aXRoKFwiTWFyc2hhbC5kYXRhX3NpemU6IG9iamVjdCB0b28gbGFyZ2UgdG8gYmUgcmVhZCBiYWNrIG9uIHRoaXMgcGxhdGZvcm1cIik7XG4gICAgfVxuICAgIGJyZWFrXG4gIGNhc2UgMHg4NDk1QTZCRjogLyogSW50ZXh0X21hZ2ljX251bWJlcl9iaWcgKi9cbiAgZGVmYXVsdDpcbiAgICBjYW1sX2ZhaWx3aXRoKFwiTWFyc2hhbC5kYXRhX3NpemU6IGJhZCBvYmplY3RcIik7XG4gICAgYnJlYWtcbiAgfVxuICByZXR1cm4gaGVhZGVyX2xlbiAtIGNhbWxfbWFyc2hhbF9oZWFkZXJfc2l6ZSArIGRhdGFfbGVuO1xufVxuXG4vL1Byb3ZpZGVzOiBNbE9iamVjdFRhYmxlXG52YXIgTWxPYmplY3RUYWJsZTtcbmlmICh0eXBlb2YgZ2xvYmFsVGhpcy5NYXAgPT09ICd1bmRlZmluZWQnKSB7XG4gIE1sT2JqZWN0VGFibGUgPSBmdW5jdGlvbigpIHtcbiAgICAvKiBwb2x5ZmlsbCAodXNpbmcgbGluZWFyIHNlYXJjaCkgKi9cbiAgICBmdW5jdGlvbiBOYWl2ZUxvb2t1cChvYmpzKSB7IHRoaXMub2JqcyA9IG9ianM7IH1cbiAgICBOYWl2ZUxvb2t1cC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24odikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm9ianMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMub2Jqc1tpXSA9PT0gdikgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfTtcbiAgICBOYWl2ZUxvb2t1cC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAvLyBEbyBub3RoaW5nIGhlcmUuIFtNbE9iamVjdFRhYmxlLnN0b3JlXSB3aWxsIHB1c2ggdG8gW3RoaXMub2Jqc10gZGlyZWN0bHkuXG4gICAgfTtcblxuICAgIHJldHVybiBmdW5jdGlvbiBNbE9iamVjdFRhYmxlKCkge1xuICAgICAgdGhpcy5vYmpzID0gW107IHRoaXMubG9va3VwID0gbmV3IE5haXZlTG9va3VwKHRoaXMub2Jqcyk7XG4gICAgfTtcbiAgfSgpO1xufVxuZWxzZSB7XG4gIE1sT2JqZWN0VGFibGUgPSBmdW5jdGlvbiBNbE9iamVjdFRhYmxlKCkge1xuICAgIHRoaXMub2JqcyA9IFtdOyB0aGlzLmxvb2t1cCA9IG5ldyBnbG9iYWxUaGlzLk1hcCgpO1xuICB9O1xufVxuXG5NbE9iamVjdFRhYmxlLnByb3RvdHlwZS5zdG9yZSA9IGZ1bmN0aW9uKHYpIHtcbiAgdGhpcy5sb29rdXAuc2V0KHYsIHRoaXMub2Jqcy5sZW5ndGgpO1xuICB0aGlzLm9ianMucHVzaCh2KTtcbn1cblxuTWxPYmplY3RUYWJsZS5wcm90b3R5cGUucmVjYWxsID0gZnVuY3Rpb24odikge1xuICB2YXIgaSA9IHRoaXMubG9va3VwLmdldCh2KTtcbiAgcmV0dXJuIChpID09PSB1bmRlZmluZWQpXG4gICAgPyB1bmRlZmluZWQgOiB0aGlzLm9ianMubGVuZ3RoIC0gaTsgICAvKiBpbmRleCBpcyByZWxhdGl2ZSAqL1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX291dHB1dF92YWxcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfdG9fYnl0ZXMsIGNhbWxfZmFpbHdpdGhcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfYml0c19vZl9mbG9hdFxuLy9SZXF1aXJlczogY2FtbF9pc19tbF9ieXRlcywgY2FtbF9tbF9ieXRlc19sZW5ndGgsIGNhbWxfYnl0ZXNfdW5zYWZlX2dldFxuLy9SZXF1aXJlczogY2FtbF9pc19tbF9zdHJpbmcsIGNhbWxfbWxfc3RyaW5nX2xlbmd0aCwgY2FtbF9zdHJpbmdfdW5zYWZlX2dldFxuLy9SZXF1aXJlczogTWxPYmplY3RUYWJsZSwgY2FtbF9saXN0X3RvX2pzX2FycmF5LCBjYW1sX2N1c3RvbV9vcHNcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudCxjYW1sX3N0cmluZ19vZl9qc2J5dGVzLCBjYW1sX2lzX2NvbnRpbnVhdGlvbl90YWdcbnZhciBjYW1sX291dHB1dF92YWwgPSBmdW5jdGlvbiAoKXtcbiAgZnVuY3Rpb24gV3JpdGVyICgpIHsgdGhpcy5jaHVuayA9IFtdOyB9XG4gIFdyaXRlci5wcm90b3R5cGUgPSB7XG4gICAgY2h1bmtfaWR4OjIwLCBibG9ja19sZW46MCwgb2JqX2NvdW50ZXI6MCwgc2l6ZV8zMjowLCBzaXplXzY0OjAsXG4gICAgd3JpdGU6ZnVuY3Rpb24gKHNpemUsIHZhbHVlKSB7XG4gICAgICBmb3IgKHZhciBpID0gc2l6ZSAtIDg7aSA+PSAwO2kgLT0gOClcbiAgICAgICAgdGhpcy5jaHVua1t0aGlzLmNodW5rX2lkeCsrXSA9ICh2YWx1ZSA+PiBpKSAmIDB4RkY7XG4gICAgfSxcbiAgICB3cml0ZV9hdDpmdW5jdGlvbiAocG9zLCBzaXplLCB2YWx1ZSkge1xuICAgICAgdmFyIHBvcyA9IHBvcztcbiAgICAgIGZvciAodmFyIGkgPSBzaXplIC0gODtpID49IDA7aSAtPSA4KVxuICAgICAgICB0aGlzLmNodW5rW3BvcysrXSA9ICh2YWx1ZSA+PiBpKSAmIDB4RkY7XG4gICAgfSxcbiAgICB3cml0ZV9jb2RlOmZ1bmN0aW9uIChzaXplLCBjb2RlLCB2YWx1ZSkge1xuICAgICAgdGhpcy5jaHVua1t0aGlzLmNodW5rX2lkeCsrXSA9IGNvZGU7XG4gICAgICBmb3IgKHZhciBpID0gc2l6ZSAtIDg7aSA+PSAwO2kgLT0gOClcbiAgICAgICAgdGhpcy5jaHVua1t0aGlzLmNodW5rX2lkeCsrXSA9ICh2YWx1ZSA+PiBpKSAmIDB4RkY7XG4gICAgfSxcbiAgICB3cml0ZV9zaGFyZWQ6ZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgaWYgKG9mZnNldCA8ICgxIDw8IDgpKSB0aGlzLndyaXRlX2NvZGUoOCwgMHgwNCAvKmNzdC5DT0RFX1NIQVJFRDgqLywgb2Zmc2V0KTtcbiAgICAgIGVsc2UgaWYgKG9mZnNldCA8ICgxIDw8IDE2KSkgdGhpcy53cml0ZV9jb2RlKDE2LCAweDA1IC8qY3N0LkNPREVfU0hBUkVEMTYqLywgb2Zmc2V0KTtcbiAgICAgIGVsc2UgdGhpcy53cml0ZV9jb2RlKDMyLCAweDA2IC8qY3N0LkNPREVfU0hBUkVEMzIqLywgb2Zmc2V0KTtcbiAgICB9LFxuICAgIHBvczpmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmNodW5rX2lkeCB9LFxuICAgIGZpbmFsaXplOmZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuYmxvY2tfbGVuID0gdGhpcy5jaHVua19pZHggLSAyMDtcbiAgICAgIHRoaXMuY2h1bmtfaWR4ID0gMDtcbiAgICAgIHRoaXMud3JpdGUgKDMyLCAweDg0OTVBNkJFKTtcbiAgICAgIHRoaXMud3JpdGUgKDMyLCB0aGlzLmJsb2NrX2xlbik7XG4gICAgICB0aGlzLndyaXRlICgzMiwgdGhpcy5vYmpfY291bnRlcik7XG4gICAgICB0aGlzLndyaXRlICgzMiwgdGhpcy5zaXplXzMyKTtcbiAgICAgIHRoaXMud3JpdGUgKDMyLCB0aGlzLnNpemVfNjQpO1xuICAgICAgcmV0dXJuIHRoaXMuY2h1bms7XG4gICAgfVxuICB9XG4gIHJldHVybiBmdW5jdGlvbiAodiwgZmxhZ3MpIHtcbiAgICBmbGFncyA9IGNhbWxfbGlzdF90b19qc19hcnJheShmbGFncyk7XG5cbiAgICB2YXIgbm9fc2hhcmluZyA9IChmbGFncy5pbmRleE9mKDAgLypNYXJzaGFsLk5vX3NoYXJpbmcqLykgIT09IC0xKSxcbiAgICAgICAgY2xvc3VyZXMgPSAgKGZsYWdzLmluZGV4T2YoMSAvKk1hcnNoYWwuQ2xvc3VyZXMqLykgIT09IC0xKTtcbiAgICAvKiBNYXJzaGFsLkNvbXBhdF8zMiBpcyByZWR1bmRhbnQgc2luY2UgaW50ZWdlcnMgYXJlIDMyLWJpdCBhbnl3YXkgKi9cblxuICAgIGlmIChjbG9zdXJlcylcbiAgICAgIGNvbnNvbGUud2FybihcImluIGNhbWxfb3V0cHV0X3ZhbDogZmxhZyBNYXJzaGFsLkNsb3N1cmVzIGlzIG5vdCBzdXBwb3J0ZWQuXCIpO1xuXG4gICAgdmFyIHdyaXRlciA9IG5ldyBXcml0ZXIgKCk7XG4gICAgdmFyIHN0YWNrID0gW107XG4gICAgdmFyIGludGVybl9vYmpfdGFibGUgPSBub19zaGFyaW5nID8gbnVsbCA6IG5ldyBNbE9iamVjdFRhYmxlKCk7XG5cbiAgICBmdW5jdGlvbiBtZW1vKHYpIHtcbiAgICAgIGlmIChub19zaGFyaW5nKSByZXR1cm4gZmFsc2U7XG4gICAgICB2YXIgZXhpc3Rpbmdfb2Zmc2V0ID0gaW50ZXJuX29ial90YWJsZS5yZWNhbGwodik7XG4gICAgICBpZiAoZXhpc3Rpbmdfb2Zmc2V0KSB7IHdyaXRlci53cml0ZV9zaGFyZWQoZXhpc3Rpbmdfb2Zmc2V0KTsgcmV0dXJuIHRydWU7IH1cbiAgICAgIGVsc2UgeyBpbnRlcm5fb2JqX3RhYmxlLnN0b3JlKHYpOyByZXR1cm4gZmFsc2U7IH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHRlcm5fcmVjICh2KSB7XG4gICAgICBpZiAodi5jYW1sX2N1c3RvbSkge1xuICAgICAgICBpZiAobWVtbyh2KSkgcmV0dXJuO1xuICAgICAgICB2YXIgbmFtZSA9IHYuY2FtbF9jdXN0b207XG4gICAgICAgIHZhciBvcHMgPSBjYW1sX2N1c3RvbV9vcHNbbmFtZV07XG4gICAgICAgIHZhciBzel8zMl82NCA9IFswLDBdO1xuICAgICAgICBpZighb3BzLnNlcmlhbGl6ZSlcbiAgICAgICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJvdXRwdXRfdmFsdWU6IGFic3RyYWN0IHZhbHVlIChDdXN0b20pXCIpO1xuICAgICAgICBpZihvcHMuZml4ZWRfbGVuZ3RoID09IHVuZGVmaW5lZCl7XG4gICAgICAgICAgd3JpdGVyLndyaXRlICg4LCAweDE4IC8qY3N0LkNPREVfQ1VTVE9NX0xFTiovKTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWUubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIG5hbWUuY2hhckNvZGVBdChpKSk7XG4gICAgICAgICAgd3JpdGVyLndyaXRlKDgsIDApO1xuICAgICAgICAgIHZhciBoZWFkZXJfcG9zID0gd3JpdGVyLnBvcyAoKTtcbiAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgd3JpdGVyLndyaXRlKDgsIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvcHMuc2VyaWFsaXplKHdyaXRlciwgdiwgc3pfMzJfNjQpO1xuICAgICAgICAgIHdyaXRlci53cml0ZV9hdChoZWFkZXJfcG9zLCAzMiwgc3pfMzJfNjRbMF0pO1xuICAgICAgICAgIHdyaXRlci53cml0ZV9hdChoZWFkZXJfcG9zICsgNCwgMzIsIDApOyAvLyB6ZXJvXG4gICAgICAgICAgd3JpdGVyLndyaXRlX2F0KGhlYWRlcl9wb3MgKyA4LCAzMiwgc3pfMzJfNjRbMV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdyaXRlci53cml0ZSAoOCwgMHgxOSAvKmNzdC5DT0RFX0NVU1RPTV9GSVhFRCovKTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWUubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIG5hbWUuY2hhckNvZGVBdChpKSk7XG4gICAgICAgICAgd3JpdGVyLndyaXRlKDgsIDApO1xuICAgICAgICAgIHZhciBvbGRfcG9zID0gd3JpdGVyLnBvcygpO1xuICAgICAgICAgIG9wcy5zZXJpYWxpemUod3JpdGVyLCB2LCBzel8zMl82NCk7XG4gICAgICAgICAgaWYgKG9wcy5maXhlZF9sZW5ndGggIT0gd3JpdGVyLnBvcygpIC0gb2xkX3BvcylcbiAgICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJvdXRwdXRfdmFsdWU6IGluY29ycmVjdCBmaXhlZCBzaXplcyBzcGVjaWZpZWQgYnkgXCIgKyBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICB3cml0ZXIuc2l6ZV8zMiArPSAyICsgKChzel8zMl82NFswXSArIDMpID4+IDIpO1xuICAgICAgICB3cml0ZXIuc2l6ZV82NCArPSAyICsgKChzel8zMl82NFsxXSArIDcpID4+IDMpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodiBpbnN0YW5jZW9mIEFycmF5ICYmIHZbMF0gPT09ICh2WzBdfDApKSB7XG4gICAgICAgIGlmICh2WzBdID09IDI1MSkge1xuICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJvdXRwdXRfdmFsdWU6IGFic3RyYWN0IHZhbHVlIChBYnN0cmFjdClcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhbWxfaXNfY29udGludWF0aW9uX3RhZyh2WzBdKSlcbiAgICAgICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJvdXRwdXRfdmFsdWU6IGNvbnRpbnVhdGlvbiB2YWx1ZVwiKTtcbiAgICAgICAgaWYgKHYubGVuZ3RoID4gMSAmJiBtZW1vKHYpKSByZXR1cm47XG4gICAgICAgIGlmICh2WzBdIDwgMTYgJiYgdi5sZW5ndGggLSAxIDwgOClcbiAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIDB4ODAgLypjc3QuUFJFRklYX1NNQUxMX0JMT0NLKi8gKyB2WzBdICsgKCh2Lmxlbmd0aCAtIDEpPDw0KSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB3cml0ZXIud3JpdGVfY29kZSgzMiwgMHgwOCAvKmNzdC5DT0RFX0JMT0NLMzIqLywgKCh2Lmxlbmd0aC0xKSA8PCAxMCkgfCB2WzBdKTtcbiAgICAgICAgd3JpdGVyLnNpemVfMzIgKz0gdi5sZW5ndGg7XG4gICAgICAgIHdyaXRlci5zaXplXzY0ICs9IHYubGVuZ3RoO1xuICAgICAgICBpZiAodi5sZW5ndGggPiAxKSBzdGFjay5wdXNoICh2LCAxKTtcbiAgICAgIH0gZWxzZSBpZiAoY2FtbF9pc19tbF9ieXRlcyh2KSkge1xuICAgICAgICBpZighKGNhbWxfaXNfbWxfYnl0ZXMoY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhcIlwiKSkpKSB7XG4gICAgICAgICAgY2FtbF9mYWlsd2l0aChcIm91dHB1dF92YWx1ZTogW0J5dGVzLnRdIGNhbm5vdCBzYWZlbHkgYmUgbWFyc2hhbGVkIHdpdGggWy0tZW5hYmxlIHVzZS1qcy1zdHJpbmddXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZW1vKHYpKSByZXR1cm47XG4gICAgICAgIHZhciBsZW4gPSBjYW1sX21sX2J5dGVzX2xlbmd0aCh2KTtcbiAgICAgICAgaWYgKGxlbiA8IDB4MjApXG4gICAgICAgICAgd3JpdGVyLndyaXRlICg4LCAweDIwIC8qY3N0LlBSRUZJWF9TTUFMTF9TVFJJTkcqLyArIGxlbik7XG4gICAgICAgIGVsc2UgaWYgKGxlbiA8IDB4MTAwKVxuICAgICAgICAgIHdyaXRlci53cml0ZV9jb2RlICg4LCAweDA5Lypjc3QuQ09ERV9TVFJJTkc4Ki8sIGxlbik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB3cml0ZXIud3JpdGVfY29kZSAoMzIsIDB4MEEgLypjc3QuQ09ERV9TVFJJTkczMiovLCBsZW4pO1xuICAgICAgICBmb3IgKHZhciBpID0gMDtpIDwgbGVuO2krKylcbiAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIGNhbWxfYnl0ZXNfdW5zYWZlX2dldCh2LGkpKTtcbiAgICAgICAgd3JpdGVyLnNpemVfMzIgKz0gMSArICgoKGxlbiArIDQpIC8gNCl8MCk7XG4gICAgICAgIHdyaXRlci5zaXplXzY0ICs9IDEgKyAoKChsZW4gKyA4KSAvIDgpfDApO1xuICAgICAgfSBlbHNlIGlmIChjYW1sX2lzX21sX3N0cmluZyh2KSkge1xuICAgICAgICBpZiAobWVtbyh2KSkgcmV0dXJuO1xuICAgICAgICB2YXIgbGVuID0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHYpO1xuICAgICAgICBpZiAobGVuIDwgMHgyMClcbiAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIDB4MjAgLypjc3QuUFJFRklYX1NNQUxMX1NUUklORyovICsgbGVuKTtcbiAgICAgICAgZWxzZSBpZiAobGVuIDwgMHgxMDApXG4gICAgICAgICAgd3JpdGVyLndyaXRlX2NvZGUgKDgsIDB4MDkvKmNzdC5DT0RFX1NUUklORzgqLywgbGVuKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHdyaXRlci53cml0ZV9jb2RlICgzMiwgMHgwQSAvKmNzdC5DT0RFX1NUUklORzMyKi8sIGxlbik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwO2kgPCBsZW47aSsrKVxuICAgICAgICAgIHdyaXRlci53cml0ZSAoOCwgY2FtbF9zdHJpbmdfdW5zYWZlX2dldCh2LGkpKTtcbiAgICAgICAgd3JpdGVyLnNpemVfMzIgKz0gMSArICgoKGxlbiArIDQpIC8gNCl8MCk7XG4gICAgICAgIHdyaXRlci5zaXplXzY0ICs9IDEgKyAoKChsZW4gKyA4KSAvIDgpfDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHYgIT0gKHZ8MCkpe1xuICAgICAgICAgIHZhciB0eXBlX29mX3YgPSB0eXBlb2YgdjtcbiAgICAgICAgICBpZih0eXBlX29mX3YgIT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJvdXRwdXRfdmFsdWU6IGFic3RyYWN0IHZhbHVlIChcIit0eXBlX29mX3YrXCIpXCIpO1xuICAgICAgICAgIC8vIElmIGEgZmxvYXQgaGFwcGVucyB0byBiZSBhbiBpbnRlZ2VyIGl0IGlzIHNlcmlhbGl6ZWQgYXMgYW4gaW50ZWdlclxuICAgICAgICAgIC8vIChKc19vZl9vY2FtbCBjYW5ub3QgdGVsbCB3aGV0aGVyIHRoZSB0eXBlIG9mIGFuIGludGVnZXIgbnVtYmVyIGlzXG4gICAgICAgICAgLy8gZmxvYXQgb3IgaW50ZWdlci4pIFRoaXMgY2FuIHJlc3VsdCBpbiB1bmV4cGVjdGVkIGNyYXNoZXMgd2hlblxuICAgICAgICAgIC8vIHVubWFyc2hhbGxpbmcgdXNpbmcgdGhlIHN0YW5kYXJkIHJ1bnRpbWUuXG4gICAgICAgICAgaWYgKG1lbW8odikpIHJldHVybjtcbiAgICAgICAgICB2YXIgdCA9IGNhbWxfaW50NjRfdG9fYnl0ZXMoY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0KHYpKTtcbiAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIDB4MEMgLypjc3QuQ09ERV9ET1VCTEVfTElUVExFKi8pO1xuICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGk8ODsgaSsrKXt3cml0ZXIud3JpdGUoOCx0WzcgLSBpXSl9XG4gICAgICAgICAgd3JpdGVyLnNpemVfMzIgKz0gM1xuICAgICAgICAgIHdyaXRlci5zaXplXzY0ICs9IDJcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2ID49IDAgJiYgdiA8IDB4NDApIHtcbiAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIDBYNDAgLypjc3QuUFJFRklYX1NNQUxMX0lOVCovICsgdik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHYgPj0gLSgxIDw8IDcpICYmIHYgPCAoMSA8PCA3KSlcbiAgICAgICAgICAgIHdyaXRlci53cml0ZV9jb2RlKDgsIDB4MDAgLypjc3QuQ09ERV9JTlQ4Ki8sIHYpO1xuICAgICAgICAgIGVsc2UgaWYgKHYgPj0gLSgxIDw8IDE1KSAmJiB2IDwgKDEgPDwgMTUpKVxuICAgICAgICAgICAgd3JpdGVyLndyaXRlX2NvZGUoMTYsIDB4MDEgLypjc3QuQ09ERV9JTlQxNiovLCB2KTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB3cml0ZXIud3JpdGVfY29kZSgzMiwgMHgwMiAvKmNzdC5DT0RFX0lOVDMyKi8sIHYpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGV4dGVybl9yZWMgKHYpO1xuICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgaSA9IHN0YWNrLnBvcCAoKTtcbiAgICAgIHZhciB2ID0gc3RhY2sucG9wICgpO1xuICAgICAgaWYgKGkgKyAxIDwgdi5sZW5ndGgpIHN0YWNrLnB1c2ggKHYsIGkgKyAxKTtcbiAgICAgIGV4dGVybl9yZWMgKHZbaV0pO1xuICAgIH1cbiAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgd3JpdGVyLm9ial9jb3VudGVyID0gaW50ZXJuX29ial90YWJsZS5vYmpzLmxlbmd0aDtcbiAgICB3cml0ZXIuZmluYWxpemUoKTtcbiAgICByZXR1cm4gd3JpdGVyLmNodW5rO1xuICB9XG59ICgpO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX291dHB1dF92YWx1ZV90b19zdHJpbmcgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9vdXRwdXRfdmFsLCBjYW1sX3N0cmluZ19vZl9hcnJheVxuZnVuY3Rpb24gY2FtbF9vdXRwdXRfdmFsdWVfdG9fc3RyaW5nICh2LCBmbGFncykge1xuICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfYXJyYXkgKGNhbWxfb3V0cHV0X3ZhbCAodiwgZmxhZ3MpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vdXRwdXRfdmFsdWVfdG9fYnl0ZXMgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9vdXRwdXRfdmFsLCBjYW1sX2J5dGVzX29mX2FycmF5XG5mdW5jdGlvbiBjYW1sX291dHB1dF92YWx1ZV90b19ieXRlcyAodiwgZmxhZ3MpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfb2ZfYXJyYXkgKGNhbWxfb3V0cHV0X3ZhbCAodiwgZmxhZ3MpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vdXRwdXRfdmFsdWVfdG9fYnVmZmVyXG4vL1JlcXVpcmVzOiBjYW1sX291dHB1dF92YWwsIGNhbWxfZmFpbHdpdGgsIGNhbWxfYmxpdF9ieXRlc1xuZnVuY3Rpb24gY2FtbF9vdXRwdXRfdmFsdWVfdG9fYnVmZmVyIChzLCBvZnMsIGxlbiwgdiwgZmxhZ3MpIHtcbiAgdmFyIHQgPSBjYW1sX291dHB1dF92YWwgKHYsIGZsYWdzKTtcbiAgaWYgKHQubGVuZ3RoID4gbGVuKSBjYW1sX2ZhaWx3aXRoIChcIk1hcnNoYWwudG9fYnVmZmVyOiBidWZmZXIgb3ZlcmZsb3dcIik7XG4gIGNhbWxfYmxpdF9ieXRlcyh0LCAwLCBzLCBvZnMsIHQubGVuZ3RoKTtcbiAgcmV0dXJuIDA7XG59XG4iLCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKiAgICBDb3B5cmlnaHQgMjAyMiBPQ2FtbFBybyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKiAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgICovXG4vKiAgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSBzcGVjaWFsICAgICAgICovXG4vKiAgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICAgICAgICAgICovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8vUHJvdmlkZXM6IE9wdGlvbmFsX2Jvb2xfdmFsXG5mdW5jdGlvbiBPcHRpb25hbF9ib29sX3ZhbChtbE9wdEJvb2wsIGRlZikge1xuICByZXR1cm4gKHR5cGVvZihtbE9wdEJvb2wpID09IFwib2JqZWN0XCIpID8gKG1sT3B0Qm9vbFsxXSAhPT0gMCkgOiBkZWY7XG59XG5cbi8vUHJvdmlkZXM6IE9wdGlvbmFsX3ZhbFxuZnVuY3Rpb24gT3B0aW9uYWxfdmFsKG1sT3B0VmFsLCBkZWYpIHtcbiAgcmV0dXJuICh0eXBlb2YobWxPcHRWYWwpID09IFwib2JqZWN0XCIpID8gbWxPcHRWYWxbMV0gOiBkZWY7XG59XG5cbi8vUHJvdmlkZXM6IFZhbF9mb2N1c19pbl9vdXRcbi8vUmVxdWlyZXM6IEZPQ1VTLEZPQ1VTX1RBR1xuXG52YXIgZm9jdXNfdG9fdGFnID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0Lk1hcChbXG4gIFtGT0NVUy5PVVQsIEZPQ1VTX1RBRy5PVVRdLFxuICBbRk9DVVMuSU4sICBGT0NVU19UQUcuSU5dLFxuXSk7XG5cbmZ1bmN0aW9uIFZhbF9mb2N1c19pbl9vdXQoZm9jdXMpIHtcbiAgcmV0dXJuIGZvY3VzX3RvX3RhZy5nZXQoZm9jdXMpO1xufVxuXG4vL1Byb3ZpZGVzOiBWYWxfa2V5X2NvZGVcbi8vUmVxdWlyZXM6IEtFWSxLRVlfVEFHXG5cbnZhciBrY190b190YWcgPSBuZXcgam9vX2dsb2JhbF9vYmplY3QuTWFwKFtcbiAgW0tFWS5FU0NBUEUsICAgICAgICAgICAgICAgS0VZX1RBRy5FU0NBUEVdLFxuICBbS0VZLkYxLCAgICAgICAgICAgICAgICAgICBLRVlfVEFHLkYxXSxcbiAgW0tFWS5GMiwgICAgICAgICAgICAgICAgICAgS0VZX1RBRy5GMl0sXG4gIFtLRVkuRjMsICAgICAgICAgICAgICAgICAgIEtFWV9UQUcuRjNdLFxuICBbS0VZLkY0LCAgICAgICAgICAgICAgICAgICBLRVlfVEFHLkY0XSxcbiAgW0tFWS5GNSwgICAgICAgICAgICAgICAgICAgS0VZX1RBRy5GNV0sXG4gIFtLRVkuRjYsICAgICAgICAgICAgICAgICAgIEtFWV9UQUcuRjZdLFxuICBbS0VZLkY3LCAgICAgICAgICAgICAgICAgICBLRVlfVEFHLkY3XSxcbiAgW0tFWS5GOCwgICAgICAgICAgICAgICAgICAgS0VZX1RBRy5GOF0sXG4gIFtLRVkuRjksICAgICAgICAgICAgICAgICAgIEtFWV9UQUcuRjldLFxuICBbS0VZLkYxMCwgICAgICAgICAgICAgICAgICBLRVlfVEFHLkYxMF0sXG4gIFtLRVkuRjExLCAgICAgICAgICAgICAgICAgIEtFWV9UQUcuRjExXSxcbiAgW0tFWS5GMTIsICAgICAgICAgICAgICAgICAgS0VZX1RBRy5GMTJdLFxuICBbS0VZLlBSSU5UU0NSRUVOLCAgICAgICAgICBLRVlfVEFHLlBSSU5UU0NSRUVOXSxcbiAgW0tFWS5TQ1JPTExMT0NLLCAgICAgICAgICAgS0VZX1RBRy5TQ1JPTExMT0NLXSxcbiAgW0tFWS5QQVVTRSwgICAgICAgICAgICAgICAgS0VZX1RBRy5QQVVTRV0sXG4gIFtLRVkuR1JBVkVfVElMREUsICAgICAgICAgIEtFWV9UQUcuR1JBVkVfVElMREVdLFxuICBbS0VZLl8xX0VYQ0xBTUFUSU9OLCAgICAgICBLRVlfVEFHLl8xX0VYQ0xBTUFUSU9OXSxcbiAgW0tFWS5fMl9BVCwgICAgICAgICAgICAgICAgS0VZX1RBRy5fMl9BVF0sXG4gIFtLRVkuXzNfTlVNQkVSLCAgICAgICAgICAgIEtFWV9UQUcuXzNfTlVNQkVSXSxcbiAgW0tFWS5fNF9ET0xMQVIsICAgICAgICAgICAgS0VZX1RBRy5fNF9ET0xMQVJdLFxuICBbS0VZLl81X1BFUkNFTlQsICAgICAgICAgICBLRVlfVEFHLl81X1BFUkNFTlRdLFxuICBbS0VZLl82X0NBUkVULCAgICAgICAgICAgICBLRVlfVEFHLl82X0NBUkVUXSxcbiAgW0tFWS5fN19BTVBFUlNBTkQsICAgICAgICAgS0VZX1RBRy5fN19BTVBFUlNBTkRdLFxuICBbS0VZLl84X0FTVEVSSVNLLCAgICAgICAgICBLRVlfVEFHLl84X0FTVEVSSVNLXSxcbiAgW0tFWS5fOV9MUEFSRU5USEVTSVMsICAgICAgS0VZX1RBRy5fOV9MUEFSRU5USEVTSVNdLFxuICBbS0VZLl8wX1JQQVJFTlRIRVNJUywgICAgICBLRVlfVEFHLl8wX1JQQVJFTlRIRVNJU10sXG4gIFtLRVkuTUlOVVNfVU5ERVJTQ09SRSwgICAgIEtFWV9UQUcuTUlOVVNfVU5ERVJTQ09SRV0sXG4gIFtLRVkuRVFVQUxfUExVUywgICAgICAgICAgIEtFWV9UQUcuRVFVQUxfUExVU10sXG4gIFtLRVkuQkFDS1NQQUNFLCAgICAgICAgICAgIEtFWV9UQUcuQkFDS1NQQUNFXSxcbiAgW0tFWS5UQUIsICAgICAgICAgICAgICAgICAgS0VZX1RBRy5UQUJdLFxuICBbS0VZLlEsICAgICAgICAgICAgICAgICAgICBLRVlfVEFHLlFdLFxuICBbS0VZLlcsICAgICAgICAgICAgICAgICAgICBLRVlfVEFHLlddLFxuICBbS0VZLkUsICAgICAgICAgICAgICAgICAgICBLRVlfVEFHLkVdLFxuICBbS0VZLlIsICAgICAgICAgICAgICAgICAgICBLRVlfVEFHLlJdLFxuICBbS0VZLlQsICAgICAgICAgICAgICAgICAgICBLRVlfVEFHLlRdLFxuICBbS0VZLlksICAgICAgICAgICAgICAgICAgICBLRVlfVEFHLlldLFxuICBbS0VZLlUsICAgICAgICAgICAgICAgICAgICBLRVlfVEFHLlVdLFxuICBbS0VZLkksICAgICAgICAgICAgICAgICAgICBLRVlfVEFHLkldLFxuICBbS0VZLk8sICAgICAgICAgICAgICAgICAgICBLRVlfVEFHLk9dLFxuICBbS0VZLlAsICAgICAgICAgICAgICAgICAgICBLRVlfVEFHLlBdLFxuICBbS0VZLkxCUkFDS0VUX0NVUkxZLCAgICAgICBLRVlfVEFHLkxCUkFDS0VUX0NVUkxZXSxcbiAgW0tFWS5SQlJBQ0tFVF9DVVJMWSwgICAgICAgS0VZX1RBRy5SQlJBQ0tFVF9DVVJMWV0sXG4gIFtLRVkuQkFDS1NMQVNIX1BJUEUsICAgICAgIEtFWV9UQUcuQkFDS1NMQVNIX1BJUEVdLFxuICBbS0VZLkNBUFNMT0NLLCAgICAgICAgICAgICBLRVlfVEFHLkNBUFNMT0NLXSxcbiAgW0tFWS5BLCAgICAgICAgICAgICAgICAgICAgS0VZX1RBRy5BXSxcbiAgW0tFWS5TLCAgICAgICAgICAgICAgICAgICAgS0VZX1RBRy5TXSxcbiAgW0tFWS5ELCAgICAgICAgICAgICAgICAgICAgS0VZX1RBRy5EXSxcbiAgW0tFWS5GLCAgICAgICAgICAgICAgICAgICAgS0VZX1RBRy5GXSxcbiAgW0tFWS5HLCAgICAgICAgICAgICAgICAgICAgS0VZX1RBRy5HXSxcbiAgW0tFWS5ILCAgICAgICAgICAgICAgICAgICAgS0VZX1RBRy5IXSxcbiAgW0tFWS5KLCAgICAgICAgICAgICAgICAgICAgS0VZX1RBRy5KXSxcbiAgW0tFWS5LLCAgICAgICAgICAgICAgICAgICAgS0VZX1RBRy5LXSxcbiAgW0tFWS5MLCAgICAgICAgICAgICAgICAgICAgS0VZX1RBRy5MXSxcbiAgW0tFWS5TRU1JQ09MT05fQ09MT04sICAgICAgS0VZX1RBRy5TRU1JQ09MT05fQ09MT05dLFxuICBbS0VZLlFVT1RFX0RPVUJMRVFVT1RFLCAgICBLRVlfVEFHLlFVT1RFX0RPVUJMRVFVT1RFXSxcbiAgW0tFWS5OT05VU19OVU1CRVJfVElMREUsICAgS0VZX1RBRy5OT05VU19OVU1CRVJfVElMREVdLFxuICBbS0VZLlJFVFVSTiwgICAgICAgICAgICAgICBLRVlfVEFHLlJFVFVSTl0sXG4gIFtLRVkuTFNISUZULCAgICAgICAgICAgICAgIEtFWV9UQUcuTFNISUZUXSxcbiAgW0tFWS5OT05VU19CQUNLU0xBU0hfUElQRSwgS0VZX1RBRy5OT05VU19CQUNLU0xBU0hfUElQRV0sXG4gIFtLRVkuWiwgICAgICAgICAgICAgICAgICAgIEtFWV9UQUcuWl0sXG4gIFtLRVkuWCwgICAgICAgICAgICAgICAgICAgIEtFWV9UQUcuWF0sXG4gIFtLRVkuQywgICAgICAgICAgICAgICAgICAgIEtFWV9UQUcuQ10sXG4gIFtLRVkuViwgICAgICAgICAgICAgICAgICAgIEtFWV9UQUcuVl0sXG4gIFtLRVkuQiwgICAgICAgICAgICAgICAgICAgIEtFWV9UQUcuQl0sXG4gIFtLRVkuTiwgICAgICAgICAgICAgICAgICAgIEtFWV9UQUcuTl0sXG4gIFtLRVkuTSwgICAgICAgICAgICAgICAgICAgIEtFWV9UQUcuTV0sXG4gIFtLRVkuQ09NTUFfTEVTUywgICAgICAgICAgIEtFWV9UQUcuQ09NTUFfTEVTU10sXG4gIFtLRVkuUEVSSU9EX0dSRUFURVIsICAgICAgIEtFWV9UQUcuUEVSSU9EX0dSRUFURVJdLFxuICBbS0VZLlNMQVNIX1FVRVNUSU9OLCAgICAgICBLRVlfVEFHLlNMQVNIX1FVRVNUSU9OXSxcbiAgW0tFWS5SU0hJRlQsICAgICAgICAgICAgICAgS0VZX1RBRy5SU0hJRlRdLFxuICBbS0VZLkxDT05UUk9MLCAgICAgICAgICAgICBLRVlfVEFHLkxDT05UUk9MXSxcbiAgW0tFWS5MTUVUQSwgICAgICAgICAgICAgICAgS0VZX1RBRy5MTUVUQV0sXG4gIFtLRVkuTEFMVCwgICAgICAgICAgICAgICAgIEtFWV9UQUcuTEFMVF0sXG4gIFtLRVkuU1BBQ0VCQVIsICAgICAgICAgICAgIEtFWV9UQUcuU1BBQ0VCQVJdLFxuICBbS0VZLlJBTFQsICAgICAgICAgICAgICAgICBLRVlfVEFHLlJBTFRdLFxuICBbS0VZLlJNRVRBLCAgICAgICAgICAgICAgICBLRVlfVEFHLlJNRVRBXSxcbiAgW0tFWS5NRU5VLCAgICAgICAgICAgICAgICAgS0VZX1RBRy5NRU5VXSxcbiAgW0tFWS5SQ09OVFJPTCwgICAgICAgICAgICAgS0VZX1RBRy5SQ09OVFJPTF0sXG4gIFtLRVkuSU5TRVJULCAgICAgICAgICAgICAgIEtFWV9UQUcuSU5TRVJUXSxcbiAgW0tFWS5IT01FLCAgICAgICAgICAgICAgICAgS0VZX1RBRy5IT01FXSxcbiAgW0tFWS5QQUdFVVAsICAgICAgICAgICAgICAgS0VZX1RBRy5QQUdFVVBdLFxuICBbS0VZLkRFTEVURUZPUldBUkQsICAgICAgICBLRVlfVEFHLkRFTEVURUZPUldBUkRdLFxuICBbS0VZLkVORCwgICAgICAgICAgICAgICAgICBLRVlfVEFHLkVORF0sXG4gIFtLRVkuUEFHRURPV04sICAgICAgICAgICAgIEtFWV9UQUcuUEFHRURPV05dLFxuICBbS0VZLlVQQVJST1csICAgICAgICAgICAgICBLRVlfVEFHLlVQQVJST1ddLFxuICBbS0VZLkxFRlRBUlJPVywgICAgICAgICAgICBLRVlfVEFHLkxFRlRBUlJPV10sXG4gIFtLRVkuRE9XTkFSUk9XLCAgICAgICAgICAgIEtFWV9UQUcuRE9XTkFSUk9XXSxcbiAgW0tFWS5SSUdIVEFSUk9XLCAgICAgICAgICAgS0VZX1RBRy5SSUdIVEFSUk9XXSxcbiAgW0tFWS5QQURfTlVNTE9DS19DTEVBUiwgICAgS0VZX1RBRy5QQURfTlVNTE9DS19DTEVBUl0sXG4gIFtLRVkuUEFEX0VRVUFMUywgICAgICAgICAgIEtFWV9UQUcuUEFEX0VRVUFMU10sXG4gIFtLRVkuUEFEX0RJVklERSwgICAgICAgICAgIEtFWV9UQUcuUEFEX0RJVklERV0sXG4gIFtLRVkuUEFEX01VTFRJUExZLCAgICAgICAgIEtFWV9UQUcuUEFEX01VTFRJUExZXSxcbiAgW0tFWS5QQURfTUlOVVMsICAgICAgICAgICAgS0VZX1RBRy5QQURfTUlOVVNdLFxuICBbS0VZLlBBRF83X0hPTUUsICAgICAgICAgICBLRVlfVEFHLlBBRF83X0hPTUVdLFxuICBbS0VZLlBBRF84X1VQQVJST1csICAgICAgICBLRVlfVEFHLlBBRF84X1VQQVJST1ddLFxuICBbS0VZLlBBRF85X1BBR0VVUCwgICAgICAgICBLRVlfVEFHLlBBRF85X1BBR0VVUF0sXG4gIFtLRVkuUEFEX1BMVVMsICAgICAgICAgICAgIEtFWV9UQUcuUEFEX1BMVVNdLFxuICBbS0VZLlBBRF80X0xFRlRBUlJPVywgICAgICBLRVlfVEFHLlBBRF80X0xFRlRBUlJPV10sXG4gIFtLRVkuUEFEXzUsICAgICAgICAgICAgICAgIEtFWV9UQUcuUEFEXzVdLFxuICBbS0VZLlBBRF82X1JJR0hUQVJST1csICAgICBLRVlfVEFHLlBBRF82X1JJR0hUQVJST1ddLFxuICBbS0VZLlBBRF9DT01NQSwgICAgICAgICAgICBLRVlfVEFHLlBBRF9DT01NQV0sXG4gIFtLRVkuUEFEXzFfRU5ELCAgICAgICAgICAgIEtFWV9UQUcuUEFEXzFfRU5EXSxcbiAgW0tFWS5QQURfMl9ET1dOQVJST1csICAgICAgS0VZX1RBRy5QQURfMl9ET1dOQVJST1ddLFxuICBbS0VZLlBBRF8zX1BBR0VET1dOLCAgICAgICBLRVlfVEFHLlBBRF8zX1BBR0VET1dOXSxcbiAgW0tFWS5QQURfMF9JTlNFUlQsICAgICAgICAgS0VZX1RBRy5QQURfMF9JTlNFUlRdLFxuICBbS0VZLlBBRF9ERUNJTUFMX0RFTEVURSwgICBLRVlfVEFHLlBBRF9ERUNJTUFMX0RFTEVURV0sXG4gIFtLRVkuUEFEX0VOVEVSLCAgICAgICAgICAgIEtFWV9UQUcuUEFEX0VOVEVSXSxcbiAgW0tFWS5GMTMsICAgICAgICAgICAgICAgICAgS0VZX1RBRy5GMTNdLFxuICBbS0VZLkYxNCwgICAgICAgICAgICAgICAgICBLRVlfVEFHLkYxNF0sXG4gIFtLRVkuRjE1LCAgICAgICAgICAgICAgICAgIEtFWV9UQUcuRjE1XSxcbiAgW0tFWS5GMTYsICAgICAgICAgICAgICAgICAgS0VZX1RBRy5GMTZdLFxuICBbS0VZLkYxNywgICAgICAgICAgICAgICAgICBLRVlfVEFHLkYxN10sXG4gIFtLRVkuRjE4LCAgICAgICAgICAgICAgICAgIEtFWV9UQUcuRjE4XSxcbiAgW0tFWS5GMTksICAgICAgICAgICAgICAgICAgS0VZX1RBRy5GMTldLFxuICBbS0VZLkYyMCwgICAgICAgICAgICAgICAgICBLRVlfVEFHLkYyMF0sXG4gIFtLRVkuRjIxLCAgICAgICAgICAgICAgICAgIEtFWV9UQUcuRjIxXSxcbiAgW0tFWS5GMjIsICAgICAgICAgICAgICAgICAgS0VZX1RBRy5GMjJdLFxuICBbS0VZLkYyMywgICAgICAgICAgICAgICAgICBLRVlfVEFHLkYyM10sXG4gIFtLRVkuRjI0LCAgICAgICAgICAgICAgICAgIEtFWV9UQUcuRjI0XSxcbiAgW0tFWS5JTlRFUk5BVElPTkFMMSwgICAgICAgS0VZX1RBRy5JTlRFUk5BVElPTkFMMV0sXG4gIFtLRVkuSU5URVJOQVRJT05BTDIsICAgICAgIEtFWV9UQUcuSU5URVJOQVRJT05BTDJdLFxuICBbS0VZLklOVEVSTkFUSU9OQUwzLCAgICAgICBLRVlfVEFHLklOVEVSTkFUSU9OQUwzXSxcbiAgW0tFWS5JTlRFUk5BVElPTkFMNCwgICAgICAgS0VZX1RBRy5JTlRFUk5BVElPTkFMNF0sXG4gIFtLRVkuSU5URVJOQVRJT05BTDUsICAgICAgIEtFWV9UQUcuSU5URVJOQVRJT05BTDVdLFxuICBbS0VZLklOVEVSTkFUSU9OQUw2LCAgICAgICBLRVlfVEFHLklOVEVSTkFUSU9OQUw2XSxcbiAgW0tFWS5JTlRFUk5BVElPTkFMNywgICAgICAgS0VZX1RBRy5JTlRFUk5BVElPTkFMN10sXG4gIFtLRVkuSU5URVJOQVRJT05BTDgsICAgICAgIEtFWV9UQUcuSU5URVJOQVRJT05BTDhdLFxuICBbS0VZLklOVEVSTkFUSU9OQUw5LCAgICAgICBLRVlfVEFHLklOVEVSTkFUSU9OQUw5XSxcbiAgW0tFWS5MQU5HMSwgICAgICAgICAgICAgICAgS0VZX1RBRy5MQU5HMV0sXG4gIFtLRVkuTEFORzIsICAgICAgICAgICAgICAgIEtFWV9UQUcuTEFORzJdLFxuICBbS0VZLkxBTkczLCAgICAgICAgICAgICAgICBLRVlfVEFHLkxBTkczXSxcbiAgW0tFWS5MQU5HNCwgICAgICAgICAgICAgICAgS0VZX1RBRy5MQU5HNF0sXG4gIFtLRVkuTEFORzUsICAgICAgICAgICAgICAgIEtFWV9UQUcuTEFORzVdLFxuICBbS0VZLkhFTFAsICAgICAgICAgICAgICAgICBLRVlfVEFHLkhFTFBdLFxuICBbS0VZLk1VVEUsICAgICAgICAgICAgICAgICBLRVlfVEFHLk1VVEVdLFxuICBbS0VZLlZPTFVNRVVQLCAgICAgICAgICAgICBLRVlfVEFHLlZPTFVNRVVQXSxcbiAgW0tFWS5WT0xVTUVET1dOLCAgICAgICAgICAgS0VZX1RBRy5WT0xVTUVET1dOXSxcbl0pO1xuXG5mdW5jdGlvbiBWYWxfa2V5X2NvZGUoa2V5Y29kZSkge1xuICByZXR1cm4ga2NfdG9fdGFnLmdldChrZXljb2RlKTtcbn1cblxuLy9Qcm92aWRlczogS2V5X2NvZGVfdmFsXG4vL1JlcXVpcmVzOiBLRVksS0VZX1RBR1xuXG52YXIgdGFnX3RvX2tjID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0Lk1hcChbXG4gIFtLRVlfVEFHLkVTQ0FQRSwgICAgICAgICAgICAgICBLRVkuRVNDQVBFXSxcbiAgW0tFWV9UQUcuRjEsICAgICAgICAgICAgICAgICAgIEtFWS5GMV0sXG4gIFtLRVlfVEFHLkYyLCAgICAgICAgICAgICAgICAgICBLRVkuRjJdLFxuICBbS0VZX1RBRy5GMywgICAgICAgICAgICAgICAgICAgS0VZLkYzXSxcbiAgW0tFWV9UQUcuRjQsICAgICAgICAgICAgICAgICAgIEtFWS5GNF0sXG4gIFtLRVlfVEFHLkY1LCAgICAgICAgICAgICAgICAgICBLRVkuRjVdLFxuICBbS0VZX1RBRy5GNiwgICAgICAgICAgICAgICAgICAgS0VZLkY2XSxcbiAgW0tFWV9UQUcuRjcsICAgICAgICAgICAgICAgICAgIEtFWS5GN10sXG4gIFtLRVlfVEFHLkY4LCAgICAgICAgICAgICAgICAgICBLRVkuRjhdLFxuICBbS0VZX1RBRy5GOSwgICAgICAgICAgICAgICAgICAgS0VZLkY5XSxcbiAgW0tFWV9UQUcuRjEwLCAgICAgICAgICAgICAgICAgIEtFWS5GMTBdLFxuICBbS0VZX1RBRy5GMTEsICAgICAgICAgICAgICAgICAgS0VZLkYxMV0sXG4gIFtLRVlfVEFHLkYxMiwgICAgICAgICAgICAgICAgICBLRVkuRjEyXSxcbiAgW0tFWV9UQUcuUFJJTlRTQ1JFRU4sICAgICAgICAgIEtFWS5QUklOVFNDUkVFTl0sXG4gIFtLRVlfVEFHLlNDUk9MTExPQ0ssICAgICAgICAgICBLRVkuU0NST0xMTE9DS10sXG4gIFtLRVlfVEFHLlBBVVNFLCAgICAgICAgICAgICAgICBLRVkuUEFVU0VdLFxuICBbS0VZX1RBRy5HUkFWRV9USUxERSwgICAgICAgICAgS0VZLkdSQVZFX1RJTERFXSxcbiAgW0tFWV9UQUcuXzFfRVhDTEFNQVRJT04sICAgICAgIEtFWS5fMV9FWENMQU1BVElPTl0sXG4gIFtLRVlfVEFHLl8yX0FULCAgICAgICAgICAgICAgICBLRVkuXzJfQVRdLFxuICBbS0VZX1RBRy5fM19OVU1CRVIsICAgICAgICAgICAgS0VZLl8zX05VTUJFUl0sXG4gIFtLRVlfVEFHLl80X0RPTExBUiwgICAgICAgICAgICBLRVkuXzRfRE9MTEFSXSxcbiAgW0tFWV9UQUcuXzVfUEVSQ0VOVCwgICAgICAgICAgIEtFWS5fNV9QRVJDRU5UXSxcbiAgW0tFWV9UQUcuXzZfQ0FSRVQsICAgICAgICAgICAgIEtFWS5fNl9DQVJFVF0sXG4gIFtLRVlfVEFHLl83X0FNUEVSU0FORCwgICAgICAgICBLRVkuXzdfQU1QRVJTQU5EXSxcbiAgW0tFWV9UQUcuXzhfQVNURVJJU0ssICAgICAgICAgIEtFWS5fOF9BU1RFUklTS10sXG4gIFtLRVlfVEFHLl85X0xQQVJFTlRIRVNJUywgICAgICBLRVkuXzlfTFBBUkVOVEhFU0lTXSxcbiAgW0tFWV9UQUcuXzBfUlBBUkVOVEhFU0lTLCAgICAgIEtFWS5fMF9SUEFSRU5USEVTSVNdLFxuICBbS0VZX1RBRy5NSU5VU19VTkRFUlNDT1JFLCAgICAgS0VZLk1JTlVTX1VOREVSU0NPUkVdLFxuICBbS0VZX1RBRy5FUVVBTF9QTFVTLCAgICAgICAgICAgS0VZLkVRVUFMX1BMVVNdLFxuICBbS0VZX1RBRy5CQUNLU1BBQ0UsICAgICAgICAgICAgS0VZLkJBQ0tTUEFDRV0sXG4gIFtLRVlfVEFHLlRBQiwgICAgICAgICAgICAgICAgICBLRVkuVEFCXSxcbiAgW0tFWV9UQUcuUSwgICAgICAgICAgICAgICAgICAgIEtFWS5RXSxcbiAgW0tFWV9UQUcuVywgICAgICAgICAgICAgICAgICAgIEtFWS5XXSxcbiAgW0tFWV9UQUcuRSwgICAgICAgICAgICAgICAgICAgIEtFWS5FXSxcbiAgW0tFWV9UQUcuUiwgICAgICAgICAgICAgICAgICAgIEtFWS5SXSxcbiAgW0tFWV9UQUcuVCwgICAgICAgICAgICAgICAgICAgIEtFWS5UXSxcbiAgW0tFWV9UQUcuWSwgICAgICAgICAgICAgICAgICAgIEtFWS5ZXSxcbiAgW0tFWV9UQUcuVSwgICAgICAgICAgICAgICAgICAgIEtFWS5VXSxcbiAgW0tFWV9UQUcuSSwgICAgICAgICAgICAgICAgICAgIEtFWS5JXSxcbiAgW0tFWV9UQUcuTywgICAgICAgICAgICAgICAgICAgIEtFWS5PXSxcbiAgW0tFWV9UQUcuUCwgICAgICAgICAgICAgICAgICAgIEtFWS5QXSxcbiAgW0tFWV9UQUcuTEJSQUNLRVRfQ1VSTFksICAgICAgIEtFWS5MQlJBQ0tFVF9DVVJMWV0sXG4gIFtLRVlfVEFHLlJCUkFDS0VUX0NVUkxZLCAgICAgICBLRVkuUkJSQUNLRVRfQ1VSTFldLFxuICBbS0VZX1RBRy5CQUNLU0xBU0hfUElQRSwgICAgICAgS0VZLkJBQ0tTTEFTSF9QSVBFXSxcbiAgW0tFWV9UQUcuQ0FQU0xPQ0ssICAgICAgICAgICAgIEtFWS5DQVBTTE9DS10sXG4gIFtLRVlfVEFHLkEsICAgICAgICAgICAgICAgICAgICBLRVkuQV0sXG4gIFtLRVlfVEFHLlMsICAgICAgICAgICAgICAgICAgICBLRVkuU10sXG4gIFtLRVlfVEFHLkQsICAgICAgICAgICAgICAgICAgICBLRVkuRF0sXG4gIFtLRVlfVEFHLkYsICAgICAgICAgICAgICAgICAgICBLRVkuRl0sXG4gIFtLRVlfVEFHLkcsICAgICAgICAgICAgICAgICAgICBLRVkuR10sXG4gIFtLRVlfVEFHLkgsICAgICAgICAgICAgICAgICAgICBLRVkuSF0sXG4gIFtLRVlfVEFHLkosICAgICAgICAgICAgICAgICAgICBLRVkuSl0sXG4gIFtLRVlfVEFHLkssICAgICAgICAgICAgICAgICAgICBLRVkuS10sXG4gIFtLRVlfVEFHLkwsICAgICAgICAgICAgICAgICAgICBLRVkuTF0sXG4gIFtLRVlfVEFHLlNFTUlDT0xPTl9DT0xPTiwgICAgICBLRVkuU0VNSUNPTE9OX0NPTE9OXSxcbiAgW0tFWV9UQUcuUVVPVEVfRE9VQkxFUVVPVEUsICAgIEtFWS5RVU9URV9ET1VCTEVRVU9URV0sXG4gIFtLRVlfVEFHLk5PTlVTX05VTUJFUl9USUxERSwgICBLRVkuTk9OVVNfTlVNQkVSX1RJTERFXSxcbiAgW0tFWV9UQUcuUkVUVVJOLCAgICAgICAgICAgICAgIEtFWS5SRVRVUk5dLFxuICBbS0VZX1RBRy5MU0hJRlQsICAgICAgICAgICAgICAgS0VZLkxTSElGVF0sXG4gIFtLRVlfVEFHLk5PTlVTX0JBQ0tTTEFTSF9QSVBFLCBLRVkuTk9OVVNfQkFDS1NMQVNIX1BJUEVdLFxuICBbS0VZX1RBRy5aLCAgICAgICAgICAgICAgICAgICAgS0VZLlpdLFxuICBbS0VZX1RBRy5YLCAgICAgICAgICAgICAgICAgICAgS0VZLlhdLFxuICBbS0VZX1RBRy5DLCAgICAgICAgICAgICAgICAgICAgS0VZLkNdLFxuICBbS0VZX1RBRy5WLCAgICAgICAgICAgICAgICAgICAgS0VZLlZdLFxuICBbS0VZX1RBRy5CLCAgICAgICAgICAgICAgICAgICAgS0VZLkJdLFxuICBbS0VZX1RBRy5OLCAgICAgICAgICAgICAgICAgICAgS0VZLk5dLFxuICBbS0VZX1RBRy5NLCAgICAgICAgICAgICAgICAgICAgS0VZLk1dLFxuICBbS0VZX1RBRy5DT01NQV9MRVNTLCAgICAgICAgICAgS0VZLkNPTU1BX0xFU1NdLFxuICBbS0VZX1RBRy5QRVJJT0RfR1JFQVRFUiwgICAgICAgS0VZLlBFUklPRF9HUkVBVEVSXSxcbiAgW0tFWV9UQUcuU0xBU0hfUVVFU1RJT04sICAgICAgIEtFWS5TTEFTSF9RVUVTVElPTl0sXG4gIFtLRVlfVEFHLlJTSElGVCwgICAgICAgICAgICAgICBLRVkuUlNISUZUXSxcbiAgW0tFWV9UQUcuTENPTlRST0wsICAgICAgICAgICAgIEtFWS5MQ09OVFJPTF0sXG4gIFtLRVlfVEFHLkxNRVRBLCAgICAgICAgICAgICAgICBLRVkuTE1FVEFdLFxuICBbS0VZX1RBRy5MQUxULCAgICAgICAgICAgICAgICAgS0VZLkxBTFRdLFxuICBbS0VZX1RBRy5TUEFDRUJBUiwgICAgICAgICAgICAgS0VZLlNQQUNFQkFSXSxcbiAgW0tFWV9UQUcuUkFMVCwgICAgICAgICAgICAgICAgIEtFWS5SQUxUXSxcbiAgW0tFWV9UQUcuUk1FVEEsICAgICAgICAgICAgICAgIEtFWS5STUVUQV0sXG4gIFtLRVlfVEFHLk1FTlUsICAgICAgICAgICAgICAgICBLRVkuTUVOVV0sXG4gIFtLRVlfVEFHLlJDT05UUk9MLCAgICAgICAgICAgICBLRVkuUkNPTlRST0xdLFxuICBbS0VZX1RBRy5JTlNFUlQsICAgICAgICAgICAgICAgS0VZLklOU0VSVF0sXG4gIFtLRVlfVEFHLkhPTUUsICAgICAgICAgICAgICAgICBLRVkuSE9NRV0sXG4gIFtLRVlfVEFHLlBBR0VVUCwgICAgICAgICAgICAgICBLRVkuUEFHRVVQXSxcbiAgW0tFWV9UQUcuREVMRVRFRk9SV0FSRCwgICAgICAgIEtFWS5ERUxFVEVGT1JXQVJEXSxcbiAgW0tFWV9UQUcuRU5ELCAgICAgICAgICAgICAgICAgIEtFWS5FTkRdLFxuICBbS0VZX1RBRy5QQUdFRE9XTiwgICAgICAgICAgICAgS0VZLlBBR0VET1dOXSxcbiAgW0tFWV9UQUcuVVBBUlJPVywgICAgICAgICAgICAgIEtFWS5VUEFSUk9XXSxcbiAgW0tFWV9UQUcuTEVGVEFSUk9XLCAgICAgICAgICAgIEtFWS5MRUZUQVJST1ddLFxuICBbS0VZX1RBRy5ET1dOQVJST1csICAgICAgICAgICAgS0VZLkRPV05BUlJPV10sXG4gIFtLRVlfVEFHLlJJR0hUQVJST1csICAgICAgICAgICBLRVkuUklHSFRBUlJPV10sXG4gIFtLRVlfVEFHLlBBRF9OVU1MT0NLX0NMRUFSLCAgICBLRVkuUEFEX05VTUxPQ0tfQ0xFQVJdLFxuICBbS0VZX1RBRy5QQURfRVFVQUxTLCAgICAgICAgICAgS0VZLlBBRF9FUVVBTFNdLFxuICBbS0VZX1RBRy5QQURfRElWSURFLCAgICAgICAgICAgS0VZLlBBRF9ESVZJREVdLFxuICBbS0VZX1RBRy5QQURfTVVMVElQTFksICAgICAgICAgS0VZLlBBRF9NVUxUSVBMWV0sXG4gIFtLRVlfVEFHLlBBRF9NSU5VUywgICAgICAgICAgICBLRVkuUEFEX01JTlVTXSxcbiAgW0tFWV9UQUcuUEFEXzdfSE9NRSwgICAgICAgICAgIEtFWS5QQURfN19IT01FXSxcbiAgW0tFWV9UQUcuUEFEXzhfVVBBUlJPVywgICAgICAgIEtFWS5QQURfOF9VUEFSUk9XXSxcbiAgW0tFWV9UQUcuUEFEXzlfUEFHRVVQLCAgICAgICAgIEtFWS5QQURfOV9QQUdFVVBdLFxuICBbS0VZX1RBRy5QQURfUExVUywgICAgICAgICAgICAgS0VZLlBBRF9QTFVTXSxcbiAgW0tFWV9UQUcuUEFEXzRfTEVGVEFSUk9XLCAgICAgIEtFWS5QQURfNF9MRUZUQVJST1ddLFxuICBbS0VZX1RBRy5QQURfNSwgICAgICAgICAgICAgICAgS0VZLlBBRF81XSxcbiAgW0tFWV9UQUcuUEFEXzZfUklHSFRBUlJPVywgICAgIEtFWS5QQURfNl9SSUdIVEFSUk9XXSxcbiAgW0tFWV9UQUcuUEFEX0NPTU1BLCAgICAgICAgICAgIEtFWS5QQURfQ09NTUFdLFxuICBbS0VZX1RBRy5QQURfMV9FTkQsICAgICAgICAgICAgS0VZLlBBRF8xX0VORF0sXG4gIFtLRVlfVEFHLlBBRF8yX0RPV05BUlJPVywgICAgICBLRVkuUEFEXzJfRE9XTkFSUk9XXSxcbiAgW0tFWV9UQUcuUEFEXzNfUEFHRURPV04sICAgICAgIEtFWS5QQURfM19QQUdFRE9XTl0sXG4gIFtLRVlfVEFHLlBBRF8wX0lOU0VSVCwgICAgICAgICBLRVkuUEFEXzBfSU5TRVJUXSxcbiAgW0tFWV9UQUcuUEFEX0RFQ0lNQUxfREVMRVRFLCAgIEtFWS5QQURfREVDSU1BTF9ERUxFVEVdLFxuICBbS0VZX1RBRy5QQURfRU5URVIsICAgICAgICAgICAgS0VZLlBBRF9FTlRFUl0sXG4gIFtLRVlfVEFHLkYxMywgICAgICAgICAgICAgICAgICBLRVkuRjEzXSxcbiAgW0tFWV9UQUcuRjE0LCAgICAgICAgICAgICAgICAgIEtFWS5GMTRdLFxuICBbS0VZX1RBRy5GMTUsICAgICAgICAgICAgICAgICAgS0VZLkYxNV0sXG4gIFtLRVlfVEFHLkYxNiwgICAgICAgICAgICAgICAgICBLRVkuRjE2XSxcbiAgW0tFWV9UQUcuRjE3LCAgICAgICAgICAgICAgICAgIEtFWS5GMTddLFxuICBbS0VZX1RBRy5GMTgsICAgICAgICAgICAgICAgICAgS0VZLkYxOF0sXG4gIFtLRVlfVEFHLkYxOSwgICAgICAgICAgICAgICAgICBLRVkuRjE5XSxcbiAgW0tFWV9UQUcuRjIwLCAgICAgICAgICAgICAgICAgIEtFWS5GMjBdLFxuICBbS0VZX1RBRy5GMjEsICAgICAgICAgICAgICAgICAgS0VZLkYyMV0sXG4gIFtLRVlfVEFHLkYyMiwgICAgICAgICAgICAgICAgICBLRVkuRjIyXSxcbiAgW0tFWV9UQUcuRjIzLCAgICAgICAgICAgICAgICAgIEtFWS5GMjNdLFxuICBbS0VZX1RBRy5GMjQsICAgICAgICAgICAgICAgICAgS0VZLkYyNF0sXG4gIFtLRVlfVEFHLklOVEVSTkFUSU9OQUwxLCAgICAgICBLRVkuSU5URVJOQVRJT05BTDFdLFxuICBbS0VZX1RBRy5JTlRFUk5BVElPTkFMMiwgICAgICAgS0VZLklOVEVSTkFUSU9OQUwyXSxcbiAgW0tFWV9UQUcuSU5URVJOQVRJT05BTDMsICAgICAgIEtFWS5JTlRFUk5BVElPTkFMM10sXG4gIFtLRVlfVEFHLklOVEVSTkFUSU9OQUw0LCAgICAgICBLRVkuSU5URVJOQVRJT05BTDRdLFxuICBbS0VZX1RBRy5JTlRFUk5BVElPTkFMNSwgICAgICAgS0VZLklOVEVSTkFUSU9OQUw1XSxcbiAgW0tFWV9UQUcuSU5URVJOQVRJT05BTDYsICAgICAgIEtFWS5JTlRFUk5BVElPTkFMNl0sXG4gIFtLRVlfVEFHLklOVEVSTkFUSU9OQUw3LCAgICAgICBLRVkuSU5URVJOQVRJT05BTDddLFxuICBbS0VZX1RBRy5JTlRFUk5BVElPTkFMOCwgICAgICAgS0VZLklOVEVSTkFUSU9OQUw4XSxcbiAgW0tFWV9UQUcuSU5URVJOQVRJT05BTDksICAgICAgIEtFWS5JTlRFUk5BVElPTkFMOV0sXG4gIFtLRVlfVEFHLkxBTkcxLCAgICAgICAgICAgICAgICBLRVkuTEFORzFdLFxuICBbS0VZX1RBRy5MQU5HMiwgICAgICAgICAgICAgICAgS0VZLkxBTkcyXSxcbiAgW0tFWV9UQUcuTEFORzMsICAgICAgICAgICAgICAgIEtFWS5MQU5HM10sXG4gIFtLRVlfVEFHLkxBTkc0LCAgICAgICAgICAgICAgICBLRVkuTEFORzRdLFxuICBbS0VZX1RBRy5MQU5HNSwgICAgICAgICAgICAgICAgS0VZLkxBTkc1XSxcbiAgW0tFWV9UQUcuSEVMUCwgICAgICAgICAgICAgICAgIEtFWS5IRUxQXSxcbiAgW0tFWV9UQUcuTVVURSwgICAgICAgICAgICAgICAgIEtFWS5NVVRFXSxcbiAgW0tFWV9UQUcuVk9MVU1FVVAsICAgICAgICAgICAgIEtFWS5WT0xVTUVVUF0sXG4gIFtLRVlfVEFHLlZPTFVNRURPV04sICAgICAgICAgICBLRVkuVk9MVU1FRE9XTl0sXG5dKTtcblxuZnVuY3Rpb24gS2V5X2NvZGVfdmFsKGtleWNvZGUpIHtcbiAgcmV0dXJuIHRhZ190b19rYy5nZXQoa2V5Y29kZSk7XG59XG5cbi8vUHJvdmlkZXM6IFZhbF9rZXlfc3RhdGVcbi8vUmVxdWlyZXM6IEtFWV9TVEFURSxLRVlfU1RBVEVfVEFHXG5cbnZhciBrZXlfc3RhdGVfdG9fdGFnID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0Lk1hcChbXG4gIFtLRVlfU1RBVEUuVVAsICAgS0VZX1NUQVRFX1RBRy5VUF0sXG4gIFtLRVlfU1RBVEUuRE9XTiwgS0VZX1NUQVRFX1RBRy5ET1dOXSxcbl0pO1xuXG5mdW5jdGlvbiBWYWxfa2V5X3N0YXRlKHN0YXRlKSB7XG4gIHJldHVybiBrZXlfc3RhdGVfdG9fdGFnLmdldChzdGF0ZSk7XG59XG5cbi8vUHJvdmlkZXM6IFZhbF9idXR0b25cbi8vUmVxdWlyZXM6IEJVVFRPTixCVVRUT05fVEFHXG5cbnZhciBidXR0b25fdG9fdGFnID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0Lk1hcChbXG4gIFtCVVRUT04uTk9ORSwgICAgICAgQlVUVE9OX1RBRy5OT05FXSxcbiAgW0JVVFRPTi5MRUZULCAgICAgICBCVVRUT05fVEFHLkxFRlRdLFxuICBbQlVUVE9OLk1JRERMRSwgICAgIEJVVFRPTl9UQUcuTUlERExFXSxcbiAgW0JVVFRPTi5NSURETEUsICAgICBCVVRUT05fVEFHLlJJR0hUXSxcbiAgW0JVVFRPTi5XSEVFTF9VUCwgICBCVVRUT05fVEFHLldIRUVMX1VQXSxcbiAgW0JVVFRPTi5XSEVFTF9ET1dOLCBCVVRUT05fVEFHLldIRUVMX0RPV05dLFxuXSk7XG5cbmZ1bmN0aW9uIFZhbF9idXR0b24oYnV0dG9uKSB7XG4gIHJldHVybiBidXR0b25fdG9fdGFnLmdldChidXR0b24pO1xufVxuXG4vL1Byb3ZpZGVzOiBWYWxfYnV0dG9uX3N0YXRlXG4vL1JlcXVpcmVzOiBCVVRUT05fU1RBVEUsQlVUVE9OX1NUQVRFX1RBR1xuXG52YXIgYnV0dG9uX3N0YXRlX3RvX3RhZyA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5NYXAoW1xuICBbQlVUVE9OX1NUQVRFLlVQLCAgIEJVVFRPTl9TVEFURV9UQUcuVVBdLFxuICBbQlVUVE9OX1NUQVRFLkRPV04sIEJVVFRPTl9TVEFURV9UQUcuRE9XTl0sXG5dKTtcblxuZnVuY3Rpb24gVmFsX2J1dHRvbl9zdGF0ZShzdGF0ZSkge1xuICByZXR1cm4gYnV0dG9uX3N0YXRlX3RvX3RhZy5nZXQoc3RhdGUpO1xufVxuXG4vL1Byb3ZpZGVzOiBWYWxfcmVwZWF0XG4vL1JlcXVpcmVzOiBSRVBFQVRfVEFHXG5cbnZhciByZXBlYXRfdG9fdGFnID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0Lk1hcChbXG4gIFtcIm5vLXJlcGVhdFwiLCBSRVBFQVRfVEFHLk5PX1JFUEVBVF0sXG4gIFtcInJlcGVhdC14XCIsICBSRVBFQVRfVEFHLlJFUEVBVF9YXSxcbiAgW1wicmVwZWF0LXlcIiwgIFJFUEVBVF9UQUcuUkVQRUFUX1ldLFxuICBbXCJyZXBlYXRcIiwgICAgUkVQRUFUX1RBRy5SRVBFQVRfWFldLFxuXSk7XG5cbmZ1bmN0aW9uIFZhbF9yZXBlYXQocmVwZWF0KSB7XG4gIHJldHVybiByZXBlYXRfdG9fdGFnLmdldChyZXBlYXQpO1xufVxuXG4vL1Byb3ZpZGVzOiBSZXBlYXRfdmFsXG4vL1JlcXVpcmVzOiBSRVBFQVRfVEFHXG5cbnZhciB0YWdfdG9fcmVwZWF0ID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0Lk1hcChbXG4gIFtSRVBFQVRfVEFHLk5PX1JFUEVBVCwgXCJuby1yZXBlYXRcIl0sXG4gIFtSRVBFQVRfVEFHLlJFUEVBVF9YLCAgXCJyZXBlYXQteFwiXSxcbiAgW1JFUEVBVF9UQUcuUkVQRUFUX1ksICBcInJlcGVhdC15XCJdLFxuICBbUkVQRUFUX1RBRy5SRVBFQVRfWFksIFwicmVwZWF0XCJdLFxuXSk7XG5cbmZ1bmN0aW9uIFJlcGVhdF92YWwocmVwZWF0KSB7XG4gIHJldHVybiB0YWdfdG9fcmVwZWF0LmdldChyZXBlYXQpO1xufVxuXG4vL1Byb3ZpZGVzOiBWYWxfZHJhd19zdHlsZVxuLy9SZXF1aXJlczogX2NvbG9yX29mX2ludCxTVFlMRV9UQUdcbmZ1bmN0aW9uIFZhbF9kcmF3X3N0eWxlKHN0eWxlKSB7XG4gIHZhciBzID0gMDtcbiAgc3dpdGNoIChzdHlsZVswXSkge1xuICAgIGNhc2UgU1RZTEVfVEFHLkNPTE9SOlxuICAgICAgcyA9IF9jb2xvcl9vZl9pbnQoc3R5bGVbMV0pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBTVFlMRV9UQUcuR1JBRElFTlQ6XG4gICAgY2FzZSBTVFlMRV9UQUcuUEFUVEVSTjpcbiAgICAgIHMgPSBzdHlsZVsxXTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4gcztcbn1cblxuLy9Qcm92aWRlczogRHJhd19zdHlsZV92YWxcbi8vUmVxdWlyZXM6IFNUWUxFX1RBR1xuZnVuY3Rpb24gRHJhd19zdHlsZV92YWwoc3R5bGUpIHtcbiAgdmFyIHMgPSBbXTtcbiAgc1sxXSA9IHN0eWxlO1xuICBzd2l0Y2ggKHR5cGVvZihzdHlsZSkpIHtcbiAgICBjYXNlIFwic3RyaW5nXCIgOlxuICAgICAgc1swXSA9IFNUWUxFX1RBRy5DT0xPUjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJDYW52YXNHcmFkaWVudFwiIDpcbiAgICAgIHNbMF0gPSBTVFlMRV9UQUcuR1JBRElFTlQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiQ2FudmFzUGF0dGVyblwiIDpcbiAgICAgIHNbMF0gPSBTVFlMRV9UQUcuUEFUVEVSTjtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiBzO1xufVxuXG4vL1Byb3ZpZGVzOiBTbGFudF92YWxcbi8vUmVxdWlyZXM6IFNMQU5ULFNMQU5UX1RBR1xuXG52YXIgdGFnX3RvX3NsYW50ID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0Lk1hcChbXG4gIFtTTEFOVF9UQUcuUk9NQU4sICAgU0xBTlQuUk9NQU5dLFxuICBbU0xBTlRfVEFHLklUQUxJQywgIFNMQU5ULklUQUxJQ10sXG4gIFtTTEFOVF9UQUcuT0JMSVFVRSwgU0xBTlQuT0JMSVFVRV0sXG5dKTtcblxuZnVuY3Rpb24gU2xhbnRfdmFsKHNsYW50KSB7XG4gIHJldHVybiB0YWdfdG9fc2xhbnQuZ2V0KHNsYW50KTtcbn1cblxuLy9Qcm92aWRlczogVmFsX2pvaW5fdHlwZVxuLy9SZXF1aXJlczogSk9JTl9UWVBFX1RBR1xuXG52YXIgam9pbl90eXBlX3RvX3RhZyA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5NYXAoW1xuICBbXCJyb3VuZFwiLCBKT0lOX1RZUEVfVEFHLlJPVU5EXSxcbiAgW1wibWl0ZXJcIiwgSk9JTl9UWVBFX1RBRy5NSVRFUl0sXG4gIFtcImJldmVsXCIsIEpPSU5fVFlQRV9UQUcuQkVWRUxdLFxuXSk7XG5cbmZ1bmN0aW9uIFZhbF9qb2luX3R5cGUoam9pbikge1xuICByZXR1cm4gam9pbl90eXBlX3RvX3RhZy5nZXQoam9pbik7XG59XG5cbi8vUHJvdmlkZXM6IEpvaW5fdHlwZV92YWxcbi8vUmVxdWlyZXM6IEpPSU5fVFlQRV9UQUdcblxudmFyIHRhZ190b19qb2luX3R5cGUgPSBuZXcgam9vX2dsb2JhbF9vYmplY3QuTWFwKFtcbiAgW0pPSU5fVFlQRV9UQUcuUk9VTkQsIFwicm91bmRcIl0sXG4gIFtKT0lOX1RZUEVfVEFHLk1JVEVSLCBcIm1pdGVyXCJdLFxuICBbSk9JTl9UWVBFX1RBRy5CRVZFTCwgXCJiZXZlbFwiXSxcbl0pO1xuXG5mdW5jdGlvbiBKb2luX3R5cGVfdmFsKGpvaW4pIHtcbiAgcmV0dXJuIHRhZ190b19qb2luX3R5cGUuZ2V0KGpvaW4pO1xufVxuXG4vL1Byb3ZpZGVzOiBWYWxfY2FwX3R5cGVcbi8vUmVxdWlyZXM6IENBUF9UWVBFX1RBR1xuXG52YXIgY2FwX3R5cGVfdG9fdGFnID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0Lk1hcChbXG4gIFtcImJ1dHRcIiwgICBDQVBfVFlQRV9UQUcuQlVUVF0sXG4gIFtcInNxdWFyZVwiLCBDQVBfVFlQRV9UQUcuU1FVQVJFXSxcbiAgW1wicm91bmRcIiwgIENBUF9UWVBFX1RBRy5ST1VORF0sXG5dKTtcblxuZnVuY3Rpb24gVmFsX2NhcF90eXBlKGNhcCkge1xuICByZXR1cm4gY2FwX3R5cGVfdG9fdGFnLmdldChjYXApO1xufVxuXG4vL1Byb3ZpZGVzOiBDYXBfdHlwZV92YWxcbi8vUmVxdWlyZXM6IENBUF9UWVBFX1RBR1xuXG52YXIgdGFnX3RvX2NhcF90eXBlID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0Lk1hcChbXG4gIFtDQVBfVFlQRV9UQUcuQlVUVCwgICBcImJ1dHRcIl0sXG4gIFtDQVBfVFlQRV9UQUcuU1FVQVJFLCBcInNxdWFyZVwiXSxcbiAgW0NBUF9UWVBFX1RBRy5ST1VORCwgIFwicm91bmRcIl0sXG5dKTtcblxuZnVuY3Rpb24gQ2FwX3R5cGVfdmFsKGNhcCkge1xuICByZXR1cm4gdGFnX3RvX2NhcF90eXBlLmdldChjYXApO1xufVxuXG4vL1Byb3ZpZGVzOiBWYWxfY29tcG9wXG4vL1JlcXVpcmVzOiBDT01QT1BfVEFHXG5cbnZhciBjb21wb3BfdG9fdGFnID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0Lk1hcChbXG4gIFtcInNvdXJjZS1vdmVyXCIsICAgICAgQ09NUE9QX1RBRy5TT1VSQ0VfT1ZFUl0sXG4gIFtcInNvdXJjZS1pblwiLCAgICAgICAgQ09NUE9QX1RBRy5TT1VSQ0VfSU5dLFxuICBbXCJzb3VyY2Utb3V0XCIsICAgICAgIENPTVBPUF9UQUcuU09VUkNFX09VVF0sXG4gIFtcInNvdXJjZS1hdG9wXCIsICAgICAgQ09NUE9QX1RBRy5TT1VSQ0VfQVRPUF0sXG4gIFtcImRlc3RpbmF0aW9uLW92ZXJcIiwgQ09NUE9QX1RBRy5ERVNUSU5BVElPTl9PVkVSXSxcbiAgW1wiZGVzdGluYXRpb24taW5cIiwgICBDT01QT1BfVEFHLkRFU1RJTkFUSU9OX0lOXSxcbiAgW1wiZGVzdGluYXRpb24tb3V0XCIsICBDT01QT1BfVEFHLkRFU1RJTkFUSU9OX09VVF0sXG4gIFtcImRlc3RpbmF0aW9uLWF0b3BcIiwgQ09NUE9QX1RBRy5ERVNUSU5BVElPTl9BVE9QXSxcbiAgW1wibGlnaHRlclwiLCAgICAgICAgICBDT01QT1BfVEFHLkxJR0hURVJdLFxuICBbXCJjb3B5XCIsICAgICAgICAgICAgIENPTVBPUF9UQUcuQ09QWV0sXG4gIFtcInhvclwiLCAgICAgICAgICAgICAgQ09NUE9QX1RBRy5YT1JdLFxuICBbXCJtdWx0aXBseVwiLCAgICAgICAgIENPTVBPUF9UQUcuTVVMVElQTFldLFxuICBbXCJzY3JlZW5cIiwgICAgICAgICAgIENPTVBPUF9UQUcuU0NSRUVOXSxcbiAgW1wib3ZlcmxheVwiLCAgICAgICAgICBDT01QT1BfVEFHLk9WRVJMQVldLFxuICBbXCJkYXJrZW5cIiwgICAgICAgICAgIENPTVBPUF9UQUcuREFSS0VOXSxcbiAgW1wibGlnaHRlblwiLCAgICAgICAgICBDT01QT1BfVEFHLkxJR0hURU5dLFxuICBbXCJjb2xvci1kb2RnZVwiLCAgICAgIENPTVBPUF9UQUcuQ09MT1JfRE9ER0VdLFxuICBbXCJjb2xvci1idXJuXCIsICAgICAgIENPTVBPUF9UQUcuQ09MT1JfQlVSTl0sXG4gIFtcImhhcmQtbGlnaHRcIiwgICAgICAgQ09NUE9QX1RBRy5IQVJEX0xJR0hUXSxcbiAgW1wic29mdC1saWdodFwiLCAgICAgICBDT01QT1BfVEFHLlNPRlRfTElHSFRdLFxuICBbXCJkaWZmZXJlbmNlXCIsICAgICAgIENPTVBPUF9UQUcuRElGRkVSRU5DRV0sXG4gIFtcImV4Y2x1c2lvblwiLCAgICAgICAgQ09NUE9QX1RBRy5FWENMVVNJT05dLFxuICBbXCJodWVcIiwgICAgICAgICAgICAgIENPTVBPUF9UQUcuSFVFXSxcbiAgW1wic2F0dXJhdGlvblwiLCAgICAgICBDT01QT1BfVEFHLlNBVFVSQVRJT05dLFxuICBbXCJjb2xvclwiLCAgICAgICAgICAgIENPTVBPUF9UQUcuQ09MT1JdLFxuICBbXCJsdW1pbm9zaXR5XCIsICAgICAgIENPTVBPUF9UQUcuTFVNSU5PU0lUWV0sXG5dKTtcblxuZnVuY3Rpb24gVmFsX2NvbXBvcChjb21wb3ApIHtcbiAgcmV0dXJuIGNvbXBvcF90b190YWcuZ2V0KGNvbXBvcCk7XG59XG5cbi8vUHJvdmlkZXM6IENvbXBvcF92YWxcbi8vUmVxdWlyZXM6IENPTVBPUF9UQUdcblxudmFyIHRhZ190b19jb21wb3AgPSBuZXcgam9vX2dsb2JhbF9vYmplY3QuTWFwKFtcbiAgW0NPTVBPUF9UQUcuU09VUkNFX09WRVIsICAgICAgXCJzb3VyY2Utb3ZlclwiXSxcbiAgW0NPTVBPUF9UQUcuU09VUkNFX0lOLCAgICAgICAgXCJzb3VyY2UtaW5cIl0sXG4gIFtDT01QT1BfVEFHLlNPVVJDRV9PVVQsICAgICAgIFwic291cmNlLW91dFwiXSxcbiAgW0NPTVBPUF9UQUcuU09VUkNFX0FUT1AsICAgICAgXCJzb3VyY2UtYXRvcFwiXSxcbiAgW0NPTVBPUF9UQUcuREVTVElOQVRJT05fT1ZFUiwgXCJkZXN0aW5hdGlvbi1vdmVyXCJdLFxuICBbQ09NUE9QX1RBRy5ERVNUSU5BVElPTl9JTiwgICBcImRlc3RpbmF0aW9uLWluXCJdLFxuICBbQ09NUE9QX1RBRy5ERVNUSU5BVElPTl9PVVQsICBcImRlc3RpbmF0aW9uLW91dFwiXSxcbiAgW0NPTVBPUF9UQUcuREVTVElOQVRJT05fQVRPUCwgXCJkZXN0aW5hdGlvbi1hdG9wXCJdLFxuICBbQ09NUE9QX1RBRy5MSUdIVEVSLCAgICAgICAgICBcImxpZ2h0ZXJcIl0sXG4gIFtDT01QT1BfVEFHLkNPUFksICAgICAgICAgICAgIFwiY29weVwiXSxcbiAgW0NPTVBPUF9UQUcuWE9SLCAgICAgICAgICAgICAgXCJ4b3JcIl0sXG4gIFtDT01QT1BfVEFHLk1VTFRJUExZLCAgICAgICAgIFwibXVsdGlwbHlcIl0sXG4gIFtDT01QT1BfVEFHLlNDUkVFTiwgICAgICAgICAgIFwic2NyZWVuXCJdLFxuICBbQ09NUE9QX1RBRy5PVkVSTEFZLCAgICAgICAgICBcIm92ZXJsYXlcIl0sXG4gIFtDT01QT1BfVEFHLkRBUktFTiwgICAgICAgICAgIFwiZGFya2VuXCJdLFxuICBbQ09NUE9QX1RBRy5MSUdIVEVOLCAgICAgICAgICBcImxpZ2h0ZW5cIl0sXG4gIFtDT01QT1BfVEFHLkNPTE9SX0RPREdFLCAgICAgIFwiY29sb3ItZG9kZ2VcIl0sXG4gIFtDT01QT1BfVEFHLkNPTE9SX0JVUk4sICAgICAgIFwiY29sb3ItYnVyblwiXSxcbiAgW0NPTVBPUF9UQUcuSEFSRF9MSUdIVCwgICAgICAgXCJoYXJkLWxpZ2h0XCJdLFxuICBbQ09NUE9QX1RBRy5TT0ZUX0xJR0hULCAgICAgICBcInNvZnQtbGlnaHRcIl0sXG4gIFtDT01QT1BfVEFHLkRJRkZFUkVOQ0UsICAgICAgIFwiZGlmZmVyZW5jZVwiXSxcbiAgW0NPTVBPUF9UQUcuRVhDTFVTSU9OLCAgICAgICAgXCJleGNsdXNpb25cIl0sXG4gIFtDT01QT1BfVEFHLkhVRSwgICAgICAgICAgICAgIFwiaHVlXCJdLFxuICBbQ09NUE9QX1RBRy5TQVRVUkFUSU9OLCAgICAgICBcInNhdHVyYXRpb25cIl0sXG4gIFtDT01QT1BfVEFHLkNPTE9SLCAgICAgICAgICAgIFwiY29sb3JcIl0sXG4gIFtDT01QT1BfVEFHLkxVTUlOT1NJVFksICAgICAgIFwibHVtaW5vc2l0eVwiXSxcbl0pO1xuXG5mdW5jdGlvbiBDb21wb3BfdmFsKGNhcCkge1xuICByZXR1cm4gdGFnX3RvX2NvbXBvcC5nZXQoY2FwKTtcbn1cbiIsIi8vUHJvdmlkZXM6IGNhbWxfdW5peF9nZXR0aW1lb2ZkYXlcbi8vQWxpYXM6IHVuaXhfZ2V0dGltZW9mZGF5XG5mdW5jdGlvbiBjYW1sX3VuaXhfZ2V0dGltZW9mZGF5ICgpIHtcbiAgcmV0dXJuIChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkgLyAxMDAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfdGltZVxuLy9SZXF1aXJlczogY2FtbF91bml4X2dldHRpbWVvZmRheVxuLy9BbGlhczogdW5peF90aW1lXG5mdW5jdGlvbiBjYW1sX3VuaXhfdGltZSAoKSB7XG4gIHJldHVybiBNYXRoLmZsb29yKGNhbWxfdW5peF9nZXR0aW1lb2ZkYXkgKCkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfZ210aW1lXG4vL0FsaWFzOiB1bml4X2dtdGltZVxuZnVuY3Rpb24gY2FtbF91bml4X2dtdGltZSAodCkge1xuICB2YXIgZCA9IG5ldyBEYXRlICh0ICogMTAwMCk7XG4gIHZhciBkX251bSA9IGQuZ2V0VGltZSgpO1xuICB2YXIgamFudWFyeWZpcnN0ID0gKG5ldyBEYXRlKERhdGUuVVRDKGQuZ2V0VVRDRnVsbFllYXIoKSwgMCwgMSkpKS5nZXRUaW1lKCk7XG4gIHZhciBkb3kgPSBNYXRoLmZsb29yKChkX251bSAtIGphbnVhcnlmaXJzdCkgLyA4NjQwMDAwMCk7XG4gIHJldHVybiBCTE9DSygwLCBkLmdldFVUQ1NlY29uZHMoKSwgZC5nZXRVVENNaW51dGVzKCksIGQuZ2V0VVRDSG91cnMoKSxcbiAgICAgICAgICAgICAgIGQuZ2V0VVRDRGF0ZSgpLCBkLmdldFVUQ01vbnRoKCksIGQuZ2V0VVRDRnVsbFllYXIoKSAtIDE5MDAsXG4gICAgICAgICAgICAgICBkLmdldFVUQ0RheSgpLCBkb3ksXG4gICAgICAgICAgICAgICBmYWxzZSB8IDAgLyogZm9yIFVUQyBkYXlsaWdodCBzYXZpbmdzIHRpbWUgaXMgZmFsc2UgKi8pXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9sb2NhbHRpbWVcbi8vQWxpYXM6IHVuaXhfbG9jYWx0aW1lXG5mdW5jdGlvbiBjYW1sX3VuaXhfbG9jYWx0aW1lICh0KSB7XG4gIHZhciBkID0gbmV3IERhdGUgKHQgKiAxMDAwKTtcbiAgdmFyIGRfbnVtID0gZC5nZXRUaW1lKCk7XG4gIHZhciBqYW51YXJ5Zmlyc3QgPSAobmV3IERhdGUoZC5nZXRGdWxsWWVhcigpLCAwLCAxKSkuZ2V0VGltZSgpO1xuICB2YXIgZG95ID0gTWF0aC5mbG9vcigoZF9udW0gLSBqYW51YXJ5Zmlyc3QpIC8gODY0MDAwMDApO1xuICB2YXIgamFuID0gbmV3IERhdGUoZC5nZXRGdWxsWWVhcigpLCAwLCAxKTtcbiAgdmFyIGp1bCA9IG5ldyBEYXRlKGQuZ2V0RnVsbFllYXIoKSwgNiwgMSk7XG4gIHZhciBzdGRUaW1lem9uZU9mZnNldCA9IE1hdGgubWF4KGphbi5nZXRUaW1lem9uZU9mZnNldCgpLCBqdWwuZ2V0VGltZXpvbmVPZmZzZXQoKSk7XG4gIHJldHVybiBCTE9DSygwLCBkLmdldFNlY29uZHMoKSwgZC5nZXRNaW51dGVzKCksIGQuZ2V0SG91cnMoKSxcbiAgICAgICAgICAgICAgIGQuZ2V0RGF0ZSgpLCBkLmdldE1vbnRoKCksIGQuZ2V0RnVsbFllYXIoKSAtIDE5MDAsXG4gICAgICAgICAgICAgICBkLmdldERheSgpLCBkb3ksXG4gICAgICAgICAgICAgICAoZC5nZXRUaW1lem9uZU9mZnNldCgpIDwgc3RkVGltZXpvbmVPZmZzZXQpIHwgMCAvKiBkYXlsaWdodCBzYXZpbmdzIHRpbWUgIGZpZWxkLiAqLylcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X21rdGltZVxuLy9SZXF1aXJlczogY2FtbF91bml4X2xvY2FsdGltZVxuLy9BbGlhczogdW5peF9ta3RpbWVcbmZ1bmN0aW9uIGNhbWxfdW5peF9ta3RpbWUodG0pe1xuICB2YXIgZCA9IChuZXcgRGF0ZSh0bVs2XSsxOTAwLHRtWzVdLHRtWzRdLHRtWzNdLHRtWzJdLHRtWzFdKSkuZ2V0VGltZSgpO1xuICB2YXIgdCA9IE1hdGguZmxvb3IoZCAvIDEwMDApO1xuICB2YXIgdG0yID0gY2FtbF91bml4X2xvY2FsdGltZSh0KTtcbiAgcmV0dXJuIEJMT0NLKDAsdCx0bTIpO1xufVxuLy9Qcm92aWRlczogY2FtbF91bml4X3N0YXJ0dXAgY29uc3Rcbi8vQWxpYXM6IHdpbl9zdGFydHVwXG5mdW5jdGlvbiBjYW1sX3VuaXhfc3RhcnR1cCgpIHt9XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9jbGVhbnVwIGNvbnN0XG4vL0FsaWFzOiB3aW5fY2xlYW51cFxuZnVuY3Rpb24gY2FtbF91bml4X2NsZWFudXAoKSB7fVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfZmlsZWRlc2NyX29mX2ZkIGNvbnN0XG4vL0FsaWFzOiB3aW5faGFuZGxlX2ZkXG5mdW5jdGlvbiBjYW1sX3VuaXhfZmlsZWRlc2NyX29mX2ZkKHgpIHtyZXR1cm4geDt9XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9pc2F0dHlcbi8vUmVxdWlyZXM6IGZzX25vZGVfc3VwcG9ydGVkXG4vL0FsaWFzOiB1bml4X2lzYXR0eVxuZnVuY3Rpb24gY2FtbF91bml4X2lzYXR0eShmaWxlRGVzY3JpcHRvcikge1xuICBpZihmc19ub2RlX3N1cHBvcnRlZCgpKSB7XG4gICAgdmFyIHR0eSA9IHJlcXVpcmUoJ3R0eScpO1xuICAgIHJldHVybiB0dHkuaXNhdHR5KGZpbGVEZXNjcmlwdG9yKT8xOjA7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfaXNhdHR5XG4vL0FsaWFzOiB1bml4X2lzYXR0eVxuLy9JZjogYnJvd3NlclxuZnVuY3Rpb24gY2FtbF91bml4X2lzYXR0eShmaWxlRGVzY3JpcHRvcikge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogbWFrZV91bml4X2Vycl9hcmdzXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZ1xudmFyIHVuaXhfZXJyb3IgPSBbXG4gIC8qID09PVVuaXguZXJyb3I9PT1cbiAgICpcbiAgICogVGhpcyBhcnJheSBpcyBpbiBvcmRlciBvZiB0aGUgdmFyaWFudCBpbiBPQ2FtbFxuICAgKi9cbiAgXCJFMkJJR1wiLCBcIkVBQ0NFU1wiLCBcIkVBR0FJTlwiLCBcIkVCQURGXCIsIFwiRUJVU1lcIiwgXCJFQ0hJTERcIiwgXCJFREVBRExLXCIsIFwiRURPTVwiLFxuICBcIkVFWElTVFwiLCBcIkVGQVVMVFwiLCBcIkVGQklHXCIsIFwiRUlOVFJcIiwgXCJFSU5WQUxcIiwgXCJFSU9cIiwgXCJFSVNESVJcIiwgXCJFTUZJTEVcIixcbiAgXCJFTUxJTktcIiwgXCJFTkFNRVRPT0xPTkdcIiwgXCJFTkZJTEVcIiwgXCJFTk9ERVZcIiwgXCJFTk9FTlRcIiwgXCJFTk9FWEVDXCIsIFwiRU5PTENLXCIsXG4gIFwiRU5PTUVNXCIsIFwiRU5PU1BDXCIsIFwiRU5PU1lTXCIsIFwiRU5PVERJUlwiLCBcIkVOT1RFTVBUWVwiLCBcIkVOT1RUWVwiLCBcIkVOWElPXCIsXG4gIFwiRVBFUk1cIiwgXCJFUElQRVwiLCBcIkVSQU5HRVwiLCBcIkVST0ZTXCIsIFwiRVNQSVBFXCIsIFwiRVNSQ0hcIiwgXCJFWERFVlwiLCBcIkVXT1VMREJMT0NLXCIsXG4gIFwiRUlOUFJPR1JFU1NcIiwgXCJFQUxSRUFEWVwiLCBcIkVOT1RTT0NLXCIsIFwiRURFU1RBRERSUkVRXCIsIFwiRU1TR1NJWkVcIixcbiAgXCJFUFJPVE9UWVBFXCIsIFwiRU5PUFJPVE9PUFRcIiwgXCJFUFJPVE9OT1NVUFBPUlRcIiwgXCJFU09DS1ROT1NVUFBPUlRcIixcbiAgXCJFT1BOT1RTVVBQXCIsIFwiRVBGTk9TVVBQT1JUXCIsIFwiRUFGTk9TVVBQT1JUXCIsIFwiRUFERFJJTlVTRVwiLCBcIkVBRERSTk9UQVZBSUxcIixcbiAgXCJFTkVURE9XTlwiLCBcIkVORVRVTlJFQUNIXCIsIFwiRU5FVFJFU0VUXCIsIFwiRUNPTk5BQk9SVEVEXCIsIFwiRUNPTk5SRVNFVFwiLCBcIkVOT0JVRlNcIixcbiAgXCJFSVNDT05OXCIsIFwiRU5PVENPTk5cIiwgXCJFU0hVVERPV05cIiwgXCJFVE9PTUFOWVJFRlNcIiwgXCJFVElNRURPVVRcIiwgXCJFQ09OTlJFRlVTRURcIixcbiAgXCJFSE9TVERPV05cIiwgXCJFSE9TVFVOUkVBQ0hcIiwgXCJFTE9PUFwiLCBcIkVPVkVSRkxPV1wiXG5dO1xuZnVuY3Rpb24gbWFrZV91bml4X2Vycl9hcmdzKGNvZGUsIHN5c2NhbGwsIHBhdGgsIGVycm5vKSB7XG4gIHZhciB2YXJpYW50ID0gdW5peF9lcnJvci5pbmRleE9mKGNvZGUpO1xuICBpZiAodmFyaWFudCA8IDApIHtcbiAgICAvLyBEZWZhdWx0IGlmIHVuZGVmaW5lZFxuICAgIGlmIChlcnJubyA9PSBudWxsKSB7XG4gICAgICBlcnJubyA9IC05OTk5XG4gICAgfVxuICAgIC8vIElmIG5vbmUgb2YgdGhlIGFib3ZlIHZhcmlhbnRzLCBmYWxsYmFjayB0byBFVU5LTk9XTkVSUihpbnQpXG4gICAgdmFyaWFudCA9IEJMT0NLKDAsIGVycm5vKTtcbiAgfVxuICB2YXIgYXJncyA9IFtcbiAgICB2YXJpYW50LFxuICAgIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKHN5c2NhbGwgfHwgXCJcIiksXG4gICAgY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcocGF0aCB8fCBcIlwiKVxuICBdO1xuICByZXR1cm4gYXJncztcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X3N0YXRcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlLCBjYW1sX2ZhaWx3aXRoXG4vL0FsaWFzOiB1bml4X3N0YXRcbmZ1bmN0aW9uIGNhbWxfdW5peF9zdGF0KG5hbWUpIHtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgaWYgKCFyb290LmRldmljZS5zdGF0KSB7XG4gICAgY2FtbF9mYWlsd2l0aChcImNhbWxfdW5peF9zdGF0OiBub3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbiAgcmV0dXJuIHJvb3QuZGV2aWNlLnN0YXQocm9vdC5yZXN0LCAvKiByYWlzZSBVbml4X2Vycm9yICovIHRydWUpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfc3RhdF82NFxuLy9SZXF1aXJlczogY2FtbF91bml4X3N0YXQsIGNhbWxfaW50NjRfb2ZfaW50MzJcbi8vQWxpYXM6IHVuaXhfc3RhdF82NFxuZnVuY3Rpb24gY2FtbF91bml4X3N0YXRfNjQobmFtZSkge1xuICB2YXIgciA9IGNhbWxfdW5peF9zdGF0KG5hbWUpO1xuICByWzldID0gY2FtbF9pbnQ2NF9vZl9pbnQzMihyWzldKTtcbiAgcmV0dXJuIHI7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9sc3RhdFxuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2UsIGNhbWxfZmFpbHdpdGhcbi8vQWxpYXM6IHVuaXhfbHN0YXRcbmZ1bmN0aW9uIGNhbWxfdW5peF9sc3RhdChuYW1lKSB7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIGlmICghcm9vdC5kZXZpY2UubHN0YXQpIHtcbiAgICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF91bml4X2xzdGF0OiBub3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbiAgcmV0dXJuIHJvb3QuZGV2aWNlLmxzdGF0KHJvb3QucmVzdCwgLyogcmFpc2UgVW5peF9lcnJvciAqLyB0cnVlKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X2xzdGF0XzY0XG4vL1JlcXVpcmVzOiBjYW1sX3VuaXhfbHN0YXQsIGNhbWxfaW50NjRfb2ZfaW50MzJcbi8vQWxpYXM6IHVuaXhfbHN0YXRfNjRcbmZ1bmN0aW9uIGNhbWxfdW5peF9sc3RhdF82NChuYW1lKSB7XG4gIHZhciByID0gY2FtbF91bml4X2xzdGF0KG5hbWUpO1xuICByWzldID0gY2FtbF9pbnQ2NF9vZl9pbnQzMihyWzldKTtcbiAgcmV0dXJuIHI7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9ta2RpclxuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2UsIGNhbWxfZmFpbHdpdGhcbi8vQWxpYXM6IHVuaXhfbWtkaXJcbmZ1bmN0aW9uIGNhbWxfdW5peF9ta2RpcihuYW1lLCBwZXJtKSB7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIGlmICghcm9vdC5kZXZpY2UubWtkaXIpIHtcbiAgICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF91bml4X21rZGlyOiBub3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbiAgcmV0dXJuIHJvb3QuZGV2aWNlLm1rZGlyKHJvb3QucmVzdCwgcGVybSwgLyogcmFpc2UgVW5peF9lcnJvciAqLyB0cnVlKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X3JtZGlyXG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZSwgY2FtbF9mYWlsd2l0aFxuLy9BbGlhczogdW5peF9ybWRpclxuZnVuY3Rpb24gY2FtbF91bml4X3JtZGlyKG5hbWUpIHtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgaWYgKCFyb290LmRldmljZS5ybWRpcikge1xuICAgIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3VuaXhfcm1kaXI6IG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfVxuICByZXR1cm4gcm9vdC5kZXZpY2Uucm1kaXIocm9vdC5yZXN0LCAvKiByYWlzZSBVbml4X2Vycm9yICovIHRydWUpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfc3ltbGlua1xuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2UsIGNhbWxfZmFpbHdpdGhcbi8vQWxpYXM6IHVuaXhfc3ltbGlua1xuZnVuY3Rpb24gY2FtbF91bml4X3N5bWxpbmsodG9fZGlyLCBzcmMsIGRzdCkge1xuICB2YXIgc3JjX3Jvb3QgPSByZXNvbHZlX2ZzX2RldmljZShzcmMpO1xuICB2YXIgZHN0X3Jvb3QgPSByZXNvbHZlX2ZzX2RldmljZShkc3QpO1xuICBpZihzcmNfcm9vdC5kZXZpY2UgIT0gZHN0X3Jvb3QuZGV2aWNlKVxuICAgIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3VuaXhfc3ltbGluazogY2Fubm90IHN5bWxpbmsgYmV0d2VlbiB0d28gZmlsZXN5c3RlbXNcIik7XG4gIGlmICghc3JjX3Jvb3QuZGV2aWNlLnN5bWxpbmspIHtcbiAgICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF91bml4X3N5bWxpbms6IG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfVxuICByZXR1cm4gc3JjX3Jvb3QuZGV2aWNlLnN5bWxpbmsodG9fZGlyLCBzcmNfcm9vdC5yZXN0LCBkc3Rfcm9vdC5yZXN0LCAvKiByYWlzZSBVbml4X2Vycm9yICovIHRydWUpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfcmVhZGxpbmtcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlLCBjYW1sX2ZhaWx3aXRoXG4vL0FsaWFzOiB1bml4X3JlYWRsaW5rXG5mdW5jdGlvbiBjYW1sX3VuaXhfcmVhZGxpbmsobmFtZSkge1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICBpZiAoIXJvb3QuZGV2aWNlLnJlYWRsaW5rKSB7XG4gICAgY2FtbF9mYWlsd2l0aChcImNhbWxfdW5peF9yZWFkbGluazogbm90IGltcGxlbWVudGVkXCIpO1xuICB9XG4gIHJldHVybiByb290LmRldmljZS5yZWFkbGluayhyb290LnJlc3QsIC8qIHJhaXNlIFVuaXhfZXJyb3IgKi8gdHJ1ZSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF91bmxpbmtcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlLCBjYW1sX2ZhaWx3aXRoXG4vL0FsaWFzOiB1bml4X3VubGlua1xuZnVuY3Rpb24gY2FtbF91bml4X3VubGluayhuYW1lKSB7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIGlmICghcm9vdC5kZXZpY2UudW5saW5rKSB7XG4gICAgY2FtbF9mYWlsd2l0aChcImNhbWxfdW5peF91bmxpbms6IG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfVxuICByZXR1cm4gcm9vdC5kZXZpY2UudW5saW5rKHJvb3QucmVzdCwgLyogcmFpc2UgVW5peF9lcnJvciAqLyB0cnVlKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X2dldHVpZFxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9ub3RfZm91bmRcbi8vQWxpYXM6IHVuaXhfZ2V0dWlkXG5mdW5jdGlvbiBjYW1sX3VuaXhfZ2V0dWlkKHVuaXQpIHtcbiAgaWYoZ2xvYmFsVGhpcy5wcm9jZXNzICYmIGdsb2JhbFRoaXMucHJvY2Vzcy5nZXR1aWQpe1xuICAgIHJldHVybiBnbG9iYWxUaGlzLnByb2Nlc3MuZ2V0dWlkKCk7XG4gIH1cbiAgY2FtbF9yYWlzZV9ub3RfZm91bmQoKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X2dldHB3dWlkXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX25vdF9mb3VuZFxuLy9BbGlhczogdW5peF9nZXRwd3VpZFxuZnVuY3Rpb24gY2FtbF91bml4X2dldHB3dWlkKHVuaXQpIHtcbiAgY2FtbF9yYWlzZV9ub3RfZm91bmQoKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X2hhc19zeW1saW5rXG4vL1JlcXVpcmVzOiBmc19ub2RlX3N1cHBvcnRlZFxuLy9BbGlhczogdW5peF9oYXNfc3ltbGlua1xuZnVuY3Rpb24gY2FtbF91bml4X2hhc19zeW1saW5rKHVuaXQpIHtcbiAgcmV0dXJuIGZzX25vZGVfc3VwcG9ydGVkKCk/MTowXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9vcGVuZGlyXG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZSwgY2FtbF9mYWlsd2l0aFxuLy9BbGlhczogdW5peF9vcGVuZGlyXG5mdW5jdGlvbiBjYW1sX3VuaXhfb3BlbmRpcihwYXRoKSB7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UocGF0aCk7XG4gIGlmICghcm9vdC5kZXZpY2Uub3BlbmRpcikge1xuICAgIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3VuaXhfb3BlbmRpcjogbm90IGltcGxlbWVudGVkXCIpO1xuICB9XG4gIHZhciBkaXJfaGFuZGxlID0gcm9vdC5kZXZpY2Uub3BlbmRpcihyb290LnJlc3QsIC8qIHJhaXNlIFVuaXhfZXJyb3IgKi8gdHJ1ZSk7XG4gIHJldHVybiB7IHBvaW50ZXIgOiBkaXJfaGFuZGxlLCBwYXRoOiBwYXRoIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X3JlYWRkaXJcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2VfZW5kX29mX2ZpbGVcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nXG4vL1JlcXVpcmVzOiBtYWtlX3VuaXhfZXJyX2FyZ3MsIGNhbWxfcmFpc2Vfd2l0aF9hcmdzLCBjYW1sX25hbWVkX3ZhbHVlXG4vL0FsaWFzOiB1bml4X3JlYWRkaXJcbmZ1bmN0aW9uIGNhbWxfdW5peF9yZWFkZGlyKGRpcl9oYW5kbGUpIHtcbiAgdmFyIGVudHJ5O1xuICB0cnkge1xuICAgICAgZW50cnkgPSBkaXJfaGFuZGxlLnBvaW50ZXIucmVhZFN5bmMoKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgICAgdmFyIHVuaXhfZXJyb3IgPSBjYW1sX25hbWVkX3ZhbHVlKCdVbml4LlVuaXhfZXJyb3InKTtcbiAgICAgIGNhbWxfcmFpc2Vfd2l0aF9hcmdzKHVuaXhfZXJyb3IsIG1ha2VfdW5peF9lcnJfYXJncyhcIkVCQURGXCIsIFwicmVhZGRpclwiLCBkaXJfaGFuZGxlLnBhdGgpKTtcbiAgfVxuICBpZiAoZW50cnkgPT09IG51bGwpIHtcbiAgICAgIGNhbWxfcmFpc2VfZW5kX29mX2ZpbGUoKTtcbiAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhlbnRyeS5uYW1lKTtcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfY2xvc2VkaXJcbi8vUmVxdWlyZXM6IG1ha2VfdW5peF9lcnJfYXJncywgY2FtbF9yYWlzZV93aXRoX2FyZ3MsIGNhbWxfbmFtZWRfdmFsdWVcbi8vQWxpYXM6IHVuaXhfY2xvc2VkaXJcbmZ1bmN0aW9uIGNhbWxfdW5peF9jbG9zZWRpcihkaXJfaGFuZGxlKSB7XG4gIHRyeSB7XG4gICAgICBkaXJfaGFuZGxlLnBvaW50ZXIuY2xvc2VTeW5jKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHZhciB1bml4X2Vycm9yID0gY2FtbF9uYW1lZF92YWx1ZSgnVW5peC5Vbml4X2Vycm9yJyk7XG4gICAgICBjYW1sX3JhaXNlX3dpdGhfYXJncyh1bml4X2Vycm9yLCBtYWtlX3VuaXhfZXJyX2FyZ3MoXCJFQkFERlwiLCBcImNsb3NlZGlyXCIsIGRpcl9oYW5kbGUucGF0aCkpO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9yZXdpbmRkaXJcbi8vUmVxdWlyZXM6IGNhbWxfdW5peF9jbG9zZWRpciwgY2FtbF91bml4X29wZW5kaXJcbi8vQWxpYXM6IHVuaXhfcmV3aW5kZGlyXG5mdW5jdGlvbiBjYW1sX3VuaXhfcmV3aW5kZGlyKGRpcl9oYW5kbGUpIHtcbiAgY2FtbF91bml4X2Nsb3NlZGlyKGRpcl9oYW5kbGUpO1xuICB2YXIgbmV3X2Rpcl9oYW5kbGUgPSBjYW1sX3VuaXhfb3BlbmRpcihkaXJfaGFuZGxlLnBhdGgpO1xuICBkaXJfaGFuZGxlLnBvaW50ZXIgPSBuZXdfZGlyX2hhbmRsZS5wb2ludGVyO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X2ZpbmRmaXJzdFxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcsIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX3VuaXhfb3BlbmRpciwgY2FtbF91bml4X3JlYWRkaXJcbi8vQWxpYXM6IHdpbl9maW5kZmlyc3RcbmZ1bmN0aW9uIGNhbWxfdW5peF9maW5kZmlyc3QocGF0aCkge1xuICAvLyBUaGUgV2luZG93cyBjb2RlIGFkZHMgdGhpcyBnbG9iIHRvIHRoZSBwYXRoLCBzbyB3ZSBuZWVkIHRvIHJlbW92ZSBpdFxuICB2YXIgcGF0aF9qcyA9IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHBhdGgpO1xuICBwYXRoX2pzID0gcGF0aF9qcy5yZXBsYWNlKC8oXnxbXFxcXFxcL10pXFwqXFwuXFwqJC8sIFwiXCIpO1xuICBwYXRoID0gY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcocGF0aF9qcyk7XG4gIC8vICouKiBpcyBub3cgc3RyaXBwZWRcbiAgdmFyIGRpcl9oYW5kbGUgPSBjYW1sX3VuaXhfb3BlbmRpcihwYXRoKTtcbiAgdmFyIGZpcnN0X2VudHJ5ID0gY2FtbF91bml4X3JlYWRkaXIoZGlyX2hhbmRsZSk7XG4gIC8vIFRoZSBXaW5kb3dzIGJpbmRpbmdzIHR5cGUgZGlyX2hhbmRsZSBhcyBhbiBgaW50YCBidXQgaXQncyBub3QgaW4gSlNcbiAgcmV0dXJuIFswLCBmaXJzdF9lbnRyeSwgZGlyX2hhbmRsZV07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9maW5kbmV4dFxuLy9SZXF1aXJlczogY2FtbF91bml4X3JlYWRkaXJcbi8vQWxpYXM6IHdpbl9maW5kbmV4dFxuZnVuY3Rpb24gY2FtbF91bml4X2ZpbmRuZXh0KGRpcl9oYW5kbGUpIHtcbiAgcmV0dXJuIGNhbWxfdW5peF9yZWFkZGlyKGRpcl9oYW5kbGUpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfZmluZGNsb3NlXG4vL1JlcXVpcmVzOiBjYW1sX3VuaXhfY2xvc2VkaXJcbi8vQWxpYXM6IHdpbl9maW5kY2xvc2VcbmZ1bmN0aW9uIGNhbWxfdW5peF9maW5kY2xvc2UoZGlyX2hhbmRsZSkge1xuICByZXR1cm4gY2FtbF91bml4X2Nsb3NlZGlyKGRpcl9oYW5kbGUpO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9pbmV0X2FkZHJfb2Zfc3RyaW5nIGNvbnN0XG4vL0FsaWFzOiB1bml4X2luZXRfYWRkcl9vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfdW5peF9pbmV0X2FkZHJfb2Zfc3RyaW5nICgpIHtyZXR1cm4gMDt9XG5cblxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwIErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUHJvdmlkZXM6IGNhbWxfY2FsbF9nZW4gKGNvbnN0LCBzaGFsbG93KVxuLy9JZjogIWVmZmVjdHNcbi8vV2Vha2RlZlxuZnVuY3Rpb24gY2FtbF9jYWxsX2dlbihmLCBhcmdzKSB7XG4gIHZhciBuID0gKGYubCA+PSAwKT9mLmw6KGYubCA9IGYubGVuZ3RoKTtcbiAgdmFyIGFyZ3NMZW4gPSBhcmdzLmxlbmd0aDtcbiAgdmFyIGQgPSBuIC0gYXJnc0xlbjtcbiAgaWYgKGQgPT0gMClcbiAgICByZXR1cm4gZi5hcHBseShudWxsLCBhcmdzKTtcbiAgZWxzZSBpZiAoZCA8IDApIHtcbiAgICB2YXIgZyA9IGYuYXBwbHkobnVsbCxhcmdzLnNsaWNlKDAsbikpO1xuICAgIGlmKHR5cGVvZiBnICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBnO1xuICAgIHJldHVybiBjYW1sX2NhbGxfZ2VuKGcsYXJncy5zbGljZShuKSk7XG4gIH1cbiAgZWxzZSB7XG4gICAgc3dpdGNoIChkKSB7XG4gICAgY2FzZSAxOiB7XG4gICAgICB2YXIgZyA9IGZ1bmN0aW9uICh4KXtcbiAgICAgICAgdmFyIG5hcmdzID0gbmV3IEFycmF5KGFyZ3NMZW4gKyAxKTtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGFyZ3NMZW47IGkrKyApIG5hcmdzW2ldID0gYXJnc1tpXTtcbiAgICAgICAgbmFyZ3NbYXJnc0xlbl0gPSB4O1xuICAgICAgICByZXR1cm4gZi5hcHBseShudWxsLCBuYXJncylcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSAyOiB7XG4gICAgICB2YXIgZyA9IGZ1bmN0aW9uICh4LCB5KXtcbiAgICAgICAgdmFyIG5hcmdzID0gbmV3IEFycmF5KGFyZ3NMZW4gKyAyKTtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGFyZ3NMZW47IGkrKyApIG5hcmdzW2ldID0gYXJnc1tpXTtcbiAgICAgICAgbmFyZ3NbYXJnc0xlbl0gPSB4O1xuICAgICAgICBuYXJnc1thcmdzTGVuICsgMV0gPSB5O1xuICAgICAgICByZXR1cm4gZi5hcHBseShudWxsLCBuYXJncylcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgdmFyIGcgPSBmdW5jdGlvbiAoKXtcbiAgICAgICAgdmFyIGV4dHJhX2FyZ3MgPSAoYXJndW1lbnRzLmxlbmd0aCA9PSAwKT8xOmFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHZhciBuYXJncyA9IG5ldyBBcnJheShhcmdzLmxlbmd0aCtleHRyYV9hcmdzKTtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKysgKSBuYXJnc1tpXSA9IGFyZ3NbaV07XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKysgKSBuYXJnc1thcmdzLmxlbmd0aCtpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgcmV0dXJuIGNhbWxfY2FsbF9nZW4oZiwgbmFyZ3MpXG4gICAgICB9O1xuICAgIH19XG4gICAgZy5sID0gZDtcbiAgICByZXR1cm4gZztcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NhbGxfZ2VuIChjb25zdCwgc2hhbGxvdylcbi8vSWY6IGVmZmVjdHNcbi8vV2Vha2RlZlxuZnVuY3Rpb24gY2FtbF9jYWxsX2dlbihmLCBhcmdzKSB7XG4gIHZhciBuID0gKGYubCA+PSAwKT9mLmw6KGYubCA9IGYubGVuZ3RoKTtcbiAgdmFyIGFyZ3NMZW4gPSBhcmdzLmxlbmd0aDtcbiAgdmFyIGQgPSBuIC0gYXJnc0xlbjtcbiAgaWYgKGQgPT0gMCkge1xuICAgIHJldHVybiBmLmFwcGx5KG51bGwsIGFyZ3MpO1xuICB9IGVsc2UgaWYgKGQgPCAwKSB7XG4gICAgdmFyIHJlc3QgPSBhcmdzLnNsaWNlKG4gLSAxKTtcbiAgICB2YXIgayA9IGFyZ3MgW2FyZ3NMZW4gLSAxXTtcbiAgICBhcmdzID0gYXJncy5zbGljZSgwLCBuKTtcbiAgICBhcmdzW24gLSAxXSA9IGZ1bmN0aW9uIChnKSB7XG4gICAgICBpZiAodHlwZW9mIGcgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIGsoZyk7XG4gICAgICB2YXIgYXJncyA9IHJlc3Quc2xpY2UoKTtcbiAgICAgIGFyZ3NbYXJncy5sZW5ndGggLSAxXSA9IGs7XG4gICAgICByZXR1cm4gY2FtbF9jYWxsX2dlbihnLCBhcmdzKTsgfTtcbiAgICByZXR1cm4gZi5hcHBseShudWxsLCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICBhcmdzTGVuLS07XG4gICAgdmFyIGsgPSBhcmdzIFthcmdzTGVuXTtcbiAgICBzd2l0Y2ggKGQpIHtcbiAgICBjYXNlIDE6IHtcbiAgICAgIHZhciBnID0gZnVuY3Rpb24gKHgsIHkpe1xuICAgICAgICB2YXIgbmFyZ3MgPSBuZXcgQXJyYXkoYXJnc0xlbiArIDIpO1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgYXJnc0xlbjsgaSsrICkgbmFyZ3NbaV0gPSBhcmdzW2ldO1xuICAgICAgICBuYXJnc1thcmdzTGVuXSA9IHg7XG4gICAgICAgIG5hcmdzW2FyZ3NMZW4gKyAxXSA9IHk7XG4gICAgICAgIHJldHVybiBmLmFwcGx5KG51bGwsIG5hcmdzKVxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIDI6IHtcbiAgICAgIHZhciBnID0gZnVuY3Rpb24gKHgsIHksIHope1xuICAgICAgICB2YXIgbmFyZ3MgPSBuZXcgQXJyYXkoYXJnc0xlbiArIDMpO1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgYXJnc0xlbjsgaSsrICkgbmFyZ3NbaV0gPSBhcmdzW2ldO1xuICAgICAgICBuYXJnc1thcmdzTGVuXSA9IHg7XG4gICAgICAgIG5hcmdzW2FyZ3NMZW4gKyAxXSA9IHk7XG4gICAgICAgIG5hcmdzW2FyZ3NMZW4gKyAyXSA9IHo7XG4gICAgICAgIHJldHVybiBmLmFwcGx5KG51bGwsIG5hcmdzKVxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICB2YXIgZyA9IGZ1bmN0aW9uICgpe1xuICAgICAgICB2YXIgZXh0cmFfYXJncyA9IChhcmd1bWVudHMubGVuZ3RoID09IDApPzE6YXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgdmFyIG5hcmdzID0gbmV3IEFycmF5KGFyZ3NMZW4gKyBleHRyYV9hcmdzKTtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGFyZ3NMZW47IGkrKyApIG5hcmdzW2ldID0gYXJnc1tpXTtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKyApXG4gICAgICAgICAgbmFyZ3NbYXJnc0xlbiArIGldID0gYXJndW1lbnRzW2ldO1xuICAgICAgICByZXR1cm4gY2FtbF9jYWxsX2dlbihmLCBuYXJncylcbiAgICAgIH07XG4gICAgfX1cbiAgICBnLmwgPSBkICsgMTtcbiAgICByZXR1cm4gayhnKTtcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX25hbWVkX3ZhbHVlc1xudmFyIGNhbWxfbmFtZWRfdmFsdWVzID0ge307XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmVnaXN0ZXJfbmFtZWRfdmFsdWUgKGNvbnN0LG11dGFibGUpXG4vL1JlcXVpcmVzOiBjYW1sX25hbWVkX3ZhbHVlcywgY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9yZWdpc3Rlcl9uYW1lZF92YWx1ZShubSx2KSB7XG4gIGNhbWxfbmFtZWRfdmFsdWVzW2NhbWxfanNieXRlc19vZl9zdHJpbmcobm0pXSA9IHY7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX25hbWVkX3ZhbHVlXG4vL1JlcXVpcmVzOiBjYW1sX25hbWVkX3ZhbHVlc1xuZnVuY3Rpb24gY2FtbF9uYW1lZF92YWx1ZShubSkge1xuICByZXR1cm4gY2FtbF9uYW1lZF92YWx1ZXNbbm1dXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2xvYmFsX2RhdGFcbnZhciBjYW1sX2dsb2JhbF9kYXRhID0gWzBdO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2J1aWxkX3N5bWJvbHNcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2J1aWxkX3N5bWJvbHMoc3ltYikge1xuICB2YXIgciA9IHt9O1xuICBpZihzeW1iKSB7XG4gICAgZm9yKHZhciBpID0gMTsgaSA8IHN5bWIubGVuZ3RoOyBpKyspe1xuICAgICAgcltjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhzeW1iW2ldWzFdKV0gPSBzeW1iW2ldWzJdXG4gICAgfVxuICB9XG4gIHJldHVybiByO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JlZ2lzdGVyX2dsb2JhbCAoY29uc3QsIHNoYWxsb3csIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9nbG9iYWxfZGF0YSwgY2FtbF9jYWxsYmFjaywgY2FtbF9idWlsZF9zeW1ib2xzXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX3JlZ2lzdGVyX2dsb2JhbCAobiwgdiwgbmFtZV9vcHQpIHtcbiAgaWYgKG5hbWVfb3B0KSB7XG4gICAgdmFyIG5hbWUgPSBuYW1lX29wdDtcbiAgICBpZihnbG9iYWxUaGlzLnRvcGxldmVsUmVsb2MpIHtcbiAgICAgIG4gPSBjYW1sX2NhbGxiYWNrKGdsb2JhbFRoaXMudG9wbGV2ZWxSZWxvYywgW25hbWVdKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY2FtbF9nbG9iYWxfZGF0YS5zeW1ib2xzKSB7XG4gICAgICBpZighY2FtbF9nbG9iYWxfZGF0YS5zeW1pZHgpIHtcbiAgICAgICAgY2FtbF9nbG9iYWxfZGF0YS5zeW1pZHggPSBjYW1sX2J1aWxkX3N5bWJvbHMoY2FtbF9nbG9iYWxfZGF0YS5zeW1ib2xzKVxuICAgICAgfVxuICAgICAgdmFyIG5pZCA9IGNhbWxfZ2xvYmFsX2RhdGEuc3ltaWR4W25hbWVdXG4gICAgICBpZihuaWQgPj0gMClcbiAgICAgICAgbiA9IG5pZFxuICAgICAgZWxzZSB7XG4gICAgICAgIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3JlZ2lzdGVyX2dsb2JhbDogY2Fubm90IGxvY2F0ZSBcIiArIG5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjYW1sX2dsb2JhbF9kYXRhW24gKyAxXSA9IHY7XG4gIGlmKG5hbWVfb3B0KSBjYW1sX2dsb2JhbF9kYXRhW25hbWVfb3B0XSA9IHY7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2V0X2dsb2JhbF9kYXRhIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfZ2V0X2dsb2JhbF9kYXRhICgpIHsgcmV0dXJuIGNhbWxfZ2xvYmFsX2RhdGE7IH1cblxuLy9Qcm92aWRlczogY2FtbF9pc19wcmludGFibGUgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9pc19wcmludGFibGUoYykgeyByZXR1cm4gKyhjID4gMzEgJiYgYyA8IDEyNyk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9tYXliZV9wcmludF9zdGF0c1xuZnVuY3Rpb24gY2FtbF9tYXliZV9wcmludF9zdGF0cyh1bml0KSB7IHJldHVybiAwIH1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vLy8vLy8vLy8vLy8gU3lzXG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2Vfc3lzX2Vycm9yIChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcsIGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfcmFpc2Vfc3lzX2Vycm9yIChtc2cpIHtcbiAgY2FtbF9yYWlzZV93aXRoX3N0cmluZyhjYW1sX2dsb2JhbF9kYXRhLlN5c19lcnJvciwgbXNnKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfZXhpdFxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX3N5c19leGl0IChjb2RlKSB7XG4gIGlmKGdsb2JhbFRoaXMucXVpdCkgZ2xvYmFsVGhpcy5xdWl0KGNvZGUpO1xuICAvL25vZGVqc1xuICBpZihnbG9iYWxUaGlzLnByb2Nlc3MgJiYgZ2xvYmFsVGhpcy5wcm9jZXNzLmV4aXQpXG4gICAgZ2xvYmFsVGhpcy5wcm9jZXNzLmV4aXQoY29kZSk7XG4gIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkZ1bmN0aW9uICdleGl0JyBub3QgaW1wbGVtZW50ZWRcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaXNfc3BlY2lhbF9leGNlcHRpb25cbmZ1bmN0aW9uIGNhbWxfaXNfc3BlY2lhbF9leGNlcHRpb24oZXhuKXtcbiAgc3dpdGNoKGV4blsyXSkge1xuICBjYXNlIC04OiAvLyBNYXRjaF9mYWlsdXJlXG4gIGNhc2UgLTExOiAvLyBBc3NlcnRfZmFpbHVyZVxuICBjYXNlIC0xMjogLy8gVW5kZWZpbmVkX3JlY3Vyc2l2ZV9tb2R1bGVcbiAgICByZXR1cm4gMTtcbiAgZGVmYXVsdDpcbiAgICByZXR1cm4gMDtcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2Zvcm1hdF9leGNlcHRpb25cbi8vUmVxdWlyZXM6IE1sQnl0ZXMsIGNhbWxfaXNfc3BlY2lhbF9leGNlcHRpb25cbmZ1bmN0aW9uIGNhbWxfZm9ybWF0X2V4Y2VwdGlvbihleG4pe1xuICB2YXIgciA9IFwiXCI7XG4gIGlmKGV4blswXSA9PSAwKSB7XG4gICAgciArPSBleG5bMV1bMV07XG4gICAgaWYoZXhuLmxlbmd0aCA9PSAzICYmIGV4blsyXVswXSA9PSAwICYmIGNhbWxfaXNfc3BlY2lhbF9leGNlcHRpb24oZXhuWzFdKSkge1xuXG4gICAgICB2YXIgYnVja2V0ID0gZXhuWzJdO1xuICAgICAgdmFyIHN0YXJ0ID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHN0YXJ0ID0gMlxuICAgICAgdmFyIGJ1Y2tldCA9IGV4bjtcbiAgICB9XG4gICAgciArPSBcIihcIjtcbiAgICBmb3IodmFyIGkgPSBzdGFydDsgaSA8IGJ1Y2tldC5sZW5ndGg7IGkgKyspe1xuICAgICAgaWYoaSA+IHN0YXJ0KSByKz1cIiwgXCI7XG4gICAgICB2YXIgdiA9IGJ1Y2tldFtpXVxuICAgICAgaWYodHlwZW9mIHYgPT0gXCJudW1iZXJcIilcbiAgICAgICAgcis9IHYudG9TdHJpbmcoKTtcbiAgICAgIGVsc2UgaWYodiBpbnN0YW5jZW9mIE1sQnl0ZXMpe1xuICAgICAgICByKz0gJ1wiJyArIHYudG9TdHJpbmcoKSArICdcIic7XG4gICAgICB9XG4gICAgICBlbHNlIGlmKHR5cGVvZiB2ID09IFwic3RyaW5nXCIpe1xuICAgICAgICByKz0gJ1wiJyArIHYudG9TdHJpbmcoKSArICdcIic7XG4gICAgICB9XG4gICAgICBlbHNlIHIgKz0gXCJfXCI7XG4gICAgfVxuICAgIHIgKz0gXCIpXCJcbiAgfSBlbHNlIGlmIChleG5bMF0gPT0gMjQ4KXtcbiAgICByICs9IGV4blsxXVxuICB9XG4gIHJldHVybiByXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmF0YWxfdW5jYXVnaHRfZXhjZXB0aW9uXG4vL1JlcXVpcmVzOiBjYW1sX25hbWVkX3ZhbHVlLCBjYW1sX2Zvcm1hdF9leGNlcHRpb24sIGNhbWxfY2FsbGJhY2tcbmZ1bmN0aW9uIGNhbWxfZmF0YWxfdW5jYXVnaHRfZXhjZXB0aW9uKGVycil7XG4gIGlmKGVyciBpbnN0YW5jZW9mIEFycmF5ICYmIChlcnJbMF0gPT0gMCB8fCBlcnJbMF0gPT0gMjQ4KSkge1xuICAgIHZhciBoYW5kbGVyID0gY2FtbF9uYW1lZF92YWx1ZShcIlByaW50ZXhjLmhhbmRsZV91bmNhdWdodF9leGNlcHRpb25cIik7XG4gICAgaWYoaGFuZGxlcikgY2FtbF9jYWxsYmFjayhoYW5kbGVyLCBbZXJyLGZhbHNlXSk7XG4gICAgZWxzZSB7XG4gICAgICB2YXIgbXNnID0gY2FtbF9mb3JtYXRfZXhjZXB0aW9uKGVycik7XG4gICAgICB2YXIgYXRfZXhpdCA9IGNhbWxfbmFtZWRfdmFsdWUoXCJQZXJ2YXNpdmVzLmRvX2F0X2V4aXRcIik7XG4gICAgICBpZihhdF9leGl0KSBjYW1sX2NhbGxiYWNrKGF0X2V4aXQsIFswXSk7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRmF0YWwgZXJyb3I6IGV4Y2VwdGlvbiBcIiArIG1zZyk7XG4gICAgICBpZihlcnIuanNfZXJyb3IpIHRocm93IGVyci5qc19lcnJvcjtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhyb3cgZXJyXG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9zZXRfc3RhdGljX2VudlxuZnVuY3Rpb24gY2FtbF9zZXRfc3RhdGljX2VudihrLHYpe1xuICBpZighZ2xvYmFsVGhpcy5qc29vX3N0YXRpY19lbnYpXG4gICAgZ2xvYmFsVGhpcy5qc29vX3N0YXRpY19lbnYgPSB7fVxuICBnbG9iYWxUaGlzLmpzb29fc3RhdGljX2VudltrXSA9IHY7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBqc29vX3N5c19nZXRlbnYgKGNvbnN0KVxuZnVuY3Rpb24ganNvb19zeXNfZ2V0ZW52KG4pIHtcbiAgdmFyIHByb2Nlc3MgPSBnbG9iYWxUaGlzLnByb2Nlc3M7XG4gIC8vbm9kZWpzIGVudlxuICBpZihwcm9jZXNzXG4gICAgICYmIHByb2Nlc3MuZW52XG4gICAgICYmIHByb2Nlc3MuZW52W25dICE9IHVuZGVmaW5lZClcbiAgICByZXR1cm4gcHJvY2Vzcy5lbnZbbl07XG4gIGlmKGdsb2JhbFRoaXMuanNvb19zdGF0aWNfZW52XG4gICAgICYmIGdsb2JhbFRoaXMuanNvb19zdGF0aWNfZW52W25dKVxuICAgIHJldHVybiBnbG9iYWxUaGlzLmpzb29fc3RhdGljX2VudltuXVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19nZXRlbnYgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9ub3RfZm91bmRcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuLy9SZXF1aXJlczoganNvb19zeXNfZ2V0ZW52XG5mdW5jdGlvbiBjYW1sX3N5c19nZXRlbnYgKG5hbWUpIHtcbiAgdmFyIHIgPSBqc29vX3N5c19nZXRlbnYoY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcobmFtZSkpO1xuICBpZihyID09PSB1bmRlZmluZWQpXG4gICAgY2FtbF9yYWlzZV9ub3RfZm91bmQgKCk7XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhyKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c191bnNhZmVfZ2V0ZW52XG4vL1JlcXVpcmVzOiBjYW1sX3N5c19nZXRlbnZcbmZ1bmN0aW9uIGNhbWxfc3lzX3Vuc2FmZV9nZXRlbnYobmFtZSl7XG4gIHJldHVybiBjYW1sX3N5c19nZXRlbnYgKG5hbWUpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FyZ3Zcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nXG52YXIgY2FtbF9hcmd2ID0gKChmdW5jdGlvbiAoKSB7XG4gIHZhciBwcm9jZXNzID0gZ2xvYmFsVGhpcy5wcm9jZXNzO1xuICB2YXIgbWFpbiA9IFwiYS5vdXRcIjtcbiAgdmFyIGFyZ3MgPSBbXVxuXG4gIGlmKHByb2Nlc3NcbiAgICAgJiYgcHJvY2Vzcy5hcmd2XG4gICAgICYmIHByb2Nlc3MuYXJndi5sZW5ndGggPiAxKSB7XG4gICAgdmFyIGFyZ3YgPSBwcm9jZXNzLmFyZ3ZcbiAgICAvL25vZGVqc1xuICAgIG1haW4gPSBhcmd2WzFdO1xuICAgIGFyZ3MgPSBhcmd2LnNsaWNlKDIpO1xuICB9XG5cbiAgdmFyIHAgPSBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhtYWluKTtcbiAgdmFyIGFyZ3MyID0gWzAsIHBdO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKylcbiAgICBhcmdzMi5wdXNoKGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKGFyZ3NbaV0pKTtcbiAgcmV0dXJuIGFyZ3MyO1xufSkoKSlcblxuLy9Qcm92aWRlczogY2FtbF9leGVjdXRhYmxlX25hbWVcbi8vUmVxdWlyZXM6IGNhbWxfYXJndlxudmFyIGNhbWxfZXhlY3V0YWJsZV9uYW1lID0gY2FtbF9hcmd2WzFdXG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2dldF9hcmd2XG4vL1JlcXVpcmVzOiBjYW1sX2FyZ3ZcbmZ1bmN0aW9uIGNhbWxfc3lzX2dldF9hcmd2IChhKSB7XG4gIHJldHVybiBbMCwgY2FtbF9hcmd2WzFdLCBjYW1sX2FyZ3ZdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19hcmd2XG4vL1JlcXVpcmVzOiBjYW1sX2FyZ3ZcbmZ1bmN0aW9uIGNhbWxfc3lzX2FyZ3YgKGEpIHtcbiAgcmV0dXJuIGNhbWxfYXJndjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfbW9kaWZ5X2FyZ3Zcbi8vUmVxdWlyZXM6IGNhbWxfYXJndlxuZnVuY3Rpb24gY2FtbF9zeXNfbW9kaWZ5X2FyZ3YoYXJnKXtcbiAgY2FtbF9hcmd2ID0gYXJnO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfZXhlY3V0YWJsZV9uYW1lIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2V4ZWN1dGFibGVfbmFtZVxuZnVuY3Rpb24gY2FtbF9zeXNfZXhlY3V0YWJsZV9uYW1lKGEpe1xuICByZXR1cm4gY2FtbF9leGVjdXRhYmxlX25hbWVcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfc3lzdGVtX2NvbW1hbmRcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N5c19zeXN0ZW1fY29tbWFuZChjbWQpe1xuICB2YXIgY21kID0gY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcoY21kKTtcbiAgaWYgKHR5cGVvZiByZXF1aXJlICE9IFwidW5kZWZpbmVkXCIpe1xuICAgIHZhciBjaGlsZF9wcm9jZXNzID0gcmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpO1xuICAgIGlmKGNoaWxkX3Byb2Nlc3MgJiYgY2hpbGRfcHJvY2Vzcy5leGVjU3luYylcbiAgICAgIHRyeSB7XG4gICAgICAgIGNoaWxkX3Byb2Nlc3MuZXhlY1N5bmMoY21kLHtzdGRpbzogJ2luaGVyaXQnfSk7XG4gICAgICAgIHJldHVybiAwXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiAxXG4gICAgICB9XG4gIH1cbiAgZWxzZSByZXR1cm4gMTI3O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19zeXN0ZW1fY29tbWFuZFxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbi8vSWY6IGJyb3dzZXJcbmZ1bmN0aW9uIGNhbWxfc3lzX3N5c3RlbV9jb21tYW5kKGNtZCl7XG4gIHJldHVybiAxMjc7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX3RpbWUgbXV0YWJsZVxudmFyIGNhbWxfaW5pdGlhbF90aW1lID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKSAqIDAuMDAxO1xuZnVuY3Rpb24gY2FtbF9zeXNfdGltZSAoKSB7XG4gIHZhciBub3cgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuICByZXR1cm4gbm93ICogMC4wMDEgLSBjYW1sX2luaXRpYWxfdGltZTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfdGltZV9pbmNsdWRlX2NoaWxkcmVuXG4vL1JlcXVpcmVzOiBjYW1sX3N5c190aW1lXG5mdW5jdGlvbiBjYW1sX3N5c190aW1lX2luY2x1ZGVfY2hpbGRyZW4oYikge1xuICByZXR1cm4gY2FtbF9zeXNfdGltZSgpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19yYW5kb21fc2VlZCBtdXRhYmxlXG4vL1RoZSBmdW5jdGlvbiBuZWVkcyB0byByZXR1cm4gYW4gYXJyYXkgc2luY2UgT0NhbWwgNC4wLi4uXG5mdW5jdGlvbiBjYW1sX3N5c19yYW5kb21fc2VlZCAoKSB7XG4gIGlmIChnbG9iYWxUaGlzLmNyeXB0bykge1xuICAgICBpZiAoZ2xvYmFsVGhpcy5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgICAgdmFyIGEgPSBnbG9iYWxUaGlzLmNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IEludDMyQXJyYXkoNCkpO1xuICAgICAgIHJldHVybiBbMCwgYVswXSwgYVsxXSwgYVsyXSwgYVszXV07XG4gICAgIH0gZWxzZSBpZiAoZ2xvYmFsVGhpcy5jcnlwdG8ucmFuZG9tQnl0ZXMpIHtcbiAgICAgICB2YXIgYSA9IG5ldyBJbnQzMkFycmF5KGdsb2JhbFRoaXMuY3J5cHRvLnJhbmRvbUJ5dGVzKDE2KS5idWZmZXIpO1xuICAgICAgIHJldHVybiBbMCwgYVswXSwgYVsxXSwgYVsyXSwgYVszXV07XG4gICAgIH1cbiAgfVxuICB2YXIgbm93ID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcbiAgdmFyIHggPSBub3deMHhmZmZmZmZmZipNYXRoLnJhbmRvbSgpO1xuICByZXR1cm4gWzAseF07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X2JpZ19lbmRpYW4gY29uc3RcbmZ1bmN0aW9uIGNhbWxfc3lzX2NvbnN0X2JpZ19lbmRpYW4gKCkgeyByZXR1cm4gMDsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jb25zdF93b3JkX3NpemUgY29uc3RcbmZ1bmN0aW9uIGNhbWxfc3lzX2NvbnN0X3dvcmRfc2l6ZSAoKSB7IHJldHVybiAzMjsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jb25zdF9pbnRfc2l6ZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9zeXNfY29uc3RfaW50X3NpemUgKCkgeyByZXR1cm4gMzI7IH1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfY29uc3RfbWF4X3dvc2l6ZSBjb25zdFxuLy8gbWF4X2ludCAvIDQgc28gdGhhdCB0aGUgZm9sbG93aW5nIGRvZXMgbm90IG92ZXJmbG93XG4vL2xldCBtYXhfc3RyaW5nX2xlbmd0aCA9IHdvcmRfc2l6ZSAvIDggKiBtYXhfYXJyYXlfbGVuZ3RoIC0gMTs7XG5mdW5jdGlvbiBjYW1sX3N5c19jb25zdF9tYXhfd29zaXplICgpIHsgcmV0dXJuICgweDdGRkZGRkZGLzQpIHwgMDt9XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X29zdHlwZV91bml4IGNvbnN0XG4vL1JlcXVpcmVzOiBvc190eXBlXG5mdW5jdGlvbiBjYW1sX3N5c19jb25zdF9vc3R5cGVfdW5peCAoKSB7IHJldHVybiBvc190eXBlID09IFwiVW5peFwiID8gMSA6IDA7IH1cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X29zdHlwZV93aW4zMiBjb25zdFxuLy9SZXF1aXJlczogb3NfdHlwZVxuZnVuY3Rpb24gY2FtbF9zeXNfY29uc3Rfb3N0eXBlX3dpbjMyICgpIHsgcmV0dXJuIG9zX3R5cGUgPT0gXCJXaW4zMlwiID8gMSA6IDA7IH1cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X29zdHlwZV9jeWd3aW4gY29uc3Rcbi8vUmVxdWlyZXM6IG9zX3R5cGVcbmZ1bmN0aW9uIGNhbWxfc3lzX2NvbnN0X29zdHlwZV9jeWd3aW4gKCkgeyByZXR1cm4gb3NfdHlwZSA9PSBcIkN5Z3dpblwiID8gMSA6IDA7IH1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfY29uc3RfYmFja2VuZF90eXBlIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX3N5c19jb25zdF9iYWNrZW5kX3R5cGUgKCkge1xuICByZXR1cm4gWzAsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoXCJqc19vZl9vY2FtbFwiKV07XG59XG5cbi8vUHJvdmlkZXM6IG9zX3R5cGVcbnZhciBvc190eXBlID0gKGdsb2JhbFRoaXMucHJvY2VzcyAmJlxuICAgICAgICAgICAgICAgZ2xvYmFsVGhpcy5wcm9jZXNzLnBsYXRmb3JtICYmXG4gICAgICAgICAgICAgICBnbG9iYWxUaGlzLnByb2Nlc3MucGxhdGZvcm0gPT0gXCJ3aW4zMlwiKSA/IFwiQ3lnd2luXCIgOiBcIlVuaXhcIjtcblxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19nZXRfY29uZmlnIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzLCBvc190eXBlXG5mdW5jdGlvbiBjYW1sX3N5c19nZXRfY29uZmlnICgpIHtcbiAgcmV0dXJuIFswLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKG9zX3R5cGUpLCAzMiwgMF07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2lzYXR0eVxuZnVuY3Rpb24gY2FtbF9zeXNfaXNhdHR5KF9jaGFuKSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3J1bnRpbWVfdmFyaWFudFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9ydW50aW1lX3ZhcmlhbnQoX3VuaXQpIHtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoXCJcIik7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX3J1bnRpbWVfcGFyYW1ldGVyc1xuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9ydW50aW1lX3BhcmFtZXRlcnMoX3VuaXQpIHtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoXCJcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW5zdGFsbF9zaWduYWxfaGFuZGxlciBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnN0YWxsX3NpZ25hbF9oYW5kbGVyKCl7cmV0dXJuIDB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfcnVudGltZV93YXJuaW5nc1xudmFyIGNhbWxfcnVudGltZV93YXJuaW5ncyA9IDA7XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfZW5hYmxlX3J1bnRpbWVfd2FybmluZ3Ncbi8vUmVxdWlyZXM6IGNhbWxfcnVudGltZV93YXJuaW5nc1xuZnVuY3Rpb24gY2FtbF9tbF9lbmFibGVfcnVudGltZV93YXJuaW5ncyAoYm9vbCkge1xuICBjYW1sX3J1bnRpbWVfd2FybmluZ3MgPSBib29sO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9ydW50aW1lX3dhcm5pbmdzX2VuYWJsZWRcbi8vUmVxdWlyZXM6IGNhbWxfcnVudGltZV93YXJuaW5nc1xuZnVuY3Rpb24gY2FtbF9tbF9ydW50aW1lX3dhcm5pbmdzX2VuYWJsZWQgKF91bml0KSB7XG4gIHJldHVybiBjYW1sX3J1bnRpbWVfd2FybmluZ3M7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9zcGFjZXRpbWVfZW5hYmxlZCBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX3NwYWNldGltZV9lbmFibGVkKF91bml0KSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jb25zdF9uYWtlZF9wb2ludGVyc19jaGVja2VkIGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfc3lzX2NvbnN0X25ha2VkX3BvaW50ZXJzX2NoZWNrZWQoX3VuaXQpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmVnaXN0ZXJfY2hhbm5lbF9mb3Jfc3BhY2V0aW1lIGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfcmVnaXN0ZXJfY2hhbm5lbF9mb3Jfc3BhY2V0aW1lKF9jaGFubmVsKSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3NwYWNldGltZV9vbmx5X3dvcmtzX2Zvcl9uYXRpdmVfY29kZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9zcGFjZXRpbWVfb25seV93b3Jrc19mb3JfbmF0aXZlX2NvZGUoKSB7XG4gIGNhbWxfZmFpbHdpdGgoXCJTcGFjZXRpbWUgcHJvZmlsaW5nIG9ubHkgd29ya3MgZm9yIG5hdGl2ZSBjb2RlXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3hkZ19kZWZhdWx0c1xuLy9WZXJzaW9uOiA+PSA1LjJcbmZ1bmN0aW9uIGNhbWxfeGRnX2RlZmF1bHRzKF91bml0KSB7XG4gIHJldHVybiAwOyAvLyBlbXB0eSBsaXN0XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2lzX3JlZ3VsYXJfZmlsZVxuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2VcbmZ1bmN0aW9uIGNhbWxfc3lzX2lzX3JlZ3VsYXJfZmlsZShuYW1lKSB7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIHJldHVybiByb290LmRldmljZS5pc0ZpbGUocm9vdC5yZXN0KTtcbn1cbi8vQWx3YXlzXG4vL1JlcXVpcmVzOiBjYW1sX2ZhdGFsX3VuY2F1Z2h0X2V4Y2VwdGlvblxuZnVuY3Rpb24gY2FtbF9zZXR1cF91bmNhdWdodF9leGNlcHRpb25faGFuZGxlcigpIHtcbiAgdmFyIHByb2Nlc3MgPSBnbG9iYWxUaGlzLnByb2Nlc3M7XG4gIGlmKHByb2Nlc3MgJiYgcHJvY2Vzcy5vbikge1xuICAgIHByb2Nlc3Mub24oJ3VuY2F1Z2h0RXhjZXB0aW9uJywgZnVuY3Rpb24gKGVyciwgb3JpZ2luKSB7XG4gICAgICBjYW1sX2ZhdGFsX3VuY2F1Z2h0X2V4Y2VwdGlvbihlcnIpO1xuICAgICAgcHJvY2Vzcy5leGl0ICgyKTtcbiAgICB9KVxuICB9XG4gIGVsc2UgaWYoZ2xvYmFsVGhpcy5hZGRFdmVudExpc3RlbmVyKXtcbiAgICBnbG9iYWxUaGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZnVuY3Rpb24oZXZlbnQpe1xuICAgICAgaWYoZXZlbnQuZXJyb3Ipe1xuICAgICAgICBjYW1sX2ZhdGFsX3VuY2F1Z2h0X2V4Y2VwdGlvbihldmVudC5lcnJvcik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbmNhbWxfc2V0dXBfdW5jYXVnaHRfZXhjZXB0aW9uX2hhbmRsZXIoKTtcblxuXG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfcmVjb3JkX2JhY2t0cmFjZV9mbGFnXG4vL1JlcXVpcmVzOiBqc29vX3N5c19nZXRlbnZcbnZhciBjYW1sX3JlY29yZF9iYWNrdHJhY2VfZmxhZyA9IEZMQUcoXCJ3aXRoLWpzLWVycm9yXCIpO1xuXG4oZnVuY3Rpb24gKCkge1xuICB2YXIgciA9IGpzb29fc3lzX2dldGVudihcIk9DQU1MUlVOUEFSQU1cIilcbiAgaWYociAhPT0gdW5kZWZpbmVkKXtcbiAgICB2YXIgbCA9IHIuc3BsaXQoXCIsXCIpO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBsLmxlbmd0aDsgaSsrKXtcbiAgICAgIGlmKGxbaV0gPT0gXCJiXCIpIHsgY2FtbF9yZWNvcmRfYmFja3RyYWNlX2ZsYWcgPSAxOyBicmVhayB9XG4gICAgICBlbHNlIGlmIChsW2ldLnN0YXJ0c1dpdGgoXCJiPVwiKSkge1xuICAgICAgICBjYW1sX3JlY29yZF9iYWNrdHJhY2VfZmxhZyA9ICsobFtpXS5zbGljZSgyKSl9XG4gICAgICBlbHNlIGNvbnRpbnVlO1xuICAgIH1cbiAgfVxufSkgKClcblxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2RlYnVnX2luZm9fc3RhdHVzIGNvbnN0XG5mdW5jdGlvbiBjYW1sX21sX2RlYnVnX2luZm9fc3RhdHVzICgpIHsgcmV0dXJuIDA7IH1cbi8vUHJvdmlkZXM6IGNhbWxfYmFja3RyYWNlX3N0YXR1c1xuLy9SZXF1aXJlczogY2FtbF9yZWNvcmRfYmFja3RyYWNlX2ZsYWdcbmZ1bmN0aW9uIGNhbWxfYmFja3RyYWNlX3N0YXR1cyAoX3VuaXQpIHsgcmV0dXJuIGNhbWxfcmVjb3JkX2JhY2t0cmFjZV9mbGFnID8gMSA6IDA7IH1cbi8vUHJvdmlkZXM6IGNhbWxfZ2V0X2V4Y2VwdGlvbl9iYWNrdHJhY2UgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZ2V0X2V4Y2VwdGlvbl9iYWNrdHJhY2UgKCkgeyByZXR1cm4gMDsgfVxuLy9Qcm92aWRlczogY2FtbF9nZXRfZXhjZXB0aW9uX3Jhd19iYWNrdHJhY2UgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZ2V0X2V4Y2VwdGlvbl9yYXdfYmFja3RyYWNlICgpIHsgcmV0dXJuIFswXTsgfVxuLy9Qcm92aWRlczogY2FtbF9yZWNvcmRfYmFja3RyYWNlXG4vL1JlcXVpcmVzOiBjYW1sX3JlY29yZF9iYWNrdHJhY2VfZmxhZ1xuZnVuY3Rpb24gY2FtbF9yZWNvcmRfYmFja3RyYWNlIChiKSB7IGNhbWxfcmVjb3JkX2JhY2t0cmFjZV9mbGFnID0gYjsgcmV0dXJuIDA7IH1cbi8vUHJvdmlkZXM6IGNhbWxfY29udmVydF9yYXdfYmFja3RyYWNlIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2NvbnZlcnRfcmF3X2JhY2t0cmFjZSAoKSB7IHJldHVybiBbMF07IH1cbi8vUHJvdmlkZXM6IGNhbWxfcmF3X2JhY2t0cmFjZV9sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfcmF3X2JhY2t0cmFjZV9sZW5ndGgoKSB7IHJldHVybiAwOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX3Jhd19iYWNrdHJhY2VfbmV4dF9zbG90XG5mdW5jdGlvbiBjYW1sX3Jhd19iYWNrdHJhY2VfbmV4dF9zbG90KCkgeyByZXR1cm4gMCB9XG4vL1Byb3ZpZGVzOiBjYW1sX3Jhd19iYWNrdHJhY2Vfc2xvdFxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX3Jhd19iYWNrdHJhY2Vfc2xvdCAoKSB7XG4gIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIlByaW50ZXhjLmdldF9yYXdfYmFja3RyYWNlX3Nsb3Q6IGluZGV4IG91dCBvZiBib3VuZHNcIik7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX3Jlc3RvcmVfcmF3X2JhY2t0cmFjZVxuZnVuY3Rpb24gY2FtbF9yZXN0b3JlX3Jhd19iYWNrdHJhY2UoZXhuLCBidCkgeyByZXR1cm4gMCB9XG4vL1Byb3ZpZGVzOiBjYW1sX2dldF9jdXJyZW50X2NhbGxzdGFjayBjb25zdFxuZnVuY3Rpb24gY2FtbF9nZXRfY3VycmVudF9jYWxsc3RhY2sgKCkgeyByZXR1cm4gWzBdOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfY29udmVydF9yYXdfYmFja3RyYWNlX3Nsb3Rcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfY29udmVydF9yYXdfYmFja3RyYWNlX3Nsb3QoKXtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfY29udmVydF9yYXdfYmFja3RyYWNlX3Nsb3RcIik7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBsaWJyYXJ5XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwIErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vLy8vLy8vLy8vLy8gSnNsaWJcblxuLy9Qcm92aWRlczogY2FtbF9qc19wdXJlX2V4cHIgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfY2FsbGJhY2tcbmZ1bmN0aW9uIGNhbWxfanNfcHVyZV9leHByIChmKSB7IHJldHVybiBjYW1sX2NhbGxiYWNrKGYsIFswXSk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9qc19zZXQgKG11dGFibGUsIGNvbnN0LCBtdXRhYmxlKVxuZnVuY3Rpb24gY2FtbF9qc19zZXQobyxmLHYpIHsgb1tmXT12O3JldHVybiAwfVxuLy9Qcm92aWRlczogY2FtbF9qc19nZXQgKG11dGFibGUsIGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc19nZXQobyxmKSB7IHJldHVybiBvW2ZdOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2RlbGV0ZSAobXV0YWJsZSwgY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX2RlbGV0ZShvLGYpIHsgZGVsZXRlIG9bZl07IHJldHVybiAwfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2luc3RhbmNlb2YgKGNvbnN0LCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfaW5zdGFuY2VvZihvLGMpIHsgcmV0dXJuIChvIGluc3RhbmNlb2YgYykgPyAxIDogMDsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3R5cGVvZiAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX3R5cGVvZihvKSB7IHJldHVybiB0eXBlb2YgbzsgfVxuXG4vL1Byb3ZpZGVzOmNhbWxfdHJhbXBvbGluZVxuZnVuY3Rpb24gY2FtbF90cmFtcG9saW5lKHJlcykge1xuICB2YXIgYyA9IDE7XG4gIHdoaWxlKHJlcyAmJiByZXMuam9vX3RyYW1wKXtcbiAgICByZXMgPSByZXMuam9vX3RyYW1wLmFwcGx5KG51bGwsIHJlcy5qb29fYXJncyk7XG4gICAgYysrO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbi8vUHJvdmlkZXM6Y2FtbF90cmFtcG9saW5lX3JldHVyblxuZnVuY3Rpb24gY2FtbF90cmFtcG9saW5lX3JldHVybihmLGFyZ3MpIHtcbiAgcmV0dXJuIHtqb29fdHJhbXA6Zixqb29fYXJnczphcmdzfTtcbn1cblxuLy9Qcm92aWRlczpjYW1sX3N0YWNrX2RlcHRoXG4vL0lmOiBlZmZlY3RzXG52YXIgY2FtbF9zdGFja19kZXB0aCA9IDA7XG5cbi8vUHJvdmlkZXM6Y2FtbF9zdGFja19jaGVja19kZXB0aFxuLy9JZjogZWZmZWN0c1xuLy9SZXF1aXJlczpjYW1sX3N0YWNrX2RlcHRoXG5mdW5jdGlvbiBjYW1sX3N0YWNrX2NoZWNrX2RlcHRoKCkge1xuICAgIHJldHVybiAtLWNhbWxfc3RhY2tfZGVwdGggPiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NhbGxiYWNrXG4vL0lmOiAhZWZmZWN0c1xuLy9SZXF1aXJlczpjYW1sX2NhbGxfZ2VuXG52YXIgY2FtbF9jYWxsYmFjayA9IGNhbWxfY2FsbF9nZW47XG5cbi8vUHJvdmlkZXM6IGNhbWxfY2FsbGJhY2tcbi8vSWY6IGVmZmVjdHNcbi8vUmVxdWlyZXM6Y2FtbF9zdGFja19kZXB0aCwgY2FtbF9jYWxsX2dlbiwgY2FtbF9leG5fc3RhY2ssIGNhbWxfZmliZXJfc3RhY2ssIGNhbWxfd3JhcF9leGNlcHRpb24sIGNhbWxfcmVzdW1lX3N0YWNrLCBjYW1sX2ZyZXNoX29vX2lkLCBjYW1sX25hbWVkX3ZhbHVlLCBjYW1sX3JhaXNlX3dpdGhfYXJnLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX2NvbnN0YW50XG5mdW5jdGlvbiBjYW1sX2NhbGxiYWNrKGYsYXJncykge1xuICBmdW5jdGlvbiB1bmNhdWdodF9lZmZlY3RfaGFuZGxlcihlZmYsayxtcykge1xuICAgIC8vIFJlc3VtZXMgdGhlIGNvbnRpbnVhdGlvbiBrIGJ5IHJhaXNpbmcgZXhjZXB0aW9uIFVuaGFuZGxlZC5cbiAgICBjYW1sX3Jlc3VtZV9zdGFjayhrWzFdLG1zKTtcbiAgICB2YXIgZXhuID0gY2FtbF9uYW1lZF92YWx1ZShcIkVmZmVjdC5VbmhhbmRsZWRcIik7XG4gICAgaWYoZXhuKSBjYW1sX3JhaXNlX3dpdGhfYXJnKGV4biwgZWZmKTtcbiAgICBlbHNlIHtcbiAgICAgIGV4biA9IFsyNDgsY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhcIkVmZmVjdC5VbmhhbmRsZWRcIiksIGNhbWxfZnJlc2hfb29faWQoMCldO1xuICAgICAgY2FtbF9yYWlzZV9jb25zdGFudChleG4pO1xuICAgIH1cbiAgfVxuICB2YXIgc2F2ZWRfc3RhY2tfZGVwdGggPSBjYW1sX3N0YWNrX2RlcHRoO1xuICB2YXIgc2F2ZWRfZXhuX3N0YWNrID0gY2FtbF9leG5fc3RhY2s7XG4gIHZhciBzYXZlZF9maWJlcl9zdGFjayA9IGNhbWxfZmliZXJfc3RhY2s7XG4gIHRyeSB7XG4gICAgY2FtbF9leG5fc3RhY2sgPSAwO1xuICAgIGNhbWxfZmliZXJfc3RhY2sgPVxuICAgICAge2g6WzAsIDAsIDAsIHVuY2F1Z2h0X2VmZmVjdF9oYW5kbGVyXSwgcjp7azowLCB4OjAsIGU6MH19O1xuICAgIHZhciByZXMgPSB7am9vX3RyYW1wOiBmLFxuICAgICAgICAgICAgICAgam9vX2FyZ3M6IGFyZ3MuY29uY2F0KGZ1bmN0aW9uICh4KXtyZXR1cm4geDt9KX07XG4gICAgZG8ge1xuICAgICAgY2FtbF9zdGFja19kZXB0aCA9IDQwO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmVzID0gY2FtbF9jYWxsX2dlbihyZXMuam9vX3RyYW1wLCByZXMuam9vX2FyZ3MpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvKiBIYW5kbGUgZXhjZXB0aW9uIGNvbWluZyBmcm9tIEphdmFTY3JpcHQgb3IgZnJvbSB0aGUgcnVudGltZS4gKi9cbiAgICAgICAgaWYgKCFjYW1sX2V4bl9zdGFjaykgdGhyb3cgZTtcbiAgICAgICAgdmFyIGhhbmRsZXIgPSBjYW1sX2V4bl9zdGFja1sxXTtcbiAgICAgICAgY2FtbF9leG5fc3RhY2sgPSBjYW1sX2V4bl9zdGFja1syXTtcbiAgICAgICAgcmVzID0ge2pvb190cmFtcDogaGFuZGxlcixcbiAgICAgICAgICAgICAgIGpvb19hcmdzOiBbY2FtbF93cmFwX2V4Y2VwdGlvbihlKV19O1xuICAgICAgfVxuICAgIH0gd2hpbGUocmVzICYmIHJlcy5qb29fYXJncylcbiAgfSBmaW5hbGx5IHtcbiAgICBjYW1sX3N0YWNrX2RlcHRoID0gc2F2ZWRfc3RhY2tfZGVwdGg7XG4gICAgY2FtbF9leG5fc3RhY2sgPSBzYXZlZF9leG5fc3RhY2s7XG4gICAgY2FtbF9maWJlcl9zdGFjayA9IHNhdmVkX2ZpYmVyX3N0YWNrO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaXNfanNcbmZ1bmN0aW9uIGNhbWxfaXNfanMoKSB7XG4gIHJldHVybiAxO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzb29fZmxhZ3NfdXNlX2pzX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc29vX2ZsYWdzX3VzZV9qc19zdHJpbmcodW5pdCl7XG4gIHJldHVybiBGTEFHKFwidXNlLWpzLXN0cmluZ1wiKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzb29fZmxhZ3NfZWZmZWN0c1xuZnVuY3Rpb24gY2FtbF9qc29vX2ZsYWdzX2VmZmVjdHModW5pdCl7XG4gIHJldHVybiBGTEFHKFwiZWZmZWN0c1wiKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3dyYXBfZXhjZXB0aW9uIGNvbnN0IChtdXRhYmxlKVxuLy9SZXF1aXJlczogY2FtbF9nbG9iYWxfZGF0YSxjYW1sX3N0cmluZ19vZl9qc3N0cmluZyxjYW1sX25hbWVkX3ZhbHVlXG5mdW5jdGlvbiBjYW1sX3dyYXBfZXhjZXB0aW9uKGUpIHtcbiAgaWYgKEZMQUcoXCJleGN3cmFwXCIpKSB7XG4gICAgaWYoZSBpbnN0YW5jZW9mIEFycmF5KSByZXR1cm4gZTtcbiAgICB2YXIgZXhuO1xuICAgIC8vU3RhY2tfb3ZlcmZsb3c6IGNocm9tZSwgc2FmYXJpXG4gICAgaWYoZ2xvYmFsVGhpcy5SYW5nZUVycm9yXG4gICAgICAgJiYgZSBpbnN0YW5jZW9mIGdsb2JhbFRoaXMuUmFuZ2VFcnJvclxuICAgICAgICYmIGUubWVzc2FnZVxuICAgICAgICYmIGUubWVzc2FnZS5tYXRjaCgvbWF4aW11bSBjYWxsIHN0YWNrL2kpKVxuICAgICAgZXhuID0gY2FtbF9nbG9iYWxfZGF0YS5TdGFja19vdmVyZmxvdztcbiAgICAvL1N0YWNrX292ZXJmbG93OiBmaXJlZm94XG4gICAgZWxzZSBpZihnbG9iYWxUaGlzLkludGVybmFsRXJyb3JcbiAgICAgICAmJiBlIGluc3RhbmNlb2YgZ2xvYmFsVGhpcy5JbnRlcm5hbEVycm9yXG4gICAgICAgJiYgZS5tZXNzYWdlXG4gICAgICAgJiYgZS5tZXNzYWdlLm1hdGNoKC90b28gbXVjaCByZWN1cnNpb24vaSkpXG4gICAgICBleG4gPSBjYW1sX2dsb2JhbF9kYXRhLlN0YWNrX292ZXJmbG93O1xuICAgIC8vV3JhcCBFcnJvciBpbiBKcy5FcnJvciBleGNlcHRpb25cbiAgICBlbHNlIGlmKGUgaW5zdGFuY2VvZiBnbG9iYWxUaGlzLkVycm9yICYmIGNhbWxfbmFtZWRfdmFsdWUoXCJqc0Vycm9yXCIpKVxuICAgICAgZXhuID0gWzAsY2FtbF9uYW1lZF92YWx1ZShcImpzRXJyb3JcIiksZV07XG4gICAgZWxzZVxuICAgICAgLy9mYWxsYmFjazogd3JhcHBlZCBpbiBGYWlsdXJlXG4gICAgICBleG4gPSBbMCxjYW1sX2dsb2JhbF9kYXRhLkZhaWx1cmUsY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcgKFN0cmluZyhlKSldO1xuICAgIC8vIFdlIGFscmVhZHkgaGF2ZSBhbiBlcnJvciBhdCBoYW5kLCBsZXQncyB1c2UgaXQuXG4gICAgaWYgKGUgaW5zdGFuY2VvZiBnbG9iYWxUaGlzLkVycm9yKVxuICAgICAgZXhuLmpzX2Vycm9yID0gZTtcbiAgICByZXR1cm4gZXhuO1xuICB9IGVsc2VcbiAgICByZXR1cm4gZTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlXG4vL1JlcXVpcmVzOiBjYW1sX2V4bl93aXRoX2pzX2JhY2t0cmFjZVxuLy9SZXF1aXJlczogY2FtbF9yZWNvcmRfYmFja3RyYWNlX2ZsYWdcbmZ1bmN0aW9uIGNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZShleG4sIGZvcmNlKSB7XG4gIGlmKGNhbWxfcmVjb3JkX2JhY2t0cmFjZV9mbGFnKVxuICAgIHJldHVybiBjYW1sX2V4bl93aXRoX2pzX2JhY2t0cmFjZShleG4sIGZvcmNlKTtcbiAgZWxzZSByZXR1cm4gZXhuXG59XG5cbi8vIEV4cGVyaW1lbnRhbFxuLy9Qcm92aWRlczogY2FtbF9leG5fd2l0aF9qc19iYWNrdHJhY2Vcbi8vUmVxdWlyZXM6IGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfZXhuX3dpdGhfanNfYmFja3RyYWNlKGV4biwgZm9yY2UpIHtcbiAgLy9uZXZlciByZXJhaXNlIGZvciBjb25zdGFudCBleG5cbiAgaWYoIWV4bi5qc19lcnJvciB8fCBmb3JjZSB8fCBleG5bMF0gPT0gMjQ4KSBleG4uanNfZXJyb3IgPSBuZXcgZ2xvYmFsVGhpcy5FcnJvcihcIkpzIGV4Y2VwdGlvbiBjb250YWluaW5nIGJhY2t0cmFjZVwiKTtcbiAgcmV0dXJuIGV4bjtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2Vycm9yX29wdGlvbl9vZl9leGNlcHRpb25cbmZ1bmN0aW9uIGNhbWxfanNfZXJyb3Jfb3B0aW9uX29mX2V4Y2VwdGlvbihleG4pIHtcbiAgaWYoZXhuLmpzX2Vycm9yKSB7IHJldHVybiBbMCwgZXhuLmpzX2Vycm9yXTsgfVxuICByZXR1cm4gMDtcbn1cblxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZnJvbV9ib29sIGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfZnJvbV9ib29sKHgpIHsgcmV0dXJuICEheDsgfVxuLy9Qcm92aWRlczogY2FtbF9qc190b19ib29sIGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfdG9fYm9vbCh4KSB7IHJldHVybiAreDsgfVxuLy9Qcm92aWRlczogY2FtbF9qc19mcm9tX2Zsb2F0IGNvbnN0IChjb25zdClcbi8vQWxpYXM6IGNhbWxfanNfZnJvbV9pbnQzMlxuLy9BbGlhczogY2FtbF9qc19mcm9tX25hdGl2ZWludFxuZnVuY3Rpb24gY2FtbF9qc19mcm9tX2Zsb2F0KHgpIHsgcmV0dXJuIHg7IH1cbi8vUHJvdmlkZXM6IGNhbWxfanNfdG9fZmxvYXQgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc190b19mbG9hdCh4KSB7IHJldHVybiB4OyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3RvX2ludDMyIGNvbnN0IChjb25zdClcbi8vQWxpYXM6IGNhbWxfanNfdG9fbmF0aXZlaW50XG5mdW5jdGlvbiBjYW1sX2pzX3RvX2ludDMyKHgpIHsgcmV0dXJuIHh8MDsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2Zyb21fYXJyYXkgbXV0YWJsZSAoc2hhbGxvdylcbmZ1bmN0aW9uIGNhbWxfanNfZnJvbV9hcnJheShhKSB7XG4gIHJldHVybiBhLnNsaWNlKDEpO1xufVxuLy9Qcm92aWRlczogY2FtbF9qc190b19hcnJheSBtdXRhYmxlIChzaGFsbG93KVxuZnVuY3Rpb24gY2FtbF9qc190b19hcnJheShhKSB7XG4gIHZhciBsZW4gPSBhLmxlbmd0aDtcbiAgdmFyIGIgPSBuZXcgQXJyYXkobGVuKzEpO1xuICBiWzBdID0gMDtcbiAgZm9yKHZhciBpPTA7aTxsZW47aSsrKSBiW2krMV0gPSBhW2ldO1xuICByZXR1cm4gYjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9saXN0X29mX2pzX2FycmF5IGNvbnN0IChtdXRhYmxlKVxuZnVuY3Rpb24gY2FtbF9saXN0X29mX2pzX2FycmF5KGEpe1xuICB2YXIgbCA9IDA7XG4gIGZvcih2YXIgaT1hLmxlbmd0aCAtIDE7IGk+PTA7IGktLSl7XG4gICAgdmFyIGUgPSBhW2ldO1xuICAgIGwgPSBbMCxlLGxdO1xuICB9XG4gIHJldHVybiBsXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbGlzdF90b19qc19hcnJheSBjb25zdCAobXV0YWJsZSlcbmZ1bmN0aW9uIGNhbWxfbGlzdF90b19qc19hcnJheShsKXtcbiAgdmFyIGEgPSBbXTtcbiAgZm9yKDsgbCAhPT0gMDsgbCA9IGxbMl0pIHtcbiAgICBhLnB1c2gobFsxXSk7XG4gIH1cbiAgcmV0dXJuIGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfdmFyIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2pzX3Zhcih4KSB7XG4gIHZhciB4ID0gY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcoeCk7XG4gIC8vQ2hlY2tzIHRoYXQgeCBoYXMgdGhlIGZvcm0gaWRlbnRbLmlkZW50XSpcbiAgaWYoIXgubWF0Y2goL15bYS16QS1aXyRdW2EtekEtWl8kMC05XSooXFwuW2EtekEtWl8kXVthLXpBLVpfJDAtOV0qKSokLykpe1xuICAgIGNvbnNvbGUuZXJyb3IoXCJjYW1sX2pzX3ZhcjogXFxcIlwiICsgeCArIFwiXFxcIiBpcyBub3QgYSB2YWxpZCBKYXZhU2NyaXB0IHZhcmlhYmxlLiBjb250aW51aW5nIC4uXCIpO1xuICAgIC8vY29uc29sZS5lcnJvcihcIkpzLlVuc2FmZS5ldmFsX3N0cmluZ1wiKVxuICB9XG4gIHJldHVybiBldmFsKHgpO1xufVxuLy9Qcm92aWRlczogY2FtbF9qc19jYWxsIChjb25zdCwgbXV0YWJsZSwgc2hhbGxvdylcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheVxuZnVuY3Rpb24gY2FtbF9qc19jYWxsKGYsIG8sIGFyZ3MpIHsgcmV0dXJuIGYuYXBwbHkobywgY2FtbF9qc19mcm9tX2FycmF5KGFyZ3MpKTsgfVxuLy9Qcm92aWRlczogY2FtbF9qc19mdW5fY2FsbCAoY29uc3QsIHNoYWxsb3cpXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfanNfZnVuX2NhbGwoZiwgYSkge1xuICBzd2l0Y2ggKGEubGVuZ3RoKSB7XG4gIGNhc2UgMTogcmV0dXJuIGYoKTtcbiAgY2FzZSAyOiByZXR1cm4gZiAoYVsxXSk7XG4gIGNhc2UgMzogcmV0dXJuIGYgKGFbMV0sYVsyXSk7XG4gIGNhc2UgNDogcmV0dXJuIGYgKGFbMV0sYVsyXSxhWzNdKTtcbiAgY2FzZSA1OiByZXR1cm4gZiAoYVsxXSxhWzJdLGFbM10sYVs0XSk7XG4gIGNhc2UgNjogcmV0dXJuIGYgKGFbMV0sYVsyXSxhWzNdLGFbNF0sYVs1XSk7XG4gIGNhc2UgNzogcmV0dXJuIGYgKGFbMV0sYVsyXSxhWzNdLGFbNF0sYVs1XSxhWzZdKTtcbiAgY2FzZSA4OiByZXR1cm4gZiAoYVsxXSxhWzJdLGFbM10sYVs0XSxhWzVdLGFbNl0sYVs3XSk7XG4gIH1cbiAgcmV0dXJuIGYuYXBwbHkobnVsbCwgY2FtbF9qc19mcm9tX2FycmF5KGEpKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfbWV0aF9jYWxsIChtdXRhYmxlLCBjb25zdCwgc2hhbGxvdylcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfanNfbWV0aF9jYWxsKG8sIGYsIGFyZ3MpIHtcbiAgcmV0dXJuIG9bY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcoZildLmFwcGx5KG8sIGNhbWxfanNfZnJvbV9hcnJheShhcmdzKSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX25ldyAoY29uc3QsIHNoYWxsb3cpXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfanNfbmV3KGMsIGEpIHtcbiAgc3dpdGNoIChhLmxlbmd0aCkge1xuICBjYXNlIDE6IHJldHVybiBuZXcgYztcbiAgY2FzZSAyOiByZXR1cm4gbmV3IGMgKGFbMV0pO1xuICBjYXNlIDM6IHJldHVybiBuZXcgYyAoYVsxXSxhWzJdKTtcbiAgY2FzZSA0OiByZXR1cm4gbmV3IGMgKGFbMV0sYVsyXSxhWzNdKTtcbiAgY2FzZSA1OiByZXR1cm4gbmV3IGMgKGFbMV0sYVsyXSxhWzNdLGFbNF0pO1xuICBjYXNlIDY6IHJldHVybiBuZXcgYyAoYVsxXSxhWzJdLGFbM10sYVs0XSxhWzVdKTtcbiAgY2FzZSA3OiByZXR1cm4gbmV3IGMgKGFbMV0sYVsyXSxhWzNdLGFbNF0sYVs1XSxhWzZdKTtcbiAgY2FzZSA4OiByZXR1cm4gbmV3IGMgKGFbMV0sYVsyXSxhWzNdLGFbNF0sYVs1XSxhWzZdLGFbN10pO1xuICB9XG4gIGZ1bmN0aW9uIEYoKSB7IHJldHVybiBjLmFwcGx5KHRoaXMsIGNhbWxfanNfZnJvbV9hcnJheShhKSk7IH1cbiAgRi5wcm90b3R5cGUgPSBjLnByb3RvdHlwZTtcbiAgcmV0dXJuIG5ldyBGO1xufVxuLy9Qcm92aWRlczogY2FtbF9vanNfbmV3X2FyciAoY29uc3QsIHNoYWxsb3cpXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfb2pzX25ld19hcnIoYywgYSkge1xuICBzd2l0Y2ggKGEubGVuZ3RoKSB7XG4gIGNhc2UgMDogcmV0dXJuIG5ldyBjO1xuICBjYXNlIDE6IHJldHVybiBuZXcgYyAoYVswXSk7XG4gIGNhc2UgMjogcmV0dXJuIG5ldyBjIChhWzBdLGFbMV0pO1xuICBjYXNlIDM6IHJldHVybiBuZXcgYyAoYVswXSxhWzFdLGFbMl0pO1xuICBjYXNlIDQ6IHJldHVybiBuZXcgYyAoYVswXSxhWzFdLGFbMl0sYVszXSk7XG4gIGNhc2UgNTogcmV0dXJuIG5ldyBjIChhWzBdLGFbMV0sYVsyXSxhWzNdLGFbNF0pO1xuICBjYXNlIDY6IHJldHVybiBuZXcgYyAoYVswXSxhWzFdLGFbMl0sYVszXSxhWzRdLGFbNV0pO1xuICBjYXNlIDc6IHJldHVybiBuZXcgYyAoYVswXSxhWzFdLGFbMl0sYVszXSxhWzRdLGFbNV0sYVs2XSk7XG4gIH1cbiAgZnVuY3Rpb24gRigpIHsgcmV0dXJuIGMuYXBwbHkodGhpcywgYSk7IH1cbiAgRi5wcm90b3R5cGUgPSBjLnByb3RvdHlwZTtcbiAgcmV0dXJuIG5ldyBGO1xufVxuLy9Qcm92aWRlczogY2FtbF9qc193cmFwX2NhbGxiYWNrIGNvbnN0IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY2FsbGJhY2tcbmZ1bmN0aW9uIGNhbWxfanNfd3JhcF9jYWxsYmFjayhmKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgaWYobGVuID4gMCl7XG4gICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShsZW4pO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXJncyA9IFt1bmRlZmluZWRdO1xuICAgIH1cbiAgICB2YXIgcmVzID0gY2FtbF9jYWxsYmFjayhmLCBhcmdzKTtcbiAgICByZXR1cm4gKHJlcyBpbnN0YW5jZW9mIEZ1bmN0aW9uKT9jYW1sX2pzX3dyYXBfY2FsbGJhY2socmVzKTpyZXM7XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9qc193cmFwX2NhbGxiYWNrX2FyZ3VtZW50c1xuLy9SZXF1aXJlczogY2FtbF9jYWxsYmFja1xuZnVuY3Rpb24gY2FtbF9qc193cmFwX2NhbGxiYWNrX2FyZ3VtZW50cyhmKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgcmV0dXJuIGNhbWxfY2FsbGJhY2soZiwgW2FyZ3NdKTtcbiAgfVxufVxuLy9Qcm92aWRlczogY2FtbF9qc193cmFwX2NhbGxiYWNrX3N0cmljdCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9jYWxsYmFja1xuZnVuY3Rpb24gY2FtbF9qc193cmFwX2NhbGxiYWNrX3N0cmljdChhcml0eSwgZikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcml0eSk7XG4gICAgdmFyIGxlbiA9IE1hdGgubWluKGFyZ3VtZW50cy5sZW5ndGgsIGFyaXR5KVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgcmV0dXJuIGNhbWxfY2FsbGJhY2soZiwgYXJncyk7XG4gIH07XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3dyYXBfY2FsbGJhY2tfdW5zYWZlIGNvbnN0IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY2FsbGJhY2ssIGNhbWxfanNfZnVuY3Rpb25fYXJpdHlcbmZ1bmN0aW9uIGNhbWxfanNfd3JhcF9jYWxsYmFja191bnNhZmUoZikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBsZW4gPSBjYW1sX2pzX2Z1bmN0aW9uX2FyaXR5KGYpO1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICByZXR1cm4gY2FtbF9jYWxsYmFjayhmLCBhcmdzKTsgfVxufVxuLy9Qcm92aWRlczogY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2sgY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jYWxsYmFjaywgY2FtbF9qc193cmFwX2NhbGxiYWNrXG5mdW5jdGlvbiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFjayhmKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkobGVuICsgMSk7XG4gICAgYXJnc1swXSA9IHRoaXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgYXJnc1tpKzFdID0gYXJndW1lbnRzW2ldO1xuICAgIHZhciByZXMgPSBjYW1sX2NhbGxiYWNrKGYsYXJncyk7XG4gICAgcmV0dXJuIChyZXMgaW5zdGFuY2VvZiBGdW5jdGlvbik/Y2FtbF9qc193cmFwX2NhbGxiYWNrKHJlcyk6cmVzO1xuICB9XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja19hcmd1bWVudHMgY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jYWxsYmFja1xuZnVuY3Rpb24gY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2tfYXJndW1lbnRzKGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgcmV0dXJuIGNhbWxfY2FsbGJhY2soZixbdGhpcyxhcmdzXSk7XG4gIH1cbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrX3N0cmljdCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9jYWxsYmFja1xuZnVuY3Rpb24gY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2tfc3RyaWN0KGFyaXR5LCBmKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJpdHkgKyAxKTtcbiAgICB2YXIgbGVuID0gTWF0aC5taW4oYXJndW1lbnRzLmxlbmd0aCwgYXJpdHkpXG4gICAgYXJnc1swXSA9IHRoaXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgYXJnc1tpKzFdID0gYXJndW1lbnRzW2ldO1xuICAgIHJldHVybiBjYW1sX2NhbGxiYWNrKGYsIGFyZ3MpO1xuICB9O1xufVxuLy9Qcm92aWRlczogY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2tfdW5zYWZlIGNvbnN0IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY2FsbGJhY2ssIGNhbWxfanNfZnVuY3Rpb25fYXJpdHlcbmZ1bmN0aW9uIGNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrX3Vuc2FmZShmKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxlbiA9IGNhbWxfanNfZnVuY3Rpb25fYXJpdHkoZikgLSAxO1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGxlbiArIDEpO1xuICAgIGFyZ3NbMF0gPSB0aGlzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIGFyZ3NbaSsxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICByZXR1cm4gY2FtbF9jYWxsYmFjayhmLCBhcmdzKTsgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2Z1bmN0aW9uX2FyaXR5XG4vL0lmOiAhZWZmZWN0c1xuZnVuY3Rpb24gY2FtbF9qc19mdW5jdGlvbl9hcml0eShmKSB7XG4gIHJldHVybiAoZi5sID49IDApP2YubDooZi5sID0gZi5sZW5ndGgpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZnVuY3Rpb25fYXJpdHlcbi8vSWY6IGVmZmVjdHNcbmZ1bmN0aW9uIGNhbWxfanNfZnVuY3Rpb25fYXJpdHkoZikge1xuICAvLyBGdW5jdGlvbnMgaGF2ZSBhbiBhZGRpdGlvbmFsIGNvbnRpbnVhdGlvbiBwYXJhbWV0ZXIuIFRoaXMgc2hvdWxkXG4gIC8vIG5vdCBiZSB2aXNpYmxlIHdoZW4gY2FsbGluZyB0aGVtIGZyb20gSmF2YVNjcmlwdFxuICByZXR1cm4gKChmLmwgPj0gMCk/Zi5sOihmLmwgPSBmLmxlbmd0aCkpIC0gMVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2VxdWFscyBtdXRhYmxlIChjb25zdCwgY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX2VxdWFscyAoeCwgeSkgeyByZXR1cm4gKyh4ID09IHkpOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfc3RyaWN0X2VxdWFscyBtdXRhYmxlIChjb25zdCwgY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX3N0cmljdF9lcXVhbHMgKHgsIHkpIHsgcmV0dXJuICsoeCA9PT0geSk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9qc19ldmFsX3N0cmluZyAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc19ldmFsX3N0cmluZyAocykge3JldHVybiBldmFsKGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHMpKTt9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZXhwciAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc19leHByKHMpIHtcbiAgY29uc29sZS5lcnJvcihcImNhbWxfanNfZXhwcjogZmFsbGJhY2sgdG8gcnVudGltZSBldmFsdWF0aW9uXFxuXCIpO1xuICByZXR1cm4gZXZhbChjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhzKSk7fVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3B1cmVfanNfZXhwciBjb25zdCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9wdXJlX2pzX2V4cHIgKHMpe1xuICBjb25zb2xlLmVycm9yKFwiY2FtbF9wdXJlX2pzX2V4cHI6IGZhbGxiYWNrIHRvIHJ1bnRpbWUgZXZhbHVhdGlvblxcblwiKTtcbiAgcmV0dXJuIGV2YWwoY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocykpO31cblxuLy9Qcm92aWRlczogY2FtbF9qc19vYmplY3QgKG9iamVjdF9saXRlcmFsKVxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfanNfb2JqZWN0IChhKSB7XG4gIHZhciBvID0ge307XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwID0gYVtpXTtcbiAgICBvW2NhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHBbMV0pXSA9IHBbMl07XG4gIH1cbiAgcmV0dXJuIG87XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1JhaXNlIGV4Y2VwdGlvblxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JhaXNlX2NvbnN0YW50IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfcmFpc2VfY29uc3RhbnQgKHRhZykgeyB0aHJvdyB0YWc7IH1cblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV93aXRoX2FyZyAoY29uc3QsIG11dGFibGUpXG4vL1JlcXVpcmVzOiBjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2VcbmZ1bmN0aW9uIGNhbWxfcmFpc2Vfd2l0aF9hcmcgKHRhZywgYXJnKSB7IHRocm93IGNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZShbMCwgdGFnLCBhcmddKTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JhaXNlX3dpdGhfYXJncyAoY29uc3QsIG11dGFibGUpXG4vL1JlcXVpcmVzOiBjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2VcbmZ1bmN0aW9uIGNhbWxfcmFpc2Vfd2l0aF9hcmdzICh0YWcsIGFyZ3MpIHsgdGhyb3cgY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlKFswLCB0YWddLmNvbmNhdChhcmdzKSk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV93aXRoX3N0cmluZyAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV93aXRoX2FyZywgY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9yYWlzZV93aXRoX3N0cmluZyAodGFnLCBtc2cpIHtcbiAgY2FtbF9yYWlzZV93aXRoX2FyZyAodGFnLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKG1zZykpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ZhaWx3aXRoIChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcsIGNhbWxfZ2xvYmFsX2RhdGEsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfZmFpbHdpdGggKG1zZykge1xuICBpZighY2FtbF9nbG9iYWxfZGF0YS5GYWlsdXJlKVxuICAgIGNhbWxfZ2xvYmFsX2RhdGEuRmFpbHVyZT1bMjQ4LGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoXCJGYWlsdXJlXCIpLC0zXTtcbiAgY2FtbF9yYWlzZV93aXRoX3N0cmluZyhjYW1sX2dsb2JhbF9kYXRhLkZhaWx1cmUsIG1zZyk7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcsIGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfaW52YWxpZF9hcmd1bWVudCAobXNnKSB7XG4gIGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcoY2FtbF9nbG9iYWxfZGF0YS5JbnZhbGlkX2FyZ3VtZW50LCBtc2cpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JhaXNlX2VuZF9vZl9maWxlXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX2NvbnN0YW50LCBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX3JhaXNlX2VuZF9vZl9maWxlICgpIHtcbiAgY2FtbF9yYWlzZV9jb25zdGFudChjYW1sX2dsb2JhbF9kYXRhLkVuZF9vZl9maWxlKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV96ZXJvX2RpdmlkZVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9jb25zdGFudCwgY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9yYWlzZV96ZXJvX2RpdmlkZSAoKSB7XG4gIGNhbWxfcmFpc2VfY29uc3RhbnQoY2FtbF9nbG9iYWxfZGF0YS5EaXZpc2lvbl9ieV96ZXJvKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV9ub3RfZm91bmRcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2VfY29uc3RhbnQsIGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfcmFpc2Vfbm90X2ZvdW5kICgpIHtcbiAgY2FtbF9yYWlzZV9jb25zdGFudChjYW1sX2dsb2JhbF9kYXRhLk5vdF9mb3VuZCk7IH1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IgKCkge1xuICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJpbmRleCBvdXQgb2YgYm91bmRzXCIpO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDE0IErDqXLDtG1lIFZvdWlsbG9uLCBIdWdvIEhldXphcmRcbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8vLy8vLy8vLy8vLyBEdW1teSBmaWxlc3lzdGVtXG5cbi8vUHJvdmlkZXM6IGNhbWxfdHJhaWxpbmdfc2xhc2hcbmZ1bmN0aW9uIGNhbWxfdHJhaWxpbmdfc2xhc2gobmFtZSl7XG4gIHJldHVybiAobmFtZS5zbGljZSgtMSkgIT09IFwiL1wiKSA/IChuYW1lICsgXCIvXCIpIDogbmFtZTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jdXJyZW50X2RpclxuLy9SZXF1aXJlczogY2FtbF90cmFpbGluZ19zbGFzaCwgZnNfbm9kZV9zdXBwb3J0ZWRcbmlmKGZzX25vZGVfc3VwcG9ydGVkICgpICYmIGdsb2JhbFRoaXMucHJvY2VzcyAmJiBnbG9iYWxUaGlzLnByb2Nlc3MuY3dkKVxuICB2YXIgY2FtbF9jdXJyZW50X2RpciA9IGdsb2JhbFRoaXMucHJvY2Vzcy5jd2QoKS5yZXBsYWNlKC9cXFxcL2csJy8nKTtcbmVsc2VcbiAgdmFyIGNhbWxfY3VycmVudF9kaXIgPSAgXCIvc3RhdGljXCI7XG5jYW1sX2N1cnJlbnRfZGlyID0gY2FtbF90cmFpbGluZ19zbGFzaChjYW1sX2N1cnJlbnRfZGlyKTtcblxuLy9Qcm92aWRlczogY2FtbF9nZXRfcm9vdFxuLy9SZXF1aXJlczogcGF0aF9pc19hYnNvbHV0ZVxuZnVuY3Rpb24gY2FtbF9nZXRfcm9vdChwYXRoKXtcbiAgdmFyIHggPSBwYXRoX2lzX2Fic29sdXRlKHBhdGgpO1xuICBpZiAoIXgpIHJldHVybjtcbiAgcmV0dXJuIHhbMF0gKyBcIi9cIn1cblxuLy9Qcm92aWRlczogY2FtbF9yb290XG4vL1JlcXVpcmVzOiBjYW1sX2dldF9yb290LCBjYW1sX2N1cnJlbnRfZGlyLCBjYW1sX2ZhaWx3aXRoXG52YXIgY2FtbF9yb290ID0gY2FtbF9nZXRfcm9vdChjYW1sX2N1cnJlbnRfZGlyKSB8fCBjYW1sX2ZhaWx3aXRoKFwidW5hYmxlIHRvIGNvbXB1dGUgY2FtbF9yb290XCIpO1xuXG5cbi8vUHJvdmlkZXM6IE1sRmlsZVxuZnVuY3Rpb24gTWxGaWxlKCl7ICB9XG5cbi8vUHJvdmlkZXM6IHBhdGhfaXNfYWJzb2x1dGVcbi8vUmVxdWlyZXM6IGZzX25vZGVfc3VwcG9ydGVkXG5mdW5jdGlvbiBtYWtlX3BhdGhfaXNfYWJzb2x1dGUoKSB7XG4gIGZ1bmN0aW9uIHBvc2l4KHBhdGgpIHtcbiAgICBpZiAocGF0aC5jaGFyQXQoMCkgPT09ICcvJykgcmV0dXJuIFtcIlwiLCBwYXRoLnN1YnN0cmluZygxKV07XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZnVuY3Rpb24gd2luMzIocGF0aCkge1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL2IzZmNjMjQ1ZmIyNTUzOTkwOWVmMWQ1ZWFhMDFkYmY5MmUxNjg2MzMvbGliL3BhdGguanMjTDU2XG4gICAgdmFyIHNwbGl0RGV2aWNlUmUgPSAvXihbYS16QS1aXTp8W1xcXFwvXXsyfVteXFxcXC9dK1tcXFxcL10rW15cXFxcL10rKT8oW1xcXFwvXSk/KFtcXHNcXFNdKj8pJC87XG4gICAgdmFyIHJlc3VsdCA9IHNwbGl0RGV2aWNlUmUuZXhlYyhwYXRoKTtcbiAgICB2YXIgZGV2aWNlID0gcmVzdWx0WzFdIHx8ICcnO1xuICAgIHZhciBpc1VuYyA9IEJvb2xlYW4oZGV2aWNlICYmIGRldmljZS5jaGFyQXQoMSkgIT09ICc6Jyk7XG5cbiAgICAvLyBVTkMgcGF0aHMgYXJlIGFsd2F5cyBhYnNvbHV0ZVxuICAgIGlmIChCb29sZWFuKHJlc3VsdFsyXSB8fCBpc1VuYykpIHtcbiAgICAgIHZhciByb290ID0gKHJlc3VsdFsxXSB8fCAnJyk7XG4gICAgICB2YXIgc2VwID0gKHJlc3VsdFsyXSB8fCAnJyk7XG4gICAgICByZXR1cm4gW3Jvb3QsIHBhdGguc3Vic3RyaW5nKHJvb3QubGVuZ3RoICsgc2VwLmxlbmd0aCldXG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICBpZihmc19ub2RlX3N1cHBvcnRlZCAoKSAmJiBnbG9iYWxUaGlzLnByb2Nlc3MgJiYgZ2xvYmFsVGhpcy5wcm9jZXNzLnBsYXRmb3JtKSB7XG4gICAgcmV0dXJuIGdsb2JhbFRoaXMucHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJyA/IHdpbjMyIDogcG9zaXg7XG4gIH1cbiAgZWxzZSByZXR1cm4gcG9zaXhcbn1cbnZhciBwYXRoX2lzX2Fic29sdXRlID0gbWFrZV9wYXRoX2lzX2Fic29sdXRlKCk7XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWFrZV9wYXRoXG4vL1JlcXVpcmVzOiBjYW1sX2N1cnJlbnRfZGlyXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZywgcGF0aF9pc19hYnNvbHV0ZVxuZnVuY3Rpb24gY2FtbF9tYWtlX3BhdGggKG5hbWUpIHtcbiAgbmFtZT1jYW1sX2pzc3RyaW5nX29mX3N0cmluZyhuYW1lKTtcbiAgaWYoICFwYXRoX2lzX2Fic29sdXRlKG5hbWUpIClcbiAgICBuYW1lID0gY2FtbF9jdXJyZW50X2RpciArIG5hbWU7XG4gIHZhciBjb21wMCA9IHBhdGhfaXNfYWJzb2x1dGUobmFtZSk7XG4gIHZhciBjb21wID0gY29tcDBbMV0uc3BsaXQoXCIvXCIpO1xuICB2YXIgbmNvbXAgPSBbXVxuICBmb3IodmFyIGkgPSAwOyBpPGNvbXAubGVuZ3RoOyBpKyspe1xuICAgIHN3aXRjaChjb21wW2ldKXtcbiAgICBjYXNlIFwiLi5cIjogaWYobmNvbXAubGVuZ3RoPjEpIG5jb21wLnBvcCgpOyBicmVhaztcbiAgICBjYXNlIFwiLlwiOiBicmVhaztcbiAgICBjYXNlIFwiXCI6IGJyZWFrO1xuICAgIGRlZmF1bHQ6IG5jb21wLnB1c2goY29tcFtpXSk7YnJlYWtcbiAgICB9XG4gIH1cbiAgbmNvbXAudW5zaGlmdChjb21wMFswXSk7XG4gIG5jb21wLm9yaWcgPSBuYW1lO1xuICByZXR1cm4gbmNvbXA7XG59XG5cbi8vUHJvdmlkZXM6anNvb19tb3VudF9wb2ludFxuLy9SZXF1aXJlczogTWxGYWtlRGV2aWNlLCBNbE5vZGVEZXZpY2UsIGNhbWxfcm9vdCwgZnNfbm9kZV9zdXBwb3J0ZWRcbnZhciBqc29vX21vdW50X3BvaW50ID0gW11cbmlmIChmc19ub2RlX3N1cHBvcnRlZCgpKSB7XG4gIGpzb29fbW91bnRfcG9pbnQucHVzaCh7cGF0aDpjYW1sX3Jvb3QsZGV2aWNlOm5ldyBNbE5vZGVEZXZpY2UoY2FtbF9yb290KX0pO1xufSBlbHNlIHtcbiAganNvb19tb3VudF9wb2ludC5wdXNoKHtwYXRoOmNhbWxfcm9vdCxkZXZpY2U6bmV3IE1sRmFrZURldmljZShjYW1sX3Jvb3QpfSk7XG59XG5qc29vX21vdW50X3BvaW50LnB1c2goe3BhdGg6XCIvc3RhdGljL1wiLCBkZXZpY2U6bmV3IE1sRmFrZURldmljZShcIi9zdGF0aWMvXCIpfSk7XG5cbi8vUHJvdmlkZXM6Y2FtbF9saXN0X21vdW50X3BvaW50XG4vL1JlcXVpcmVzOiBqc29vX21vdW50X3BvaW50LCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX2xpc3RfbW91bnRfcG9pbnQoKXtcbiAgdmFyIHByZXYgPSAwXG4gIGZvcih2YXIgaSA9IDA7IGkgPCBqc29vX21vdW50X3BvaW50Lmxlbmd0aDsgaSsrKXtcbiAgICB2YXIgb2xkID0gcHJldjtcbiAgICBwcmV2ID0gWzAsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoanNvb19tb3VudF9wb2ludFtpXS5wYXRoKSwgb2xkXVxuICB9XG4gIHJldHVybiBwcmV2O1xufVxuXG4vL1Byb3ZpZGVzOiByZXNvbHZlX2ZzX2RldmljZVxuLy9SZXF1aXJlczogY2FtbF9tYWtlX3BhdGgsIGpzb29fbW91bnRfcG9pbnQsIGNhbWxfcmFpc2Vfc3lzX2Vycm9yLCBjYW1sX2dldF9yb290LCBNbE5vZGVEZXZpY2UsIGNhbWxfdHJhaWxpbmdfc2xhc2gsIGZzX25vZGVfc3VwcG9ydGVkXG5mdW5jdGlvbiByZXNvbHZlX2ZzX2RldmljZShuYW1lKXtcbiAgdmFyIHBhdGggPSBjYW1sX21ha2VfcGF0aChuYW1lKTtcbiAgdmFyIG5hbWUgPSBwYXRoLmpvaW4oXCIvXCIpO1xuICB2YXIgbmFtZV9zbGFzaCA9IGNhbWxfdHJhaWxpbmdfc2xhc2gobmFtZSk7XG4gIHZhciByZXM7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBqc29vX21vdW50X3BvaW50Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG0gPSBqc29vX21vdW50X3BvaW50W2ldO1xuICAgIGlmKG5hbWVfc2xhc2guc2VhcmNoKG0ucGF0aCkgPT0gMFxuICAgICAgICYmICghcmVzIHx8IHJlcy5wYXRoLmxlbmd0aCA8IG0ucGF0aC5sZW5ndGgpKVxuICAgICAgcmVzID0ge3BhdGg6bS5wYXRoLGRldmljZTptLmRldmljZSxyZXN0Om5hbWUuc3Vic3RyaW5nKG0ucGF0aC5sZW5ndGgsbmFtZS5sZW5ndGgpfTtcbiAgfVxuICBpZiggIXJlcyAmJiBmc19ub2RlX3N1cHBvcnRlZCgpKSB7XG4gICAgdmFyIHJvb3QgPSBjYW1sX2dldF9yb290KG5hbWUpO1xuICAgIGlmIChyb290ICYmIHJvb3QubWF0Y2goL15bYS16QS1aXTpcXC8kLykpe1xuICAgICAgdmFyIG0gPSB7cGF0aDpyb290LGRldmljZTpuZXcgTWxOb2RlRGV2aWNlKHJvb3QpfTtcbiAgICAgIGpzb29fbW91bnRfcG9pbnQucHVzaChtKTtcbiAgICAgIHJlcyA9IHtwYXRoOm0ucGF0aCxkZXZpY2U6bS5kZXZpY2UscmVzdDpuYW1lLnN1YnN0cmluZyhtLnBhdGgubGVuZ3RoLG5hbWUubGVuZ3RoKX07XG4gICAgfVxuICB9XG4gIGlmKCByZXMgKSByZXR1cm4gcmVzO1xuICBjYW1sX3JhaXNlX3N5c19lcnJvcihcIm5vIGRldmljZSBmb3VuZCBmb3IgXCIgKyBuYW1lX3NsYXNoKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tb3VudF9hdXRvbG9hZFxuLy9SZXF1aXJlczogTWxGYWtlRGV2aWNlLCBjYW1sX21ha2VfcGF0aCwganNvb19tb3VudF9wb2ludCwgY2FtbF90cmFpbGluZ19zbGFzaFxuZnVuY3Rpb24gY2FtbF9tb3VudF9hdXRvbG9hZChuYW1lLGYpe1xuICB2YXIgcGF0aCA9IGNhbWxfbWFrZV9wYXRoKG5hbWUpO1xuICB2YXIgbmFtZSA9IGNhbWxfdHJhaWxpbmdfc2xhc2gocGF0aC5qb2luKFwiL1wiKSk7XG4gIGpzb29fbW91bnRfcG9pbnQucHVzaCh7cGF0aDpuYW1lLGRldmljZTpuZXcgTWxGYWtlRGV2aWNlKG5hbWUsZil9KVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bm1vdW50XG4vL1JlcXVpcmVzOiBqc29vX21vdW50X3BvaW50LCBjYW1sX21ha2VfcGF0aCwgY2FtbF90cmFpbGluZ19zbGFzaFxuZnVuY3Rpb24gY2FtbF91bm1vdW50KG5hbWUpe1xuICB2YXIgcGF0aCA9IGNhbWxfbWFrZV9wYXRoKG5hbWUpO1xuICB2YXIgbmFtZSA9IGNhbWxfdHJhaWxpbmdfc2xhc2gocGF0aC5qb2luKFwiL1wiKSk7XG4gIHZhciBpZHggPSAtMTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGpzb29fbW91bnRfcG9pbnQubGVuZ3RoOyBpKyspXG4gICAgaWYoanNvb19tb3VudF9wb2ludFtpXS5wYXRoID09IG5hbWUpIGlkeCA9IGk7XG4gIGlmKGlkeCA+IC0xKSBqc29vX21vdW50X3BvaW50LnNwbGljZShpZHgsMSk7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2dldGN3ZFxuLy9SZXF1aXJlczogY2FtbF9jdXJyZW50X2RpciwgY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9zeXNfZ2V0Y3dkKCkge1xuICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhjYW1sX2N1cnJlbnRfZGlyKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfY2hkaXJcbi8vUmVxdWlyZXM6IGNhbWxfY3VycmVudF9kaXIsIGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlLCByZXNvbHZlX2ZzX2RldmljZSwgY2FtbF90cmFpbGluZ19zbGFzaCwgY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9zeXNfY2hkaXIoZGlyKSB7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UoZGlyKTtcbiAgaWYocm9vdC5kZXZpY2UuZXhpc3RzKHJvb3QucmVzdCkpIHtcbiAgICBpZihyb290LnJlc3QpIGNhbWxfY3VycmVudF9kaXIgPSBjYW1sX3RyYWlsaW5nX3NsYXNoKHJvb3QucGF0aCArIHJvb3QucmVzdCk7XG4gICAgZWxzZSBjYW1sX2N1cnJlbnRfZGlyID0gcm9vdC5wYXRoO1xuICAgIHJldHVybiAwO1xuICB9XG4gIGVsc2Uge1xuICAgIGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlKGNhbWxfanNieXRlc19vZl9zdHJpbmcoZGlyKSk7XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGVcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfc3lzX2Vycm9yXG5mdW5jdGlvbiBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZShuYW1lKXtcbiAgY2FtbF9yYWlzZV9zeXNfZXJyb3IgKG5hbWUgKyBcIjogTm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeVwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV9ub3RfYV9kaXJcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfc3lzX2Vycm9yXG5mdW5jdGlvbiBjYW1sX3JhaXNlX25vdF9hX2RpcihuYW1lKXtcbiAgY2FtbF9yYWlzZV9zeXNfZXJyb3IgKG5hbWUgKyBcIjogTm90IGEgZGlyZWN0b3J5XCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19maWxlX2V4aXN0c1xuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2VcbmZ1bmN0aW9uIGNhbWxfc3lzX2ZpbGVfZXhpc3RzIChuYW1lKSB7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIHJldHVybiByb290LmRldmljZS5leGlzdHMocm9vdC5yZXN0KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfcmVhZF9kaXJlY3Rvcnlcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfbm90X2FfZGlyLCByZXNvbHZlX2ZzX2RldmljZVxuZnVuY3Rpb24gY2FtbF9zeXNfcmVhZF9kaXJlY3RvcnkobmFtZSl7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIHZhciBhID0gcm9vdC5kZXZpY2UucmVhZGRpcihyb290LnJlc3QpO1xuICB2YXIgbCA9IG5ldyBBcnJheShhLmxlbmd0aCArIDEpO1xuICBsWzBdID0gMDtcbiAgZm9yKHZhciBpPTA7aTxhLmxlbmd0aDtpKyspXG4gICAgbFtpKzFdID0gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhhW2ldKTtcbiAgcmV0dXJuIGw7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX3JlbW92ZVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUsIHJlc29sdmVfZnNfZGV2aWNlLCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N5c19yZW1vdmUobmFtZSl7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIHZhciBvayA9IHJvb3QuZGV2aWNlLnVubGluayhyb290LnJlc3QpO1xuICBpZihvayA9PSAwKSBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZShjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKG5hbWUpKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2lzX2RpcmVjdG9yeVxuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2VcbmZ1bmN0aW9uIGNhbWxfc3lzX2lzX2RpcmVjdG9yeShuYW1lKXtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgdmFyIGEgPSByb290LmRldmljZS5pc19kaXIocm9vdC5yZXN0KTtcbiAgcmV0dXJuIGE/MTowO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19yZW5hbWVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGgsIHJlc29sdmVfZnNfZGV2aWNlXG5mdW5jdGlvbiBjYW1sX3N5c19yZW5hbWUobyxuKXtcbiAgdmFyIG9fcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG8pO1xuICB2YXIgbl9yb290ID0gcmVzb2x2ZV9mc19kZXZpY2Uobik7XG4gIGlmKG9fcm9vdC5kZXZpY2UgIT0gbl9yb290LmRldmljZSlcbiAgICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9zeXNfcmVuYW1lOiBjYW5ub3QgbW92ZSBmaWxlIGJldHdlZW4gdHdvIGZpbGVzeXN0ZW1cIik7XG4gIGlmKCFvX3Jvb3QuZGV2aWNlLnJlbmFtZSlcbiAgICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9zeXNfcmVuYW1lOiBubyBpbXBsZW1lbnRlZFwiKTtcbiAgb19yb290LmRldmljZS5yZW5hbWUob19yb290LnJlc3QsIG5fcm9vdC5yZXN0KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfbWtkaXJcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlLCBjYW1sX3JhaXNlX3N5c19lcnJvclxuZnVuY3Rpb24gY2FtbF9zeXNfbWtkaXIobmFtZSwgcGVybSl7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIHJvb3QuZGV2aWNlLm1rZGlyKHJvb3QucmVzdCxwZXJtKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX3JtZGlyXG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZSwgY2FtbF9yYWlzZV9zeXNfZXJyb3IsIGNhbWxfcmFpc2Vfbm90X2FfZGlyXG5mdW5jdGlvbiBjYW1sX3N5c19ybWRpcihuYW1lKXtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgcm9vdC5kZXZpY2Uucm1kaXIocm9vdC5yZXN0KTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfbWFwX2ZpbGVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfYmFfbWFwX2ZpbGUodmZkLCBraW5kLCBsYXlvdXQsIHNoYXJlZCwgZGltcywgcG9zKSB7XG4gIC8vIHZhciBkYXRhID0gY2FtbF9zeXNfZmRzW3ZmZF07XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX2JhX21hcF9maWxlIG5vdCBpbXBsZW1lbnRlZFwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9tYXBfZmlsZV9ieXRlY29kZVxuLy9SZXF1aXJlczogY2FtbF9iYV9tYXBfZmlsZVxuZnVuY3Rpb24gY2FtbF9iYV9tYXBfZmlsZV9ieXRlY29kZShhcmd2LGFyZ24pe1xuICByZXR1cm4gY2FtbF9iYV9tYXBfZmlsZShhcmd2WzBdLGFyZ3ZbMV0sYXJndlsyXSxhcmd2WzNdLGFyZ3ZbNF0sYXJndls1XSk7XG59XG5cbi8vUHJvdmlkZXM6IGpzb29fY3JlYXRlX2ZpbGVfZXh0ZXJuXG5mdW5jdGlvbiBqc29vX2NyZWF0ZV9maWxlX2V4dGVybihuYW1lLGNvbnRlbnQpe1xuICBpZihnbG9iYWxUaGlzLmpzb29fY3JlYXRlX2ZpbGUpXG4gICAgZ2xvYmFsVGhpcy5qc29vX2NyZWF0ZV9maWxlKG5hbWUsY29udGVudCk7XG4gIGVsc2Uge1xuICAgIGlmKCFnbG9iYWxUaGlzLmNhbWxfZnNfdG1wKSBnbG9iYWxUaGlzLmNhbWxfZnNfdG1wID0gW107XG4gICAgZ2xvYmFsVGhpcy5jYW1sX2ZzX3RtcC5wdXNoKHtuYW1lOm5hbWUsY29udGVudDpjb250ZW50fSk7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZnNfaW5pdFxuLy9SZXF1aXJlczoganNvb19jcmVhdGVfZmlsZVxuZnVuY3Rpb24gY2FtbF9mc19pbml0ICgpe1xuICB2YXIgdG1wPWdsb2JhbFRoaXMuY2FtbF9mc190bXBcbiAgaWYodG1wKXtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdG1wLmxlbmd0aDsgaSsrKXtcbiAgICAgIGpzb29fY3JlYXRlX2ZpbGUodG1wW2ldLm5hbWUsdG1wW2ldLmNvbnRlbnQpO1xuICAgIH1cbiAgfVxuICBnbG9iYWxUaGlzLmpzb29fY3JlYXRlX2ZpbGUgPSBqc29vX2NyZWF0ZV9maWxlO1xuICBnbG9iYWxUaGlzLmNhbWxfZnNfdG1wID0gW107XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NyZWF0ZV9maWxlXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoLCByZXNvbHZlX2ZzX2RldmljZVxuZnVuY3Rpb24gY2FtbF9jcmVhdGVfZmlsZShuYW1lLGNvbnRlbnQpIHtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgaWYoISByb290LmRldmljZS5yZWdpc3RlcikgY2FtbF9mYWlsd2l0aChcImNhbm5vdCByZWdpc3RlciBmaWxlXCIpO1xuICByb290LmRldmljZS5yZWdpc3Rlcihyb290LnJlc3QsY29udGVudCk7XG4gIHJldHVybiAwO1xufVxuXG5cbi8vUHJvdmlkZXM6IGpzb29fY3JlYXRlX2ZpbGVcbi8vUmVxdWlyZXM6IGNhbWxfY3JlYXRlX2ZpbGUsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGpzb29fY3JlYXRlX2ZpbGUobmFtZSxjb250ZW50KSB7XG4gIHZhciBuYW1lID0gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhuYW1lKTtcbiAgdmFyIGNvbnRlbnQgPSBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKGNvbnRlbnQpO1xuICByZXR1cm4gY2FtbF9jcmVhdGVfZmlsZShuYW1lLCBjb250ZW50KTtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JlYWRfZmlsZV9jb250ZW50XG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZSwgY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUsIGNhbWxfc3RyaW5nX29mX2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzLCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3JlYWRfZmlsZV9jb250ZW50IChuYW1lKSB7XG4gIHZhciBuYW1lID0gKHR5cGVvZiBuYW1lID09IFwic3RyaW5nXCIpP2NhbWxfc3RyaW5nX29mX2pzYnl0ZXMobmFtZSk6bmFtZTtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgaWYocm9vdC5kZXZpY2UuZXhpc3RzKHJvb3QucmVzdCkpIHtcbiAgICB2YXIgZmlsZSA9IHJvb3QuZGV2aWNlLm9wZW4ocm9vdC5yZXN0LHtyZG9ubHk6MX0pO1xuICAgIHZhciBsZW4gID0gZmlsZS5sZW5ndGgoKTtcbiAgICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkobGVuKTtcbiAgICBmaWxlLnJlYWQoMCxidWYsMCxsZW4pO1xuICAgIHJldHVybiBjYW1sX3N0cmluZ19vZl9hcnJheShidWYpXG4gIH1cbiAgY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUoY2FtbF9qc2J5dGVzX29mX3N0cmluZyhuYW1lKSk7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTQgSsOpcsO0bWUgVm91aWxsb24sIEh1Z28gSGV1emFyZFxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBNbEZha2VEZXZpY2Vcbi8vUmVxdWlyZXM6IE1sRmFrZUZpbGUsIE1sRmFrZUZkLCBjYW1sX2NyZWF0ZV9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXNfZXJyb3IsIGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzLCBjYW1sX3N0cmluZ19vZl9qc3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9ieXRlc19vZl9hcnJheSwgY2FtbF9ieXRlc19vZl9zdHJpbmcsIGNhbWxfYnl0ZXNfb2ZfanNieXRlc1xuLy9SZXF1aXJlczogY2FtbF9pc19tbF9ieXRlcywgY2FtbF9pc19tbF9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfbmFtZWRfdmFsdWUsIGNhbWxfcmFpc2Vfd2l0aF9hcmdzLCBjYW1sX25hbWVkX3ZhbHVlc1xuLy9SZXF1aXJlczogbWFrZV91bml4X2Vycl9hcmdzXG5mdW5jdGlvbiBNbEZha2VEZXZpY2UgKHJvb3QsIGYpIHtcbiAgdGhpcy5jb250ZW50PXt9O1xuICB0aGlzLnJvb3QgPSByb290O1xuICB0aGlzLmxvb2t1cEZ1biA9IGY7XG59XG5NbEZha2VEZXZpY2UucHJvdG90eXBlLm5tID0gZnVuY3Rpb24obmFtZSkge1xuICByZXR1cm4gKHRoaXMucm9vdCArIG5hbWUpO1xufVxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5jcmVhdGVfZGlyX2lmX25lZWRlZCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdmFyIGNvbXAgPSBuYW1lLnNwbGl0KFwiL1wiKTtcbiAgdmFyIHJlcyA9IFwiXCI7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBjb21wLmxlbmd0aCAtIDE7IGkrKyl7XG4gICAgcmVzICs9IGNvbXBbaV0gKyBcIi9cIjtcbiAgICBpZih0aGlzLmNvbnRlbnRbcmVzXSkgY29udGludWU7XG4gICAgdGhpcy5jb250ZW50W3Jlc10gPSBTeW1ib2woXCJkaXJlY3RvcnlcIik7XG4gIH1cbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUuc2xhc2ggPSBmdW5jdGlvbihuYW1lKXtcbiAgcmV0dXJuIC9cXC8kLy50ZXN0KG5hbWUpP25hbWU6KG5hbWUgKyBcIi9cIik7XG59XG5NbEZha2VEZXZpY2UucHJvdG90eXBlLmxvb2t1cCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgaWYoIXRoaXMuY29udGVudFtuYW1lXSAmJiB0aGlzLmxvb2t1cEZ1bikge1xuICAgIHZhciByZXMgPSB0aGlzLmxvb2t1cEZ1bihjYW1sX3N0cmluZ19vZl9qc2J5dGVzKHRoaXMucm9vdCksIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMobmFtZSkpO1xuICAgIGlmKHJlcyAhPT0gMCkge1xuICAgICAgdGhpcy5jcmVhdGVfZGlyX2lmX25lZWRlZChuYW1lKTtcbiAgICAgIHRoaXMuY29udGVudFtuYW1lXT1uZXcgTWxGYWtlRmlsZShjYW1sX2J5dGVzX29mX3N0cmluZyhyZXNbMV0pKTtcbiAgICB9XG4gIH1cbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUuZXhpc3RzID0gZnVuY3Rpb24obmFtZSkge1xuICAvLyBUaGUgcm9vdCBvZiB0aGUgZGV2aWNlIGV4aXN0c1xuICBpZihuYW1lID09IFwiXCIpIHJldHVybiAxO1xuICAvLyBDaGVjayBpZiBhIGRpcmVjdG9yeSBleGlzdHNcbiAgdmFyIG5hbWVfc2xhc2ggPSB0aGlzLnNsYXNoKG5hbWUpO1xuICBpZih0aGlzLmNvbnRlbnRbbmFtZV9zbGFzaF0pIHJldHVybiAxO1xuICAvLyBDaGVjayBpZiBhIGZpbGUgZXhpc3RzXG4gIHRoaXMubG9va3VwKG5hbWUpO1xuICByZXR1cm4gdGhpcy5jb250ZW50W25hbWVdPzE6MDtcbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUuaXNGaWxlID0gZnVuY3Rpb24obmFtZSkge1xuICBpZih0aGlzLmV4aXN0cyhuYW1lKSAmJiAhdGhpcy5pc19kaXIobmFtZSkpIHtcbiAgICByZXR1cm4gMVxuICB9XG4gIGVsc2Uge1xuICAgIHJldHVybiAwXG4gIH1cbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUubWtkaXIgPSBmdW5jdGlvbihuYW1lLG1vZGUsIHJhaXNlX3VuaXgpIHtcbiAgdmFyIHVuaXhfZXJyb3IgPSByYWlzZV91bml4ICYmIGNhbWxfbmFtZWRfdmFsdWUoJ1VuaXguVW5peF9lcnJvcicpO1xuICBpZih0aGlzLmV4aXN0cyhuYW1lKSkge1xuICAgIGlmICh1bml4X2Vycm9yKSB7XG4gICAgICBjYW1sX3JhaXNlX3dpdGhfYXJncyh1bml4X2Vycm9yLCBtYWtlX3VuaXhfZXJyX2FyZ3MoXCJFRVhJU1RcIiwgXCJta2RpclwiLCB0aGlzLm5tKG5hbWUpKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IobmFtZSArIFwiOiBGaWxlIGV4aXN0c1wiKTtcbiAgICB9XG4gIH1cbiAgdmFyIHBhcmVudCA9IC9eKC4qKVxcL1teL10rLy5leGVjKG5hbWUpO1xuICBwYXJlbnQgPSAocGFyZW50ICYmIHBhcmVudFsxXSkgfHwgJyc7XG4gIGlmKCF0aGlzLmV4aXN0cyhwYXJlbnQpKXtcbiAgICBpZiAodW5peF9lcnJvcikge1xuICAgICAgY2FtbF9yYWlzZV93aXRoX2FyZ3ModW5peF9lcnJvciwgbWFrZV91bml4X2Vycl9hcmdzKFwiRU5PRU5UXCIsIFwibWtkaXJcIiwgdGhpcy5ubShwYXJlbnQpKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IocGFyZW50ICsgXCI6IE5vIHN1Y2ggZmlsZSBvciBkaXJlY3RvcnlcIik7XG4gICAgfVxuICB9XG4gIGlmKCF0aGlzLmlzX2RpcihwYXJlbnQpKXtcbiAgICBpZiAodW5peF9lcnJvcikge1xuICAgICAgY2FtbF9yYWlzZV93aXRoX2FyZ3ModW5peF9lcnJvciwgbWFrZV91bml4X2Vycl9hcmdzKFwiRU5PVERJUlwiLCBcIm1rZGlyXCIsIHRoaXMubm0ocGFyZW50KSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHBhcmVudCArIFwiOiBOb3QgYSBkaXJlY3RvcnlcIik7XG4gICAgfVxuICB9XG4gIHRoaXMuY3JlYXRlX2Rpcl9pZl9uZWVkZWQodGhpcy5zbGFzaChuYW1lKSk7XG59XG5NbEZha2VEZXZpY2UucHJvdG90eXBlLnJtZGlyID0gZnVuY3Rpb24obmFtZSwgcmFpc2VfdW5peCkge1xuICB2YXIgdW5peF9lcnJvciA9IHJhaXNlX3VuaXggJiYgY2FtbF9uYW1lZF92YWx1ZSgnVW5peC5Vbml4X2Vycm9yJyk7XG4gIHZhciBuYW1lX3NsYXNoID0gKG5hbWUgPT0gXCJcIik/XCJcIjoodGhpcy5zbGFzaChuYW1lKSk7XG4gIHZhciByID0gbmV3IFJlZ0V4cChcIl5cIiArIG5hbWVfc2xhc2ggKyBcIihbXi9dKylcIik7XG4gIGlmKCF0aGlzLmV4aXN0cyhuYW1lKSkge1xuICAgIGlmICh1bml4X2Vycm9yKSB7XG4gICAgICBjYW1sX3JhaXNlX3dpdGhfYXJncyh1bml4X2Vycm9yLCBtYWtlX3VuaXhfZXJyX2FyZ3MoXCJFTk9FTlRcIiwgXCJybWRpclwiLCB0aGlzLm5tKG5hbWUpKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IobmFtZSArIFwiOiBObyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5XCIpO1xuICAgIH1cbiAgfVxuICBpZighdGhpcy5pc19kaXIobmFtZSkpIHtcbiAgICBpZiAodW5peF9lcnJvcikge1xuICAgICAgY2FtbF9yYWlzZV93aXRoX2FyZ3ModW5peF9lcnJvciwgbWFrZV91bml4X2Vycl9hcmdzKFwiRU5PVERJUlwiLCBcInJtZGlyXCIsIHRoaXMubm0obmFtZSkpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihuYW1lICsgXCI6IE5vdCBhIGRpcmVjdG9yeVwiKTtcbiAgICB9XG4gIH1cbiAgZm9yKHZhciBuIGluIHRoaXMuY29udGVudCkge1xuICAgIGlmKG4ubWF0Y2gocikpIHtcbiAgICAgIGlmICh1bml4X2Vycm9yKSB7XG4gICAgICAgIGNhbWxfcmFpc2Vfd2l0aF9hcmdzKHVuaXhfZXJyb3IsIG1ha2VfdW5peF9lcnJfYXJncyhcIkVOT1RFTVBUWVwiLCBcInJtZGlyXCIsIHRoaXMubm0obmFtZSkpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHRoaXMubm0obmFtZSkgKyBcIjogRGlyZWN0b3J5IG5vdCBlbXB0eVwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZGVsZXRlIHRoaXMuY29udGVudFtuYW1lX3NsYXNoXTtcbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUucmVhZGRpciA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdmFyIG5hbWVfc2xhc2ggPSAobmFtZSA9PSBcIlwiKT9cIlwiOih0aGlzLnNsYXNoKG5hbWUpKTtcbiAgaWYoIXRoaXMuZXhpc3RzKG5hbWUpKSB7XG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IobmFtZSArIFwiOiBObyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5XCIpO1xuICB9XG4gIGlmKCF0aGlzLmlzX2RpcihuYW1lKSkge1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKG5hbWUgKyBcIjogTm90IGEgZGlyZWN0b3J5XCIpO1xuICB9XG4gIHZhciByID0gbmV3IFJlZ0V4cChcIl5cIiArIG5hbWVfc2xhc2ggKyBcIihbXi9dKylcIik7XG4gIHZhciBzZWVuID0ge31cbiAgdmFyIGEgPSBbXTtcbiAgZm9yKHZhciBuIGluIHRoaXMuY29udGVudCkge1xuICAgIHZhciBtID0gbi5tYXRjaChyKTtcbiAgICBpZihtICYmICFzZWVuW21bMV1dKSB7c2VlblttWzFdXSA9IHRydWU7IGEucHVzaChtWzFdKX1cbiAgfVxuICByZXR1cm4gYTtcbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUub3BlbmRpciA9IGZ1bmN0aW9uKG5hbWUsIHJhaXNlX3VuaXgpIHtcbiAgdmFyIHVuaXhfZXJyb3IgPSByYWlzZV91bml4ICYmIGNhbWxfbmFtZWRfdmFsdWUoJ1VuaXguVW5peF9lcnJvcicpO1xuXG4gIHZhciBhID0gdGhpcy5yZWFkZGlyKG5hbWUpO1xuICB2YXIgYyA9IGZhbHNlO1xuICB2YXIgaSA9IDA7XG4gIHJldHVybiB7IHJlYWRTeW5jIDogKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoYykge1xuICAgICAgaWYgKHVuaXhfZXJyb3IpIHtcbiAgICAgICAgY2FtbF9yYWlzZV93aXRoX2FyZ3ModW5peF9lcnJvciwgbWFrZV91bml4X2Vycl9hcmdzKFwiRUJBREZcIiwgXCJjbG9zZWRpclwiLCB0aGlzLm5tKG5hbWUpKSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IobmFtZSArIFwiOiBjbG9zZWRpciBmYWlsZWRcIik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmKGkgPT0gYS5sZW5ndGgpIHJldHVybiBudWxsO1xuICAgIHZhciBlbnRyeSA9IGFbaV07XG4gICAgaSsrO1xuICAgIHJldHVybiB7IG5hbWU6IGVudHJ5IH1cbiAgfSlcbiAgICAsIGNsb3NlU3luYzogKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChjKSB7XG4gICAgICAgIGlmICh1bml4X2Vycm9yKSB7XG4gICAgICAgICAgY2FtbF9yYWlzZV93aXRoX2FyZ3ModW5peF9lcnJvciwgbWFrZV91bml4X2Vycl9hcmdzKFwiRUJBREZcIiwgXCJjbG9zZWRpclwiLCB0aGlzLm5tKG5hbWUpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IobmFtZSArIFwiOiBjbG9zZWRpciBmYWlsZWRcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGMgPSB0cnVlO1xuICAgICAgYSA9IFtdO1xuICAgIH0pXG4gIH1cbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUuaXNfZGlyID0gZnVuY3Rpb24obmFtZSkge1xuICBpZihuYW1lID09IFwiXCIpICByZXR1cm4gdHJ1ZTtcbiAgdmFyIG5hbWVfc2xhc2ggPSB0aGlzLnNsYXNoKG5hbWUpO1xuICByZXR1cm4gdGhpcy5jb250ZW50W25hbWVfc2xhc2hdPzE6MDtcbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUudW5saW5rID0gZnVuY3Rpb24obmFtZSkge1xuICB2YXIgb2sgPSB0aGlzLmNvbnRlbnRbbmFtZV0/dHJ1ZTpmYWxzZTtcbiAgZGVsZXRlIHRoaXMuY29udGVudFtuYW1lXTtcbiAgcmV0dXJuIG9rO1xufVxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24obmFtZSwgZikge1xuICB2YXIgZmlsZTtcbiAgaWYoZi5yZG9ubHkgJiYgZi53cm9ubHkpXG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IodGhpcy5ubShuYW1lKSArIFwiIDogZmxhZ3MgT3Blbl9yZG9ubHkgYW5kIE9wZW5fd3Jvbmx5IGFyZSBub3QgY29tcGF0aWJsZVwiKTtcbiAgaWYoZi50ZXh0ICYmIGYuYmluYXJ5KVxuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHRoaXMubm0obmFtZSkgKyBcIiA6IGZsYWdzIE9wZW5fdGV4dCBhbmQgT3Blbl9iaW5hcnkgYXJlIG5vdCBjb21wYXRpYmxlXCIpO1xuICB0aGlzLmxvb2t1cChuYW1lKTtcbiAgaWYgKHRoaXMuY29udGVudFtuYW1lXSkge1xuICAgIGlmICh0aGlzLmlzX2RpcihuYW1lKSkgY2FtbF9yYWlzZV9zeXNfZXJyb3IodGhpcy5ubShuYW1lKSArIFwiIDogaXMgYSBkaXJlY3RvcnlcIik7XG4gICAgaWYgKGYuY3JlYXRlICYmIGYuZXhjbCkgY2FtbF9yYWlzZV9zeXNfZXJyb3IodGhpcy5ubShuYW1lKSArIFwiIDogZmlsZSBhbHJlYWR5IGV4aXN0c1wiKTtcbiAgICBmaWxlID0gdGhpcy5jb250ZW50W25hbWVdO1xuICAgIGlmKGYudHJ1bmNhdGUpIGZpbGUudHJ1bmNhdGUoKTtcbiAgfSBlbHNlIGlmIChmLmNyZWF0ZSkge1xuICAgIHRoaXMuY3JlYXRlX2Rpcl9pZl9uZWVkZWQobmFtZSk7XG4gICAgdGhpcy5jb250ZW50W25hbWVdID0gbmV3IE1sRmFrZUZpbGUoY2FtbF9jcmVhdGVfYnl0ZXMoMCkpO1xuICAgIGZpbGUgPSB0aGlzLmNvbnRlbnRbbmFtZV07XG4gIH0gZWxzZSB7XG4gICAgY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUgKHRoaXMubm0obmFtZSkpO1xuICB9XG4gIHJldHVybiBuZXcgTWxGYWtlRmQodGhpcy5ubShuYW1lKSwgZmlsZSwgZik7XG59XG5cbk1sRmFrZURldmljZS5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uKG5hbWUsIGYpIHtcbiAgdmFyIGZpbGU7XG4gIGlmKGYucmRvbmx5ICYmIGYud3Jvbmx5KVxuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHRoaXMubm0obmFtZSkgKyBcIiA6IGZsYWdzIE9wZW5fcmRvbmx5IGFuZCBPcGVuX3dyb25seSBhcmUgbm90IGNvbXBhdGlibGVcIik7XG4gIGlmKGYudGV4dCAmJiBmLmJpbmFyeSlcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcih0aGlzLm5tKG5hbWUpICsgXCIgOiBmbGFncyBPcGVuX3RleHQgYW5kIE9wZW5fYmluYXJ5IGFyZSBub3QgY29tcGF0aWJsZVwiKTtcbiAgdGhpcy5sb29rdXAobmFtZSk7XG4gIGlmICh0aGlzLmNvbnRlbnRbbmFtZV0pIHtcbiAgICBpZiAodGhpcy5pc19kaXIobmFtZSkpIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHRoaXMubm0obmFtZSkgKyBcIiA6IGlzIGEgZGlyZWN0b3J5XCIpO1xuICAgIGlmIChmLmNyZWF0ZSAmJiBmLmV4Y2wpIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHRoaXMubm0obmFtZSkgKyBcIiA6IGZpbGUgYWxyZWFkeSBleGlzdHNcIik7XG4gICAgZmlsZSA9IHRoaXMuY29udGVudFtuYW1lXTtcbiAgICBpZihmLnRydW5jYXRlKSBmaWxlLnRydW5jYXRlKCk7XG4gIH0gZWxzZSBpZiAoZi5jcmVhdGUpIHtcbiAgICB0aGlzLmNyZWF0ZV9kaXJfaWZfbmVlZGVkKG5hbWUpO1xuICAgIHRoaXMuY29udGVudFtuYW1lXSA9IG5ldyBNbEZha2VGaWxlKGNhbWxfY3JlYXRlX2J5dGVzKDApKTtcbiAgICBmaWxlID0gdGhpcy5jb250ZW50W25hbWVdO1xuICB9IGVsc2Uge1xuICAgIGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlICh0aGlzLm5tKG5hbWUpKTtcbiAgfVxuICByZXR1cm4gbmV3IE1sRmFrZUZkKHRoaXMubm0obmFtZSksIGZpbGUsIGYpO1xufVxuXG5NbEZha2VEZXZpY2UucHJvdG90eXBlLnJlZ2lzdGVyPSBmdW5jdGlvbiAobmFtZSxjb250ZW50KXtcbiAgdmFyIGZpbGU7XG4gIGlmKHRoaXMuY29udGVudFtuYW1lXSkgY2FtbF9yYWlzZV9zeXNfZXJyb3IodGhpcy5ubShuYW1lKSArIFwiIDogZmlsZSBhbHJlYWR5IGV4aXN0c1wiKTtcbiAgaWYoY2FtbF9pc19tbF9ieXRlcyhjb250ZW50KSlcbiAgICBmaWxlID0gbmV3IE1sRmFrZUZpbGUoY29udGVudCk7XG4gIGlmKGNhbWxfaXNfbWxfc3RyaW5nKGNvbnRlbnQpKVxuICAgIGZpbGUgPSBuZXcgTWxGYWtlRmlsZShjYW1sX2J5dGVzX29mX3N0cmluZyhjb250ZW50KSk7XG4gIGVsc2UgaWYoY29udGVudCBpbnN0YW5jZW9mIEFycmF5KVxuICAgIGZpbGUgPSBuZXcgTWxGYWtlRmlsZShjYW1sX2J5dGVzX29mX2FycmF5KGNvbnRlbnQpKTtcbiAgZWxzZSBpZih0eXBlb2YgY29udGVudCA9PT0gXCJzdHJpbmdcIilcbiAgICBmaWxlID0gbmV3IE1sRmFrZUZpbGUoY2FtbF9ieXRlc19vZl9qc2J5dGVzKGNvbnRlbnQpKTtcbiAgZWxzZSBpZihjb250ZW50LnRvU3RyaW5nKSB7XG4gICAgdmFyIGJ5dGVzID0gY2FtbF9ieXRlc19vZl9zdHJpbmcoY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcoY29udGVudC50b1N0cmluZygpKSk7XG4gICAgZmlsZSA9IG5ldyBNbEZha2VGaWxlKGJ5dGVzKTtcbiAgfVxuICBpZihmaWxlKXtcbiAgICB0aGlzLmNyZWF0ZV9kaXJfaWZfbmVlZGVkKG5hbWUpO1xuICAgIHRoaXMuY29udGVudFtuYW1lXSA9IGZpbGU7XG4gIH1cbiAgZWxzZSBjYW1sX3JhaXNlX3N5c19lcnJvcih0aGlzLm5tKG5hbWUpICsgXCIgOiByZWdpc3RlcmluZyBmaWxlIHdpdGggaW52YWxpZCBjb250ZW50IHR5cGVcIik7XG59XG5cbk1sRmFrZURldmljZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNbEZha2VEZXZpY2VcblxuLy9Qcm92aWRlczogTWxGYWtlRmlsZVxuLy9SZXF1aXJlczogTWxGaWxlXG4vL1JlcXVpcmVzOiBjYW1sX2NyZWF0ZV9ieXRlcywgY2FtbF9tbF9ieXRlc19sZW5ndGgsIGNhbWxfYmxpdF9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF91aW50OF9hcnJheV9vZl9ieXRlcywgY2FtbF9ieXRlc19vZl9hcnJheVxuZnVuY3Rpb24gTWxGYWtlRmlsZShjb250ZW50KXtcbiAgdGhpcy5kYXRhID0gY29udGVudDtcbn1cbk1sRmFrZUZpbGUucHJvdG90eXBlID0gbmV3IE1sRmlsZSAoKTtcbk1sRmFrZUZpbGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWxGYWtlRmlsZVxuTWxGYWtlRmlsZS5wcm90b3R5cGUudHJ1bmNhdGUgPSBmdW5jdGlvbihsZW4pe1xuICB2YXIgb2xkID0gdGhpcy5kYXRhO1xuICB0aGlzLmRhdGEgPSBjYW1sX2NyZWF0ZV9ieXRlcyhsZW58MCk7XG4gIGNhbWxfYmxpdF9ieXRlcyhvbGQsIDAsIHRoaXMuZGF0YSwgMCwgbGVuKTtcbn1cbk1sRmFrZUZpbGUucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGNhbWxfbWxfYnl0ZXNfbGVuZ3RoKHRoaXMuZGF0YSk7XG59XG5NbEZha2VGaWxlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKG9mZnNldCxidWYscG9zLGxlbil7XG4gIHZhciBjbGVuID0gdGhpcy5sZW5ndGgoKTtcbiAgaWYob2Zmc2V0ICsgbGVuID49IGNsZW4pIHtcbiAgICB2YXIgbmV3X3N0ciA9IGNhbWxfY3JlYXRlX2J5dGVzKG9mZnNldCArIGxlbik7XG4gICAgdmFyIG9sZF9kYXRhID0gdGhpcy5kYXRhO1xuICAgIHRoaXMuZGF0YSA9IG5ld19zdHI7XG4gICAgY2FtbF9ibGl0X2J5dGVzKG9sZF9kYXRhLCAwLCB0aGlzLmRhdGEsIDAsIGNsZW4pO1xuICB9XG4gIGNhbWxfYmxpdF9ieXRlcyhjYW1sX2J5dGVzX29mX2FycmF5KGJ1ZiksIHBvcywgdGhpcy5kYXRhLCBvZmZzZXQsIGxlbik7XG4gIHJldHVybiAwXG59XG5NbEZha2VGaWxlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24ob2Zmc2V0LGJ1Zixwb3MsbGVuKXtcbiAgdmFyIGNsZW4gPSB0aGlzLmxlbmd0aCgpO1xuICBpZihvZmZzZXQgKyBsZW4gPj0gY2xlbikge1xuICAgIGxlbiA9IGNsZW4gLSBvZmZzZXQ7XG4gIH1cbiAgaWYobGVuKSB7XG4gICAgdmFyIGRhdGEgPSBjYW1sX2NyZWF0ZV9ieXRlcyhsZW58MCk7XG4gICAgY2FtbF9ibGl0X2J5dGVzKHRoaXMuZGF0YSwgb2Zmc2V0LCBkYXRhLCAwLCBsZW4pO1xuICAgIGJ1Zi5zZXQoY2FtbF91aW50OF9hcnJheV9vZl9ieXRlcyhkYXRhKSwgcG9zKTtcbiAgfVxuICByZXR1cm4gbGVuXG59XG5cblxuLy9Qcm92aWRlczogTWxGYWtlRmRfb3V0XG4vL1JlcXVpcmVzOiBNbEZha2VGaWxlLCBjYW1sX2NyZWF0ZV9ieXRlcywgY2FtbF9ibGl0X2J5dGVzLCBjYW1sX2J5dGVzX29mX2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3N5c19lcnJvclxuZnVuY3Rpb24gTWxGYWtlRmRfb3V0KGZkLGZsYWdzKSB7XG4gIE1sRmFrZUZpbGUuY2FsbCh0aGlzLCBjYW1sX2NyZWF0ZV9ieXRlcygwKSk7XG4gIHRoaXMubG9nID0gKGZ1bmN0aW9uIChzKSB7IHJldHVybiAwIH0pO1xuICBpZihmZCA9PSAxICYmIHR5cGVvZiBjb25zb2xlLmxvZyA9PSBcImZ1bmN0aW9uXCIpXG4gICAgdGhpcy5sb2cgPSBjb25zb2xlLmxvZztcbiAgZWxzZSBpZihmZCA9PSAyICYmIHR5cGVvZiBjb25zb2xlLmVycm9yID09IFwiZnVuY3Rpb25cIilcbiAgICB0aGlzLmxvZyA9IGNvbnNvbGUuZXJyb3I7XG4gIGVsc2UgaWYodHlwZW9mIGNvbnNvbGUubG9nID09IFwiZnVuY3Rpb25cIilcbiAgICB0aGlzLmxvZyA9IGNvbnNvbGUubG9nXG4gIHRoaXMuZmxhZ3MgPSBmbGFncztcbn1cbk1sRmFrZUZkX291dC5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24oKSB7IHJldHVybiAwIH1cbk1sRmFrZUZkX291dC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAob2Zmc2V0LGJ1Zixwb3MsbGVuKSB7XG4gIGlmKHRoaXMubG9nKSB7XG4gICAgaWYobGVuID4gMFxuICAgICAgICYmIHBvcyA+PSAwXG4gICAgICAgJiYgcG9zK2xlbiA8PSBidWYubGVuZ3RoXG4gICAgICAgJiYgYnVmW3BvcytsZW4tMV0gPT0gMTApXG4gICAgICBsZW4gLS07XG4gICAgLy8gRG8gbm90IG91dHB1dCB0aGUgbGFzdCBcXG4gaWYgcHJlc2VudFxuICAgIC8vIGFzIGNvbnNvbGUgbG9nZ2luZyBkaXNwbGF5IGEgbmV3bGluZSBhdCB0aGUgZW5kXG4gICAgdmFyIHNyYyA9IGNhbWxfY3JlYXRlX2J5dGVzKGxlbik7XG4gICAgY2FtbF9ibGl0X2J5dGVzKGNhbWxfYnl0ZXNfb2ZfYXJyYXkoYnVmKSwgcG9zLCBzcmMsIDAsIGxlbik7XG4gICAgdGhpcy5sb2coc3JjLnRvVXRmMTYoKSk7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgY2FtbF9yYWlzZV9zeXNfZXJyb3IodGhpcy5mZCAgKyBcIjogZmlsZSBkZXNjcmlwdG9yIGFscmVhZHkgY2xvc2VkXCIpO1xufVxuTWxGYWtlRmRfb3V0LnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKG9mZnNldCwgYnVmLCBwb3MsIGxlbikge1xuICBjYW1sX3JhaXNlX3N5c19lcnJvcih0aGlzLmZkICArIFwiOiBmaWxlIGRlc2NyaXB0b3IgaXMgd3JpdGUgb25seVwiKTtcbn1cbk1sRmFrZUZkX291dC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMubG9nID0gdW5kZWZpbmVkO1xufVxuXG5cbi8vUHJvdmlkZXM6IE1sRmFrZUZkXG4vL1JlcXVpcmVzOiBNbEZha2VGaWxlXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3N5c19lcnJvclxuZnVuY3Rpb24gTWxGYWtlRmQobmFtZSwgZmlsZSxmbGFncykge1xuICB0aGlzLmZpbGUgPSBmaWxlO1xuICB0aGlzLm5hbWUgPSBuYW1lO1xuICB0aGlzLmZsYWdzID0gZmxhZ3M7XG59XG5cbk1sRmFrZUZkLnByb3RvdHlwZS5lcnJfY2xvc2VkID0gZnVuY3Rpb24gKCkge1xuICBjYW1sX3JhaXNlX3N5c19lcnJvcih0aGlzLm5hbWUgICsgXCI6IGZpbGUgZGVzY3JpcHRvciBhbHJlYWR5IGNsb3NlZFwiKTtcbn1cbk1sRmFrZUZkLnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbigpIHtcbiAgaWYodGhpcy5maWxlKSByZXR1cm4gdGhpcy5maWxlLmxlbmd0aCAoKVxuICB0aGlzLmVycl9jbG9zZWQoKTtcbn1cbk1sRmFrZUZkLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChvZmZzZXQsYnVmLHBvcyxsZW4pIHtcbiAgaWYodGhpcy5maWxlKSByZXR1cm4gdGhpcy5maWxlLndyaXRlKG9mZnNldCxidWYscG9zLGxlbilcbiAgdGhpcy5lcnJfY2xvc2VkKCk7XG59XG5NbEZha2VGZC5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIChvZmZzZXQsIGJ1ZiwgcG9zLCBsZW4pIHtcbiAgaWYodGhpcy5maWxlKSByZXR1cm4gdGhpcy5maWxlLnJlYWQob2Zmc2V0LCBidWYsIHBvcywgbGVuKVxuICB0aGlzLmVycl9jbG9zZWQoKTtcbn1cbk1sRmFrZUZkLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5maWxlID0gdW5kZWZpbmVkO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwIErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfb2Zmc2V0XG52YXIgY2FtbF9pbnQ2NF9vZmZzZXQgPSBNYXRoLnBvdygyLCAtMjQpO1xuXG4vL1Byb3ZpZGVzOiBNbEludDY0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mZnNldCwgY2FtbF9yYWlzZV96ZXJvX2RpdmlkZVxuZnVuY3Rpb24gTWxJbnQ2NCAobG8sbWksaGkpIHtcbiAgdGhpcy5sbyA9IGxvICYgMHhmZmZmZmY7XG4gIHRoaXMubWkgPSBtaSAmIDB4ZmZmZmZmO1xuICB0aGlzLmhpID0gaGkgJiAweGZmZmY7XG59XG5NbEludDY0LnByb3RvdHlwZS5jYW1sX2N1c3RvbSA9IFwiX2pcIlxuTWxJbnQ2NC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG5ldyBNbEludDY0KHRoaXMubG8sdGhpcy5taSx0aGlzLmhpKTtcbn1cblxuTWxJbnQ2NC5wcm90b3R5cGUudWNvbXBhcmUgPSBmdW5jdGlvbiAoeCkge1xuICBpZiAodGhpcy5oaSA+IHguaGkpIHJldHVybiAxO1xuICBpZiAodGhpcy5oaSA8IHguaGkpIHJldHVybiAtMTtcbiAgaWYgKHRoaXMubWkgPiB4Lm1pKSByZXR1cm4gMTtcbiAgaWYgKHRoaXMubWkgPCB4Lm1pKSByZXR1cm4gLTE7XG4gIGlmICh0aGlzLmxvID4geC5sbykgcmV0dXJuIDE7XG4gIGlmICh0aGlzLmxvIDwgeC5sbykgcmV0dXJuIC0xO1xuICByZXR1cm4gMDtcbn1cbk1sSW50NjQucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiAoeCkge1xuICB2YXIgaGkgPSB0aGlzLmhpIDw8IDE2O1xuICB2YXIgeGhpID0geC5oaSA8PCAxNjtcbiAgaWYgKGhpID4geGhpKSByZXR1cm4gMTtcbiAgaWYgKGhpIDwgeGhpKSByZXR1cm4gLTE7XG4gIGlmICh0aGlzLm1pID4geC5taSkgcmV0dXJuIDE7XG4gIGlmICh0aGlzLm1pIDwgeC5taSkgcmV0dXJuIC0xO1xuICBpZiAodGhpcy5sbyA+IHgubG8pIHJldHVybiAxO1xuICBpZiAodGhpcy5sbyA8IHgubG8pIHJldHVybiAtMTtcbiAgcmV0dXJuIDA7XG59XG5NbEludDY0LnByb3RvdHlwZS5uZWcgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBsbyA9IC0gdGhpcy5sbztcbiAgdmFyIG1pID0gLSB0aGlzLm1pICsgKGxvID4+IDI0KTtcbiAgdmFyIGhpID0gLSB0aGlzLmhpICsgKG1pID4+IDI0KTtcbiAgcmV0dXJuIG5ldyBNbEludDY0KGxvLCBtaSwgaGkpO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHgpIHtcbiAgdmFyIGxvID0gdGhpcy5sbyArIHgubG87XG4gIHZhciBtaSA9IHRoaXMubWkgKyB4Lm1pICsgKGxvID4+IDI0KTtcbiAgdmFyIGhpID0gdGhpcy5oaSArIHguaGkgKyAobWkgPj4gMjQpO1xuICByZXR1cm4gbmV3IE1sSW50NjQobG8sIG1pLCBoaSk7XG59XG5NbEludDY0LnByb3RvdHlwZS5zdWIgPSBmdW5jdGlvbiAoeCkge1xuICB2YXIgbG8gPSB0aGlzLmxvIC0geC5sbztcbiAgdmFyIG1pID0gdGhpcy5taSAtIHgubWkgKyAobG8gPj4gMjQpO1xuICB2YXIgaGkgPSB0aGlzLmhpIC0geC5oaSArIChtaSA+PiAyNCk7XG4gIHJldHVybiBuZXcgTWxJbnQ2NChsbywgbWksIGhpKTtcbn1cbk1sSW50NjQucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uICh4KSB7XG4gIHZhciBsbyA9IHRoaXMubG8gKiB4LmxvO1xuICB2YXIgbWkgPSAoKGxvICogY2FtbF9pbnQ2NF9vZmZzZXQpIHwgMCkgKyB0aGlzLm1pICogeC5sbyArIHRoaXMubG8gKiB4Lm1pO1xuICB2YXIgaGkgPSAoKG1pICogY2FtbF9pbnQ2NF9vZmZzZXQpIHwgMCkgKyB0aGlzLmhpICogeC5sbyArIHRoaXMubWkgKiB4Lm1pICsgdGhpcy5sbyAqIHguaGk7XG4gIHJldHVybiBuZXcgTWxJbnQ2NChsbywgbWksIGhpKTtcbn1cbk1sSW50NjQucHJvdG90eXBlLmlzWmVybyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICh0aGlzLmxvfHRoaXMubWl8dGhpcy5oaSkgPT0gMDtcbn1cbk1sSW50NjQucHJvdG90eXBlLmlzTmVnID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gKHRoaXMuaGkgPDwgMTYpIDwgMDtcbn1cbk1sSW50NjQucHJvdG90eXBlLmFuZCA9IGZ1bmN0aW9uICh4KSB7XG4gIHJldHVybiBuZXcgTWxJbnQ2NCh0aGlzLmxvICYgeC5sbywgdGhpcy5taSAmIHgubWksIHRoaXMuaGkgJiB4LmhpKTtcbn1cbk1sSW50NjQucHJvdG90eXBlLm9yID0gZnVuY3Rpb24gKHgpIHtcbiAgcmV0dXJuIG5ldyBNbEludDY0KHRoaXMubG98eC5sbywgdGhpcy5taXx4Lm1pLCB0aGlzLmhpfHguaGkpO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUueG9yID0gZnVuY3Rpb24gKHgpIHtcbiAgcmV0dXJuIG5ldyBNbEludDY0KHRoaXMubG9eeC5sbywgdGhpcy5taV54Lm1pLCB0aGlzLmhpXnguaGkpO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUuc2hpZnRfbGVmdCA9IGZ1bmN0aW9uIChzKSB7XG4gIHMgPSBzICYgNjM7XG4gIGlmIChzID09IDApIHJldHVybiB0aGlzO1xuICBpZiAocyA8IDI0KSB7XG4gICAgcmV0dXJuIG5ldyBNbEludDY0ICh0aGlzLmxvIDw8IHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAodGhpcy5taSA8PCBzKSB8ICh0aGlzLmxvID4+ICgyNCAtIHMpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzLmhpIDw8IHMpIHwgKHRoaXMubWkgPj4gKDI0IC0gcykpKTtcbiAgfVxuICBpZiAocyA8IDQ4KVxuICAgIHJldHVybiBuZXcgTWxJbnQ2NCAoMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG8gPDwgKHMgLSAyNCksXG4gICAgICAgICAgICAgICAgICAgICAgICAodGhpcy5taSA8PCAocyAtIDI0KSkgfCAodGhpcy5sbyA+PiAoNDggLSBzKSkpO1xuICByZXR1cm4gbmV3IE1sSW50NjQoMCwgMCwgdGhpcy5sbyA8PCAocyAtIDQ4KSlcbn1cbk1sSW50NjQucHJvdG90eXBlLnNoaWZ0X3JpZ2h0X3Vuc2lnbmVkID0gZnVuY3Rpb24gKHMpIHtcbiAgcyA9IHMgJiA2MztcbiAgaWYgKHMgPT0gMCkgcmV0dXJuIHRoaXM7XG4gIGlmIChzIDwgMjQpXG4gICAgcmV0dXJuIG5ldyBNbEludDY0IChcbiAgICAgICh0aGlzLmxvID4+IHMpIHwgKHRoaXMubWkgPDwgKDI0IC0gcykpLFxuICAgICAgKHRoaXMubWkgPj4gcykgfCAodGhpcy5oaSA8PCAoMjQgLSBzKSksXG4gICAgICAodGhpcy5oaSA+PiBzKSk7XG4gIGlmIChzIDwgNDgpXG4gICAgcmV0dXJuIG5ldyBNbEludDY0IChcbiAgICAgICh0aGlzLm1pID4+IChzIC0gMjQpKSB8ICh0aGlzLmhpIDw8ICg0OCAtIHMpKSxcbiAgICAgICh0aGlzLmhpID4+IChzIC0gMjQpKSxcbiAgICAgIDApO1xuICByZXR1cm4gbmV3IE1sSW50NjQgKHRoaXMuaGkgPj4gKHMgLSA0OCksIDAsIDApO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUuc2hpZnRfcmlnaHQgPSBmdW5jdGlvbiAocykge1xuICBzID0gcyAmIDYzO1xuICBpZiAocyA9PSAwKSByZXR1cm4gdGhpcztcbiAgdmFyIGggPSAodGhpcy5oaSA8PCAxNikgPj4gMTY7XG4gIGlmIChzIDwgMjQpXG4gICAgcmV0dXJuIG5ldyBNbEludDY0IChcbiAgICAgICh0aGlzLmxvID4+IHMpIHwgKHRoaXMubWkgPDwgKDI0IC0gcykpLFxuICAgICAgKHRoaXMubWkgPj4gcykgfCAoaCA8PCAoMjQgLSBzKSksXG4gICAgICAoKHRoaXMuaGkgPDwgMTYpID4+IHMpID4+PiAxNik7XG4gIHZhciBzaWduID0gKHRoaXMuaGkgPDwgMTYpID4+IDMxO1xuICBpZiAocyA8IDQ4KVxuICAgIHJldHVybiBuZXcgTWxJbnQ2NCAoXG4gICAgICAodGhpcy5taSA+PiAocyAtIDI0KSkgfCAodGhpcy5oaSA8PCAoNDggLSBzKSksXG4gICAgICAodGhpcy5oaSA8PCAxNikgPj4gKHMgLSAyNCkgPj4gMTYsXG4gICAgICBzaWduICYgMHhmZmZmKTtcbiAgcmV0dXJuIG5ldyBNbEludDY0ICgodGhpcy5oaSA8PCAxNikgPj4gKHMgLSAzMiksIHNpZ24sIHNpZ24pO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUubHNsMSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5oaSA9ICh0aGlzLmhpIDw8IDEpIHwgKHRoaXMubWkgPj4gMjMpO1xuICB0aGlzLm1pID0gKCh0aGlzLm1pIDw8IDEpIHwgKHRoaXMubG8gPj4gMjMpKSAmIDB4ZmZmZmZmO1xuICB0aGlzLmxvID0gKHRoaXMubG8gPDwgMSkgJiAweGZmZmZmZjtcbn1cbk1sSW50NjQucHJvdG90eXBlLmxzcjEgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMubG8gPSAoKHRoaXMubG8gPj4+IDEpIHwgKHRoaXMubWkgPDwgMjMpKSAmIDB4ZmZmZmZmO1xuICB0aGlzLm1pID0gKCh0aGlzLm1pID4+PiAxKSB8ICh0aGlzLmhpIDw8IDIzKSkgJiAweGZmZmZmZjtcbiAgdGhpcy5oaSA9IHRoaXMuaGkgPj4+IDE7XG59XG5NbEludDY0LnByb3RvdHlwZS51ZGl2bW9kID0gZnVuY3Rpb24gKHgpIHtcbiAgdmFyIG9mZnNldCA9IDA7XG4gIHZhciBtb2R1bHVzID0gdGhpcy5jb3B5KCk7XG4gIHZhciBkaXZpc29yID0geC5jb3B5KCk7XG4gIHZhciBxdW90aWVudCA9IG5ldyBNbEludDY0KDAsMCwwKTtcbiAgd2hpbGUgKG1vZHVsdXMudWNvbXBhcmUoZGl2aXNvcikgPiAwKSB7XG4gICAgb2Zmc2V0Kys7XG4gICAgZGl2aXNvci5sc2wxKCk7XG4gIH1cbiAgd2hpbGUgKG9mZnNldCA+PSAwKSB7XG4gICAgb2Zmc2V0IC0tO1xuICAgIHF1b3RpZW50LmxzbDEoKTtcbiAgICBpZiAobW9kdWx1cy51Y29tcGFyZShkaXZpc29yKSA+PSAwKSB7XG4gICAgICBxdW90aWVudC5sbyArKztcbiAgICAgIG1vZHVsdXMgPSBtb2R1bHVzLnN1YihkaXZpc29yKTtcbiAgICB9XG4gICAgZGl2aXNvci5sc3IxKCk7XG4gIH1cbiAgcmV0dXJuIHsgcXVvdGllbnQgOiBxdW90aWVudCwgbW9kdWx1cyA6IG1vZHVsdXMgfTtcbn1cbk1sSW50NjQucHJvdG90eXBlLmRpdiA9IGZ1bmN0aW9uICh5KVxue1xuICB2YXIgeCA9IHRoaXM7XG4gIGlmICh5LmlzWmVybygpKSBjYW1sX3JhaXNlX3plcm9fZGl2aWRlICgpO1xuICB2YXIgc2lnbiA9IHguaGkgXiB5LmhpO1xuICBpZiAoeC5oaSAmIDB4ODAwMCkgeCA9IHgubmVnKCk7XG4gIGlmICh5LmhpICYgMHg4MDAwKSB5ID0geS5uZWcoKTtcbiAgdmFyIHEgPSB4LnVkaXZtb2QoeSkucXVvdGllbnQ7XG4gIGlmIChzaWduICYgMHg4MDAwKSBxID0gcS5uZWcoKTtcbiAgcmV0dXJuIHE7XG59XG5NbEludDY0LnByb3RvdHlwZS5tb2QgPSBmdW5jdGlvbiAoeSlcbntcbiAgdmFyIHggPSB0aGlzO1xuICBpZiAoeS5pc1plcm8oKSkgY2FtbF9yYWlzZV96ZXJvX2RpdmlkZSAoKTtcbiAgdmFyIHNpZ24gPSB4LmhpO1xuICBpZiAoeC5oaSAmIDB4ODAwMCkgeCA9IHgubmVnKCk7XG4gIGlmICh5LmhpICYgMHg4MDAwKSB5ID0geS5uZWcoKTtcbiAgdmFyIHIgPSB4LnVkaXZtb2QoeSkubW9kdWx1cztcbiAgaWYgKHNpZ24gJiAweDgwMDApIHIgPSByLm5lZygpO1xuICByZXR1cm4gcjtcbn1cbk1sSW50NjQucHJvdG90eXBlLnRvSW50ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5sbyB8ICh0aGlzLm1pIDw8IDI0KTtcbn1cbk1sSW50NjQucHJvdG90eXBlLnRvRmxvYXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAoKHRoaXMuaGkgPDwgMTYpICogTWF0aC5wb3coMiwgMzIpICsgdGhpcy5taSAqIE1hdGgucG93KDIsIDI0KSkgKyB0aGlzLmxvO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIFt0aGlzLmhpID4+IDgsXG4gICAgICAgICAgdGhpcy5oaSAmIDB4ZmYsXG4gICAgICAgICAgdGhpcy5taSA+PiAxNixcbiAgICAgICAgICAodGhpcy5taSA+PiA4KSAmIDB4ZmYsXG4gICAgICAgICAgdGhpcy5taSAmIDB4ZmYsXG4gICAgICAgICAgdGhpcy5sbyA+PiAxNixcbiAgICAgICAgICAodGhpcy5sbyA+PiA4KSAmIDB4ZmYsXG4gICAgICAgICAgdGhpcy5sbyAmIDB4ZmZdO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUubG8zMiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubG8gfCAoKHRoaXMubWkgJiAweGZmKSA8PCAyNCk7XG59XG5NbEludDY0LnByb3RvdHlwZS5oaTMyID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gKCh0aGlzLm1pID4+PiA4KSAmIDB4ZmZmZikgfCAodGhpcy5oaSA8PCAxNik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfdWx0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X3VsdCh4LHkpIHsgcmV0dXJuIHgudWNvbXBhcmUoeSkgPCAwOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfY29tcGFyZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9jb21wYXJlKHgseSwgdG90YWwpIHsgcmV0dXJuIHguY29tcGFyZSh5KSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfbmVnIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X25lZyAoeCkgeyByZXR1cm4geC5uZWcoKSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfYWRkIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2FkZCAoeCwgeSkgeyByZXR1cm4geC5hZGQoeSkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3N1YiBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9zdWIgKHgsIHkpIHsgcmV0dXJuIHguc3ViKHkpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9tdWwgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2Zmc2V0XG5mdW5jdGlvbiBjYW1sX2ludDY0X211bCh4LHkpIHsgcmV0dXJuIHgubXVsKHkpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9pc196ZXJvIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2lzX3plcm8oeCkgeyByZXR1cm4gK3guaXNaZXJvKCk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9pc19uZWdhdGl2ZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9pc19uZWdhdGl2ZSh4KSB7IHJldHVybiAreC5pc05lZygpOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfYW5kIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2FuZCAoeCwgeSkgeyByZXR1cm4geC5hbmQoeSk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9vciBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9vciAoeCwgeSkgeyByZXR1cm4geC5vcih5KTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3hvciBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF94b3IgKHgsIHkpIHsgcmV0dXJuIHgueG9yKHkpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9zaGlmdF9sZWZ0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X3NoaWZ0X2xlZnQgKHgsIHMpIHsgcmV0dXJuIHguc2hpZnRfbGVmdChzKSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfc2hpZnRfcmlnaHRfdW5zaWduZWQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfc2hpZnRfcmlnaHRfdW5zaWduZWQgKHgsIHMpIHsgcmV0dXJuIHguc2hpZnRfcmlnaHRfdW5zaWduZWQocykgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0ICh4LCBzKSB7IHJldHVybiB4LnNoaWZ0X3JpZ2h0KHMpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9kaXYgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfZGl2ICh4LCB5KSB7IHJldHVybiB4LmRpdih5KSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfbW9kIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X21vZCAoeCwgeSkgeyByZXR1cm4geC5tb2QoeSkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X29mX2ludDMyIGNvbnN0XG4vL1JlcXVpcmVzOiBNbEludDY0XG5mdW5jdGlvbiBjYW1sX2ludDY0X29mX2ludDMyICh4KSB7XG4gIHJldHVybiBuZXcgTWxJbnQ2NCh4ICYgMHhmZmZmZmYsICh4ID4+IDI0KSAmIDB4ZmZmZmZmLCAoeCA+PiAzMSkgJiAweGZmZmYpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfdG9faW50MzIgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfdG9faW50MzIgKHgpIHsgcmV0dXJuIHgudG9JbnQoKSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfdG9fZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfdG9fZmxvYXQgKHgpIHsgcmV0dXJuIHgudG9GbG9hdCAoKSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfb2ZfZmxvYXQgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2Zmc2V0LCBNbEludDY0XG5mdW5jdGlvbiBjYW1sX2ludDY0X29mX2Zsb2F0ICh4KSB7XG4gIGlmICh4IDwgMCkgeCA9IE1hdGguY2VpbCh4KTtcbiAgcmV0dXJuIG5ldyBNbEludDY0KFxuICAgIHggJiAweGZmZmZmZixcbiAgICBNYXRoLmZsb29yKHggKiBjYW1sX2ludDY0X29mZnNldCkgJiAweGZmZmZmZixcbiAgICBNYXRoLmZsb29yKHggKiBjYW1sX2ludDY0X29mZnNldCAqIGNhbWxfaW50NjRfb2Zmc2V0KSAmIDB4ZmZmZik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfZm9ybWF0IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX3BhcnNlX2Zvcm1hdCwgY2FtbF9maW5pc2hfZm9ybWF0dGluZ1xuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9pc19uZWdhdGl2ZSwgY2FtbF9pbnQ2NF9uZWdcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfaW50MzIsIGNhbWxfaW50NjRfdG9faW50MzJcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfaXNfemVybywgY2FtbF9zdHJfcmVwZWF0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2Zvcm1hdCAoZm10LCB4KSB7XG4gIHZhciBmID0gY2FtbF9wYXJzZV9mb3JtYXQoZm10KTtcbiAgaWYgKGYuc2lnbmVkY29udiAmJiBjYW1sX2ludDY0X2lzX25lZ2F0aXZlKHgpKSB7XG4gICAgZi5zaWduID0gLTE7IHggPSBjYW1sX2ludDY0X25lZyh4KTtcbiAgfVxuICB2YXIgYnVmZmVyID0gXCJcIjtcbiAgdmFyIHdiYXNlID0gY2FtbF9pbnQ2NF9vZl9pbnQzMihmLmJhc2UpO1xuICB2YXIgY3Z0YmwgPSBcIjAxMjM0NTY3ODlhYmNkZWZcIjtcbiAgZG8ge1xuICAgIHZhciBwID0geC51ZGl2bW9kKHdiYXNlKTtcbiAgICB4ID0gcC5xdW90aWVudDtcbiAgICBidWZmZXIgPSBjdnRibC5jaGFyQXQoY2FtbF9pbnQ2NF90b19pbnQzMihwLm1vZHVsdXMpKSArIGJ1ZmZlcjtcbiAgfSB3aGlsZSAoISBjYW1sX2ludDY0X2lzX3plcm8oeCkpO1xuICBpZiAoZi5wcmVjID49IDApIHtcbiAgICBmLmZpbGxlciA9ICcgJztcbiAgICB2YXIgbiA9IGYucHJlYyAtIGJ1ZmZlci5sZW5ndGg7XG4gICAgaWYgKG4gPiAwKSBidWZmZXIgPSBjYW1sX3N0cl9yZXBlYXQgKG4sICcwJykgKyBidWZmZXI7XG4gIH1cbiAgcmV0dXJuIGNhbWxfZmluaXNoX2Zvcm1hdHRpbmcoZiwgYnVmZmVyKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9vZl9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfcGFyc2Vfc2lnbl9hbmRfYmFzZSwgY2FtbF9mYWlsd2l0aCwgY2FtbF9wYXJzZV9kaWdpdFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZl9pbnQzMiwgY2FtbF9pbnQ2NF91bHRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfYWRkLCBjYW1sX2ludDY0X211bCwgY2FtbF9pbnQ2NF9uZWdcbi8vUmVxdWlyZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aCxjYW1sX3N0cmluZ191bnNhZmVfZ2V0LCBNbEludDY0XG5mdW5jdGlvbiBjYW1sX2ludDY0X29mX3N0cmluZyhzKSB7XG4gIHZhciByID0gY2FtbF9wYXJzZV9zaWduX2FuZF9iYXNlIChzKTtcbiAgdmFyIGkgPSByWzBdLCBzaWduID0gclsxXSwgYmFzZSA9IHJbMl07XG4gIHZhciBiYXNlNjQgPSBjYW1sX2ludDY0X29mX2ludDMyKGJhc2UpO1xuICB2YXIgdGhyZXNob2xkID1cbiAgICAgIG5ldyBNbEludDY0KDB4ZmZmZmZmLCAweGZmZmZmZmYsIDB4ZmZmZikudWRpdm1vZChiYXNlNjQpLnF1b3RpZW50O1xuICB2YXIgYyA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQocywgaSk7XG4gIHZhciBkID0gY2FtbF9wYXJzZV9kaWdpdChjKTtcbiAgaWYgKGQgPCAwIHx8IGQgPj0gYmFzZSkgY2FtbF9mYWlsd2l0aChcImludF9vZl9zdHJpbmdcIik7XG4gIHZhciByZXMgPSBjYW1sX2ludDY0X29mX2ludDMyKGQpO1xuICBmb3IgKDs7KSB7XG4gICAgaSsrO1xuICAgIGMgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0KHMsIGkpO1xuICAgIGlmIChjID09IDk1KSBjb250aW51ZTtcbiAgICBkID0gY2FtbF9wYXJzZV9kaWdpdChjKTtcbiAgICBpZiAoZCA8IDAgfHwgZCA+PSBiYXNlKSBicmVhaztcbiAgICAvKiBEZXRlY3Qgb3ZlcmZsb3cgaW4gbXVsdGlwbGljYXRpb24gYmFzZSAqIHJlcyAqL1xuICAgIGlmIChjYW1sX2ludDY0X3VsdCh0aHJlc2hvbGQsIHJlcykpIGNhbWxfZmFpbHdpdGgoXCJpbnRfb2Zfc3RyaW5nXCIpO1xuICAgIGQgPSBjYW1sX2ludDY0X29mX2ludDMyKGQpO1xuICAgIHJlcyA9IGNhbWxfaW50NjRfYWRkKGNhbWxfaW50NjRfbXVsKGJhc2U2NCwgcmVzKSwgZCk7XG4gICAgLyogRGV0ZWN0IG92ZXJmbG93IGluIGFkZGl0aW9uIChiYXNlICogcmVzKSArIGQgKi9cbiAgICBpZiAoY2FtbF9pbnQ2NF91bHQocmVzLCBkKSkgY2FtbF9mYWlsd2l0aChcImludF9vZl9zdHJpbmdcIik7XG4gIH1cbiAgaWYgKGkgIT0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpKSBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgaWYgKGJhc2UgPT0gMTAgJiYgY2FtbF9pbnQ2NF91bHQobmV3IE1sSW50NjQoMCwgMCwgMHg4MDAwKSwgcmVzKSlcbiAgICBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgaWYgKHNpZ24gPCAwKSByZXMgPSBjYW1sX2ludDY0X25lZyhyZXMpO1xuICByZXR1cm4gcmVzO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2NyZWF0ZV9sb19taV9oaSBjb25zdFxuLy9SZXF1aXJlczogTWxJbnQ2NFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9jcmVhdGVfbG9fbWlfaGkobG8sIG1pLCBoaSl7XG4gIHJldHVybiBuZXcgTWxJbnQ2NChsbywgbWksIGhpKVxufVxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9jcmVhdGVfbG9faGkgY29uc3Rcbi8vUmVxdWlyZXM6IE1sSW50NjRcbmZ1bmN0aW9uIGNhbWxfaW50NjRfY3JlYXRlX2xvX2hpKGxvLCBoaSl7XG4gIHJldHVybiBuZXcgTWxJbnQ2NCAoXG4gICAgbG8gJiAweGZmZmZmZixcbiAgICAoKGxvID4+PiAyNCkgJiAweGZmKSB8ICgoaGkgJiAweGZmZmYpIDw8IDgpLFxuICAgIChoaSA+Pj4gMTYpICYgMHhmZmZmKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfbG8zMiBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9sbzMyKHYpeyByZXR1cm4gdi5sbzMyKCkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2hpMzIgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfaGkzMih2KXsgcmV0dXJuIHYuaGkzMigpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9vZl9ieXRlcyBjb25zdFxuLy9SZXF1aXJlczogTWxJbnQ2NFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9vZl9ieXRlcyhhKSB7XG4gIHJldHVybiBuZXcgTWxJbnQ2NChhWzddIDw8IDAgfCAoYVs2XSA8PCA4KSB8IChhWzVdIDw8IDE2KSxcbiAgICAgICAgICAgICAgICAgICAgIGFbNF0gPDwgMCB8IChhWzNdIDw8IDgpIHwgKGFbMl0gPDwgMTYpLFxuICAgICAgICAgICAgICAgICAgICAgYVsxXSA8PCAwIHwgKGFbMF0gPDwgOCkpO1xufVxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF90b19ieXRlcyBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF90b19ieXRlcyh4KSB7IHJldHVybiB4LnRvQXJyYXkoKSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfaGFzaCBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9oYXNoKHYpe1xuICByZXR1cm4gKHYubG8zMigpKSBeICh2LmhpMzIoKSlcbn1cbiIsIlxuLy9Qcm92aWRlczogTWxNdXRleFxuZnVuY3Rpb24gTWxNdXRleCgpIHtcbiAgdGhpcy5sb2NrZWQgPSBmYWxzZVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX211dGV4X25ld1xuLy9SZXF1aXJlczogTWxNdXRleFxuZnVuY3Rpb24gY2FtbF9tbF9tdXRleF9uZXcodW5pdCkge1xuICByZXR1cm4gbmV3IE1sTXV0ZXgoKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9tdXRleF9sb2NrXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX21sX211dGV4X2xvY2sodCkge1xuICBpZih0LmxvY2tlZClcbiAgICBjYW1sX2ZhaWx3aXRoKFwiTXV0ZXgubG9jazogbXV0ZXggYWxyZWFkeSBsb2NrZWQuIENhbm5vdCB3YWl0LlwiKTtcbiAgZWxzZSB0LmxvY2tlZCA9IHRydWU7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX211dGV4X3RyeV9sb2NrXG5mdW5jdGlvbiBjYW1sX21sX211dGV4X3RyeV9sb2NrKHQpIHtcbiAgaWYoIXQubG9ja2VkKSB7XG4gICAgdC5sb2NrZWQgPSB0cnVlO1xuICAgIHJldHVybiAxO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX211dGV4X3VubG9ja1xuZnVuY3Rpb24gY2FtbF9tbF9tdXRleF91bmxvY2sodCkge1xuICB0LmxvY2tlZCA9IGZhbHNlO1xuICByZXR1cm4gMDtcbn1cbiIsIi8vUHJvdmlkZXM6IGluaXRpYWxpemVfbmF0XG4vL1JlcXVpcmVzOiBjYW1sX2N1c3RvbV9vcHNcbi8vUmVxdWlyZXM6IHNlcmlhbGl6ZV9uYXQsIGRlc2VyaWFsaXplX25hdCwgY2FtbF9oYXNoX25hdFxuZnVuY3Rpb24gaW5pdGlhbGl6ZV9uYXQoKSB7XG4gIGNhbWxfY3VzdG9tX29wc1tcIl9uYXRcIl0gPVxuICAgIHsgZGVzZXJpYWxpemUgOiBkZXNlcmlhbGl6ZV9uYXQsXG4gICAgICBzZXJpYWxpemUgOiBzZXJpYWxpemVfbmF0LFxuICAgICAgaGFzaCA6IGNhbWxfaGFzaF9uYXRcbiAgICB9XG59XG5cbi8vUHJvdmlkZXM6IE1sTmF0XG5mdW5jdGlvbiBNbE5hdCh4KXtcbiAgdGhpcy5kYXRhID0gbmV3IEludDMyQXJyYXkoeCk7XG4gIC8vIEZvciBudW0gPCAxLjVcbiAgLy8gbGVuZ3RoX25hdCBpc24ndCBleHRlcm5hbCwgc28gd2UgaGF2ZSB0byBtYWtlIHRoZSBPYmouc2l6ZVxuICAvLyB3b3JrIG91dCByaWdodC5cbiAgLy8gV2UgYWRkICsyIHRvIHRoZSBhcnJheSBsZW5ndGg6XG4gIC8vIC0gKzEgZm9yIHRoZSB0YWdcbiAgLy8gLSArMSBmb3IgdGhlIGN1c3RvbV9vcHMgc2xvdFxuICB0aGlzLmxlbmd0aCA9IHRoaXMuZGF0YS5sZW5ndGggKyAyXG59XG5cbk1sTmF0LnByb3RvdHlwZS5jYW1sX2N1c3RvbSA9IFwiX25hdFwiO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbmF0XG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2ludCwgbnVtX2RpZ2l0c19uYXRcbmZ1bmN0aW9uIGNhbWxfaGFzaF9uYXQoeCkge1xuICB2YXIgbGVuID0gbnVtX2RpZ2l0c19uYXQoeCwgMCwgeC5kYXRhLmxlbmd0aCk7XG4gIHZhciBoID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCB4LmRhdGFbaV0pO1xuICB9XG4gIHJldHVybiBoO1xufVxuXG4vL1Byb3ZpZGVzOiBsZW5ndGhfbmF0XG5mdW5jdGlvbiBsZW5ndGhfbmF0KHgpIHtcbiAgcmV0dXJuIHguZGF0YS5sZW5ndGg7XG59XG5cbi8vUHJvdmlkZXM6IG5hdF9vZl9hcnJheVxuLy9SZXF1aXJlczogTWxOYXRcbmZ1bmN0aW9uIG5hdF9vZl9hcnJheShsKXtcbiAgcmV0dXJuIG5ldyBNbE5hdChsKTtcbn1cblxuLy9Qcm92aWRlczogY3JlYXRlX25hdFxuLy9SZXF1aXJlczogTWxOYXRcbmZ1bmN0aW9uIGNyZWF0ZV9uYXQoc2l6ZSkge1xuICB2YXIgYXJyID0gbmV3IE1sTmF0KHNpemUpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgYXJyLmRhdGFbaV0gPSAtMTtcbiAgfVxuICByZXR1cm4gYXJyO1xufVxuXG4vL1Byb3ZpZGVzOiBzZXRfdG9femVyb19uYXRcbmZ1bmN0aW9uIHNldF90b196ZXJvX25hdChuYXQsIG9mcywgbGVuKSB7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIG5hdC5kYXRhW29mcytpXSA9IDA7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGJsaXRfbmF0XG5mdW5jdGlvbiBibGl0X25hdChuYXQxLCBvZnMxLCBuYXQyLCBvZnMyLCBsZW4pIHtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgbmF0MS5kYXRhW29mczEraV0gPSBuYXQyLmRhdGFbb2ZzMitpXTtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogc2V0X2RpZ2l0X25hdFxuZnVuY3Rpb24gc2V0X2RpZ2l0X25hdChuYXQsIG9mcywgZGlnaXQpIHtcbiAgbmF0LmRhdGFbb2ZzXSA9IGRpZ2l0O1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogbnRoX2RpZ2l0X25hdFxuZnVuY3Rpb24gbnRoX2RpZ2l0X25hdChuYXQsIG9mcykge1xuICByZXR1cm4gbmF0LmRhdGFbb2ZzXTtcbn1cblxuLy9Qcm92aWRlczogc2V0X2RpZ2l0X25hdF9uYXRpdmVcbmZ1bmN0aW9uIHNldF9kaWdpdF9uYXRfbmF0aXZlKG5hdCwgb2ZzLCBkaWdpdCkge1xuICBuYXQuZGF0YVtvZnNdID0gZGlnaXQ7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBudGhfZGlnaXRfbmF0X25hdGl2ZVxuZnVuY3Rpb24gbnRoX2RpZ2l0X25hdF9uYXRpdmUobmF0LCBvZnMpIHtcbiAgcmV0dXJuIG5hdC5kYXRhW29mc107XG59XG5cbi8vUHJvdmlkZXM6IG51bV9kaWdpdHNfbmF0XG5mdW5jdGlvbiBudW1fZGlnaXRzX25hdChuYXQsIG9mcywgbGVuKSB7XG4gIGZvcih2YXIgaSA9IGxlbiAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYobmF0LmRhdGFbb2ZzK2ldICE9IDApIHJldHVybiBpKzE7XG4gIH1cbiAgcmV0dXJuIDE7IC8vIDAgY291bnRzIGFzIDEgZGlnaXRcbn1cblxuLy9Qcm92aWRlczogbnVtX2xlYWRpbmdfemVyb19iaXRzX2luX2RpZ2l0XG5mdW5jdGlvbiBudW1fbGVhZGluZ196ZXJvX2JpdHNfaW5fZGlnaXQobmF0LCBvZnMpIHtcbiAgdmFyIGEgPSBuYXQuZGF0YVtvZnNdO1xuICB2YXIgYiA9IDA7XG4gIGlmKGEgJiAweEZGRkYwMDAwKSB7IGIgKz0xNjsgYSA+Pj49MTY7IH1cbiAgaWYoYSAmIDB4RkYwMCkgICAgIHsgYiArPSA4OyBhID4+Pj0gODsgfVxuICBpZihhICYgMHhGMCkgICAgICAgeyBiICs9IDQ7IGEgPj4+PSA0OyB9XG4gIGlmKGEgJiAxMikgICAgICAgICB7IGIgKz0gMjsgYSA+Pj49IDI7IH1cbiAgaWYoYSAmIDIpICAgICAgICAgIHsgYiArPSAxOyBhID4+Pj0gMTsgfVxuICBpZihhICYgMSkgICAgICAgICAgeyBiICs9IDE7IH1cbiAgcmV0dXJuIDMyIC0gYjtcbn1cblxuLy9Qcm92aWRlczogaXNfZGlnaXRfaW50XG5mdW5jdGlvbiBpc19kaWdpdF9pbnQobmF0LCBvZnMpIHtcbiAgaWYgKG5hdC5kYXRhW29mc10gPj0gMCkgcmV0dXJuIDFcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGlzX2RpZ2l0X3plcm9cbmZ1bmN0aW9uIGlzX2RpZ2l0X3plcm8obmF0LCBvZnMpIHtcbiAgaWYobmF0LmRhdGFbb2ZzXSA9PSAwKSByZXR1cm4gMTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGlzX2RpZ2l0X29kZFxuZnVuY3Rpb24gaXNfZGlnaXRfb2RkKG5hdCwgb2ZzKSB7XG4gIGlmKG5hdC5kYXRhW29mc10gJiAxKSByZXR1cm4gMTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGluY3JfbmF0XG5mdW5jdGlvbiBpbmNyX25hdChuYXQsIG9mcywgbGVuLCBjYXJyeV9pbikge1xuICB2YXIgY2FycnkgPSBjYXJyeV9pbjtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIHggPSAobmF0LmRhdGFbb2ZzK2ldID4+PiAwKSArIGNhcnJ5O1xuICAgIG5hdC5kYXRhW29mcytpXSA9ICh4IHwgMCk7XG4gICAgaWYoeCA9PSAoeCA+Pj4gMCkpIHtcbiAgICAgIGNhcnJ5ID0gMDtcbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYXJyeSA9IDE7XG4gICAgfVxuICB9XG4gIHJldHVybiBjYXJyeTtcbn1cblxuLy8gbGVuMSA+PSBsZW4yXG4vL1Byb3ZpZGVzOiBhZGRfbmF0XG4vL1JlcXVpcmVzOiBpbmNyX25hdFxuZnVuY3Rpb24gYWRkX25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBsZW4yLCBjYXJyeV9pbikge1xuICB2YXIgY2FycnkgPSBjYXJyeV9pbjtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjI7IGkrKykge1xuICAgIHZhciB4ID0gKG5hdDEuZGF0YVtvZnMxK2ldID4+PiAwKSArIChuYXQyLmRhdGFbb2ZzMitpXSA+Pj4gMCkgKyBjYXJyeTtcbiAgICBuYXQxLmRhdGFbb2ZzMStpXSA9IHhcbiAgICBpZih4ID09ICh4ID4+PiAwKSkge1xuICAgICAgY2FycnkgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYXJyeSA9IDE7XG4gICAgfVxuICB9XG4gIHJldHVybiBpbmNyX25hdChuYXQxLCBvZnMxK2xlbjIsIGxlbjEtbGVuMiwgY2FycnkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjb21wbGVtZW50X25hdFxuZnVuY3Rpb24gY29tcGxlbWVudF9uYXQobmF0LCBvZnMsIGxlbikge1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBuYXQuZGF0YVtvZnMraV0gPSAoLTEgPj4+IDApIC0gKG5hdC5kYXRhW29mcytpXSA+Pj4gMCk7XG4gIH1cbn1cblxuLy8gb2NhbWwgZmxpcHMgY2FycnlfaW5cbi8vUHJvdmlkZXM6IGRlY3JfbmF0XG5mdW5jdGlvbiBkZWNyX25hdChuYXQsIG9mcywgbGVuLCBjYXJyeV9pbikge1xuICB2YXIgYm9ycm93ID0gKGNhcnJ5X2luID09IDEpID8gMCA6IDE7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciB4ID0gKG5hdC5kYXRhW29mcytpXSA+Pj4wKSAtIGJvcnJvdztcbiAgICBuYXQuZGF0YVtvZnMraV0gPSB4O1xuICAgIGlmICh4ID49IDApIHtcbiAgICAgIGJvcnJvdyA9IDA7XG4gICAgICBicmVhaztcbiAgICB9IGVsc2Uge1xuICAgICAgYm9ycm93ID0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIChib3Jyb3cgPT0gMSkgPyAwIDogMTtcbn1cblxuLy8gb2NhbWwgZmxpcHMgY2FycnlfaW5cbi8vIGxlbjEgPj0gbGVuMlxuLy9Qcm92aWRlczogc3ViX25hdFxuLy9SZXF1aXJlczogZGVjcl9uYXRcbmZ1bmN0aW9uIHN1Yl9uYXQobmF0MSwgb2ZzMSwgbGVuMSwgbmF0Miwgb2ZzMiwgbGVuMiwgY2FycnlfaW4pIHtcbiAgdmFyIGJvcnJvdyA9IChjYXJyeV9pbiA9PSAxKSA/IDAgOiAxO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuMjsgaSsrKSB7XG4gICAgdmFyIHggPSAobmF0MS5kYXRhW29mczEraV0gPj4+IDApIC0gKG5hdDIuZGF0YVtvZnMyK2ldID4+PiAwKSAtIGJvcnJvdztcbiAgICBuYXQxLmRhdGFbb2ZzMStpXSA9IHg7XG4gICAgaWYgKHggPj0gMCkge1xuICAgICAgYm9ycm93ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgYm9ycm93ID0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlY3JfbmF0KG5hdDEsIG9mczErbGVuMiwgbGVuMS1sZW4yLCAoYm9ycm93PT0xKT8wOjEpO1xufVxuXG4vLyBuYXQxICs9IG5hdDIgKiBuYXQzW29mczNdXG4vLyBsZW4xID49IGxlbjJcbi8vUHJvdmlkZXM6IG11bHRfZGlnaXRfbmF0XG4vL1JlcXVpcmVzOiBhZGRfbmF0LCBuYXRfb2ZfYXJyYXlcbmZ1bmN0aW9uIG11bHRfZGlnaXRfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIGxlbjIsIG5hdDMsIG9mczMpIHtcbiAgdmFyIGNhcnJ5ID0gMDtcbiAgdmFyIGEgPSAobmF0My5kYXRhW29mczNdID4+PiAwKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjI7IGkrKykge1xuICAgIHZhciB4MSA9IChuYXQxLmRhdGFbb2ZzMStpXSA+Pj4gMCkgKyAobmF0Mi5kYXRhW29mczIraV0gPj4+IDApICogKGEgJiAweDAwMDBGRkZGKSArIGNhcnJ5O1xuICAgIHZhciB4MiA9IChuYXQyLmRhdGFbb2ZzMitpXSA+Pj4gMCkgKiAoYSA+Pj4gMTYpO1xuICAgIGNhcnJ5ID0gTWF0aC5mbG9vcih4Mi82NTUzNik7XG4gICAgdmFyIHgzID0geDEgKyAoeDIgJSA2NTUzNikgKiA2NTUzNjtcbiAgICBuYXQxLmRhdGFbb2ZzMStpXSA9IHgzO1xuICAgIGNhcnJ5ICs9IE1hdGguZmxvb3IoeDMvNDI5NDk2NzI5Nik7XG4gIH1cblxuICBpZihsZW4yIDwgbGVuMSAmJiBjYXJyeSkge1xuICAgIHJldHVybiBhZGRfbmF0KG5hdDEsIG9mczErbGVuMiwgbGVuMS1sZW4yLCBuYXRfb2ZfYXJyYXkoW2NhcnJ5XSksIDAsIDEsIDApO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjYXJyeTtcbiAgfVxufVxuXG4vLyBuYXQxICs9IG5hdDIgKiBuYXQzXG4vLyBsZW4xID49IGxlbjIgKyBsZW4zLlxuLy9Qcm92aWRlczogbXVsdF9uYXRcbi8vUmVxdWlyZXM6IG11bHRfZGlnaXRfbmF0XG5mdW5jdGlvbiBtdWx0X25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBsZW4yLCBuYXQzLCBvZnMzLCBsZW4zKSB7XG4gIHZhciBjYXJyeSA9IDA7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW4zOyBpKyspIHtcbiAgICBjYXJyeSArPSBtdWx0X2RpZ2l0X25hdChuYXQxLCBvZnMxK2ksIGxlbjEtaSwgbmF0Miwgb2ZzMiwgbGVuMiwgbmF0Mywgb2ZzMytpKTtcbiAgfVxuICByZXR1cm4gY2Fycnk7XG59XG5cbi8vIG5hdDEgPSAyICogbmF0MSArIG5hdDIgKiBuYXQyXG4vLyBsZW4xID49IDIgKiBsZW4yXG4vL1Byb3ZpZGVzOiBzcXVhcmVfbmF0XG4vL1JlcXVpcmVzOiBtdWx0X25hdCwgYWRkX25hdFxuZnVuY3Rpb24gc3F1YXJlX25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBsZW4yKSB7XG4gIHZhciBjYXJyeSA9IDA7XG4gIGNhcnJ5ICs9IGFkZF9uYXQobmF0MSwgb2ZzMSwgbGVuMSwgbmF0MSwgb2ZzMSwgbGVuMSwgMCk7XG4gIGNhcnJ5ICs9IG11bHRfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIGxlbjIsIG5hdDIsIG9mczIsIGxlbjIpO1xuICByZXR1cm4gY2Fycnk7XG59XG5cblxuLy8gMCA8PSBzaGlmdCA8IDMyXG4vL1Byb3ZpZGVzOiBzaGlmdF9sZWZ0X25hdFxuZnVuY3Rpb24gc2hpZnRfbGVmdF9uYXQobmF0MSwgb2ZzMSwgbGVuMSwgbmF0Miwgb2ZzMiwgbmJpdHMpIHtcbiAgaWYobmJpdHMgPT0gMCkge1xuICAgIG5hdDIuZGF0YVtvZnMyXSA9IDA7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgdmFyIHdyYXAgPSAwO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuMTsgaSsrKSB7XG4gICAgdmFyIGEgPSAobmF0MS5kYXRhW29mczEraV0gPj4+IDApO1xuICAgIG5hdDEuZGF0YVtvZnMxK2ldID0gKGEgPDwgbmJpdHMpIHwgd3JhcDtcbiAgICB3cmFwID0gYSA+Pj4gKDMyIC0gbmJpdHMpO1xuICB9XG4gIG5hdDIuZGF0YVtvZnMyXSA9IHdyYXA7XG4gIHJldHVybiAwO1xufVxuXG4vLyBBc3N1bWluZyBjID4gYSwgcmV0dXJucyBbcXVvdGllbnQsIHJlbWFpbmRlcl0gb2YgKGE8PDMyICsgYikvY1xuLy9Qcm92aWRlczogZGl2X2hlbHBlclxuZnVuY3Rpb24gZGl2X2hlbHBlcihhLCBiLCBjKSB7XG4gIHZhciB4ID0gYSAqIDY1NTM2ICsgKGI+Pj4xNik7XG4gIHZhciB5ID0gTWF0aC5mbG9vcih4L2MpICogNjU1MzY7XG4gIHZhciB6ID0gKHggJSBjKSAqIDY1NTM2O1xuICB2YXIgdyA9IHogKyAoYiAmIDB4MDAwMEZGRkYpO1xuICByZXR1cm4gW3kgKyBNYXRoLmZsb29yKHcvYyksIHcgJSBjXTtcbn1cblxuLy8gbmF0MVtvZnMxK2xlbl0gPCBuYXQyW29mczJdXG4vL1Byb3ZpZGVzOiBkaXZfZGlnaXRfbmF0XG4vL1JlcXVpcmVzOiBkaXZfaGVscGVyXG5mdW5jdGlvbiBkaXZfZGlnaXRfbmF0KG5hdHEsIG9mc3EsIG5hdHIsIG9mc3IsIG5hdDEsIG9mczEsIGxlbiwgbmF0Miwgb2ZzMikge1xuICB2YXIgcmVtID0gKG5hdDEuZGF0YVtvZnMxK2xlbi0xXSA+Pj4wKTtcbiAgLy8gbmF0cVtvZnNxK2xlbi0xXSBpcyBndWFyYW50ZWVkIHRvIGJlIHplcm8gKGR1ZSB0byB0aGUgTVNEIHJlcXVpcmVtZW50KSxcbiAgLy8gYW5kIHNob3VsZCBub3QgYmUgd3JpdHRlbiB0by5cbiAgZm9yKHZhciBpID0gbGVuLTI7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIHggPSBkaXZfaGVscGVyKHJlbSwgKG5hdDEuZGF0YVtvZnMxK2ldID4+PiAwKSwgKG5hdDIuZGF0YVtvZnMyXSA+Pj4gMCkpO1xuICAgIG5hdHEuZGF0YVtvZnNxK2ldID0geFswXTtcbiAgICByZW0gPSB4WzFdO1xuICB9XG4gIG5hdHIuZGF0YVtvZnNyXSA9IHJlbTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vIG5hdDFbbmF0MjpdIDo9IG5hdDEgLyBuYXQyXG4vLyBuYXQxWzpuYXQyXSA6PSBuYXQxICUgbmF0MlxuLy8gbGVuMSA+IGxlbjIsIG5hdDJbb2ZzMitsZW4yLTFdID4gbmF0MVtvZnMxK2xlbjEtMV1cbi8vUHJvdmlkZXM6IGRpdl9uYXRcbi8vUmVxdWlyZXM6IGRpdl9kaWdpdF9uYXQsIGRpdl9oZWxwZXIsIG51bV9sZWFkaW5nX3plcm9fYml0c19pbl9kaWdpdCwgc2hpZnRfbGVmdF9uYXQsIHNoaWZ0X3JpZ2h0X25hdCwgY3JlYXRlX25hdCwgc2V0X3RvX3plcm9fbmF0LCBtdWx0X2RpZ2l0X25hdCwgc3ViX25hdCwgY29tcGFyZV9uYXQsIG5hdF9vZl9hcnJheVxuZnVuY3Rpb24gZGl2X25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBsZW4yKSB7XG4gIGlmKGxlbjIgPT0gMSkge1xuICAgIGRpdl9kaWdpdF9uYXQobmF0MSwgb2ZzMSsxLCBuYXQxLCBvZnMxLCBuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyKTtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHZhciBzID0gbnVtX2xlYWRpbmdfemVyb19iaXRzX2luX2RpZ2l0KG5hdDIsIG9mczIrbGVuMi0xKTtcbiAgc2hpZnRfbGVmdF9uYXQobmF0Miwgb2ZzMiwgbGVuMiwgbmF0X29mX2FycmF5KFswXSksIDAsIHMpO1xuICBzaGlmdF9sZWZ0X25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXRfb2ZfYXJyYXkoWzBdKSwgMCwgcyk7XG5cbiAgdmFyIGQgPSAobmF0Mi5kYXRhW29mczIrbGVuMi0xXSA+Pj4gMCkgKyAxO1xuICB2YXIgYSA9IGNyZWF0ZV9uYXQobGVuMisxKTtcbiAgZm9yICh2YXIgaSA9IGxlbjEgLSAxOyBpID49IGxlbjI7IGktLSkge1xuICAgIC8vIERlY2VudCBsb3dlciBib3VuZCBvbiBxdW9cbiAgICB2YXIgcXVvID0gZCA9PSA0Mjk0OTY3Mjk2ID8gKG5hdDEuZGF0YVtvZnMxK2ldID4+PiAwKSA6IGRpdl9oZWxwZXIoKG5hdDEuZGF0YVtvZnMxK2ldID4+PiAwKSwgKG5hdDEuZGF0YVtvZnMxK2ktMV0gPj4+MCksIGQpWzBdO1xuICAgIHNldF90b196ZXJvX25hdChhLCAwLCBsZW4yKzEpO1xuICAgIG11bHRfZGlnaXRfbmF0KGEsIDAsIGxlbjIrMSwgbmF0Miwgb2ZzMiwgbGVuMiwgbmF0X29mX2FycmF5KFtxdW9dKSwgMCk7XG4gICAgc3ViX25hdChuYXQxLCBvZnMxK2ktbGVuMiwgbGVuMisxLCBhLCAwLCBsZW4yKzEsIDEpO1xuXG4gICAgd2hpbGUgKG5hdDEuZGF0YVtvZnMxK2ldICE9IDAgfHwgY29tcGFyZV9uYXQobmF0MSwgb2ZzMStpLWxlbjIsIGxlbjIsIG5hdDIsIG9mczIsIGxlbjIpID49IDApIHtcbiAgICAgIHF1byA9IHF1byArIDE7XG4gICAgICBzdWJfbmF0KG5hdDEsIG9mczEraS1sZW4yLCBsZW4yKzEsIG5hdDIsIG9mczIsIGxlbjIsIDEpO1xuICAgIH1cblxuICAgIG5hdDEuZGF0YVtvZnMxK2ldID0gcXVvO1xuICB9XG5cbiAgc2hpZnRfcmlnaHRfbmF0KG5hdDEsIG9mczEsIGxlbjIsIG5hdF9vZl9hcnJheShbMF0pLCAwLCBzKTsgLy8gc2hpZnQgcmVtYWluZGVyXG4gIHNoaWZ0X3JpZ2h0X25hdChuYXQyLCBvZnMyLCBsZW4yLCBuYXRfb2ZfYXJyYXkoWzBdKSwgMCwgcyk7IC8vIHJlc3RvcmVcbiAgcmV0dXJuIDA7XG59XG5cblxuLy8gMCA8PSBzaGlmdCA8IDMyXG4vL1Byb3ZpZGVzOiBzaGlmdF9yaWdodF9uYXRcbmZ1bmN0aW9uIHNoaWZ0X3JpZ2h0X25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBuYml0cykge1xuICBpZihuYml0cyA9PSAwKSB7XG4gICAgbmF0Mi5kYXRhW29mczJdID0gMDtcbiAgICByZXR1cm4gMDtcbiAgfVxuICB2YXIgd3JhcCA9IDA7XG4gIGZvcih2YXIgaSA9IGxlbjEtMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgYSA9IG5hdDEuZGF0YVtvZnMxK2ldID4+PiAwO1xuICAgIG5hdDEuZGF0YVtvZnMxK2ldID0gKGEgPj4+IG5iaXRzKSB8IHdyYXA7XG4gICAgd3JhcCA9IGEgPDwgKDMyIC0gbmJpdHMpO1xuICB9XG4gIG5hdDIuZGF0YVtvZnMyXSA9IHdyYXA7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjb21wYXJlX2RpZ2l0c19uYXRcbmZ1bmN0aW9uIGNvbXBhcmVfZGlnaXRzX25hdChuYXQxLCBvZnMxLCBuYXQyLCBvZnMyKSB7XG4gIGlmKG5hdDEuZGF0YVtvZnMxXSA+IG5hdDIuZGF0YVtvZnMyXSkgcmV0dXJuIDE7XG4gIGlmKG5hdDEuZGF0YVtvZnMxXSA8IG5hdDIuZGF0YVtvZnMyXSkgcmV0dXJuIC0xO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY29tcGFyZV9uYXRcbi8vUmVxdWlyZXM6IG51bV9kaWdpdHNfbmF0XG5mdW5jdGlvbiBjb21wYXJlX25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBsZW4yKSB7XG4gIHZhciBhID0gbnVtX2RpZ2l0c19uYXQobmF0MSwgb2ZzMSwgbGVuMSk7XG4gIHZhciBiID0gbnVtX2RpZ2l0c19uYXQobmF0Miwgb2ZzMiwgbGVuMik7XG4gIGlmKGEgPiBiKSByZXR1cm4gMTtcbiAgaWYoYSA8IGIpIHJldHVybiAtMTtcbiAgZm9yKHZhciBpID0gbGVuMSAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKChuYXQxLmRhdGFbb2ZzMStpXSA+Pj4gMCkgPiAobmF0Mi5kYXRhW29mczIraV0gPj4+IDApKSByZXR1cm4gMTtcbiAgICBpZiAoKG5hdDEuZGF0YVtvZnMxK2ldID4+PiAwKSA8IChuYXQyLmRhdGFbb2ZzMitpXSA+Pj4gMCkpIHJldHVybiAtMTtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY29tcGFyZV9uYXRfcmVhbFxuLy9SZXF1aXJlczogY29tcGFyZV9uYXRcbmZ1bmN0aW9uIGNvbXBhcmVfbmF0X3JlYWwobmF0MSxuYXQyKXtcbiAgcmV0dXJuIGNvbXBhcmVfbmF0KG5hdDEsMCxuYXQxLmRhdGEubGVuZ3RoLG5hdDIsMCxuYXQyLmRhdGEubGVuZ3RoKTtcbn1cblxuLy9Qcm92aWRlczogbGFuZF9kaWdpdF9uYXRcbmZ1bmN0aW9uIGxhbmRfZGlnaXRfbmF0KG5hdDEsIG9mczEsIG5hdDIsIG9mczIpIHtcbiAgbmF0MS5kYXRhW29mczFdICY9IG5hdDIuZGF0YVtvZnMyXTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGxvcl9kaWdpdF9uYXRcbmZ1bmN0aW9uIGxvcl9kaWdpdF9uYXQobmF0MSwgb2ZzMSwgbmF0Miwgb2ZzMikge1xuICBuYXQxLmRhdGFbb2ZzMV0gfD0gbmF0Mi5kYXRhW29mczJdO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogbHhvcl9kaWdpdF9uYXRcbmZ1bmN0aW9uIGx4b3JfZGlnaXRfbmF0KG5hdDEsIG9mczEsIG5hdDIsIG9mczIpIHtcbiAgbmF0MS5kYXRhW29mczFdIF49IG5hdDIuZGF0YVtvZnMyXTtcbiAgcmV0dXJuIDA7XG59XG5cblxuLy9Qcm92aWRlczogc2VyaWFsaXplX25hdFxuZnVuY3Rpb24gc2VyaWFsaXplX25hdCh3cml0ZXIsIG5hdCwgc3ope1xuICB2YXIgbGVuID0gbmF0LmRhdGEubGVuZ3RoO1xuICB3cml0ZXIud3JpdGUoMzIsIGxlbik7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKyl7XG4gICAgd3JpdGVyLndyaXRlKDMyLCBuYXQuZGF0YVtpXSk7XG4gIH1cbiAgc3pbMF0gPSBsZW4gKiA0O1xuICBzelsxXSA9IGxlbiAqIDg7XG59XG5cbi8vUHJvdmlkZXM6IGRlc2VyaWFsaXplX25hdFxuLy9SZXF1aXJlczogTWxOYXRcbmZ1bmN0aW9uIGRlc2VyaWFsaXplX25hdChyZWFkZXIsIHN6KXtcbiAgdmFyIGxlbiA9IHJlYWRlci5yZWFkMzJzKCk7XG4gIHZhciBuYXQgPSBuZXcgTWxOYXQobGVuKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKXtcbiAgICBuYXQuZGF0YVtpXSA9IHJlYWRlci5yZWFkMzJzKCk7XG4gIH1cbiAgc3pbMF0gPSBsZW4gKiA0O1xuICByZXR1cm4gbmF0O1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDE0IErDqXLDtG1lIFZvdWlsbG9uLCBIdWdvIEhldXphcmRcbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogZnNfbm9kZV9zdXBwb3J0ZWRcbmZ1bmN0aW9uIGZzX25vZGVfc3VwcG9ydGVkICgpIHtcbiAgcmV0dXJuIChcbiAgICB0eXBlb2YgZ2xvYmFsVGhpcy5wcm9jZXNzICE9PSAndW5kZWZpbmVkJ1xuICAgICAgJiYgdHlwZW9mIGdsb2JhbFRoaXMucHJvY2Vzcy52ZXJzaW9ucyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICYmIHR5cGVvZiBnbG9iYWxUaGlzLnByb2Nlc3MudmVyc2lvbnMubm9kZSAhPT0gJ3VuZGVmaW5lZCcpXG59XG4vL1Byb3ZpZGVzOiBmc19ub2RlX3N1cHBvcnRlZFxuLy9JZjogYnJvd3NlclxuZnVuY3Rpb24gZnNfbm9kZV9zdXBwb3J0ZWQgKCkge1xuICByZXR1cm4gZmFsc2Vcbn1cblxuXG4vL1Byb3ZpZGVzOiBNbE5vZGVEZXZpY2Vcbi8vUmVxdWlyZXM6IE1sTm9kZUZkLCBjYW1sX3JhaXNlX3N5c19lcnJvciwgY2FtbF9yYWlzZV93aXRoX2FyZ3Ncbi8vUmVxdWlyZXM6IG1ha2VfdW5peF9lcnJfYXJncywgY2FtbF9uYW1lZF92YWx1ZSwgY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmdcbmZ1bmN0aW9uIE1sTm9kZURldmljZShyb290KSB7XG4gIHRoaXMuZnMgPSByZXF1aXJlKCdmcycpO1xuICB0aGlzLnJvb3QgPSByb290O1xufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5ubSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgcmV0dXJuICh0aGlzLnJvb3QgKyBuYW1lKTtcbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUuZXhpc3RzID0gZnVuY3Rpb24obmFtZSkge1xuICB0cnkge1xuICAgIHJldHVybiB0aGlzLmZzLmV4aXN0c1N5bmModGhpcy5ubShuYW1lKSk/MTowO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5pc0ZpbGUgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHRoaXMuZnMuc3RhdFN5bmModGhpcy5ubShuYW1lKSkuaXNGaWxlKCk/MTowO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihlcnIudG9TdHJpbmcoKSk7XG4gIH1cbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUubWtkaXIgPSBmdW5jdGlvbihuYW1lLCBtb2RlLCByYWlzZV91bml4KSB7XG4gIHRyeSB7XG4gICAgdGhpcy5mcy5ta2RpclN5bmModGhpcy5ubShuYW1lKSx7bW9kZTptb2RlfSk7XG4gICAgcmV0dXJuIDBcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhpcy5yYWlzZV9ub2RlanNfZXJyb3IoZXJyLCByYWlzZV91bml4KTtcbiAgfVxufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5ybWRpciA9IGZ1bmN0aW9uKG5hbWUsIHJhaXNlX3VuaXgpIHtcbiAgdHJ5IHtcbiAgICB0aGlzLmZzLnJtZGlyU3luYyh0aGlzLm5tKG5hbWUpKTtcbiAgICByZXR1cm4gMFxuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aGlzLnJhaXNlX25vZGVqc19lcnJvcihlcnIsIHJhaXNlX3VuaXgpO1xuICB9XG59XG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLnJlYWRkaXIgPSBmdW5jdGlvbihuYW1lLCByYWlzZV91bml4KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHRoaXMuZnMucmVhZGRpclN5bmModGhpcy5ubShuYW1lKSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRoaXMucmFpc2Vfbm9kZWpzX2Vycm9yKGVyciwgcmFpc2VfdW5peCk7XG4gIH1cbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUuaXNfZGlyID0gZnVuY3Rpb24obmFtZSkge1xuICB0cnkge1xuICAgIHJldHVybiB0aGlzLmZzLnN0YXRTeW5jKHRoaXMubm0obmFtZSkpLmlzRGlyZWN0b3J5KCk/MTowO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihlcnIudG9TdHJpbmcoKSk7XG4gIH1cbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUudW5saW5rID0gZnVuY3Rpb24obmFtZSwgcmFpc2VfdW5peCkge1xuICB0cnkge1xuICAgIHZhciBiID0gdGhpcy5mcy5leGlzdHNTeW5jKHRoaXMubm0obmFtZSkpPzE6MDtcbiAgICB0aGlzLmZzLnVubGlua1N5bmModGhpcy5ubShuYW1lKSk7XG4gICAgcmV0dXJuIGI7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRoaXMucmFpc2Vfbm9kZWpzX2Vycm9yKGVyciwgcmFpc2VfdW5peCk7XG4gIH1cbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uKG5hbWUsIGYsIHJhaXNlX3VuaXgpIHtcbiAgdmFyIGNvbnN0cyA9IHJlcXVpcmUoJ2NvbnN0YW50cycpO1xuICB2YXIgcmVzID0gMDtcbiAgZm9yKHZhciBrZXkgaW4gZil7XG4gICAgc3dpdGNoKGtleSl7XG4gICAgY2FzZSBcInJkb25seVwiICA6IHJlcyB8PSBjb25zdHMuT19SRE9OTFk7IGJyZWFrO1xuICAgIGNhc2UgXCJ3cm9ubHlcIiAgOiByZXMgfD0gY29uc3RzLk9fV1JPTkxZOyBicmVhaztcbiAgICBjYXNlIFwiYXBwZW5kXCIgIDpcbiAgICAgIHJlcyB8PSBjb25zdHMuT19XUk9OTFkgfCBjb25zdHMuT19BUFBFTkQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiY3JlYXRlXCIgICA6IHJlcyB8PSBjb25zdHMuT19DUkVBVDsgICAgYnJlYWs7XG4gICAgY2FzZSBcInRydW5jYXRlXCIgOiByZXMgfD0gY29uc3RzLk9fVFJVTkM7ICAgIGJyZWFrO1xuICAgIGNhc2UgXCJleGNsXCIgICAgIDogcmVzIHw9IGNvbnN0cy5PX0VYQ0w7ICAgICBicmVhaztcbiAgICBjYXNlIFwiYmluYXJ5XCIgICA6IHJlcyB8PSBjb25zdHMuT19CSU5BUlk7ICAgYnJlYWs7XG4gICAgY2FzZSBcInRleHRcIiAgICAgOiByZXMgfD0gY29uc3RzLk9fVEVYVDsgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJub25ibG9ja1wiIDogcmVzIHw9IGNvbnN0cy5PX05PTkJMT0NLOyBicmVhaztcbiAgICB9XG4gIH1cbiAgdHJ5IHtcbiAgICB2YXIgZmQgPSB0aGlzLmZzLm9wZW5TeW5jKHRoaXMubm0obmFtZSksIHJlcyk7XG4gICAgdmFyIGlzQ2hhcmFjdGVyRGV2aWNlID0gdGhpcy5mcy5sc3RhdFN5bmModGhpcy5ubShuYW1lKSkuaXNDaGFyYWN0ZXJEZXZpY2UoKTtcbiAgICBmLmlzQ2hhcmFjdGVyRGV2aWNlID0gaXNDaGFyYWN0ZXJEZXZpY2U7XG4gICAgcmV0dXJuIG5ldyBNbE5vZGVGZChmZCwgZik7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRoaXMucmFpc2Vfbm9kZWpzX2Vycm9yKGVyciwgcmFpc2VfdW5peCk7XG4gIH1cbn1cblxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5yZW5hbWUgPSBmdW5jdGlvbihvLCBuLCByYWlzZV91bml4KSB7XG4gIHRyeSB7XG4gICAgdGhpcy5mcy5yZW5hbWVTeW5jKHRoaXMubm0obyksIHRoaXMubm0obikpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aGlzLnJhaXNlX25vZGVqc19lcnJvcihlcnIsIHJhaXNlX3VuaXgpO1xuICB9XG59XG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLnN0YXQgPSBmdW5jdGlvbihuYW1lLCByYWlzZV91bml4KSB7XG4gIHRyeSB7XG4gICAgdmFyIGpzX3N0YXRzID0gdGhpcy5mcy5zdGF0U3luYyh0aGlzLm5tKG5hbWUpKTtcbiAgICByZXR1cm4gdGhpcy5zdGF0c19mcm9tX2pzKGpzX3N0YXRzKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhpcy5yYWlzZV9ub2RlanNfZXJyb3IoZXJyLCByYWlzZV91bml4KTtcbiAgfVxufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5sc3RhdCA9IGZ1bmN0aW9uKG5hbWUsIHJhaXNlX3VuaXgpIHtcbiAgdHJ5IHtcbiAgICB2YXIganNfc3RhdHMgPSB0aGlzLmZzLmxzdGF0U3luYyh0aGlzLm5tKG5hbWUpKTtcbiAgICByZXR1cm4gdGhpcy5zdGF0c19mcm9tX2pzKGpzX3N0YXRzKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhpcy5yYWlzZV9ub2RlanNfZXJyb3IoZXJyLCByYWlzZV91bml4KTtcbiAgfVxufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5zeW1saW5rID0gZnVuY3Rpb24odG9fZGlyLCB0YXJnZXQsIHBhdGgsIHJhaXNlX3VuaXgpIHtcbiAgdHJ5IHtcbiAgICB0aGlzLmZzLnN5bWxpbmtTeW5jKHRoaXMubm0odGFyZ2V0KSwgdGhpcy5ubShwYXRoKSwgdG9fZGlyID8gJ2RpcicgOiAnZmlsZScpO1xuICAgIHJldHVybiAwO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aGlzLnJhaXNlX25vZGVqc19lcnJvcihlcnIsIHJhaXNlX3VuaXgpO1xuICB9XG59XG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLnJlYWRsaW5rID0gZnVuY3Rpb24obmFtZSwgcmFpc2VfdW5peCkge1xuICB0cnkge1xuICAgIHZhciBsaW5rID0gdGhpcy5mcy5yZWFkbGlua1N5bmModGhpcy5ubShuYW1lKSwgJ3V0ZjgnKTtcbiAgICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcobGluayk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRoaXMucmFpc2Vfbm9kZWpzX2Vycm9yKGVyciwgcmFpc2VfdW5peCk7XG4gIH1cbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUub3BlbmRpciA9IGZ1bmN0aW9uKG5hbWUsIHJhaXNlX3VuaXgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gdGhpcy5mcy5vcGVuZGlyU3luYyh0aGlzLm5tKG5hbWUpKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhpcy5yYWlzZV9ub2RlanNfZXJyb3IoZXJyLCByYWlzZV91bml4KTtcbiAgfVxufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5yYWlzZV9ub2RlanNfZXJyb3IgPSBmdW5jdGlvbihlcnIsIHJhaXNlX3VuaXgpIHtcbiAgdmFyIHVuaXhfZXJyb3IgPSBjYW1sX25hbWVkX3ZhbHVlKFwiVW5peC5Vbml4X2Vycm9yXCIpO1xuICBpZiAocmFpc2VfdW5peCAmJiB1bml4X2Vycm9yKSB7XG4gICAgdmFyIGFyZ3MgPSBtYWtlX3VuaXhfZXJyX2FyZ3MoZXJyLmNvZGUsIGVyci5zeXNjYWxsLCBlcnIucGF0aCwgZXJyLmVycm5vKTtcbiAgICBjYW1sX3JhaXNlX3dpdGhfYXJncyh1bml4X2Vycm9yLCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihlcnIudG9TdHJpbmcoKSk7XG4gIH1cbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUuc3RhdHNfZnJvbV9qcyA9IGZ1bmN0aW9uKGpzX3N0YXRzKSB7XG4gIC8qID09PVVuaXguZmlsZV9raW5kPT09XG4gICAqIHR5cGUgZmlsZV9raW5kID1cbiAgICogICAgIFNfUkVHICAgICAgICAgICAgICAgICAgICAgICAoKiogUmVndWxhciBmaWxlICopXG4gICAqICAgfCBTX0RJUiAgICAgICAgICAgICAgICAgICAgICAgKCoqIERpcmVjdG9yeSAqKVxuICAgKiAgIHwgU19DSFIgICAgICAgICAgICAgICAgICAgICAgICgqKiBDaGFyYWN0ZXIgZGV2aWNlICopXG4gICAqICAgfCBTX0JMSyAgICAgICAgICAgICAgICAgICAgICAgKCoqIEJsb2NrIGRldmljZSAqKVxuICAgKiAgIHwgU19MTksgICAgICAgICAgICAgICAgICAgICAgICgqKiBTeW1ib2xpYyBsaW5rICopXG4gICAqICAgfCBTX0ZJRk8gICAgICAgICAgICAgICAgICAgICAgKCoqIE5hbWVkIHBpcGUgKilcbiAgICogICB8IFNfU09DSyAgICAgICAgICAgICAgICAgICAgICAoKiogU29ja2V0ICopXG4gICAqL1xuICB2YXIgZmlsZV9raW5kO1xuICBpZiAoanNfc3RhdHMuaXNGaWxlKCkpIHtcbiAgICBmaWxlX2tpbmQgPSAwO1xuICB9IGVsc2UgaWYgKGpzX3N0YXRzLmlzRGlyZWN0b3J5KCkpIHtcbiAgICBmaWxlX2tpbmQgPSAxO1xuICB9IGVsc2UgaWYgKGpzX3N0YXRzLmlzQ2hhcmFjdGVyRGV2aWNlKCkpIHtcbiAgICBmaWxlX2tpbmQgPSAyO1xuICB9IGVsc2UgaWYgKGpzX3N0YXRzLmlzQmxvY2tEZXZpY2UoKSkge1xuICAgIGZpbGVfa2luZCA9IDM7XG4gIH0gZWxzZSBpZiAoanNfc3RhdHMuaXNTeW1ib2xpY0xpbmsoKSkge1xuICAgIGZpbGVfa2luZCA9IDQ7XG4gIH0gZWxzZSBpZiAoanNfc3RhdHMuaXNGSUZPKCkpIHtcbiAgICBmaWxlX2tpbmQgPSA1O1xuICB9IGVsc2UgaWYgKGpzX3N0YXRzLmlzU29ja2V0KCkpIHtcbiAgICBmaWxlX2tpbmQgPSA2O1xuICB9XG4gIC8qID09PVVuaXguc3RhdHM9PT1cbiAgICogdHlwZSBzdGF0cyA9XG4gICAqICB7IHN0X2RldiA6IGludDsgICAgICAgICAgICAgICAoKiogRGV2aWNlIG51bWJlciAqKVxuICAgKiAgICBzdF9pbm8gOiBpbnQ7ICAgICAgICAgICAgICAgKCoqIElub2RlIG51bWJlciAqKVxuICAgKiAgICBzdF9raW5kIDogZmlsZV9raW5kOyAgICAgICAgKCoqIEtpbmQgb2YgdGhlIGZpbGUgKilcbiAgICogICAgc3RfcGVybSA6IGZpbGVfcGVybTsgICAgICAgICgqKiBBY2Nlc3MgcmlnaHRzICopXG4gICAqICAgIHN0X25saW5rIDogaW50OyAgICAgICAgICAgICAoKiogTnVtYmVyIG9mIGxpbmtzICopXG4gICAqICAgIHN0X3VpZCA6IGludDsgICAgICAgICAgICAgICAoKiogVXNlciBpZCBvZiB0aGUgb3duZXIgKilcbiAgICogICAgc3RfZ2lkIDogaW50OyAgICAgICAgICAgICAgICgqKiBHcm91cCBJRCBvZiB0aGUgZmlsZSdzIGdyb3VwICopXG4gICAqICAgIHN0X3JkZXYgOiBpbnQ7ICAgICAgICAgICAgICAoKiogRGV2aWNlIElEIChpZiBzcGVjaWFsIGZpbGUpICopXG4gICAqICAgIHN0X3NpemUgOiBpbnQ7ICAgICAgICAgICAgICAoKiogU2l6ZSBpbiBieXRlcyAqKVxuICAgKiAgICBzdF9hdGltZSA6IGZsb2F0OyAgICAgICAgICAgKCoqIExhc3QgYWNjZXNzIHRpbWUgKilcbiAgICogICAgc3RfbXRpbWUgOiBmbG9hdDsgICAgICAgICAgICgqKiBMYXN0IG1vZGlmaWNhdGlvbiB0aW1lICopXG4gICAqICAgIHN0X2N0aW1lIDogZmxvYXQ7ICAgICAgICAgICAoKiogTGFzdCBzdGF0dXMgY2hhbmdlIHRpbWUgKilcbiAgICogIH1cbiAgICovXG4gIHJldHVybiBCTE9DSyhcbiAgICAwLFxuICAgIGpzX3N0YXRzLmRldixcbiAgICBqc19zdGF0cy5pbm8sXG4gICAgZmlsZV9raW5kLFxuICAgIGpzX3N0YXRzLm1vZGUsXG4gICAganNfc3RhdHMubmxpbmssXG4gICAganNfc3RhdHMudWlkLFxuICAgIGpzX3N0YXRzLmdpZCxcbiAgICBqc19zdGF0cy5yZGV2LFxuICAgIGpzX3N0YXRzLnNpemUsXG4gICAganNfc3RhdHMuYXRpbWVNcyxcbiAgICBqc19zdGF0cy5tdGltZU1zLFxuICAgIGpzX3N0YXRzLmN0aW1lTXNcbiAgKTtcbn1cblxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1sTm9kZURldmljZVxuXG4vL1Byb3ZpZGVzOiBNbE5vZGVEZXZpY2Vcbi8vSWY6IGJyb3dzZXJcbmZ1bmN0aW9uIE1sTm9kZURldmljZSgpIHtcbn1cblxuLy9Qcm92aWRlczogTWxOb2RlRmRcbi8vUmVxdWlyZXM6IE1sRmlsZSwgY2FtbF91aW50OF9hcnJheV9vZl9zdHJpbmcsIGNhbWxfdWludDhfYXJyYXlfb2ZfYnl0ZXMsIGNhbWxfYnl0ZXNfc2V0LCBjYW1sX3JhaXNlX3N5c19lcnJvclxuZnVuY3Rpb24gTWxOb2RlRmQoZmQsIGZsYWdzKXtcbiAgdGhpcy5mcyA9IHJlcXVpcmUoJ2ZzJyk7XG4gIHRoaXMuZmQgPSBmZDtcbiAgdGhpcy5mbGFncyA9IGZsYWdzO1xufVxuTWxOb2RlRmQucHJvdG90eXBlID0gbmV3IE1sRmlsZSAoKTtcbk1sTm9kZUZkLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1sTm9kZUZkO1xuXG5NbE5vZGVGZC5wcm90b3R5cGUudHJ1bmNhdGUgPSBmdW5jdGlvbihsZW4pe1xuICB0cnkge1xuICAgIHRoaXMuZnMuZnRydW5jYXRlU3luYyh0aGlzLmZkLGxlbnwwKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoZXJyLnRvU3RyaW5nKCkpO1xuICB9XG59XG5NbE5vZGVGZC5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIHJldHVybiB0aGlzLmZzLmZzdGF0U3luYyh0aGlzLmZkKS5zaXplO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihlcnIudG9TdHJpbmcoKSk7XG4gIH1cbn1cbk1sTm9kZUZkLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKG9mZnNldCxidWYsYnVmX29mZnNldCxsZW4pe1xuICB0cnkge1xuICAgIGlmKHRoaXMuZmxhZ3MuaXNDaGFyYWN0ZXJEZXZpY2UpXG4gICAgICB0aGlzLmZzLndyaXRlU3luYyh0aGlzLmZkLCBidWYsIGJ1Zl9vZmZzZXQsIGxlbik7XG4gICAgZWxzZVxuICAgICAgdGhpcy5mcy53cml0ZVN5bmModGhpcy5mZCwgYnVmLCBidWZfb2Zmc2V0LCBsZW4sIG9mZnNldCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKGVyci50b1N0cmluZygpKTtcbiAgfVxuICByZXR1cm4gMDtcbn1cbk1sTm9kZUZkLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24ob2Zmc2V0LGEsYnVmX29mZnNldCxsZW4pe1xuICB0cnkge1xuICAgIGlmKHRoaXMuZmxhZ3MuaXNDaGFyYWN0ZXJEZXZpY2UpXG4gICAgICB2YXIgcmVhZCA9IHRoaXMuZnMucmVhZFN5bmModGhpcy5mZCwgYSwgYnVmX29mZnNldCwgbGVuKTtcbiAgICBlbHNlXG4gICAgICB2YXIgcmVhZCA9IHRoaXMuZnMucmVhZFN5bmModGhpcy5mZCwgYSwgYnVmX29mZnNldCwgbGVuLCBvZmZzZXQpO1xuICAgIHJldHVybiByZWFkO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihlcnIudG9TdHJpbmcoKSk7XG4gIH1cbn1cbk1sTm9kZUZkLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCl7XG4gIHRyeSB7XG4gICAgdGhpcy5mcy5jbG9zZVN5bmModGhpcy5mZCk7XG4gICAgcmV0dXJuIDBcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoZXJyLnRvU3RyaW5nKCkpO1xuICB9XG59XG5cblxuLy9Qcm92aWRlczogTWxOb2RlRmRcbi8vSWY6IGJyb3dzZXJcbmZ1bmN0aW9uIE1sTm9kZUZkKCl7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfb3Blbl9mb3Jfbm9kZVxuLy9SZXF1aXJlczogTWxOb2RlRmRcbmZ1bmN0aW9uIGNhbWxfc3lzX29wZW5fZm9yX25vZGUoZmQsIGZsYWdzKXtcbiAgaWYoZmxhZ3MubmFtZSkge1xuICAgIHRyeSB7XG4gICAgICB2YXIgZnMgPSByZXF1aXJlKFwiZnNcIik7XG4gICAgICB2YXIgZmQyID0gZnMub3BlblN5bmMoZmxhZ3MubmFtZSwgXCJyc1wiKTtcbiAgICAgIHJldHVybiBuZXcgTWxOb2RlRmQoZmQyLCBmbGFncyk7XG4gICAgfSBjYXRjaChlKSB7ICB9XG4gIH1cbiAgcmV0dXJuIG5ldyBNbE5vZGVGZChmZCwgZmxhZ3MpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19vcGVuX2Zvcl9ub2RlXG4vL0lmOiBicm93c2VyXG5mdW5jdGlvbiBjYW1sX3N5c19vcGVuX2Zvcl9ub2RlKGZkLCBmbGFncyl7XG4gIHJldHVybiBudWxsO1xufVxuIiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogICAgQ29weXJpZ2h0IDIwMjIgT0NhbWxQcm8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogIEFsbCByaWdodHMgcmVzZXJ2ZWQuIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlICAqL1xuLyogIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgc3BlY2lhbCAgICAgICAqL1xuLyogIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAgICAgICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cblxuLyogVXRpbGl0eSBmdW5jdGlvbnMgKi9cblxuLy9Qcm92aWRlczogX21sX2NhbnZhc19pbml0aWFsaXplZFxudmFyIF9tbF9jYW52YXNfaW5pdGlhbGl6ZWQgPSBmYWxzZTtcblxuLy9Qcm92aWRlczogX21sX2NhbnZhc19lbnN1cmVfaW5pdGlhbGl6ZWRcbi8vUmVxdWlyZXM6IF9tbF9jYW52YXNfaW5pdGlhbGl6ZWRcbi8vUmVxdWlyZXM6IGNhbWxfbmFtZWRfdmFsdWUsIGNhbWxfcmFpc2VfY29uc3RhbnRcbmZ1bmN0aW9uIF9tbF9jYW52YXNfZW5zdXJlX2luaXRpYWxpemVkKCkge1xuICBpZiAoX21sX2NhbnZhc19pbml0aWFsaXplZCA9PSBmYWxzZSkge1xuICAgIGNhbWxfcmFpc2VfY29uc3RhbnQoY2FtbF9uYW1lZF92YWx1ZShcIk5vdF9pbml0aWFsaXplZFwiKSk7XG4gIH1cbn1cblxuLy9Qcm92aWRlczogX21sX2NhbnZhc192YWxpZF9jYW52YXNfc2l6ZVxuZnVuY3Rpb24gX21sX2NhbnZhc192YWxpZF9jYW52YXNfc2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gIHJldHVybiAwIDwgd2lkdGggJiYgd2lkdGggPD0gMzI3NjcgJiYgMCA8IGhlaWdodCAmJiBoZWlnaHQgPD0gMzI3Njc7XG59XG5cbi8vIFByb3ZpZGVzOiBfaW50ZXJuYWxfY2FudmFzXG52YXIgX2ludGVybmFsX2NhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG5cbi8vIFByb3ZpZGVzOiBfaW50ZXJuYWxfY3R4dFxuLy8gUmVxdWlyZXM6IF9pbnRlcm5hbF9jYW52YXNcbnZhciBfaW50ZXJuYWxfY3R4dCA9IF9pbnRlcm5hbF9jYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuXG5cblxuLyogSlMgRXZlbnQgaGFuZGxlcnMgKi9cblxuLy9Qcm92aWRlczogX2ZvY3VzXG52YXIgX2ZvY3VzID0gbnVsbDtcblxuLy9Qcm92aWRlczogX21vdmVcbnZhciBfbW92ZSA9IHtcbiAgbW92aW5nOiBmYWxzZSxcbiAgdGFyZ2V0OiBudWxsLFxuICBwcmV2X3g6IDAsXG4gIHByZXZfeTogMFxufVxuXG4vL1Byb3ZpZGVzOiBfcmVzaXplXG4vL1JlcXVpcmVzOiBfcmVzaXplX2hhbmRsZXJcbnZhciBfcmVzaXplID0gbmV3IHdpbmRvdy5SZXNpemVPYnNlcnZlcihfcmVzaXplX2hhbmRsZXIpO1xuXG4vL1Byb3ZpZGVzOiBfZXZlbnRfY2FudmFzX3NjYWxlXG5mdW5jdGlvbiBfZXZlbnRfY2FudmFzX3NjYWxlKGUpIHtcbiAgICByZXR1cm4geyBzY2FsZVggOiBlLnRhcmdldC5jYW52YXMud2lkdGggLyBlLnRhcmdldC5jbGllbnRXaWR0aCxcbiAgICAgICAgICAgICBzY2FsZVkgOiBlLnRhcmdldC5jYW52YXMuaGVpZ2h0IC8gZS50YXJnZXQuY2xpZW50SGVpZ2h0XG4gICAgICAgICAgIH1cbn1cblxuLy9Qcm92aWRlczogX21ha2Vfa2V5X2V2ZW50XG4vL1JlcXVpcmVzOiBfZm9jdXMsIGtleW5hbWVfdG9fa2V5Y29kZSwgVmFsX2tleV9jb2RlLCBWYWxfa2V5X3N0YXRlLCBFVkVOVF9UQUdcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfZmxvYXRcbmZ1bmN0aW9uIF9tYWtlX2tleV9ldmVudChlLCBzdGF0ZSkge1xuICB2YXIgY2hhciA9IChlLmtleS5sZW5ndGggPT09IDEpID8gZS5rZXkuY2hhckNvZGVBdCgwKSA6IDA7XG4gIHZhciBmbGFncyA9IFswLCBlLnNoaWZ0S2V5LCBlLmFsdEtleSwgZS5jdHJsS2V5LCBlLm1ldGFLZXksXG4gICAgICAgICAgICAgICAgICBlLmdldE1vZGlmaWVyU3RhdGUoXCJDYXBzTG9ja1wiKSxcbiAgICAgICAgICAgICAgICAgIGUuZ2V0TW9kaWZpZXJTdGF0ZShcIk51bUxvY2tcIiksXG4gICAgICAgICAgICAgICAgICAoZS5rZXkgPT09IFwiRGVhZFwiKV07XG4gIHZhciBldnQgPSBbRVZFTlRfVEFHLktFWV9BQ1RJT04sXG4gICAgICAgICAgICAgWzAsIF9mb2N1cywgY2FtbF9pbnQ2NF9vZl9mbG9hdChlLnRpbWVTdGFtcCAqIDEwMDAuMCksXG4gICAgICAgICAgICAgIFZhbF9rZXlfY29kZShrZXluYW1lX3RvX2tleWNvZGUoZS5jb2RlKSksXG4gICAgICAgICAgICAgIGNoYXIsIGZsYWdzLCBWYWxfa2V5X3N0YXRlKHN0YXRlKV1dO1xuICByZXR1cm4gZXZ0O1xufVxuXG4vL1Byb3ZpZGVzOiBfa2V5X2Rvd25faGFuZGxlclxuLy9SZXF1aXJlczogX2ZvY3VzLCBfbWFrZV9rZXlfZXZlbnQsIF9tbF9jYW52YXNfcHJvY2Vzc19ldmVudCwgS0VZX1NUQVRFXG5mdW5jdGlvbiBfa2V5X2Rvd25faGFuZGxlcihlKSB7XG4gIGlmIChfZm9jdXMgIT09IG51bGwpIHtcbiAgICB2YXIgZXZ0ID0gX21ha2Vfa2V5X2V2ZW50KGUsIEtFWV9TVEFURS5ET1dOKTtcbiAgICBfbWxfY2FudmFzX3Byb2Nlc3NfZXZlbnQoZXZ0KTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vUHJvdmlkZXM6IF9rZXlfdXBfaGFuZGxlclxuLy9SZXF1aXJlczogX2ZvY3VzLCBfbWFrZV9rZXlfZXZlbnQsIF9tbF9jYW52YXNfcHJvY2Vzc19ldmVudCwgS0VZX1NUQVRFXG5mdW5jdGlvbiBfa2V5X3VwX2hhbmRsZXIoZSkge1xuICBpZiAoX2ZvY3VzICE9PSBudWxsKSB7XG4gICAgdmFyIGV2dCA9IF9tYWtlX2tleV9ldmVudChlLCBLRVlfU1RBVEUuVVApO1xuICAgIF9tbF9jYW52YXNfcHJvY2Vzc19ldmVudChldnQpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy9Qcm92aWRlczogX2hlYWRlcl9kb3duX2hhbmRsZXJcbi8vUmVxdWlyZXM6IF9mb2N1cywgX21vdmUsIG1sX2NhbnZhc19jbG9zZSwgX21sX2NhbnZhc19wcm9jZXNzX2V2ZW50LCBFVkVOVF9UQUdcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfZmxvYXRcbmZ1bmN0aW9uIF9oZWFkZXJfZG93bl9oYW5kbGVyKGUpIHtcbiAgaWYgKGUudGFyZ2V0ICE9PSBudWxsKSB7XG4gICAgX2ZvY3VzID0gZS50YXJnZXQuY2FudmFzO1xuICAgIGlmICgoZS5vZmZzZXRYID49IGUudGFyZ2V0LmNhbnZhcy53aWR0aCAtIDIwKSAmJlxuICAgICAgICAoZS5vZmZzZXRYIDw9IGUudGFyZ2V0LmNhbnZhcy53aWR0aCAtIDEwKSAmJlxuICAgICAgICAoZS5vZmZzZXRZID49IDEwKSAmJiAoZS5vZmZzZXRZIDw9IDIwKSkge1xuICAgICAgdmFyIGV2dCA9IFtFVkVOVF9UQUcuQ0FOVkFTX0NMT1NFRCxcbiAgICAgICAgICAgICAgICAgWzAsIGUudGFyZ2V0LmNhbnZhcyxcbiAgICAgICAgICAgICAgICAgIGNhbWxfaW50NjRfb2ZfZmxvYXQoZS50aW1lU3RhbXAgKiAxMDAwLjApXV07XG4gICAgICBfbWxfY2FudmFzX3Byb2Nlc3NfZXZlbnQoZXZ0KTtcbiAgICAgIG1sX2NhbnZhc19jbG9zZShlLnRhcmdldC5jYW52YXMpO1xuICAgICAgX2ZvY3VzID0gbnVsbDtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgX21vdmUubW92aW5nID0gdHJ1ZTtcbiAgICBfbW92ZS50YXJnZXQgPSBlLnRhcmdldC5jYW52YXMuZnJhbWU7XG4gICAgX21vdmUucHJldl94ID0gZS5wYWdlWDtcbiAgICBfbW92ZS5wcmV2X3kgPSBlLnBhZ2VZO1xuICAgIGUudGFyZ2V0LmNhbnZhcy50YXJnZXQuaW5zZXJ0QmVmb3JlKF9tb3ZlLnRhcmdldCwgbnVsbCk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vL1Byb3ZpZGVzOiBfc3VyZmFjZV9kb3duX2hhbmRsZXJcbi8vUmVxdWlyZXM6IF9mb2N1cywgX21sX2NhbnZhc19wcm9jZXNzX2V2ZW50LCBfZXZlbnRfY2FudmFzX3NjYWxlLCBFVkVOVF9UQUdcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfZmxvYXRcbmZ1bmN0aW9uIF9zdXJmYWNlX2Rvd25faGFuZGxlcihlKSB7XG4gIGlmIChlLnRhcmdldCAhPT0gbnVsbCkge1xuICAgIF9mb2N1cyA9IGUudGFyZ2V0LmNhbnZhcztcbiAgICBlLnRhcmdldC5jYW52YXMudGFyZ2V0Lmluc2VydEJlZm9yZShlLnRhcmdldC5jYW52YXMuZnJhbWUsIG51bGwpO1xuICAgIHZhciBzID0gX2V2ZW50X2NhbnZhc19zY2FsZShlKTtcbiAgICB2YXIgZXZ0ID0gW0VWRU5UX1RBRy5CVVRUT05fQUNUSU9OLFxuICAgICAgICAgICAgICAgWzAsIGUudGFyZ2V0LmNhbnZhcyxcbiAgICAgICAgICAgICAgICBjYW1sX2ludDY0X29mX2Zsb2F0KGUudGltZVN0YW1wICogMTAwMC4wKSxcbiAgICAgICAgICAgICAgICBbMCwgZS5vZmZzZXRYKnMuc2NhbGVYLCBlLm9mZnNldFkqcy5zY2FsZVldLCBlLmJ1dHRvbiArIDEsIDFdXTtcbiAgICBfbWxfY2FudmFzX3Byb2Nlc3NfZXZlbnQoZXZ0KTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vUHJvdmlkZXM6IF91cF9oYW5kbGVyXG4vL1JlcXVpcmVzOiBfbW92ZSwgX21sX2NhbnZhc19wcm9jZXNzX2V2ZW50LCBfZXZlbnRfY2FudmFzX3NjYWxlLCBFVkVOVF9UQUdcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfZmxvYXRcbmZ1bmN0aW9uIF91cF9oYW5kbGVyKGUpIHtcbiAgX21vdmUubW92aW5nID0gZmFsc2U7XG4gIGlmIChlLnRhcmdldC5jYW52YXMgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBzID0gX2V2ZW50X2NhbnZhc19zY2FsZShlKTtcbiAgICB2YXIgZXZ0ID0gW0VWRU5UX1RBRy5CVVRUT05fQUNUSU9OLFxuICAgICAgICAgICAgICAgWzAsIGUudGFyZ2V0LmNhbnZhcyxcbiAgICAgICAgICAgICAgICBjYW1sX2ludDY0X29mX2Zsb2F0KGUudGltZVN0YW1wICogMTAwMC4wKSxcbiAgICAgICAgICAgICAgICBbMCwgZS5vZmZzZXRYKnMuc2NhbGVYLCBlLm9mZnNldFkqcy5zY2FsZVldLCBlLmJ1dHRvbiArIDEsIDBdXTtcbiAgICBfbWxfY2FudmFzX3Byb2Nlc3NfZXZlbnQoZXZ0KTtcbiAgfVxuICByZXR1cm4gZmFsc2U7IC8vID0gcHJldmVudCBkZWZhdWx0IGJlaGF2aW9yXG59XG5cbi8vUHJvdmlkZXM6IF9tb3ZlX2hhbmRsZXJcbi8vUmVxdWlyZXM6IF9tb3ZlLCBfbWxfY2FudmFzX3Byb2Nlc3NfZXZlbnQsIF9ldmVudF9jYW52YXNfc2NhbGUsIEVWRU5UX1RBR1xuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZl9mbG9hdFxuZnVuY3Rpb24gX21vdmVfaGFuZGxlcihlKSB7XG4gIGlmIChfbW92ZS5tb3ZpbmcpIHtcbiAgICB2YXIgbmV3X3ggPSBlLnBhZ2VYO1xuICAgIHZhciBuZXdfeSA9IGUucGFnZVk7XG4gICAgdmFyIGR4ID0gbmV3X3ggLSBfbW92ZS5wcmV2X3g7XG4gICAgdmFyIGR5ID0gbmV3X3kgLSBfbW92ZS5wcmV2X3k7XG4gICAgX21vdmUucHJldl94ID0gbmV3X3g7XG4gICAgX21vdmUucHJldl95ID0gbmV3X3k7XG4gICAgdmFyIGNhbnZhcyA9IF9tb3ZlLnRhcmdldC5jYW52YXM7XG4gICAgY2FudmFzLnggKz0gZHg7XG4gICAgY2FudmFzLnkgKz0gZHk7XG4gICAgX21vdmUudGFyZ2V0LnN0eWxlLmxlZnQgPSBjYW52YXMueCArIFwicHhcIjtcbiAgICBfbW92ZS50YXJnZXQuc3R5bGUudG9wID0gY2FudmFzLnkgKyBcInB4XCI7XG4gIH0gZWxzZSBpZiAoZS50YXJnZXQuY2FudmFzICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgcyA9IF9ldmVudF9jYW52YXNfc2NhbGUoZSk7XG4gICAgdmFyIGV2dCA9IFtFVkVOVF9UQUcuTU9VU0VfTU9WRSxcbiAgICAgICAgICAgICAgIFswLCBlLnRhcmdldC5jYW52YXMsXG4gICAgICAgICAgICAgICAgY2FtbF9pbnQ2NF9vZl9mbG9hdChlLnRpbWVTdGFtcCAqIDEwMDAuMCksXG4gICAgICAgICAgICAgICAgWzAsIGUub2Zmc2V0WCpzLnNjYWxlWCwgZS5vZmZzZXRZKnMuc2NhbGVZXV1dO1xuICAgIF9tbF9jYW52YXNfcHJvY2Vzc19ldmVudChldnQpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy9Qcm92aWRlczogX3Jlc2l6ZV9oYW5kbGVyXG4vL1JlcXVpcmVzOiBfbWxfY2FudmFzX3Byb2Nlc3NfZXZlbnQsIEVWRU5UX1RBR1xuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZl9mbG9hdFxuZnVuY3Rpb24gX3Jlc2l6ZV9oYW5kbGVyKGVudHJpZXMpIHtcbiAgZW50cmllcy5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIGV2dCA9IFtFVkVOVF9UQUcuQ0FOVkFTX1JFU0laRUQsXG4gICAgICAgICAgICAgICBbMCwgZS50YXJnZXQuY2FudmFzLFxuICAgICAgICAgICAgICAgIGNhbWxfaW50NjRfb2ZfZmxvYXQoZS50aW1lU3RhbXAgKiAxMDAwLjApLFxuICAgICAgICAgICAgICAgIFswLCBlLnRhcmdldC5jbGllbnRXaWR0aCwgZS50YXJnZXQuY2xpZW50SGVpZ2h0XV1dO1xuICAgIF9tbF9jYW52YXNfcHJvY2Vzc19ldmVudChldnQpO1xuICB9KTtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vL1Byb3ZpZGVzOiBfZnJhbWVfaGFuZGxlclxuLy9SZXF1aXJlczogX21sX2NhbnZhc19wcm9jZXNzX2V2ZW50LCBFVkVOVF9UQUdcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfZmxvYXRcbmZ1bmN0aW9uIF9mcmFtZV9oYW5kbGVyKHRpbWVzdGFtcCkge1xuICB2YXIgc3VyZmFjZXMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImNhbnZhc1wiKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdXJmYWNlcy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBldnQgPSBbRVZFTlRfVEFHLkZSQU1FLFxuICAgICAgICAgICAgICAgWzAsIHN1cmZhY2VzW2ldLmNhbnZhcyxcbiAgICAgICAgICAgICAgICBjYW1sX2ludDY0X29mX2Zsb2F0KHRpbWVzdGFtcCAqIDEwMDAuMCldXTtcbiAgICBfbWxfY2FudmFzX3Byb2Nlc3NfZXZlbnQoZXZ0KTtcbiAgfVxuICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKF9mcmFtZV9oYW5kbGVyKTtcbn1cblxuXG5cbi8qIEltYWdlIERhdGEgKGFrYSBQaXhtYXBzKSAqL1xuXG4vL1Byb3ZpZGVzOiBfbWxfY2FudmFzX2ltYWdlX29mX3BuZ19maWxlXG4vL1JlcXVpcmVzOiBjYW1sX3JlYWRfZmlsZV9jb250ZW50LCBjYW1sX3JhaXNlX3dpdGhfc3RyaW5nLCBjYW1sX25hbWVkX3ZhbHVlXG5mdW5jdGlvbiBfbWxfY2FudmFzX2ltYWdlX29mX3BuZ19maWxlKGZpbGVuYW1lKSB7XG4gIHZhciBmaWxlID0gY2FtbF9yZWFkX2ZpbGVfY29udGVudChmaWxlbmFtZSk7XG4gIGlmIChmaWxlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIGZjID0gY2FtbF9yZWFkX2ZpbGVfY29udGVudChmaWxlbmFtZSk7XG4gIC8vIFRlc3QgZm9yIG1sQnl0ZXMgb3IgSlMtc3RyaW5nXG4gIHZhciBkYXRhID0gd2luZG93LmJ0b2EoZmMuYyA9PT0gdW5kZWZpbmVkID8gZmMgOiBmYy5jKTtcbiAgdmFyIGltZyA9IG5ldyB3aW5kb3cuSW1hZ2UoKTtcbiAgaW1nLmxvYWRpbmcgPSAnZWFnZXInO1xuICBpbWcuZGVjb2RpbmcgPSAnc3luYyc7XG4gIGltZy5zcmMgPSAnZGF0YTppbWFnZS9wbmc7YmFzZTY0LCcgKyBkYXRhO1xuICByZXR1cm4gW2ltZy5kZWNvZGUoKSwgaW1nXTtcbn1cblxuLy9Qcm92aWRlczogX21sX2NhbnZhc19iYV9vZl9pbWdcbi8vUmVxdWlyZXM6IGNhbWxfYmFfY3JlYXRlX3Vuc2FmZVxuZnVuY3Rpb24gX21sX2NhbnZhc19iYV9vZl9pbWcoaW1nKSB7XG4gIHZhciBzdXJmYWNlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgc3VyZmFjZS53aWR0aCA9IGltZy53aWR0aDtcbiAgc3VyZmFjZS5oZWlnaHQgPSBpbWcuaGVpZ2h0O1xuICB2YXIgY3R4dCA9IHN1cmZhY2UuZ2V0Q29udGV4dChcIjJkXCIpO1xuICBjdHh0LmRyYXdJbWFnZShpbWcsIDAsIDApO1xuICB2YXIgaW1hZ2UgPSBjdHh0LmdldEltYWdlRGF0YSgwLCAwLCBpbWcud2lkdGgsIGltZy5oZWlnaHQpO1xuICB2YXIgc3RhID0gbmV3IHdpbmRvdy5VaW50OEFycmF5KGltYWdlLmRhdGEuYnVmZmVyKTtcbiAgdmFyIGR0YSA9IG5ldyB3aW5kb3cuVWludDhBcnJheShzdGEubGVuZ3RoKTtcbiAgLy8gQ29udmVydCBmcm9tIFJHQkEgdG8gQkdSQVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YS5sZW5ndGg7IGkgKz0gNCkge1xuICAgIGR0YVtpKzBdID0gc3RhW2krMl07XG4gICAgZHRhW2krMV0gPSBzdGFbaSsxXTtcbiAgICBkdGFbaSsyXSA9IHN0YVtpKzBdO1xuICAgIGR0YVtpKzNdID0gc3RhW2krM107XG4gIH1cbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZSgzIC8qIFVpbnQ4QXJyYXkgKi8sIDAgLyogY19sYXlvdXQgKi8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2ltZy5oZWlnaHQsIGltZy53aWR0aCwgNF0sIGR0YSk7XG59XG5cbi8vUHJvdmlkZXM6IF9tbF9jYW52YXNfc3VyZmFjZV9vZl9iYVxuLy9SZXF1aXJlczogY2FtbF9iYV9kaW0sIGNhbWxfYmFfdG9fdHlwZWRfYXJyYXlcbmZ1bmN0aW9uIF9tbF9jYW52YXNfc3VyZmFjZV9vZl9iYShkYXRhKSB7XG4gIHZhciBzdXJmYWNlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgc3VyZmFjZS53aWR0aCA9IGNhbWxfYmFfZGltKGRhdGEsIDEpO1xuICBzdXJmYWNlLmhlaWdodCA9IGNhbWxfYmFfZGltKGRhdGEsIDApO1xuICB2YXIgY3R4dCA9IHN1cmZhY2UuZ2V0Q29udGV4dChcIjJkXCIpO1xuICB2YXIgc3RhID0gbmV3IHdpbmRvdy5VaW50OEFycmF5KGNhbWxfYmFfdG9fdHlwZWRfYXJyYXkoZGF0YSkuYnVmZmVyKTtcbiAgdmFyIGR0YSA9IG5ldyB3aW5kb3cuVWludDhDbGFtcGVkQXJyYXkoc3RhLmxlbmd0aCk7XG4gIC8vIENvbnZlcnQgZnJvbSBCR1JBIHRvIFJHQkFcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGEubGVuZ3RoOyBpICs9IDQpIHtcbiAgICBkdGFbaSswXSA9IHN0YVtpKzJdO1xuICAgIGR0YVtpKzFdID0gc3RhW2krMV07XG4gICAgZHRhW2krMl0gPSBzdGFbaSswXTtcbiAgICBkdGFbaSszXSA9IHN0YVtpKzNdO1xuICB9XG4gIGlmICh3aW5kb3cuSW1hZ2VEYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgaW1hZ2UgPSBjdHh0LmNyZWF0ZUltYWdlRGF0YShzdXJmYWNlLndpZHRoLCBzdXJmYWNlLmhlaWdodCk7XG4gICAgaW1hZ2UuZGF0YS5zZXQoZHRhKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgaW1hZ2UgPSBuZXcgd2luZG93LkltYWdlRGF0YShkdGEsIHN1cmZhY2Uud2lkdGgsIHN1cmZhY2UuaGVpZ2h0KTtcbiAgfVxuICBjdHh0LnB1dEltYWdlRGF0YShpbWFnZSwgMCwgMCk7XG4gIHJldHVybiBzdXJmYWNlO1xufVxuXG4vL1Byb3ZpZGVzOiBtbF9jYW52YXNfaW1hZ2VfZGF0YV9jcmVhdGVfZnJvbV9wbmdcbi8vUmVxdWlyZXM6IF9tbF9jYW52YXNfZW5zdXJlX2luaXRpYWxpemVkLCBfbWxfY2FudmFzX2ltYWdlX29mX3BuZ19maWxlLCBfbWxfY2FudmFzX2JhX29mX2ltZ1xuLy9SZXF1aXJlczogY2FtbF9yYWlzZV93aXRoX3N0cmluZywgY2FtbF9uYW1lZF92YWx1ZVxuZnVuY3Rpb24gbWxfY2FudmFzX2ltYWdlX2RhdGFfY3JlYXRlX2Zyb21fcG5nKGZpbGVuYW1lLCBvbmxvYWQpIHtcbiAgX21sX2NhbnZhc19lbnN1cmVfaW5pdGlhbGl6ZWQoKTtcbiAgdmFyIGltZyA9IF9tbF9jYW52YXNfaW1hZ2Vfb2ZfcG5nX2ZpbGUoZmlsZW5hbWUpO1xuICBpZiAoaW1nID09PSBudWxsKSB7XG4gICAgY2FtbF9yYWlzZV93aXRoX3N0cmluZyhjYW1sX25hbWVkX3ZhbHVlKFwiUmVhZF9wbmdfZmFpbGVkXCIpLCBmaWxlbmFtZSk7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgaW1nWzBdLnRoZW4oZnVuY3Rpb24gKF9faW1nKSB7XG4gICAgdmFyIGJhID0gX21sX2NhbnZhc19iYV9vZl9pbWcoaW1nWzFdKTtcbiAgICBvbmxvYWQoYmEpO1xuICAgIHJldHVybiAwO1xuICB9KTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IG1sX2NhbnZhc19pbWFnZV9kYXRhX2dldF9zaXplXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2RpbVxuZnVuY3Rpb24gbWxfY2FudmFzX2ltYWdlX2RhdGFfZ2V0X3NpemUoZGF0YSkge1xuICByZXR1cm4gWzAsIGNhbWxfYmFfZGltKGRhdGEsIDEpLCBjYW1sX2JhX2RpbShkYXRhLCAwKV07XG59XG5cbi8vUHJvdmlkZXM6IG1sX2NhbnZhc19pbWFnZV9kYXRhX2ZpbGxcbi8vUmVxdWlyZXM6IGNhbWxfYmFfdG9fdHlwZWRfYXJyYXlcbmZ1bmN0aW9uIG1sX2NhbnZhc19pbWFnZV9kYXRhX2ZpbGwoZGF0YSwgY29sb3IpIHtcbiAgdmFyIHRhID0gbmV3IHdpbmRvdy5VaW50MzJBcnJheShjYW1sX2JhX3RvX3R5cGVkX2FycmF5KGRhdGEpLmJ1ZmZlcik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGEubGVuZ3RoOyBpKyspIHtcbiAgICB0YVtpXSA9IGNvbG9yO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBfbWxfY2FudmFzX2FkanVzdF9ibGl0X2luZm9cbmZ1bmN0aW9uIF9tbF9jYW52YXNfYWRqdXN0X2JsaXRfaW5mbyhkd2lkdGgsIGRoZWlnaHQsIGR4LCBkeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2lkdGgsIHNoZWlnaHQsIHN4LCBzeSwgd2lkdGgsIGhlaWdodCkge1xuICBpZiAoZHggPCAwKSB7IHN4IC09IGR4OyB3aWR0aCAgKz0gZHg7IGR4ID0gMDsgfVxuICBpZiAoZHkgPCAwKSB7IHN5IC09IGR5OyBoZWlnaHQgKz0gZHk7IGR5ID0gMDsgfVxuICBpZiAoc3ggPCAwKSB7IGR4IC09IHN4OyB3aWR0aCAgKz0gc3g7IHN4ID0gMDsgfVxuICBpZiAoc3kgPCAwKSB7IGR5IC09IHN5OyBoZWlnaHQgKz0gc3k7IHN5ID0gMDsgfVxuICBpZiAoZHggKyB3aWR0aCAgPiBkd2lkdGgpICB7IHdpZHRoICA9IGR3aWR0aCAgLSBkeDsgfVxuICBpZiAoZHkgKyBoZWlnaHQgPiBkaGVpZ2h0KSB7IGhlaWdodCA9IGRoZWlnaHQgLSBkeTsgfVxuICBpZiAoc3ggKyB3aWR0aCAgPiBzd2lkdGgpICB7IHdpZHRoICA9IHN3aWR0aCAgLSBzeDsgfVxuICBpZiAoc3kgKyBoZWlnaHQgPiBzaGVpZ2h0KSB7IGhlaWdodCA9IHNoZWlnaHQgLSBzeTsgfVxuICByZXR1cm4gW2R4LCBkeSwgc3gsIHN5LCB3aWR0aCwgaGVpZ2h0XTtcbn1cblxuLy9Qcm92aWRlczogbWxfY2FudmFzX2ltYWdlX2RhdGFfc3ViXG4vL1JlcXVpcmVzOiBfbWxfY2FudmFzX3ZhbGlkX2NhbnZhc19zaXplLCBfbWxfY2FudmFzX2FkanVzdF9ibGl0X2luZm9cbi8vUmVxdWlyZXM6IGNhbWxfYmFfZGltLCBjYW1sX2JhX3RvX3R5cGVkX2FycmF5LCBjYW1sX2JhX2NyZWF0ZV91bnNhZmUsIGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gbWxfY2FudmFzX2ltYWdlX2RhdGFfc3ViKHNyY19kYXRhLCBzcG9zLCBzaXplKSB7XG4gIHZhciBkd2lkdGggPSBzaXplWzFdO1xuICB2YXIgZGhlaWdodCA9IHNpemVbMl07XG4gIGlmICghX21sX2NhbnZhc192YWxpZF9jYW52YXNfc2l6ZShkd2lkdGgsIGRoZWlnaHQpKSB7XG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiSW1hZ2VEYXRhLmJsaXQ6IGludmFsaWQgZGltZW5zaW9uc1wiKTtcbiAgfVxuICB2YXIgc3dpZHRoID0gY2FtbF9iYV9kaW0oc3JjX2RhdGEsIDEpO1xuICB2YXIgc2hlaWdodCA9IGNhbWxfYmFfZGltKHNyY19kYXRhLCAwKTtcbiAgdmFyIHRhID0gbmV3IHdpbmRvdy5VaW50OEFycmF5KGR3aWR0aCAqIGRoZWlnaHQgKiA0KTtcbiAgdmFyIGRzdF9kYXRhID0gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKDMgLyogVWludDhBcnJheSAqLywgMCAvKiBjX2xheW91dCAqLyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtkaGVpZ2h0LCBkd2lkdGgsIDRdLCB0YSk7XG4gIHZhciBibGl0X2luZm8gPVxuICAgIF9tbF9jYW52YXNfYWRqdXN0X2JsaXRfaW5mbyhkd2lkdGgsIGRoZWlnaHQsIDAsIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aWR0aCwgc2hlaWdodCwgc3Bvc1sxXSwgc3Bvc1syXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHdpZHRoLCBkaGVpZ2h0KTtcbiAgdmFyIGR4ID0gYmxpdF9pbmZvWzBdO1xuICB2YXIgZHkgPSBibGl0X2luZm9bMV07XG4gIHZhciBzeCA9IGJsaXRfaW5mb1syXTtcbiAgdmFyIHN5ID0gYmxpdF9pbmZvWzNdO1xuICB2YXIgd2lkdGggPSBibGl0X2luZm9bNF07XG4gIHZhciBoZWlnaHQgPSBibGl0X2luZm9bNV07XG4gIGlmICgod2lkdGggPiAwKSAmJiAoaGVpZ2h0ID4gMCkpIHtcbiAgICB2YXIgZHRhID0gbmV3IHdpbmRvdy5VaW50MzJBcnJheShjYW1sX2JhX3RvX3R5cGVkX2FycmF5KGRzdF9kYXRhKS5idWZmZXIpO1xuICAgIHZhciBzdGEgPSBuZXcgd2luZG93LlVpbnQzMkFycmF5KGNhbWxfYmFfdG9fdHlwZWRfYXJyYXkoc3JjX2RhdGEpLmJ1ZmZlcik7XG4gICAgZm9yICh2YXIgeSA9IDA7IHkgPCBoZWlnaHQ7ICsreSkge1xuICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCB3aWR0aDsgKyt4KSB7XG4gICAgICAgIGR0YVsoZHkgKyB5KSAqIGR3aWR0aCArIChkeCArIHgpXSA9XG4gICAgICAgICAgc3RhWyhzeSArIHkpICogc3dpZHRoICsgKHN4ICsgeCldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZHN0X2RhdGE7XG59XG5cbi8vUHJvdmlkZXM6IG1sX2NhbnZhc19pbWFnZV9kYXRhX2JsaXRcbi8vUmVxdWlyZXM6IF9tbF9jYW52YXNfdmFsaWRfY2FudmFzX3NpemUsIF9tbF9jYW52YXNfYWRqdXN0X2JsaXRfaW5mb1xuLy9SZXF1aXJlczogY2FtbF9iYV9kaW0sIGNhbWxfYmFfdG9fdHlwZWRfYXJyYXksIGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gbWxfY2FudmFzX2ltYWdlX2RhdGFfYmxpdChkc3RfZGF0YSwgZHBvcywgc3JjX2RhdGEsIHNwb3MsIHNpemUpIHtcbiAgdmFyIHdpZHRoID0gc2l6ZVsxXTtcbiAgdmFyIGhlaWdodCA9IHNpemVbMl07XG4gIGlmICghX21sX2NhbnZhc192YWxpZF9jYW52YXNfc2l6ZSh3aWR0aCwgaGVpZ2h0KSkge1xuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkltYWdlRGF0YS5ibGl0OiBpbnZhbGlkIGRpbWVuc2lvbnNcIik7XG4gIH1cbiAgdmFyIGR3aWR0aCA9IGNhbWxfYmFfZGltKGRzdF9kYXRhLCAxKTtcbiAgdmFyIGRoZWlnaHQgPSBjYW1sX2JhX2RpbShkc3RfZGF0YSwgMCk7XG4gIHZhciBzd2lkdGggPSBjYW1sX2JhX2RpbShzcmNfZGF0YSwgMSk7XG4gIHZhciBzaGVpZ2h0ID0gY2FtbF9iYV9kaW0oc3JjX2RhdGEsIDApO1xuICB2YXIgYmxpdF9pbmZvID1cbiAgICBfbWxfY2FudmFzX2FkanVzdF9ibGl0X2luZm8oZHdpZHRoLCBkaGVpZ2h0LCBkcG9zWzFdLCBkcG9zWzJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2lkdGgsIHNoZWlnaHQsIHNwb3NbMV0sIHNwb3NbMl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoLCBoZWlnaHQpO1xuICB2YXIgZHggPSBibGl0X2luZm9bMF07XG4gIHZhciBkeSA9IGJsaXRfaW5mb1sxXTtcbiAgdmFyIHN4ID0gYmxpdF9pbmZvWzJdO1xuICB2YXIgc3kgPSBibGl0X2luZm9bM107XG4gIHZhciB3aWR0aCA9IGJsaXRfaW5mb1s0XTtcbiAgdmFyIGhlaWdodCA9IGJsaXRfaW5mb1s1XTtcbiAgaWYgKCh3aWR0aCA+IDApICYmIChoZWlnaHQgPiAwKSkge1xuICAgIHZhciBkdGEgPSBuZXcgd2luZG93LlVpbnQzMkFycmF5KGNhbWxfYmFfdG9fdHlwZWRfYXJyYXkoZHN0X2RhdGEpLmJ1ZmZlcik7XG4gICAgdmFyIHN0YSA9IG5ldyB3aW5kb3cuVWludDMyQXJyYXkoY2FtbF9iYV90b190eXBlZF9hcnJheShzcmNfZGF0YSkuYnVmZmVyKTtcbiAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGhlaWdodDsgKyt5KSB7XG4gICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHdpZHRoOyArK3gpIHtcbiAgICAgICAgZHRhWyhkeSArIHkpICogZHdpZHRoICsgKGR4ICsgeCldID1cbiAgICAgICAgICBzdGFbKHN5ICsgeSkgKiBzd2lkdGggKyAoc3ggKyB4KV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBtbF9jYW52YXNfaW1hZ2VfZGF0YV9nZXRfcGl4ZWxcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZGltLCBjYW1sX2JhX3RvX3R5cGVkX2FycmF5XG5mdW5jdGlvbiBtbF9jYW52YXNfaW1hZ2VfZGF0YV9nZXRfcGl4ZWwoZGF0YSwgcG9zKSB7XG4gIHZhciB0YSA9IG5ldyB3aW5kb3cuVWludDMyQXJyYXkoY2FtbF9iYV90b190eXBlZF9hcnJheShkYXRhKS5idWZmZXIpO1xuICByZXR1cm4gdGFbcG9zWzJdICogY2FtbF9iYV9kaW0oZGF0YSwgMSkgKyBwb3NbMV1dXG59XG5cbi8vUHJvdmlkZXM6IG1sX2NhbnZhc19pbWFnZV9kYXRhX3B1dF9waXhlbFxuLy9SZXF1aXJlczogY2FtbF9iYV9kaW0sIGNhbWxfYmFfdG9fdHlwZWRfYXJyYXlcbmZ1bmN0aW9uIG1sX2NhbnZhc19pbWFnZV9kYXRhX3B1dF9waXhlbChkYXRhLCBwb3MsIGNvbG9yKSB7XG4gIHZhciB0YSA9IG5ldyB3aW5kb3cuVWludDMyQXJyYXkoY2FtbF9iYV90b190eXBlZF9hcnJheShkYXRhKS5idWZmZXIpO1xuICB0YVtwb3NbMl0gKiBjYW1sX2JhX2RpbShkYXRhLCAxKSArIHBvc1sxXV0gPSBjb2xvcjtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IG1sX2NhbnZhc19pbWFnZV9kYXRhX2ltcG9ydF9wbmdcbi8vUmVxdWlyZXM6IF9tbF9jYW52YXNfZW5zdXJlX2luaXRpYWxpemVkLCBfbWxfY2FudmFzX3N1cmZhY2Vfb2ZfYmEsIF9tbF9jYW52YXNfaW1hZ2Vfb2ZfcG5nX2ZpbGVcbi8vUmVxdWlyZXM6IGNhbWxfYmFfdG9fdHlwZWRfYXJyYXksIGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcsIGNhbWxfbmFtZWRfdmFsdWVcbmZ1bmN0aW9uIG1sX2NhbnZhc19pbWFnZV9kYXRhX2ltcG9ydF9wbmcoZGF0YSwgcG9zLCBmaWxlbmFtZSwgb25sb2FkKSB7XG4gIF9tbF9jYW52YXNfZW5zdXJlX2luaXRpYWxpemVkKCk7XG4gIHZhciBpbWcgPSBfbWxfY2FudmFzX2ltYWdlX29mX3BuZ19maWxlKGZpbGVuYW1lKTtcbiAgdmFyIHN1cmZhY2UgPSBfbWxfY2FudmFzX3N1cmZhY2Vfb2ZfYmEoZGF0YSk7XG4gIGlmICgoaW1nID09PSBudWxsKSB8fCAoc3VyZmFjZSA9PT0gbnVsbCkpIHtcbiAgICBjYW1sX3JhaXNlX3dpdGhfc3RyaW5nKGNhbWxfbmFtZWRfdmFsdWUoXCJSZWFkX3BuZ19mYWlsZWRcIiksIGZpbGVuYW1lKTtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBpbWdbMF0udGhlbihmdW5jdGlvbiAoX19pbWcpIHtcbiAgICB2YXIgY3R4dCA9IHN1cmZhY2UuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgIGN0eHQuZHJhd0ltYWdlKGltZ1sxXSwgcG9zWzFdLCBwb3NbMl0pO1xuICAgIHZhciBpbWFnZSA9IGN0eHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIHN1cmZhY2Uud2lkdGgsIHN1cmZhY2UuaGVpZ2h0KTtcbiAgICB2YXIgc3RhID0gbmV3IHdpbmRvdy5VaW50OEFycmF5KGltYWdlLmRhdGEuYnVmZmVyKTtcbiAgICB2YXIgZHRhID0gY2FtbF9iYV90b190eXBlZF9hcnJheShkYXRhKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGR0YS5sZW5ndGg7IGkrKykge1xuICAgICAgZHRhW2ldID0gc3RhW2ldO1xuICAgIH1cbiAgICBvbmxvYWQoZGF0YSk7XG4gICAgcmV0dXJuIDA7XG4gIH0pO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogbWxfY2FudmFzX2ltYWdlX2RhdGFfZXhwb3J0X3BuZ1xuLy9SZXF1aXJlczogX21sX2NhbnZhc19lbnN1cmVfaW5pdGlhbGl6ZWQsIF9tbF9jYW52YXNfc3VyZmFjZV9vZl9iYVxuLy9SZXF1aXJlczogY2FtbF9jcmVhdGVfZmlsZSwgY2FtbF9yYWlzZV93aXRoX3N0cmluZywgY2FtbF9uYW1lZF92YWx1ZVxuZnVuY3Rpb24gbWxfY2FudmFzX2ltYWdlX2RhdGFfZXhwb3J0X3BuZyhkYXRhLCBmaWxlbmFtZSkge1xuICBfbWxfY2FudmFzX2Vuc3VyZV9pbml0aWFsaXplZCgpO1xuICB0cnkge1xuICAgIHZhciBzdXJmYWNlID0gX21sX2NhbnZhc19zdXJmYWNlX29mX2JhKGRhdGEpO1xuICAgIGlmIChzdXJmYWNlICE9PSBudWxsKSB7XG4gICAgICB2YXIgZGF0YSA9IHN1cmZhY2UudG9EYXRhVVJMKFwiaW1hZ2UvcG5nXCIpLnN1YnN0cmluZygyMik7XG4gICAgICBjYW1sX2NyZWF0ZV9maWxlKGZpbGVuYW1lLCB3aW5kb3cuYXRvYihkYXRhKSk7XG4gICAgfVxuICB9IGNhdGNoIChleG4pIHtcbiAgICBjYW1sX3JhaXNlX3dpdGhfc3RyaW5nKGNhbWxfbmFtZWRfdmFsdWUoXCJXcml0ZV9wbmdfZmFpbGVkXCIpLCBmaWxlbmFtZSk7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cblxuXG4vKiBQYXRoMkQgKi9cblxuLy9Qcm92aWRlczogbWxfY2FudmFzX3BhdGhfY3JlYXRlXG5mdW5jdGlvbiBtbF9jYW52YXNfcGF0aF9jcmVhdGUoKSB7XG4gIHJldHVybiBuZXcgd2luZG93LlBhdGgyRCgpO1xufVxuXG4vL1Byb3ZpZGVzOiBtbF9jYW52YXNfcGF0aF9jbG9zZVxuZnVuY3Rpb24gbWxfY2FudmFzX3BhdGhfY2xvc2UocGF0aCkge1xuICBwYXRoLmNsb3NlUGF0aCgpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogbWxfY2FudmFzX3BhdGhfbW92ZV90b1xuZnVuY3Rpb24gbWxfY2FudmFzX3BhdGhfbW92ZV90byhwYXRoLCBwKSB7XG4gIHBhdGgubW92ZVRvKHBbMV0sIHBbMl0pO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogbWxfY2FudmFzX3BhdGhfbGluZV90b1xuZnVuY3Rpb24gbWxfY2FudmFzX3BhdGhfbGluZV90byhwYXRoLCBwKSB7XG4gIHBhdGgubGluZVRvKHBbMV0sIHBbMl0pO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogbWxfY2FudmFzX3BhdGhfYXJjXG5mdW5jdGlvbiBtbF9jYW52YXNfcGF0aF9hcmMocGF0aCwgcCwgcmFkaXVzLCB0aGV0YTEsIHRoZXRhMiwgY2N3KSB7XG4gIHBhdGguYXJjKHBbMV0sIHBbMl0sIHJhZGl1cywgdGhldGExLCB0aGV0YTIsIGNjdyk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBtbF9jYW52YXNfcGF0aF9hcmNfdG9cbmZ1bmN0aW9uIG1sX2NhbnZhc19wYXRoX2FyY190byhwYXRoLCBwMSwgcDIsIHJhZGl1cykge1xuICBwYXRoLmFyY1RvKHAxWzFdLCBwMVsyXSwgcDJbMV0sIHAyWzJdLCByYWRpdXMpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogbWxfY2FudmFzX3BhdGhfcXVhZHJhdGljX2N1cnZlX3RvXG5mdW5jdGlvbiBtbF9jYW52YXNfcGF0aF9xdWFkcmF0aWNfY3VydmVfdG8ocGF0aCwgY3AsIHApIHtcbiAgcGF0aC5xdWFkcmF0aWNDdXJ2ZVRvKGNwWzFdLCBjcFsyXSwgcFsxXSwgcFsyXSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzIDogbWxfY2FudmFzX3BhdGhfYmV6aWVyX2N1cnZlX3RvXG5mdW5jdGlvbiBtbF9jYW52YXNfcGF0aF9iZXppZXJfY3VydmVfdG8ocGF0aCwgY3AxLCBjcDIsIHApIHtcbiAgcGF0aC5iZXppZXJDdXJ2ZVRvKGNwMVsxXSwgY3AxWzJdLCBjcDJbMV0sIGNwMlsyXSwgcFsxXSwgcFsyXSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBtbF9jYW52YXNfcGF0aF9yZWN0XG5mdW5jdGlvbiBtbF9jYW52YXNfcGF0aF9yZWN0KHBhdGgsIHBvcywgc2l6ZSkge1xuICBwYXRoLnJlY3QocG9zWzFdLCBwb3NbMl0sIHNpemVbMV0sIHNpemVbMl0pO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogbWxfY2FudmFzX3BhdGhfZWxsaXBzZVxuZnVuY3Rpb24gbWxfY2FudmFzX3BhdGhfZWxsaXBzZShwYXRoLCBwLCByYWRpdXMsIHJvdGF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGV0YTEsIHRoZXRhMiwgY2N3KSB7XG4gIHBhdGguZWxsaXBzZShwWzFdLCBwWzJdLCByYWRpdXNbMV0sIHJhZGl1c1syXSxcbiAgICAgICAgICAgICAgIHJvdGF0aW9uLCB0aGV0YTEsIHRoZXRhMiwgY2N3KTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IG1sX2NhbnZhc19wYXRoX2FkZFxuZnVuY3Rpb24gbWxfY2FudmFzX3BhdGhfYWRkKHBhdGgxLCBwYXRoMikge1xuICBwYXRoMS5hZGRQYXRoKHBhdGgyKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IG1sX2NhbnZhc19wYXRoX2FkZF90cmFuc2Zvcm1lZFxuZnVuY3Rpb24gbWxfY2FudmFzX3BhdGhfYWRkX3RyYW5zZm9ybWVkKHBhdGgxLCBwYXRoMiwgdCkge1xuICB2YXIgbSA9IG5ldyB3aW5kb3cuRE9NTWF0cml4KFtbMV0sIHRbMl0sIHRbM10sIHRbNF0sIHRbNV0sIHRbNl1dKTtcbiAgcGF0aDEuYWRkUGF0aChwYXRoMiwgbSk7XG4gIHJldHVybiAwO1xufVxuXG5cblxuLyogR3JhZGllbnRzICovXG5cbi8vUHJvdmlkZXM6IG1sX2NhbnZhc19ncmFkaWVudF9jcmVhdGVfbGluZWFyXG4vL1JlcXVpcmVzIDogX2ludGVybmFsX2N0eHRcbmZ1bmN0aW9uIG1sX2NhbnZhc19ncmFkaWVudF9jcmVhdGVfbGluZWFyKHBvczEsIHBvczIpIHtcbiAgcmV0dXJuIF9pbnRlcm5hbF9jdHh0LmNyZWF0ZUxpbmVhckdyYWRpZW50KHBvczFbMV0sIHBvczFbMl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3MyWzFdLCBwb3MyWzJdKTtcbn1cblxuLy9Qcm92aWRlczogbWxfY2FudmFzX2dyYWRpZW50X2NyZWF0ZV9yYWRpYWxcbi8vUmVxdWlyZXMgOiBfaW50ZXJuYWxfY3R4dFxuZnVuY3Rpb24gbWxfY2FudmFzX2dyYWRpZW50X2NyZWF0ZV9yYWRpYWwoY2VudGVyMSwgcmFkMSwgY2VudGVyMiwgcmFkMikge1xuICByZXR1cm4gX2ludGVybmFsX2N0eHQuY3JlYXRlUmFkaWFsR3JhZGllbnQoY2VudGVyMVsxXSwgY2VudGVyMVsyXSwgcmFkMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbnRlcjJbMV0sIGNlbnRlcjJbMl0sIHJhZDIpO1xufVxuXG4vL1Byb3ZpZGVzOiBtbF9jYW52YXNfZ3JhZGllbnRfY3JlYXRlX2NvbmljXG4vL1JlcXVpcmVzIDogX2ludGVybmFsX2N0eHRcbmZ1bmN0aW9uIG1sX2NhbnZhc19ncmFkaWVudF9jcmVhdGVfY29uaWMoY2VudGVyLCBhbmdsZSkge1xuICByZXR1cm4gX2ludGVybmFsX2N0eHQuY3JlYXRlQ29uaWNHcmFkaWVudChhbmdsZSwgY2VudGVyWzFdLCBjZW50ZXJbMl0pO1xufVxuXG4vL1Byb3ZpZGVzOiBtbF9jYW52YXNfZ3JhZGllbnRfYWRkX2NvbG9yX3N0b3Bcbi8vUmVxdWlyZXM6IF9jb2xvcl9vZl9pbnRcbmZ1bmN0aW9uIG1sX2NhbnZhc19ncmFkaWVudF9hZGRfY29sb3Jfc3RvcChncmFkaWVudCwgY29sb3IsIHBvcykge1xuICBncmFkaWVudC5hZGRDb2xvclN0b3AocG9zLCBfY29sb3Jfb2ZfaW50KGNvbG9yKSk7XG4gIHJldHVybiAwO1xufVxuXG5cblxuLyogUGF0dGVybnMgKi9cblxuLy9Qcm92aWRlczogbWxfY2FudmFzX3BhdHRlcm5fY3JlYXRlXG4vL1JlcXVpcmVzIDogUmVwZWF0X3ZhbCwgX21sX2NhbnZhc19zdXJmYWNlX29mX2JhLCBfaW50ZXJuYWxfY3R4dFxuZnVuY3Rpb24gbWxfY2FudmFzX3BhdHRlcm5fY3JlYXRlKGltYWdlLCByZXBlYXQpIHtcbiAgdmFyIGltZ19jYW52ID0gX21sX2NhbnZhc19zdXJmYWNlX29mX2JhKGltYWdlKTtcbiAgcmV0dXJuIF9pbnRlcm5hbF9jdHh0LmNyZWF0ZVBhdHRlcm4oaW1nX2NhbnYsIFJlcGVhdF92YWwocmVwZWF0KSk7XG59XG5cblxuXG4vKiBDYW52YXMgKi9cblxuLyogQ29tcGFyaXNvbiBhbmQgaGFzaGluZyAqL1xuXG4vLyBQcm92aWRlczogbWxfY2FudmFzX2hhc2hcbi8vIFJlcXVpcmVzOiBjYW1sX25hbWVkX3ZhbHVlXG5mdW5jdGlvbiBtbF9jYW52YXNfaGFzaChjYW52YXMpIHtcbiAgdmFyIGhhc2ggPSBjYW1sX25hbWVkX3ZhbHVlKFwiSGFzaHRibC5oYXNoXCIpO1xuICByZXR1cm4gaGFzaChjYW52YXMuaWQpO1xufVxuXG4vLyBQcm92aWRlczogbWxfY2FudmFzX2NvbXBhcmVcbmZ1bmN0aW9uIG1sX2NhbnZhc19jb21wYXJlKGNhbnZhczEsIGNhbnZhczIpIHtcbiAgaWYgKGNhbnZhczEuaWQgPCBjYW52YXMyLmlkKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9IGVsc2UgaWYgKGNhbnZhczEuaWQgPiBjYW52YXMyLmlkKSB7XG4gICAgcmV0dXJuIDE7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbn1cblxuXG5cbi8qIENyZWF0aW9uICovXG5cbi8vUHJvdmlkZXM6IF9uZXh0X2lkXG52YXIgX25leHRfaWQgPSAwO1xuXG4vL1Byb3ZpZGVzOiBfbWxfY2FudmFzX2RlY29yYXRlXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gX21sX2NhbnZhc19kZWNvcmF0ZShoZWFkZXIsIG1pbmltaXplLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhpbWl6ZSwgY2xvc2UsIHRpdGxlKSB7XG4gIHZhciB3aWR0aCA9IGhlYWRlci53aWR0aDtcbiAgdmFyIGN0eHQgPSBoZWFkZXIuZ2V0Q29udGV4dChcIjJkXCIpO1xuICBjdHh0LmZpbGxTdHlsZSA9IFwiIzU4NTg1OFwiO1xuICBjdHh0LmZpbGxSZWN0KDAsIDAsIHdpZHRoLCAzMCk7XG4gIGlmICh0aXRsZSAhPT0gbnVsbCkge1xuICAgIGN0eHQuZmlsbFN0eWxlID0gXCIjRjBGMEYwRjBcIjtcbiAgICBjdHh0LmZvbnQgPSBcImJvbGQgMTZweCBBcmlhbFwiO1xuICAgIGN0eHQudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcbiAgICBjdHh0LmZpbGxUZXh0KGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHRpdGxlKSwgd2lkdGggLyAyLCAyMSk7XG4gIH1cbiAgY3R4dC5zdHJva2VTdHlsZSA9IFwiI0YwRjBGMEYwXCI7XG4gIGN0eHQubGluZVdpZHRoID0gMi4wO1xuICBpZiAoY2xvc2UgPT0gdHJ1ZSkge1xuICAgIGN0eHQuYmVnaW5QYXRoKCk7XG4gICAgY3R4dC5tb3ZlVG8od2lkdGggLSAyMCwgMTApO1xuICAgIGN0eHQubGluZVRvKHdpZHRoIC0gMTAsIDIwKTtcbiAgICBjdHh0Lm1vdmVUbyh3aWR0aCAtIDIwLCAyMCk7XG4gICAgY3R4dC5saW5lVG8od2lkdGggLSAxMCwgMTApO1xuICAgIGN0eHQuc3Ryb2tlKCk7XG4gIH1cbn1cblxuLy9Qcm92aWRlczogbWxfY2FudmFzX2NyZWF0ZV9vbnNjcmVlblxuLy9SZXF1aXJlczogX21sX2NhbnZhc19lbnN1cmVfaW5pdGlhbGl6ZWQsIF9tbF9jYW52YXNfdmFsaWRfY2FudmFzX3NpemUsIF9yZXNpemUsIF9uZXh0X2lkLCBfaGVhZGVyX2Rvd25faGFuZGxlclxuLy9SZXF1aXJlczogX3N1cmZhY2VfZG93bl9oYW5kbGVyLCBfdXBfaGFuZGxlciwgX21vdmVfaGFuZGxlciwgX21sX2NhbnZhc19kZWNvcmF0ZSwgT3B0aW9uYWxfYm9vbF92YWwsIE9wdGlvbmFsX3ZhbFxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBtbF9jYW52YXNfY3JlYXRlX29uc2NyZWVuKGF1dG9jb21taXQsIGRlY29yYXRlZCwgcmVzaXplYWJsZSwgbWluaW1pemUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heGltaXplLCBjbG9zZSwgdGl0bGUsIHRhcmdldCwgcG9zLCBzaXplKSB7XG5cbiAgX21sX2NhbnZhc19lbnN1cmVfaW5pdGlhbGl6ZWQoKTtcblxuICB2YXIgd2lkdGggPSBzaXplWzFdO1xuICB2YXIgaGVpZ2h0ID0gc2l6ZVsyXTtcbiAgaWYgKCFfbWxfY2FudmFzX3ZhbGlkX2NhbnZhc19zaXplKHdpZHRoLCBoZWlnaHQpKSB7XG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQ2FudmFzLmJsaXQ6IGludmFsaWQgZGltZW5zaW9uc1wiKTtcbiAgfVxuXG4gIHZhciBwb3MgPSBPcHRpb25hbF92YWwocG9zLCBbMCwgMCwgMF0pO1xuICB2YXIgeCA9IHBvc1sxXTtcbiAgdmFyIHkgPSBwb3NbMl07XG5cbiAgdmFyIGF1dG9jb21taXQgPSBPcHRpb25hbF9ib29sX3ZhbChhdXRvY29tbWl0LCB0cnVlKTtcbiAgdmFyIGRlY29yYXRlZCA9IGZhbHNlOyAvLyBPcHRpb25hbF9ib29sX3ZhbChkZWNvcmF0ZWQsIHRydWUpO1xuICB2YXIgcmVzaXplYWJsZSA9IE9wdGlvbmFsX2Jvb2xfdmFsKHJlc2l6ZWFibGUsIHRydWUpO1xuICB2YXIgbWluaW1pemUgPSBPcHRpb25hbF9ib29sX3ZhbChtaW5pbWl6ZSwgdHJ1ZSk7XG4gIHZhciBtYXhpbWl6ZSA9IE9wdGlvbmFsX2Jvb2xfdmFsKG1heGltaXplLCB0cnVlKTtcbiAgdmFyIGNsb3NlID0gT3B0aW9uYWxfYm9vbF92YWwoY2xvc2UsIHRydWUpO1xuICB2YXIgdGl0bGUgPSBPcHRpb25hbF92YWwodGl0bGUsIG51bGwpO1xuICB2YXIgdGFyZ2V0ID0gT3B0aW9uYWxfdmFsKHRhcmdldCwgbnVsbCk7XG4gIHRhcmdldCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRhcmdldCk7XG4gIGlmKHRhcmdldCA9PSBudWxsKSB7XG4gICAgdGFyZ2V0ID0gZG9jdW1lbnQuYm9keTtcbiAgfVxuXG4gIHZhciBpZCA9ICsrX25leHRfaWQ7XG5cbiAgdmFyIGNhbnZhcyA9IHtcbiAgICBuYW1lOiB0aXRsZSxcbiAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICBmcmFtZTogbnVsbCxcbiAgICBoZWFkZXI6IG51bGwsXG4gICAgc3VyZmFjZTogbnVsbCxcbiAgICBjdHh0OiBudWxsLFxuICAgIHg6IHgsIHk6IHksXG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIGlkOiBpZCxcbiAgICBhdXRvY29tbWl0OiBhdXRvY29tbWl0LFxuICAgIHJlc2l6ZWFibGU6IHJlc2l6ZWFibGUsXG4gICAgbWluaW1pemU6IG1pbmltaXplLFxuICAgIG1heGltaXplOiBtYXhpbWl6ZSxcbiAgICBjbG9zZTogY2xvc2VcbiAgfTtcblxuICB2YXIgaGVhZGVyX2hlaWdodCA9IChkZWNvcmF0ZWQgPT0gdHJ1ZSA/IDMwIDogMCk7XG5cbiAgdmFyIGZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgZnJhbWUuaWQgPSBcImZcIiArIGlkO1xuICBpZiAocmVzaXplYWJsZSA9PSB0cnVlKSB7XG4gICAgZnJhbWUuc3R5bGUud2lkdGggPSBcIjEwMCVcIjtcbiAgICBmcmFtZS5zdHlsZS5oZWlnaHQgPSBcIjEwMCVcIjtcbiAgfSBlbHNlIHtcbiAgICBmcmFtZS5zdHlsZS53aWR0aCA9IHdpZHRoICsgXCJweFwiO1xuICAgIGZyYW1lLnN0eWxlLmhlaWdodCA9IGhlaWdodCArIGhlYWRlcl9oZWlnaHQgKyBcInB4XCI7XG4gIH1cbiAgZnJhbWUuc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCI7XG4gIGZyYW1lLm9uY29udGV4dG1lbnUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGZyYW1lLmNhbnZhcyA9IGNhbnZhcztcbiAgY2FudmFzLmZyYW1lID0gZnJhbWU7XG4gIHRhcmdldC5hcHBlbmRDaGlsZChmcmFtZSk7XG5cbiAgdmFyIGhlYWRlciA9IG51bGw7XG4gIGlmIChkZWNvcmF0ZWQgPT09IHRydWUpIHtcbiAgICBmcmFtZS5zdHlsZS5ib3JkZXIgPSBcIjFweCBzb2xpZCBibGFja1wiO1xuICAgIGhlYWRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgaGVhZGVyLmlkID0gXCJoXCIgKyBpZDtcbiAgICBoZWFkZXIud2lkdGggPSB3aWR0aDtcbiAgICBoZWFkZXIuaGVpZ2h0ID0gMzA7XG4gICAgX21sX2NhbnZhc19kZWNvcmF0ZShoZWFkZXIsIG1pbmltaXplLCBtYXhpbWl6ZSwgY2xvc2UsIHRpdGxlKTtcbiAgICBoZWFkZXIub25tb3VzZWRvd24gPSBfaGVhZGVyX2Rvd25faGFuZGxlcjtcbiAgICBoZWFkZXIuY2FudmFzID0gY2FudmFzO1xuICAgIGNhbnZhcy5oZWFkZXIgPSBoZWFkZXI7XG4gICAgZnJhbWUuYXBwZW5kQ2hpbGQoaGVhZGVyKTtcbiAgfVxuXG4gIHZhciBzdXJmYWNlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgc3VyZmFjZS5pZCA9IFwic1wiICsgaWQ7XG4gIHN1cmZhY2Uud2lkdGggPSB3aWR0aDtcbiAgc3VyZmFjZS5oZWlnaHQgPSBoZWlnaHQ7XG4gIHN1cmZhY2Uub25tb3VzZWRvd24gPSBfc3VyZmFjZV9kb3duX2hhbmRsZXI7XG4gIHN1cmZhY2UuY2FudmFzID0gY2FudmFzO1xuICBjYW52YXMuc3VyZmFjZSA9IHN1cmZhY2U7XG4gIGZyYW1lLmFwcGVuZENoaWxkKHN1cmZhY2UpO1xuXG4gIGlmIChyZXNpemVhYmxlID09PSB0cnVlKSB7XG4gICAgc3VyZmFjZS5zdHlsZS53aWR0aCA9IFwiMTAwJVwiO1xuICAgIHN1cmZhY2Uuc3R5bGUuaGVpZ2h0ID0gXCIxMDAlXCI7XG4gICAgX3Jlc2l6ZS5vYnNlcnZlKHN1cmZhY2UpO1xuICB9XG5cbiAgdmFyIGN0eHQgPSBzdXJmYWNlLmdldENvbnRleHQoXCIyZFwiKTtcbiAgY3R4dC5nbG9iYWxBbHBoYSA9IDEuMDtcbiAgY3R4dC5saW5lV2lkdGggPSAxLjA7XG4gIGN0eHQuZmlsbFN0eWxlID0gXCJ3aGl0ZVwiO1xuICBjdHh0LnN0cm9rZVN0eWxlID0gXCJibGFja1wiO1xuICBjYW52YXMuY3R4dCA9IGN0eHQ7XG5cbiAgLy8gT25zY3JlZW4gY2FudmFzIGFyZSBmaWxsZWQgd2l0aCB3aGl0ZSBieSBkZWZhdWx0XG4gIGN0eHQuZmlsbFJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG5cbiAgcmV0dXJuIGNhbnZhcztcbn1cblxuLy9Qcm92aWRlczogbWxfY2FudmFzX2NyZWF0ZV9vZmZzY3JlZW5cbi8vUmVxdWlyZXM6IF9tbF9jYW52YXNfZW5zdXJlX2luaXRpYWxpemVkLCBfbWxfY2FudmFzX3ZhbGlkX2NhbnZhc19zaXplLCBfbmV4dF9pZFxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBtbF9jYW52YXNfY3JlYXRlX29mZnNjcmVlbihzaXplKSB7XG5cbiAgX21sX2NhbnZhc19lbnN1cmVfaW5pdGlhbGl6ZWQoKTtcblxuICB2YXIgd2lkdGggPSBzaXplWzFdO1xuICB2YXIgaGVpZ2h0ID0gc2l6ZVsyXTtcblxuICBpZiAoIV9tbF9jYW52YXNfdmFsaWRfY2FudmFzX3NpemUod2lkdGgsIGhlaWdodCkpIHtcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJDYW52YXMuY3JlYXRlT2Zmc2NyZWVuOiBpbnZhbGlkIGRpbWVuc2lvbnNcIik7XG4gIH1cblxuICB2YXIgaWQgPSArK19uZXh0X2lkO1xuXG4gIHZhciBjYW52YXMgPSB7XG4gICAgbmFtZTogbnVsbCxcbiAgICBmcmFtZTogbnVsbCxcbiAgICBoZWFkZXI6IG51bGwsXG4gICAgc3VyZmFjZTogc3VyZmFjZSxcbiAgICBjdHh0OiBjdHh0LFxuICAgIHg6IDAsIHk6IDAsXG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIGlkOiBpZCxcbiAgICBhdXRvY29tbWl0OiBmYWxzZSxcbiAgICByZXNpemVhYmxlOiBmYWxzZSxcbiAgICBtaW5pbWl6ZTogZmFsc2UsXG4gICAgbWF4aW1pemU6IGZhbHNlLFxuICAgIGNsb3NlOiBmYWxzZVxuICB9O1xuXG4gIHZhciBzdXJmYWNlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgc3VyZmFjZS5pZCA9IFwic1wiICsgaWQ7XG4gIHN1cmZhY2Uud2lkdGggPSB3aWR0aDtcbiAgc3VyZmFjZS5oZWlnaHQgPSBoZWlnaHQ7XG4gIHN1cmZhY2Uuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCJcbiAgc3VyZmFjZS5jYW52YXMgPSBjYW52YXM7XG4gIGNhbnZhcy5zdXJmYWNlID0gc3VyZmFjZTtcblxuICB2YXIgY3R4dCA9IHN1cmZhY2UuZ2V0Q29udGV4dChcIjJkXCIpO1xuICBjdHh0Lmdsb2JhbEFscGhhID0gMS4wO1xuICBjdHh0LmxpbmVXaWR0aCA9IDIuMDtcbiAgY3R4dC5maWxsU3R5bGUgPSBcIndoaXRlXCI7XG4gIGN0eHQuc3Ryb2tlU3R5bGUgPSBcImJsYWNrXCI7XG4gIGNhbnZhcy5jdHh0ID0gY3R4dDtcblxuICByZXR1cm4gY2FudmFzO1xufVxuXG4vL1Byb3ZpZGVzOiBtbF9jYW52YXNfY3JlYXRlX29mZnNjcmVlbl9mcm9tX2ltYWdlX2RhdGFcbi8vUmVxdWlyZXM6IF9tbF9jYW52YXNfZW5zdXJlX2luaXRpYWxpemVkLCBtbF9jYW52YXNfY3JlYXRlX29mZnNjcmVlblxuLy9SZXF1aXJlczogY2FtbF9iYV90b190eXBlZF9hcnJheSwgY2FtbF9iYV9kaW1cbmZ1bmN0aW9uIG1sX2NhbnZhc19jcmVhdGVfb2Zmc2NyZWVuX2Zyb21faW1hZ2VfZGF0YShkYXRhKSB7XG4gIF9tbF9jYW52YXNfZW5zdXJlX2luaXRpYWxpemVkKCk7XG4gIHZhciB3aWR0aCA9IGNhbWxfYmFfZGltKGRhdGEsIDEpO1xuICB2YXIgaGVpZ2h0ID0gY2FtbF9iYV9kaW0oZGF0YSwgMCk7XG4gIHZhciBjYW52YXMgPSBtbF9jYW52YXNfY3JlYXRlX29mZnNjcmVlbihbMCwgd2lkdGgsIGhlaWdodF0pXG4gIGlmIChjYW52YXMgPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgc3RhID0gbmV3IHdpbmRvdy5VaW50OEFycmF5KGNhbWxfYmFfdG9fdHlwZWRfYXJyYXkoZGF0YSkuYnVmZmVyKTtcbiAgdmFyIGR0YSA9IG5ldyB3aW5kb3cuVWludDhDbGFtcGVkQXJyYXkoc3RhLmxlbmd0aCk7XG4gIC8vIENvbnZlcnQgZnJvbSBCR1JBIHRvIFJHQkFcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGEubGVuZ3RoOyBpICs9IDQpIHtcbiAgICBkdGFbaSswXSA9IHN0YVtpKzJdO1xuICAgIGR0YVtpKzFdID0gc3RhW2krMV07XG4gICAgZHRhW2krMl0gPSBzdGFbaSswXTtcbiAgICBkdGFbaSszXSA9IHN0YVtpKzNdO1xuICB9XG4gIGlmICh3aW5kb3cuSW1hZ2VEYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgaW1hZ2UgPSBjYW52YXMuY3R4dC5jcmVhdGVJbWFnZURhdGEod2lkdGgsIGhlaWdodCk7XG4gICAgaW1hZ2UuZGF0YS5zZXQoZHRhKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgaW1hZ2UgPSBuZXcgd2luZG93LkltYWdlRGF0YShkdGEsIHdpZHRoLCBoZWlnaHQpO1xuICB9XG4gIGNhbnZhcy5jdHh0LnB1dEltYWdlRGF0YShpbWFnZSwgMCwgMCk7XG4gIHJldHVybiBjYW52YXM7XG59XG5cbi8vUHJvdmlkZXM6IG1sX2NhbnZhc19jcmVhdGVfb2Zmc2NyZWVuX2Zyb21fcG5nXG4vL1JlcXVpcmVzOiBfbWxfY2FudmFzX2Vuc3VyZV9pbml0aWFsaXplZCwgbWxfY2FudmFzX2NyZWF0ZV9vZmZzY3JlZW4sIF9tbF9jYW52YXNfaW1hZ2Vfb2ZfcG5nX2ZpbGVcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcsIGNhbWxfbmFtZWRfdmFsdWVcbmZ1bmN0aW9uIG1sX2NhbnZhc19jcmVhdGVfb2Zmc2NyZWVuX2Zyb21fcG5nKGZpbGVuYW1lLCBvbmxvYWQpIHtcbiAgX21sX2NhbnZhc19lbnN1cmVfaW5pdGlhbGl6ZWQoKTtcbiAgdmFyIGltZyA9IF9tbF9jYW52YXNfaW1hZ2Vfb2ZfcG5nX2ZpbGUoZmlsZW5hbWUpO1xuICBpZiAoaW1nID09PSBudWxsKSB7XG4gICAgY2FtbF9yYWlzZV93aXRoX3N0cmluZyhjYW1sX25hbWVkX3ZhbHVlKFwiUmVhZF9wbmdfZmFpbGVkXCIpLCBmaWxlbmFtZSk7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgaW1nWzBdLnRoZW4oZnVuY3Rpb24gKF9faW1nKSB7XG4gICAgdmFyIGNhbnZhcyA9IG1sX2NhbnZhc19jcmVhdGVfb2Zmc2NyZWVuKFswLCBpbWdbMV0ud2lkdGgsIGltZ1sxXS5oZWlnaHRdKVxuICAgIGlmIChjYW52YXMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBjYW52YXMuY3R4dC5kcmF3SW1hZ2UoaW1nWzFdLCAwLCAwKTtcbiAgICBvbmxvYWQoY2FudmFzKTtcbiAgICByZXR1cm4gMDtcbiAgfSk7XG4gIHJldHVybiAwO1xufVxuXG5cblxuLyogVmlzaWJpbGl0eSAqL1xuXG4vLyBQcm92aWRlczogbWxfY2FudmFzX3Nob3dcbi8vIFJlcXVpcmVzOiBfZm9jdXNcbmZ1bmN0aW9uIG1sX2NhbnZhc19zaG93KGNhbnZhcykge1xuICBpZiAoY2FudmFzLmZyYW1lICE9PSBudWxsKSB7XG4gICAgX2ZvY3VzID0gY2FudmFzO1xuICAgIGNhbnZhcy5mcmFtZS5zdHlsZS52aXNpYmlsaXR5ID0gXCJ2aXNpYmxlXCI7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vIFByb3ZpZGVzOiBtbF9jYW52YXNfaGlkZVxuLy8gUmVxdWlyZXM6IF9mb2N1c1xuZnVuY3Rpb24gbWxfY2FudmFzX2hpZGUoY2FudmFzKSB7XG4gIGlmIChjYW52YXMuZnJhbWUgIT09IG51bGwpIHtcbiAgICBpZiAoX2ZvY3VzID09PSBjYW52YXMpIHtcbiAgICAgIF9mb2N1cyA9IG51bGw7XG4gICAgfVxuICAgIGNhbnZhcy5mcmFtZS5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy8gUHJvdmlkZXM6IG1sX2NhbnZhc19jbG9zZVxuLy8gUmVxdWlyZXM6IG1sX2NhbnZhc19oaWRlXG5mdW5jdGlvbiBtbF9jYW52YXNfY2xvc2UoY2FudmFzKSB7XG4gIGlmIChjYW52YXMuZnJhbWUgIT09IG51bGwpIHtcbiAgICBtbF9jYW52YXNfaGlkZShjYW52YXMpO1xuICAgIGNhbnZhcy5uYW1lID0gbnVsbDtcbiAgICBpZiAoY2FudmFzLnN1cmZhY2UgIT0gbnVsbCkge1xuICAgICAgY2FudmFzLnN1cmZhY2UuY2FudmFzID0gbnVsbDtcbiAgICAgIGlmIChjYW52YXMuc3VyZmFjZS5wYXJlbnROb2RlICE9PSBudWxsKSB7XG4gICAgICAgIGNhbnZhcy5zdXJmYWNlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY2FudmFzLnN1cmZhY2UpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY2FudmFzLmhlYWRlciAhPSBudWxsKSB7XG4gICAgICBjYW52YXMuaGVhZGVyLmNhbnZhcyA9IG51bGw7XG4gICAgICBpZiAoY2FudmFzLmhlYWRlci5wYXJlbnROb2RlICE9PSBudWxsKSB7XG4gICAgICAgIGNhbnZhcy5oZWFkZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjYW52YXMuaGVhZGVyKTtcbiAgICAgIH1cbiAgICAgIGNhbnZhcy5oZWFkZXIgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoY2FudmFzLmZyYW1lICE9PSBudWxsKSB7XG4gICAgICBjYW52YXMuZnJhbWUuY2FudmFzID0gbnVsbDtcbiAgICAgIGlmIChjYW52YXMuZnJhbWUucGFyZW50Tm9kZSAhPT0gbnVsbCkge1xuICAgICAgICBjYW52YXMuZnJhbWUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjYW52YXMuZnJhbWUpO1xuICAgICAgfVxuICAgICAgY2FudmFzLmZyYW1lID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cblxuXG4vKiBSZW5kZXJpbmcgKi9cblxuLy8gUHJvdmlkZXM6IG1sX2NhbnZhc19jb21taXRcbmZ1bmN0aW9uIG1sX2NhbnZhc19jb21taXQoY2FudmFzKSB7XG4gIHJldHVybiAwO1xufVxuXG5cblxuLyogQ29uZmlndXJhdGlvbiAqL1xuXG4vLyBQcm92aWRlczogbWxfY2FudmFzX2dldF9pZFxuZnVuY3Rpb24gbWxfY2FudmFzX2dldF9pZChjYW52YXMpIHtcbiAgcmV0dXJuIGNhbnZhcy5pZDtcbn1cblxuLy8gUHJvdmlkZXM6IG1sX2NhbnZhc19nZXRfc2l6ZVxuZnVuY3Rpb24gbWxfY2FudmFzX2dldF9zaXplKGNhbnZhcykge1xuICByZXR1cm4gWzAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodF07XG59XG5cbi8vIFByb3ZpZGVzOiBtbF9jYW52YXNfc2V0X3NpemVcbi8vIFJlcXVpcmVzOiBfbWxfY2FudmFzX3ZhbGlkX2NhbnZhc19zaXplLCBfbWxfY2FudmFzX2RlY29yYXRlXG4vLyBSZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBtbF9jYW52YXNfc2V0X3NpemUoY2FudmFzLCBzaXplKSB7XG4gIHZhciB3aWR0aCA9IHNpemVbMV07XG4gIHZhciBoZWlnaHQgPSBzaXplWzJdO1xuICBpZiAoIV9tbF9jYW52YXNfdmFsaWRfY2FudmFzX3NpemUod2lkdGgsIGhlaWdodCkpIHtcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJDYW52YXMuc2V0U2l6ZTogaW52YWxpZCBkaW1lbnNpb25zXCIpO1xuICB9XG4gIHZhciBpbWcgPSBjYW52YXMuY3R4dC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgaWYgKGNhbnZhcy5oZWFkZXIgIT09IG51bGwpIHtcbiAgICAgIGNhbnZhcy5oZWFkZXIud2lkdGggPSB3aWR0aDtcbiAgICAgIF9tbF9jYW52YXNfZGVjb3JhdGUoY2FudmFzLmhlYWRlciwgY2FudmFzLm1pbmltaXplLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBjYW52YXMubWF4aW1pemUsIGNhbnZhcy5jbG9zZSwgY2FudmFzLm5hbWUpO1xuICB9XG4gIGNhbnZhcy5zdXJmYWNlLndpZHRoID0gY2FudmFzLndpZHRoID0gd2lkdGg7XG4gIGNhbnZhcy5zdXJmYWNlLmhlaWdodCA9IGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gIGNhbnZhcy5jdHh0LmZpbGxSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICBjYW52YXMuY3R4dC5wdXRJbWFnZURhdGEoaW1nLCAwLCAwKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vIFByb3ZpZGVzOiBtbF9jYW52YXNfZ2V0X3Bvc2l0aW9uXG5mdW5jdGlvbiBtbF9jYW52YXNfZ2V0X3Bvc2l0aW9uKGNhbnZhcykge1xuICBpZiAoY2FudmFzLmZyYW1lICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIFswLCBjYW52YXMueCwgY2FudmFzLnldO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBbMCwgMCwgMF07XG4gIH1cbn1cblxuLy8gUHJvdmlkZXM6IG1sX2NhbnZhc19zZXRfcG9zaXRpb25cbmZ1bmN0aW9uIG1sX2NhbnZhc19zZXRfcG9zaXRpb24oY2FudmFzLCBwb3MpIHtcbiAgaWYgKGNhbnZhcy5mcmFtZSAhPT0gbnVsbCkge1xuICAgIHZhciB4ID0gcG9zWzFdO1xuICAgIHZhciB5ID0gcG9zWzJdO1xuICAgIGNhbnZhcy54ID0geDtcbiAgICBjYW52YXMueSA9IHk7XG4gICAgY2FudmFzLmZyYW1lLnN0eWxlLmxlZnQgPSB4ICsgXCJweFwiO1xuICAgIGNhbnZhcy5mcmFtZS5zdHlsZS50b3AgPSB5ICsgXCJweFwiO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG5cblxuLyogVHJhbnNmb3JtICovXG5cbi8vIFByb3ZpZGVzOiBtbF9jYW52YXNfc2V0X3RyYW5zZm9ybVxuZnVuY3Rpb24gbWxfY2FudmFzX3NldF90cmFuc2Zvcm0oY2FudmFzLCB0KSB7XG4gIGNhbnZhcy5jdHh0LnNldFRyYW5zZm9ybSh0WzFdLCB0WzJdLCB0WzNdLCB0WzRdLCB0WzVdLCB0WzZdKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vIFByb3ZpZGVzOiBtbF9jYW52YXNfdHJhbnNmb3JtXG5mdW5jdGlvbiBtbF9jYW52YXNfdHJhbnNmb3JtKGNhbnZhcywgdCkge1xuICBjYW52YXMuY3R4dC50cmFuc2Zvcm0odFsxXSwgdFsyXSwgdFszXSwgdFs0XSwgdFs1XSwgdFs2XSk7XG4gIHJldHVybiAwO1xufVxuXG4vLyBQcm92aWRlczogbWxfY2FudmFzX3RyYW5zbGF0ZVxuZnVuY3Rpb24gbWxfY2FudmFzX3RyYW5zbGF0ZShjYW52YXMsIHZlYykge1xuICBjYW52YXMuY3R4dC50cmFuc2xhdGUodmVjWzFdLCB2ZWNbMl0pO1xuICByZXR1cm4gMDtcbn1cblxuLy8gUHJvdmlkZXM6IG1sX2NhbnZhc19zY2FsZVxuZnVuY3Rpb24gbWxfY2FudmFzX3NjYWxlKGNhbnZhcywgdmVjKSB7XG4gIGNhbnZhcy5jdHh0LnNjYWxlKHZlY1sxXSwgdmVjWzJdKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vIFByb3ZpZGVzOiBtbF9jYW52YXNfc2hlYXJcbmZ1bmN0aW9uIG1sX2NhbnZhc19zaGVhcihjYW52YXMsIHZlYykge1xuICBjYW52YXMuY3R4dC50cmFuc2Zvcm0oMS4wLCB2ZWNbMl0sIHZlY1sxXSwgMS4wLCAwLjAsIDAuMCk7XG4gIHJldHVybiAwO1xufVxuXG4vLyBQcm92aWRlczogbWxfY2FudmFzX3JvdGF0ZVxuZnVuY3Rpb24gbWxfY2FudmFzX3JvdGF0ZShjYW52YXMsIHRoZXRhKSB7XG4gIGNhbnZhcy5jdHh0LnJvdGF0ZSh0aGV0YSk7XG4gIHJldHVybiAwO1xufVxuXG5cblxuLyogU3RhdGUgKi9cblxuLy8gUHJvdmlkZXM6IG1sX2NhbnZhc19zYXZlXG5mdW5jdGlvbiBtbF9jYW52YXNfc2F2ZShjYW52YXMpIHtcbiAgY2FudmFzLmN0eHQuc2F2ZSgpO1xuICByZXR1cm4gMDtcbn1cblxuLy8gUHJvdmlkZXM6IG1sX2NhbnZhc19yZXN0b3JlXG5mdW5jdGlvbiBtbF9jYW52YXNfcmVzdG9yZShjYW52YXMpIHtcbiAgY2FudmFzLmN0eHQucmVzdG9yZSgpO1xuICByZXR1cm4gMDtcbn1cblxuXG5cbi8qIFN0eWxlIC8gY29uZmlnICovXG5cbi8vUHJvdmlkZXM6IF9jb2xvcl9vZl9pbnRcbmZ1bmN0aW9uIF9jb2xvcl9vZl9pbnQoaSkge1xuICB2YXIgYSA9ICgoaSAmIDB4RkYwMDAwMDApID4+PiAyNCk7XG4gIGlmIChhID09IDI1NSkge1xuICAgIHJldHVybiBcIiNcIiArIChpICYgMHgwMEZGRkZGRikudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDYsICcwJyk7XG4gIH1cbiAgdmFyIGIgPSBpICYgMHgwMDAwMDBGRjtcbiAgdmFyIGcgPSAoaSAmIDB4MDAwMEZGMDApID4+PiA4O1xuICB2YXIgciA9IChpICYgMHgwMEZGMDAwMCkgPj4+IDE2O1xuICByZXR1cm4gXCJyZ2JhKFwiICsgciArIFwiLFwiICsgZyArIFwiLFwiICsgYiArIFwiLFwiICsgYSAvIDI1NS4wICsgXCIpXCI7XG59XG5cbi8vUHJvdmlkZXM6IF9pbnRfb2ZfY29sb3JcbmZ1bmN0aW9uIF9pbnRfb2ZfY29sb3IoYykge1xuICBpZiAoY1swXSA9PSAnIycpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQoYy5zdWJzdHIoMSwgYy5sZW5ndGggLSAxKSwgMTYpO1xuICB9IGVsc2Uge1xuICAgIHZhciByZ2JhID0gYy5yZXBsYWNlKC9ecmdiYT9cXCh8XFxzK3xcXCkkL2csICcnKS5zcGxpdCgnLCcpO1xuICAgIHZhciByID0gcGFyc2VJbnQocmdiYVswXSk7XG4gICAgdmFyIGcgPSBwYXJzZUludChyZ2JhWzFdKTtcbiAgICB2YXIgYiA9IHBhcnNlSW50KHJnYmFbMl0pO1xuICAgIHZhciBhID0gcGFyc2VGbG9hdChyZ2JhWzNdKSAqIDI1NTtcbiAgICByZXR1cm4gYiB8IChnIDw8IDgpIHwgKHIgPDwgMTYpIHwgKGEgPDwgMjQpO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IG1sX2NhbnZhc19nZXRfbGluZV93aWR0aFxuZnVuY3Rpb24gbWxfY2FudmFzX2dldF9saW5lX3dpZHRoKGNhbnZhcykge1xuICByZXR1cm4gY2FudmFzLmN0eHQubGluZVdpZHRoO1xufVxuXG4vL1Byb3ZpZGVzOiBtbF9jYW52YXNfc2V0X2xpbmVfd2lkdGhcbmZ1bmN0aW9uIG1sX2NhbnZhc19zZXRfbGluZV93aWR0aChjYW52YXMsIHdpZHRoKSB7XG4gIGNhbnZhcy5jdHh0LmxpbmVXaWR0aCA9IHdpZHRoO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogbWxfY2FudmFzX2dldF9saW5lX2NhcFxuLy9SZXF1aXJlczogVmFsX2NhcF90eXBlXG5mdW5jdGlvbiBtbF9jYW52YXNfZ2V0X2xpbmVfY2FwKGNhbnZhcykge1xuICByZXR1cm4gVmFsX2NhcF90eXBlKGNhbnZhcy5saW5lQ2FwKTtcbn1cblxuLy9Qcm92aWRlczogbWxfY2FudmFzX3NldF9saW5lX2NhcFxuLy9SZXF1aXJlczogQ2FwX3R5cGVfdmFsXG5mdW5jdGlvbiBtbF9jYW52YXNfc2V0X2xpbmVfY2FwKGNhbnZhcywgY2FwKSB7XG4gIGNhbnZhcy5jdHh0LmxpbmVDYXAgPSBDYXBfdHlwZV92YWwoY2FwKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IG1sX2NhbnZhc19nZXRfbGluZV9kYXNoX29mZnNldFxuZnVuY3Rpb24gbWxfY2FudmFzX2dldF9saW5lX2Rhc2hfb2Zmc2V0KGNhbnZhcykge1xuICByZXR1cm4gY2FudmFzLmN0eHQubGluZURhc2hPZmZzZXQ7XG59XG5cbi8vUHJvdmlkZXM6IG1sX2NhbnZhc19zZXRfbGluZV9kYXNoX29mZnNldFxuZnVuY3Rpb24gbWxfY2FudmFzX3NldF9saW5lX2Rhc2hfb2Zmc2V0KGNhbnZhcywgb2Zmc2V0KSB7XG4gIGNhbnZhcy5jdHh0LmxpbmVEYXNoT2Zmc2V0ID0gb2Zmc2V0O1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogbWxfY2FudmFzX2dldF9saW5lX2Rhc2hcbmZ1bmN0aW9uIG1sX2NhbnZhc19nZXRfbGluZV9kYXNoKGNhbnZhcykge1xuICB2YXIgYXJyID0gY2FudmFzLmN0eHQuZ2V0TGluZURhc2goKTtcbiAgYXJyLnVuc2hpZnQoMjU0KTsgLy8gRG91YmxlIGFycmF5IHRhZ1xuICByZXR1cm4gYXJyO1xufVxuXG4vL1Byb3ZpZGVzOiBtbF9jYW52YXNfc2V0X2xpbmVfZGFzaFxuZnVuY3Rpb24gbWxfY2FudmFzX3NldF9saW5lX2Rhc2goY2FudmFzLCBkYXNoKSB7XG4gIGRhc2guc2hpZnQoKTtcbiAgY2FudmFzLmN0eHQuc2V0TGluZURhc2goZGFzaCk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBtbF9jYW52YXNfZ2V0X2xpbmVfam9pblxuLy9SZXF1aXJlczogVmFsX2pvaW5fdHlwZVxuZnVuY3Rpb24gbWxfY2FudmFzX2dldF9saW5lX2pvaW4oY2FudmFzKSB7XG4gIHJldHVybiBWYWxfam9pbl90eXBlKGNhbnZhcy5saW5lSm9pbik7XG59XG5cbi8vUHJvdmlkZXM6IG1sX2NhbnZhc19zZXRfbGluZV9qb2luXG4vL1JlcXVpcmVzOiBKb2luX3R5cGVfdmFsXG5mdW5jdGlvbiBtbF9jYW52YXNfc2V0X2xpbmVfam9pbihjYW52YXMsIGpvaW4pIHtcbiAgY2FudmFzLmN0eHQubGluZUpvaW4gPSBKb2luX3R5cGVfdmFsKGpvaW4pO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogbWxfY2FudmFzX2dldF9taXRlcl9saW1pdFxuZnVuY3Rpb24gbWxfY2FudmFzX2dldF9taXRlcl9saW1pdChjYW52YXMpIHtcbiAgcmV0dXJuIGNhbnZhcy5jdHh0Lm1pdGVyTGltaXQ7XG59XG5cbi8vUHJvdmlkZXM6IG1sX2NhbnZhc19zZXRfbWl0ZXJfbGltaXRcbmZ1bmN0aW9uIG1sX2NhbnZhc19zZXRfbWl0ZXJfbGltaXQoY2FudmFzLCBsaW1pdCkge1xuICBjYW52YXMuY3R4dC5taXRlckxpbWl0ID0gbGltaXQ7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBtbF9jYW52YXNfZ2V0X3N0cm9rZV9jb2xvclxuLy9SZXF1aXJlczogX2ludF9vZl9jb2xvclxuZnVuY3Rpb24gbWxfY2FudmFzX2dldF9zdHJva2VfY29sb3IoY2FudmFzKSB7XG4gIGlmICh0eXBlb2YoY2FudmFzLmN0eHQuc3Ryb2tlU3R5bGUpID09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gX2ludF9vZl9jb2xvcihjYW52YXMuY3R4dC5zdHJva2VTdHlsZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbn1cblxuLy9Qcm92aWRlczogbWxfY2FudmFzX3NldF9zdHJva2VfY29sb3Jcbi8vUmVxdWlyZXM6IF9jb2xvcl9vZl9pbnRcbmZ1bmN0aW9uIG1sX2NhbnZhc19zZXRfc3Ryb2tlX2NvbG9yKGNhbnZhcywgY29sb3IpIHtcbiAgY2FudmFzLmN0eHQuc3Ryb2tlU3R5bGUgPSBfY29sb3Jfb2ZfaW50KGNvbG9yKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IG1sX2NhbnZhc19zZXRfc3Ryb2tlX2dyYWRpZW50XG5mdW5jdGlvbiBtbF9jYW52YXNfc2V0X3N0cm9rZV9ncmFkaWVudChjYW52YXMsIGdyYWQpIHtcbiAgY2FudmFzLmN0eHQuc3Ryb2tlU3R5bGUgPSBncmFkO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogbWxfY2FudmFzX3NldF9zdHJva2VfcGF0dGVyblxuZnVuY3Rpb24gbWxfY2FudmFzX3NldF9zdHJva2VfcGF0dGVybihjYW52YXMsIHBhdHRlcm4pIHtcbiAgY2FudmFzLmN0eHQuc3Ryb2tlU3R5bGUgPSBwYXR0ZXJuO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogbWxfY2FudmFzX3NldF9zdHJva2Vfc3R5bGVcbi8vUmVxdWlyZXM6IFZhbF9kcmF3X3N0eWxlXG5mdW5jdGlvbiBtbF9jYW52YXNfc2V0X3N0cm9rZV9zdHlsZShjYW52YXMsIHN0eWxlKSB7XG4gIGNhbnZhcy5jdHh0LnN0cm9rZVN0eWxlID0gVmFsX2RyYXdfc3R5bGUoc3R5bGUpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogbWxfY2FudmFzX2dldF9zdHJva2Vfc3R5bGVcbi8vUmVxdWlyZXM6IERyYXdfc3R5bGVfdmFsXG5mdW5jdGlvbiBtbF9jYW52YXNfZ2V0X3N0cm9rZV9zdHlsZShjYW52YXMpIHtcbiAgcmV0dXJuIERyYXdfc3R5bGVfdmFsKGNhbnZhcy5jdHh0LnN0cm9rZVN0eWxlKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IG1sX2NhbnZhc19nZXRfZmlsbF9jb2xvclxuLy9SZXF1aXJlczogX2ludF9vZl9jb2xvclxuZnVuY3Rpb24gbWxfY2FudmFzX2dldF9maWxsX2NvbG9yKGNhbnZhcykge1xuICBpZiAodHlwZW9mKGNhbnZhcy5jdHh0LmZpbGxTdHlsZSkgPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBfaW50X29mX2NvbG9yKGNhbnZhcy5jdHh0LmZpbGxTdHlsZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbn1cblxuLy9Qcm92aWRlczogbWxfY2FudmFzX3NldF9maWxsX2NvbG9yXG4vL1JlcXVpcmVzOiBfY29sb3Jfb2ZfaW50XG5mdW5jdGlvbiBtbF9jYW52YXNfc2V0X2ZpbGxfY29sb3IoY2FudmFzLCBjb2xvcikge1xuICBjYW52YXMuY3R4dC5maWxsU3R5bGUgPSBfY29sb3Jfb2ZfaW50KGNvbG9yKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IG1sX2NhbnZhc19nZXRfZ2xvYmFsX2FscGhhXG5mdW5jdGlvbiBtbF9jYW52YXNfZ2V0X2dsb2JhbF9hbHBoYShjYW52YXMpIHtcbiAgcmV0dXJuIGNhbnZhcy5jdHh0Lmdsb2JhbEFscGhhO1xufVxuXG4vL1Byb3ZpZGVzOiBtbF9jYW52YXNfc2V0X2dsb2JhbF9hbHBoYVxuZnVuY3Rpb24gbWxfY2FudmFzX3NldF9nbG9iYWxfYWxwaGEoY2FudmFzLCBnbG9iYWxfYWxwaGEpIHtcbiAgY2FudmFzLmN0eHQuZ2xvYmFsQWxwaGEgPSBnbG9iYWxfYWxwaGE7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBtbF9jYW52YXNfc2V0X2ZpbGxfZ3JhZGllbnRcbmZ1bmN0aW9uIG1sX2NhbnZhc19zZXRfZmlsbF9ncmFkaWVudChjYW52YXMsIGdyYWQpIHtcbiAgY2FudmFzLmN0eHQuZmlsbFN0eWxlID0gZ3JhZDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IG1sX2NhbnZhc19zZXRfZmlsbF9wYXR0ZXJuXG5mdW5jdGlvbiBtbF9jYW52YXNfc2V0X2ZpbGxfcGF0dGVybihjYW52YXMsIHBhdHRlcm4pIHtcbiAgY2FudmFzLmN0eHQuZmlsbFN0eWxlID0gcGF0dGVybjtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IG1sX2NhbnZhc19zZXRfZmlsbF9zdHlsZVxuLy9SZXF1aXJlczogVmFsX2RyYXdfc3R5bGVcbmZ1bmN0aW9uIG1sX2NhbnZhc19zZXRfZmlsbF9zdHlsZShjYW52YXMsIHN0eWxlKSB7XG4gIGNhbnZhcy5jdHh0LmZpbGxTdHlsZSA9IFZhbF9kcmF3X3N0eWxlKHN0eWxlKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IG1sX2NhbnZhc19nZXRfZmlsbF9zdHlsZVxuLy9SZXF1aXJlczogRHJhd19zdHlsZV92YWxcbmZ1bmN0aW9uIG1sX2NhbnZhc19nZXRfZmlsbF9zdHlsZShjYW52YXMpIHtcbiAgcmV0dXJuIERyYXdfc3R5bGVfdmFsKGNhbnZhcy5jdHh0LmZpbGxTdHlsZSk7XG59XG5cbi8vUHJvdmlkZXM6IG1sX2NhbnZhc19nZXRfZ2xvYmFsX2NvbXBvc2l0ZV9vcGVyYXRpb25cbi8vUmVxdWlyZXM6IFZhbF9jb21wb3BcbmZ1bmN0aW9uIG1sX2NhbnZhc19nZXRfZ2xvYmFsX2NvbXBvc2l0ZV9vcGVyYXRpb24oY2FudmFzKSB7XG4gIHJldHVybiBWYWxfY29tcG9wKGNhbnZhcy5jdHh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbik7XG59XG5cbi8vUHJvdmlkZXM6IG1sX2NhbnZhc19zZXRfZ2xvYmFsX2NvbXBvc2l0ZV9vcGVyYXRpb25cbi8vUmVxdWlyZXM6IENvbXBvcF92YWxcbmZ1bmN0aW9uIG1sX2NhbnZhc19zZXRfZ2xvYmFsX2NvbXBvc2l0ZV9vcGVyYXRpb24oY2FudmFzLCBvcCkge1xuICBjYW52YXMuY3R4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBDb21wb3BfdmFsKG9wKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IG1sX2NhbnZhc19nZXRfc2hhZG93X2NvbG9yXG4vL1JlcXVpcmVzOiBfaW50X29mX2NvbG9yXG5mdW5jdGlvbiBtbF9jYW52YXNfZ2V0X3NoYWRvd19jb2xvcihjYW52YXMpIHtcbiAgcmV0dXJuIF9pbnRfb2ZfY29sb3IoY2FudmFzLmN0eHQuc2hhZG93Q29sb3IpO1xufVxuXG4vL1Byb3ZpZGVzOiBtbF9jYW52YXNfc2V0X3NoYWRvd19jb2xvclxuLy9SZXF1aXJlczogX2NvbG9yX29mX2ludFxuZnVuY3Rpb24gbWxfY2FudmFzX3NldF9zaGFkb3dfY29sb3IoY2FudmFzLCBjb2xvcikge1xuICBjYW52YXMuY3R4dC5zaGFkb3dDb2xvciA9IF9jb2xvcl9vZl9pbnQoY29sb3IpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogbWxfY2FudmFzX2dldF9zaGFkb3dfYmx1clxuZnVuY3Rpb24gbWxfY2FudmFzX2dldF9zaGFkb3dfYmx1cihjYW52YXMpIHtcbiAgcmV0dXJuIGNhbnZhcy5jdHh0LnNoYWRvd0JsdXI7XG59XG5cbi8vUHJvdmlkZXM6IG1sX2NhbnZhc19zZXRfc2hhZG93X2JsdXJcbmZ1bmN0aW9uIG1sX2NhbnZhc19zZXRfc2hhZG93X2JsdXIoY2FudmFzLCBibHVyKSB7XG4gIGNhbnZhcy5jdHh0LnNoYWRvd0JsdXIgPSBibHVyO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogbWxfY2FudmFzX2dldF9zaGFkb3dfb2Zmc2V0XG5mdW5jdGlvbiBtbF9jYW52YXNfZ2V0X3NoYWRvd19vZmZzZXQoY2FudmFzLCBvZmZzZXQpIHtcbiAgcmV0dXJuIFswLCBjYW52YXMuY3R4dC5zaGFkb3dPZmZzZXRYLCBjYW52YXMuY3R4dC5zaGFkb3dPZmZzZXRZXTtcbn1cblxuLy9Qcm92aWRlczogbWxfY2FudmFzX3NldF9zaGFkb3dfb2Zmc2V0XG5mdW5jdGlvbiBtbF9jYW52YXNfc2V0X3NoYWRvd19vZmZzZXQoY2FudmFzLCBvZmZzZXQpIHtcbiAgY2FudmFzLmN0eHQuc2hhZG93T2Zmc2V0WCA9IG9mZnNldFsxXTtcbiAgY2FudmFzLmN0eHQuc2hhZG93T2Zmc2V0WSA9IG9mZnNldFsyXTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IG1sX2NhbnZhc19zZXRfZm9udFxuLy9SZXF1aXJlczogU2xhbnRfdmFsLCBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gbWxfY2FudmFzX3NldF9mb250KGNhbnZhcywgZmFtaWx5LCBzaXplLCBzbGFudCwgd2VpZ2h0KSB7XG4gIGNhbnZhcy5jdHh0LmZvbnQgPVxuICAgIFNsYW50X3ZhbChzbGFudCkgKyBcIiBcIiArIHdlaWdodCArIFwiIFwiICsgc2l6ZSArIFwicHQgXCIgK1xuICAgICAgICBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhmYW1pbHkpO1xuICByZXR1cm4gMDtcbn1cblxuXG5cbi8qIFBhdGhzICovXG5cbi8vUHJvdmlkZXM6IG1sX2NhbnZhc19jbGVhcl9wYXRoXG5mdW5jdGlvbiBtbF9jYW52YXNfY2xlYXJfcGF0aChjYW52YXMpIHtcbiAgY2FudmFzLmN0eHQuYmVnaW5QYXRoKCk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBtbF9jYW52YXNfY2xvc2VfcGF0aFxuZnVuY3Rpb24gbWxfY2FudmFzX2Nsb3NlX3BhdGgoY2FudmFzKSB7XG4gIGNhbnZhcy5jdHh0LmNsb3NlUGF0aCgpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogbWxfY2FudmFzX21vdmVfdG9cbmZ1bmN0aW9uIG1sX2NhbnZhc19tb3ZlX3RvKGNhbnZhcywgcCkge1xuICBjYW52YXMuY3R4dC5tb3ZlVG8ocFsxXSwgcFsyXSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBtbF9jYW52YXNfbGluZV90b1xuZnVuY3Rpb24gbWxfY2FudmFzX2xpbmVfdG8oY2FudmFzLCBwKSB7XG4gIGNhbnZhcy5jdHh0LmxpbmVUbyhwWzFdLCBwWzJdKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IG1sX2NhbnZhc19hcmNcbmZ1bmN0aW9uIG1sX2NhbnZhc19hcmMoY2FudmFzLCBwLCByYWRpdXMsIHRoZXRhMSwgdGhldGEyLCBjY3cpIHtcbiAgY2FudmFzLmN0eHQuYXJjKHBbMV0sIHBbMl0sIHJhZGl1cywgdGhldGExLCB0aGV0YTIsIGNjdyk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBtbF9jYW52YXNfYXJjX3RvXG5mdW5jdGlvbiBtbF9jYW52YXNfYXJjX3RvKGNhbnZhcywgcDEsIHAyLCByYWRpdXMpIHtcbiAgY2FudmFzLmN0eHQuYXJjVG8ocDFbMV0sIHAxWzJdLCBwMlsxXSwgcDJbMl0sIHJhZGl1cyk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBtbF9jYW52YXNfcXVhZHJhdGljX2N1cnZlX3RvXG5mdW5jdGlvbiBtbF9jYW52YXNfcXVhZHJhdGljX2N1cnZlX3RvKGNhbnZhcywgcDEsIHAyKSB7XG4gIGNhbnZhcy5jdHh0LnF1YWRyYXRpY0N1cnZlVG8ocDFbMV0sIHAxWzJdLCBwMlsxXSwgcDJbMl0pO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogbWxfY2FudmFzX2Jlemllcl9jdXJ2ZV90b1xuZnVuY3Rpb24gbWxfY2FudmFzX2Jlemllcl9jdXJ2ZV90byhjYW52YXMsIHAxLCBwMiwgcDMpIHtcbiAgY2FudmFzLmN0eHQuYmV6aWVyQ3VydmVUbyhwMVsxXSwgcDFbMl0sIHAyWzFdLCBwMlsyXSwgcDNbMV0sIHAzWzJdKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IG1sX2NhbnZhc19yZWN0XG5mdW5jdGlvbiBtbF9jYW52YXNfcmVjdChjYW52YXMsIHBvcywgc2l6ZSkge1xuICBjYW52YXMuY3R4dC5yZWN0KHBvc1sxXSwgcG9zWzJdLCBzaXplWzFdLCBzaXplWzJdKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IG1sX2NhbnZhc19lbGxpcHNlXG5mdW5jdGlvbiBtbF9jYW52YXNfZWxsaXBzZShjYW52YXMsIHAsIHJhZGl1cywgcm90YXRpb24sIHRoZXRhMSwgdGhldGEyLCBjY3cpIHtcbiAgY2FudmFzLmN0eHQuZWxsaXBzZShwWzFdLCBwWzJdLCByYWRpdXNbMV0sIHJhZGl1c1syXSxcbiAgICAgICAgICAgICAgICAgICAgICByb3RhdGlvbiwgdGhldGExLCB0aGV0YTIsIGNjdyk7XG4gIHJldHVybiAwO1xufVxuXG5cbi8qIFBhdGggc3Ryb2tpbmcvZmlsbGluZyAqL1xuXG4vL1Byb3ZpZGVzOiBtbF9jYW52YXNfZmlsbFxuZnVuY3Rpb24gbWxfY2FudmFzX2ZpbGwoY2FudmFzLCBub256ZXJvKSB7XG4gIGlmIChub256ZXJvKSB7XG4gICAgY2FudmFzLmN0eHQuZmlsbChcIm5vbnplcm9cIik7XG4gIH0gZWxzZSB7XG4gICAgY2FudmFzLmN0eHQuZmlsbCgpOyAvLyBcImV2ZW5vZGRcIlxuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBtbF9jYW52YXNfZmlsbF9wYXRoXG5mdW5jdGlvbiBtbF9jYW52YXNfZmlsbF9wYXRoKGNhbnZhcywgcGF0aCwgbm9uemVybykge1xuICBpZiAobm9uemVybykge1xuICAgIGNhbnZhcy5jdHh0LmZpbGwocGF0aCwgXCJub256ZXJvXCIpO1xuICB9IGVsc2Uge1xuICAgIGNhbnZhcy5jdHh0LmZpbGwocGF0aCk7IC8vIFwiZXZlbm9kZFwiXG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IG1sX2NhbnZhc19zdHJva2VcbmZ1bmN0aW9uIG1sX2NhbnZhc19zdHJva2UoY2FudmFzKSB7XG4gIGNhbnZhcy5jdHh0LnN0cm9rZSgpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogbWxfY2FudmFzX3N0cm9rZV9wYXRoXG5mdW5jdGlvbiBtbF9jYW52YXNfc3Ryb2tlX3BhdGgoY2FudmFzLCBwYXRoKSB7XG4gIGNhbnZhcy5jdHh0LnN0cm9rZShwYXRoKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IG1sX2NhbnZhc19jbGlwXG5mdW5jdGlvbiBtbF9jYW52YXNfY2xpcChjYW52YXMsIG5vbnplcm8pIHtcbiAgaWYgKG5vbnplcm8pIHtcbiAgICBjYW52YXMuY3R4dC5jbGlwKFwibm9uemVyb1wiKTtcbiAgfSBlbHNlIHtcbiAgICBjYW52YXMuY3R4dC5jbGlwKCk7IC8vIFwiZXZlbm9kZFwiXG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IG1sX2NhbnZhc19jbGlwX3BhdGhcbmZ1bmN0aW9uIG1sX2NhbnZhc19jbGlwX3BhdGgoY2FudmFzLCBwYXRoLCBub256ZXJvKSB7XG4gIGlmIChub256ZXJvKSB7XG4gICAgY2FudmFzLmN0eHQuY2xpcChwYXRoLCBcIm5vbnplcm9cIik7XG4gIH0gZWxzZSB7XG4gICAgY2FudmFzLmN0eHQuY2xpcChwYXRoKTsgLy8gXCJldmVub2RkXCJcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuXG5cbi8qIEltbWVkaWF0ZSBkcmF3aW5nICovXG5cbi8vUHJvdmlkZXM6IG1sX2NhbnZhc19maWxsX3JlY3RcbmZ1bmN0aW9uIG1sX2NhbnZhc19maWxsX3JlY3QoY2FudmFzLCBwb3MsIHNpemUpIHtcbiAgY2FudmFzLmN0eHQuZmlsbFJlY3QocG9zWzFdLCBwb3NbMl0sIHNpemVbMV0sIHNpemVbMl0pO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogbWxfY2FudmFzX3N0cm9rZV9yZWN0XG5mdW5jdGlvbiBtbF9jYW52YXNfc3Ryb2tlX3JlY3QoY2FudmFzLCBwb3MsIHNpemUpIHtcbiAgY2FudmFzLmN0eHQuc3Ryb2tlUmVjdChwb3NbMV0sIHBvc1syXSwgc2l6ZVsxXSwgc2l6ZVsyXSk7XG4gIHJldHVybiAwO1xufVxuXG5cbi8vUHJvdmlkZXM6IG1sX2NhbnZhc19maWxsX3RleHRcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBtbF9jYW52YXNfZmlsbF90ZXh0KGNhbnZhcywgdGV4dCwgcG9zKSB7XG4gIGNhbnZhcy5jdHh0LmZpbGxUZXh0KGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHRleHQpLCBwb3NbMV0sIHBvc1syXSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBtbF9jYW52YXNfc3Ryb2tlX3RleHRcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBtbF9jYW52YXNfc3Ryb2tlX3RleHQoY2FudmFzLCB0ZXh0LCBwb3MpIHtcbiAgY2FudmFzLmN0eHQuc3Ryb2tlVGV4dChjYW1sX2pzc3RyaW5nX29mX3N0cmluZyh0ZXh0KSwgcG9zWzFdLCBwb3NbMl0pO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogbWxfY2FudmFzX2JsaXRcbi8vUmVxdWlyZXM6IF9tbF9jYW52YXNfdmFsaWRfY2FudmFzX3NpemVcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gbWxfY2FudmFzX2JsaXQoZHN0X2NhbnZhcywgZHBvcywgc3JjX2NhbnZhcywgc3Bvcywgc2l6ZSkge1xuICB2YXIgd2lkdGggPSBzaXplWzFdO1xuICB2YXIgaGVpZ2h0ID0gc2l6ZVsyXTtcbiAgaWYgKCFfbWxfY2FudmFzX3ZhbGlkX2NhbnZhc19zaXplKHdpZHRoLCBoZWlnaHQpKSB7XG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQ2FudmFzLmJsaXQ6IGludmFsaWQgZGltZW5zaW9uc1wiKTtcbiAgfVxuICBkc3RfY2FudmFzLmN0eHQuZHJhd0ltYWdlKHNyY19jYW52YXMuc3VyZmFjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcG9zWzFdLCBzcG9zWzJdLCB3aWR0aCwgaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRwb3NbMV0sIGRwb3NbMl0sIHdpZHRoLCBoZWlnaHQpO1xuICByZXR1cm4gMDtcbn1cblxuXG4vKiBEaXJlY3QgcGl4ZWwgYWNjZXNzICovXG5cbi8vUHJvdmlkZXM6IG1sX2NhbnZhc19nZXRfcGl4ZWxcbmZ1bmN0aW9uIG1sX2NhbnZhc19nZXRfcGl4ZWwoY2FudmFzLCBwb3MpIHtcbiAgdmFyIGltYWdlID0gY2FudmFzLmN0eHQuZ2V0SW1hZ2VEYXRhKHBvc1sxXSwgcG9zWzJdLCAxLCAxKTtcbiAgcmV0dXJuICgoaW1hZ2UuZGF0YVszXSA8PCAyNCkgPj4+IDApIHxcbiAgICAgICAgICAoaW1hZ2UuZGF0YVswXSA8PCAxNikgfFxuICAgICAgICAgIChpbWFnZS5kYXRhWzFdIDw8IDgpIHxcbiAgICAgICAgICAoaW1hZ2UuZGF0YVsyXSA8PCAwKTtcbn1cblxuLy9Qcm92aWRlczogbWxfY2FudmFzX3B1dF9waXhlbFxuZnVuY3Rpb24gbWxfY2FudmFzX3B1dF9waXhlbChjYW52YXMsIHBvcywgY29sb3IpIHtcbiAgdmFyIGltYWdlID0gY2FudmFzLmN0eHQuY3JlYXRlSW1hZ2VEYXRhKDEsIDEpO1xuICBpbWFnZS5kYXRhWzNdID0gKGNvbG9yICYgMHhGRjAwMDAwMCkgPj4+IDI0OyAvLyBBXG4gIGltYWdlLmRhdGFbMF0gPSAoY29sb3IgJiAweDAwRkYwMDAwKSA+Pj4gMTY7IC8vIFJcbiAgaW1hZ2UuZGF0YVsxXSA9IChjb2xvciAmIDB4MDAwMEZGMDApID4+PiA4OyAvLyBHXG4gIGltYWdlLmRhdGFbMl0gPSAoY29sb3IgJiAweDAwMDAwMEZGKSA+Pj4gMDsgLy8gQlxuICBjYW52YXMuY3R4dC5wdXRJbWFnZURhdGEoaW1hZ2UsIHBvc1sxXSwgcG9zWzJdKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IG1sX2NhbnZhc19nZXRfaW1hZ2VfZGF0YVxuLy9SZXF1aXJlczogX21sX2NhbnZhc192YWxpZF9jYW52YXNfc2l6ZVxuLy9SZXF1aXJlczogY2FtbF9iYV9jcmVhdGVfdW5zYWZlLCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIG1sX2NhbnZhc19nZXRfaW1hZ2VfZGF0YShjYW52YXMsIHBvcywgc2l6ZSkge1xuICB2YXIgd2lkdGggPSBzaXplWzFdO1xuICB2YXIgaGVpZ2h0ID0gc2l6ZVsyXTtcbiAgaWYgKCFfbWxfY2FudmFzX3ZhbGlkX2NhbnZhc19zaXplKHdpZHRoLCBoZWlnaHQpKSB7XG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQ2FudmFzLmdldEltYWdlRGF0YTogaW52YWxpZCBkaW1lbnNpb25zXCIpO1xuICB9XG4gIHZhciBpbWFnZSA9IGNhbnZhcy5jdHh0LmdldEltYWdlRGF0YShwb3NbMV0sIHBvc1syXSwgd2lkdGgsIGhlaWdodCk7XG4gIHZhciBzdGEgPSBuZXcgd2luZG93LlVpbnQ4QXJyYXkoaW1hZ2UuZGF0YS5idWZmZXIpO1xuICB2YXIgZHRhID0gbmV3IHdpbmRvdy5VaW50OEFycmF5KHN0YS5sZW5ndGgpO1xuICAvLyBDb252ZXJ0IGZyb20gUkdOQSB0byBCR1JBXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhLmxlbmd0aDsgaSArPSA0KSB7XG4gICAgZHRhW2krMF0gPSBzdGFbaSsyXTtcbiAgICBkdGFbaSsxXSA9IHN0YVtpKzFdO1xuICAgIGR0YVtpKzJdID0gc3RhW2krMF07XG4gICAgZHRhW2krM10gPSBzdGFbaSszXTtcbiAgfVxuICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKDMgLyogVWludDhBcnJheSAqLywgMCAvKiBjX2xheW91dCAqLyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbaGVpZ2h0LCB3aWR0aCwgNF0sIGR0YSk7XG59XG5cbi8vUHJvdmlkZXM6IG1sX2NhbnZhc19wdXRfaW1hZ2VfZGF0YVxuLy9SZXF1aXJlczogX21sX2NhbnZhc192YWxpZF9jYW52YXNfc2l6ZVxuLy9SZXF1aXJlczogY2FtbF9iYV90b190eXBlZF9hcnJheSwgY2FtbF9iYV9kaW0sIGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gbWxfY2FudmFzX3B1dF9pbWFnZV9kYXRhKGNhbnZhcywgZHBvcywgZGF0YSwgc3Bvcywgc2l6ZSkge1xuICB2YXIgd2lkdGggPSBzaXplWzFdO1xuICB2YXIgaGVpZ2h0ID0gc2l6ZVsyXTtcbiAgaWYgKCFfbWxfY2FudmFzX3ZhbGlkX2NhbnZhc19zaXplKHdpZHRoLCBoZWlnaHQpKSB7XG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQ2FudmFzLnB1dEltYWdlRGF0YTogaW52YWxpZCBkaW1lbnNpb25zXCIpO1xuICB9XG4gIHZhciBzdGEgPSBuZXcgd2luZG93LlVpbnQ4QXJyYXkoY2FtbF9iYV90b190eXBlZF9hcnJheShkYXRhKS5idWZmZXIpO1xuICB2YXIgZHRhID0gbmV3IHdpbmRvdy5VaW50OENsYW1wZWRBcnJheShzdGEubGVuZ3RoKTtcbiAgLy8gQ29udmVydCBmcm9tIEJHUkEgdG8gUkdCQVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YS5sZW5ndGg7IGkgKz0gNCkge1xuICAgIGR0YVtpKzBdID0gc3RhW2krMl07XG4gICAgZHRhW2krMV0gPSBzdGFbaSsxXTtcbiAgICBkdGFbaSsyXSA9IHN0YVtpKzBdO1xuICAgIGR0YVtpKzNdID0gc3RhW2krM107XG4gIH1cbiAgaWYgKHdpbmRvdy5JbWFnZURhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBpbWFnZSA9XG4gICAgICBjYW52YXMuY3R4dC5jcmVhdGVJbWFnZURhdGEoY2FtbF9iYV9kaW0oZGF0YSwgMSksIGNhbWxfYmFfZGltKGRhdGEsIDApKTtcbiAgICBpbWFnZS5kYXRhLnNldChkdGEpO1xuICB9IGVsc2Uge1xuICAgIHZhciBpbWFnZSA9XG4gICAgICBuZXcgd2luZG93LkltYWdlRGF0YShkdGEsIGNhbWxfYmFfZGltKGRhdGEsIDEpLCBjYW1sX2JhX2RpbShkYXRhLCAwKSk7XG4gIH1cbiAgY2FudmFzLmN0eHQucHV0SW1hZ2VEYXRhKGltYWdlLCBkcG9zWzFdLCBkcG9zWzJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Bvc1sxXSwgc3Bvc1syXSwgd2lkdGgsIGhlaWdodCk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBtbF9jYW52YXNfaW1wb3J0X3BuZ1xuLy9SZXF1aXJlczogX21sX2NhbnZhc19pbWFnZV9vZl9wbmdfZmlsZVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV93aXRoX3N0cmluZywgY2FtbF9uYW1lZF92YWx1ZVxuZnVuY3Rpb24gbWxfY2FudmFzX2ltcG9ydF9wbmcoY2FudmFzLCBwb3MsIGZpbGVuYW1lLCBvbmxvYWQpIHtcbiAgLy9UT0RPOiBjaGVjayByZWFkIGZhaWx1cmVcbiAgdmFyIGltZyA9IF9tbF9jYW52YXNfaW1hZ2Vfb2ZfcG5nX2ZpbGUoZmlsZW5hbWUpO1xuICBpZiAoaW1nID09PSBudWxsKSB7XG4gICAgY2FtbF9yYWlzZV93aXRoX3N0cmluZyhjYW1sX25hbWVkX3ZhbHVlKFwiUmVhZF9wbmdfZmFpbGVkXCIpLCBmaWxlbmFtZSk7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgaW1nWzBdLnRoZW4oZnVuY3Rpb24gKF9faW1nKSB7XG4gICAgY2FudmFzLmN0eHQuZHJhd0ltYWdlKGltZ1sxXSwgcG9zWzFdLCBwb3NbMl0pO1xuICAgIC8vIGltYWdlLCBzeCwgc3ksIHNXaXRkaCwgc0hlaWdodCwgZHgsIGR5LCBkV2lkdGgsIGRIZWlnaHRcbiAgICBvbmxvYWQoY2FudmFzKTtcbiAgICByZXR1cm4gMDtcbiAgfSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBtbF9jYW52YXNfZXhwb3J0X3BuZ1xuLy9SZXF1aXJlczogY2FtbF9jcmVhdGVfZmlsZSwgY2FtbF9yYWlzZV93aXRoX3N0cmluZywgY2FtbF9uYW1lZF92YWx1ZVxuZnVuY3Rpb24gbWxfY2FudmFzX2V4cG9ydF9wbmcoY2FudmFzLCBmaWxlbmFtZSkge1xuICB0cnkge1xuICAgIHZhciBkYXRhID0gY2FudmFzLnN1cmZhY2UudG9EYXRhVVJMKFwiaW1hZ2UvcG5nXCIpLnN1YnN0cmluZygyMik7XG4gICAgY2FtbF9jcmVhdGVfZmlsZShmaWxlbmFtZSwgd2luZG93LmF0b2IoZGF0YSkpO1xuICB9IGNhdGNoIChleG4pIHtcbiAgICBjYW1sX3JhaXNlX3dpdGhfc3RyaW5nKGNhbWxfbmFtZWRfdmFsdWUoXCJXcml0ZV9wbmdfZmFpbGVkXCIpLCBmaWxlbmFtZSk7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cblxuXG4vKiBFdmVudCAqL1xuXG4vL1Byb3ZpZGVzOiBtbF9jYW52YXNfaW50X29mX2tleVxuLy9SZXF1aXJlczogS2V5X2NvZGVfdmFsXG5mdW5jdGlvbiBtbF9jYW52YXNfaW50X29mX2tleShrZXljb2RlKSB7XG4gIHJldHVybiBLZXlfY29kZV92YWwoa2V5Y29kZSk7XG59XG5cbi8vUHJvdmlkZXM6IG1sX2NhbnZhc19rZXlfb2ZfaW50XG4vL1JlcXVpcmVzOiBWYWxfa2V5X2NvZGVcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gbWxfY2FudmFzX2tleV9vZl9pbnQoa2V5Y29kZSkge1xuICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJrZXlfb2ZfaW50OiBpIG11c3QgYmUgaW4gdGhlIDAtMjU1IHJhbmdlXCIpO1xuICByZXR1cm4gVmFsX2tleV9jb2RlKGtleWNvZGUpO1xufVxuXG5cblxuLyogQmFja2VuZCAqL1xuXG4vL1Byb3ZpZGVzOiBtbF9jYW52YXNfaW5pdFxuLy9SZXF1aXJlczogX2tleV9kb3duX2hhbmRsZXIsIF9rZXlfdXBfaGFuZGxlciwgX3VwX2hhbmRsZXIsIF9tb3ZlX2hhbmRsZXIsIF9yZXNpemVfaGFuZGxlciwgX2ZyYW1lX2hhbmRsZXJcbi8vUmVxdWlyZXM6IF9tbF9jYW52YXNfaW5pdGlhbGl6ZWQsIGNhbWxfbGlzdF90b19qc19hcnJheVxuZnVuY3Rpb24gbWxfY2FudmFzX2luaXQoKSB7XG4gIGlmIChfbWxfY2FudmFzX2luaXRpYWxpemVkID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgX2tleV9kb3duX2hhbmRsZXIsIHtwYXNzaXZlOiB0cnVlfSk7XG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLCBfa2V5X3VwX2hhbmRsZXIsIHtwYXNzaXZlOiB0cnVlfSk7XG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIF91cF9oYW5kbGVyLCB7cGFzc2l2ZTogdHJ1ZX0pO1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIF9tb3ZlX2hhbmRsZXIsIHtwYXNzaXZlOiB0cnVlfSk7XG4gIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoX2ZyYW1lX2hhbmRsZXIpO1xuICBfbWxfY2FudmFzX2luaXRpYWxpemVkID0gdHJ1ZTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IF9tbF9jYW52YXNfbWxQcm9jZXNzRXZlbnRcbnZhciBfbWxfY2FudmFzX21sUHJvY2Vzc0V2ZW50ID0gbnVsbDtcblxuLy9Qcm92aWRlczogX21sX2NhbnZhc19tbENvbnRpbnVhdGlvblxudmFyIF9tbF9jYW52YXNfbWxDb250aW51YXRpb24gPSBudWxsO1xuXG4vL1Byb3ZpZGVzOiBfbWxfY2FudmFzX21sRXhjZXB0aW9uXG52YXIgX21sX2NhbnZhc19tbEV4Y2VwdGlvbiA9IG51bGw7XG5cbi8vUHJvdmlkZXM6IF9tbF9jYW52YXNfcHJvY2Vzc19ldmVudFxuLy9SZXF1aXJlczogX21sX2NhbnZhc19tbFByb2Nlc3NFdmVudCwgX21sX2NhbnZhc19tbEV4Y2VwdGlvbiwgbWxfY2FudmFzX3N0b3BcbmZ1bmN0aW9uIF9tbF9jYW52YXNfcHJvY2Vzc19ldmVudChtbEV2ZW50KSB7XG4gIGlmIChfbWxfY2FudmFzX21sUHJvY2Vzc0V2ZW50ID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHRyeSB7XG4gICAgX21sX2NhbnZhc19tbFByb2Nlc3NFdmVudChtbEV2ZW50KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZXhuKSB7XG4gICAgX21sX2NhbnZhc19tbEV4Y2VwdGlvbiA9IGV4bjtcbiAgICBtbF9jYW52YXNfc3RvcCgpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBtbF9jYW52YXNfcnVuXG4vL1JlcXVpcmVzOiBfbWxfY2FudmFzX2Vuc3VyZV9pbml0aWFsaXplZCwgX21sX2NhbnZhc19tbFByb2Nlc3NFdmVudCwgX21sX2NhbnZhc19tbENvbnRpbnVhdGlvbiwgX21sX2NhbnZhc19tbEV4Y2VwdGlvbiwgX21sX2NhbnZhc19lbnN1cmVfaW5pdGlhbGl6ZWRcbmZ1bmN0aW9uIG1sX2NhbnZhc19ydW4obWxQcm9jZXNzRXZlbnQsIG1sQ29udGludWF0aW9uKSB7XG4gIF9tbF9jYW52YXNfZW5zdXJlX2luaXRpYWxpemVkKCk7XG4gIGlmIChfbWxfY2FudmFzX21sUHJvY2Vzc0V2ZW50ICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgX21sX2NhbnZhc19tbFByb2Nlc3NFdmVudCA9IG1sUHJvY2Vzc0V2ZW50O1xuICBfbWxfY2FudmFzX21sQ29udGludWF0aW9uID0gbWxDb250aW51YXRpb247XG4gIF9tbF9jYW52YXNfbWxFeGNlcHRpb24gPSBudWxsO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogbWxfY2FudmFzX3N0b3Bcbi8vUmVxdWlyZXM6IF9tbF9jYW52YXNfZW5zdXJlX2luaXRpYWxpemVkLCBfbWxfY2FudmFzX21sUHJvY2Vzc0V2ZW50LCBfbWxfY2FudmFzX21sQ29udGludWF0aW9uLCBfbWxfY2FudmFzX21sRXhjZXB0aW9uLCBfbWxfY2FudmFzX2Vuc3VyZV9pbml0aWFsaXplZFxuZnVuY3Rpb24gbWxfY2FudmFzX3N0b3AoKSB7XG4gIF9tbF9jYW52YXNfZW5zdXJlX2luaXRpYWxpemVkKCk7XG4gIF9tbF9jYW52YXNfbWxQcm9jZXNzRXZlbnQgPSBudWxsO1xuICBpZiAoX21sX2NhbnZhc19tbEV4Y2VwdGlvbiAhPT0gbnVsbCkge1xuICAgIHZhciBleG4gPSBfbWxfY2FudmFzX21sRXhjZXB0aW9uO1xuICAgIF9tbF9jYW52YXNfbWxDb250aW51YXRpb24gPSBudWxsO1xuICAgIF9tbF9jYW52YXNfbWxFeGNlcHRpb24gPSBudWxsO1xuICAgIHRocm93IChleG4pO1xuICB9IGVsc2UgaWYgKF9tbF9jYW52YXNfbWxDb250aW51YXRpb24gIT09IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgX21sX2NhbnZhc19tbENvbnRpbnVhdGlvbigpO1xuICAgICAgX21sX2NhbnZhc19tbENvbnRpbnVhdGlvbiA9IG51bGw7XG4gICAgfSBjYXRjaCAoZXhuKSB7XG4gICAgICBfbWxfY2FudmFzX21sQ29udGludWF0aW9uID0gbnVsbDtcbiAgICAgIHRocm93IChleG4pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogbWxfY2FudmFzX2dldF9jYW52YXNcbi8vUmVxdWlyZXM6IF9tbF9jYW52YXNfZW5zdXJlX2luaXRpYWxpemVkXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX25vdF9mb3VuZFxuZnVuY3Rpb24gbWxfY2FudmFzX2dldF9jYW52YXMoaWQpIHtcbiAgX21sX2NhbnZhc19lbnN1cmVfaW5pdGlhbGl6ZWQoKTtcbiAgdmFyIHN1cmZhY2UgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNcIiArIGlkKTtcbiAgaWYgKHN1cmZhY2UgPT09IG51bGwpIHtcbiAgICBjYW1sX3JhaXNlX25vdF9mb3VuZCgpO1xuICAgIHJldHVybiAwO1xuICB9XG4gIHJldHVybiBzdXJmYWNlLmNhbnZhcztcbn1cblxuLy9Qcm92aWRlczogbWxfY2FudmFzX2dldF9jdXJyZW50X3RpbWVzdGFtcFxuLy9SZXF1aXJlczogX21sX2NhbnZhc19lbnN1cmVfaW5pdGlhbGl6ZWRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfZmxvYXRcbmZ1bmN0aW9uIG1sX2NhbnZhc19nZXRfY3VycmVudF90aW1lc3RhbXAoKSB7XG4gIF9tbF9jYW52YXNfZW5zdXJlX2luaXRpYWxpemVkKCk7XG4gIHZhciBlID0gbmV3IHdpbmRvdy5FdmVudChcImR1bW15XCIpO1xuICByZXR1cm4gY2FtbF9pbnQ2NF9vZl9mbG9hdChlLnRpbWVTdGFtcCAqIDEwMDAuMCk7XG59XG4iLCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKiAgICBDb3B5cmlnaHQgMjAyMiBPQ2FtbFBybyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKiAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgICovXG4vKiAgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSBzcGVjaWFsICAgICAgICovXG4vKiAgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICAgICAgICAgICovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8vUHJvdmlkZXM6IGtleW5hbWVfdG9fa2V5Y29kZVxuLy9SZXF1aXJlczogS0VZXG52YXIga25fdG9fa2MgPSBuZXcgam9vX2dsb2JhbF9vYmplY3QuTWFwKFtcbiAgW1wiXCIsICAgICAgICAgICAgICAgIEtFWS5VTkRFRklORURdLFxuICBbXCJVbmlkZW50aWZpZWRcIiwgICAgS0VZLlVOREVGSU5FRF0sXG5cbiAgW1wiRXNjYXBlXCIsICAgICAgICAgIEtFWS5FU0NBUEVdLFxuICBbXCJGMVwiLCAgICAgICAgICAgICAgS0VZLkYxXSxcbiAgW1wiRjJcIiwgICAgICAgICAgICAgIEtFWS5GMl0sXG4gIFtcIkYzXCIsICAgICAgICAgICAgICBLRVkuRjNdLFxuICBbXCJGNFwiLCAgICAgICAgICAgICAgS0VZLkY0XSxcbiAgW1wiRjVcIiwgICAgICAgICAgICAgIEtFWS5GNV0sXG4gIFtcIkY2XCIsICAgICAgICAgICAgICBLRVkuRjZdLFxuICBbXCJGN1wiLCAgICAgICAgICAgICAgS0VZLkY3XSxcbiAgW1wiRjhcIiwgICAgICAgICAgICAgIEtFWS5GOF0sXG4gIFtcIkY5XCIsICAgICAgICAgICAgICBLRVkuRjldLFxuICBbXCJGMTBcIiwgICAgICAgICAgICAgS0VZLkYxMF0sXG4gIFtcIkYxMVwiLCAgICAgICAgICAgICBLRVkuRjExXSxcbiAgW1wiRjEyXCIsICAgICAgICAgICAgIEtFWS5GMTJdLFxuXG4gIFtcIlByaW50U2NyZWVuXCIsICAgICBLRVkuUFJJTlRTQ1JFRU5dLFxuICBbXCJTY3JvbGxMb2NrXCIsICAgICAgS0VZLlNDUk9MTExPQ0tdLFxuICBbXCJQYXVzZVwiLCAgICAgICAgICAgS0VZLlBBVVNFXSxcblxuICBbXCJCYWNrcXVvdGVcIiwgICAgICAgS0VZLkdSQVZFX1RJTERFXSxcbiAgW1wiRGlnaXQxXCIsICAgICAgICAgIEtFWS5fMV9FWENMQU1BVElPTl0sXG4gIFtcIkRpZ2l0MlwiLCAgICAgICAgICBLRVkuXzJfQVRdLFxuICBbXCJEaWdpdDNcIiwgICAgICAgICAgS0VZLl8zX05VTUJFUl0sXG4gIFtcIkRpZ2l0NFwiLCAgICAgICAgICBLRVkuXzRfRE9MTEFSXSxcbiAgW1wiRGlnaXQ1XCIsICAgICAgICAgIEtFWS5fNV9QRVJDRU5UXSxcbiAgW1wiRGlnaXQ2XCIsICAgICAgICAgIEtFWS5fNl9DQVJFVF0sXG4gIFtcIkRpZ2l0N1wiLCAgICAgICAgICBLRVkuXzdfQU1QRVJTQU5EXSxcbiAgW1wiRGlnaXQ4XCIsICAgICAgICAgIEtFWS5fOF9BU1RFUklTS10sXG4gIFtcIkRpZ2l0OVwiLCAgICAgICAgICBLRVkuXzlfTFBBUkVOVEhFU0lTXSxcbiAgW1wiRGlnaXQwXCIsICAgICAgICAgIEtFWS5fMF9SUEFSRU5USEVTSVNdLFxuICBbXCJNaW51c1wiLCAgICAgICAgICAgS0VZLk1JTlVTX1VOREVSU0NPUkVdLFxuICBbXCJFcXVhbFwiLCAgICAgICAgICAgS0VZLkVRVUFMX1BMVVNdLFxuICBbXCJJbnRsWWVuXCIsICAgICAgICAgS0VZLklOVEVSTkFUSU9OQUwzXSwgLyogfCBhbmQgWWVuIGtleSBsZWZ0ICovXG4gIFtcIkJhY2tzcGFjZVwiLCAgICAgICBLRVkuQkFDS1NQQUNFXSxcblxuICBbXCJUYWJcIiwgICAgICAgICAgICAgS0VZLlRBQl0sXG4gIFtcIktleVFcIiwgICAgICAgICAgICBLRVkuUV0sXG4gIFtcIktleVdcIiwgICAgICAgICAgICBLRVkuV10sXG4gIFtcIktleUVcIiwgICAgICAgICAgICBLRVkuRV0sXG4gIFtcIktleVJcIiwgICAgICAgICAgICBLRVkuUl0sXG4gIFtcIktleVRcIiwgICAgICAgICAgICBLRVkuVF0sXG4gIFtcIktleVlcIiwgICAgICAgICAgICBLRVkuWV0sXG4gIFtcIktleVVcIiwgICAgICAgICAgICBLRVkuVV0sXG4gIFtcIktleUlcIiwgICAgICAgICAgICBLRVkuSV0sXG4gIFtcIktleU9cIiwgICAgICAgICAgICBLRVkuT10sXG4gIFtcIktleVBcIiwgICAgICAgICAgICBLRVkuUF0sXG4gIFtcIkJyYWNrZXRMZWZ0XCIsICAgICBLRVkuTEJSQUNLRVRfQ1VSTFldLFxuICBbXCJCcmFja2V0UmlnaHRcIiwgICAgS0VZLlJCUkFDS0VUX0NVUkxZXSxcbiAgW1wiQmFja3NsYXNoXCIsICAgICAgIEtFWS5CQUNLU0xBU0hfUElQRV0sIC8qIG9yIEtFWS5OT05VU19OVU1CRVJfVElMREUgKi9cblxuICBbXCJDYXBzTG9ja1wiLCAgICAgICAgS0VZLkNBUFNMT0NLXSxcbiAgW1wiS2V5QVwiLCAgICAgICAgICAgIEtFWS5BXSxcbiAgW1wiS2V5U1wiLCAgICAgICAgICAgIEtFWS5TXSxcbiAgW1wiS2V5RFwiLCAgICAgICAgICAgIEtFWS5EXSxcbiAgW1wiS2V5RlwiLCAgICAgICAgICAgIEtFWS5GXSxcbiAgW1wiS2V5R1wiLCAgICAgICAgICAgIEtFWS5HXSxcbiAgW1wiS2V5SFwiLCAgICAgICAgICAgIEtFWS5IXSxcbiAgW1wiS2V5SlwiLCAgICAgICAgICAgIEtFWS5KXSxcbiAgW1wiS2V5S1wiLCAgICAgICAgICAgIEtFWS5LXSxcbiAgW1wiS2V5TFwiLCAgICAgICAgICAgIEtFWS5MXSxcbiAgW1wiU2VtaWNvbG9uXCIsICAgICAgIEtFWS5TRU1JQ09MT05fQ09MT05dLFxuICBbXCJRdW90ZVwiLCAgICAgICAgICAgS0VZLlFVT1RFX0RPVUJMRVFVT1RFXSxcbi8vW1wiQmFja3NsYXNoXCIsICAgICAgIEtFWS5OT05VU19OVU1CRVJfVElMREVdLCAvKiBvciBLRVkuQkFDS1NMQVNIX1BJUEUgKi9cbiAgW1wiRW50ZXJcIiwgICAgICAgICAgIEtFWS5SRVRVUk5dLFxuXG4gIFtcIlNoaWZ0TGVmdFwiLCAgICAgICBLRVkuTFNISUZUXSxcbiAgW1wiSW50bEJhY2tzbGFzaFwiLCAgIEtFWS5OT05VU19CQUNLU0xBU0hfUElQRV0sXG4gIFtcIktleVpcIiwgICAgICAgICAgICBLRVkuWl0sXG4gIFtcIktleVhcIiwgICAgICAgICAgICBLRVkuWF0sXG4gIFtcIktleUNcIiwgICAgICAgICAgICBLRVkuQ10sXG4gIFtcIktleVZcIiwgICAgICAgICAgICBLRVkuVl0sXG4gIFtcIktleUJcIiwgICAgICAgICAgICBLRVkuQl0sXG4gIFtcIktleU5cIiwgICAgICAgICAgICBLRVkuTl0sXG4gIFtcIktleU1cIiwgICAgICAgICAgICBLRVkuTV0sXG4gIFtcIkNvbW1hXCIsICAgICAgICAgICBLRVkuQ09NTUFfTEVTU10sXG4gIFtcIlBlcmlvZFwiLCAgICAgICAgICBLRVkuUEVSSU9EX0dSRUFURVJdLFxuICBbXCJTbGFzaFwiLCAgICAgICAgICAgS0VZLlNMQVNIX1FVRVNUSU9OXSxcbiAgW1wiSW50bFJvXCIsICAgICAgICAgIEtFWS5JTlRFUk5BVElPTkFMMV0sIC8qIF8gYW5kIFxcIGtleSAqL1xuICBbXCJTaGlmdFJpZ2h0XCIsICAgICAgS0VZLlJTSElGVF0sXG5cbiAgW1wiQ29udHJvbExlZnRcIiwgICAgIEtFWS5MQ09OVFJPTF0sXG4gIFtcIk1ldGFMZWZ0XCIsICAgICAgICBLRVkuTE1FVEFdLFxuICBbXCJBbHRMZWZ0XCIsICAgICAgICAgS0VZLkxBTFRdLFxuICBbXCJOb25Db252ZXJ0XCIsICAgICAgS0VZLklOVEVSTkFUSU9OQUw1XSwgLyogTXVoZW5rYW4ga2V5IEtCICovXG4gIFtcIkxhbmcyXCIsICAgICAgICAgICBLRVkuTEFORzJdLCAvKiBIYW5qYSAvIEVpc3UgKE1hYykgKi9cbiAgW1wiU3BhY2VcIiwgICAgICAgICAgIEtFWS5TUEFDRUJBUl0sXG4gIFtcIkxhbmcxXCIsICAgICAgICAgICBLRVkuTEFORzFdLCAvKiBIYW5ndWxNb2RlIC8gS2FuYSAoTWFjKSAqL1xuICBbXCJDb252ZXJ0XCIsICAgICAgICAgS0VZLklOVEVSTkFUSU9OQUw0XSwgLyogSGVua2FuIGtleSAqL1xuICBbXCJLYW5hTW9kZVwiLCAgICAgICAgS0VZLklOVEVSTkFUSU9OQUwyXSwgLyogS2F0YWthbmEvSGlyYWdhbmEga2V5ICovXG4gIFtcIkFsdFJpZ2h0XCIsICAgICAgICBLRVkuUkFMVF0sXG4gIFtcIk1ldGFSaWdodFwiLCAgICAgICBLRVkuUk1FVEFdLFxuICBbXCJDb250ZXh0TWVudVwiLCAgICAgS0VZLk1FTlVdLFxuICBbXCJDb250cm9sUmlnaHRcIiwgICAgS0VZLlJDT05UUk9MXSxcblxuICBbXCJIZWxwXCIsICAgICAgICAgICAgS0VZLkhFTFBdLCAvKiBvbiBvbGQgTWFjIGtleWJvYXJkcyAqL1xuICBbXCJJbnNlcnRcIiwgICAgICAgICAgS0VZLklOU0VSVF0sIC8qIG5vdCBwcmVzZW50IG9uIE1hYyBrZXlib2FyZHMgKi9cbiAgW1wiSG9tZVwiLCAgICAgICAgICAgIEtFWS5IT01FXSxcbiAgW1wiUGFnZVVwXCIsICAgICAgICAgIEtFWS5QQUdFVVBdLFxuICBbXCJEZWxldGVcIiwgICAgICAgICAgS0VZLkRFTEVURUZPUldBUkRdLFxuICBbXCJFbmRcIiwgICAgICAgICAgICAgS0VZLkVORF0sXG4gIFtcIlBhZ2VEb3duXCIsICAgICAgICBLRVkuUEFHRURPV05dLFxuXG4gIFtcIkFycm93VXBcIiwgICAgICAgICBLRVkuVVBBUlJPV10sXG4gIFtcIkFycm93TGVmdFwiLCAgICAgICBLRVkuTEVGVEFSUk9XXSxcbiAgW1wiQXJyb3dEb3duXCIsICAgICAgIEtFWS5ET1dOQVJST1ddLFxuICBbXCJBcnJvd1JpZ2h0XCIsICAgICAgS0VZLlJJR0hUQVJST1ddLFxuXG4gIFtcIk51bXBhZExvY2tcIiwgICAgICBLRVkuUEFEX05VTUxPQ0tfQ0xFQVJdLCAvKiBOdW1Mb2NrIGlzIENsZWFyIG9uIE1hYyAqL1xuICBbXCJOdW1wYWRFcXVhbFwiLCAgICAgS0VZLlBBRF9FUVVBTFNdLCAvKiBNYWMgb25seSAqL1xuICBbXCJOdW1wYWREaXZpZGVcIiwgICAgS0VZLlBBRF9ESVZJREVdLFxuICBbXCJOdW1wYWRNdWx0aXBseVwiLCAgS0VZLlBBRF9NVUxUSVBMWV0sXG4gIFtcIk51bXBhZFN1YnRyYWN0XCIsICBLRVkuUEFEX01JTlVTXSxcbiAgW1wiTnVtcGFkN1wiLCAgICAgICAgIEtFWS5QQURfN19IT01FXSxcbiAgW1wiTnVtcGFkOFwiLCAgICAgICAgIEtFWS5QQURfOF9VUEFSUk9XXSxcbiAgW1wiTnVtcGFkOVwiLCAgICAgICAgIEtFWS5QQURfOV9QQUdFVVBdLFxuICBbXCJOdW1wYWRBZGRcIiwgICAgICAgS0VZLlBBRF9QTFVTXSxcbiAgW1wiTnVtcGFkNFwiLCAgICAgICAgIEtFWS5QQURfNF9MRUZUQVJST1ddLFxuICBbXCJOdW1wYWQ1XCIsICAgICAgICAgS0VZLlBBRF81XSxcbiAgW1wiTnVtcGFkNlwiLCAgICAgICAgIEtFWS5QQURfNl9SSUdIVEFSUk9XXSxcbiAgW1wiTnVtcGFkQ29tbWFcIiwgICAgIEtFWS5QQURfQ09NTUFdLCAvKiBzcGVjaWZpYyB0byBCcmF6aWxpYW4ga2V5Ym9hcmRzICovXG4gIFtcIk51bXBhZDFcIiwgICAgICAgICBLRVkuUEFEXzFfRU5EXSxcbiAgW1wiTnVtcGFkMlwiLCAgICAgICAgIEtFWS5QQURfMl9ET1dOQVJST1ddLFxuICBbXCJOdW1wYWQzXCIsICAgICAgICAgS0VZLlBBRF8zX1BBR0VET1dOXSxcbiAgW1wiTnVtcGFkMFwiLCAgICAgICAgIEtFWS5QQURfMF9JTlNFUlRdLFxuICBbXCJOdW1wYWREZWNpbWFsXCIsICAgS0VZLlBBRF9ERUNJTUFMX0RFTEVURV0sXG4vL1tcIj8/Pz8/P1wiLCAgICAgICAgICBLRVkuSU5URVJOQVRJT05BTDZdLCAvKiBLYW5tYSAoY29tbWEpICovXG4gIFtcIk51bXBhZEVudGVyXCIsICAgICBLRVkuUEFEX0VOVEVSXSxcblxuICBbXCJGMTNcIiwgICAgICAgICAgICAgS0VZLkYxM10sXG4gIFtcIkYxNFwiLCAgICAgICAgICAgICBLRVkuRjE0XSwgLy8gRkY6IGFsc28gaGFzIGtleSA9IExhdW5jaEFwcGxpY2F0aW9uNlxuICBbXCJGMTVcIiwgICAgICAgICAgICAgS0VZLkYxNV0sIC8vIEZGOiBhbHNvIGhhcyBrZXkgPSBMYXVuY2hBcHBsaWNhdGlvbjdcbiAgW1wiRjE2XCIsICAgICAgICAgICAgIEtFWS5GMTZdLCAvLyBGRjogYWxzbyBoYXMga2V5ID0gTGF1bmNoQXBwbGljYXRpb244XG4gIFtcIkYxN1wiLCAgICAgICAgICAgICBLRVkuRjE3XSwgLy8gRkY6IGFsc28gaGFzIGtleSA9IExhdW5jaEFwcGxpY2F0aW9uOVxuICBbXCJGMThcIiwgICAgICAgICAgICAgS0VZLkYxOF0sIC8vIEZGOiBhbHNvIGhhcyBrZXkgPSBMYXVuY2hBcHBsaWNhdGlvbjEwXG4gIFtcIkYxOVwiLCAgICAgICAgICAgICBLRVkuRjE5XSxcbiAgW1wiRjIwXCIsICAgICAgICAgICAgIEtFWS5GMjBdLFxuICBbXCJGMjFcIiwgICAgICAgICAgICAgS0VZLkYyMV0sXG4gIFtcIkYyMlwiLCAgICAgICAgICAgICBLRVkuRjIyXSxcbiAgW1wiRjIzXCIsICAgICAgICAgICAgIEtFWS5GMjNdLFxuICBbXCJGMjRcIiwgICAgICAgICAgICAgS0VZLkYyNF0sXG5cbiAgW1wiTGFuZzNcIiwgICAgICAgICAgIEtFWS5MQU5HM10sIC8qIEthdGFrYW5hIGtleSAoSmFwYW5lc2UpICovXG4gIFtcIkxhbmc0XCIsICAgICAgICAgICBLRVkuTEFORzRdLCAvKiBIaXJhZ2FuYSBrZXkgKEphcGFuZXNlKSAqL1xuICBbXCJMYW5nNVwiLCAgICAgICAgICAgS0VZLkxBTkc1XSwgLyogWmVua2FrdS9IYW5rYWt1IGtleSAoSmFwYW5lc2UpICovXG5cbiAgW1wiS2F0YWthbmFcIiwgICAgICAgIEtFWS5MQU5HM10sIC8qIEthdGFrYW5hIGtleSAoSmFwYW5lc2UpICovXG4gIFtcIkhpcmFnYW5hXCIsICAgICAgICBLRVkuTEFORzRdLCAvKiBIaXJhZ2FuYSBrZXkgKEphcGFuZXNlKSAqL1xuXG4gIFtcIkF1ZGlvVm9sdW1lRG93blwiLCBLRVkuVk9MVU1FRE9XTl0sXG4gIFtcIkF1ZGlvVm9sdW1lVXBcIiwgICBLRVkuVk9MVU1FVVBdLFxuICBbXCJBdWRpb1ZvbHVtZU11dGVcIiwgS0VZLk1VVEVdLFxuXG4vL1tcIkxhdW5jaEFwcGxpY2F0aW9uMVwiLCA/XSwgLy8ga2V5IG9ubHkgKENocm9tZSlcbi8vW1wiTGF1bmNoTXlDb21wdXRlclwiLCAgID9dLCAvLyBrZXkgb25seSAoRmlyZWZveClcbi8vW1wiTWVkaWFSZWNvcmRcIiwgICAgICAgID9dLCAvLyBvbiBGRjoga2V5IG9ubHksIG9uIENocm9tZTogYm90aFxuLy9bXCJDbG9zZVwiLCAgICAgICAgICAgICAgP10sIC8vIEZGIG9ubHksIGtleSBvbmx5XG5dKTtcblxuZnVuY3Rpb24ga2V5bmFtZV90b19rZXljb2RlKGtleW5hbWUpIHtcbiAgcmV0dXJuIGtuX3RvX2tjLmdldChrZXluYW1lKTtcbn1cbiIsIi8vLy8vLy8vLyBCSUdTVFJJTkdcblxuLy9Qcm92aWRlczogY2FtbF9oYXNoX21peF9iaWdzdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfYnl0ZXNfYXJyXG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X2JpZ3N0cmluZyhoLCBicykge1xuICByZXR1cm4gY2FtbF9oYXNoX21peF9ieXRlc19hcnIoaCxicy5kYXRhKTtcbn1cblxuLy9Qcm92aWRlczogYmlnc3RyaW5nX3RvX2FycmF5X2J1ZmZlciBtdXRhYmxlXG5mdW5jdGlvbiBiaWdzdHJpbmdfdG9fYXJyYXlfYnVmZmVyKGJzKSB7XG4gIHJldHVybiBicy5kYXRhLmJ1ZmZlclxufVxuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdfdG9fdHlwZWRfYXJyYXkgbXV0YWJsZVxuZnVuY3Rpb24gYmlnc3RyaW5nX3RvX3R5cGVkX2FycmF5KGJzKSB7XG4gIHJldHVybiBicy5kYXRhXG59XG5cbi8vUHJvdmlkZXM6IGJpZ3N0cmluZ19vZl9hcnJheV9idWZmZXIgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9iYV9jcmVhdGVfdW5zYWZlXG5mdW5jdGlvbiBiaWdzdHJpbmdfb2ZfYXJyYXlfYnVmZmVyKGFiKSB7XG4gIHZhciB0YSA9IG5ldyBVaW50OEFycmF5KGFiKTtcbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZSgxMiwgMCwgW3RhLmxlbmd0aF0sIHRhKTtcbn1cblxuLy9Qcm92aWRlczogYmlnc3RyaW5nX29mX3R5cGVkX2FycmF5IG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfYmFfY3JlYXRlX3Vuc2FmZVxuZnVuY3Rpb24gYmlnc3RyaW5nX29mX3R5cGVkX2FycmF5KGJhKSB7XG4gIHZhciB0YSA9IG5ldyBVaW50OEFycmF5KGJhLmJ1ZmZlciwgYmEuYnl0ZU9mZnNldCwgYmEubGVuZ3RoICogYmEuQllURVNfUEVSX0VMRU1FTlQpO1xuICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKDEyLCAwLCBbdGEubGVuZ3RoXSwgdGEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JpZ3N0cmluZ19tZW1jbXBcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZ2V0XzFcbmZ1bmN0aW9uIGNhbWxfYmlnc3RyaW5nX21lbWNtcChzMSwgcG9zMSwgczIsIHBvczIsIGxlbil7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgYSA9IGNhbWxfYmFfZ2V0XzEoczEscG9zMSArIGkpO1xuICAgIHZhciBiID0gY2FtbF9iYV9nZXRfMShzMixwb3MyICsgaSk7XG4gICAgaWYgKGEgPCBiKSByZXR1cm4gLTE7XG4gICAgaWYgKGEgPiBiKSByZXR1cm4gMTtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19iYVxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX2JpZ3N0cmluZ19ibGl0X2JhX3RvX2JhKGJhMSwgcG9zMSwgYmEyLCBwb3MyLCBsZW4pe1xuICBpZigxMiAhPSBiYTEua2luZClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJjYW1sX2JpZ3N0cmluZ19ibGl0X2JhX3RvX2JhOiBraW5kIG1pc21hdGNoXCIpO1xuICBpZigxMiAhPSBiYTIua2luZClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJjYW1sX2JpZ3N0cmluZ19ibGl0X2JhX3RvX2JhOiBraW5kIG1pc21hdGNoXCIpO1xuICBpZihsZW4gPT0gMCkgcmV0dXJuIDA7XG4gIHZhciBvZnMxID0gYmExLm9mZnNldChwb3MxKTtcbiAgdmFyIG9mczIgPSBiYTIub2Zmc2V0KHBvczIpO1xuICBpZihvZnMxICsgbGVuID4gYmExLmRhdGEubGVuZ3RoKXtcbiAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIH1cbiAgaWYob2ZzMiArIGxlbiA+IGJhMi5kYXRhLmxlbmd0aCl7XG4gICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB9XG4gIHZhciBzbGljZSA9IGJhMS5kYXRhLnN1YmFycmF5KG9mczEsb2ZzMStsZW4pO1xuICBiYTIuZGF0YS5zZXQoc2xpY2UscG9zMik7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmlnc3RyaW5nX2JsaXRfc3RyaW5nX3RvX2JhXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IsIGNhbWxfdWludDhfYXJyYXlfb2Zfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfYmlnc3RyaW5nX2JsaXRfc3RyaW5nX3RvX2JhKHN0cjEsIHBvczEsIGJhMiwgcG9zMiwgbGVuKXtcbiAgaWYoMTIgIT0gYmEyLmtpbmQpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY2FtbF9iaWdzdHJpbmdfYmxpdF9zdHJpbmdfdG9fYmE6IGtpbmQgbWlzbWF0Y2hcIik7XG4gIGlmKGxlbiA9PSAwKSByZXR1cm4gMDtcbiAgdmFyIG9mczIgPSBiYTIub2Zmc2V0KHBvczIpO1xuICBpZihwb3MxICsgbGVuID4gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHN0cjEpKSB7XG4gICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB9XG4gIGlmKG9mczIgKyBsZW4gPiBiYTIuZGF0YS5sZW5ndGgpIHtcbiAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIH1cbiAgdmFyIHNsaWNlID0gY2FtbF91aW50OF9hcnJheV9vZl9zdHJpbmcoc3RyMSkuc2xpY2UocG9zMSxwb3MxICsgbGVuKTtcbiAgYmEyLmRhdGEuc2V0KHNsaWNlLG9mczIpO1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JpZ3N0cmluZ19ibGl0X2J5dGVzX3RvX2JhXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IsIGNhbWxfdWludDhfYXJyYXlfb2ZfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfbWxfYnl0ZXNfbGVuZ3RoXG5mdW5jdGlvbiBjYW1sX2JpZ3N0cmluZ19ibGl0X2J5dGVzX3RvX2JhKHN0cjEsIHBvczEsIGJhMiwgcG9zMiwgbGVuKXtcbiAgaWYoMTIgIT0gYmEyLmtpbmQpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY2FtbF9iaWdzdHJpbmdfYmxpdF9zdHJpbmdfdG9fYmE6IGtpbmQgbWlzbWF0Y2hcIik7XG4gIGlmKGxlbiA9PSAwKSByZXR1cm4gMDtcbiAgdmFyIG9mczIgPSBiYTIub2Zmc2V0KHBvczIpO1xuICBpZihwb3MxICsgbGVuID4gY2FtbF9tbF9ieXRlc19sZW5ndGgoc3RyMSkpIHtcbiAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIH1cbiAgaWYob2ZzMiArIGxlbiA+IGJhMi5kYXRhLmxlbmd0aCkge1xuICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgfVxuICB2YXIgc2xpY2UgPSBjYW1sX3VpbnQ4X2FycmF5X29mX2J5dGVzKHN0cjEpLnNsaWNlKHBvczEscG9zMSArIGxlbik7XG4gIGJhMi5kYXRhLnNldChzbGljZSxvZnMyKTtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX2JsaXRfYnl0ZXMsIGNhbWxfYnl0ZXNfb2ZfYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfbWxfYnl0ZXNfbGVuZ3RoXG5mdW5jdGlvbiBjYW1sX2JpZ3N0cmluZ19ibGl0X2JhX3RvX2J5dGVzKGJhMSwgcG9zMSwgYnl0ZXMyLCBwb3MyLCBsZW4pe1xuICBpZigxMiAhPSBiYTEua2luZClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJjYW1sX2JpZ3N0cmluZ19ibGl0X3N0cmluZ190b19iYToga2luZCBtaXNtYXRjaFwiKTtcbiAgaWYobGVuID09IDApIHJldHVybiAwO1xuICB2YXIgb2ZzMSA9IGJhMS5vZmZzZXQocG9zMSk7XG4gIGlmKG9mczEgKyBsZW4gPiBiYTEuZGF0YS5sZW5ndGgpe1xuICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgfVxuICBpZihwb3MyICsgbGVuID4gY2FtbF9tbF9ieXRlc19sZW5ndGgoYnl0ZXMyKSl7XG4gICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB9XG4gIHZhciBzbGljZSA9IGJhMS5kYXRhLnNsaWNlKG9mczEsIG9mczErbGVuKTtcbiAgY2FtbF9ibGl0X2J5dGVzKGNhbWxfYnl0ZXNfb2ZfYXJyYXkoc2xpY2UpLCAwLCBieXRlczIsIHBvczIsIGxlbik7XG4gIHJldHVybiAwXG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogY2FtbF9tZDVfY2hhblxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2VfZW5kX29mX2ZpbGUsIGNhbWxfbWxfaW5wdXRfYmxvY2tcbi8vUmVxdWlyZXM6IGNhbWxfTUQ1SW5pdCwgY2FtbF9NRDVVcGRhdGUsIGNhbWxfTUQ1RmluYWxcbmZ1bmN0aW9uIGNhbWxfbWQ1X2NoYW4oY2hhbmlkLHRvcmVhZCl7XG4gIHZhciBjdHggPSBjYW1sX01ENUluaXQoKTtcbiAgdmFyIGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KDQwOTYpO1xuICBpZih0b3JlYWQgPCAwKXtcbiAgICB3aGlsZSh0cnVlKXtcbiAgICAgIHZhciByZWFkID0gY2FtbF9tbF9pbnB1dF9ibG9jayhjaGFuaWQsYnVmZmVyLDAsYnVmZmVyLmxlbmd0aCk7XG4gICAgICBpZihyZWFkID09IDApIGJyZWFrO1xuICAgICAgY2FtbF9NRDVVcGRhdGUoY3R4LGJ1ZmZlci5zdWJhcnJheSgwLCByZWFkKSwgcmVhZCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHdoaWxlKHRvcmVhZCA+IDApIHtcbiAgICAgIHZhciByZWFkID0gY2FtbF9tbF9pbnB1dF9ibG9jayhjaGFuaWQsYnVmZmVyLDAsICh0b3JlYWQgPiBidWZmZXIubGVuZ3RoID8gYnVmZmVyLmxlbmd0aCA6IHRvcmVhZCkpO1xuICAgICAgaWYocmVhZCA9PSAwKSBjYW1sX3JhaXNlX2VuZF9vZl9maWxlKCk7XG4gICAgICBjYW1sX01ENVVwZGF0ZShjdHgsYnVmZmVyLnN1YmFycmF5KDAsIHJlYWQpLCByZWFkKTtcbiAgICAgIHRvcmVhZCAtPSByZWFkXG4gICAgfVxuICB9XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9hcnJheShjYW1sX01ENUZpbmFsKGN0eCkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21kNV9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfb2Zfc3RyaW5nLCBjYW1sX21kNV9ieXRlc1xuZnVuY3Rpb24gY2FtbF9tZDVfc3RyaW5nKHMsIG9mcywgbGVuKSB7XG4gIHJldHVybiBjYW1sX21kNV9ieXRlcyhjYW1sX2J5dGVzX29mX3N0cmluZyhzKSxvZnMsbGVuKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9NRDVUcmFuc2Zvcm1cbnZhciBjYW1sX01ENVRyYW5zZm9ybSA9IChmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIGFkZCAoeCwgeSkgeyByZXR1cm4gKHggKyB5KSB8IDA7IH1cbiAgZnVuY3Rpb24geHgocSxhLGIseCxzLHQpIHtcbiAgICBhID0gYWRkKGFkZChhLCBxKSwgYWRkKHgsIHQpKTtcbiAgICByZXR1cm4gYWRkKChhIDw8IHMpIHwgKGEgPj4+ICgzMiAtIHMpKSwgYik7XG4gIH1cbiAgZnVuY3Rpb24gZmYoYSxiLGMsZCx4LHMsdCkge1xuICAgIHJldHVybiB4eCgoYiAmIGMpIHwgKCh+YikgJiBkKSwgYSwgYiwgeCwgcywgdCk7XG4gIH1cbiAgZnVuY3Rpb24gZ2coYSxiLGMsZCx4LHMsdCkge1xuICAgIHJldHVybiB4eCgoYiAmIGQpIHwgKGMgJiAofmQpKSwgYSwgYiwgeCwgcywgdCk7XG4gIH1cbiAgZnVuY3Rpb24gaGgoYSxiLGMsZCx4LHMsdCkgeyByZXR1cm4geHgoYiBeIGMgXiBkLCBhLCBiLCB4LCBzLCB0KTsgfVxuICBmdW5jdGlvbiBpaShhLGIsYyxkLHgscyx0KSB7IHJldHVybiB4eChjIF4gKGIgfCAofmQpKSwgYSwgYiwgeCwgcywgdCk7IH1cblxuICByZXR1cm4gZnVuY3Rpb24gKHcsIGJ1ZmZlcikge1xuICAgIHZhciBhID0gd1swXSwgYiA9IHdbMV0sIGMgPSB3WzJdLCBkID0gd1szXTtcblxuICAgIGEgPSBmZihhLCBiLCBjLCBkLCBidWZmZXJbIDBdLCA3LCAweEQ3NkFBNDc4KTtcbiAgICBkID0gZmYoZCwgYSwgYiwgYywgYnVmZmVyWyAxXSwgMTIsIDB4RThDN0I3NTYpO1xuICAgIGMgPSBmZihjLCBkLCBhLCBiLCBidWZmZXJbIDJdLCAxNywgMHgyNDIwNzBEQik7XG4gICAgYiA9IGZmKGIsIGMsIGQsIGEsIGJ1ZmZlclsgM10sIDIyLCAweEMxQkRDRUVFKTtcbiAgICBhID0gZmYoYSwgYiwgYywgZCwgYnVmZmVyWyA0XSwgNywgMHhGNTdDMEZBRik7XG4gICAgZCA9IGZmKGQsIGEsIGIsIGMsIGJ1ZmZlclsgNV0sIDEyLCAweDQ3ODdDNjJBKTtcbiAgICBjID0gZmYoYywgZCwgYSwgYiwgYnVmZmVyWyA2XSwgMTcsIDB4QTgzMDQ2MTMpO1xuICAgIGIgPSBmZihiLCBjLCBkLCBhLCBidWZmZXJbIDddLCAyMiwgMHhGRDQ2OTUwMSk7XG4gICAgYSA9IGZmKGEsIGIsIGMsIGQsIGJ1ZmZlclsgOF0sIDcsIDB4Njk4MDk4RDgpO1xuICAgIGQgPSBmZihkLCBhLCBiLCBjLCBidWZmZXJbIDldLCAxMiwgMHg4QjQ0RjdBRik7XG4gICAgYyA9IGZmKGMsIGQsIGEsIGIsIGJ1ZmZlclsxMF0sIDE3LCAweEZGRkY1QkIxKTtcbiAgICBiID0gZmYoYiwgYywgZCwgYSwgYnVmZmVyWzExXSwgMjIsIDB4ODk1Q0Q3QkUpO1xuICAgIGEgPSBmZihhLCBiLCBjLCBkLCBidWZmZXJbMTJdLCA3LCAweDZCOTAxMTIyKTtcbiAgICBkID0gZmYoZCwgYSwgYiwgYywgYnVmZmVyWzEzXSwgMTIsIDB4RkQ5ODcxOTMpO1xuICAgIGMgPSBmZihjLCBkLCBhLCBiLCBidWZmZXJbMTRdLCAxNywgMHhBNjc5NDM4RSk7XG4gICAgYiA9IGZmKGIsIGMsIGQsIGEsIGJ1ZmZlclsxNV0sIDIyLCAweDQ5QjQwODIxKTtcblxuICAgIGEgPSBnZyhhLCBiLCBjLCBkLCBidWZmZXJbIDFdLCA1LCAweEY2MUUyNTYyKTtcbiAgICBkID0gZ2coZCwgYSwgYiwgYywgYnVmZmVyWyA2XSwgOSwgMHhDMDQwQjM0MCk7XG4gICAgYyA9IGdnKGMsIGQsIGEsIGIsIGJ1ZmZlclsxMV0sIDE0LCAweDI2NUU1QTUxKTtcbiAgICBiID0gZ2coYiwgYywgZCwgYSwgYnVmZmVyWyAwXSwgMjAsIDB4RTlCNkM3QUEpO1xuICAgIGEgPSBnZyhhLCBiLCBjLCBkLCBidWZmZXJbIDVdLCA1LCAweEQ2MkYxMDVEKTtcbiAgICBkID0gZ2coZCwgYSwgYiwgYywgYnVmZmVyWzEwXSwgOSwgMHgwMjQ0MTQ1Myk7XG4gICAgYyA9IGdnKGMsIGQsIGEsIGIsIGJ1ZmZlclsxNV0sIDE0LCAweEQ4QTFFNjgxKTtcbiAgICBiID0gZ2coYiwgYywgZCwgYSwgYnVmZmVyWyA0XSwgMjAsIDB4RTdEM0ZCQzgpO1xuICAgIGEgPSBnZyhhLCBiLCBjLCBkLCBidWZmZXJbIDldLCA1LCAweDIxRTFDREU2KTtcbiAgICBkID0gZ2coZCwgYSwgYiwgYywgYnVmZmVyWzE0XSwgOSwgMHhDMzM3MDdENik7XG4gICAgYyA9IGdnKGMsIGQsIGEsIGIsIGJ1ZmZlclsgM10sIDE0LCAweEY0RDUwRDg3KTtcbiAgICBiID0gZ2coYiwgYywgZCwgYSwgYnVmZmVyWyA4XSwgMjAsIDB4NDU1QTE0RUQpO1xuICAgIGEgPSBnZyhhLCBiLCBjLCBkLCBidWZmZXJbMTNdLCA1LCAweEE5RTNFOTA1KTtcbiAgICBkID0gZ2coZCwgYSwgYiwgYywgYnVmZmVyWyAyXSwgOSwgMHhGQ0VGQTNGOCk7XG4gICAgYyA9IGdnKGMsIGQsIGEsIGIsIGJ1ZmZlclsgN10sIDE0LCAweDY3NkYwMkQ5KTtcbiAgICBiID0gZ2coYiwgYywgZCwgYSwgYnVmZmVyWzEyXSwgMjAsIDB4OEQyQTRDOEEpO1xuXG4gICAgYSA9IGhoKGEsIGIsIGMsIGQsIGJ1ZmZlclsgNV0sIDQsIDB4RkZGQTM5NDIpO1xuICAgIGQgPSBoaChkLCBhLCBiLCBjLCBidWZmZXJbIDhdLCAxMSwgMHg4NzcxRjY4MSk7XG4gICAgYyA9IGhoKGMsIGQsIGEsIGIsIGJ1ZmZlclsxMV0sIDE2LCAweDZEOUQ2MTIyKTtcbiAgICBiID0gaGgoYiwgYywgZCwgYSwgYnVmZmVyWzE0XSwgMjMsIDB4RkRFNTM4MEMpO1xuICAgIGEgPSBoaChhLCBiLCBjLCBkLCBidWZmZXJbIDFdLCA0LCAweEE0QkVFQTQ0KTtcbiAgICBkID0gaGgoZCwgYSwgYiwgYywgYnVmZmVyWyA0XSwgMTEsIDB4NEJERUNGQTkpO1xuICAgIGMgPSBoaChjLCBkLCBhLCBiLCBidWZmZXJbIDddLCAxNiwgMHhGNkJCNEI2MCk7XG4gICAgYiA9IGhoKGIsIGMsIGQsIGEsIGJ1ZmZlclsxMF0sIDIzLCAweEJFQkZCQzcwKTtcbiAgICBhID0gaGgoYSwgYiwgYywgZCwgYnVmZmVyWzEzXSwgNCwgMHgyODlCN0VDNik7XG4gICAgZCA9IGhoKGQsIGEsIGIsIGMsIGJ1ZmZlclsgMF0sIDExLCAweEVBQTEyN0ZBKTtcbiAgICBjID0gaGgoYywgZCwgYSwgYiwgYnVmZmVyWyAzXSwgMTYsIDB4RDRFRjMwODUpO1xuICAgIGIgPSBoaChiLCBjLCBkLCBhLCBidWZmZXJbIDZdLCAyMywgMHgwNDg4MUQwNSk7XG4gICAgYSA9IGhoKGEsIGIsIGMsIGQsIGJ1ZmZlclsgOV0sIDQsIDB4RDlENEQwMzkpO1xuICAgIGQgPSBoaChkLCBhLCBiLCBjLCBidWZmZXJbMTJdLCAxMSwgMHhFNkRCOTlFNSk7XG4gICAgYyA9IGhoKGMsIGQsIGEsIGIsIGJ1ZmZlclsxNV0sIDE2LCAweDFGQTI3Q0Y4KTtcbiAgICBiID0gaGgoYiwgYywgZCwgYSwgYnVmZmVyWyAyXSwgMjMsIDB4QzRBQzU2NjUpO1xuXG4gICAgYSA9IGlpKGEsIGIsIGMsIGQsIGJ1ZmZlclsgMF0sIDYsIDB4RjQyOTIyNDQpO1xuICAgIGQgPSBpaShkLCBhLCBiLCBjLCBidWZmZXJbIDddLCAxMCwgMHg0MzJBRkY5Nyk7XG4gICAgYyA9IGlpKGMsIGQsIGEsIGIsIGJ1ZmZlclsxNF0sIDE1LCAweEFCOTQyM0E3KTtcbiAgICBiID0gaWkoYiwgYywgZCwgYSwgYnVmZmVyWyA1XSwgMjEsIDB4RkM5M0EwMzkpO1xuICAgIGEgPSBpaShhLCBiLCBjLCBkLCBidWZmZXJbMTJdLCA2LCAweDY1NUI1OUMzKTtcbiAgICBkID0gaWkoZCwgYSwgYiwgYywgYnVmZmVyWyAzXSwgMTAsIDB4OEYwQ0NDOTIpO1xuICAgIGMgPSBpaShjLCBkLCBhLCBiLCBidWZmZXJbMTBdLCAxNSwgMHhGRkVGRjQ3RCk7XG4gICAgYiA9IGlpKGIsIGMsIGQsIGEsIGJ1ZmZlclsgMV0sIDIxLCAweDg1ODQ1REQxKTtcbiAgICBhID0gaWkoYSwgYiwgYywgZCwgYnVmZmVyWyA4XSwgNiwgMHg2RkE4N0U0Rik7XG4gICAgZCA9IGlpKGQsIGEsIGIsIGMsIGJ1ZmZlclsxNV0sIDEwLCAweEZFMkNFNkUwKTtcbiAgICBjID0gaWkoYywgZCwgYSwgYiwgYnVmZmVyWyA2XSwgMTUsIDB4QTMwMTQzMTQpO1xuICAgIGIgPSBpaShiLCBjLCBkLCBhLCBidWZmZXJbMTNdLCAyMSwgMHg0RTA4MTFBMSk7XG4gICAgYSA9IGlpKGEsIGIsIGMsIGQsIGJ1ZmZlclsgNF0sIDYsIDB4Rjc1MzdFODIpO1xuICAgIGQgPSBpaShkLCBhLCBiLCBjLCBidWZmZXJbMTFdLCAxMCwgMHhCRDNBRjIzNSk7XG4gICAgYyA9IGlpKGMsIGQsIGEsIGIsIGJ1ZmZlclsgMl0sIDE1LCAweDJBRDdEMkJCKTtcbiAgICBiID0gaWkoYiwgYywgZCwgYSwgYnVmZmVyWyA5XSwgMjEsIDB4RUI4NkQzOTEpO1xuXG4gICAgd1swXSA9IGFkZChhLCB3WzBdKTtcbiAgICB3WzFdID0gYWRkKGIsIHdbMV0pO1xuICAgIHdbMl0gPSBhZGQoYywgd1syXSk7XG4gICAgd1szXSA9IGFkZChkLCB3WzNdKTtcbiAgfX0pKClcblxuLy9Qcm92aWRlczogY2FtbF9NRDVJbml0XG5mdW5jdGlvbiBjYW1sX01ENUluaXQoKSB7XG4gIHZhciBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoNjQpO1xuICB2YXIgYjMyID0gbmV3IFVpbnQzMkFycmF5KGJ1ZmZlcik7XG4gIHZhciBiOCA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG4gIHJldHVybiB7bGVuOjAsXG4gICAgICAgICAgdzpuZXcgVWludDMyQXJyYXkoWzB4Njc0NTIzMDEsIDB4RUZDREFCODksIDB4OThCQURDRkUsIDB4MTAzMjU0NzZdKSxcbiAgICAgICAgICBiMzI6YjMyLFxuICAgICAgICAgIGI4OmI4fVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX01ENVVwZGF0ZVxuLy9SZXF1aXJlczogY2FtbF9NRDVUcmFuc2Zvcm1cbmZ1bmN0aW9uIGNhbWxfTUQ1VXBkYXRlKGN0eCwgaW5wdXQsIGlucHV0X2xlbil7XG4gIHZhciBpbl9idWYgPSBjdHgubGVuICYgMHgzZjtcbiAgdmFyIGlucHV0X3BvcyA9IDA7XG4gIGN0eC5sZW4gKz0gaW5wdXRfbGVuO1xuICBpZihpbl9idWYpe1xuICAgIHZhciBtaXNzaW5nID0gNjQgLSBpbl9idWY7XG4gICAgaWYoaW5wdXRfbGVuIDwgbWlzc2luZykge1xuICAgICAgY3R4LmI4LnNldChpbnB1dC5zdWJhcnJheSgwLGlucHV0X2xlbiksaW5fYnVmKTtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjdHguYjguc2V0KGlucHV0LnN1YmFycmF5KDAsbWlzc2luZyksaW5fYnVmKTtcbiAgICBjYW1sX01ENVRyYW5zZm9ybShjdHgudywgY3R4LmIzMik7XG4gICAgaW5wdXRfbGVuIC09IG1pc3Npbmc7XG4gICAgaW5wdXRfcG9zICs9IG1pc3Npbmc7XG4gIH1cbiAgd2hpbGUoaW5wdXRfbGVuID49IDY0KXtcbiAgICBjdHguYjguc2V0KGlucHV0LnN1YmFycmF5KGlucHV0X3BvcyxpbnB1dF9wb3MgKyA2NCksIDApO1xuICAgIGNhbWxfTUQ1VHJhbnNmb3JtKGN0eC53LCBjdHguYjMyKTtcbiAgICBpbnB1dF9sZW4gLT0gNjQ7XG4gICAgaW5wdXRfcG9zICs9IDY0O1xuICB9XG4gIGlmKGlucHV0X2xlbilcbiAgICBjdHguYjguc2V0KGlucHV0LnN1YmFycmF5KGlucHV0X3BvcyxpbnB1dF9wb3MgKyBpbnB1dF9sZW4pLCAwKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9NRDVGaW5hbFxuLy9SZXF1aXJlczogY2FtbF9NRDVUcmFuc2Zvcm1cbmZ1bmN0aW9uIGNhbWxfTUQ1RmluYWwoY3R4KXtcbiAgdmFyIGluX2J1ZiA9IGN0eC5sZW4gJiAweDNmO1xuICBjdHguYjhbaW5fYnVmXSA9IDB4ODA7XG4gIGluX2J1ZiArKztcbiAgaWYoaW5fYnVmID4gNTYpIHtcbiAgICBmb3IodmFyIGogPSBpbl9idWY7IGogPCA2NDsgaisrKXtcbiAgICAgIGN0eC5iOFtqXSA9IDA7XG4gICAgfVxuICAgIGNhbWxfTUQ1VHJhbnNmb3JtKGN0eC53LCBjdHguYjMyKTtcbiAgICBmb3IodmFyIGogPSAwOyBqIDwgNTY7IGorKyl7XG4gICAgICBjdHguYjhbal0gPSAwO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IodmFyIGogPSBpbl9idWY7IGogPCA1NjsgaisrKXtcbiAgICAgIGN0eC5iOFtqXSA9IDA7XG4gICAgfVxuICB9XG4gIGN0eC5iMzJbMTRdID0gY3R4LmxlbiA8PCAzO1xuICBjdHguYjMyWzE1XSA9IChjdHgubGVuID4+IDI5KSAmIDB4MUZGRkZGRkY7XG4gIGNhbWxfTUQ1VHJhbnNmb3JtKGN0eC53LCBjdHguYjMyKTtcbiAgdmFyIHQgPSBuZXcgVWludDhBcnJheSgxNik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKVxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgNDsgaisrKVxuICAgICAgdFtpICogNCArIGpdID0gKGN0eC53W2ldID4+ICg4ICogaikpICYgMHhGRjtcbiAgcmV0dXJuIHQ7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9tZDVfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfdWludDhfYXJyYXlfb2ZfYnl0ZXMsIGNhbWxfc3RyaW5nX29mX2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX01ENUluaXQsIGNhbWxfTUQ1VXBkYXRlLCBjYW1sX01ENUZpbmFsXG5mdW5jdGlvbiBjYW1sX21kNV9ieXRlcyhzLCBvZnMsIGxlbikge1xuICB2YXIgY3R4ID0gY2FtbF9NRDVJbml0KCk7XG4gIHZhciBhID0gY2FtbF91aW50OF9hcnJheV9vZl9ieXRlcyhzKTtcbiAgY2FtbF9NRDVVcGRhdGUoY3R4LGEuc3ViYXJyYXkob2ZzLCBvZnMgKyBsZW4pLCBsZW4pO1xuICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfYXJyYXkoY2FtbF9NRDVGaW5hbChjdHgpKTtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxMCBKw6lyw7RtZSBWb3VpbGxvblxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBqc29vX2Zsb29yX2xvZzJcbnZhciBsb2cyX29rID0gTWF0aC5sb2cyICYmIE1hdGgubG9nMigxLjEyMzU1ODIwOTI4ODk0NzRFKzMwNykgPT0gMTAyMFxuZnVuY3Rpb24ganNvb19mbG9vcl9sb2cyKHgpIHtcbiAgaWYobG9nMl9vaykgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5sb2cyKHgpKVxuICB2YXIgaSA9IDA7XG4gIGlmICh4ID09IDApIHJldHVybiAtSW5maW5pdHk7XG4gIGlmKHg+PTEpIHt3aGlsZSAoeD49Mikge3gvPTI7IGkrK30gfVxuICBlbHNlIHt3aGlsZSAoeCA8IDEpIHt4Kj0yOyBpLS19IH07XG4gIHJldHVybiBpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQgY29uc3Rcbi8vUmVxdWlyZXM6IGpzb29fZmxvb3JfbG9nMiwgY2FtbF9pbnQ2NF9jcmVhdGVfbG9fbWlfaGlcbmZ1bmN0aW9uIGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCAoeCkge1xuICBpZiAoIWlzRmluaXRlKHgpKSB7XG4gICAgaWYgKGlzTmFOKHgpKVxuICAgICAgcmV0dXJuIGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpKDEsIDAsIDB4N2ZmMCk7XG4gICAgaWYgKHggPiAwKVxuICAgICAgcmV0dXJuIGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpKDAsIDAsIDB4N2ZmMClcbiAgICBlbHNlXG4gICAgICByZXR1cm4gY2FtbF9pbnQ2NF9jcmVhdGVfbG9fbWlfaGkoMCwgMCwgMHhmZmYwKVxuICB9XG4gIHZhciBzaWduID0gKHg9PTAgJiYgMS94ID09IC1JbmZpbml0eSk/MHg4MDAwOih4Pj0wKT8wOjB4ODAwMDtcbiAgaWYgKHNpZ24pIHggPSAteDtcbiAgLy8gSW50NjQuYml0c19vZl9mbG9hdCAxLjEyMzU1ODIwOTI4ODk0NzRFKzMwNyA9IDB4N2ZiMDAwMDAwMDAwMDAwMExcbiAgLy8gdXNpbmcgTWF0aC5MT0cyRSpNYXRoLmxvZyh4KSBpbiBwbGFjZSBvZiBNYXRoLmxvZzIgcmVzdWx0IGluIHByZWNpc2lvbiBsb3N0XG4gIHZhciBleHAgPSBqc29vX2Zsb29yX2xvZzIoeCkgKyAxMDIzO1xuICBpZiAoZXhwIDw9IDApIHtcbiAgICBleHAgPSAwO1xuICAgIHggLz0gTWF0aC5wb3coMiwtMTAyNik7XG4gIH0gZWxzZSB7XG4gICAgeCAvPSBNYXRoLnBvdygyLGV4cC0xMDI3KTtcbiAgICBpZiAoeCA8IDE2KSB7XG4gICAgICB4ICo9IDI7IGV4cCAtPTE7IH1cbiAgICBpZiAoZXhwID09IDApIHtcbiAgICAgIHggLz0gMjsgfVxuICB9XG4gIHZhciBrID0gTWF0aC5wb3coMiwyNCk7XG4gIHZhciByMyA9IHh8MDtcbiAgeCA9ICh4IC0gcjMpICogaztcbiAgdmFyIHIyID0geHwwO1xuICB4ID0gKHggLSByMikgKiBrO1xuICB2YXIgcjEgPSB4fDA7XG4gIHIzID0gKHIzICYweGYpIHwgc2lnbiB8IGV4cCA8PCA0O1xuICByZXR1cm4gY2FtbF9pbnQ2NF9jcmVhdGVfbG9fbWlfaGkocjEsIHIyLCByMyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50MzJfYml0c19vZl9mbG9hdCBjb25zdFxuLy9SZXF1aXJlczoganNvb19mbG9vcl9sb2cyXG5mdW5jdGlvbiBjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXQgKHgpIHtcbiAgdmFyIGZsb2F0MzJhID0gbmV3IEZsb2F0MzJBcnJheSgxKTtcbiAgZmxvYXQzMmFbMF0gPSB4O1xuICB2YXIgaW50MzJhID0gbmV3IEludDMyQXJyYXkoZmxvYXQzMmEuYnVmZmVyKTtcbiAgcmV0dXJuIGludDMyYVswXSB8IDA7XG59XG5cbi8vRlAgbGl0ZXJhbHMgY2FuIGJlIHdyaXR0ZW4gdXNpbmcgdGhlIGhleGFkZWNpbWFsXG4vL25vdGF0aW9uIDB4PG1hbnRpc3NhIGluIGhleD5wPGV4cG9uZW50PiBmcm9tIElTTyBDOTkuXG4vL2h0dHBzOi8vZ2l0aHViLmNvbS9kYW5rb2dhaS9qcy1oZXhmbG9hdC9ibG9iL21hc3Rlci9oZXhmbG9hdC5qc1xuLy9Qcm92aWRlczogY2FtbF9oZXhzdHJpbmdfb2ZfZmxvYXQgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nLCBjYW1sX3N0cl9yZXBlYXRcbmZ1bmN0aW9uIGNhbWxfaGV4c3RyaW5nX29mX2Zsb2F0ICh4LCBwcmVjLCBzdHlsZSkge1xuICBpZiAoIWlzRmluaXRlKHgpKSB7XG4gICAgaWYgKGlzTmFOKHgpKSByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcoXCJuYW5cIik7XG4gICAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nICgoeCA+IDApP1wiaW5maW5pdHlcIjpcIi1pbmZpbml0eVwiKTtcbiAgfVxuICB2YXIgc2lnbiA9ICh4PT0wICYmIDEveCA9PSAtSW5maW5pdHkpPzE6KHg+PTApPzA6MTtcbiAgaWYoc2lnbikgeCA9IC14O1xuICB2YXIgZXhwID0gMDtcbiAgaWYgKHggPT0gMCkgeyB9XG4gIGVsc2UgaWYgKHggPCAxKSB7XG4gICAgd2hpbGUgKHggPCAxICYmIGV4cCA+IC0xMDIyKSAgeyB4ICo9IDI7IGV4cC0tIH1cbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAoeCA+PSAyKSB7IHggLz0gMjsgZXhwKysgfVxuICB9XG4gIHZhciBleHBfc2lnbiA9IGV4cCA8IDAgPyAnJyA6ICcrJztcbiAgdmFyIHNpZ25fc3RyID0gJyc7XG4gIGlmIChzaWduKSBzaWduX3N0ciA9ICctJ1xuICBlbHNlIHtcbiAgICBzd2l0Y2goc3R5bGUpe1xuICAgIGNhc2UgNDMgLyogJysnICovOiBzaWduX3N0ciA9ICcrJzsgYnJlYWs7XG4gICAgY2FzZSAzMiAvKiAnICcgKi86IHNpZ25fc3RyID0gJyAnOyBicmVhaztcbiAgICBkZWZhdWx0OiBicmVhaztcbiAgICB9XG4gIH1cbiAgaWYgKHByZWMgPj0gMCAmJiBwcmVjIDwgMTMpIHtcbiAgICAvKiBJZiBhIHByZWNpc2lvbiBpcyBnaXZlbiwgYW5kIGlzIHNtYWxsLCByb3VuZCBtYW50aXNzYSBhY2NvcmRpbmdseSAqL1xuICAgIHZhciBjc3QgPSBNYXRoLnBvdygyLHByZWMgKiA0KTtcbiAgICB4ID0gTWF0aC5yb3VuZCh4ICogY3N0KSAvIGNzdDtcbiAgfVxuICB2YXIgeF9zdHIgPSB4LnRvU3RyaW5nKDE2KTtcbiAgaWYocHJlYyA+PSAwKXtcbiAgICB2YXIgaWR4ID0geF9zdHIuaW5kZXhPZignLicpO1xuICAgIGlmKGlkeDwwKSB7XG4gICAgICB4X3N0ciArPSAnLicgKyBjYW1sX3N0cl9yZXBlYXQocHJlYywgJzAnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2YXIgc2l6ZSA9IGlkeCsxK3ByZWM7XG4gICAgICBpZih4X3N0ci5sZW5ndGggPCBzaXplKVxuICAgICAgICB4X3N0ciArPSBjYW1sX3N0cl9yZXBlYXQoc2l6ZSAtIHhfc3RyLmxlbmd0aCwgJzAnKTtcbiAgICAgIGVsc2VcbiAgICAgICAgeF9zdHIgPSB4X3N0ci5zdWJzdHIoMCxzaXplKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nIChzaWduX3N0ciArICcweCcgKyB4X3N0ciArICdwJyArIGV4cF9zaWduICsgZXhwLnRvU3RyaW5nKDEwKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cyBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzICh4KSB7XG4gIHZhciBsbyA9IHgubG87XG4gIHZhciBtaSA9IHgubWk7XG4gIHZhciBoaSA9IHguaGk7XG4gIHZhciBleHAgPSAoaGkgJiAweDdmZmYpID4+IDQ7XG4gIGlmIChleHAgPT0gMjA0Nykge1xuICAgIGlmICgobG98bWl8KGhpJjB4ZikpID09IDApXG4gICAgICByZXR1cm4gKGhpICYgMHg4MDAwKT8oLUluZmluaXR5KTpJbmZpbml0eTtcbiAgICBlbHNlXG4gICAgICByZXR1cm4gTmFOO1xuICB9XG4gIHZhciBrID0gTWF0aC5wb3coMiwtMjQpO1xuICB2YXIgcmVzID0gKGxvKmsrbWkpKmsrKGhpJjB4Zik7XG4gIGlmIChleHAgPiAwKSB7XG4gICAgcmVzICs9IDE2O1xuICAgIHJlcyAqPSBNYXRoLnBvdygyLGV4cC0xMDI3KTtcbiAgfSBlbHNlXG4gICAgcmVzICo9IE1hdGgucG93KDIsLTEwMjYpO1xuICBpZiAoaGkgJiAweDgwMDApIHJlcyA9IC0gcmVzO1xuICByZXR1cm4gcmVzO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX25leHRhZnRlcl9mbG9hdCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzLCBjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQsIGNhbWxfaW50NjRfYWRkLCBjYW1sX2ludDY0X3N1YixjYW1sX2ludDY0X29mX2ludDMyXG5mdW5jdGlvbiBjYW1sX25leHRhZnRlcl9mbG9hdCAoeCx5KSB7XG4gIGlmKGlzTmFOKHgpIHx8IGlzTmFOKHkpKSByZXR1cm4gTmFOO1xuICBpZih4PT15KSByZXR1cm4geTtcbiAgaWYoeD09MCl7XG4gICAgaWYoeSA8IDApXG4gICAgICByZXR1cm4gLU1hdGgucG93KDIsIC0xMDc0KVxuICAgIGVsc2VcbiAgICAgIHJldHVybiBNYXRoLnBvdygyLCAtMTA3NClcbiAgfVxuICB2YXIgYml0cyA9IGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCh4KTtcbiAgdmFyIG9uZSA9IGNhbWxfaW50NjRfb2ZfaW50MzIoMSk7XG4gIGlmICgoeDx5KSA9PSAoeD4wKSlcbiAgICBiaXRzID0gY2FtbF9pbnQ2NF9hZGQoYml0cywgb25lKVxuICBlbHNlXG4gICAgYml0cyA9IGNhbWxfaW50NjRfc3ViKGJpdHMsIG9uZSlcbiAgcmV0dXJuIGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cyhiaXRzKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF90cnVuY19mbG9hdFxuZnVuY3Rpb24gY2FtbF90cnVuY19mbG9hdCh4KXtcbiAgcmV0dXJuIE1hdGgudHJ1bmMoeCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50MzJfZmxvYXRfb2ZfYml0cyBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQzMl9mbG9hdF9vZl9iaXRzICh4KSB7XG4gIHZhciBpbnQzMmEgPSBuZXcgSW50MzJBcnJheSgxKTtcbiAgaW50MzJhWzBdID0geDtcbiAgdmFyIGZsb2F0MzJhID0gbmV3IEZsb2F0MzJBcnJheShpbnQzMmEuYnVmZmVyKTtcbiAgcmV0dXJuIGZsb2F0MzJhWzBdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NsYXNzaWZ5X2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2NsYXNzaWZ5X2Zsb2F0ICh4KSB7XG4gIGlmIChpc0Zpbml0ZSAoeCkpIHtcbiAgICBpZiAoTWF0aC5hYnMoeCkgPj0gMi4yMjUwNzM4NTg1MDcyMDE0ZS0zMDgpIHJldHVybiAwO1xuICAgIGlmICh4ICE9IDApIHJldHVybiAxO1xuICAgIHJldHVybiAyO1xuICB9XG4gIHJldHVybiBpc05hTih4KT80OjM7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX21vZGZfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfbW9kZl9mbG9hdCAoeCkge1xuICBpZiAoaXNGaW5pdGUgKHgpKSB7XG4gICAgdmFyIG5lZyA9ICgxL3gpIDwgMDtcbiAgICB4ID0gTWF0aC5hYnMoeCk7XG4gICAgdmFyIGkgPSBNYXRoLmZsb29yICh4KTtcbiAgICB2YXIgZiA9IHggLSBpO1xuICAgIGlmIChuZWcpIHsgaSA9IC1pOyBmID0gLWY7IH1cbiAgICByZXR1cm4gWzAsIGYsIGldO1xuICB9XG4gIGlmIChpc05hTiAoeCkpIHJldHVybiBbMCwgTmFOLCBOYU5dO1xuICByZXR1cm4gWzAsIDEveCwgeF07XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2xkZXhwX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2xkZXhwX2Zsb2F0ICh4LGV4cCkge1xuICBleHAgfD0gMDtcbiAgaWYgKGV4cCA+IDEwMjMpIHtcbiAgICBleHAgLT0gMTAyMztcbiAgICB4ICo9IE1hdGgucG93KDIsIDEwMjMpO1xuICAgIGlmIChleHAgPiAxMDIzKSB7ICAvLyBpbiBjYXNlIHggaXMgc3Vibm9ybWFsXG4gICAgICBleHAgLT0gMTAyMztcbiAgICAgIHggKj0gTWF0aC5wb3coMiwgMTAyMyk7XG4gICAgfVxuICB9XG4gIGlmIChleHAgPCAtMTAyMykge1xuICAgIGV4cCArPSAxMDIzO1xuICAgIHggKj0gTWF0aC5wb3coMiwgLTEwMjMpO1xuICB9XG4gIHggKj0gTWF0aC5wb3coMiwgZXhwKTtcbiAgcmV0dXJuIHg7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2ZyZXhwX2Zsb2F0IGNvbnN0XG4vL1JlcXVpcmVzOiBqc29vX2Zsb29yX2xvZzJcbmZ1bmN0aW9uIGNhbWxfZnJleHBfZmxvYXQgKHgpIHtcbiAgaWYgKCh4ID09IDApIHx8ICFpc0Zpbml0ZSh4KSkgcmV0dXJuIFswLCB4LCAwXTtcbiAgdmFyIG5lZyA9IHggPCAwO1xuICBpZiAobmVnKSB4ID0gLSB4O1xuICB2YXIgZXhwID0gTWF0aC5tYXgoLTEwMjMsIGpzb29fZmxvb3JfbG9nMih4KSArIDEpO1xuICB4ICo9IE1hdGgucG93KDIsLWV4cCk7XG4gIHdoaWxlICh4IDwgMC41KSB7XG4gICAgeCAqPSAyO1xuICAgIGV4cC0tO1xuICB9XG4gIHdoaWxlICh4ID49IDEpIHtcbiAgICB4ICo9IDAuNTtcbiAgICBleHArKztcbiAgfVxuICBpZiAobmVnKSB4ID0gLSB4O1xuICByZXR1cm4gWzAsIHgsIGV4cF07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmxvYXRfY29tcGFyZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9mbG9hdF9jb21wYXJlICh4LCB5KSB7XG4gIGlmICh4ID09PSB5KSByZXR1cm4gMDtcbiAgaWYgKHggPCB5KSByZXR1cm4gLTE7XG4gIGlmICh4ID4geSkgcmV0dXJuIDE7XG4gIGlmICh4ID09PSB4KSByZXR1cm4gMTtcbiAgaWYgKHkgPT09IHkpIHJldHVybiAtMTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY29weXNpZ25fZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfY29weXNpZ25fZmxvYXQgKHgsIHkpIHtcbiAgaWYgKHkgPT0gMCkgeSA9IDEgLyB5O1xuICB4ID0gTWF0aC5hYnMoeCk7XG4gIHJldHVybiAoeSA8IDApPygteCk6eDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zaWduYml0X2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX3NpZ25iaXRfZmxvYXQoeCkge1xuICBpZiAoeCA9PSAwKSB4ID0gMSAvIHg7XG4gIHJldHVybiAoeCA8IDApPzE6MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9leHBtMV9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9leHBtMV9mbG9hdCAoeCkgeyByZXR1cm4gTWF0aC5leHBtMSh4KTsgfVxuLy9Qcm92aWRlczogY2FtbF9leHAyX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2V4cDJfZmxvYXQoeCkgeyByZXR1cm4gTWF0aC5wb3coMiwgeCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfbG9nMXBfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfbG9nMXBfZmxvYXQoeCkgeyByZXR1cm4gTWF0aC5sb2cxcCh4KTsgfVxuLy9Qcm92aWRlczogY2FtbF9sb2cyX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2xvZzJfZmxvYXQoeCkgeyByZXR1cm4gTWF0aC5sb2cyKHgpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2h5cG90X2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2h5cG90X2Zsb2F0ICh4LCB5KSB7IHJldHVybiBNYXRoLmh5cG90KHgsIHkpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2xvZzEwX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2xvZzEwX2Zsb2F0ICh4KSB7IHJldHVybiBNYXRoLmxvZzEwKHgpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2Nvc2hfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfY29zaF9mbG9hdCAoeCkgeyByZXR1cm4gTWF0aC5jb3NoKHgpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2Fjb3NoX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2Fjb3NoX2Zsb2F0ICh4KSB7IHJldHVybiBNYXRoLmFjb3NoKHgpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX3NpbmhfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfc2luaF9mbG9hdCAoeCkgeyByZXR1cm4gTWF0aC5zaW5oKHgpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2FzaW5oX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2FzaW5oX2Zsb2F0ICh4KSB7IHJldHVybiBNYXRoLmFzaW5oKHgpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX3RhbmhfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfdGFuaF9mbG9hdCAoeCkgeyByZXR1cm4gTWF0aC50YW5oKHgpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2F0YW5oX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2F0YW5oX2Zsb2F0ICh4KSB7IHJldHVybiBNYXRoLmF0YW5oKHgpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX3JvdW5kX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX3JvdW5kX2Zsb2F0ICh4KSB7XG4gIGlmICh4ID49IDApIHtcbiAgICB2YXIgeSA9IE1hdGguZmxvb3IoeCk7XG4gICAgcmV0dXJuICh4IC0geSA+PSAwLjUpPyh5ICsgMSk6eVxuICB9IGVsc2Uge1xuICAgIHZhciB5ID0gTWF0aC5jZWlsKHgpO1xuICAgIHJldHVybiAoeSAtIHggPj0gMC41KT8oeSAtIDEpOnlcbiAgfVxufVxuLy9Qcm92aWRlczogY2FtbF9jYnJ0X2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2NicnRfZmxvYXQgKHgpIHsgcmV0dXJuIE1hdGguY2JydCh4KTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VyZl9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9lcmZfZmxvYXQoeCkge1xuICB2YXIgYTEgPSAwLjI1NDgyOTU5MjtcbiAgdmFyIGEyID0gLTAuMjg0NDk2NzM2O1xuICB2YXIgYTMgPSAxLjQyMTQxMzc0MTtcbiAgdmFyIGE0ID0gLTEuNDUzMTUyMDI3O1xuICB2YXIgYTUgPSAxLjA2MTQwNTQyOTtcbiAgdmFyIHAgPSAwLjMyNzU5MTE7XG5cbiAgdmFyIHNpZ24gPSAxO1xuICBpZiAoeCA8IDApIHtcbiAgICBzaWduID0gLTE7XG4gIH1cbiAgeCA9IE1hdGguYWJzKHgpO1xuICB2YXIgdCA9IDEuMCAvICgxLjAgKyBwICogeCk7XG4gIHZhciB5ID0gMS4wIC0gKCgoKGE1ICogdCArIGE0KSAqIHQgKyBhMykgKiB0ICsgYTIpICogdCArIGExKSAqIHQgKiBNYXRoLmV4cCgteCAqIHgpO1xuXG4gIHJldHVybiBzaWduICogeTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcmZjX2Zsb2F0IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2VyZl9mbG9hdFxuZnVuY3Rpb24gY2FtbF9lcmZjX2Zsb2F0KHgpIHtcbiAgcmV0dXJuIDEgLSBjYW1sX2VyZl9mbG9hdCh4KTtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ZtYV9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9mbWFfZmxvYXQoeCwgeSwgeikge1xuICB2YXIgU1BMSVQgPSBNYXRoLnBvdygyLCAyNykgKyAxO1xuICB2YXIgTUlOX1ZBTFVFID0gTWF0aC5wb3coMiwgLTEwMjIpO1xuICB2YXIgRVBTSUxPTiA9IE1hdGgucG93KDIsIC01Mik7XG4gIHZhciBDID0gNDE2O1xuICB2YXIgQSA9IE1hdGgucG93KDIsICtDKTtcbiAgdmFyIEIgPSBNYXRoLnBvdygyLCAtQyk7XG5cbiAgZnVuY3Rpb24gbXVsdGlwbHkgKGEsIGIpIHtcbiAgICB2YXIgYXQgPSBTUExJVCAqIGE7XG4gICAgdmFyIGFoaSA9IGF0IC0gKGF0IC0gYSk7XG4gICAgdmFyIGFsbyA9IGEgLSBhaGk7XG4gICAgdmFyIGJ0ID0gU1BMSVQgKiBiO1xuICAgIHZhciBiaGkgPSBidCAtIChidCAtIGIpO1xuICAgIHZhciBibG8gPSBiIC0gYmhpO1xuICAgIHZhciBwID0gYSAqIGI7XG4gICAgdmFyIGUgPSAoKGFoaSAqIGJoaSAtIHApICsgYWhpICogYmxvICsgYWxvICogYmhpKSArIGFsbyAqIGJsbztcbiAgICByZXR1cm4ge1xuICAgICAgcDogcCxcbiAgICAgIGU6IGVcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIGFkZCAoYSwgYikge1xuICAgIHZhciBzID0gYSArIGI7XG4gICAgdmFyIHYgPSBzIC0gYTtcbiAgICB2YXIgZSA9IChhIC0gKHMgLSB2KSkgKyAoYiAtIHYpO1xuICAgIHJldHVybiB7XG4gICAgICBzOiBzLFxuICAgICAgZTogZVxuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gYWRqdXN0ICh4LCB5KSB7XG4gICAgcmV0dXJuIHggIT09IDAgJiYgeSAhPT0gMCAmJiBTUExJVCAqIHggLSAoU1BMSVQgKiB4IC0geCkgPT09IHggPyB4ICogKDEgKyAoeCA8IDAgPyAtMSA6ICsxKSAqICh5IDwgMCA/IC0xIDogKzEpICogRVBTSUxPTikgOiB4O1xuICB9O1xuXG4gIGlmICh4ID09PSAwIHx8IHggIT09IHggfHwgeCA9PT0gKzEgLyAwIHx8IHggPT09IC0xIC8gMCB8fFxuICAgICAgeSA9PT0gMCB8fCB5ICE9PSB5IHx8IHkgPT09ICsxIC8gMCB8fCB5ID09PSAtMSAvIDApIHtcbiAgICByZXR1cm4geCAqIHkgKyB6O1xuICB9XG4gIGlmICh6ID09PSAwKSB7XG4gICAgcmV0dXJuIHggKiB5O1xuICB9XG4gIGlmICh6ICE9PSB6IHx8IHogPT09ICsxIC8gMCB8fCB6ID09PSAtMSAvIDApIHtcbiAgICByZXR1cm4gejtcbiAgfVxuXG4gIHZhciBzY2FsZSA9IDE7XG4gIHdoaWxlIChNYXRoLmFicyh4KSA+IEEpIHtcbiAgICBzY2FsZSAqPSBBO1xuICAgIHggKj0gQjtcbiAgfVxuICB3aGlsZSAoTWF0aC5hYnMoeSkgPiBBKSB7XG4gICAgc2NhbGUgKj0gQTtcbiAgICB5ICo9IEI7XG4gIH1cbiAgaWYgKHNjYWxlID09PSAxIC8gMCkge1xuICAgIHJldHVybiB4ICogeSAqIHNjYWxlO1xuICB9XG4gIHdoaWxlIChNYXRoLmFicyh4KSA8IEIpIHtcbiAgICBzY2FsZSAqPSBCO1xuICAgIHggKj0gQTtcbiAgfVxuICB3aGlsZSAoTWF0aC5hYnMoeSkgPCBCKSB7XG4gICAgc2NhbGUgKj0gQjtcbiAgICB5ICo9IEE7XG4gIH1cbiAgaWYgKHNjYWxlID09PSAwKSB7XG4gICAgcmV0dXJuIHo7XG4gIH1cblxuICB2YXIgeHMgPSB4O1xuICB2YXIgeXMgPSB5O1xuICB2YXIgenMgPSB6IC8gc2NhbGU7XG5cbiAgaWYgKE1hdGguYWJzKHpzKSA+IE1hdGguYWJzKHhzICogeXMpICogNCAvIEVQU0lMT04pIHtcbiAgICByZXR1cm4gejtcbiAgfVxuICBpZiAoTWF0aC5hYnMoenMpIDwgTWF0aC5hYnMoeHMgKiB5cykgKiBFUFNJTE9OIC8gNCAqIEVQU0lMT04gLyA0KSB7XG4gICAgenMgPSAoeiA8IDAgPyAtMSA6ICsxKSAqIE1JTl9WQUxVRTtcbiAgfVxuXG4gIHZhciB4eSA9IG11bHRpcGx5KHhzLCB5cyk7XG4gIHZhciBzID0gYWRkKHh5LnAsIHpzKTtcbiAgdmFyIHUgPSBhZGQoeHkuZSwgcy5lKTtcbiAgdmFyIGkgPSBhZGQocy5zLCB1LnMpO1xuXG4gIHZhciBmID0gaS5zICsgYWRqdXN0KGkuZSwgdS5lKTtcbiAgaWYgKGYgPT09IDApIHtcbiAgICByZXR1cm4gZjtcbiAgfVxuXG4gIHZhciBmcyA9IGYgKiBzY2FsZTtcbiAgaWYgKE1hdGguYWJzKGZzKSA+IE1JTl9WQUxVRSkge1xuICAgIHJldHVybiBmcztcbiAgfVxuXG4gIC8vIEl0IGlzIHBvc3NpYmxlIHRoYXQgdGhlcmUgd2FzIGV4dHJhIHJvdW5kaW5nIGZvciBhIGRlbm9ybWFsaXplZCB2YWx1ZS5cbiAgcmV0dXJuIGZzICsgYWRqdXN0KGYgLSBmcyAvIHNjYWxlLCBpLmUpICogc2NhbGU7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZm9ybWF0X2Zsb2F0IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX3BhcnNlX2Zvcm1hdCwgY2FtbF9maW5pc2hfZm9ybWF0dGluZ1xuZnVuY3Rpb24gY2FtbF9mb3JtYXRfZmxvYXQgKGZtdCwgeCkge1xuICBmdW5jdGlvbiB0b0ZpeGVkKHgsZHApIHtcbiAgICBpZiAoTWF0aC5hYnMoeCkgPCAxLjApIHtcbiAgICAgIHJldHVybiB4LnRvRml4ZWQoZHApO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZSA9IHBhcnNlSW50KHgudG9TdHJpbmcoKS5zcGxpdCgnKycpWzFdKTtcbiAgICAgIGlmIChlID4gMjApIHtcbiAgICAgICAgZSAtPSAyMDtcbiAgICAgICAgeCAvPSBNYXRoLnBvdygxMCxlKTtcbiAgICAgICAgeCArPSAobmV3IEFycmF5KGUrMSkpLmpvaW4oJzAnKTtcbiAgICAgICAgaWYoZHAgPiAwKSB7XG4gICAgICAgICAgeCA9IHggKyAnLicgKyAobmV3IEFycmF5KGRwKzEpKS5qb2luKCcwJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHg7XG4gICAgICB9XG4gICAgICBlbHNlIHJldHVybiB4LnRvRml4ZWQoZHApXG4gICAgfVxuICB9XG4gIHZhciBzLCBmID0gY2FtbF9wYXJzZV9mb3JtYXQoZm10KTtcbiAgdmFyIHByZWMgPSAoZi5wcmVjIDwgMCk/NjpmLnByZWM7XG4gIGlmICh4IDwgMCB8fCAoeCA9PSAwICYmIDEveCA9PSAtSW5maW5pdHkpKSB7IGYuc2lnbiA9IC0xOyB4ID0gLXg7IH1cbiAgaWYgKGlzTmFOKHgpKSB7IHMgPSBcIm5hblwiOyBmLmZpbGxlciA9ICcgJzsgfVxuICBlbHNlIGlmICghaXNGaW5pdGUoeCkpIHsgcyA9IFwiaW5mXCI7IGYuZmlsbGVyID0gJyAnOyB9XG4gIGVsc2VcbiAgICBzd2l0Y2ggKGYuY29udikge1xuICAgIGNhc2UgJ2UnOlxuICAgICAgdmFyIHMgPSB4LnRvRXhwb25lbnRpYWwocHJlYyk7XG4gICAgICAvLyBleHBvbmVudCBzaG91bGQgYmUgYXQgbGVhc3QgdHdvIGRpZ2l0c1xuICAgICAgdmFyIGkgPSBzLmxlbmd0aDtcbiAgICAgIGlmIChzLmNoYXJBdChpIC0gMykgPT0gJ2UnKVxuICAgICAgICBzID0gcy5zbGljZSAoMCwgaSAtIDEpICsgJzAnICsgcy5zbGljZSAoaSAtIDEpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZic6XG4gICAgICBzID0gdG9GaXhlZCh4LCBwcmVjKTsgYnJlYWs7XG4gICAgY2FzZSAnZyc6XG4gICAgICBwcmVjID0gcHJlYz9wcmVjOjE7XG4gICAgICBzID0geC50b0V4cG9uZW50aWFsKHByZWMgLSAxKTtcbiAgICAgIHZhciBqID0gcy5pbmRleE9mKCdlJyk7XG4gICAgICB2YXIgZXhwID0gK3Muc2xpY2UoaiArIDEpO1xuICAgICAgaWYgKGV4cCA8IC00IHx8IHggPj0gMWUyMSB8fCB4LnRvRml4ZWQoMCkubGVuZ3RoID4gcHJlYykge1xuICAgICAgICAvLyByZW1vdmUgdHJhaWxpbmcgemVyb2VzXG4gICAgICAgIHZhciBpID0gaiAtIDE7IHdoaWxlIChzLmNoYXJBdChpKSA9PSAnMCcpIGktLTtcbiAgICAgICAgaWYgKHMuY2hhckF0KGkpID09ICcuJykgaS0tO1xuICAgICAgICBzID0gcy5zbGljZSgwLCBpICsgMSkgKyBzLnNsaWNlKGopO1xuICAgICAgICBpID0gcy5sZW5ndGg7XG4gICAgICAgIGlmIChzLmNoYXJBdChpIC0gMykgPT0gJ2UnKVxuICAgICAgICAgIHMgPSBzLnNsaWNlICgwLCBpIC0gMSkgKyAnMCcgKyBzLnNsaWNlIChpIC0gMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHAgPSBwcmVjO1xuICAgICAgICBpZiAoZXhwIDwgMCkgeyBwIC09IGV4cCArIDE7IHMgPSB4LnRvRml4ZWQocCk7IH1cbiAgICAgICAgZWxzZSB3aGlsZSAocyA9IHgudG9GaXhlZChwKSwgcy5sZW5ndGggPiBwcmVjICsgMSkgcC0tO1xuICAgICAgICBpZiAocCkge1xuICAgICAgICAgIC8vIHJlbW92ZSB0cmFpbGluZyB6ZXJvZXNcbiAgICAgICAgICB2YXIgaSA9IHMubGVuZ3RoIC0gMTsgd2hpbGUgKHMuY2hhckF0KGkpID09ICcwJykgaS0tO1xuICAgICAgICAgIGlmIChzLmNoYXJBdChpKSA9PSAnLicpIGktLTtcbiAgICAgICAgICBzID0gcy5zbGljZSgwLCBpICsgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgcmV0dXJuIGNhbWxfZmluaXNoX2Zvcm1hdHRpbmcoZiwgcyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmxvYXRfb2Zfc3RyaW5nIChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGgsIGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfZmxvYXRfb2Zfc3RyaW5nKHMpIHtcbiAgdmFyIHJlcztcbiAgcyA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcocylcbiAgcmVzID0gK3M7XG4gIGlmICgocy5sZW5ndGggPiAwKSAmJiAocmVzID09PSByZXMpKSByZXR1cm4gcmVzO1xuICBzID0gcy5yZXBsYWNlKC9fL2csXCJcIik7XG4gIHJlcyA9ICtzO1xuICBpZiAoKChzLmxlbmd0aCA+IDApICYmIChyZXMgPT09IHJlcykpIHx8IC9eWystXT9uYW4kL2kudGVzdChzKSkgcmV0dXJuIHJlcztcbiAgdmFyIG0gPSAvXiAqKFsrLV0/KTB4KFswLTlhLWZdKylcXC4/KFswLTlhLWZdKikocChbKy1dP1swLTldKykpPy9pLmV4ZWMocyk7XG4gIC8vICAgICAgICAgIDEgICAgICAgIDIgICAgICAgICAgICAgMyAgICAgICAgICAgNVxuICBpZihtKXtcbiAgICB2YXIgbTMgPSBtWzNdLnJlcGxhY2UoLzArJC8sJycpO1xuICAgIHZhciBtYW50aXNzYSA9IHBhcnNlSW50KG1bMV0gKyBtWzJdICsgbTMsIDE2KTtcbiAgICB2YXIgZXhwb25lbnQgPSAobVs1XXwwKSAtIDQqbTMubGVuZ3RoO1xuICAgIHJlcyA9IG1hbnRpc3NhICogTWF0aC5wb3coMiwgZXhwb25lbnQpO1xuICAgIHJldHVybiByZXM7XG4gIH1cbiAgaWYoL15cXCs/aW5mKGluaXR5KT8kL2kudGVzdChzKSkgcmV0dXJuIEluZmluaXR5O1xuICBpZigvXi1pbmYoaW5pdHkpPyQvaS50ZXN0KHMpKSByZXR1cm4gLUluZmluaXR5O1xuICBjYW1sX2ZhaWx3aXRoKFwiZmxvYXRfb2Zfc3RyaW5nXCIpO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogY2FtbF91cGRhdGVfZHVtbXlcbmZ1bmN0aW9uIGNhbWxfdXBkYXRlX2R1bW15ICh4LCB5KSB7XG4gIGlmKCB5LmZ1biApIHsgeC5mdW4gPSB5LmZ1bjsgcmV0dXJuIDA7IH1cbiAgaWYoIHR5cGVvZiB5PT09XCJmdW5jdGlvblwiICkgeyB4LmZ1biA9IHk7IHJldHVybiAwOyB9XG4gIHZhciBpID0geS5sZW5ndGg7IHdoaWxlIChpLS0pIHhbaV0gPSB5W2ldOyByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hbGxvY19kdW1teV9pbmZpeFxuLy9SZXF1aXJlczogY2FtbF9jYWxsX2dlblxuZnVuY3Rpb24gY2FtbF9hbGxvY19kdW1teV9pbmZpeCAoKSB7XG4gIHJldHVybiBmdW5jdGlvbiBmICh4KSB7IHJldHVybiBjYW1sX2NhbGxfZ2VuKGYuZnVuLCBbeF0pIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfaXNfYmxvY2sgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9vYmpfaXNfYmxvY2sgKHgpIHsgcmV0dXJuICsoeCBpbnN0YW5jZW9mIEFycmF5KTsgfVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX3RhZ1xuLy9SZXF1aXJlczogY2FtbF9pc19tbF9ieXRlcywgY2FtbF9pc19tbF9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfb2JqX3RhZyAoeCkge1xuICBpZiAoKHggaW5zdGFuY2VvZiBBcnJheSkgJiYgeFswXSA9PSAoeFswXSA+Pj4gMCkpXG4gICAgcmV0dXJuIHhbMF1cbiAgZWxzZSBpZiAoY2FtbF9pc19tbF9ieXRlcyh4KSlcbiAgICByZXR1cm4gMjUyXG4gIGVsc2UgaWYgKGNhbWxfaXNfbWxfc3RyaW5nKHgpKVxuICAgIHJldHVybiAyNTJcbiAgZWxzZSBpZiAoKHggaW5zdGFuY2VvZiBGdW5jdGlvbikgfHwgdHlwZW9mIHggPT0gXCJmdW5jdGlvblwiKVxuICAgIHJldHVybiAyNDdcbiAgZWxzZSBpZiAoeCAmJiB4LmNhbWxfY3VzdG9tKVxuICAgIHJldHVybiAyNTVcbiAgZWxzZVxuICAgIHJldHVybiAxMDAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX3NldF90YWcgKG11dGFibGUsIGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9vYmpfc2V0X3RhZyAoeCwgdGFnKSB7IHhbMF0gPSB0YWc7IHJldHVybiAwOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX29ial9ibG9jayBjb25zdCAoY29uc3QsY29uc3QpXG5mdW5jdGlvbiBjYW1sX29ial9ibG9jayAodGFnLCBzaXplKSB7XG4gIHZhciBvID0gbmV3IEFycmF5KHNpemUrMSk7XG4gIG9bMF09dGFnO1xuICBmb3IgKHZhciBpID0gMTsgaSA8PSBzaXplOyBpKyspIG9baV0gPSAwO1xuICByZXR1cm4gbztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfd2l0aF90YWdcbmZ1bmN0aW9uIGNhbWxfb2JqX3dpdGhfdGFnKHRhZyx4KSB7XG4gIHZhciBsID0geC5sZW5ndGg7XG4gIHZhciBhID0gbmV3IEFycmF5KGwpO1xuICBhWzBdID0gdGFnO1xuICBmb3IodmFyIGkgPSAxOyBpIDwgbDsgaSsrICkgYVtpXSA9IHhbaV07XG4gIHJldHVybiBhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29ial9kdXAgbXV0YWJsZSAobXV0YWJsZSlcbmZ1bmN0aW9uIGNhbWxfb2JqX2R1cCAoeCkge1xuICB2YXIgbCA9IHgubGVuZ3RoO1xuICB2YXIgYSA9IG5ldyBBcnJheShsKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGw7IGkrKyApIGFbaV0gPSB4W2ldO1xuICByZXR1cm4gYTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfdHJ1bmNhdGUgKG11dGFibGUsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX29ial90cnVuY2F0ZSAoeCwgcykge1xuICBpZiAoczw9MCB8fCBzICsgMSA+IHgubGVuZ3RoKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudCAoXCJPYmoudHJ1bmNhdGVcIik7XG4gIGlmICh4Lmxlbmd0aCAhPSBzICsgMSkgeC5sZW5ndGggPSBzICsgMTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX21ha2VfZm9yd2FyZFxuZnVuY3Rpb24gY2FtbF9vYmpfbWFrZV9mb3J3YXJkIChiLHYpIHtcbiAgYlswXT0yNTA7XG4gIGJbMV09djtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfY29tcGFyZV9hbmRfc3dhcFxuZnVuY3Rpb24gY2FtbF9vYmpfY29tcGFyZV9hbmRfc3dhcCh4LGksb2xkLG4pe1xuICBpZih4W2krMV0gPT0gb2xkKSB7XG4gICAgeFtpKzFdID0gbjtcbiAgICByZXR1cm4gMTtcbiAgfVxuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29ial9pc19zaGFyZWRcbmZ1bmN0aW9uIGNhbWxfb2JqX2lzX3NoYXJlZCh4KXtcbiAgcmV0dXJuIDFcbn1cblxuLy9Qcm92aWRlczogY2FtbF9sYXp5X21ha2VfZm9yd2FyZCBjb25zdCAobXV0YWJsZSlcbmZ1bmN0aW9uIGNhbWxfbGF6eV9tYWtlX2ZvcndhcmQgKHYpIHsgcmV0dXJuIFsyNTAsIHZdOyB9XG5cbi8vLy8vLy8vLy8vLy8gQ2FtbGludGVybmFsT09cbi8vUHJvdmlkZXM6IGNhbWxfZ2V0X3B1YmxpY19tZXRob2QgY29uc3RcbnZhciBjYW1sX21ldGhvZF9jYWNoZSA9IFtdO1xuZnVuY3Rpb24gY2FtbF9nZXRfcHVibGljX21ldGhvZCAob2JqLCB0YWcsIGNhY2hlaWQpIHtcbiAgdmFyIG1ldGhzID0gb2JqWzFdO1xuICB2YXIgb2ZzID0gY2FtbF9tZXRob2RfY2FjaGVbY2FjaGVpZF07XG4gIGlmIChvZnMgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE1ha2Ugc3VyZSB0aGUgYXJyYXkgaXMgbm90IHNwYXJzZVxuICAgIGZvciAodmFyIGkgPSBjYW1sX21ldGhvZF9jYWNoZS5sZW5ndGg7IGkgPCBjYWNoZWlkOyBpKyspXG4gICAgICBjYW1sX21ldGhvZF9jYWNoZVtpXSA9IDA7XG4gIH0gZWxzZSBpZiAobWV0aHNbb2ZzXSA9PT0gdGFnKSB7XG4gICAgcmV0dXJuIG1ldGhzW29mcyAtIDFdO1xuICB9XG4gIHZhciBsaSA9IDMsIGhpID0gbWV0aHNbMV0gKiAyICsgMSwgbWk7XG4gIHdoaWxlIChsaSA8IGhpKSB7XG4gICAgbWkgPSAoKGxpK2hpKSA+PiAxKSB8IDE7XG4gICAgaWYgKHRhZyA8IG1ldGhzW21pKzFdKSBoaSA9IG1pLTI7XG4gICAgZWxzZSBsaSA9IG1pO1xuICB9XG4gIGNhbWxfbWV0aG9kX2NhY2hlW2NhY2hlaWRdID0gbGkgKyAxO1xuICAvKiByZXR1cm4gMCBpZiB0YWcgaXMgbm90IHRoZXJlICovXG4gIHJldHVybiAodGFnID09IG1ldGhzW2xpKzFdID8gbWV0aHNbbGldIDogMCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb29fbGFzdF9pZFxudmFyIGNhbWxfb29fbGFzdF9pZCA9IDA7XG5cbi8vUHJvdmlkZXM6IGNhbWxfc2V0X29vX2lkXG4vL1JlcXVpcmVzOiBjYW1sX29vX2xhc3RfaWRcbmZ1bmN0aW9uIGNhbWxfc2V0X29vX2lkIChiKSB7XG4gIGJbMl09Y2FtbF9vb19sYXN0X2lkKys7XG4gIHJldHVybiBiO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ZyZXNoX29vX2lkIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX29vX2xhc3RfaWRcbmZ1bmN0aW9uIGNhbWxfZnJlc2hfb29faWQoKSB7XG4gIHJldHVybiBjYW1sX29vX2xhc3RfaWQrKztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfcmF3X2ZpZWxkXG5mdW5jdGlvbiBjYW1sX29ial9yYXdfZmllbGQobyxpKSB7IHJldHVybiBvW2krMV0gfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29ial9zZXRfcmF3X2ZpZWxkXG5mdW5jdGlvbiBjYW1sX29ial9zZXRfcmF3X2ZpZWxkKG8saSx2KSB7IHJldHVybiBvW2krMV0gPSB2IH1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfcmVhY2hhYmxlX3dvcmRzXG5mdW5jdGlvbiBjYW1sX29ial9yZWFjaGFibGVfd29yZHMobykgeyByZXR1cm4gMDsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29ial9hZGRfb2Zmc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX29ial9hZGRfb2Zmc2V0KHYsb2Zmc2V0KSB7XG4gIGNhbWxfZmFpbHdpdGgoXCJPYmouYWRkX29mZnNldCBpcyBub3Qgc3VwcG9ydGVkXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29ial91cGRhdGVfdGFnXG5mdW5jdGlvbiBjYW1sX29ial91cGRhdGVfdGFnKGIsbyxuKSB7XG4gICAgaWYoYlswXT09bykgeyBiWzBdID0gbjsgcmV0dXJuIDEgfVxuICAgIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbGF6eV91cGRhdGVfdG9fZm9yY2luZ1xuLy9SZXF1aXJlczogY2FtbF9vYmpfdXBkYXRlX3RhZ1xuZnVuY3Rpb24gY2FtbF9sYXp5X3VwZGF0ZV90b19mb3JjaW5nKG8pIHtcbiAgaWYgKChvIGluc3RhbmNlb2YgQXJyYXkpICYmIG9bMF0gPT0gKG9bMF0gPj4+IDApICYmXG4gICAgICBjYW1sX29ial91cGRhdGVfdGFnKG8sIDI0NiwgMjQ0KSkge1xuICAgIHJldHVybiAwO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAxO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbGF6eV91cGRhdGVfdG9fZm9yd2FyZFxuLy9SZXF1aXJlczogY2FtbF9vYmpfdXBkYXRlX3RhZ1xuICBmdW5jdGlvbiBjYW1sX2xhenlfdXBkYXRlX3RvX2ZvcndhcmQobykge1xuICBjYW1sX29ial91cGRhdGVfdGFnKG8sMjQ0LDI1MCk7XG4gIHJldHVybiAwOyAvLyB1bml0XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9sYXp5X3Jlc2V0X3RvX2xhenlcbi8vUmVxdWlyZXM6IGNhbWxfb2JqX3VwZGF0ZV90YWdcbmZ1bmN0aW9uIGNhbWxfbGF6eV9yZXNldF90b19sYXp5KG8pIHtcbiAgY2FtbF9vYmpfdXBkYXRlX3RhZyhvLDI0NCwyNDYpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9sYXp5X3JlYWRfcmVzdWx0XG4vL1JlcXVpcmVzOiBjYW1sX29ial90YWdcbmZ1bmN0aW9uIGNhbWxfbGF6eV9yZWFkX3Jlc3VsdChvKSB7XG4gIHJldHVybiAoY2FtbF9vYmpfdGFnKG8pID09IDI1MCk/b1sxXTpvO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfaXNfY29udGludWF0aW9uX3RhZ1xuLy9WZXJzaW9uOiA8IDVcbmZ1bmN0aW9uIGNhbWxfaXNfY29udGludWF0aW9uX3RhZyh0KSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lzX2NvbnRpbnVhdGlvbl90YWdcbi8vVmVyc2lvbjogPj0gNVxuZnVuY3Rpb24gY2FtbF9pc19jb250aW51YXRpb25fdGFnKHQpIHtcbiAgcmV0dXJuICh0ID09IDI0NSkgPyAxIDogMDtcbn1cbiIsIi8qXG5UbyBkZWFsIHdpdGggZWZmZWN0cywgdGhlIGV4ZWN1dGlvbiBjb250ZXh0IGlzIGludHVpdGl2ZWx5IGNvbXBvc2VkIG9mXG5hIHN0YWNrIG9mIGZpYmVycy4gRWFjaCBmaWJlciBoYXMgYSBjdXJyZW50IGxvdy1sZXZlbCBjb250aW51YXRpb25cbihvbmUtYXJndW1lbnQgSmF2YVNjcmlwdCBmdW5jdGlvbiksIGEgc3RhY2sgb2YgZXhjZXB0aW9uIGhhbmRsZXJzIGFuZFxuYSB0cmlwbGUgb2YgaGFuZGxlcnMsIHdoaWNoIGFyZSBpbnZva2VkIHdoZW4gdGhlIGZpYmVyIHRlcm1pbmF0ZXNcbihlaXRoZXIgd2l0aCBhIHZhbHVlIG9yIGFuIGV4Y2VwdGlvbikgb3Igd2hlbiBhbiBlZmZlY3QgaXMgcGVyZm9ybWVkLlxuVGhlIGxvdy1sZXZlbCBjb250aW51YXRpb24gb2YgdGhlIHRvcG1vc3QgZmliZXIgKHdoaWNoIGlzIGN1cnJlbnRseVxuZXhlY3V0aW5nKSBpcyBwYXNzZWQgZnJvbSBmdW5jdGlvbiB0byBmdW5jdGlvbiBhcyBhbiBhZGRpdGlvbmFsXG5hcmd1bWVudC4gSXRzIHN0YWNrIG9mIGV4Y2VwdGlvbiBoYW5kbGVycyBpcyBzdG9yZWQgaW5cbltjYW1sX2V4bl9zdGFja10uIEV4Y2VwdGlvbiBoYW5kbGVycyBhcmUgcHVzaGVkIGludG8gdGhpcyBzdGFjayB3aGVuXG5lbnRlcmluZyBhIFt0cnkgLi4uIHdpdGggLi4uXSBhbmQgcG9wcGVkIG9uIGV4aXQuIFRoZW4sIGhhbmRsZXJzIGFuZFxudGhlIHJlbWFpbmluZyBmaWJlcnMgYXJlIHN0b3JlZCBpbiBbY2FtbF9maWJlcl9zdGFja10uIFRvIGluc3RhbGwgYW5cbmVmZmVjdCBoYW5kbGVyLCB3ZSBwdXNoIGEgbmV3IGZpYmVyIGludG8gdGhlIGV4ZWN1dGlvbiBjb250ZXh0LlxuXG5XZSBoYXZlIGJhc2ljYWxseSB0aGUgZm9sbG93aW5nIHR5cGUgZm9yIHJlaWZpZWQgY29udGludWF0aW9ucyAodHlwZVxuW2NvbnRpbnVhdGlvbl0gaW4gbW9kdWxlIFtFZmZlY3RdIG9mIHRoZSBzdGFuZGFyZCBsaWJyYXJ5KTpcblxuICB0eXBlICgnYSwgJ2IpIGNvbnRpbnVhdGlvbiA9ICgnYSwgJ2IpIHN0YWNrIHJlZlxuXG4gIGFuZCAoXywgXykgc3RhY2sgPVxuICAgICAgQ29ucyA6ICgnYiAtPiB1bml0KSAqICAgICAgICAgICAgICgqIGxvdy1sZXZlbCBjb250aW51YXRpb24gKilcbiAgICAgICAgICAgICAoZXhuIC0+IHVuaXQpIGxpc3QgKiAgICAgICAoKiBleGNlcHRpb24gaGFuZGxlcnMgKilcbiAgICAgICAgICAgICAoJ2IsICdjKSBoYW5kbGVyICpcbiAgICAgICAgICAgICAoJ2EsICdiKSBzdGFja1xuICAgICAgICAgICAgIC0+ICgnYSwgJ2MpIHN0YWNrXG4gICAgfCBFbXB0eSA6ICgnYSwgJ2EpIHN0YWNrXG5cbiAgYW5kICgnYSwnYikgaGFuZGxlciA9ICAgKCogQXMgaW4gbW9kdWxlIEVmZmVjdCBmcm9tIHRoZSBzdGFuZGFyZCBsaWJyYXJ5ICopXG4gICAgeyByZXRjOiAnYSAtPiAnYjtcbiAgICAgIGV4bmM6IGV4biAtPiAnYjtcbiAgICAgIGVmZmM6ICdjLidjIEVmZmVjdC50IC0+ICgoJ2MsJ2IpIGNvbnRpbnVhdGlvbiAtPiAnYikgb3B0aW9uIH1cblxuQ29udGludWF0aW9ucyBhcmUgb25lLXNob3QuIEEgY29udGludWF0aW9uIFtyZWYgRW1wdHldIGhhcyBhbHJlYWR5XG5iZWVuIHJlc3VtZWQuXG5cbkEgY29udGludWF0aW9uIGlzIGJhc2ljYWxseSBjb21wb3NlZCBvZiBhIGxpc3Qgb2YgZmliZXJzLCB3aGljaCBlYWNoXG5oYXMgaXRzIGxvdy1sZXZlbCBjb250aW51YXRpb24sIGl0cyBzdGFjayBvZiBleGNlcHRpb24gaGFuZGxlcnMgYW5kIGFcbnRyaXBsZSBvZiBoYW5kbGVycyB0byBkZWFsIHdpdGggd2hlbiB0aGUgZmliZXIgdGVybWluYXRlcyBvciBhblxuZWZmZWN0IGlzIHBlcmZvcm1lZC4gV2hlbiByZXN1bWluZyBhIGNvbnRpbnVhdGlvbiwgdGhlIGlubmVybW9zdCBmaWJlclxuaXMgcmVzdW1lZCBmaXJzdC5cblxuVGhlIGhhbmRsZXJzIGFyZSBDUFMtdHJhbnNmb3JtZWQgZnVuY3Rpb25zOiB0aGV5IGFjdHVhbGx5IHRha2UgYW5cbmFkZGl0aW9uYWwgcGFyYW1ldGVyIHdoaWNoIGlzIHRoZSBjdXJyZW50IGxvdy1sZXZlbCBjb250aW51YXRpb24uXG4qL1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2V4bl9zdGFja1xuLy9JZjogZWZmZWN0c1xuLy8gVGhpcyBpcyBhbiBPQ2FtbCBsaXN0IG9mIGV4Y2VwdGlvbiBoYW5kbGVyc1xudmFyIGNhbWxfZXhuX3N0YWNrID0gMDtcblxuLy9Qcm92aWRlczogY2FtbF9wdXNoX3RyYXBcbi8vUmVxdWlyZXM6IGNhbWxfZXhuX3N0YWNrXG4vL0lmOiBlZmZlY3RzXG5mdW5jdGlvbiBjYW1sX3B1c2hfdHJhcChoYW5kbGVyKSB7XG4gIGNhbWxfZXhuX3N0YWNrPVswLGhhbmRsZXIsY2FtbF9leG5fc3RhY2tdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3BvcF90cmFwXG4vL1JlcXVpcmVzOiBjYW1sX2V4bl9zdGFja1xuLy9JZjogZWZmZWN0c1xuZnVuY3Rpb24gY2FtbF9wb3BfdHJhcCgpIHtcbiAgaWYgKCFjYW1sX2V4bl9zdGFjaykgcmV0dXJuIGZ1bmN0aW9uKHgpe3Rocm93IHg7fVxuICB2YXIgaCA9IGNhbWxfZXhuX3N0YWNrWzFdO1xuICBjYW1sX2V4bl9zdGFjaz1jYW1sX2V4bl9zdGFja1syXTtcbiAgcmV0dXJuIGhcbn1cblxuLy9Qcm92aWRlczogY2FtbF9maWJlcl9zdGFja1xuLy9JZjogZWZmZWN0c1xuLy8gVGhpcyBoYXMgdGhlIHNoYXBlIHtoLCByOntrLCB4LCBlfX0gd2hlcmUgaCBpcyBhIHRyaXBsZSBvZiBoYW5kbGVyc1xuLy8gKHNlZSBlZmZlY3QuanMpIGFuZCBrLCB4IGFuZCBlIGFyZSB0aGUgc2F2ZWQgY29udGludWF0aW9uLFxuLy8gZXhjZXB0aW9uIHN0YWNrIGFuZCBmaWJlciBzdGFjayBvZiB0aGUgcGFyZW50IGZpYmVyLlxudmFyIGNhbWxfZmliZXJfc3RhY2s7XG5cbi8vUHJvdmlkZXM6Y2FtbF9yZXN1bWVfc3RhY2tcbi8vUmVxdWlyZXM6IGNhbWxfbmFtZWRfdmFsdWUsIGNhbWxfcmFpc2VfY29uc3RhbnQsIGNhbWxfZXhuX3N0YWNrLCBjYW1sX2ZpYmVyX3N0YWNrXG4vL0lmOiBlZmZlY3RzXG5mdW5jdGlvbiBjYW1sX3Jlc3VtZV9zdGFjayhzdGFjaywgaykge1xuICBpZiAoIXN0YWNrKSBjYW1sX3JhaXNlX2NvbnN0YW50XG4gICAgICAgICAgICAgICAgIChjYW1sX25hbWVkX3ZhbHVlKFwiRWZmZWN0LkNvbnRpbnVhdGlvbl9hbHJlYWR5X3Jlc3VtZWRcIikpO1xuICAvLyBVcGRhdGUgdGhlIGV4ZWN1dGlvbiBjb250ZXh0IHdpdGggdGhlIHN0YWNrIG9mIGZpYmVycyBpbiBbc3RhY2tdIGluXG4gIC8vIG9yZGVyIHRvIHJlc3VtZSB0aGUgY29udGludWF0aW9uXG4gIGRvIHtcbiAgICBjYW1sX2ZpYmVyX3N0YWNrID1cbiAgICAgIHtoOnN0YWNrWzNdLCByOntrOmssIHg6Y2FtbF9leG5fc3RhY2ssIGU6Y2FtbF9maWJlcl9zdGFja319O1xuICAgIGsgPSBzdGFja1sxXTtcbiAgICBjYW1sX2V4bl9zdGFjayA9IHN0YWNrWzJdO1xuICAgIHN0YWNrID0gc3RhY2tbNF07XG4gIH0gd2hpbGUgKHN0YWNrKVxuICByZXR1cm4gaztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9wb3BfZmliZXJcbi8vUmVxdWlyZXM6IGNhbWxfZXhuX3N0YWNrLCBjYW1sX2ZpYmVyX3N0YWNrXG4vL0lmOiBlZmZlY3RzXG5mdW5jdGlvbiBjYW1sX3BvcF9maWJlcigpIHtcbiAgLy8gTW92ZSB0byB0aGUgcGFyZW50IGZpYmVyLCByZXR1cm5pbmcgdGhlIHBhcmVudCdzIGxvdy1sZXZlbCBjb250aW51YXRpb25cbiAgdmFyIHJlbSA9IGNhbWxfZmliZXJfc3RhY2sucjtcbiAgY2FtbF9leG5fc3RhY2sgPSByZW0ueDtcbiAgY2FtbF9maWJlcl9zdGFjayA9IHJlbS5lO1xuICByZXR1cm4gcmVtLms7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcGVyZm9ybV9lZmZlY3Rcbi8vUmVxdWlyZXM6IGNhbWxfcG9wX2ZpYmVyLCBjYW1sX3N0YWNrX2NoZWNrX2RlcHRoLCBjYW1sX3RyYW1wb2xpbmVfcmV0dXJuLCBjYW1sX2V4bl9zdGFjaywgY2FtbF9maWJlcl9zdGFja1xuLy9JZjogZWZmZWN0c1xuZnVuY3Rpb24gY2FtbF9wZXJmb3JtX2VmZmVjdChlZmYsIGNvbnQsIGswKSB7XG4gIC8vIEFsbG9jYXRlIGEgY29udGludWF0aW9uIGlmIHdlIGRvbid0IGFscmVhZHkgaGF2ZSBvbmVcbiAgaWYgKCFjb250KSBjb250ID0gWzI0NSAvKmNvbnRpbnVhdGlvbiovLCAwXTtcbiAgLy8gR2V0IGN1cnJlbnQgZWZmZWN0IGhhbmRsZXJcbiAgdmFyIGhhbmRsZXIgPSBjYW1sX2ZpYmVyX3N0YWNrLmhbM107XG4gIC8vIENvbnMgdGhlIGN1cnJlbnQgZmliZXIgb250byB0aGUgY29udGludWF0aW9uOlxuICAvLyAgIGNvbnQgOj0gQ29ucyAoaywgZXhuX3N0YWNrLCBoYW5kbGVycywgIWNvbnQpXG4gIGNvbnRbMV0gPSBbMCxrMCxjYW1sX2V4bl9zdGFjayxjYW1sX2ZpYmVyX3N0YWNrLmgsY29udFsxXV07XG4gIC8vIE1vdmUgdG8gcGFyZW50IGZpYmVyIGFuZCBleGVjdXRlIHRoZSBlZmZlY3QgaGFuZGxlciB0aGVyZVxuICAvLyBUaGUgaGFuZGxlciBpcyBkZWZpbmVkIGluIFN0ZGxpYi5FZmZlY3QsIHNvIHdlIGtub3cgdGhhdCB0aGUgYXJpdHkgbWF0Y2hlc1xuICB2YXIgazEgPSBjYW1sX3BvcF9maWJlcigpO1xuICByZXR1cm4gY2FtbF9zdGFja19jaGVja19kZXB0aCgpP2hhbmRsZXIoZWZmLGNvbnQsazEsazEpXG4gICAgICAgICA6Y2FtbF90cmFtcG9saW5lX3JldHVybihoYW5kbGVyLFtlZmYsY29udCxrMSxrMV0pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FsbG9jX3N0YWNrXG4vL1JlcXVpcmVzOiBjYW1sX3BvcF9maWJlciwgY2FtbF9maWJlcl9zdGFjaywgY2FtbF9jYWxsX2dlbiwgY2FtbF9zdGFja19jaGVja19kZXB0aCwgY2FtbF90cmFtcG9saW5lX3JldHVyblxuLy9JZjogZWZmZWN0c1xuZnVuY3Rpb24gY2FtbF9hbGxvY19zdGFjayhodiwgaHgsIGhmKSB7XG4gIGZ1bmN0aW9uIGNhbGwoaSwgeCkge1xuICAgIHZhciBmPWNhbWxfZmliZXJfc3RhY2suaFtpXTtcbiAgICB2YXIgYXJncyA9IFt4LCBjYW1sX3BvcF9maWJlcigpXTtcbiAgICByZXR1cm4gY2FtbF9zdGFja19jaGVja19kZXB0aCgpP2NhbWxfY2FsbF9nZW4oZixhcmdzKVxuICAgICAgICAgICA6Y2FtbF90cmFtcG9saW5lX3JldHVybihmLGFyZ3MpO1xuICB9XG4gIGZ1bmN0aW9uIGh2YWwoeCkge1xuICAgIC8vIENhbGwgW2h2XSBpbiB0aGUgcGFyZW50IGZpYmVyXG4gICAgcmV0dXJuIGNhbGwoMSwgeCk7XG4gIH1cbiAgZnVuY3Rpb24gaGV4bihlKSB7XG4gICAgLy8gQ2FsbCBbaHhdIGluIHRoZSBwYXJlbnQgZmliZXJcbiAgICByZXR1cm4gY2FsbCgyLCBlKTtcbiAgfVxuICByZXR1cm4gWzAsIGh2YWwsIFswLCBoZXhuLCAwXSwgWzAsIGh2LCBoeCwgaGZdLCAwXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hbGxvY19zdGFja1xuLy9JZjogIWVmZmVjdHNcbmZ1bmN0aW9uIGNhbWxfYWxsb2Nfc3RhY2soaHYsIGh4LCBoZikge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jb250aW51YXRpb25fdXNlX25vZXhjXG5mdW5jdGlvbiBjYW1sX2NvbnRpbnVhdGlvbl91c2Vfbm9leGMoY29udCkge1xuICB2YXIgc3RhY2s9Y29udFsxXTtcbiAgY29udFsxXT0wO1xuICByZXR1cm4gc3RhY2s7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY29udGludWF0aW9uX3VzZV9hbmRfdXBkYXRlX2hhbmRsZXJfbm9leGNcbi8vUmVxdWlyZXM6IGNhbWxfY29udGludWF0aW9uX3VzZV9ub2V4Y1xuZnVuY3Rpb24gY2FtbF9jb250aW51YXRpb25fdXNlX2FuZF91cGRhdGVfaGFuZGxlcl9ub2V4Yyhjb250LCBodmFsLCBoZXhuLCBoZWZmKSB7XG4gIHZhciBzdGFjayA9IGNhbWxfY29udGludWF0aW9uX3VzZV9ub2V4Yyhjb250KTtcbiAgc3RhY2tbM10gPSBbMCwgaHZhbCwgaGV4biwgaGVmZl07XG4gIHJldHVybiBzdGFjaztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9nZXRfY29udGludWF0aW9uX2NhbGxzdGFja1xuZnVuY3Rpb24gY2FtbF9nZXRfY29udGludWF0aW9uX2NhbGxzdGFjayAoKSB7IHJldHVybiBbMF07IH1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9jb25kaXRpb25fbmV3XG5mdW5jdGlvbiBjYW1sX21sX2NvbmRpdGlvbl9uZXcodW5pdCl7XG4gICAgcmV0dXJuIHtjb25kaXRpb246MX07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfY29uZGl0aW9uX3dhaXRcbmZ1bmN0aW9uIGNhbWxfbWxfY29uZGl0aW9uX3dhaXQodCxtdXRleHQpe1xuICAgIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2NvbmRpdGlvbl9icm9hZGNhc3RcbmZ1bmN0aW9uIGNhbWxfbWxfY29uZGl0aW9uX2Jyb2FkY2FzdCh0KXtcbiAgICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9jb25kaXRpb25fc2lnbmFsXG5mdW5jdGlvbiBjYW1sX21sX2NvbmRpdGlvbl9zaWduYWwodCl7XG4gICAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGpzb29fZWZmZWN0X25vdF9zdXBwb3J0ZWRcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbi8vIUlmOiBlZmZlY3RzXG5mdW5jdGlvbiBqc29vX2VmZmVjdF9ub3Rfc3VwcG9ydGVkKCl7XG4gIGNhbWxfZmFpbHdpdGgoXCJFZmZlY3QgaGFuZGxlcnMgYXJlIG5vdCBzdXBwb3J0ZWRcIik7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vLy8vLy8vLy8vLy8vIEFycmF5XG5cbi8vUHJvdmlkZXM6IGNhbWxfYXJyYXlfc3ViIG11dGFibGVcbmZ1bmN0aW9uIGNhbWxfYXJyYXlfc3ViIChhLCBpLCBsZW4pIHtcbiAgdmFyIGEyID0gbmV3IEFycmF5KGxlbisxKTtcbiAgYTJbMF09MDtcbiAgZm9yKHZhciBpMiA9IDEsIGkxPSBpKzE7IGkyIDw9IGxlbjsgaTIrKyxpMSsrICl7XG4gICAgYTJbaTJdPWFbaTFdO1xuICB9XG4gIHJldHVybiBhMjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9hcHBlbmQgbXV0YWJsZVxuZnVuY3Rpb24gY2FtbF9hcnJheV9hcHBlbmQoYTEsIGEyKSB7XG4gIHZhciBsMSA9IGExLmxlbmd0aCwgbDIgPSBhMi5sZW5ndGg7XG4gIHZhciBsID0gbDErbDItMVxuICB2YXIgYSA9IG5ldyBBcnJheShsKTtcbiAgYVswXSA9IDA7XG4gIHZhciBpID0gMSxqID0gMTtcbiAgZm9yKDtpPGwxO2krKykgYVtpXT1hMVtpXTtcbiAgZm9yKDtpPGw7aSsrLGorKykgYVtpXT1hMltqXTtcbiAgcmV0dXJuIGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYXJyYXlfY29uY2F0IG11dGFibGVcbmZ1bmN0aW9uIGNhbWxfYXJyYXlfY29uY2F0KGwpIHtcbiAgdmFyIGEgPSBbMF07XG4gIHdoaWxlIChsICE9PSAwKSB7XG4gICAgdmFyIGIgPSBsWzFdO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYi5sZW5ndGg7IGkrKykgYS5wdXNoKGJbaV0pO1xuICAgIGwgPSBsWzJdO1xuICB9XG4gIHJldHVybiBhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X2JsaXRcbmZ1bmN0aW9uIGNhbWxfYXJyYXlfYmxpdChhMSwgaTEsIGEyLCBpMiwgbGVuKSB7XG4gIGlmIChpMiA8PSBpMSkge1xuICAgIGZvciAodmFyIGogPSAxOyBqIDw9IGxlbjsgaisrKSBhMltpMiArIGpdID0gYTFbaTEgKyBqXTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBqID0gbGVuOyBqID49IDE7IGotLSkgYTJbaTIgKyBqXSA9IGExW2kxICsgal07XG4gIH07XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2Zsb2F0YXJyYXlfYmxpdFxuZnVuY3Rpb24gY2FtbF9mbG9hdGFycmF5X2JsaXQoYTEsIGkxLCBhMiwgaTIsIGxlbikge1xuICBpZiAoaTIgPD0gaTEpIHtcbiAgICBmb3IgKHZhciBqID0gMTsgaiA8PSBsZW47IGorKykgYTJbaTIgKyBqXSA9IGExW2kxICsgal07XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaiA9IGxlbjsgaiA+PSAxOyBqLS0pIGEyW2kyICsgal0gPSBhMVtpMSArIGpdO1xuICB9O1xuICByZXR1cm4gMDtcbn1cblxuLy8vLy8vLy8vLy8vLyBQZXJ2YXNpdmVcbi8vUHJvdmlkZXM6IGNhbWxfYXJyYXlfc2V0IChtdXRhYmxlLCBjb25zdCwgbXV0YWJsZSlcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfYXJyYXlfc2V0IChhcnJheSwgaW5kZXgsIG5ld3ZhbCkge1xuICBpZiAoKGluZGV4IDwgMCkgfHwgKGluZGV4ID49IGFycmF5Lmxlbmd0aCAtIDEpKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIGFycmF5W2luZGV4KzFdPW5ld3ZhbDsgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYXJyYXlfZ2V0IG11dGFibGUgKG11dGFibGUsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9hcnJheV9nZXQgKGFycmF5LCBpbmRleCkge1xuICBpZiAoKGluZGV4IDwgMCkgfHwgKGluZGV4ID49IGFycmF5Lmxlbmd0aCAtIDEpKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHJldHVybiBhcnJheVtpbmRleCsxXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9maWxsXG5mdW5jdGlvbiBjYW1sX2FycmF5X2ZpbGwoYXJyYXksIG9mcywgbGVuLCB2KXtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKXtcbiAgICBhcnJheVtvZnMraSsxXSA9IHY7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY2hlY2tfYm91bmQgKG11dGFibGUsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9jaGVja19ib3VuZCAoYXJyYXksIGluZGV4KSB7XG4gIGlmIChpbmRleCA+Pj4gMCA+PSBhcnJheS5sZW5ndGggLSAxKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHJldHVybiBhcnJheTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tYWtlX3ZlY3QgY29uc3QgKGNvbnN0LCBtdXRhYmxlKVxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9tYWtlX3ZlY3QgKGxlbiwgaW5pdCkge1xuICBpZiAobGVuIDwgMCkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB2YXIgbGVuID0gbGVuICsgMSB8IDA7XG4gIHZhciBiID0gbmV3IEFycmF5KGxlbik7XG4gIGJbMF09MDtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBsZW47IGkrKykgYltpXSA9IGluaXQ7XG4gIHJldHVybiBiO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21ha2VfZmxvYXRfdmVjdCBjb25zdCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX21ha2VfZmxvYXRfdmVjdChsZW4pe1xuICBpZiAobGVuIDwgMCkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB2YXIgbGVuID0gbGVuICsgMSB8IDA7XG4gIHZhciBiID0gbmV3IEFycmF5KGxlbik7XG4gIGJbMF09MjU0O1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGxlbjsgaSsrKSBiW2ldID0gMDtcbiAgcmV0dXJuIGJcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZmxvYXRhcnJheV9jcmVhdGUgY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9mbG9hdGFycmF5X2NyZWF0ZShsZW4pe1xuICBpZiAobGVuIDwgMCkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB2YXIgbGVuID0gbGVuICsgMSB8IDA7XG4gIHZhciBiID0gbmV3IEFycmF5KGxlbik7XG4gIGJbMF09MjU0O1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGxlbjsgaSsrKSBiW2ldID0gMDtcbiAgcmV0dXJuIGJcbn1cbiIsIi8vUHJvdmlkZXM6IGNhbWxfZG9tYWluX2Rsc1xudmFyIGNhbWxfZG9tYWluX2RscyA9IFswXTtcblxuLy9Qcm92aWRlczogY2FtbF9kb21haW5fZGxzX3NldFxuLy9SZXF1aXJlczogY2FtbF9kb21haW5fZGxzXG5mdW5jdGlvbiBjYW1sX2RvbWFpbl9kbHNfc2V0KGEpIHtcbiAgY2FtbF9kb21haW5fZGxzID0gYTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9kb21haW5fZGxzX2NvbXBhcmVfYW5kX3NldFxuLy9SZXF1aXJlczogY2FtbF9kb21haW5fZGxzXG4vL1ZlcnNpb246ID49IDUuMlxuZnVuY3Rpb24gY2FtbF9kb21haW5fZGxzX2NvbXBhcmVfYW5kX3NldChvbGQsbikge1xuICBpZihjYW1sX2RvbWFpbl9kbHMgIT09IG9sZCkgcmV0dXJuIDBcbiAgY2FtbF9kb21haW5fZGxzID0gbjtcbiAgcmV0dXJuIDE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZG9tYWluX2Rsc19nZXRcbi8vUmVxdWlyZXM6IGNhbWxfZG9tYWluX2Rsc1xuZnVuY3Rpb24gY2FtbF9kb21haW5fZGxzX2dldCh1bml0KSB7XG4gIHJldHVybiBjYW1sX2RvbWFpbl9kbHM7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9hdG9taWNfbG9hZFxuZnVuY3Rpb24gY2FtbF9hdG9taWNfbG9hZChyZWYpe1xuICByZXR1cm4gcmVmWzFdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2F0b21pY19jYXNcbmZ1bmN0aW9uIGNhbWxfYXRvbWljX2NhcyhyZWYsbyxuKSB7XG4gIGlmKHJlZlsxXSA9PT0gbyl7XG4gICAgcmVmWzFdID0gbjtcbiAgICByZXR1cm4gMTtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hdG9taWNfZmV0Y2hfYWRkXG5mdW5jdGlvbiBjYW1sX2F0b21pY19mZXRjaF9hZGQocmVmLCBpKSB7XG4gIHZhciBvbGQgPSByZWZbMV07XG4gIHJlZlsxXSArPSBpO1xuICByZXR1cm4gb2xkO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2F0b21pY19leGNoYW5nZVxuZnVuY3Rpb24gY2FtbF9hdG9taWNfZXhjaGFuZ2UocmVmLCB2KSB7XG4gIHZhciByID0gcmVmWzFdO1xuICByZWZbMV0gPSB2O1xuICByZXR1cm4gcjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hdG9taWNfbWFrZV9jb250ZW5kZWRcbmZ1bmN0aW9uIGNhbWxfYXRvbWljX21ha2VfY29udGVuZGVkKGEpIHtcbiAgcmV0dXJuIFswLCBhXVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2RvbWFpbl91bmlxdWVfdG9rZW5cbi8vVmVyc2lvbjogPCA1LjJcbnZhciBjYW1sX21sX2RvbWFpbl91bmlxdWVfdG9rZW5fID0gWzBdXG5mdW5jdGlvbiBjYW1sX21sX2RvbWFpbl91bmlxdWVfdG9rZW4odW5pdCkge1xuICByZXR1cm4gY2FtbF9tbF9kb21haW5fdW5pcXVlX3Rva2VuX1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfZG9tYWluX3NldF9uYW1lXG5mdW5jdGlvbiBjYW1sX21sX2RvbWFpbl9zZXRfbmFtZShfbmFtZSkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9yZWNvbW1lbmRlZF9kb21haW5fY291bnRcbmZ1bmN0aW9uIGNhbWxfcmVjb21tZW5kZWRfZG9tYWluX2NvdW50KHVuaXQpIHsgcmV0dXJuIDEgfVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfZG9tYWluX2lkXG52YXIgY2FtbF9kb21haW5faWQgPSAwO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2RvbWFpbl9zcGF3blxuLy9SZXF1aXJlczogY2FtbF9tbF9tdXRleF91bmxvY2tcbi8vUmVxdWlyZXM6IGNhbWxfZG9tYWluX2lkXG4vL1JlcXVpcmVzOiBjYW1sX2NhbGxiYWNrXG4vL1ZlcnNpb246ID49IDUuMlxudmFyIGNhbWxfZG9tYWluX2xhdGVzdF9pZHggPSAxXG5mdW5jdGlvbiBjYW1sX2RvbWFpbl9zcGF3bihmLHRlcm1fc3luYyl7XG4gICAgdmFyIGlkID0gY2FtbF9kb21haW5fbGF0ZXN0X2lkeCsrO1xuICAgIHZhciBvbGQgPSBjYW1sX2RvbWFpbl9pZDtcbiAgICBjYW1sX2RvbWFpbl9pZCA9IGlkO1xuICAgIHZhciByZXMgPSBjYW1sX2NhbGxiYWNrKGYsWzBdKTtcbiAgICBjYW1sX2RvbWFpbl9pZCA9IG9sZDtcbiAgICBjYW1sX21sX211dGV4X3VubG9jayh0ZXJtX3N5bmNbMl0pO1xuICAgIC8vVE9ETzogZml4IGV4biBjYXNlXG4gICAgdGVybV9zeW5jWzFdID0gWzAsIFswLCByZXNdXTtcbiAgICByZXR1cm4gaWQ7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZG9tYWluX3NwYXduXG4vL1JlcXVpcmVzOiBjYW1sX21sX211dGV4X3VubG9ja1xuLy9SZXF1aXJlczogY2FtbF9kb21haW5faWRcbi8vUmVxdWlyZXM6IGNhbWxfY2FsbGJhY2tcbi8vVmVyc2lvbjogPCA1LjJcbnZhciBjYW1sX2RvbWFpbl9sYXRlc3RfaWR4ID0gMVxuZnVuY3Rpb24gY2FtbF9kb21haW5fc3Bhd24oZixtdXRleCl7XG4gICAgdmFyIGlkID0gY2FtbF9kb21haW5fbGF0ZXN0X2lkeCsrO1xuICAgIHZhciBvbGQgPSBjYW1sX2RvbWFpbl9pZDtcbiAgICBjYW1sX2RvbWFpbl9pZCA9IGlkO1xuICAgIHZhciByZXMgPSBjYW1sX2NhbGxiYWNrKGYsWzBdKTtcbiAgICBjYW1sX2RvbWFpbl9pZCA9IG9sZDtcbiAgICBjYW1sX21sX211dGV4X3VubG9jayhtdXRleCk7XG4gICAgcmV0dXJuIGlkO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfZG9tYWluX2lkXG4vL1JlcXVpcmVzOiBjYW1sX2RvbWFpbl9pZFxuZnVuY3Rpb24gY2FtbF9tbF9kb21haW5faWQodW5pdCl7XG4gICAgcmV0dXJuIGNhbWxfZG9tYWluX2lkO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfZG9tYWluX2NwdV9yZWxheFxuZnVuY3Rpb24gY2FtbF9tbF9kb21haW5fY3B1X3JlbGF4KHVuaXQpe1xuICAgIHJldHVybiAwO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogY2FtbF9mb3JtYXRfaW50IGNvbnN0IChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX3BhcnNlX2Zvcm1hdCwgY2FtbF9maW5pc2hfZm9ybWF0dGluZywgY2FtbF9zdHJfcmVwZWF0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzLCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2Zvcm1hdF9pbnQoZm10LCBpKSB7XG4gIGlmIChjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKGZtdCkgPT0gXCIlZFwiKSByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhcIlwiK2kpO1xuICB2YXIgZiA9IGNhbWxfcGFyc2VfZm9ybWF0KGZtdCk7XG4gIGlmIChpIDwgMCkgeyBpZiAoZi5zaWduZWRjb252KSB7IGYuc2lnbiA9IC0xOyBpID0gLWk7IH0gZWxzZSBpID4+Pj0gMDsgfVxuICB2YXIgcyA9IGkudG9TdHJpbmcoZi5iYXNlKTtcbiAgaWYgKGYucHJlYyA+PSAwKSB7XG4gICAgZi5maWxsZXIgPSAnICc7XG4gICAgdmFyIG4gPSBmLnByZWMgLSBzLmxlbmd0aDtcbiAgICBpZiAobiA+IDApIHMgPSBjYW1sX3N0cl9yZXBlYXQgKG4sICcwJykgKyBzO1xuICB9XG4gIHJldHVybiBjYW1sX2ZpbmlzaF9mb3JtYXR0aW5nKGYsIHMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3BhcnNlX3NpZ25fYW5kX2Jhc2Vcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQsIGNhbWxfbWxfc3RyaW5nX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9wYXJzZV9zaWduX2FuZF9iYXNlIChzKSB7XG4gIHZhciBpID0gMCwgbGVuID0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpLCBiYXNlID0gMTAsIHNpZ24gPSAxO1xuICBpZiAobGVuID4gMCkge1xuICAgIHN3aXRjaCAoY2FtbF9zdHJpbmdfdW5zYWZlX2dldChzLGkpKSB7XG4gICAgY2FzZSA0NTogaSsrOyBzaWduID0gLTE7IGJyZWFrO1xuICAgIGNhc2UgNDM6IGkrKzsgc2lnbiA9IDE7IGJyZWFrO1xuICAgIH1cbiAgfVxuICBpZiAoaSArIDEgPCBsZW4gJiYgY2FtbF9zdHJpbmdfdW5zYWZlX2dldChzLCBpKSA9PSA0OClcbiAgICBzd2l0Y2ggKGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQocywgaSArIDEpKSB7XG4gICAgY2FzZSAxMjA6IGNhc2UgODg6IGJhc2UgPSAxNjsgaSArPSAyOyBicmVhaztcbiAgICBjYXNlIDExMTogY2FzZSA3OTogYmFzZSA9ICA4OyBpICs9IDI7IGJyZWFrO1xuICAgIGNhc2UgIDk4OiBjYXNlIDY2OiBiYXNlID0gIDI7IGkgKz0gMjsgYnJlYWs7XG4gICAgY2FzZSAxMTc6IGNhc2UgODU6IGkgKz0gMjsgYnJlYWs7XG4gICAgfVxuICByZXR1cm4gW2ksIHNpZ24sIGJhc2VdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3BhcnNlX2RpZ2l0XG5mdW5jdGlvbiBjYW1sX3BhcnNlX2RpZ2l0KGMpIHtcbiAgaWYgKGMgPj0gNDggJiYgYyA8PSA1NykgIHJldHVybiBjIC0gNDg7XG4gIGlmIChjID49IDY1ICYmIGMgPD0gOTApICByZXR1cm4gYyAtIDU1O1xuICBpZiAoYyA+PSA5NyAmJiBjIDw9IDEyMikgcmV0dXJuIGMgLSA4NztcbiAgcmV0dXJuIC0xO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludF9vZl9zdHJpbmcgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoLCBjYW1sX3N0cmluZ191bnNhZmVfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX3BhcnNlX3NpZ25fYW5kX2Jhc2UsIGNhbWxfcGFyc2VfZGlnaXQsIGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfaW50X29mX3N0cmluZyAocykge1xuICB2YXIgciA9IGNhbWxfcGFyc2Vfc2lnbl9hbmRfYmFzZSAocyk7XG4gIHZhciBpID0gclswXSwgc2lnbiA9IHJbMV0sIGJhc2UgPSByWzJdO1xuICB2YXIgbGVuID0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpO1xuICB2YXIgdGhyZXNob2xkID0gLTEgPj4+IDA7XG4gIHZhciBjID0gKGkgPCBsZW4pP2NhbWxfc3RyaW5nX3Vuc2FmZV9nZXQocywgaSk6MDtcbiAgdmFyIGQgPSBjYW1sX3BhcnNlX2RpZ2l0KGMpO1xuICBpZiAoZCA8IDAgfHwgZCA+PSBiYXNlKSBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgdmFyIHJlcyA9IGQ7XG4gIGZvciAoaSsrO2k8bGVuO2krKykge1xuICAgIGMgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0KHMsIGkpO1xuICAgIGlmIChjID09IDk1KSBjb250aW51ZTtcbiAgICBkID0gY2FtbF9wYXJzZV9kaWdpdChjKTtcbiAgICBpZiAoZCA8IDAgfHwgZCA+PSBiYXNlKSBicmVhaztcbiAgICByZXMgPSBiYXNlICogcmVzICsgZDtcbiAgICBpZiAocmVzID4gdGhyZXNob2xkKSBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgfVxuICBpZiAoaSAhPSBsZW4pIGNhbWxfZmFpbHdpdGgoXCJpbnRfb2Zfc3RyaW5nXCIpO1xuICAvLyBGb3IgYmFzZSBkaWZmZXJlbnQgZnJvbSAxMCwgd2UgZXhwZWN0IGFuIHVuc2lnbmVkIHJlcHJlc2VudGF0aW9uLFxuICAvLyBoZW5jZSBhbnkgdmFsdWUgb2YgJ3JlcycgKGxlc3MgdGhhbiAndGhyZXNob2xkJykgaXMgYWNjZXB0YWJsZS5cbiAgLy8gQnV0IHdlIGhhdmUgdG8gY29udmVydCB0aGUgcmVzdWx0IGJhY2sgdG8gYSBzaWduZWQgaW50ZWdlci5cbiAgcmVzID0gc2lnbiAqIHJlcztcbiAgaWYgKChiYXNlID09IDEwKSAmJiAoKHJlcyB8IDApICE9IHJlcykpXG4gICAgLyogU2lnbmVkIHJlcHJlc2VudGF0aW9uIGV4cGVjdGVkLCBhbGxvdyAtMl4obmJpdHMtMSkgdG8gMl4obmJpdHMtMSkgLSAxICovXG4gICAgY2FtbF9mYWlsd2l0aChcImludF9vZl9zdHJpbmdcIik7XG4gIHJldHVybiByZXMgfCAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX211bCBjb25zdFxuZnVuY3Rpb24gY2FtbF9tdWwoYSxiKXtcbiAgcmV0dXJuIE1hdGguaW11bChhLGIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2RpdlxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV96ZXJvX2RpdmlkZVxuZnVuY3Rpb24gY2FtbF9kaXYoeCx5KSB7XG4gIGlmICh5ID09IDApIGNhbWxfcmFpc2VfemVyb19kaXZpZGUgKCk7XG4gIHJldHVybiAoeC95KXwwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21vZFxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV96ZXJvX2RpdmlkZVxuZnVuY3Rpb24gY2FtbF9tb2QoeCx5KSB7XG4gIGlmICh5ID09IDApIGNhbWxfcmFpc2VfemVyb19kaXZpZGUgKCk7XG4gIHJldHVybiB4JXk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnN3YXAxNlxuZnVuY3Rpb24gY2FtbF9ic3dhcDE2KHgpIHtcbiAgcmV0dXJuICgoKCh4ICYgMHgwMEZGKSA8PCA4KSB8XG4gICAgICAgICAgICgoeCAmIDB4RkYwMCkgPj4gOCkpKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfaW50MzJfYnN3YXBcbmZ1bmN0aW9uIGNhbWxfaW50MzJfYnN3YXAoeCkge1xuICByZXR1cm4gKCgoeCAmIDB4MDAwMDAwRkYpIDw8IDI0KSB8XG4gICAgICAgICAgKCh4ICYgMHgwMDAwRkYwMCkgPDwgOCkgfFxuICAgICAgICAgICgoeCAmIDB4MDBGRjAwMDApID4+PiA4KSB8XG4gICAgICAgICAgKCh4ICYgMHhGRjAwMDAwMCkgPj4+IDI0KSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2Jzd2FwXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3RvX2J5dGVzLCBjYW1sX2ludDY0X29mX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2ludDY0X2Jzd2FwKHgpIHtcbiAgdmFyIHkgPSBjYW1sX2ludDY0X3RvX2J5dGVzKHgpO1xuICByZXR1cm4gY2FtbF9pbnQ2NF9vZl9ieXRlcyhbeVs3XSwgeVs2XSwgeVs1XSwgeVs0XSwgeVszXSwgeVsyXSwgeVsxXSwgeVswXV0pO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8vLy8vLy8vLy8vLyBIYXNodGJsXG5cblxuLy9Qcm92aWRlczogY2FtbF9oYXNoX3VuaXZfcGFyYW0gbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9pc19tbF9zdHJpbmcsIGNhbWxfaXNfbWxfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfbWxfYnl0ZXNfY29udGVudFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF90b19ieXRlcywgY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0LCBjYW1sX2N1c3RvbV9vcHNcbi8vUmVxdWlyZXM6IGNhbWxfbWxfYnl0ZXNfbGVuZ3RoLCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG4vL1ZlcnNpb246IDwgNC4xMlxuZnVuY3Rpb24gY2FtbF9oYXNoX3VuaXZfcGFyYW0gKGNvdW50LCBsaW1pdCwgb2JqKSB7XG4gIHZhciBoYXNoX2FjY3UgPSAwO1xuICBmdW5jdGlvbiBoYXNoX2F1eCAob2JqKSB7XG4gICAgbGltaXQgLS07XG4gICAgaWYgKGNvdW50IDwgMCB8fCBsaW1pdCA8IDApIHJldHVybjtcbiAgICBpZiAob2JqIGluc3RhbmNlb2YgQXJyYXkgJiYgb2JqWzBdID09PSAob2JqWzBdfDApKSB7XG4gICAgICBzd2l0Y2ggKG9ialswXSkge1xuICAgICAgY2FzZSAyNDg6XG4gICAgICAgIC8vIE9iamVjdFxuICAgICAgICBjb3VudCAtLTtcbiAgICAgICAgaGFzaF9hY2N1ID0gKGhhc2hfYWNjdSAqIDY1NTk5ICsgb2JqWzJdKSB8IDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNTA6XG4gICAgICAgIC8vIEZvcndhcmRcbiAgICAgICAgbGltaXQrKzsgaGFzaF9hdXgob2JqKTsgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjb3VudCAtLTtcbiAgICAgICAgaGFzaF9hY2N1ID0gKGhhc2hfYWNjdSAqIDE5ICsgb2JqWzBdKSB8IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSBvYmoubGVuZ3RoIC0gMTsgaSA+IDA7IGktLSkgaGFzaF9hdXggKG9ialtpXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjYW1sX2lzX21sX2J5dGVzKG9iaikpIHtcbiAgICAgIGNvdW50IC0tO1xuICAgICAgdmFyIGNvbnRlbnQgPSBjYW1sX21sX2J5dGVzX2NvbnRlbnQob2JqKTtcbiAgICAgIGlmKHR5cGVvZiBjb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGZvciAodmFyIGIgPSBjb250ZW50LCBsID0gYi5sZW5ndGgsIGkgPSAwOyBpIDwgbDsgaSsrKVxuICAgICAgICAgIGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiAxOSArIGIuY2hhckNvZGVBdChpKSkgfCAwO1xuICAgICAgfSBlbHNlIHsgLyogQVJSQVkgKi9cbiAgICAgICAgZm9yICh2YXIgYSA9IGNvbnRlbnQsIGwgPSBhLmxlbmd0aCwgaSA9IDA7IGkgPCBsOyBpKyspXG4gICAgICAgICAgaGFzaF9hY2N1ID0gKGhhc2hfYWNjdSAqIDE5ICsgYVtpXSkgfCAwO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2FtbF9pc19tbF9zdHJpbmcob2JqKSkge1xuICAgICAgdmFyIGpzYnl0ZXMgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKG9iaik7XG4gICAgICBmb3IgKHZhciBiID0ganNieXRlcywgbCA9IGpzYnl0ZXMubGVuZ3RoLCBpID0gMDsgaSA8IGw7IGkrKylcbiAgICAgICAgaGFzaF9hY2N1ID0gKGhhc2hfYWNjdSAqIDE5ICsgYi5jaGFyQ29kZUF0KGkpKSB8IDA7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBmb3IgKHZhciBiID0gb2JqLCBsID0gb2JqLmxlbmd0aCwgaSA9IDA7IGkgPCBsOyBpKyspXG4gICAgICAgIGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiAxOSArIGIuY2hhckNvZGVBdChpKSkgfCAwO1xuICAgIH0gZWxzZSBpZiAob2JqID09PSAob2JqfDApKSB7XG4gICAgICAvLyBJbnRlZ2VyXG4gICAgICBjb3VudCAtLTtcbiAgICAgIGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiA2NTU5OSArIG9iaikgfCAwO1xuICAgIH0gZWxzZSBpZiAob2JqID09PSArb2JqKSB7XG4gICAgICAvLyBGbG9hdFxuICAgICAgY291bnQtLTtcbiAgICAgIHZhciBwID0gY2FtbF9pbnQ2NF90b19ieXRlcyAoY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0IChvYmopKTtcbiAgICAgIGZvciAodmFyIGkgPSA3OyBpID49IDA7IGktLSkgaGFzaF9hY2N1ID0gKGhhc2hfYWNjdSAqIDE5ICsgcFtpXSkgfCAwO1xuICAgIH0gZWxzZSBpZihvYmogJiYgb2JqLmNhbWxfY3VzdG9tKSB7XG4gICAgICBpZihjYW1sX2N1c3RvbV9vcHNbb2JqLmNhbWxfY3VzdG9tXSAmJiBjYW1sX2N1c3RvbV9vcHNbb2JqLmNhbWxfY3VzdG9tXS5oYXNoKSB7XG4gICAgICAgIHZhciBoID0gY2FtbF9jdXN0b21fb3BzW29iai5jYW1sX2N1c3RvbV0uaGFzaChvYmopIHwgMDtcbiAgICAgICAgaGFzaF9hY2N1ID0gKGhhc2hfYWNjdSAqIDY1NTk5ICsgaCkgfCAwO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBoYXNoX2F1eCAob2JqKTtcbiAgcmV0dXJuIGhhc2hfYWNjdSAmIDB4M0ZGRkZGRkY7XG59XG5cbi8vZnVuY3Rpb24gUk9UTDMyKHgsbikgeyByZXR1cm4gKCh4IDw8IG4pIHwgKHggPj4+ICgzMi1uKSkpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbWl4X2ludFxuLy9SZXF1aXJlczogY2FtbF9tdWxcbmZ1bmN0aW9uIGNhbWxfaGFzaF9taXhfaW50KGgsZCkge1xuICBkID0gY2FtbF9tdWwoZCwgMHhjYzllMmQ1MXwwKTtcbiAgZCA9ICgoZCA8PCAxNSkgfCAoZCA+Pj4gKDMyLTE1KSkpOyAvLyBST1RMMzIoZCwgMTUpO1xuICBkID0gY2FtbF9tdWwoZCwgMHgxYjg3MzU5Myk7XG4gIGggXj0gZDtcbiAgaCA9ICgoaCA8PCAxMykgfCAoaCA+Pj4gKDMyLTEzKSkpOyAgIC8vUk9UTDMyKGgsIDEzKTtcbiAgcmV0dXJuICgoKGggKyAoaCA8PCAyKSl8MCkgKyAoMHhlNjU0NmI2NHwwKSl8MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9oYXNoX21peF9maW5hbFxuLy9SZXF1aXJlczogY2FtbF9tdWxcbmZ1bmN0aW9uIGNhbWxfaGFzaF9taXhfZmluYWwoaCkge1xuICBoIF49IGggPj4+IDE2O1xuICBoID0gY2FtbF9tdWwgKGgsIDB4ODVlYmNhNmJ8MCk7XG4gIGggXj0gaCA+Pj4gMTM7XG4gIGggPSBjYW1sX211bCAoaCwgMHhjMmIyYWUzNXwwKTtcbiAgaCBePSBoID4+PiAxNjtcbiAgcmV0dXJuIGg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfZmxvYXRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCwgY2FtbF9oYXNoX21peF9pbnQ2NFxuZnVuY3Rpb24gY2FtbF9oYXNoX21peF9mbG9hdCAoaCwgdjApIHtcbiAgcmV0dXJuIGNhbWxfaGFzaF9taXhfaW50NjQoaCwgY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0ICh2MCkpO1xufVxuLy9Qcm92aWRlczogY2FtbF9oYXNoX21peF9pbnQ2NFxuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9pbnRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfbG8zMiwgY2FtbF9pbnQ2NF9oaTMyXG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X2ludDY0IChoLCB2KSB7XG4gIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCBjYW1sX2ludDY0X2xvMzIodikpO1xuICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgY2FtbF9pbnQ2NF9oaTMyKHYpKTtcbiAgcmV0dXJuIGg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfanNieXRlc1xuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9pbnRcbmZ1bmN0aW9uIGNhbWxfaGFzaF9taXhfanNieXRlcyhoLCBzKSB7XG4gIHZhciBsZW4gPSBzLmxlbmd0aCwgaSwgdztcbiAgZm9yIChpID0gMDsgaSArIDQgPD0gbGVuOyBpICs9IDQpIHtcbiAgICB3ID0gcy5jaGFyQ29kZUF0KGkpXG4gICAgICB8IChzLmNoYXJDb2RlQXQoaSsxKSA8PCA4KVxuICAgICAgfCAocy5jaGFyQ29kZUF0KGkrMikgPDwgMTYpXG4gICAgICB8IChzLmNoYXJDb2RlQXQoaSszKSA8PCAyNCk7XG4gICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHcpO1xuICB9XG4gIHcgPSAwO1xuICBzd2l0Y2ggKGxlbiAmIDMpIHtcbiAgY2FzZSAzOiB3ICA9IHMuY2hhckNvZGVBdChpKzIpIDw8IDE2O1xuICBjYXNlIDI6IHcgfD0gcy5jaGFyQ29kZUF0KGkrMSkgPDwgODtcbiAgY2FzZSAxOlxuICAgIHcgfD0gcy5jaGFyQ29kZUF0KGkpO1xuICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCB3KTtcbiAgZGVmYXVsdDpcbiAgfVxuICBoIF49IGxlbjtcbiAgcmV0dXJuIGg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfYnl0ZXNfYXJyXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2ludFxuZnVuY3Rpb24gY2FtbF9oYXNoX21peF9ieXRlc19hcnIoaCwgcykge1xuICB2YXIgbGVuID0gcy5sZW5ndGgsIGksIHc7XG4gIGZvciAoaSA9IDA7IGkgKyA0IDw9IGxlbjsgaSArPSA0KSB7XG4gICAgdyA9IHNbaV1cbiAgICAgIHwgKHNbaSsxXSA8PCA4KVxuICAgICAgfCAoc1tpKzJdIDw8IDE2KVxuICAgICAgfCAoc1tpKzNdIDw8IDI0KTtcbiAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgdyk7XG4gIH1cbiAgdyA9IDA7XG4gIHN3aXRjaCAobGVuICYgMykge1xuICBjYXNlIDM6IHcgID0gc1tpKzJdIDw8IDE2O1xuICBjYXNlIDI6IHcgfD0gc1tpKzFdIDw8IDg7XG4gIGNhc2UgMTogdyB8PSBzW2ldO1xuICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCB3KTtcbiAgZGVmYXVsdDpcbiAgfVxuICBoIF49IGxlbjtcbiAgcmV0dXJuIGg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfbWxfYnl0ZXNfY29udGVudFxuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9qc2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2J5dGVzX2FyclxuZnVuY3Rpb24gY2FtbF9oYXNoX21peF9ieXRlcyhoLCB2KSB7XG4gIHZhciBjb250ZW50ID0gY2FtbF9tbF9ieXRlc19jb250ZW50KHYpO1xuICBpZih0eXBlb2YgY29udGVudCA9PT0gXCJzdHJpbmdcIilcbiAgICByZXR1cm4gY2FtbF9oYXNoX21peF9qc2J5dGVzKGgsIGNvbnRlbnQpXG4gIGVsc2UgLyogQVJSQVkgKi9cbiAgICByZXR1cm4gY2FtbF9oYXNoX21peF9ieXRlc19hcnIoaCwgY29udGVudCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2pzYnl0ZXMsIGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfaGFzaF9taXhfc3RyaW5nKGgsIHYpIHtcbiAgcmV0dXJuIGNhbWxfaGFzaF9taXhfanNieXRlcyhoLCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKHYpKTtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2ggbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9pc19tbF9zdHJpbmcsIGNhbWxfaXNfbWxfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfaW50LCBjYW1sX2hhc2hfbWl4X2ZpbmFsXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2Zsb2F0LCBjYW1sX2hhc2hfbWl4X3N0cmluZywgY2FtbF9oYXNoX21peF9ieXRlcywgY2FtbF9jdXN0b21fb3BzXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2pzYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfaXNfY29udGludWF0aW9uX3RhZ1xuZnVuY3Rpb24gY2FtbF9oYXNoIChjb3VudCwgbGltaXQsIHNlZWQsIG9iaikge1xuICB2YXIgcXVldWUsIHJkLCB3ciwgc3osIG51bSwgaCwgdiwgaSwgbGVuO1xuICBzeiA9IGxpbWl0O1xuICBpZiAoc3ogPCAwIHx8IHN6ID4gMjU2KSBzeiA9IDI1NjtcbiAgbnVtID0gY291bnQ7XG4gIGggPSBzZWVkO1xuICBxdWV1ZSA9IFtvYmpdOyByZCA9IDA7IHdyID0gMTtcbiAgd2hpbGUgKHJkIDwgd3IgJiYgbnVtID4gMCkge1xuICAgIHYgPSBxdWV1ZVtyZCsrXTtcbiAgICBpZiAodiAmJiB2LmNhbWxfY3VzdG9tKXtcbiAgICAgIGlmKGNhbWxfY3VzdG9tX29wc1t2LmNhbWxfY3VzdG9tXSAmJiBjYW1sX2N1c3RvbV9vcHNbdi5jYW1sX2N1c3RvbV0uaGFzaCkge1xuICAgICAgICB2YXIgaGggPSBjYW1sX2N1c3RvbV9vcHNbdi5jYW1sX2N1c3RvbV0uaGFzaCh2KTtcbiAgICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50IChoLCBoaCk7XG4gICAgICAgIG51bSAtLTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodiBpbnN0YW5jZW9mIEFycmF5ICYmIHZbMF0gPT09ICh2WzBdfDApKSB7XG4gICAgICBzd2l0Y2ggKHZbMF0pIHtcbiAgICAgIGNhc2UgMjQ4OlxuICAgICAgICAvLyBPYmplY3RcbiAgICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHZbMl0pO1xuICAgICAgICBudW0tLTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI1MDpcbiAgICAgICAgLy8gRm9yd2FyZFxuICAgICAgICBxdWV1ZVstLXJkXSA9IHZbMV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYoY2FtbF9pc19jb250aW51YXRpb25fdGFnKHZbMF0pKSB7XG4gICAgICAgICAgLyogQWxsIGNvbnRpbnVhdGlvbnMgaGFzaCB0byB0aGUgc2FtZSB2YWx1ZSxcbiAgICAgICAgICAgICBzaW5jZSB3ZSBoYXZlIG5vIGlkZWEgaG93IHRvIGRpc3Rpbmd1aXNoIHRoZW0uICovXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRhZyA9ICgodi5sZW5ndGggLSAxKSA8PCAxMCkgfCB2WzBdO1xuICAgICAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgdGFnKTtcbiAgICAgICAgZm9yIChpID0gMSwgbGVuID0gdi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGlmICh3ciA+PSBzeikgYnJlYWs7XG4gICAgICAgICAgcXVldWVbd3IrK10gPSB2W2ldO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2FtbF9pc19tbF9ieXRlcyh2KSkge1xuICAgICAgaCA9IGNhbWxfaGFzaF9taXhfYnl0ZXMoaCx2KVxuICAgICAgbnVtLS07XG4gICAgfSBlbHNlIGlmIChjYW1sX2lzX21sX3N0cmluZyh2KSkge1xuICAgICAgaCA9IGNhbWxfaGFzaF9taXhfc3RyaW5nKGgsdilcbiAgICAgIG51bS0tO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHYgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2pzYnl0ZXMoaCx2KVxuICAgICAgbnVtLS07XG4gICAgfSBlbHNlIGlmICh2ID09PSAodnwwKSkge1xuICAgICAgLy8gSW50ZWdlclxuICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHYrdisxKTtcbiAgICAgIG51bS0tO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHYgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIC8vIEZsb2F0XG4gICAgICBoID0gY2FtbF9oYXNoX21peF9mbG9hdChoLHYpO1xuICAgICAgbnVtLS07XG4gICAgfVxuICB9XG4gIGggPSBjYW1sX2hhc2hfbWl4X2ZpbmFsKGgpO1xuICByZXR1cm4gaCAmIDB4M0ZGRkZGRkY7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2hhc2hcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfZmluYWwsIGNhbWxfaGFzaF9taXhfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19oYXNoKGgsIHYpe1xuICB2YXIgaCA9IGNhbWxfaGFzaF9taXhfc3RyaW5nKGgsdik7XG4gIHZhciBoID0gY2FtbF9oYXNoX21peF9maW5hbChoKTtcbiAgcmV0dXJuIGggJiAweDNGRkZGRkZGO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDE0IErDqXLDtG1lIFZvdWlsbG9uLCBIdWdvIEhldXphcmRcbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8vLy8vLy8vLy8vLyBJb1xuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19mZHNcbnZhciBjYW1sX3N5c19mZHMgPSBuZXcgQXJyYXkoMyk7XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2Nsb3NlXG4vL1JlcXVpcmVzOiBjYW1sX3N5c19mZHNcbmZ1bmN0aW9uIGNhbWxfc3lzX2Nsb3NlKGZkKSB7XG4gIHZhciBmaWxlID0gY2FtbF9zeXNfZmRzW2ZkXTtcbiAgaWYoZmlsZSkgZmlsZS5jbG9zZSgpO1xuICBkZWxldGUgY2FtbF9zeXNfZmRzW2ZkXTtcbiAgcmV0dXJuIDA7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfb3BlblxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXNfZXJyb3Jcbi8vUmVxdWlyZXM6IE1sRmFrZUZkX291dFxuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2Vcbi8vUmVxdWlyZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmdcbi8vUmVxdWlyZXM6IGZzX25vZGVfc3VwcG9ydGVkXG4vL1JlcXVpcmVzOiBjYW1sX3N5c19mZHNcbi8vUmVxdWlyZXM6IGNhbWxfc3lzX29wZW5fZm9yX25vZGVcbmZ1bmN0aW9uIGNhbWxfc3lzX29wZW5faW50ZXJuYWwoZmlsZSxpZHgpIHtcbiAgaWYoaWR4ID09IHVuZGVmaW5lZCl7XG4gICAgaWR4ID0gY2FtbF9zeXNfZmRzLmxlbmd0aDtcbiAgfVxuICBjYW1sX3N5c19mZHNbaWR4XSA9IGZpbGU7XG4gIHJldHVybiBpZHggfCAwO1xufVxuZnVuY3Rpb24gY2FtbF9zeXNfb3BlbiAobmFtZSwgZmxhZ3MsIF9wZXJtcykge1xuICB2YXIgZiA9IHt9O1xuICB3aGlsZShmbGFncyl7XG4gICAgc3dpdGNoKGZsYWdzWzFdKXtcbiAgICBjYXNlIDA6IGYucmRvbmx5ID0gMTticmVhaztcbiAgICBjYXNlIDE6IGYud3Jvbmx5ID0gMTticmVhaztcbiAgICBjYXNlIDI6IGYuYXBwZW5kID0gMTticmVhaztcbiAgICBjYXNlIDM6IGYuY3JlYXRlID0gMTticmVhaztcbiAgICBjYXNlIDQ6IGYudHJ1bmNhdGUgPSAxO2JyZWFrO1xuICAgIGNhc2UgNTogZi5leGNsID0gMTsgYnJlYWs7XG4gICAgY2FzZSA2OiBmLmJpbmFyeSA9IDE7YnJlYWs7XG4gICAgY2FzZSA3OiBmLnRleHQgPSAxO2JyZWFrO1xuICAgIGNhc2UgODogZi5ub25ibG9jayA9IDE7YnJlYWs7XG4gICAgfVxuICAgIGZsYWdzPWZsYWdzWzJdO1xuICB9XG4gIGlmKGYucmRvbmx5ICYmIGYud3Jvbmx5KVxuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKGNhbWxfanNieXRlc19vZl9zdHJpbmcobmFtZSkgKyBcIiA6IGZsYWdzIE9wZW5fcmRvbmx5IGFuZCBPcGVuX3dyb25seSBhcmUgbm90IGNvbXBhdGlibGVcIik7XG4gIGlmKGYudGV4dCAmJiBmLmJpbmFyeSlcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKG5hbWUpICsgXCIgOiBmbGFncyBPcGVuX3RleHQgYW5kIE9wZW5fYmluYXJ5IGFyZSBub3QgY29tcGF0aWJsZVwiKTtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgdmFyIGZpbGUgPSByb290LmRldmljZS5vcGVuKHJvb3QucmVzdCxmKTtcbiAgcmV0dXJuIGNhbWxfc3lzX29wZW5faW50ZXJuYWwgKGZpbGUsIHVuZGVmaW5lZCk7XG59XG4oZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBmaWxlKGZkLCBmbGFncykge1xuICAgIGlmKGZzX25vZGVfc3VwcG9ydGVkKCkpIHtcbiAgICAgIHJldHVybiBjYW1sX3N5c19vcGVuX2Zvcl9ub2RlKGZkLCBmbGFncyk7XG4gICAgfVxuICAgIGVsc2VcbiAgICAgIHJldHVybiBuZXcgTWxGYWtlRmRfb3V0KGZkLCBmbGFncylcbiAgfVxuICBjYW1sX3N5c19vcGVuX2ludGVybmFsKGZpbGUoMCx7cmRvbmx5OjEsYWx0bmFtZTpcIi9kZXYvc3RkaW5cIixpc0NoYXJhY3RlckRldmljZTp0cnVlfSksIDApO1xuICBjYW1sX3N5c19vcGVuX2ludGVybmFsKGZpbGUoMSx7YnVmZmVyZWQ6Mix3cm9ubHk6MSxpc0NoYXJhY3RlckRldmljZTp0cnVlfSksIDEpO1xuICBjYW1sX3N5c19vcGVuX2ludGVybmFsKGZpbGUoMix7YnVmZmVyZWQ6Mix3cm9ubHk6MSxpc0NoYXJhY3RlckRldmljZTp0cnVlfSksIDIpO1xufSkoKVxuXG5cbi8vIG9jYW1sIENoYW5uZWxzXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2V0X2NoYW5uZWxfbmFtZVxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVsX2dldFxuZnVuY3Rpb24gY2FtbF9tbF9zZXRfY2hhbm5lbF9uYW1lKGNoYW5pZCwgbmFtZSkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbF9nZXQoY2hhbmlkKTtcbiAgY2hhbi5uYW1lID0gbmFtZTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfY2hhbm5lbHNcbnZhciBjYW1sX21sX2NoYW5uZWxzID0gbmV3IEFycmF5KCk7XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfY2hhbm5lbF9yZWRpcmVjdFxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVsX2dldCwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9jaGFubmVsX3JlZGlyZWN0IChjYXB0dXJlZCwgaW50byl7XG4gIHZhciB0b19yZXN0b3JlID0gY2FtbF9tbF9jaGFubmVsX2dldChjYXB0dXJlZCk7XG4gIHZhciBuZXdfID0gY2FtbF9tbF9jaGFubmVsX2dldChpbnRvKTtcbiAgY2FtbF9tbF9jaGFubmVsc1tjYXB0dXJlZF0gPSBuZXdfOyAvLyBYWFhcbiAgcmV0dXJuIHRvX3Jlc3RvcmU7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfY2hhbm5lbF9yZXN0b3JlXG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX2NoYW5uZWxfcmVzdG9yZSAoY2FwdHVyZWQsIHRvX3Jlc3RvcmUpe1xuICBjYW1sX21sX2NoYW5uZWxzW2NhcHR1cmVkXSA9IHRvX3Jlc3RvcmU7IC8vIFhYWFxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9jaGFubmVsX2dldFxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9jaGFubmVsX2dldChpZCkge1xuICByZXR1cm4gY2FtbF9tbF9jaGFubmVsc1tpZF07IC8vIFhYWFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX291dF9jaGFubmVsc19saXN0XG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX291dF9jaGFubmVsc19saXN0ICgpIHtcbiAgdmFyIGwgPSAwO1xuICBmb3IodmFyIGMgPSAwOyBjIDwgY2FtbF9tbF9jaGFubmVscy5sZW5ndGg7IGMrKyl7XG4gICAgaWYoY2FtbF9tbF9jaGFubmVsc1tjXSAmJiBjYW1sX21sX2NoYW5uZWxzW2NdLm9wZW5lZCAmJiBjYW1sX21sX2NoYW5uZWxzW2NdLm91dClcbiAgICAgIGw9WzAsY2FtbF9tbF9jaGFubmVsc1tjXS5mZCxsXTtcbiAgfVxuICByZXR1cm4gbDtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9vdXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbHMsIGNhbWxfc3lzX2Zkc1xuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXNfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfc3lzX29wZW5cbmZ1bmN0aW9uIGNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX291dCAoZmQpIHtcbiAgdmFyIGZpbGUgPSBjYW1sX3N5c19mZHNbZmRdO1xuICBpZihmaWxlLmZsYWdzLnJkb25seSkgY2FtbF9yYWlzZV9zeXNfZXJyb3IoXCJmZCBcIisgZmQgKyBcIiBpcyByZWFkb25seVwiKTtcbiAgdmFyIGJ1ZmZlcmVkID0gKGZpbGUuZmxhZ3MuYnVmZmVyZWQgIT09IHVuZGVmaW5lZCkgPyBmaWxlLmZsYWdzLmJ1ZmZlcmVkIDogMTtcbiAgdmFyIGNoYW5uZWwgPSB7XG4gICAgZmlsZTpmaWxlLFxuICAgIG9mZnNldDpmaWxlLmZsYWdzLmFwcGVuZD9maWxlLmxlbmd0aCgpOjAsXG4gICAgZmQ6ZmQsXG4gICAgb3BlbmVkOnRydWUsXG4gICAgb3V0OnRydWUsXG4gICAgYnVmZmVyX2N1cnI6MCxcbiAgICBidWZmZXI6bmV3IFVpbnQ4QXJyYXkoNjU1MzYpLFxuICAgIGJ1ZmZlcmVkOmJ1ZmZlcmVkXG4gIH07XG4gIGNhbWxfbWxfY2hhbm5lbHNbY2hhbm5lbC5mZF09Y2hhbm5lbDtcbiAgcmV0dXJuIGNoYW5uZWwuZmQ7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX2luXG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxzLCBjYW1sX3N5c19mZHNcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfc3lzX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX3N5c19vcGVuXG5mdW5jdGlvbiBjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9pbiAoZmQpICB7XG4gIHZhciBmaWxlID0gY2FtbF9zeXNfZmRzW2ZkXTtcbiAgaWYoZmlsZS5mbGFncy53cm9ubHkpIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKFwiZmQgXCIrIGZkICsgXCIgaXMgd3JpdGVvbmx5XCIpO1xuICB2YXIgcmVmaWxsID0gbnVsbDtcbiAgdmFyIGNoYW5uZWwgPSB7XG4gICAgZmlsZTpmaWxlLFxuICAgIG9mZnNldDpmaWxlLmZsYWdzLmFwcGVuZD9maWxlLmxlbmd0aCgpOjAsXG4gICAgZmQ6ZmQsXG4gICAgb3BlbmVkOnRydWUsXG4gICAgb3V0OiBmYWxzZSxcbiAgICBidWZmZXJfY3VycjowLFxuICAgIGJ1ZmZlcl9tYXg6MCxcbiAgICBidWZmZXI6bmV3IFVpbnQ4QXJyYXkoNjU1MzYpLFxuICAgIHJlZmlsbDpyZWZpbGxcbiAgfTtcbiAgY2FtbF9tbF9jaGFubmVsc1tjaGFubmVsLmZkXT1jaGFubmVsO1xuICByZXR1cm4gY2hhbm5lbC5mZDtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9pbl93aXRoX2ZsYWdzXG4vL1JlcXVpcmVzOiBjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9pblxuLy9WZXJzaW9uOiA+PSA1LjFcbmZ1bmN0aW9uIGNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX2luX3dpdGhfZmxhZ3MoZmQsIGZsYWdzKXtcbiAgcmV0dXJuIGNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX2luKGZkKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3Jfb3V0X3dpdGhfZmxhZ3Ncbi8vUmVxdWlyZXM6IGNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX291dFxuLy9WZXJzaW9uOiA+PSA1LjFcbmZ1bmN0aW9uIGNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX291dF93aXRoX2ZsYWdzKGZkLCBmbGFncyl7XG4gIHJldHVybiBjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9vdXQoZmQpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NoYW5uZWxfZGVzY3JpcHRvclxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVsX2dldFxuLy9BbGlhczogd2luX2ZpbGVkZXNjcl9vZl9jaGFubmVsXG5mdW5jdGlvbiBjYW1sX2NoYW5uZWxfZGVzY3JpcHRvcihjaGFuaWQpe1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbF9nZXQoY2hhbmlkKTtcbiAgcmV0dXJuIGNoYW4uZmQ7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2V0X2JpbmFyeV9tb2RlXG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxfZ2V0XG5mdW5jdGlvbiBjYW1sX21sX3NldF9iaW5hcnlfbW9kZShjaGFuaWQsbW9kZSl7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsX2dldChjaGFuaWQpO1xuICBjaGFuLmZpbGUuZmxhZ3MudGV4dCA9ICFtb2RlXG4gIGNoYW4uZmlsZS5mbGFncy5iaW5hcnkgPSBtb2RlXG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2lzX2JpbmFyeV9tb2RlXG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxfZ2V0XG4vL1ZlcnNpb246ID49IDUuMlxuZnVuY3Rpb24gY2FtbF9tbF9pc19iaW5hcnlfbW9kZShjaGFuaWQpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxfZ2V0KGNoYW5pZCk7XG4gIHJldHVybiBjaGFuLmZpbGUuZmxhZ3MuYmluYXJ5XG59XG5cbi8vSW5wdXQgZnJvbSBpbl9jaGFubmVsXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfY2xvc2VfY2hhbm5lbFxuLy9SZXF1aXJlczogY2FtbF9tbF9mbHVzaCwgY2FtbF9tbF9jaGFubmVsX2dldFxuLy9SZXF1aXJlczogY2FtbF9zeXNfY2xvc2VcbmZ1bmN0aW9uIGNhbWxfbWxfY2xvc2VfY2hhbm5lbCAoY2hhbmlkKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsX2dldChjaGFuaWQpO1xuICBpZihjaGFuLm9wZW5lZCkge1xuICAgIGNoYW4ub3BlbmVkID0gZmFsc2U7XG4gICAgY2FtbF9zeXNfY2xvc2UoY2hhbi5mZCk7XG4gICAgY2hhbi5mZCA9IC0xO1xuICAgIGNoYW4uYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoMCk7XG4gICAgY2hhbi5idWZmZXJfY3VyciA9IDA7XG4gICAgY2hhbi5idWZmZXJfbWF4ID0gMDtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9jaGFubmVsX3NpemVcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbF9nZXRcbmZ1bmN0aW9uIGNhbWxfbWxfY2hhbm5lbF9zaXplKGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbF9nZXQoY2hhbmlkKTtcbiAgcmV0dXJuIGNoYW4uZmlsZS5sZW5ndGgoKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9jaGFubmVsX3NpemVfNjRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfZmxvYXQsY2FtbF9tbF9jaGFubmVsX2dldFxuZnVuY3Rpb24gY2FtbF9tbF9jaGFubmVsX3NpemVfNjQoY2hhbmlkKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsX2dldChjaGFuaWQpO1xuICByZXR1cm4gY2FtbF9pbnQ2NF9vZl9mbG9hdChjaGFuLmZpbGUubGVuZ3RoICgpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9zZXRfY2hhbm5lbF9vdXRwdXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbF9nZXRcbmZ1bmN0aW9uIGNhbWxfbWxfc2V0X2NoYW5uZWxfb3V0cHV0KGNoYW5pZCxmKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsX2dldChjaGFuaWQpO1xuICBjaGFuLm91dHB1dCA9IChmdW5jdGlvbiAocykge2Yocyl9KTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2V0X2NoYW5uZWxfcmVmaWxsXG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxfZ2V0XG5mdW5jdGlvbiBjYW1sX21sX3NldF9jaGFubmVsX3JlZmlsbChjaGFuaWQsZikge1xuICBjYW1sX21sX2NoYW5uZWxfZ2V0KGNoYW5pZCkucmVmaWxsID0gZjtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmVmaWxsXG4vL1JlcXVpcmVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGgsIGNhbWxfdWludDhfYXJyYXlfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3JlZmlsbCAoY2hhbikge1xuICBpZihjaGFuLnJlZmlsbCAhPSBudWxsKXtcbiAgICB2YXIgc3RyID0gY2hhbi5yZWZpbGwoKTtcbiAgICB2YXIgc3RyX2EgPSBjYW1sX3VpbnQ4X2FycmF5X29mX3N0cmluZyhzdHIpO1xuICAgIGlmIChzdHJfYS5sZW5ndGggPT0gMCkge1xuICAgICAgY2hhbi5yZWZpbGwgPSBudWxsXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaWYoY2hhbi5idWZmZXIubGVuZ3RoIDwgY2hhbi5idWZmZXJfbWF4ICsgc3RyX2EubGVuZ3RoKXtcbiAgICAgICAgdmFyIGIgPSBuZXcgVWludDhBcnJheShjaGFuLmJ1ZmZlcl9tYXggKyBzdHJfYS5sZW5ndGgpO1xuICAgICAgICBiLnNldChjaGFuLmJ1ZmZlcik7XG4gICAgICAgIGNoYW4uYnVmZmVyID0gYjtcbiAgICAgIH1cbiAgICAgIGNoYW4uYnVmZmVyLnNldChzdHJfYSxjaGFuLmJ1ZmZlcl9tYXgpO1xuICAgICAgY2hhbi5vZmZzZXQgKz0gc3RyX2EubGVuZ3RoO1xuICAgICAgY2hhbi5idWZmZXJfbWF4ICs9IHN0cl9hLmxlbmd0aDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIG5yZWFkID0gY2hhbi5maWxlLnJlYWQoY2hhbi5vZmZzZXQsIGNoYW4uYnVmZmVyLCBjaGFuLmJ1ZmZlcl9tYXgsIGNoYW4uYnVmZmVyLmxlbmd0aCAtIGNoYW4uYnVmZmVyX21heCk7XG4gICAgY2hhbi5vZmZzZXQgKz0gbnJlYWQ7XG4gICAgY2hhbi5idWZmZXJfbWF4ICs9IG5yZWFkO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfaW5wdXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfaW5wdXRfYmxvY2tcbi8vUmVxdWlyZXM6IGNhbWxfdWludDhfYXJyYXlfb2ZfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfbWxfaW5wdXQgKGNoYW5pZCwgYiwgaSwgbCkge1xuICB2YXIgYmEgPSBjYW1sX3VpbnQ4X2FycmF5X29mX2J5dGVzKGIpO1xuICByZXR1cm4gY2FtbF9tbF9pbnB1dF9ibG9jayhjaGFuaWQsIGJhLCBpLCBsKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2lucHV0X2JpZ2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX21sX2lucHV0X2Jsb2NrXG4vL1JlcXVpcmVzOiBjYW1sX2JhX3RvX3R5cGVkX2FycmF5XG5mdW5jdGlvbiBjYW1sX21sX2lucHV0X2JpZ2FycmF5IChjaGFuaWQsIGIsIGksIGwpIHtcbiAgdmFyIGJhID0gY2FtbF9iYV90b190eXBlZF9hcnJheShiKTtcbiAgcmV0dXJuIGNhbWxfbWxfaW5wdXRfYmxvY2soY2hhbmlkLCBiYSwgaSwgbClcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9pbnB1dF9ibG9ja1xuLy9SZXF1aXJlczogY2FtbF9yZWZpbGwsIGNhbWxfbWxfY2hhbm5lbF9nZXRcbmZ1bmN0aW9uIGNhbWxfbWxfaW5wdXRfYmxvY2sgKGNoYW5pZCwgYmEsIGksIGwpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxfZ2V0KGNoYW5pZCk7XG4gIHZhciBuID0gbDtcbiAgdmFyIGF2YWlsID0gY2hhbi5idWZmZXJfbWF4IC0gY2hhbi5idWZmZXJfY3VycjtcbiAgaWYobCA8PSBhdmFpbCkge1xuICAgIGJhLnNldChjaGFuLmJ1ZmZlci5zdWJhcnJheShjaGFuLmJ1ZmZlcl9jdXJyLGNoYW4uYnVmZmVyX2N1cnIgKyBsKSwgaSk7XG4gICAgY2hhbi5idWZmZXJfY3VyciArPSBsO1xuICB9XG4gIGVsc2UgaWYoYXZhaWwgPiAwKSB7XG4gICAgYmEuc2V0KGNoYW4uYnVmZmVyLnN1YmFycmF5KGNoYW4uYnVmZmVyX2N1cnIsY2hhbi5idWZmZXJfY3VyciArIGF2YWlsKSwgaSk7XG4gICAgY2hhbi5idWZmZXJfY3VyciArPSBhdmFpbDtcbiAgICBuID0gYXZhaWw7XG4gIH0gZWxzZSB7XG4gICAgY2hhbi5idWZmZXJfY3VyciA9IDA7XG4gICAgY2hhbi5idWZmZXJfbWF4ID0gMDtcbiAgICBjYW1sX3JlZmlsbChjaGFuKTtcbiAgICB2YXIgYXZhaWwgPSBjaGFuLmJ1ZmZlcl9tYXggLSBjaGFuLmJ1ZmZlcl9jdXJyO1xuICAgIGlmKG4gPiBhdmFpbCkgbiA9IGF2YWlsO1xuICAgIGJhLnNldChjaGFuLmJ1ZmZlci5zdWJhcnJheShjaGFuLmJ1ZmZlcl9jdXJyLGNoYW4uYnVmZmVyX2N1cnIgKyBuKSwgaSk7XG4gICAgY2hhbi5idWZmZXJfY3VyciArPSBuO1xuICB9XG4gIHJldHVybiBuIHwgMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnB1dF92YWx1ZVxuLy9SZXF1aXJlczogY2FtbF9tYXJzaGFsX2RhdGFfc2l6ZSwgY2FtbF9pbnB1dF92YWx1ZV9mcm9tX2J5dGVzLCBjYW1sX2NyZWF0ZV9ieXRlcywgY2FtbF9tbF9jaGFubmVsX2dldCwgY2FtbF9ieXRlc19vZl9hcnJheVxuLy9SZXF1aXJlczogY2FtbF9yZWZpbGwsIGNhbWxfZmFpbHdpdGgsIGNhbWxfcmFpc2VfZW5kX29mX2ZpbGVcbi8vUmVxdWlyZXM6IGNhbWxfbWFyc2hhbF9oZWFkZXJfc2l6ZVxuZnVuY3Rpb24gY2FtbF9pbnB1dF92YWx1ZSAoY2hhbmlkKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsX2dldChjaGFuaWQpO1xuICB2YXIgaGVhZGVyID0gbmV3IFVpbnQ4QXJyYXkoY2FtbF9tYXJzaGFsX2hlYWRlcl9zaXplKTtcbiAgZnVuY3Rpb24gYmxvY2soYnVmZmVyLCBvZmZzZXQsIG4pIHtcbiAgICB2YXIgciA9IDA7XG4gICAgd2hpbGUociA8IG4pe1xuICAgICAgaWYoY2hhbi5idWZmZXJfY3VyciA+PSBjaGFuLmJ1ZmZlcl9tYXgpe1xuICAgICAgICBjaGFuLmJ1ZmZlcl9jdXJyID0gMDtcbiAgICAgICAgY2hhbi5idWZmZXJfbWF4ID0gMDtcbiAgICAgICAgY2FtbF9yZWZpbGwoY2hhbik7XG4gICAgICB9XG4gICAgICBpZiAoY2hhbi5idWZmZXJfY3VyciA+PSBjaGFuLmJ1ZmZlcl9tYXgpXG4gICAgICAgIGJyZWFrO1xuICAgICAgYnVmZmVyW29mZnNldCtyXSA9IGNoYW4uYnVmZmVyW2NoYW4uYnVmZmVyX2N1cnJdO1xuICAgICAgY2hhbi5idWZmZXJfY3VycisrO1xuICAgICAgcisrO1xuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfVxuICB2YXIgciA9IGJsb2NrKGhlYWRlciwgMCwgY2FtbF9tYXJzaGFsX2hlYWRlcl9zaXplKTtcbiAgaWYociA9PSAwKVxuICAgIGNhbWxfcmFpc2VfZW5kX29mX2ZpbGUoKTtcbiAgZWxzZSBpZiAociA8IGNhbWxfbWFyc2hhbF9oZWFkZXJfc2l6ZSlcbiAgICBjYW1sX2ZhaWx3aXRoKFwiaW5wdXRfdmFsdWU6IHRydW5jYXRlZCBvYmplY3RcIik7XG4gIHZhciBsZW4gPSBjYW1sX21hcnNoYWxfZGF0YV9zaXplIChjYW1sX2J5dGVzX29mX2FycmF5KGhlYWRlciksIDApO1xuICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkobGVuICsgY2FtbF9tYXJzaGFsX2hlYWRlcl9zaXplKTtcbiAgYnVmLnNldChoZWFkZXIsMCk7XG4gIHZhciByID0gYmxvY2soYnVmLCBjYW1sX21hcnNoYWxfaGVhZGVyX3NpemUsIGxlbilcbiAgaWYociA8IGxlbilcbiAgICBjYW1sX2ZhaWx3aXRoKFwiaW5wdXRfdmFsdWU6IHRydW5jYXRlZCBvYmplY3QgXCIgKyByICsgXCIgIFwiICsgbGVuKTtcbiAgdmFyIG9mZnNldCA9IFswXTtcbiAgdmFyIHJlcyA9IGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9ieXRlcyhjYW1sX2J5dGVzX29mX2FycmF5KGJ1ZiksIG9mZnNldCk7XG4gIGNoYW4ub2Zmc2V0ID0gY2hhbi5vZmZzZXQgKyBvZmZzZXRbMF07XG4gIHJldHVybiByZXM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW5wdXRfdmFsdWVfdG9fb3V0c2lkZV9oZWFwXG4vL1JlcXVpcmVzOiBjYW1sX2lucHV0X3ZhbHVlXG5mdW5jdGlvbiBjYW1sX2lucHV0X3ZhbHVlX3RvX291dHNpZGVfaGVhcChjKSB7XG4gIHJldHVybiBjYW1sX2lucHV0X3ZhbHVlKGMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2lucHV0X2NoYXJcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2VfZW5kX29mX2ZpbGUsIGNhbWxfYXJyYXlfYm91bmRfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbF9nZXQsIGNhbWxfcmVmaWxsXG5mdW5jdGlvbiBjYW1sX21sX2lucHV0X2NoYXIgKGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbF9nZXQoY2hhbmlkKTtcbiAgaWYoY2hhbi5idWZmZXJfY3VyciA+PSBjaGFuLmJ1ZmZlcl9tYXgpe1xuICAgIGNoYW4uYnVmZmVyX2N1cnIgPSAwO1xuICAgIGNoYW4uYnVmZmVyX21heCA9IDA7XG4gICAgY2FtbF9yZWZpbGwoY2hhbik7XG4gIH1cbiAgaWYgKGNoYW4uYnVmZmVyX2N1cnIgPj0gY2hhbi5idWZmZXJfbWF4KVxuICAgIGNhbWxfcmFpc2VfZW5kX29mX2ZpbGUoKTtcbiAgdmFyIHJlcyA9IGNoYW4uYnVmZmVyW2NoYW4uYnVmZmVyX2N1cnJdO1xuICBjaGFuLmJ1ZmZlcl9jdXJyKys7XG4gIHJldHVybiByZXM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfaW5wdXRfaW50XG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX2VuZF9vZl9maWxlXG4vL1JlcXVpcmVzOiBjYW1sX21sX2lucHV0X2NoYXIsIGNhbWxfbWxfY2hhbm5lbF9nZXRcbmZ1bmN0aW9uIGNhbWxfbWxfaW5wdXRfaW50IChjaGFuaWQpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxfZ2V0KGNoYW5pZCk7XG4gIHZhciByZXMgPSAwO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgNDsgaSsrKXtcbiAgICByZXMgPSAocmVzIDw8IDgpICsgY2FtbF9tbF9pbnB1dF9jaGFyKGNoYW5pZCkgfCAwO1xuICB9XG4gIHJldHVybiByZXMgfCAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3NlZWtfaW5cbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfc3lzX2Vycm9yLCBjYW1sX21sX2NoYW5uZWxfZ2V0XG5mdW5jdGlvbiBjYW1sX3NlZWtfaW4oY2hhbmlkLCBwb3MpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxfZ2V0KGNoYW5pZCk7XG4gIGlmIChjaGFuLnJlZmlsbCAhPSBudWxsKSBjYW1sX3JhaXNlX3N5c19lcnJvcihcIklsbGVnYWwgc2Vla1wiKTtcbiAgaWYocG9zID49IGNoYW4ub2Zmc2V0IC0gY2hhbi5idWZmZXJfbWF4XG4gICAgICYmIHBvcyA8PSBjaGFuLm9mZnNldFxuICAgICAmJiBjaGFuLmZpbGUuZmxhZ3MuYmluYXJ5KSB7XG4gICAgY2hhbi5idWZmZXJfY3VyciA9IGNoYW4uYnVmZmVyX21heCAtIChjaGFuLm9mZnNldCAtIHBvcyk7XG4gIH0gZWxzZSB7XG4gICAgY2hhbi5vZmZzZXQgPSBwb3M7XG4gICAgY2hhbi5idWZmZXJfY3VyciA9IDA7XG4gICAgY2hhbi5idWZmZXJfbWF4ID0gMDtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9zZWVrX2luXG4vL1JlcXVpcmVzOiBjYW1sX3NlZWtfaW5cbmZ1bmN0aW9uIGNhbWxfbWxfc2Vla19pbihjaGFuaWQscG9zKXtcbiAgcmV0dXJuIGNhbWxfc2Vla19pbihjaGFuaWQscG9zKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9zZWVrX2luXzY0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3RvX2Zsb2F0LCBjYW1sX3NlZWtfaW5cbmZ1bmN0aW9uIGNhbWxfbWxfc2Vla19pbl82NChjaGFuaWQscG9zKXtcbiAgdmFyIHBvcyA9IGNhbWxfaW50NjRfdG9fZmxvYXQocG9zKTtcbiAgcmV0dXJuIGNhbWxfc2Vla19pbihjaGFuaWQsIHBvcyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcG9zX2luXG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxfZ2V0XG5mdW5jdGlvbiBjYW1sX3Bvc19pbihjaGFuaWQpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxfZ2V0KGNoYW5pZCk7XG4gIHJldHVybiBjaGFuLm9mZnNldCAtIChjaGFuLmJ1ZmZlcl9tYXggLSBjaGFuLmJ1ZmZlcl9jdXJyKSB8IDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfcG9zX2luXG4vL1JlcXVpcmVzOiBjYW1sX3Bvc19pblxuZnVuY3Rpb24gY2FtbF9tbF9wb3NfaW4oY2hhbmlkKSB7XG4gIHJldHVybiBjYW1sX3Bvc19pbihjaGFuaWQpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3Bvc19pbl82NFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZl9mbG9hdCwgY2FtbF9wb3NfaW5cbmZ1bmN0aW9uIGNhbWxfbWxfcG9zX2luXzY0KGNoYW5pZCkge1xuICByZXR1cm4gY2FtbF9pbnQ2NF9vZl9mbG9hdChjYW1sX3Bvc19pbihjaGFuaWQpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9pbnB1dF9zY2FuX2xpbmVcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbF9nZXQsIGNhbWxfcmVmaWxsXG5mdW5jdGlvbiBjYW1sX21sX2lucHV0X3NjYW5fbGluZShjaGFuaWQpe1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbF9nZXQoY2hhbmlkKTtcbiAgdmFyIHAgPSBjaGFuLmJ1ZmZlcl9jdXJyO1xuICBkbyB7XG4gICAgaWYocCA+PSBjaGFuLmJ1ZmZlcl9tYXgpIHtcbiAgICAgIGlmKGNoYW4uYnVmZmVyX2N1cnIgPiAwKSB7XG4gICAgICAgIGNoYW4uYnVmZmVyLnNldChjaGFuLmJ1ZmZlci5zdWJhcnJheShjaGFuLmJ1ZmZlcl9jdXJyKSwwKTtcbiAgICAgICAgcCAtPSBjaGFuLmJ1ZmZlcl9jdXJyO1xuICAgICAgICBjaGFuLmJ1ZmZlcl9tYXggLT0gY2hhbi5idWZmZXJfY3VycjtcbiAgICAgICAgY2hhbi5idWZmZXJfY3VyciA9IDA7XG4gICAgICB9XG4gICAgICBpZihjaGFuLmJ1ZmZlcl9tYXggPj0gY2hhbi5idWZmZXIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAtKGNoYW4uYnVmZmVyX21heCkgfCAwO1xuICAgICAgfVxuICAgICAgdmFyIHByZXZfbWF4ID0gY2hhbi5idWZmZXJfbWF4O1xuICAgICAgY2FtbF9yZWZpbGwgKGNoYW4pO1xuICAgICAgaWYocHJldl9tYXggPT0gY2hhbi5idWZmZXJfbWF4KSB7XG4gICAgICAgIHJldHVybiAtKGNoYW4uYnVmZmVyX21heCkgfCAwO1xuICAgICAgfVxuICAgIH1cbiAgfSB3aGlsZSAoY2hhbi5idWZmZXJbcCsrXSAhPSAxMCk7XG4gIHJldHVybiAocCAtIGNoYW4uYnVmZmVyX2N1cnIpIHwgMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9mbHVzaFxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXNfZXJyb3IsIGNhbWxfbWxfY2hhbm5lbF9nZXRcbi8vUmVxdWlyZXM6IGNhbWxfc3ViYXJyYXlfdG9fanNieXRlc1xuZnVuY3Rpb24gY2FtbF9tbF9mbHVzaCAoY2hhbmlkKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsX2dldChjaGFuaWQpO1xuICBpZighIGNoYW4ub3BlbmVkKSBjYW1sX3JhaXNlX3N5c19lcnJvcihcIkNhbm5vdCBmbHVzaCBhIGNsb3NlZCBjaGFubmVsXCIpO1xuICBpZighY2hhbi5idWZmZXIgfHwgY2hhbi5idWZmZXJfY3VyciA9PSAwKSByZXR1cm4gMDtcbiAgaWYoY2hhbi5vdXRwdXQpIHtcbiAgICBjaGFuLm91dHB1dChjYW1sX3N1YmFycmF5X3RvX2pzYnl0ZXMoY2hhbi5idWZmZXIsIDAsIGNoYW4uYnVmZmVyX2N1cnIpKTtcbiAgfSBlbHNlIHtcbiAgICBjaGFuLmZpbGUud3JpdGUoY2hhbi5vZmZzZXQsIGNoYW4uYnVmZmVyLCAwLCBjaGFuLmJ1ZmZlcl9jdXJyKTtcbiAgfVxuICBjaGFuLm9mZnNldCArPSBjaGFuLmJ1ZmZlcl9jdXJyO1xuICBjaGFuLmJ1ZmZlcl9jdXJyID0gMDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vb3V0cHV0IHRvIG91dF9jaGFubmVsXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfb3V0cHV0X3RhXG4vL1JlcXVpcmVzOiBjYW1sX21sX2ZsdXNoLGNhbWxfbWxfYnl0ZXNfbGVuZ3RoXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3N5c19lcnJvciwgY2FtbF9tbF9jaGFubmVsX2dldFxuZnVuY3Rpb24gY2FtbF9tbF9vdXRwdXRfdGEoY2hhbmlkLGJ1ZmZlcixvZmZzZXQsbGVuKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsX2dldChjaGFuaWQpO1xuICBpZighIGNoYW4ub3BlbmVkKSBjYW1sX3JhaXNlX3N5c19lcnJvcihcIkNhbm5vdCBvdXRwdXQgdG8gYSBjbG9zZWQgY2hhbm5lbFwiKTtcbiAgYnVmZmVyID0gYnVmZmVyLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgaWYoY2hhbi5idWZmZXJfY3VyciArIGJ1ZmZlci5sZW5ndGggPiBjaGFuLmJ1ZmZlci5sZW5ndGgpIHtcbiAgICB2YXIgYiA9IG5ldyBVaW50OEFycmF5KGNoYW4uYnVmZmVyX2N1cnIgKyBidWZmZXIubGVuZ3RoKTtcbiAgICBiLnNldChjaGFuLmJ1ZmZlcik7XG4gICAgY2hhbi5idWZmZXIgPSBiXG4gIH1cbiAgc3dpdGNoKGNoYW4uYnVmZmVyZWQpe1xuICBjYXNlIDA6IC8vIFVuYnVmZmVyZWRcbiAgICBjaGFuLmJ1ZmZlci5zZXQoYnVmZmVyLCBjaGFuLmJ1ZmZlcl9jdXJyKTtcbiAgICBjaGFuLmJ1ZmZlcl9jdXJyICs9IGJ1ZmZlci5sZW5ndGg7XG4gICAgY2FtbF9tbF9mbHVzaCAoY2hhbmlkKTtcbiAgICBicmVha1xuICBjYXNlIDE6IC8vIEJ1ZmZlcmVkICh0aGUgZGVmYXVsdClcbiAgICBjaGFuLmJ1ZmZlci5zZXQoYnVmZmVyLCBjaGFuLmJ1ZmZlcl9jdXJyKTtcbiAgICBjaGFuLmJ1ZmZlcl9jdXJyICs9IGJ1ZmZlci5sZW5ndGg7XG4gICAgaWYoY2hhbi5idWZmZXJfY3VyciA+PSBjaGFuLmJ1ZmZlci5sZW5ndGgpXG4gICAgICBjYW1sX21sX2ZsdXNoIChjaGFuaWQpO1xuICAgIGJyZWFrO1xuICBjYXNlIDI6IC8vIEJ1ZmZlcmVkIChvbmx5IGZvciBzdGRvdXQgYW5kIHN0ZGVycilcbiAgICB2YXIgaWQgPSBidWZmZXIubGFzdEluZGV4T2YoMTApXG4gICAgaWYoaWQgPCAwKSB7XG4gICAgICBjaGFuLmJ1ZmZlci5zZXQoYnVmZmVyLCBjaGFuLmJ1ZmZlcl9jdXJyKTtcbiAgICAgIGNoYW4uYnVmZmVyX2N1cnIgKz0gYnVmZmVyLmxlbmd0aDtcbiAgICAgIGlmKGNoYW4uYnVmZmVyX2N1cnIgPj0gY2hhbi5idWZmZXIubGVuZ3RoKVxuICAgICAgICBjYW1sX21sX2ZsdXNoIChjaGFuaWQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNoYW4uYnVmZmVyLnNldChidWZmZXIuc3ViYXJyYXkoMCwgaWQgKyAxKSwgY2hhbi5idWZmZXJfY3Vycik7XG4gICAgICBjaGFuLmJ1ZmZlcl9jdXJyICs9IGlkICsgMTtcbiAgICAgIGNhbWxfbWxfZmx1c2ggKGNoYW5pZCk7XG4gICAgICBjaGFuLmJ1ZmZlci5zZXQoYnVmZmVyLnN1YmFycmF5KGlkICsgMSksIGNoYW4uYnVmZmVyX2N1cnIpO1xuICAgICAgY2hhbi5idWZmZXJfY3VyciArPSBidWZmZXIubGVuZ3RoIC0gaWQgLSAxO1xuICAgIH1cbiAgICBicmVhaztcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9vdXRwdXRfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfdWludDhfYXJyYXlfb2ZfYnl0ZXMsIGNhbWxfbWxfb3V0cHV0X3RhXG5mdW5jdGlvbiBjYW1sX21sX291dHB1dF9ieXRlcyhjaGFuaWQsYnVmZmVyLG9mZnNldCxsZW4pIHtcbiAgdmFyIGJ1ZmZlciA9IGNhbWxfdWludDhfYXJyYXlfb2ZfYnl0ZXMoYnVmZmVyKTtcbiAgcmV0dXJuIGNhbWxfbWxfb3V0cHV0X3RhKGNoYW5pZCxidWZmZXIsb2Zmc2V0LGxlbik7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9tbF9vdXRwdXRfYmlnYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfYmFfdG9fdHlwZWRfYXJyYXksIGNhbWxfbWxfb3V0cHV0X3RhXG5mdW5jdGlvbiBjYW1sX21sX291dHB1dF9iaWdhcnJheShjaGFuaWQsYnVmZmVyLG9mZnNldCxsZW4pIHtcbiAgdmFyIGJ1ZmZlciA9IGNhbWxfYmFfdG9fdHlwZWRfYXJyYXkoYnVmZmVyKTtcbiAgcmV0dXJuIGNhbWxfbWxfb3V0cHV0X3RhKGNoYW5pZCxidWZmZXIsb2Zmc2V0LGxlbik7XG59XG5cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX291dHB1dFxuLy9SZXF1aXJlczogY2FtbF9tbF9vdXRwdXRfYnl0ZXMsIGNhbWxfYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX21sX291dHB1dChjaGFuaWQsYnVmZmVyLG9mZnNldCxsZW4pe1xuICByZXR1cm4gY2FtbF9tbF9vdXRwdXRfYnl0ZXMoY2hhbmlkLGNhbWxfYnl0ZXNfb2Zfc3RyaW5nKGJ1ZmZlciksb2Zmc2V0LGxlbik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfb3V0cHV0X2NoYXJcbi8vUmVxdWlyZXM6IGNhbWxfbWxfb3V0cHV0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX21sX291dHB1dF9jaGFyIChjaGFuaWQsYykge1xuICB2YXIgcyA9IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoU3RyaW5nLmZyb21DaGFyQ29kZShjKSk7XG4gIGNhbWxfbWxfb3V0cHV0KGNoYW5pZCxzLDAsMSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX291dHB1dF92YWx1ZVxuLy9SZXF1aXJlczogY2FtbF9vdXRwdXRfdmFsdWVfdG9fc3RyaW5nLCBjYW1sX21sX291dHB1dCxjYW1sX21sX3N0cmluZ19sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfb3V0cHV0X3ZhbHVlIChjaGFuaWQsdixmbGFncykge1xuICB2YXIgcyA9IGNhbWxfb3V0cHV0X3ZhbHVlX3RvX3N0cmluZyh2LCBmbGFncyk7XG4gIGNhbWxfbWxfb3V0cHV0KGNoYW5pZCxzLDAsY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpKTtcbiAgcmV0dXJuIDA7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9zZWVrX291dFxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVsX2dldCwgY2FtbF9tbF9mbHVzaFxuZnVuY3Rpb24gY2FtbF9zZWVrX291dChjaGFuaWQsIHBvcyl7XG4gIGNhbWxfbWxfZmx1c2goY2hhbmlkKTtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxfZ2V0KGNoYW5pZCk7XG4gIGNoYW4ub2Zmc2V0ID0gcG9zO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9zZWVrX291dFxuLy9SZXF1aXJlczogY2FtbF9zZWVrX291dFxuZnVuY3Rpb24gY2FtbF9tbF9zZWVrX291dChjaGFuaWQscG9zKXtcbiAgcmV0dXJuIGNhbWxfc2Vla19vdXQoY2hhbmlkLCBwb3MpO1xufVxuLy9Qcm92aWRlczogY2FtbF9tbF9zZWVrX291dF82NFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF90b19mbG9hdCwgY2FtbF9zZWVrX291dFxuZnVuY3Rpb24gY2FtbF9tbF9zZWVrX291dF82NChjaGFuaWQscG9zKXtcbiAgdmFyIHBvcyA9IGNhbWxfaW50NjRfdG9fZmxvYXQocG9zKTtcbiAgcmV0dXJuIGNhbWxfc2Vla19vdXQoY2hhbmlkLCBwb3MpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3Bvc19vdXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbF9nZXQsIGNhbWxfbWxfZmx1c2hcbmZ1bmN0aW9uIGNhbWxfcG9zX291dChjaGFuaWQpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxfZ2V0KGNoYW5pZCk7XG4gIHJldHVybiBjaGFuLm9mZnNldCArIGNoYW4uYnVmZmVyX2N1cnJcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9wb3Nfb3V0XG4vL1JlcXVpcmVzOiBjYW1sX3Bvc19vdXRcbmZ1bmN0aW9uIGNhbWxfbWxfcG9zX291dChjaGFuaWQpIHtcbiAgcmV0dXJuIGNhbWxfcG9zX291dChjaGFuaWQpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3Bvc19vdXRfNjRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfZmxvYXQsIGNhbWxfcG9zX291dFxuZnVuY3Rpb24gY2FtbF9tbF9wb3Nfb3V0XzY0KGNoYW5pZCkge1xuICByZXR1cm4gY2FtbF9pbnQ2NF9vZl9mbG9hdCAoY2FtbF9wb3Nfb3V0KGNoYW5pZCkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX291dHB1dF9pbnRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfb3V0cHV0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9hcnJheVxuZnVuY3Rpb24gY2FtbF9tbF9vdXRwdXRfaW50IChjaGFuaWQsaSkge1xuICB2YXIgYXJyID0gWyhpPj4yNCkgJiAweEZGLChpPj4xNikgJiAweEZGLChpPj44KSAmIDB4RkYsaSAmIDB4RkYgXTtcbiAgdmFyIHMgPSBjYW1sX3N0cmluZ19vZl9hcnJheShhcnIpO1xuICBjYW1sX21sX291dHB1dChjaGFuaWQscywwLDQpO1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2lzX2J1ZmZlcmVkXG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxfZ2V0XG5mdW5jdGlvbiBjYW1sX21sX2lzX2J1ZmZlcmVkKGNoYW5pZCkge1xuICByZXR1cm4gY2FtbF9tbF9jaGFubmVsX2dldChjaGFuaWQpLmJ1ZmZlcmVkID8gMSA6IDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9zZXRfYnVmZmVyZWRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbF9nZXQsIGNhbWxfbWxfZmx1c2hcbmZ1bmN0aW9uIGNhbWxfbWxfc2V0X2J1ZmZlcmVkKGNoYW5pZCx2KSB7XG4gIGNhbWxfbWxfY2hhbm5lbF9nZXQoY2hhbmlkKS5idWZmZXJlZCA9IHY7XG4gIGlmKCF2KSBjYW1sX21sX2ZsdXNoKGNoYW5pZCk7XG4gIHJldHVybiAwXG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvbXBhcmVfdmFsX3RhZ1xuLy9SZXF1aXJlczogY2FtbF9pc19tbF9zdHJpbmcsIGNhbWxfaXNfbWxfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfY29tcGFyZV92YWxfdGFnKGEpe1xuICBpZiAodHlwZW9mIGEgPT09IFwibnVtYmVyXCIpIHJldHVybiAxMDAwOyAvLyBpbnRfdGFnICh3ZSB1c2UgaXQgZm9yIGFsbCBudW1iZXJzKVxuICBlbHNlIGlmIChjYW1sX2lzX21sX2J5dGVzKGEpKSByZXR1cm4gMjUyOyAvLyBzdHJpbmdfdGFnXG4gIGVsc2UgaWYgKGNhbWxfaXNfbWxfc3RyaW5nKGEpKSByZXR1cm4gMTI1MjsgLy8gb2NhbWwgc3RyaW5nIChpZiBkaWZmZXJlbnQgZnJvbSBieXRlcylcbiAgZWxzZSBpZiAoYSBpbnN0YW5jZW9mIEFycmF5ICYmIGFbMF0gPT09IChhWzBdPj4+MCkgJiYgYVswXSA8PSAyNTUpIHtcbiAgICAvLyBMb29rIGxpa2UgYW4gb2NhbWwgYmxvY2tcbiAgICB2YXIgdGFnID0gYVswXSB8IDA7XG4gICAgLy8gaWdub3JlIGRvdWJsZV9hcnJheV90YWcgYmVjYXVzZSB3ZSBjYW5ub3QgYWNjdXJhdGVseSBzZXRcbiAgICAvLyB0aGlzIHRhZyB3aGVuIHdlIGNyZWF0ZSBhbiBhcnJheSBvZiBmbG9hdC5cbiAgICByZXR1cm4gKHRhZyA9PSAyNTQpPzA6dGFnXG4gIH1cbiAgZWxzZSBpZiAoYSBpbnN0YW5jZW9mIFN0cmluZykgcmV0dXJuIDEyNTIwOyAvLyBqYXZhc2NyaXB0IHN0cmluZywgbGlrZSBzdHJpbmdfdGFnICgyNTIpXG4gIGVsc2UgaWYgKHR5cGVvZiBhID09IFwic3RyaW5nXCIpIHJldHVybiAxMjUyMDsgLy8gamF2YXNjcmlwdCBzdHJpbmcsIGxpa2Ugc3RyaW5nX3RhZyAoMjUyKVxuICBlbHNlIGlmIChhIGluc3RhbmNlb2YgTnVtYmVyKSByZXR1cm4gMTAwMDsgLy8gaW50X3RhZyAod2UgdXNlIGl0IGZvciBhbGwgbnVtYmVycylcbiAgZWxzZSBpZiAoYSAmJiBhLmNhbWxfY3VzdG9tKSByZXR1cm4gMTI1NTsgLy8gbGlrZSBjdXN0b21fdGFnICgyNTUpXG4gIGVsc2UgaWYgKGEgJiYgYS5jb21wYXJlKSByZXR1cm4gMTI1NjsgLy8gbGlrZSBjdXN0b21fdGFnICgyNTUpXG4gIGVsc2UgaWYgKHR5cGVvZiBhID09IFwiZnVuY3Rpb25cIikgcmV0dXJuIDEyNDc7IC8vIGxpa2UgY2xvc3VyZV90YWcgKDI0NylcbiAgZWxzZSBpZiAodHlwZW9mIGEgPT0gXCJzeW1ib2xcIikgcmV0dXJuIDEyNTE7XG4gIHJldHVybiAxMDAxOyAvL291dF9vZl9oZWFwX3RhZ1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvbXBhcmVfdmFsX2dldF9jdXN0b21cbi8vUmVxdWlyZXM6IGNhbWxfY3VzdG9tX29wc1xuZnVuY3Rpb24gY2FtbF9jb21wYXJlX3ZhbF9nZXRfY3VzdG9tKGEpe1xuICByZXR1cm4gY2FtbF9jdXN0b21fb3BzW2EuY2FtbF9jdXN0b21dICYmIGNhbWxfY3VzdG9tX29wc1thLmNhbWxfY3VzdG9tXS5jb21wYXJlO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvbXBhcmVfdmFsX251bWJlcl9jdXN0b21cbi8vUmVxdWlyZXM6IGNhbWxfY29tcGFyZV92YWxfZ2V0X2N1c3RvbVxuZnVuY3Rpb24gY2FtbF9jb21wYXJlX3ZhbF9udW1iZXJfY3VzdG9tKG51bSwgY3VzdG9tLCBzd2FwLCB0b3RhbCkge1xuICB2YXIgY29tcCA9IGNhbWxfY29tcGFyZV92YWxfZ2V0X2N1c3RvbShjdXN0b20pO1xuICBpZihjb21wKSB7XG4gICAgdmFyIHggPSAoc3dhcCA+IDApP2NvbXAoY3VzdG9tLG51bSx0b3RhbCk6Y29tcChudW0sY3VzdG9tLHRvdGFsKTtcbiAgICBpZih0b3RhbCAmJiB4ICE9IHgpIHJldHVybiBzd2FwOyAvLyB0b3RhbCAmJiBuYW5cbiAgICBpZigreCAhPSAreCkgcmV0dXJuICt4OyAvLyBuYW5cbiAgICBpZigoeCB8IDApICE9IDApIHJldHVybiAoeCB8IDApOyAvLyAhbmFuXG4gIH1cbiAgcmV0dXJuIHN3YXBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jb21wYXJlX3ZhbCAoY29uc3QsIGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfaW50X2NvbXBhcmUsIGNhbWxfc3RyaW5nX2NvbXBhcmUsIGNhbWxfYnl0ZXNfY29tcGFyZVxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2NvbXBhcmVfdmFsX2dldF9jdXN0b20sIGNhbWxfY29tcGFyZV92YWxfdGFnXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsX251bWJlcl9jdXN0b21cbi8vUmVxdWlyZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfaXNfY29udGludWF0aW9uX3RhZ1xuZnVuY3Rpb24gY2FtbF9jb21wYXJlX3ZhbCAoYSwgYiwgdG90YWwpIHtcbiAgdmFyIHN0YWNrID0gW107XG4gIGZvcig7Oykge1xuICAgIGlmICghKHRvdGFsICYmIGEgPT09IGIpKSB7XG4gICAgICB2YXIgdGFnX2EgPSBjYW1sX2NvbXBhcmVfdmFsX3RhZyhhKTtcbiAgICAgIC8vIGZvcndhcmRfdGFnID9cbiAgICAgIGlmKHRhZ19hID09IDI1MCkgeyBhID0gYVsxXTsgY29udGludWUgfVxuXG4gICAgICB2YXIgdGFnX2IgPSBjYW1sX2NvbXBhcmVfdmFsX3RhZyhiKTtcbiAgICAgIC8vIGZvcndhcmRfdGFnID9cbiAgICAgIGlmKHRhZ19iID09IDI1MCkgeyBiID0gYlsxXTsgY29udGludWUgfVxuXG4gICAgICAvLyB0YWdzIGFyZSBkaWZmZXJlbnRcbiAgICAgIGlmKHRhZ19hICE9PSB0YWdfYikge1xuICAgICAgICBpZih0YWdfYSA9PSAxMDAwKSB7XG4gICAgICAgICAgaWYodGFnX2IgPT0gMTI1NSkgeyAvL2ltbWVkaWF0ZSBjYW4gY29tcGFyZSBhZ2FpbnN0IGN1c3RvbVxuICAgICAgICAgICAgcmV0dXJuIGNhbWxfY29tcGFyZV92YWxfbnVtYmVyX2N1c3RvbShhLCBiLCAtMSwgdG90YWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gLTFcbiAgICAgICAgfVxuICAgICAgICBpZih0YWdfYiA9PSAxMDAwKSB7XG4gICAgICAgICAgaWYodGFnX2EgPT0gMTI1NSkgeyAvL2ltbWVkaWF0ZSBjYW4gY29tcGFyZSBhZ2FpbnN0IGN1c3RvbVxuICAgICAgICAgICAgcmV0dXJuIGNhbWxfY29tcGFyZV92YWxfbnVtYmVyX2N1c3RvbShiLCBhLCAxLCB0b3RhbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAxXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICh0YWdfYSA8IHRhZ19iKT8tMToxO1xuICAgICAgfVxuICAgICAgc3dpdGNoKHRhZ19hKXtcbiAgICAgICAgLy8gMjQ2OiBMYXp5X3RhZyBoYW5kbGVkIGJlbGxvd1xuICAgICAgY2FzZSAyNDc6IC8vIENsb3N1cmVfdGFnXG4gICAgICAgIC8vIENhbm5vdCBoYXBwZW5cbiAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY29tcGFyZTogZnVuY3Rpb25hbCB2YWx1ZVwiKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgMjQ4OiAvLyBPYmplY3RcbiAgICAgICAgdmFyIHggPSBjYW1sX2ludF9jb21wYXJlKGFbMl0sIGJbMl0pO1xuICAgICAgICBpZiAoeCAhPSAwKSByZXR1cm4gKHggfCAwKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI0OTogLy8gSW5maXhcbiAgICAgICAgLy8gQ2Fubm90IGhhcHBlblxuICAgICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJjb21wYXJlOiBmdW5jdGlvbmFsIHZhbHVlXCIpO1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSAyNTA6IC8vIEZvcndhcmQgdGFnXG4gICAgICAgIC8vIENhbm5vdCBoYXBwZW4sIGhhbmRsZWQgYWJvdmVcbiAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiZXF1YWw6IGdvdCBGb3J3YXJkX3RhZywgc2hvdWxkIG5vdCBoYXBwZW5cIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNTE6IC8vQWJzdHJhY3RcbiAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiZXF1YWw6IGFic3RyYWN0IHZhbHVlXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjUyOiAvLyBPQ2FtbCBieXRlc1xuICAgICAgICBpZiAoYSAhPT0gYikge1xuICAgICAgICAgIHZhciB4ID0gY2FtbF9ieXRlc19jb21wYXJlKGEsIGIpO1xuICAgICAgICAgIGlmICh4ICE9IDApIHJldHVybiAoeCB8IDApO1xuICAgICAgICB9O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjUzOiAvLyBEb3VibGVfdGFnXG4gICAgICAgIC8vIENhbm5vdCBoYXBwZW5cbiAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiZXF1YWw6IGdvdCBEb3VibGVfdGFnLCBzaG91bGQgbm90IGhhcHBlblwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI1NDogLy8gRG91YmxlX2FycmF5X3RhZ1xuICAgICAgICAvLyBDYW5ub3QgaGFwcGVuLCBoYW5kbGVkIGFib3ZlXG4gICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImVxdWFsOiBnb3QgRG91YmxlX2FycmF5X3RhZywgc2hvdWxkIG5vdCBoYXBwZW5cIik7XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIDI1NTogLy8gQ3VzdG9tX3RhZ1xuICAgICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJlcXVhbDogZ290IEN1c3RvbV90YWcsIHNob3VsZCBub3QgaGFwcGVuXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTI0NzogLy8gRnVuY3Rpb25cbiAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY29tcGFyZTogZnVuY3Rpb25hbCB2YWx1ZVwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEyNTU6IC8vIEN1c3RvbVxuICAgICAgICB2YXIgY29tcCA9IGNhbWxfY29tcGFyZV92YWxfZ2V0X2N1c3RvbShhKTtcbiAgICAgICAgaWYoY29tcCAhPSBjYW1sX2NvbXBhcmVfdmFsX2dldF9jdXN0b20oYikpe1xuICAgICAgICAgIHJldHVybiAoYS5jYW1sX2N1c3RvbTxiLmNhbWxfY3VzdG9tKT8tMToxO1xuICAgICAgICB9XG4gICAgICAgIGlmKCFjb21wKVxuICAgICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNvbXBhcmU6IGFic3RyYWN0IHZhbHVlXCIpO1xuICAgICAgICB2YXIgeCA9IGNvbXAoYSxiLHRvdGFsKTtcbiAgICAgICAgaWYoeCAhPSB4KXsgLy8gUHJvdGVjdCBhZ2FpbnN0IGludmFsaWQgVU5PUkRFUkVEXG4gICAgICAgICAgcmV0dXJuIHRvdGFsPy0xOng7XG4gICAgICAgIH1cbiAgICAgICAgaWYoeCAhPT0gKHh8MCkpeyAvLyBQcm90ZWN0IGFnYWluc3QgaW52YWxpZCByZXR1cm4gdmFsdWVcbiAgICAgICAgICByZXR1cm4gLTFcbiAgICAgICAgfVxuICAgICAgICBpZiAoeCAhPSAwKSByZXR1cm4gKHggfCAwKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEyNTY6IC8vIGNvbXBhcmUgZnVuY3Rpb25cbiAgICAgICAgdmFyIHggPSBhLmNvbXBhcmUoYix0b3RhbCk7XG4gICAgICAgIGlmKHggIT0geCkgeyAvLyBQcm90ZWN0IGFnYWluc3QgaW52YWxpZCBVTk9SREVSRURcbiAgICAgICAgICByZXR1cm4gdG90YWw/LTE6eDtcbiAgICAgICAgfVxuICAgICAgICBpZih4ICE9PSAoeHwwKSl7IC8vIFByb3RlY3QgYWdhaW5zdCBpbnZhbGlkIHJldHVybiB2YWx1ZVxuICAgICAgICAgIHJldHVybiAtMVxuICAgICAgICB9XG4gICAgICAgIGlmICh4ICE9IDApIHJldHVybiAoeCB8IDApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTAwMDogLy8gTnVtYmVyXG4gICAgICAgIGEgPSArYTtcbiAgICAgICAgYiA9ICtiO1xuICAgICAgICBpZiAoYSA8IGIpIHJldHVybiAtMTtcbiAgICAgICAgaWYgKGEgPiBiKSByZXR1cm4gMTtcbiAgICAgICAgaWYgKGEgIT0gYikge1xuICAgICAgICAgIGlmICghdG90YWwpIHJldHVybiBOYU47XG4gICAgICAgICAgaWYgKGEgPT0gYSkgcmV0dXJuIDE7XG4gICAgICAgICAgaWYgKGIgPT0gYikgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxMDAxOiAvLyBUaGUgcmVzdFxuICAgICAgICAvLyBIZXJlIHdlIGNhbiBiZSBpbiB0aGUgZm9sbG93aW5nIGNhc2VzOlxuICAgICAgICAvLyAxLiBKYXZhU2NyaXB0IHByaW1pdGl2ZSB0eXBlc1xuICAgICAgICAvLyAyLiBKYXZhU2NyaXB0IG9iamVjdCB0aGF0IGNhbiBiZSBjb2VyY2VkIHRvIHByaW1pdGl2ZSB0eXBlc1xuICAgICAgICAvLyAzLiBKYXZhU2NyaXB0IG9iamVjdCB0aGFuIGNhbm5vdCBiZSBjb2VyY2VkIHRvIHByaW1pdGl2ZSB0eXBlc1xuICAgICAgICAvL1xuICAgICAgICAvLyAoMykgd2lsbCByYWlzZSBhIFtUeXBlRXJyb3JdXG4gICAgICAgIC8vICgyKSB3aWxsIGNvZXJjZSB0byBwcmltaXRpdmUgdHlwZXMgdXNpbmcgW3ZhbHVlT2ZdIG9yIFt0b1N0cmluZ11cbiAgICAgICAgLy8gKDIpIGFuZCAoMyksIGFmdGVyIGV2ZW50dWFsIGNvZXJjaW9uXG4gICAgICAgIC8vIC0gaWYgYSBhbmQgYiBhcmUgc3RyaW5ncywgYXBwbHkgbGV4aWNvZ3JhcGhpYyBjb21wYXJpc29uXG4gICAgICAgIC8vIC0gaWYgYSBvciBiIGFyZSBub3Qgc3RyaW5ncywgY29udmVydCBhIGFuZCBiIHRvIG51bWJlclxuICAgICAgICAvLyAgIGFuZCBhcHBseSBzdGFuZGFyZCBjb21wYXJpc29uXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEV4Y2VwdGlvbjogYCE9YCB3aWxsIG5vdCBjb2VyY2UvY29udmVydCBpZiBib3RoIGEgYW5kIGIgYXJlIG9iamVjdHNcbiAgICAgICAgaWYgKGEgPCBiKSByZXR1cm4gLTE7XG4gICAgICAgIGlmIChhID4gYikgcmV0dXJuIDE7XG4gICAgICAgIGlmIChhICE9IGIpIHtcbiAgICAgICAgICBpZiAoIXRvdGFsKSByZXR1cm4gTmFOO1xuICAgICAgICAgIGlmIChhID09IGEpIHJldHVybiAxO1xuICAgICAgICAgIGlmIChiID09IGIpIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTI1MTogLy8gSmF2YVNjcmlwdCBTeW1ib2wsIG5vIG9yZGVyaW5nLlxuICAgICAgICBpZihhICE9PSBiKSB7XG4gICAgICAgICAgaWYgKCF0b3RhbCkgcmV0dXJuIE5hTjtcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTI1MjogLy8gb2NhbWwgc3RyaW5nc1xuICAgICAgICB2YXIgYSA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcoYSk7XG4gICAgICAgIHZhciBiID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhiKTtcbiAgICAgICAgaWYoYSAhPT0gYikge1xuICAgICAgICAgIGlmKGEgPCBiKSByZXR1cm4gLTE7XG4gICAgICAgICAgaWYoYSA+IGIpIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxMjUyMDogLy8gamF2YXNjcmlwdCBzdHJpbmdzXG4gICAgICAgIHZhciBhID0gYS50b1N0cmluZygpO1xuICAgICAgICB2YXIgYiA9IGIudG9TdHJpbmcoKTtcbiAgICAgICAgaWYoYSAhPT0gYikge1xuICAgICAgICAgIGlmKGEgPCBiKSByZXR1cm4gLTE7XG4gICAgICAgICAgaWYoYSA+IGIpIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNDY6IC8vIExhenlfdGFnXG4gICAgICBjYXNlIDI1NDogLy8gRG91YmxlX2FycmF5XG4gICAgICBkZWZhdWx0OiAvLyBCbG9jayB3aXRoIG90aGVyIHRhZ1xuICAgICAgICBpZihjYW1sX2lzX2NvbnRpbnVhdGlvbl90YWcodGFnX2EpKSB7XG4gICAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY29tcGFyZTogY29udGludWF0aW9uIHZhbHVlXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aCkgcmV0dXJuIChhLmxlbmd0aCA8IGIubGVuZ3RoKT8tMToxO1xuICAgICAgICBpZiAoYS5sZW5ndGggPiAxKSBzdGFjay5wdXNoKGEsIGIsIDEpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN0YWNrLmxlbmd0aCA9PSAwKSByZXR1cm4gMDtcbiAgICB2YXIgaSA9IHN0YWNrLnBvcCgpO1xuICAgIGIgPSBzdGFjay5wb3AoKTtcbiAgICBhID0gc3RhY2sucG9wKCk7XG4gICAgaWYgKGkgKyAxIDwgYS5sZW5ndGgpIHN0YWNrLnB1c2goYSwgYiwgaSArIDEpO1xuICAgIGEgPSBhW2ldO1xuICAgIGIgPSBiW2ldO1xuICB9XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2NvbXBhcmUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY29tcGFyZV92YWxcbmZ1bmN0aW9uIGNhbWxfY29tcGFyZSAoYSwgYikgeyByZXR1cm4gY2FtbF9jb21wYXJlX3ZhbCAoYSwgYiwgdHJ1ZSk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfaW50X2NvbXBhcmUgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9pbnRfY29tcGFyZSAoYSwgYikge1xuICBpZiAoYSA8IGIpIHJldHVybiAoLTEpOyBpZiAoYSA9PSBiKSByZXR1cm4gMDsgcmV0dXJuIDE7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2VxdWFsIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY29tcGFyZV92YWxcbmZ1bmN0aW9uIGNhbWxfZXF1YWwgKHgsIHkpIHsgcmV0dXJuICsoY2FtbF9jb21wYXJlX3ZhbCh4LHksZmFsc2UpID09IDApOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX25vdGVxdWFsIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY29tcGFyZV92YWxcbmZ1bmN0aW9uIGNhbWxfbm90ZXF1YWwgKHgsIHkpIHsgcmV0dXJuICsoY2FtbF9jb21wYXJlX3ZhbCh4LHksZmFsc2UpICE9IDApOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2dyZWF0ZXJlcXVhbCBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsXG5mdW5jdGlvbiBjYW1sX2dyZWF0ZXJlcXVhbCAoeCwgeSkgeyByZXR1cm4gKyhjYW1sX2NvbXBhcmVfdmFsKHgseSxmYWxzZSkgPj0gMCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JlYXRlcnRoYW4gbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jb21wYXJlX3ZhbFxuZnVuY3Rpb24gY2FtbF9ncmVhdGVydGhhbiAoeCwgeSkgeyByZXR1cm4gKyhjYW1sX2NvbXBhcmVfdmFsKHgseSxmYWxzZSkgPiAwKTsgfVxuLy9Qcm92aWRlczogY2FtbF9sZXNzZXF1YWwgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jb21wYXJlX3ZhbFxuZnVuY3Rpb24gY2FtbF9sZXNzZXF1YWwgKHgsIHkpIHsgcmV0dXJuICsoY2FtbF9jb21wYXJlX3ZhbCh4LHksZmFsc2UpIDw9IDApOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2xlc3N0aGFuIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY29tcGFyZV92YWxcbmZ1bmN0aW9uIGNhbWxfbGVzc3RoYW4gKHgsIHkpIHsgcmV0dXJuICsoY2FtbF9jb21wYXJlX3ZhbCh4LHksZmFsc2UpIDwgMCk7IH1cbiIsIlxuLy9Qcm92aWRlczogY2FtbF9jdXN0b21fZXZlbnRfaW5kZXhcbnZhciBjYW1sX2N1c3RvbV9ldmVudF9pbmRleCA9IDA7XG5cbi8vUHJvdmlkZXM6IGNhbWxfcnVudGltZV9ldmVudHNfdXNlcl9yZWdpc3RlclxuLy9SZXF1aXJlczogY2FtbF9jdXN0b21fZXZlbnRfaW5kZXhcbmZ1bmN0aW9uIGNhbWxfcnVudGltZV9ldmVudHNfdXNlcl9yZWdpc3RlcihldmVudF9uYW1lLCBldmVudF90YWcsIGV2ZW50X3R5cGUpIHtcbiAgY2FtbF9jdXN0b21fZXZlbnRfaW5kZXggKz0gMTtcbiAgcmV0dXJuIFswLCBjYW1sX2N1c3RvbV9ldmVudF9pbmRleCwgZXZlbnRfbmFtZSwgZXZlbnRfdHlwZSwgZXZlbnRfdGFnXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ydW50aW1lX2V2ZW50c191c2VyX3dyaXRlXG5mdW5jdGlvbiBjYW1sX3J1bnRpbWVfZXZlbnRzX3VzZXJfd3JpdGUoZXZlbnQsIGV2ZW50X2NvbnRlbnQpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcnVudGltZV9ldmVudHNfdXNlcl9yZXNvbHZlXG5mdW5jdGlvbiBjYW1sX3J1bnRpbWVfZXZlbnRzX3VzZXJfcmVzb2x2ZSgpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfcnVudGltZV9ldmVudHNfc3RhcnRcbi8vQWxpYXM6IGNhbWxfcnVudGltZV9ldmVudHNfc3RhcnRcbmZ1bmN0aW9uIGNhbWxfbWxfcnVudGltZV9ldmVudHNfc3RhcnQoKSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3J1bnRpbWVfZXZlbnRzX3BhdXNlXG4vL0FsaWFzOiBjYW1sX3J1bnRpbWVfZXZlbnRzX3BhdXNlXG5mdW5jdGlvbiBjYW1sX21sX3J1bnRpbWVfZXZlbnRzX3BhdXNlKCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9ydW50aW1lX2V2ZW50c19hcmVfYWN0aXZlXG4vL1ZlcnNpb246ID49IDUuMlxuZnVuY3Rpb24gY2FtbF9tbF9ydW50aW1lX2V2ZW50c19hcmVfYWN0aXZlKCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9ydW50aW1lX2V2ZW50c19yZXN1bWVcbi8vQWxpYXM6IGNhbWxfcnVudGltZV9ldmVudHNfcmVzdW1lXG5mdW5jdGlvbiBjYW1sX21sX3J1bnRpbWVfZXZlbnRzX3Jlc3VtZSgpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcnVudGltZV9ldmVudHNfY3JlYXRlX2N1cnNvclxuZnVuY3Rpb24gY2FtbF9ydW50aW1lX2V2ZW50c19jcmVhdGVfY3Vyc29yKHRhcmdldCkge1xuICByZXR1cm4ge307XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcnVudGltZV9ldmVudHNfZnJlZV9jdXJzb3JcbmZ1bmN0aW9uIGNhbWxfcnVudGltZV9ldmVudHNfZnJlZV9jdXJzb3IoY3Vyc29yKSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3J1bnRpbWVfZXZlbnRzX3JlYWRfcG9sbFxuZnVuY3Rpb24gY2FtbF9ydW50aW1lX2V2ZW50c19yZWFkX3BvbGwoY3Vyc29yLCBjYWxsYmFja3MsIG51bSkge1xuICByZXR1cm4gMDtcbn1cbiIsIlxuLy9Qcm92aWRlczogenN0ZF9kZWNvbXByZXNzXG4vL1ZlcnNpb246ID49IDUuMVxudmFyIHpzdGRfZGVjb21wcmVzcyA9IChmdW5jdGlvbiAoKSB7XG5cInVzZSBzdHJpY3RcIjtcbi8vIGFsaWFzZXMgZm9yIHNob3J0ZXIgY29tcHJlc3NlZCBjb2RlIChtb3N0IG1pbmlmZXJzIGRvbid0IGRvIHRoaXMpXG52YXIgYWIgPSBBcnJheUJ1ZmZlciwgdTggPSBVaW50OEFycmF5LCB1MTYgPSBVaW50MTZBcnJheSwgaTE2ID0gSW50MTZBcnJheSwgdTMyID0gVWludDMyQXJyYXksIGkzMiA9IEludDMyQXJyYXk7XG52YXIgc2xjID0gZnVuY3Rpb24gKHYsIHMsIGUpIHtcbiAgICBpZiAodTgucHJvdG90eXBlLnNsaWNlKVxuICAgICAgICByZXR1cm4gdTgucHJvdG90eXBlLnNsaWNlLmNhbGwodiwgcywgZSk7XG4gICAgaWYgKHMgPT0gbnVsbCB8fCBzIDwgMClcbiAgICAgICAgcyA9IDA7XG4gICAgaWYgKGUgPT0gbnVsbCB8fCBlID4gdi5sZW5ndGgpXG4gICAgICAgIGUgPSB2Lmxlbmd0aDtcbiAgICB2YXIgbiA9IG5ldyB1OChlIC0gcyk7XG4gICAgbi5zZXQodi5zdWJhcnJheShzLCBlKSk7XG4gICAgcmV0dXJuIG47XG59O1xudmFyIGZpbGwgPSBmdW5jdGlvbiAodiwgbiwgcywgZSkge1xuICAgIGlmICh1OC5wcm90b3R5cGUuZmlsbClcbiAgICAgICAgcmV0dXJuIHU4LnByb3RvdHlwZS5maWxsLmNhbGwodiwgbiwgcywgZSk7XG4gICAgaWYgKHMgPT0gbnVsbCB8fCBzIDwgMClcbiAgICAgICAgcyA9IDA7XG4gICAgaWYgKGUgPT0gbnVsbCB8fCBlID4gdi5sZW5ndGgpXG4gICAgICAgIGUgPSB2Lmxlbmd0aDtcbiAgICBmb3IgKDsgcyA8IGU7ICsrcylcbiAgICAgICAgdltzXSA9IG47XG4gICAgcmV0dXJuIHY7XG59O1xudmFyIGNwdyA9IGZ1bmN0aW9uICh2LCB0LCBzLCBlKSB7XG4gICAgaWYgKHU4LnByb3RvdHlwZS5jb3B5V2l0aGluKVxuICAgICAgICByZXR1cm4gdTgucHJvdG90eXBlLmNvcHlXaXRoaW4uY2FsbCh2LCB0LCBzLCBlKTtcbiAgICBpZiAocyA9PSBudWxsIHx8IHMgPCAwKVxuICAgICAgICBzID0gMDtcbiAgICBpZiAoZSA9PSBudWxsIHx8IGUgPiB2Lmxlbmd0aClcbiAgICAgICAgZSA9IHYubGVuZ3RoO1xuICAgIHdoaWxlIChzIDwgZSkge1xuICAgICAgICB2W3QrK10gPSB2W3MrK107XG4gICAgfVxufTtcbi8qKlxuICogQ29kZXMgZm9yIGVycm9ycyBnZW5lcmF0ZWQgd2l0aGluIHRoaXMgbGlicmFyeVxuICovXG4vLyBlcnJvciBjb2Rlc1xudmFyIGVjID0gW1xuICAgICdpbnZhbGlkIHpzdGQgZGF0YScsXG4gICAgJ3dpbmRvdyBzaXplIHRvbyBsYXJnZSAoPjIwNDZNQiknLFxuICAgICdpbnZhbGlkIGJsb2NrIHR5cGUnLFxuICAgICdGU0UgYWNjdXJhY3kgdG9vIGhpZ2gnLFxuICAgICdtYXRjaCBkaXN0YW5jZSB0b28gZmFyIGJhY2snLFxuICAgICd1bmV4cGVjdGVkIEVPRidcbl07XG47XG52YXIgZXJyID0gZnVuY3Rpb24gKGluZCwgbXNnLCBudCkge1xuICAgIHZhciBlID0gbmV3IEVycm9yKG1zZyB8fCBlY1tpbmRdKTtcbiAgICBlLmNvZGUgPSBpbmQ7XG4gICAgaWYgKCFudClcbiAgICAgICAgdGhyb3cgZTtcbiAgICByZXR1cm4gZTtcbn07XG52YXIgcmIgPSBmdW5jdGlvbiAoZCwgYiwgbikge1xuICAgIHZhciBpID0gMCwgbyA9IDA7XG4gICAgZm9yICg7IGkgPCBuOyArK2kpXG4gICAgICAgIG8gfD0gZFtiKytdIDw8IChpIDw8IDMpO1xuICAgIHJldHVybiBvO1xufTtcbnZhciBiNCA9IGZ1bmN0aW9uIChkLCBiKSB7IHJldHVybiAoZFtiXSB8IChkW2IgKyAxXSA8PCA4KSB8IChkW2IgKyAyXSA8PCAxNikgfCAoZFtiICsgM10gPDwgMjQpKSA+Pj4gMDsgfTtcbi8vIHJlYWQgWnN0YW5kYXJkIGZyYW1lIGhlYWRlclxudmFyIHJ6ZmggPSBmdW5jdGlvbiAoZGF0LCB3KSB7XG4gICAgdmFyIG4zID0gZGF0WzBdIHwgKGRhdFsxXSA8PCA4KSB8IChkYXRbMl0gPDwgMTYpO1xuICAgIGlmIChuMyA9PSAweDJGQjUyOCAmJiBkYXRbM10gPT0gMjUzKSB7XG4gICAgICAgIC8vIFpzdGFuZGFyZFxuICAgICAgICB2YXIgZmxnID0gZGF0WzRdO1xuICAgICAgICAvLyAgICBzaW5nbGUgc2VnbWVudCAgICAgICBjaGVja3N1bSAgICAgICAgICAgICBkaWN0IGZsYWcgICAgIGZyYW1lIGNvbnRlbnQgZmxhZ1xuICAgICAgICB2YXIgc3MgPSAoZmxnID4+IDUpICYgMSwgY2MgPSAoZmxnID4+IDIpICYgMSwgZGYgPSBmbGcgJiAzLCBmY2YgPSBmbGcgPj4gNjtcbiAgICAgICAgaWYgKGZsZyAmIDgpXG4gICAgICAgICAgICBlcnIoMCk7XG4gICAgICAgIC8vIGJ5dGVcbiAgICAgICAgdmFyIGJ0ID0gNiAtIHNzO1xuICAgICAgICAvLyBkaWN0IGJ5dGVzXG4gICAgICAgIHZhciBkYiA9IGRmID09IDMgPyA0IDogZGY7XG4gICAgICAgIC8vIGRpY3Rpb25hcnkgaWRcbiAgICAgICAgdmFyIGRpID0gcmIoZGF0LCBidCwgZGIpO1xuICAgICAgICBidCArPSBkYjtcbiAgICAgICAgLy8gZnJhbWUgc2l6ZSBieXRlc1xuICAgICAgICB2YXIgZnNiID0gZmNmID8gKDEgPDwgZmNmKSA6IHNzO1xuICAgICAgICAvLyBmcmFtZSBzb3VyY2Ugc2l6ZVxuICAgICAgICB2YXIgZnNzID0gcmIoZGF0LCBidCwgZnNiKSArICgoZmNmID09IDEpICYmIDI1Nik7XG4gICAgICAgIC8vIHdpbmRvdyBzaXplXG4gICAgICAgIHZhciB3cyA9IGZzcztcbiAgICAgICAgaWYgKCFzcykge1xuICAgICAgICAgICAgLy8gd2luZG93IGRlc2NyaXB0b3JcbiAgICAgICAgICAgIHZhciB3YiA9IDEgPDwgKDEwICsgKGRhdFs1XSA+PiAzKSk7XG4gICAgICAgICAgICB3cyA9IHdiICsgKHdiID4+IDMpICogKGRhdFs1XSAmIDcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3cyA+IDIxNDUzODY0OTYpXG4gICAgICAgICAgICBlcnIoMSk7XG4gICAgICAgIHZhciBidWYgPSBuZXcgdTgoKHcgPT0gMSA/IChmc3MgfHwgd3MpIDogdyA/IDAgOiB3cykgKyAxMik7XG4gICAgICAgIGJ1ZlswXSA9IDEsIGJ1Zls0XSA9IDQsIGJ1Zls4XSA9IDg7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBiOiBidCArIGZzYixcbiAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICBsOiAwLFxuICAgICAgICAgICAgZDogZGksXG4gICAgICAgICAgICB3OiAodyAmJiB3ICE9IDEpID8gdyA6IGJ1Zi5zdWJhcnJheSgxMiksXG4gICAgICAgICAgICBlOiB3cyxcbiAgICAgICAgICAgIG86IG5ldyBpMzIoYnVmLmJ1ZmZlciwgMCwgMyksXG4gICAgICAgICAgICB1OiBmc3MsXG4gICAgICAgICAgICBjOiBjYyxcbiAgICAgICAgICAgIG06IE1hdGgubWluKDEzMTA3Miwgd3MpXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKCgobjMgPj4gNCkgfCAoZGF0WzNdIDw8IDIwKSkgPT0gMHgxODREMkE1KSB7XG4gICAgICAgIC8vIHNraXBwYWJsZVxuICAgICAgICByZXR1cm4gYjQoZGF0LCA0KSArIDg7XG4gICAgfVxuICAgIGVycigwKTtcbn07XG4vLyBtb3N0IHNpZ25pZmljYW50IGJpdCBmb3Igbm9uemVyb1xudmFyIG1zYiA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICB2YXIgYml0cyA9IDA7XG4gICAgZm9yICg7ICgxIDw8IGJpdHMpIDw9IHZhbDsgKytiaXRzKVxuICAgICAgICA7XG4gICAgcmV0dXJuIGJpdHMgLSAxO1xufTtcbi8vIHJlYWQgZmluaXRlIHN0YXRlIGVudHJvcHlcbnZhciByZnNlID0gZnVuY3Rpb24gKGRhdCwgYnQsIG1hbCkge1xuICAgIC8vIHRhYmxlIHBvc1xuICAgIHZhciB0cG9zID0gKGJ0IDw8IDMpICsgNDtcbiAgICAvLyBhY2N1cmFjeSBsb2dcbiAgICB2YXIgYWwgPSAoZGF0W2J0XSAmIDE1KSArIDU7XG4gICAgaWYgKGFsID4gbWFsKVxuICAgICAgICBlcnIoMyk7XG4gICAgLy8gc2l6ZVxuICAgIHZhciBzeiA9IDEgPDwgYWw7XG4gICAgLy8gcHJvYmFiaWxpdGllcyBzeW1ib2xzICByZXBlYXQgICBpbmRleCAgIGhpZ2ggdGhyZXNob2xkXG4gICAgdmFyIHByb2JzID0gc3osIHN5bSA9IC0xLCByZSA9IC0xLCBpID0gLTEsIGh0ID0gc3o7XG4gICAgLy8gb3B0aW1pemF0aW9uOiBzaW5nbGUgYWxsb2NhdGlvbiBpcyBtdWNoIGZhc3RlclxuICAgIHZhciBidWYgPSBuZXcgYWIoNTEyICsgKHN6IDw8IDIpKTtcbiAgICB2YXIgZnJlcSA9IG5ldyBpMTYoYnVmLCAwLCAyNTYpO1xuICAgIC8vIHNhbWUgdmlldyBhcyBmcmVxXG4gICAgdmFyIGRzdGF0ZSA9IG5ldyB1MTYoYnVmLCAwLCAyNTYpO1xuICAgIHZhciBuc3RhdGUgPSBuZXcgdTE2KGJ1ZiwgNTEyLCBzeik7XG4gICAgdmFyIGJiMSA9IDUxMiArIChzeiA8PCAxKTtcbiAgICB2YXIgc3ltcyA9IG5ldyB1OChidWYsIGJiMSwgc3opO1xuICAgIHZhciBuYml0cyA9IG5ldyB1OChidWYsIGJiMSArIHN6KTtcbiAgICB3aGlsZSAoc3ltIDwgMjU1ICYmIHByb2JzID4gMCkge1xuICAgICAgICB2YXIgYml0cyA9IG1zYihwcm9icyArIDEpO1xuICAgICAgICB2YXIgY2J0ID0gdHBvcyA+PiAzO1xuICAgICAgICAvLyBtYXNrXG4gICAgICAgIHZhciBtc2sgPSAoMSA8PCAoYml0cyArIDEpKSAtIDE7XG4gICAgICAgIHZhciB2YWwgPSAoKGRhdFtjYnRdIHwgKGRhdFtjYnQgKyAxXSA8PCA4KSB8IChkYXRbY2J0ICsgMl0gPDwgMTYpKSA+PiAodHBvcyAmIDcpKSAmIG1zaztcbiAgICAgICAgLy8gbWFzayAoMSBmZXdlciBiaXQpXG4gICAgICAgIHZhciBtc2sxZmIgPSAoMSA8PCBiaXRzKSAtIDE7XG4gICAgICAgIC8vIG1heCBzbWFsbCB2YWx1ZVxuICAgICAgICB2YXIgbXN2ID0gbXNrIC0gcHJvYnMgLSAxO1xuICAgICAgICAvLyBzbWFsbCB2YWx1ZVxuICAgICAgICB2YXIgc3ZhbCA9IHZhbCAmIG1zazFmYjtcbiAgICAgICAgaWYgKHN2YWwgPCBtc3YpXG4gICAgICAgICAgICB0cG9zICs9IGJpdHMsIHZhbCA9IHN2YWw7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdHBvcyArPSBiaXRzICsgMTtcbiAgICAgICAgICAgIGlmICh2YWwgPiBtc2sxZmIpXG4gICAgICAgICAgICAgICAgdmFsIC09IG1zdjtcbiAgICAgICAgfVxuICAgICAgICBmcmVxWysrc3ltXSA9IC0tdmFsO1xuICAgICAgICBpZiAodmFsID09IC0xKSB7XG4gICAgICAgICAgICBwcm9icyArPSB2YWw7XG4gICAgICAgICAgICBzeW1zWy0taHRdID0gc3ltO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHByb2JzIC09IHZhbDtcbiAgICAgICAgaWYgKCF2YWwpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAvLyByZXBlYXQgYnl0ZVxuICAgICAgICAgICAgICAgIHZhciByYnQgPSB0cG9zID4+IDM7XG4gICAgICAgICAgICAgICAgcmUgPSAoKGRhdFtyYnRdIHwgKGRhdFtyYnQgKyAxXSA8PCA4KSkgPj4gKHRwb3MgJiA3KSkgJiAzO1xuICAgICAgICAgICAgICAgIHRwb3MgKz0gMjtcbiAgICAgICAgICAgICAgICBzeW0gKz0gcmU7XG4gICAgICAgICAgICB9IHdoaWxlIChyZSA9PSAzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3ltID4gMjU1IHx8IHByb2JzKVxuICAgICAgICBlcnIoMCk7XG4gICAgdmFyIHN5bXBvcyA9IDA7XG4gICAgLy8gc3ltIHN0ZXAgKGNvcHJpbWUgd2l0aCBzeiAtIGZvcm11bGEgZnJvbSB6c3RkIHNvdXJjZSlcbiAgICB2YXIgc3N0ZXAgPSAoc3ogPj4gMSkgKyAoc3ogPj4gMykgKyAzO1xuICAgIC8vIHN5bSBtYXNrXG4gICAgdmFyIHNtYXNrID0gc3ogLSAxO1xuICAgIGZvciAodmFyIHMgPSAwOyBzIDw9IHN5bTsgKytzKSB7XG4gICAgICAgIHZhciBzZiA9IGZyZXFbc107XG4gICAgICAgIGlmIChzZiA8IDEpIHtcbiAgICAgICAgICAgIGRzdGF0ZVtzXSA9IC1zZjtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoaXMgaXMgc3BsaXQgaW50byB0d28gbG9vcHMgaW4genN0ZCB0byBhdm9pZCBicmFuY2hpbmcsIGJ1dCBhcyBKUyBpcyBoaWdoZXItbGV2ZWwgdGhhdCBpcyB1bm5lY2Vzc2FyeVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2Y7ICsraSkge1xuICAgICAgICAgICAgc3ltc1tzeW1wb3NdID0gcztcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBzeW1wb3MgPSAoc3ltcG9zICsgc3N0ZXApICYgc21hc2s7XG4gICAgICAgICAgICB9IHdoaWxlIChzeW1wb3MgPj0gaHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEFmdGVyIHNwcmVhZGluZyBzeW1ib2xzLCBzaG91bGQgYmUgemVybyBhZ2FpblxuICAgIGlmIChzeW1wb3MpXG4gICAgICAgIGVycigwKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgc3o7ICsraSkge1xuICAgICAgICAvLyBuZXh0IHN0YXRlXG4gICAgICAgIHZhciBucyA9IGRzdGF0ZVtzeW1zW2ldXSsrO1xuICAgICAgICAvLyBudW0gYml0c1xuICAgICAgICB2YXIgbmIgPSBuYml0c1tpXSA9IGFsIC0gbXNiKG5zKTtcbiAgICAgICAgbnN0YXRlW2ldID0gKG5zIDw8IG5iKSAtIHN6O1xuICAgIH1cbiAgICByZXR1cm4gWyh0cG9zICsgNykgPj4gMywge1xuICAgICAgICAgICAgYjogYWwsXG4gICAgICAgICAgICBzOiBzeW1zLFxuICAgICAgICAgICAgbjogbmJpdHMsXG4gICAgICAgICAgICB0OiBuc3RhdGVcbiAgICAgICAgfV07XG59O1xuLy8gcmVhZCBodWZmbWFuXG52YXIgcmh1ID0gZnVuY3Rpb24gKGRhdCwgYnQpIHtcbiAgICAvLyAgaW5kZXggIHdlaWdodCBjb3VudFxuICAgIHZhciBpID0gMCwgd2MgPSAtMTtcbiAgICAvLyAgICBidWZmZXIgICAgICAgICAgICAgaGVhZGVyIGJ5dGVcbiAgICB2YXIgYnVmID0gbmV3IHU4KDI5MiksIGhiID0gZGF0W2J0XTtcbiAgICAvLyBodWZmbWFuIHdlaWdodHNcbiAgICB2YXIgaHcgPSBidWYuc3ViYXJyYXkoMCwgMjU2KTtcbiAgICAvLyByYW5rIGNvdW50XG4gICAgdmFyIHJjID0gYnVmLnN1YmFycmF5KDI1NiwgMjY4KTtcbiAgICAvLyByYW5rIGluZGV4XG4gICAgdmFyIHJpID0gbmV3IHUxNihidWYuYnVmZmVyLCAyNjgpO1xuICAgIC8vIE5PVEU6IGF0IHRoaXMgcG9pbnQgYnQgaXMgMSBsZXNzIHRoYW4gZXhwZWN0ZWRcbiAgICBpZiAoaGIgPCAxMjgpIHtcbiAgICAgICAgLy8gZW5kIGJ5dGUsIGZzZSBkZWNvZGUgdGFibGVcbiAgICAgICAgdmFyIF9hID0gcmZzZShkYXQsIGJ0ICsgMSwgNiksIGVidCA9IF9hWzBdLCBmZHQgPSBfYVsxXTtcbiAgICAgICAgYnQgKz0gaGI7XG4gICAgICAgIHZhciBlcG9zID0gZWJ0IDw8IDM7XG4gICAgICAgIC8vIGxhc3QgYnl0ZVxuICAgICAgICB2YXIgbGIgPSBkYXRbYnRdO1xuICAgICAgICBpZiAoIWxiKVxuICAgICAgICAgICAgZXJyKDApO1xuICAgICAgICAvLyAgc3RhdGUxICAgc3RhdGUyICAgc3RhdGUxIGJpdHMgICBzdGF0ZTIgYml0c1xuICAgICAgICB2YXIgc3QxID0gMCwgc3QyID0gMCwgYnRyMSA9IGZkdC5iLCBidHIyID0gYnRyMTtcbiAgICAgICAgLy8gZnNlIHBvc1xuICAgICAgICAvLyBwcmUtaW5jcmVtZW50IHRvIGFjY291bnQgZm9yIG9yaWdpbmFsIGRlZmljaXQgb2YgMVxuICAgICAgICB2YXIgZnBvcyA9ICgrK2J0IDw8IDMpIC0gOCArIG1zYihsYik7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGZwb3MgLT0gYnRyMTtcbiAgICAgICAgICAgIGlmIChmcG9zIDwgZXBvcylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHZhciBjYnQgPSBmcG9zID4+IDM7XG4gICAgICAgICAgICBzdDEgKz0gKChkYXRbY2J0XSB8IChkYXRbY2J0ICsgMV0gPDwgOCkpID4+IChmcG9zICYgNykpICYgKCgxIDw8IGJ0cjEpIC0gMSk7XG4gICAgICAgICAgICBod1srK3djXSA9IGZkdC5zW3N0MV07XG4gICAgICAgICAgICBmcG9zIC09IGJ0cjI7XG4gICAgICAgICAgICBpZiAoZnBvcyA8IGVwb3MpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYnQgPSBmcG9zID4+IDM7XG4gICAgICAgICAgICBzdDIgKz0gKChkYXRbY2J0XSB8IChkYXRbY2J0ICsgMV0gPDwgOCkpID4+IChmcG9zICYgNykpICYgKCgxIDw8IGJ0cjIpIC0gMSk7XG4gICAgICAgICAgICBod1srK3djXSA9IGZkdC5zW3N0Ml07XG4gICAgICAgICAgICBidHIxID0gZmR0Lm5bc3QxXTtcbiAgICAgICAgICAgIHN0MSA9IGZkdC50W3N0MV07XG4gICAgICAgICAgICBidHIyID0gZmR0Lm5bc3QyXTtcbiAgICAgICAgICAgIHN0MiA9IGZkdC50W3N0Ml07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCsrd2MgPiAyNTUpXG4gICAgICAgICAgICBlcnIoMCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB3YyA9IGhiIC0gMTI3O1xuICAgICAgICBmb3IgKDsgaSA8IHdjOyBpICs9IDIpIHtcbiAgICAgICAgICAgIHZhciBieXRlID0gZGF0WysrYnRdO1xuICAgICAgICAgICAgaHdbaV0gPSBieXRlID4+IDQ7XG4gICAgICAgICAgICBod1tpICsgMV0gPSBieXRlICYgMTU7XG4gICAgICAgIH1cbiAgICAgICAgKytidDtcbiAgICB9XG4gICAgLy8gd2VpZ2h0IGV4cG9uZW50aWFsIHN1bVxuICAgIHZhciB3ZXMgPSAwO1xuICAgIGZvciAoaSA9IDA7IGkgPCB3YzsgKytpKSB7XG4gICAgICAgIHZhciB3dCA9IGh3W2ldO1xuICAgICAgICAvLyBiaXRzIG11c3QgYmUgYXQgbW9zdCAxMSwgc2FtZSBhcyB3ZWlnaHRcbiAgICAgICAgaWYgKHd0ID4gMTEpXG4gICAgICAgICAgICBlcnIoMCk7XG4gICAgICAgIHdlcyArPSB3dCAmJiAoMSA8PCAod3QgLSAxKSk7XG4gICAgfVxuICAgIC8vIG1heCBiaXRzXG4gICAgdmFyIG1iID0gbXNiKHdlcykgKyAxO1xuICAgIC8vIHRhYmxlIHNpemVcbiAgICB2YXIgdHMgPSAxIDw8IG1iO1xuICAgIC8vIHJlbWFpbmluZyBzdW1cbiAgICB2YXIgcmVtID0gdHMgLSB3ZXM7XG4gICAgLy8gbXVzdCBiZSBwb3dlciBvZiAyXG4gICAgaWYgKHJlbSAmIChyZW0gLSAxKSlcbiAgICAgICAgZXJyKDApO1xuICAgIGh3W3djKytdID0gbXNiKHJlbSkgKyAxO1xuICAgIGZvciAoaSA9IDA7IGkgPCB3YzsgKytpKSB7XG4gICAgICAgIHZhciB3dCA9IGh3W2ldO1xuICAgICAgICArK3JjW2h3W2ldID0gd3QgJiYgKG1iICsgMSAtIHd0KV07XG4gICAgfVxuICAgIC8vIGh1ZiBidWZcbiAgICB2YXIgaGJ1ZiA9IG5ldyB1OCh0cyA8PCAxKTtcbiAgICAvLyAgICBzeW1ib2xzICAgICAgICAgICAgICAgICAgICAgIG51bSBiaXRzXG4gICAgdmFyIHN5bXMgPSBoYnVmLnN1YmFycmF5KDAsIHRzKSwgbmIgPSBoYnVmLnN1YmFycmF5KHRzKTtcbiAgICByaVttYl0gPSAwO1xuICAgIGZvciAoaSA9IG1iOyBpID4gMDsgLS1pKSB7XG4gICAgICAgIHZhciBwdiA9IHJpW2ldO1xuICAgICAgICBmaWxsKG5iLCBpLCBwdiwgcmlbaSAtIDFdID0gcHYgKyByY1tpXSAqICgxIDw8IChtYiAtIGkpKSk7XG4gICAgfVxuICAgIGlmIChyaVswXSAhPSB0cylcbiAgICAgICAgZXJyKDApO1xuICAgIGZvciAoaSA9IDA7IGkgPCB3YzsgKytpKSB7XG4gICAgICAgIHZhciBiaXRzID0gaHdbaV07XG4gICAgICAgIGlmIChiaXRzKSB7XG4gICAgICAgICAgICB2YXIgY29kZSA9IHJpW2JpdHNdO1xuICAgICAgICAgICAgZmlsbChzeW1zLCBpLCBjb2RlLCByaVtiaXRzXSA9IGNvZGUgKyAoMSA8PCAobWIgLSBiaXRzKSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbYnQsIHtcbiAgICAgICAgICAgIG46IG5iLFxuICAgICAgICAgICAgYjogbWIsXG4gICAgICAgICAgICBzOiBzeW1zXG4gICAgICAgIH1dO1xufTtcbi8vIFRhYmxlcyBnZW5lcmF0ZWQgdXNpbmcgdGhpczpcbi8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tLzEwMWFycm93ei9hOTc5NDUyZDQzNTU5OTJjYmY4ZjI1N2NiZmZjOWVkZFxuLy8gZGVmYXVsdCBsaXRlcmFsIGxlbmd0aCB0YWJsZVxudmFyIGRsbHQgPSAvKiNfX1BVUkVfXyovIHJmc2UoLyojX19QVVJFX18qLyBuZXcgdTgoW1xuICAgIDgxLCAxNiwgOTksIDE0MCwgNDksIDE5OCwgMjQsIDk5LCAxMiwgMzMsIDE5NiwgMjQsIDk5LCAxMDIsIDEwMiwgMTM0LCA3MCwgMTQ2LCA0XG5dKSwgMCwgNilbMV07XG4vLyBkZWZhdWx0IG1hdGNoIGxlbmd0aCB0YWJsZVxudmFyIGRtbHQgPSAvKiNfX1BVUkVfXyovIHJmc2UoLyojX19QVVJFX18qLyBuZXcgdTgoW1xuICAgIDMzLCAyMCwgMTk2LCAyNCwgOTksIDE0MCwgMzMsIDEzMiwgMTYsIDY2LCA4LCAzMywgMTMyLCAxNiwgNjYsIDgsIDMzLCA2OCwgNjgsIDY4LCA2OCwgNjgsIDY4LCA2OCwgNjgsIDM2LCA5XG5dKSwgMCwgNilbMV07XG4vLyBkZWZhdWx0IG9mZnNldCBjb2RlIHRhYmxlXG52YXIgZG9jdCA9IC8qI19fUFVSRV9fICovIHJmc2UoLyojX19QVVJFX18qLyBuZXcgdTgoW1xuICAgIDMyLCAxMzIsIDE2LCA2NiwgMTAyLCA3MCwgNjgsIDY4LCA2OCwgNjgsIDM2LCA3MywgMlxuXSksIDAsIDUpWzFdO1xuLy8gYml0cyB0byBiYXNlbGluZVxudmFyIGIyYmwgPSBmdW5jdGlvbiAoYiwgcykge1xuICAgIHZhciBsZW4gPSBiLmxlbmd0aCwgYmwgPSBuZXcgaTMyKGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICBibFtpXSA9IHM7XG4gICAgICAgIHMgKz0gMSA8PCBiW2ldO1xuICAgIH1cbiAgICByZXR1cm4gYmw7XG59O1xuLy8gbGl0ZXJhbCBsZW5ndGggYml0c1xudmFyIGxsYiA9IC8qI19fUFVSRV9fICovIG5ldyB1OCgoIC8qI19fUFVSRV9fICovbmV3IGkzMihbXG4gICAgMCwgMCwgMCwgMCwgMTY4NDMwMDksIDUwNTI4NzcwLCAxMzQ2NzgwMjAsIDIwMjA1MDA1NywgMjY5NDIyMDkzXG5dKSkuYnVmZmVyLCAwLCAzNik7XG4vLyBsaXRlcmFsIGxlbmd0aCBiYXNlbGluZVxudmFyIGxsYmwgPSAvKiNfX1BVUkVfXyAqLyBiMmJsKGxsYiwgMCk7XG4vLyBtYXRjaCBsZW5ndGggYml0c1xudmFyIG1sYiA9IC8qI19fUFVSRV9fICovIG5ldyB1OCgoIC8qI19fUFVSRV9fICovbmV3IGkzMihbXG4gICAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMTY4NDMwMDksIDUwNTI4NzcwLCAxMTc3NjkyMjAsIDE4NTIwNzA0OCwgMjUyNTc5MDg0LCAxNlxuXSkpLmJ1ZmZlciwgMCwgNTMpO1xuLy8gbWF0Y2ggbGVuZ3RoIGJhc2VsaW5lXG52YXIgbWxibCA9IC8qI19fUFVSRV9fICovIGIyYmwobWxiLCAzKTtcbi8vIGRlY29kZSBodWZmbWFuIHN0cmVhbVxudmFyIGRodSA9IGZ1bmN0aW9uIChkYXQsIG91dCwgaHUpIHtcbiAgICB2YXIgbGVuID0gZGF0Lmxlbmd0aCwgc3MgPSBvdXQubGVuZ3RoLCBsYiA9IGRhdFtsZW4gLSAxXSwgbXNrID0gKDEgPDwgaHUuYikgLSAxLCBlYiA9IC1odS5iO1xuICAgIGlmICghbGIpXG4gICAgICAgIGVycigwKTtcbiAgICB2YXIgc3QgPSAwLCBidHIgPSBodS5iLCBwb3MgPSAobGVuIDw8IDMpIC0gOCArIG1zYihsYikgLSBidHIsIGkgPSAtMTtcbiAgICBmb3IgKDsgcG9zID4gZWIgJiYgaSA8IHNzOykge1xuICAgICAgICB2YXIgY2J0ID0gcG9zID4+IDM7XG4gICAgICAgIHZhciB2YWwgPSAoZGF0W2NidF0gfCAoZGF0W2NidCArIDFdIDw8IDgpIHwgKGRhdFtjYnQgKyAyXSA8PCAxNikpID4+IChwb3MgJiA3KTtcbiAgICAgICAgc3QgPSAoKHN0IDw8IGJ0cikgfCB2YWwpICYgbXNrO1xuICAgICAgICBvdXRbKytpXSA9IGh1LnNbc3RdO1xuICAgICAgICBwb3MgLT0gKGJ0ciA9IGh1Lm5bc3RdKTtcbiAgICB9XG4gICAgaWYgKHBvcyAhPSBlYiB8fCBpICsgMSAhPSBzcylcbiAgICAgICAgZXJyKDApO1xufTtcbi8vIGRlY29kZSBodWZmbWFuIHN0cmVhbSA0eFxuLy8gVE9ETzogdXNlIHdvcmtlcnMgdG8gcGFyYWxsZWxpemVcbnZhciBkaHU0ID0gZnVuY3Rpb24gKGRhdCwgb3V0LCBodSkge1xuICAgIHZhciBidCA9IDY7XG4gICAgdmFyIHNzID0gb3V0Lmxlbmd0aCwgc3oxID0gKHNzICsgMykgPj4gMiwgc3oyID0gc3oxIDw8IDEsIHN6MyA9IHN6MSArIHN6MjtcbiAgICBkaHUoZGF0LnN1YmFycmF5KGJ0LCBidCArPSBkYXRbMF0gfCAoZGF0WzFdIDw8IDgpKSwgb3V0LnN1YmFycmF5KDAsIHN6MSksIGh1KTtcbiAgICBkaHUoZGF0LnN1YmFycmF5KGJ0LCBidCArPSBkYXRbMl0gfCAoZGF0WzNdIDw8IDgpKSwgb3V0LnN1YmFycmF5KHN6MSwgc3oyKSwgaHUpO1xuICAgIGRodShkYXQuc3ViYXJyYXkoYnQsIGJ0ICs9IGRhdFs0XSB8IChkYXRbNV0gPDwgOCkpLCBvdXQuc3ViYXJyYXkoc3oyLCBzejMpLCBodSk7XG4gICAgZGh1KGRhdC5zdWJhcnJheShidCksIG91dC5zdWJhcnJheShzejMpLCBodSk7XG59O1xuLy8gcmVhZCBac3RhbmRhcmQgYmxvY2tcbnZhciByemIgPSBmdW5jdGlvbiAoZGF0LCBzdCwgb3V0KSB7XG4gICAgdmFyIF9hO1xuICAgIHZhciBidCA9IHN0LmI7XG4gICAgLy8gICAgYnl0ZSAwICAgICAgICBibG9jayB0eXBlXG4gICAgdmFyIGIwID0gZGF0W2J0XSwgYnR5cGUgPSAoYjAgPj4gMSkgJiAzO1xuICAgIHN0LmwgPSBiMCAmIDE7XG4gICAgdmFyIHN6ID0gKGIwID4+IDMpIHwgKGRhdFtidCArIDFdIDw8IDUpIHwgKGRhdFtidCArIDJdIDw8IDEzKTtcbiAgICAvLyBlbmQgYnl0ZSBmb3IgYmxvY2tcbiAgICB2YXIgZWJ0ID0gKGJ0ICs9IDMpICsgc3o7XG4gICAgaWYgKGJ0eXBlID09IDEpIHtcbiAgICAgICAgaWYgKGJ0ID49IGRhdC5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHN0LmIgPSBidCArIDE7XG4gICAgICAgIGlmIChvdXQpIHtcbiAgICAgICAgICAgIGZpbGwob3V0LCBkYXRbYnRdLCBzdC55LCBzdC55ICs9IHN6KTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpbGwobmV3IHU4KHN6KSwgZGF0W2J0XSk7XG4gICAgfVxuICAgIGlmIChlYnQgPiBkYXQubGVuZ3RoKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKGJ0eXBlID09IDApIHtcbiAgICAgICAgc3QuYiA9IGVidDtcbiAgICAgICAgaWYgKG91dCkge1xuICAgICAgICAgICAgb3V0LnNldChkYXQuc3ViYXJyYXkoYnQsIGVidCksIHN0LnkpO1xuICAgICAgICAgICAgc3QueSArPSBzejtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNsYyhkYXQsIGJ0LCBlYnQpO1xuICAgIH1cbiAgICBpZiAoYnR5cGUgPT0gMikge1xuICAgICAgICAvLyAgICBieXRlIDMgICAgICAgIGxpdCBidHlwZSAgICAgc2l6ZSBmb3JtYXRcbiAgICAgICAgdmFyIGIzID0gZGF0W2J0XSwgbGJ0ID0gYjMgJiAzLCBzZiA9IChiMyA+PiAyKSAmIDM7XG4gICAgICAgIC8vIGxpdCBzcmMgc2l6ZSAgbGl0IGNtcCBzeiA0IHN0cmVhbXNcbiAgICAgICAgdmFyIGxzcyA9IGIzID4+IDQsIGxjcyA9IDAsIHM0ID0gMDtcbiAgICAgICAgaWYgKGxidCA8IDIpIHtcbiAgICAgICAgICAgIGlmIChzZiAmIDEpXG4gICAgICAgICAgICAgICAgbHNzIHw9IChkYXRbKytidF0gPDwgNCkgfCAoKHNmICYgMikgJiYgKGRhdFsrK2J0XSA8PCAxMikpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGxzcyA9IGIzID4+IDM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzNCA9IHNmO1xuICAgICAgICAgICAgaWYgKHNmIDwgMilcbiAgICAgICAgICAgICAgICBsc3MgfD0gKChkYXRbKytidF0gJiA2MykgPDwgNCksIGxjcyA9IChkYXRbYnRdID4+IDYpIHwgKGRhdFsrK2J0XSA8PCAyKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHNmID09IDIpXG4gICAgICAgICAgICAgICAgbHNzIHw9IChkYXRbKytidF0gPDwgNCkgfCAoKGRhdFsrK2J0XSAmIDMpIDw8IDEyKSwgbGNzID0gKGRhdFtidF0gPj4gMikgfCAoZGF0WysrYnRdIDw8IDYpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGxzcyB8PSAoZGF0WysrYnRdIDw8IDQpIHwgKChkYXRbKytidF0gJiA2MykgPDwgMTIpLCBsY3MgPSAoZGF0W2J0XSA+PiA2KSB8IChkYXRbKytidF0gPDwgMikgfCAoZGF0WysrYnRdIDw8IDEwKTtcbiAgICAgICAgfVxuICAgICAgICArK2J0O1xuICAgICAgICAvLyBhZGQgbGl0ZXJhbHMgdG8gZW5kIC0gY2FuIG5ldmVyIG92ZXJsYXAgd2l0aCBiYWNrcmVmZXJlbmNlcyBiZWNhdXNlIHVudXNlZCBsaXRlcmFscyBhbHdheXMgYXBwZW5kZWRcbiAgICAgICAgdmFyIGJ1ZiA9IG91dCA/IG91dC5zdWJhcnJheShzdC55LCBzdC55ICsgc3QubSkgOiBuZXcgdTgoc3QubSk7XG4gICAgICAgIC8vIHN0YXJ0aW5nIHBvaW50IGZvciBsaXRlcmFsc1xuICAgICAgICB2YXIgc3BsID0gYnVmLmxlbmd0aCAtIGxzcztcbiAgICAgICAgaWYgKGxidCA9PSAwKVxuICAgICAgICAgICAgYnVmLnNldChkYXQuc3ViYXJyYXkoYnQsIGJ0ICs9IGxzcyksIHNwbCk7XG4gICAgICAgIGVsc2UgaWYgKGxidCA9PSAxKVxuICAgICAgICAgICAgZmlsbChidWYsIGRhdFtidCsrXSwgc3BsKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBodWZmbWFuIHRhYmxlXG4gICAgICAgICAgICB2YXIgaHUgPSBzdC5oO1xuICAgICAgICAgICAgaWYgKGxidCA9PSAyKSB7XG4gICAgICAgICAgICAgICAgdmFyIGh1ZCA9IHJodShkYXQsIGJ0KTtcbiAgICAgICAgICAgICAgICAvLyBzdWJ0cmFjdCBkZXNjcmlwdGlvbiBsZW5ndGhcbiAgICAgICAgICAgICAgICBsY3MgKz0gYnQgLSAoYnQgPSBodWRbMF0pO1xuICAgICAgICAgICAgICAgIHN0LmggPSBodSA9IGh1ZFsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFodSlcbiAgICAgICAgICAgICAgICBlcnIoMCk7XG4gICAgICAgICAgICAoczQgPyBkaHU0IDogZGh1KShkYXQuc3ViYXJyYXkoYnQsIGJ0ICs9IGxjcyksIGJ1Zi5zdWJhcnJheShzcGwpLCBodSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbnVtIHNlcXVlbmNlc1xuICAgICAgICB2YXIgbnMgPSBkYXRbYnQrK107XG4gICAgICAgIGlmIChucykge1xuICAgICAgICAgICAgaWYgKG5zID09IDI1NSlcbiAgICAgICAgICAgICAgICBucyA9IChkYXRbYnQrK10gfCAoZGF0W2J0KytdIDw8IDgpKSArIDB4N0YwMDtcbiAgICAgICAgICAgIGVsc2UgaWYgKG5zID4gMTI3KVxuICAgICAgICAgICAgICAgIG5zID0gKChucyAtIDEyOCkgPDwgOCkgfCBkYXRbYnQrK107XG4gICAgICAgICAgICAvLyBzeW1ib2wgY29tcHJlc3Npb24gbW9kZXNcbiAgICAgICAgICAgIHZhciBzY20gPSBkYXRbYnQrK107XG4gICAgICAgICAgICBpZiAoc2NtICYgMylcbiAgICAgICAgICAgICAgICBlcnIoMCk7XG4gICAgICAgICAgICB2YXIgZHRzID0gW2RtbHQsIGRvY3QsIGRsbHRdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDI7IGkgPiAtMTsgLS1pKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1kID0gKHNjbSA+PiAoKGkgPDwgMSkgKyAyKSkgJiAzO1xuICAgICAgICAgICAgICAgIGlmIChtZCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJsZSBidWZcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJidWYgPSBuZXcgdTgoWzAsIDAsIGRhdFtidCsrXV0pO1xuICAgICAgICAgICAgICAgICAgICBkdHNbaV0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzOiByYnVmLnN1YmFycmF5KDIsIDMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbjogcmJ1Zi5zdWJhcnJheSgwLCAxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHQ6IG5ldyB1MTYocmJ1Zi5idWZmZXIsIDAsIDEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYjogMFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtZCA9PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFjY3VyYWN5IGxvZyA4IGZvciBvZmZzZXRzLCA5IGZvciBvdGhlcnNcbiAgICAgICAgICAgICAgICAgICAgX2EgPSByZnNlKGRhdCwgYnQsIDkgLSAoaSAmIDEpKSwgYnQgPSBfYVswXSwgZHRzW2ldID0gX2FbMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1kID09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzdC50KVxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyKDApO1xuICAgICAgICAgICAgICAgICAgICBkdHNbaV0gPSBzdC50W2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfYiA9IHN0LnQgPSBkdHMsIG1sdCA9IF9iWzBdLCBvY3QgPSBfYlsxXSwgbGx0ID0gX2JbMl07XG4gICAgICAgICAgICB2YXIgbGIgPSBkYXRbZWJ0IC0gMV07XG4gICAgICAgICAgICBpZiAoIWxiKVxuICAgICAgICAgICAgICAgIGVycigwKTtcbiAgICAgICAgICAgIHZhciBzcG9zID0gKGVidCA8PCAzKSAtIDggKyBtc2IobGIpIC0gbGx0LmIsIGNidCA9IHNwb3MgPj4gMywgb3VidCA9IDA7XG4gICAgICAgICAgICB2YXIgbHN0ID0gKChkYXRbY2J0XSB8IChkYXRbY2J0ICsgMV0gPDwgOCkpID4+IChzcG9zICYgNykpICYgKCgxIDw8IGxsdC5iKSAtIDEpO1xuICAgICAgICAgICAgY2J0ID0gKHNwb3MgLT0gb2N0LmIpID4+IDM7XG4gICAgICAgICAgICB2YXIgb3N0ID0gKChkYXRbY2J0XSB8IChkYXRbY2J0ICsgMV0gPDwgOCkpID4+IChzcG9zICYgNykpICYgKCgxIDw8IG9jdC5iKSAtIDEpO1xuICAgICAgICAgICAgY2J0ID0gKHNwb3MgLT0gbWx0LmIpID4+IDM7XG4gICAgICAgICAgICB2YXIgbXN0ID0gKChkYXRbY2J0XSB8IChkYXRbY2J0ICsgMV0gPDwgOCkpID4+IChzcG9zICYgNykpICYgKCgxIDw8IG1sdC5iKSAtIDEpO1xuICAgICAgICAgICAgZm9yICgrK25zOyAtLW5zOykge1xuICAgICAgICAgICAgICAgIHZhciBsbGMgPSBsbHQuc1tsc3RdO1xuICAgICAgICAgICAgICAgIHZhciBsYnRyID0gbGx0Lm5bbHN0XTtcbiAgICAgICAgICAgICAgICB2YXIgbWxjID0gbWx0LnNbbXN0XTtcbiAgICAgICAgICAgICAgICB2YXIgbWJ0ciA9IG1sdC5uW21zdF07XG4gICAgICAgICAgICAgICAgdmFyIG9mYyA9IG9jdC5zW29zdF07XG4gICAgICAgICAgICAgICAgdmFyIG9idHIgPSBvY3Qubltvc3RdO1xuICAgICAgICAgICAgICAgIGNidCA9IChzcG9zIC09IG9mYykgPj4gMztcbiAgICAgICAgICAgICAgICB2YXIgb2ZwID0gMSA8PCBvZmM7XG4gICAgICAgICAgICAgICAgdmFyIG9mZiA9IG9mcCArICgoKGRhdFtjYnRdIHwgKGRhdFtjYnQgKyAxXSA8PCA4KSB8IChkYXRbY2J0ICsgMl0gPDwgMTYpIHwgKGRhdFtjYnQgKyAzXSA8PCAyNCkpID4+PiAoc3BvcyAmIDcpKSAmIChvZnAgLSAxKSk7XG4gICAgICAgICAgICAgICAgY2J0ID0gKHNwb3MgLT0gbWxiW21sY10pID4+IDM7XG4gICAgICAgICAgICAgICAgdmFyIG1sID0gbWxibFttbGNdICsgKCgoZGF0W2NidF0gfCAoZGF0W2NidCArIDFdIDw8IDgpIHwgKGRhdFtjYnQgKyAyXSA8PCAxNikpID4+IChzcG9zICYgNykpICYgKCgxIDw8IG1sYlttbGNdKSAtIDEpKTtcbiAgICAgICAgICAgICAgICBjYnQgPSAoc3BvcyAtPSBsbGJbbGxjXSkgPj4gMztcbiAgICAgICAgICAgICAgICB2YXIgbGwgPSBsbGJsW2xsY10gKyAoKChkYXRbY2J0XSB8IChkYXRbY2J0ICsgMV0gPDwgOCkgfCAoZGF0W2NidCArIDJdIDw8IDE2KSkgPj4gKHNwb3MgJiA3KSkgJiAoKDEgPDwgbGxiW2xsY10pIC0gMSkpO1xuICAgICAgICAgICAgICAgIGNidCA9IChzcG9zIC09IGxidHIpID4+IDM7XG4gICAgICAgICAgICAgICAgbHN0ID0gbGx0LnRbbHN0XSArICgoKGRhdFtjYnRdIHwgKGRhdFtjYnQgKyAxXSA8PCA4KSkgPj4gKHNwb3MgJiA3KSkgJiAoKDEgPDwgbGJ0cikgLSAxKSk7XG4gICAgICAgICAgICAgICAgY2J0ID0gKHNwb3MgLT0gbWJ0cikgPj4gMztcbiAgICAgICAgICAgICAgICBtc3QgPSBtbHQudFttc3RdICsgKCgoZGF0W2NidF0gfCAoZGF0W2NidCArIDFdIDw8IDgpKSA+PiAoc3BvcyAmIDcpKSAmICgoMSA8PCBtYnRyKSAtIDEpKTtcbiAgICAgICAgICAgICAgICBjYnQgPSAoc3BvcyAtPSBvYnRyKSA+PiAzO1xuICAgICAgICAgICAgICAgIG9zdCA9IG9jdC50W29zdF0gKyAoKChkYXRbY2J0XSB8IChkYXRbY2J0ICsgMV0gPDwgOCkpID4+IChzcG9zICYgNykpICYgKCgxIDw8IG9idHIpIC0gMSkpO1xuICAgICAgICAgICAgICAgIGlmIChvZmYgPiAzKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0Lm9bMl0gPSBzdC5vWzFdO1xuICAgICAgICAgICAgICAgICAgICBzdC5vWzFdID0gc3Qub1swXTtcbiAgICAgICAgICAgICAgICAgICAgc3Qub1swXSA9IG9mZiAtPSAzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlkeCA9IG9mZiAtIChsbCAhPSAwKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlkeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2ZmID0gaWR4ID09IDMgPyBzdC5vWzBdIC0gMSA6IHN0Lm9baWR4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpZHggPiAxKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0Lm9bMl0gPSBzdC5vWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3Qub1sxXSA9IHN0Lm9bMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBzdC5vWzBdID0gb2ZmO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZiA9IHN0Lm9bMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGw7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBidWZbb3VidCArIGldID0gYnVmW3NwbCArIGldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvdWJ0ICs9IGxsLCBzcGwgKz0gbGw7XG4gICAgICAgICAgICAgICAgdmFyIHN0aW4gPSBvdWJ0IC0gb2ZmO1xuICAgICAgICAgICAgICAgIGlmIChzdGluIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGVuID0gLXN0aW47XG4gICAgICAgICAgICAgICAgICAgIHZhciBicyA9IHN0LmUgKyBzdGluO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGVuID4gbWwpXG4gICAgICAgICAgICAgICAgICAgICAgICBsZW4gPSBtbDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVmW291YnQgKyBpXSA9IHN0LndbYnMgKyBpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvdWJ0ICs9IGxlbiwgbWwgLT0gbGVuLCBzdGluID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtbDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZltvdWJ0ICsgaV0gPSBidWZbc3RpbiArIGldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvdWJ0ICs9IG1sO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG91YnQgIT0gc3BsKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHNwbCA8IGJ1Zi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmW291YnQrK10gPSBidWZbc3BsKytdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBvdWJ0ID0gYnVmLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChvdXQpXG4gICAgICAgICAgICAgICAgc3QueSArPSBvdWJ0O1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGJ1ZiA9IHNsYyhidWYsIDAsIG91YnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKG91dCkge1xuICAgICAgICAgICAgICAgIHN0LnkgKz0gbHNzO1xuICAgICAgICAgICAgICAgIGlmIChzcGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsc3M7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVmW2ldID0gYnVmW3NwbCArIGldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3BsKVxuICAgICAgICAgICAgICAgIGJ1ZiA9IHNsYyhidWYsIHNwbCk7XG4gICAgICAgIH1cbiAgICAgICAgc3QuYiA9IGVidDtcbiAgICAgICAgcmV0dXJuIGJ1ZjtcbiAgICB9XG4gICAgZXJyKDIpO1xufTtcbi8vIGNvbmNhdFxudmFyIGNjdCA9IGZ1bmN0aW9uIChidWZzLCBvbCkge1xuICAgIGlmIChidWZzLmxlbmd0aCA9PSAxKVxuICAgICAgICByZXR1cm4gYnVmc1swXTtcbiAgICB2YXIgYnVmID0gbmV3IHU4KG9sKTtcbiAgICBmb3IgKHZhciBpID0gMCwgYiA9IDA7IGkgPCBidWZzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBjaGsgPSBidWZzW2ldO1xuICAgICAgICBidWYuc2V0KGNoaywgYik7XG4gICAgICAgIGIgKz0gY2hrLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIGJ1Zjtcbn07XG4vKipcbiAqIERlY29tcHJlc3NlcyBac3RhbmRhcmQgZGF0YVxuICogQHBhcmFtIGRhdCBUaGUgaW5wdXQgZGF0YVxuICogQHBhcmFtIGJ1ZiBUaGUgb3V0cHV0IGJ1ZmZlci4gSWYgdW5zcGVjaWZpZWQsIHRoZSBmdW5jdGlvbiB3aWxsIGFsbG9jYXRlXG4gKiAgICAgICAgICAgIGV4YWN0bHkgZW5vdWdoIG1lbW9yeSB0byBmaXQgdGhlIGRlY29tcHJlc3NlZCBkYXRhLiBJZiB5b3VyXG4gKiAgICAgICAgICAgIGRhdGEgaGFzIG11bHRpcGxlIGZyYW1lcyBhbmQgeW91IGtub3cgdGhlIG91dHB1dCBzaXplLCBzcGVjaWZ5aW5nXG4gKiAgICAgICAgICAgIGl0IHdpbGwgeWllbGQgYmV0dGVyIHBlcmZvcm1hbmNlLlxuICogQHJldHVybnMgVGhlIGRlY29tcHJlc3NlZCBkYXRhXG4gKi9cbnJldHVybiBmdW5jdGlvbiBkZWNvbXByZXNzKGRhdCwgYnVmKSB7XG4gICAgdmFyIGJ0ID0gMCwgYnVmcyA9IFtdLCBuYiA9ICshYnVmLCBvbCA9IDA7XG4gICAgZm9yICg7IGRhdC5sZW5ndGg7KSB7XG4gICAgICAgIHZhciBzdCA9IHJ6ZmgoZGF0LCBuYiB8fCBidWYpO1xuICAgICAgICBpZiAodHlwZW9mIHN0ID09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBpZiAobmIpIHtcbiAgICAgICAgICAgICAgICBidWYgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChzdC53Lmxlbmd0aCA9PSBzdC51KSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZnMucHVzaChidWYgPSBzdC53KTtcbiAgICAgICAgICAgICAgICAgICAgb2wgKz0gc3QudTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBidWZzLnB1c2goYnVmKTtcbiAgICAgICAgICAgICAgICBzdC5lID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoOyAhc3QubDspIHtcbiAgICAgICAgICAgICAgICB2YXIgYmxrID0gcnpiKGRhdCwgc3QsIGJ1Zik7XG4gICAgICAgICAgICAgICAgaWYgKCFibGspXG4gICAgICAgICAgICAgICAgICAgIGVycig1KTtcbiAgICAgICAgICAgICAgICBpZiAoYnVmKVxuICAgICAgICAgICAgICAgICAgICBzdC5lID0gc3QueTtcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmcy5wdXNoKGJsayk7XG4gICAgICAgICAgICAgICAgICAgIG9sICs9IGJsay5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGNwdyhzdC53LCAwLCBibGsubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgc3Qudy5zZXQoYmxrLCBzdC53Lmxlbmd0aCAtIGJsay5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ0ID0gc3QuYiArIChzdC5jICogNCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgYnQgPSBzdDtcbiAgICAgICAgZGF0ID0gZGF0LnN1YmFycmF5KGJ0KTtcbiAgICB9XG4gICAgcmV0dXJuIGNjdChidWZzLCBvbCk7XG59XG59KSAoKVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfZGVjb21wcmVzc19pbnB1dFxuLy9WZXJzaW9uOiA8IDUuMS4wXG52YXIgY2FtbF9kZWNvbXByZXNzX2lucHV0ID0gbnVsbFxuXG4vL1Byb3ZpZGVzOiBjYW1sX2RlY29tcHJlc3NfaW5wdXRcbi8vVmVyc2lvbjogPj0gNS4xLjBcbi8vVmVyc2lvbjogPCA1LjEuMVxuLy9SZXF1aXJlczogenN0ZF9kZWNvbXByZXNzXG52YXIgY2FtbF9kZWNvbXByZXNzX2lucHV0ID0genN0ZF9kZWNvbXByZXNzO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2RlY29tcHJlc3NfaW5wdXRcbi8vVmVyc2lvbjogPj0gNS4xLjFcbi8vVmVyc2lvbjogPCA1LjIuMFxudmFyIGNhbWxfZGVjb21wcmVzc19pbnB1dCA9IG51bGxcblxuLy9Qcm92aWRlczogY2FtbF9kZWNvbXByZXNzX2lucHV0XG4vL1ZlcnNpb246ID49IDUuMlxuLy9SZXF1aXJlczogenN0ZF9kZWNvbXByZXNzXG52YXIgY2FtbF9kZWNvbXByZXNzX2lucHV0ID0genN0ZF9kZWNvbXByZXNzO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX3pzdGRfaW5pdGlhbGl6ZVxuLy9SZXF1aXJlczogY2FtbF9kZWNvbXByZXNzX2lucHV0XG4vL1JlcXVpcmVzOiB6c3RkX2RlY29tcHJlc3Ncbi8vVmVyc2lvbjogPj0gNS4xLjFcbmZ1bmN0aW9uIGNhbWxfenN0ZF9pbml0aWFsaXplKHVuaXQpIHtcbiAgY2FtbF9kZWNvbXByZXNzX2lucHV0ID0genN0ZF9kZWNvbXByZXNzO1xuICByZXR1cm4gMVxufVxuXG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8gV2VhayBBUElcblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2tleV9vZmZzZXRcbnZhciBjYW1sX2VwaGVfa2V5X29mZnNldCA9IDNcblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XG52YXIgY2FtbF9lcGhlX2RhdGFfb2Zmc2V0ID0gMlxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfc2V0X2tleVxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2VwaGVfa2V5X29mZnNldFxuZnVuY3Rpb24gY2FtbF9lcGhlX3NldF9rZXkoeCwgaSwgdikge1xuICBpZihpIDwgMCB8fCBjYW1sX2VwaGVfa2V5X29mZnNldCArIGkgPj0geC5sZW5ndGgpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50IChcIldlYWsuc2V0XCIpO1xuICBpZiAodiBpbnN0YW5jZW9mIE9iamVjdCAmJiBnbG9iYWxUaGlzLldlYWtSZWYpIHtcbiAgICBpZih4WzFdLnJlZ2lzdGVyKSB4WzFdLnJlZ2lzdGVyKHYsIHVuZGVmaW5lZCwgdik7XG4gICAgeFtjYW1sX2VwaGVfa2V5X29mZnNldCArIGldID0gbmV3IGdsb2JhbFRoaXMuV2Vha1JlZih2KTtcbiAgfVxuICBlbHNlIHhbY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpXSA9IHY7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV91bnNldF9rZXlcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9lcGhlX2tleV9vZmZzZXRcbmZ1bmN0aW9uIGNhbWxfZXBoZV91bnNldF9rZXkoeCwgaSkge1xuICBpZihpIDwgMCB8fCBjYW1sX2VwaGVfa2V5X29mZnNldCArIGkgPj0geC5sZW5ndGgpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50IChcIldlYWsuc2V0XCIpO1xuICBpZihnbG9iYWxUaGlzLldlYWtSZWYgJiYgeFtjYW1sX2VwaGVfa2V5X29mZnNldCArIGldIGluc3RhbmNlb2YgZ2xvYmFsVGhpcy5XZWFrUmVmICYmIHhbMV0udW5yZWdpc3Rlcikge1xuICAgIHZhciBvbGQgPSB4W2NhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaV0uZGVyZWYoKTtcbiAgICBpZihvbGQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGNvdW50ID0gMFxuICAgICAgZm9yKHZhciBqID0gY2FtbF9lcGhlX2tleV9vZmZzZXQ7IGogPCB4Lmxlbmd0aDsgaisrKXtcbiAgICAgICAgdmFyIGtleSA9IHhbal07XG4gICAgICAgIGlmKGtleSBpbnN0YW5jZW9mIGdsb2JhbFRoaXMuV2Vha1JlZil7XG4gICAgICAgICAga2V5ID0ga2V5LmRlcmVmKClcbiAgICAgICAgICBpZihrZXkgPT09IG9sZCkgY291bnQrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYoY291bnQgPT0gMSkgeFsxXS51bnJlZ2lzdGVyKG9sZCk7XG4gICAgfVxuICB9XG4gIHhbY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpXSA9IHVuZGVmaW5lZDtcbiAgcmV0dXJuIDBcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfY3JlYXRlXG4vL1JlcXVpcmVzOiBjYW1sX3dlYWtfY3JlYXRlLCBjYW1sX2VwaGVfZGF0YV9vZmZzZXRcbmZ1bmN0aW9uIGNhbWxfZXBoZV9jcmVhdGUgKG4pIHtcbiAgdmFyIHggPSBjYW1sX3dlYWtfY3JlYXRlKG4pO1xuICByZXR1cm4geDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF93ZWFrX2NyZWF0ZVxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2tleV9vZmZzZXQsIGNhbWxfaW52YWxpZF9hcmd1bWVudCxjYW1sX2VwaGVfZGF0YV9vZmZzZXRcbmZ1bmN0aW9uIGNhbWxfd2Vha19jcmVhdGUgKG4pIHtcbiAgaWYgKG4gPCAwKSBjYW1sX2ludmFsaWRfYXJndW1lbnQgKFwiV2Vhay5jcmVhdGVcIik7XG4gIHZhciB4ID0gWzI1MSxcImNhbWxfZXBoZV9saXN0X2hlYWRcIl07XG4gIHgubGVuZ3RoID0gY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBuO1xuICByZXR1cm4geDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF93ZWFrX3NldFxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfc2V0X2tleSwgY2FtbF9lcGhlX3Vuc2V0X2tleVxuZnVuY3Rpb24gY2FtbF93ZWFrX3NldCh4LCBpLCB2KSB7XG4gIGlmKHYgPT0gMCkgY2FtbF9lcGhlX3Vuc2V0X2tleSh4LGkpXG4gIGVsc2UgY2FtbF9lcGhlX3NldF9rZXkoeCxpLHZbMV0pXG4gIHJldHVybiAwO1xufVxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2dldF9rZXlcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9rZXlfb2Zmc2V0LCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbi8vQWxpYXM6IGNhbWxfd2Vha19nZXRcbmZ1bmN0aW9uIGNhbWxfZXBoZV9nZXRfa2V5KHgsIGkpIHtcbiAgaWYoaSA8IDAgfHwgY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpID49IHgubGVuZ3RoKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudCAoXCJXZWFrLmdldF9rZXlcIik7XG4gIHZhciB3ZWFrID0geFtjYW1sX2VwaGVfa2V5X29mZnNldCArIGkgXTtcbiAgaWYoZ2xvYmFsVGhpcy5XZWFrUmVmICYmIHdlYWsgaW5zdGFuY2VvZiBnbG9iYWxUaGlzLldlYWtSZWYpIHdlYWsgPSB3ZWFrLmRlcmVmKCk7XG4gIHJldHVybiAod2Vhaz09PXVuZGVmaW5lZCk/MDpbMCwgd2Vha107XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfZ2V0X2tleV9jb3B5XG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfZ2V0X2tleSxjYW1sX2VwaGVfa2V5X29mZnNldFxuLy9SZXF1aXJlczogY2FtbF9vYmpfZHVwLCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbi8vQWxpYXM6IGNhbWxfd2Vha19nZXRfY29weVxuZnVuY3Rpb24gY2FtbF9lcGhlX2dldF9rZXlfY29weSh4LCBpKSB7XG4gIGlmKGkgPCAwIHx8IGNhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaSA+PSB4Lmxlbmd0aClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQgKFwiV2Vhay5nZXRfY29weVwiKTtcbiAgdmFyIHkgPSBjYW1sX2VwaGVfZ2V0X2tleSh4LCBpKTtcbiAgaWYgKHkgPT09IDApIHJldHVybiB5O1xuICB2YXIgeiA9IHlbMV07XG4gIGlmICh6IGluc3RhbmNlb2YgQXJyYXkpIHJldHVybiBbMCwgY2FtbF9vYmpfZHVwKHopXTtcbiAgcmV0dXJuIHk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9jaGVja19rZXkgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2tleV9vZmZzZXRcbi8vQWxpYXM6IGNhbWxfd2Vha19jaGVja1xuZnVuY3Rpb24gY2FtbF9lcGhlX2NoZWNrX2tleSh4LCBpKSB7XG4gIHZhciB3ZWFrID0geFtjYW1sX2VwaGVfa2V5X29mZnNldCArIGldO1xuICBpZihnbG9iYWxUaGlzLldlYWtSZWYgJiYgd2VhayBpbnN0YW5jZW9mIGdsb2JhbFRoaXMuV2Vha1JlZikgd2VhayA9IHdlYWsuZGVyZWYoKTtcbiAgaWYod2Vhaz09PXVuZGVmaW5lZClcbiAgICByZXR1cm4gMDtcbiAgZWxzZVxuICAgIHJldHVybiAxO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfYmxpdF9rZXlcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYmxpdFxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2tleV9vZmZzZXRcbi8vQWxpYXM6IGNhbWxfd2Vha19ibGl0XG5mdW5jdGlvbiBjYW1sX2VwaGVfYmxpdF9rZXkoYTEsIGkxLCBhMiwgaTIsIGxlbikge1xuICAvLyBtaW51cyBvbmUgYmVjYXVzZSBjYW1sX2FycmF5X2JsaXQgd29ya3Mgb24gb2NhbWwgYXJyYXlcbiAgY2FtbF9hcnJheV9ibGl0KGExLCBjYW1sX2VwaGVfa2V5X29mZnNldCArIGkxIC0gMSxcbiAgICAgICAgICAgICAgICAgIGEyLCBjYW1sX2VwaGVfa2V5X29mZnNldCArIGkyIC0gMSxcbiAgICAgICAgICAgICAgICAgIGxlbik7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfYmxpdF9kYXRhXG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfZGF0YV9vZmZzZXQsIGNhbWxfZXBoZV9zZXRfZGF0YSwgY2FtbF9lcGhlX3Vuc2V0X2RhdGFcbmZ1bmN0aW9uIGNhbWxfZXBoZV9ibGl0X2RhdGEoc3JjLCBkc3Qpe1xuICB2YXIgbiA9IHNyY1tjYW1sX2VwaGVfZGF0YV9vZmZzZXRdO1xuICBpZihuID09PSB1bmRlZmluZWQpIGNhbWxfZXBoZV91bnNldF9kYXRhKGRzdCk7XG4gIGVsc2UgY2FtbF9lcGhlX3NldF9kYXRhKGRzdCwgbik7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfZ2V0X2RhdGFcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9kYXRhX29mZnNldFxuZnVuY3Rpb24gY2FtbF9lcGhlX2dldF9kYXRhKHgpe1xuICBpZih4W2NhbWxfZXBoZV9kYXRhX29mZnNldF0gPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gMDtcbiAgZWxzZVxuICAgIHJldHVybiBbMCwgeFtjYW1sX2VwaGVfZGF0YV9vZmZzZXRdXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2dldF9kYXRhX2NvcHlcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9kYXRhX29mZnNldFxuLy9SZXF1aXJlczogY2FtbF9vYmpfZHVwXG5mdW5jdGlvbiBjYW1sX2VwaGVfZ2V0X2RhdGFfY29weSh4KXtcbiAgaWYoeFtjYW1sX2VwaGVfZGF0YV9vZmZzZXRdID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIDA7XG4gIGVsc2VcbiAgICByZXR1cm4gWzAsIGNhbWxfb2JqX2R1cCh4W2NhbWxfZXBoZV9kYXRhX29mZnNldF0pXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX3NldF9kYXRhXG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfZGF0YV9vZmZzZXQsIGNhbWxfZXBoZV9rZXlfb2Zmc2V0LCBjYW1sX2VwaGVfdW5zZXRfZGF0YVxuZnVuY3Rpb24gY2FtbF9lcGhlX3NldF9kYXRhKHgsIGRhdGEpe1xuICBpZihnbG9iYWxUaGlzLkZpbmFsaXphdGlvblJlZ2lzdHJ5ICYmIGdsb2JhbFRoaXMuV2Vha1JlZikge1xuICAgIGlmKCEgKHhbMV0gaW5zdGFuY2VvZiBnbG9iYWxUaGlzLkZpbmFsaXphdGlvblJlZ2lzdHJ5KSkge1xuICAgICAgeFsxXSA9IG5ldyBnbG9iYWxUaGlzLkZpbmFsaXphdGlvblJlZ2lzdHJ5KGZ1bmN0aW9uICgpIHsgY2FtbF9lcGhlX3Vuc2V0X2RhdGEoeCkgfSk7XG4gICAgICAvL3JlZ2lzdGVyIGFsbCBrZXlzXG4gICAgICBmb3IodmFyIGogPSBjYW1sX2VwaGVfa2V5X29mZnNldDsgaiA8IHgubGVuZ3RoOyBqKyspe1xuICAgICAgICB2YXIga2V5ID0geFtqXTtcbiAgICAgICAgaWYoa2V5IGluc3RhbmNlb2YgZ2xvYmFsVGhpcy5XZWFrUmVmKSB7XG4gICAgICAgICAga2V5ID0ga2V5LmRlcmVmKCk7XG4gICAgICAgICAgaWYoa2V5KSB4WzFdLnJlZ2lzdGVyKGtleSwgdW5kZWZpbmVkLCBrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHhbY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XSA9IGRhdGE7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfdW5zZXRfZGF0YVxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2RhdGFfb2Zmc2V0LCBjYW1sX2VwaGVfa2V5X29mZnNldFxuZnVuY3Rpb24gY2FtbF9lcGhlX3Vuc2V0X2RhdGEoeCl7XG4gIGlmKGdsb2JhbFRoaXMuRmluYWxpemF0aW9uUmVnaXN0cnkgJiYgZ2xvYmFsVGhpcy5XZWFrUmVmKSB7XG4gICAgaWYoeFsxXSBpbnN0YW5jZW9mIGdsb2JhbFRoaXMuRmluYWxpemF0aW9uUmVnaXN0cnkpe1xuICAgICAgLy91bnJlZ2lzdGVyIGFsbCBrZXlzXG4gICAgICBmb3IodmFyIGogPSBjYW1sX2VwaGVfa2V5X29mZnNldDsgaiA8IHgubGVuZ3RoOyBqKyspe1xuICAgICAgICB2YXIga2V5ID0geFtqXTtcbiAgICAgICAgaWYoa2V5IGluc3RhbmNlb2YgZ2xvYmFsVGhpcy5XZWFrUmVmKSB7XG4gICAgICAgICAga2V5ID0ga2V5LmRlcmVmKCk7XG4gICAgICAgICAgaWYoa2V5KSB4WzFdLnVucmVnaXN0ZXIoa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICB4W2NhbWxfZXBoZV9kYXRhX29mZnNldF0gPSB1bmRlZmluZWQ7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfY2hlY2tfZGF0YVxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XG5mdW5jdGlvbiBjYW1sX2VwaGVfY2hlY2tfZGF0YSh4KXtcbiAgaWYoeFtjYW1sX2VwaGVfZGF0YV9vZmZzZXRdID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIDA7XG4gIGVsc2VcbiAgICByZXR1cm4gMTtcbn1cbiIsIlxuXG4vL1Byb3ZpZGVzOiBjYW1sX2djX21pbm9yXG5mdW5jdGlvbiBjYW1sX2djX21pbm9yKHVuaXQpe1xuICAvL2F2YWlsYWJsZSB3aXRoIFtub2RlIC0tZXhwb3NlLWdjXVxuICBpZih0eXBlb2YgZ2xvYmFsVGhpcy5nYyA9PSAnZnVuY3Rpb24nKSBnbG9iYWxUaGlzLmdjKHRydWUpO1xuICByZXR1cm4gMFxufVxuLy9Qcm92aWRlczogY2FtbF9nY19tYWpvclxuZnVuY3Rpb24gY2FtbF9nY19tYWpvcih1bml0KXtcbiAgLy9hdmFpbGFibGUgd2l0aCBbbm9kZSAtLWV4cG9zZS1nY11cbiAgaWYodHlwZW9mIGdsb2JhbFRoaXMuZ2MgPT0gJ2Z1bmN0aW9uJykgZ2xvYmFsVGhpcy5nYygpO1xuICByZXR1cm4gMFxufVxuLy9Qcm92aWRlczogY2FtbF9nY19mdWxsX21ham9yXG5mdW5jdGlvbiBjYW1sX2djX2Z1bGxfbWFqb3IodW5pdCl7XG4gIC8vYXZhaWxhYmxlIHdpdGggW25vZGUgLS1leHBvc2UtZ2NdXG4gIGlmKHR5cGVvZiBnbG9iYWxUaGlzLmdjID09ICdmdW5jdGlvbicpIGdsb2JhbFRoaXMuZ2MoKTtcbiAgcmV0dXJuIDBcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ2NfY29tcGFjdGlvblxuZnVuY3Rpb24gY2FtbF9nY19jb21wYWN0aW9uKCl7IHJldHVybiAwfVxuLy9Qcm92aWRlczogY2FtbF9nY19jb3VudGVyc1xuZnVuY3Rpb24gY2FtbF9nY19jb3VudGVycygpIHsgcmV0dXJuIFsyNTQsMCwwLDBdIH1cbi8vUHJvdmlkZXM6IGNhbWxfZ2NfcXVpY2tfc3RhdFxuLy9WZXJzaW9uOiA+PSA0LjEyXG5mdW5jdGlvbiBjYW1sX2djX3F1aWNrX3N0YXQoKXtcbiAgcmV0dXJuIFswLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMF1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9nY19xdWlja19zdGF0XG4vL1ZlcnNpb246IDwgNC4xMlxuZnVuY3Rpb24gY2FtbF9nY19xdWlja19zdGF0KCl7XG4gIHJldHVybiBbMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwXVxufVxuLy9Qcm92aWRlczogY2FtbF9nY19zdGF0XG4vL1JlcXVpcmVzOiBjYW1sX2djX3F1aWNrX3N0YXRcbmZ1bmN0aW9uIGNhbWxfZ2Nfc3RhdCgpIHtcbiAgcmV0dXJuIGNhbWxfZ2NfcXVpY2tfc3RhdCgpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2djX3NldFxuZnVuY3Rpb24gY2FtbF9nY19zZXQoX2NvbnRyb2wpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2NfZ2V0XG5mdW5jdGlvbiBjYW1sX2djX2dldCgpe1xuICByZXR1cm4gWzAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwXVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21lbXByb2Zfc2V0XG5mdW5jdGlvbiBjYW1sX21lbXByb2Zfc2V0KF9jb250cm9sKSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ZpbmFsX3JlZ2lzdGVyIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ZpbmFsX3JlZ2lzdGVyICgpIHsgcmV0dXJuIDA7IH1cblxuLy9Qcm92aWRlczogY2FtbF9maW5hbF9yZWdpc3Rlcl9jYWxsZWRfd2l0aG91dF92YWx1ZVxudmFyIGFsbF9maW5hbGl6ZXJzID0gbmV3IGdsb2JhbFRoaXMuU2V0KClcbmZ1bmN0aW9uIGNhbWxfZmluYWxfcmVnaXN0ZXJfY2FsbGVkX3dpdGhvdXRfdmFsdWUgKGNiLCBhKSB7XG4gIGlmKGdsb2JhbFRoaXMuRmluYWxpemF0aW9uUmVnaXN0cnkgJiYgYSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgIHZhciB4ID0gbmV3IGdsb2JhbFRoaXMuRmluYWxpemF0aW9uUmVnaXN0cnkoZnVuY3Rpb24gKHgpe2FsbF9maW5hbGl6ZXJzLmRlbGV0ZSh4KTsgY2IoMCk7IHJldHVybjt9KTtcbiAgICB4LnJlZ2lzdGVyKGEseCk7XG4gICAgYWxsX2ZpbmFsaXplcnMuYWRkKHgpO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ZpbmFsX3JlbGVhc2UgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZmluYWxfcmVsZWFzZSAoKSB7IHJldHVybiAwOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWVtcHJvZl9zdGFydFxuZnVuY3Rpb24gY2FtbF9tZW1wcm9mX3N0YXJ0KHJhdGUsc3RhY2tfc2l6ZSx0cmFja2VyKXtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWVtcHJvZl9zdG9wXG5mdW5jdGlvbiBjYW1sX21lbXByb2Zfc3RvcCh1bml0KSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21lbXByb2ZfZGlzY2FyZFxuZnVuY3Rpb24gY2FtbF9tZW1wcm9mX2Rpc2NhcmQodCkgeyByZXR1cm4gMCB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXZlbnRsb2dfcmVzdW1lXG5mdW5jdGlvbiBjYW1sX2V2ZW50bG9nX3Jlc3VtZSh1bml0KSB7IHJldHVybiAwOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXZlbnRsb2dfcGF1c2VcbmZ1bmN0aW9uIGNhbWxfZXZlbnRsb2dfcGF1c2UodW5pdCkgeyByZXR1cm4gMDsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2djX2h1Z2VfZmFsbGJhY2tfY291bnRcbmZ1bmN0aW9uIGNhbWxfZ2NfaHVnZV9mYWxsYmFja19jb3VudCh1bml0KSB7IHJldHVybiAwOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2NfbWFqb3Jfc2xpY2VcbmZ1bmN0aW9uIGNhbWxfZ2NfbWFqb3Jfc2xpY2Uod29yaykgeyByZXR1cm4gMDsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2djX21pbm9yX3dvcmRzXG5mdW5jdGlvbiBjYW1sX2djX21pbm9yX3dvcmRzKHVuaXQpIHsgcmV0dXJuIDA7IH1cblxuLy9Qcm92aWRlczogY2FtbF9nZXRfbWlub3JfZnJlZVxuZnVuY3Rpb24gY2FtbF9nZXRfbWlub3JfZnJlZSh1bml0KSB7IHJldHVybiAwOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2V0X21ham9yX2J1Y2tldFxuZnVuY3Rpb24gY2FtbF9nZXRfbWFqb3JfYnVja2V0KG4pIHsgcmV0dXJuIDA7IH1cblxuLy9Qcm92aWRlczogY2FtbF9nZXRfbWFqb3JfY3JlZGl0XG5mdW5jdGlvbiBjYW1sX2dldF9tYWpvcl9jcmVkaXQobikgeyByZXR1cm4gMDsgfVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8vLy8vLy8vLy8vLyBGb3JtYXRcblxuLy9Qcm92aWRlczogY2FtbF9wYXJzZV9mb3JtYXRcbi8vUmVxdWlyZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmcsIGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9wYXJzZV9mb3JtYXQgKGZtdCkge1xuICBmbXQgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKGZtdCk7XG4gIHZhciBsZW4gPSBmbXQubGVuZ3RoO1xuICBpZiAobGVuID4gMzEpIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImZvcm1hdF9pbnQ6IGZvcm1hdCB0b28gbG9uZ1wiKTtcbiAgdmFyIGYgPVxuICAgICAgeyBqdXN0aWZ5OicrJywgc2lnbnN0eWxlOictJywgZmlsbGVyOicgJywgYWx0ZXJuYXRlOmZhbHNlLFxuICAgICAgICBiYXNlOjAsIHNpZ25lZGNvbnY6ZmFsc2UsIHdpZHRoOjAsIHVwcGVyY2FzZTpmYWxzZSxcbiAgICAgICAgc2lnbjoxLCBwcmVjOi0xLCBjb252OidmJyB9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIGMgPSBmbXQuY2hhckF0KGkpO1xuICAgIHN3aXRjaCAoYykge1xuICAgIGNhc2UgJy0nOlxuICAgICAgZi5qdXN0aWZ5ID0gJy0nOyBicmVhaztcbiAgICBjYXNlICcrJzogY2FzZSAnICc6XG4gICAgICBmLnNpZ25zdHlsZSA9IGM7IGJyZWFrO1xuICAgIGNhc2UgJzAnOlxuICAgICAgZi5maWxsZXIgPSAnMCc7IGJyZWFrO1xuICAgIGNhc2UgJyMnOlxuICAgICAgZi5hbHRlcm5hdGUgPSB0cnVlOyBicmVhaztcbiAgICBjYXNlICcxJzogY2FzZSAnMic6IGNhc2UgJzMnOiBjYXNlICc0JzogY2FzZSAnNSc6XG4gICAgY2FzZSAnNic6IGNhc2UgJzcnOiBjYXNlICc4JzogY2FzZSAnOSc6XG4gICAgICBmLndpZHRoID0gMDtcbiAgICAgIHdoaWxlIChjPWZtdC5jaGFyQ29kZUF0KGkpIC0gNDgsIGMgPj0gMCAmJiBjIDw9IDkpIHtcbiAgICAgICAgZi53aWR0aCA9IGYud2lkdGggKiAxMCArIGM7IGkrK1xuICAgICAgfVxuICAgICAgaS0tO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnLic6XG4gICAgICBmLnByZWMgPSAwO1xuICAgICAgaSsrO1xuICAgICAgd2hpbGUgKGM9Zm10LmNoYXJDb2RlQXQoaSkgLSA0OCwgYyA+PSAwICYmIGMgPD0gOSkge1xuICAgICAgICBmLnByZWMgPSBmLnByZWMgKiAxMCArIGM7IGkrK1xuICAgICAgfVxuICAgICAgaS0tO1xuICAgIGNhc2UgJ2QnOiBjYXNlICdpJzpcbiAgICAgIGYuc2lnbmVkY29udiA9IHRydWU7IC8qIGZhbGx0aHJvdWdoICovXG4gICAgY2FzZSAndSc6XG4gICAgICBmLmJhc2UgPSAxMDsgYnJlYWs7XG4gICAgY2FzZSAneCc6XG4gICAgICBmLmJhc2UgPSAxNjsgYnJlYWs7XG4gICAgY2FzZSAnWCc6XG4gICAgICBmLmJhc2UgPSAxNjsgZi51cHBlcmNhc2UgPSB0cnVlOyBicmVhaztcbiAgICBjYXNlICdvJzpcbiAgICAgIGYuYmFzZSA9IDg7IGJyZWFrO1xuICAgIGNhc2UgJ2UnOiBjYXNlICdmJzogY2FzZSAnZyc6XG4gICAgICBmLnNpZ25lZGNvbnYgPSB0cnVlOyBmLmNvbnYgPSBjOyBicmVhaztcbiAgICBjYXNlICdFJzogY2FzZSAnRic6IGNhc2UgJ0cnOlxuICAgICAgZi5zaWduZWRjb252ID0gdHJ1ZTsgZi51cHBlcmNhc2UgPSB0cnVlO1xuICAgICAgZi5jb252ID0gYy50b0xvd2VyQ2FzZSAoKTsgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBmO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ZpbmlzaF9mb3JtYXR0aW5nXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX2ZpbmlzaF9mb3JtYXR0aW5nKGYsIHJhd2J1ZmZlcikge1xuICBpZiAoZi51cHBlcmNhc2UpIHJhd2J1ZmZlciA9IHJhd2J1ZmZlci50b1VwcGVyQ2FzZSgpO1xuICB2YXIgbGVuID0gcmF3YnVmZmVyLmxlbmd0aDtcbiAgLyogQWRqdXN0IGxlbiB0byByZWZsZWN0IGFkZGl0aW9uYWwgY2hhcnMgKHNpZ24sIGV0YykgKi9cbiAgaWYgKGYuc2lnbmVkY29udiAmJiAoZi5zaWduIDwgMCB8fCBmLnNpZ25zdHlsZSAhPSAnLScpKSBsZW4rKztcbiAgaWYgKGYuYWx0ZXJuYXRlKSB7XG4gICAgaWYgKGYuYmFzZSA9PSA4KSBsZW4gKz0gMTtcbiAgICBpZiAoZi5iYXNlID09IDE2KSBsZW4gKz0gMjtcbiAgfVxuICAvKiBEbyB0aGUgZm9ybWF0dGluZyAqL1xuICB2YXIgYnVmZmVyID0gXCJcIjtcbiAgaWYgKGYuanVzdGlmeSA9PSAnKycgJiYgZi5maWxsZXIgPT0gJyAnKVxuICAgIGZvciAodmFyIGkgPSBsZW47IGkgPCBmLndpZHRoOyBpKyspIGJ1ZmZlciArPSAnICc7XG4gIGlmIChmLnNpZ25lZGNvbnYpIHtcbiAgICBpZiAoZi5zaWduIDwgMCkgYnVmZmVyICs9ICctJztcbiAgICBlbHNlIGlmIChmLnNpZ25zdHlsZSAhPSAnLScpIGJ1ZmZlciArPSBmLnNpZ25zdHlsZTtcbiAgfVxuICBpZiAoZi5hbHRlcm5hdGUgJiYgZi5iYXNlID09IDgpIGJ1ZmZlciArPSAnMCc7XG4gIGlmIChmLmFsdGVybmF0ZSAmJiBmLmJhc2UgPT0gMTYpIGJ1ZmZlciArPSBmLnVwcGVyY2FzZT9cIjBYXCI6XCIweFwiO1xuICBpZiAoZi5qdXN0aWZ5ID09ICcrJyAmJiBmLmZpbGxlciA9PSAnMCcpXG4gICAgZm9yICh2YXIgaSA9IGxlbjsgaSA8IGYud2lkdGg7IGkrKykgYnVmZmVyICs9ICcwJztcbiAgYnVmZmVyICs9IHJhd2J1ZmZlcjtcbiAgaWYgKGYuanVzdGlmeSA9PSAnLScpXG4gICAgZm9yICh2YXIgaSA9IGxlbjsgaSA8IGYud2lkdGg7IGkrKykgYnVmZmVyICs9ICcgJztcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoYnVmZmVyKTtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxNCBIdWdvIEhldXphcmRcblxuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc3RhdGVcbnZhciBjYW1sX2dyX3N0YXRlO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3N0YXRlX2dldFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZVxuLy9SZXF1aXJlczogY2FtbF9uYW1lZF92YWx1ZSwgY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuLy9SZXF1aXJlczogY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlXG5mdW5jdGlvbiBjYW1sX2dyX3N0YXRlX2dldCgpIHtcbiAgaWYoY2FtbF9ncl9zdGF0ZSkge1xuICAgIHJldHVybiBjYW1sX2dyX3N0YXRlO1xuICB9XG4gIHRocm93IGNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZShbMCxjYW1sX25hbWVkX3ZhbHVlKFwiR3JhcGhpY3MuR3JhcGhpY19mYWlsdXJlXCIpLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKFwiTm90IGluaXRpYWxpemVkXCIpXSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3N0YXRlX3NldFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZSxjYW1sX2dyX3N0YXRlX2luaXRcbmZ1bmN0aW9uIGNhbWxfZ3Jfc3RhdGVfc2V0KGN0eCkge1xuICBjYW1sX2dyX3N0YXRlPWN0eDtcbiAgY2FtbF9ncl9zdGF0ZV9pbml0KClcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfb3Blbl9ncmFwaFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9jcmVhdGVcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9ncl9vcGVuX2dyYXBoKGluZm8pe1xuICB2YXIgaW5mbyA9IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKGluZm8pO1xuICBmdW5jdGlvbiBnZXQobmFtZSl7XG4gICAgdmFyIHJlcyA9IGluZm8ubWF0Y2goXCIoXnwsKSAqXCIrbmFtZStcIiAqPSAqKFthLXpBLVowLTlfXSspICooLHwkKVwiKTtcbiAgICBpZihyZXMpIHJldHVybiByZXNbMl07XG4gIH1cbiAgdmFyIHNwZWNzID0gW107XG4gIGlmKCEoaW5mbz09XCJcIikpIHNwZWNzLnB1c2goaW5mbyk7XG4gIHZhciB0YXJnZXQgPSBnZXQoXCJ0YXJnZXRcIik7XG4gIGlmKCF0YXJnZXQpIHRhcmdldD1cIlwiO1xuICB2YXIgc3RhdHVzID0gZ2V0KFwic3RhdHVzXCIpO1xuICBpZighc3RhdHVzKSBzcGVjcy5wdXNoKFwic3RhdHVzPTFcIilcblxuICB2YXIgdyA9IGdldChcIndpZHRoXCIpO1xuICB3ID0gdz9wYXJzZUludCh3KToyMDA7XG4gIHNwZWNzLnB1c2goXCJ3aWR0aD1cIit3KTtcblxuICB2YXIgaCA9IGdldChcImhlaWdodFwiKTtcbiAgaCA9IGg/cGFyc2VJbnQoaCk6MjAwO1xuICBzcGVjcy5wdXNoKFwiaGVpZ2h0PVwiK2gpO1xuXG4gIHZhciB3aW4gPSBnbG9iYWxUaGlzLm9wZW4oXCJhYm91dDpibGFua1wiLHRhcmdldCxzcGVjcy5qb2luKFwiLFwiKSk7XG4gIGlmKCF3aW4pIHtjYW1sX2ZhaWx3aXRoKFwiR3JhcGhpY3Mub3Blbl9ncmFwaDogY2Fubm90IG9wZW4gdGhlIHdpbmRvd1wiKX1cbiAgdmFyIGRvYyA9IHdpbi5kb2N1bWVudDtcbiAgdmFyIGNhbnZhcyA9IGRvYy5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICBjYW52YXMud2lkdGggPSB3O1xuICBjYW52YXMuaGVpZ2h0ID0gaDtcbiAgdmFyIGN0eCA9IGNhbWxfZ3Jfc3RhdGVfY3JlYXRlKGNhbnZhcyx3LGgpO1xuICBjdHguc2V0X3RpdGxlID0gZnVuY3Rpb24gKHRpdGxlKSB7XG4gICAgZG9jLnRpdGxlID0gdGl0bGU7XG4gIH07XG4gIGNhbWxfZ3Jfc3RhdGVfc2V0KGN0eCk7XG4gIHZhciBib2R5ID0gZG9jLmJvZHk7XG4gIGJvZHkuc3R5bGUubWFyZ2luID0gXCIwcHhcIjtcbiAgYm9keS5hcHBlbmRDaGlsZChjYW52YXMpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9zdGF0ZV9pbml0XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3NldF9jb2xvcixjYW1sX2dyX21vdmV0byxjYW1sX2dyX3Jlc2l6ZV93aW5kb3dcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc2V0X2xpbmVfd2lkdGgsY2FtbF9ncl9zZXRfdGV4dF9zaXplLGNhbWxfZ3Jfc2V0X2ZvbnRcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc2V0X3dpbmRvd190aXRsZVxuZnVuY3Rpb24gY2FtbF9ncl9zdGF0ZV9pbml0KCl7XG4gIGNhbWxfZ3JfbW92ZXRvKGNhbWxfZ3Jfc3RhdGUueCxjYW1sX2dyX3N0YXRlLnkpO1xuICBjYW1sX2dyX3Jlc2l6ZV93aW5kb3coY2FtbF9ncl9zdGF0ZS53aWR0aCxjYW1sX2dyX3N0YXRlLmhlaWdodCk7XG4gIGNhbWxfZ3Jfc2V0X2xpbmVfd2lkdGgoY2FtbF9ncl9zdGF0ZS5saW5lX3dpZHRoKTtcbiAgY2FtbF9ncl9zZXRfdGV4dF9zaXplKGNhbWxfZ3Jfc3RhdGUudGV4dF9zaXplKTtcbiAgY2FtbF9ncl9zZXRfZm9udChjYW1sX2dyX3N0YXRlLmZvbnQpO1xuICBjYW1sX2dyX3NldF9jb2xvcihjYW1sX2dyX3N0YXRlLmNvbG9yKTtcbiAgY2FtbF9ncl9zZXRfd2luZG93X3RpdGxlKGNhbWxfZ3Jfc3RhdGUudGl0bGUpO1xuICAvL2NhbWxfZ3JfcmVzaXplX3dpbmRvdyBtaWdodCByZXNldCBzb21lIGNhbnZhcycgcHJvcGVydGllc1xuICBjYW1sX2dyX3N0YXRlLmNvbnRleHQudGV4dEJhc2VsaW5lID0gJ2JvdHRvbSc7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc3RhdGVfY3JlYXRlXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX2dyX3N0YXRlX2NyZWF0ZShjYW52YXMsdyxoKXtcbiAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICByZXR1cm4ge1xuICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgY2FudmFzIDogY2FudmFzLFxuICAgIHggOiAwLFxuICAgIHkgOiAwLFxuICAgIHdpZHRoIDogdyxcbiAgICBoZWlnaHQgOiBoLFxuICAgIGxpbmVfd2lkdGggOiAxLFxuICAgIGZvbnQgOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKFwiZml4ZWRcIiksXG4gICAgdGV4dF9zaXplIDogMjYsXG4gICAgY29sb3IgOiAweDAwMDAwMCxcbiAgICB0aXRsZSA6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoXCJcIilcbiAgfTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9kb2Nfb2Zfc3RhdGVcbmZ1bmN0aW9uIGNhbWxfZ3JfZG9jX29mX3N0YXRlKHN0YXRlKSB7XG4gIGlmKHN0YXRlLmNhbnZhcy5vd25lckRvY3VtZW50KVxuICAgIHJldHVybiBzdGF0ZS5jYW52YXMub3duZXJEb2N1bWVudDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9jbG9zZV9ncmFwaFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfY2xvc2VfZ3JhcGgoKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLmNhbnZhcy53aWR0aCA9IDA7XG4gIHMuY2FudmFzLmhlaWdodCA9IDA7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3NldF93aW5kb3dfdGl0bGVcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9ncl9zZXRfd2luZG93X3RpdGxlKG5hbWUpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMudGl0bGUgPSBuYW1lO1xuICB2YXIganNuYW1lID0gY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcobmFtZSk7XG4gIGlmKHMuc2V0X3RpdGxlKSBzLnNldF90aXRsZShqc25hbWUpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9yZXNpemVfd2luZG93XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9yZXNpemVfd2luZG93KHcsaCl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKVxuICBzLndpZHRoID0gdztcbiAgcy5oZWlnaHQgPSBoO1xuICBzLmNhbnZhcy53aWR0aCA9IHc7XG4gIHMuY2FudmFzLmhlaWdodCA9IGg7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2NsZWFyX2dyYXBoXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9jbGVhcl9ncmFwaCgpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMuY2FudmFzLndpZHRoID0gcy53aWR0aDtcbiAgcy5jYW52YXMuaGVpZ2h0ID0gcy5oZWlnaHQ7XG4gIC8vICBzLmNvbnRleHQuc3Ryb2tlUmVjdCAoMC4sIDAuLCBzLndpZHRoLCBzLmhlaWdodCk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3NpemVfeFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3Jfc2l6ZV94KCl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcmV0dXJuIHMud2lkdGg7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3NpemVfeVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3Jfc2l6ZV95KCl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcmV0dXJuIHMuaGVpZ2h0O1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc2V0X2NvbG9yXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9zZXRfY29sb3IoY29sb3Ipe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIGZ1bmN0aW9uIGNvbnZlcnQobnVtYmVyKSB7XG4gICAgdmFyIHN0ciA9ICcnICsgbnVtYmVyLnRvU3RyaW5nKDE2KTtcbiAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IDIpIHN0ciA9ICcwJyArIHN0cjtcbiAgICByZXR1cm4gc3RyO1xuICB9XG4gIHZhclxuICByID0gKGNvbG9yID4+IDE2KSAmIDB4ZmYsXG4gIGcgPSAoY29sb3IgPj4gOCkgICYgMHhmZixcbiAgYiA9IChjb2xvciA+PiAwKSAgJiAweGZmO1xuICBzLmNvbG9yPWNvbG9yO1xuICB2YXIgY19zdHIgPSAnIycgKyBjb252ZXJ0KHIpICsgY29udmVydChnKSArIGNvbnZlcnQoYik7XG4gIHMuY29udGV4dC5maWxsU3R5bGUgPSAgIGNfc3RyO1xuICBzLmNvbnRleHQuc3Ryb2tlU3R5bGUgPSBjX3N0cjtcbiAgcmV0dXJuIDA7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3Bsb3Rcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX3Bsb3QoeCx5KXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICB2YXIgaW09cy5jb250ZXh0LmNyZWF0ZUltYWdlRGF0YSgxLDEpO1xuICB2YXIgZCA9IGltLmRhdGE7XG4gIHZhciBjb2xvciA9IHMuY29sb3I7XG4gIGRbMF0gPSAoY29sb3IgPj4gMTYpICYgMHhmZjsgLy9yXG4gIGRbMV0gPSAoY29sb3IgPj4gOCkgICYgMHhmZiwgLy9nXG4gIGRbMl0gPSAoY29sb3IgPj4gMCkgICYgMHhmZjsgLy9iXG4gIGRbM10gPSAweEZGOyAvL2FcbiAgcy54PXg7XG4gIHMueT15O1xuICBzLmNvbnRleHQucHV0SW1hZ2VEYXRhKGltLHgscy5oZWlnaHQgLSB5KTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfcG9pbnRfY29sb3Jcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX3BvaW50X2NvbG9yKHgseSl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgdmFyIGltPXMuY29udGV4dC5nZXRJbWFnZURhdGEoeCxzLmhlaWdodCAtIHksMSwxKTtcbiAgdmFyIGQgPSBpbS5kYXRhO1xuICByZXR1cm4gKGRbMF0gPDwgMTYpICsgKGRbMV0gPDwgOCkgKyBkWzJdO1xufVxuLy9Qcm92aWRlczogY2FtbF9ncl9tb3ZldG9cbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX21vdmV0byh4LHkpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMueD14O1xuICBzLnk9eTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfY3VycmVudF94XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9jdXJyZW50X3goKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICByZXR1cm4gcy54XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2N1cnJlbnRfeVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfY3VycmVudF95KCl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcmV0dXJuIHMueVxufVxuLy9Qcm92aWRlczogY2FtbF9ncl9saW5ldG9cbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2xpbmV0byh4LHkpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMuY29udGV4dC5iZWdpblBhdGgoKTtcbiAgcy5jb250ZXh0Lm1vdmVUbyhzLngscy5oZWlnaHQgLSBzLnkpO1xuICBzLmNvbnRleHQubGluZVRvKHgscy5oZWlnaHQgLSB5KTtcbiAgcy5jb250ZXh0LnN0cm9rZSgpO1xuICBzLng9eDtcbiAgcy55PXk7XG4gIHJldHVybiAwO1xufVxuLy9Qcm92aWRlczogY2FtbF9ncl9kcmF3X3JlY3Rcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2RyYXdfcmVjdCh4LHksdyxoKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLmNvbnRleHQuc3Ryb2tlUmVjdCh4LHMuaGVpZ2h0IC0geSx3LC1oKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfYXJjX2F1eFxuZnVuY3Rpb24gY2FtbF9ncl9hcmNfYXV4KGN0eCxjeCxjeSxyeSxyeCxhMSxhMil7XG4gIHdoaWxlKGExPmEyKSBhMis9MzYwO1xuICBhMSAvPSAxODA7XG4gIGEyIC89IDE4MDtcbiAgdmFyIHJvdCA9IDAseFBvcyx5UG9zLHhQb3NfcHJldix5UG9zX3ByZXY7XG4gIHZhciBzcGFjZSA9IDI7XG4gIHZhciBudW0gPSAoKChhMiAtIGExKSAqIE1hdGguUEkgKiAoKHJ4K3J5KS8yKSkgLyBzcGFjZSkgfCAwO1xuICB2YXIgZGVsdGEgPSAoYTIgLSBhMSkgKiBNYXRoLlBJIC8gbnVtO1xuICB2YXIgaSA9IGExICogTWF0aC5QSTtcbiAgZm9yICh2YXIgaj0wO2o8PW51bTtqKyspe1xuICAgIHhQb3MgPSBjeCAtIChyeCAqIE1hdGguc2luKGkpKSAqIE1hdGguc2luKHJvdCAqIE1hdGguUEkpICsgKHJ5ICogTWF0aC5jb3MoaSkpICogTWF0aC5jb3Mocm90ICogTWF0aC5QSSk7XG4gICAgeFBvcyA9IHhQb3MudG9GaXhlZCgyKTtcbiAgICB5UG9zID0gY3kgKyAocnkgKiBNYXRoLmNvcyhpKSkgKiBNYXRoLnNpbihyb3QgKiBNYXRoLlBJKSArIChyeCAqIE1hdGguc2luKGkpKSAqIE1hdGguY29zKHJvdCAqIE1hdGguUEkpO1xuICAgIHlQb3MgPSB5UG9zLnRvRml4ZWQoMik7XG4gICAgaWYgKGo9PTApIHtcbiAgICAgIGN0eC5tb3ZlVG8oeFBvcywgeVBvcyk7XG4gICAgfSBlbHNlIGlmICh4UG9zX3ByZXYhPXhQb3MgfHwgeVBvc19wcmV2IT15UG9zKXtcbiAgICAgIGN0eC5saW5lVG8oeFBvcywgeVBvcyk7XG4gICAgfVxuICAgIHhQb3NfcHJldj14UG9zO1xuICAgIHlQb3NfcHJldj15UG9zO1xuICAgIGktPSBkZWx0YTsvL2Njd1xuICB9XG4gIHJldHVybiAwO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfZHJhd19hcmNcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0LCBjYW1sX2dyX2FyY19hdXhcbmZ1bmN0aW9uIGNhbWxfZ3JfZHJhd19hcmMoeCx5LHJ4LHJ5LGExLGEyKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLmNvbnRleHQuYmVnaW5QYXRoKCk7XG4gIGNhbWxfZ3JfYXJjX2F1eChzLmNvbnRleHQseCxzLmhlaWdodCAtIHkscngscnksYTEsYTIpO1xuICBzLmNvbnRleHQuc3Ryb2tlKCk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3NldF9saW5lX3dpZHRoXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9zZXRfbGluZV93aWR0aCh3KXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLmxpbmVfd2lkdGggPSB3O1xuICBzLmNvbnRleHQubGluZVdpZHRoID0gd1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9maWxsX3JlY3Rcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2ZpbGxfcmVjdCh4LHksdyxoKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLmNvbnRleHQuZmlsbFJlY3QoeCxzLmhlaWdodCAtIHksdywtaCk7XG4gIHJldHVybiAwO1xufVxuLy9Qcm92aWRlczogY2FtbF9ncl9maWxsX3BvbHlcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2ZpbGxfcG9seShhcil7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy5jb250ZXh0LmJlZ2luUGF0aCgpO1xuICBzLmNvbnRleHQubW92ZVRvKGFyWzFdWzFdLHMuaGVpZ2h0IC0gYXJbMV1bMl0pO1xuICBmb3IodmFyIGkgPSAyOyBpIDwgYXIubGVuZ3RoOyBpKyspXG4gICAgcy5jb250ZXh0LmxpbmVUbyhhcltpXVsxXSxzLmhlaWdodCAtIGFyW2ldWzJdKTtcbiAgcy5jb250ZXh0LmxpbmVUbyhhclsxXVsxXSxzLmhlaWdodCAtIGFyWzFdWzJdKTtcbiAgcy5jb250ZXh0LmZpbGwoKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfZmlsbF9hcmNcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0LCBjYW1sX2dyX2FyY19hdXhcbmZ1bmN0aW9uIGNhbWxfZ3JfZmlsbF9hcmMoeCx5LHJ4LHJ5LGExLGEyKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLmNvbnRleHQuYmVnaW5QYXRoKCk7XG4gIGNhbWxfZ3JfYXJjX2F1eChzLmNvbnRleHQseCxzLmhlaWdodCAtIHkscngscnksYTEsYTIpO1xuICBzLmNvbnRleHQuZmlsbCgpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9kcmF3X3N0clxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfZHJhd19zdHIoc3RyKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICB2YXIgbSA9IHMuY29udGV4dC5tZWFzdXJlVGV4dChzdHIpO1xuICB2YXIgZHggPSBtLndpZHRoO1xuICBzLmNvbnRleHQuZmlsbFRleHQoc3RyLHMueCxzLmhlaWdodCAtIHMueSk7XG4gIHMueCArPSBkeCB8IDA7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2RyYXdfY2hhclxuLy9SZXF1aXJlczogY2FtbF9ncl9kcmF3X3N0clxuZnVuY3Rpb24gY2FtbF9ncl9kcmF3X2NoYXIoYyl7XG4gIGNhbWxfZ3JfZHJhd19zdHIoU3RyaW5nLmZyb21DaGFyQ29kZShjKSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2RyYXdfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2dyX2RyYXdfc3RyXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9ncl9kcmF3X3N0cmluZyhzdHIpe1xuICBjYW1sX2dyX2RyYXdfc3RyKGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHN0cikpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9zZXRfZm9udFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2dyX3NldF9mb250KGYpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMuZm9udCA9IGY7XG4gIHMuY29udGV4dC5mb250ID0gcy50ZXh0X3NpemUgKyBcInB4IFwiICsgY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocy5mb250KTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc2V0X3RleHRfc2l6ZVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2dyX3NldF90ZXh0X3NpemUoc2l6ZSl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy50ZXh0X3NpemUgPSBzaXplO1xuICBzLmNvbnRleHQuZm9udCA9IHMudGV4dF9zaXplICsgXCJweCBcIiArIGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHMuZm9udCk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3RleHRfc2l6ZVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2dyX3RleHRfc2l6ZSh0eHQpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHZhciB3ID0gcy5jb250ZXh0Lm1lYXN1cmVUZXh0KGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHR4dCkpLndpZHRoO1xuICByZXR1cm4gWzAsdyxzLnRleHRfc2l6ZV07XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9ncl9tYWtlX2ltYWdlXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9tYWtlX2ltYWdlKGFycil7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgdmFyIGggPSBhcnIubGVuZ3RoIC0gMSA7XG4gIHZhciB3ID0gYXJyWzFdLmxlbmd0aCAtIDE7XG4gIHZhciBpbSA9IHMuY29udGV4dC5jcmVhdGVJbWFnZURhdGEodyxoKTtcbiAgZm9yKHZhciBpPTA7aTxoO2krKyl7XG4gICAgZm9yKHZhciBqPTA7ajx3O2orKyl7XG4gICAgICB2YXIgYyA9IGFycltpKzFdW2orMV07XG4gICAgICB2YXIgbyA9IGkqKHcqNCkgKyAoaiAqIDQpO1xuICAgICAgaWYoYyA9PSAtMSkge1xuICAgICAgICBpbS5kYXRhW28gKyAwXSA9IDA7XG4gICAgICAgIGltLmRhdGFbbyArIDFdID0gMDtcbiAgICAgICAgaW0uZGF0YVtvICsgMl0gPSAwO1xuICAgICAgICBpbS5kYXRhW28gKyAzXSA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbS5kYXRhW28gKyAwXSA9IGMgPj4gMTYgJiAweGZmO1xuICAgICAgICBpbS5kYXRhW28gKyAxXSA9IGMgPj4gIDggJiAweGZmO1xuICAgICAgICBpbS5kYXRhW28gKyAyXSA9IGMgPj4gIDAgJiAwWGZmO1xuICAgICAgICBpbS5kYXRhW28gKyAzXSA9IDB4ZmY7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBpbVxufVxuLy9Qcm92aWRlczogY2FtbF9ncl9kdW1wX2ltYWdlXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9kdW1wX2ltYWdlKGltKXtcbiAgdmFyIGRhdGEgPSBbMF1cbiAgZm9yKHZhciBpPTA7IGk8aW0uaGVpZ2h0O2krKyl7XG4gICAgZGF0YVtpKzFdID0gWzBdXG4gICAgZm9yKHZhciBqPTA7IGo8aW0ud2lkdGg7aisrKXtcbiAgICAgIHZhciBvID0gaSooaW0ud2lkdGgqNCkgKyAoaiAqIDQpLFxuICAgICAgICAgIHIgPSBpbS5kYXRhW28rMF0sXG4gICAgICAgICAgZyA9IGltLmRhdGFbbysxXSxcbiAgICAgICAgICBiID0gaW0uZGF0YVtvKzJdO1xuICAgICAgZGF0YVtpKzFdW2orMV0gPSAociA8PCAxNikgKyAoZyA8PCA4KSArIGJcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfZHJhd19pbWFnZVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfZHJhd19pbWFnZShpbSx4LHkpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIGlmKCFpbS5pbWFnZSkge1xuICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgIGNhbnZhcy53aWR0aCA9IHMud2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IHMuaGVpZ2h0O1xuICAgIGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIikucHV0SW1hZ2VEYXRhKGltLDAsMCk7XG4gICAgdmFyIGltYWdlID0gbmV3IGdsb2JhbFRoaXMuSW1hZ2UoKTtcbiAgICBpbWFnZS5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBzLmNvbnRleHQuZHJhd0ltYWdlKGltYWdlLHgscy5oZWlnaHQgLSBpbS5oZWlnaHQgLSB5KTtcbiAgICAgIGltLmltYWdlID0gaW1hZ2U7XG4gICAgfVxuICAgIGltYWdlLnNyYyA9IGNhbnZhcy50b0RhdGFVUkwoXCJpbWFnZS9wbmdcIik7XG4gIH0gZWxzZSB7XG4gICAgcy5jb250ZXh0LmRyYXdJbWFnZShpbS5pbWFnZSx4LHMuaGVpZ2h0IC0gaW0uaGVpZ2h0IC0geSk7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2NyZWF0ZV9pbWFnZVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfY3JlYXRlX2ltYWdlKHgseSl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcmV0dXJuIHMuY29udGV4dC5jcmVhdGVJbWFnZURhdGEoeCx5KTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfYmxpdF9pbWFnZVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfYmxpdF9pbWFnZShpbSx4LHkpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHZhciBpbTIgPSBzLmNvbnRleHQuZ2V0SW1hZ2VEYXRhKHgscy5oZWlnaHQgLSBpbS5oZWlnaHQgLSB5LGltLndpZHRoLGltLmhlaWdodCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaW0yLmRhdGEubGVuZ3RoOyBpKz00KXtcbiAgICBpbS5kYXRhW2ldID0gaW0yLmRhdGFbaV07XG4gICAgaW0uZGF0YVtpKzFdID0gaW0yLmRhdGFbaSsxXTtcbiAgICBpbS5kYXRhW2krMl0gPSBpbTIuZGF0YVtpKzJdO1xuICAgIGltLmRhdGFbaSszXSA9IGltMi5kYXRhW2krM107XG4gIH1cbiAgcmV0dXJuIDA7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3NpZ2lvX2hhbmRsZXJcbmZ1bmN0aW9uIGNhbWxfZ3Jfc2lnaW9faGFuZGxlcigpe3JldHVybiAwfVxuLy9Qcm92aWRlczogY2FtbF9ncl9zaWdpb19zaWduYWxcbmZ1bmN0aW9uIGNhbWxfZ3Jfc2lnaW9fc2lnbmFsKCl7cmV0dXJuIDB9XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3dhaXRfZXZlbnRcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfZ3Jfd2FpdF9ldmVudChfZXZsKXtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfZ3Jfd2FpdF9ldmVudCBub3QgSW1wbGVtZW50ZWQ6IHVzZSBHcmFwaGljc19qcyBpbnN0ZWFkXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3N5bmNocm9uaXplXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2dyX3N5bmNocm9uaXplICgpIHtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfZ3Jfc3luY2hyb25pemUgbm90IEltcGxlbWVudGVkXCIpO1xufVxuLy9Qcm92aWRlczogY2FtbF9ncl9yZW1lbWJlcl9tb2RlXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2dyX3JlbWVtYmVyX21vZGUgKCkge1xuICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9ncl9yZW1lbWJlcl9tb2RlIG5vdCBJbXBsZW1lbnRlZFwiKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfZGlzcGxheV9tb2RlXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2dyX2Rpc3BsYXlfbW9kZSgpIHtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfZ3JfZGlzcGxheV9tb2RlIG5vdCBJbXBsZW1lbnRlZFwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl93aW5kb3dfaWRcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfZ3Jfd2luZG93X2lkKGEpIHtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfZ3Jfd2luZG93X2lkIG5vdCBJbXBsZW1lbnRlZFwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9vcGVuX3N1YndpbmRvd1xuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9ncl9vcGVuX3N1YndpbmRvdyhhLGIsYyxkKSB7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX2dyX29wZW5fc3Vid2luZG93IG5vdCBJbXBsZW1lbnRlZFwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9jbG9zZV9zdWJ3aW5kb3dcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfZ3JfY2xvc2Vfc3Vid2luZG93KGEpIHtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfZ3JfY2xvc2Vfc3Vid2luZG93IG5vdCBJbXBsZW1lbnRlZFwiKTtcbn1cbiIsIi8vIEpzX29mX29jYW1sIGxpYnJhcnlcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8vLy8vLy8vLy8vLyBKc2xpYjogY29kZSBzcGVjaWZpYyB0byBKc19vZl9vY2FtbFxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX29uX2llIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2pzX29uX2llICgpIHtcbiAgdmFyIHVhID1cbiAgICAgIChnbG9iYWxUaGlzLm5hdmlnYXRvciYmZ2xvYmFsVGhpcy5uYXZpZ2F0b3IudXNlckFnZW50KVxuICAgICAgP2dsb2JhbFRoaXMubmF2aWdhdG9yLnVzZXJBZ2VudDpcIlwiO1xuICByZXR1cm4gdWEuaW5kZXhPZihcIk1TSUVcIikgIT0gLTEgJiYgdWEuaW5kZXhPZihcIk9wZXJhXCIpICE9IDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfaHRtbF9lc2NhcGUgY29uc3QgKGNvbnN0KVxudmFyIGNhbWxfanNfcmVnZXhwcyA9IHsgYW1wOi8mL2csIGx0Oi88L2csIHF1b3Q6L1xcXCIvZywgYWxsOi9bJjxcXFwiXS8gfTtcbmZ1bmN0aW9uIGNhbWxfanNfaHRtbF9lc2NhcGUgKHMpIHtcbiAgaWYgKCFjYW1sX2pzX3JlZ2V4cHMuYWxsLnRlc3QocykpIHJldHVybiBzO1xuICByZXR1cm4gcy5yZXBsYWNlKGNhbWxfanNfcmVnZXhwcy5hbXAsIFwiJmFtcDtcIilcbiAgICAucmVwbGFjZShjYW1sX2pzX3JlZ2V4cHMubHQsIFwiJmx0O1wiKVxuICAgIC5yZXBsYWNlKGNhbWxfanNfcmVnZXhwcy5xdW90LCBcIiZxdW90O1wiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9qc19odG1sX2VudGl0aWVzXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2pzX2h0bWxfZW50aXRpZXMocykge1xuICB2YXIgZW50aXR5ID0gL14mIz9bMC05YS16QS1aXSs7JC9cbiAgaWYocy5tYXRjaChlbnRpdHkpKVxuICB7XG4gICAgdmFyIHN0ciwgdGVtcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3AnKTtcbiAgICB0ZW1wLmlubmVySFRNTD0gcztcbiAgICBzdHI9IHRlbXAudGV4dENvbnRlbnQgfHwgdGVtcC5pbm5lclRleHQ7XG4gICAgdGVtcD1udWxsO1xuICAgIHJldHVybiBzdHI7XG4gIH1cbiAgZWxzZSB7XG4gICAgY2FtbF9mYWlsd2l0aChcIkludmFsaWQgZW50aXR5IFwiICsgcyk7XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9qc19nZXRfY29uc29sZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9qc19nZXRfY29uc29sZSAoKSB7XG4gIHZhciBjID0gY29uc29sZTtcbiAgdmFyIG0gPSBbXCJsb2dcIiwgXCJkZWJ1Z1wiLCBcImluZm9cIiwgXCJ3YXJuXCIsIFwiZXJyb3JcIiwgXCJhc3NlcnRcIiwgXCJkaXJcIiwgXCJkaXJ4bWxcIixcbiAgICAgICAgICAgXCJ0cmFjZVwiLCBcImdyb3VwXCIsIFwiZ3JvdXBDb2xsYXBzZWRcIiwgXCJncm91cEVuZFwiLCBcInRpbWVcIiwgXCJ0aW1lRW5kXCJdO1xuICBmdW5jdGlvbiBmICgpIHt9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbS5sZW5ndGg7IGkrKykgaWYgKCFjW21baV1dKSBjW21baV1dPWY7XG4gIHJldHVybiBjO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3htbGh0dHByZXF1ZXN0X2NyZWF0ZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuLy9XZWFrZGVmXG5mdW5jdGlvbiBjYW1sX3htbGh0dHByZXF1ZXN0X2NyZWF0ZSh1bml0KXtcbiAgaWYodHlwZW9mIGdsb2JhbFRoaXMuWE1MSHR0cFJlcXVlc3QgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdHJ5IHsgcmV0dXJuIG5ldyBnbG9iYWxUaGlzLlhNTEh0dHBSZXF1ZXN0IH0gY2F0Y2ggKGUpIHsgfTtcbiAgfVxuICBpZih0eXBlb2YgZ2xvYmFsVGhpcy5hY3RpdmVYT2JqZWN0ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHRyeSB7IHJldHVybiBuZXcgZ2xvYmFsVGhpcy5hY3RpdmVYT2JqZWN0KFwiTXN4bWwyLlhNTEhUVFBcIikgfSBjYXRjaChlKXsgfTtcbiAgICB0cnkgeyByZXR1cm4gbmV3IGdsb2JhbFRoaXMuYWN0aXZlWE9iamVjdChcIk1zeG1sMy5YTUxIVFRQXCIpIH0gY2F0Y2goZSl7IH07XG4gICAgdHJ5IHsgcmV0dXJuIG5ldyBnbG9iYWxUaGlzLmFjdGl2ZVhPYmplY3QoXCJNaWNyb3NvZnQuWE1MSFRUUFwiKSB9IGNhdGNoKGUpeyB9O1xuICB9XG4gIGNhbWxfZmFpbHdpdGgoXCJDYW5ub3QgY3JlYXRlIGEgWE1MSHR0cFJlcXVlc3RcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZXJyb3Jfb2ZfZXhjZXB0aW9uXG5mdW5jdGlvbiBjYW1sX2pzX2Vycm9yX29mX2V4Y2VwdGlvbihleG4pIHtcbiAgaWYoZXhuLmpzX2Vycm9yKSB7IHJldHVybiBleG4uanNfZXJyb3I7IH1cbiAgcmV0dXJuIG51bGw7XG59XG4iLCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdGl2ZSBDYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKiAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKiAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICovXG4vKiAgZW4gQXV0b21hdGlxdWUuICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkICAgICovXG4vKiAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UsIHdpdGggICAgICovXG4vKiAgdGhlIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIGZpbGUgLi4vTElDRU5TRS4gICAgICovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8qICRJZDogbGV4aW5nLmMgNjA0NSAyMDA0LTAxLTAxIDE2OjQyOjQzWiBkb2xpZ2V6ICQgKi9cblxuLyogVGhlIHRhYmxlLWRyaXZlbiBhdXRvbWF0b24gZm9yIGxleGVycyBnZW5lcmF0ZWQgYnkgY2FtbGxleC4gKi9cblxuLy9Qcm92aWRlczogY2FtbF9sZXhfYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfbGV4X2FycmF5KHMpIHtcbiAgcyA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcocyk7XG4gIHZhciBsID0gcy5sZW5ndGggLyAyO1xuICB2YXIgYSA9IG5ldyBBcnJheShsKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspXG4gICAgYVtpXSA9IChzLmNoYXJDb2RlQXQoMiAqIGkpIHwgKHMuY2hhckNvZGVBdCgyICogaSArIDEpIDw8IDgpKSA8PCAxNiA+PiAxNjtcbiAgcmV0dXJuIGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbGV4X2VuZ2luZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aCwgY2FtbF9sZXhfYXJyYXksIGNhbWxfdWludDhfYXJyYXlfb2ZfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfbGV4X2VuZ2luZSh0YmwsIHN0YXJ0X3N0YXRlLCBsZXhidWYpIHtcbiAgdmFyIGxleF9idWZmZXIgPSAyO1xuICB2YXIgbGV4X2J1ZmZlcl9sZW4gPSAzO1xuICB2YXIgbGV4X3N0YXJ0X3BvcyA9IDU7XG4gIHZhciBsZXhfY3Vycl9wb3MgPSA2O1xuICB2YXIgbGV4X2xhc3RfcG9zID0gNztcbiAgdmFyIGxleF9sYXN0X2FjdGlvbiA9IDg7XG4gIHZhciBsZXhfZW9mX3JlYWNoZWQgPSA5O1xuICB2YXIgbGV4X2Jhc2UgPSAxO1xuICB2YXIgbGV4X2JhY2t0cmsgPSAyO1xuICB2YXIgbGV4X2RlZmF1bHQgPSAzO1xuICB2YXIgbGV4X3RyYW5zID0gNDtcbiAgdmFyIGxleF9jaGVjayA9IDU7XG5cbiAgaWYgKCF0YmwubGV4X2RlZmF1bHQpIHtcbiAgICB0YmwubGV4X2Jhc2UgPSAgICBjYW1sX2xleF9hcnJheSAodGJsW2xleF9iYXNlXSk7XG4gICAgdGJsLmxleF9iYWNrdHJrID0gY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfYmFja3Rya10pO1xuICAgIHRibC5sZXhfY2hlY2sgPSAgIGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2NoZWNrXSk7XG4gICAgdGJsLmxleF90cmFucyA9ICAgY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfdHJhbnNdKTtcbiAgICB0YmwubGV4X2RlZmF1bHQgPSBjYW1sX2xleF9hcnJheSAodGJsW2xleF9kZWZhdWx0XSk7XG4gIH1cblxuICB2YXIgYywgc3RhdGUgPSBzdGFydF9zdGF0ZTtcblxuICB2YXIgYnVmZmVyID0gY2FtbF91aW50OF9hcnJheV9vZl9ieXRlcyhsZXhidWZbbGV4X2J1ZmZlcl0pO1xuXG4gIGlmIChzdGF0ZSA+PSAwKSB7XG4gICAgLyogRmlyc3QgZW50cnkgKi9cbiAgICBsZXhidWZbbGV4X2xhc3RfcG9zXSA9IGxleGJ1ZltsZXhfc3RhcnRfcG9zXSA9IGxleGJ1ZltsZXhfY3Vycl9wb3NdO1xuICAgIGxleGJ1ZltsZXhfbGFzdF9hY3Rpb25dID0gLTE7XG4gIH0gZWxzZSB7XG4gICAgLyogUmVlbnRyeSBhZnRlciByZWZpbGwgKi9cbiAgICBzdGF0ZSA9IC1zdGF0ZSAtIDE7XG4gIH1cbiAgZm9yKDs7KSB7XG4gICAgLyogTG9va3VwIGJhc2UgYWRkcmVzcyBvciBhY3Rpb24gbnVtYmVyIGZvciBjdXJyZW50IHN0YXRlICovXG4gICAgdmFyIGJhc2UgPSB0YmwubGV4X2Jhc2Vbc3RhdGVdO1xuICAgIGlmIChiYXNlIDwgMCkgcmV0dXJuIC1iYXNlLTE7XG4gICAgLyogU2VlIGlmIGl0J3MgYSBiYWNrdHJhY2sgcG9pbnQgKi9cbiAgICB2YXIgYmFja3RyayA9IHRibC5sZXhfYmFja3Rya1tzdGF0ZV07XG4gICAgaWYgKGJhY2t0cmsgPj0gMCkge1xuICAgICAgbGV4YnVmW2xleF9sYXN0X3Bvc10gPSBsZXhidWZbbGV4X2N1cnJfcG9zXTtcbiAgICAgIGxleGJ1ZltsZXhfbGFzdF9hY3Rpb25dID0gYmFja3RyaztcbiAgICB9XG4gICAgLyogU2VlIGlmIHdlIG5lZWQgYSByZWZpbGwgKi9cbiAgICBpZiAobGV4YnVmW2xleF9jdXJyX3Bvc10gPj0gbGV4YnVmW2xleF9idWZmZXJfbGVuXSl7XG4gICAgICBpZiAobGV4YnVmW2xleF9lb2ZfcmVhY2hlZF0gPT0gMClcbiAgICAgICAgcmV0dXJuIC1zdGF0ZSAtIDE7XG4gICAgICBlbHNlXG4gICAgICAgIGMgPSAyNTY7XG4gICAgfWVsc2V7XG4gICAgICAvKiBSZWFkIG5leHQgaW5wdXQgY2hhciAqL1xuICAgICAgYyA9IGJ1ZmZlcltsZXhidWZbbGV4X2N1cnJfcG9zXV07XG4gICAgICBsZXhidWZbbGV4X2N1cnJfcG9zXSArKztcbiAgICB9XG4gICAgLyogRGV0ZXJtaW5lIG5leHQgc3RhdGUgKi9cbiAgICBpZiAodGJsLmxleF9jaGVja1tiYXNlICsgY10gPT0gc3RhdGUpXG4gICAgICBzdGF0ZSA9IHRibC5sZXhfdHJhbnNbYmFzZSArIGNdO1xuICAgIGVsc2VcbiAgICAgIHN0YXRlID0gdGJsLmxleF9kZWZhdWx0W3N0YXRlXTtcbiAgICAvKiBJZiBubyB0cmFuc2l0aW9uIG9uIHRoaXMgY2hhciwgcmV0dXJuIHRvIGxhc3QgYmFja3RyYWNrIHBvaW50ICovXG4gICAgaWYgKHN0YXRlIDwgMCkge1xuICAgICAgbGV4YnVmW2xleF9jdXJyX3Bvc10gPSBsZXhidWZbbGV4X2xhc3RfcG9zXTtcbiAgICAgIGlmIChsZXhidWZbbGV4X2xhc3RfYWN0aW9uXSA9PSAtMSlcbiAgICAgICAgY2FtbF9mYWlsd2l0aChcImxleGluZzogZW1wdHkgdG9rZW5cIik7XG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiBsZXhidWZbbGV4X2xhc3RfYWN0aW9uXTtcbiAgICB9ZWxzZXtcbiAgICAgIC8qIEVyYXNlIHRoZSBFT0YgY29uZGl0aW9uIG9ubHkgaWYgdGhlIEVPRiBwc2V1ZG8tY2hhcmFjdGVyIHdhc1xuICAgICAgICAgY29uc3VtZWQgYnkgdGhlIGF1dG9tYXRvbiAoaS5lLiB0aGVyZSB3YXMgbm8gYmFja3RyYWNrIGFib3ZlKVxuICAgICAgKi9cbiAgICAgIGlmIChjID09IDI1NikgbGV4YnVmW2xleF9lb2ZfcmVhY2hlZF0gPSAwO1xuICAgIH1cbiAgfVxufVxuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiBOZXcgbGV4ZXIgZW5naW5lLCB3aXRoIG1lbW9yeSBvZiBwb3NpdGlvbnMgICovXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8vUHJvdmlkZXM6IGNhbWxfbmV3X2xleF9lbmdpbmVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGgsIGNhbWxfbGV4X2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nLCBjYW1sX3VpbnQ4X2FycmF5X29mX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2xleF9ydW5fbWVtKHMsIGksIG1lbSwgY3Vycl9wb3MpIHtcbiAgZm9yICg7Oykge1xuICAgIHZhciBkc3QgPSBzLmNoYXJDb2RlQXQoaSk7IGkrKztcbiAgICBpZiAoZHN0ID09IDB4ZmYpIHJldHVybjtcbiAgICB2YXIgc3JjID0gcy5jaGFyQ29kZUF0KGkpOyBpKys7XG4gICAgaWYgKHNyYyA9PSAweGZmKVxuICAgICAgbWVtIFtkc3QgKyAxXSA9IGN1cnJfcG9zO1xuICAgIGVsc2VcbiAgICAgIG1lbSBbZHN0ICsgMV0gPSBtZW0gW3NyYyArIDFdO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbWxfbGV4X3J1bl90YWcocywgaSwgbWVtKSB7XG4gIGZvciAoOzspIHtcbiAgICB2YXIgZHN0ID0gcy5jaGFyQ29kZUF0KGkpOyBpKys7XG4gICAgaWYgKGRzdCA9PSAweGZmKSByZXR1cm4gO1xuICAgIHZhciBzcmMgPSBzLmNoYXJDb2RlQXQoaSk7IGkrKztcbiAgICBpZiAoc3JjID09IDB4ZmYpXG4gICAgICBtZW0gW2RzdCArIDFdID0gLTE7XG4gICAgZWxzZVxuICAgICAgbWVtIFtkc3QgKyAxXSA9IG1lbSBbc3JjICsgMV07XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FtbF9uZXdfbGV4X2VuZ2luZSh0YmwsIHN0YXJ0X3N0YXRlLCBsZXhidWYpIHtcbiAgdmFyIGxleF9idWZmZXIgPSAyO1xuICB2YXIgbGV4X2J1ZmZlcl9sZW4gPSAzO1xuICB2YXIgbGV4X3N0YXJ0X3BvcyA9IDU7XG4gIHZhciBsZXhfY3Vycl9wb3MgPSA2O1xuICB2YXIgbGV4X2xhc3RfcG9zID0gNztcbiAgdmFyIGxleF9sYXN0X2FjdGlvbiA9IDg7XG4gIHZhciBsZXhfZW9mX3JlYWNoZWQgPSA5O1xuICB2YXIgbGV4X21lbSA9IDEwO1xuICB2YXIgbGV4X2Jhc2UgPSAxO1xuICB2YXIgbGV4X2JhY2t0cmsgPSAyO1xuICB2YXIgbGV4X2RlZmF1bHQgPSAzO1xuICB2YXIgbGV4X3RyYW5zID0gNDtcbiAgdmFyIGxleF9jaGVjayA9IDU7XG4gIHZhciBsZXhfYmFzZV9jb2RlID0gNjtcbiAgdmFyIGxleF9iYWNrdHJrX2NvZGUgPSA3O1xuICB2YXIgbGV4X2RlZmF1bHRfY29kZSA9IDg7XG4gIHZhciBsZXhfdHJhbnNfY29kZSA9IDk7XG4gIHZhciBsZXhfY2hlY2tfY29kZSA9IDEwO1xuICB2YXIgbGV4X2NvZGUgPSAxMTtcblxuICBpZiAoIXRibC5sZXhfZGVmYXVsdCkge1xuICAgIHRibC5sZXhfYmFzZSA9ICAgIGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2Jhc2VdKTtcbiAgICB0YmwubGV4X2JhY2t0cmsgPSBjYW1sX2xleF9hcnJheSAodGJsW2xleF9iYWNrdHJrXSk7XG4gICAgdGJsLmxleF9jaGVjayA9ICAgY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfY2hlY2tdKTtcbiAgICB0YmwubGV4X3RyYW5zID0gICBjYW1sX2xleF9hcnJheSAodGJsW2xleF90cmFuc10pO1xuICAgIHRibC5sZXhfZGVmYXVsdCA9IGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2RlZmF1bHRdKTtcbiAgfVxuICBpZiAoIXRibC5sZXhfZGVmYXVsdF9jb2RlKSB7XG4gICAgdGJsLmxleF9iYXNlX2NvZGUgPSAgICBjYW1sX2xleF9hcnJheSAodGJsW2xleF9iYXNlX2NvZGVdKTtcbiAgICB0YmwubGV4X2JhY2t0cmtfY29kZSA9IGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2JhY2t0cmtfY29kZV0pO1xuICAgIHRibC5sZXhfY2hlY2tfY29kZSA9ICAgY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfY2hlY2tfY29kZV0pO1xuICAgIHRibC5sZXhfdHJhbnNfY29kZSA9ICAgY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfdHJhbnNfY29kZV0pO1xuICAgIHRibC5sZXhfZGVmYXVsdF9jb2RlID0gY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfZGVmYXVsdF9jb2RlXSk7XG4gIH1cbiAgaWYgKHRibC5sZXhfY29kZSA9PSBudWxsKSB0YmwubGV4X2NvZGUgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKHRibFtsZXhfY29kZV0pO1xuXG4gIHZhciBjLCBzdGF0ZSA9IHN0YXJ0X3N0YXRlO1xuXG4gIHZhciBidWZmZXIgPSBjYW1sX3VpbnQ4X2FycmF5X29mX2J5dGVzKGxleGJ1ZltsZXhfYnVmZmVyXSk7XG5cbiAgaWYgKHN0YXRlID49IDApIHtcbiAgICAvKiBGaXJzdCBlbnRyeSAqL1xuICAgIGxleGJ1ZltsZXhfbGFzdF9wb3NdID0gbGV4YnVmW2xleF9zdGFydF9wb3NdID0gbGV4YnVmW2xleF9jdXJyX3Bvc107XG4gICAgbGV4YnVmW2xleF9sYXN0X2FjdGlvbl0gPSAtMTtcbiAgfSBlbHNlIHtcbiAgICAvKiBSZWVudHJ5IGFmdGVyIHJlZmlsbCAqL1xuICAgIHN0YXRlID0gLXN0YXRlIC0gMTtcbiAgfVxuICBmb3IoOzspIHtcbiAgICAvKiBMb29rdXAgYmFzZSBhZGRyZXNzIG9yIGFjdGlvbiBudW1iZXIgZm9yIGN1cnJlbnQgc3RhdGUgKi9cbiAgICB2YXIgYmFzZSA9IHRibC5sZXhfYmFzZVtzdGF0ZV07XG4gICAgaWYgKGJhc2UgPCAwKSB7XG4gICAgICB2YXIgcGNfb2ZmID0gdGJsLmxleF9iYXNlX2NvZGVbc3RhdGVdO1xuICAgICAgY2FtbF9sZXhfcnVuX3RhZyh0YmwubGV4X2NvZGUsIHBjX29mZiwgbGV4YnVmW2xleF9tZW1dKTtcbiAgICAgIHJldHVybiAtYmFzZS0xO1xuICAgIH1cbiAgICAvKiBTZWUgaWYgaXQncyBhIGJhY2t0cmFjayBwb2ludCAqL1xuICAgIHZhciBiYWNrdHJrID0gdGJsLmxleF9iYWNrdHJrW3N0YXRlXTtcbiAgICBpZiAoYmFja3RyayA+PSAwKSB7XG4gICAgICB2YXIgcGNfb2ZmID0gdGJsLmxleF9iYWNrdHJrX2NvZGVbc3RhdGVdO1xuICAgICAgY2FtbF9sZXhfcnVuX3RhZyh0YmwubGV4X2NvZGUsIHBjX29mZiwgbGV4YnVmW2xleF9tZW1dKTtcbiAgICAgIGxleGJ1ZltsZXhfbGFzdF9wb3NdID0gbGV4YnVmW2xleF9jdXJyX3Bvc107XG4gICAgICBsZXhidWZbbGV4X2xhc3RfYWN0aW9uXSA9IGJhY2t0cms7XG4gICAgfVxuICAgIC8qIFNlZSBpZiB3ZSBuZWVkIGEgcmVmaWxsICovXG4gICAgaWYgKGxleGJ1ZltsZXhfY3Vycl9wb3NdID49IGxleGJ1ZltsZXhfYnVmZmVyX2xlbl0pe1xuICAgICAgaWYgKGxleGJ1ZltsZXhfZW9mX3JlYWNoZWRdID09IDApXG4gICAgICAgIHJldHVybiAtc3RhdGUgLSAxO1xuICAgICAgZWxzZVxuICAgICAgICBjID0gMjU2O1xuICAgIH1lbHNle1xuICAgICAgLyogUmVhZCBuZXh0IGlucHV0IGNoYXIgKi9cbiAgICAgIGMgPSBidWZmZXJbbGV4YnVmW2xleF9jdXJyX3Bvc11dO1xuICAgICAgbGV4YnVmW2xleF9jdXJyX3Bvc10gKys7XG4gICAgfVxuICAgIC8qIERldGVybWluZSBuZXh0IHN0YXRlICovXG4gICAgdmFyIHBzdGF0ZSA9IHN0YXRlIDtcbiAgICBpZiAodGJsLmxleF9jaGVja1tiYXNlICsgY10gPT0gc3RhdGUpXG4gICAgICBzdGF0ZSA9IHRibC5sZXhfdHJhbnNbYmFzZSArIGNdO1xuICAgIGVsc2VcbiAgICAgIHN0YXRlID0gdGJsLmxleF9kZWZhdWx0W3N0YXRlXTtcbiAgICAvKiBJZiBubyB0cmFuc2l0aW9uIG9uIHRoaXMgY2hhciwgcmV0dXJuIHRvIGxhc3QgYmFja3RyYWNrIHBvaW50ICovXG4gICAgaWYgKHN0YXRlIDwgMCkge1xuICAgICAgbGV4YnVmW2xleF9jdXJyX3Bvc10gPSBsZXhidWZbbGV4X2xhc3RfcG9zXTtcbiAgICAgIGlmIChsZXhidWZbbGV4X2xhc3RfYWN0aW9uXSA9PSAtMSlcbiAgICAgICAgY2FtbF9mYWlsd2l0aChcImxleGluZzogZW1wdHkgdG9rZW5cIik7XG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiBsZXhidWZbbGV4X2xhc3RfYWN0aW9uXTtcbiAgICB9ZWxzZXtcbiAgICAgIC8qIElmIHNvbWUgdHJhbnNpdGlvbiwgZ2V0IGFuZCBwZXJmb3JtIG1lbW9yeSBtb3ZlcyAqL1xuICAgICAgdmFyIGJhc2VfY29kZSA9IHRibC5sZXhfYmFzZV9jb2RlW3BzdGF0ZV0sIHBjX29mZjtcbiAgICAgIGlmICh0YmwubGV4X2NoZWNrX2NvZGVbYmFzZV9jb2RlICsgY10gPT0gcHN0YXRlKVxuICAgICAgICBwY19vZmYgPSB0YmwubGV4X3RyYW5zX2NvZGVbYmFzZV9jb2RlICsgY107XG4gICAgICBlbHNlXG4gICAgICAgIHBjX29mZiA9IHRibC5sZXhfZGVmYXVsdF9jb2RlW3BzdGF0ZV07XG4gICAgICBpZiAocGNfb2ZmID4gMClcbiAgICAgICAgY2FtbF9sZXhfcnVuX21lbVxuICAgICAgKHRibC5sZXhfY29kZSwgcGNfb2ZmLCBsZXhidWZbbGV4X21lbV0sIGxleGJ1ZltsZXhfY3Vycl9wb3NdKTtcbiAgICAgIC8qIEVyYXNlIHRoZSBFT0YgY29uZGl0aW9uIG9ubHkgaWYgdGhlIEVPRiBwc2V1ZG8tY2hhcmFjdGVyIHdhc1xuICAgICAgICAgY29uc3VtZWQgYnkgdGhlIGF1dG9tYXRvbiAoaS5lLiB0aGVyZSB3YXMgbm8gYmFja3RyYWNrIGFib3ZlKVxuICAgICAgKi9cbiAgICAgIGlmIChjID09IDI1NikgbGV4YnVmW2xleF9lb2ZfcmVhY2hlZF0gPSAwO1xuICAgIH1cbiAgfVxufVxuIiwiXG4vL1Byb3ZpZGVzOiBjYW1sX2x4bV9uZXh0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3NoaWZ0X2xlZnRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfc2hpZnRfcmlnaHRfdW5zaWduZWRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb3Jcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfeG9yXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2FkZFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9tdWxcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZ2V0XzFcbi8vUmVxdWlyZXM6IGNhbWxfYmFfc2V0XzFcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2Zfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX25ld19zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfbHhtX25leHQodikge1xuICBmdW5jdGlvbiBzaGlmdF9sKHgsIGspe1xuICAgIHJldHVybiBjYW1sX2ludDY0X3NoaWZ0X2xlZnQoeCxrKTtcbiAgfVxuICBmdW5jdGlvbiBzaGlmdF9yKHgsIGspe1xuICAgIHJldHVybiBjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0X3Vuc2lnbmVkKHgsayk7XG4gIH1cbiAgZnVuY3Rpb24gb3IoYSwgYil7XG4gICAgcmV0dXJuIGNhbWxfaW50NjRfb3IoYSxiKTtcbiAgfVxuICBmdW5jdGlvbiB4b3IoYSwgYil7XG4gICAgcmV0dXJuIGNhbWxfaW50NjRfeG9yKGEsYik7XG4gIH1cbiAgZnVuY3Rpb24gYWRkKGEsIGIpe1xuICAgIHJldHVybiBjYW1sX2ludDY0X2FkZChhLGIpO1xuICB9XG4gIGZ1bmN0aW9uIG11bChhLCBiKXtcbiAgICByZXR1cm4gY2FtbF9pbnQ2NF9tdWwoYSxiKTtcbiAgfVxuICBmdW5jdGlvbiByb3RsKHgsIGspIHtcbiAgICByZXR1cm4gb3Ioc2hpZnRfbCh4LGspLHNoaWZ0X3IgKHgsIDY0IC0gaykpO1xuICB9XG4gIGZ1bmN0aW9uIGdldChhLCBpKSB7XG4gICAgcmV0dXJuIGNhbWxfYmFfZ2V0XzEoYSwgaSk7XG4gIH1cbiAgZnVuY3Rpb24gc2V0KGEsIGksIHgpIHtcbiAgICByZXR1cm4gY2FtbF9iYV9zZXRfMShhLCBpLCB4KTtcbiAgfVxuICB2YXIgTSA9IGNhbWxfaW50NjRfb2Zfc3RyaW5nKGNhbWxfbmV3X3N0cmluZyhcIjB4ZDEzNDI1NDNkZTgyZWY5NVwiKSk7XG4gIHZhciBkYWJhID0gY2FtbF9pbnQ2NF9vZl9zdHJpbmcoY2FtbF9uZXdfc3RyaW5nKFwiMHhkYWJhMGI2ZWIwOTMyMmUzXCIpKTtcbiAgdmFyIHosIHEwLCBxMTtcbiAgdmFyIHN0ID0gdjtcbiAgdmFyIGEgPSBnZXQoc3QsMCk7XG4gIHZhciBzID0gZ2V0KHN0LDEpO1xuICB2YXIgeDAgPSBnZXQoc3QsMik7XG4gIHZhciB4MSA9IGdldChzdCwzKTtcbiAgLyogQ29tYmluaW5nIG9wZXJhdGlvbiAqL1xuICB6ID0gYWRkKHMsIHgwKTtcbiAgLyogTWl4aW5nIGZ1bmN0aW9uICovXG4gIHogPSBtdWwoeG9yKHosc2hpZnRfcih6LDMyKSksIGRhYmEpO1xuICB6ID0gbXVsKHhvcih6LHNoaWZ0X3IoeiwzMikpLCBkYWJhKTtcbiAgeiA9IHhvcih6LHNoaWZ0X3IoeiwzMikpO1xuICAvKiBMQ0cgdXBkYXRlICovXG4gIHNldChzdCwgMSwgYWRkIChtdWwocyxNKSwgYSkpO1xuICAvKiBYQkcgdXBkYXRlICovXG4gIHZhciBxMCA9IHgwXG4gIHZhciBxMSA9IHgxXG4gIHExID0geG9yKHExLHEwKTtcbiAgcTAgPSByb3RsKHEwLCAyNCk7XG4gIHEwID0geG9yKHhvcihxMCwgcTEpLCAoc2hpZnRfbChxMSwxNikpKTtcbiAgcTEgPSByb3RsKHExLCAzNyk7XG4gIHNldChzdCwgMiwgcTApO1xuICBzZXQoc3QsIDMsIHExKTtcbiAgLyogUmV0dXJuIHJlc3VsdCAqL1xuICByZXR1cm4gejtcbn1cbiIsIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0aXZlIENhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgKi9cbi8qICBlbiBBdXRvbWF0aXF1ZS4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgICAgKi9cbi8qICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSwgd2l0aCAgICAgKi9cbi8qICB0aGUgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gZmlsZSAuLi9MSUNFTlNFLiAgICAgKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLyogJElkOiBwYXJzaW5nLmMgODk4MyAyMDA4LTA4LTA2IDA5OjM4OjI1WiB4bGVyb3kgJCAqL1xuXG4vKiBUaGUgUERBIGF1dG9tYXRvbiBmb3IgcGFyc2VycyBnZW5lcmF0ZWQgYnkgY2FtbHlhY2MgKi9cblxuLyogVGhlIHB1c2hkb3duIGF1dG9tYXRhICovXG5cbi8vUHJvdmlkZXM6IGNhbWxfcGFyc2VyX3RyYWNlXG52YXIgY2FtbF9wYXJzZXJfdHJhY2UgPSAwO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX3BhcnNlX2VuZ2luZVxuLy9SZXF1aXJlczogY2FtbF9sZXhfYXJyYXksIGNhbWxfcGFyc2VyX3RyYWNlLGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX21sX291dHB1dCwgY2FtbF9tbF9zdHJpbmdfbGVuZ3RoLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nLCBNbEJ5dGVzXG5mdW5jdGlvbiBjYW1sX3BhcnNlX2VuZ2luZSh0YWJsZXMsIGVudiwgY21kLCBhcmcpXG57XG4gIHZhciBFUlJDT0RFID0gMjU2O1xuXG4gIC8vdmFyIFNUQVJUID0gMDtcbiAgLy92YXIgVE9LRU5fUkVBRCA9IDE7XG4gIC8vdmFyIFNUQUNLU19HUk9XTl8xID0gMjtcbiAgLy92YXIgU1RBQ0tTX0dST1dOXzIgPSAzO1xuICAvL3ZhciBTRU1BTlRJQ19BQ1RJT05fQ09NUFVURUQgPSA0O1xuICAvL3ZhciBFUlJPUl9ERVRFQ1RFRCA9IDU7XG4gIHZhciBsb29wID0gNjtcbiAgdmFyIHRlc3RzaGlmdCA9IDc7XG4gIHZhciBzaGlmdCA9IDg7XG4gIHZhciBzaGlmdF9yZWNvdmVyID0gOTtcbiAgdmFyIHJlZHVjZSA9IDEwO1xuXG4gIHZhciBSRUFEX1RPS0VOID0gMDtcbiAgdmFyIFJBSVNFX1BBUlNFX0VSUk9SID0gMTtcbiAgdmFyIEdST1dfU1RBQ0tTXzEgPSAyO1xuICB2YXIgR1JPV19TVEFDS1NfMiA9IDM7XG4gIHZhciBDT01QVVRFX1NFTUFOVElDX0FDVElPTiA9IDQ7XG4gIHZhciBDQUxMX0VSUk9SX0ZVTkNUSU9OID0gNTtcblxuICB2YXIgZW52X3Nfc3RhY2sgPSAxO1xuICB2YXIgZW52X3Zfc3RhY2sgPSAyO1xuICB2YXIgZW52X3N5bWJfc3RhcnRfc3RhY2sgPSAzO1xuICB2YXIgZW52X3N5bWJfZW5kX3N0YWNrID0gNDtcbiAgdmFyIGVudl9zdGFja3NpemUgPSA1O1xuICB2YXIgZW52X3N0YWNrYmFzZSA9IDY7XG4gIHZhciBlbnZfY3Vycl9jaGFyID0gNztcbiAgdmFyIGVudl9sdmFsID0gODtcbiAgdmFyIGVudl9zeW1iX3N0YXJ0ID0gOTtcbiAgdmFyIGVudl9zeW1iX2VuZCA9IDEwO1xuICB2YXIgZW52X2FzcCA9IDExO1xuICB2YXIgZW52X3J1bGVfbGVuID0gMTI7XG4gIHZhciBlbnZfcnVsZV9udW1iZXIgPSAxMztcbiAgdmFyIGVudl9zcCA9IDE0O1xuICB2YXIgZW52X3N0YXRlID0gMTU7XG4gIHZhciBlbnZfZXJyZmxhZyA9IDE2O1xuXG4gIC8vIHZhciBfdGJsX2FjdGlvbnMgPSAxO1xuICB2YXIgdGJsX3RyYW5zbF9jb25zdCA9IDI7XG4gIHZhciB0YmxfdHJhbnNsX2Jsb2NrID0gMztcbiAgdmFyIHRibF9saHMgPSA0O1xuICB2YXIgdGJsX2xlbiA9IDU7XG4gIHZhciB0YmxfZGVmcmVkID0gNjtcbiAgdmFyIHRibF9kZ290byA9IDc7XG4gIHZhciB0Ymxfc2luZGV4ID0gODtcbiAgdmFyIHRibF9yaW5kZXggPSA5O1xuICB2YXIgdGJsX2dpbmRleCA9IDEwO1xuICB2YXIgdGJsX3RhYmxlc2l6ZSA9IDExO1xuICB2YXIgdGJsX3RhYmxlID0gMTI7XG4gIHZhciB0YmxfY2hlY2sgPSAxMztcbiAgLy8gdmFyIF90YmxfZXJyb3JfZnVuY3Rpb24gPSAxNDtcbiAgdmFyIHRibF9uYW1lc19jb25zdCA9IDE1O1xuICB2YXIgdGJsX25hbWVzX2Jsb2NrID0gMTY7XG5cblxuICBmdW5jdGlvbiBsb2coeCkge1xuICAgIHZhciBzID0gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyh4ICsgXCJcXG5cIik7XG4gICAgY2FtbF9tbF9vdXRwdXQoMiwgcywgMCwgY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRva2VuX25hbWUobmFtZXMsIG51bWJlcilcbiAge1xuICAgIHZhciBzdHIgPSBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhuYW1lcyk7XG4gICAgaWYgKHN0clswXSA9PSAnXFx4MDAnKVxuICAgICAgcmV0dXJuIFwiPHVua25vd24gdG9rZW4+XCI7XG4gICAgcmV0dXJuIHN0ci5zcGxpdCgnXFx4MDAnKVtudW1iZXJdO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJpbnRfdG9rZW4oc3RhdGUsIHRvaylcbiAge1xuICAgIHZhciB0b2tlbiwga2luZDtcbiAgICBpZiAodG9rIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIHRva2VuID0gdG9rZW5fbmFtZSh0YWJsZXNbdGJsX25hbWVzX2Jsb2NrXSwgdG9rWzBdKTtcbiAgICAgIGlmICh0eXBlb2YgdG9rWzFdID09IFwibnVtYmVyXCIpXG4gICAgICAgIGtpbmQgPSBcIlwiICsgdG9rWzFdO1xuICAgICAgZWxzZSBpZiAodHlwZW9mIHRva1sxXSA9PSBcInN0cmluZ1wiKVxuICAgICAgICBraW5kID0gdG9rWzFdXG4gICAgICBlbHNlIGlmICh0b2tbMV0gaW5zdGFuY2VvZiBNbEJ5dGVzKVxuICAgICAgICBraW5kID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyh0b2tbMV0pXG4gICAgICBlbHNlXG4gICAgICAgIGtpbmQgPSBcIl9cIlxuICAgICAgbG9nKFwiU3RhdGUgXCIgKyBzdGF0ZSArIFwiOiByZWFkIHRva2VuIFwiICsgdG9rZW4gKyBcIihcIiArIGtpbmQgKyBcIilcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRva2VuID0gdG9rZW5fbmFtZSh0YWJsZXNbdGJsX25hbWVzX2NvbnN0XSwgdG9rKTtcbiAgICAgIGxvZyhcIlN0YXRlIFwiICsgc3RhdGUgKyBcIjogcmVhZCB0b2tlbiBcIiArIHRva2VuKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIXRhYmxlcy5kZ290bykge1xuICAgIHRhYmxlcy5kZWZyZWQgPSBjYW1sX2xleF9hcnJheSAodGFibGVzW3RibF9kZWZyZWRdKTtcbiAgICB0YWJsZXMuc2luZGV4ID0gY2FtbF9sZXhfYXJyYXkgKHRhYmxlc1t0Ymxfc2luZGV4XSk7XG4gICAgdGFibGVzLmNoZWNrICA9IGNhbWxfbGV4X2FycmF5ICh0YWJsZXNbdGJsX2NoZWNrXSk7XG4gICAgdGFibGVzLnJpbmRleCA9IGNhbWxfbGV4X2FycmF5ICh0YWJsZXNbdGJsX3JpbmRleF0pO1xuICAgIHRhYmxlcy50YWJsZSAgPSBjYW1sX2xleF9hcnJheSAodGFibGVzW3RibF90YWJsZV0pO1xuICAgIHRhYmxlcy5sZW4gICAgPSBjYW1sX2xleF9hcnJheSAodGFibGVzW3RibF9sZW5dKTtcbiAgICB0YWJsZXMubGhzICAgID0gY2FtbF9sZXhfYXJyYXkgKHRhYmxlc1t0YmxfbGhzXSk7XG4gICAgdGFibGVzLmdpbmRleCA9IGNhbWxfbGV4X2FycmF5ICh0YWJsZXNbdGJsX2dpbmRleF0pO1xuICAgIHRhYmxlcy5kZ290byAgPSBjYW1sX2xleF9hcnJheSAodGFibGVzW3RibF9kZ290b10pO1xuICB9XG5cbiAgdmFyIHJlcyA9IDAsIG4sIG4xLCBuMiwgc3RhdGUxO1xuXG4gIC8vIFJFU1RPUkVcbiAgdmFyIHNwID0gZW52W2Vudl9zcF07XG4gIHZhciBzdGF0ZSA9IGVudltlbnZfc3RhdGVdO1xuICB2YXIgZXJyZmxhZyA9IGVudltlbnZfZXJyZmxhZ107XG5cbiAgZXhpdDpmb3IgKDs7KSB7XG4gICAgbmV4dDpzd2l0Y2goY21kKSB7XG4gICAgY2FzZSAwOi8vU1RBUlQ6XG4gICAgICBzdGF0ZSA9IDA7XG4gICAgICBlcnJmbGFnID0gMDtcbiAgICAgIC8vIEZhbGwgdGhyb3VnaFxuXG4gICAgY2FzZSA2Oi8vbG9vcDpcbiAgICAgIG4gPSB0YWJsZXMuZGVmcmVkW3N0YXRlXTtcbiAgICAgIGlmIChuICE9IDApIHsgY21kID0gcmVkdWNlOyBicmVhazsgfVxuICAgICAgaWYgKGVudltlbnZfY3Vycl9jaGFyXSA+PSAwKSB7IGNtZCA9IHRlc3RzaGlmdDsgYnJlYWs7IH1cbiAgICAgIHJlcyA9IFJFQURfVE9LRU47XG4gICAgICBicmVhayBleGl0O1xuICAgICAgLyogVGhlIE1MIGNvZGUgY2FsbHMgdGhlIGxleGVyIGFuZCB1cGRhdGVzICovXG4gICAgICAvKiBzeW1iX3N0YXJ0IGFuZCBzeW1iX2VuZCAqL1xuICAgIGNhc2UgMTovL1RPS0VOX1JFQUQ6XG4gICAgICBpZiAoYXJnIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgZW52W2Vudl9jdXJyX2NoYXJdID0gdGFibGVzW3RibF90cmFuc2xfYmxvY2tdW2FyZ1swXSArIDFdO1xuICAgICAgICBlbnZbZW52X2x2YWxdID0gYXJnWzFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW52W2Vudl9jdXJyX2NoYXJdID0gdGFibGVzW3RibF90cmFuc2xfY29uc3RdW2FyZyArIDFdO1xuICAgICAgICBlbnZbZW52X2x2YWxdID0gMDtcbiAgICAgIH1cbiAgICAgIGlmIChjYW1sX3BhcnNlcl90cmFjZSkgcHJpbnRfdG9rZW4gKHN0YXRlLCBhcmcpO1xuICAgICAgLy8gRmFsbCB0aHJvdWdoXG5cbiAgICBjYXNlIDc6Ly90ZXN0c2hpZnQ6XG4gICAgICBuMSA9IHRhYmxlcy5zaW5kZXhbc3RhdGVdO1xuICAgICAgbjIgPSBuMSArIGVudltlbnZfY3Vycl9jaGFyXTtcbiAgICAgIGlmIChuMSAhPSAwICYmIG4yID49IDAgJiYgbjIgPD0gdGFibGVzW3RibF90YWJsZXNpemVdICYmXG4gICAgICAgICAgdGFibGVzLmNoZWNrW24yXSA9PSBlbnZbZW52X2N1cnJfY2hhcl0pIHtcbiAgICAgICAgY21kID0gc2hpZnQ7IGJyZWFrO1xuICAgICAgfVxuICAgICAgbjEgPSB0YWJsZXMucmluZGV4W3N0YXRlXTtcbiAgICAgIG4yID0gbjEgKyBlbnZbZW52X2N1cnJfY2hhcl07XG4gICAgICBpZiAobjEgIT0gMCAmJiBuMiA+PSAwICYmIG4yIDw9IHRhYmxlc1t0YmxfdGFibGVzaXplXSAmJlxuICAgICAgICAgIHRhYmxlcy5jaGVja1tuMl0gPT0gZW52W2Vudl9jdXJyX2NoYXJdKSB7XG4gICAgICAgIG4gPSB0YWJsZXMudGFibGVbbjJdO1xuICAgICAgICBjbWQgPSByZWR1Y2U7IGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGVycmZsYWcgPD0gMCkge1xuICAgICAgICByZXMgPSBDQUxMX0VSUk9SX0ZVTkNUSU9OO1xuICAgICAgICBicmVhayBleGl0O1xuICAgICAgfVxuICAgICAgLy8gRmFsbCB0aHJvdWdoXG4gICAgICAvKiBUaGUgTUwgY29kZSBjYWxscyB0aGUgZXJyb3IgZnVuY3Rpb24gKi9cbiAgICBjYXNlIDU6Ly9FUlJPUl9ERVRFQ1RFRDpcbiAgICAgIGlmIChlcnJmbGFnIDwgMykge1xuICAgICAgICBlcnJmbGFnID0gMztcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgIHN0YXRlMSA9IGVudltlbnZfc19zdGFja11bc3AgKyAxXTtcbiAgICAgICAgICBuMSA9IHRhYmxlcy5zaW5kZXhbc3RhdGUxXTtcbiAgICAgICAgICBuMiA9IG4xICsgRVJSQ09ERTtcbiAgICAgICAgICBpZiAobjEgIT0gMCAmJiBuMiA+PSAwICYmIG4yIDw9IHRhYmxlc1t0YmxfdGFibGVzaXplXSAmJlxuICAgICAgICAgICAgICB0YWJsZXMuY2hlY2tbbjJdID09IEVSUkNPREUpIHtcbiAgICAgICAgICAgIGlmIChjYW1sX3BhcnNlcl90cmFjZSlcbiAgICAgICAgICAgICAgbG9nKFwiUmVjb3ZlcmluZyBpbiBzdGF0ZSBcIiArIHN0YXRlMSk7XG4gICAgICAgICAgICBjbWQgPSBzaGlmdF9yZWNvdmVyOyBicmVhayBuZXh0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoY2FtbF9wYXJzZXJfdHJhY2UpXG4gICAgICAgICAgICAgIGxvZyhcIkRpc2NhcmRpbmcgc3RhdGUgXCIgKyBzdGF0ZTEpO1xuICAgICAgICAgICAgaWYgKHNwIDw9IGVudltlbnZfc3RhY2tiYXNlXSkge1xuICAgICAgICAgICAgICBpZiAoY2FtbF9wYXJzZXJfdHJhY2UpXG4gICAgICAgICAgICAgICAgbG9nKFwiTm8gbW9yZSBzdGF0ZXMgdG8gZGlzY2FyZFwiKTtcbiAgICAgICAgICAgICAgcmV0dXJuIFJBSVNFX1BBUlNFX0VSUk9SO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogVGhlIE1MIGNvZGUgcmFpc2VzIFBhcnNlX2Vycm9yICovXG4gICAgICAgICAgICBzcC0tO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGVudltlbnZfY3Vycl9jaGFyXSA9PSAwKVxuICAgICAgICAgIHJldHVybiBSQUlTRV9QQVJTRV9FUlJPUjsgLyogVGhlIE1MIGNvZGUgcmFpc2VzIFBhcnNlX2Vycm9yICovXG4gICAgICAgIGlmIChjYW1sX3BhcnNlcl90cmFjZSlcbiAgICAgICAgICBsb2coXCJEaXNjYXJkaW5nIGxhc3QgdG9rZW4gcmVhZFwiKTtcbiAgICAgICAgZW52W2Vudl9jdXJyX2NoYXJdID0gLTE7XG4gICAgICAgIGNtZCA9IGxvb3A7IGJyZWFrO1xuICAgICAgfVxuICAgICAgLy8gRmFsbCB0aHJvdWdoXG4gICAgY2FzZSA4Oi8vc2hpZnQ6XG4gICAgICBlbnZbZW52X2N1cnJfY2hhcl0gPSAtMTtcbiAgICAgIGlmIChlcnJmbGFnID4gMCkgZXJyZmxhZy0tO1xuICAgICAgLy8gRmFsbCB0aHJvdWdoXG4gICAgY2FzZSA5Oi8vc2hpZnRfcmVjb3ZlcjpcbiAgICAgIGlmIChjYW1sX3BhcnNlcl90cmFjZSlcbiAgICAgICAgbG9nKFwiU3RhdGUgXCIgKyBzdGF0ZSArIFwiOiBzaGlmdCB0byBzdGF0ZSBcIiArIHRhYmxlcy50YWJsZVtuMl0pO1xuICAgICAgc3RhdGUgPSB0YWJsZXMudGFibGVbbjJdO1xuICAgICAgc3ArKztcbiAgICAgIGlmIChzcCA+PSBlbnZbZW52X3N0YWNrc2l6ZV0pIHtcbiAgICAgICAgcmVzID0gR1JPV19TVEFDS1NfMTtcbiAgICAgICAgYnJlYWsgZXhpdDtcbiAgICAgIH1cbiAgICAgIC8vIEZhbGwgdGhyb3VnaFxuICAgICAgLyogVGhlIE1MIGNvZGUgcmVzaXplcyB0aGUgc3RhY2tzICovXG4gICAgY2FzZSAyOi8vU1RBQ0tTX0dST1dOXzE6XG4gICAgICBlbnZbZW52X3Nfc3RhY2tdW3NwICsgMV0gPSBzdGF0ZTtcbiAgICAgIGVudltlbnZfdl9zdGFja11bc3AgKyAxXSA9IGVudltlbnZfbHZhbF07XG4gICAgICBlbnZbZW52X3N5bWJfc3RhcnRfc3RhY2tdW3NwICsgMV0gPSBlbnZbZW52X3N5bWJfc3RhcnRdO1xuICAgICAgZW52W2Vudl9zeW1iX2VuZF9zdGFja11bc3AgKyAxXSA9IGVudltlbnZfc3ltYl9lbmRdO1xuICAgICAgY21kID0gbG9vcDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAxMDovL3JlZHVjZTpcbiAgICAgIGlmIChjYW1sX3BhcnNlcl90cmFjZSlcbiAgICAgICAgbG9nKFwiU3RhdGUgXCIgKyBzdGF0ZSArIFwiOiByZWR1Y2UgYnkgcnVsZSBcIiArIG4pO1xuICAgICAgdmFyIG0gPSB0YWJsZXMubGVuW25dO1xuICAgICAgZW52W2Vudl9hc3BdID0gc3A7XG4gICAgICBlbnZbZW52X3J1bGVfbnVtYmVyXSA9IG47XG4gICAgICBlbnZbZW52X3J1bGVfbGVuXSA9IG07XG4gICAgICBzcCA9IHNwIC0gbSArIDE7XG4gICAgICBtID0gdGFibGVzLmxoc1tuXTtcbiAgICAgIHN0YXRlMSA9IGVudltlbnZfc19zdGFja11bc3BdO1xuICAgICAgbjEgPSB0YWJsZXMuZ2luZGV4W21dO1xuICAgICAgbjIgPSBuMSArIHN0YXRlMTtcbiAgICAgIGlmIChuMSAhPSAwICYmIG4yID49IDAgJiYgbjIgPD0gdGFibGVzW3RibF90YWJsZXNpemVdICYmXG4gICAgICAgICAgdGFibGVzLmNoZWNrW24yXSA9PSBzdGF0ZTEpXG4gICAgICAgIHN0YXRlID0gdGFibGVzLnRhYmxlW24yXTtcbiAgICAgIGVsc2VcbiAgICAgICAgc3RhdGUgPSB0YWJsZXMuZGdvdG9bbV07XG4gICAgICBpZiAoc3AgPj0gZW52W2Vudl9zdGFja3NpemVdKSB7XG4gICAgICAgIHJlcyA9IEdST1dfU1RBQ0tTXzI7XG4gICAgICAgIGJyZWFrIGV4aXQ7XG4gICAgICB9XG4gICAgICAvLyBGYWxsIHRocm91Z2hcbiAgICAgIC8qIFRoZSBNTCBjb2RlIHJlc2l6ZXMgdGhlIHN0YWNrcyAqL1xuICAgIGNhc2UgMzovL1NUQUNLU19HUk9XTl8yOlxuICAgICAgcmVzID0gQ09NUFVURV9TRU1BTlRJQ19BQ1RJT047XG4gICAgICBicmVhayBleGl0O1xuICAgICAgLyogVGhlIE1MIGNvZGUgY2FsbHMgdGhlIHNlbWFudGljIGFjdGlvbiAqL1xuICAgIGNhc2UgNDovL1NFTUFOVElDX0FDVElPTl9DT01QVVRFRDpcbiAgICAgIGVudltlbnZfc19zdGFja11bc3AgKyAxXSA9IHN0YXRlO1xuICAgICAgZW52W2Vudl92X3N0YWNrXVtzcCArIDFdID0gYXJnO1xuICAgICAgdmFyIGFzcCA9IGVudltlbnZfYXNwXTtcbiAgICAgIGVudltlbnZfc3ltYl9lbmRfc3RhY2tdW3NwICsgMV0gPSBlbnZbZW52X3N5bWJfZW5kX3N0YWNrXVthc3AgKyAxXTtcbiAgICAgIGlmIChzcCA+IGFzcCkge1xuICAgICAgICAvKiBUaGlzIGlzIGFuIGVwc2lsb24gcHJvZHVjdGlvbi4gVGFrZSBzeW1iX3N0YXJ0IGVxdWFsIHRvIHN5bWJfZW5kLiAqL1xuICAgICAgICBlbnZbZW52X3N5bWJfc3RhcnRfc3RhY2tdW3NwICsgMV0gPSBlbnZbZW52X3N5bWJfZW5kX3N0YWNrXVthc3AgKyAxXTtcbiAgICAgIH1cbiAgICAgIGNtZCA9IGxvb3A7IGJyZWFrO1xuICAgICAgLyogU2hvdWxkIG5vdCBoYXBwZW4gKi9cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFJBSVNFX1BBUlNFX0VSUk9SO1xuICAgIH1cbiAgfVxuICAvLyBTQVZFXG4gIGVudltlbnZfc3BdID0gc3A7XG4gIGVudltlbnZfc3RhdGVdID0gc3RhdGU7XG4gIGVudltlbnZfZXJyZmxhZ10gPSBlcnJmbGFnO1xuICByZXR1cm4gcmVzO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3NldF9wYXJzZXJfdHJhY2Vcbi8vUmVxdWlyZXM6IGNhbWxfcGFyc2VyX3RyYWNlXG5mdW5jdGlvbiBjYW1sX3NldF9wYXJzZXJfdHJhY2UoYm9vbCkge1xuICB2YXIgb2xkZmxhZyA9IGNhbWxfcGFyc2VyX3RyYWNlO1xuICBjYW1sX3BhcnNlcl90cmFjZSA9IGJvb2w7XG4gIHJldHVybiBvbGRmbGFnO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDIwIC0gSHVnbyBIZXV6YXJkXG4vLyBDb3B5cmlnaHQgKEMpIDIwMjAgLSBTaGFjaGFyIEl0emhha3lcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vIEJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9vY2FtbC9vY2FtbC9ibG9iLzQuMDcvb3RoZXJsaWJzL3N0ci9zdHJzdHVicy5jXG4vLyBDb3BpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vanNjb3EvanNjb3EvYmxvYi92OC4xMS9jb3EtanMvanNfc3R1Yi9zdHIuanNcblxuLy9Qcm92aWRlczogcmVfbWF0Y2hcbi8vUmVxdWlyZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmcsIGNhbWxfanNfZnJvbV9hcnJheSwgY2FtbF91aW50OF9hcnJheV9vZl9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX2dldFxuXG52YXIgcmVfbWF0Y2ggPSBmdW5jdGlvbigpe1xuICB2YXIgcmVfd29yZF9sZXR0ZXJzID0gW1xuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsICAgICAgIC8qIDB4MDAtMHgxRjogbm9uZSAqL1xuICAgIDB4MDAsIDB4MDAsIDB4RkYsIDB4MDMsICAgICAgIC8qIDB4MjAtMHgzRjogZGlnaXRzIDAtOSAqL1xuICAgIDB4RkUsIDB4RkYsIDB4RkYsIDB4ODcsICAgICAgIC8qIDB4NDAtMHg1RjogQSB0byBaLCBfICovXG4gICAgMHhGRSwgMHhGRiwgMHhGRiwgMHgwNywgICAgICAgLyogMHg2MC0weDdGOiBhIHRvIHogKi9cbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAgICAgICAvKiAweDgwLTB4OUY6IG5vbmUgKi9cbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAgICAgICAvKiAweEEwLTB4QkY6IG5vbmUgKi9cbiAgICAweEZGLCAweEZGLCAweDdGLCAweEZGLCAgICAgICAvKiAweEMwLTB4REY6IExhdGluLTEgYWNjZW50ZWQgdXBwZXJjYXNlICovXG4gICAgMHhGRiwgMHhGRiwgMHg3RiwgMHhGRiAgICAgICAgLyogMHhFMC0weEZGOiBMYXRpbi0xIGFjY2VudGVkIGxvd2VyY2FzZSAqL1xuICBdO1xuXG4gIHZhciBvcGNvZGVzID0ge1xuICAgIENIQVI6IDAsIENIQVJOT1JNOiAxLCBTVFJJTkc6IDIsIFNUUklOR05PUk06IDMsIENIQVJDTEFTUzogNCxcbiAgICBCT0w6IDUsIEVPTDogNiwgV09SREJPVU5EQVJZOiA3LFxuICAgIEJFR0dST1VQOiA4LCBFTkRHUk9VUDogOSwgUkVGR1JPVVA6IDEwLFxuICAgIEFDQ0VQVDogMTEsXG4gICAgU0lNUExFT1BUOiAxMiwgU0lNUExFU1RBUjogMTMsIFNJTVBMRVBMVVM6IDE0LFxuICAgIEdPVE86IDE1LCBQVVNIQkFDSzogMTYsIFNFVE1BUks6IDE3LFxuICAgIENIRUNLUFJPR1JFU1M6IDE4XG4gIH07XG5cbiAgZnVuY3Rpb24gaXNfd29yZF9sZXR0ZXIoYykge1xuICAgIHJldHVybiAocmVfd29yZF9sZXR0ZXJzWyAgKGMgPj4gMyldID4+IChjICYgNykpICYgMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluX2JpdHNldChzLGkpIHtcbiAgICByZXR1cm4gKGNhbWxfc3RyaW5nX2dldChzLChpID4+IDMpKSA+PiAoaSAmIDcpKSAmIDE7XG4gIH1cblxuICBmdW5jdGlvbiByZV9tYXRjaF9pbXBsKHJlLCBzLCBwb3MsIHBhcnRpYWwpIHtcblxuICAgIHZhciBwcm9nICAgICAgICAgID0gY2FtbF9qc19mcm9tX2FycmF5KHJlWzFdKSxcbiAgICAgICAgY3Bvb2wgICAgICAgICA9IGNhbWxfanNfZnJvbV9hcnJheShyZVsyXSksXG4gICAgICAgIG5vcm10YWJsZSAgICAgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKHJlWzNdKSxcbiAgICAgICAgbnVtZ3JvdXBzICAgICA9IHJlWzRdIHwgMCxcbiAgICAgICAgbnVtcmVnaXN0ZXJzICA9IHJlWzVdIHwgMCxcbiAgICAgICAgc3RhcnRjaGFycyAgICA9IHJlWzZdIHwgMDtcblxuICAgIHZhciBzID0gY2FtbF91aW50OF9hcnJheV9vZl9zdHJpbmcocyk7XG5cbiAgICB2YXIgcGMgPSAwLFxuICAgICAgICBxdWl0ID0gZmFsc2UsXG4gICAgICAgIHN0YWNrID0gW10sXG4gICAgICAgIGdyb3VwcyA9IG5ldyBBcnJheShudW1ncm91cHMpLFxuICAgICAgICByZV9yZWdpc3RlciA9IG5ldyBBcnJheShudW1yZWdpc3RlcnMpO1xuXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGdyb3Vwcy5sZW5ndGg7IGkrKyl7XG4gICAgICBncm91cHNbaV0gPSB7c3RhcnQ6IC0xLCBlbmQ6LTF9XG4gICAgfVxuICAgIGdyb3Vwc1swXS5zdGFydCA9IHBvcztcblxuICAgIHZhciBiYWNrdHJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB3aGlsZSAoc3RhY2subGVuZ3RoKSB7XG4gICAgICAgIHZhciBpdGVtID0gc3RhY2sucG9wKCk7XG4gICAgICAgIGlmIChpdGVtLnVuZG8pIHtcbiAgICAgICAgICBpdGVtLnVuZG8ub2JqW2l0ZW0udW5kby5wcm9wXSA9IGl0ZW0udW5kby52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmKGl0ZW0ucG9zKSB7XG4gICAgICAgICAgcGMgPSBpdGVtLnBvcy5wYztcbiAgICAgICAgICBwb3MgPSBpdGVtLnBvcy50eHQ7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBxdWl0ID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgdmFyIHB1c2ggPSBmdW5jdGlvbihpdGVtKSB7IHN0YWNrLnB1c2goaXRlbSk7IH07XG5cbiAgICB2YXIgYWNjZXB0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgZ3JvdXBzWzBdLmVuZCA9IHBvcztcbiAgICAgIHZhciByZXN1bHQgPSBuZXcgQXJyYXkoMSArIGdyb3Vwcy5sZW5ndGgqMik7XG4gICAgICByZXN1bHRbMF0gPSAwOyAvLyB0YWdcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgZyA9IGdyb3Vwc1tpXTtcbiAgICAgICAgaWYoZy5zdGFydCA8IDAgfHwgZy5lbmQgPCAwKSB7XG4gICAgICAgICAgZy5zdGFydCA9IGcuZW5kID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0WzIqaSArIDEgXSA9IGcuc3RhcnQ7XG4gICAgICAgIHJlc3VsdFsyKmkgKyAxICsgMSBdID0gZy5lbmQ7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH07XG5cbiAgICB2YXIgcHJlZml4X21hdGNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYocGFydGlhbCkgcmV0dXJuIGFjY2VwdCAoKTtcbiAgICAgIGVsc2UgYmFja3RyYWNrICgpO1xuICAgIH1cblxuICAgIC8qIE1haW4gREZBIGludGVycHJldGVyIGxvb3AgKi9cbiAgICB3aGlsZSAoIXF1aXQpIHtcbiAgICAgIHZhciBvcCA9IHByb2dbcGNdICYgMHhmZixcbiAgICAgICAgICBzYXJnID0gcHJvZ1twY10gPj4gOCxcbiAgICAgICAgICB1YXJnID0gc2FyZyAmIDB4ZmYsXG4gICAgICAgICAgYyA9IHNbcG9zXSxcbiAgICAgICAgICBncm91cDtcblxuICAgICAgcGMrKztcblxuICAgICAgc3dpdGNoIChvcCkge1xuICAgICAgY2FzZSBvcGNvZGVzLkNIQVI6XG4gICAgICAgIGlmKHBvcyA9PT0gcy5sZW5ndGgpIHtwcmVmaXhfbWF0Y2ggKCk7IGJyZWFrfTtcbiAgICAgICAgaWYgKGMgPT09IHVhcmcpIHBvcysrO1xuICAgICAgICBlbHNlIGJhY2t0cmFjaygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5DSEFSTk9STTpcbiAgICAgICAgaWYocG9zID09PSBzLmxlbmd0aCkge3ByZWZpeF9tYXRjaCAoKTsgYnJlYWt9O1xuICAgICAgICBpZiAobm9ybXRhYmxlLmNoYXJDb2RlQXQoYykgPT09IHVhcmcpIHBvcysrO1xuICAgICAgICBlbHNlIGJhY2t0cmFjaygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5TVFJJTkc6XG4gICAgICAgIGZvciAodmFyIGFyZyA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcoY3Bvb2xbdWFyZ10pLCBpID0gMDsgaSA8IGFyZy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmKHBvcyA9PT0gcy5sZW5ndGgpIHtwcmVmaXhfbWF0Y2ggKCk7IGJyZWFrfTtcbiAgICAgICAgICBpZiAoYyA9PT0gYXJnLmNoYXJDb2RlQXQoaSkpXG4gICAgICAgICAgICBjID0gc1srK3Bvc107XG4gICAgICAgICAgZWxzZSB7IGJhY2t0cmFjaygpOyBicmVhazsgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLlNUUklOR05PUk06XG4gICAgICAgIGZvciAodmFyIGFyZyA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcoY3Bvb2xbdWFyZ10pLCBpID0gMDsgaSA8IGFyZy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmKHBvcyA9PT0gcy5sZW5ndGgpIHtwcmVmaXhfbWF0Y2ggKCk7IGJyZWFrfTtcbiAgICAgICAgICBpZiAobm9ybXRhYmxlLmNoYXJDb2RlQXQoYykgPT09IGFyZy5jaGFyQ29kZUF0KGkpKVxuICAgICAgICAgICAgYyA9IHNbKytwb3NdO1xuICAgICAgICAgIGVsc2UgeyBiYWNrdHJhY2soKTsgYnJlYWs7IH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5DSEFSQ0xBU1M6XG4gICAgICAgIGlmKHBvcyA9PT0gcy5sZW5ndGgpIHtwcmVmaXhfbWF0Y2ggKCk7IGJyZWFrfTtcbiAgICAgICAgaWYgKGluX2JpdHNldChjcG9vbFt1YXJnXSwgYykpIHBvcysrO1xuICAgICAgICBlbHNlIGJhY2t0cmFjaygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5CT0w6XG4gICAgICAgIGlmKHBvcyA+IDAgJiYgc1twb3MgLSAxXSAhPSAxMCAvKiBcXG4gKi8pIHtiYWNrdHJhY2soKX1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuRU9MOlxuICAgICAgICBpZihwb3MgPCBzLmxlbmd0aCAmJiBzW3Bvc10gIT0gMTAgLyogXFxuICovKSB7YmFja3RyYWNrKCl9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLldPUkRCT1VOREFSWTpcbiAgICAgICAgaWYocG9zID09IDApIHtcbiAgICAgICAgICBpZihwb3MgPT09IHMubGVuZ3RoKSB7cHJlZml4X21hdGNoICgpOyBicmVha307XG4gICAgICAgICAgaWYoaXNfd29yZF9sZXR0ZXIoc1swXSkpIGJyZWFrO1xuICAgICAgICAgIGJhY2t0cmFjaygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBvcyA9PT0gcy5sZW5ndGgpIHtcbiAgICAgICAgICBpZihpc193b3JkX2xldHRlcihzW3BvcyAtIDFdKSkgYnJlYWs7XG4gICAgICAgICAgYmFja3RyYWNrICgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmKGlzX3dvcmRfbGV0dGVyKHNbcG9zIC0gMV0pICE9IGlzX3dvcmRfbGV0dGVyKHNbcG9zXSkpIGJyZWFrO1xuICAgICAgICAgIGJhY2t0cmFjayAoKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5CRUdHUk9VUDpcbiAgICAgICAgZ3JvdXAgPSBncm91cHNbdWFyZ107XG4gICAgICAgIHB1c2goe3VuZG86IHtvYmo6Z3JvdXAsXG4gICAgICAgICAgICAgICAgICAgICBwcm9wOidzdGFydCcsXG4gICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZ3JvdXAuc3RhcnR9fSk7XG4gICAgICAgIGdyb3VwLnN0YXJ0ID0gcG9zO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5FTkRHUk9VUDpcbiAgICAgICAgZ3JvdXAgPSBncm91cHNbdWFyZ107XG4gICAgICAgIHB1c2goe3VuZG86IHtvYmo6IGdyb3VwLFxuICAgICAgICAgICAgICAgICAgICAgcHJvcDonZW5kJyxcbiAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBncm91cC5lbmR9fSk7XG4gICAgICAgIGdyb3VwLmVuZCA9IHBvcztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuUkVGR1JPVVA6XG4gICAgICAgIGdyb3VwID0gZ3JvdXBzW3VhcmddO1xuICAgICAgICBpZihncm91cC5zdGFydCA8IDAgfHwgZ3JvdXAuZW5kIDwgMCkge2JhY2t0cmFjayAoKTsgYnJlYWt9XG4gICAgICAgIGZvciAodmFyIGkgPSBncm91cC5zdGFydDsgaSA8IGdyb3VwLmVuZDsgaSsrKXtcbiAgICAgICAgICBpZihwb3MgPT09IHMubGVuZ3RoKSB7cHJlZml4X21hdGNoICgpOyBicmVha307XG4gICAgICAgICAgaWYoc1tpXSAhPSBzW3Bvc10pIHtiYWNrdHJhY2sgKCk7IGJyZWFrfVxuICAgICAgICAgIHBvcysrO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLlNJTVBMRU9QVDpcbiAgICAgICAgaWYgKGluX2JpdHNldChjcG9vbFt1YXJnXSwgYykpIHBvcysrO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5TSU1QTEVTVEFSOlxuICAgICAgICB3aGlsZSAoaW5fYml0c2V0KGNwb29sW3VhcmddLCBjKSlcbiAgICAgICAgICBjID0gc1srK3Bvc107XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLlNJTVBMRVBMVVM6XG4gICAgICAgIGlmKHBvcyA9PT0gcy5sZW5ndGgpIHtwcmVmaXhfbWF0Y2ggKCk7IGJyZWFrfTtcbiAgICAgICAgaWYgKGluX2JpdHNldChjcG9vbFt1YXJnXSwgYykpIHtcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBjID0gc1srK3Bvc107XG4gICAgICAgICAgfSB3aGlsZSAoaW5fYml0c2V0KGNwb29sW3VhcmddLCBjKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBiYWNrdHJhY2soKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuQUNDRVBUOlxuICAgICAgICByZXR1cm4gYWNjZXB0KCk7XG4gICAgICBjYXNlIG9wY29kZXMuR09UTzpcbiAgICAgICAgcGMgPSBwYyArIHNhcmc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLlBVU0hCQUNLOlxuICAgICAgICBwdXNoKHtwb3M6IHtwYzogcGMgKyBzYXJnLCB0eHQ6IHBvc319KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuU0VUTUFSSzpcbiAgICAgICAgcHVzaCh7dW5kbzoge29iajpyZV9yZWdpc3RlcixcbiAgICAgICAgICAgICAgICAgICAgIHByb3A6IHVhcmcsXG4gICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcmVfcmVnaXN0ZXJbdWFyZ119fSk7XG4gICAgICAgIHJlX3JlZ2lzdGVyW3VhcmddID0gcG9zO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5DSEVDS1BST0dSRVNTOlxuICAgICAgICBpZiAocmVfcmVnaXN0ZXJbdWFyZ10gPT09IHBvcykgYmFja3RyYWNrKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBieXRlY29kZVwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICByZXR1cm4gcmVfbWF0Y2hfaW1wbDtcbn0oKTtcblxuXG4vL1Byb3ZpZGVzOiByZV9zZWFyY2hfZm9yd2FyZFxuLy9SZXF1aXJlczogcmVfbWF0Y2gsIGNhbWxfbWxfc3RyaW5nX2xlbmd0aCwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiByZV9zZWFyY2hfZm9yd2FyZChyZSwgcywgcG9zKSB7XG4gIGlmKHBvcyA8IDAgfHwgcG9zID4gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIlN0ci5zZWFyY2hfZm9yd2FyZFwiKVxuICB3aGlsZSAocG9zIDw9IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSkge1xuICAgIHZhciByZXMgPSByZV9tYXRjaChyZSwgcywgcG9zLCAwKTtcbiAgICBpZiAocmVzKSByZXR1cm4gcmVzO1xuICAgIHBvcysrO1xuICB9XG5cbiAgcmV0dXJuIFswXTsgIC8qIFt8fF0gOiBpbnQgYXJyYXkgKi9cbn1cblxuLy9Qcm92aWRlczogcmVfc2VhcmNoX2JhY2t3YXJkXG4vL1JlcXVpcmVzOiByZV9tYXRjaCwgY2FtbF9tbF9zdHJpbmdfbGVuZ3RoLCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIHJlX3NlYXJjaF9iYWNrd2FyZChyZSwgcywgcG9zKSB7XG4gIGlmKHBvcyA8IDAgfHwgcG9zID4gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIlN0ci5zZWFyY2hfYmFja3dhcmRcIilcbiAgd2hpbGUgKHBvcyA+PSAwKSB7XG4gICAgdmFyIHJlcyA9IHJlX21hdGNoKHJlLCBzLCBwb3MsIDApO1xuICAgIGlmIChyZXMpIHJldHVybiByZXM7XG4gICAgcG9zLS07XG4gIH1cblxuICByZXR1cm4gWzBdOyAgLyogW3x8XSA6IGludCBhcnJheSAqL1xufVxuXG5cbi8vUHJvdmlkZXM6IHJlX3N0cmluZ19tYXRjaFxuLy9SZXF1aXJlczogcmVfbWF0Y2gsIGNhbWxfbWxfc3RyaW5nX2xlbmd0aCwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiByZV9zdHJpbmdfbWF0Y2gocmUscyxwb3Mpe1xuICBpZihwb3MgPCAwIHx8IHBvcyA+IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSlcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJTdHIuc3RyaW5nX21hdGNoXCIpXG4gIHZhciByZXMgPSByZV9tYXRjaChyZSwgcywgcG9zLCAwKTtcbiAgaWYgKHJlcykgcmV0dXJuIHJlcztcbiAgZWxzZSByZXR1cm4gWzBdO1xufVxuXG4vL1Byb3ZpZGVzOiByZV9wYXJ0aWFsX21hdGNoXG4vL1JlcXVpcmVzOiByZV9tYXRjaCwgY2FtbF9tbF9zdHJpbmdfbGVuZ3RoLCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIHJlX3BhcnRpYWxfbWF0Y2gocmUscyxwb3Mpe1xuICBpZihwb3MgPCAwIHx8IHBvcyA+IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSlcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJTdHIucGFydGlhbF9tYXRjaFwiKVxuICB2YXIgcmVzID0gcmVfbWF0Y2gocmUsIHMsIHBvcywgMSk7XG4gIGlmIChyZXMpIHJldHVybiByZXM7XG4gIGVsc2UgcmV0dXJuIFswXTtcbn1cblxuLy9Qcm92aWRlczogcmVfcmVwbGFjZW1lbnRfdGV4dFxuLy9SZXF1aXJlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZywgY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuLy9SZXF1aXJlczogY2FtbF9hcnJheV9nZXRcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbi8vIGV4dGVybmFsIHJlX3JlcGxhY2VtZW50X3RleHQ6IHN0cmluZyAtPiBpbnQgYXJyYXkgLT4gc3RyaW5nIC0+IHN0cmluZ1xuZnVuY3Rpb24gcmVfcmVwbGFjZW1lbnRfdGV4dChyZXBsLGdyb3VwcyxvcmlnKSB7XG4gIHZhciByZXBsID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhyZXBsKTtcbiAgdmFyIGxlbiA9IHJlcGwubGVuZ3RoO1xuICB2YXIgb3JpZyA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcob3JpZyk7XG4gIHZhciByZXMgPSBcIlwiOyAvL3Jlc3VsdFxuICB2YXIgbiA9IDA7IC8vIGN1cnJlbnQgcG9zaXRpb25cbiAgdmFyIGN1cjsgLy9jdXJyZW50IGNoYXJcbiAgdmFyIHN0YXJ0LCBlbmQsIGM7XG4gIHdoaWxlKG4gPCBsZW4pe1xuICAgIGN1ciA9IHJlcGwuY2hhckF0KG4rKyk7XG4gICAgaWYoY3VyICE9ICdcXFxcJyl7XG4gICAgICByZXMgKz0gY3VyO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmKG4gPT0gbGVuKSBjYW1sX2ZhaWx3aXRoKFwiU3RyLnJlcGxhY2U6IGlsbGVnYWwgYmFja3NsYXNoIHNlcXVlbmNlXCIpO1xuICAgICAgY3VyID0gcmVwbC5jaGFyQXQobisrKTtcbiAgICAgIHN3aXRjaChjdXIpe1xuICAgICAgY2FzZSAnXFxcXCc6XG4gICAgICAgIHJlcyArPSBjdXI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnMCc6IGNhc2UgJzEnOiBjYXNlICcyJzogY2FzZSAnMyc6IGNhc2UgJzQnOlxuICAgICAgY2FzZSAnNSc6IGNhc2UgJzYnOiBjYXNlICc3JzogY2FzZSAnOCc6IGNhc2UgJzknOlxuICAgICAgICBjID0gK2N1cjtcbiAgICAgICAgaWYgKGMqMiA+PSBncm91cHMubGVuZ3RoIC0gMSApXG4gICAgICAgICAgY2FtbF9mYWlsd2l0aChcIlN0ci5yZXBsYWNlOiByZWZlcmVuY2UgdG8gdW5tYXRjaGVkIGdyb3VwXCIgKTtcbiAgICAgICAgc3RhcnQgPSBjYW1sX2FycmF5X2dldChncm91cHMsYyoyKTtcbiAgICAgICAgZW5kID0gY2FtbF9hcnJheV9nZXQoZ3JvdXBzLCBjKjIgKzEpO1xuICAgICAgICBpZiAoc3RhcnQgPT0gLTEpXG4gICAgICAgICAgY2FtbF9mYWlsd2l0aChcIlN0ci5yZXBsYWNlOiByZWZlcmVuY2UgdG8gdW5tYXRjaGVkIGdyb3VwXCIpO1xuICAgICAgICByZXMrPW9yaWcuc2xpY2Uoc3RhcnQsZW5kKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXMgKz0gKCdcXFxcJyAgKyBjdXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhyZXMpOyB9XG5cblxuLy9Qcm92aWRlczogY2FtbF9zdHJfaW5pdGlhbGl6ZVxuZnVuY3Rpb24gY2FtbF9zdHJfaW5pdGlhbGl6ZSh1bml0KSB7XG4gIHJldHVybiAwO1xufVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgIEJlbm9pdCBWYXVnb24sIEVOU1RBICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxNCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBQYWRkaW5nIHBvc2l0aW9uLiAqKVxudHlwZSBwYWR0eSA9XG4gIHwgTGVmdCAgICgqIFRleHQgaXMgbGVmdCBqdXN0aWZpZWQgKCctJyBvcHRpb24pLiAgICAgICAgICAgICAgICopXG4gIHwgUmlnaHQgICgqIFRleHQgaXMgcmlnaHQganVzdGlmaWVkIChubyAnLScgb3B0aW9uKS4gICAgICAgICAgICopXG4gIHwgWmVyb3MgICgqIFRleHQgaXMgcmlnaHQganVzdGlmaWVkIGJ5IHplcm9zIChzZWUgJzAnIG9wdGlvbikuICopXG5cbigqKiopXG5cbigqIEludGVnZXIgY29udmVyc2lvbi4gKilcbnR5cGUgaW50X2NvbnYgPVxuICB8IEludF9kIHwgSW50X3BkIHwgSW50X3NkICAgICAgICAoKiAgJWQgfCAlK2QgfCAlIGQgICopXG4gIHwgSW50X2kgfCBJbnRfcGkgfCBJbnRfc2kgICAgICAgICgqICAlaSB8ICUraSB8ICUgaSAgKilcbiAgfCBJbnRfeCB8IEludF9DeCAgICAgICAgICAgICAgICAgKCogICV4IHwgJSN4ICAgICAgICAqKVxuICB8IEludF9YIHwgSW50X0NYICAgICAgICAgICAgICAgICAoKiAgJVggfCAlI1ggICAgICAgICopXG4gIHwgSW50X28gfCBJbnRfQ28gICAgICAgICAgICAgICAgICgqICAlbyB8ICUjbyAgICAgICAgKilcbiAgfCBJbnRfdSAgICAgICAgICAgICAgICAgICAgICAgICAgKCogICV1ICAgICAgICAgICAgICAqKVxuICB8IEludF9DZCB8IEludF9DaSB8IEludF9DdSAgICAgICAoKiAgJSNkIHwgJSNpIHwgJSN1ICopXG5cbigqIEZsb2F0IGNvbnZlcnNpb24uICopXG50eXBlIGZsb2F0X2ZsYWdfY29udiA9XG4gIHwgRmxvYXRfZmxhZ18gICAgICAgICAgICAgICAgICAgICgqICVbZmVFZ0dGaEhdICopXG4gIHwgRmxvYXRfZmxhZ19wICAgICAgICAgICAgICAgICAgICgqICUrW2ZlRWdHRmhIXSAqKVxuICB8IEZsb2F0X2ZsYWdfcyAgICAgICAgICAgICAgICAgICAoKiAlIFtmZUVnR0ZoSF0gKilcbnR5cGUgZmxvYXRfa2luZF9jb252ID1cbiAgfCBGbG9hdF9mICAgICAgICAgICAgICAgICAgICAgICAgKCogICVmIHwgJStmIHwgJSBmICAqKVxuICB8IEZsb2F0X2UgICAgICAgICAgICAgICAgICAgICAgICAoKiAgJWUgfCAlK2UgfCAlIGUgICopXG4gIHwgRmxvYXRfRSAgICAgICAgICAgICAgICAgICAgICAgICgqICAlRSB8ICUrRSB8ICUgRSAgKilcbiAgfCBGbG9hdF9nICAgICAgICAgICAgICAgICAgICAgICAgKCogICVnIHwgJStnIHwgJSBnICAqKVxuICB8IEZsb2F0X0cgICAgICAgICAgICAgICAgICAgICAgICAoKiAgJUcgfCAlK0cgfCAlIEcgICopXG4gIHwgRmxvYXRfRiAgICAgICAgICAgICAgICAgICAgICAgICgqICAlRiB8ICUrRiB8ICUgRiAgKilcbiAgfCBGbG9hdF9oICAgICAgICAgICAgICAgICAgICAgICAgKCogICVoIHwgJStoIHwgJSBoICAqKVxuICB8IEZsb2F0X0ggICAgICAgICAgICAgICAgICAgICAgICAoKiAgJUggfCAlK0ggfCAlIEggICopXG4gIHwgRmxvYXRfQ0YgICAgICAgICAgICAgICAgICAgICAgICgqICAlI0Z8ICUrI0Z8ICUgI0YgKilcbnR5cGUgZmxvYXRfY29udiA9IGZsb2F0X2ZsYWdfY29udiAqIGZsb2F0X2tpbmRfY29udlxuXG4oKioqKVxuXG4oKiBDaGFyIHNldHMgKHNlZSAlWy4uLl0pIGFyZSBiaXRtYXBzIGltcGxlbWVudGVkIGFzIDMyLWNoYXIgc3RyaW5ncy4gKilcbnR5cGUgY2hhcl9zZXQgPSBzdHJpbmdcblxuKCoqKilcblxuKCogQ291bnRlciB1c2VkIGluIFNjYW5mLiAqKVxudHlwZSBjb3VudGVyID1cbiAgfCBMaW5lX2NvdW50ZXIgICAgICgqICAlbCAgICAgICopXG4gIHwgQ2hhcl9jb3VudGVyICAgICAoKiAgJW4gICAgICAqKVxuICB8IFRva2VuX2NvdW50ZXIgICAgKCogICVOLCAlTCAgKilcblxuKCoqKilcblxuKCogUGFkZGluZyBvZiBzdHJpbmdzIGFuZCBudW1iZXJzLiAqKVxudHlwZSAoJ2EsICdiKSBwYWRkaW5nID1cbiAgKCogTm8gcGFkZGluZyAoZXg6IFwiJWRcIikgKilcbiAgfCBOb19wYWRkaW5nICA6ICgnYSwgJ2EpIHBhZGRpbmdcbiAgKCogTGl0ZXJhbCBwYWRkaW5nIChleDogXCIlOGRcIikgKilcbiAgfCBMaXRfcGFkZGluZyA6IHBhZHR5ICogaW50IC0+ICgnYSwgJ2EpIHBhZGRpbmdcbiAgKCogUGFkZGluZyBhcyBleHRyYSBhcmd1bWVudCAoZXg6IFwiJSpkXCIpICopXG4gIHwgQXJnX3BhZGRpbmcgOiBwYWR0eSAtPiAoaW50IC0+ICdhLCAnYSkgcGFkZGluZ1xuXG4oKiBTb21lIGZvcm1hdHMsIHN1Y2ggYXMgJV9kLFxuICAgb25seSBhY2NlcHQgYW4gb3B0aW9uYWwgbnVtYmVyIGFzIHBhZGRpbmcgb3B0aW9uIChubyBleHRyYSBhcmd1bWVudCkgKilcbnR5cGUgcGFkX29wdGlvbiA9IGludCBvcHRpb25cblxuKCogUHJlY2lzaW9uIG9mIGZsb2F0cyBhbmQgJzAnLXBhZGRpbmcgb2YgaW50ZWdlcnMuICopXG50eXBlICgnYSwgJ2IpIHByZWNpc2lvbiA9XG4gICgqIE5vIHByZWNpc2lvbiAoZXg6IFwiJWZcIikgKilcbiAgfCBOb19wcmVjaXNpb24gOiAoJ2EsICdhKSBwcmVjaXNpb25cbiAgKCogTGl0ZXJhbCBwcmVjaXNpb24gKGV4OiBcIiUuM2ZcIikgKilcbiAgfCBMaXRfcHJlY2lzaW9uIDogaW50IC0+ICgnYSwgJ2EpIHByZWNpc2lvblxuICAoKiBQcmVjaXNpb24gYXMgZXh0cmEgYXJndW1lbnQgKGV4OiBcIiUuKmZcIikgKilcbiAgfCBBcmdfcHJlY2lzaW9uIDogKGludCAtPiAnYSwgJ2EpIHByZWNpc2lvblxuXG4oKiBTb21lIGZvcm1hdHMsIHN1Y2ggYXMgJV9mLFxuICAgb25seSBhY2NlcHQgYW4gb3B0aW9uYWwgbnVtYmVyIGFzIHByZWNpc2lvbiBvcHRpb24gKG5vIGV4dHJhIGFyZ3VtZW50KSAqKVxudHlwZSBwcmVjX29wdGlvbiA9IGludCBvcHRpb25cblxuKCogc2VlIHRoZSBDdXN0b20gZm9ybWF0IGNvbWJpbmF0b3IgKilcbnR5cGUgKCdhLCAnYiwgJ2MpIGN1c3RvbV9hcml0eSA9XG4gIHwgQ3VzdG9tX3plcm8gOiAoJ2EsIHN0cmluZywgJ2EpIGN1c3RvbV9hcml0eVxuICB8IEN1c3RvbV9zdWNjIDogKCdhLCAnYiwgJ2MpIGN1c3RvbV9hcml0eSAtPlxuICAgICgnYSwgJ3ggLT4gJ2IsICd4IC0+ICdjKSBjdXN0b21fYXJpdHlcblxuKCoqKilcblxuKCogICAgICAgIFJlbGF0aW9uYWwgZm9ybWF0IHR5cGVzXG5cbkluIHRoZSBmaXJzdCBmb3JtYXQrZ2FkdHMgaW1wbGVtZW50YXRpb24sIHRoZSB0eXBlIGZvciAlKC4uJSkgaW4gdGhlXG5mbXQgR0FEVCB3YXMgYXMgZm9sbG93czpcblxufCBGb3JtYXRfc3Vic3QgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlKC4uLiUpICopXG4gICAgcGFkX29wdGlvbiAqICgnZDEsICdxMSwgJ2QyLCAncTIpIHJlYWRlcl9uYl91bmlmaWVyICpcbiAgICAoJ3gsICdiLCAnYywgJ2QxLCAncTEsICd1KSBmbXR0eSAqXG4gICAgKCd1LCAnYiwgJ2MsICdxMSwgJ2UxLCAnZikgZm10IC0+XG4gICAgICAoKCd4LCAnYiwgJ2MsICdkMiwgJ3EyLCAndSkgZm9ybWF0NiAtPiAneCwgJ2IsICdjLCAnZDEsICdlMSwgJ2YpIGZtdFxuXG5Ob3RpY2UgdGhhdCB0aGUgJ3UgcGFyYW1ldGVyIGluICdmIHBvc2l0aW9uIGluIHRoZSBmb3JtYXQgYXJndW1lbnRcbigoJ3gsIC4uLCAndSkgZm9ybWF0NiAtPiAuLikgaXMgZXF1YWwgdG8gdGhlICd1IHBhcmFtZXRlciBpbiAnYVxucG9zaXRpb24gaW4gdGhlIGZvcm1hdCB0YWlsICgoJ3UsIC4uLCAnZikgZm10KS4gVGhpcyBtZWFucyB0aGF0IHRoZVxudHlwZSBvZiB0aGUgZXhwZWN0ZWQgZm9ybWF0IHBhcmFtZXRlciBkZXBlbmRzIG9mIHdoZXJlIHRoZSAlKC4uLiUpXG5hcmUgaW4gdGhlIGZvcm1hdCBzdHJpbmc6XG5cbiAgIyBQcmludGYucHJpbnRmIFwiJSglKVwiXG4gIC0gOiAodW5pdCwgb3V0X2NoYW5uZWwsIHVuaXQsICdfYSwgJ19hLCB1bml0KVxuICAgICAgQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzLmZvcm1hdDYgLT4gdW5pdFxuICA9IDxmdW4+XG4gICMgUHJpbnRmLnByaW50ZiBcIiUoJSklZFwiXG4gIC0gOiAoaW50IC0+IHVuaXQsIG91dF9jaGFubmVsLCB1bml0LCAnX2EsICdfYSwgaW50IC0+IHVuaXQpXG4gICAgICBDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3MuZm9ybWF0NiAtPiBpbnQgLT4gdW5pdFxuICA9IDxmdW4+XG5cbk9uIHRoZSBjb250cmFyeSwgdGhlIGxlZ2FjeSB0eXBlciBnaXZlcyBhIGNsZXZlciB0eXBlIHRoYXQgZG9lcyBub3RcbmRlcGVuZCBvbiB0aGUgcG9zaXRpb24gb2YgJSguLiUpIGluIHRoZSBmb3JtYXQgc3RyaW5nLiBGb3IgZXhhbXBsZSxcbiUoJSkgd2lsbCBoYXZlIHRoZSBwb2x5bW9ycGhpYyB0eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKTogaXQgY2FuXG5iZSBjb25jYXRlbmF0ZWQgdG8gYW55IGZvcm1hdCB0eXBlLCBhbmQgb25seSBlbmZvcmNlcyB0aGUgY29uc3RyYWludFxudGhhdCBpdHMgJ2EgYW5kICdmIHBhcmFtZXRlcnMgYXJlIGVxdWFsIChubyBmb3JtYXQgYXJndW1lbnRzKSBhbmQgJ2RcbmFuZCAnZSBhcmUgZXF1YWwgKG5vIHJlYWRlciBhcmd1bWVudCkuXG5cblRoZSB3ZWFrZW5pbmcgb2YgdGhpcyBwYXJhbWV0ZXIgdHlwZSBpbiB0aGUgR0FEVCB2ZXJzaW9uIGJyb2tlIHVzZXJcbmNvZGUgKGluIGZhY3QgaXQgZXNzZW50aWFsbHkgbWFkZSAlKC4uLiUpIHVudXNhYmxlIGV4Y2VwdCBhdCB0aGUgbGFzdFxucG9zaXRpb24gb2YgYSBmb3JtYXQpLiBJbiBwYXJ0aWN1bGFyLCB0aGUgZm9sbG93aW5nIHdvdWxkIG5vdCB3b3JrXG5hbnltb3JlOlxuXG4gIGZ1biBzZXAgLT5cbiAgICBGb3JtYXQucHJpbnRmIFwiZm9vJSglKWJhciUoJSliYXpcIiBzZXAgc2VwXG5cbkFzIHRoZSB0eXBlLWNoZWNrZXIgd291bGQgcmVxdWlyZSB0d28gKmluY29tcGF0aWJsZSogdHlwZXMgZm9yIHRoZSAlKCUpXG5pbiBkaWZmZXJlbnQgcG9zaXRpb25zLlxuXG5UaGUgc29sdXRpb24gdG8gcmVnYWluIGEgZ2VuZXJhbCB0eXBlIGZvciAlKC4uJSkgaXMgdG8gZ2VuZXJhbGl6ZSB0aGlzXG50ZWNobmlxdWUsIG5vdCBvbmx5IG9uIHRoZSAnZCwgJ2UgcGFyYW1ldGVycywgYnV0IG9uIGFsbCBzaXhcbnBhcmFtZXRlcnMgb2YgYSBmb3JtYXQ6IHdlIGludHJvZHVjZSBhIFwicmVsYXRpb25hbFwiIHR5cGVcbiAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbndob3NlIHZhbHVlcyBhcmUgcHJvb2ZzIHRoYXQgKCdhMSwgLi4sICdmMSkgYW5kICgnYTIsIC4uLCAnZjIpIG1vcmFsbHlcbmNvcnJlc3BvbmQgdG8gdGhlIHNhbWUgZm9ybWF0IHR5cGU6ICdhMSBpcyBvYnRhaW5lZCBmcm9tICdmMSwnYjEsJ2MxXG5pbiB0aGUgZXhhY3Qgc2FtZSB3YXkgdGhhdCAnYTIgaXMgb2J0YWluZWQgZnJvbSAnZjIsJ2IyLCdjMiwgZXRjLlxuXG5Gb3IgZXhhbXBsZSwgdGhlIHJlbGF0aW9uIGJldHdlZW4gdHdvIGZvcm1hdCB0eXBlcyBiZWdpbm5pbmcgd2l0aCBhIENoYXJcbnBhcmFtZXRlciBpcyBhcyBmb2xsb3dzOlxuXG58IENoYXJfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlYyAgKilcbiAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgKGNoYXIgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgY2hhciAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcblxuSW4gdGhlIGdlbmVyYWwgY2FzZSwgdGhlIHRlcm0gc3RydWN0dXJlIG9mIGZtdHR5X3JlbCBpcyAoYWxtb3N0WzFdKVxuaXNvbW9ycGhpYyB0byB0aGUgZm10dHkgb2YgdGhlIHByZXZpb3VzIGltcGxlbWVudGF0aW9uOiBldmVyeVxuY29uc3RydWN0b3IgaXMgcmUtcmVhZCB3aXRoIGEgYmluYXJ5LCByZWxhdGlvbmFsIHR5cGUsIGluc3RlYWQgb2YgdGhlXG5wcmV2aW91cyB1bmFyeSB0eXBpbmcuIGZtdHR5IGNhbiB0aGVuIGJlIHJlLWRlZmluZWQgYXMgdGhlIGRpYWdvbmFsIG9mXG5mbXR0eV9yZWw6XG5cbiAgdHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHkgPVxuICAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmLFxuICAgICAgICAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXR0eV9yZWxcblxuT25jZSB3ZSBoYXZlIHRoaXMgZm10dHlfcmVsIHR5cGUgaW4gcGxhY2UsIHdlIGNhbiBnaXZlIHRoZSBtb3JlXG5nZW5lcmFsIHR5cGUgdG8gJSguLi4lKTpcblxufCBGb3JtYXRfc3Vic3QgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlKC4uLiUpICopXG4gICAgcGFkX29wdGlvbiAqXG4gICAgKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wsXG4gICAgICdnMiwgJ2IsICdjLCAnajIsICdkLCAnYSkgZm10dHlfcmVsICpcbiAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgKCgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmb3JtYXQ2IC0+ICdnMiwgJ2IsICdjLCAnajIsICdlLCAnZikgZm10XG5cbldlIGFjY2VwdCBhbnkgZm9ybWF0ICgoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm9ybWF0NikgKHRoaXMgaXNcbmNvbXBsZXRlbHkgdW5yZWxhdGVkIHRvIHRoZSB0eXBlIG9mIHRoZSBjdXJyZW50IGZvcm1hdCksIGJ1dCBhbHNvXG5yZXF1aXJlIGEgcHJvb2YgdGhhdCB0aGlzIGZvcm1hdCBpcyBpbiByZWxhdGlvbiB0byBhbm90aGVyIGZvcm1hdCB0aGF0XG5pcyBjb25jYXRlbmFibGUgdG8gdGhlIGZvcm1hdCB0YWlsLiBXaGVuIGV4ZWN1dGluZyBhICUoLi4uJSkgZm9ybWF0XG4oaW4gY2FtbGludGVybmFsRm9ybWF0Lm1sOm1ha2VfcHJpbnRmIG9yIHNjYW5mLm1sOm1ha2Vfc2NhbmYpLCB3ZVxudHJhbnN0eXBlIHRoZSBmb3JtYXQgYWxvbmcgdGhpcyByZWxhdGlvbiB1c2luZyB0aGUgJ3JlY2FzdCcgZnVuY3Rpb25cbnRvIHRyYW5zcG9zZSBiZXR3ZWVuIHJlbGF0ZWQgZm9ybWF0IHR5cGVzLlxuXG4gIHZhbCByZWNhc3QgOlxuICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSkgZm10XG4gIC0+ICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG4gIC0+ICgnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXRcblxuTk9URSBbMV06IHRoZSB0eXBpbmcgb2YgRm9ybWF0X3N1YnN0X3R5IHJlcXVpcmVzIG5vdCBvbmUgZm9ybWF0IHR5cGUsIGJ1dFxudHdvLCBvbmUgdG8gZXN0YWJsaXNoIHRoZSBsaW5rIGJldHdlZW4gdGhlIGZvcm1hdCBhcmd1bWVudCBhbmQgdGhlXG5maXJzdCBzaXggcGFyYW1ldGVycywgYW5kIHRoZSBvdGhlciBmb3IgdGhlIGxpbmsgYmV0d2VlbiB0aGUgZm9ybWF0XG5hcmd1bWVudCBhbmQgdGhlIGxhc3Qgc2l4IHBhcmFtZXRlcnMuXG5cbnwgRm9ybWF0X3N1YnN0X3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICUoLi4uJSkgKilcbiAgICAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCxcbiAgICAgJ2cxLCAnYjEsICdjMSwgJ2oxLCAnZDEsICdhMSkgZm10dHlfcmVsICpcbiAgICAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCxcbiAgICAgJ2cyLCAnYjIsICdjMiwgJ2oyLCAnZDIsICdhMikgZm10dHlfcmVsICpcbiAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgKCgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmb3JtYXQ2IC0+ICdnMSwgJ2IxLCAnYzEsICdqMSwgJ2UxLCAnZjEsXG4gICAgICgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmb3JtYXQ2IC0+ICdnMiwgJ2IyLCAnYzIsICdqMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuXG5XaGVuIHdlIGdlbmVyYXRlIGEgZm9ybWF0IEFTVCwgd2UgZ2VuZXJhdGUgZXhhY3RseSB0aGUgc2FtZSB3aXRuZXNzXG5mb3IgYm90aCByZWxhdGlvbnMsIGFuZCB0aGUgd2l0bmVzcy1jb252ZXJzaW9uIGZ1bmN0aW9ucyBpblxuY2FtbGludGVybmFsRm9ybWF0IGRvIHJlbHkgb24gdGhpcyBpbnZhcmlhbnQuIEZvciBleGFtcGxlLCB0aGVcbmZ1bmN0aW9uIHRoYXQgcHJvdmVzIHRoYXQgdGhlIHJlbGF0aW9uIGlzIHRyYW5zaXRpdmVcblxuICB2YWwgdHJhbnMgOlxuICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICAtPiAoJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMixcbiAgICAgICdhMywgJ2IzLCAnYzMsICdkMywgJ2UzLCAnZjMpIGZtdHR5X3JlbFxuICAtPiAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICdhMywgJ2IzLCAnYzMsICdkMywgJ2UzLCAnZjMpIGZtdHR5X3JlbFxuXG5kb2VzIGFzc3VtZSB0aGF0IHRoZSB0d28gaW5wdXRzIGhhdmUgZXhhY3RseSB0aGUgc2FtZSB0ZXJtIHN0cnVjdHVyZVxuKGFuZCBpcyBvbmx5IGV2ZXJ5IHVzZWQgZm9yIGFyZ3VtZW50IHdpdG5lc3NlcyBvZiB0aGVcbkZvcm1hdF9zdWJzdF90eSBjb25zdHJ1Y3RvcikuXG4qKVxuXG4oKiBUeXBlIG9mIGEgYmxvY2sgdXNlZCBieSB0aGUgRm9ybWF0IHByZXR0eS1wcmludGVyLiAqKVxudHlwZSBibG9ja190eXBlID1cbiAgfCBQcF9oYm94ICAgKCogSG9yaXpvbnRhbCBibG9jayBubyBsaW5lIGJyZWFraW5nICopXG4gIHwgUHBfdmJveCAgICgqIFZlcnRpY2FsIGJsb2NrIGVhY2ggYnJlYWsgbGVhZHMgdG8gYSBuZXcgbGluZSAqKVxuICB8IFBwX2h2Ym94ICAoKiBIb3Jpem9udGFsLXZlcnRpY2FsIGJsb2NrOiBzYW1lIGFzIHZib3gsIGV4Y2VwdCBpZiB0aGlzIGJsb2NrXG4gICAgICAgICAgICAgICAgIGlzIHNtYWxsIGVub3VnaCB0byBmaXQgb24gYSBzaW5nbGUgbGluZSAqKVxuICB8IFBwX2hvdmJveCAoKiBIb3Jpem9udGFsIG9yIFZlcnRpY2FsIGJsb2NrOiBicmVha3MgbGVhZCB0byBuZXcgbGluZVxuICAgICAgICAgICAgICAgICBvbmx5IHdoZW4gbmVjZXNzYXJ5IHRvIHByaW50IHRoZSBjb250ZW50IG9mIHRoZSBibG9jayAqKVxuICB8IFBwX2JveCAgICAoKiBIb3Jpem9udGFsIG9yIEluZGVudCBibG9jazogYnJlYWtzIGxlYWQgdG8gbmV3IGxpbmVcbiAgICAgICAgICAgICAgICAgb25seSB3aGVuIG5lY2Vzc2FyeSB0byBwcmludCB0aGUgY29udGVudCBvZiB0aGUgYmxvY2ssIG9yXG4gICAgICAgICAgICAgICAgIHdoZW4gaXQgbGVhZHMgdG8gYSBuZXcgaW5kZW50YXRpb24gb2YgdGhlIGN1cnJlbnQgbGluZSAqKVxuICB8IFBwX2ZpdHMgICAoKiBJbnRlcm5hbCB1c2FnZTogd2hlbiBhIGJsb2NrIGZpdHMgb24gYSBzaW5nbGUgbGluZSAqKVxuXG4oKiBGb3JtYXR0aW5nIGVsZW1lbnQgdXNlZCBieSB0aGUgRm9ybWF0IHByZXR0eS1wcmludGVyLiAqKVxudHlwZSBmb3JtYXR0aW5nX2xpdCA9XG4gIHwgQ2xvc2VfYm94ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEBdICAgKilcbiAgfCBDbG9zZV90YWcgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQH0gICAqKVxuICB8IEJyZWFrIG9mIHN0cmluZyAqIGludCAqIGludCAgICAgICAgICAoKiBALCB8IEAgIHwgQDsgfCBAOzw+ICopXG4gIHwgRkZsdXNoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEA/ICAgKilcbiAgfCBGb3JjZV9uZXdsaW5lICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQFxcbiAgKilcbiAgfCBGbHVzaF9uZXdsaW5lICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQC4gICAqKVxuICB8IE1hZ2ljX3NpemUgb2Ygc3RyaW5nICogaW50ICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBAPG4+ICopXG4gIHwgRXNjYXBlZF9hdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEBAICAgKilcbiAgfCBFc2NhcGVkX3BlcmNlbnQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQCUlICAqKVxuICB8IFNjYW5faW5kaWMgb2YgY2hhciAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBAWCAgICopXG5cbigqIEZvcm1hdHRpbmcgZWxlbWVudCB1c2VkIGJ5IHRoZSBGb3JtYXQgcHJldHR5LXByaW50ZXIuICopXG50eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXR0aW5nX2dlbiA9XG4gIHwgT3Blbl90YWcgOiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiAtPiAgICAgICgqIEB7ICAgKilcbiAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0dGluZ19nZW5cbiAgfCBPcGVuX2JveCA6ICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2IC0+ICAgICAgKCogQFsgICAqKVxuICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXR0aW5nX2dlblxuXG4oKioqKVxuXG4oKiBMaXN0IG9mIGZvcm1hdCB0eXBlIGVsZW1lbnRzLiAqKVxuKCogSW4gcGFydGljdWxhciB1c2VkIHRvIHJlcHJlc2VudCAlKC4uLiUpIGFuZCAley4uLiV9IGNvbnRlbnRzLiAqKVxuYW5kICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXR0eSA9XG4gICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmLFxuICAgICAgJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHlfcmVsXG5hbmQgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCA9XG4gIHwgQ2hhcl90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVjICAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoY2hhciAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgIGNoYXIgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG4gIHwgU3RyaW5nX3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVzICAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoc3RyaW5nIC0+ICdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgc3RyaW5nIC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICB8IEludF90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlZCAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKGludCAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgIGludCAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgfCBJbnQzMl90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJWxkICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgIChpbnQzMiAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgIGludDMyIC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICB8IE5hdGl2ZWludF90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlbmQgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKG5hdGl2ZWludCAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgIG5hdGl2ZWludCAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgfCBJbnQ2NF90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJUxkICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgIChpbnQ2NCAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgIGludDY0IC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICB8IEZsb2F0X3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlZiAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKGZsb2F0IC0+ICdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgZmxvYXQgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG4gIHwgQm9vbF90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVCICAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoYm9vbCAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgIGJvb2wgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG5cbiAgfCBGb3JtYXRfYXJnX3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJXsuLi4lfSAqKVxuICAgICAgKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZtdHR5ICpcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKCgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmb3JtYXQ2IC0+ICdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZvcm1hdDYgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMilcbiAgICAgICAgICAgZm10dHlfcmVsXG4gIHwgRm9ybWF0X3N1YnN0X3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICUoLi4uJSkgKilcbiAgICAgICgnZywgJ2gsICdpLCAnaiwgJ2ssICdsLFxuICAgICAgICdnMSwgJ2IxLCAnYzEsICdqMSwgJ2QxLCAnYTEpIGZtdHR5X3JlbCAqXG4gICAgICAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCxcbiAgICAgICAnZzIsICdiMiwgJ2MyLCAnajIsICdkMiwgJ2EyKSBmbXR0eV9yZWwgKlxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZvcm1hdDYgLT4gJ2cxLCAnYjEsICdjMSwgJ2oxLCAnZTEsICdmMSxcbiAgICAgICAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm9ybWF0NiAtPiAnZzIsICdiMiwgJ2MyLCAnajIsICdlMiwgJ2YyKVxuICAgICAgICAgICBmbXR0eV9yZWxcblxuICAoKiBQcmludGYgYW5kIEZvcm1hdCBzcGVjaWZpYyBjb25zdHJ1Y3RvcnMuICopXG4gIHwgQWxwaGFfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVhICAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoKCdiMSAtPiAneCAtPiAnYzEpIC0+ICd4IC0+ICdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgKCdiMiAtPiAneCAtPiAnYzIpIC0+ICd4IC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICB8IFRoZXRhX3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAldCAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKCgnYjEgLT4gJ2MxKSAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICgnYjIgLT4gJ2MyKSAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgfCBBbnlfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIFVzZWQgZm9yIGN1c3RvbSBmb3JtYXRzICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgICgneCAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICd4IC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuXG4gICgqIFNjYW5mIHNwZWNpZmljIGNvbnN0cnVjdG9yLiAqKVxuICB8IFJlYWRlcl90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlciAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKCd4IC0+ICdhMSwgJ2IxLCAnYzEsICgnYjEgLT4gJ3gpIC0+ICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ3ggLT4gJ2EyLCAnYjIsICdjMiwgKCdiMiAtPiAneCkgLT4gJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfciAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICgnYjEgLT4gJ3gpIC0+ICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgKCdiMiAtPiAneCkgLT4gJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG5cbiAgfCBFbmRfb2ZfZm10dHkgOlxuICAgICAgKCdmMSwgJ2IxLCAnYzEsICdkMSwgJ2QxLCAnZjEsXG4gICAgICAgJ2YyLCAnYjIsICdjMiwgJ2QyLCAnZDIsICdmMikgZm10dHlfcmVsXG5cbigqKiopXG5cbigqIExpc3Qgb2YgZm9ybWF0IGVsZW1lbnRzLiAqKVxuYW5kICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgPVxuICB8IENoYXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVjICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgIChjaGFyIC0+ICdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IENhbWxfY2hhciA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVDICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgIChjaGFyIC0+ICdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IFN0cmluZyA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVzICopXG4gICAgICAoJ3gsIHN0cmluZyAtPiAnYSkgcGFkZGluZyAqICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCd4LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IENhbWxfc3RyaW5nIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVTICopXG4gICAgICAoJ3gsIHN0cmluZyAtPiAnYSkgcGFkZGluZyAqICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCd4LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IEludCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVbZGl4WHVvXSAqKVxuICAgICAgaW50X2NvbnYgKiAoJ3gsICd5KSBwYWRkaW5nICogKCd5LCBpbnQgLT4gJ2EpIHByZWNpc2lvbiAqXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgneCwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBJbnQzMiA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlbFtkaXhYdW9dICopXG4gICAgICBpbnRfY29udiAqICgneCwgJ3kpIHBhZGRpbmcgKiAoJ3ksIGludDMyIC0+ICdhKSBwcmVjaXNpb24gKlxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ3gsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgTmF0aXZlaW50IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJW5bZGl4WHVvXSAqKVxuICAgICAgaW50X2NvbnYgKiAoJ3gsICd5KSBwYWRkaW5nICogKCd5LCBuYXRpdmVpbnQgLT4gJ2EpIHByZWNpc2lvbiAqXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgneCwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBJbnQ2NCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlTFtkaXhYdW9dICopXG4gICAgICBpbnRfY29udiAqICgneCwgJ3kpIHBhZGRpbmcgKiAoJ3ksIGludDY0IC0+ICdhKSBwcmVjaXNpb24gKlxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ3gsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgRmxvYXQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJVtmZUVnR0ZoSF0gKilcbiAgICAgIGZsb2F0X2NvbnYgKiAoJ3gsICd5KSBwYWRkaW5nICogKCd5LCBmbG9hdCAtPiAnYSkgcHJlY2lzaW9uICpcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCd4LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IEJvb2wgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVbYkJdICopXG4gICAgICAoJ3gsIGJvb2wgLT4gJ2EpIHBhZGRpbmcgKiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgneCwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBGbHVzaCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlISAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG5cbiAgfCBTdHJpbmdfbGl0ZXJhbCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBhYmMgKilcbiAgICAgIHN0cmluZyAqICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IENoYXJfbGl0ZXJhbCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIHggKilcbiAgICAgIGNoYXIgKiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcblxuICB8IEZvcm1hdF9hcmcgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICV7Li4uJX0gKilcbiAgICAgIHBhZF9vcHRpb24gKiAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm10dHkgKlxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZvcm1hdDYgLT4gJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgRm9ybWF0X3N1YnN0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJSguLi4lKSAqKVxuICAgICAgcGFkX29wdGlvbiAqXG4gICAgICAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCxcbiAgICAgICAnZzIsICdiLCAnYywgJ2oyLCAnZCwgJ2EpIGZtdHR5X3JlbCAqXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAoKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZvcm1hdDYgLT4gJ2cyLCAnYiwgJ2MsICdqMiwgJ2UsICdmKSBmbXRcblxuICAoKiBQcmludGYgYW5kIEZvcm1hdCBzcGVjaWZpYyBjb25zdHJ1Y3Rvci4gKilcbiAgfCBBbHBoYSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlYSAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoKCdiIC0+ICd4IC0+ICdjKSAtPiAneCAtPiAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBUaGV0YSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAldCAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoKCdiIC0+ICdjKSAtPiAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcblxuICAoKiBGb3JtYXQgc3BlY2lmaWMgY29uc3RydWN0b3I6ICopXG4gIHwgRm9ybWF0dGluZ19saXQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQF8gKilcbiAgICAgIGZvcm1hdHRpbmdfbGl0ICogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgRm9ybWF0dGluZ19nZW4gOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEBfICopXG4gICAgICAoJ2ExLCAnYiwgJ2MsICdkMSwgJ2UxLCAnZjEpIGZvcm1hdHRpbmdfZ2VuICpcbiAgICAgICgnZjEsICdiLCAnYywgJ2UxLCAnZTIsICdmMikgZm10IC0+ICgnYTEsICdiLCAnYywgJ2QxLCAnZTIsICdmMikgZm10XG5cbiAgKCogU2NhbmYgc3BlY2lmaWMgY29uc3RydWN0b3JzOiAqKVxuICB8IFJlYWRlciA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVyICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgneCAtPiAnYSwgJ2IsICdjLCAoJ2IgLT4gJ3gpIC0+ICdkLCAnZSwgJ2YpIGZtdFxuICB8IFNjYW5fY2hhcl9zZXQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVbLi4uXSAqKVxuICAgICAgcGFkX29wdGlvbiAqIGNoYXJfc2V0ICogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoc3RyaW5nIC0+ICdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IFNjYW5fZ2V0X2NvdW50ZXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVbbmxOTF0gKilcbiAgICAgIGNvdW50ZXIgKiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgIChpbnQgLT4gJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgU2Nhbl9uZXh0X2NoYXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJTBjICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAoY2hhciAtPiAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBJZ25vcmVkX3BhcmFtIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlXyAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAneSwgJ3gpIGlnbm9yZWQgKiAoJ3gsICdiLCAnYywgJ3ksICdlLCAnZikgZm10IC0+XG4gICAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcblxuICAoKiBDdXN0b20gcHJpbnRpbmcgZm9ybWF0IChQUiM2NDUyLCBHUFIjMTQwKVxuXG4gICAgIFdlIGluY2x1ZGUgYSB0eXBlIEN1c3RvbSBvZiBcImN1c3RvbSBjb252ZXJ0ZXJzXCIsIHdoZXJlIGFuXG4gICAgIGFyYml0cmFyeSBmdW5jdGlvbiBjYW4gYmUgdXNlZCB0byBjb252ZXJ0IG9uZSBvciBtb3JlXG4gICAgIGFyZ3VtZW50cy4gVGhlcmUgaXMgbm8gc3ludGF4IGZvciBjdXN0b20gY29udmVydGVycywgaXQgaXMgb25seVxuICAgICBpbnRlbmRlZCBmb3IgY3VzdG9tIHByb2Nlc3NvcnMgdGhhdCB3aXNoIHRvIHJlbHkgb24gdGhlXG4gICAgIHN0ZGxpYi1kZWZpbmVkIGZvcm1hdCBHQURUcy5cblxuICAgICBGb3IgaW5zdGFuY2UgYSBwcmUtcHJvY2Vzc29yIGNvdWxkIGNob29zZSB0byBpbnRlcnByZXQgc3RyaW5nc1xuICAgICBwcmVmaXhlZCB3aXRoIFtcIiFcIl0gYXMgZm9ybWF0IHN0cmluZ3Mgd2hlcmUgWyV7eyAuLi4gfX1dIGlzXG4gICAgIGEgc3BlY2lhbCBmb3JtIHRvIHBhc3MgYSB0b19zdHJpbmcgZnVuY3Rpb24sIHNvIHRoYXQgb25lIGNvdWxkXG4gICAgIHdyaXRlOlxuXG4gICAgIHtbXG4gICAgICAgdHlwZSB0ID0geyB4IDogaW50OyB5IDogaW50IH1cblxuICAgICAgIGxldCBzdHJpbmdfb2ZfdCB0ID0gUHJpbnRmLnNwcmludGYgXCJ7IHggPSAlZDsgeSA9ICVkIH1cIiB0LnggdC55XG5cbiAgICAgICBQcmludGYucHJpbnRmICFcInQgPSAle3tzdHJpbmdfb2ZfdH19XCIgeyB4ID0gNDI7IHkgPSA0MiB9XG4gICAgIF19XG4gICopXG4gIHwgQ3VzdG9tIDpcbiAgICAgICgnYSwgJ3gsICd5KSBjdXN0b21fYXJpdHkgKiAodW5pdCAtPiAneCkgKiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAoJ3ksICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG5cbiAgKCogZW5kIG9mIGEgZm9ybWF0IHNwZWNpZmljYXRpb24gKilcbiAgfCBFbmRfb2ZfZm9ybWF0IDpcbiAgICAgICAgKCdmLCAnYiwgJ2MsICdlLCAnZSwgJ2YpIGZtdFxuXG4oKioqKVxuXG4oKiBUeXBlIGZvciBpZ25vcmVkIHBhcmFtZXRlcnMgKHNlZSBcIiVfXCIpLiAqKVxuYW5kICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBpZ25vcmVkID1cbiAgfCBJZ25vcmVkX2NoYXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX2MgKilcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9jYW1sX2NoYXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9DICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfc3RyaW5nIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfcyAqKVxuICAgICAgcGFkX29wdGlvbiAtPiAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfY2FtbF9zdHJpbmcgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfUyAqKVxuICAgICAgcGFkX29wdGlvbiAtPiAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfaW50IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfZCAqKVxuICAgICAgaW50X2NvbnYgKiBwYWRfb3B0aW9uIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9pbnQzMiA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9sZCAqKVxuICAgICAgaW50X2NvbnYgKiBwYWRfb3B0aW9uIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9uYXRpdmVpbnQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9uZCAqKVxuICAgICAgaW50X2NvbnYgKiBwYWRfb3B0aW9uIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9pbnQ2NCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9MZCAqKVxuICAgICAgaW50X2NvbnYgKiBwYWRfb3B0aW9uIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9mbG9hdCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9mICopXG4gICAgICBwYWRfb3B0aW9uICogcHJlY19vcHRpb24gLT4gKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX2Jvb2wgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX0IgKilcbiAgICAgIHBhZF9vcHRpb24gLT4gKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX2Zvcm1hdF9hcmcgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX3suLi4lfSAqKVxuICAgICAgcGFkX29wdGlvbiAqICgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmbXR0eSAtPlxuICAgICAgICAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfZm9ybWF0X3N1YnN0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfKC4uLiUpICopXG4gICAgICBwYWRfb3B0aW9uICogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdHR5IC0+XG4gICAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9yZWFkZXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9yICopXG4gICAgICAoJ2EsICdiLCAnYywgKCdiIC0+ICd4KSAtPiAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9zY2FuX2NoYXJfc2V0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9bLi4uXSAqKVxuICAgICAgcGFkX29wdGlvbiAqIGNoYXJfc2V0IC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9zY2FuX2dldF9jb3VudGVyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9bbmxOTF0gKilcbiAgICAgIGNvdW50ZXIgLT4gKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX3NjYW5fbmV4dF9jaGFyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlXzBjICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuXG5hbmQgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgPVxuICBGb3JtYXQgb2YgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAqIHN0cmluZ1xuXG5sZXQgcmVjIGVyYXNlX3JlbCA6IHR5cGUgYSBiIGMgZCBlIGYgZyBoIGkgaiBrIGwgLlxuICAoYSwgYiwgYywgZCwgZSwgZixcbiAgIGcsIGgsIGksIGosIGssIGwpIGZtdHR5X3JlbCAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10dHlcbj0gZnVuY3Rpb25cbiAgfCBDaGFyX3R5IHJlc3QgLT5cbiAgICBDaGFyX3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBTdHJpbmdfdHkgcmVzdCAtPlxuICAgIFN0cmluZ190eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgSW50X3R5IHJlc3QgLT5cbiAgICBJbnRfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IEludDMyX3R5IHJlc3QgLT5cbiAgICBJbnQzMl90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgSW50NjRfdHkgcmVzdCAtPlxuICAgIEludDY0X3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBOYXRpdmVpbnRfdHkgcmVzdCAtPlxuICAgIE5hdGl2ZWludF90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgRmxvYXRfdHkgcmVzdCAtPlxuICAgIEZsb2F0X3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBCb29sX3R5IHJlc3QgLT5cbiAgICBCb29sX3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBGb3JtYXRfYXJnX3R5ICh0eSwgcmVzdCkgLT5cbiAgICBGb3JtYXRfYXJnX3R5ICh0eSwgZXJhc2VfcmVsIHJlc3QpXG4gIHwgRm9ybWF0X3N1YnN0X3R5ICh0eTEsIF90eTIsIHJlc3QpIC0+XG4gICAgRm9ybWF0X3N1YnN0X3R5ICh0eTEsIHR5MSwgZXJhc2VfcmVsIHJlc3QpXG4gIHwgQWxwaGFfdHkgcmVzdCAtPlxuICAgIEFscGhhX3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBUaGV0YV90eSByZXN0IC0+XG4gICAgVGhldGFfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IEFueV90eSByZXN0IC0+XG4gICAgQW55X3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBSZWFkZXJfdHkgcmVzdCAtPlxuICAgIFJlYWRlcl90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgcmVzdCAtPlxuICAgIElnbm9yZWRfcmVhZGVyX3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBFbmRfb2ZfZm10dHkgLT4gRW5kX29mX2ZtdHR5XG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgKCogRm9ybWF0IHR5cGUgY29uY2F0ZW5hdGlvbiAqKVxuXG4oKiBDb25jYXRlbmF0ZSB0d28gZm9ybWF0IHR5cGVzLiAqKVxuKCogVXNlZCBieTpcbiAgICogcmVhZGVyX25iX3VuaWZpZXJfb2ZfZm10dHkgdG8gY291bnQgcmVhZGVycyBpbiBhbiBmbXR0eSxcbiAgICogU2NhbmYudGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyB0byBleHRyYWN0IHJlYWRlcnMgaW5zaWRlICUoLi4uJSksXG4gICAqIENhbWxpbnRlcm5hbEZvcm1hdC5mbXR0eV9vZl9pZ25vcmVkX2Zvcm1hdCB0byBleHRyYWN0IGZvcm1hdCB0eXBlLiAqKVxuXG4oKlxubGV0IHJlYyBjb25jYXRfZm10dHkgOiB0eXBlIGEgYiBjIGQgZSBmIGcgaCAuXG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5IC0+XG4gICAgKGYsIGIsIGMsIGUsIGcsIGgpIGZtdHR5IC0+XG4gICAgKGEsIGIsIGMsIGQsIGcsIGgpIGZtdHR5ID1cbiopXG5sZXQgcmVjIGNvbmNhdF9mbXR0eSA6XG4gIHR5cGUgYTEgYjEgYzEgZDEgZTEgZjFcbiAgICAgICBhMiBiMiBjMiBkMiBlMiBmMlxuICAgICAgIGcxIGoxIGcyIGoyXG4gIC5cbiAgICAoZzEsIGIxLCBjMSwgajEsIGQxLCBhMSxcbiAgICAgZzIsIGIyLCBjMiwgajIsIGQyLCBhMikgZm10dHlfcmVsIC0+XG4gICAgKGExLCBiMSwgYzEsIGQxLCBlMSwgZjEsXG4gICAgIGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIpIGZtdHR5X3JlbCAtPlxuICAgIChnMSwgYjEsIGMxLCBqMSwgZTEsIGYxLFxuICAgICBnMiwgYjIsIGMyLCBqMiwgZTIsIGYyKSBmbXR0eV9yZWwgPVxuZnVuIGZtdHR5MSBmbXR0eTIgLT4gbWF0Y2ggZm10dHkxIHdpdGhcbiAgfCBDaGFyX3R5IHJlc3QgLT5cbiAgICBDaGFyX3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgU3RyaW5nX3R5IHJlc3QgLT5cbiAgICBTdHJpbmdfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBJbnRfdHkgcmVzdCAtPlxuICAgIEludF90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IEludDMyX3R5IHJlc3QgLT5cbiAgICBJbnQzMl90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IE5hdGl2ZWludF90eSByZXN0IC0+XG4gICAgTmF0aXZlaW50X3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgSW50NjRfdHkgcmVzdCAtPlxuICAgIEludDY0X3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgRmxvYXRfdHkgcmVzdCAtPlxuICAgIEZsb2F0X3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgQm9vbF90eSByZXN0IC0+XG4gICAgQm9vbF90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IEFscGhhX3R5IHJlc3QgLT5cbiAgICBBbHBoYV90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IFRoZXRhX3R5IHJlc3QgLT5cbiAgICBUaGV0YV90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IEFueV90eSByZXN0IC0+XG4gICAgQW55X3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgUmVhZGVyX3R5IHJlc3QgLT5cbiAgICBSZWFkZXJfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBJZ25vcmVkX3JlYWRlcl90eSByZXN0IC0+XG4gICAgSWdub3JlZF9yZWFkZXJfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBGb3JtYXRfYXJnX3R5ICh0eSwgcmVzdCkgLT5cbiAgICBGb3JtYXRfYXJnX3R5ICh0eSwgY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IEZvcm1hdF9zdWJzdF90eSAodHkxLCB0eTIsIHJlc3QpIC0+XG4gICAgRm9ybWF0X3N1YnN0X3R5ICh0eTEsIHR5MiwgY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IEVuZF9vZl9mbXR0eSAtPiBmbXR0eTJcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEZvcm1hdCBjb25jYXRlbmF0aW9uICopXG5cbigqIENvbmNhdGVuYXRlIHR3byBmb3JtYXRzLiAqKVxubGV0IHJlYyBjb25jYXRfZm10IDogdHlwZSBhIGIgYyBkIGUgZiBnIGggLlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT5cbiAgICAoZiwgYiwgYywgZSwgZywgaCkgZm10IC0+XG4gICAgKGEsIGIsIGMsIGQsIGcsIGgpIGZtdCA9XG5mdW4gZm10MSBmbXQyIC0+IG1hdGNoIGZtdDEgd2l0aFxuICB8IFN0cmluZyAocGFkLCByZXN0KSAtPlxuICAgIFN0cmluZyAocGFkLCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBDYW1sX3N0cmluZyAocGFkLCByZXN0KSAtPlxuICAgIENhbWxfc3RyaW5nIChwYWQsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuXG4gIHwgSW50IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIEludCAoaWNvbnYsIHBhZCwgcHJlYywgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgSW50MzIgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgSW50MzIgKGljb252LCBwYWQsIHByZWMsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IE5hdGl2ZWludCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBOYXRpdmVpbnQgKGljb252LCBwYWQsIHByZWMsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IEludDY0IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIEludDY0IChpY29udiwgcGFkLCBwcmVjLCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBGbG9hdCAoZmNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBGbG9hdCAoZmNvbnYsIHBhZCwgcHJlYywgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG5cbiAgfCBDaGFyIChyZXN0KSAtPlxuICAgIENoYXIgKGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IENhbWxfY2hhciByZXN0IC0+XG4gICAgQ2FtbF9jaGFyIChjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBCb29sIChwYWQsIHJlc3QpIC0+XG4gICAgQm9vbCAocGFkLCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBBbHBoYSByZXN0IC0+XG4gICAgQWxwaGEgKGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IFRoZXRhIHJlc3QgLT5cbiAgICBUaGV0YSAoY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgQ3VzdG9tIChhcml0eSwgZiwgcmVzdCkgLT5cbiAgICBDdXN0b20gKGFyaXR5LCBmLCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBSZWFkZXIgcmVzdCAtPlxuICAgIFJlYWRlciAoY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgRmx1c2ggcmVzdCAtPlxuICAgIEZsdXNoIChjb25jYXRfZm10IHJlc3QgZm10MilcblxuICB8IFN0cmluZ19saXRlcmFsIChzdHIsIHJlc3QpIC0+XG4gICAgU3RyaW5nX2xpdGVyYWwgKHN0ciwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgQ2hhcl9saXRlcmFsIChjaHIsIHJlc3QpIC0+XG4gICAgQ2hhcl9saXRlcmFsICAgKGNociwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG5cbiAgfCBGb3JtYXRfYXJnIChwYWQsIGZtdHR5LCByZXN0KSAtPlxuICAgIEZvcm1hdF9hcmcgICAocGFkLCBmbXR0eSwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgRm9ybWF0X3N1YnN0IChwYWQsIGZtdHR5LCByZXN0KSAtPlxuICAgIEZvcm1hdF9zdWJzdCAocGFkLCBmbXR0eSwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG5cbiAgfCBTY2FuX2NoYXJfc2V0ICh3aWR0aF9vcHQsIGNoYXJfc2V0LCByZXN0KSAtPlxuICAgIFNjYW5fY2hhcl9zZXQgKHdpZHRoX29wdCwgY2hhcl9zZXQsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IFNjYW5fZ2V0X2NvdW50ZXIgKGNvdW50ZXIsIHJlc3QpIC0+XG4gICAgU2Nhbl9nZXRfY291bnRlciAoY291bnRlciwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgU2Nhbl9uZXh0X2NoYXIgKHJlc3QpIC0+XG4gICAgU2Nhbl9uZXh0X2NoYXIgKGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IElnbm9yZWRfcGFyYW0gKGlnbiwgcmVzdCkgLT5cbiAgICBJZ25vcmVkX3BhcmFtIChpZ24sIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuXG4gIHwgRm9ybWF0dGluZ19saXQgKGZtdGluZ19saXQsIHJlc3QpIC0+XG4gICAgRm9ybWF0dGluZ19saXQgKGZtdGluZ19saXQsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IEZvcm1hdHRpbmdfZ2VuIChmbXRpbmdfZ2VuLCByZXN0KSAtPlxuICAgIEZvcm1hdHRpbmdfZ2VuIChmbXRpbmdfZ2VuLCBjb25jYXRfZm10IHJlc3QgZm10MilcblxuICB8IEVuZF9vZl9mb3JtYXQgLT5cbiAgICBmbXQyXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBHYWJyaWVsIFNjaGVyZXIsIHByb2pldCBQYXJ0b3V0LCBJTlJJQSBQYXJpcy1TYWNsYXkgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDIwIEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIENhbWxpbnRlcm5hbEF0b21pYyBpcyBhIGRlcGVuZGVuY3kgb2YgU3RkbGliLCBzbyBpdCBpcyBjb21waWxlZCB3aXRoXG4gICAtbm9wZXJ2YXNpdmVzLiAqKVxuZXh0ZXJuYWwgKCA9PSApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWVxXCJcbmV4dGVybmFsICggKyApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVhZGRpbnRcIlxuZXh0ZXJuYWwgaWdub3JlIDogJ2EgLT4gdW5pdCA9IFwiJWlnbm9yZVwiXG5cbigqIFdlIGFyZSBub3QgcmV1c2luZyAoJ2EgcmVmKSBkaXJlY3RseSB0byBtYWtlIGl0IGVhc2llciB0byByZWFzb25cbiAgIGFib3V0IGF0b21pY2l0eSBpZiB3ZSB3aXNoIHRvOiBldmVuIGluIGEgc2VxdWVudGlhbCBpbXBsZW1lbnRhdGlvbixcbiAgIHNpZ25hbHMgYW5kIG90aGVyIGFzeW5jaHJvbm91cyBjYWxsYmFja3MgbWlnaHQgYnJlYWsgYXRvbWljaXR5LiAqKVxudHlwZSAnYSB0ID0ge211dGFibGUgdjogJ2F9XG5cbmxldCBtYWtlIHYgPSB7dn1cbmxldCBnZXQgciA9IHIudlxubGV0IHNldCByIHYgPSByLnYgPC0gdlxuXG4oKiBUaGUgZm9sbG93aW5nIGZ1bmN0aW9ucyBhcmUgc2V0IHRvIG5ldmVyIGJlIGlubGluZWQ6IEZsYW1iZGEgaXNcbiAgIGFsbG93ZWQgdG8gbW92ZSBzdXJyb3VuZGluZyBjb2RlIGluc2lkZSB0aGUgY3JpdGljYWwgc2VjdGlvbixcbiAgIGluY2x1ZGluZyBhbGxvY2F0aW9ucy4gKilcblxubGV0W0BpbmxpbmUgbmV2ZXJdIGV4Y2hhbmdlIHIgdiA9XG4gICgqIEJFR0lOIEFUT01JQyAqKVxuICBsZXQgY3VyID0gci52IGluXG4gIHIudiA8LSB2O1xuICAoKiBFTkQgQVRPTUlDICopXG4gIGN1clxuXG5sZXRbQGlubGluZSBuZXZlcl0gY29tcGFyZV9hbmRfc2V0IHIgc2VlbiB2ID1cbiAgKCogQkVHSU4gQVRPTUlDICopXG4gIGxldCBjdXIgPSByLnYgaW5cbiAgaWYgY3VyID09IHNlZW4gdGhlbiAoXG4gICAgci52IDwtIHY7XG4gICAgKCogRU5EIEFUT01JQyAqKVxuICAgIHRydWVcbiAgKSBlbHNlXG4gICAgZmFsc2VcblxubGV0W0BpbmxpbmUgbmV2ZXJdIGZldGNoX2FuZF9hZGQgciBuID1cbiAgKCogQkVHSU4gQVRPTUlDICopXG4gIGxldCBjdXIgPSByLnYgaW5cbiAgci52IDwtIChjdXIgKyBuKTtcbiAgKCogRU5EIEFUT01JQyAqKVxuICBjdXJcblxubGV0IGluY3IgciA9IGlnbm9yZSAoZmV0Y2hfYW5kX2FkZCByIDEpXG5sZXQgZGVjciByID0gaWdub3JlIChmZXRjaF9hbmRfYWRkIHIgKC0xKSlcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogRXhjZXB0aW9ucyAqKVxuXG5leHRlcm5hbCByZWdpc3Rlcl9uYW1lZF92YWx1ZSA6IHN0cmluZyAtPiAnYSAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9yZWdpc3Rlcl9uYW1lZF92YWx1ZVwiXG5cbmxldCAoKSA9XG4gICgqIGZvciBydW50aW1lL2ZhaWxfbmF0LmMgKilcbiAgcmVnaXN0ZXJfbmFtZWRfdmFsdWUgXCJQZXJ2YXNpdmVzLmFycmF5X2JvdW5kX2Vycm9yXCJcbiAgICAoSW52YWxpZF9hcmd1bWVudCBcImluZGV4IG91dCBvZiBib3VuZHNcIilcblxuZXh0ZXJuYWwgcmFpc2UgOiBleG4gLT4gJ2EgPSBcIiVyYWlzZVwiXG5leHRlcm5hbCByYWlzZV9ub3RyYWNlIDogZXhuIC0+ICdhID0gXCIlcmFpc2Vfbm90cmFjZVwiXG5cbmxldCBmYWlsd2l0aCBzID0gcmFpc2UoRmFpbHVyZSBzKVxubGV0IGludmFsaWRfYXJnIHMgPSByYWlzZShJbnZhbGlkX2FyZ3VtZW50IHMpXG5cbmV4Y2VwdGlvbiBFeGl0XG5leGNlcHRpb24gTWF0Y2hfZmFpbHVyZSA9IE1hdGNoX2ZhaWx1cmVcbmV4Y2VwdGlvbiBBc3NlcnRfZmFpbHVyZSA9IEFzc2VydF9mYWlsdXJlXG5leGNlcHRpb24gSW52YWxpZF9hcmd1bWVudCA9IEludmFsaWRfYXJndW1lbnRcbmV4Y2VwdGlvbiBGYWlsdXJlID0gRmFpbHVyZVxuZXhjZXB0aW9uIE5vdF9mb3VuZCA9IE5vdF9mb3VuZFxuZXhjZXB0aW9uIE91dF9vZl9tZW1vcnkgPSBPdXRfb2ZfbWVtb3J5XG5leGNlcHRpb24gU3RhY2tfb3ZlcmZsb3cgPSBTdGFja19vdmVyZmxvd1xuZXhjZXB0aW9uIFN5c19lcnJvciA9IFN5c19lcnJvclxuZXhjZXB0aW9uIEVuZF9vZl9maWxlID0gRW5kX29mX2ZpbGVcbmV4Y2VwdGlvbiBEaXZpc2lvbl9ieV96ZXJvID0gRGl2aXNpb25fYnlfemVyb1xuZXhjZXB0aW9uIFN5c19ibG9ja2VkX2lvID0gU3lzX2Jsb2NrZWRfaW9cbmV4Y2VwdGlvbiBVbmRlZmluZWRfcmVjdXJzaXZlX21vZHVsZSA9IFVuZGVmaW5lZF9yZWN1cnNpdmVfbW9kdWxlXG5cbigqIENvbXBvc2l0aW9uIG9wZXJhdG9ycyAqKVxuXG5leHRlcm5hbCAoIHw+ICkgOiAnYSAtPiAoJ2EgLT4gJ2IpIC0+ICdiID0gXCIlcmV2YXBwbHlcIlxuZXh0ZXJuYWwgKCBAQCApIDogKCdhIC0+ICdiKSAtPiAnYSAtPiAnYiA9IFwiJWFwcGx5XCJcblxuKCogRGVidWdnaW5nICopXG5cbmV4dGVybmFsIF9fTE9DX18gOiBzdHJpbmcgPSBcIiVsb2NfTE9DXCJcbmV4dGVybmFsIF9fRklMRV9fIDogc3RyaW5nID0gXCIlbG9jX0ZJTEVcIlxuZXh0ZXJuYWwgX19MSU5FX18gOiBpbnQgPSBcIiVsb2NfTElORVwiXG5leHRlcm5hbCBfX01PRFVMRV9fIDogc3RyaW5nID0gXCIlbG9jX01PRFVMRVwiXG5leHRlcm5hbCBfX1BPU19fIDogc3RyaW5nICogaW50ICogaW50ICogaW50ID0gXCIlbG9jX1BPU1wiXG5leHRlcm5hbCBfX0ZVTkNUSU9OX18gOiBzdHJpbmcgPSBcIiVsb2NfRlVOQ1RJT05cIlxuXG5leHRlcm5hbCBfX0xPQ19PRl9fIDogJ2EgLT4gc3RyaW5nICogJ2EgPSBcIiVsb2NfTE9DXCJcbmV4dGVybmFsIF9fTElORV9PRl9fIDogJ2EgLT4gaW50ICogJ2EgPSBcIiVsb2NfTElORVwiXG5leHRlcm5hbCBfX1BPU19PRl9fIDogJ2EgLT4gKHN0cmluZyAqIGludCAqIGludCAqIGludCkgKiAnYSA9IFwiJWxvY19QT1NcIlxuXG4oKiBDb21wYXJpc29ucyAqKVxuXG5leHRlcm5hbCAoID0gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVlcXVhbFwiXG5leHRlcm5hbCAoIDw+ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlbm90ZXF1YWxcIlxuZXh0ZXJuYWwgKCA8ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlbGVzc3RoYW5cIlxuZXh0ZXJuYWwgKCA+ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlZ3JlYXRlcnRoYW5cIlxuZXh0ZXJuYWwgKCA8PSApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWxlc3NlcXVhbFwiXG5leHRlcm5hbCAoID49ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlZ3JlYXRlcmVxdWFsXCJcbmV4dGVybmFsIGNvbXBhcmUgOiAnYSAtPiAnYSAtPiBpbnQgPSBcIiVjb21wYXJlXCJcblxubGV0IG1pbiB4IHkgPSBpZiB4IDw9IHkgdGhlbiB4IGVsc2UgeVxubGV0IG1heCB4IHkgPSBpZiB4ID49IHkgdGhlbiB4IGVsc2UgeVxuXG5leHRlcm5hbCAoID09ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlZXFcIlxuZXh0ZXJuYWwgKCAhPSApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJW5vdGVxXCJcblxuKCogQm9vbGVhbiBvcGVyYXRpb25zICopXG5cbmV4dGVybmFsIG5vdCA6IGJvb2wgLT4gYm9vbCA9IFwiJWJvb2xub3RcIlxuZXh0ZXJuYWwgKCAmICkgOiBib29sIC0+IGJvb2wgLT4gYm9vbCA9IFwiJXNlcXVhbmRcIlxuZXh0ZXJuYWwgKCAmJiApIDogYm9vbCAtPiBib29sIC0+IGJvb2wgPSBcIiVzZXF1YW5kXCJcbmV4dGVybmFsICggb3IgKSA6IGJvb2wgLT4gYm9vbCAtPiBib29sID0gXCIlc2VxdW9yXCJcbmV4dGVybmFsICggfHwgKSA6IGJvb2wgLT4gYm9vbCAtPiBib29sID0gXCIlc2VxdW9yXCJcblxuKCogSW50ZWdlciBvcGVyYXRpb25zICopXG5cbmV4dGVybmFsICggfi0gKSA6IGludCAtPiBpbnQgPSBcIiVuZWdpbnRcIlxuZXh0ZXJuYWwgKCB+KyApIDogaW50IC0+IGludCA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIHN1Y2MgOiBpbnQgLT4gaW50ID0gXCIlc3VjY2ludFwiXG5leHRlcm5hbCBwcmVkIDogaW50IC0+IGludCA9IFwiJXByZWRpbnRcIlxuZXh0ZXJuYWwgKCArICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWFkZGludFwiXG5leHRlcm5hbCAoIC0gKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlc3ViaW50XCJcbmV4dGVybmFsICggKiApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVtdWxpbnRcIlxuZXh0ZXJuYWwgKCAvICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWRpdmludFwiXG5leHRlcm5hbCAoIG1vZCApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVtb2RpbnRcIlxuXG5sZXQgYWJzIHggPSBpZiB4ID49IDAgdGhlbiB4IGVsc2UgLXhcblxuZXh0ZXJuYWwgKCBsYW5kICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWFuZGludFwiXG5leHRlcm5hbCAoIGxvciApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVvcmludFwiXG5leHRlcm5hbCAoIGx4b3IgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIleG9yaW50XCJcblxubGV0IGxub3QgeCA9IHggbHhvciAoLTEpXG5cbmV4dGVybmFsICggbHNsICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWxzbGludFwiXG5leHRlcm5hbCAoIGxzciApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVsc3JpbnRcIlxuZXh0ZXJuYWwgKCBhc3IgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlYXNyaW50XCJcblxubGV0IG1heF9pbnQgPSAoLTEpIGxzciAxXG5sZXQgbWluX2ludCA9IG1heF9pbnQgKyAxXG5cbigqIEZsb2F0aW5nLXBvaW50IG9wZXJhdGlvbnMgKilcblxuZXh0ZXJuYWwgKCB+LS4gKSA6IGZsb2F0IC0+IGZsb2F0ID0gXCIlbmVnZmxvYXRcIlxuZXh0ZXJuYWwgKCB+Ky4gKSA6IGZsb2F0IC0+IGZsb2F0ID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgKCArLiApIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcIiVhZGRmbG9hdFwiXG5leHRlcm5hbCAoIC0uICkgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiJXN1YmZsb2F0XCJcbmV4dGVybmFsICggKi4gKSA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCIlbXVsZmxvYXRcIlxuZXh0ZXJuYWwgKCAvLiApIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcIiVkaXZmbG9hdFwiXG5leHRlcm5hbCAoICoqICkgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9wb3dlcl9mbG9hdFwiIFwicG93XCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGV4cCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2V4cF9mbG9hdFwiIFwiZXhwXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGV4cG0xIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfZXhwbTFfZmxvYXRcIiBcImNhbWxfZXhwbTFcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYWNvcyA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Fjb3NfZmxvYXRcIiBcImFjb3NcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYXNpbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2FzaW5fZmxvYXRcIiBcImFzaW5cIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYXRhbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2F0YW5fZmxvYXRcIiBcImF0YW5cIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYXRhbjIgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hdGFuMl9mbG9hdFwiIFwiYXRhbjJcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgaHlwb3QgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdFxuICAgICAgICAgICAgICAgPSBcImNhbWxfaHlwb3RfZmxvYXRcIiBcImNhbWxfaHlwb3RcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgY29zIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfY29zX2Zsb2F0XCIgXCJjb3NcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgY29zaCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Nvc2hfZmxvYXRcIiBcImNvc2hcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYWNvc2ggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hY29zaF9mbG9hdFwiIFwiY2FtbF9hY29zaFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBsb2cgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9sb2dfZmxvYXRcIiBcImxvZ1wiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBsb2cxMCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2xvZzEwX2Zsb2F0XCIgXCJsb2cxMFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBsb2cxcCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2xvZzFwX2Zsb2F0XCIgXCJjYW1sX2xvZzFwXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHNpbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3Npbl9mbG9hdFwiIFwic2luXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHNpbmggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9zaW5oX2Zsb2F0XCIgXCJzaW5oXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGFzaW5oIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYXNpbmhfZmxvYXRcIiBcImNhbWxfYXNpbmhcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgc3FydCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3NxcnRfZmxvYXRcIiBcInNxcnRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdGFuIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfdGFuX2Zsb2F0XCIgXCJ0YW5cIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdGFuaCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3RhbmhfZmxvYXRcIiBcInRhbmhcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYXRhbmggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hdGFuaF9mbG9hdFwiIFwiY2FtbF9hdGFuaFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBjZWlsIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfY2VpbF9mbG9hdFwiIFwiY2VpbFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBmbG9vciA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Zsb29yX2Zsb2F0XCIgXCJmbG9vclwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBhYnNfZmxvYXQgOiBmbG9hdCAtPiBmbG9hdCA9IFwiJWFic2Zsb2F0XCJcbmV4dGVybmFsIGNvcHlzaWduIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXRcbiAgICAgICAgICAgICAgICAgID0gXCJjYW1sX2NvcHlzaWduX2Zsb2F0XCIgXCJjYW1sX2NvcHlzaWduXCJcbiAgICAgICAgICAgICAgICAgIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBtb2RfZmxvYXQgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9mbW9kX2Zsb2F0XCIgXCJmbW9kXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGZyZXhwIDogZmxvYXQgLT4gZmxvYXQgKiBpbnQgPSBcImNhbWxfZnJleHBfZmxvYXRcIlxuZXh0ZXJuYWwgbGRleHAgOiAoZmxvYXQgW0B1bmJveGVkXSkgLT4gKGludCBbQHVudGFnZ2VkXSkgLT4gKGZsb2F0IFtAdW5ib3hlZF0pID1cbiAgXCJjYW1sX2xkZXhwX2Zsb2F0XCIgXCJjYW1sX2xkZXhwX2Zsb2F0X3VuYm94ZWRcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgbW9kZiA6IGZsb2F0IC0+IGZsb2F0ICogZmxvYXQgPSBcImNhbWxfbW9kZl9mbG9hdFwiXG5leHRlcm5hbCBmbG9hdCA6IGludCAtPiBmbG9hdCA9IFwiJWZsb2F0b2ZpbnRcIlxuZXh0ZXJuYWwgZmxvYXRfb2ZfaW50IDogaW50IC0+IGZsb2F0ID0gXCIlZmxvYXRvZmludFwiXG5leHRlcm5hbCB0cnVuY2F0ZSA6IGZsb2F0IC0+IGludCA9IFwiJWludG9mZmxvYXRcIlxuZXh0ZXJuYWwgaW50X29mX2Zsb2F0IDogZmxvYXQgLT4gaW50ID0gXCIlaW50b2ZmbG9hdFwiXG5leHRlcm5hbCBmbG9hdF9vZl9iaXRzIDogaW50NjQgLT4gZmxvYXRcbiAgPSBcImNhbWxfaW50NjRfZmxvYXRfb2ZfYml0c1wiIFwiY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzX3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxubGV0IGluZmluaXR5ID1cbiAgZmxvYXRfb2ZfYml0cyAweDdGX0YwXzAwXzAwXzAwXzAwXzAwXzAwTFxubGV0IG5lZ19pbmZpbml0eSA9XG4gIGZsb2F0X29mX2JpdHMgMHhGRl9GMF8wMF8wMF8wMF8wMF8wMF8wMExcbmxldCBuYW4gPVxuICBmbG9hdF9vZl9iaXRzIDB4N0ZfRjBfMDBfMDBfMDBfMDBfMDBfMDFMXG5sZXQgbWF4X2Zsb2F0ID1cbiAgZmxvYXRfb2ZfYml0cyAweDdGX0VGX0ZGX0ZGX0ZGX0ZGX0ZGX0ZGTFxubGV0IG1pbl9mbG9hdCA9XG4gIGZsb2F0X29mX2JpdHMgMHgwMF8xMF8wMF8wMF8wMF8wMF8wMF8wMExcbmxldCBlcHNpbG9uX2Zsb2F0ID1cbiAgZmxvYXRfb2ZfYml0cyAweDNDX0IwXzAwXzAwXzAwXzAwXzAwXzAwTFxuXG50eXBlIGZwY2xhc3MgPVxuICAgIEZQX25vcm1hbFxuICB8IEZQX3N1Ym5vcm1hbFxuICB8IEZQX3plcm9cbiAgfCBGUF9pbmZpbml0ZVxuICB8IEZQX25hblxuZXh0ZXJuYWwgY2xhc3NpZnlfZmxvYXQgOiAoZmxvYXQgW0B1bmJveGVkXSkgLT4gZnBjbGFzcyA9XG4gIFwiY2FtbF9jbGFzc2lmeV9mbG9hdFwiIFwiY2FtbF9jbGFzc2lmeV9mbG9hdF91bmJveGVkXCIgW0BAbm9hbGxvY11cblxuKCogU3RyaW5nIGFuZCBieXRlIHNlcXVlbmNlIG9wZXJhdGlvbnMgLS0gbW9yZSBpbiBtb2R1bGVzIFN0cmluZyBhbmQgQnl0ZXMgKilcblxuZXh0ZXJuYWwgc3RyaW5nX2xlbmd0aCA6IHN0cmluZyAtPiBpbnQgPSBcIiVzdHJpbmdfbGVuZ3RoXCJcbmV4dGVybmFsIGJ5dGVzX2xlbmd0aCA6IGJ5dGVzIC0+IGludCA9IFwiJWJ5dGVzX2xlbmd0aFwiXG5leHRlcm5hbCBieXRlc19jcmVhdGUgOiBpbnQgLT4gYnl0ZXMgPSBcImNhbWxfY3JlYXRlX2J5dGVzXCJcbmV4dGVybmFsIHN0cmluZ19ibGl0IDogc3RyaW5nIC0+IGludCAtPiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX2JsaXRfc3RyaW5nXCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIGJ5dGVzX2JsaXQgOiBieXRlcyAtPiBpbnQgLT4gYnl0ZXMgLT4gaW50IC0+IGludCAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9ibGl0X2J5dGVzXCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIGJ5dGVzX3Vuc2FmZV90b19zdHJpbmcgOiBieXRlcyAtPiBzdHJpbmcgPSBcIiVieXRlc190b19zdHJpbmdcIlxuXG5sZXQgKCBeICkgczEgczIgPVxuICBsZXQgbDEgPSBzdHJpbmdfbGVuZ3RoIHMxIGFuZCBsMiA9IHN0cmluZ19sZW5ndGggczIgaW5cbiAgbGV0IHMgPSBieXRlc19jcmVhdGUgKGwxICsgbDIpIGluXG4gIHN0cmluZ19ibGl0IHMxIDAgcyAwIGwxO1xuICBzdHJpbmdfYmxpdCBzMiAwIHMgbDEgbDI7XG4gIGJ5dGVzX3Vuc2FmZV90b19zdHJpbmcgc1xuXG4oKiBDaGFyYWN0ZXIgb3BlcmF0aW9ucyAtLSBtb3JlIGluIG1vZHVsZSBDaGFyICopXG5cbmV4dGVybmFsIGludF9vZl9jaGFyIDogY2hhciAtPiBpbnQgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCB1bnNhZmVfY2hhcl9vZl9pbnQgOiBpbnQgLT4gY2hhciA9IFwiJWlkZW50aXR5XCJcbmxldCBjaGFyX29mX2ludCBuID1cbiAgaWYgbiA8IDAgfHwgbiA+IDI1NSB0aGVuIGludmFsaWRfYXJnIFwiY2hhcl9vZl9pbnRcIiBlbHNlIHVuc2FmZV9jaGFyX29mX2ludCBuXG5cbigqIFVuaXQgb3BlcmF0aW9ucyAqKVxuXG5leHRlcm5hbCBpZ25vcmUgOiAnYSAtPiB1bml0ID0gXCIlaWdub3JlXCJcblxuKCogUGFpciBvcGVyYXRpb25zICopXG5cbmV4dGVybmFsIGZzdCA6ICdhICogJ2IgLT4gJ2EgPSBcIiVmaWVsZDBcIlxuZXh0ZXJuYWwgc25kIDogJ2EgKiAnYiAtPiAnYiA9IFwiJWZpZWxkMVwiXG5cbigqIFJlZmVyZW5jZXMgKilcblxudHlwZSAnYSByZWYgPSB7IG11dGFibGUgY29udGVudHMgOiAnYSB9XG5leHRlcm5hbCByZWYgOiAnYSAtPiAnYSByZWYgPSBcIiVtYWtlbXV0YWJsZVwiXG5leHRlcm5hbCAoICEgKSA6ICdhIHJlZiAtPiAnYSA9IFwiJWZpZWxkMFwiXG5leHRlcm5hbCAoIDo9ICkgOiAnYSByZWYgLT4gJ2EgLT4gdW5pdCA9IFwiJXNldGZpZWxkMFwiXG5leHRlcm5hbCBpbmNyIDogaW50IHJlZiAtPiB1bml0ID0gXCIlaW5jclwiXG5leHRlcm5hbCBkZWNyIDogaW50IHJlZiAtPiB1bml0ID0gXCIlZGVjclwiXG5cbigqIFJlc3VsdCB0eXBlICopXG5cbnR5cGUgKCdhLCdiKSByZXN1bHQgPSBPayBvZiAnYSB8IEVycm9yIG9mICdiXG5cbigqIFN0cmluZyBjb252ZXJzaW9uIGZ1bmN0aW9ucyAqKVxuXG5leHRlcm5hbCBmb3JtYXRfaW50IDogc3RyaW5nIC0+IGludCAtPiBzdHJpbmcgPSBcImNhbWxfZm9ybWF0X2ludFwiXG5leHRlcm5hbCBmb3JtYXRfZmxvYXQgOiBzdHJpbmcgLT4gZmxvYXQgLT4gc3RyaW5nID0gXCJjYW1sX2Zvcm1hdF9mbG9hdFwiXG5cbmxldCBzdHJpbmdfb2ZfYm9vbCBiID1cbiAgaWYgYiB0aGVuIFwidHJ1ZVwiIGVsc2UgXCJmYWxzZVwiXG5sZXQgYm9vbF9vZl9zdHJpbmcgPSBmdW5jdGlvblxuICB8IFwidHJ1ZVwiIC0+IHRydWVcbiAgfCBcImZhbHNlXCIgLT4gZmFsc2VcbiAgfCBfIC0+IGludmFsaWRfYXJnIFwiYm9vbF9vZl9zdHJpbmdcIlxuXG5sZXQgYm9vbF9vZl9zdHJpbmdfb3B0ID0gZnVuY3Rpb25cbiAgfCBcInRydWVcIiAtPiBTb21lIHRydWVcbiAgfCBcImZhbHNlXCIgLT4gU29tZSBmYWxzZVxuICB8IF8gLT4gTm9uZVxuXG5sZXQgc3RyaW5nX29mX2ludCBuID1cbiAgZm9ybWF0X2ludCBcIiVkXCIgblxuXG5leHRlcm5hbCBpbnRfb2Zfc3RyaW5nIDogc3RyaW5nIC0+IGludCA9IFwiY2FtbF9pbnRfb2Zfc3RyaW5nXCJcblxubGV0IGludF9vZl9zdHJpbmdfb3B0IHMgPVxuICAoKiBUT0RPOiBwcm92aWRlIHRoaXMgZGlyZWN0bHkgYXMgYSBub24tcmFpc2luZyBwcmltaXRpdmUuICopXG4gIHRyeSBTb21lIChpbnRfb2Zfc3RyaW5nIHMpXG4gIHdpdGggRmFpbHVyZSBfIC0+IE5vbmVcblxuZXh0ZXJuYWwgc3RyaW5nX2dldCA6IHN0cmluZyAtPiBpbnQgLT4gY2hhciA9IFwiJXN0cmluZ19zYWZlX2dldFwiXG5cbmxldCB2YWxpZF9mbG9hdF9sZXhlbSBzID1cbiAgbGV0IGwgPSBzdHJpbmdfbGVuZ3RoIHMgaW5cbiAgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPj0gbCB0aGVuIHMgXiBcIi5cIiBlbHNlXG4gICAgbWF0Y2ggc3RyaW5nX2dldCBzIGkgd2l0aFxuICAgIHwgJzAnIC4uICc5JyB8ICctJyAtPiBsb29wIChpICsgMSlcbiAgICB8IF8gLT4gc1xuICBpblxuICBsb29wIDBcblxubGV0IHN0cmluZ19vZl9mbG9hdCBmID0gdmFsaWRfZmxvYXRfbGV4ZW0gKGZvcm1hdF9mbG9hdCBcIiUuMTJnXCIgZilcblxuZXh0ZXJuYWwgZmxvYXRfb2Zfc3RyaW5nIDogc3RyaW5nIC0+IGZsb2F0ID0gXCJjYW1sX2Zsb2F0X29mX3N0cmluZ1wiXG5cbmxldCBmbG9hdF9vZl9zdHJpbmdfb3B0IHMgPVxuICAoKiBUT0RPOiBwcm92aWRlIHRoaXMgZGlyZWN0bHkgYXMgYSBub24tcmFpc2luZyBwcmltaXRpdmUuICopXG4gIHRyeSBTb21lIChmbG9hdF9vZl9zdHJpbmcgcylcbiAgd2l0aCBGYWlsdXJlIF8gLT4gTm9uZVxuXG4oKiBMaXN0IG9wZXJhdGlvbnMgLS0gbW9yZSBpbiBtb2R1bGUgTGlzdCAqKVxuXG5sZXQgcmVjICggQCApIGwxIGwyID1cbiAgbWF0Y2ggbDEgd2l0aFxuICAgIFtdIC0+IGwyXG4gIHwgaGQgOjogdGwgLT4gaGQgOjogKHRsIEAgbDIpXG5cbigqIEkvTyBvcGVyYXRpb25zICopXG5cbnR5cGUgaW5fY2hhbm5lbFxudHlwZSBvdXRfY2hhbm5lbFxuXG5leHRlcm5hbCBvcGVuX2Rlc2NyaXB0b3Jfb3V0IDogaW50IC0+IG91dF9jaGFubmVsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9vdXRcIlxuZXh0ZXJuYWwgb3Blbl9kZXNjcmlwdG9yX2luIDogaW50IC0+IGluX2NoYW5uZWwgPSBcImNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX2luXCJcblxubGV0IHN0ZGluID0gb3Blbl9kZXNjcmlwdG9yX2luIDBcbmxldCBzdGRvdXQgPSBvcGVuX2Rlc2NyaXB0b3Jfb3V0IDFcbmxldCBzdGRlcnIgPSBvcGVuX2Rlc2NyaXB0b3Jfb3V0IDJcblxuKCogR2VuZXJhbCBvdXRwdXQgZnVuY3Rpb25zICopXG5cbnR5cGUgb3Blbl9mbGFnID1cbiAgICBPcGVuX3Jkb25seSB8IE9wZW5fd3Jvbmx5IHwgT3Blbl9hcHBlbmRcbiAgfCBPcGVuX2NyZWF0IHwgT3Blbl90cnVuYyB8IE9wZW5fZXhjbFxuICB8IE9wZW5fYmluYXJ5IHwgT3Blbl90ZXh0IHwgT3Blbl9ub25ibG9ja1xuXG5leHRlcm5hbCBvcGVuX2Rlc2MgOiBzdHJpbmcgLT4gb3Blbl9mbGFnIGxpc3QgLT4gaW50IC0+IGludCA9IFwiY2FtbF9zeXNfb3BlblwiXG5cbmV4dGVybmFsIHNldF9vdXRfY2hhbm5lbF9uYW1lOiBvdXRfY2hhbm5lbCAtPiBzdHJpbmcgLT4gdW5pdCA9XG4gIFwiY2FtbF9tbF9zZXRfY2hhbm5lbF9uYW1lXCJcblxubGV0IG9wZW5fb3V0X2dlbiBtb2RlIHBlcm0gbmFtZSA9XG4gIGxldCBjID0gb3Blbl9kZXNjcmlwdG9yX291dChvcGVuX2Rlc2MgbmFtZSBtb2RlIHBlcm0pIGluXG4gIHNldF9vdXRfY2hhbm5lbF9uYW1lIGMgbmFtZTtcbiAgY1xuXG5sZXQgb3Blbl9vdXQgbmFtZSA9XG4gIG9wZW5fb3V0X2dlbiBbT3Blbl93cm9ubHk7IE9wZW5fY3JlYXQ7IE9wZW5fdHJ1bmM7IE9wZW5fdGV4dF0gMG82NjYgbmFtZVxuXG5sZXQgb3Blbl9vdXRfYmluIG5hbWUgPVxuICBvcGVuX291dF9nZW4gW09wZW5fd3Jvbmx5OyBPcGVuX2NyZWF0OyBPcGVuX3RydW5jOyBPcGVuX2JpbmFyeV0gMG82NjYgbmFtZVxuXG5leHRlcm5hbCBmbHVzaCA6IG91dF9jaGFubmVsIC0+IHVuaXQgPSBcImNhbWxfbWxfZmx1c2hcIlxuXG5leHRlcm5hbCBvdXRfY2hhbm5lbHNfbGlzdCA6IHVuaXQgLT4gb3V0X2NoYW5uZWwgbGlzdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfbWxfb3V0X2NoYW5uZWxzX2xpc3RcIlxuXG5sZXQgZmx1c2hfYWxsICgpID1cbiAgbGV0IHJlYyBpdGVyID0gZnVuY3Rpb25cbiAgICAgIFtdIC0+ICgpXG4gICAgfCBhOjpsIC0+XG4gICAgICAgIGJlZ2luIHRyeVxuICAgICAgICAgICAgZmx1c2ggYVxuICAgICAgICB3aXRoIFN5c19lcnJvciBfIC0+XG4gICAgICAgICAgKCkgKCogaWdub3JlIGNoYW5uZWxzIGNsb3NlZCBkdXJpbmcgYSBwcmVjZWRpbmcgZmx1c2guICopXG4gICAgICAgIGVuZDtcbiAgICAgICAgaXRlciBsXG4gIGluIGl0ZXIgKG91dF9jaGFubmVsc19saXN0ICgpKVxuXG5leHRlcm5hbCB1bnNhZmVfb3V0cHV0IDogb3V0X2NoYW5uZWwgLT4gYnl0ZXMgLT4gaW50IC0+IGludCAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX21sX291dHB1dF9ieXRlc1wiXG5leHRlcm5hbCB1bnNhZmVfb3V0cHV0X3N0cmluZyA6IG91dF9jaGFubmVsIC0+IHN0cmluZyAtPiBpbnQgLT4gaW50IC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX21sX291dHB1dFwiXG5cbmV4dGVybmFsIG91dHB1dF9jaGFyIDogb3V0X2NoYW5uZWwgLT4gY2hhciAtPiB1bml0ID0gXCJjYW1sX21sX291dHB1dF9jaGFyXCJcblxubGV0IG91dHB1dF9ieXRlcyBvYyBzID1cbiAgdW5zYWZlX291dHB1dCBvYyBzIDAgKGJ5dGVzX2xlbmd0aCBzKVxuXG5sZXQgb3V0cHV0X3N0cmluZyBvYyBzID1cbiAgdW5zYWZlX291dHB1dF9zdHJpbmcgb2MgcyAwIChzdHJpbmdfbGVuZ3RoIHMpXG5cbmxldCBvdXRwdXQgb2MgcyBvZnMgbGVuID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IGJ5dGVzX2xlbmd0aCBzIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJvdXRwdXRcIlxuICBlbHNlIHVuc2FmZV9vdXRwdXQgb2MgcyBvZnMgbGVuXG5cbmxldCBvdXRwdXRfc3Vic3RyaW5nIG9jIHMgb2ZzIGxlbiA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBzdHJpbmdfbGVuZ3RoIHMgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIm91dHB1dF9zdWJzdHJpbmdcIlxuICBlbHNlIHVuc2FmZV9vdXRwdXRfc3RyaW5nIG9jIHMgb2ZzIGxlblxuXG5leHRlcm5hbCBvdXRwdXRfYnl0ZSA6IG91dF9jaGFubmVsIC0+IGludCAtPiB1bml0ID0gXCJjYW1sX21sX291dHB1dF9jaGFyXCJcbmV4dGVybmFsIG91dHB1dF9iaW5hcnlfaW50IDogb3V0X2NoYW5uZWwgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfbWxfb3V0cHV0X2ludFwiXG5cbmV4dGVybmFsIG1hcnNoYWxfdG9fY2hhbm5lbCA6IG91dF9jaGFubmVsIC0+ICdhIC0+IHVuaXQgbGlzdCAtPiB1bml0XG4gICAgID0gXCJjYW1sX291dHB1dF92YWx1ZVwiXG5sZXQgb3V0cHV0X3ZhbHVlIGNoYW4gdiA9IG1hcnNoYWxfdG9fY2hhbm5lbCBjaGFuIHYgW11cblxuZXh0ZXJuYWwgc2Vla19vdXQgOiBvdXRfY2hhbm5lbCAtPiBpbnQgLT4gdW5pdCA9IFwiY2FtbF9tbF9zZWVrX291dFwiXG5leHRlcm5hbCBwb3Nfb3V0IDogb3V0X2NoYW5uZWwgLT4gaW50ID0gXCJjYW1sX21sX3Bvc19vdXRcIlxuZXh0ZXJuYWwgb3V0X2NoYW5uZWxfbGVuZ3RoIDogb3V0X2NoYW5uZWwgLT4gaW50ID0gXCJjYW1sX21sX2NoYW5uZWxfc2l6ZVwiXG5leHRlcm5hbCBjbG9zZV9vdXRfY2hhbm5lbCA6IG91dF9jaGFubmVsIC0+IHVuaXQgPSBcImNhbWxfbWxfY2xvc2VfY2hhbm5lbFwiXG5sZXQgY2xvc2Vfb3V0IG9jID0gZmx1c2ggb2M7IGNsb3NlX291dF9jaGFubmVsIG9jXG5sZXQgY2xvc2Vfb3V0X25vZXJyIG9jID1cbiAgKHRyeSBmbHVzaCBvYyB3aXRoIF8gLT4gKCkpO1xuICAodHJ5IGNsb3NlX291dF9jaGFubmVsIG9jIHdpdGggXyAtPiAoKSlcbmV4dGVybmFsIHNldF9iaW5hcnlfbW9kZV9vdXQgOiBvdXRfY2hhbm5lbCAtPiBib29sIC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfbWxfc2V0X2JpbmFyeV9tb2RlXCJcblxuKCogR2VuZXJhbCBpbnB1dCBmdW5jdGlvbnMgKilcblxuZXh0ZXJuYWwgc2V0X2luX2NoYW5uZWxfbmFtZTogaW5fY2hhbm5lbCAtPiBzdHJpbmcgLT4gdW5pdCA9XG4gIFwiY2FtbF9tbF9zZXRfY2hhbm5lbF9uYW1lXCJcblxubGV0IG9wZW5faW5fZ2VuIG1vZGUgcGVybSBuYW1lID1cbiAgbGV0IGMgPSBvcGVuX2Rlc2NyaXB0b3JfaW4ob3Blbl9kZXNjIG5hbWUgbW9kZSBwZXJtKSBpblxuICBzZXRfaW5fY2hhbm5lbF9uYW1lIGMgbmFtZTtcbiAgY1xuXG5sZXQgb3Blbl9pbiBuYW1lID1cbiAgb3Blbl9pbl9nZW4gW09wZW5fcmRvbmx5OyBPcGVuX3RleHRdIDAgbmFtZVxuXG5sZXQgb3Blbl9pbl9iaW4gbmFtZSA9XG4gIG9wZW5faW5fZ2VuIFtPcGVuX3Jkb25seTsgT3Blbl9iaW5hcnldIDAgbmFtZVxuXG5leHRlcm5hbCBpbnB1dF9jaGFyIDogaW5fY2hhbm5lbCAtPiBjaGFyID0gXCJjYW1sX21sX2lucHV0X2NoYXJcIlxuXG5leHRlcm5hbCB1bnNhZmVfaW5wdXQgOiBpbl9jaGFubmVsIC0+IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gaW50XG4gICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfbWxfaW5wdXRcIlxuXG5sZXQgaW5wdXQgaWMgcyBvZnMgbGVuID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IGJ5dGVzX2xlbmd0aCBzIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJpbnB1dFwiXG4gIGVsc2UgdW5zYWZlX2lucHV0IGljIHMgb2ZzIGxlblxuXG5sZXQgcmVjIHVuc2FmZV9yZWFsbHlfaW5wdXQgaWMgcyBvZnMgbGVuID1cbiAgaWYgbGVuIDw9IDAgdGhlbiAoKSBlbHNlIGJlZ2luXG4gICAgbGV0IHIgPSB1bnNhZmVfaW5wdXQgaWMgcyBvZnMgbGVuIGluXG4gICAgaWYgciA9IDBcbiAgICB0aGVuIHJhaXNlIEVuZF9vZl9maWxlXG4gICAgZWxzZSB1bnNhZmVfcmVhbGx5X2lucHV0IGljIHMgKG9mcyArIHIpIChsZW4gLSByKVxuICBlbmRcblxubGV0IHJlYWxseV9pbnB1dCBpYyBzIG9mcyBsZW4gPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gYnl0ZXNfbGVuZ3RoIHMgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcInJlYWxseV9pbnB1dFwiXG4gIGVsc2UgdW5zYWZlX3JlYWxseV9pbnB1dCBpYyBzIG9mcyBsZW5cblxubGV0IHJlYWxseV9pbnB1dF9zdHJpbmcgaWMgbGVuID1cbiAgbGV0IHMgPSBieXRlc19jcmVhdGUgbGVuIGluXG4gIHJlYWxseV9pbnB1dCBpYyBzIDAgbGVuO1xuICBieXRlc191bnNhZmVfdG9fc3RyaW5nIHNcblxuZXh0ZXJuYWwgaW5wdXRfc2Nhbl9saW5lIDogaW5fY2hhbm5lbCAtPiBpbnQgPSBcImNhbWxfbWxfaW5wdXRfc2Nhbl9saW5lXCJcblxubGV0IGlucHV0X2xpbmUgY2hhbiA9XG4gIGxldCByZWMgYnVpbGRfcmVzdWx0IGJ1ZiBwb3MgPSBmdW5jdGlvblxuICAgIFtdIC0+IGJ1ZlxuICB8IGhkIDo6IHRsIC0+XG4gICAgICBsZXQgbGVuID0gYnl0ZXNfbGVuZ3RoIGhkIGluXG4gICAgICBieXRlc19ibGl0IGhkIDAgYnVmIChwb3MgLSBsZW4pIGxlbjtcbiAgICAgIGJ1aWxkX3Jlc3VsdCBidWYgKHBvcyAtIGxlbikgdGwgaW5cbiAgbGV0IHJlYyBzY2FuIGFjY3UgbGVuID1cbiAgICBsZXQgbiA9IGlucHV0X3NjYW5fbGluZSBjaGFuIGluXG4gICAgaWYgbiA9IDAgdGhlbiBiZWdpbiAgICAgICAgICAgICAgICAgICAoKiBuID0gMDogd2UgYXJlIGF0IEVPRiAqKVxuICAgICAgbWF0Y2ggYWNjdSB3aXRoXG4gICAgICAgIFtdIC0+IHJhaXNlIEVuZF9vZl9maWxlXG4gICAgICB8IF8gIC0+IGJ1aWxkX3Jlc3VsdCAoYnl0ZXNfY3JlYXRlIGxlbikgbGVuIGFjY3VcbiAgICBlbmQgZWxzZSBpZiBuID4gMCB0aGVuIGJlZ2luICAgICAgICAgICgqIG4gPiAwOiBuZXdsaW5lIGZvdW5kIGluIGJ1ZmZlciAqKVxuICAgICAgbGV0IHJlcyA9IGJ5dGVzX2NyZWF0ZSAobiAtIDEpIGluXG4gICAgICBpZ25vcmUgKHVuc2FmZV9pbnB1dCBjaGFuIHJlcyAwIChuIC0gMSkpO1xuICAgICAgaWdub3JlIChpbnB1dF9jaGFyIGNoYW4pOyAgICAgICAgICAgKCogc2tpcCB0aGUgbmV3bGluZSAqKVxuICAgICAgbWF0Y2ggYWNjdSB3aXRoXG4gICAgICAgIFtdIC0+IHJlc1xuICAgICAgfCAgXyAtPiBsZXQgbGVuID0gbGVuICsgbiAtIDEgaW5cbiAgICAgICAgICAgICAgYnVpbGRfcmVzdWx0IChieXRlc19jcmVhdGUgbGVuKSBsZW4gKHJlcyA6OiBhY2N1KVxuICAgIGVuZCBlbHNlIGJlZ2luICAgICAgICAgICAgICAgICAgICAgICAgKCogbiA8IDA6IG5ld2xpbmUgbm90IGZvdW5kICopXG4gICAgICBsZXQgYmVnID0gYnl0ZXNfY3JlYXRlICgtbikgaW5cbiAgICAgIGlnbm9yZSh1bnNhZmVfaW5wdXQgY2hhbiBiZWcgMCAoLW4pKTtcbiAgICAgIHNjYW4gKGJlZyA6OiBhY2N1KSAobGVuIC0gbilcbiAgICBlbmRcbiAgaW4gYnl0ZXNfdW5zYWZlX3RvX3N0cmluZyAoc2NhbiBbXSAwKVxuXG5leHRlcm5hbCBpbnB1dF9ieXRlIDogaW5fY2hhbm5lbCAtPiBpbnQgPSBcImNhbWxfbWxfaW5wdXRfY2hhclwiXG5leHRlcm5hbCBpbnB1dF9iaW5hcnlfaW50IDogaW5fY2hhbm5lbCAtPiBpbnQgPSBcImNhbWxfbWxfaW5wdXRfaW50XCJcbmV4dGVybmFsIGlucHV0X3ZhbHVlIDogaW5fY2hhbm5lbCAtPiAnYSA9IFwiY2FtbF9pbnB1dF92YWx1ZVwiXG5leHRlcm5hbCBzZWVrX2luIDogaW5fY2hhbm5lbCAtPiBpbnQgLT4gdW5pdCA9IFwiY2FtbF9tbF9zZWVrX2luXCJcbmV4dGVybmFsIHBvc19pbiA6IGluX2NoYW5uZWwgLT4gaW50ID0gXCJjYW1sX21sX3Bvc19pblwiXG5leHRlcm5hbCBpbl9jaGFubmVsX2xlbmd0aCA6IGluX2NoYW5uZWwgLT4gaW50ID0gXCJjYW1sX21sX2NoYW5uZWxfc2l6ZVwiXG5leHRlcm5hbCBjbG9zZV9pbiA6IGluX2NoYW5uZWwgLT4gdW5pdCA9IFwiY2FtbF9tbF9jbG9zZV9jaGFubmVsXCJcbmxldCBjbG9zZV9pbl9ub2VyciBpYyA9ICh0cnkgY2xvc2VfaW4gaWMgd2l0aCBfIC0+ICgpKVxuZXh0ZXJuYWwgc2V0X2JpbmFyeV9tb2RlX2luIDogaW5fY2hhbm5lbCAtPiBib29sIC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9tbF9zZXRfYmluYXJ5X21vZGVcIlxuXG4oKiBPdXRwdXQgZnVuY3Rpb25zIG9uIHN0YW5kYXJkIG91dHB1dCAqKVxuXG5sZXQgcHJpbnRfY2hhciBjID0gb3V0cHV0X2NoYXIgc3Rkb3V0IGNcbmxldCBwcmludF9zdHJpbmcgcyA9IG91dHB1dF9zdHJpbmcgc3Rkb3V0IHNcbmxldCBwcmludF9ieXRlcyBzID0gb3V0cHV0X2J5dGVzIHN0ZG91dCBzXG5sZXQgcHJpbnRfaW50IGkgPSBvdXRwdXRfc3RyaW5nIHN0ZG91dCAoc3RyaW5nX29mX2ludCBpKVxubGV0IHByaW50X2Zsb2F0IGYgPSBvdXRwdXRfc3RyaW5nIHN0ZG91dCAoc3RyaW5nX29mX2Zsb2F0IGYpXG5sZXQgcHJpbnRfZW5kbGluZSBzID1cbiAgb3V0cHV0X3N0cmluZyBzdGRvdXQgczsgb3V0cHV0X2NoYXIgc3Rkb3V0ICdcXG4nOyBmbHVzaCBzdGRvdXRcbmxldCBwcmludF9uZXdsaW5lICgpID0gb3V0cHV0X2NoYXIgc3Rkb3V0ICdcXG4nOyBmbHVzaCBzdGRvdXRcblxuKCogT3V0cHV0IGZ1bmN0aW9ucyBvbiBzdGFuZGFyZCBlcnJvciAqKVxuXG5sZXQgcHJlcnJfY2hhciBjID0gb3V0cHV0X2NoYXIgc3RkZXJyIGNcbmxldCBwcmVycl9zdHJpbmcgcyA9IG91dHB1dF9zdHJpbmcgc3RkZXJyIHNcbmxldCBwcmVycl9ieXRlcyBzID0gb3V0cHV0X2J5dGVzIHN0ZGVyciBzXG5sZXQgcHJlcnJfaW50IGkgPSBvdXRwdXRfc3RyaW5nIHN0ZGVyciAoc3RyaW5nX29mX2ludCBpKVxubGV0IHByZXJyX2Zsb2F0IGYgPSBvdXRwdXRfc3RyaW5nIHN0ZGVyciAoc3RyaW5nX29mX2Zsb2F0IGYpXG5sZXQgcHJlcnJfZW5kbGluZSBzID1cbiAgb3V0cHV0X3N0cmluZyBzdGRlcnIgczsgb3V0cHV0X2NoYXIgc3RkZXJyICdcXG4nOyBmbHVzaCBzdGRlcnJcbmxldCBwcmVycl9uZXdsaW5lICgpID0gb3V0cHV0X2NoYXIgc3RkZXJyICdcXG4nOyBmbHVzaCBzdGRlcnJcblxuKCogSW5wdXQgZnVuY3Rpb25zIG9uIHN0YW5kYXJkIGlucHV0ICopXG5cbmxldCByZWFkX2xpbmUgKCkgPSBmbHVzaCBzdGRvdXQ7IGlucHV0X2xpbmUgc3RkaW5cbmxldCByZWFkX2ludCAoKSA9IGludF9vZl9zdHJpbmcocmVhZF9saW5lKCkpXG5sZXQgcmVhZF9pbnRfb3B0ICgpID0gaW50X29mX3N0cmluZ19vcHQocmVhZF9saW5lKCkpXG5sZXQgcmVhZF9mbG9hdCAoKSA9IGZsb2F0X29mX3N0cmluZyhyZWFkX2xpbmUoKSlcbmxldCByZWFkX2Zsb2F0X29wdCAoKSA9IGZsb2F0X29mX3N0cmluZ19vcHQocmVhZF9saW5lKCkpXG5cbigqIE9wZXJhdGlvbnMgb24gbGFyZ2UgZmlsZXMgKilcblxubW9kdWxlIExhcmdlRmlsZSA9XG4gIHN0cnVjdFxuICAgIGV4dGVybmFsIHNlZWtfb3V0IDogb3V0X2NoYW5uZWwgLT4gaW50NjQgLT4gdW5pdCA9IFwiY2FtbF9tbF9zZWVrX291dF82NFwiXG4gICAgZXh0ZXJuYWwgcG9zX291dCA6IG91dF9jaGFubmVsIC0+IGludDY0ID0gXCJjYW1sX21sX3Bvc19vdXRfNjRcIlxuICAgIGV4dGVybmFsIG91dF9jaGFubmVsX2xlbmd0aCA6IG91dF9jaGFubmVsIC0+IGludDY0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX21sX2NoYW5uZWxfc2l6ZV82NFwiXG4gICAgZXh0ZXJuYWwgc2Vla19pbiA6IGluX2NoYW5uZWwgLT4gaW50NjQgLT4gdW5pdCA9IFwiY2FtbF9tbF9zZWVrX2luXzY0XCJcbiAgICBleHRlcm5hbCBwb3NfaW4gOiBpbl9jaGFubmVsIC0+IGludDY0ID0gXCJjYW1sX21sX3Bvc19pbl82NFwiXG4gICAgZXh0ZXJuYWwgaW5fY2hhbm5lbF9sZW5ndGggOiBpbl9jaGFubmVsIC0+IGludDY0ID0gXCJjYW1sX21sX2NoYW5uZWxfc2l6ZV82NFwiXG4gIGVuZFxuXG4oKiBGb3JtYXRzICopXG5cbnR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDZcbiAgID0gKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljcy5mb3JtYXQ2XG4gICA9IEZvcm1hdCBvZiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzLmZtdFxuICAgICAgICAgICAgICAgKiBzdHJpbmdcblxudHlwZSAoJ2EsICdiLCAnYywgJ2QpIGZvcm1hdDQgPSAoJ2EsICdiLCAnYywgJ2MsICdjLCAnZCkgZm9ybWF0NlxuXG50eXBlICgnYSwgJ2IsICdjKSBmb3JtYXQgPSAoJ2EsICdiLCAnYywgJ2MpIGZvcm1hdDRcblxubGV0IHN0cmluZ19vZl9mb3JtYXQgKEZvcm1hdCAoX2ZtdCwgc3RyKSkgPSBzdHJcblxuZXh0ZXJuYWwgZm9ybWF0X29mX3N0cmluZyA6XG4gKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgLT5cbiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiA9IFwiJWlkZW50aXR5XCJcblxubGV0ICggXl4gKSAoRm9ybWF0IChmbXQxLCBzdHIxKSkgKEZvcm1hdCAoZm10Miwgc3RyMikpID1cbiAgRm9ybWF0IChDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3MuY29uY2F0X2ZtdCBmbXQxIGZtdDIsXG4gICAgICAgICAgc3RyMSBeIFwiJSxcIiBeIHN0cjIpXG5cbigqIE1pc2NlbGxhbmVvdXMgKilcblxuZXh0ZXJuYWwgc3lzX2V4aXQgOiBpbnQgLT4gJ2EgPSBcImNhbWxfc3lzX2V4aXRcIlxuXG5sZXQgZXhpdF9mdW5jdGlvbiA9IENhbWxpbnRlcm5hbEF0b21pYy5tYWtlIGZsdXNoX2FsbFxuXG5sZXQgcmVjIGF0X2V4aXQgZiA9XG4gIGxldCBtb2R1bGUgQXRvbWljID0gQ2FtbGludGVybmFsQXRvbWljIGluXG4gICgqIE1QUiM3MjUzLCBNUFIjNzc5NjogbWFrZSBzdXJlIFwiZlwiIGlzIGV4ZWN1dGVkIG9ubHkgb25jZSAqKVxuICBsZXQgZl95ZXRfdG9fcnVuID0gQXRvbWljLm1ha2UgdHJ1ZSBpblxuICBsZXQgb2xkX2V4aXQgPSBBdG9taWMuZ2V0IGV4aXRfZnVuY3Rpb24gaW5cbiAgbGV0IG5ld19leGl0ICgpID1cbiAgICBpZiBBdG9taWMuY29tcGFyZV9hbmRfc2V0IGZfeWV0X3RvX3J1biB0cnVlIGZhbHNlIHRoZW4gZiAoKSA7XG4gICAgb2xkX2V4aXQgKClcbiAgaW5cbiAgbGV0IHN1Y2Nlc3MgPSBBdG9taWMuY29tcGFyZV9hbmRfc2V0IGV4aXRfZnVuY3Rpb24gb2xkX2V4aXQgbmV3X2V4aXQgaW5cbiAgaWYgbm90IHN1Y2Nlc3MgdGhlbiBhdF9leGl0IGZcblxubGV0IGRvX2F0X2V4aXQgKCkgPSAoQ2FtbGludGVybmFsQXRvbWljLmdldCBleGl0X2Z1bmN0aW9uKSAoKVxuXG5sZXQgZXhpdCByZXRjb2RlID1cbiAgZG9fYXRfZXhpdCAoKTtcbiAgc3lzX2V4aXQgcmV0Y29kZVxuXG5sZXQgXyA9IHJlZ2lzdGVyX25hbWVkX3ZhbHVlIFwiUGVydmFzaXZlcy5kb19hdF9leGl0XCIgZG9fYXRfZXhpdFxuXG5leHRlcm5hbCBtYWpvciA6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9nY19tYWpvclwiXG5leHRlcm5hbCBuYWtlZF9wb2ludGVyc19jaGVja2VkIDogdW5pdCAtPiBib29sXG4gID0gXCJjYW1sX3N5c19jb25zdF9uYWtlZF9wb2ludGVyc19jaGVja2VkXCJcbmxldCAoKSA9IGlmIG5ha2VkX3BvaW50ZXJzX2NoZWNrZWQgKCkgdGhlbiBhdF9leGl0IG1ham9yXG5cbigqTU9EVUxFX0FMSUFTRVMqKVxubW9kdWxlIEFyZyAgICAgICAgICA9IEFyZ1xubW9kdWxlIEFycmF5ICAgICAgICA9IEFycmF5XG5tb2R1bGUgQXJyYXlMYWJlbHMgID0gQXJyYXlMYWJlbHNcbm1vZHVsZSBBdG9taWMgICAgICAgPSBBdG9taWNcbm1vZHVsZSBCaWdhcnJheSAgICAgPSBCaWdhcnJheVxubW9kdWxlIEJvb2wgICAgICAgICA9IEJvb2xcbm1vZHVsZSBCdWZmZXIgICAgICAgPSBCdWZmZXJcbm1vZHVsZSBCeXRlcyAgICAgICAgPSBCeXRlc1xubW9kdWxlIEJ5dGVzTGFiZWxzICA9IEJ5dGVzTGFiZWxzXG5tb2R1bGUgQ2FsbGJhY2sgICAgID0gQ2FsbGJhY2tcbm1vZHVsZSBDaGFyICAgICAgICAgPSBDaGFyXG5tb2R1bGUgQ29tcGxleCAgICAgID0gQ29tcGxleFxubW9kdWxlIERpZ2VzdCAgICAgICA9IERpZ2VzdFxubW9kdWxlIEVpdGhlciAgICAgICA9IEVpdGhlclxubW9kdWxlIEVwaGVtZXJvbiAgICA9IEVwaGVtZXJvblxubW9kdWxlIEZpbGVuYW1lICAgICA9IEZpbGVuYW1lXG5tb2R1bGUgRmxvYXQgICAgICAgID0gRmxvYXRcbm1vZHVsZSBGb3JtYXQgICAgICAgPSBGb3JtYXRcbm1vZHVsZSBGdW4gICAgICAgICAgPSBGdW5cbm1vZHVsZSBHYyAgICAgICAgICAgPSBHY1xubW9kdWxlIEdlbmxleCAgICAgICA9IEdlbmxleFxubW9kdWxlIEhhc2h0YmwgICAgICA9IEhhc2h0Ymxcbm1vZHVsZSBJbl9jaGFubmVsICAgPSBJbl9jaGFubmVsXG5tb2R1bGUgSW50ICAgICAgICAgID0gSW50XG5tb2R1bGUgSW50MzIgICAgICAgID0gSW50MzJcbm1vZHVsZSBJbnQ2NCAgICAgICAgPSBJbnQ2NFxubW9kdWxlIExhenkgICAgICAgICA9IExhenlcbm1vZHVsZSBMZXhpbmcgICAgICAgPSBMZXhpbmdcbm1vZHVsZSBMaXN0ICAgICAgICAgPSBMaXN0XG5tb2R1bGUgTGlzdExhYmVscyAgID0gTGlzdExhYmVsc1xubW9kdWxlIE1hcCAgICAgICAgICA9IE1hcFxubW9kdWxlIE1hcnNoYWwgICAgICA9IE1hcnNoYWxcbm1vZHVsZSBNb3JlTGFiZWxzICAgPSBNb3JlTGFiZWxzXG5tb2R1bGUgTmF0aXZlaW50ICAgID0gTmF0aXZlaW50XG5tb2R1bGUgT2JqICAgICAgICAgID0gT2JqXG5tb2R1bGUgT28gICAgICAgICAgID0gT29cbm1vZHVsZSBPcHRpb24gICAgICAgPSBPcHRpb25cbm1vZHVsZSBPdXRfY2hhbm5lbCAgPSBPdXRfY2hhbm5lbFxubW9kdWxlIFBhcnNpbmcgICAgICA9IFBhcnNpbmdcbm1vZHVsZSBQZXJ2YXNpdmVzICAgPSBQZXJ2YXNpdmVzXG5tb2R1bGUgUHJpbnRleGMgICAgID0gUHJpbnRleGNcbm1vZHVsZSBQcmludGYgICAgICAgPSBQcmludGZcbm1vZHVsZSBRdWV1ZSAgICAgICAgPSBRdWV1ZVxubW9kdWxlIFJhbmRvbSAgICAgICA9IFJhbmRvbVxubW9kdWxlIFJlc3VsdCAgICAgICA9IFJlc3VsdFxubW9kdWxlIFNjYW5mICAgICAgICA9IFNjYW5mXG5tb2R1bGUgU2VxICAgICAgICAgID0gU2VxXG5tb2R1bGUgU2V0ICAgICAgICAgID0gU2V0XG5tb2R1bGUgU3RhY2sgICAgICAgID0gU3RhY2tcbm1vZHVsZSBTdGRMYWJlbHMgICAgPSBTdGRMYWJlbHNcbm1vZHVsZSBTdHJlYW0gICAgICAgPSBTdHJlYW1cbm1vZHVsZSBTdHJpbmcgICAgICAgPSBTdHJpbmdcbm1vZHVsZSBTdHJpbmdMYWJlbHMgPSBTdHJpbmdMYWJlbHNcbm1vZHVsZSBTeXMgICAgICAgICAgPSBTeXNcbm1vZHVsZSBVY2hhciAgICAgICAgPSBVY2hhclxubW9kdWxlIFVuaXQgICAgICAgICA9IFVuaXRcbm1vZHVsZSBXZWFrICAgICAgICAgPSBXZWFrXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICBKZXJlbWllIERpbWlubywgSmFuZSBTdHJlZXQgRXVyb3BlICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE3IEphbmUgU3RyZWV0IEdyb3VwIExMQyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqKiBAZGVwcmVjYXRlZCBVc2UgeyFTdGRsaWJ9ICopXG5cbmV4dGVybmFsIHJhaXNlIDogZXhuIC0+ICdhID0gXCIlcmFpc2VcIlxuZXh0ZXJuYWwgcmFpc2Vfbm90cmFjZSA6IGV4biAtPiAnYSA9IFwiJXJhaXNlX25vdHJhY2VcIlxubGV0IGludmFsaWRfYXJnID0gaW52YWxpZF9hcmdcbmxldCBmYWlsd2l0aCA9IGZhaWx3aXRoXG5leGNlcHRpb24gRXhpdFxuZXh0ZXJuYWwgKCA9ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlZXF1YWxcIlxuZXh0ZXJuYWwgKCA8PiApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJW5vdGVxdWFsXCJcbmV4dGVybmFsICggPCApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWxlc3N0aGFuXCJcbmV4dGVybmFsICggPiApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWdyZWF0ZXJ0aGFuXCJcbmV4dGVybmFsICggPD0gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVsZXNzZXF1YWxcIlxuZXh0ZXJuYWwgKCA+PSApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWdyZWF0ZXJlcXVhbFwiXG5leHRlcm5hbCBjb21wYXJlIDogJ2EgLT4gJ2EgLT4gaW50ID0gXCIlY29tcGFyZVwiXG5sZXQgbWluID0gbWluXG5sZXQgbWF4ID0gbWF4XG5leHRlcm5hbCAoID09ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlZXFcIlxuZXh0ZXJuYWwgKCAhPSApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJW5vdGVxXCJcbmV4dGVybmFsIG5vdCA6IGJvb2wgLT4gYm9vbCA9IFwiJWJvb2xub3RcIlxuZXh0ZXJuYWwgKCAmJiApIDogYm9vbCAtPiBib29sIC0+IGJvb2wgPSBcIiVzZXF1YW5kXCJcbmV4dGVybmFsICggJiApIDogYm9vbCAtPiBib29sIC0+IGJvb2wgPSBcIiVzZXF1YW5kXCJcbiAgW0BAb2NhbWwuZGVwcmVjYXRlZCBcIlVzZSAoJiYpIGluc3RlYWQuXCJdXG5leHRlcm5hbCAoIHx8ICkgOiBib29sIC0+IGJvb2wgLT4gYm9vbCA9IFwiJXNlcXVvclwiXG5leHRlcm5hbCAoIG9yICkgOiBib29sIC0+IGJvb2wgLT4gYm9vbCA9IFwiJXNlcXVvclwiXG4gIFtAQG9jYW1sLmRlcHJlY2F0ZWQgXCJVc2UgKHx8KSBpbnN0ZWFkLlwiXVxuZXh0ZXJuYWwgX19MT0NfXyA6IHN0cmluZyA9IFwiJWxvY19MT0NcIlxuZXh0ZXJuYWwgX19GSUxFX18gOiBzdHJpbmcgPSBcIiVsb2NfRklMRVwiXG5leHRlcm5hbCBfX0xJTkVfXyA6IGludCA9IFwiJWxvY19MSU5FXCJcbmV4dGVybmFsIF9fTU9EVUxFX18gOiBzdHJpbmcgPSBcIiVsb2NfTU9EVUxFXCJcbmV4dGVybmFsIF9fUE9TX18gOiBzdHJpbmcgKiBpbnQgKiBpbnQgKiBpbnQgPSBcIiVsb2NfUE9TXCJcbmV4dGVybmFsIF9fTE9DX09GX18gOiAnYSAtPiBzdHJpbmcgKiAnYSA9IFwiJWxvY19MT0NcIlxuZXh0ZXJuYWwgX19MSU5FX09GX18gOiAnYSAtPiBpbnQgKiAnYSA9IFwiJWxvY19MSU5FXCJcbmV4dGVybmFsIF9fUE9TX09GX18gOiAnYSAtPiAoc3RyaW5nICogaW50ICogaW50ICogaW50KSAqICdhID0gXCIlbG9jX1BPU1wiXG5leHRlcm5hbCAoIHw+ICkgOiAnYSAtPiAoJ2EgLT4gJ2IpIC0+ICdiID0gXCIlcmV2YXBwbHlcIlxuZXh0ZXJuYWwgKCBAQCApIDogKCdhIC0+ICdiKSAtPiAnYSAtPiAnYiA9IFwiJWFwcGx5XCJcbmV4dGVybmFsICggfi0gKSA6IGludCAtPiBpbnQgPSBcIiVuZWdpbnRcIlxuZXh0ZXJuYWwgKCB+KyApIDogaW50IC0+IGludCA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIHN1Y2MgOiBpbnQgLT4gaW50ID0gXCIlc3VjY2ludFwiXG5leHRlcm5hbCBwcmVkIDogaW50IC0+IGludCA9IFwiJXByZWRpbnRcIlxuZXh0ZXJuYWwgKCArICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWFkZGludFwiXG5leHRlcm5hbCAoIC0gKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlc3ViaW50XCJcbmV4dGVybmFsICggKiApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVtdWxpbnRcIlxuZXh0ZXJuYWwgKCAvICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWRpdmludFwiXG5leHRlcm5hbCAoIG1vZCApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVtb2RpbnRcIlxubGV0IGFicyA9IGFic1xubGV0IG1heF9pbnQgPSBtYXhfaW50XG5sZXQgbWluX2ludCA9IG1pbl9pbnRcbmV4dGVybmFsICggbGFuZCApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVhbmRpbnRcIlxuZXh0ZXJuYWwgKCBsb3IgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlb3JpbnRcIlxuZXh0ZXJuYWwgKCBseG9yICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJXhvcmludFwiXG5sZXQgbG5vdCA9IGxub3RcbmV4dGVybmFsICggbHNsICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWxzbGludFwiXG5leHRlcm5hbCAoIGxzciApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVsc3JpbnRcIlxuZXh0ZXJuYWwgKCBhc3IgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlYXNyaW50XCJcbmV4dGVybmFsICggfi0uICkgOiBmbG9hdCAtPiBmbG9hdCA9IFwiJW5lZ2Zsb2F0XCJcbmV4dGVybmFsICggfisuICkgOiBmbG9hdCAtPiBmbG9hdCA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsICggKy4gKSA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCIlYWRkZmxvYXRcIlxuZXh0ZXJuYWwgKCAtLiApIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcIiVzdWJmbG9hdFwiXG5leHRlcm5hbCAoICouICkgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiJW11bGZsb2F0XCJcbmV4dGVybmFsICggLy4gKSA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCIlZGl2ZmxvYXRcIlxuZXh0ZXJuYWwgKCAqKiApIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfcG93ZXJfZmxvYXRcIiBcInBvd1wiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBzcXJ0IDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfc3FydF9mbG9hdFwiIFwic3FydFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBleHAgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9leHBfZmxvYXRcIiBcImV4cFwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBsb2cgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9sb2dfZmxvYXRcIiBcImxvZ1wiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBsb2cxMCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2xvZzEwX2Zsb2F0XCIgXCJsb2cxMFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBleHBtMSA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2V4cG0xX2Zsb2F0XCIgXCJjYW1sX2V4cG0xXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGxvZzFwIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfbG9nMXBfZmxvYXRcIiBcImNhbWxfbG9nMXBcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgY29zIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfY29zX2Zsb2F0XCIgXCJjb3NcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgc2luIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfc2luX2Zsb2F0XCIgXCJzaW5cIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdGFuIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfdGFuX2Zsb2F0XCIgXCJ0YW5cIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYWNvcyA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Fjb3NfZmxvYXRcIiBcImFjb3NcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYXNpbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2FzaW5fZmxvYXRcIiBcImFzaW5cIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYXRhbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2F0YW5fZmxvYXRcIiBcImF0YW5cIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYXRhbjIgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hdGFuMl9mbG9hdFwiIFwiYXRhbjJcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgaHlwb3QgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9oeXBvdF9mbG9hdFwiIFwiY2FtbF9oeXBvdFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBjb3NoIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfY29zaF9mbG9hdFwiIFwiY29zaFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBzaW5oIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfc2luaF9mbG9hdFwiIFwic2luaFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCB0YW5oIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfdGFuaF9mbG9hdFwiIFwidGFuaFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBjZWlsIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfY2VpbF9mbG9hdFwiIFwiY2VpbFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBmbG9vciA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Zsb29yX2Zsb2F0XCIgXCJmbG9vclwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBhYnNfZmxvYXQgOiBmbG9hdCAtPiBmbG9hdCA9IFwiJWFic2Zsb2F0XCJcbmV4dGVybmFsIGNvcHlzaWduIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXRcbiAgICAgICAgICAgICAgICAgID0gXCJjYW1sX2NvcHlzaWduX2Zsb2F0XCIgXCJjYW1sX2NvcHlzaWduXCJcbiAgICAgICAgICAgICAgICAgIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBtb2RfZmxvYXQgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9mbW9kX2Zsb2F0XCIgXCJmbW9kXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGZyZXhwIDogZmxvYXQgLT4gZmxvYXQgKiBpbnQgPSBcImNhbWxfZnJleHBfZmxvYXRcIlxuZXh0ZXJuYWwgbGRleHAgOiAoZmxvYXQgW0B1bmJveGVkXSkgLT4gKGludCBbQHVudGFnZ2VkXSkgLT4gKGZsb2F0IFtAdW5ib3hlZF0pID1cbiAgXCJjYW1sX2xkZXhwX2Zsb2F0XCIgXCJjYW1sX2xkZXhwX2Zsb2F0X3VuYm94ZWRcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgbW9kZiA6IGZsb2F0IC0+IGZsb2F0ICogZmxvYXQgPSBcImNhbWxfbW9kZl9mbG9hdFwiXG5leHRlcm5hbCBmbG9hdCA6IGludCAtPiBmbG9hdCA9IFwiJWZsb2F0b2ZpbnRcIlxuZXh0ZXJuYWwgZmxvYXRfb2ZfaW50IDogaW50IC0+IGZsb2F0ID0gXCIlZmxvYXRvZmludFwiXG5leHRlcm5hbCB0cnVuY2F0ZSA6IGZsb2F0IC0+IGludCA9IFwiJWludG9mZmxvYXRcIlxuZXh0ZXJuYWwgaW50X29mX2Zsb2F0IDogZmxvYXQgLT4gaW50ID0gXCIlaW50b2ZmbG9hdFwiXG5sZXQgaW5maW5pdHkgPSBpbmZpbml0eVxubGV0IG5lZ19pbmZpbml0eSA9IG5lZ19pbmZpbml0eVxubGV0IG5hbiA9IG5hblxubGV0IG1heF9mbG9hdCA9IG1heF9mbG9hdFxubGV0IG1pbl9mbG9hdCA9IG1pbl9mbG9hdFxubGV0IGVwc2lsb25fZmxvYXQgPSBlcHNpbG9uX2Zsb2F0XG50eXBlIG5vbnJlYyBmcGNsYXNzID0gZnBjbGFzcyA9XG4gICAgRlBfbm9ybWFsXG4gIHwgRlBfc3Vibm9ybWFsXG4gIHwgRlBfemVyb1xuICB8IEZQX2luZmluaXRlXG4gIHwgRlBfbmFuXG5leHRlcm5hbCBjbGFzc2lmeV9mbG9hdCA6IChmbG9hdCBbQHVuYm94ZWRdKSAtPiBmcGNsYXNzID1cbiAgXCJjYW1sX2NsYXNzaWZ5X2Zsb2F0XCIgXCJjYW1sX2NsYXNzaWZ5X2Zsb2F0X3VuYm94ZWRcIiBbQEBub2FsbG9jXVxubGV0ICggXiApID0gKCBeIClcbmV4dGVybmFsIGludF9vZl9jaGFyIDogY2hhciAtPiBpbnQgPSBcIiVpZGVudGl0eVwiXG5sZXQgY2hhcl9vZl9pbnQgPSBjaGFyX29mX2ludFxuZXh0ZXJuYWwgaWdub3JlIDogJ2EgLT4gdW5pdCA9IFwiJWlnbm9yZVwiXG5sZXQgc3RyaW5nX29mX2Jvb2wgPSBzdHJpbmdfb2ZfYm9vbFxubGV0IGJvb2xfb2Zfc3RyaW5nID0gYm9vbF9vZl9zdHJpbmdcbmxldCBib29sX29mX3N0cmluZ19vcHQgPSBib29sX29mX3N0cmluZ19vcHRcbmxldCBzdHJpbmdfb2ZfaW50ID0gc3RyaW5nX29mX2ludFxuZXh0ZXJuYWwgaW50X29mX3N0cmluZyA6IHN0cmluZyAtPiBpbnQgPSBcImNhbWxfaW50X29mX3N0cmluZ1wiXG5sZXQgaW50X29mX3N0cmluZ19vcHQgPSBpbnRfb2Zfc3RyaW5nX29wdFxubGV0IHN0cmluZ19vZl9mbG9hdCA9IHN0cmluZ19vZl9mbG9hdFxuZXh0ZXJuYWwgZmxvYXRfb2Zfc3RyaW5nIDogc3RyaW5nIC0+IGZsb2F0ID0gXCJjYW1sX2Zsb2F0X29mX3N0cmluZ1wiXG5sZXQgZmxvYXRfb2Zfc3RyaW5nX29wdCA9IGZsb2F0X29mX3N0cmluZ19vcHRcbmV4dGVybmFsIGZzdCA6ICdhICogJ2IgLT4gJ2EgPSBcIiVmaWVsZDBcIlxuZXh0ZXJuYWwgc25kIDogJ2EgKiAnYiAtPiAnYiA9IFwiJWZpZWxkMVwiXG5sZXQgKCBAICkgID0gKCBAIClcbnR5cGUgbm9ucmVjIGluX2NoYW5uZWwgPSBpbl9jaGFubmVsXG50eXBlIG5vbnJlYyBvdXRfY2hhbm5lbCA9IG91dF9jaGFubmVsXG5sZXQgc3RkaW4gPSBzdGRpblxubGV0IHN0ZG91dCA9IHN0ZG91dFxubGV0IHN0ZGVyciA9IHN0ZGVyclxubGV0IHByaW50X2NoYXIgPSBwcmludF9jaGFyXG5sZXQgcHJpbnRfc3RyaW5nID0gcHJpbnRfc3RyaW5nXG5sZXQgcHJpbnRfYnl0ZXMgPSBwcmludF9ieXRlc1xubGV0IHByaW50X2ludCA9IHByaW50X2ludFxubGV0IHByaW50X2Zsb2F0ID0gcHJpbnRfZmxvYXRcbmxldCBwcmludF9lbmRsaW5lID0gcHJpbnRfZW5kbGluZVxubGV0IHByaW50X25ld2xpbmUgPSBwcmludF9uZXdsaW5lXG5sZXQgcHJlcnJfY2hhciA9IHByZXJyX2NoYXJcbmxldCBwcmVycl9zdHJpbmcgPSBwcmVycl9zdHJpbmdcbmxldCBwcmVycl9ieXRlcyA9IHByZXJyX2J5dGVzXG5sZXQgcHJlcnJfaW50ID0gcHJlcnJfaW50XG5sZXQgcHJlcnJfZmxvYXQgPSBwcmVycl9mbG9hdFxubGV0IHByZXJyX2VuZGxpbmUgPSBwcmVycl9lbmRsaW5lXG5sZXQgcHJlcnJfbmV3bGluZSA9IHByZXJyX25ld2xpbmVcbmxldCByZWFkX2xpbmUgPSByZWFkX2xpbmVcbmxldCByZWFkX2ludCA9IHJlYWRfaW50XG5sZXQgcmVhZF9pbnRfb3B0ID0gcmVhZF9pbnRfb3B0XG5sZXQgcmVhZF9mbG9hdCA9IHJlYWRfZmxvYXRcbmxldCByZWFkX2Zsb2F0X29wdCA9IHJlYWRfZmxvYXRfb3B0XG50eXBlIG5vbnJlYyBvcGVuX2ZsYWcgPSBvcGVuX2ZsYWcgPVxuICAgIE9wZW5fcmRvbmx5XG4gIHwgT3Blbl93cm9ubHlcbiAgfCBPcGVuX2FwcGVuZFxuICB8IE9wZW5fY3JlYXRcbiAgfCBPcGVuX3RydW5jXG4gIHwgT3Blbl9leGNsXG4gIHwgT3Blbl9iaW5hcnlcbiAgfCBPcGVuX3RleHRcbiAgfCBPcGVuX25vbmJsb2NrXG5sZXQgb3Blbl9vdXQgPSBvcGVuX291dFxubGV0IG9wZW5fb3V0X2JpbiA9IG9wZW5fb3V0X2JpblxubGV0IG9wZW5fb3V0X2dlbiA9IG9wZW5fb3V0X2dlblxubGV0IGZsdXNoID0gZmx1c2hcbmxldCBmbHVzaF9hbGwgPSBmbHVzaF9hbGxcbmxldCBvdXRwdXRfY2hhciA9IG91dHB1dF9jaGFyXG5sZXQgb3V0cHV0X3N0cmluZyA9IG91dHB1dF9zdHJpbmdcbmxldCBvdXRwdXRfYnl0ZXMgPSBvdXRwdXRfYnl0ZXNcbmxldCBvdXRwdXQgPSBvdXRwdXRcbmxldCBvdXRwdXRfc3Vic3RyaW5nID0gb3V0cHV0X3N1YnN0cmluZ1xubGV0IG91dHB1dF9ieXRlID0gb3V0cHV0X2J5dGVcbmxldCBvdXRwdXRfYmluYXJ5X2ludCA9IG91dHB1dF9iaW5hcnlfaW50XG5sZXQgb3V0cHV0X3ZhbHVlID0gb3V0cHV0X3ZhbHVlXG5sZXQgc2Vla19vdXQgPSBzZWVrX291dFxubGV0IHBvc19vdXQgPSBwb3Nfb3V0XG5sZXQgb3V0X2NoYW5uZWxfbGVuZ3RoID0gb3V0X2NoYW5uZWxfbGVuZ3RoXG5sZXQgY2xvc2Vfb3V0ID0gY2xvc2Vfb3V0XG5sZXQgY2xvc2Vfb3V0X25vZXJyID0gY2xvc2Vfb3V0X25vZXJyXG5sZXQgc2V0X2JpbmFyeV9tb2RlX291dCA9IHNldF9iaW5hcnlfbW9kZV9vdXRcbmxldCBvcGVuX2luID0gb3Blbl9pblxubGV0IG9wZW5faW5fYmluID0gb3Blbl9pbl9iaW5cbmxldCBvcGVuX2luX2dlbiA9IG9wZW5faW5fZ2VuXG5sZXQgaW5wdXRfY2hhciA9IGlucHV0X2NoYXJcbmxldCBpbnB1dF9saW5lID0gaW5wdXRfbGluZVxubGV0IGlucHV0ID0gaW5wdXRcbmxldCByZWFsbHlfaW5wdXQgPSByZWFsbHlfaW5wdXRcbmxldCByZWFsbHlfaW5wdXRfc3RyaW5nID0gcmVhbGx5X2lucHV0X3N0cmluZ1xubGV0IGlucHV0X2J5dGUgPSBpbnB1dF9ieXRlXG5sZXQgaW5wdXRfYmluYXJ5X2ludCA9IGlucHV0X2JpbmFyeV9pbnRcbmxldCBpbnB1dF92YWx1ZSA9IGlucHV0X3ZhbHVlXG5sZXQgc2Vla19pbiA9IHNlZWtfaW5cbmxldCBwb3NfaW4gPSBwb3NfaW5cbmxldCBpbl9jaGFubmVsX2xlbmd0aCA9IGluX2NoYW5uZWxfbGVuZ3RoXG5sZXQgY2xvc2VfaW4gPSBjbG9zZV9pblxubGV0IGNsb3NlX2luX25vZXJyID0gY2xvc2VfaW5fbm9lcnJcbmxldCBzZXRfYmluYXJ5X21vZGVfaW4gPSBzZXRfYmluYXJ5X21vZGVfaW5cbm1vZHVsZSBMYXJnZUZpbGUgPSBMYXJnZUZpbGVcbnR5cGUgbm9ucmVjICdhIHJlZiA9ICdhIHJlZiA9IHsgbXV0YWJsZSBjb250ZW50cyA6ICdhIH1cbmV4dGVybmFsIHJlZiA6ICdhIC0+ICdhIHJlZiA9IFwiJW1ha2VtdXRhYmxlXCJcbmV4dGVybmFsICggISApIDogJ2EgcmVmIC0+ICdhID0gXCIlZmllbGQwXCJcbmV4dGVybmFsICggOj0gKSA6ICdhIHJlZiAtPiAnYSAtPiB1bml0ID0gXCIlc2V0ZmllbGQwXCJcbmV4dGVybmFsIGluY3IgOiBpbnQgcmVmIC0+IHVuaXQgPSBcIiVpbmNyXCJcbmV4dGVybmFsIGRlY3IgOiBpbnQgcmVmIC0+IHVuaXQgPSBcIiVkZWNyXCJcbnR5cGUgbm9ucmVjICgnYSwnYikgcmVzdWx0ID0gKCdhLCdiKSByZXN1bHQgPSBPayBvZiAnYSB8IEVycm9yIG9mICdiXG50eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2ID1cbiAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljcy5mb3JtYXQ2XG50eXBlICgnYSwgJ2IsICdjLCAnZCkgZm9ybWF0NCA9ICgnYSwgJ2IsICdjLCAnYywgJ2MsICdkKSBmb3JtYXQ2XG50eXBlICgnYSwgJ2IsICdjKSBmb3JtYXQgPSAoJ2EsICdiLCAnYywgJ2MpIGZvcm1hdDRcbmxldCBzdHJpbmdfb2ZfZm9ybWF0ID0gc3RyaW5nX29mX2Zvcm1hdFxuZXh0ZXJuYWwgZm9ybWF0X29mX3N0cmluZyA6XG4gICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2IC0+XG4gICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2ID0gXCIlaWRlbnRpdHlcIlxubGV0ICggXl4gKSA9ICggXl4gKVxubGV0IGV4aXQgPSBleGl0XG5sZXQgYXRfZXhpdCA9IGF0X2V4aXRcbmxldCB2YWxpZF9mbG9hdF9sZXhlbSA9IHZhbGlkX2Zsb2F0X2xleGVtXG5sZXQgZG9fYXRfZXhpdCA9IGRvX2F0X2V4aXRcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgR2FicmllbCBTY2hlcmVyLCBwcm9qZXQgUGFyc2lmYWwsIElOUklBIFNhY2xheSAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMTkgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxudHlwZSAoJ2EsICdiKSB0ID0gTGVmdCBvZiAnYSB8IFJpZ2h0IG9mICdiXG5cbmxldCBsZWZ0IHYgPSBMZWZ0IHZcbmxldCByaWdodCB2ID0gUmlnaHQgdlxuXG5sZXQgaXNfbGVmdCA9IGZ1bmN0aW9uXG58IExlZnQgXyAtPiB0cnVlXG58IFJpZ2h0IF8gLT4gZmFsc2VcblxubGV0IGlzX3JpZ2h0ID0gZnVuY3Rpb25cbnwgTGVmdCBfIC0+IGZhbHNlXG58IFJpZ2h0IF8gLT4gdHJ1ZVxuXG5sZXQgZmluZF9sZWZ0ID0gZnVuY3Rpb25cbnwgTGVmdCB2IC0+IFNvbWUgdlxufCBSaWdodCBfIC0+IE5vbmVcblxubGV0IGZpbmRfcmlnaHQgPSBmdW5jdGlvblxufCBMZWZ0IF8gLT4gTm9uZVxufCBSaWdodCB2IC0+IFNvbWUgdlxuXG5sZXQgbWFwX2xlZnQgZiA9IGZ1bmN0aW9uXG58IExlZnQgdiAtPiBMZWZ0IChmIHYpXG58IFJpZ2h0IF8gYXMgZSAtPiBlXG5cbmxldCBtYXBfcmlnaHQgZiA9IGZ1bmN0aW9uXG58IExlZnQgXyBhcyBlIC0+IGVcbnwgUmlnaHQgdiAtPiBSaWdodCAoZiB2KVxuXG5sZXQgbWFwIH5sZWZ0IH5yaWdodCA9IGZ1bmN0aW9uXG58IExlZnQgdiAtPiBMZWZ0IChsZWZ0IHYpXG58IFJpZ2h0IHYgLT4gUmlnaHQgKHJpZ2h0IHYpXG5cbmxldCBmb2xkIH5sZWZ0IH5yaWdodCA9IGZ1bmN0aW9uXG58IExlZnQgdiAtPiBsZWZ0IHZcbnwgUmlnaHQgdiAtPiByaWdodCB2XG5cbmxldCBpdGVyID0gZm9sZFxuXG5sZXQgZm9yX2FsbCA9IGZvbGRcblxubGV0IGVxdWFsIH5sZWZ0IH5yaWdodCBlMSBlMiA9IG1hdGNoIGUxLCBlMiB3aXRoXG58IExlZnQgdjEsIExlZnQgdjIgLT4gbGVmdCB2MSB2MlxufCBSaWdodCB2MSwgUmlnaHQgdjIgLT4gcmlnaHQgdjEgdjJcbnwgTGVmdCBfLCBSaWdodCBfIHwgUmlnaHQgXywgTGVmdCBfIC0+IGZhbHNlXG5cbmxldCBjb21wYXJlIH5sZWZ0IH5yaWdodCBlMSBlMiA9IG1hdGNoIGUxLCBlMiB3aXRoXG58IExlZnQgdjEsIExlZnQgdjIgLT4gbGVmdCB2MSB2MlxufCBSaWdodCB2MSwgUmlnaHQgdjIgLT4gcmlnaHQgdjEgdjJcbnwgTGVmdCBfLCBSaWdodCBfIC0+ICgtMSlcbnwgUmlnaHQgXywgTGVmdCBfIC0+IDFcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogT3BlcmF0aW9ucyBvbiBpbnRlcm5hbCByZXByZXNlbnRhdGlvbnMgb2YgdmFsdWVzICopXG5cbnR5cGUgdFxuXG50eXBlIHJhd19kYXRhID0gbmF0aXZlaW50XG5cbmV4dGVybmFsIHJlcHIgOiAnYSAtPiB0ID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgb2JqIDogdCAtPiAnYSA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIG1hZ2ljIDogJ2EgLT4gJ2IgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCBpc19pbnQgOiB0IC0+IGJvb2wgPSBcIiVvYmpfaXNfaW50XCJcbmxldCBbQGlubGluZSBhbHdheXNdIGlzX2Jsb2NrIGEgPSBub3QgKGlzX2ludCBhKVxuZXh0ZXJuYWwgdGFnIDogdCAtPiBpbnQgPSBcImNhbWxfb2JqX3RhZ1wiIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBzZXRfdGFnIDogdCAtPiBpbnQgLT4gdW5pdCA9IFwiY2FtbF9vYmpfc2V0X3RhZ1wiXG5leHRlcm5hbCBzaXplIDogdCAtPiBpbnQgPSBcIiVvYmpfc2l6ZVwiXG5leHRlcm5hbCByZWFjaGFibGVfd29yZHMgOiB0IC0+IGludCA9IFwiY2FtbF9vYmpfcmVhY2hhYmxlX3dvcmRzXCJcbmV4dGVybmFsIGZpZWxkIDogdCAtPiBpbnQgLT4gdCA9IFwiJW9ial9maWVsZFwiXG5leHRlcm5hbCBzZXRfZmllbGQgOiB0IC0+IGludCAtPiB0IC0+IHVuaXQgPSBcIiVvYmpfc2V0X2ZpZWxkXCJcbmV4dGVybmFsIGZsb2F0YXJyYXlfZ2V0IDogZmxvYXRhcnJheSAtPiBpbnQgLT4gZmxvYXQgPSBcImNhbWxfZmxvYXRhcnJheV9nZXRcIlxuZXh0ZXJuYWwgZmxvYXRhcnJheV9zZXQgOlxuICAgIGZsb2F0YXJyYXkgLT4gaW50IC0+IGZsb2F0IC0+IHVuaXQgPSBcImNhbWxfZmxvYXRhcnJheV9zZXRcIlxubGV0IFtAaW5saW5lIGFsd2F5c10gZG91YmxlX2ZpZWxkIHggaSA9IGZsb2F0YXJyYXlfZ2V0IChvYmogeCA6IGZsb2F0YXJyYXkpIGlcbmxldCBbQGlubGluZSBhbHdheXNdIHNldF9kb3VibGVfZmllbGQgeCBpIHYgPVxuICBmbG9hdGFycmF5X3NldCAob2JqIHggOiBmbG9hdGFycmF5KSBpIHZcbmV4dGVybmFsIHJhd19maWVsZCA6IHQgLT4gaW50IC0+IHJhd19kYXRhID0gXCJjYW1sX29ial9yYXdfZmllbGRcIlxuZXh0ZXJuYWwgc2V0X3Jhd19maWVsZCA6IHQgLT4gaW50IC0+IHJhd19kYXRhIC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX29ial9zZXRfcmF3X2ZpZWxkXCJcblxuZXh0ZXJuYWwgbmV3X2Jsb2NrIDogaW50IC0+IGludCAtPiB0ID0gXCJjYW1sX29ial9ibG9ja1wiXG5leHRlcm5hbCBkdXAgOiB0IC0+IHQgPSBcImNhbWxfb2JqX2R1cFwiXG5leHRlcm5hbCB0cnVuY2F0ZSA6IHQgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfb2JqX3RydW5jYXRlXCJcbmV4dGVybmFsIGFkZF9vZmZzZXQgOiB0IC0+IEludDMyLnQgLT4gdCA9IFwiY2FtbF9vYmpfYWRkX29mZnNldFwiXG5leHRlcm5hbCB3aXRoX3RhZyA6IGludCAtPiB0IC0+IHQgPSBcImNhbWxfb2JqX3dpdGhfdGFnXCJcblxubGV0IGZpcnN0X25vbl9jb25zdGFudF9jb25zdHJ1Y3Rvcl90YWcgPSAwXG5sZXQgbGFzdF9ub25fY29uc3RhbnRfY29uc3RydWN0b3JfdGFnID0gMjQ1XG5cbmxldCBsYXp5X3RhZyA9IDI0NlxubGV0IGNsb3N1cmVfdGFnID0gMjQ3XG5sZXQgb2JqZWN0X3RhZyA9IDI0OFxubGV0IGluZml4X3RhZyA9IDI0OVxubGV0IGZvcndhcmRfdGFnID0gMjUwXG5cbmxldCBub19zY2FuX3RhZyA9IDI1MVxuXG5sZXQgYWJzdHJhY3RfdGFnID0gMjUxXG5sZXQgc3RyaW5nX3RhZyA9IDI1MlxubGV0IGRvdWJsZV90YWcgPSAyNTNcbmxldCBkb3VibGVfYXJyYXlfdGFnID0gMjU0XG5sZXQgY3VzdG9tX3RhZyA9IDI1NVxubGV0IGZpbmFsX3RhZyA9IGN1c3RvbV90YWdcblxuXG5sZXQgaW50X3RhZyA9IDEwMDBcbmxldCBvdXRfb2ZfaGVhcF90YWcgPSAxMDAxXG5sZXQgdW5hbGlnbmVkX3RhZyA9IDEwMDJcblxubW9kdWxlIENsb3N1cmUgPSBzdHJ1Y3RcbiAgdHlwZSBpbmZvID0ge1xuICAgIGFyaXR5OiBpbnQ7XG4gICAgc3RhcnRfZW52OiBpbnQ7XG4gIH1cblxuICBsZXQgaW5mb19vZl9yYXcgKGluZm8gOiBuYXRpdmVpbnQpID1cbiAgICBsZXQgb3BlbiBOYXRpdmVpbnQgaW5cbiAgICBsZXQgYXJpdHkgPVxuICAgICAgKCogc2lnbmVkOiBuZWdhdGl2ZSBmb3IgdHVwbGVkIGZ1bmN0aW9ucyAqKVxuICAgICAgaWYgU3lzLndvcmRfc2l6ZSA9IDY0IHRoZW5cbiAgICAgICAgdG9faW50IChzaGlmdF9yaWdodCBpbmZvIDU2KVxuICAgICAgZWxzZVxuICAgICAgICB0b19pbnQgKHNoaWZ0X3JpZ2h0IGluZm8gMjQpXG4gICAgaW5cbiAgICBsZXQgc3RhcnRfZW52ID1cbiAgICAgICgqIHN0YXJ0X2VudiBpcyB1bnNpZ25lZCwgYnV0IHdlIGtub3cgaXQgY2FuIGFsd2F5cyBmaXQgYW4gT0NhbWxcbiAgICAgICAgIGludGVnZXIgc28gd2UgdXNlIFt0b19pbnRdIGluc3RlYWQgb2YgW3Vuc2lnbmVkX3RvX2ludF0uICopXG4gICAgICB0b19pbnQgKHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgKHNoaWZ0X2xlZnQgaW5mbyA4KSA5KSBpblxuICAgIHsgYXJpdHk7IHN0YXJ0X2VudiB9XG5cbiAgKCogbm90ZTogd2UgZXhwZWN0IGEgY2xvc3VyZSwgbm90IGFuIGluZml4IHBvaW50ZXIgKilcbiAgbGV0IGluZm8gKG9iaiA6IHQpID1cbiAgICBhc3NlcnQgKHRhZyBvYmogPSBjbG9zdXJlX3RhZyk7XG4gICAgaW5mb19vZl9yYXcgKHJhd19maWVsZCBvYmogMSlcbmVuZFxuXG5tb2R1bGUgRXh0ZW5zaW9uX2NvbnN0cnVjdG9yID1cbnN0cnVjdFxuICB0eXBlIHQgPSBleHRlbnNpb25fY29uc3RydWN0b3JcbiAgbGV0IG9mX3ZhbCB4ID1cbiAgICBsZXQgeCA9IHJlcHIgeCBpblxuICAgIGxldCBzbG90ID1cbiAgICAgIGlmIChpc19ibG9jayB4KSAmJiAodGFnIHgpIDw+IG9iamVjdF90YWcgJiYgKHNpemUgeCkgPj0gMSB0aGVuIGZpZWxkIHggMFxuICAgICAgZWxzZSB4XG4gICAgaW5cbiAgICBsZXQgbmFtZSA9XG4gICAgICBpZiAoaXNfYmxvY2sgc2xvdCkgJiYgKHRhZyBzbG90KSA9IG9iamVjdF90YWcgdGhlbiBmaWVsZCBzbG90IDBcbiAgICAgIGVsc2UgaW52YWxpZF9hcmcgXCJPYmouZXh0ZW5zaW9uX2NvbnN0cnVjdG9yXCJcbiAgICBpblxuICAgICAgaWYgKHRhZyBuYW1lKSA9IHN0cmluZ190YWcgdGhlbiAob2JqIHNsb3QgOiB0KVxuICAgICAgZWxzZSBpbnZhbGlkX2FyZyBcIk9iai5leHRlbnNpb25fY29uc3RydWN0b3JcIlxuXG4gIGxldCBbQGlubGluZSBhbHdheXNdIG5hbWUgKHNsb3QgOiB0KSA9XG4gICAgKG9iaiAoZmllbGQgKHJlcHIgc2xvdCkgMCkgOiBzdHJpbmcpXG5cbiAgbGV0IFtAaW5saW5lIGFsd2F5c10gaWQgKHNsb3QgOiB0KSA9XG4gICAgKG9iaiAoZmllbGQgKHJlcHIgc2xvdCkgMSkgOiBpbnQpXG5lbmRcblxubGV0IGV4dGVuc2lvbl9jb25zdHJ1Y3RvciA9IEV4dGVuc2lvbl9jb25zdHJ1Y3Rvci5vZl92YWxcbmxldCBleHRlbnNpb25fbmFtZSA9IEV4dGVuc2lvbl9jb25zdHJ1Y3Rvci5uYW1lXG5sZXQgZXh0ZW5zaW9uX2lkID0gRXh0ZW5zaW9uX2NvbnN0cnVjdG9yLmlkXG5cbm1vZHVsZSBFcGhlbWVyb24gPSBzdHJ1Y3RcbiAgdHlwZSBvYmpfdCA9IHRcblxuICB0eXBlIHQgKCoqIGVwaGVtZXJvbiAqKVxuXG4gICAoKiogVG8gY2hhbmdlIGluIHN5bmMgd2l0aCB3ZWFrLmggKilcbiAgbGV0IGFkZGl0aW9uYWxfdmFsdWVzID0gMlxuICBsZXQgbWF4X2VwaGVfbGVuZ3RoID0gU3lzLm1heF9hcnJheV9sZW5ndGggLSBhZGRpdGlvbmFsX3ZhbHVlc1xuXG4gIGV4dGVybmFsIGNyZWF0ZSA6IGludCAtPiB0ID0gXCJjYW1sX2VwaGVfY3JlYXRlXCI7O1xuICBsZXQgY3JlYXRlIGwgPVxuICAgIGlmIG5vdCAoMCA8PSBsICYmIGwgPD0gbWF4X2VwaGVfbGVuZ3RoKSB0aGVuXG4gICAgICBpbnZhbGlkX2FyZyBcIk9iai5FcGhlbWVyb24uY3JlYXRlXCI7XG4gICAgY3JlYXRlIGxcblxuICBsZXQgbGVuZ3RoIHggPSBzaXplKHJlcHIgeCkgLSBhZGRpdGlvbmFsX3ZhbHVlc1xuXG4gIGxldCByYWlzZV9pZl9pbnZhbGlkX29mZnNldCBlIG8gbXNnID1cbiAgICBpZiBub3QgKDAgPD0gbyAmJiBvIDwgbGVuZ3RoIGUpIHRoZW5cbiAgICAgIGludmFsaWRfYXJnIG1zZ1xuXG4gIGV4dGVybmFsIGdldF9rZXk6IHQgLT4gaW50IC0+IG9ial90IG9wdGlvbiA9IFwiY2FtbF9lcGhlX2dldF9rZXlcIlxuICBsZXQgZ2V0X2tleSBlIG8gPVxuICAgIHJhaXNlX2lmX2ludmFsaWRfb2Zmc2V0IGUgbyBcIk9iai5FcGhlbWVyb24uZ2V0X2tleVwiO1xuICAgIGdldF9rZXkgZSBvXG5cbiAgZXh0ZXJuYWwgZ2V0X2tleV9jb3B5OiB0IC0+IGludCAtPiBvYmpfdCBvcHRpb24gPSBcImNhbWxfZXBoZV9nZXRfa2V5X2NvcHlcIlxuICBsZXQgZ2V0X2tleV9jb3B5IGUgbyA9XG4gICAgcmFpc2VfaWZfaW52YWxpZF9vZmZzZXQgZSBvIFwiT2JqLkVwaGVtZXJvbi5nZXRfa2V5X2NvcHlcIjtcbiAgICBnZXRfa2V5X2NvcHkgZSBvXG5cbiAgZXh0ZXJuYWwgc2V0X2tleTogdCAtPiBpbnQgLT4gb2JqX3QgLT4gdW5pdCA9IFwiY2FtbF9lcGhlX3NldF9rZXlcIlxuICBsZXQgc2V0X2tleSBlIG8geCA9XG4gICAgcmFpc2VfaWZfaW52YWxpZF9vZmZzZXQgZSBvIFwiT2JqLkVwaGVtZXJvbi5zZXRfa2V5XCI7XG4gICAgc2V0X2tleSBlIG8geFxuXG4gIGV4dGVybmFsIHVuc2V0X2tleTogdCAtPiBpbnQgLT4gdW5pdCA9IFwiY2FtbF9lcGhlX3Vuc2V0X2tleVwiXG4gIGxldCB1bnNldF9rZXkgZSBvID1cbiAgICByYWlzZV9pZl9pbnZhbGlkX29mZnNldCBlIG8gXCJPYmouRXBoZW1lcm9uLnVuc2V0X2tleVwiO1xuICAgIHVuc2V0X2tleSBlIG9cblxuICBleHRlcm5hbCBjaGVja19rZXk6IHQgLT4gaW50IC0+IGJvb2wgPSBcImNhbWxfZXBoZV9jaGVja19rZXlcIlxuICBsZXQgY2hlY2tfa2V5IGUgbyA9XG4gICAgcmFpc2VfaWZfaW52YWxpZF9vZmZzZXQgZSBvIFwiT2JqLkVwaGVtZXJvbi5jaGVja19rZXlcIjtcbiAgICBjaGVja19rZXkgZSBvXG5cbiAgZXh0ZXJuYWwgYmxpdF9rZXkgOiB0IC0+IGludCAtPiB0IC0+IGludCAtPiBpbnQgLT4gdW5pdFxuICAgID0gXCJjYW1sX2VwaGVfYmxpdF9rZXlcIlxuXG4gIGxldCBibGl0X2tleSBlMSBvMSBlMiBvMiBsID1cbiAgICBpZiBsIDwgMCB8fCBvMSA8IDAgfHwgbzEgPiBsZW5ndGggZTEgLSBsXG4gICAgICAgfHwgbzIgPCAwIHx8IG8yID4gbGVuZ3RoIGUyIC0gbFxuICAgIHRoZW4gaW52YWxpZF9hcmcgXCJPYmouRXBoZW1lcm9uLmJsaXRfa2V5XCJcbiAgICBlbHNlIGlmIGwgPD4gMCB0aGVuIGJsaXRfa2V5IGUxIG8xIGUyIG8yIGxcblxuICBleHRlcm5hbCBnZXRfZGF0YTogdCAtPiBvYmpfdCBvcHRpb24gPSBcImNhbWxfZXBoZV9nZXRfZGF0YVwiXG4gIGV4dGVybmFsIGdldF9kYXRhX2NvcHk6IHQgLT4gb2JqX3Qgb3B0aW9uID0gXCJjYW1sX2VwaGVfZ2V0X2RhdGFfY29weVwiXG4gIGV4dGVybmFsIHNldF9kYXRhOiB0IC0+IG9ial90IC0+IHVuaXQgPSBcImNhbWxfZXBoZV9zZXRfZGF0YVwiXG4gIGV4dGVybmFsIHVuc2V0X2RhdGE6IHQgLT4gdW5pdCA9IFwiY2FtbF9lcGhlX3Vuc2V0X2RhdGFcIlxuICBleHRlcm5hbCBjaGVja19kYXRhOiB0IC0+IGJvb2wgPSBcImNhbWxfZXBoZV9jaGVja19kYXRhXCJcbiAgZXh0ZXJuYWwgYmxpdF9kYXRhIDogdCAtPiB0IC0+IHVuaXQgPSBcImNhbWxfZXBoZV9ibGl0X2RhdGFcIlxuXG5lbmRcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIERhbWllbiBEb2xpZ2V6LCBwcm9qZXQgUGFyYSwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTcgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogSW50ZXJuYWxzIG9mIGZvcmNpbmcgbGF6eSB2YWx1ZXMuICopXG5cbnR5cGUgJ2EgdCA9ICdhIGxhenlfdFxuXG5leGNlcHRpb24gVW5kZWZpbmVkXG5cbmxldCByYWlzZV91bmRlZmluZWQgPSBPYmoucmVwciAoZnVuICgpIC0+IHJhaXNlIFVuZGVmaW5lZClcblxuZXh0ZXJuYWwgbWFrZV9mb3J3YXJkIDogT2JqLnQgLT4gT2JqLnQgLT4gdW5pdCA9IFwiY2FtbF9vYmpfbWFrZV9mb3J3YXJkXCJcblxuKCogQXNzdW1lIFtibGtdIGlzIGEgYmxvY2sgd2l0aCB0YWcgbGF6eSAqKVxubGV0IGZvcmNlX2xhenlfYmxvY2sgKGJsayA6ICdhcmcgbGF6eV90KSA9XG4gIGxldCBjbG9zdXJlID0gKE9iai5vYmogKE9iai5maWVsZCAoT2JqLnJlcHIgYmxrKSAwKSA6IHVuaXQgLT4gJ2FyZykgaW5cbiAgT2JqLnNldF9maWVsZCAoT2JqLnJlcHIgYmxrKSAwIHJhaXNlX3VuZGVmaW5lZDtcbiAgdHJ5XG4gICAgbGV0IHJlc3VsdCA9IGNsb3N1cmUgKCkgaW5cbiAgICBtYWtlX2ZvcndhcmQgKE9iai5yZXByIGJsaykgKE9iai5yZXByIHJlc3VsdCk7XG4gICAgcmVzdWx0XG4gIHdpdGggZSAtPlxuICAgIE9iai5zZXRfZmllbGQgKE9iai5yZXByIGJsaykgMCAoT2JqLnJlcHIgKGZ1biAoKSAtPiByYWlzZSBlKSk7XG4gICAgcmFpc2UgZVxuXG5cbigqIEFzc3VtZSBbYmxrXSBpcyBhIGJsb2NrIHdpdGggdGFnIGxhenkgKilcbmxldCBmb3JjZV92YWxfbGF6eV9ibG9jayAoYmxrIDogJ2FyZyBsYXp5X3QpID1cbiAgbGV0IGNsb3N1cmUgPSAoT2JqLm9iaiAoT2JqLmZpZWxkIChPYmoucmVwciBibGspIDApIDogdW5pdCAtPiAnYXJnKSBpblxuICBPYmouc2V0X2ZpZWxkIChPYmoucmVwciBibGspIDAgcmFpc2VfdW5kZWZpbmVkO1xuICBsZXQgcmVzdWx0ID0gY2xvc3VyZSAoKSBpblxuICBtYWtlX2ZvcndhcmQgKE9iai5yZXByIGJsaykgKE9iai5yZXByIHJlc3VsdCk7XG4gIHJlc3VsdFxuXG5cbigqIFtmb3JjZV0gaXMgbm90IHVzZWQsIHNpbmNlIFtMYXp5LmZvcmNlXSBpcyBkZWNsYXJlZCBhcyBhIHByaW1pdGl2ZVxuICAgd2hvc2UgY29kZSBpbmxpbmVzIHRoZSB0YWcgdGVzdHMgb2YgaXRzIGFyZ3VtZW50LCBleGNlcHQgd2hlbiBhZmxcbiAgIGluc3RydW1lbnRhdGlvbiBpcyB0dXJuZWQgb24uICopXG5cbmxldCBmb3JjZSAobHp2IDogJ2FyZyBsYXp5X3QpID1cbiAgKCogVXNpbmcgW1N5cy5vcGFxdWVfaWRlbnRpdHldIHByZXZlbnRzIHR3byBwb3RlbnRpYWwgcHJvYmxlbXM6XG4gICAgIC0gSWYgdGhlIHZhbHVlIGlzIGtub3duIHRvIGhhdmUgRm9yd2FyZF90YWcsIHRoZW4gaXRzIHRhZyBjb3VsZCBoYXZlXG4gICAgICAgY2hhbmdlZCBkdXJpbmcgR0MsIHNvIHRoYXQgaW5mb3JtYXRpb24gbXVzdCBiZSBmb3Jnb3R0ZW4gKHNlZSBHUFIjNzEzXG4gICAgICAgYW5kIGlzc3VlICM3MzAxKVxuICAgICAtIElmIHRoZSB2YWx1ZSBpcyBrbm93biB0byBiZSBpbW11dGFibGUsIHRoZW4gaWYgdGhlIGNvbXBpbGVyXG4gICAgICAgY2Fubm90IHByb3ZlIHRoYXQgdGhlIGxhc3QgYnJhbmNoIGlzIG5vdCB0YWtlbiBpdCB3aWxsIGlzc3VlIGFcbiAgICAgICB3YXJuaW5nIDU5IChtb2RpZmljYXRpb24gb2YgYW4gaW1tdXRhYmxlIHZhbHVlKSAqKVxuICBsZXQgbHp2ID0gU3lzLm9wYXF1ZV9pZGVudGl0eSBsenYgaW5cbiAgbGV0IHggPSBPYmoucmVwciBsenYgaW5cbiAgbGV0IHQgPSBPYmoudGFnIHggaW5cbiAgaWYgdCA9IE9iai5mb3J3YXJkX3RhZyB0aGVuIChPYmoub2JqIChPYmouZmllbGQgeCAwKSA6ICdhcmcpIGVsc2VcbiAgaWYgdCA8PiBPYmoubGF6eV90YWcgdGhlbiAoT2JqLm9iaiB4IDogJ2FyZylcbiAgZWxzZSBmb3JjZV9sYXp5X2Jsb2NrIGx6dlxuXG5cbmxldCBmb3JjZV92YWwgKGx6diA6ICdhcmcgbGF6eV90KSA9XG4gIGxldCB4ID0gT2JqLnJlcHIgbHp2IGluXG4gIGxldCB0ID0gT2JqLnRhZyB4IGluXG4gIGlmIHQgPSBPYmouZm9yd2FyZF90YWcgdGhlbiAoT2JqLm9iaiAoT2JqLmZpZWxkIHggMCkgOiAnYXJnKSBlbHNlXG4gIGlmIHQgPD4gT2JqLmxhenlfdGFnIHRoZW4gKE9iai5vYmogeCA6ICdhcmcpXG4gIGVsc2UgZm9yY2VfdmFsX2xhenlfYmxvY2sgbHp2XG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBEYW1pZW4gRG9saWdleiwgcHJvamV0IFBhcmEsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk3IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIE1vZHVsZSBbTGF6eV06IGRlZmVycmVkIGNvbXB1dGF0aW9ucyAqKVxuXG5cbigqXG4gICBXQVJOSU5HOiBzb21lIHB1cnBsZSBtYWdpYyBpcyBnb2luZyBvbiBoZXJlLiAgRG8gbm90IHRha2UgdGhpcyBmaWxlXG4gICBhcyBhbiBleGFtcGxlIG9mIGhvdyB0byBwcm9ncmFtIGluIE9DYW1sLlxuKilcblxuXG4oKiBXZSBtYWtlIHVzZSBvZiB0d28gc3BlY2lhbCB0YWdzIHByb3ZpZGVkIGJ5IHRoZSBydW50aW1lOlxuICAgW2xhenlfdGFnXSBhbmQgW2ZvcndhcmRfdGFnXS5cblxuICAgQSB2YWx1ZSBvZiB0eXBlIFsnYSBMYXp5LnRdIGNhbiBiZSBvbmUgb2YgdGhyZWUgdGhpbmdzOlxuICAgMS4gQSBibG9jayBvZiBzaXplIDEgd2l0aCB0YWcgW2xhenlfdGFnXS4gIEl0cyBmaWVsZCBpcyBhIGNsb3N1cmUgb2ZcbiAgICAgIHR5cGUgW3VuaXQgLT4gJ2FdIHRoYXQgY29tcHV0ZXMgdGhlIHZhbHVlLlxuICAgMi4gQSBibG9jayBvZiBzaXplIDEgd2l0aCB0YWcgW2ZvcndhcmRfdGFnXS4gIEl0cyBmaWVsZCBpcyB0aGUgdmFsdWVcbiAgICAgIG9mIHR5cGUgWydhXSB0aGF0IHdhcyBjb21wdXRlZC5cbiAgIDMuIEFueXRoaW5nIGVsc2UgZXhjZXB0IGEgZmxvYXQuICBUaGlzIGhhcyB0eXBlIFsnYV0gYW5kIGlzIHRoZSB2YWx1ZVxuICAgICAgdGhhdCB3YXMgY29tcHV0ZWQuXG4gICBFeGNlcHRpb25zIGFyZSBzdG9yZWQgaW4gZm9ybWF0ICgxKS5cbiAgIFRoZSBHQyB3aWxsIG1hZ2ljYWxseSBjaGFuZ2UgdGhpbmdzIGZyb20gKDIpIHRvICgzKSBhY2NvcmRpbmcgdG8gaXRzXG4gICBmYW5jeS5cblxuICAgSWYgT0NhbWwgd2FzIGNvbmZpZ3VyZWQgd2l0aCB0aGUgLWZsYXQtZmxvYXQtYXJyYXkgb3B0aW9uICh3aGljaCBpc1xuICAgY3VycmVudGx5IHRoZSBkZWZhdWx0KSwgdGhlIGZvbGxvd2luZyBpcyBhbHNvIHRydWU6XG4gICBXZSBjYW5ub3QgdXNlIHJlcHJlc2VudGF0aW9uICgzKSBmb3IgYSBbZmxvYXQgTGF6eS50XSBiZWNhdXNlXG4gICBbY2FtbF9tYWtlX2FycmF5XSBhc3N1bWVzIHRoYXQgb25seSBhIFtmbG9hdF0gdmFsdWUgY2FuIGhhdmUgdGFnXG4gICBbRG91YmxlX3RhZ10uXG5cbiAgIFdlIGhhdmUgdG8gdXNlIHRoZSBidWlsdC1pbiB0eXBlIGNvbnN0cnVjdG9yIFtsYXp5X3RdIHRvXG4gICBsZXQgdGhlIGNvbXBpbGVyIGltcGxlbWVudCB0aGUgc3BlY2lhbCB0eXBpbmcgYW5kIGNvbXBpbGF0aW9uXG4gICBydWxlcyBmb3IgdGhlIFtsYXp5XSBrZXl3b3JkLlxuKilcblxudHlwZSAnYSB0ID0gJ2EgQ2FtbGludGVybmFsTGF6eS50XG5cbmV4Y2VwdGlvbiBVbmRlZmluZWQgPSBDYW1saW50ZXJuYWxMYXp5LlVuZGVmaW5lZFxuXG5leHRlcm5hbCBtYWtlX2ZvcndhcmQgOiAnYSAtPiAnYSBsYXp5X3QgPSBcImNhbWxfbGF6eV9tYWtlX2ZvcndhcmRcIlxuXG5leHRlcm5hbCBmb3JjZSA6ICdhIHQgLT4gJ2EgPSBcIiVsYXp5X2ZvcmNlXCJcblxuXG5sZXQgZm9yY2VfdmFsID0gQ2FtbGludGVybmFsTGF6eS5mb3JjZV92YWxcblxubGV0IGZyb21fZnVuIChmIDogdW5pdCAtPiAnYXJnKSA9XG4gIGxldCB4ID0gT2JqLm5ld19ibG9jayBPYmoubGF6eV90YWcgMSBpblxuICBPYmouc2V0X2ZpZWxkIHggMCAoT2JqLnJlcHIgZik7XG4gIChPYmoub2JqIHggOiAnYXJnIHQpXG5cbmxldCBmcm9tX3ZhbCAodiA6ICdhcmcpID1cbiAgbGV0IHQgPSBPYmoudGFnIChPYmoucmVwciB2KSBpblxuICBpZiB0ID0gT2JqLmZvcndhcmRfdGFnIHx8IHQgPSBPYmoubGF6eV90YWcgfHwgdCA9IE9iai5kb3VibGVfdGFnIHRoZW4gYmVnaW5cbiAgICBtYWtlX2ZvcndhcmQgdlxuICBlbmQgZWxzZSBiZWdpblxuICAgIChPYmoubWFnaWMgdiA6ICdhcmcgdClcbiAgZW5kXG5cblxubGV0IGlzX3ZhbCAobCA6ICdhcmcgdCkgPSBPYmoudGFnIChPYmoucmVwciBsKSA8PiBPYmoubGF6eV90YWdcblxubGV0IGxhenlfZnJvbV9mdW4gPSBmcm9tX2Z1blxuXG5sZXQgbGF6eV9mcm9tX3ZhbCA9IGZyb21fdmFsXG5cbmxldCBsYXp5X2lzX3ZhbCA9IGlzX3ZhbFxuXG5cbmxldCBtYXAgZiB4ID1cbiAgbGF6eSAoZiAoZm9yY2UgeCkpXG5cbmxldCBtYXBfdmFsIGYgeCA9XG4gIGlmIGlzX3ZhbCB4XG4gIHRoZW4gbGF6eV9mcm9tX3ZhbCAoZiAoZm9yY2UgeCkpXG4gIGVsc2UgbGF6eSAoZiAoZm9yY2UgeCkpXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgU2ltb24gQ3J1YW5lcyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE3IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIE1vZHVsZSBbU2VxXTogZnVuY3Rpb25hbCBpdGVyYXRvcnMgKilcblxudHlwZSArJ2Egbm9kZSA9XG4gIHwgTmlsXG4gIHwgQ29ucyBvZiAnYSAqICdhIHRcblxuYW5kICdhIHQgPSB1bml0IC0+ICdhIG5vZGVcblxubGV0IGVtcHR5ICgpID0gTmlsXG5cbmxldCByZXR1cm4geCAoKSA9IENvbnMgKHgsIGVtcHR5KVxuXG5sZXQgY29ucyB4IG5leHQgKCkgPSBDb25zICh4LCBuZXh0KVxuXG5sZXQgcmVjIGFwcGVuZCBzZXExIHNlcTIgKCkgPVxuICBtYXRjaCBzZXExKCkgd2l0aFxuICB8IE5pbCAtPiBzZXEyKClcbiAgfCBDb25zICh4LCBuZXh0KSAtPiBDb25zICh4LCBhcHBlbmQgbmV4dCBzZXEyKVxuXG5sZXQgcmVjIG1hcCBmIHNlcSAoKSA9IG1hdGNoIHNlcSgpIHdpdGhcbiAgfCBOaWwgLT4gTmlsXG4gIHwgQ29ucyAoeCwgbmV4dCkgLT4gQ29ucyAoZiB4LCBtYXAgZiBuZXh0KVxuXG5sZXQgcmVjIGZpbHRlcl9tYXAgZiBzZXEgKCkgPSBtYXRjaCBzZXEoKSB3aXRoXG4gIHwgTmlsIC0+IE5pbFxuICB8IENvbnMgKHgsIG5leHQpIC0+XG4gICAgICBtYXRjaCBmIHggd2l0aFxuICAgICAgICB8IE5vbmUgLT4gZmlsdGVyX21hcCBmIG5leHQgKClcbiAgICAgICAgfCBTb21lIHkgLT4gQ29ucyAoeSwgZmlsdGVyX21hcCBmIG5leHQpXG5cbmxldCByZWMgZmlsdGVyIGYgc2VxICgpID0gbWF0Y2ggc2VxKCkgd2l0aFxuICB8IE5pbCAtPiBOaWxcbiAgfCBDb25zICh4LCBuZXh0KSAtPlxuICAgICAgaWYgZiB4XG4gICAgICB0aGVuIENvbnMgKHgsIGZpbHRlciBmIG5leHQpXG4gICAgICBlbHNlIGZpbHRlciBmIG5leHQgKClcblxubGV0IHJlYyBjb25jYXQgc2VxICgpID0gbWF0Y2ggc2VxICgpIHdpdGhcbiAgfCBOaWwgLT4gTmlsXG4gIHwgQ29ucyAoeCwgbmV4dCkgLT5cbiAgICAgYXBwZW5kIHggKGNvbmNhdCBuZXh0KSAoKVxuXG5sZXQgcmVjIGZsYXRfbWFwIGYgc2VxICgpID0gbWF0Y2ggc2VxICgpIHdpdGhcbiAgfCBOaWwgLT4gTmlsXG4gIHwgQ29ucyAoeCwgbmV4dCkgLT5cbiAgICBhcHBlbmQgKGYgeCkgKGZsYXRfbWFwIGYgbmV4dCkgKClcblxubGV0IGNvbmNhdF9tYXAgPSBmbGF0X21hcFxuXG5sZXQgcmVjIGZvbGRfbGVmdCBmIGFjYyBzZXEgPVxuICBtYXRjaCBzZXEgKCkgd2l0aFxuICAgIHwgTmlsIC0+IGFjY1xuICAgIHwgQ29ucyAoeCwgbmV4dCkgLT5cbiAgICAgICAgbGV0IGFjYyA9IGYgYWNjIHggaW5cbiAgICAgICAgZm9sZF9sZWZ0IGYgYWNjIG5leHRcblxubGV0IHJlYyBpdGVyIGYgc2VxID1cbiAgbWF0Y2ggc2VxICgpIHdpdGhcbiAgICB8IE5pbCAtPiAoKVxuICAgIHwgQ29ucyAoeCwgbmV4dCkgLT5cbiAgICAgICAgZiB4O1xuICAgICAgICBpdGVyIGYgbmV4dFxuXG5sZXQgcmVjIHVuZm9sZCBmIHUgKCkgPVxuICBtYXRjaCBmIHUgd2l0aFxuICB8IE5vbmUgLT4gTmlsXG4gIHwgU29tZSAoeCwgdScpIC0+IENvbnMgKHgsIHVuZm9sZCBmIHUnKVxuXG5sZXQgaXNfZW1wdHkgeHMgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIHRydWVcbiAgfCBDb25zIChfLCBfKSAtPlxuICAgICAgZmFsc2VcblxubGV0IHVuY29ucyB4cyA9XG4gIG1hdGNoIHhzKCkgd2l0aFxuICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgU29tZSAoeCwgeHMpXG4gIHwgTmlsIC0+XG4gICAgICBOb25lXG5cblxuXG5sZXQgcmVjIGxlbmd0aF9hdXggYWNjdSB4cyA9XG4gIG1hdGNoIHhzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgYWNjdVxuICB8IENvbnMgKF8sIHhzKSAtPlxuICAgICAgbGVuZ3RoX2F1eCAoYWNjdSArIDEpIHhzXG5cbmxldFtAaW5saW5lXSBsZW5ndGggeHMgPVxuICBsZW5ndGhfYXV4IDAgeHNcblxubGV0IHJlYyBpdGVyaV9hdXggZiBpIHhzID1cbiAgbWF0Y2ggeHMoKSB3aXRoXG4gIHwgTmlsIC0+XG4gICAgICAoKVxuICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgZiBpIHg7XG4gICAgICBpdGVyaV9hdXggZiAoaSsxKSB4c1xuXG5sZXRbQGlubGluZV0gaXRlcmkgZiB4cyA9XG4gIGl0ZXJpX2F1eCBmIDAgeHNcblxubGV0IHJlYyBmb2xkX2xlZnRpX2F1eCBmIGFjY3UgaSB4cyA9XG4gIG1hdGNoIHhzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgYWNjdVxuICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgbGV0IGFjY3UgPSBmIGFjY3UgaSB4IGluXG4gICAgICBmb2xkX2xlZnRpX2F1eCBmIGFjY3UgKGkrMSkgeHNcblxubGV0W0BpbmxpbmVdIGZvbGRfbGVmdGkgZiBhY2N1IHhzID1cbiAgZm9sZF9sZWZ0aV9hdXggZiBhY2N1IDAgeHNcblxubGV0IHJlYyBmb3JfYWxsIHAgeHMgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIHRydWVcbiAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgIHAgeCAmJiBmb3JfYWxsIHAgeHNcblxubGV0IHJlYyBleGlzdHMgcCB4cyA9XG4gIG1hdGNoIHhzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgZmFsc2VcbiAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgIHAgeCB8fCBleGlzdHMgcCB4c1xuXG5sZXQgcmVjIGZpbmQgcCB4cyA9XG4gIG1hdGNoIHhzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgTm9uZVxuICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgaWYgcCB4IHRoZW4gU29tZSB4IGVsc2UgZmluZCBwIHhzXG5cbmxldCByZWMgZmluZF9tYXAgZiB4cyA9XG4gIG1hdGNoIHhzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgTm9uZVxuICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgbWF0Y2ggZiB4IHdpdGhcbiAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgIGZpbmRfbWFwIGYgeHNcbiAgICAgIHwgU29tZSBfIGFzIHJlc3VsdCAtPlxuICAgICAgICAgIHJlc3VsdFxuXG4oKiBbaXRlcjJdLCBbZm9sZF9sZWZ0Ml0sIFtmb3JfYWxsMl0sIFtleGlzdHMyXSwgW21hcDJdLCBbemlwXSB3b3JrIGFsc28gaW5cbiAgIHRoZSBjYXNlIHdoZXJlIHRoZSB0d28gc2VxdWVuY2VzIGhhdmUgZGlmZmVyZW50IGxlbmd0aHMuIFRoZXkgc3RvcCBhcyBzb29uXG4gICBhcyBvbmUgc2VxdWVuY2UgaXMgZXhoYXVzdGVkLiBUaGVpciBiZWhhdmlvciBpcyBzbGlnaHRseSBhc3ltbWV0cmljOiB3aGVuXG4gICBbeHNdIGlzIGVtcHR5LCB0aGV5IGRvIG5vdCBmb3JjZSBbeXNdOyBob3dldmVyLCB3aGVuIFt5c10gaXMgZW1wdHksIFt4c10gaXNcbiAgIGZvcmNlZCwgZXZlbiB0aG91Z2ggdGhlIHJlc3VsdCBvZiB0aGUgZnVuY3Rpb24gYXBwbGljYXRpb24gW3hzKCldIHR1cm5zIG91dFxuICAgdG8gYmUgdXNlbGVzcy4gKilcblxubGV0IHJlYyBpdGVyMiBmIHhzIHlzID1cbiAgbWF0Y2ggeHMoKSB3aXRoXG4gIHwgTmlsIC0+XG4gICAgICAoKVxuICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgbWF0Y2ggeXMoKSB3aXRoXG4gICAgICB8IE5pbCAtPlxuICAgICAgICAgICgpXG4gICAgICB8IENvbnMgKHksIHlzKSAtPlxuICAgICAgICAgIGYgeCB5O1xuICAgICAgICAgIGl0ZXIyIGYgeHMgeXNcblxubGV0IHJlYyBmb2xkX2xlZnQyIGYgYWNjdSB4cyB5cyA9XG4gIG1hdGNoIHhzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgYWNjdVxuICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgbWF0Y2ggeXMoKSB3aXRoXG4gICAgICB8IE5pbCAtPlxuICAgICAgICAgIGFjY3VcbiAgICAgIHwgQ29ucyAoeSwgeXMpIC0+XG4gICAgICAgICAgbGV0IGFjY3UgPSBmIGFjY3UgeCB5IGluXG4gICAgICAgICAgZm9sZF9sZWZ0MiBmIGFjY3UgeHMgeXNcblxubGV0IHJlYyBmb3JfYWxsMiBmIHhzIHlzID1cbiAgbWF0Y2ggeHMoKSB3aXRoXG4gIHwgTmlsIC0+XG4gICAgICB0cnVlXG4gIHwgQ29ucyAoeCwgeHMpIC0+XG4gICAgICBtYXRjaCB5cygpIHdpdGhcbiAgICAgIHwgTmlsIC0+XG4gICAgICAgICAgdHJ1ZVxuICAgICAgfCBDb25zICh5LCB5cykgLT5cbiAgICAgICAgICBmIHggeSAmJiBmb3JfYWxsMiBmIHhzIHlzXG5cbmxldCByZWMgZXhpc3RzMiBmIHhzIHlzID1cbiAgbWF0Y2ggeHMoKSB3aXRoXG4gIHwgTmlsIC0+XG4gICAgICBmYWxzZVxuICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgbWF0Y2ggeXMoKSB3aXRoXG4gICAgICB8IE5pbCAtPlxuICAgICAgICAgIGZhbHNlXG4gICAgICB8IENvbnMgKHksIHlzKSAtPlxuICAgICAgICAgIGYgeCB5IHx8IGV4aXN0czIgZiB4cyB5c1xuXG5sZXQgcmVjIGVxdWFsIGVxIHhzIHlzID1cbiAgbWF0Y2ggeHMoKSwgeXMoKSB3aXRoXG4gIHwgTmlsLCBOaWwgLT5cbiAgICAgIHRydWVcbiAgfCBDb25zICh4LCB4cyksIENvbnMgKHksIHlzKSAtPlxuICAgICAgZXEgeCB5ICYmIGVxdWFsIGVxIHhzIHlzXG4gIHwgTmlsLCBDb25zIChfLCBfKVxuICB8IENvbnMgKF8sIF8pLCBOaWwgLT5cbiAgICAgIGZhbHNlXG5cbmxldCByZWMgY29tcGFyZSBjbXAgeHMgeXMgPVxuICBtYXRjaCB4cygpLCB5cygpIHdpdGhcbiAgfCBOaWwsIE5pbCAtPlxuICAgICAgMFxuICB8IENvbnMgKHgsIHhzKSwgQ29ucyAoeSwgeXMpIC0+XG4gICAgICBsZXQgYyA9IGNtcCB4IHkgaW5cbiAgICAgIGlmIGMgPD4gMCB0aGVuIGMgZWxzZSBjb21wYXJlIGNtcCB4cyB5c1xuICB8IE5pbCwgQ29ucyAoXywgXykgLT5cbiAgICAgIC0xXG4gIHwgQ29ucyAoXywgXyksIE5pbCAtPlxuICAgICAgKzFcblxuXG5cbigqIFtpbml0X2F1eCBmIGkgal0gaXMgdGhlIHNlcXVlbmNlIFtmIGksIC4uLiwgZiAoai0xKV0uICopXG5cbmxldCByZWMgaW5pdF9hdXggZiBpIGogKCkgPVxuICBpZiBpIDwgaiB0aGVuIGJlZ2luXG4gICAgQ29ucyAoZiBpLCBpbml0X2F1eCBmIChpICsgMSkgailcbiAgZW5kXG4gIGVsc2VcbiAgICBOaWxcblxubGV0IGluaXQgbiBmID1cbiAgaWYgbiA8IDAgdGhlblxuICAgIGludmFsaWRfYXJnIFwiU2VxLmluaXRcIlxuICBlbHNlXG4gICAgaW5pdF9hdXggZiAwIG5cblxubGV0IHJlYyByZXBlYXQgeCAoKSA9XG4gIENvbnMgKHgsIHJlcGVhdCB4KVxuXG5sZXQgcmVjIGZvcmV2ZXIgZiAoKSA9XG4gIENvbnMgKGYoKSwgZm9yZXZlciBmKVxuXG4oKiBUaGlzIHByZWxpbWluYXJ5IGRlZmluaXRpb24gb2YgW2N5Y2xlXSByZXF1aXJlcyB0aGUgc2VxdWVuY2UgW3hzXVxuICAgdG8gYmUgbm9uZW1wdHkuIEFwcGx5aW5nIGl0IHRvIGFuIGVtcHR5IHNlcXVlbmNlIHdvdWxkIHByb2R1Y2UgYVxuICAgc2VxdWVuY2UgdGhhdCBkaXZlcmdlcyB3aGVuIGl0IGlzIGZvcmNlZC4gKilcblxubGV0IHJlYyBjeWNsZV9ub25lbXB0eSB4cyAoKSA9XG4gIGFwcGVuZCB4cyAoY3ljbGVfbm9uZW1wdHkgeHMpICgpXG5cbigqIFtjeWNsZSB4c10gY2hlY2tzIHdoZXRoZXIgW3hzXSBpcyBlbXB0eSBhbmQsIGlmIHNvLCByZXR1cm5zIGFuIGVtcHR5XG4gICBzZXF1ZW5jZS4gT3RoZXJ3aXNlLCBbY3ljbGUgeHNdIHByb2R1Y2VzIG9uZSBjb3B5IG9mIFt4c10gZm9sbG93ZWRcbiAgIHdpdGggdGhlIGluZmluaXRlIHNlcXVlbmNlIFtjeWNsZV9ub25lbXB0eSB4c10uIFRodXMsIHRoZSBub25lbXB0aW5lc3NcbiAgIGNoZWNrIGlzIHBlcmZvcm1lZCBqdXN0IG9uY2UuICopXG5cbmxldCBjeWNsZSB4cyAoKSA9XG4gIG1hdGNoIHhzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgTmlsXG4gIHwgQ29ucyAoeCwgeHMnKSAtPlxuICAgICAgQ29ucyAoeCwgYXBwZW5kIHhzJyAoY3ljbGVfbm9uZW1wdHkgeHMpKVxuXG4oKiBbaXRlcmF0ZTEgZiB4XSBpcyB0aGUgc2VxdWVuY2UgW2YgeCwgZiAoZiB4KSwgLi4uXS5cbiAgIEl0IGlzIGVxdWl2YWxlbnQgdG8gW3RhaWwgKGl0ZXJhdGUgZiB4KV0uXG4gICBbaXRlcmF0ZTFdIGlzIHVzZWQgYXMgYSBidWlsZGluZyBibG9jayBpbiB0aGUgZGVmaW5pdGlvbiBvZiBbaXRlcmF0ZV0uICopXG5cbmxldCByZWMgaXRlcmF0ZTEgZiB4ICgpID1cbiAgbGV0IHkgPSBmIHggaW5cbiAgQ29ucyAoeSwgaXRlcmF0ZTEgZiB5KVxuXG4oKiBbaXRlcmF0ZSBmIHhdIGlzIHRoZSBzZXF1ZW5jZSBbeCwgZiB4LCAuLi5dLiAqKVxuXG4oKiBUaGUgcmVhc29uIHdoeSB3ZSBnaXZlIHRoaXMgc2xpZ2h0bHkgaW5kaXJlY3QgZGVmaW5pdGlvbiBvZiBbaXRlcmF0ZV0sXG4gICBhcyBvcHBvc2VkIHRvIHRoZSBtb3JlIG5haXZlIGRlZmluaXRpb24gdGhhdCBtYXkgY29tZSB0byBtaW5kLCBpcyB0aGF0XG4gICB3ZSBhcmUgY2FyZWZ1bCB0byBhdm9pZCBldmFsdWF0aW5nIFtmIHhdIHVudGlsIHRoaXMgZnVuY3Rpb24gY2FsbCBpc1xuICAgYWN0dWFsbHkgbmVjZXNzYXJ5LiBUaGUgbmFpdmUgZGVmaW5pdGlvbiAobm90IHNob3duIGhlcmUpIGNvbXB1dGVzIHRoZVxuICAgc2Vjb25kIGFyZ3VtZW50IG9mIHRoZSBzZXF1ZW5jZSwgW2YgeF0sIHdoZW4gdGhlIGZpcnN0IGFyZ3VtZW50IGlzXG4gICByZXF1ZXN0ZWQgYnkgdGhlIHVzZXIuICopXG5cbmxldCBpdGVyYXRlIGYgeCA9XG4gIGNvbnMgeCAoaXRlcmF0ZTEgZiB4KVxuXG5cblxubGV0IHJlYyBtYXBpX2F1eCBmIGkgeHMgKCkgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIE5pbFxuICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgQ29ucyAoZiBpIHgsIG1hcGlfYXV4IGYgKGkrMSkgeHMpXG5cbmxldFtAaW5saW5lXSBtYXBpIGYgeHMgPVxuICBtYXBpX2F1eCBmIDAgeHNcblxuKCogW3RhaWxfc2NhbiBmIHMgeHNdIGlzIGVxdWl2YWxlbnQgdG8gW3RhaWwgKHNjYW4gZiBzIHhzKV0uXG4gICBbdGFpbF9zY2FuXSBpcyB1c2VkIGFzIGEgYnVpbGRpbmcgYmxvY2sgaW4gdGhlIGRlZmluaXRpb24gb2YgW3NjYW5dLiAqKVxuXG4oKiBUaGlzIHNsaWdodGx5IGluZGlyZWN0IGRlZmluaXRpb24gb2YgW3NjYW5dIGlzIG1lYW50IHRvIGF2b2lkIGNvbXB1dGluZ1xuICAgZWxlbWVudHMgdG9vIGVhcmx5OyBzZWUgdGhlIGFib3ZlIGNvbW1lbnQgYWJvdXQgW2l0ZXJhdGUxXSBhbmQgW2l0ZXJhdGVdLiAqKVxuXG5sZXQgcmVjIHRhaWxfc2NhbiBmIHMgeHMgKCkgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIE5pbFxuICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgbGV0IHMgPSBmIHMgeCBpblxuICAgICAgQ29ucyAocywgdGFpbF9zY2FuIGYgcyB4cylcblxubGV0IHNjYW4gZiBzIHhzID1cbiAgY29ucyBzICh0YWlsX3NjYW4gZiBzIHhzKVxuXG4oKiBbdGFrZV0gaXMgZGVmaW5lZCBpbiBzdWNoIGEgd2F5IHRoYXQgW3Rha2UgMCB4c10gcmV0dXJucyBbZW1wdHldXG4gICBpbW1lZGlhdGVseSwgd2l0aG91dCBhbGxvY2F0aW5nIGFueSBtZW1vcnkuICopXG5cbmxldCByZWMgdGFrZV9hdXggbiB4cyA9XG4gIGlmIG4gPSAwIHRoZW5cbiAgICBlbXB0eVxuICBlbHNlXG4gICAgZnVuICgpIC0+XG4gICAgICBtYXRjaCB4cygpIHdpdGhcbiAgICAgIHwgTmlsIC0+XG4gICAgICAgICAgTmlsXG4gICAgICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgICAgIENvbnMgKHgsIHRha2VfYXV4IChuLTEpIHhzKVxuXG5sZXQgdGFrZSBuIHhzID1cbiAgaWYgbiA8IDAgdGhlbiBpbnZhbGlkX2FyZyBcIlNlcS50YWtlXCI7XG4gIHRha2VfYXV4IG4geHNcblxuKCogW2ZvcmNlX2Ryb3AgbiB4c10gaXMgZXF1aXZhbGVudCB0byBbZHJvcCBuIHhzICgpXS5cbiAgIFtmb3JjZV9kcm9wIG4geHNdIHJlcXVpcmVzIFtuID4gMF0uXG4gICBbZm9yY2VfZHJvcF0gaXMgdXNlZCBhcyBhIGJ1aWxkaW5nIGJsb2NrIGluIHRoZSBkZWZpbml0aW9uIG9mIFtkcm9wXS4gKilcblxubGV0IHJlYyBmb3JjZV9kcm9wIG4geHMgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIE5pbFxuICB8IENvbnMgKF8sIHhzKSAtPlxuICAgICAgbGV0IG4gPSBuIC0gMSBpblxuICAgICAgaWYgbiA9IDAgdGhlblxuICAgICAgICB4cygpXG4gICAgICBlbHNlXG4gICAgICAgIGZvcmNlX2Ryb3AgbiB4c1xuXG4oKiBbZHJvcF0gaXMgZGVmaW5lZCBpbiBzdWNoIGEgd2F5IHRoYXQgW2Ryb3AgMCB4c10gcmV0dXJucyBbeHNdIGltbWVkaWF0ZWx5LFxuICAgd2l0aG91dCBhbGxvY2F0aW5nIGFueSBtZW1vcnkuICopXG5cbmxldCBkcm9wIG4geHMgPVxuICBpZiBuIDwgMCB0aGVuIGludmFsaWRfYXJnIFwiU2VxLmRyb3BcIlxuICBlbHNlIGlmIG4gPSAwIHRoZW5cbiAgICB4c1xuICBlbHNlXG4gICAgZnVuICgpIC0+XG4gICAgICBmb3JjZV9kcm9wIG4geHNcblxubGV0IHJlYyB0YWtlX3doaWxlIHAgeHMgKCkgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIE5pbFxuICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgaWYgcCB4IHRoZW4gQ29ucyAoeCwgdGFrZV93aGlsZSBwIHhzKSBlbHNlIE5pbFxuXG5sZXQgcmVjIGRyb3Bfd2hpbGUgcCB4cyAoKSA9XG4gIG1hdGNoIHhzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgTmlsXG4gIHwgQ29ucyAoeCwgeHMpIGFzIG5vZGUgLT5cbiAgICAgIGlmIHAgeCB0aGVuIGRyb3Bfd2hpbGUgcCB4cyAoKSBlbHNlIG5vZGVcblxubGV0IHJlYyBncm91cCBlcSB4cyAoKSA9XG4gIG1hdGNoIHhzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgTmlsXG4gIHwgQ29ucyAoeCwgeHMpIC0+XG4gICAgICBDb25zIChjb25zIHggKHRha2Vfd2hpbGUgKGVxIHgpIHhzKSwgZ3JvdXAgZXEgKGRyb3Bfd2hpbGUgKGVxIHgpIHhzKSlcblxuZXhjZXB0aW9uIEZvcmNlZF90d2ljZVxuXG5tb2R1bGUgU3VzcGVuc2lvbiA9IHN0cnVjdFxuXG4gIHR5cGUgJ2Egc3VzcGVuc2lvbiA9XG4gICAgdW5pdCAtPiAnYVxuXG4gICgqIENvbnZlcnNpb25zLiAqKVxuXG4gIGxldCB0b19sYXp5IDogJ2Egc3VzcGVuc2lvbiAtPiAnYSBMYXp5LnQgPVxuICAgIExhenkuZnJvbV9mdW5cbiAgICAoKiBmdW4gcyAtPiBsYXp5IChzKCkpICopXG5cbiAgbGV0IGZyb21fbGF6eSAocyA6ICdhIExhenkudCkgOiAnYSBzdXNwZW5zaW9uID1cbiAgICBmdW4gKCkgLT4gTGF6eS5mb3JjZSBzXG5cbiAgKCogW21lbW9pemVdIHR1cm5zIGFuIGFyYml0cmFyeSBzdXNwZW5zaW9uIGludG8gYSBwZXJzaXN0ZW50IHN1c3BlbnNpb24uICopXG5cbiAgbGV0IG1lbW9pemUgKHMgOiAnYSBzdXNwZW5zaW9uKSA6ICdhIHN1c3BlbnNpb24gPVxuICAgIGZyb21fbGF6eSAodG9fbGF6eSBzKVxuXG4gICgqIFtmYWlsdXJlXSBpcyBhIHN1c3BlbnNpb24gdGhhdCBmYWlscyB3aGVuIGZvcmNlZC4gKilcblxuICBsZXQgZmFpbHVyZSA6IF8gc3VzcGVuc2lvbiA9XG4gICAgZnVuICgpIC0+XG4gICAgICAoKiBBIHN1c3BlbnNpb24gY3JlYXRlZCBieSBbb25jZV0gaGFzIGJlZW4gZm9yY2VkIHR3aWNlLiAqKVxuICAgICAgcmFpc2UgRm9yY2VkX3R3aWNlXG5cbiAgKCogSWYgW2ZdIGlzIGEgc3VzcGVuc2lvbiwgdGhlbiBbb25jZSBmXSBpcyBhIHN1c3BlbnNpb24gdGhhdCBjYW4gYmUgZm9yY2VkXG4gICAgIGF0IG1vc3Qgb25jZS4gSWYgaXQgaXMgZm9yY2VkIG1vcmUgdGhhbiBvbmNlLCB0aGVuIFtGb3JjZWRfdHdpY2VdIGlzXG4gICAgIHJhaXNlZC4gKilcblxuICBsZXQgb25jZSAoZiA6ICdhIHN1c3BlbnNpb24pIDogJ2Egc3VzcGVuc2lvbiA9XG4gICAgbGV0IGFjdGlvbiA9IENhbWxpbnRlcm5hbEF0b21pYy5tYWtlIGYgaW5cbiAgICBmdW4gKCkgLT5cbiAgICAgICgqIEdldCB0aGUgZnVuY3Rpb24gY3VycmVudGx5IHN0b3JlZCBpbiBbYWN0aW9uXSwgYW5kIHdyaXRlIHRoZVxuICAgICAgICAgZnVuY3Rpb24gW2ZhaWx1cmVdIGluIGl0cyBwbGFjZSwgc28gdGhlIG5leHQgYWNjZXNzIHdpbGwgcmVzdWx0XG4gICAgICAgICBpbiBhIGNhbGwgdG8gW2ZhaWx1cmUoKV0uICopXG4gICAgICBsZXQgZiA9IENhbWxpbnRlcm5hbEF0b21pYy5leGNoYW5nZSBhY3Rpb24gZmFpbHVyZSBpblxuICAgICAgZigpXG5cbmVuZCAoKiBTdXNwZW5zaW9uICopXG5cbmxldCByZWMgbWVtb2l6ZSB4cyA9XG4gIFN1c3BlbnNpb24ubWVtb2l6ZSAoZnVuICgpIC0+XG4gICAgbWF0Y2ggeHMoKSB3aXRoXG4gICAgfCBOaWwgLT5cbiAgICAgICAgTmlsXG4gICAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgICAgQ29ucyAoeCwgbWVtb2l6ZSB4cylcbiAgKVxuXG5sZXQgcmVjIG9uY2UgeHMgPVxuICBTdXNwZW5zaW9uLm9uY2UgKGZ1biAoKSAtPlxuICAgIG1hdGNoIHhzKCkgd2l0aFxuICAgIHwgTmlsIC0+XG4gICAgICAgIE5pbFxuICAgIHwgQ29ucyAoeCwgeHMpIC0+XG4gICAgICAgIENvbnMgKHgsIG9uY2UgeHMpXG4gIClcblxuXG5sZXQgcmVjIHppcCB4cyB5cyAoKSA9XG4gIG1hdGNoIHhzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgTmlsXG4gIHwgQ29ucyAoeCwgeHMpIC0+XG4gICAgICBtYXRjaCB5cygpIHdpdGhcbiAgICAgIHwgTmlsIC0+XG4gICAgICAgICAgTmlsXG4gICAgICB8IENvbnMgKHksIHlzKSAtPlxuICAgICAgICAgIENvbnMgKCh4LCB5KSwgemlwIHhzIHlzKVxuXG5sZXQgcmVjIG1hcDIgZiB4cyB5cyAoKSA9XG4gIG1hdGNoIHhzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgTmlsXG4gIHwgQ29ucyAoeCwgeHMpIC0+XG4gICAgICBtYXRjaCB5cygpIHdpdGhcbiAgICAgIHwgTmlsIC0+XG4gICAgICAgICAgTmlsXG4gICAgICB8IENvbnMgKHksIHlzKSAtPlxuICAgICAgICAgIENvbnMgKGYgeCB5LCBtYXAyIGYgeHMgeXMpXG5cbmxldCByZWMgaW50ZXJsZWF2ZSB4cyB5cyAoKSA9XG4gIG1hdGNoIHhzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgeXMoKVxuICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgQ29ucyAoeCwgaW50ZXJsZWF2ZSB5cyB4cylcblxuKCogW3NvcnRlZF9tZXJnZTFsIGNtcCB4IHhzIHlzXSBpcyBlcXVpdmFsZW50IHRvXG4gICAgIFtzb3J0ZWRfbWVyZ2UgY21wIChjb25zIHggeHMpIHlzXS5cblxuICAgW3NvcnRlZF9tZXJnZTFyIGNtcCB4cyB5IHlzXSBpcyBlcXVpdmFsZW50IHRvXG4gICAgIFtzb3J0ZWRfbWVyZ2UgY21wIHhzIChjb25zIHkgeXMpXS5cblxuICAgW3NvcnRlZF9tZXJnZTEgY21wIHggeHMgeSB5c10gaXMgZXF1aXZhbGVudCB0b1xuICAgICBbc29ydGVkX21lcmdlIGNtcCAoY29ucyB4IHhzKSAoY29ucyB5IHlzKV0uXG5cbiAgIFRoZXNlIHRocmVlIGZ1bmN0aW9ucyBhcmUgdXNlZCBhcyBidWlsZGluZyBibG9ja3MgaW4gdGhlIGRlZmluaXRpb25cbiAgIG9mIFtzb3J0ZWRfbWVyZ2VdLiAqKVxuXG5sZXQgcmVjIHNvcnRlZF9tZXJnZTFsIGNtcCB4IHhzIHlzICgpID1cbiAgbWF0Y2ggeXMoKSB3aXRoXG4gIHwgTmlsIC0+XG4gICAgICBDb25zICh4LCB4cylcbiAgfCBDb25zICh5LCB5cykgLT5cbiAgICAgIHNvcnRlZF9tZXJnZTEgY21wIHggeHMgeSB5c1xuXG5hbmQgc29ydGVkX21lcmdlMXIgY21wIHhzIHkgeXMgKCkgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIENvbnMgKHksIHlzKVxuICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgc29ydGVkX21lcmdlMSBjbXAgeCB4cyB5IHlzXG5cbmFuZCBzb3J0ZWRfbWVyZ2UxIGNtcCB4IHhzIHkgeXMgPVxuICBpZiBjbXAgeCB5IDw9IDAgdGhlblxuICAgIENvbnMgKHgsIHNvcnRlZF9tZXJnZTFyIGNtcCB4cyB5IHlzKVxuICBlbHNlXG4gICAgQ29ucyAoeSwgc29ydGVkX21lcmdlMWwgY21wIHggeHMgeXMpXG5cbmxldCBzb3J0ZWRfbWVyZ2UgY21wIHhzIHlzICgpID1cbiAgbWF0Y2ggeHMoKSwgeXMoKSB3aXRoXG4gICAgfCBOaWwsIE5pbCAtPlxuICAgICAgICBOaWxcbiAgICB8IE5pbCwgY1xuICAgIHwgYywgTmlsIC0+XG4gICAgICAgIGNcbiAgICB8IENvbnMgKHgsIHhzKSwgQ29ucyAoeSwgeXMpIC0+XG4gICAgICAgIHNvcnRlZF9tZXJnZTEgY21wIHggeHMgeSB5c1xuXG5cbmxldCByZWMgbWFwX2ZzdCB4eXMgKCkgPVxuICBtYXRjaCB4eXMoKSB3aXRoXG4gIHwgTmlsIC0+XG4gICAgICBOaWxcbiAgfCBDb25zICgoeCwgXyksIHh5cykgLT5cbiAgICAgIENvbnMgKHgsIG1hcF9mc3QgeHlzKVxuXG5sZXQgcmVjIG1hcF9zbmQgeHlzICgpID1cbiAgbWF0Y2ggeHlzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgTmlsXG4gIHwgQ29ucyAoKF8sIHkpLCB4eXMpIC0+XG4gICAgICBDb25zICh5LCBtYXBfc25kIHh5cylcblxubGV0IHVuemlwIHh5cyA9XG4gIG1hcF9mc3QgeHlzLCBtYXBfc25kIHh5c1xuXG5sZXQgc3BsaXQgPVxuICB1bnppcFxuXG4oKiBbZmlsdGVyX21hcF9maW5kX2xlZnRfbWFwIGYgeHNdIGlzIGVxdWl2YWxlbnQgdG9cbiAgIFtmaWx0ZXJfbWFwIEVpdGhlci5maW5kX2xlZnQgKG1hcCBmIHhzKV0uICopXG5cbmxldCByZWMgZmlsdGVyX21hcF9maW5kX2xlZnRfbWFwIGYgeHMgKCkgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIE5pbFxuICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgbWF0Y2ggZiB4IHdpdGhcbiAgICAgIHwgRWl0aGVyLkxlZnQgeSAtPlxuICAgICAgICAgIENvbnMgKHksIGZpbHRlcl9tYXBfZmluZF9sZWZ0X21hcCBmIHhzKVxuICAgICAgfCBFaXRoZXIuUmlnaHQgXyAtPlxuICAgICAgICAgIGZpbHRlcl9tYXBfZmluZF9sZWZ0X21hcCBmIHhzICgpXG5cbmxldCByZWMgZmlsdGVyX21hcF9maW5kX3JpZ2h0X21hcCBmIHhzICgpID1cbiAgbWF0Y2ggeHMoKSB3aXRoXG4gIHwgTmlsIC0+XG4gICAgICBOaWxcbiAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgIG1hdGNoIGYgeCB3aXRoXG4gICAgICB8IEVpdGhlci5MZWZ0IF8gLT5cbiAgICAgICAgICBmaWx0ZXJfbWFwX2ZpbmRfcmlnaHRfbWFwIGYgeHMgKClcbiAgICAgIHwgRWl0aGVyLlJpZ2h0IHogLT5cbiAgICAgICAgICBDb25zICh6LCBmaWx0ZXJfbWFwX2ZpbmRfcmlnaHRfbWFwIGYgeHMpXG5cbmxldCBwYXJ0aXRpb25fbWFwIGYgeHMgPVxuICBmaWx0ZXJfbWFwX2ZpbmRfbGVmdF9tYXAgZiB4cyxcbiAgZmlsdGVyX21hcF9maW5kX3JpZ2h0X21hcCBmIHhzXG5cbmxldCBwYXJ0aXRpb24gcCB4cyA9XG4gIGZpbHRlciBwIHhzLCBmaWx0ZXIgKGZ1biB4IC0+IG5vdCAocCB4KSkgeHNcblxuKCogSWYgW3hzc10gaXMgYSBtYXRyaXggKGEgc2VxdWVuY2Ugb2Ygcm93cyksIHRoZW4gW3BlZWwgeHNzXSBpcyBhIHBhaXIgb2ZcbiAgIHRoZSBmaXJzdCBjb2x1bW4gKGEgc2VxdWVuY2Ugb2YgZWxlbWVudHMpIGFuZCBvZiB0aGUgcmVtYWluZGVyIG9mIHRoZVxuICAgbWF0cml4IChhIHNlcXVlbmNlIG9mIHNob3J0ZXIgcm93cykuIFRoZXNlIHR3byBzZXF1ZW5jZXMgaGF2ZSB0aGUgc2FtZVxuICAgbGVuZ3RoLiBUaGUgcm93cyBvZiB0aGUgbWF0cml4IFt4c3NdIGFyZSBub3QgcmVxdWlyZWQgdG8gaGF2ZSB0aGUgc2FtZVxuICAgbGVuZ3RoLiBBbiBlbXB0eSByb3cgaXMgaWdub3JlZC4gKilcblxuKCogQmVjYXVzZSBbcGVlbF0gdXNlcyBbdW56aXBdLCBpdHMgYXJndW1lbnQgbXVzdCBiZSBwZXJzaXN0ZW50LiBUaGUgc2FtZVxuICAgcmVtYXJrIGFwcGxpZXMgdG8gW3RyYW5zcG9zZV0sIFtkaWFnb25hbHNdLCBbcHJvZHVjdF0sIGV0Yy4gKilcblxubGV0IHBlZWwgeHNzID1cbiAgdW56aXAgKGZpbHRlcl9tYXAgdW5jb25zIHhzcylcblxubGV0IHJlYyB0cmFuc3Bvc2UgeHNzICgpID1cbiAgbGV0IGhlYWRzLCB0YWlscyA9IHBlZWwgeHNzIGluXG4gIGlmIGlzX2VtcHR5IGhlYWRzIHRoZW4gYmVnaW5cbiAgICBhc3NlcnQgKGlzX2VtcHR5IHRhaWxzKTtcbiAgICBOaWxcbiAgZW5kXG4gIGVsc2VcbiAgICBDb25zIChoZWFkcywgdHJhbnNwb3NlIHRhaWxzKVxuXG4oKiBUaGUgaW50ZXJuYWwgZnVuY3Rpb24gW2RpYWdvbmFsc10gdGFrZXMgYW4gZXh0cmEgYXJndW1lbnQsIFtyZW1haW5kZXJzXSxcbiAgIHdoaWNoIGNvbnRhaW5zIHRoZSByZW1haW5kZXJzIG9mIHRoZSByb3dzIHRoYXQgaGF2ZSBhbHJlYWR5IGJlZW5cbiAgIGRpc2NvdmVyZWQuICopXG5cbmxldCByZWMgZGlhZ29uYWxzIHJlbWFpbmRlcnMgeHNzICgpID1cbiAgbWF0Y2ggeHNzKCkgd2l0aFxuICB8IENvbnMgKHhzLCB4c3MpIC0+XG4gICAgICBiZWdpbiBtYXRjaCB4cygpIHdpdGhcbiAgICAgIHwgQ29ucyAoeCwgeHMpIC0+XG4gICAgICAgICAgKCogV2UgZGlzY292ZXIgYSBuZXcgbm9uZW1wdHkgcm93IFt4IDo6IHhzXS4gVGh1cywgdGhlIG5leHQgZGlhZ29uYWxcbiAgICAgICAgICAgICBpcyBbeCA6OiBoZWFkc106IHRoaXMgZGlhZ29uYWwgYmVnaW5zIHdpdGggW3hdIGFuZCBjb250aW51ZXMgd2l0aFxuICAgICAgICAgICAgIHRoZSBmaXJzdCBlbGVtZW50IG9mIGV2ZXJ5IHJvdyBpbiBbcmVtYWluZGVyc10uIEluIHRoZSByZWN1cnNpdmVcbiAgICAgICAgICAgICBjYWxsLCB0aGUgYXJndW1lbnQgW3JlbWFpbmRlcnNdIGlzIGluc3RhbnRpYXRlZCB3aXRoIFt4cyA6OlxuICAgICAgICAgICAgIHRhaWxzXSwgd2hpY2ggbWVhbnMgdGhhdCB3ZSBoYXZlIG9uZSBtb3JlIHJlbWFpbmluZyByb3csIFt4c10sXG4gICAgICAgICAgICAgYW5kIHRoYXQgd2Uga2VlcCB0aGUgdGFpbHMgb2YgdGhlIHByZS1leGlzdGluZyByZW1haW5pbmcgcm93cy4gKilcbiAgICAgICAgICBsZXQgaGVhZHMsIHRhaWxzID0gcGVlbCByZW1haW5kZXJzIGluXG4gICAgICAgICAgQ29ucyAoY29ucyB4IGhlYWRzLCBkaWFnb25hbHMgKGNvbnMgeHMgdGFpbHMpIHhzcylcbiAgICAgIHwgTmlsIC0+XG4gICAgICAgICAgKCogV2UgZGlzY292ZXIgYSBuZXcgZW1wdHkgcm93LiBJbiB0aGlzIGNhc2UsIHRoZSBuZXcgZGlhZ29uYWwgaXNcbiAgICAgICAgICAgICBqdXN0IFtoZWFkc10sIGFuZCBbcmVtYWluZGVyc10gaXMgaW5zdGFudGlhdGVkIHdpdGgganVzdCBbdGFpbHNdLFxuICAgICAgICAgICAgIGFzIHdlIGRvIG5vdCBoYXZlIG9uZSBtb3JlIHJlbWFpbmluZyByb3cuICopXG4gICAgICAgICAgbGV0IGhlYWRzLCB0YWlscyA9IHBlZWwgcmVtYWluZGVycyBpblxuICAgICAgICAgIENvbnMgKGhlYWRzLCBkaWFnb25hbHMgdGFpbHMgeHNzKVxuICAgICAgZW5kXG4gIHwgTmlsIC0+XG4gICAgICAoKiBUaGVyZSBhcmUgbm8gbW9yZSByb3dzIHRvIGJlIGRpc2NvdmVyZWQuIFRoZXJlIHJlbWFpbnMgdG8gZXhoYXVzdFxuICAgICAgICAgdGhlIHJlbWFpbmluZyByb3dzLiAqKVxuICAgICAgdHJhbnNwb3NlIHJlbWFpbmRlcnMgKClcblxuKCogSWYgW3hzc10gaXMgYSBtYXRyaXggKGEgc2VxdWVuY2Ugb2Ygcm93cyksIHRoZW4gW2RpYWdvbmFscyB4c3NdIGlzXG4gICB0aGUgc2VxdWVuY2Ugb2YgaXRzIGRpYWdvbmFscy5cblxuICAgVGhlIGZpcnN0IGRpYWdvbmFsIGNvbnRhaW5zIGp1c3QgdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlXG4gICBmaXJzdCByb3cuIFRoZSBzZWNvbmQgZGlhZ29uYWwgY29udGFpbnMgdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlXG4gICBzZWNvbmQgcm93IGFuZCB0aGUgc2Vjb25kIGVsZW1lbnQgb2YgdGhlIGZpcnN0IHJvdzsgYW5kIHNvIG9uLlxuICAgVGhpcyBraW5kIG9mIGRpYWdvbmFsIGlzIGluIGZhY3Qgc29tZXRpbWVzIGtub3duIGFzIGFuIGFudGlkaWFnb25hbC5cblxuICAgLSBFdmVyeSBkaWFnb25hbCBpcyBhIGZpbml0ZSBzZXF1ZW5jZS5cbiAgIC0gVGhlIHJvd3Mgb2YgdGhlIG1hdHJpeCBbeHNzXSBhcmUgbm90IHJlcXVpcmVkIHRvIGhhdmUgdGhlIHNhbWUgbGVuZ3RoLlxuICAgLSBUaGUgbWF0cml4IFt4c3NdIGlzIG5vdCByZXF1aXJlZCB0byBiZSBmaW5pdGUgKGluIGVpdGhlciBkaXJlY3Rpb24pLlxuICAgLSBUaGUgbWF0cml4IFt4c3NdIG11c3QgYmUgcGVyc2lzdGVudC4gKilcblxubGV0IGRpYWdvbmFscyB4c3MgPVxuICBkaWFnb25hbHMgZW1wdHkgeHNzXG5cbmxldCBtYXBfcHJvZHVjdCBmIHhzIHlzID1cbiAgY29uY2F0IChkaWFnb25hbHMgKFxuICAgIG1hcCAoZnVuIHggLT5cbiAgICAgIG1hcCAoZnVuIHkgLT5cbiAgICAgICAgZiB4IHlcbiAgICAgICkgeXNcbiAgICApIHhzXG4gICkpXG5cbmxldCBwcm9kdWN0IHhzIHlzID1cbiAgbWFwX3Byb2R1Y3QgKGZ1biB4IHkgLT4gKHgsIHkpKSB4cyB5c1xuXG5sZXQgb2ZfZGlzcGVuc2VyIGl0ID1cbiAgbGV0IHJlYyBjICgpID1cbiAgICBtYXRjaCBpdCgpIHdpdGhcbiAgICB8IE5vbmUgLT5cbiAgICAgICAgTmlsXG4gICAgfCBTb21lIHggLT5cbiAgICAgICAgQ29ucyAoeCwgYylcbiAgaW5cbiAgY1xuXG5sZXQgdG9fZGlzcGVuc2VyIHhzID1cbiAgbGV0IHMgPSByZWYgeHMgaW5cbiAgZnVuICgpIC0+XG4gICAgbWF0Y2ggKCFzKSgpIHdpdGhcbiAgICB8IE5pbCAtPlxuICAgICAgICBOb25lXG4gICAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgICAgcyA6PSB4cztcbiAgICAgICAgU29tZSB4XG5cblxuXG5sZXQgcmVjIGludHMgaSAoKSA9XG4gIENvbnMgKGksIGludHMgKGkgKyAxKSlcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBPQ2FtbCBwcm9ncmFtbWVycyAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMTggSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxudHlwZSAnYSB0ID0gJ2Egb3B0aW9uID0gTm9uZSB8IFNvbWUgb2YgJ2FcblxubGV0IG5vbmUgPSBOb25lXG5sZXQgc29tZSB2ID0gU29tZSB2XG5sZXQgdmFsdWUgbyB+ZGVmYXVsdCA9IG1hdGNoIG8gd2l0aCBTb21lIHYgLT4gdiB8IE5vbmUgLT4gZGVmYXVsdFxubGV0IGdldCA9IGZ1bmN0aW9uIFNvbWUgdiAtPiB2IHwgTm9uZSAtPiBpbnZhbGlkX2FyZyBcIm9wdGlvbiBpcyBOb25lXCJcbmxldCBiaW5kIG8gZiA9IG1hdGNoIG8gd2l0aCBOb25lIC0+IE5vbmUgfCBTb21lIHYgLT4gZiB2XG5sZXQgam9pbiA9IGZ1bmN0aW9uIFNvbWUgbyAtPiBvIHwgTm9uZSAtPiBOb25lXG5sZXQgbWFwIGYgbyA9IG1hdGNoIG8gd2l0aCBOb25lIC0+IE5vbmUgfCBTb21lIHYgLT4gU29tZSAoZiB2KVxubGV0IGZvbGQgfm5vbmUgfnNvbWUgPSBmdW5jdGlvbiBTb21lIHYgLT4gc29tZSB2IHwgTm9uZSAtPiBub25lXG5sZXQgaXRlciBmID0gZnVuY3Rpb24gU29tZSB2IC0+IGYgdiB8IE5vbmUgLT4gKClcbmxldCBpc19ub25lID0gZnVuY3Rpb24gTm9uZSAtPiB0cnVlIHwgU29tZSBfIC0+IGZhbHNlXG5sZXQgaXNfc29tZSA9IGZ1bmN0aW9uIE5vbmUgLT4gZmFsc2UgfCBTb21lIF8gLT4gdHJ1ZVxuXG5sZXQgZXF1YWwgZXEgbzAgbzEgPSBtYXRjaCBvMCwgbzEgd2l0aFxufCBTb21lIHYwLCBTb21lIHYxIC0+IGVxIHYwIHYxXG58IE5vbmUsIE5vbmUgLT4gdHJ1ZVxufCBfIC0+IGZhbHNlXG5cbmxldCBjb21wYXJlIGNtcCBvMCBvMSA9IG1hdGNoIG8wLCBvMSB3aXRoXG58IFNvbWUgdjAsIFNvbWUgdjEgLT4gY21wIHYwIHYxXG58IE5vbmUsIE5vbmUgLT4gMFxufCBOb25lLCBTb21lIF8gLT4gLTFcbnwgU29tZSBfLCBOb25lIC0+IDFcblxubGV0IHRvX3Jlc3VsdCB+bm9uZSA9IGZ1bmN0aW9uIE5vbmUgLT4gRXJyb3Igbm9uZSB8IFNvbWUgdiAtPiBPayB2XG5sZXQgdG9fbGlzdCA9IGZ1bmN0aW9uIE5vbmUgLT4gW10gfCBTb21lIHYgLT4gW3ZdXG5sZXQgdG9fc2VxID0gZnVuY3Rpb24gTm9uZSAtPiBTZXEuZW1wdHkgfCBTb21lIHYgLT4gU2VxLnJldHVybiB2XG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgT0NhbWwgcHJvZ3JhbW1lcnMgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE4IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUgKCdhLCAnZSkgdCA9ICgnYSwgJ2UpIHJlc3VsdCA9IE9rIG9mICdhIHwgRXJyb3Igb2YgJ2VcblxubGV0IG9rIHYgPSBPayB2XG5sZXQgZXJyb3IgZSA9IEVycm9yIGVcbmxldCB2YWx1ZSByIH5kZWZhdWx0ID0gbWF0Y2ggciB3aXRoIE9rIHYgLT4gdiB8IEVycm9yIF8gLT4gZGVmYXVsdFxubGV0IGdldF9vayA9IGZ1bmN0aW9uIE9rIHYgLT4gdiB8IEVycm9yIF8gLT4gaW52YWxpZF9hcmcgXCJyZXN1bHQgaXMgRXJyb3IgX1wiXG5sZXQgZ2V0X2Vycm9yID0gZnVuY3Rpb24gRXJyb3IgZSAtPiBlIHwgT2sgXyAtPiBpbnZhbGlkX2FyZyBcInJlc3VsdCBpcyBPayBfXCJcbmxldCBiaW5kIHIgZiA9IG1hdGNoIHIgd2l0aCBPayB2IC0+IGYgdiB8IEVycm9yIF8gYXMgZSAtPiBlXG5sZXQgam9pbiA9IGZ1bmN0aW9uIE9rIHIgLT4gciB8IEVycm9yIF8gYXMgZSAtPiBlXG5sZXQgbWFwIGYgPSBmdW5jdGlvbiBPayB2IC0+IE9rIChmIHYpIHwgRXJyb3IgXyBhcyBlIC0+IGVcbmxldCBtYXBfZXJyb3IgZiA9IGZ1bmN0aW9uIEVycm9yIGUgLT4gRXJyb3IgKGYgZSkgfCBPayBfIGFzIHYgLT4gdlxubGV0IGZvbGQgfm9rIH5lcnJvciA9IGZ1bmN0aW9uIE9rIHYgLT4gb2sgdiB8IEVycm9yIGUgLT4gZXJyb3IgZVxubGV0IGl0ZXIgZiA9IGZ1bmN0aW9uIE9rIHYgLT4gZiB2IHwgRXJyb3IgXyAtPiAoKVxubGV0IGl0ZXJfZXJyb3IgZiA9IGZ1bmN0aW9uIEVycm9yIGUgLT4gZiBlIHwgT2sgXyAtPiAoKVxubGV0IGlzX29rID0gZnVuY3Rpb24gT2sgXyAtPiB0cnVlIHwgRXJyb3IgXyAtPiBmYWxzZVxubGV0IGlzX2Vycm9yID0gZnVuY3Rpb24gRXJyb3IgXyAtPiB0cnVlIHwgT2sgXyAtPiBmYWxzZVxuXG5sZXQgZXF1YWwgfm9rIH5lcnJvciByMCByMSA9IG1hdGNoIHIwLCByMSB3aXRoXG58IE9rIHYwLCBPayB2MSAtPiBvayB2MCB2MVxufCBFcnJvciBlMCwgRXJyb3IgZTEgLT4gZXJyb3IgZTAgZTFcbnwgXywgXyAtPiBmYWxzZVxuXG5sZXQgY29tcGFyZSB+b2sgfmVycm9yIHIwIHIxID0gbWF0Y2ggcjAsIHIxIHdpdGhcbnwgT2sgdjAsIE9rIHYxIC0+IG9rIHYwIHYxXG58IEVycm9yIGUwLCBFcnJvciBlMSAtPiBlcnJvciBlMCBlMVxufCBPayBfLCBFcnJvciBfIC0+IC0xXG58IEVycm9yIF8sIE9rIF8gLT4gMVxuXG5sZXQgdG9fb3B0aW9uID0gZnVuY3Rpb24gT2sgdiAtPiBTb21lIHYgfCBFcnJvciBfIC0+IE5vbmVcbmxldCB0b19saXN0ID0gZnVuY3Rpb24gT2sgdiAtPiBbdl0gfCBFcnJvciBfIC0+IFtdXG5sZXQgdG9fc2VxID0gZnVuY3Rpb24gT2sgdiAtPiBTZXEucmV0dXJuIHYgfCBFcnJvciBfIC0+IFNlcS5lbXB0eVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgVGhlIE9DYW1sIHByb2dyYW1tZXJzICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxOCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlIHQgPSBib29sID0gZmFsc2UgfCB0cnVlXG5cbmV4dGVybmFsIG5vdCA6IGJvb2wgLT4gYm9vbCA9IFwiJWJvb2xub3RcIlxuZXh0ZXJuYWwgKCAmJiApIDogYm9vbCAtPiBib29sIC0+IGJvb2wgPSBcIiVzZXF1YW5kXCJcbmV4dGVybmFsICggfHwgKSA6IGJvb2wgLT4gYm9vbCAtPiBib29sID0gXCIlc2VxdW9yXCJcbmxldCBlcXVhbCA6IGJvb2wgLT4gYm9vbCAtPiBib29sID0gKCA9IClcbmxldCBjb21wYXJlIDogYm9vbCAtPiBib29sIC0+IGludCA9IFN0ZGxpYi5jb21wYXJlXG5leHRlcm5hbCB0b19pbnQgOiBib29sIC0+IGludCA9IFwiJWlkZW50aXR5XCJcbmxldCB0b19mbG9hdCA9IGZ1bmN0aW9uIGZhbHNlIC0+IDAuIHwgdHJ1ZSAtPiAxLlxuXG4oKlxubGV0IG9mX3N0cmluZyA9IGZ1bmN0aW9uXG58IFwiZmFsc2VcIiAtPiBTb21lIGZhbHNlXG58IFwidHJ1ZVwiIC0+IFNvbWUgdHJ1ZVxufCBfIC0+IE5vbmVcbiopXG5cbmxldCB0b19zdHJpbmcgPSBmdW5jdGlvbiBmYWxzZSAtPiBcImZhbHNlXCIgfCB0cnVlIC0+IFwidHJ1ZVwiXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIENoYXJhY3RlciBvcGVyYXRpb25zICopXG5cbmV4dGVybmFsIGNvZGU6IGNoYXIgLT4gaW50ID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgdW5zYWZlX2NocjogaW50IC0+IGNoYXIgPSBcIiVpZGVudGl0eVwiXG5cbmxldCBjaHIgbiA9XG4gIGlmIG4gPCAwIHx8IG4gPiAyNTUgdGhlbiBpbnZhbGlkX2FyZyBcIkNoYXIuY2hyXCIgZWxzZSB1bnNhZmVfY2hyIG5cblxuZXh0ZXJuYWwgYnl0ZXNfY3JlYXRlOiBpbnQgLT4gYnl0ZXMgPSBcImNhbWxfY3JlYXRlX2J5dGVzXCJcbmV4dGVybmFsIGJ5dGVzX3Vuc2FmZV9zZXQgOiBieXRlcyAtPiBpbnQgLT4gY2hhciAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICA9IFwiJWJ5dGVzX3Vuc2FmZV9zZXRcIlxuZXh0ZXJuYWwgdW5zYWZlX3RvX3N0cmluZyA6IGJ5dGVzIC0+IHN0cmluZyA9IFwiJWJ5dGVzX3RvX3N0cmluZ1wiXG5cbmxldCBlc2NhcGVkID0gZnVuY3Rpb25cbiAgfCAnXFwnJyAtPiBcIlxcXFwnXCJcbiAgfCAnXFxcXCcgLT4gXCJcXFxcXFxcXFwiXG4gIHwgJ1xcbicgLT4gXCJcXFxcblwiXG4gIHwgJ1xcdCcgLT4gXCJcXFxcdFwiXG4gIHwgJ1xccicgLT4gXCJcXFxcclwiXG4gIHwgJ1xcYicgLT4gXCJcXFxcYlwiXG4gIHwgJyAnIC4uICd+JyBhcyBjIC0+XG4gICAgICBsZXQgcyA9IGJ5dGVzX2NyZWF0ZSAxIGluXG4gICAgICBieXRlc191bnNhZmVfc2V0IHMgMCBjO1xuICAgICAgdW5zYWZlX3RvX3N0cmluZyBzXG4gIHwgYyAtPlxuICAgICAgbGV0IG4gPSBjb2RlIGMgaW5cbiAgICAgIGxldCBzID0gYnl0ZXNfY3JlYXRlIDQgaW5cbiAgICAgIGJ5dGVzX3Vuc2FmZV9zZXQgcyAwICdcXFxcJztcbiAgICAgIGJ5dGVzX3Vuc2FmZV9zZXQgcyAxICh1bnNhZmVfY2hyICg0OCArIG4gLyAxMDApKTtcbiAgICAgIGJ5dGVzX3Vuc2FmZV9zZXQgcyAyICh1bnNhZmVfY2hyICg0OCArIChuIC8gMTApIG1vZCAxMCkpO1xuICAgICAgYnl0ZXNfdW5zYWZlX3NldCBzIDMgKHVuc2FmZV9jaHIgKDQ4ICsgbiBtb2QgMTApKTtcbiAgICAgIHVuc2FmZV90b19zdHJpbmcgc1xuXG5sZXQgbG93ZXJjYXNlID0gZnVuY3Rpb25cbiAgfCAnQScgLi4gJ1onXG4gIHwgJ1xcMTkyJyAuLiAnXFwyMTQnXG4gIHwgJ1xcMjE2JyAuLiAnXFwyMjInIGFzIGMgLT5cbiAgICB1bnNhZmVfY2hyKGNvZGUgYyArIDMyKVxuICB8IGMgLT4gY1xuXG5sZXQgdXBwZXJjYXNlID0gZnVuY3Rpb25cbiAgfCAnYScgLi4gJ3onXG4gIHwgJ1xcMjI0JyAuLiAnXFwyNDYnXG4gIHwgJ1xcMjQ4JyAuLiAnXFwyNTQnIGFzIGMgLT5cbiAgICB1bnNhZmVfY2hyKGNvZGUgYyAtIDMyKVxuICB8IGMgLT4gY1xuXG5sZXQgbG93ZXJjYXNlX2FzY2lpID0gZnVuY3Rpb25cbiAgfCAnQScgLi4gJ1onIGFzIGMgLT4gdW5zYWZlX2Nocihjb2RlIGMgKyAzMilcbiAgfCBjIC0+IGNcblxubGV0IHVwcGVyY2FzZV9hc2NpaSA9IGZ1bmN0aW9uXG4gIHwgJ2EnIC4uICd6JyBhcyBjIC0+IHVuc2FmZV9jaHIoY29kZSBjIC0gMzIpXG4gIHwgYyAtPiBjXG5cbnR5cGUgdCA9IGNoYXJcblxubGV0IGNvbXBhcmUgYzEgYzIgPSBjb2RlIGMxIC0gY29kZSBjMlxubGV0IGVxdWFsIChjMTogdCkgKGMyOiB0KSA9IGNvbXBhcmUgYzEgYzIgPSAwXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgIERhbmllbCBDLiBCdWVuemxpICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE0IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbmV4dGVybmFsIGZvcm1hdF9pbnQgOiBzdHJpbmcgLT4gaW50IC0+IHN0cmluZyA9IFwiY2FtbF9mb3JtYXRfaW50XCJcblxubGV0IGVycl9ub19wcmVkID0gXCJVKzAwMDAgaGFzIG5vIHByZWRlY2Vzc29yXCJcbmxldCBlcnJfbm9fc3VjYyA9IFwiVSsxMEZGRkYgaGFzIG5vIHN1Y2Nlc3NvclwiXG5sZXQgZXJyX25vdF9zdiBpID0gZm9ybWF0X2ludCBcIiVYXCIgaSBeIFwiIGlzIG5vdCBhbiBVbmljb2RlIHNjYWxhciB2YWx1ZVwiXG5sZXQgZXJyX25vdF9sYXRpbjEgdSA9IFwiVStcIiBeIGZvcm1hdF9pbnQgXCIlMDRYXCIgdSBeIFwiIGlzIG5vdCBhIGxhdGluMSBjaGFyYWN0ZXJcIlxuXG50eXBlIHQgPSBpbnRcblxubGV0IG1pbiA9IDB4MDAwMFxubGV0IG1heCA9IDB4MTBGRkZGXG5sZXQgbG9fYm91bmQgPSAweEQ3RkZcbmxldCBoaV9ib3VuZCA9IDB4RTAwMFxuXG5sZXQgYm9tID0gMHhGRUZGXG5sZXQgcmVwID0gMHhGRkZEXG5cbmxldCBzdWNjIHUgPVxuICBpZiB1ID0gbG9fYm91bmQgdGhlbiBoaV9ib3VuZCBlbHNlXG4gIGlmIHUgPSBtYXggdGhlbiBpbnZhbGlkX2FyZyBlcnJfbm9fc3VjYyBlbHNlXG4gIHUgKyAxXG5cbmxldCBwcmVkIHUgPVxuICBpZiB1ID0gaGlfYm91bmQgdGhlbiBsb19ib3VuZCBlbHNlXG4gIGlmIHUgPSBtaW4gdGhlbiBpbnZhbGlkX2FyZyBlcnJfbm9fcHJlZCBlbHNlXG4gIHUgLSAxXG5cbmxldCBpc192YWxpZCBpID0gKG1pbiA8PSBpICYmIGkgPD0gbG9fYm91bmQpIHx8IChoaV9ib3VuZCA8PSBpICYmIGkgPD0gbWF4KVxubGV0IG9mX2ludCBpID0gaWYgaXNfdmFsaWQgaSB0aGVuIGkgZWxzZSBpbnZhbGlkX2FyZyAoZXJyX25vdF9zdiBpKVxuZXh0ZXJuYWwgdW5zYWZlX29mX2ludCA6IGludCAtPiB0ID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgdG9faW50IDogdCAtPiBpbnQgPSBcIiVpZGVudGl0eVwiXG5cbmxldCBpc19jaGFyIHUgPSB1IDwgMjU2XG5sZXQgb2ZfY2hhciBjID0gQ2hhci5jb2RlIGNcbmxldCB0b19jaGFyIHUgPVxuICBpZiB1ID4gMjU1IHRoZW4gaW52YWxpZF9hcmcgKGVycl9ub3RfbGF0aW4xIHUpIGVsc2VcbiAgQ2hhci51bnNhZmVfY2hyIHVcblxubGV0IHVuc2FmZV90b19jaGFyID0gQ2hhci51bnNhZmVfY2hyXG5cbmxldCBlcXVhbCA6IGludCAtPiBpbnQgLT4gYm9vbCA9ICggPSApXG5sZXQgY29tcGFyZSA6IGludCAtPiBpbnQgLT4gaW50ID0gU3RkbGliLmNvbXBhcmVcbmxldCBoYXNoID0gdG9faW50XG5cbigqIFVURiBjb2RlY3MgdG9vbHMgKilcblxudHlwZSB1dGZfZGVjb2RlID0gaW50XG4oKiBUaGlzIGlzIGFuIGludCBbMHhEVVVVVVVVXSBkZWNvbXBvc2VkIGFzIGZvbGxvd3M6XG4gICAtIFtEXSBpcyBmb3VyIGJpdHMgZm9yIGRlY29kZSBpbmZvcm1hdGlvbiwgdGhlIGhpZ2hlc3QgYml0IGlzIHNldCBpZiB0aGVcbiAgICAgZGVjb2RlIGlzIHZhbGlkLiBUaGUgdGhyZWUgbG93ZXIgYml0cyBpbmRpY2F0ZSB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzXG4gICAgIGZyb20gdGhlIHNvdXJjZSB0aGF0IHdlcmUgY29uc3VtZWQgYnkgdGhlIGRlY29kZS5cbiAgIC0gW1VVVVVVVV0gaXMgdGhlIGRlY29kZWQgVW5pY29kZSBjaGFyYWN0ZXIgb3IgdGhlIFVuaWNvZGUgcmVwbGFjZW1lbnRcbiAgICAgY2hhcmFjdGVyIFUrRkZGRCBpZiBmb3IgaW52YWxpZCBkZWNvZGVzLiAqKVxuXG5sZXQgdmFsaWRfYml0ID0gMjdcbmxldCBkZWNvZGVfYml0cyA9IDI0XG5cbmxldFtAaW5saW5lXSB1dGZfZGVjb2RlX2lzX3ZhbGlkIGQgPSAoZCBsc3IgdmFsaWRfYml0KSA9IDFcbmxldFtAaW5saW5lXSB1dGZfZGVjb2RlX2xlbmd0aCBkID0gKGQgbHNyIGRlY29kZV9iaXRzKSBsYW5kIDBiMTExXG5sZXRbQGlubGluZV0gdXRmX2RlY29kZV91Y2hhciBkID0gdW5zYWZlX29mX2ludCAoZCBsYW5kIDB4RkZGRkZGKVxubGV0W0BpbmxpbmVdIHV0Zl9kZWNvZGUgbiB1ID0gKCg4IGxvciBuKSBsc2wgZGVjb2RlX2JpdHMpIGxvciAodG9faW50IHUpXG5sZXRbQGlubGluZV0gdXRmX2RlY29kZV9pbnZhbGlkIG4gPSAobiBsc2wgZGVjb2RlX2JpdHMpIGxvciByZXBcblxubGV0IHV0Zl84X2J5dGVfbGVuZ3RoIHUgPSBtYXRjaCB0b19pbnQgdSB3aXRoXG58IHUgd2hlbiB1IDwgMCAtPiBhc3NlcnQgZmFsc2VcbnwgdSB3aGVuIHUgPD0gMHgwMDdGIC0+IDFcbnwgdSB3aGVuIHUgPD0gMHgwN0ZGIC0+IDJcbnwgdSB3aGVuIHUgPD0gMHhGRkZGIC0+IDNcbnwgdSB3aGVuIHUgPD0gMHgxMEZGRkYgLT4gNFxufCBfIC0+IGFzc2VydCBmYWxzZVxuXG5sZXQgdXRmXzE2X2J5dGVfbGVuZ3RoIHUgPSBtYXRjaCB0b19pbnQgdSB3aXRoXG58IHUgd2hlbiB1IDwgMCAtPiBhc3NlcnQgZmFsc2VcbnwgdSB3aGVuIHUgPD0gMHhGRkZGIC0+IDJcbnwgdSB3aGVuIHUgPD0gMHgxMEZGRkYgLT4gNFxufCBfIC0+IGFzc2VydCBmYWxzZVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBBbiBhbGlhcyBmb3IgdGhlIHR5cGUgb2YgbGlzdHMuICopXG50eXBlICdhIHQgPSAnYSBsaXN0ID0gW10gfCAoOjopIG9mICdhICogJ2EgbGlzdFxuXG4oKiBMaXN0IG9wZXJhdGlvbnMgKilcblxubGV0IHJlYyBsZW5ndGhfYXV4IGxlbiA9IGZ1bmN0aW9uXG4gICAgW10gLT4gbGVuXG4gIHwgXzo6bCAtPiBsZW5ndGhfYXV4IChsZW4gKyAxKSBsXG5cbmxldCBsZW5ndGggbCA9IGxlbmd0aF9hdXggMCBsXG5cbmxldCBjb25zIGEgbCA9IGE6OmxcblxubGV0IGhkID0gZnVuY3Rpb25cbiAgICBbXSAtPiBmYWlsd2l0aCBcImhkXCJcbiAgfCBhOjpfIC0+IGFcblxubGV0IHRsID0gZnVuY3Rpb25cbiAgICBbXSAtPiBmYWlsd2l0aCBcInRsXCJcbiAgfCBfOjpsIC0+IGxcblxubGV0IG50aCBsIG4gPVxuICBpZiBuIDwgMCB0aGVuIGludmFsaWRfYXJnIFwiTGlzdC5udGhcIiBlbHNlXG4gIGxldCByZWMgbnRoX2F1eCBsIG4gPVxuICAgIG1hdGNoIGwgd2l0aFxuICAgIHwgW10gLT4gZmFpbHdpdGggXCJudGhcIlxuICAgIHwgYTo6bCAtPiBpZiBuID0gMCB0aGVuIGEgZWxzZSBudGhfYXV4IGwgKG4tMSlcbiAgaW4gbnRoX2F1eCBsIG5cblxubGV0IG50aF9vcHQgbCBuID1cbiAgaWYgbiA8IDAgdGhlbiBpbnZhbGlkX2FyZyBcIkxpc3QubnRoXCIgZWxzZVxuICBsZXQgcmVjIG50aF9hdXggbCBuID1cbiAgICBtYXRjaCBsIHdpdGhcbiAgICB8IFtdIC0+IE5vbmVcbiAgICB8IGE6OmwgLT4gaWYgbiA9IDAgdGhlbiBTb21lIGEgZWxzZSBudGhfYXV4IGwgKG4tMSlcbiAgaW4gbnRoX2F1eCBsIG5cblxubGV0IGFwcGVuZCA9IChAKVxuXG5sZXQgcmVjIHJldl9hcHBlbmQgbDEgbDIgPVxuICBtYXRjaCBsMSB3aXRoXG4gICAgW10gLT4gbDJcbiAgfCBhIDo6IGwgLT4gcmV2X2FwcGVuZCBsIChhIDo6IGwyKVxuXG5sZXQgcmV2IGwgPSByZXZfYXBwZW5kIGwgW11cblxubGV0IHJlYyBpbml0X3RhaWxyZWNfYXV4IGFjYyBpIG4gZiA9XG4gIGlmIGkgPj0gbiB0aGVuIGFjY1xuICBlbHNlIGluaXRfdGFpbHJlY19hdXggKGYgaSA6OiBhY2MpIChpKzEpIG4gZlxuXG5sZXQgcmVjIGluaXRfYXV4IGkgbiBmID1cbiAgaWYgaSA+PSBuIHRoZW4gW11cbiAgZWxzZVxuICAgIGxldCByID0gZiBpIGluXG4gICAgciA6OiBpbml0X2F1eCAoaSsxKSBuIGZcblxubGV0IHJldl9pbml0X3RocmVzaG9sZCA9XG4gIG1hdGNoIFN5cy5iYWNrZW5kX3R5cGUgd2l0aFxuICB8IFN5cy5OYXRpdmUgfCBTeXMuQnl0ZWNvZGUgLT4gMTBfMDAwXG4gICgqIFdlIGRvbid0IGtub3cgdGhlIHNpemUgb2YgdGhlIHN0YWNrLCBiZXR0ZXIgYmUgc2FmZSBhbmQgYXNzdW1lIGl0J3NcbiAgICAgc21hbGwuICopXG4gIHwgU3lzLk90aGVyIF8gLT4gNTBcblxubGV0IGluaXQgbGVuIGYgPVxuICBpZiBsZW4gPCAwIHRoZW4gaW52YWxpZF9hcmcgXCJMaXN0LmluaXRcIiBlbHNlXG4gIGlmIGxlbiA+IHJldl9pbml0X3RocmVzaG9sZCB0aGVuIHJldiAoaW5pdF90YWlscmVjX2F1eCBbXSAwIGxlbiBmKVxuICBlbHNlIGluaXRfYXV4IDAgbGVuIGZcblxubGV0IHJlYyBmbGF0dGVuID0gZnVuY3Rpb25cbiAgICBbXSAtPiBbXVxuICB8IGw6OnIgLT4gbCBAIGZsYXR0ZW4gclxuXG5sZXQgY29uY2F0ID0gZmxhdHRlblxuXG5sZXQgcmVjIG1hcCBmID0gZnVuY3Rpb25cbiAgICBbXSAtPiBbXVxuICB8IGE6OmwgLT4gbGV0IHIgPSBmIGEgaW4gciA6OiBtYXAgZiBsXG5cbmxldCByZWMgbWFwaSBpIGYgPSBmdW5jdGlvblxuICAgIFtdIC0+IFtdXG4gIHwgYTo6bCAtPiBsZXQgciA9IGYgaSBhIGluIHIgOjogbWFwaSAoaSArIDEpIGYgbFxuXG5sZXQgbWFwaSBmIGwgPSBtYXBpIDAgZiBsXG5cbmxldCByZXZfbWFwIGYgbCA9XG4gIGxldCByZWMgcm1hcF9mIGFjY3UgPSBmdW5jdGlvblxuICAgIHwgW10gLT4gYWNjdVxuICAgIHwgYTo6bCAtPiBybWFwX2YgKGYgYSA6OiBhY2N1KSBsXG4gIGluXG4gIHJtYXBfZiBbXSBsXG5cblxubGV0IHJlYyBpdGVyIGYgPSBmdW5jdGlvblxuICAgIFtdIC0+ICgpXG4gIHwgYTo6bCAtPiBmIGE7IGl0ZXIgZiBsXG5cbmxldCByZWMgaXRlcmkgaSBmID0gZnVuY3Rpb25cbiAgICBbXSAtPiAoKVxuICB8IGE6OmwgLT4gZiBpIGE7IGl0ZXJpIChpICsgMSkgZiBsXG5cbmxldCBpdGVyaSBmIGwgPSBpdGVyaSAwIGYgbFxuXG5sZXQgcmVjIGZvbGRfbGVmdCBmIGFjY3UgbCA9XG4gIG1hdGNoIGwgd2l0aFxuICAgIFtdIC0+IGFjY3VcbiAgfCBhOjpsIC0+IGZvbGRfbGVmdCBmIChmIGFjY3UgYSkgbFxuXG5sZXQgcmVjIGZvbGRfcmlnaHQgZiBsIGFjY3UgPVxuICBtYXRjaCBsIHdpdGhcbiAgICBbXSAtPiBhY2N1XG4gIHwgYTo6bCAtPiBmIGEgKGZvbGRfcmlnaHQgZiBsIGFjY3UpXG5cbmxldCByZWMgbWFwMiBmIGwxIGwyID1cbiAgbWF0Y2ggKGwxLCBsMikgd2l0aFxuICAgIChbXSwgW10pIC0+IFtdXG4gIHwgKGExOjpsMSwgYTI6OmwyKSAtPiBsZXQgciA9IGYgYTEgYTIgaW4gciA6OiBtYXAyIGYgbDEgbDJcbiAgfCAoXywgXykgLT4gaW52YWxpZF9hcmcgXCJMaXN0Lm1hcDJcIlxuXG5sZXQgcmV2X21hcDIgZiBsMSBsMiA9XG4gIGxldCByZWMgcm1hcDJfZiBhY2N1IGwxIGwyID1cbiAgICBtYXRjaCAobDEsIGwyKSB3aXRoXG4gICAgfCAoW10sIFtdKSAtPiBhY2N1XG4gICAgfCAoYTE6OmwxLCBhMjo6bDIpIC0+IHJtYXAyX2YgKGYgYTEgYTIgOjogYWNjdSkgbDEgbDJcbiAgICB8IChfLCBfKSAtPiBpbnZhbGlkX2FyZyBcIkxpc3QucmV2X21hcDJcIlxuICBpblxuICBybWFwMl9mIFtdIGwxIGwyXG5cblxubGV0IHJlYyBpdGVyMiBmIGwxIGwyID1cbiAgbWF0Y2ggKGwxLCBsMikgd2l0aFxuICAgIChbXSwgW10pIC0+ICgpXG4gIHwgKGExOjpsMSwgYTI6OmwyKSAtPiBmIGExIGEyOyBpdGVyMiBmIGwxIGwyXG4gIHwgKF8sIF8pIC0+IGludmFsaWRfYXJnIFwiTGlzdC5pdGVyMlwiXG5cbmxldCByZWMgZm9sZF9sZWZ0MiBmIGFjY3UgbDEgbDIgPVxuICBtYXRjaCAobDEsIGwyKSB3aXRoXG4gICAgKFtdLCBbXSkgLT4gYWNjdVxuICB8IChhMTo6bDEsIGEyOjpsMikgLT4gZm9sZF9sZWZ0MiBmIChmIGFjY3UgYTEgYTIpIGwxIGwyXG4gIHwgKF8sIF8pIC0+IGludmFsaWRfYXJnIFwiTGlzdC5mb2xkX2xlZnQyXCJcblxubGV0IHJlYyBmb2xkX3JpZ2h0MiBmIGwxIGwyIGFjY3UgPVxuICBtYXRjaCAobDEsIGwyKSB3aXRoXG4gICAgKFtdLCBbXSkgLT4gYWNjdVxuICB8IChhMTo6bDEsIGEyOjpsMikgLT4gZiBhMSBhMiAoZm9sZF9yaWdodDIgZiBsMSBsMiBhY2N1KVxuICB8IChfLCBfKSAtPiBpbnZhbGlkX2FyZyBcIkxpc3QuZm9sZF9yaWdodDJcIlxuXG5sZXQgcmVjIGZvcl9hbGwgcCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gdHJ1ZVxuICB8IGE6OmwgLT4gcCBhICYmIGZvcl9hbGwgcCBsXG5cbmxldCByZWMgZXhpc3RzIHAgPSBmdW5jdGlvblxuICAgIFtdIC0+IGZhbHNlXG4gIHwgYTo6bCAtPiBwIGEgfHwgZXhpc3RzIHAgbFxuXG5sZXQgcmVjIGZvcl9hbGwyIHAgbDEgbDIgPVxuICBtYXRjaCAobDEsIGwyKSB3aXRoXG4gICAgKFtdLCBbXSkgLT4gdHJ1ZVxuICB8IChhMTo6bDEsIGEyOjpsMikgLT4gcCBhMSBhMiAmJiBmb3JfYWxsMiBwIGwxIGwyXG4gIHwgKF8sIF8pIC0+IGludmFsaWRfYXJnIFwiTGlzdC5mb3JfYWxsMlwiXG5cbmxldCByZWMgZXhpc3RzMiBwIGwxIGwyID1cbiAgbWF0Y2ggKGwxLCBsMikgd2l0aFxuICAgIChbXSwgW10pIC0+IGZhbHNlXG4gIHwgKGExOjpsMSwgYTI6OmwyKSAtPiBwIGExIGEyIHx8IGV4aXN0czIgcCBsMSBsMlxuICB8IChfLCBfKSAtPiBpbnZhbGlkX2FyZyBcIkxpc3QuZXhpc3RzMlwiXG5cbmxldCByZWMgbWVtIHggPSBmdW5jdGlvblxuICAgIFtdIC0+IGZhbHNlXG4gIHwgYTo6bCAtPiBjb21wYXJlIGEgeCA9IDAgfHwgbWVtIHggbFxuXG5sZXQgcmVjIG1lbXEgeCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gZmFsc2VcbiAgfCBhOjpsIC0+IGEgPT0geCB8fCBtZW1xIHggbFxuXG5sZXQgcmVjIGFzc29jIHggPSBmdW5jdGlvblxuICAgIFtdIC0+IHJhaXNlIE5vdF9mb3VuZFxuICB8IChhLGIpOjpsIC0+IGlmIGNvbXBhcmUgYSB4ID0gMCB0aGVuIGIgZWxzZSBhc3NvYyB4IGxcblxubGV0IHJlYyBhc3NvY19vcHQgeCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gTm9uZVxuICB8IChhLGIpOjpsIC0+IGlmIGNvbXBhcmUgYSB4ID0gMCB0aGVuIFNvbWUgYiBlbHNlIGFzc29jX29wdCB4IGxcblxubGV0IHJlYyBhc3NxIHggPSBmdW5jdGlvblxuICAgIFtdIC0+IHJhaXNlIE5vdF9mb3VuZFxuICB8IChhLGIpOjpsIC0+IGlmIGEgPT0geCB0aGVuIGIgZWxzZSBhc3NxIHggbFxuXG5sZXQgcmVjIGFzc3Ffb3B0IHggPSBmdW5jdGlvblxuICAgIFtdIC0+IE5vbmVcbiAgfCAoYSxiKTo6bCAtPiBpZiBhID09IHggdGhlbiBTb21lIGIgZWxzZSBhc3NxX29wdCB4IGxcblxubGV0IHJlYyBtZW1fYXNzb2MgeCA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gZmFsc2VcbiAgfCAoYSwgXykgOjogbCAtPiBjb21wYXJlIGEgeCA9IDAgfHwgbWVtX2Fzc29jIHggbFxuXG5sZXQgcmVjIG1lbV9hc3NxIHggPSBmdW5jdGlvblxuICB8IFtdIC0+IGZhbHNlXG4gIHwgKGEsIF8pIDo6IGwgLT4gYSA9PSB4IHx8IG1lbV9hc3NxIHggbFxuXG5sZXQgcmVjIHJlbW92ZV9hc3NvYyB4ID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBbXVxuICB8IChhLCBfIGFzIHBhaXIpIDo6IGwgLT5cbiAgICAgIGlmIGNvbXBhcmUgYSB4ID0gMCB0aGVuIGwgZWxzZSBwYWlyIDo6IHJlbW92ZV9hc3NvYyB4IGxcblxubGV0IHJlYyByZW1vdmVfYXNzcSB4ID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBbXVxuICB8IChhLCBfIGFzIHBhaXIpIDo6IGwgLT4gaWYgYSA9PSB4IHRoZW4gbCBlbHNlIHBhaXIgOjogcmVtb3ZlX2Fzc3EgeCBsXG5cbmxldCByZWMgZmluZCBwID0gZnVuY3Rpb25cbiAgfCBbXSAtPiByYWlzZSBOb3RfZm91bmRcbiAgfCB4IDo6IGwgLT4gaWYgcCB4IHRoZW4geCBlbHNlIGZpbmQgcCBsXG5cbmxldCByZWMgZmluZF9vcHQgcCA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gTm9uZVxuICB8IHggOjogbCAtPiBpZiBwIHggdGhlbiBTb21lIHggZWxzZSBmaW5kX29wdCBwIGxcblxubGV0IHJlYyBmaW5kX21hcCBmID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBOb25lXG4gIHwgeCA6OiBsIC0+XG4gICAgIGJlZ2luIG1hdGNoIGYgeCB3aXRoXG4gICAgICAgfCBTb21lIF8gYXMgcmVzdWx0IC0+IHJlc3VsdFxuICAgICAgIHwgTm9uZSAtPiBmaW5kX21hcCBmIGxcbiAgICAgZW5kXG5cbmxldCBmaW5kX2FsbCBwID1cbiAgbGV0IHJlYyBmaW5kIGFjY3UgPSBmdW5jdGlvblxuICB8IFtdIC0+IHJldiBhY2N1XG4gIHwgeCA6OiBsIC0+IGlmIHAgeCB0aGVuIGZpbmQgKHggOjogYWNjdSkgbCBlbHNlIGZpbmQgYWNjdSBsIGluXG4gIGZpbmQgW11cblxubGV0IGZpbHRlciA9IGZpbmRfYWxsXG5cbmxldCBmaWx0ZXJpIHAgbCA9XG4gIGxldCByZWMgYXV4IGkgYWNjID0gZnVuY3Rpb25cbiAgfCBbXSAtPiByZXYgYWNjXG4gIHwgeDo6bCAtPiBhdXggKGkgKyAxKSAoaWYgcCBpIHggdGhlbiB4OjphY2MgZWxzZSBhY2MpIGxcbiAgaW5cbiAgYXV4IDAgW10gbFxuXG5sZXQgZmlsdGVyX21hcCBmID1cbiAgbGV0IHJlYyBhdXggYWNjdSA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiByZXYgYWNjdVxuICAgIHwgeCA6OiBsIC0+XG4gICAgICAgIG1hdGNoIGYgeCB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiBhdXggYWNjdSBsXG4gICAgICAgIHwgU29tZSB2IC0+IGF1eCAodiA6OiBhY2N1KSBsXG4gIGluXG4gIGF1eCBbXVxuXG5sZXQgY29uY2F0X21hcCBmIGwgPVxuICBsZXQgcmVjIGF1eCBmIGFjYyA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiByZXYgYWNjXG4gICAgfCB4IDo6IGwgLT5cbiAgICAgICBsZXQgeHMgPSBmIHggaW5cbiAgICAgICBhdXggZiAocmV2X2FwcGVuZCB4cyBhY2MpIGxcbiAgaW4gYXV4IGYgW10gbFxuXG5sZXQgZm9sZF9sZWZ0X21hcCBmIGFjY3UgbCA9XG4gIGxldCByZWMgYXV4IGFjY3UgbF9hY2N1ID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IGFjY3UsIHJldiBsX2FjY3VcbiAgICB8IHggOjogbCAtPlxuICAgICAgICBsZXQgYWNjdSwgeCA9IGYgYWNjdSB4IGluXG4gICAgICAgIGF1eCBhY2N1ICh4IDo6IGxfYWNjdSkgbCBpblxuICBhdXggYWNjdSBbXSBsXG5cbmxldCBwYXJ0aXRpb24gcCBsID1cbiAgbGV0IHJlYyBwYXJ0IHllcyBubyA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gKHJldiB5ZXMsIHJldiBubylcbiAgfCB4IDo6IGwgLT4gaWYgcCB4IHRoZW4gcGFydCAoeCA6OiB5ZXMpIG5vIGwgZWxzZSBwYXJ0IHllcyAoeCA6OiBubykgbCBpblxuICBwYXJ0IFtdIFtdIGxcblxubGV0IHBhcnRpdGlvbl9tYXAgcCBsID1cbiAgbGV0IHJlYyBwYXJ0IGxlZnQgcmlnaHQgPSBmdW5jdGlvblxuICB8IFtdIC0+IChyZXYgbGVmdCwgcmV2IHJpZ2h0KVxuICB8IHggOjogbCAtPlxuICAgICBiZWdpbiBtYXRjaCBwIHggd2l0aFxuICAgICAgIHwgRWl0aGVyLkxlZnQgdiAtPiBwYXJ0ICh2IDo6IGxlZnQpIHJpZ2h0IGxcbiAgICAgICB8IEVpdGhlci5SaWdodCB2IC0+IHBhcnQgbGVmdCAodiA6OiByaWdodCkgbFxuICAgICBlbmRcbiAgaW5cbiAgcGFydCBbXSBbXSBsXG5cbmxldCByZWMgc3BsaXQgPSBmdW5jdGlvblxuICAgIFtdIC0+IChbXSwgW10pXG4gIHwgKHgseSk6OmwgLT5cbiAgICAgIGxldCAocngsIHJ5KSA9IHNwbGl0IGwgaW4gKHg6OnJ4LCB5OjpyeSlcblxubGV0IHJlYyBjb21iaW5lIGwxIGwyID1cbiAgbWF0Y2ggKGwxLCBsMikgd2l0aFxuICAgIChbXSwgW10pIC0+IFtdXG4gIHwgKGExOjpsMSwgYTI6OmwyKSAtPiAoYTEsIGEyKSA6OiBjb21iaW5lIGwxIGwyXG4gIHwgKF8sIF8pIC0+IGludmFsaWRfYXJnIFwiTGlzdC5jb21iaW5lXCJcblxuKCoqIHNvcnRpbmcgKilcblxubGV0IHJlYyBtZXJnZSBjbXAgbDEgbDIgPVxuICBtYXRjaCBsMSwgbDIgd2l0aFxuICB8IFtdLCBsMiAtPiBsMlxuICB8IGwxLCBbXSAtPiBsMVxuICB8IGgxIDo6IHQxLCBoMiA6OiB0MiAtPlxuICAgICAgaWYgY21wIGgxIGgyIDw9IDBcbiAgICAgIHRoZW4gaDEgOjogbWVyZ2UgY21wIHQxIGwyXG4gICAgICBlbHNlIGgyIDo6IG1lcmdlIGNtcCBsMSB0MlxuXG5cbmxldCBzdGFibGVfc29ydCBjbXAgbCA9XG4gIGxldCByZWMgcmV2X21lcmdlIGwxIGwyIGFjY3UgPVxuICAgIG1hdGNoIGwxLCBsMiB3aXRoXG4gICAgfCBbXSwgbDIgLT4gcmV2X2FwcGVuZCBsMiBhY2N1XG4gICAgfCBsMSwgW10gLT4gcmV2X2FwcGVuZCBsMSBhY2N1XG4gICAgfCBoMTo6dDEsIGgyOjp0MiAtPlxuICAgICAgICBpZiBjbXAgaDEgaDIgPD0gMFxuICAgICAgICB0aGVuIHJldl9tZXJnZSB0MSBsMiAoaDE6OmFjY3UpXG4gICAgICAgIGVsc2UgcmV2X21lcmdlIGwxIHQyIChoMjo6YWNjdSlcbiAgaW5cbiAgbGV0IHJlYyByZXZfbWVyZ2VfcmV2IGwxIGwyIGFjY3UgPVxuICAgIG1hdGNoIGwxLCBsMiB3aXRoXG4gICAgfCBbXSwgbDIgLT4gcmV2X2FwcGVuZCBsMiBhY2N1XG4gICAgfCBsMSwgW10gLT4gcmV2X2FwcGVuZCBsMSBhY2N1XG4gICAgfCBoMTo6dDEsIGgyOjp0MiAtPlxuICAgICAgICBpZiBjbXAgaDEgaDIgPiAwXG4gICAgICAgIHRoZW4gcmV2X21lcmdlX3JldiB0MSBsMiAoaDE6OmFjY3UpXG4gICAgICAgIGVsc2UgcmV2X21lcmdlX3JldiBsMSB0MiAoaDI6OmFjY3UpXG4gIGluXG4gIGxldCByZWMgc29ydCBuIGwgPVxuICAgIG1hdGNoIG4sIGwgd2l0aFxuICAgIHwgMiwgeDEgOjogeDIgOjogdGwgLT5cbiAgICAgICAgbGV0IHMgPSBpZiBjbXAgeDEgeDIgPD0gMCB0aGVuIFt4MTsgeDJdIGVsc2UgW3gyOyB4MV0gaW5cbiAgICAgICAgKHMsIHRsKVxuICAgIHwgMywgeDEgOjogeDIgOjogeDMgOjogdGwgLT5cbiAgICAgICAgbGV0IHMgPVxuICAgICAgICAgIGlmIGNtcCB4MSB4MiA8PSAwIHRoZW5cbiAgICAgICAgICAgIGlmIGNtcCB4MiB4MyA8PSAwIHRoZW4gW3gxOyB4MjsgeDNdXG4gICAgICAgICAgICBlbHNlIGlmIGNtcCB4MSB4MyA8PSAwIHRoZW4gW3gxOyB4MzsgeDJdXG4gICAgICAgICAgICBlbHNlIFt4MzsgeDE7IHgyXVxuICAgICAgICAgIGVsc2UgaWYgY21wIHgxIHgzIDw9IDAgdGhlbiBbeDI7IHgxOyB4M11cbiAgICAgICAgICBlbHNlIGlmIGNtcCB4MiB4MyA8PSAwIHRoZW4gW3gyOyB4MzsgeDFdXG4gICAgICAgICAgZWxzZSBbeDM7IHgyOyB4MV1cbiAgICAgICAgaW5cbiAgICAgICAgKHMsIHRsKVxuICAgIHwgbiwgbCAtPlxuICAgICAgICBsZXQgbjEgPSBuIGFzciAxIGluXG4gICAgICAgIGxldCBuMiA9IG4gLSBuMSBpblxuICAgICAgICBsZXQgczEsIGwyID0gcmV2X3NvcnQgbjEgbCBpblxuICAgICAgICBsZXQgczIsIHRsID0gcmV2X3NvcnQgbjIgbDIgaW5cbiAgICAgICAgKHJldl9tZXJnZV9yZXYgczEgczIgW10sIHRsKVxuICBhbmQgcmV2X3NvcnQgbiBsID1cbiAgICBtYXRjaCBuLCBsIHdpdGhcbiAgICB8IDIsIHgxIDo6IHgyIDo6IHRsIC0+XG4gICAgICAgIGxldCBzID0gaWYgY21wIHgxIHgyID4gMCB0aGVuIFt4MTsgeDJdIGVsc2UgW3gyOyB4MV0gaW5cbiAgICAgICAgKHMsIHRsKVxuICAgIHwgMywgeDEgOjogeDIgOjogeDMgOjogdGwgLT5cbiAgICAgICAgbGV0IHMgPVxuICAgICAgICAgIGlmIGNtcCB4MSB4MiA+IDAgdGhlblxuICAgICAgICAgICAgaWYgY21wIHgyIHgzID4gMCB0aGVuIFt4MTsgeDI7IHgzXVxuICAgICAgICAgICAgZWxzZSBpZiBjbXAgeDEgeDMgPiAwIHRoZW4gW3gxOyB4MzsgeDJdXG4gICAgICAgICAgICBlbHNlIFt4MzsgeDE7IHgyXVxuICAgICAgICAgIGVsc2UgaWYgY21wIHgxIHgzID4gMCB0aGVuIFt4MjsgeDE7IHgzXVxuICAgICAgICAgIGVsc2UgaWYgY21wIHgyIHgzID4gMCB0aGVuIFt4MjsgeDM7IHgxXVxuICAgICAgICAgIGVsc2UgW3gzOyB4MjsgeDFdXG4gICAgICAgIGluXG4gICAgICAgIChzLCB0bClcbiAgICB8IG4sIGwgLT5cbiAgICAgICAgbGV0IG4xID0gbiBhc3IgMSBpblxuICAgICAgICBsZXQgbjIgPSBuIC0gbjEgaW5cbiAgICAgICAgbGV0IHMxLCBsMiA9IHNvcnQgbjEgbCBpblxuICAgICAgICBsZXQgczIsIHRsID0gc29ydCBuMiBsMiBpblxuICAgICAgICAocmV2X21lcmdlIHMxIHMyIFtdLCB0bClcbiAgaW5cbiAgbGV0IGxlbiA9IGxlbmd0aCBsIGluXG4gIGlmIGxlbiA8IDIgdGhlbiBsIGVsc2UgZnN0IChzb3J0IGxlbiBsKVxuXG5cbmxldCBzb3J0ID0gc3RhYmxlX3NvcnRcbmxldCBmYXN0X3NvcnQgPSBzdGFibGVfc29ydFxuXG4oKiBOb3RlOiBvbiBhIGxpc3Qgb2YgbGVuZ3RoIGJldHdlZW4gYWJvdXQgMTAwMDAwIChkZXBlbmRpbmcgb24gdGhlIG1pbm9yXG4gICBoZWFwIHNpemUgYW5kIHRoZSB0eXBlIG9mIHRoZSBsaXN0KSBhbmQgU3lzLm1heF9hcnJheV9zaXplLCBpdCBpc1xuICAgYWN0dWFsbHkgZmFzdGVyIHRvIHVzZSB0aGUgZm9sbG93aW5nLCBidXQgaXQgbWlnaHQgYWxzbyB1c2UgbW9yZSBtZW1vcnlcbiAgIGJlY2F1c2UgdGhlIGFyZ3VtZW50IGxpc3QgY2Fubm90IGJlIGRlYWxsb2NhdGVkIGluY3JlbWVudGFsbHkuXG5cbiAgIEFsc28sIHRoZXJlIHNlZW1zIHRvIGJlIGEgYnVnIGluIHRoaXMgY29kZSBvciBpbiB0aGVcbiAgIGltcGxlbWVudGF0aW9uIG9mIG9ial90cnVuY2F0ZS5cblxuZXh0ZXJuYWwgb2JqX3RydW5jYXRlIDogJ2EgYXJyYXkgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfb2JqX3RydW5jYXRlXCJcblxubGV0IGFycmF5X3RvX2xpc3RfaW5fcGxhY2UgYSA9XG4gIGxldCBsID0gQXJyYXkubGVuZ3RoIGEgaW5cbiAgbGV0IHJlYyBsb29wIGFjY3UgbiBwID1cbiAgICBpZiBwIDw9IDAgdGhlbiBhY2N1IGVsc2UgYmVnaW5cbiAgICAgIGlmIHAgPSBuIHRoZW4gYmVnaW5cbiAgICAgICAgb2JqX3RydW5jYXRlIGEgcDtcbiAgICAgICAgbG9vcCAoYS4ocC0xKSA6OiBhY2N1KSAobi0xMDAwKSAocC0xKVxuICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgbG9vcCAoYS4ocC0xKSA6OiBhY2N1KSBuIChwLTEpXG4gICAgICBlbmRcbiAgICBlbmRcbiAgaW5cbiAgbG9vcCBbXSAobC0xMDAwKSBsXG5cblxubGV0IHN0YWJsZV9zb3J0IGNtcCBsID1cbiAgbGV0IGEgPSBBcnJheS5vZl9saXN0IGwgaW5cbiAgQXJyYXkuc3RhYmxlX3NvcnQgY21wIGE7XG4gIGFycmF5X3RvX2xpc3RfaW5fcGxhY2UgYVxuXG4qKVxuXG5cbigqKiBzb3J0aW5nICsgcmVtb3ZpbmcgZHVwbGljYXRlcyAqKVxuXG5sZXQgc29ydF91bmlxIGNtcCBsID1cbiAgbGV0IHJlYyByZXZfbWVyZ2UgbDEgbDIgYWNjdSA9XG4gICAgbWF0Y2ggbDEsIGwyIHdpdGhcbiAgICB8IFtdLCBsMiAtPiByZXZfYXBwZW5kIGwyIGFjY3VcbiAgICB8IGwxLCBbXSAtPiByZXZfYXBwZW5kIGwxIGFjY3VcbiAgICB8IGgxOjp0MSwgaDI6OnQyIC0+XG4gICAgICAgIGxldCBjID0gY21wIGgxIGgyIGluXG4gICAgICAgIGlmIGMgPSAwIHRoZW4gcmV2X21lcmdlIHQxIHQyIChoMTo6YWNjdSlcbiAgICAgICAgZWxzZSBpZiBjIDwgMFxuICAgICAgICB0aGVuIHJldl9tZXJnZSB0MSBsMiAoaDE6OmFjY3UpXG4gICAgICAgIGVsc2UgcmV2X21lcmdlIGwxIHQyIChoMjo6YWNjdSlcbiAgaW5cbiAgbGV0IHJlYyByZXZfbWVyZ2VfcmV2IGwxIGwyIGFjY3UgPVxuICAgIG1hdGNoIGwxLCBsMiB3aXRoXG4gICAgfCBbXSwgbDIgLT4gcmV2X2FwcGVuZCBsMiBhY2N1XG4gICAgfCBsMSwgW10gLT4gcmV2X2FwcGVuZCBsMSBhY2N1XG4gICAgfCBoMTo6dDEsIGgyOjp0MiAtPlxuICAgICAgICBsZXQgYyA9IGNtcCBoMSBoMiBpblxuICAgICAgICBpZiBjID0gMCB0aGVuIHJldl9tZXJnZV9yZXYgdDEgdDIgKGgxOjphY2N1KVxuICAgICAgICBlbHNlIGlmIGMgPiAwXG4gICAgICAgIHRoZW4gcmV2X21lcmdlX3JldiB0MSBsMiAoaDE6OmFjY3UpXG4gICAgICAgIGVsc2UgcmV2X21lcmdlX3JldiBsMSB0MiAoaDI6OmFjY3UpXG4gIGluXG4gIGxldCByZWMgc29ydCBuIGwgPVxuICAgIG1hdGNoIG4sIGwgd2l0aFxuICAgIHwgMiwgeDEgOjogeDIgOjogdGwgLT5cbiAgICAgICAgbGV0IHMgPVxuICAgICAgICAgIGxldCBjID0gY21wIHgxIHgyIGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiBbeDFdIGVsc2UgaWYgYyA8IDAgdGhlbiBbeDE7IHgyXSBlbHNlIFt4MjsgeDFdXG4gICAgICAgIGluXG4gICAgICAgIChzLCB0bClcbiAgICB8IDMsIHgxIDo6IHgyIDo6IHgzIDo6IHRsIC0+XG4gICAgICAgIGxldCBzID1cbiAgICAgICAgICBsZXQgYyA9IGNtcCB4MSB4MiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW5cbiAgICAgICAgICAgIGxldCBjID0gY21wIHgyIHgzIGluXG4gICAgICAgICAgICBpZiBjID0gMCB0aGVuIFt4Ml0gZWxzZSBpZiBjIDwgMCB0aGVuIFt4MjsgeDNdIGVsc2UgW3gzOyB4Ml1cbiAgICAgICAgICBlbHNlIGlmIGMgPCAwIHRoZW5cbiAgICAgICAgICAgIGxldCBjID0gY21wIHgyIHgzIGluXG4gICAgICAgICAgICBpZiBjID0gMCB0aGVuIFt4MTsgeDJdXG4gICAgICAgICAgICBlbHNlIGlmIGMgPCAwIHRoZW4gW3gxOyB4MjsgeDNdXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGxldCBjID0gY21wIHgxIHgzIGluXG4gICAgICAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gxOyB4Ml1cbiAgICAgICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuIFt4MTsgeDM7IHgyXVxuICAgICAgICAgICAgICBlbHNlIFt4MzsgeDE7IHgyXVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxldCBjID0gY21wIHgxIHgzIGluXG4gICAgICAgICAgICBpZiBjID0gMCB0aGVuIFt4MjsgeDFdXG4gICAgICAgICAgICBlbHNlIGlmIGMgPCAwIHRoZW4gW3gyOyB4MTsgeDNdXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGxldCBjID0gY21wIHgyIHgzIGluXG4gICAgICAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gyOyB4MV1cbiAgICAgICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuIFt4MjsgeDM7IHgxXVxuICAgICAgICAgICAgICBlbHNlIFt4MzsgeDI7IHgxXVxuICAgICAgICBpblxuICAgICAgICAocywgdGwpXG4gICAgfCBuLCBsIC0+XG4gICAgICAgIGxldCBuMSA9IG4gYXNyIDEgaW5cbiAgICAgICAgbGV0IG4yID0gbiAtIG4xIGluXG4gICAgICAgIGxldCBzMSwgbDIgPSByZXZfc29ydCBuMSBsIGluXG4gICAgICAgIGxldCBzMiwgdGwgPSByZXZfc29ydCBuMiBsMiBpblxuICAgICAgICAocmV2X21lcmdlX3JldiBzMSBzMiBbXSwgdGwpXG4gIGFuZCByZXZfc29ydCBuIGwgPVxuICAgIG1hdGNoIG4sIGwgd2l0aFxuICAgIHwgMiwgeDEgOjogeDIgOjogdGwgLT5cbiAgICAgICAgbGV0IHMgPVxuICAgICAgICAgIGxldCBjID0gY21wIHgxIHgyIGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiBbeDFdIGVsc2UgaWYgYyA+IDAgdGhlbiBbeDE7IHgyXSBlbHNlIFt4MjsgeDFdXG4gICAgICAgIGluXG4gICAgICAgIChzLCB0bClcbiAgICB8IDMsIHgxIDo6IHgyIDo6IHgzIDo6IHRsIC0+XG4gICAgICAgIGxldCBzID1cbiAgICAgICAgICBsZXQgYyA9IGNtcCB4MSB4MiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW5cbiAgICAgICAgICAgIGxldCBjID0gY21wIHgyIHgzIGluXG4gICAgICAgICAgICBpZiBjID0gMCB0aGVuIFt4Ml0gZWxzZSBpZiBjID4gMCB0aGVuIFt4MjsgeDNdIGVsc2UgW3gzOyB4Ml1cbiAgICAgICAgICBlbHNlIGlmIGMgPiAwIHRoZW5cbiAgICAgICAgICAgIGxldCBjID0gY21wIHgyIHgzIGluXG4gICAgICAgICAgICBpZiBjID0gMCB0aGVuIFt4MTsgeDJdXG4gICAgICAgICAgICBlbHNlIGlmIGMgPiAwIHRoZW4gW3gxOyB4MjsgeDNdXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGxldCBjID0gY21wIHgxIHgzIGluXG4gICAgICAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gxOyB4Ml1cbiAgICAgICAgICAgICAgZWxzZSBpZiBjID4gMCB0aGVuIFt4MTsgeDM7IHgyXVxuICAgICAgICAgICAgICBlbHNlIFt4MzsgeDE7IHgyXVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxldCBjID0gY21wIHgxIHgzIGluXG4gICAgICAgICAgICBpZiBjID0gMCB0aGVuIFt4MjsgeDFdXG4gICAgICAgICAgICBlbHNlIGlmIGMgPiAwIHRoZW4gW3gyOyB4MTsgeDNdXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGxldCBjID0gY21wIHgyIHgzIGluXG4gICAgICAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gyOyB4MV1cbiAgICAgICAgICAgICAgZWxzZSBpZiBjID4gMCB0aGVuIFt4MjsgeDM7IHgxXVxuICAgICAgICAgICAgICBlbHNlIFt4MzsgeDI7IHgxXVxuICAgICAgICBpblxuICAgICAgICAocywgdGwpXG4gICAgfCBuLCBsIC0+XG4gICAgICAgIGxldCBuMSA9IG4gYXNyIDEgaW5cbiAgICAgICAgbGV0IG4yID0gbiAtIG4xIGluXG4gICAgICAgIGxldCBzMSwgbDIgPSBzb3J0IG4xIGwgaW5cbiAgICAgICAgbGV0IHMyLCB0bCA9IHNvcnQgbjIgbDIgaW5cbiAgICAgICAgKHJldl9tZXJnZSBzMSBzMiBbXSwgdGwpXG4gIGluXG4gIGxldCBsZW4gPSBsZW5ndGggbCBpblxuICBpZiBsZW4gPCAyIHRoZW4gbCBlbHNlIGZzdCAoc29ydCBsZW4gbClcblxuXG5sZXQgcmVjIGNvbXBhcmVfbGVuZ3RocyBsMSBsMiA9XG4gIG1hdGNoIGwxLCBsMiB3aXRoXG4gIHwgW10sIFtdIC0+IDBcbiAgfCBbXSwgXyAtPiAtMVxuICB8IF8sIFtdIC0+IDFcbiAgfCBfIDo6IGwxLCBfIDo6IGwyIC0+IGNvbXBhcmVfbGVuZ3RocyBsMSBsMlxuOztcblxubGV0IHJlYyBjb21wYXJlX2xlbmd0aF93aXRoIGwgbiA9XG4gIG1hdGNoIGwgd2l0aFxuICB8IFtdIC0+XG4gICAgaWYgbiA9IDAgdGhlbiAwIGVsc2VcbiAgICAgIGlmIG4gPiAwIHRoZW4gLTEgZWxzZSAxXG4gIHwgXyA6OiBsIC0+XG4gICAgaWYgbiA8PSAwIHRoZW4gMSBlbHNlXG4gICAgICBjb21wYXJlX2xlbmd0aF93aXRoIGwgKG4tMSlcbjs7XG5cbigqKiB7MSBDb21wYXJpc29ufSAqKVxuXG4oKiBOb3RlOiB3ZSBhcmUgKm5vdCogc2hvcnRjdXR0aW5nIHRoZSBsaXN0IGJ5IHVzaW5nXG4gICBbTGlzdC5jb21wYXJlX2xlbmd0aHNdIGZpcnN0OyB0aGlzIG1heSBiZSBzbG93ZXIgb24gbG9uZyBsaXN0c1xuICAgaW1tZWRpYXRlbHkgc3RhcnQgd2l0aCBkaXN0aW5jdCBlbGVtZW50cy4gSXQgaXMgYWxzbyBpbmNvcnJlY3QgZm9yXG4gICBbY29tcGFyZV0gYmVsb3csIGFuZCBpdCBpcyBiZXR0ZXIgKHByaW5jaXBsZSBvZiBsZWFzdCBzdXJwcmlzZSkgdG9cbiAgIHVzZSB0aGUgc2FtZSBhcHByb2FjaCBmb3IgYm90aCBmdW5jdGlvbnMuICopXG5sZXQgcmVjIGVxdWFsIGVxIGwxIGwyID1cbiAgbWF0Y2ggbDEsIGwyIHdpdGhcbiAgfCBbXSwgW10gLT4gdHJ1ZVxuICB8IFtdLCBfOjpfIHwgXzo6XywgW10gLT4gZmFsc2VcbiAgfCBhMTo6bDEsIGEyOjpsMiAtPiBlcSBhMSBhMiAmJiBlcXVhbCBlcSBsMSBsMlxuXG5sZXQgcmVjIGNvbXBhcmUgY21wIGwxIGwyID1cbiAgbWF0Y2ggbDEsIGwyIHdpdGhcbiAgfCBbXSwgW10gLT4gMFxuICB8IFtdLCBfOjpfIC0+IC0xXG4gIHwgXzo6XywgW10gLT4gMVxuICB8IGExOjpsMSwgYTI6OmwyIC0+XG4gICAgbGV0IGMgPSBjbXAgYTEgYTIgaW5cbiAgICBpZiBjIDw+IDAgdGhlbiBjXG4gICAgZWxzZSBjb21wYXJlIGNtcCBsMSBsMlxuXG4oKiogezEgSXRlcmF0b3JzfSAqKVxuXG5sZXQgdG9fc2VxIGwgPVxuICBsZXQgcmVjIGF1eCBsICgpID0gbWF0Y2ggbCB3aXRoXG4gICAgfCBbXSAtPiBTZXEuTmlsXG4gICAgfCB4IDo6IHRhaWwgLT4gU2VxLkNvbnMgKHgsIGF1eCB0YWlsKVxuICBpblxuICBhdXggbFxuXG5sZXQgb2Zfc2VxIHNlcSA9XG4gIGxldCByZWMgZGlyZWN0IGRlcHRoIHNlcSA6IF8gbGlzdCA9XG4gICAgaWYgZGVwdGg9MFxuICAgIHRoZW5cbiAgICAgIFNlcS5mb2xkX2xlZnQgKGZ1biBhY2MgeCAtPiB4OjphY2MpIFtdIHNlcVxuICAgICAgfD4gcmV2ICgqIHRhaWxyZWMgKilcbiAgICBlbHNlIG1hdGNoIHNlcSgpIHdpdGhcbiAgICAgIHwgU2VxLk5pbCAtPiBbXVxuICAgICAgfCBTZXEuQ29ucyAoeCwgbmV4dCkgLT4geCA6OiBkaXJlY3QgKGRlcHRoLTEpIG5leHRcbiAgaW5cbiAgZGlyZWN0IDUwMCBzZXFcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBPQ2FtbCBwcm9ncmFtbWVycyAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMTggSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxudHlwZSB0ID0gaW50XG5cbmxldCB6ZXJvID0gMFxubGV0IG9uZSA9IDFcbmxldCBtaW51c19vbmUgPSAtMVxuZXh0ZXJuYWwgbmVnIDogaW50IC0+IGludCA9IFwiJW5lZ2ludFwiXG5leHRlcm5hbCBhZGQgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWFkZGludFwiXG5leHRlcm5hbCBzdWIgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJXN1YmludFwiXG5leHRlcm5hbCBtdWwgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJW11bGludFwiXG5leHRlcm5hbCBkaXYgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWRpdmludFwiXG5leHRlcm5hbCByZW0gOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJW1vZGludFwiXG5leHRlcm5hbCBzdWNjIDogaW50IC0+IGludCA9IFwiJXN1Y2NpbnRcIlxuZXh0ZXJuYWwgcHJlZCA6IGludCAtPiBpbnQgPSBcIiVwcmVkaW50XCJcbmxldCBhYnMgeCA9IGlmIHggPj0gMCB0aGVuIHggZWxzZSAteFxubGV0IG1heF9pbnQgPSAoLTEpIGxzciAxXG5sZXQgbWluX2ludCA9IG1heF9pbnQgKyAxXG5leHRlcm5hbCBsb2dhbmQgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWFuZGludFwiXG5leHRlcm5hbCBsb2dvciA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlb3JpbnRcIlxuZXh0ZXJuYWwgbG9neG9yIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiV4b3JpbnRcIlxubGV0IGxvZ25vdCB4ID0gbG9neG9yIHggKC0xKVxuZXh0ZXJuYWwgc2hpZnRfbGVmdCA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlbHNsaW50XCJcbmV4dGVybmFsIHNoaWZ0X3JpZ2h0IDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVhc3JpbnRcIlxuZXh0ZXJuYWwgc2hpZnRfcmlnaHRfbG9naWNhbCA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlbHNyaW50XCJcbmxldCBlcXVhbCA6IGludCAtPiBpbnQgLT4gYm9vbCA9ICggPSApXG5sZXQgY29tcGFyZSA6IGludCAtPiBpbnQgLT4gaW50ID0gU3RkbGliLmNvbXBhcmVcbmxldCBtaW4geCB5IDogdCA9IGlmIHggPD0geSB0aGVuIHggZWxzZSB5XG5sZXQgbWF4IHggeSA6IHQgPSBpZiB4ID49IHkgdGhlbiB4IGVsc2UgeVxuZXh0ZXJuYWwgdG9fZmxvYXQgOiBpbnQgLT4gZmxvYXQgPSBcIiVmbG9hdG9maW50XCJcbmV4dGVybmFsIG9mX2Zsb2F0IDogZmxvYXQgLT4gaW50ID0gXCIlaW50b2ZmbG9hdFwiXG5cbigqXG5leHRlcm5hbCBpbnRfb2Zfc3RyaW5nIDogc3RyaW5nIC0+IGludCA9IFwiY2FtbF9pbnRfb2Zfc3RyaW5nXCJcbmxldCBvZl9zdHJpbmcgcyA9IHRyeSBTb21lIChpbnRfb2Zfc3RyaW5nIHMpIHdpdGggRmFpbHVyZSBfIC0+IE5vbmVcbiopXG5cbmV4dGVybmFsIGZvcm1hdF9pbnQgOiBzdHJpbmcgLT4gaW50IC0+IHN0cmluZyA9IFwiY2FtbF9mb3JtYXRfaW50XCJcbmxldCB0b19zdHJpbmcgeCA9IGZvcm1hdF9pbnQgXCIlZFwiIHhcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogQnl0ZSBzZXF1ZW5jZSBvcGVyYXRpb25zICopXG5cbigqIFdBUk5JTkc6IFNvbWUgZnVuY3Rpb25zIGluIHRoaXMgZmlsZSBhcmUgZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgZm9yXG4gICBlZmZpY2llbmN5IHJlYXNvbnMuIFdoZW4geW91IG1vZGlmeSB0aGUgb25lIGluIHRoaXMgZmlsZSB5b3UgbmVlZCB0b1xuICAgbW9kaWZ5IGl0cyBkdXBsaWNhdGUgaW4gc3RyaW5nLm1sLlxuICAgVGhlc2UgZnVuY3Rpb25zIGhhdmUgYSBcImR1cGxpY2F0ZWRcIiBjb21tZW50IGFib3ZlIHRoZWlyIGRlZmluaXRpb24uXG4qKVxuXG5leHRlcm5hbCBsZW5ndGggOiBieXRlcyAtPiBpbnQgPSBcIiVieXRlc19sZW5ndGhcIlxuZXh0ZXJuYWwgc3RyaW5nX2xlbmd0aCA6IHN0cmluZyAtPiBpbnQgPSBcIiVzdHJpbmdfbGVuZ3RoXCJcbmV4dGVybmFsIGdldCA6IGJ5dGVzIC0+IGludCAtPiBjaGFyID0gXCIlYnl0ZXNfc2FmZV9nZXRcIlxuZXh0ZXJuYWwgc2V0IDogYnl0ZXMgLT4gaW50IC0+IGNoYXIgLT4gdW5pdCA9IFwiJWJ5dGVzX3NhZmVfc2V0XCJcbmV4dGVybmFsIGNyZWF0ZSA6IGludCAtPiBieXRlcyA9IFwiY2FtbF9jcmVhdGVfYnl0ZXNcIlxuZXh0ZXJuYWwgdW5zYWZlX2dldCA6IGJ5dGVzIC0+IGludCAtPiBjaGFyID0gXCIlYnl0ZXNfdW5zYWZlX2dldFwiXG5leHRlcm5hbCB1bnNhZmVfc2V0IDogYnl0ZXMgLT4gaW50IC0+IGNoYXIgLT4gdW5pdCA9IFwiJWJ5dGVzX3Vuc2FmZV9zZXRcIlxuZXh0ZXJuYWwgdW5zYWZlX2ZpbGwgOiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IGNoYXIgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfZmlsbF9ieXRlc1wiIFtAQG5vYWxsb2NdXG5leHRlcm5hbCB1bnNhZmVfdG9fc3RyaW5nIDogYnl0ZXMgLT4gc3RyaW5nID0gXCIlYnl0ZXNfdG9fc3RyaW5nXCJcbmV4dGVybmFsIHVuc2FmZV9vZl9zdHJpbmcgOiBzdHJpbmcgLT4gYnl0ZXMgPSBcIiVieXRlc19vZl9zdHJpbmdcIlxuXG5leHRlcm5hbCB1bnNhZmVfYmxpdCA6IGJ5dGVzIC0+IGludCAtPiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX2JsaXRfYnl0ZXNcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdW5zYWZlX2JsaXRfc3RyaW5nIDogc3RyaW5nIC0+IGludCAtPiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX2JsaXRfc3RyaW5nXCIgW0BAbm9hbGxvY11cblxubGV0IG1ha2UgbiBjID1cbiAgbGV0IHMgPSBjcmVhdGUgbiBpblxuICB1bnNhZmVfZmlsbCBzIDAgbiBjO1xuICBzXG5cbmxldCBpbml0IG4gZiA9XG4gIGxldCBzID0gY3JlYXRlIG4gaW5cbiAgZm9yIGkgPSAwIHRvIG4gLSAxIGRvXG4gICAgdW5zYWZlX3NldCBzIGkgKGYgaSlcbiAgZG9uZTtcbiAgc1xuXG5sZXQgZW1wdHkgPSBjcmVhdGUgMFxuXG5sZXQgY29weSBzID1cbiAgbGV0IGxlbiA9IGxlbmd0aCBzIGluXG4gIGxldCByID0gY3JlYXRlIGxlbiBpblxuICB1bnNhZmVfYmxpdCBzIDAgciAwIGxlbjtcbiAgclxuXG5sZXQgdG9fc3RyaW5nIGIgPSB1bnNhZmVfdG9fc3RyaW5nIChjb3B5IGIpXG5sZXQgb2Zfc3RyaW5nIHMgPSBjb3B5ICh1bnNhZmVfb2Zfc3RyaW5nIHMpXG5cbmxldCBzdWIgcyBvZnMgbGVuID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IGxlbmd0aCBzIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJTdHJpbmcuc3ViIC8gQnl0ZXMuc3ViXCJcbiAgZWxzZSBiZWdpblxuICAgIGxldCByID0gY3JlYXRlIGxlbiBpblxuICAgIHVuc2FmZV9ibGl0IHMgb2ZzIHIgMCBsZW47XG4gICAgclxuICBlbmRcblxubGV0IHN1Yl9zdHJpbmcgYiBvZnMgbGVuID0gdW5zYWZlX3RvX3N0cmluZyAoc3ViIGIgb2ZzIGxlbilcblxuKCogYWRkaXRpb24gd2l0aCBhbiBvdmVyZmxvdyBjaGVjayAqKVxubGV0ICgrKykgYSBiID1cbiAgbGV0IGMgPSBhICsgYiBpblxuICBtYXRjaCBhIDwgMCwgYiA8IDAsIGMgPCAwIHdpdGhcbiAgfCB0cnVlICwgdHJ1ZSAsIGZhbHNlXG4gIHwgZmFsc2UsIGZhbHNlLCB0cnVlICAtPiBpbnZhbGlkX2FyZyBcIkJ5dGVzLmV4dGVuZFwiICgqIG92ZXJmbG93ICopXG4gIHwgXyAtPiBjXG5cbmxldCBleHRlbmQgcyBsZWZ0IHJpZ2h0ID1cbiAgbGV0IGxlbiA9IGxlbmd0aCBzICsrIGxlZnQgKysgcmlnaHQgaW5cbiAgbGV0IHIgPSBjcmVhdGUgbGVuIGluXG4gIGxldCAoc3Jjb2ZmLCBkc3RvZmYpID0gaWYgbGVmdCA8IDAgdGhlbiAtbGVmdCwgMCBlbHNlIDAsIGxlZnQgaW5cbiAgbGV0IGNweWxlbiA9IEludC5taW4gKGxlbmd0aCBzIC0gc3Jjb2ZmKSAobGVuIC0gZHN0b2ZmKSBpblxuICBpZiBjcHlsZW4gPiAwIHRoZW4gdW5zYWZlX2JsaXQgcyBzcmNvZmYgciBkc3RvZmYgY3B5bGVuO1xuICByXG5cbmxldCBmaWxsIHMgb2ZzIGxlbiBjID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IGxlbmd0aCBzIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJTdHJpbmcuZmlsbCAvIEJ5dGVzLmZpbGxcIlxuICBlbHNlIHVuc2FmZV9maWxsIHMgb2ZzIGxlbiBjXG5cbmxldCBibGl0IHMxIG9mczEgczIgb2ZzMiBsZW4gPVxuICBpZiBsZW4gPCAwIHx8IG9mczEgPCAwIHx8IG9mczEgPiBsZW5ndGggczEgLSBsZW5cbiAgICAgICAgICAgICB8fCBvZnMyIDwgMCB8fCBvZnMyID4gbGVuZ3RoIHMyIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJCeXRlcy5ibGl0XCJcbiAgZWxzZSB1bnNhZmVfYmxpdCBzMSBvZnMxIHMyIG9mczIgbGVuXG5cbmxldCBibGl0X3N0cmluZyBzMSBvZnMxIHMyIG9mczIgbGVuID1cbiAgaWYgbGVuIDwgMCB8fCBvZnMxIDwgMCB8fCBvZnMxID4gc3RyaW5nX2xlbmd0aCBzMSAtIGxlblxuICAgICAgICAgICAgIHx8IG9mczIgPCAwIHx8IG9mczIgPiBsZW5ndGggczIgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIlN0cmluZy5ibGl0IC8gQnl0ZXMuYmxpdF9zdHJpbmdcIlxuICBlbHNlIHVuc2FmZV9ibGl0X3N0cmluZyBzMSBvZnMxIHMyIG9mczIgbGVuXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgaXRlciBmIGEgPVxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvIGYodW5zYWZlX2dldCBhIGkpIGRvbmVcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCBpdGVyaSBmIGEgPVxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvIGYgaSAodW5zYWZlX2dldCBhIGkpIGRvbmVcblxubGV0IGVuc3VyZV9nZSAoeDppbnQpIHkgPSBpZiB4ID49IHkgdGhlbiB4IGVsc2UgaW52YWxpZF9hcmcgXCJCeXRlcy5jb25jYXRcIlxuXG5sZXQgcmVjIHN1bV9sZW5ndGhzIGFjYyBzZXBsZW4gPSBmdW5jdGlvblxuICB8IFtdIC0+IGFjY1xuICB8IGhkIDo6IFtdIC0+IGxlbmd0aCBoZCArIGFjY1xuICB8IGhkIDo6IHRsIC0+IHN1bV9sZW5ndGhzIChlbnN1cmVfZ2UgKGxlbmd0aCBoZCArIHNlcGxlbiArIGFjYykgYWNjKSBzZXBsZW4gdGxcblxubGV0IHJlYyB1bnNhZmVfYmxpdHMgZHN0IHBvcyBzZXAgc2VwbGVuID0gZnVuY3Rpb25cbiAgICBbXSAtPiBkc3RcbiAgfCBoZCA6OiBbXSAtPlxuICAgIHVuc2FmZV9ibGl0IGhkIDAgZHN0IHBvcyAobGVuZ3RoIGhkKTsgZHN0XG4gIHwgaGQgOjogdGwgLT5cbiAgICB1bnNhZmVfYmxpdCBoZCAwIGRzdCBwb3MgKGxlbmd0aCBoZCk7XG4gICAgdW5zYWZlX2JsaXQgc2VwIDAgZHN0IChwb3MgKyBsZW5ndGggaGQpIHNlcGxlbjtcbiAgICB1bnNhZmVfYmxpdHMgZHN0IChwb3MgKyBsZW5ndGggaGQgKyBzZXBsZW4pIHNlcCBzZXBsZW4gdGxcblxubGV0IGNvbmNhdCBzZXAgPSBmdW5jdGlvblxuICAgIFtdIC0+IGVtcHR5XG4gIHwgbCAtPiBsZXQgc2VwbGVuID0gbGVuZ3RoIHNlcCBpblxuICAgICAgICAgIHVuc2FmZV9ibGl0c1xuICAgICAgICAgICAgKGNyZWF0ZSAoc3VtX2xlbmd0aHMgMCBzZXBsZW4gbCkpXG4gICAgICAgICAgICAwIHNlcCBzZXBsZW4gbFxuXG5sZXQgY2F0IHMxIHMyID1cbiAgbGV0IGwxID0gbGVuZ3RoIHMxIGluXG4gIGxldCBsMiA9IGxlbmd0aCBzMiBpblxuICBsZXQgciA9IGNyZWF0ZSAobDEgKyBsMikgaW5cbiAgdW5zYWZlX2JsaXQgczEgMCByIDAgbDE7XG4gIHVuc2FmZV9ibGl0IHMyIDAgciBsMSBsMjtcbiAgclxuXG5cbmV4dGVybmFsIGNoYXJfY29kZTogY2hhciAtPiBpbnQgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCBjaGFyX2NocjogaW50IC0+IGNoYXIgPSBcIiVpZGVudGl0eVwiXG5cbmxldCBpc19zcGFjZSA9IGZ1bmN0aW9uXG4gIHwgJyAnIHwgJ1xcMDEyJyB8ICdcXG4nIHwgJ1xccicgfCAnXFx0JyAtPiB0cnVlXG4gIHwgXyAtPiBmYWxzZVxuXG5sZXQgdHJpbSBzID1cbiAgbGV0IGxlbiA9IGxlbmd0aCBzIGluXG4gIGxldCBpID0gcmVmIDAgaW5cbiAgd2hpbGUgIWkgPCBsZW4gJiYgaXNfc3BhY2UgKHVuc2FmZV9nZXQgcyAhaSkgZG9cbiAgICBpbmNyIGlcbiAgZG9uZTtcbiAgbGV0IGogPSByZWYgKGxlbiAtIDEpIGluXG4gIHdoaWxlICFqID49ICFpICYmIGlzX3NwYWNlICh1bnNhZmVfZ2V0IHMgIWopIGRvXG4gICAgZGVjciBqXG4gIGRvbmU7XG4gIGlmICFqID49ICFpIHRoZW5cbiAgICBzdWIgcyAhaSAoIWogLSAhaSArIDEpXG4gIGVsc2VcbiAgICBlbXB0eVxuXG5sZXQgZXNjYXBlZCBzID1cbiAgbGV0IG4gPSByZWYgMCBpblxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIHMgLSAxIGRvXG4gICAgbiA6PSAhbiArXG4gICAgICAobWF0Y2ggdW5zYWZlX2dldCBzIGkgd2l0aFxuICAgICAgIHwgJ1xcXCInIHwgJ1xcXFwnIHwgJ1xcbicgfCAnXFx0JyB8ICdcXHInIHwgJ1xcYicgLT4gMlxuICAgICAgIHwgJyAnIC4uICd+JyAtPiAxXG4gICAgICAgfCBfIC0+IDQpXG4gIGRvbmU7XG4gIGlmICFuID0gbGVuZ3RoIHMgdGhlbiBjb3B5IHMgZWxzZSBiZWdpblxuICAgIGxldCBzJyA9IGNyZWF0ZSAhbiBpblxuICAgIG4gOj0gMDtcbiAgICBmb3IgaSA9IDAgdG8gbGVuZ3RoIHMgLSAxIGRvXG4gICAgICBiZWdpbiBtYXRjaCB1bnNhZmVfZ2V0IHMgaSB3aXRoXG4gICAgICB8ICgnXFxcIicgfCAnXFxcXCcpIGFzIGMgLT5cbiAgICAgICAgICB1bnNhZmVfc2V0IHMnICFuICdcXFxcJzsgaW5jciBuOyB1bnNhZmVfc2V0IHMnICFuIGNcbiAgICAgIHwgJ1xcbicgLT5cbiAgICAgICAgICB1bnNhZmVfc2V0IHMnICFuICdcXFxcJzsgaW5jciBuOyB1bnNhZmVfc2V0IHMnICFuICduJ1xuICAgICAgfCAnXFx0JyAtPlxuICAgICAgICAgIHVuc2FmZV9zZXQgcycgIW4gJ1xcXFwnOyBpbmNyIG47IHVuc2FmZV9zZXQgcycgIW4gJ3QnXG4gICAgICB8ICdcXHInIC0+XG4gICAgICAgICAgdW5zYWZlX3NldCBzJyAhbiAnXFxcXCc7IGluY3IgbjsgdW5zYWZlX3NldCBzJyAhbiAncidcbiAgICAgIHwgJ1xcYicgLT5cbiAgICAgICAgICB1bnNhZmVfc2V0IHMnICFuICdcXFxcJzsgaW5jciBuOyB1bnNhZmVfc2V0IHMnICFuICdiJ1xuICAgICAgfCAoJyAnIC4uICd+JykgYXMgYyAtPiB1bnNhZmVfc2V0IHMnICFuIGNcbiAgICAgIHwgYyAtPlxuICAgICAgICAgIGxldCBhID0gY2hhcl9jb2RlIGMgaW5cbiAgICAgICAgICB1bnNhZmVfc2V0IHMnICFuICdcXFxcJztcbiAgICAgICAgICBpbmNyIG47XG4gICAgICAgICAgdW5zYWZlX3NldCBzJyAhbiAoY2hhcl9jaHIgKDQ4ICsgYSAvIDEwMCkpO1xuICAgICAgICAgIGluY3IgbjtcbiAgICAgICAgICB1bnNhZmVfc2V0IHMnICFuIChjaGFyX2NociAoNDggKyAoYSAvIDEwKSBtb2QgMTApKTtcbiAgICAgICAgICBpbmNyIG47XG4gICAgICAgICAgdW5zYWZlX3NldCBzJyAhbiAoY2hhcl9jaHIgKDQ4ICsgYSBtb2QgMTApKTtcbiAgICAgIGVuZDtcbiAgICAgIGluY3IgblxuICAgIGRvbmU7XG4gICAgcydcbiAgZW5kXG5cbmxldCBtYXAgZiBzID1cbiAgbGV0IGwgPSBsZW5ndGggcyBpblxuICBpZiBsID0gMCB0aGVuIHMgZWxzZSBiZWdpblxuICAgIGxldCByID0gY3JlYXRlIGwgaW5cbiAgICBmb3IgaSA9IDAgdG8gbCAtIDEgZG8gdW5zYWZlX3NldCByIGkgKGYgKHVuc2FmZV9nZXQgcyBpKSkgZG9uZTtcbiAgICByXG4gIGVuZFxuXG5sZXQgbWFwaSBmIHMgPVxuICBsZXQgbCA9IGxlbmd0aCBzIGluXG4gIGlmIGwgPSAwIHRoZW4gcyBlbHNlIGJlZ2luXG4gICAgbGV0IHIgPSBjcmVhdGUgbCBpblxuICAgIGZvciBpID0gMCB0byBsIC0gMSBkbyB1bnNhZmVfc2V0IHIgaSAoZiBpICh1bnNhZmVfZ2V0IHMgaSkpIGRvbmU7XG4gICAgclxuICBlbmRcblxubGV0IGZvbGRfbGVmdCBmIHggYSA9XG4gIGxldCByID0gcmVmIHggaW5cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCBhIC0gMSBkb1xuICAgIHIgOj0gZiAhciAodW5zYWZlX2dldCBhIGkpXG4gIGRvbmU7XG4gICFyXG5cbmxldCBmb2xkX3JpZ2h0IGYgYSB4ID1cbiAgbGV0IHIgPSByZWYgeCBpblxuICBmb3IgaSA9IGxlbmd0aCBhIC0gMSBkb3dudG8gMCBkb1xuICAgIHIgOj0gZiAodW5zYWZlX2dldCBhIGkpICFyXG4gIGRvbmU7XG4gICFyXG5cbmxldCBleGlzdHMgcCBzID1cbiAgbGV0IG4gPSBsZW5ndGggcyBpblxuICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgaWYgaSA9IG4gdGhlbiBmYWxzZVxuICAgIGVsc2UgaWYgcCAodW5zYWZlX2dldCBzIGkpIHRoZW4gdHJ1ZVxuICAgIGVsc2UgbG9vcCAoc3VjYyBpKSBpblxuICBsb29wIDBcblxubGV0IGZvcl9hbGwgcCBzID1cbiAgbGV0IG4gPSBsZW5ndGggcyBpblxuICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgaWYgaSA9IG4gdGhlbiB0cnVlXG4gICAgZWxzZSBpZiBwICh1bnNhZmVfZ2V0IHMgaSkgdGhlbiBsb29wIChzdWNjIGkpXG4gICAgZWxzZSBmYWxzZSBpblxuICBsb29wIDBcblxubGV0IHVwcGVyY2FzZV9hc2NpaSBzID0gbWFwIENoYXIudXBwZXJjYXNlX2FzY2lpIHNcbmxldCBsb3dlcmNhc2VfYXNjaWkgcyA9IG1hcCBDaGFyLmxvd2VyY2FzZV9hc2NpaSBzXG5cbmxldCBhcHBseTEgZiBzID1cbiAgaWYgbGVuZ3RoIHMgPSAwIHRoZW4gcyBlbHNlIGJlZ2luXG4gICAgbGV0IHIgPSBjb3B5IHMgaW5cbiAgICB1bnNhZmVfc2V0IHIgMCAoZih1bnNhZmVfZ2V0IHMgMCkpO1xuICAgIHJcbiAgZW5kXG5cbmxldCBjYXBpdGFsaXplX2FzY2lpIHMgPSBhcHBseTEgQ2hhci51cHBlcmNhc2VfYXNjaWkgc1xubGV0IHVuY2FwaXRhbGl6ZV9hc2NpaSBzID0gYXBwbHkxIENoYXIubG93ZXJjYXNlX2FzY2lpIHNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCBzdGFydHNfd2l0aCB+cHJlZml4IHMgPVxuICBsZXQgbGVuX3MgPSBsZW5ndGggc1xuICBhbmQgbGVuX3ByZSA9IGxlbmd0aCBwcmVmaXggaW5cbiAgbGV0IHJlYyBhdXggaSA9XG4gICAgaWYgaSA9IGxlbl9wcmUgdGhlbiB0cnVlXG4gICAgZWxzZSBpZiB1bnNhZmVfZ2V0IHMgaSA8PiB1bnNhZmVfZ2V0IHByZWZpeCBpIHRoZW4gZmFsc2VcbiAgICBlbHNlIGF1eCAoaSArIDEpXG4gIGluIGxlbl9zID49IGxlbl9wcmUgJiYgYXV4IDBcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCBlbmRzX3dpdGggfnN1ZmZpeCBzID1cbiAgbGV0IGxlbl9zID0gbGVuZ3RoIHNcbiAgYW5kIGxlbl9zdWYgPSBsZW5ndGggc3VmZml4IGluXG4gIGxldCBkaWZmID0gbGVuX3MgLSBsZW5fc3VmIGluXG4gIGxldCByZWMgYXV4IGkgPVxuICAgIGlmIGkgPSBsZW5fc3VmIHRoZW4gdHJ1ZVxuICAgIGVsc2UgaWYgdW5zYWZlX2dldCBzIChkaWZmICsgaSkgPD4gdW5zYWZlX2dldCBzdWZmaXggaSB0aGVuIGZhbHNlXG4gICAgZWxzZSBhdXggKGkgKyAxKVxuICBpbiBkaWZmID49IDAgJiYgYXV4IDBcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCByZWMgaW5kZXhfcmVjIHMgbGltIGkgYyA9XG4gIGlmIGkgPj0gbGltIHRoZW4gcmFpc2UgTm90X2ZvdW5kIGVsc2VcbiAgaWYgdW5zYWZlX2dldCBzIGkgPSBjIHRoZW4gaSBlbHNlIGluZGV4X3JlYyBzIGxpbSAoaSArIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCBpbmRleCBzIGMgPSBpbmRleF9yZWMgcyAobGVuZ3RoIHMpIDAgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IHJlYyBpbmRleF9yZWNfb3B0IHMgbGltIGkgYyA9XG4gIGlmIGkgPj0gbGltIHRoZW4gTm9uZSBlbHNlXG4gIGlmIHVuc2FmZV9nZXQgcyBpID0gYyB0aGVuIFNvbWUgaSBlbHNlIGluZGV4X3JlY19vcHQgcyBsaW0gKGkgKyAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgaW5kZXhfb3B0IHMgYyA9IGluZGV4X3JlY19vcHQgcyAobGVuZ3RoIHMpIDAgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IGluZGV4X2Zyb20gcyBpIGMgPVxuICBsZXQgbCA9IGxlbmd0aCBzIGluXG4gIGlmIGkgPCAwIHx8IGkgPiBsIHRoZW4gaW52YWxpZF9hcmcgXCJTdHJpbmcuaW5kZXhfZnJvbSAvIEJ5dGVzLmluZGV4X2Zyb21cIiBlbHNlXG4gIGluZGV4X3JlYyBzIGwgaSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgaW5kZXhfZnJvbV9vcHQgcyBpIGMgPVxuICBsZXQgbCA9IGxlbmd0aCBzIGluXG4gIGlmIGkgPCAwIHx8IGkgPiBsIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIlN0cmluZy5pbmRleF9mcm9tX29wdCAvIEJ5dGVzLmluZGV4X2Zyb21fb3B0XCJcbiAgZWxzZVxuICAgIGluZGV4X3JlY19vcHQgcyBsIGkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IHJlYyByaW5kZXhfcmVjIHMgaSBjID1cbiAgaWYgaSA8IDAgdGhlbiByYWlzZSBOb3RfZm91bmQgZWxzZVxuICBpZiB1bnNhZmVfZ2V0IHMgaSA9IGMgdGhlbiBpIGVsc2UgcmluZGV4X3JlYyBzIChpIC0gMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IHJpbmRleCBzIGMgPSByaW5kZXhfcmVjIHMgKGxlbmd0aCBzIC0gMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IHJpbmRleF9mcm9tIHMgaSBjID1cbiAgaWYgaSA8IC0xIHx8IGkgPj0gbGVuZ3RoIHMgdGhlblxuICAgIGludmFsaWRfYXJnIFwiU3RyaW5nLnJpbmRleF9mcm9tIC8gQnl0ZXMucmluZGV4X2Zyb21cIlxuICBlbHNlXG4gICAgcmluZGV4X3JlYyBzIGkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IHJlYyByaW5kZXhfcmVjX29wdCBzIGkgYyA9XG4gIGlmIGkgPCAwIHRoZW4gTm9uZSBlbHNlXG4gIGlmIHVuc2FmZV9nZXQgcyBpID0gYyB0aGVuIFNvbWUgaSBlbHNlIHJpbmRleF9yZWNfb3B0IHMgKGkgLSAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgcmluZGV4X29wdCBzIGMgPSByaW5kZXhfcmVjX29wdCBzIChsZW5ndGggcyAtIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCByaW5kZXhfZnJvbV9vcHQgcyBpIGMgPVxuICBpZiBpIDwgLTEgfHwgaSA+PSBsZW5ndGggcyB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJTdHJpbmcucmluZGV4X2Zyb21fb3B0IC8gQnl0ZXMucmluZGV4X2Zyb21fb3B0XCJcbiAgZWxzZVxuICAgIHJpbmRleF9yZWNfb3B0IHMgaSBjXG5cblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCBjb250YWluc19mcm9tIHMgaSBjID1cbiAgbGV0IGwgPSBsZW5ndGggcyBpblxuICBpZiBpIDwgMCB8fCBpID4gbCB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJTdHJpbmcuY29udGFpbnNfZnJvbSAvIEJ5dGVzLmNvbnRhaW5zX2Zyb21cIlxuICBlbHNlXG4gICAgdHJ5IGlnbm9yZSAoaW5kZXhfcmVjIHMgbCBpIGMpOyB0cnVlIHdpdGggTm90X2ZvdW5kIC0+IGZhbHNlXG5cblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCBjb250YWlucyBzIGMgPSBjb250YWluc19mcm9tIHMgMCBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgcmNvbnRhaW5zX2Zyb20gcyBpIGMgPVxuICBpZiBpIDwgMCB8fCBpID49IGxlbmd0aCBzIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIlN0cmluZy5yY29udGFpbnNfZnJvbSAvIEJ5dGVzLnJjb250YWluc19mcm9tXCJcbiAgZWxzZVxuICAgIHRyeSBpZ25vcmUgKHJpbmRleF9yZWMgcyBpIGMpOyB0cnVlIHdpdGggTm90X2ZvdW5kIC0+IGZhbHNlXG5cblxudHlwZSB0ID0gYnl0ZXNcblxubGV0IGNvbXBhcmUgKHg6IHQpICh5OiB0KSA9IFN0ZGxpYi5jb21wYXJlIHggeVxuZXh0ZXJuYWwgZXF1YWwgOiB0IC0+IHQgLT4gYm9vbCA9IFwiY2FtbF9ieXRlc19lcXVhbFwiIFtAQG5vYWxsb2NdXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgc3BsaXRfb25fY2hhciBzZXAgcyA9XG4gIGxldCByID0gcmVmIFtdIGluXG4gIGxldCBqID0gcmVmIChsZW5ndGggcykgaW5cbiAgZm9yIGkgPSBsZW5ndGggcyAtIDEgZG93bnRvIDAgZG9cbiAgICBpZiB1bnNhZmVfZ2V0IHMgaSA9IHNlcCB0aGVuIGJlZ2luXG4gICAgICByIDo9IHN1YiBzIChpICsgMSkgKCFqIC0gaSAtIDEpIDo6ICFyO1xuICAgICAgaiA6PSBpXG4gICAgZW5kXG4gIGRvbmU7XG4gIHN1YiBzIDAgIWogOjogIXJcblxuKCogRGVwcmVjYXRlZCBmdW5jdGlvbnMgaW1wbGVtZW50ZWQgdmlhIG90aGVyIGRlcHJlY2F0ZWQgZnVuY3Rpb25zICopXG5bQEBAb2NhbWwud2FybmluZyBcIi0zXCJdXG5sZXQgdXBwZXJjYXNlIHMgPSBtYXAgQ2hhci51cHBlcmNhc2Ugc1xubGV0IGxvd2VyY2FzZSBzID0gbWFwIENoYXIubG93ZXJjYXNlIHNcblxubGV0IGNhcGl0YWxpemUgcyA9IGFwcGx5MSBDaGFyLnVwcGVyY2FzZSBzXG5sZXQgdW5jYXBpdGFsaXplIHMgPSBhcHBseTEgQ2hhci5sb3dlcmNhc2Ugc1xuXG4oKiogezEgSXRlcmF0b3JzfSAqKVxuXG5sZXQgdG9fc2VxIHMgPVxuICBsZXQgcmVjIGF1eCBpICgpID1cbiAgICBpZiBpID0gbGVuZ3RoIHMgdGhlbiBTZXEuTmlsXG4gICAgZWxzZVxuICAgICAgbGV0IHggPSBnZXQgcyBpIGluXG4gICAgICBTZXEuQ29ucyAoeCwgYXV4IChpKzEpKVxuICBpblxuICBhdXggMFxuXG5sZXQgdG9fc2VxaSBzID1cbiAgbGV0IHJlYyBhdXggaSAoKSA9XG4gICAgaWYgaSA9IGxlbmd0aCBzIHRoZW4gU2VxLk5pbFxuICAgIGVsc2VcbiAgICAgIGxldCB4ID0gZ2V0IHMgaSBpblxuICAgICAgU2VxLkNvbnMgKChpLHgpLCBhdXggKGkrMSkpXG4gIGluXG4gIGF1eCAwXG5cbmxldCBvZl9zZXEgaSA9XG4gIGxldCBuID0gcmVmIDAgaW5cbiAgbGV0IGJ1ZiA9IHJlZiAobWFrZSAyNTYgJ1xcMDAwJykgaW5cbiAgbGV0IHJlc2l6ZSAoKSA9XG4gICAgKCogcmVzaXplICopXG4gICAgbGV0IG5ld19sZW4gPSBJbnQubWluICgyICogbGVuZ3RoICFidWYpIFN5cy5tYXhfc3RyaW5nX2xlbmd0aCBpblxuICAgIGlmIGxlbmd0aCAhYnVmID0gbmV3X2xlbiB0aGVuIGZhaWx3aXRoIFwiQnl0ZXMub2Zfc2VxOiBjYW5ub3QgZ3JvdyBieXRlc1wiO1xuICAgIGxldCBuZXdfYnVmID0gbWFrZSBuZXdfbGVuICdcXDAwMCcgaW5cbiAgICBibGl0ICFidWYgMCBuZXdfYnVmIDAgIW47XG4gICAgYnVmIDo9IG5ld19idWZcbiAgaW5cbiAgU2VxLml0ZXJcbiAgICAoZnVuIGMgLT5cbiAgICAgICBpZiAhbiA9IGxlbmd0aCAhYnVmIHRoZW4gcmVzaXplKCk7XG4gICAgICAgc2V0ICFidWYgIW4gYztcbiAgICAgICBpbmNyIG4pXG4gICAgaTtcbiAgc3ViICFidWYgMCAhblxuXG4oKiogezYgQmluYXJ5IGVuY29kaW5nL2RlY29kaW5nIG9mIGludGVnZXJzfSAqKVxuXG4oKiBUaGUgZ2V0XyBmdW5jdGlvbnMgYXJlIGFsbCBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxuXG5leHRlcm5hbCB1bnNhZmVfZ2V0X3VpbnQ4IDogYnl0ZXMgLT4gaW50IC0+IGludCA9IFwiJWJ5dGVzX3Vuc2FmZV9nZXRcIlxuZXh0ZXJuYWwgdW5zYWZlX2dldF91aW50MTZfbmUgOiBieXRlcyAtPiBpbnQgLT4gaW50ID0gXCIlY2FtbF9ieXRlc19nZXQxNnVcIlxuZXh0ZXJuYWwgZ2V0X3VpbnQ4IDogYnl0ZXMgLT4gaW50IC0+IGludCA9IFwiJWJ5dGVzX3NhZmVfZ2V0XCJcbmV4dGVybmFsIGdldF91aW50MTZfbmUgOiBieXRlcyAtPiBpbnQgLT4gaW50ID0gXCIlY2FtbF9ieXRlc19nZXQxNlwiXG5leHRlcm5hbCBnZXRfaW50MzJfbmUgOiBieXRlcyAtPiBpbnQgLT4gaW50MzIgPSBcIiVjYW1sX2J5dGVzX2dldDMyXCJcbmV4dGVybmFsIGdldF9pbnQ2NF9uZSA6IGJ5dGVzIC0+IGludCAtPiBpbnQ2NCA9IFwiJWNhbWxfYnl0ZXNfZ2V0NjRcIlxuXG5leHRlcm5hbCB1bnNhZmVfc2V0X3VpbnQ4IDogYnl0ZXMgLT4gaW50IC0+IGludCAtPiB1bml0ID0gXCIlYnl0ZXNfdW5zYWZlX3NldFwiXG5leHRlcm5hbCB1bnNhZmVfc2V0X3VpbnQxNl9uZSA6IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcIiVjYW1sX2J5dGVzX3NldDE2dVwiXG5leHRlcm5hbCBzZXRfaW50OCA6IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gdW5pdCA9IFwiJWJ5dGVzX3NhZmVfc2V0XCJcbmV4dGVybmFsIHNldF9pbnQxNl9uZSA6IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gdW5pdCA9IFwiJWNhbWxfYnl0ZXNfc2V0MTZcIlxuZXh0ZXJuYWwgc2V0X2ludDMyX25lIDogYnl0ZXMgLT4gaW50IC0+IGludDMyIC0+IHVuaXQgPSBcIiVjYW1sX2J5dGVzX3NldDMyXCJcbmV4dGVybmFsIHNldF9pbnQ2NF9uZSA6IGJ5dGVzIC0+IGludCAtPiBpbnQ2NCAtPiB1bml0ID0gXCIlY2FtbF9ieXRlc19zZXQ2NFwiXG5leHRlcm5hbCBzd2FwMTYgOiBpbnQgLT4gaW50ID0gXCIlYnN3YXAxNlwiXG5leHRlcm5hbCBzd2FwMzIgOiBpbnQzMiAtPiBpbnQzMiA9IFwiJWJzd2FwX2ludDMyXCJcbmV4dGVybmFsIHN3YXA2NCA6IGludDY0IC0+IGludDY0ID0gXCIlYnN3YXBfaW50NjRcIlxuXG5sZXQgdW5zYWZlX2dldF91aW50MTZfbGUgYiBpID1cbiAgaWYgU3lzLmJpZ19lbmRpYW5cbiAgdGhlbiBzd2FwMTYgKHVuc2FmZV9nZXRfdWludDE2X25lIGIgaSlcbiAgZWxzZSB1bnNhZmVfZ2V0X3VpbnQxNl9uZSBiIGlcblxubGV0IHVuc2FmZV9nZXRfdWludDE2X2JlIGIgaSA9XG4gIGlmIFN5cy5iaWdfZW5kaWFuXG4gIHRoZW4gdW5zYWZlX2dldF91aW50MTZfbmUgYiBpXG4gIGVsc2Ugc3dhcDE2ICh1bnNhZmVfZ2V0X3VpbnQxNl9uZSBiIGkpXG5cbmxldCBnZXRfaW50OCBiIGkgPVxuICAoKGdldF91aW50OCBiIGkpIGxzbCAoU3lzLmludF9zaXplIC0gOCkpIGFzciAoU3lzLmludF9zaXplIC0gOClcblxubGV0IGdldF91aW50MTZfbGUgYiBpID1cbiAgaWYgU3lzLmJpZ19lbmRpYW4gdGhlbiBzd2FwMTYgKGdldF91aW50MTZfbmUgYiBpKVxuICBlbHNlIGdldF91aW50MTZfbmUgYiBpXG5cbmxldCBnZXRfdWludDE2X2JlIGIgaSA9XG4gIGlmIG5vdCBTeXMuYmlnX2VuZGlhbiB0aGVuIHN3YXAxNiAoZ2V0X3VpbnQxNl9uZSBiIGkpXG4gIGVsc2UgZ2V0X3VpbnQxNl9uZSBiIGlcblxubGV0IGdldF9pbnQxNl9uZSBiIGkgPVxuICAoKGdldF91aW50MTZfbmUgYiBpKSBsc2wgKFN5cy5pbnRfc2l6ZSAtIDE2KSkgYXNyIChTeXMuaW50X3NpemUgLSAxNilcblxubGV0IGdldF9pbnQxNl9sZSBiIGkgPVxuICAoKGdldF91aW50MTZfbGUgYiBpKSBsc2wgKFN5cy5pbnRfc2l6ZSAtIDE2KSkgYXNyIChTeXMuaW50X3NpemUgLSAxNilcblxubGV0IGdldF9pbnQxNl9iZSBiIGkgPVxuICAoKGdldF91aW50MTZfYmUgYiBpKSBsc2wgKFN5cy5pbnRfc2l6ZSAtIDE2KSkgYXNyIChTeXMuaW50X3NpemUgLSAxNilcblxubGV0IGdldF9pbnQzMl9sZSBiIGkgPVxuICBpZiBTeXMuYmlnX2VuZGlhbiB0aGVuIHN3YXAzMiAoZ2V0X2ludDMyX25lIGIgaSlcbiAgZWxzZSBnZXRfaW50MzJfbmUgYiBpXG5cbmxldCBnZXRfaW50MzJfYmUgYiBpID1cbiAgaWYgbm90IFN5cy5iaWdfZW5kaWFuIHRoZW4gc3dhcDMyIChnZXRfaW50MzJfbmUgYiBpKVxuICBlbHNlIGdldF9pbnQzMl9uZSBiIGlcblxubGV0IGdldF9pbnQ2NF9sZSBiIGkgPVxuICBpZiBTeXMuYmlnX2VuZGlhbiB0aGVuIHN3YXA2NCAoZ2V0X2ludDY0X25lIGIgaSlcbiAgZWxzZSBnZXRfaW50NjRfbmUgYiBpXG5cbmxldCBnZXRfaW50NjRfYmUgYiBpID1cbiAgaWYgbm90IFN5cy5iaWdfZW5kaWFuIHRoZW4gc3dhcDY0IChnZXRfaW50NjRfbmUgYiBpKVxuICBlbHNlIGdldF9pbnQ2NF9uZSBiIGlcblxubGV0IHVuc2FmZV9zZXRfdWludDE2X2xlIGIgaSB4ID1cbiAgaWYgU3lzLmJpZ19lbmRpYW5cbiAgdGhlbiB1bnNhZmVfc2V0X3VpbnQxNl9uZSBiIGkgKHN3YXAxNiB4KVxuICBlbHNlIHVuc2FmZV9zZXRfdWludDE2X25lIGIgaSB4XG5cbmxldCB1bnNhZmVfc2V0X3VpbnQxNl9iZSBiIGkgeCA9XG4gIGlmIFN5cy5iaWdfZW5kaWFuXG4gIHRoZW4gdW5zYWZlX3NldF91aW50MTZfbmUgYiBpIHggZWxzZVxuICB1bnNhZmVfc2V0X3VpbnQxNl9uZSBiIGkgKHN3YXAxNiB4KVxuXG5sZXQgc2V0X2ludDE2X2xlIGIgaSB4ID1cbiAgaWYgU3lzLmJpZ19lbmRpYW4gdGhlbiBzZXRfaW50MTZfbmUgYiBpIChzd2FwMTYgeClcbiAgZWxzZSBzZXRfaW50MTZfbmUgYiBpIHhcblxubGV0IHNldF9pbnQxNl9iZSBiIGkgeCA9XG4gIGlmIG5vdCBTeXMuYmlnX2VuZGlhbiB0aGVuIHNldF9pbnQxNl9uZSBiIGkgKHN3YXAxNiB4KVxuICBlbHNlIHNldF9pbnQxNl9uZSBiIGkgeFxuXG5sZXQgc2V0X2ludDMyX2xlIGIgaSB4ID1cbiAgaWYgU3lzLmJpZ19lbmRpYW4gdGhlbiBzZXRfaW50MzJfbmUgYiBpIChzd2FwMzIgeClcbiAgZWxzZSBzZXRfaW50MzJfbmUgYiBpIHhcblxubGV0IHNldF9pbnQzMl9iZSBiIGkgeCA9XG4gIGlmIG5vdCBTeXMuYmlnX2VuZGlhbiB0aGVuIHNldF9pbnQzMl9uZSBiIGkgKHN3YXAzMiB4KVxuICBlbHNlIHNldF9pbnQzMl9uZSBiIGkgeFxuXG5sZXQgc2V0X2ludDY0X2xlIGIgaSB4ID1cbiAgaWYgU3lzLmJpZ19lbmRpYW4gdGhlbiBzZXRfaW50NjRfbmUgYiBpIChzd2FwNjQgeClcbiAgZWxzZSBzZXRfaW50NjRfbmUgYiBpIHhcblxubGV0IHNldF9pbnQ2NF9iZSBiIGkgeCA9XG4gIGlmIG5vdCBTeXMuYmlnX2VuZGlhbiB0aGVuIHNldF9pbnQ2NF9uZSBiIGkgKHN3YXA2NCB4KVxuICBlbHNlIHNldF9pbnQ2NF9uZSBiIGkgeFxuXG5sZXQgc2V0X3VpbnQ4ID0gc2V0X2ludDhcbmxldCBzZXRfdWludDE2X25lID0gc2V0X2ludDE2X25lXG5sZXQgc2V0X3VpbnQxNl9iZSA9IHNldF9pbnQxNl9iZVxubGV0IHNldF91aW50MTZfbGUgPSBzZXRfaW50MTZfbGVcblxuKCogVVRGIGNvZGVjcyBhbmQgdmFsaWRhdGlvbnMgKilcblxubGV0IGRlY19pbnZhbGlkID0gVWNoYXIudXRmX2RlY29kZV9pbnZhbGlkXG5sZXRbQGlubGluZV0gZGVjX3JldCBuIHUgPSBVY2hhci51dGZfZGVjb2RlIG4gKFVjaGFyLnVuc2FmZV9vZl9pbnQgdSlcblxuKCogSW4gY2FzZSBvZiBkZWNvZGluZyBlcnJvciwgaWYgd2UgZXJyb3Igb24gdGhlIGZpcnN0IGJ5dGUsIHdlXG4gICBjb25zdW1lIHRoZSBieXRlLCBvdGhlcndpc2Ugd2UgY29uc3VtZSB0aGUgW25dIGJ5dGVzIHByZWNlZWRpbmdcbiAgIHRoZSBlcnJvcmluZyBieXRlLlxuXG4gICBUaGlzIG1lYW5zIHRoYXQgaWYgYSBjbGllbnQgdXNlcyBkZWNvZGVzIHdpdGhvdXQgY2FyaW5nIGFib3V0XG4gICB2YWxpZGl0eSBpdCBuYXR1cmFsbHkgcmVwbGFjZSBib2d1cyBkYXRhIHdpdGggVWNoYXIucmVwIGFjY29yZGluZ1xuICAgdG8gdGhlIFdIQVRXRyBFbmNvZGluZyBzdGFuZGFyZC4gT3RoZXIgc2NoZW1lcyBhcmUgcG9zc2libGUgYnlcbiAgIGNvbnN1bHRpbmcgdGhlIG51bWJlciBvZiB1c2VkIGJ5dGVzIG9uIGludmFsaWQgZGVjb2Rlcy4gRm9yIG1vcmVcbiAgIGRldGFpbHMgc2VlIGh0dHBzOi8vaHNpdm9uZW4uZmkvYnJva2VuLXV0Zi04L1xuXG4gICBGb3IgdGhpcyByZWFzb24gaW4gW2dldF91dGZfOF91Y2hhcl0gd2UgZ3JhZHVhbGx5IGNoZWNrIHRoZSBuZXh0XG4gICBieXRlIGlzIGF2YWlsYWJsZSByYXRoZXIgdGhhbiBkb2luZyBpdCBpbW1lZGlhdGVseSBhZnRlciB0aGVcbiAgIGZpcnN0IGJ5dGUuIENvbnRyYXN0IHdpdGggW2lzX3ZhbGlkX3V0Zl84XS4gKilcblxuKCogVVRGLTggKilcblxubGV0W0BpbmxpbmVdIG5vdF9pbl94ODBfdG9feEJGIGIgPSBiIGxzciA2IDw+IDBiMTBcbmxldFtAaW5saW5lXSBub3RfaW5feEEwX3RvX3hCRiBiID0gYiBsc3IgNSA8PiAwYjEwMVxubGV0W0BpbmxpbmVdIG5vdF9pbl94ODBfdG9feDlGIGIgPSBiIGxzciA1IDw+IDBiMTAwXG5sZXRbQGlubGluZV0gbm90X2luX3g5MF90b194QkYgYiA9IGIgPCAweDkwIHx8IDB4QkYgPCBiXG5sZXRbQGlubGluZV0gbm90X2luX3g4MF90b194OEYgYiA9IGIgbHNyIDQgPD4gMHg4XG5cbmxldFtAaW5saW5lXSB1dGZfOF91Y2hhcl8yIGIwIGIxID1cbiAgKChiMCBsYW5kIDB4MUYpIGxzbCA2KSBsb3JcbiAgKChiMSBsYW5kIDB4M0YpKVxuXG5sZXRbQGlubGluZV0gdXRmXzhfdWNoYXJfMyBiMCBiMSBiMiA9XG4gICgoYjAgbGFuZCAweDBGKSBsc2wgMTIpIGxvclxuICAoKGIxIGxhbmQgMHgzRikgbHNsIDYpIGxvclxuICAoKGIyIGxhbmQgMHgzRikpXG5cbmxldFtAaW5saW5lXSB1dGZfOF91Y2hhcl80IGIwIGIxIGIyIGIzID1cbiAgKChiMCBsYW5kIDB4MDcpIGxzbCAxOCkgbG9yXG4gICgoYjEgbGFuZCAweDNGKSBsc2wgMTIpIGxvclxuICAoKGIyIGxhbmQgMHgzRikgbHNsIDYpIGxvclxuICAoKGIzIGxhbmQgMHgzRikpXG5cbmxldCBnZXRfdXRmXzhfdWNoYXIgYiBpID1cbiAgbGV0IGIwID0gZ2V0X3VpbnQ4IGIgaSBpbiAoKiByYWlzZXMgaWYgW2ldIGlzIG5vdCBhIHZhbGlkIGluZGV4LiAqKVxuICBsZXQgZ2V0ID0gdW5zYWZlX2dldF91aW50OCBpblxuICBsZXQgbWF4ID0gbGVuZ3RoIGIgLSAxIGluXG4gIG1hdGNoIENoYXIudW5zYWZlX2NociBiMCB3aXRoICgqIFNlZSBUaGUgVW5pY29kZSBTdGFuZGFyZCwgVGFibGUgMy43ICopXG4gIHwgJ1xceDAwJyAuLiAnXFx4N0YnIC0+IGRlY19yZXQgMSBiMFxuICB8ICdcXHhDMicgLi4gJ1xceERGJyAtPlxuICAgICAgbGV0IGkgPSBpICsgMSBpbiBpZiBpID4gbWF4IHRoZW4gZGVjX2ludmFsaWQgMSBlbHNlXG4gICAgICBsZXQgYjEgPSBnZXQgYiBpIGluIGlmIG5vdF9pbl94ODBfdG9feEJGIGIxIHRoZW4gZGVjX2ludmFsaWQgMSBlbHNlXG4gICAgICBkZWNfcmV0IDIgKHV0Zl84X3VjaGFyXzIgYjAgYjEpXG4gIHwgJ1xceEUwJyAtPlxuICAgICAgbGV0IGkgPSBpICsgMSBpbiBpZiBpID4gbWF4IHRoZW4gZGVjX2ludmFsaWQgMSBlbHNlXG4gICAgICBsZXQgYjEgPSBnZXQgYiBpIGluIGlmIG5vdF9pbl94QTBfdG9feEJGIGIxIHRoZW4gZGVjX2ludmFsaWQgMSBlbHNlXG4gICAgICBsZXQgaSA9IGkgKyAxIGluIGlmIGkgPiBtYXggdGhlbiBkZWNfaW52YWxpZCAyIGVsc2VcbiAgICAgIGxldCBiMiA9IGdldCBiIGkgaW4gaWYgbm90X2luX3g4MF90b194QkYgYjIgdGhlbiBkZWNfaW52YWxpZCAyIGVsc2VcbiAgICAgIGRlY19yZXQgMyAodXRmXzhfdWNoYXJfMyBiMCBiMSBiMilcbiAgfCAnXFx4RTEnIC4uICdcXHhFQycgfCAnXFx4RUUnIC4uICdcXHhFRicgLT5cbiAgICAgIGxldCBpID0gaSArIDEgaW4gaWYgaSA+IG1heCB0aGVuIGRlY19pbnZhbGlkIDEgZWxzZVxuICAgICAgbGV0IGIxID0gZ2V0IGIgaSBpbiBpZiBub3RfaW5feDgwX3RvX3hCRiBiMSB0aGVuIGRlY19pbnZhbGlkIDEgZWxzZVxuICAgICAgbGV0IGkgPSBpICsgMSBpbiBpZiBpID4gbWF4IHRoZW4gZGVjX2ludmFsaWQgMiBlbHNlXG4gICAgICBsZXQgYjIgPSBnZXQgYiBpIGluIGlmIG5vdF9pbl94ODBfdG9feEJGIGIyIHRoZW4gZGVjX2ludmFsaWQgMiBlbHNlXG4gICAgICBkZWNfcmV0IDMgKHV0Zl84X3VjaGFyXzMgYjAgYjEgYjIpXG4gIHwgJ1xceEVEJyAtPlxuICAgICAgbGV0IGkgPSBpICsgMSBpbiBpZiBpID4gbWF4IHRoZW4gZGVjX2ludmFsaWQgMSBlbHNlXG4gICAgICBsZXQgYjEgPSBnZXQgYiBpIGluIGlmIG5vdF9pbl94ODBfdG9feDlGIGIxIHRoZW4gZGVjX2ludmFsaWQgMSBlbHNlXG4gICAgICBsZXQgaSA9IGkgKyAxIGluIGlmIGkgPiBtYXggdGhlbiBkZWNfaW52YWxpZCAyIGVsc2VcbiAgICAgIGxldCBiMiA9IGdldCBiIGkgaW4gaWYgbm90X2luX3g4MF90b194QkYgYjIgdGhlbiBkZWNfaW52YWxpZCAyIGVsc2VcbiAgICAgIGRlY19yZXQgMyAodXRmXzhfdWNoYXJfMyBiMCBiMSBiMilcbiAgfCAnXFx4RjAnIC0+XG4gICAgICBsZXQgaSA9IGkgKyAxIGluIGlmIGkgPiBtYXggdGhlbiBkZWNfaW52YWxpZCAxIGVsc2VcbiAgICAgIGxldCBiMSA9IGdldCBiIGkgaW4gaWYgbm90X2luX3g5MF90b194QkYgYjEgdGhlbiBkZWNfaW52YWxpZCAxIGVsc2VcbiAgICAgIGxldCBpID0gaSArIDEgaW4gaWYgaSA+IG1heCB0aGVuIGRlY19pbnZhbGlkIDIgZWxzZVxuICAgICAgbGV0IGIyID0gZ2V0IGIgaSBpbiBpZiBub3RfaW5feDgwX3RvX3hCRiBiMiB0aGVuIGRlY19pbnZhbGlkIDIgZWxzZVxuICAgICAgbGV0IGkgPSBpICsgMSBpbiBpZiBpID4gbWF4IHRoZW4gZGVjX2ludmFsaWQgMyBlbHNlXG4gICAgICBsZXQgYjMgPSBnZXQgYiBpIGluIGlmIG5vdF9pbl94ODBfdG9feEJGIGIzIHRoZW4gZGVjX2ludmFsaWQgMyBlbHNlXG4gICAgICBkZWNfcmV0IDQgKHV0Zl84X3VjaGFyXzQgYjAgYjEgYjIgYjMpXG4gIHwgJ1xceEYxJyAuLiAnXFx4RjMnIC0+XG4gICAgICBsZXQgaSA9IGkgKyAxIGluIGlmIGkgPiBtYXggdGhlbiBkZWNfaW52YWxpZCAxIGVsc2VcbiAgICAgIGxldCBiMSA9IGdldCBiIGkgaW4gaWYgbm90X2luX3g4MF90b194QkYgYjEgdGhlbiBkZWNfaW52YWxpZCAxIGVsc2VcbiAgICAgIGxldCBpID0gaSArIDEgaW4gaWYgaSA+IG1heCB0aGVuIGRlY19pbnZhbGlkIDIgZWxzZVxuICAgICAgbGV0IGIyID0gZ2V0IGIgaSBpbiBpZiBub3RfaW5feDgwX3RvX3hCRiBiMiB0aGVuIGRlY19pbnZhbGlkIDIgZWxzZVxuICAgICAgbGV0IGkgPSBpICsgMSBpbiBpZiBpID4gbWF4IHRoZW4gZGVjX2ludmFsaWQgMyBlbHNlXG4gICAgICBsZXQgYjMgPSBnZXQgYiBpIGluIGlmIG5vdF9pbl94ODBfdG9feEJGIGIzIHRoZW4gZGVjX2ludmFsaWQgMyBlbHNlXG4gICAgICBkZWNfcmV0IDQgKHV0Zl84X3VjaGFyXzQgYjAgYjEgYjIgYjMpXG4gIHwgJ1xceEY0JyAtPlxuICAgICAgbGV0IGkgPSBpICsgMSBpbiBpZiBpID4gbWF4IHRoZW4gZGVjX2ludmFsaWQgMSBlbHNlXG4gICAgICBsZXQgYjEgPSBnZXQgYiBpIGluIGlmIG5vdF9pbl94ODBfdG9feDhGIGIxIHRoZW4gZGVjX2ludmFsaWQgMSBlbHNlXG4gICAgICBsZXQgaSA9IGkgKyAxIGluIGlmIGkgPiBtYXggdGhlbiBkZWNfaW52YWxpZCAyIGVsc2VcbiAgICAgIGxldCBiMiA9IGdldCBiIGkgaW4gaWYgbm90X2luX3g4MF90b194QkYgYjIgdGhlbiBkZWNfaW52YWxpZCAyIGVsc2VcbiAgICAgIGxldCBpID0gaSArIDEgaW4gaWYgaSA+IG1heCB0aGVuIGRlY19pbnZhbGlkIDMgZWxzZVxuICAgICAgbGV0IGIzID0gZ2V0IGIgaSBpbiBpZiBub3RfaW5feDgwX3RvX3hCRiBiMyB0aGVuIGRlY19pbnZhbGlkIDMgZWxzZVxuICAgICAgZGVjX3JldCA0ICh1dGZfOF91Y2hhcl80IGIwIGIxIGIyIGIzKVxuICB8IF8gLT4gZGVjX2ludmFsaWQgMVxuXG5sZXQgc2V0X3V0Zl84X3VjaGFyIGIgaSB1ID1cbiAgbGV0IHNldCA9IHVuc2FmZV9zZXRfdWludDggaW5cbiAgbGV0IG1heCA9IGxlbmd0aCBiIC0gMSBpblxuICBtYXRjaCBVY2hhci50b19pbnQgdSB3aXRoXG4gIHwgdSB3aGVuIHUgPCAwIC0+IGFzc2VydCBmYWxzZVxuICB8IHUgd2hlbiB1IDw9IDB4MDA3RiAtPlxuICAgICAgc2V0X3VpbnQ4IGIgaSB1O1xuICAgICAgMVxuICB8IHUgd2hlbiB1IDw9IDB4MDdGRiAtPlxuICAgICAgbGV0IGxhc3QgPSBpICsgMSBpblxuICAgICAgaWYgbGFzdCA+IG1heCB0aGVuIDAgZWxzZVxuICAgICAgKHNldF91aW50OCBiIGkgKDB4QzAgbG9yICh1IGxzciA2KSk7XG4gICAgICAgc2V0IGIgbGFzdCAoMHg4MCBsb3IgKHUgbGFuZCAweDNGKSk7XG4gICAgICAgMilcbiAgfCB1IHdoZW4gdSA8PSAweEZGRkYgLT5cbiAgICAgIGxldCBsYXN0ID0gaSArIDIgaW5cbiAgICAgIGlmIGxhc3QgPiBtYXggdGhlbiAwIGVsc2VcbiAgICAgIChzZXRfdWludDggYiBpICgweEUwIGxvciAodSBsc3IgMTIpKTtcbiAgICAgICBzZXQgYiAoaSArIDEpICgweDgwIGxvciAoKHUgbHNyIDYpIGxhbmQgMHgzRikpO1xuICAgICAgIHNldCBiIGxhc3QgKDB4ODAgbG9yICh1IGxhbmQgMHgzRikpO1xuICAgICAgIDMpXG4gIHwgdSB3aGVuIHUgPD0gMHgxMEZGRkYgLT5cbiAgICAgIGxldCBsYXN0ID0gaSArIDMgaW5cbiAgICAgIGlmIGxhc3QgPiBtYXggdGhlbiAwIGVsc2VcbiAgICAgIChzZXRfdWludDggYiBpICgweEYwIGxvciAodSBsc3IgMTgpKTtcbiAgICAgICBzZXQgYiAoaSArIDEpICgweDgwIGxvciAoKHUgbHNyIDEyKSBsYW5kIDB4M0YpKTtcbiAgICAgICBzZXQgYiAoaSArIDIpICgweDgwIGxvciAoKHUgbHNyIDYpIGxhbmQgMHgzRikpO1xuICAgICAgIHNldCBiIGxhc3QgKDB4ODAgbG9yICh1IGxhbmQgMHgzRikpO1xuICAgICAgIDQpXG4gIHwgXyAtPiBhc3NlcnQgZmFsc2VcblxubGV0IGlzX3ZhbGlkX3V0Zl84IGIgPVxuICBsZXQgcmVjIGxvb3AgbWF4IGIgaSA9XG4gICAgaWYgaSA+IG1heCB0aGVuIHRydWUgZWxzZVxuICAgIGxldCBnZXQgPSB1bnNhZmVfZ2V0X3VpbnQ4IGluXG4gICAgbWF0Y2ggQ2hhci51bnNhZmVfY2hyIChnZXQgYiBpKSB3aXRoXG4gICAgfCAnXFx4MDAnIC4uICdcXHg3RicgLT4gbG9vcCBtYXggYiAoaSArIDEpXG4gICAgfCAnXFx4QzInIC4uICdcXHhERicgLT5cbiAgICAgICAgbGV0IGxhc3QgPSBpICsgMSBpblxuICAgICAgICBpZiBsYXN0ID4gbWF4XG4gICAgICAgIHx8IG5vdF9pbl94ODBfdG9feEJGIChnZXQgYiBsYXN0KVxuICAgICAgICB0aGVuIGZhbHNlXG4gICAgICAgIGVsc2UgbG9vcCBtYXggYiAobGFzdCArIDEpXG4gICAgfCAnXFx4RTAnIC0+XG4gICAgICAgIGxldCBsYXN0ID0gaSArIDIgaW5cbiAgICAgICAgaWYgbGFzdCA+IG1heFxuICAgICAgICB8fCBub3RfaW5feEEwX3RvX3hCRiAoZ2V0IGIgKGkgKyAxKSlcbiAgICAgICAgfHwgbm90X2luX3g4MF90b194QkYgKGdldCBiIGxhc3QpXG4gICAgICAgIHRoZW4gZmFsc2VcbiAgICAgICAgZWxzZSBsb29wIG1heCBiIChsYXN0ICsgMSlcbiAgICB8ICdcXHhFMScgLi4gJ1xceEVDJyB8ICdcXHhFRScgLi4gJ1xceEVGJyAtPlxuICAgICAgICBsZXQgbGFzdCA9IGkgKyAyIGluXG4gICAgICAgIGlmIGxhc3QgPiBtYXhcbiAgICAgICAgfHwgbm90X2luX3g4MF90b194QkYgKGdldCBiIChpICsgMSkpXG4gICAgICAgIHx8IG5vdF9pbl94ODBfdG9feEJGIChnZXQgYiBsYXN0KVxuICAgICAgICB0aGVuIGZhbHNlXG4gICAgICAgIGVsc2UgbG9vcCBtYXggYiAobGFzdCArIDEpXG4gICAgfCAnXFx4RUQnIC0+XG4gICAgICAgIGxldCBsYXN0ID0gaSArIDIgaW5cbiAgICAgICAgaWYgbGFzdCA+IG1heFxuICAgICAgICB8fCBub3RfaW5feDgwX3RvX3g5RiAoZ2V0IGIgKGkgKyAxKSlcbiAgICAgICAgfHwgbm90X2luX3g4MF90b194QkYgKGdldCBiIGxhc3QpXG4gICAgICAgIHRoZW4gZmFsc2VcbiAgICAgICAgZWxzZSBsb29wIG1heCBiIChsYXN0ICsgMSlcbiAgICB8ICdcXHhGMCcgLT5cbiAgICAgICAgbGV0IGxhc3QgPSBpICsgMyBpblxuICAgICAgICBpZiBsYXN0ID4gbWF4XG4gICAgICAgIHx8IG5vdF9pbl94OTBfdG9feEJGIChnZXQgYiAoaSArIDEpKVxuICAgICAgICB8fCBub3RfaW5feDgwX3RvX3hCRiAoZ2V0IGIgKGkgKyAyKSlcbiAgICAgICAgfHwgbm90X2luX3g4MF90b194QkYgKGdldCBiIGxhc3QpXG4gICAgICAgIHRoZW4gZmFsc2VcbiAgICAgICAgZWxzZSBsb29wIG1heCBiIChsYXN0ICsgMSlcbiAgICB8ICdcXHhGMScgLi4gJ1xceEYzJyAtPlxuICAgICAgICBsZXQgbGFzdCA9IGkgKyAzIGluXG4gICAgICAgIGlmIGxhc3QgPiBtYXhcbiAgICAgICAgfHwgbm90X2luX3g4MF90b194QkYgKGdldCBiIChpICsgMSkpXG4gICAgICAgIHx8IG5vdF9pbl94ODBfdG9feEJGIChnZXQgYiAoaSArIDIpKVxuICAgICAgICB8fCBub3RfaW5feDgwX3RvX3hCRiAoZ2V0IGIgbGFzdClcbiAgICAgICAgdGhlbiBmYWxzZVxuICAgICAgICBlbHNlIGxvb3AgbWF4IGIgKGxhc3QgKyAxKVxuICAgIHwgJ1xceEY0JyAtPlxuICAgICAgICBsZXQgbGFzdCA9IGkgKyAzIGluXG4gICAgICAgIGlmIGxhc3QgPiBtYXhcbiAgICAgICAgfHwgbm90X2luX3g4MF90b194OEYgKGdldCBiIChpICsgMSkpXG4gICAgICAgIHx8IG5vdF9pbl94ODBfdG9feEJGIChnZXQgYiAoaSArIDIpKVxuICAgICAgICB8fCBub3RfaW5feDgwX3RvX3hCRiAoZ2V0IGIgbGFzdClcbiAgICAgICAgdGhlbiBmYWxzZVxuICAgICAgICBlbHNlIGxvb3AgbWF4IGIgKGxhc3QgKyAxKVxuICAgIHwgXyAtPiBmYWxzZVxuICBpblxuICBsb29wIChsZW5ndGggYiAtIDEpIGIgMFxuXG4oKiBVVEYtMTZCRSAqKVxuXG5sZXQgZ2V0X3V0Zl8xNmJlX3VjaGFyIGIgaSA9XG4gIGxldCBnZXQgPSB1bnNhZmVfZ2V0X3VpbnQxNl9iZSBpblxuICBsZXQgbWF4ID0gbGVuZ3RoIGIgLSAxIGluXG4gIGlmIGkgPCAwIHx8IGkgPiBtYXggdGhlbiBpbnZhbGlkX2FyZyBcImluZGV4IG91dCBvZiBib3VuZHNcIiBlbHNlXG4gIGlmIGkgPSBtYXggdGhlbiBkZWNfaW52YWxpZCAxIGVsc2VcbiAgbWF0Y2ggZ2V0IGIgaSB3aXRoXG4gIHwgdSB3aGVuIHUgPCAweEQ4MDAgfHwgdSA+IDB4REZGRiAtPiBkZWNfcmV0IDIgdVxuICB8IHUgd2hlbiB1ID4gMHhEQkZGIC0+IGRlY19pbnZhbGlkIDJcbiAgfCBoaSAtPiAoKiBjb21iaW5lIFtoaV0gd2l0aCBhIGxvdyBzdXJyb2dhdGUgKilcbiAgICAgIGxldCBsYXN0ID0gaSArIDMgaW5cbiAgICAgIGlmIGxhc3QgPiBtYXggdGhlbiBkZWNfaW52YWxpZCAobWF4IC0gaSArIDEpIGVsc2VcbiAgICAgIG1hdGNoIGdldCBiIChpICsgMikgd2l0aFxuICAgICAgfCB1IHdoZW4gdSA8IDB4REMwMCB8fCB1ID4gMHhERkZGIC0+IGRlY19pbnZhbGlkIDIgKCogcmV0cnkgaGVyZSAqKVxuICAgICAgfCBsbyAtPlxuICAgICAgICAgIGxldCB1ID0gKCgoaGkgbGFuZCAweDNGRikgbHNsIDEwKSBsb3IgKGxvIGxhbmQgMHgzRkYpKSArIDB4MTAwMDAgaW5cbiAgICAgICAgICBkZWNfcmV0IDQgdVxuXG5sZXQgc2V0X3V0Zl8xNmJlX3VjaGFyIGIgaSB1ID1cbiAgbGV0IHNldCA9IHVuc2FmZV9zZXRfdWludDE2X2JlIGluXG4gIGxldCBtYXggPSBsZW5ndGggYiAtIDEgaW5cbiAgaWYgaSA8IDAgfHwgaSA+IG1heCB0aGVuIGludmFsaWRfYXJnIFwiaW5kZXggb3V0IG9mIGJvdW5kc1wiIGVsc2VcbiAgbWF0Y2ggVWNoYXIudG9faW50IHUgd2l0aFxuICB8IHUgd2hlbiB1IDwgMCAtPiBhc3NlcnQgZmFsc2VcbiAgfCB1IHdoZW4gdSA8PSAweEZGRkYgLT5cbiAgICAgIGxldCBsYXN0ID0gaSArIDEgaW5cbiAgICAgIGlmIGxhc3QgPiBtYXggdGhlbiAwIGVsc2UgKHNldCBiIGkgdTsgMilcbiAgfCB1IHdoZW4gdSA8PSAweDEwRkZGRiAtPlxuICAgICAgbGV0IGxhc3QgPSBpICsgMyBpblxuICAgICAgaWYgbGFzdCA+IG1heCB0aGVuIDAgZWxzZVxuICAgICAgbGV0IHUnID0gdSAtIDB4MTAwMDAgaW5cbiAgICAgIGxldCBoaSA9ICgweEQ4MDAgbG9yICh1JyBsc3IgMTApKSBpblxuICAgICAgbGV0IGxvID0gKDB4REMwMCBsb3IgKHUnIGxhbmQgMHgzRkYpKSBpblxuICAgICAgc2V0IGIgaSBoaTsgc2V0IGIgKGkgKyAyKSBsbzsgNFxuICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbmxldCBpc192YWxpZF91dGZfMTZiZSBiID1cbiAgbGV0IHJlYyBsb29wIG1heCBiIGkgPVxuICAgIGxldCBnZXQgPSB1bnNhZmVfZ2V0X3VpbnQxNl9iZSBpblxuICAgIGlmIGkgPiBtYXggdGhlbiB0cnVlIGVsc2VcbiAgICBpZiBpID0gbWF4IHRoZW4gZmFsc2UgZWxzZVxuICAgIG1hdGNoIGdldCBiIGkgd2l0aFxuICAgIHwgdSB3aGVuIHUgPCAweEQ4MDAgfHwgdSA+IDB4REZGRiAtPiBsb29wIG1heCBiIChpICsgMilcbiAgICB8IHUgd2hlbiB1ID4gMHhEQkZGIC0+IGZhbHNlXG4gICAgfCBfaGkgLT5cbiAgICAgICAgbGV0IGxhc3QgPSBpICsgMyBpblxuICAgICAgICBpZiBsYXN0ID4gbWF4IHRoZW4gZmFsc2UgZWxzZVxuICAgICAgICBtYXRjaCBnZXQgYiAoaSArIDIpIHdpdGhcbiAgICAgICAgfCB1IHdoZW4gdSA8IDB4REMwMCB8fCB1ID4gMHhERkZGIC0+IGZhbHNlXG4gICAgICAgIHwgX2xvIC0+IGxvb3AgbWF4IGIgKGkgKyA0KVxuICBpblxuICBsb29wIChsZW5ndGggYiAtIDEpIGIgMFxuXG4oKiBVVEYtMTZMRSAqKVxuXG5sZXQgZ2V0X3V0Zl8xNmxlX3VjaGFyIGIgaSA9XG4gIGxldCBnZXQgPSB1bnNhZmVfZ2V0X3VpbnQxNl9sZSBpblxuICBsZXQgbWF4ID0gbGVuZ3RoIGIgLSAxIGluXG4gIGlmIGkgPCAwIHx8IGkgPiBtYXggdGhlbiBpbnZhbGlkX2FyZyBcImluZGV4IG91dCBvZiBib3VuZHNcIiBlbHNlXG4gIGlmIGkgPSBtYXggdGhlbiBkZWNfaW52YWxpZCAxIGVsc2VcbiAgbWF0Y2ggZ2V0IGIgaSB3aXRoXG4gIHwgdSB3aGVuIHUgPCAweEQ4MDAgfHwgdSA+IDB4REZGRiAtPiBkZWNfcmV0IDIgdVxuICB8IHUgd2hlbiB1ID4gMHhEQkZGIC0+IGRlY19pbnZhbGlkIDJcbiAgfCBoaSAtPiAoKiBjb21iaW5lIFtoaV0gd2l0aCBhIGxvdyBzdXJyb2dhdGUgKilcbiAgICAgIGxldCBsYXN0ID0gaSArIDMgaW5cbiAgICAgIGlmIGxhc3QgPiBtYXggdGhlbiBkZWNfaW52YWxpZCAobWF4IC0gaSArIDEpIGVsc2VcbiAgICAgIG1hdGNoIGdldCBiIChpICsgMikgd2l0aFxuICAgICAgfCB1IHdoZW4gdSA8IDB4REMwMCB8fCB1ID4gMHhERkZGIC0+IGRlY19pbnZhbGlkIDIgKCogcmV0cnkgaGVyZSAqKVxuICAgICAgfCBsbyAtPlxuICAgICAgICAgIGxldCB1ID0gKCgoaGkgbGFuZCAweDNGRikgbHNsIDEwKSBsb3IgKGxvIGxhbmQgMHgzRkYpKSArIDB4MTAwMDAgaW5cbiAgICAgICAgICBkZWNfcmV0IDQgdVxuXG5sZXQgc2V0X3V0Zl8xNmxlX3VjaGFyIGIgaSB1ID1cbiAgbGV0IHNldCA9IHVuc2FmZV9zZXRfdWludDE2X2xlIGluXG4gIGxldCBtYXggPSBsZW5ndGggYiAtIDEgaW5cbiAgaWYgaSA8IDAgfHwgaSA+IG1heCB0aGVuIGludmFsaWRfYXJnIFwiaW5kZXggb3V0IG9mIGJvdW5kc1wiIGVsc2VcbiAgbWF0Y2ggVWNoYXIudG9faW50IHUgd2l0aFxuICB8IHUgd2hlbiB1IDwgMCAtPiBhc3NlcnQgZmFsc2VcbiAgfCB1IHdoZW4gdSA8PSAweEZGRkYgLT5cbiAgICAgIGxldCBsYXN0ID0gaSArIDEgaW5cbiAgICAgIGlmIGxhc3QgPiBtYXggdGhlbiAwIGVsc2UgKHNldCBiIGkgdTsgMilcbiAgfCB1IHdoZW4gdSA8PSAweDEwRkZGRiAtPlxuICAgICAgbGV0IGxhc3QgPSBpICsgMyBpblxuICAgICAgaWYgbGFzdCA+IG1heCB0aGVuIDAgZWxzZVxuICAgICAgbGV0IHUnID0gdSAtIDB4MTAwMDAgaW5cbiAgICAgIGxldCBoaSA9ICgweEQ4MDAgbG9yICh1JyBsc3IgMTApKSBpblxuICAgICAgbGV0IGxvID0gKDB4REMwMCBsb3IgKHUnIGxhbmQgMHgzRkYpKSBpblxuICAgICAgc2V0IGIgaSBoaTsgc2V0IGIgKGkgKyAyKSBsbzsgNFxuICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbmxldCBpc192YWxpZF91dGZfMTZsZSBiID1cbiAgbGV0IHJlYyBsb29wIG1heCBiIGkgPVxuICAgIGxldCBnZXQgPSB1bnNhZmVfZ2V0X3VpbnQxNl9sZSBpblxuICAgIGlmIGkgPiBtYXggdGhlbiB0cnVlIGVsc2VcbiAgICBpZiBpID0gbWF4IHRoZW4gZmFsc2UgZWxzZVxuICAgIG1hdGNoIGdldCBiIGkgd2l0aFxuICAgIHwgdSB3aGVuIHUgPCAweEQ4MDAgfHwgdSA+IDB4REZGRiAtPiBsb29wIG1heCBiIChpICsgMilcbiAgICB8IHUgd2hlbiB1ID4gMHhEQkZGIC0+IGZhbHNlXG4gICAgfCBfaGkgLT5cbiAgICAgICAgbGV0IGxhc3QgPSBpICsgMyBpblxuICAgICAgICBpZiBsYXN0ID4gbWF4IHRoZW4gZmFsc2UgZWxzZVxuICAgICAgICBtYXRjaCBnZXQgYiAoaSArIDIpIHdpdGhcbiAgICAgICAgfCB1IHdoZW4gdSA8IDB4REMwMCB8fCB1ID4gMHhERkZGIC0+IGZhbHNlXG4gICAgICAgIHwgX2xvIC0+IGxvb3AgbWF4IGIgKGkgKyA0KVxuICBpblxuICBsb29wIChsZW5ndGggYiAtIDEpIGIgMFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgIERhbWllbiBEb2xpZ2V6LCBwcm9qZXQgR2FsbGl1bSwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxNCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBTdHJpbmcgb3BlcmF0aW9ucywgYmFzZWQgb24gYnl0ZSBzZXF1ZW5jZSBvcGVyYXRpb25zICopXG5cbigqIFdBUk5JTkc6IFNvbWUgZnVuY3Rpb25zIGluIHRoaXMgZmlsZSBhcmUgZHVwbGljYXRlZCBpbiBieXRlcy5tbCBmb3JcbiAgIGVmZmljaWVuY3kgcmVhc29ucy4gV2hlbiB5b3UgbW9kaWZ5IHRoZSBvbmUgaW4gdGhpcyBmaWxlIHlvdSBuZWVkIHRvXG4gICBtb2RpZnkgaXRzIGR1cGxpY2F0ZSBpbiBieXRlcy5tbC5cbiAgIFRoZXNlIGZ1bmN0aW9ucyBoYXZlIGEgXCJkdXBsaWNhdGVkXCIgY29tbWVudCBhYm92ZSB0aGVpciBkZWZpbml0aW9uLlxuKilcblxuZXh0ZXJuYWwgbGVuZ3RoIDogc3RyaW5nIC0+IGludCA9IFwiJXN0cmluZ19sZW5ndGhcIlxuZXh0ZXJuYWwgZ2V0IDogc3RyaW5nIC0+IGludCAtPiBjaGFyID0gXCIlc3RyaW5nX3NhZmVfZ2V0XCJcbmV4dGVybmFsIHNldCA6IGJ5dGVzIC0+IGludCAtPiBjaGFyIC0+IHVuaXQgPSBcIiVzdHJpbmdfc2FmZV9zZXRcIlxuZXh0ZXJuYWwgY3JlYXRlIDogaW50IC0+IGJ5dGVzID0gXCJjYW1sX2NyZWF0ZV9zdHJpbmdcIlxuZXh0ZXJuYWwgdW5zYWZlX2dldCA6IHN0cmluZyAtPiBpbnQgLT4gY2hhciA9IFwiJXN0cmluZ191bnNhZmVfZ2V0XCJcbmV4dGVybmFsIHVuc2FmZV9zZXQgOiBieXRlcyAtPiBpbnQgLT4gY2hhciAtPiB1bml0ID0gXCIlc3RyaW5nX3Vuc2FmZV9zZXRcIlxuZXh0ZXJuYWwgdW5zYWZlX2JsaXQgOiBzdHJpbmcgLT4gaW50IC0+ICBieXRlcyAtPiBpbnQgLT4gaW50IC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX2JsaXRfc3RyaW5nXCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIHVuc2FmZV9maWxsIDogYnl0ZXMgLT4gaW50IC0+IGludCAtPiBjaGFyIC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX2ZpbGxfc3RyaW5nXCIgW0BAbm9hbGxvY11cblxubW9kdWxlIEIgPSBCeXRlc1xuXG5sZXQgYnRzID0gQi51bnNhZmVfdG9fc3RyaW5nXG5sZXQgYm9zID0gQi51bnNhZmVfb2Zfc3RyaW5nXG5cbmxldCBtYWtlIG4gYyA9XG4gIEIubWFrZSBuIGMgfD4gYnRzXG5sZXQgaW5pdCBuIGYgPVxuICBCLmluaXQgbiBmIHw+IGJ0c1xubGV0IGVtcHR5ID0gXCJcIlxubGV0IGNvcHkgcyA9XG4gIEIuY29weSAoYm9zIHMpIHw+IGJ0c1xubGV0IG9mX2J5dGVzID0gQi50b19zdHJpbmdcbmxldCB0b19ieXRlcyA9IEIub2Zfc3RyaW5nXG5sZXQgc3ViIHMgb2ZzIGxlbiA9XG4gIEIuc3ViIChib3Mgcykgb2ZzIGxlbiB8PiBidHNcbmxldCBmaWxsID1cbiAgQi5maWxsXG5sZXQgYmxpdCA9XG4gIEIuYmxpdF9zdHJpbmdcblxubGV0IGVuc3VyZV9nZSAoeDppbnQpIHkgPSBpZiB4ID49IHkgdGhlbiB4IGVsc2UgaW52YWxpZF9hcmcgXCJTdHJpbmcuY29uY2F0XCJcblxubGV0IHJlYyBzdW1fbGVuZ3RocyBhY2Mgc2VwbGVuID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBhY2NcbiAgfCBoZCA6OiBbXSAtPiBsZW5ndGggaGQgKyBhY2NcbiAgfCBoZCA6OiB0bCAtPiBzdW1fbGVuZ3RocyAoZW5zdXJlX2dlIChsZW5ndGggaGQgKyBzZXBsZW4gKyBhY2MpIGFjYykgc2VwbGVuIHRsXG5cbmxldCByZWMgdW5zYWZlX2JsaXRzIGRzdCBwb3Mgc2VwIHNlcGxlbiA9IGZ1bmN0aW9uXG4gICAgW10gLT4gZHN0XG4gIHwgaGQgOjogW10gLT5cbiAgICB1bnNhZmVfYmxpdCBoZCAwIGRzdCBwb3MgKGxlbmd0aCBoZCk7IGRzdFxuICB8IGhkIDo6IHRsIC0+XG4gICAgdW5zYWZlX2JsaXQgaGQgMCBkc3QgcG9zIChsZW5ndGggaGQpO1xuICAgIHVuc2FmZV9ibGl0IHNlcCAwIGRzdCAocG9zICsgbGVuZ3RoIGhkKSBzZXBsZW47XG4gICAgdW5zYWZlX2JsaXRzIGRzdCAocG9zICsgbGVuZ3RoIGhkICsgc2VwbGVuKSBzZXAgc2VwbGVuIHRsXG5cbmxldCBjb25jYXQgc2VwID0gZnVuY3Rpb25cbiAgICBbXSAtPiBcIlwiXG4gIHwgbCAtPiBsZXQgc2VwbGVuID0gbGVuZ3RoIHNlcCBpbiBidHMgQEBcbiAgICAgICAgICB1bnNhZmVfYmxpdHNcbiAgICAgICAgICAgIChCLmNyZWF0ZSAoc3VtX2xlbmd0aHMgMCBzZXBsZW4gbCkpXG4gICAgICAgICAgICAwIHNlcCBzZXBsZW4gbFxuXG5sZXQgY2F0ID0gKCBeIClcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IGl0ZXIgZiBzID1cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCBzIC0gMSBkbyBmICh1bnNhZmVfZ2V0IHMgaSkgZG9uZVxuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgaXRlcmkgZiBzID1cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCBzIC0gMSBkbyBmIGkgKHVuc2FmZV9nZXQgcyBpKSBkb25lXG5cbmxldCBtYXAgZiBzID1cbiAgQi5tYXAgZiAoYm9zIHMpIHw+IGJ0c1xubGV0IG1hcGkgZiBzID1cbiAgQi5tYXBpIGYgKGJvcyBzKSB8PiBidHNcbmxldCBmb2xkX3JpZ2h0IGYgeCBhID1cbiAgQi5mb2xkX3JpZ2h0IGYgKGJvcyB4KSBhXG5sZXQgZm9sZF9sZWZ0IGYgYSB4ID1cbiAgQi5mb2xkX2xlZnQgZiBhIChib3MgeClcbmxldCBleGlzdHMgZiBzID1cbiAgQi5leGlzdHMgZiAoYm9zIHMpXG5sZXQgZm9yX2FsbCBmIHMgPVxuICBCLmZvcl9hbGwgZiAoYm9zIHMpXG5cbigqIEJld2FyZTogd2UgY2Fubm90IHVzZSBCLnRyaW0gb3IgQi5lc2NhcGUgYmVjYXVzZSB0aGV5IGFsd2F5cyBtYWtlIGFcbiAgIGNvcHksIGJ1dCBTdHJpbmcubWxpIHNwZWxscyBvdXQgc29tZSBjYXNlcyB3aGVyZSB3ZSBhcmUgbm90IGFsbG93ZWRcbiAgIHRvIG1ha2UgYSBjb3B5LiAqKVxuXG5sZXQgaXNfc3BhY2UgPSBmdW5jdGlvblxuICB8ICcgJyB8ICdcXDAxMicgfCAnXFxuJyB8ICdcXHInIHwgJ1xcdCcgLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2VcblxubGV0IHRyaW0gcyA9XG4gIGlmIHMgPSBcIlwiIHRoZW4gc1xuICBlbHNlIGlmIGlzX3NwYWNlICh1bnNhZmVfZ2V0IHMgMCkgfHwgaXNfc3BhY2UgKHVuc2FmZV9nZXQgcyAobGVuZ3RoIHMgLSAxKSlcbiAgICB0aGVuIGJ0cyAoQi50cmltIChib3MgcykpXG4gIGVsc2Ugc1xuXG5sZXQgZXNjYXBlZCBzID1cbiAgbGV0IHJlYyBlc2NhcGVfaWZfbmVlZGVkIHMgbiBpID1cbiAgICBpZiBpID49IG4gdGhlbiBzIGVsc2VcbiAgICAgIG1hdGNoIHVuc2FmZV9nZXQgcyBpIHdpdGhcbiAgICAgIHwgJ1xcXCInIHwgJ1xcXFwnIHwgJ1xcMDAwJy4uJ1xcMDMxJyB8ICdcXDEyNycuLiAnXFwyNTUnIC0+XG4gICAgICAgICAgYnRzIChCLmVzY2FwZWQgKGJvcyBzKSlcbiAgICAgIHwgXyAtPiBlc2NhcGVfaWZfbmVlZGVkIHMgbiAoaSsxKVxuICBpblxuICBlc2NhcGVfaWZfbmVlZGVkIHMgKGxlbmd0aCBzKSAwXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCByZWMgaW5kZXhfcmVjIHMgbGltIGkgYyA9XG4gIGlmIGkgPj0gbGltIHRoZW4gcmFpc2UgTm90X2ZvdW5kIGVsc2VcbiAgaWYgdW5zYWZlX2dldCBzIGkgPSBjIHRoZW4gaSBlbHNlIGluZGV4X3JlYyBzIGxpbSAoaSArIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IGluZGV4IHMgYyA9IGluZGV4X3JlYyBzIChsZW5ndGggcykgMCBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCByZWMgaW5kZXhfcmVjX29wdCBzIGxpbSBpIGMgPVxuICBpZiBpID49IGxpbSB0aGVuIE5vbmUgZWxzZVxuICBpZiB1bnNhZmVfZ2V0IHMgaSA9IGMgdGhlbiBTb21lIGkgZWxzZSBpbmRleF9yZWNfb3B0IHMgbGltIChpICsgMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgaW5kZXhfb3B0IHMgYyA9IGluZGV4X3JlY19vcHQgcyAobGVuZ3RoIHMpIDAgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgaW5kZXhfZnJvbSBzIGkgYyA9XG4gIGxldCBsID0gbGVuZ3RoIHMgaW5cbiAgaWYgaSA8IDAgfHwgaSA+IGwgdGhlbiBpbnZhbGlkX2FyZyBcIlN0cmluZy5pbmRleF9mcm9tIC8gQnl0ZXMuaW5kZXhfZnJvbVwiIGVsc2VcbiAgICBpbmRleF9yZWMgcyBsIGkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgaW5kZXhfZnJvbV9vcHQgcyBpIGMgPVxuICBsZXQgbCA9IGxlbmd0aCBzIGluXG4gIGlmIGkgPCAwIHx8IGkgPiBsIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIlN0cmluZy5pbmRleF9mcm9tX29wdCAvIEJ5dGVzLmluZGV4X2Zyb21fb3B0XCJcbiAgZWxzZVxuICAgIGluZGV4X3JlY19vcHQgcyBsIGkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgcmVjIHJpbmRleF9yZWMgcyBpIGMgPVxuICBpZiBpIDwgMCB0aGVuIHJhaXNlIE5vdF9mb3VuZCBlbHNlXG4gIGlmIHVuc2FmZV9nZXQgcyBpID0gYyB0aGVuIGkgZWxzZSByaW5kZXhfcmVjIHMgKGkgLSAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCByaW5kZXggcyBjID0gcmluZGV4X3JlYyBzIChsZW5ndGggcyAtIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IHJpbmRleF9mcm9tIHMgaSBjID1cbiAgaWYgaSA8IC0xIHx8IGkgPj0gbGVuZ3RoIHMgdGhlblxuICAgIGludmFsaWRfYXJnIFwiU3RyaW5nLnJpbmRleF9mcm9tIC8gQnl0ZXMucmluZGV4X2Zyb21cIlxuICBlbHNlXG4gICAgcmluZGV4X3JlYyBzIGkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgcmVjIHJpbmRleF9yZWNfb3B0IHMgaSBjID1cbiAgaWYgaSA8IDAgdGhlbiBOb25lIGVsc2VcbiAgaWYgdW5zYWZlX2dldCBzIGkgPSBjIHRoZW4gU29tZSBpIGVsc2UgcmluZGV4X3JlY19vcHQgcyAoaSAtIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IHJpbmRleF9vcHQgcyBjID0gcmluZGV4X3JlY19vcHQgcyAobGVuZ3RoIHMgLSAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCByaW5kZXhfZnJvbV9vcHQgcyBpIGMgPVxuICBpZiBpIDwgLTEgfHwgaSA+PSBsZW5ndGggcyB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJTdHJpbmcucmluZGV4X2Zyb21fb3B0IC8gQnl0ZXMucmluZGV4X2Zyb21fb3B0XCJcbiAgZWxzZVxuICAgIHJpbmRleF9yZWNfb3B0IHMgaSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCBjb250YWluc19mcm9tIHMgaSBjID1cbiAgbGV0IGwgPSBsZW5ndGggcyBpblxuICBpZiBpIDwgMCB8fCBpID4gbCB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJTdHJpbmcuY29udGFpbnNfZnJvbSAvIEJ5dGVzLmNvbnRhaW5zX2Zyb21cIlxuICBlbHNlXG4gICAgdHJ5IGlnbm9yZSAoaW5kZXhfcmVjIHMgbCBpIGMpOyB0cnVlIHdpdGggTm90X2ZvdW5kIC0+IGZhbHNlXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCBjb250YWlucyBzIGMgPSBjb250YWluc19mcm9tIHMgMCBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCByY29udGFpbnNfZnJvbSBzIGkgYyA9XG4gIGlmIGkgPCAwIHx8IGkgPj0gbGVuZ3RoIHMgdGhlblxuICAgIGludmFsaWRfYXJnIFwiU3RyaW5nLnJjb250YWluc19mcm9tIC8gQnl0ZXMucmNvbnRhaW5zX2Zyb21cIlxuICBlbHNlXG4gICAgdHJ5IGlnbm9yZSAocmluZGV4X3JlYyBzIGkgYyk7IHRydWUgd2l0aCBOb3RfZm91bmQgLT4gZmFsc2VcblxubGV0IHVwcGVyY2FzZV9hc2NpaSBzID1cbiAgQi51cHBlcmNhc2VfYXNjaWkgKGJvcyBzKSB8PiBidHNcbmxldCBsb3dlcmNhc2VfYXNjaWkgcyA9XG4gIEIubG93ZXJjYXNlX2FzY2lpIChib3MgcykgfD4gYnRzXG5sZXQgY2FwaXRhbGl6ZV9hc2NpaSBzID1cbiAgQi5jYXBpdGFsaXplX2FzY2lpIChib3MgcykgfD4gYnRzXG5sZXQgdW5jYXBpdGFsaXplX2FzY2lpIHMgPVxuICBCLnVuY2FwaXRhbGl6ZV9hc2NpaSAoYm9zIHMpIHw+IGJ0c1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgc3RhcnRzX3dpdGggfnByZWZpeCBzID1cbiAgbGV0IGxlbl9zID0gbGVuZ3RoIHNcbiAgYW5kIGxlbl9wcmUgPSBsZW5ndGggcHJlZml4IGluXG4gIGxldCByZWMgYXV4IGkgPVxuICAgIGlmIGkgPSBsZW5fcHJlIHRoZW4gdHJ1ZVxuICAgIGVsc2UgaWYgdW5zYWZlX2dldCBzIGkgPD4gdW5zYWZlX2dldCBwcmVmaXggaSB0aGVuIGZhbHNlXG4gICAgZWxzZSBhdXggKGkgKyAxKVxuICBpbiBsZW5fcyA+PSBsZW5fcHJlICYmIGF1eCAwXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCBlbmRzX3dpdGggfnN1ZmZpeCBzID1cbiAgbGV0IGxlbl9zID0gbGVuZ3RoIHNcbiAgYW5kIGxlbl9zdWYgPSBsZW5ndGggc3VmZml4IGluXG4gIGxldCBkaWZmID0gbGVuX3MgLSBsZW5fc3VmIGluXG4gIGxldCByZWMgYXV4IGkgPVxuICAgIGlmIGkgPSBsZW5fc3VmIHRoZW4gdHJ1ZVxuICAgIGVsc2UgaWYgdW5zYWZlX2dldCBzIChkaWZmICsgaSkgPD4gdW5zYWZlX2dldCBzdWZmaXggaSB0aGVuIGZhbHNlXG4gICAgZWxzZSBhdXggKGkgKyAxKVxuICBpbiBkaWZmID49IDAgJiYgYXV4IDBcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IHNwbGl0X29uX2NoYXIgc2VwIHMgPVxuICBsZXQgciA9IHJlZiBbXSBpblxuICBsZXQgaiA9IHJlZiAobGVuZ3RoIHMpIGluXG4gIGZvciBpID0gbGVuZ3RoIHMgLSAxIGRvd250byAwIGRvXG4gICAgaWYgdW5zYWZlX2dldCBzIGkgPSBzZXAgdGhlbiBiZWdpblxuICAgICAgciA6PSBzdWIgcyAoaSArIDEpICghaiAtIGkgLSAxKSA6OiAhcjtcbiAgICAgIGogOj0gaVxuICAgIGVuZFxuICBkb25lO1xuICBzdWIgcyAwICFqIDo6ICFyXG5cbigqIERlcHJlY2F0ZWQgZnVuY3Rpb25zIGltcGxlbWVudGVkIHZpYSBvdGhlciBkZXByZWNhdGVkIGZ1bmN0aW9ucyAqKVxuW0BAQG9jYW1sLndhcm5pbmcgXCItM1wiXVxubGV0IHVwcGVyY2FzZSBzID1cbiAgQi51cHBlcmNhc2UgKGJvcyBzKSB8PiBidHNcbmxldCBsb3dlcmNhc2UgcyA9XG4gIEIubG93ZXJjYXNlIChib3MgcykgfD4gYnRzXG5sZXQgY2FwaXRhbGl6ZSBzID1cbiAgQi5jYXBpdGFsaXplIChib3MgcykgfD4gYnRzXG5sZXQgdW5jYXBpdGFsaXplIHMgPVxuICBCLnVuY2FwaXRhbGl6ZSAoYm9zIHMpIHw+IGJ0c1xuXG50eXBlIHQgPSBzdHJpbmdcblxubGV0IGNvbXBhcmUgKHg6IHQpICh5OiB0KSA9IFN0ZGxpYi5jb21wYXJlIHggeVxuZXh0ZXJuYWwgZXF1YWwgOiBzdHJpbmcgLT4gc3RyaW5nIC0+IGJvb2wgPSBcImNhbWxfc3RyaW5nX2VxdWFsXCIgW0BAbm9hbGxvY11cblxuKCoqIHsxIEl0ZXJhdG9yc30gKilcblxubGV0IHRvX3NlcSBzID0gYm9zIHMgfD4gQi50b19zZXFcblxubGV0IHRvX3NlcWkgcyA9IGJvcyBzIHw+IEIudG9fc2VxaVxuXG5sZXQgb2Zfc2VxIGcgPSBCLm9mX3NlcSBnIHw+IGJ0c1xuXG4oKiBVVEYgZGVjb2RlcnMgYW5kIHZhbGlkYXRvcnMgKilcblxubGV0IGdldF91dGZfOF91Y2hhciBzIGkgPSBCLmdldF91dGZfOF91Y2hhciAoYm9zIHMpIGlcbmxldCBpc192YWxpZF91dGZfOCBzID0gQi5pc192YWxpZF91dGZfOCAoYm9zIHMpXG5cbmxldCBnZXRfdXRmXzE2YmVfdWNoYXIgcyBpID0gQi5nZXRfdXRmXzE2YmVfdWNoYXIgKGJvcyBzKSBpXG5sZXQgaXNfdmFsaWRfdXRmXzE2YmUgcyA9IEIuaXNfdmFsaWRfdXRmXzE2YmUgKGJvcyBzKVxuXG5sZXQgZ2V0X3V0Zl8xNmxlX3VjaGFyIHMgaSA9IEIuZ2V0X3V0Zl8xNmxlX3VjaGFyIChib3MgcykgaVxubGV0IGlzX3ZhbGlkX3V0Zl8xNmxlIHMgPSBCLmlzX3ZhbGlkX3V0Zl8xNmxlIChib3MgcylcblxuKCoqIHs2IEJpbmFyeSBlbmNvZGluZy9kZWNvZGluZyBvZiBpbnRlZ2Vyc30gKilcblxuZXh0ZXJuYWwgZ2V0X3VpbnQ4IDogc3RyaW5nIC0+IGludCAtPiBpbnQgPSBcIiVzdHJpbmdfc2FmZV9nZXRcIlxuZXh0ZXJuYWwgZ2V0X3VpbnQxNl9uZSA6IHN0cmluZyAtPiBpbnQgLT4gaW50ID0gXCIlY2FtbF9zdHJpbmdfZ2V0MTZcIlxuZXh0ZXJuYWwgZ2V0X2ludDMyX25lIDogc3RyaW5nIC0+IGludCAtPiBpbnQzMiA9IFwiJWNhbWxfc3RyaW5nX2dldDMyXCJcbmV4dGVybmFsIGdldF9pbnQ2NF9uZSA6IHN0cmluZyAtPiBpbnQgLT4gaW50NjQgPSBcIiVjYW1sX3N0cmluZ19nZXQ2NFwiXG5cbmxldCBnZXRfaW50OCBzIGkgPSBCLmdldF9pbnQ4IChib3MgcykgaVxubGV0IGdldF91aW50MTZfbGUgcyBpID0gQi5nZXRfdWludDE2X2xlIChib3MgcykgaVxubGV0IGdldF91aW50MTZfYmUgcyBpID0gQi5nZXRfdWludDE2X2JlIChib3MgcykgaVxubGV0IGdldF9pbnQxNl9uZSBzIGkgPSBCLmdldF9pbnQxNl9uZSAoYm9zIHMpIGlcbmxldCBnZXRfaW50MTZfbGUgcyBpID0gQi5nZXRfaW50MTZfbGUgKGJvcyBzKSBpXG5sZXQgZ2V0X2ludDE2X2JlIHMgaSA9IEIuZ2V0X2ludDE2X2JlIChib3MgcykgaVxubGV0IGdldF9pbnQzMl9sZSBzIGkgPSBCLmdldF9pbnQzMl9sZSAoYm9zIHMpIGlcbmxldCBnZXRfaW50MzJfYmUgcyBpID0gQi5nZXRfaW50MzJfYmUgKGJvcyBzKSBpXG5sZXQgZ2V0X2ludDY0X2xlIHMgaSA9IEIuZ2V0X2ludDY0X2xlIChib3MgcykgaVxubGV0IGdldF9pbnQ2NF9iZSBzIGkgPSBCLmdldF9pbnQ2NF9iZSAoYm9zIHMpIGlcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBPQ2FtbCBwcm9ncmFtbWVycyAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMTggSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxudHlwZSB0ID0gdW5pdCA9ICgpXG5cbmxldCBlcXVhbCAoKSAoKSA9IHRydWVcbmxldCBjb21wYXJlICgpICgpID0gMFxubGV0IHRvX3N0cmluZyAoKSA9IFwiKClcIlxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NyBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlIGV4dGVybl9mbGFncyA9XG4gICAgTm9fc2hhcmluZ1xuICB8IENsb3N1cmVzXG4gIHwgQ29tcGF0XzMyXG4oKiBub3RlOiB0aGlzIHR5cGUgZGVmaW5pdGlvbiBpcyB1c2VkIGluICdydW50aW1lL2RlYnVnZ2VyLmMnICopXG5cbmV4dGVybmFsIHRvX2NoYW5uZWw6IG91dF9jaGFubmVsIC0+ICdhIC0+IGV4dGVybl9mbGFncyBsaXN0IC0+IHVuaXRcbiAgICA9IFwiY2FtbF9vdXRwdXRfdmFsdWVcIlxuZXh0ZXJuYWwgdG9fYnl0ZXM6ICdhIC0+IGV4dGVybl9mbGFncyBsaXN0IC0+IGJ5dGVzXG4gICAgPSBcImNhbWxfb3V0cHV0X3ZhbHVlX3RvX2J5dGVzXCJcbmV4dGVybmFsIHRvX3N0cmluZzogJ2EgLT4gZXh0ZXJuX2ZsYWdzIGxpc3QgLT4gc3RyaW5nXG4gICAgPSBcImNhbWxfb3V0cHV0X3ZhbHVlX3RvX3N0cmluZ1wiXG5leHRlcm5hbCB0b19idWZmZXJfdW5zYWZlOlxuICAgICAgYnl0ZXMgLT4gaW50IC0+IGludCAtPiAnYSAtPiBleHRlcm5fZmxhZ3MgbGlzdCAtPiBpbnRcbiAgICA9IFwiY2FtbF9vdXRwdXRfdmFsdWVfdG9fYnVmZmVyXCJcblxubGV0IHRvX2J1ZmZlciBidWZmIG9mcyBsZW4gdiBmbGFncyA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBCeXRlcy5sZW5ndGggYnVmZiAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiTWFyc2hhbC50b19idWZmZXI6IHN1YnN0cmluZyBvdXQgb2YgYm91bmRzXCJcbiAgZWxzZSB0b19idWZmZXJfdW5zYWZlIGJ1ZmYgb2ZzIGxlbiB2IGZsYWdzXG5cbigqIFRoZSBmdW5jdGlvbnMgYmVsb3cgdXNlIGJ5dGUgc2VxdWVuY2VzIGFzIGlucHV0LCBuZXZlciB1c2luZyBhbnlcbiAgIG11dGF0aW9uLiBJdCBtYWtlcyBzZW5zZSB0byB1c2Ugbm9uLW11dGF0ZWQgW2J5dGVzXSByYXRoZXIgdGhhblxuICAgW3N0cmluZ10sIGJlY2F1c2Ugd2UgcmVhbGx5IHdvcmsgd2l0aCBzZXF1ZW5jZXMgb2YgYnl0ZXMsIG5vdFxuICAgYSB0ZXh0IHJlcHJlc2VudGF0aW9uLlxuKilcblxuZXh0ZXJuYWwgZnJvbV9jaGFubmVsOiBpbl9jaGFubmVsIC0+ICdhID0gXCJjYW1sX2lucHV0X3ZhbHVlXCJcbmV4dGVybmFsIGZyb21fYnl0ZXNfdW5zYWZlOiBieXRlcyAtPiBpbnQgLT4gJ2EgPSBcImNhbWxfaW5wdXRfdmFsdWVfZnJvbV9ieXRlc1wiXG5leHRlcm5hbCBkYXRhX3NpemVfdW5zYWZlOiBieXRlcyAtPiBpbnQgLT4gaW50ID0gXCJjYW1sX21hcnNoYWxfZGF0YV9zaXplXCJcblxubGV0IGhlYWRlcl9zaXplID0gMjBcbmxldCBkYXRhX3NpemUgYnVmZiBvZnMgPVxuICBpZiBvZnMgPCAwIHx8IG9mcyA+IEJ5dGVzLmxlbmd0aCBidWZmIC0gaGVhZGVyX3NpemVcbiAgdGhlbiBpbnZhbGlkX2FyZyBcIk1hcnNoYWwuZGF0YV9zaXplXCJcbiAgZWxzZSBkYXRhX3NpemVfdW5zYWZlIGJ1ZmYgb2ZzXG5sZXQgdG90YWxfc2l6ZSBidWZmIG9mcyA9IGhlYWRlcl9zaXplICsgZGF0YV9zaXplIGJ1ZmYgb2ZzXG5cbmxldCBmcm9tX2J5dGVzIGJ1ZmYgb2ZzID1cbiAgaWYgb2ZzIDwgMCB8fCBvZnMgPiBCeXRlcy5sZW5ndGggYnVmZiAtIGhlYWRlcl9zaXplXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJNYXJzaGFsLmZyb21fYnl0ZXNcIlxuICBlbHNlIGJlZ2luXG4gICAgbGV0IGxlbiA9IGRhdGFfc2l6ZV91bnNhZmUgYnVmZiBvZnMgaW5cbiAgICBpZiBvZnMgPiBCeXRlcy5sZW5ndGggYnVmZiAtIChoZWFkZXJfc2l6ZSArIGxlbilcbiAgICB0aGVuIGludmFsaWRfYXJnIFwiTWFyc2hhbC5mcm9tX2J5dGVzXCJcbiAgICBlbHNlIGZyb21fYnl0ZXNfdW5zYWZlIGJ1ZmYgb2ZzXG4gIGVuZFxuXG5sZXQgZnJvbV9zdHJpbmcgYnVmZiBvZnMgPVxuICAoKiBCeXRlcy51bnNhZmVfb2Zfc3RyaW5nIGlzIHNhZmUgaGVyZSwgYXMgdGhlIHByb2R1Y2VkIGJ5dGVcbiAgICAgc2VxdWVuY2UgaXMgbmV2ZXIgbXV0YXRlZCAqKVxuICBmcm9tX2J5dGVzIChCeXRlcy51bnNhZmVfb2Zfc3RyaW5nIGJ1ZmYpIG9mc1xuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBBbiBhbGlhcyBmb3IgdGhlIHR5cGUgb2YgYXJyYXlzLiAqKVxudHlwZSAnYSB0ID0gJ2EgYXJyYXlcblxuKCogQXJyYXkgb3BlcmF0aW9ucyAqKVxuXG5leHRlcm5hbCBsZW5ndGggOiAnYSBhcnJheSAtPiBpbnQgPSBcIiVhcnJheV9sZW5ndGhcIlxuZXh0ZXJuYWwgZ2V0OiAnYSBhcnJheSAtPiBpbnQgLT4gJ2EgPSBcIiVhcnJheV9zYWZlX2dldFwiXG5leHRlcm5hbCBzZXQ6ICdhIGFycmF5IC0+IGludCAtPiAnYSAtPiB1bml0ID0gXCIlYXJyYXlfc2FmZV9zZXRcIlxuZXh0ZXJuYWwgdW5zYWZlX2dldDogJ2EgYXJyYXkgLT4gaW50IC0+ICdhID0gXCIlYXJyYXlfdW5zYWZlX2dldFwiXG5leHRlcm5hbCB1bnNhZmVfc2V0OiAnYSBhcnJheSAtPiBpbnQgLT4gJ2EgLT4gdW5pdCA9IFwiJWFycmF5X3Vuc2FmZV9zZXRcIlxuZXh0ZXJuYWwgbWFrZTogaW50IC0+ICdhIC0+ICdhIGFycmF5ID0gXCJjYW1sX21ha2VfdmVjdFwiXG5leHRlcm5hbCBjcmVhdGU6IGludCAtPiAnYSAtPiAnYSBhcnJheSA9IFwiY2FtbF9tYWtlX3ZlY3RcIlxuZXh0ZXJuYWwgdW5zYWZlX3N1YiA6ICdhIGFycmF5IC0+IGludCAtPiBpbnQgLT4gJ2EgYXJyYXkgPSBcImNhbWxfYXJyYXlfc3ViXCJcbmV4dGVybmFsIGFwcGVuZF9wcmltIDogJ2EgYXJyYXkgLT4gJ2EgYXJyYXkgLT4gJ2EgYXJyYXkgPSBcImNhbWxfYXJyYXlfYXBwZW5kXCJcbmV4dGVybmFsIGNvbmNhdCA6ICdhIGFycmF5IGxpc3QgLT4gJ2EgYXJyYXkgPSBcImNhbWxfYXJyYXlfY29uY2F0XCJcbmV4dGVybmFsIHVuc2FmZV9ibGl0IDpcbiAgJ2EgYXJyYXkgLT4gaW50IC0+ICdhIGFycmF5IC0+IGludCAtPiBpbnQgLT4gdW5pdCA9IFwiY2FtbF9hcnJheV9ibGl0XCJcbmV4dGVybmFsIHVuc2FmZV9maWxsIDpcbiAgJ2EgYXJyYXkgLT4gaW50IC0+IGludCAtPiAnYSAtPiB1bml0ID0gXCJjYW1sX2FycmF5X2ZpbGxcIlxuZXh0ZXJuYWwgY3JlYXRlX2Zsb2F0OiBpbnQgLT4gZmxvYXQgYXJyYXkgPSBcImNhbWxfbWFrZV9mbG9hdF92ZWN0XCJcbmxldCBtYWtlX2Zsb2F0ID0gY3JlYXRlX2Zsb2F0XG5cbm1vZHVsZSBGbG9hdGFycmF5ID0gc3RydWN0XG4gIGV4dGVybmFsIGNyZWF0ZSA6IGludCAtPiBmbG9hdGFycmF5ID0gXCJjYW1sX2Zsb2F0YXJyYXlfY3JlYXRlXCJcbiAgZXh0ZXJuYWwgbGVuZ3RoIDogZmxvYXRhcnJheSAtPiBpbnQgPSBcIiVmbG9hdGFycmF5X2xlbmd0aFwiXG4gIGV4dGVybmFsIGdldCA6IGZsb2F0YXJyYXkgLT4gaW50IC0+IGZsb2F0ID0gXCIlZmxvYXRhcnJheV9zYWZlX2dldFwiXG4gIGV4dGVybmFsIHNldCA6IGZsb2F0YXJyYXkgLT4gaW50IC0+IGZsb2F0IC0+IHVuaXQgPSBcIiVmbG9hdGFycmF5X3NhZmVfc2V0XCJcbiAgZXh0ZXJuYWwgdW5zYWZlX2dldCA6IGZsb2F0YXJyYXkgLT4gaW50IC0+IGZsb2F0ID0gXCIlZmxvYXRhcnJheV91bnNhZmVfZ2V0XCJcbiAgZXh0ZXJuYWwgdW5zYWZlX3NldCA6IGZsb2F0YXJyYXkgLT4gaW50IC0+IGZsb2F0IC0+IHVuaXRcbiAgICAgID0gXCIlZmxvYXRhcnJheV91bnNhZmVfc2V0XCJcbmVuZFxuXG5sZXQgaW5pdCBsIGYgPVxuICBpZiBsID0gMCB0aGVuIFt8fF0gZWxzZVxuICBpZiBsIDwgMCB0aGVuIGludmFsaWRfYXJnIFwiQXJyYXkuaW5pdFwiXG4gICgqIFNlZSAjNjU3NS4gV2UgY291bGQgYWxzbyBjaGVjayBmb3IgbWF4aW11bSBhcnJheSBzaXplLCBidXQgdGhpcyBkZXBlbmRzXG4gICAgIG9uIHdoZXRoZXIgd2UgY3JlYXRlIGEgZmxvYXQgYXJyYXkgb3IgYSByZWd1bGFyIG9uZS4uLiAqKVxuICBlbHNlXG4gICBsZXQgcmVzID0gY3JlYXRlIGwgKGYgMCkgaW5cbiAgIGZvciBpID0gMSB0byBwcmVkIGwgZG9cbiAgICAgdW5zYWZlX3NldCByZXMgaSAoZiBpKVxuICAgZG9uZTtcbiAgIHJlc1xuXG5sZXQgbWFrZV9tYXRyaXggc3ggc3kgaW5pdCA9XG4gIGxldCByZXMgPSBjcmVhdGUgc3ggW3x8XSBpblxuICBmb3IgeCA9IDAgdG8gcHJlZCBzeCBkb1xuICAgIHVuc2FmZV9zZXQgcmVzIHggKGNyZWF0ZSBzeSBpbml0KVxuICBkb25lO1xuICByZXNcblxubGV0IGNyZWF0ZV9tYXRyaXggPSBtYWtlX21hdHJpeFxuXG5sZXQgY29weSBhID1cbiAgbGV0IGwgPSBsZW5ndGggYSBpbiBpZiBsID0gMCB0aGVuIFt8fF0gZWxzZSB1bnNhZmVfc3ViIGEgMCBsXG5cbmxldCBhcHBlbmQgYTEgYTIgPVxuICBsZXQgbDEgPSBsZW5ndGggYTEgaW5cbiAgaWYgbDEgPSAwIHRoZW4gY29weSBhMlxuICBlbHNlIGlmIGxlbmd0aCBhMiA9IDAgdGhlbiB1bnNhZmVfc3ViIGExIDAgbDFcbiAgZWxzZSBhcHBlbmRfcHJpbSBhMSBhMlxuXG5sZXQgc3ViIGEgb2ZzIGxlbiA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBsZW5ndGggYSAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiQXJyYXkuc3ViXCJcbiAgZWxzZSB1bnNhZmVfc3ViIGEgb2ZzIGxlblxuXG5sZXQgZmlsbCBhIG9mcyBsZW4gdiA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBsZW5ndGggYSAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiQXJyYXkuZmlsbFwiXG4gIGVsc2UgdW5zYWZlX2ZpbGwgYSBvZnMgbGVuIHZcblxubGV0IGJsaXQgYTEgb2ZzMSBhMiBvZnMyIGxlbiA9XG4gIGlmIGxlbiA8IDAgfHwgb2ZzMSA8IDAgfHwgb2ZzMSA+IGxlbmd0aCBhMSAtIGxlblxuICAgICAgICAgICAgIHx8IG9mczIgPCAwIHx8IG9mczIgPiBsZW5ndGggYTIgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIkFycmF5LmJsaXRcIlxuICBlbHNlIHVuc2FmZV9ibGl0IGExIG9mczEgYTIgb2ZzMiBsZW5cblxubGV0IGl0ZXIgZiBhID1cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCBhIC0gMSBkbyBmKHVuc2FmZV9nZXQgYSBpKSBkb25lXG5cbmxldCBpdGVyMiBmIGEgYiA9XG4gIGlmIGxlbmd0aCBhIDw+IGxlbmd0aCBiIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIkFycmF5Lml0ZXIyOiBhcnJheXMgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aFwiXG4gIGVsc2VcbiAgICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvIGYgKHVuc2FmZV9nZXQgYSBpKSAodW5zYWZlX2dldCBiIGkpIGRvbmVcblxubGV0IG1hcCBmIGEgPVxuICBsZXQgbCA9IGxlbmd0aCBhIGluXG4gIGlmIGwgPSAwIHRoZW4gW3x8XSBlbHNlIGJlZ2luXG4gICAgbGV0IHIgPSBjcmVhdGUgbCAoZih1bnNhZmVfZ2V0IGEgMCkpIGluXG4gICAgZm9yIGkgPSAxIHRvIGwgLSAxIGRvXG4gICAgICB1bnNhZmVfc2V0IHIgaSAoZih1bnNhZmVfZ2V0IGEgaSkpXG4gICAgZG9uZTtcbiAgICByXG4gIGVuZFxuXG5sZXQgbWFwMiBmIGEgYiA9XG4gIGxldCBsYSA9IGxlbmd0aCBhIGluXG4gIGxldCBsYiA9IGxlbmd0aCBiIGluXG4gIGlmIGxhIDw+IGxiIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIkFycmF5Lm1hcDI6IGFycmF5cyBtdXN0IGhhdmUgdGhlIHNhbWUgbGVuZ3RoXCJcbiAgZWxzZSBiZWdpblxuICAgIGlmIGxhID0gMCB0aGVuIFt8fF0gZWxzZSBiZWdpblxuICAgICAgbGV0IHIgPSBjcmVhdGUgbGEgKGYgKHVuc2FmZV9nZXQgYSAwKSAodW5zYWZlX2dldCBiIDApKSBpblxuICAgICAgZm9yIGkgPSAxIHRvIGxhIC0gMSBkb1xuICAgICAgICB1bnNhZmVfc2V0IHIgaSAoZiAodW5zYWZlX2dldCBhIGkpICh1bnNhZmVfZ2V0IGIgaSkpXG4gICAgICBkb25lO1xuICAgICAgclxuICAgIGVuZFxuICBlbmRcblxubGV0IGl0ZXJpIGYgYSA9XG4gIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG8gZiBpICh1bnNhZmVfZ2V0IGEgaSkgZG9uZVxuXG5sZXQgbWFwaSBmIGEgPVxuICBsZXQgbCA9IGxlbmd0aCBhIGluXG4gIGlmIGwgPSAwIHRoZW4gW3x8XSBlbHNlIGJlZ2luXG4gICAgbGV0IHIgPSBjcmVhdGUgbCAoZiAwICh1bnNhZmVfZ2V0IGEgMCkpIGluXG4gICAgZm9yIGkgPSAxIHRvIGwgLSAxIGRvXG4gICAgICB1bnNhZmVfc2V0IHIgaSAoZiBpICh1bnNhZmVfZ2V0IGEgaSkpXG4gICAgZG9uZTtcbiAgICByXG4gIGVuZFxuXG5sZXQgdG9fbGlzdCBhID1cbiAgbGV0IHJlYyB0b2xpc3QgaSByZXMgPVxuICAgIGlmIGkgPCAwIHRoZW4gcmVzIGVsc2UgdG9saXN0IChpIC0gMSkgKHVuc2FmZV9nZXQgYSBpIDo6IHJlcykgaW5cbiAgdG9saXN0IChsZW5ndGggYSAtIDEpIFtdXG5cbigqIENhbm5vdCB1c2UgTGlzdC5sZW5ndGggaGVyZSBiZWNhdXNlIHRoZSBMaXN0IG1vZHVsZSBkZXBlbmRzIG9uIEFycmF5LiAqKVxubGV0IHJlYyBsaXN0X2xlbmd0aCBhY2N1ID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBhY2N1XG4gIHwgXzo6dCAtPiBsaXN0X2xlbmd0aCAoc3VjYyBhY2N1KSB0XG5cbmxldCBvZl9saXN0ID0gZnVuY3Rpb25cbiAgICBbXSAtPiBbfHxdXG4gIHwgaGQ6OnRsIGFzIGwgLT5cbiAgICAgIGxldCBhID0gY3JlYXRlIChsaXN0X2xlbmd0aCAwIGwpIGhkIGluXG4gICAgICBsZXQgcmVjIGZpbGwgaSA9IGZ1bmN0aW9uXG4gICAgICAgICAgW10gLT4gYVxuICAgICAgICB8IGhkOjp0bCAtPiB1bnNhZmVfc2V0IGEgaSBoZDsgZmlsbCAoaSsxKSB0bCBpblxuICAgICAgZmlsbCAxIHRsXG5cbmxldCBmb2xkX2xlZnQgZiB4IGEgPVxuICBsZXQgciA9IHJlZiB4IGluXG4gIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG9cbiAgICByIDo9IGYgIXIgKHVuc2FmZV9nZXQgYSBpKVxuICBkb25lO1xuICAhclxuXG5sZXQgZm9sZF9sZWZ0X21hcCBmIGFjYyBpbnB1dF9hcnJheSA9XG4gIGxldCBsZW4gPSBsZW5ndGggaW5wdXRfYXJyYXkgaW5cbiAgaWYgbGVuID0gMCB0aGVuIChhY2MsIFt8fF0pIGVsc2UgYmVnaW5cbiAgICBsZXQgYWNjLCBlbHQgPSBmIGFjYyAodW5zYWZlX2dldCBpbnB1dF9hcnJheSAwKSBpblxuICAgIGxldCBvdXRwdXRfYXJyYXkgPSBjcmVhdGUgbGVuIGVsdCBpblxuICAgIGxldCBhY2MgPSByZWYgYWNjIGluXG4gICAgZm9yIGkgPSAxIHRvIGxlbiAtIDEgZG9cbiAgICAgIGxldCBhY2MnLCBlbHQgPSBmICFhY2MgKHVuc2FmZV9nZXQgaW5wdXRfYXJyYXkgaSkgaW5cbiAgICAgIGFjYyA6PSBhY2MnO1xuICAgICAgdW5zYWZlX3NldCBvdXRwdXRfYXJyYXkgaSBlbHQ7XG4gICAgZG9uZTtcbiAgICAhYWNjLCBvdXRwdXRfYXJyYXlcbiAgZW5kXG5cbmxldCBmb2xkX3JpZ2h0IGYgYSB4ID1cbiAgbGV0IHIgPSByZWYgeCBpblxuICBmb3IgaSA9IGxlbmd0aCBhIC0gMSBkb3dudG8gMCBkb1xuICAgIHIgOj0gZiAodW5zYWZlX2dldCBhIGkpICFyXG4gIGRvbmU7XG4gICFyXG5cbmxldCBleGlzdHMgcCBhID1cbiAgbGV0IG4gPSBsZW5ndGggYSBpblxuICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgaWYgaSA9IG4gdGhlbiBmYWxzZVxuICAgIGVsc2UgaWYgcCAodW5zYWZlX2dldCBhIGkpIHRoZW4gdHJ1ZVxuICAgIGVsc2UgbG9vcCAoc3VjYyBpKSBpblxuICBsb29wIDBcblxubGV0IGZvcl9hbGwgcCBhID1cbiAgbGV0IG4gPSBsZW5ndGggYSBpblxuICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgaWYgaSA9IG4gdGhlbiB0cnVlXG4gICAgZWxzZSBpZiBwICh1bnNhZmVfZ2V0IGEgaSkgdGhlbiBsb29wIChzdWNjIGkpXG4gICAgZWxzZSBmYWxzZSBpblxuICBsb29wIDBcblxubGV0IGZvcl9hbGwyIHAgbDEgbDIgPVxuICBsZXQgbjEgPSBsZW5ndGggbDFcbiAgYW5kIG4yID0gbGVuZ3RoIGwyIGluXG4gIGlmIG4xIDw+IG4yIHRoZW4gaW52YWxpZF9hcmcgXCJBcnJheS5mb3JfYWxsMlwiXG4gIGVsc2UgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPSBuMSB0aGVuIHRydWVcbiAgICBlbHNlIGlmIHAgKHVuc2FmZV9nZXQgbDEgaSkgKHVuc2FmZV9nZXQgbDIgaSkgdGhlbiBsb29wIChzdWNjIGkpXG4gICAgZWxzZSBmYWxzZSBpblxuICBsb29wIDBcblxubGV0IGV4aXN0czIgcCBsMSBsMiA9XG4gIGxldCBuMSA9IGxlbmd0aCBsMVxuICBhbmQgbjIgPSBsZW5ndGggbDIgaW5cbiAgaWYgbjEgPD4gbjIgdGhlbiBpbnZhbGlkX2FyZyBcIkFycmF5LmV4aXN0czJcIlxuICBlbHNlIGxldCByZWMgbG9vcCBpID1cbiAgICBpZiBpID0gbjEgdGhlbiBmYWxzZVxuICAgIGVsc2UgaWYgcCAodW5zYWZlX2dldCBsMSBpKSAodW5zYWZlX2dldCBsMiBpKSB0aGVuIHRydWVcbiAgICBlbHNlIGxvb3AgKHN1Y2MgaSkgaW5cbiAgbG9vcCAwXG5cbmxldCBtZW0geCBhID1cbiAgbGV0IG4gPSBsZW5ndGggYSBpblxuICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgaWYgaSA9IG4gdGhlbiBmYWxzZVxuICAgIGVsc2UgaWYgY29tcGFyZSAodW5zYWZlX2dldCBhIGkpIHggPSAwIHRoZW4gdHJ1ZVxuICAgIGVsc2UgbG9vcCAoc3VjYyBpKSBpblxuICBsb29wIDBcblxubGV0IG1lbXEgeCBhID1cbiAgbGV0IG4gPSBsZW5ndGggYSBpblxuICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgaWYgaSA9IG4gdGhlbiBmYWxzZVxuICAgIGVsc2UgaWYgeCA9PSAodW5zYWZlX2dldCBhIGkpIHRoZW4gdHJ1ZVxuICAgIGVsc2UgbG9vcCAoc3VjYyBpKSBpblxuICBsb29wIDBcblxubGV0IGZpbmRfb3B0IHAgYSA9XG4gIGxldCBuID0gbGVuZ3RoIGEgaW5cbiAgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPSBuIHRoZW4gTm9uZVxuICAgIGVsc2VcbiAgICAgIGxldCB4ID0gdW5zYWZlX2dldCBhIGkgaW5cbiAgICAgIGlmIHAgeCB0aGVuIFNvbWUgeFxuICAgICAgZWxzZSBsb29wIChzdWNjIGkpXG4gIGluXG4gIGxvb3AgMFxuXG5sZXQgZmluZF9tYXAgZiBhID1cbiAgbGV0IG4gPSBsZW5ndGggYSBpblxuICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgaWYgaSA9IG4gdGhlbiBOb25lXG4gICAgZWxzZVxuICAgICAgbWF0Y2ggZiAodW5zYWZlX2dldCBhIGkpIHdpdGhcbiAgICAgIHwgTm9uZSAtPiBsb29wIChzdWNjIGkpXG4gICAgICB8IFNvbWUgXyBhcyByIC0+IHJcbiAgaW5cbiAgbG9vcCAwXG5cbmxldCBzcGxpdCB4ID1cbiAgaWYgeCA9IFt8fF0gdGhlbiBbfHxdLCBbfHxdXG4gIGVsc2UgYmVnaW5cbiAgICBsZXQgYTAsIGIwID0gdW5zYWZlX2dldCB4IDAgaW5cbiAgICBsZXQgbiA9IGxlbmd0aCB4IGluXG4gICAgbGV0IGEgPSBjcmVhdGUgbiBhMCBpblxuICAgIGxldCBiID0gY3JlYXRlIG4gYjAgaW5cbiAgICBmb3IgaSA9IDEgdG8gbiAtIDEgZG9cbiAgICAgIGxldCBhaSwgYmkgPSB1bnNhZmVfZ2V0IHggaSBpblxuICAgICAgdW5zYWZlX3NldCBhIGkgYWk7XG4gICAgICB1bnNhZmVfc2V0IGIgaSBiaVxuICAgIGRvbmU7XG4gICAgYSwgYlxuICBlbmRcblxubGV0IGNvbWJpbmUgYSBiID1cbiAgbGV0IG5hID0gbGVuZ3RoIGEgaW5cbiAgbGV0IG5iID0gbGVuZ3RoIGIgaW5cbiAgaWYgbmEgPD4gbmIgdGhlbiBpbnZhbGlkX2FyZyBcIkFycmF5LmNvbWJpbmVcIjtcbiAgaWYgbmEgPSAwIHRoZW4gW3x8XVxuICBlbHNlIGJlZ2luXG4gICAgbGV0IHggPSBjcmVhdGUgbmEgKHVuc2FmZV9nZXQgYSAwLCB1bnNhZmVfZ2V0IGIgMCkgaW5cbiAgICBmb3IgaSA9IDEgdG8gbmEgLSAxIGRvXG4gICAgICB1bnNhZmVfc2V0IHggaSAodW5zYWZlX2dldCBhIGksIHVuc2FmZV9nZXQgYiBpKVxuICAgIGRvbmU7XG4gICAgeFxuICBlbmRcblxuZXhjZXB0aW9uIEJvdHRvbSBvZiBpbnRcbmxldCBzb3J0IGNtcCBhID1cbiAgbGV0IG1heHNvbiBsIGkgPVxuICAgIGxldCBpMzEgPSBpK2kraSsxIGluXG4gICAgbGV0IHggPSByZWYgaTMxIGluXG4gICAgaWYgaTMxKzIgPCBsIHRoZW4gYmVnaW5cbiAgICAgIGlmIGNtcCAoZ2V0IGEgaTMxKSAoZ2V0IGEgKGkzMSsxKSkgPCAwIHRoZW4geCA6PSBpMzErMTtcbiAgICAgIGlmIGNtcCAoZ2V0IGEgIXgpIChnZXQgYSAoaTMxKzIpKSA8IDAgdGhlbiB4IDo9IGkzMSsyO1xuICAgICAgIXhcbiAgICBlbmQgZWxzZVxuICAgICAgaWYgaTMxKzEgPCBsICYmIGNtcCAoZ2V0IGEgaTMxKSAoZ2V0IGEgKGkzMSsxKSkgPCAwXG4gICAgICB0aGVuIGkzMSsxXG4gICAgICBlbHNlIGlmIGkzMSA8IGwgdGhlbiBpMzEgZWxzZSByYWlzZSAoQm90dG9tIGkpXG4gIGluXG4gIGxldCByZWMgdHJpY2tsZWRvd24gbCBpIGUgPVxuICAgIGxldCBqID0gbWF4c29uIGwgaSBpblxuICAgIGlmIGNtcCAoZ2V0IGEgaikgZSA+IDAgdGhlbiBiZWdpblxuICAgICAgc2V0IGEgaSAoZ2V0IGEgaik7XG4gICAgICB0cmlja2xlZG93biBsIGogZTtcbiAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgc2V0IGEgaSBlO1xuICAgIGVuZDtcbiAgaW5cbiAgbGV0IHRyaWNrbGUgbCBpIGUgPSB0cnkgdHJpY2tsZWRvd24gbCBpIGUgd2l0aCBCb3R0b20gaSAtPiBzZXQgYSBpIGUgaW5cbiAgbGV0IHJlYyBidWJibGVkb3duIGwgaSA9XG4gICAgbGV0IGogPSBtYXhzb24gbCBpIGluXG4gICAgc2V0IGEgaSAoZ2V0IGEgaik7XG4gICAgYnViYmxlZG93biBsIGpcbiAgaW5cbiAgbGV0IGJ1YmJsZSBsIGkgPSB0cnkgYnViYmxlZG93biBsIGkgd2l0aCBCb3R0b20gaSAtPiBpIGluXG4gIGxldCByZWMgdHJpY2tsZXVwIGkgZSA9XG4gICAgbGV0IGZhdGhlciA9IChpIC0gMSkgLyAzIGluXG4gICAgYXNzZXJ0IChpIDw+IGZhdGhlcik7XG4gICAgaWYgY21wIChnZXQgYSBmYXRoZXIpIGUgPCAwIHRoZW4gYmVnaW5cbiAgICAgIHNldCBhIGkgKGdldCBhIGZhdGhlcik7XG4gICAgICBpZiBmYXRoZXIgPiAwIHRoZW4gdHJpY2tsZXVwIGZhdGhlciBlIGVsc2Ugc2V0IGEgMCBlO1xuICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICBzZXQgYSBpIGU7XG4gICAgZW5kO1xuICBpblxuICBsZXQgbCA9IGxlbmd0aCBhIGluXG4gIGZvciBpID0gKGwgKyAxKSAvIDMgLSAxIGRvd250byAwIGRvIHRyaWNrbGUgbCBpIChnZXQgYSBpKTsgZG9uZTtcbiAgZm9yIGkgPSBsIC0gMSBkb3dudG8gMiBkb1xuICAgIGxldCBlID0gKGdldCBhIGkpIGluXG4gICAgc2V0IGEgaSAoZ2V0IGEgMCk7XG4gICAgdHJpY2tsZXVwIChidWJibGUgaSAwKSBlO1xuICBkb25lO1xuICBpZiBsID4gMSB0aGVuIChsZXQgZSA9IChnZXQgYSAxKSBpbiBzZXQgYSAxIChnZXQgYSAwKTsgc2V0IGEgMCBlKVxuXG5cbmxldCBjdXRvZmYgPSA1XG5sZXQgc3RhYmxlX3NvcnQgY21wIGEgPVxuICBsZXQgbWVyZ2Ugc3JjMW9mcyBzcmMxbGVuIHNyYzIgc3JjMm9mcyBzcmMybGVuIGRzdCBkc3RvZnMgPVxuICAgIGxldCBzcmMxciA9IHNyYzFvZnMgKyBzcmMxbGVuIGFuZCBzcmMyciA9IHNyYzJvZnMgKyBzcmMybGVuIGluXG4gICAgbGV0IHJlYyBsb29wIGkxIHMxIGkyIHMyIGQgPVxuICAgICAgaWYgY21wIHMxIHMyIDw9IDAgdGhlbiBiZWdpblxuICAgICAgICBzZXQgZHN0IGQgczE7XG4gICAgICAgIGxldCBpMSA9IGkxICsgMSBpblxuICAgICAgICBpZiBpMSA8IHNyYzFyIHRoZW5cbiAgICAgICAgICBsb29wIGkxIChnZXQgYSBpMSkgaTIgczIgKGQgKyAxKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgYmxpdCBzcmMyIGkyIGRzdCAoZCArIDEpIChzcmMyciAtIGkyKVxuICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgc2V0IGRzdCBkIHMyO1xuICAgICAgICBsZXQgaTIgPSBpMiArIDEgaW5cbiAgICAgICAgaWYgaTIgPCBzcmMyciB0aGVuXG4gICAgICAgICAgbG9vcCBpMSBzMSBpMiAoZ2V0IHNyYzIgaTIpIChkICsgMSlcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGJsaXQgYSBpMSBkc3QgKGQgKyAxKSAoc3JjMXIgLSBpMSlcbiAgICAgIGVuZFxuICAgIGluIGxvb3Agc3JjMW9mcyAoZ2V0IGEgc3JjMW9mcykgc3JjMm9mcyAoZ2V0IHNyYzIgc3JjMm9mcykgZHN0b2ZzO1xuICBpblxuICBsZXQgaXNvcnR0byBzcmNvZnMgZHN0IGRzdG9mcyBsZW4gPVxuICAgIGZvciBpID0gMCB0byBsZW4gLSAxIGRvXG4gICAgICBsZXQgZSA9IChnZXQgYSAoc3Jjb2ZzICsgaSkpIGluXG4gICAgICBsZXQgaiA9IHJlZiAoZHN0b2ZzICsgaSAtIDEpIGluXG4gICAgICB3aGlsZSAoIWogPj0gZHN0b2ZzICYmIGNtcCAoZ2V0IGRzdCAhaikgZSA+IDApIGRvXG4gICAgICAgIHNldCBkc3QgKCFqICsgMSkgKGdldCBkc3QgIWopO1xuICAgICAgICBkZWNyIGo7XG4gICAgICBkb25lO1xuICAgICAgc2V0IGRzdCAoIWogKyAxKSBlO1xuICAgIGRvbmU7XG4gIGluXG4gIGxldCByZWMgc29ydHRvIHNyY29mcyBkc3QgZHN0b2ZzIGxlbiA9XG4gICAgaWYgbGVuIDw9IGN1dG9mZiB0aGVuIGlzb3J0dG8gc3Jjb2ZzIGRzdCBkc3RvZnMgbGVuIGVsc2UgYmVnaW5cbiAgICAgIGxldCBsMSA9IGxlbiAvIDIgaW5cbiAgICAgIGxldCBsMiA9IGxlbiAtIGwxIGluXG4gICAgICBzb3J0dG8gKHNyY29mcyArIGwxKSBkc3QgKGRzdG9mcyArIGwxKSBsMjtcbiAgICAgIHNvcnR0byBzcmNvZnMgYSAoc3Jjb2ZzICsgbDIpIGwxO1xuICAgICAgbWVyZ2UgKHNyY29mcyArIGwyKSBsMSBkc3QgKGRzdG9mcyArIGwxKSBsMiBkc3QgZHN0b2ZzO1xuICAgIGVuZDtcbiAgaW5cbiAgbGV0IGwgPSBsZW5ndGggYSBpblxuICBpZiBsIDw9IGN1dG9mZiB0aGVuIGlzb3J0dG8gMCBhIDAgbCBlbHNlIGJlZ2luXG4gICAgbGV0IGwxID0gbCAvIDIgaW5cbiAgICBsZXQgbDIgPSBsIC0gbDEgaW5cbiAgICBsZXQgdCA9IG1ha2UgbDIgKGdldCBhIDApIGluXG4gICAgc29ydHRvIGwxIHQgMCBsMjtcbiAgICBzb3J0dG8gMCBhIGwyIGwxO1xuICAgIG1lcmdlIGwyIGwxIHQgMCBsMiBhIDA7XG4gIGVuZFxuXG5cbmxldCBmYXN0X3NvcnQgPSBzdGFibGVfc29ydFxuXG4oKiogezEgSXRlcmF0b3JzfSAqKVxuXG5sZXQgdG9fc2VxIGEgPVxuICBsZXQgcmVjIGF1eCBpICgpID1cbiAgICBpZiBpIDwgbGVuZ3RoIGFcbiAgICB0aGVuXG4gICAgICBsZXQgeCA9IHVuc2FmZV9nZXQgYSBpIGluXG4gICAgICBTZXEuQ29ucyAoeCwgYXV4IChpKzEpKVxuICAgIGVsc2UgU2VxLk5pbFxuICBpblxuICBhdXggMFxuXG5sZXQgdG9fc2VxaSBhID1cbiAgbGV0IHJlYyBhdXggaSAoKSA9XG4gICAgaWYgaSA8IGxlbmd0aCBhXG4gICAgdGhlblxuICAgICAgbGV0IHggPSB1bnNhZmVfZ2V0IGEgaSBpblxuICAgICAgU2VxLkNvbnMgKChpLHgpLCBhdXggKGkrMSkpXG4gICAgZWxzZSBTZXEuTmlsXG4gIGluXG4gIGF1eCAwXG5cbmxldCBvZl9yZXZfbGlzdCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gW3x8XVxuICB8IGhkOjp0bCBhcyBsIC0+XG4gICAgICBsZXQgbGVuID0gbGlzdF9sZW5ndGggMCBsIGluXG4gICAgICBsZXQgYSA9IGNyZWF0ZSBsZW4gaGQgaW5cbiAgICAgIGxldCByZWMgZmlsbCBpID0gZnVuY3Rpb25cbiAgICAgICAgICBbXSAtPiBhXG4gICAgICAgIHwgaGQ6OnRsIC0+IHVuc2FmZV9zZXQgYSBpIGhkOyBmaWxsIChpLTEpIHRsXG4gICAgICBpblxuICAgICAgZmlsbCAobGVuLTIpIHRsXG5cbmxldCBvZl9zZXEgaSA9XG4gIGxldCBsID0gU2VxLmZvbGRfbGVmdCAoZnVuIGFjYyB4IC0+IHg6OmFjYykgW10gaSBpblxuICBvZl9yZXZfbGlzdCBsXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgIE5pY29sYXMgT2plZGEgQmFyLCBMZXhpRmkgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE4IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbmV4dGVybmFsIG5lZyA6IGZsb2F0IC0+IGZsb2F0ID0gXCIlbmVnZmxvYXRcIlxuZXh0ZXJuYWwgYWRkIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcIiVhZGRmbG9hdFwiXG5leHRlcm5hbCBzdWIgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiJXN1YmZsb2F0XCJcbmV4dGVybmFsIG11bCA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCIlbXVsZmxvYXRcIlxuZXh0ZXJuYWwgZGl2IDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcIiVkaXZmbG9hdFwiXG5leHRlcm5hbCByZW0gOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9mbW9kX2Zsb2F0XCIgXCJmbW9kXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGZtYSA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2ZtYV9mbG9hdFwiIFwiY2FtbF9mbWFcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYWJzIDogZmxvYXQgLT4gZmxvYXQgPSBcIiVhYnNmbG9hdFwiXG5cbmxldCB6ZXJvID0gMC5cbmxldCBvbmUgPSAxLlxubGV0IG1pbnVzX29uZSA9IC0xLlxubGV0IGluZmluaXR5ID0gU3RkbGliLmluZmluaXR5XG5sZXQgbmVnX2luZmluaXR5ID0gU3RkbGliLm5lZ19pbmZpbml0eVxubGV0IG5hbiA9IFN0ZGxpYi5uYW5cbmxldCBpc19maW5pdGUgKHg6IGZsb2F0KSA9IHggLS4geCA9IDAuXG5sZXQgaXNfaW5maW5pdGUgKHg6IGZsb2F0KSA9IDEuIC8uIHggPSAwLlxubGV0IGlzX25hbiAoeDogZmxvYXQpID0geCA8PiB4XG5cbmxldCBwaSA9IDB4MS45MjFmYjU0NDQyZDE4cCsxXG5sZXQgbWF4X2Zsb2F0ID0gU3RkbGliLm1heF9mbG9hdFxubGV0IG1pbl9mbG9hdCA9IFN0ZGxpYi5taW5fZmxvYXRcbmxldCBlcHNpbG9uID0gU3RkbGliLmVwc2lsb25fZmxvYXRcbmV4dGVybmFsIG9mX2ludCA6IGludCAtPiBmbG9hdCA9IFwiJWZsb2F0b2ZpbnRcIlxuZXh0ZXJuYWwgdG9faW50IDogZmxvYXQgLT4gaW50ID0gXCIlaW50b2ZmbG9hdFwiXG5leHRlcm5hbCBvZl9zdHJpbmcgOiBzdHJpbmcgLT4gZmxvYXQgPSBcImNhbWxfZmxvYXRfb2Zfc3RyaW5nXCJcbmxldCBvZl9zdHJpbmdfb3B0ID0gU3RkbGliLmZsb2F0X29mX3N0cmluZ19vcHRcbmxldCB0b19zdHJpbmcgPSBTdGRsaWIuc3RyaW5nX29mX2Zsb2F0XG50eXBlIGZwY2xhc3MgPSBTdGRsaWIuZnBjbGFzcyA9XG4gICAgRlBfbm9ybWFsXG4gIHwgRlBfc3Vibm9ybWFsXG4gIHwgRlBfemVyb1xuICB8IEZQX2luZmluaXRlXG4gIHwgRlBfbmFuXG5leHRlcm5hbCBjbGFzc2lmeV9mbG9hdCA6IChmbG9hdCBbQHVuYm94ZWRdKSAtPiBmcGNsYXNzID1cbiAgXCJjYW1sX2NsYXNzaWZ5X2Zsb2F0XCIgXCJjYW1sX2NsYXNzaWZ5X2Zsb2F0X3VuYm94ZWRcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgcG93IDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfcG93ZXJfZmxvYXRcIiBcInBvd1wiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBzcXJ0IDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfc3FydF9mbG9hdFwiIFwic3FydFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBjYnJ0IDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfY2JydF9mbG9hdFwiIFwiY2FtbF9jYnJ0XCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGV4cCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2V4cF9mbG9hdFwiIFwiZXhwXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGV4cDIgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9leHAyX2Zsb2F0XCIgXCJjYW1sX2V4cDJcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgbG9nIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfbG9nX2Zsb2F0XCIgXCJsb2dcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgbG9nMTAgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9sb2cxMF9mbG9hdFwiIFwibG9nMTBcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgbG9nMiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2xvZzJfZmxvYXRcIiBcImNhbWxfbG9nMlwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBleHBtMSA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2V4cG0xX2Zsb2F0XCIgXCJjYW1sX2V4cG0xXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGxvZzFwIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfbG9nMXBfZmxvYXRcIiBcImNhbWxfbG9nMXBcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgY29zIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfY29zX2Zsb2F0XCIgXCJjb3NcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgc2luIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfc2luX2Zsb2F0XCIgXCJzaW5cIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdGFuIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfdGFuX2Zsb2F0XCIgXCJ0YW5cIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYWNvcyA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Fjb3NfZmxvYXRcIiBcImFjb3NcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYXNpbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2FzaW5fZmxvYXRcIiBcImFzaW5cIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYXRhbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2F0YW5fZmxvYXRcIiBcImF0YW5cIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYXRhbjIgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hdGFuMl9mbG9hdFwiIFwiYXRhbjJcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgaHlwb3QgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdFxuICAgICAgICAgICAgICAgPSBcImNhbWxfaHlwb3RfZmxvYXRcIiBcImNhbWxfaHlwb3RcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgY29zaCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Nvc2hfZmxvYXRcIiBcImNvc2hcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgc2luaCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3NpbmhfZmxvYXRcIiBcInNpbmhcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdGFuaCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3RhbmhfZmxvYXRcIiBcInRhbmhcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYWNvc2ggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hY29zaF9mbG9hdFwiIFwiY2FtbF9hY29zaFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBhc2luaCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2FzaW5oX2Zsb2F0XCIgXCJjYW1sX2FzaW5oXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGF0YW5oIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYXRhbmhfZmxvYXRcIiBcImNhbWxfYXRhbmhcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZXJmIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfZXJmX2Zsb2F0XCIgXCJjYW1sX2VyZlwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBlcmZjIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfZXJmY19mbG9hdFwiIFwiY2FtbF9lcmZjXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHRydW5jIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfdHJ1bmNfZmxvYXRcIiBcImNhbWxfdHJ1bmNcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgcm91bmQgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9yb3VuZF9mbG9hdFwiIFwiY2FtbF9yb3VuZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBjZWlsIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfY2VpbF9mbG9hdFwiIFwiY2VpbFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBmbG9vciA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Zsb29yX2Zsb2F0XCIgXCJmbG9vclwiXG5bQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuXG5sZXQgaXNfaW50ZWdlciB4ID0geCA9IHRydW5jIHggJiYgaXNfZmluaXRlIHhcblxuZXh0ZXJuYWwgbmV4dF9hZnRlciA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0XG4gID0gXCJjYW1sX25leHRhZnRlcl9mbG9hdFwiIFwiY2FtbF9uZXh0YWZ0ZXJcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuXG5sZXQgc3VjYyB4ID0gbmV4dF9hZnRlciB4IGluZmluaXR5XG5sZXQgcHJlZCB4ID0gbmV4dF9hZnRlciB4IG5lZ19pbmZpbml0eVxuXG5leHRlcm5hbCBjb3B5X3NpZ24gOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdFxuICAgICAgICAgICAgICAgICAgPSBcImNhbWxfY29weXNpZ25fZmxvYXRcIiBcImNhbWxfY29weXNpZ25cIlxuICAgICAgICAgICAgICAgICAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHNpZ25fYml0IDogKGZsb2F0IFtAdW5ib3hlZF0pIC0+IGJvb2xcbiAgPSBcImNhbWxfc2lnbmJpdF9mbG9hdFwiIFwiY2FtbF9zaWduYml0XCIgW0BAbm9hbGxvY11cblxuZXh0ZXJuYWwgZnJleHAgOiBmbG9hdCAtPiBmbG9hdCAqIGludCA9IFwiY2FtbF9mcmV4cF9mbG9hdFwiXG5leHRlcm5hbCBsZGV4cCA6IChmbG9hdCBbQHVuYm94ZWRdKSAtPiAoaW50IFtAdW50YWdnZWRdKSAtPiAoZmxvYXQgW0B1bmJveGVkXSkgPVxuICBcImNhbWxfbGRleHBfZmxvYXRcIiBcImNhbWxfbGRleHBfZmxvYXRfdW5ib3hlZFwiIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBtb2RmIDogZmxvYXQgLT4gZmxvYXQgKiBmbG9hdCA9IFwiY2FtbF9tb2RmX2Zsb2F0XCJcbnR5cGUgdCA9IGZsb2F0XG5leHRlcm5hbCBjb21wYXJlIDogZmxvYXQgLT4gZmxvYXQgLT4gaW50ID0gXCIlY29tcGFyZVwiXG5sZXQgZXF1YWwgeCB5ID0gY29tcGFyZSB4IHkgPSAwXG5cbmxldFtAaW5saW5lXSBtaW4gKHg6IGZsb2F0KSAoeTogZmxvYXQpID1cbiAgaWYgeSA+IHggfHwgKG5vdChzaWduX2JpdCB5KSAmJiBzaWduX2JpdCB4KSB0aGVuXG4gICAgaWYgaXNfbmFuIHkgdGhlbiB5IGVsc2UgeFxuICBlbHNlIGlmIGlzX25hbiB4IHRoZW4geCBlbHNlIHlcblxubGV0W0BpbmxpbmVdIG1heCAoeDogZmxvYXQpICh5OiBmbG9hdCkgPVxuICBpZiB5ID4geCB8fCAobm90KHNpZ25fYml0IHkpICYmIHNpZ25fYml0IHgpIHRoZW5cbiAgICBpZiBpc19uYW4geCB0aGVuIHggZWxzZSB5XG4gIGVsc2UgaWYgaXNfbmFuIHkgdGhlbiB5IGVsc2UgeFxuXG5sZXRbQGlubGluZV0gbWluX21heCAoeDogZmxvYXQpICh5OiBmbG9hdCkgPVxuICBpZiBpc19uYW4geCB8fCBpc19uYW4geSB0aGVuIChuYW4sIG5hbilcbiAgZWxzZSBpZiB5ID4geCB8fCAobm90KHNpZ25fYml0IHkpICYmIHNpZ25fYml0IHgpIHRoZW4gKHgsIHkpIGVsc2UgKHksIHgpXG5cbmxldFtAaW5saW5lXSBtaW5fbnVtICh4OiBmbG9hdCkgKHk6IGZsb2F0KSA9XG4gIGlmIHkgPiB4IHx8IChub3Qoc2lnbl9iaXQgeSkgJiYgc2lnbl9iaXQgeCkgdGhlblxuICAgIGlmIGlzX25hbiB4IHRoZW4geSBlbHNlIHhcbiAgZWxzZSBpZiBpc19uYW4geSB0aGVuIHggZWxzZSB5XG5cbmxldFtAaW5saW5lXSBtYXhfbnVtICh4OiBmbG9hdCkgKHk6IGZsb2F0KSA9XG4gIGlmIHkgPiB4IHx8IChub3Qoc2lnbl9iaXQgeSkgJiYgc2lnbl9iaXQgeCkgdGhlblxuICAgIGlmIGlzX25hbiB5IHRoZW4geCBlbHNlIHlcbiAgZWxzZSBpZiBpc19uYW4geCB0aGVuIHkgZWxzZSB4XG5cbmxldFtAaW5saW5lXSBtaW5fbWF4X251bSAoeDogZmxvYXQpICh5OiBmbG9hdCkgPVxuICBpZiBpc19uYW4geCB0aGVuICh5LHkpXG4gIGVsc2UgaWYgaXNfbmFuIHkgdGhlbiAoeCx4KVxuICBlbHNlIGlmIHkgPiB4IHx8IChub3Qoc2lnbl9iaXQgeSkgJiYgc2lnbl9iaXQgeCkgdGhlbiAoeCx5KSBlbHNlICh5LHgpXG5cbmV4dGVybmFsIHNlZWRlZF9oYXNoX3BhcmFtIDogaW50IC0+IGludCAtPiBpbnQgLT4gZmxvYXQgLT4gaW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9oYXNoXCIgW0BAbm9hbGxvY11cbmxldCBoYXNoIHggPSBzZWVkZWRfaGFzaF9wYXJhbSAxMCAxMDAgMCB4XG5cbm1vZHVsZSBBcnJheSA9IHN0cnVjdFxuXG4gIHR5cGUgdCA9IGZsb2F0YXJyYXlcblxuICBleHRlcm5hbCBsZW5ndGggOiB0IC0+IGludCA9IFwiJWZsb2F0YXJyYXlfbGVuZ3RoXCJcbiAgZXh0ZXJuYWwgZ2V0IDogdCAtPiBpbnQgLT4gZmxvYXQgPSBcIiVmbG9hdGFycmF5X3NhZmVfZ2V0XCJcbiAgZXh0ZXJuYWwgc2V0IDogdCAtPiBpbnQgLT4gZmxvYXQgLT4gdW5pdCA9IFwiJWZsb2F0YXJyYXlfc2FmZV9zZXRcIlxuICBleHRlcm5hbCBjcmVhdGUgOiBpbnQgLT4gdCA9IFwiY2FtbF9mbG9hdGFycmF5X2NyZWF0ZVwiXG4gIGV4dGVybmFsIHVuc2FmZV9nZXQgOiB0IC0+IGludCAtPiBmbG9hdCA9IFwiJWZsb2F0YXJyYXlfdW5zYWZlX2dldFwiXG4gIGV4dGVybmFsIHVuc2FmZV9zZXQgOiB0IC0+IGludCAtPiBmbG9hdCAtPiB1bml0ID0gXCIlZmxvYXRhcnJheV91bnNhZmVfc2V0XCJcblxuICBsZXQgdW5zYWZlX2ZpbGwgYSBvZnMgbGVuIHYgPVxuICAgIGZvciBpID0gb2ZzIHRvIG9mcyArIGxlbiAtIDEgZG8gdW5zYWZlX3NldCBhIGkgdiBkb25lXG5cbiAgZXh0ZXJuYWwgdW5zYWZlX2JsaXQ6IHQgLT4gaW50IC0+IHQgLT4gaW50IC0+IGludCAtPiB1bml0ID1cbiAgICBcImNhbWxfZmxvYXRhcnJheV9ibGl0XCIgW0BAbm9hbGxvY11cblxuICBsZXQgY2hlY2sgYSBvZnMgbGVuIG1zZyA9XG4gICAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyArIGxlbiA8IDAgfHwgb2ZzICsgbGVuID4gbGVuZ3RoIGEgdGhlblxuICAgICAgaW52YWxpZF9hcmcgbXNnXG5cbiAgbGV0IG1ha2UgbiB2ID1cbiAgICBsZXQgcmVzdWx0ID0gY3JlYXRlIG4gaW5cbiAgICB1bnNhZmVfZmlsbCByZXN1bHQgMCBuIHY7XG4gICAgcmVzdWx0XG5cbiAgbGV0IGluaXQgbCBmID1cbiAgICBpZiBsIDwgMCB0aGVuIGludmFsaWRfYXJnIFwiRmxvYXQuQXJyYXkuaW5pdFwiXG4gICAgZWxzZVxuICAgICAgbGV0IHJlcyA9IGNyZWF0ZSBsIGluXG4gICAgICBmb3IgaSA9IDAgdG8gbCAtIDEgZG9cbiAgICAgICAgdW5zYWZlX3NldCByZXMgaSAoZiBpKVxuICAgICAgZG9uZTtcbiAgICAgIHJlc1xuXG4gIGxldCBhcHBlbmQgYTEgYTIgPVxuICAgIGxldCBsMSA9IGxlbmd0aCBhMSBpblxuICAgIGxldCBsMiA9IGxlbmd0aCBhMiBpblxuICAgIGxldCByZXN1bHQgPSBjcmVhdGUgKGwxICsgbDIpIGluXG4gICAgdW5zYWZlX2JsaXQgYTEgMCByZXN1bHQgMCBsMTtcbiAgICB1bnNhZmVfYmxpdCBhMiAwIHJlc3VsdCBsMSBsMjtcbiAgICByZXN1bHRcblxuICAoKiBuZXh0IDMgZnVuY3Rpb25zOiBtb2RpZmllZCBjb3B5IG9mIGNvZGUgZnJvbSBzdHJpbmcubWwgKilcbiAgbGV0IGVuc3VyZV9nZSAoeDppbnQpIHkgPVxuICAgIGlmIHggPj0geSB0aGVuIHggZWxzZSBpbnZhbGlkX2FyZyBcIkZsb2F0LkFycmF5LmNvbmNhdFwiXG5cbiAgbGV0IHJlYyBzdW1fbGVuZ3RocyBhY2MgPSBmdW5jdGlvblxuICAgIHwgW10gLT4gYWNjXG4gICAgfCBoZCA6OiB0bCAtPiBzdW1fbGVuZ3RocyAoZW5zdXJlX2dlIChsZW5ndGggaGQgKyBhY2MpIGFjYykgdGxcblxuICBsZXQgY29uY2F0IGwgPVxuICAgIGxldCBsZW4gPSBzdW1fbGVuZ3RocyAwIGwgaW5cbiAgICBsZXQgcmVzdWx0ID0gY3JlYXRlIGxlbiBpblxuICAgIGxldCByZWMgbG9vcCBsIGkgPVxuICAgICAgbWF0Y2ggbCB3aXRoXG4gICAgICB8IFtdIC0+IGFzc2VydCAoaSA9IGxlbilcbiAgICAgIHwgaGQgOjogdGwgLT5cbiAgICAgICAgbGV0IGhsZW4gPSBsZW5ndGggaGQgaW5cbiAgICAgICAgdW5zYWZlX2JsaXQgaGQgMCByZXN1bHQgaSBobGVuO1xuICAgICAgICBsb29wIHRsIChpICsgaGxlbilcbiAgICBpblxuICAgIGxvb3AgbCAwO1xuICAgIHJlc3VsdFxuXG4gIGxldCBzdWIgYSBvZnMgbGVuID1cbiAgICBjaGVjayBhIG9mcyBsZW4gXCJGbG9hdC5BcnJheS5zdWJcIjtcbiAgICBsZXQgcmVzdWx0ID0gY3JlYXRlIGxlbiBpblxuICAgIHVuc2FmZV9ibGl0IGEgb2ZzIHJlc3VsdCAwIGxlbjtcbiAgICByZXN1bHRcblxuICBsZXQgY29weSBhID1cbiAgICBsZXQgbCA9IGxlbmd0aCBhIGluXG4gICAgbGV0IHJlc3VsdCA9IGNyZWF0ZSBsIGluXG4gICAgdW5zYWZlX2JsaXQgYSAwIHJlc3VsdCAwIGw7XG4gICAgcmVzdWx0XG5cbiAgbGV0IGZpbGwgYSBvZnMgbGVuIHYgPVxuICAgIGNoZWNrIGEgb2ZzIGxlbiBcIkZsb2F0LkFycmF5LmZpbGxcIjtcbiAgICB1bnNhZmVfZmlsbCBhIG9mcyBsZW4gdlxuXG4gIGxldCBibGl0IHNyYyBzb2ZzIGRzdCBkb2ZzIGxlbiA9XG4gICAgY2hlY2sgc3JjIHNvZnMgbGVuIFwiRmxvYXQuYXJyYXkuYmxpdFwiO1xuICAgIGNoZWNrIGRzdCBkb2ZzIGxlbiBcIkZsb2F0LmFycmF5LmJsaXRcIjtcbiAgICB1bnNhZmVfYmxpdCBzcmMgc29mcyBkc3QgZG9mcyBsZW5cblxuICBsZXQgdG9fbGlzdCBhID1cbiAgICBMaXN0LmluaXQgKGxlbmd0aCBhKSAodW5zYWZlX2dldCBhKVxuXG4gIGxldCBvZl9saXN0IGwgPVxuICAgIGxldCByZXN1bHQgPSBjcmVhdGUgKExpc3QubGVuZ3RoIGwpIGluXG4gICAgbGV0IHJlYyBmaWxsIGkgbCA9XG4gICAgICBtYXRjaCBsIHdpdGhcbiAgICAgIHwgW10gLT4gcmVzdWx0XG4gICAgICB8IGggOjogdCAtPiB1bnNhZmVfc2V0IHJlc3VsdCBpIGg7IGZpbGwgKGkgKyAxKSB0XG4gICAgaW5cbiAgICBmaWxsIDAgbFxuXG4gICgqIGR1cGxpY2F0ZWQgZnJvbSBhcnJheS5tbCAqKVxuICBsZXQgaXRlciBmIGEgPVxuICAgIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG8gZiAodW5zYWZlX2dldCBhIGkpIGRvbmVcblxuICAoKiBkdXBsaWNhdGVkIGZyb20gYXJyYXkubWwgKilcbiAgbGV0IGl0ZXIyIGYgYSBiID1cbiAgICBpZiBsZW5ndGggYSA8PiBsZW5ndGggYiB0aGVuXG4gICAgICBpbnZhbGlkX2FyZyBcIkZsb2F0LkFycmF5Lml0ZXIyOiBhcnJheXMgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aFwiXG4gICAgZWxzZVxuICAgICAgZm9yIGkgPSAwIHRvIGxlbmd0aCBhIC0gMSBkbyBmICh1bnNhZmVfZ2V0IGEgaSkgKHVuc2FmZV9nZXQgYiBpKSBkb25lXG5cbiAgbGV0IG1hcCBmIGEgPVxuICAgIGxldCBsID0gbGVuZ3RoIGEgaW5cbiAgICBsZXQgciA9IGNyZWF0ZSBsIGluXG4gICAgZm9yIGkgPSAwIHRvIGwgLSAxIGRvXG4gICAgICB1bnNhZmVfc2V0IHIgaSAoZiAodW5zYWZlX2dldCBhIGkpKVxuICAgIGRvbmU7XG4gICAgclxuXG4gIGxldCBtYXAyIGYgYSBiID1cbiAgICBsZXQgbGEgPSBsZW5ndGggYSBpblxuICAgIGxldCBsYiA9IGxlbmd0aCBiIGluXG4gICAgaWYgbGEgPD4gbGIgdGhlblxuICAgICAgaW52YWxpZF9hcmcgXCJGbG9hdC5BcnJheS5tYXAyOiBhcnJheXMgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aFwiXG4gICAgZWxzZSBiZWdpblxuICAgICAgbGV0IHIgPSBjcmVhdGUgbGEgaW5cbiAgICAgIGZvciBpID0gMCB0byBsYSAtIDEgZG9cbiAgICAgICAgdW5zYWZlX3NldCByIGkgKGYgKHVuc2FmZV9nZXQgYSBpKSAodW5zYWZlX2dldCBiIGkpKVxuICAgICAgZG9uZTtcbiAgICAgIHJcbiAgICBlbmRcblxuICAoKiBkdXBsaWNhdGVkIGZyb20gYXJyYXkubWwgKilcbiAgbGV0IGl0ZXJpIGYgYSA9XG4gICAgZm9yIGkgPSAwIHRvIGxlbmd0aCBhIC0gMSBkbyBmIGkgKHVuc2FmZV9nZXQgYSBpKSBkb25lXG5cbiAgbGV0IG1hcGkgZiBhID1cbiAgICBsZXQgbCA9IGxlbmd0aCBhIGluXG4gICAgbGV0IHIgPSBjcmVhdGUgbCBpblxuICAgIGZvciBpID0gMCB0byBsIC0gMSBkb1xuICAgICAgdW5zYWZlX3NldCByIGkgKGYgaSAodW5zYWZlX2dldCBhIGkpKVxuICAgIGRvbmU7XG4gICAgclxuXG4gICgqIGR1cGxpY2F0ZWQgZnJvbSBhcnJheS5tbCAqKVxuICBsZXQgZm9sZF9sZWZ0IGYgeCBhID1cbiAgICBsZXQgciA9IHJlZiB4IGluXG4gICAgZm9yIGkgPSAwIHRvIGxlbmd0aCBhIC0gMSBkb1xuICAgICAgciA6PSBmICFyICh1bnNhZmVfZ2V0IGEgaSlcbiAgICBkb25lO1xuICAgICFyXG5cbiAgKCogZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sICopXG4gIGxldCBmb2xkX3JpZ2h0IGYgYSB4ID1cbiAgICBsZXQgciA9IHJlZiB4IGluXG4gICAgZm9yIGkgPSBsZW5ndGggYSAtIDEgZG93bnRvIDAgZG9cbiAgICAgIHIgOj0gZiAodW5zYWZlX2dldCBhIGkpICFyXG4gICAgZG9uZTtcbiAgICAhclxuXG4gICgqIGR1cGxpY2F0ZWQgZnJvbSBhcnJheS5tbCAqKVxuICBsZXQgZXhpc3RzIHAgYSA9XG4gICAgbGV0IG4gPSBsZW5ndGggYSBpblxuICAgIGxldCByZWMgbG9vcCBpID1cbiAgICAgIGlmIGkgPSBuIHRoZW4gZmFsc2VcbiAgICAgIGVsc2UgaWYgcCAodW5zYWZlX2dldCBhIGkpIHRoZW4gdHJ1ZVxuICAgICAgZWxzZSBsb29wIChpICsgMSkgaW5cbiAgICBsb29wIDBcblxuICAoKiBkdXBsaWNhdGVkIGZyb20gYXJyYXkubWwgKilcbiAgbGV0IGZvcl9hbGwgcCBhID1cbiAgICBsZXQgbiA9IGxlbmd0aCBhIGluXG4gICAgbGV0IHJlYyBsb29wIGkgPVxuICAgICAgaWYgaSA9IG4gdGhlbiB0cnVlXG4gICAgICBlbHNlIGlmIHAgKHVuc2FmZV9nZXQgYSBpKSB0aGVuIGxvb3AgKGkgKyAxKVxuICAgICAgZWxzZSBmYWxzZSBpblxuICAgIGxvb3AgMFxuXG4gICgqIGR1cGxpY2F0ZWQgZnJvbSBhcnJheS5tbCAqKVxuICBsZXQgbWVtIHggYSA9XG4gICAgbGV0IG4gPSBsZW5ndGggYSBpblxuICAgIGxldCByZWMgbG9vcCBpID1cbiAgICAgIGlmIGkgPSBuIHRoZW4gZmFsc2VcbiAgICAgIGVsc2UgaWYgY29tcGFyZSAodW5zYWZlX2dldCBhIGkpIHggPSAwIHRoZW4gdHJ1ZVxuICAgICAgZWxzZSBsb29wIChpICsgMSlcbiAgICBpblxuICAgIGxvb3AgMFxuXG4gICgqIG1vc3RseSBkdXBsaWNhdGVkIGZyb20gYXJyYXkubWwsIGJ1dCBzbGlnaHRseSBkaWZmZXJlbnQgKilcbiAgbGV0IG1lbV9pZWVlIHggYSA9XG4gICAgbGV0IG4gPSBsZW5ndGggYSBpblxuICAgIGxldCByZWMgbG9vcCBpID1cbiAgICAgIGlmIGkgPSBuIHRoZW4gZmFsc2VcbiAgICAgIGVsc2UgaWYgeCA9ICh1bnNhZmVfZ2V0IGEgaSkgdGhlbiB0cnVlXG4gICAgICBlbHNlIGxvb3AgKGkgKyAxKVxuICAgIGluXG4gICAgbG9vcCAwXG5cbiAgKCogZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sICopXG4gIGV4Y2VwdGlvbiBCb3R0b20gb2YgaW50XG4gIGxldCBzb3J0IGNtcCBhID1cbiAgICBsZXQgbWF4c29uIGwgaSA9XG4gICAgICBsZXQgaTMxID0gaStpK2krMSBpblxuICAgICAgbGV0IHggPSByZWYgaTMxIGluXG4gICAgICBpZiBpMzErMiA8IGwgdGhlbiBiZWdpblxuICAgICAgICBpZiBjbXAgKGdldCBhIGkzMSkgKGdldCBhIChpMzErMSkpIDwgMCB0aGVuIHggOj0gaTMxKzE7XG4gICAgICAgIGlmIGNtcCAoZ2V0IGEgIXgpIChnZXQgYSAoaTMxKzIpKSA8IDAgdGhlbiB4IDo9IGkzMSsyO1xuICAgICAgICAheFxuICAgICAgZW5kIGVsc2VcbiAgICAgICAgaWYgaTMxKzEgPCBsICYmIGNtcCAoZ2V0IGEgaTMxKSAoZ2V0IGEgKGkzMSsxKSkgPCAwXG4gICAgICAgIHRoZW4gaTMxKzFcbiAgICAgICAgZWxzZSBpZiBpMzEgPCBsIHRoZW4gaTMxIGVsc2UgcmFpc2UgKEJvdHRvbSBpKVxuICAgIGluXG4gICAgbGV0IHJlYyB0cmlja2xlZG93biBsIGkgZSA9XG4gICAgICBsZXQgaiA9IG1heHNvbiBsIGkgaW5cbiAgICAgIGlmIGNtcCAoZ2V0IGEgaikgZSA+IDAgdGhlbiBiZWdpblxuICAgICAgICBzZXQgYSBpIChnZXQgYSBqKTtcbiAgICAgICAgdHJpY2tsZWRvd24gbCBqIGU7XG4gICAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgICBzZXQgYSBpIGU7XG4gICAgICBlbmQ7XG4gICAgaW5cbiAgICBsZXQgdHJpY2tsZSBsIGkgZSA9IHRyeSB0cmlja2xlZG93biBsIGkgZSB3aXRoIEJvdHRvbSBpIC0+IHNldCBhIGkgZSBpblxuICAgIGxldCByZWMgYnViYmxlZG93biBsIGkgPVxuICAgICAgbGV0IGogPSBtYXhzb24gbCBpIGluXG4gICAgICBzZXQgYSBpIChnZXQgYSBqKTtcbiAgICAgIGJ1YmJsZWRvd24gbCBqXG4gICAgaW5cbiAgICBsZXQgYnViYmxlIGwgaSA9IHRyeSBidWJibGVkb3duIGwgaSB3aXRoIEJvdHRvbSBpIC0+IGkgaW5cbiAgICBsZXQgcmVjIHRyaWNrbGV1cCBpIGUgPVxuICAgICAgbGV0IGZhdGhlciA9IChpIC0gMSkgLyAzIGluXG4gICAgICBhc3NlcnQgKGkgPD4gZmF0aGVyKTtcbiAgICAgIGlmIGNtcCAoZ2V0IGEgZmF0aGVyKSBlIDwgMCB0aGVuIGJlZ2luXG4gICAgICAgIHNldCBhIGkgKGdldCBhIGZhdGhlcik7XG4gICAgICAgIGlmIGZhdGhlciA+IDAgdGhlbiB0cmlja2xldXAgZmF0aGVyIGUgZWxzZSBzZXQgYSAwIGU7XG4gICAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgICBzZXQgYSBpIGU7XG4gICAgICBlbmQ7XG4gICAgaW5cbiAgICBsZXQgbCA9IGxlbmd0aCBhIGluXG4gICAgZm9yIGkgPSAobCArIDEpIC8gMyAtIDEgZG93bnRvIDAgZG8gdHJpY2tsZSBsIGkgKGdldCBhIGkpOyBkb25lO1xuICAgIGZvciBpID0gbCAtIDEgZG93bnRvIDIgZG9cbiAgICAgIGxldCBlID0gKGdldCBhIGkpIGluXG4gICAgICBzZXQgYSBpIChnZXQgYSAwKTtcbiAgICAgIHRyaWNrbGV1cCAoYnViYmxlIGkgMCkgZTtcbiAgICBkb25lO1xuICAgIGlmIGwgPiAxIHRoZW4gKGxldCBlID0gKGdldCBhIDEpIGluIHNldCBhIDEgKGdldCBhIDApOyBzZXQgYSAwIGUpXG5cbiAgKCogZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sLCBleGNlcHQgZm9yIHRoZSBjYWxsIHRvIFtjcmVhdGVdICopXG4gIGxldCBjdXRvZmYgPSA1XG4gIGxldCBzdGFibGVfc29ydCBjbXAgYSA9XG4gICAgbGV0IG1lcmdlIHNyYzFvZnMgc3JjMWxlbiBzcmMyIHNyYzJvZnMgc3JjMmxlbiBkc3QgZHN0b2ZzID1cbiAgICAgIGxldCBzcmMxciA9IHNyYzFvZnMgKyBzcmMxbGVuIGFuZCBzcmMyciA9IHNyYzJvZnMgKyBzcmMybGVuIGluXG4gICAgICBsZXQgcmVjIGxvb3AgaTEgczEgaTIgczIgZCA9XG4gICAgICAgIGlmIGNtcCBzMSBzMiA8PSAwIHRoZW4gYmVnaW5cbiAgICAgICAgICBzZXQgZHN0IGQgczE7XG4gICAgICAgICAgbGV0IGkxID0gaTEgKyAxIGluXG4gICAgICAgICAgaWYgaTEgPCBzcmMxciB0aGVuXG4gICAgICAgICAgICBsb29wIGkxIChnZXQgYSBpMSkgaTIgczIgKGQgKyAxKVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGJsaXQgc3JjMiBpMiBkc3QgKGQgKyAxKSAoc3JjMnIgLSBpMilcbiAgICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgICBzZXQgZHN0IGQgczI7XG4gICAgICAgICAgbGV0IGkyID0gaTIgKyAxIGluXG4gICAgICAgICAgaWYgaTIgPCBzcmMyciB0aGVuXG4gICAgICAgICAgICBsb29wIGkxIHMxIGkyIChnZXQgc3JjMiBpMikgKGQgKyAxKVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGJsaXQgYSBpMSBkc3QgKGQgKyAxKSAoc3JjMXIgLSBpMSlcbiAgICAgICAgZW5kXG4gICAgICBpbiBsb29wIHNyYzFvZnMgKGdldCBhIHNyYzFvZnMpIHNyYzJvZnMgKGdldCBzcmMyIHNyYzJvZnMpIGRzdG9mcztcbiAgICBpblxuICAgIGxldCBpc29ydHRvIHNyY29mcyBkc3QgZHN0b2ZzIGxlbiA9XG4gICAgICBmb3IgaSA9IDAgdG8gbGVuIC0gMSBkb1xuICAgICAgICBsZXQgZSA9IChnZXQgYSAoc3Jjb2ZzICsgaSkpIGluXG4gICAgICAgIGxldCBqID0gcmVmIChkc3RvZnMgKyBpIC0gMSkgaW5cbiAgICAgICAgd2hpbGUgKCFqID49IGRzdG9mcyAmJiBjbXAgKGdldCBkc3QgIWopIGUgPiAwKSBkb1xuICAgICAgICAgIHNldCBkc3QgKCFqICsgMSkgKGdldCBkc3QgIWopO1xuICAgICAgICAgIGRlY3IgajtcbiAgICAgICAgZG9uZTtcbiAgICAgICAgc2V0IGRzdCAoIWogKyAxKSBlO1xuICAgICAgZG9uZTtcbiAgICBpblxuICAgIGxldCByZWMgc29ydHRvIHNyY29mcyBkc3QgZHN0b2ZzIGxlbiA9XG4gICAgICBpZiBsZW4gPD0gY3V0b2ZmIHRoZW4gaXNvcnR0byBzcmNvZnMgZHN0IGRzdG9mcyBsZW4gZWxzZSBiZWdpblxuICAgICAgICBsZXQgbDEgPSBsZW4gLyAyIGluXG4gICAgICAgIGxldCBsMiA9IGxlbiAtIGwxIGluXG4gICAgICAgIHNvcnR0byAoc3Jjb2ZzICsgbDEpIGRzdCAoZHN0b2ZzICsgbDEpIGwyO1xuICAgICAgICBzb3J0dG8gc3Jjb2ZzIGEgKHNyY29mcyArIGwyKSBsMTtcbiAgICAgICAgbWVyZ2UgKHNyY29mcyArIGwyKSBsMSBkc3QgKGRzdG9mcyArIGwxKSBsMiBkc3QgZHN0b2ZzO1xuICAgICAgZW5kO1xuICAgIGluXG4gICAgbGV0IGwgPSBsZW5ndGggYSBpblxuICAgIGlmIGwgPD0gY3V0b2ZmIHRoZW4gaXNvcnR0byAwIGEgMCBsIGVsc2UgYmVnaW5cbiAgICAgIGxldCBsMSA9IGwgLyAyIGluXG4gICAgICBsZXQgbDIgPSBsIC0gbDEgaW5cbiAgICAgIGxldCB0ID0gY3JlYXRlIGwyIGluXG4gICAgICBzb3J0dG8gbDEgdCAwIGwyO1xuICAgICAgc29ydHRvIDAgYSBsMiBsMTtcbiAgICAgIG1lcmdlIGwyIGwxIHQgMCBsMiBhIDA7XG4gICAgZW5kXG5cbiAgbGV0IGZhc3Rfc29ydCA9IHN0YWJsZV9zb3J0XG5cbiAgKCogZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sICopXG4gIGxldCB0b19zZXEgYSA9XG4gICAgbGV0IHJlYyBhdXggaSAoKSA9XG4gICAgICBpZiBpIDwgbGVuZ3RoIGFcbiAgICAgIHRoZW5cbiAgICAgICAgbGV0IHggPSB1bnNhZmVfZ2V0IGEgaSBpblxuICAgICAgICBTZXEuQ29ucyAoeCwgYXV4IChpKzEpKVxuICAgICAgZWxzZSBTZXEuTmlsXG4gICAgaW5cbiAgICBhdXggMFxuXG4gICgqIGR1cGxpY2F0ZWQgZnJvbSBhcnJheS5tbCAqKVxuICBsZXQgdG9fc2VxaSBhID1cbiAgICBsZXQgcmVjIGF1eCBpICgpID1cbiAgICAgIGlmIGkgPCBsZW5ndGggYVxuICAgICAgdGhlblxuICAgICAgICBsZXQgeCA9IHVuc2FmZV9nZXQgYSBpIGluXG4gICAgICAgIFNlcS5Db25zICgoaSx4KSwgYXV4IChpKzEpKVxuICAgICAgZWxzZSBTZXEuTmlsXG4gICAgaW5cbiAgICBhdXggMFxuXG4gICgqIG1vc3RseSBkdXBsaWNhdGVkIGZyb20gYXJyYXkubWwgKilcbiAgbGV0IG9mX3Jldl9saXN0IGwgPVxuICAgIGxldCBsZW4gPSBMaXN0Lmxlbmd0aCBsIGluXG4gICAgbGV0IGEgPSBjcmVhdGUgbGVuIGluXG4gICAgbGV0IHJlYyBmaWxsIGkgPSBmdW5jdGlvblxuICAgICAgICBbXSAtPiBhXG4gICAgICB8IGhkOjp0bCAtPiB1bnNhZmVfc2V0IGEgaSBoZDsgZmlsbCAoaS0xKSB0bFxuICAgIGluXG4gICAgZmlsbCAobGVuLTEpIGxcblxuICAoKiBkdXBsaWNhdGVkIGZyb20gYXJyYXkubWwgKilcbiAgbGV0IG9mX3NlcSBpID1cbiAgICBsZXQgbCA9IFNlcS5mb2xkX2xlZnQgKGZ1biBhY2MgeCAtPiB4OjphY2MpIFtdIGkgaW5cbiAgICBvZl9yZXZfbGlzdCBsXG5cblxuICBsZXQgbWFwX3RvX2FycmF5IGYgYSA9XG4gICAgbGV0IGwgPSBsZW5ndGggYSBpblxuICAgIGlmIGwgPSAwIHRoZW4gW3wgfF0gZWxzZSBiZWdpblxuICAgICAgbGV0IHIgPSBBcnJheS5tYWtlIGwgKGYgKHVuc2FmZV9nZXQgYSAwKSkgaW5cbiAgICAgIGZvciBpID0gMSB0byBsIC0gMSBkb1xuICAgICAgICBBcnJheS51bnNhZmVfc2V0IHIgaSAoZiAodW5zYWZlX2dldCBhIGkpKVxuICAgICAgZG9uZTtcbiAgICAgIHJcbiAgICBlbmRcblxuICBsZXQgbWFwX2Zyb21fYXJyYXkgZiBhID1cbiAgICBsZXQgbCA9IEFycmF5Lmxlbmd0aCBhIGluXG4gICAgbGV0IHIgPSBjcmVhdGUgbCBpblxuICAgIGZvciBpID0gMCB0byBsIC0gMSBkb1xuICAgICAgdW5zYWZlX3NldCByIGkgKGYgKEFycmF5LnVuc2FmZV9nZXQgYSBpKSlcbiAgICBkb25lO1xuICAgIHJcblxuZW5kXG5cbm1vZHVsZSBBcnJheUxhYmVscyA9IEFycmF5XG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIE1vZHVsZSBbSW50MzJdOiAzMi1iaXQgaW50ZWdlcnMgKilcblxuZXh0ZXJuYWwgbmVnIDogaW50MzIgLT4gaW50MzIgPSBcIiVpbnQzMl9uZWdcIlxuZXh0ZXJuYWwgYWRkIDogaW50MzIgLT4gaW50MzIgLT4gaW50MzIgPSBcIiVpbnQzMl9hZGRcIlxuZXh0ZXJuYWwgc3ViIDogaW50MzIgLT4gaW50MzIgLT4gaW50MzIgPSBcIiVpbnQzMl9zdWJcIlxuZXh0ZXJuYWwgbXVsIDogaW50MzIgLT4gaW50MzIgLT4gaW50MzIgPSBcIiVpbnQzMl9tdWxcIlxuZXh0ZXJuYWwgZGl2IDogaW50MzIgLT4gaW50MzIgLT4gaW50MzIgPSBcIiVpbnQzMl9kaXZcIlxuZXh0ZXJuYWwgcmVtIDogaW50MzIgLT4gaW50MzIgLT4gaW50MzIgPSBcIiVpbnQzMl9tb2RcIlxuZXh0ZXJuYWwgbG9nYW5kIDogaW50MzIgLT4gaW50MzIgLT4gaW50MzIgPSBcIiVpbnQzMl9hbmRcIlxuZXh0ZXJuYWwgbG9nb3IgOiBpbnQzMiAtPiBpbnQzMiAtPiBpbnQzMiA9IFwiJWludDMyX29yXCJcbmV4dGVybmFsIGxvZ3hvciA6IGludDMyIC0+IGludDMyIC0+IGludDMyID0gXCIlaW50MzJfeG9yXCJcbmV4dGVybmFsIHNoaWZ0X2xlZnQgOiBpbnQzMiAtPiBpbnQgLT4gaW50MzIgPSBcIiVpbnQzMl9sc2xcIlxuZXh0ZXJuYWwgc2hpZnRfcmlnaHQgOiBpbnQzMiAtPiBpbnQgLT4gaW50MzIgPSBcIiVpbnQzMl9hc3JcIlxuZXh0ZXJuYWwgc2hpZnRfcmlnaHRfbG9naWNhbCA6IGludDMyIC0+IGludCAtPiBpbnQzMiA9IFwiJWludDMyX2xzclwiXG5leHRlcm5hbCBvZl9pbnQgOiBpbnQgLT4gaW50MzIgPSBcIiVpbnQzMl9vZl9pbnRcIlxuZXh0ZXJuYWwgdG9faW50IDogaW50MzIgLT4gaW50ID0gXCIlaW50MzJfdG9faW50XCJcbmV4dGVybmFsIG9mX2Zsb2F0IDogZmxvYXQgLT4gaW50MzJcbiAgPSBcImNhbWxfaW50MzJfb2ZfZmxvYXRcIiBcImNhbWxfaW50MzJfb2ZfZmxvYXRfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCB0b19mbG9hdCA6IGludDMyIC0+IGZsb2F0XG4gID0gXCJjYW1sX2ludDMyX3RvX2Zsb2F0XCIgXCJjYW1sX2ludDMyX3RvX2Zsb2F0X3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYml0c19vZl9mbG9hdCA6IGZsb2F0IC0+IGludDMyXG4gID0gXCJjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXRcIiBcImNhbWxfaW50MzJfYml0c19vZl9mbG9hdF91bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGZsb2F0X29mX2JpdHMgOiBpbnQzMiAtPiBmbG9hdFxuICA9IFwiY2FtbF9pbnQzMl9mbG9hdF9vZl9iaXRzXCIgXCJjYW1sX2ludDMyX2Zsb2F0X29mX2JpdHNfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5cbmxldCB6ZXJvID0gMGxcbmxldCBvbmUgPSAxbFxubGV0IG1pbnVzX29uZSA9IC0xbFxubGV0IHN1Y2MgbiA9IGFkZCBuIDFsXG5sZXQgcHJlZCBuID0gc3ViIG4gMWxcbmxldCBhYnMgbiA9IGlmIG4gPj0gMGwgdGhlbiBuIGVsc2UgbmVnIG5cbmxldCBtaW5faW50ID0gMHg4MDAwMDAwMGxcbmxldCBtYXhfaW50ID0gMHg3RkZGRkZGRmxcbmxldCBsb2dub3QgbiA9IGxvZ3hvciBuICgtMWwpXG5cbmxldCB1bnNpZ25lZF90b19pbnQgPVxuICBtYXRjaCBTeXMud29yZF9zaXplIHdpdGhcbiAgfCAzMiAtPlxuICAgICAgbGV0IG1heF9pbnQgPSBvZl9pbnQgU3RkbGliLm1heF9pbnQgaW5cbiAgICAgIGZ1biBuIC0+XG4gICAgICAgIGlmIGNvbXBhcmUgemVybyBuIDw9IDAgJiYgY29tcGFyZSBuIG1heF9pbnQgPD0gMCB0aGVuXG4gICAgICAgICAgU29tZSAodG9faW50IG4pXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBOb25lXG4gIHwgNjQgLT5cbiAgICAgICgqIFNvIHRoYXQgaXQgY29tcGlsZXMgaW4gMzItYml0ICopXG4gICAgICBsZXQgbWFzayA9IDB4RkZGRiBsc2wgMTYgbG9yIDB4RkZGRiBpblxuICAgICAgZnVuIG4gLT4gU29tZSAodG9faW50IG4gbGFuZCBtYXNrKVxuICB8IF8gLT5cbiAgICAgIGFzc2VydCBmYWxzZVxuXG5leHRlcm5hbCBmb3JtYXQgOiBzdHJpbmcgLT4gaW50MzIgLT4gc3RyaW5nID0gXCJjYW1sX2ludDMyX2Zvcm1hdFwiXG5sZXQgdG9fc3RyaW5nIG4gPSBmb3JtYXQgXCIlZFwiIG5cblxuZXh0ZXJuYWwgb2Zfc3RyaW5nIDogc3RyaW5nIC0+IGludDMyID0gXCJjYW1sX2ludDMyX29mX3N0cmluZ1wiXG5cbmxldCBvZl9zdHJpbmdfb3B0IHMgPVxuICAoKiBUT0RPOiBleHBvc2UgYSBub24tcmFpc2luZyBwcmltaXRpdmUgZGlyZWN0bHkuICopXG4gIHRyeSBTb21lIChvZl9zdHJpbmcgcylcbiAgd2l0aCBGYWlsdXJlIF8gLT4gTm9uZVxuXG50eXBlIHQgPSBpbnQzMlxuXG5sZXQgY29tcGFyZSAoeDogdCkgKHk6IHQpID0gU3RkbGliLmNvbXBhcmUgeCB5XG5sZXQgZXF1YWwgKHg6IHQpICh5OiB0KSA9IGNvbXBhcmUgeCB5ID0gMFxuXG5sZXQgdW5zaWduZWRfY29tcGFyZSBuIG0gPVxuICBjb21wYXJlIChzdWIgbiBtaW5faW50KSAoc3ViIG0gbWluX2ludClcblxubGV0IG1pbiB4IHkgOiB0ID0gaWYgeCA8PSB5IHRoZW4geCBlbHNlIHlcbmxldCBtYXggeCB5IDogdCA9IGlmIHggPj0geSB0aGVuIHggZWxzZSB5XG5cbigqIFVuc2lnbmVkIGRpdmlzaW9uIGZyb20gc2lnbmVkIGRpdmlzaW9uIG9mIHRoZSBzYW1lXG4gICBiaXRuZXNzLiBTZWUgV2FycmVuIEpyLiwgSGVucnkgUy4gKDIwMTMpLiBIYWNrZXIncyBEZWxpZ2h0ICgyIGVkLiksIFNlYyA5LTMuXG4qKVxubGV0IHVuc2lnbmVkX2RpdiBuIGQgPVxuICBpZiBkIDwgemVybyB0aGVuXG4gICAgaWYgdW5zaWduZWRfY29tcGFyZSBuIGQgPCAwIHRoZW4gemVybyBlbHNlIG9uZVxuICBlbHNlXG4gICAgbGV0IHEgPSBzaGlmdF9sZWZ0IChkaXYgKHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgbiAxKSBkKSAxIGluXG4gICAgbGV0IHIgPSBzdWIgbiAobXVsIHEgZCkgaW5cbiAgICBpZiB1bnNpZ25lZF9jb21wYXJlIHIgZCA+PSAwIHRoZW4gc3VjYyBxIGVsc2UgcVxuXG5sZXQgdW5zaWduZWRfcmVtIG4gZCA9XG4gIHN1YiBuIChtdWwgKHVuc2lnbmVkX2RpdiBuIGQpIGQpXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIE1vZHVsZSBbSW50NjRdOiA2NC1iaXQgaW50ZWdlcnMgKilcblxuZXh0ZXJuYWwgbmVnIDogaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9uZWdcIlxuZXh0ZXJuYWwgYWRkIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9hZGRcIlxuZXh0ZXJuYWwgc3ViIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9zdWJcIlxuZXh0ZXJuYWwgbXVsIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9tdWxcIlxuZXh0ZXJuYWwgZGl2IDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9kaXZcIlxuZXh0ZXJuYWwgcmVtIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9tb2RcIlxuZXh0ZXJuYWwgbG9nYW5kIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9hbmRcIlxuZXh0ZXJuYWwgbG9nb3IgOiBpbnQ2NCAtPiBpbnQ2NCAtPiBpbnQ2NCA9IFwiJWludDY0X29yXCJcbmV4dGVybmFsIGxvZ3hvciA6IGludDY0IC0+IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfeG9yXCJcbmV4dGVybmFsIHNoaWZ0X2xlZnQgOiBpbnQ2NCAtPiBpbnQgLT4gaW50NjQgPSBcIiVpbnQ2NF9sc2xcIlxuZXh0ZXJuYWwgc2hpZnRfcmlnaHQgOiBpbnQ2NCAtPiBpbnQgLT4gaW50NjQgPSBcIiVpbnQ2NF9hc3JcIlxuZXh0ZXJuYWwgc2hpZnRfcmlnaHRfbG9naWNhbCA6IGludDY0IC0+IGludCAtPiBpbnQ2NCA9IFwiJWludDY0X2xzclwiXG5leHRlcm5hbCBvZl9pbnQgOiBpbnQgLT4gaW50NjQgPSBcIiVpbnQ2NF9vZl9pbnRcIlxuZXh0ZXJuYWwgdG9faW50IDogaW50NjQgLT4gaW50ID0gXCIlaW50NjRfdG9faW50XCJcbmV4dGVybmFsIG9mX2Zsb2F0IDogZmxvYXQgLT4gaW50NjRcbiAgPSBcImNhbWxfaW50NjRfb2ZfZmxvYXRcIiBcImNhbWxfaW50NjRfb2ZfZmxvYXRfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCB0b19mbG9hdCA6IGludDY0IC0+IGZsb2F0XG4gID0gXCJjYW1sX2ludDY0X3RvX2Zsb2F0XCIgXCJjYW1sX2ludDY0X3RvX2Zsb2F0X3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgb2ZfaW50MzIgOiBpbnQzMiAtPiBpbnQ2NCA9IFwiJWludDY0X29mX2ludDMyXCJcbmV4dGVybmFsIHRvX2ludDMyIDogaW50NjQgLT4gaW50MzIgPSBcIiVpbnQ2NF90b19pbnQzMlwiXG5leHRlcm5hbCBvZl9uYXRpdmVpbnQgOiBuYXRpdmVpbnQgLT4gaW50NjQgPSBcIiVpbnQ2NF9vZl9uYXRpdmVpbnRcIlxuZXh0ZXJuYWwgdG9fbmF0aXZlaW50IDogaW50NjQgLT4gbmF0aXZlaW50ID0gXCIlaW50NjRfdG9fbmF0aXZlaW50XCJcblxubGV0IHplcm8gPSAwTFxubGV0IG9uZSA9IDFMXG5sZXQgbWludXNfb25lID0gLTFMXG5sZXQgc3VjYyBuID0gYWRkIG4gMUxcbmxldCBwcmVkIG4gPSBzdWIgbiAxTFxubGV0IGFicyBuID0gaWYgbiA+PSAwTCB0aGVuIG4gZWxzZSBuZWcgblxubGV0IG1pbl9pbnQgPSAweDgwMDAwMDAwMDAwMDAwMDBMXG5sZXQgbWF4X2ludCA9IDB4N0ZGRkZGRkZGRkZGRkZGRkxcbmxldCBsb2dub3QgbiA9IGxvZ3hvciBuICgtMUwpXG5cbmxldCB1bnNpZ25lZF90b19pbnQgPVxuICBsZXQgbWF4X2ludCA9IG9mX2ludCBTdGRsaWIubWF4X2ludCBpblxuICBmdW4gbiAtPlxuICAgIGlmIGNvbXBhcmUgemVybyBuIDw9IDAgJiYgY29tcGFyZSBuIG1heF9pbnQgPD0gMCB0aGVuXG4gICAgICBTb21lICh0b19pbnQgbilcbiAgICBlbHNlXG4gICAgICBOb25lXG5cbmV4dGVybmFsIGZvcm1hdCA6IHN0cmluZyAtPiBpbnQ2NCAtPiBzdHJpbmcgPSBcImNhbWxfaW50NjRfZm9ybWF0XCJcbmxldCB0b19zdHJpbmcgbiA9IGZvcm1hdCBcIiVkXCIgblxuXG5leHRlcm5hbCBvZl9zdHJpbmcgOiBzdHJpbmcgLT4gaW50NjQgPSBcImNhbWxfaW50NjRfb2Zfc3RyaW5nXCJcblxubGV0IG9mX3N0cmluZ19vcHQgcyA9XG4gICgqIFRPRE86IGV4cG9zZSBhIG5vbi1yYWlzaW5nIHByaW1pdGl2ZSBkaXJlY3RseS4gKilcbiAgdHJ5IFNvbWUgKG9mX3N0cmluZyBzKVxuICB3aXRoIEZhaWx1cmUgXyAtPiBOb25lXG5cblxuXG5leHRlcm5hbCBiaXRzX29mX2Zsb2F0IDogZmxvYXQgLT4gaW50NjRcbiAgPSBcImNhbWxfaW50NjRfYml0c19vZl9mbG9hdFwiIFwiY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0X3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZmxvYXRfb2ZfYml0cyA6IGludDY0IC0+IGZsb2F0XG4gID0gXCJjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHNcIiBcImNhbWxfaW50NjRfZmxvYXRfb2ZfYml0c191bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cblxudHlwZSB0ID0gaW50NjRcblxubGV0IGNvbXBhcmUgKHg6IHQpICh5OiB0KSA9IFN0ZGxpYi5jb21wYXJlIHggeVxubGV0IGVxdWFsICh4OiB0KSAoeTogdCkgPSBjb21wYXJlIHggeSA9IDBcblxubGV0IHVuc2lnbmVkX2NvbXBhcmUgbiBtID1cbiAgY29tcGFyZSAoc3ViIG4gbWluX2ludCkgKHN1YiBtIG1pbl9pbnQpXG5cbmxldCBtaW4geCB5IDogdCA9IGlmIHggPD0geSB0aGVuIHggZWxzZSB5XG5sZXQgbWF4IHggeSA6IHQgPSBpZiB4ID49IHkgdGhlbiB4IGVsc2UgeVxuXG4oKiBVbnNpZ25lZCBkaXZpc2lvbiBmcm9tIHNpZ25lZCBkaXZpc2lvbiBvZiB0aGUgc2FtZVxuICAgYml0bmVzcy4gU2VlIFdhcnJlbiBKci4sIEhlbnJ5IFMuICgyMDEzKS4gSGFja2VyJ3MgRGVsaWdodCAoMiBlZC4pLCBTZWMgOS0zLlxuKilcbmxldCB1bnNpZ25lZF9kaXYgbiBkID1cbiAgaWYgZCA8IHplcm8gdGhlblxuICAgIGlmIHVuc2lnbmVkX2NvbXBhcmUgbiBkIDwgMCB0aGVuIHplcm8gZWxzZSBvbmVcbiAgZWxzZVxuICAgIGxldCBxID0gc2hpZnRfbGVmdCAoZGl2IChzaGlmdF9yaWdodF9sb2dpY2FsIG4gMSkgZCkgMSBpblxuICAgIGxldCByID0gc3ViIG4gKG11bCBxIGQpIGluXG4gICAgaWYgdW5zaWduZWRfY29tcGFyZSByIGQgPj0gMCB0aGVuIHN1Y2MgcSBlbHNlIHFcblxubGV0IHVuc2lnbmVkX3JlbSBuIGQgPVxuICBzdWIgbiAobXVsICh1bnNpZ25lZF9kaXYgbiBkKSBkKVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBNb2R1bGUgW05hdGl2ZWludF06IHByb2Nlc3Nvci1uYXRpdmUgaW50ZWdlcnMgKilcblxuZXh0ZXJuYWwgbmVnOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X25lZ1wiXG5leHRlcm5hbCBhZGQ6IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X2FkZFwiXG5leHRlcm5hbCBzdWI6IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X3N1YlwiXG5leHRlcm5hbCBtdWw6IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X211bFwiXG5leHRlcm5hbCBkaXY6IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X2RpdlwiXG5leHRlcm5hbCByZW06IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X21vZFwiXG5leHRlcm5hbCBsb2dhbmQ6IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X2FuZFwiXG5leHRlcm5hbCBsb2dvcjogbmF0aXZlaW50IC0+IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfb3JcIlxuZXh0ZXJuYWwgbG9neG9yOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF94b3JcIlxuZXh0ZXJuYWwgc2hpZnRfbGVmdDogbmF0aXZlaW50IC0+IGludCAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfbHNsXCJcbmV4dGVybmFsIHNoaWZ0X3JpZ2h0OiBuYXRpdmVpbnQgLT4gaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9hc3JcIlxuZXh0ZXJuYWwgc2hpZnRfcmlnaHRfbG9naWNhbDogbmF0aXZlaW50IC0+IGludCAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfbHNyXCJcbmV4dGVybmFsIG9mX2ludDogaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9vZl9pbnRcIlxuZXh0ZXJuYWwgdG9faW50OiBuYXRpdmVpbnQgLT4gaW50ID0gXCIlbmF0aXZlaW50X3RvX2ludFwiXG5leHRlcm5hbCBvZl9mbG9hdCA6IGZsb2F0IC0+IG5hdGl2ZWludFxuICA9IFwiY2FtbF9uYXRpdmVpbnRfb2ZfZmxvYXRcIiBcImNhbWxfbmF0aXZlaW50X29mX2Zsb2F0X3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdG9fZmxvYXQgOiBuYXRpdmVpbnQgLT4gZmxvYXRcbiAgPSBcImNhbWxfbmF0aXZlaW50X3RvX2Zsb2F0XCIgXCJjYW1sX25hdGl2ZWludF90b19mbG9hdF91bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIG9mX2ludDMyOiBpbnQzMiAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfb2ZfaW50MzJcIlxuZXh0ZXJuYWwgdG9faW50MzI6IG5hdGl2ZWludCAtPiBpbnQzMiA9IFwiJW5hdGl2ZWludF90b19pbnQzMlwiXG5cbmxldCB6ZXJvID0gMG5cbmxldCBvbmUgPSAxblxubGV0IG1pbnVzX29uZSA9IC0xblxubGV0IHN1Y2MgbiA9IGFkZCBuIDFuXG5sZXQgcHJlZCBuID0gc3ViIG4gMW5cbmxldCBhYnMgbiA9IGlmIG4gPj0gMG4gdGhlbiBuIGVsc2UgbmVnIG5cbmxldCBzaXplID0gU3lzLndvcmRfc2l6ZVxubGV0IG1pbl9pbnQgPSBzaGlmdF9sZWZ0IDFuIChzaXplIC0gMSlcbmxldCBtYXhfaW50ID0gc3ViIG1pbl9pbnQgMW5cbmxldCBsb2dub3QgbiA9IGxvZ3hvciBuICgtMW4pXG5cbmxldCB1bnNpZ25lZF90b19pbnQgPVxuICBsZXQgbWF4X2ludCA9IG9mX2ludCBTdGRsaWIubWF4X2ludCBpblxuICBmdW4gbiAtPlxuICAgIGlmIGNvbXBhcmUgemVybyBuIDw9IDAgJiYgY29tcGFyZSBuIG1heF9pbnQgPD0gMCB0aGVuXG4gICAgICBTb21lICh0b19pbnQgbilcbiAgICBlbHNlXG4gICAgICBOb25lXG5cbmV4dGVybmFsIGZvcm1hdCA6IHN0cmluZyAtPiBuYXRpdmVpbnQgLT4gc3RyaW5nID0gXCJjYW1sX25hdGl2ZWludF9mb3JtYXRcIlxubGV0IHRvX3N0cmluZyBuID0gZm9ybWF0IFwiJWRcIiBuXG5cbmV4dGVybmFsIG9mX3N0cmluZzogc3RyaW5nIC0+IG5hdGl2ZWludCA9IFwiY2FtbF9uYXRpdmVpbnRfb2Zfc3RyaW5nXCJcblxubGV0IG9mX3N0cmluZ19vcHQgcyA9XG4gICgqIFRPRE86IGV4cG9zZSBhIG5vbi1yYWlzaW5nIHByaW1pdGl2ZSBkaXJlY3RseS4gKilcbiAgdHJ5IFNvbWUgKG9mX3N0cmluZyBzKVxuICB3aXRoIEZhaWx1cmUgXyAtPiBOb25lXG5cbnR5cGUgdCA9IG5hdGl2ZWludFxuXG5sZXQgY29tcGFyZSAoeDogdCkgKHk6IHQpID0gU3RkbGliLmNvbXBhcmUgeCB5XG5sZXQgZXF1YWwgKHg6IHQpICh5OiB0KSA9IGNvbXBhcmUgeCB5ID0gMFxuXG5sZXQgdW5zaWduZWRfY29tcGFyZSBuIG0gPVxuICBjb21wYXJlIChzdWIgbiBtaW5faW50KSAoc3ViIG0gbWluX2ludClcblxubGV0IG1pbiB4IHkgOiB0ID0gaWYgeCA8PSB5IHRoZW4geCBlbHNlIHlcbmxldCBtYXggeCB5IDogdCA9IGlmIHggPj0geSB0aGVuIHggZWxzZSB5XG5cbigqIFVuc2lnbmVkIGRpdmlzaW9uIGZyb20gc2lnbmVkIGRpdmlzaW9uIG9mIHRoZSBzYW1lXG4gICBiaXRuZXNzLiBTZWUgV2FycmVuIEpyLiwgSGVucnkgUy4gKDIwMTMpLiBIYWNrZXIncyBEZWxpZ2h0ICgyIGVkLiksIFNlYyA5LTMuXG4qKVxubGV0IHVuc2lnbmVkX2RpdiBuIGQgPVxuICBpZiBkIDwgemVybyB0aGVuXG4gICAgaWYgdW5zaWduZWRfY29tcGFyZSBuIGQgPCAwIHRoZW4gemVybyBlbHNlIG9uZVxuICBlbHNlXG4gICAgbGV0IHEgPSBzaGlmdF9sZWZ0IChkaXYgKHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgbiAxKSBkKSAxIGluXG4gICAgbGV0IHIgPSBzdWIgbiAobXVsIHEgZCkgaW5cbiAgICBpZiB1bnNpZ25lZF9jb21wYXJlIHIgZCA+PSAwIHRoZW4gc3VjYyBxIGVsc2UgcVxuXG5sZXQgdW5zaWduZWRfcmVtIG4gZCA9XG4gIHN1YiBuIChtdWwgKHVuc2lnbmVkX2RpdiBuIGQpIGQpXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIFRoZSBydW4tdGltZSBsaWJyYXJ5IGZvciBsZXhlcnMgZ2VuZXJhdGVkIGJ5IGNhbWxsZXggKilcblxudHlwZSBwb3NpdGlvbiA9IHtcbiAgcG9zX2ZuYW1lIDogc3RyaW5nO1xuICBwb3NfbG51bSA6IGludDtcbiAgcG9zX2JvbCA6IGludDtcbiAgcG9zX2NudW0gOiBpbnQ7XG59XG5cbmxldCBkdW1teV9wb3MgPSB7XG4gIHBvc19mbmFtZSA9IFwiXCI7XG4gIHBvc19sbnVtID0gMDtcbiAgcG9zX2JvbCA9IDA7XG4gIHBvc19jbnVtID0gLTE7XG59XG5cbnR5cGUgbGV4YnVmID1cbiAgeyByZWZpbGxfYnVmZiA6IGxleGJ1ZiAtPiB1bml0O1xuICAgIG11dGFibGUgbGV4X2J1ZmZlciA6IGJ5dGVzO1xuICAgIG11dGFibGUgbGV4X2J1ZmZlcl9sZW4gOiBpbnQ7XG4gICAgbXV0YWJsZSBsZXhfYWJzX3BvcyA6IGludDtcbiAgICBtdXRhYmxlIGxleF9zdGFydF9wb3MgOiBpbnQ7XG4gICAgbXV0YWJsZSBsZXhfY3Vycl9wb3MgOiBpbnQ7XG4gICAgbXV0YWJsZSBsZXhfbGFzdF9wb3MgOiBpbnQ7XG4gICAgbXV0YWJsZSBsZXhfbGFzdF9hY3Rpb24gOiBpbnQ7XG4gICAgbXV0YWJsZSBsZXhfZW9mX3JlYWNoZWQgOiBib29sO1xuICAgIG11dGFibGUgbGV4X21lbSA6IGludCBhcnJheTtcbiAgICBtdXRhYmxlIGxleF9zdGFydF9wIDogcG9zaXRpb247XG4gICAgbXV0YWJsZSBsZXhfY3Vycl9wIDogcG9zaXRpb247XG4gIH1cblxudHlwZSBsZXhfdGFibGVzID1cbiAgeyBsZXhfYmFzZTogc3RyaW5nO1xuICAgIGxleF9iYWNrdHJrOiBzdHJpbmc7XG4gICAgbGV4X2RlZmF1bHQ6IHN0cmluZztcbiAgICBsZXhfdHJhbnM6IHN0cmluZztcbiAgICBsZXhfY2hlY2s6IHN0cmluZztcbiAgICBsZXhfYmFzZV9jb2RlIDogc3RyaW5nO1xuICAgIGxleF9iYWNrdHJrX2NvZGUgOiBzdHJpbmc7XG4gICAgbGV4X2RlZmF1bHRfY29kZSA6IHN0cmluZztcbiAgICBsZXhfdHJhbnNfY29kZSA6IHN0cmluZztcbiAgICBsZXhfY2hlY2tfY29kZSA6IHN0cmluZztcbiAgICBsZXhfY29kZTogc3RyaW5nO31cblxuZXh0ZXJuYWwgY19lbmdpbmUgOiBsZXhfdGFibGVzIC0+IGludCAtPiBsZXhidWYgLT4gaW50ID0gXCJjYW1sX2xleF9lbmdpbmVcIlxuZXh0ZXJuYWwgY19uZXdfZW5naW5lIDogbGV4X3RhYmxlcyAtPiBpbnQgLT4gbGV4YnVmIC0+IGludFxuICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX25ld19sZXhfZW5naW5lXCJcblxubGV0IGVuZ2luZSB0Ymwgc3RhdGUgYnVmID1cbiAgbGV0IHJlc3VsdCA9IGNfZW5naW5lIHRibCBzdGF0ZSBidWYgaW5cbiAgaWYgcmVzdWx0ID49IDAgJiYgYnVmLmxleF9jdXJyX3AgIT0gZHVtbXlfcG9zIHRoZW4gYmVnaW5cbiAgICBidWYubGV4X3N0YXJ0X3AgPC0gYnVmLmxleF9jdXJyX3A7XG4gICAgYnVmLmxleF9jdXJyX3AgPC0ge2J1Zi5sZXhfY3Vycl9wXG4gICAgICAgICAgICAgICAgICAgICAgIHdpdGggcG9zX2NudW0gPSBidWYubGV4X2Fic19wb3MgKyBidWYubGV4X2N1cnJfcG9zfTtcbiAgZW5kO1xuICByZXN1bHRcblxuXG5sZXQgbmV3X2VuZ2luZSB0Ymwgc3RhdGUgYnVmID1cbiAgbGV0IHJlc3VsdCA9IGNfbmV3X2VuZ2luZSB0Ymwgc3RhdGUgYnVmIGluXG4gIGlmIHJlc3VsdCA+PSAwICYmIGJ1Zi5sZXhfY3Vycl9wICE9IGR1bW15X3BvcyB0aGVuIGJlZ2luXG4gICAgYnVmLmxleF9zdGFydF9wIDwtIGJ1Zi5sZXhfY3Vycl9wO1xuICAgIGJ1Zi5sZXhfY3Vycl9wIDwtIHtidWYubGV4X2N1cnJfcFxuICAgICAgICAgICAgICAgICAgICAgICB3aXRoIHBvc19jbnVtID0gYnVmLmxleF9hYnNfcG9zICsgYnVmLmxleF9jdXJyX3Bvc307XG4gIGVuZDtcbiAgcmVzdWx0XG5cbmxldCBsZXhfcmVmaWxsIHJlYWRfZnVuIGF1eF9idWZmZXIgbGV4YnVmID1cbiAgbGV0IHJlYWQgPVxuICAgIHJlYWRfZnVuIGF1eF9idWZmZXIgKEJ5dGVzLmxlbmd0aCBhdXhfYnVmZmVyKSBpblxuICBsZXQgbiA9XG4gICAgaWYgcmVhZCA+IDBcbiAgICB0aGVuIHJlYWRcbiAgICBlbHNlIChsZXhidWYubGV4X2VvZl9yZWFjaGVkIDwtIHRydWU7IDApIGluXG4gICgqIEN1cnJlbnQgc3RhdGUgb2YgdGhlIGJ1ZmZlcjpcbiAgICAgICAgPC0tLS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tPlxuICAgICAgICB8ICBqdW5rIHwgICAgICB2YWxpZCBkYXRhICAgICB8ICAganVuayAgICB8XG4gICAgICAgIF4gICAgICAgXiAgICAgICAgICAgICAgICAgICAgIF4gICAgICAgICAgIF5cbiAgICAgICAgMCAgICBzdGFydF9wb3MgICAgICAgICAgICAgYnVmZmVyX2VuZCAgICBCeXRlcy5sZW5ndGggYnVmZmVyXG4gICopXG4gIGlmIGxleGJ1Zi5sZXhfYnVmZmVyX2xlbiArIG4gPiBCeXRlcy5sZW5ndGggbGV4YnVmLmxleF9idWZmZXIgdGhlbiBiZWdpblxuICAgICgqIFRoZXJlIGlzIG5vdCBlbm91Z2ggc3BhY2UgYXQgdGhlIGVuZCBvZiB0aGUgYnVmZmVyICopXG4gICAgaWYgbGV4YnVmLmxleF9idWZmZXJfbGVuIC0gbGV4YnVmLmxleF9zdGFydF9wb3MgKyBuXG4gICAgICAgPD0gQnl0ZXMubGVuZ3RoIGxleGJ1Zi5sZXhfYnVmZmVyXG4gICAgdGhlbiBiZWdpblxuICAgICAgKCogQnV0IHRoZXJlIGlzIGVub3VnaCBzcGFjZSBpZiB3ZSByZWNsYWltIHRoZSBqdW5rIGF0IHRoZSBiZWdpbm5pbmdcbiAgICAgICAgIG9mIHRoZSBidWZmZXIgKilcbiAgICAgIEJ5dGVzLmJsaXQgbGV4YnVmLmxleF9idWZmZXIgbGV4YnVmLmxleF9zdGFydF9wb3NcbiAgICAgICAgICAgICAgICAgIGxleGJ1Zi5sZXhfYnVmZmVyIDBcbiAgICAgICAgICAgICAgICAgIChsZXhidWYubGV4X2J1ZmZlcl9sZW4gLSBsZXhidWYubGV4X3N0YXJ0X3BvcylcbiAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgKCogV2UgbXVzdCBncm93IHRoZSBidWZmZXIuICBEb3VibGluZyBpdHMgc2l6ZSB3aWxsIHByb3ZpZGUgZW5vdWdoXG4gICAgICAgICBzcGFjZSBzaW5jZSBuIDw9IFN0cmluZy5sZW5ndGggYXV4X2J1ZmZlciA8PSBTdHJpbmcubGVuZ3RoIGJ1ZmZlci5cbiAgICAgICAgIFdhdGNoIG91dCBmb3Igc3RyaW5nIGxlbmd0aCBvdmVyZmxvdywgdGhvdWdoLiAqKVxuICAgICAgbGV0IG5ld2xlbiA9XG4gICAgICAgIEludC5taW4gKDIgKiBCeXRlcy5sZW5ndGggbGV4YnVmLmxleF9idWZmZXIpIFN5cy5tYXhfc3RyaW5nX2xlbmd0aCBpblxuICAgICAgaWYgbGV4YnVmLmxleF9idWZmZXJfbGVuIC0gbGV4YnVmLmxleF9zdGFydF9wb3MgKyBuID4gbmV3bGVuXG4gICAgICB0aGVuIGZhaWx3aXRoIFwiTGV4aW5nLmxleF9yZWZpbGw6IGNhbm5vdCBncm93IGJ1ZmZlclwiO1xuICAgICAgbGV0IG5ld2J1ZiA9IEJ5dGVzLmNyZWF0ZSBuZXdsZW4gaW5cbiAgICAgICgqIENvcHkgdGhlIHZhbGlkIGRhdGEgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgbmV3IGJ1ZmZlciAqKVxuICAgICAgQnl0ZXMuYmxpdCBsZXhidWYubGV4X2J1ZmZlciBsZXhidWYubGV4X3N0YXJ0X3Bvc1xuICAgICAgICAgICAgICAgICAgbmV3YnVmIDBcbiAgICAgICAgICAgICAgICAgIChsZXhidWYubGV4X2J1ZmZlcl9sZW4gLSBsZXhidWYubGV4X3N0YXJ0X3Bvcyk7XG4gICAgICBsZXhidWYubGV4X2J1ZmZlciA8LSBuZXdidWZcbiAgICBlbmQ7XG4gICAgKCogUmVhbGxvY2F0aW9uIG9yIG5vdCwgd2UgaGF2ZSBzaGlmdGVkIHRoZSBkYXRhIGxlZnQgYnlcbiAgICAgICBzdGFydF9wb3MgY2hhcmFjdGVyczsgdXBkYXRlIHRoZSBwb3NpdGlvbnMgKilcbiAgICBsZXQgcyA9IGxleGJ1Zi5sZXhfc3RhcnRfcG9zIGluXG4gICAgbGV4YnVmLmxleF9hYnNfcG9zIDwtIGxleGJ1Zi5sZXhfYWJzX3BvcyArIHM7XG4gICAgbGV4YnVmLmxleF9jdXJyX3BvcyA8LSBsZXhidWYubGV4X2N1cnJfcG9zIC0gcztcbiAgICBsZXhidWYubGV4X3N0YXJ0X3BvcyA8LSAwO1xuICAgIGxleGJ1Zi5sZXhfbGFzdF9wb3MgPC0gbGV4YnVmLmxleF9sYXN0X3BvcyAtIHM7XG4gICAgbGV4YnVmLmxleF9idWZmZXJfbGVuIDwtIGxleGJ1Zi5sZXhfYnVmZmVyX2xlbiAtIHMgO1xuICAgIGxldCB0ID0gbGV4YnVmLmxleF9tZW0gaW5cbiAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIHQtMSBkb1xuICAgICAgbGV0IHYgPSB0LihpKSBpblxuICAgICAgaWYgdiA+PSAwIHRoZW5cbiAgICAgICAgdC4oaSkgPC0gdi1zXG4gICAgZG9uZVxuICBlbmQ7XG4gICgqIFRoZXJlIGlzIG5vdyBlbm91Z2ggc3BhY2UgYXQgdGhlIGVuZCBvZiB0aGUgYnVmZmVyICopXG4gIEJ5dGVzLmJsaXQgYXV4X2J1ZmZlciAwIGxleGJ1Zi5sZXhfYnVmZmVyIGxleGJ1Zi5sZXhfYnVmZmVyX2xlbiBuO1xuICBsZXhidWYubGV4X2J1ZmZlcl9sZW4gPC0gbGV4YnVmLmxleF9idWZmZXJfbGVuICsgblxuXG5sZXQgemVyb19wb3MgPSB7XG4gIHBvc19mbmFtZSA9IFwiXCI7XG4gIHBvc19sbnVtID0gMTtcbiAgcG9zX2JvbCA9IDA7XG4gIHBvc19jbnVtID0gMDtcbn1cblxubGV0IGZyb21fZnVuY3Rpb24gPyh3aXRoX3Bvc2l0aW9ucyA9IHRydWUpIGYgPVxuICB7IHJlZmlsbF9idWZmID0gbGV4X3JlZmlsbCBmIChCeXRlcy5jcmVhdGUgNTEyKTtcbiAgICBsZXhfYnVmZmVyID0gQnl0ZXMuY3JlYXRlIDEwMjQ7XG4gICAgbGV4X2J1ZmZlcl9sZW4gPSAwO1xuICAgIGxleF9hYnNfcG9zID0gMDtcbiAgICBsZXhfc3RhcnRfcG9zID0gMDtcbiAgICBsZXhfY3Vycl9wb3MgPSAwO1xuICAgIGxleF9sYXN0X3BvcyA9IDA7XG4gICAgbGV4X2xhc3RfYWN0aW9uID0gMDtcbiAgICBsZXhfbWVtID0gW3x8XTtcbiAgICBsZXhfZW9mX3JlYWNoZWQgPSBmYWxzZTtcbiAgICBsZXhfc3RhcnRfcCA9IGlmIHdpdGhfcG9zaXRpb25zIHRoZW4gemVyb19wb3MgZWxzZSBkdW1teV9wb3M7XG4gICAgbGV4X2N1cnJfcCA9IGlmIHdpdGhfcG9zaXRpb25zIHRoZW4gemVyb19wb3MgZWxzZSBkdW1teV9wb3M7XG4gIH1cblxubGV0IGZyb21fY2hhbm5lbCA/d2l0aF9wb3NpdGlvbnMgaWMgPVxuICBmcm9tX2Z1bmN0aW9uID93aXRoX3Bvc2l0aW9ucyAoZnVuIGJ1ZiBuIC0+IGlucHV0IGljIGJ1ZiAwIG4pXG5cbmxldCBmcm9tX3N0cmluZyA/KHdpdGhfcG9zaXRpb25zID0gdHJ1ZSkgcyA9XG4gIHsgcmVmaWxsX2J1ZmYgPSAoZnVuIGxleGJ1ZiAtPiBsZXhidWYubGV4X2VvZl9yZWFjaGVkIDwtIHRydWUpO1xuICAgIGxleF9idWZmZXIgPSBCeXRlcy5vZl9zdHJpbmcgczsgKCogaGF2ZSB0byBtYWtlIGEgY29weSBmb3IgY29tcGF0aWJpbGl0eVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2l0aCB1bnNhZmUtc3RyaW5nIG1vZGUgKilcbiAgICBsZXhfYnVmZmVyX2xlbiA9IFN0cmluZy5sZW5ndGggcztcbiAgICBsZXhfYWJzX3BvcyA9IDA7XG4gICAgbGV4X3N0YXJ0X3BvcyA9IDA7XG4gICAgbGV4X2N1cnJfcG9zID0gMDtcbiAgICBsZXhfbGFzdF9wb3MgPSAwO1xuICAgIGxleF9sYXN0X2FjdGlvbiA9IDA7XG4gICAgbGV4X21lbSA9IFt8fF07XG4gICAgbGV4X2VvZl9yZWFjaGVkID0gdHJ1ZTtcbiAgICBsZXhfc3RhcnRfcCA9IGlmIHdpdGhfcG9zaXRpb25zIHRoZW4gemVyb19wb3MgZWxzZSBkdW1teV9wb3M7XG4gICAgbGV4X2N1cnJfcCA9IGlmIHdpdGhfcG9zaXRpb25zIHRoZW4gemVyb19wb3MgZWxzZSBkdW1teV9wb3M7XG4gIH1cblxubGV0IHNldF9wb3NpdGlvbiBsZXhidWYgcG9zaXRpb24gPVxuICBsZXhidWYubGV4X2N1cnJfcCAgPC0ge3Bvc2l0aW9uIHdpdGggcG9zX2ZuYW1lID0gbGV4YnVmLmxleF9jdXJyX3AucG9zX2ZuYW1lfTtcbiAgbGV4YnVmLmxleF9hYnNfcG9zIDwtIHBvc2l0aW9uLnBvc19jbnVtXG5cbmxldCBzZXRfZmlsZW5hbWUgbGV4YnVmIGZuYW1lID1cbiAgbGV4YnVmLmxleF9jdXJyX3AgPC0ge2xleGJ1Zi5sZXhfY3Vycl9wIHdpdGggcG9zX2ZuYW1lID0gZm5hbWV9XG5cbmxldCB3aXRoX3Bvc2l0aW9ucyBsZXhidWYgPSBsZXhidWYubGV4X2N1cnJfcCAhPSBkdW1teV9wb3NcblxubGV0IGxleGVtZSBsZXhidWYgPVxuICBsZXQgbGVuID0gbGV4YnVmLmxleF9jdXJyX3BvcyAtIGxleGJ1Zi5sZXhfc3RhcnRfcG9zIGluXG4gIEJ5dGVzLnN1Yl9zdHJpbmcgbGV4YnVmLmxleF9idWZmZXIgbGV4YnVmLmxleF9zdGFydF9wb3MgbGVuXG5cbmxldCBzdWJfbGV4ZW1lIGxleGJ1ZiBpMSBpMiA9XG4gIGxldCBsZW4gPSBpMi1pMSBpblxuICBCeXRlcy5zdWJfc3RyaW5nIGxleGJ1Zi5sZXhfYnVmZmVyIGkxIGxlblxuXG5sZXQgc3ViX2xleGVtZV9vcHQgbGV4YnVmIGkxIGkyID1cbiAgaWYgaTEgPj0gMCB0aGVuIGJlZ2luXG4gICAgbGV0IGxlbiA9IGkyLWkxIGluXG4gICAgU29tZSAoQnl0ZXMuc3ViX3N0cmluZyBsZXhidWYubGV4X2J1ZmZlciBpMSBsZW4pXG4gIGVuZCBlbHNlIGJlZ2luXG4gICAgTm9uZVxuICBlbmRcblxubGV0IHN1Yl9sZXhlbWVfY2hhciBsZXhidWYgaSA9IEJ5dGVzLmdldCBsZXhidWYubGV4X2J1ZmZlciBpXG5cbmxldCBzdWJfbGV4ZW1lX2NoYXJfb3B0IGxleGJ1ZiBpID1cbiAgaWYgaSA+PSAwIHRoZW5cbiAgICBTb21lIChCeXRlcy5nZXQgbGV4YnVmLmxleF9idWZmZXIgaSlcbiAgZWxzZVxuICAgIE5vbmVcblxuXG5sZXQgbGV4ZW1lX2NoYXIgbGV4YnVmIGkgPVxuICBCeXRlcy5nZXQgbGV4YnVmLmxleF9idWZmZXIgKGxleGJ1Zi5sZXhfc3RhcnRfcG9zICsgaSlcblxubGV0IGxleGVtZV9zdGFydCBsZXhidWYgPSBsZXhidWYubGV4X3N0YXJ0X3AucG9zX2NudW1cbmxldCBsZXhlbWVfZW5kIGxleGJ1ZiA9IGxleGJ1Zi5sZXhfY3Vycl9wLnBvc19jbnVtXG5cbmxldCBsZXhlbWVfc3RhcnRfcCBsZXhidWYgPSBsZXhidWYubGV4X3N0YXJ0X3BcbmxldCBsZXhlbWVfZW5kX3AgbGV4YnVmID0gbGV4YnVmLmxleF9jdXJyX3BcblxubGV0IG5ld19saW5lIGxleGJ1ZiA9XG4gIGxldCBsY3AgPSBsZXhidWYubGV4X2N1cnJfcCBpblxuICBpZiBsY3AgIT0gZHVtbXlfcG9zIHRoZW5cbiAgICBsZXhidWYubGV4X2N1cnJfcCA8LVxuICAgICAgeyBsY3Agd2l0aFxuICAgICAgICBwb3NfbG51bSA9IGxjcC5wb3NfbG51bSArIDE7XG4gICAgICAgIHBvc19ib2wgPSBsY3AucG9zX2NudW07XG4gICAgICB9XG5cblxuXG4oKiBEaXNjYXJkIGRhdGEgbGVmdCBpbiBsZXhlciBidWZmZXIuICopXG5cbmxldCBmbHVzaF9pbnB1dCBsYiA9XG4gIGxiLmxleF9jdXJyX3BvcyA8LSAwO1xuICBsYi5sZXhfYWJzX3BvcyA8LSAwO1xuICBsZXQgbGNwID0gbGIubGV4X2N1cnJfcCBpblxuICBpZiBsY3AgIT0gZHVtbXlfcG9zIHRoZW5cbiAgICBsYi5sZXhfY3Vycl9wIDwtIHt6ZXJvX3BvcyB3aXRoIHBvc19mbmFtZSA9IGxjcC5wb3NfZm5hbWV9O1xuICBsYi5sZXhfYnVmZmVyX2xlbiA8LSAwO1xuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBUaGUgcGFyc2luZyBlbmdpbmUgKilcblxub3BlbiBMZXhpbmdcblxuKCogSW50ZXJuYWwgaW50ZXJmYWNlIHRvIHRoZSBwYXJzaW5nIGVuZ2luZSAqKVxuXG50eXBlIHBhcnNlcl9lbnYgPVxuICB7IG11dGFibGUgc19zdGFjayA6IGludCBhcnJheTsgICAgICAgICgqIFN0YXRlcyAqKVxuICAgIG11dGFibGUgdl9zdGFjayA6IE9iai50IGFycmF5OyAgICAgICgqIFNlbWFudGljIGF0dHJpYnV0ZXMgKilcbiAgICBtdXRhYmxlIHN5bWJfc3RhcnRfc3RhY2sgOiBwb3NpdGlvbiBhcnJheTsgKCogU3RhcnQgcG9zaXRpb25zICopXG4gICAgbXV0YWJsZSBzeW1iX2VuZF9zdGFjayA6IHBvc2l0aW9uIGFycmF5OyAgICgqIEVuZCBwb3NpdGlvbnMgKilcbiAgICBtdXRhYmxlIHN0YWNrc2l6ZSA6IGludDsgICAgICAgICAgICAoKiBTaXplIG9mIHRoZSBzdGFja3MgKilcbiAgICBtdXRhYmxlIHN0YWNrYmFzZSA6IGludDsgICAgICAgICAgICAoKiBCYXNlIHNwIGZvciBjdXJyZW50IHBhcnNlICopXG4gICAgbXV0YWJsZSBjdXJyX2NoYXIgOiBpbnQ7ICAgICAgICAgICAgKCogTGFzdCB0b2tlbiByZWFkICopXG4gICAgbXV0YWJsZSBsdmFsIDogT2JqLnQ7ICAgICAgICAgICAgICAgKCogSXRzIHNlbWFudGljIGF0dHJpYnV0ZSAqKVxuICAgIG11dGFibGUgc3ltYl9zdGFydCA6IHBvc2l0aW9uOyAgICAgICgqIFN0YXJ0IHBvcy4gb2YgdGhlIGN1cnJlbnQgc3ltYm9sKilcbiAgICBtdXRhYmxlIHN5bWJfZW5kIDogcG9zaXRpb247ICAgICAgICAoKiBFbmQgcG9zLiBvZiB0aGUgY3VycmVudCBzeW1ib2wgKilcbiAgICBtdXRhYmxlIGFzcCA6IGludDsgICAgICAgICAgICAgICAgICAoKiBUaGUgc3RhY2sgcG9pbnRlciBmb3IgYXR0cmlidXRlcyAqKVxuICAgIG11dGFibGUgcnVsZV9sZW4gOiBpbnQ7ICAgICAgICAgICAgICgqIE51bWJlciBvZiByaHMgaXRlbXMgaW4gdGhlIHJ1bGUgKilcbiAgICBtdXRhYmxlIHJ1bGVfbnVtYmVyIDogaW50OyAgICAgICAgICAoKiBSdWxlIG51bWJlciB0byByZWR1Y2UgYnkgKilcbiAgICBtdXRhYmxlIHNwIDogaW50OyAgICAgICAgICAgICAgICAgICAoKiBTYXZlZCBzcCBmb3IgcGFyc2VfZW5naW5lICopXG4gICAgbXV0YWJsZSBzdGF0ZSA6IGludDsgICAgICAgICAgICAgICAgKCogU2F2ZWQgc3RhdGUgZm9yIHBhcnNlX2VuZ2luZSAqKVxuICAgIG11dGFibGUgZXJyZmxhZyA6IGludCB9ICAgICAgICAgICAgICgqIFNhdmVkIGVycm9yIGZsYWcgZm9yIHBhcnNlX2VuZ2luZSAqKVxuW0BAd2FybmluZyBcIi11bnVzZWQtZmllbGRcIl1cblxudHlwZSBwYXJzZV90YWJsZXMgPVxuICB7IGFjdGlvbnMgOiAocGFyc2VyX2VudiAtPiBPYmoudCkgYXJyYXk7XG4gICAgdHJhbnNsX2NvbnN0IDogaW50IGFycmF5O1xuICAgIHRyYW5zbF9ibG9jayA6IGludCBhcnJheTtcbiAgICBsaHMgOiBzdHJpbmc7XG4gICAgbGVuIDogc3RyaW5nO1xuICAgIGRlZnJlZCA6IHN0cmluZztcbiAgICBkZ290byA6IHN0cmluZztcbiAgICBzaW5kZXggOiBzdHJpbmc7XG4gICAgcmluZGV4IDogc3RyaW5nO1xuICAgIGdpbmRleCA6IHN0cmluZztcbiAgICB0YWJsZXNpemUgOiBpbnQ7XG4gICAgdGFibGUgOiBzdHJpbmc7XG4gICAgY2hlY2sgOiBzdHJpbmc7XG4gICAgZXJyb3JfZnVuY3Rpb24gOiBzdHJpbmcgLT4gdW5pdDtcbiAgICBuYW1lc19jb25zdCA6IHN0cmluZztcbiAgICBuYW1lc19ibG9jayA6IHN0cmluZyB9XG5cbmV4Y2VwdGlvbiBZWWV4aXQgb2YgT2JqLnRcbmV4Y2VwdGlvbiBQYXJzZV9lcnJvclxuXG50eXBlIHBhcnNlcl9pbnB1dCA9XG4gICAgU3RhcnRcbiAgfCBUb2tlbl9yZWFkXG4gIHwgU3RhY2tzX2dyb3duXzFcbiAgfCBTdGFja3NfZ3Jvd25fMlxuICB8IFNlbWFudGljX2FjdGlvbl9jb21wdXRlZFxuICB8IEVycm9yX2RldGVjdGVkXG5cbnR5cGUgcGFyc2VyX291dHB1dCA9XG4gICAgUmVhZF90b2tlblxuICB8IFJhaXNlX3BhcnNlX2Vycm9yXG4gIHwgR3Jvd19zdGFja3NfMVxuICB8IEdyb3dfc3RhY2tzXzJcbiAgfCBDb21wdXRlX3NlbWFudGljX2FjdGlvblxuICB8IENhbGxfZXJyb3JfZnVuY3Rpb25cblxuKCogdG8gYXZvaWQgd2FybmluZ3MgKilcbmxldCBfID0gW1JlYWRfdG9rZW47IFJhaXNlX3BhcnNlX2Vycm9yOyBHcm93X3N0YWNrc18xOyBHcm93X3N0YWNrc18yO1xuICAgICAgICAgQ29tcHV0ZV9zZW1hbnRpY19hY3Rpb247IENhbGxfZXJyb3JfZnVuY3Rpb25dXG5cbmV4dGVybmFsIHBhcnNlX2VuZ2luZSA6XG4gICAgcGFyc2VfdGFibGVzIC0+IHBhcnNlcl9lbnYgLT4gcGFyc2VyX2lucHV0IC0+IE9iai50IC0+IHBhcnNlcl9vdXRwdXRcbiAgICA9IFwiY2FtbF9wYXJzZV9lbmdpbmVcIlxuXG5leHRlcm5hbCBzZXRfdHJhY2U6IGJvb2wgLT4gYm9vbFxuICAgID0gXCJjYW1sX3NldF9wYXJzZXJfdHJhY2VcIlxuXG5sZXQgZW52ID1cbiAgeyBzX3N0YWNrID0gQXJyYXkubWFrZSAxMDAgMDtcbiAgICB2X3N0YWNrID0gQXJyYXkubWFrZSAxMDAgKE9iai5yZXByICgpKTtcbiAgICBzeW1iX3N0YXJ0X3N0YWNrID0gQXJyYXkubWFrZSAxMDAgZHVtbXlfcG9zO1xuICAgIHN5bWJfZW5kX3N0YWNrID0gQXJyYXkubWFrZSAxMDAgZHVtbXlfcG9zO1xuICAgIHN0YWNrc2l6ZSA9IDEwMDtcbiAgICBzdGFja2Jhc2UgPSAwO1xuICAgIGN1cnJfY2hhciA9IDA7XG4gICAgbHZhbCA9IE9iai5yZXByICgpO1xuICAgIHN5bWJfc3RhcnQgPSBkdW1teV9wb3M7XG4gICAgc3ltYl9lbmQgPSBkdW1teV9wb3M7XG4gICAgYXNwID0gMDtcbiAgICBydWxlX2xlbiA9IDA7XG4gICAgcnVsZV9udW1iZXIgPSAwO1xuICAgIHNwID0gMDtcbiAgICBzdGF0ZSA9IDA7XG4gICAgZXJyZmxhZyA9IDAgfVxuXG5sZXQgZ3Jvd19zdGFja3MoKSA9XG4gIGxldCBvbGRzaXplID0gZW52LnN0YWNrc2l6ZSBpblxuICBsZXQgbmV3c2l6ZSA9IG9sZHNpemUgKiAyIGluXG4gIGxldCBuZXdfcyA9IEFycmF5Lm1ha2UgbmV3c2l6ZSAwXG4gIGFuZCBuZXdfdiA9IEFycmF5Lm1ha2UgbmV3c2l6ZSAoT2JqLnJlcHIgKCkpXG4gIGFuZCBuZXdfc3RhcnQgPSBBcnJheS5tYWtlIG5ld3NpemUgZHVtbXlfcG9zXG4gIGFuZCBuZXdfZW5kID0gQXJyYXkubWFrZSBuZXdzaXplIGR1bW15X3BvcyBpblxuICAgIEFycmF5LmJsaXQgZW52LnNfc3RhY2sgMCBuZXdfcyAwIG9sZHNpemU7XG4gICAgZW52LnNfc3RhY2sgPC0gbmV3X3M7XG4gICAgQXJyYXkuYmxpdCBlbnYudl9zdGFjayAwIG5ld192IDAgb2xkc2l6ZTtcbiAgICBlbnYudl9zdGFjayA8LSBuZXdfdjtcbiAgICBBcnJheS5ibGl0IGVudi5zeW1iX3N0YXJ0X3N0YWNrIDAgbmV3X3N0YXJ0IDAgb2xkc2l6ZTtcbiAgICBlbnYuc3ltYl9zdGFydF9zdGFjayA8LSBuZXdfc3RhcnQ7XG4gICAgQXJyYXkuYmxpdCBlbnYuc3ltYl9lbmRfc3RhY2sgMCBuZXdfZW5kIDAgb2xkc2l6ZTtcbiAgICBlbnYuc3ltYl9lbmRfc3RhY2sgPC0gbmV3X2VuZDtcbiAgICBlbnYuc3RhY2tzaXplIDwtIG5ld3NpemVcblxubGV0IGNsZWFyX3BhcnNlcigpID1cbiAgQXJyYXkuZmlsbCBlbnYudl9zdGFjayAwIGVudi5zdGFja3NpemUgKE9iai5yZXByICgpKTtcbiAgZW52Lmx2YWwgPC0gT2JqLnJlcHIgKClcblxubGV0IGN1cnJlbnRfbG9va2FoZWFkX2Z1biA9IHJlZiAoZnVuIChfIDogT2JqLnQpIC0+IGZhbHNlKVxuXG5sZXQgeXlwYXJzZSB0YWJsZXMgc3RhcnQgbGV4ZXIgbGV4YnVmID1cbiAgbGV0IHJlYyBsb29wIGNtZCBhcmcgPVxuICAgIG1hdGNoIHBhcnNlX2VuZ2luZSB0YWJsZXMgZW52IGNtZCBhcmcgd2l0aFxuICAgICAgUmVhZF90b2tlbiAtPlxuICAgICAgICBsZXQgdCA9IE9iai5yZXByKGxleGVyIGxleGJ1ZikgaW5cbiAgICAgICAgZW52LnN5bWJfc3RhcnQgPC0gbGV4YnVmLmxleF9zdGFydF9wO1xuICAgICAgICBlbnYuc3ltYl9lbmQgPC0gbGV4YnVmLmxleF9jdXJyX3A7XG4gICAgICAgIGxvb3AgVG9rZW5fcmVhZCB0XG4gICAgfCBSYWlzZV9wYXJzZV9lcnJvciAtPlxuICAgICAgICByYWlzZSBQYXJzZV9lcnJvclxuICAgIHwgQ29tcHV0ZV9zZW1hbnRpY19hY3Rpb24gLT5cbiAgICAgICAgbGV0IChhY3Rpb24sIHZhbHVlKSA9XG4gICAgICAgICAgdHJ5XG4gICAgICAgICAgICAoU2VtYW50aWNfYWN0aW9uX2NvbXB1dGVkLCB0YWJsZXMuYWN0aW9ucy4oZW52LnJ1bGVfbnVtYmVyKSBlbnYpXG4gICAgICAgICAgd2l0aCBQYXJzZV9lcnJvciAtPlxuICAgICAgICAgICAgKEVycm9yX2RldGVjdGVkLCBPYmoucmVwciAoKSkgaW5cbiAgICAgICAgbG9vcCBhY3Rpb24gdmFsdWVcbiAgICB8IEdyb3dfc3RhY2tzXzEgLT5cbiAgICAgICAgZ3Jvd19zdGFja3MoKTsgbG9vcCBTdGFja3NfZ3Jvd25fMSAoT2JqLnJlcHIgKCkpXG4gICAgfCBHcm93X3N0YWNrc18yIC0+XG4gICAgICAgIGdyb3dfc3RhY2tzKCk7IGxvb3AgU3RhY2tzX2dyb3duXzIgKE9iai5yZXByICgpKVxuICAgIHwgQ2FsbF9lcnJvcl9mdW5jdGlvbiAtPlxuICAgICAgICB0YWJsZXMuZXJyb3JfZnVuY3Rpb24gXCJzeW50YXggZXJyb3JcIjtcbiAgICAgICAgbG9vcCBFcnJvcl9kZXRlY3RlZCAoT2JqLnJlcHIgKCkpIGluXG4gIGxldCBpbml0X2FzcCA9IGVudi5hc3BcbiAgYW5kIGluaXRfc3AgPSBlbnYuc3BcbiAgYW5kIGluaXRfc3RhY2tiYXNlID0gZW52LnN0YWNrYmFzZVxuICBhbmQgaW5pdF9zdGF0ZSA9IGVudi5zdGF0ZVxuICBhbmQgaW5pdF9jdXJyX2NoYXIgPSBlbnYuY3Vycl9jaGFyXG4gIGFuZCBpbml0X2x2YWwgPSBlbnYubHZhbFxuICBhbmQgaW5pdF9lcnJmbGFnID0gZW52LmVycmZsYWcgaW5cbiAgZW52LnN0YWNrYmFzZSA8LSBlbnYuc3AgKyAxO1xuICBlbnYuY3Vycl9jaGFyIDwtIHN0YXJ0O1xuICBlbnYuc3ltYl9lbmQgPC0gbGV4YnVmLmxleF9jdXJyX3A7XG4gIHRyeVxuICAgIGxvb3AgU3RhcnQgKE9iai5yZXByICgpKVxuICB3aXRoIGV4biAtPlxuICAgIGxldCBjdXJyX2NoYXIgPSBlbnYuY3Vycl9jaGFyIGluXG4gICAgZW52LmFzcCA8LSBpbml0X2FzcDtcbiAgICBlbnYuc3AgPC0gaW5pdF9zcDtcbiAgICBlbnYuc3RhY2tiYXNlIDwtIGluaXRfc3RhY2tiYXNlO1xuICAgIGVudi5zdGF0ZSA8LSBpbml0X3N0YXRlO1xuICAgIGVudi5jdXJyX2NoYXIgPC0gaW5pdF9jdXJyX2NoYXI7XG4gICAgZW52Lmx2YWwgPC0gaW5pdF9sdmFsO1xuICAgIGVudi5lcnJmbGFnIDwtIGluaXRfZXJyZmxhZztcbiAgICBtYXRjaCBleG4gd2l0aFxuICAgICAgWVlleGl0IHYgLT5cbiAgICAgICAgT2JqLm1hZ2ljIHZcbiAgICB8IF8gLT5cbiAgICAgICAgY3VycmVudF9sb29rYWhlYWRfZnVuIDo9XG4gICAgICAgICAgKGZ1biB0b2sgLT5cbiAgICAgICAgICAgIGlmIE9iai5pc19ibG9jayB0b2tcbiAgICAgICAgICAgIHRoZW4gdGFibGVzLnRyYW5zbF9ibG9jay4oT2JqLnRhZyB0b2spID0gY3Vycl9jaGFyXG4gICAgICAgICAgICBlbHNlIHRhYmxlcy50cmFuc2xfY29uc3QuKE9iai5tYWdpYyB0b2spID0gY3Vycl9jaGFyKTtcbiAgICAgICAgcmFpc2UgZXhuXG5cbmxldCBwZWVrX3ZhbCBlbnYgbiA9XG4gIE9iai5tYWdpYyBlbnYudl9zdGFjay4oZW52LmFzcCAtIG4pXG5cbmxldCBzeW1ib2xfc3RhcnRfcG9zICgpID1cbiAgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPD0gMCB0aGVuIGVudi5zeW1iX2VuZF9zdGFjay4oZW52LmFzcClcbiAgICBlbHNlIGJlZ2luXG4gICAgICBsZXQgc3QgPSBlbnYuc3ltYl9zdGFydF9zdGFjay4oZW52LmFzcCAtIGkgKyAxKSBpblxuICAgICAgbGV0IGVuID0gZW52LnN5bWJfZW5kX3N0YWNrLihlbnYuYXNwIC0gaSArIDEpIGluXG4gICAgICBpZiBzdCA8PiBlbiB0aGVuIHN0IGVsc2UgbG9vcCAoaSAtIDEpXG4gICAgZW5kXG4gIGluXG4gIGxvb3AgZW52LnJ1bGVfbGVuXG5cbmxldCBzeW1ib2xfZW5kX3BvcyAoKSA9IGVudi5zeW1iX2VuZF9zdGFjay4oZW52LmFzcClcbmxldCByaHNfc3RhcnRfcG9zIG4gPSBlbnYuc3ltYl9zdGFydF9zdGFjay4oZW52LmFzcCAtIChlbnYucnVsZV9sZW4gLSBuKSlcbmxldCByaHNfZW5kX3BvcyBuID0gZW52LnN5bWJfZW5kX3N0YWNrLihlbnYuYXNwIC0gKGVudi5ydWxlX2xlbiAtIG4pKVxuXG5sZXQgc3ltYm9sX3N0YXJ0ICgpID0gKHN5bWJvbF9zdGFydF9wb3MgKCkpLnBvc19jbnVtXG5sZXQgc3ltYm9sX2VuZCAoKSA9IChzeW1ib2xfZW5kX3BvcyAoKSkucG9zX2NudW1cbmxldCByaHNfc3RhcnQgbiA9IChyaHNfc3RhcnRfcG9zIG4pLnBvc19jbnVtXG5sZXQgcmhzX2VuZCBuID0gKHJoc19lbmRfcG9zIG4pLnBvc19jbnVtXG5cbmxldCBpc19jdXJyZW50X2xvb2thaGVhZCB0b2sgPVxuICAoIWN1cnJlbnRfbG9va2FoZWFkX2Z1bikoT2JqLnJlcHIgdG9rKVxuXG5sZXQgcGFyc2VfZXJyb3IgKF8gOiBzdHJpbmcpID0gKClcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogU2V0cyBvdmVyIG9yZGVyZWQgdHlwZXMgKilcblxubW9kdWxlIHR5cGUgT3JkZXJlZFR5cGUgPVxuICBzaWdcbiAgICB0eXBlIHRcbiAgICB2YWwgY29tcGFyZTogdCAtPiB0IC0+IGludFxuICBlbmRcblxubW9kdWxlIHR5cGUgUyA9XG4gIHNpZ1xuICAgIHR5cGUgZWx0XG4gICAgdHlwZSB0XG4gICAgdmFsIGVtcHR5OiB0XG4gICAgdmFsIGlzX2VtcHR5OiB0IC0+IGJvb2xcbiAgICB2YWwgbWVtOiBlbHQgLT4gdCAtPiBib29sXG4gICAgdmFsIGFkZDogZWx0IC0+IHQgLT4gdFxuICAgIHZhbCBzaW5nbGV0b246IGVsdCAtPiB0XG4gICAgdmFsIHJlbW92ZTogZWx0IC0+IHQgLT4gdFxuICAgIHZhbCB1bmlvbjogdCAtPiB0IC0+IHRcbiAgICB2YWwgaW50ZXI6IHQgLT4gdCAtPiB0XG4gICAgdmFsIGRpc2pvaW50OiB0IC0+IHQgLT4gYm9vbFxuICAgIHZhbCBkaWZmOiB0IC0+IHQgLT4gdFxuICAgIHZhbCBjb21wYXJlOiB0IC0+IHQgLT4gaW50XG4gICAgdmFsIGVxdWFsOiB0IC0+IHQgLT4gYm9vbFxuICAgIHZhbCBzdWJzZXQ6IHQgLT4gdCAtPiBib29sXG4gICAgdmFsIGl0ZXI6IChlbHQgLT4gdW5pdCkgLT4gdCAtPiB1bml0XG4gICAgdmFsIG1hcDogKGVsdCAtPiBlbHQpIC0+IHQgLT4gdFxuICAgIHZhbCBmb2xkOiAoZWx0IC0+ICdhIC0+ICdhKSAtPiB0IC0+ICdhIC0+ICdhXG4gICAgdmFsIGZvcl9hbGw6IChlbHQgLT4gYm9vbCkgLT4gdCAtPiBib29sXG4gICAgdmFsIGV4aXN0czogKGVsdCAtPiBib29sKSAtPiB0IC0+IGJvb2xcbiAgICB2YWwgZmlsdGVyOiAoZWx0IC0+IGJvb2wpIC0+IHQgLT4gdFxuICAgIHZhbCBmaWx0ZXJfbWFwOiAoZWx0IC0+IGVsdCBvcHRpb24pIC0+IHQgLT4gdFxuICAgIHZhbCBwYXJ0aXRpb246IChlbHQgLT4gYm9vbCkgLT4gdCAtPiB0ICogdFxuICAgIHZhbCBjYXJkaW5hbDogdCAtPiBpbnRcbiAgICB2YWwgZWxlbWVudHM6IHQgLT4gZWx0IGxpc3RcbiAgICB2YWwgbWluX2VsdDogdCAtPiBlbHRcbiAgICB2YWwgbWluX2VsdF9vcHQ6IHQgLT4gZWx0IG9wdGlvblxuICAgIHZhbCBtYXhfZWx0OiB0IC0+IGVsdFxuICAgIHZhbCBtYXhfZWx0X29wdDogdCAtPiBlbHQgb3B0aW9uXG4gICAgdmFsIGNob29zZTogdCAtPiBlbHRcbiAgICB2YWwgY2hvb3NlX29wdDogdCAtPiBlbHQgb3B0aW9uXG4gICAgdmFsIHNwbGl0OiBlbHQgLT4gdCAtPiB0ICogYm9vbCAqIHRcbiAgICB2YWwgZmluZDogZWx0IC0+IHQgLT4gZWx0XG4gICAgdmFsIGZpbmRfb3B0OiBlbHQgLT4gdCAtPiBlbHQgb3B0aW9uXG4gICAgdmFsIGZpbmRfZmlyc3Q6IChlbHQgLT4gYm9vbCkgLT4gdCAtPiBlbHRcbiAgICB2YWwgZmluZF9maXJzdF9vcHQ6IChlbHQgLT4gYm9vbCkgLT4gdCAtPiBlbHQgb3B0aW9uXG4gICAgdmFsIGZpbmRfbGFzdDogKGVsdCAtPiBib29sKSAtPiB0IC0+IGVsdFxuICAgIHZhbCBmaW5kX2xhc3Rfb3B0OiAoZWx0IC0+IGJvb2wpIC0+IHQgLT4gZWx0IG9wdGlvblxuICAgIHZhbCBvZl9saXN0OiBlbHQgbGlzdCAtPiB0XG4gICAgdmFsIHRvX3NlcV9mcm9tIDogZWx0IC0+IHQgLT4gZWx0IFNlcS50XG4gICAgdmFsIHRvX3NlcSA6IHQgLT4gZWx0IFNlcS50XG4gICAgdmFsIHRvX3Jldl9zZXEgOiB0IC0+IGVsdCBTZXEudFxuICAgIHZhbCBhZGRfc2VxIDogZWx0IFNlcS50IC0+IHQgLT4gdFxuICAgIHZhbCBvZl9zZXEgOiBlbHQgU2VxLnQgLT4gdFxuICBlbmRcblxubW9kdWxlIE1ha2UoT3JkOiBPcmRlcmVkVHlwZSkgPVxuICBzdHJ1Y3RcbiAgICB0eXBlIGVsdCA9IE9yZC50XG4gICAgdHlwZSB0ID0gRW1wdHkgfCBOb2RlIG9mIHtsOnQ7IHY6ZWx0OyByOnQ7IGg6aW50fVxuXG4gICAgKCogU2V0cyBhcmUgcmVwcmVzZW50ZWQgYnkgYmFsYW5jZWQgYmluYXJ5IHRyZWVzICh0aGUgaGVpZ2h0cyBvZiB0aGVcbiAgICAgICBjaGlsZHJlbiBkaWZmZXIgYnkgYXQgbW9zdCAyICopXG5cbiAgICBsZXQgaGVpZ2h0ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gMFxuICAgICAgfCBOb2RlIHtofSAtPiBoXG5cbiAgICAoKiBDcmVhdGVzIGEgbmV3IG5vZGUgd2l0aCBsZWZ0IHNvbiBsLCB2YWx1ZSB2IGFuZCByaWdodCBzb24gci5cbiAgICAgICBXZSBtdXN0IGhhdmUgYWxsIGVsZW1lbnRzIG9mIGwgPCB2IDwgYWxsIGVsZW1lbnRzIG9mIHIuXG4gICAgICAgbCBhbmQgciBtdXN0IGJlIGJhbGFuY2VkIGFuZCB8IGhlaWdodCBsIC0gaGVpZ2h0IHIgfCA8PSAyLlxuICAgICAgIElubGluZSBleHBhbnNpb24gb2YgaGVpZ2h0IGZvciBiZXR0ZXIgc3BlZWQuICopXG5cbiAgICBsZXQgY3JlYXRlIGwgdiByID1cbiAgICAgIGxldCBobCA9IG1hdGNoIGwgd2l0aCBFbXB0eSAtPiAwIHwgTm9kZSB7aH0gLT4gaCBpblxuICAgICAgbGV0IGhyID0gbWF0Y2ggciB3aXRoIEVtcHR5IC0+IDAgfCBOb2RlIHtofSAtPiBoIGluXG4gICAgICBOb2Rle2w7IHY7IHI7IGg9KGlmIGhsID49IGhyIHRoZW4gaGwgKyAxIGVsc2UgaHIgKyAxKX1cblxuICAgICgqIFNhbWUgYXMgY3JlYXRlLCBidXQgcGVyZm9ybXMgb25lIHN0ZXAgb2YgcmViYWxhbmNpbmcgaWYgbmVjZXNzYXJ5LlxuICAgICAgIEFzc3VtZXMgbCBhbmQgciBiYWxhbmNlZCBhbmQgfCBoZWlnaHQgbCAtIGhlaWdodCByIHwgPD0gMy5cbiAgICAgICBJbmxpbmUgZXhwYW5zaW9uIG9mIGNyZWF0ZSBmb3IgYmV0dGVyIHNwZWVkIGluIHRoZSBtb3N0IGZyZXF1ZW50IGNhc2VcbiAgICAgICB3aGVyZSBubyByZWJhbGFuY2luZyBpcyByZXF1aXJlZC4gKilcblxuICAgIGxldCBiYWwgbCB2IHIgPVxuICAgICAgbGV0IGhsID0gbWF0Y2ggbCB3aXRoIEVtcHR5IC0+IDAgfCBOb2RlIHtofSAtPiBoIGluXG4gICAgICBsZXQgaHIgPSBtYXRjaCByIHdpdGggRW1wdHkgLT4gMCB8IE5vZGUge2h9IC0+IGggaW5cbiAgICAgIGlmIGhsID4gaHIgKyAyIHRoZW4gYmVnaW5cbiAgICAgICAgbWF0Y2ggbCB3aXRoXG4gICAgICAgICAgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJTZXQuYmFsXCJcbiAgICAgICAgfCBOb2Rle2w9bGw7IHY9bHY7IHI9bHJ9IC0+XG4gICAgICAgICAgICBpZiBoZWlnaHQgbGwgPj0gaGVpZ2h0IGxyIHRoZW5cbiAgICAgICAgICAgICAgY3JlYXRlIGxsIGx2IChjcmVhdGUgbHIgdiByKVxuICAgICAgICAgICAgZWxzZSBiZWdpblxuICAgICAgICAgICAgICBtYXRjaCBsciB3aXRoXG4gICAgICAgICAgICAgICAgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJTZXQuYmFsXCJcbiAgICAgICAgICAgICAgfCBOb2Rle2w9bHJsOyB2PWxydjsgcj1scnJ9LT5cbiAgICAgICAgICAgICAgICAgIGNyZWF0ZSAoY3JlYXRlIGxsIGx2IGxybCkgbHJ2IChjcmVhdGUgbHJyIHYgcilcbiAgICAgICAgICAgIGVuZFxuICAgICAgZW5kIGVsc2UgaWYgaHIgPiBobCArIDIgdGhlbiBiZWdpblxuICAgICAgICBtYXRjaCByIHdpdGhcbiAgICAgICAgICBFbXB0eSAtPiBpbnZhbGlkX2FyZyBcIlNldC5iYWxcIlxuICAgICAgICB8IE5vZGV7bD1ybDsgdj1ydjsgcj1ycn0gLT5cbiAgICAgICAgICAgIGlmIGhlaWdodCByciA+PSBoZWlnaHQgcmwgdGhlblxuICAgICAgICAgICAgICBjcmVhdGUgKGNyZWF0ZSBsIHYgcmwpIHJ2IHJyXG4gICAgICAgICAgICBlbHNlIGJlZ2luXG4gICAgICAgICAgICAgIG1hdGNoIHJsIHdpdGhcbiAgICAgICAgICAgICAgICBFbXB0eSAtPiBpbnZhbGlkX2FyZyBcIlNldC5iYWxcIlxuICAgICAgICAgICAgICB8IE5vZGV7bD1ybGw7IHY9cmx2OyByPXJscn0gLT5cbiAgICAgICAgICAgICAgICAgIGNyZWF0ZSAoY3JlYXRlIGwgdiBybGwpIHJsdiAoY3JlYXRlIHJsciBydiBycilcbiAgICAgICAgICAgIGVuZFxuICAgICAgZW5kIGVsc2VcbiAgICAgICAgTm9kZXtsOyB2OyByOyBoPShpZiBobCA+PSBociB0aGVuIGhsICsgMSBlbHNlIGhyICsgMSl9XG5cbiAgICAoKiBJbnNlcnRpb24gb2Ygb25lIGVsZW1lbnQgKilcblxuICAgIGxldCByZWMgYWRkIHggPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBOb2Rle2w9RW1wdHk7IHY9eDsgcj1FbXB0eTsgaD0xfVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IGFzIHQgLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gdCBlbHNlXG4gICAgICAgICAgaWYgYyA8IDAgdGhlblxuICAgICAgICAgICAgbGV0IGxsID0gYWRkIHggbCBpblxuICAgICAgICAgICAgaWYgbCA9PSBsbCB0aGVuIHQgZWxzZSBiYWwgbGwgdiByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbGV0IHJyID0gYWRkIHggciBpblxuICAgICAgICAgICAgaWYgciA9PSByciB0aGVuIHQgZWxzZSBiYWwgbCB2IHJyXG5cbiAgICBsZXQgc2luZ2xldG9uIHggPSBOb2Rle2w9RW1wdHk7IHY9eDsgcj1FbXB0eTsgaD0xfVxuXG4gICAgKCogQmV3YXJlOiB0aG9zZSB0d28gZnVuY3Rpb25zIGFzc3VtZSB0aGF0IHRoZSBhZGRlZCB2IGlzICpzdHJpY3RseSpcbiAgICAgICBzbWFsbGVyIChvciBiaWdnZXIpIHRoYW4gYWxsIHRoZSBwcmVzZW50IGVsZW1lbnRzIGluIHRoZSB0cmVlOyBpdFxuICAgICAgIGRvZXMgbm90IHRlc3QgZm9yIGVxdWFsaXR5IHdpdGggdGhlIGN1cnJlbnQgbWluIChvciBtYXgpIGVsZW1lbnQuXG4gICAgICAgSW5kZWVkLCB0aGV5IGFyZSBvbmx5IHVzZWQgZHVyaW5nIHRoZSBcImpvaW5cIiBvcGVyYXRpb24gd2hpY2hcbiAgICAgICByZXNwZWN0cyB0aGlzIHByZWNvbmRpdGlvbi5cbiAgICAqKVxuXG4gICAgbGV0IHJlYyBhZGRfbWluX2VsZW1lbnQgeCA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+IHNpbmdsZXRvbiB4XG4gICAgICB8IE5vZGUge2w7IHY7IHJ9IC0+XG4gICAgICAgIGJhbCAoYWRkX21pbl9lbGVtZW50IHggbCkgdiByXG5cbiAgICBsZXQgcmVjIGFkZF9tYXhfZWxlbWVudCB4ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT4gc2luZ2xldG9uIHhcbiAgICAgIHwgTm9kZSB7bDsgdjsgcn0gLT5cbiAgICAgICAgYmFsIGwgdiAoYWRkX21heF9lbGVtZW50IHggcilcblxuICAgICgqIFNhbWUgYXMgY3JlYXRlIGFuZCBiYWwsIGJ1dCBubyBhc3N1bXB0aW9ucyBhcmUgbWFkZSBvbiB0aGVcbiAgICAgICByZWxhdGl2ZSBoZWlnaHRzIG9mIGwgYW5kIHIuICopXG5cbiAgICBsZXQgcmVjIGpvaW4gbCB2IHIgPVxuICAgICAgbWF0Y2ggKGwsIHIpIHdpdGhcbiAgICAgICAgKEVtcHR5LCBfKSAtPiBhZGRfbWluX2VsZW1lbnQgdiByXG4gICAgICB8IChfLCBFbXB0eSkgLT4gYWRkX21heF9lbGVtZW50IHYgbFxuICAgICAgfCAoTm9kZXtsPWxsOyB2PWx2OyByPWxyOyBoPWxofSwgTm9kZXtsPXJsOyB2PXJ2OyByPXJyOyBoPXJofSkgLT5cbiAgICAgICAgICBpZiBsaCA+IHJoICsgMiB0aGVuIGJhbCBsbCBsdiAoam9pbiBsciB2IHIpIGVsc2VcbiAgICAgICAgICBpZiByaCA+IGxoICsgMiB0aGVuIGJhbCAoam9pbiBsIHYgcmwpIHJ2IHJyIGVsc2VcbiAgICAgICAgICBjcmVhdGUgbCB2IHJcblxuICAgICgqIFNtYWxsZXN0IGFuZCBncmVhdGVzdCBlbGVtZW50IG9mIGEgc2V0ICopXG5cbiAgICBsZXQgcmVjIG1pbl9lbHQgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgTm9kZXtsPUVtcHR5OyB2fSAtPiB2XG4gICAgICB8IE5vZGV7bH0gLT4gbWluX2VsdCBsXG5cbiAgICBsZXQgcmVjIG1pbl9lbHRfb3B0ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gTm9uZVxuICAgICAgfCBOb2Rle2w9RW1wdHk7IHZ9IC0+IFNvbWUgdlxuICAgICAgfCBOb2Rle2x9IC0+IG1pbl9lbHRfb3B0IGxcblxuICAgIGxldCByZWMgbWF4X2VsdCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBOb2Rle3Y7IHI9RW1wdHl9IC0+IHZcbiAgICAgIHwgTm9kZXtyfSAtPiBtYXhfZWx0IHJcblxuICAgIGxldCByZWMgbWF4X2VsdF9vcHQgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBOb25lXG4gICAgICB8IE5vZGV7djsgcj1FbXB0eX0gLT4gU29tZSB2XG4gICAgICB8IE5vZGV7cn0gLT4gbWF4X2VsdF9vcHQgclxuXG4gICAgKCogUmVtb3ZlIHRoZSBzbWFsbGVzdCBlbGVtZW50IG9mIHRoZSBnaXZlbiBzZXQgKilcblxuICAgIGxldCByZWMgcmVtb3ZlX21pbl9lbHQgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBpbnZhbGlkX2FyZyBcIlNldC5yZW1vdmVfbWluX2VsdFwiXG4gICAgICB8IE5vZGV7bD1FbXB0eTsgcn0gLT4gclxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+IGJhbCAocmVtb3ZlX21pbl9lbHQgbCkgdiByXG5cbiAgICAoKiBNZXJnZSB0d28gdHJlZXMgbCBhbmQgciBpbnRvIG9uZS5cbiAgICAgICBBbGwgZWxlbWVudHMgb2YgbCBtdXN0IHByZWNlZGUgdGhlIGVsZW1lbnRzIG9mIHIuXG4gICAgICAgQXNzdW1lIHwgaGVpZ2h0IGwgLSBoZWlnaHQgciB8IDw9IDIuICopXG5cbiAgICBsZXQgbWVyZ2UgdDEgdDIgPVxuICAgICAgbWF0Y2ggKHQxLCB0Mikgd2l0aFxuICAgICAgICAoRW1wdHksIHQpIC0+IHRcbiAgICAgIHwgKHQsIEVtcHR5KSAtPiB0XG4gICAgICB8IChfLCBfKSAtPiBiYWwgdDEgKG1pbl9lbHQgdDIpIChyZW1vdmVfbWluX2VsdCB0MilcblxuICAgICgqIE1lcmdlIHR3byB0cmVlcyBsIGFuZCByIGludG8gb25lLlxuICAgICAgIEFsbCBlbGVtZW50cyBvZiBsIG11c3QgcHJlY2VkZSB0aGUgZWxlbWVudHMgb2Ygci5cbiAgICAgICBObyBhc3N1bXB0aW9uIG9uIHRoZSBoZWlnaHRzIG9mIGwgYW5kIHIuICopXG5cbiAgICBsZXQgY29uY2F0IHQxIHQyID1cbiAgICAgIG1hdGNoICh0MSwgdDIpIHdpdGhcbiAgICAgICAgKEVtcHR5LCB0KSAtPiB0XG4gICAgICB8ICh0LCBFbXB0eSkgLT4gdFxuICAgICAgfCAoXywgXykgLT4gam9pbiB0MSAobWluX2VsdCB0MikgKHJlbW92ZV9taW5fZWx0IHQyKVxuXG4gICAgKCogU3BsaXR0aW5nLiAgc3BsaXQgeCBzIHJldHVybnMgYSB0cmlwbGUgKGwsIHByZXNlbnQsIHIpIHdoZXJlXG4gICAgICAgIC0gbCBpcyB0aGUgc2V0IG9mIGVsZW1lbnRzIG9mIHMgdGhhdCBhcmUgPCB4XG4gICAgICAgIC0gciBpcyB0aGUgc2V0IG9mIGVsZW1lbnRzIG9mIHMgdGhhdCBhcmUgPiB4XG4gICAgICAgIC0gcHJlc2VudCBpcyBmYWxzZSBpZiBzIGNvbnRhaW5zIG5vIGVsZW1lbnQgZXF1YWwgdG8geCxcbiAgICAgICAgICBvciB0cnVlIGlmIHMgY29udGFpbnMgYW4gZWxlbWVudCBlcXVhbCB0byB4LiAqKVxuXG4gICAgbGV0IHJlYyBzcGxpdCB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICAoRW1wdHksIGZhbHNlLCBFbXB0eSlcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiAobCwgdHJ1ZSwgcilcbiAgICAgICAgICBlbHNlIGlmIGMgPCAwIHRoZW5cbiAgICAgICAgICAgIGxldCAobGwsIHByZXMsIHJsKSA9IHNwbGl0IHggbCBpbiAobGwsIHByZXMsIGpvaW4gcmwgdiByKVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxldCAobHIsIHByZXMsIHJyKSA9IHNwbGl0IHggciBpbiAoam9pbiBsIHYgbHIsIHByZXMsIHJyKVxuXG4gICAgKCogSW1wbGVtZW50YXRpb24gb2YgdGhlIHNldCBvcGVyYXRpb25zICopXG5cbiAgICBsZXQgZW1wdHkgPSBFbXB0eVxuXG4gICAgbGV0IGlzX2VtcHR5ID0gZnVuY3Rpb24gRW1wdHkgLT4gdHJ1ZSB8IF8gLT4gZmFsc2VcblxuICAgIGxldCByZWMgbWVtIHggPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBmYWxzZVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBjID0gMCB8fCBtZW0geCAoaWYgYyA8IDAgdGhlbiBsIGVsc2UgcilcblxuICAgIGxldCByZWMgcmVtb3ZlIHggPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBFbXB0eVxuICAgICAgfCAoTm9kZXtsOyB2OyByfSBhcyB0KSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiBtZXJnZSBsIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBpZiBjIDwgMCB0aGVuXG4gICAgICAgICAgICAgIGxldCBsbCA9IHJlbW92ZSB4IGwgaW5cbiAgICAgICAgICAgICAgaWYgbCA9PSBsbCB0aGVuIHRcbiAgICAgICAgICAgICAgZWxzZSBiYWwgbGwgdiByXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGxldCByciA9IHJlbW92ZSB4IHIgaW5cbiAgICAgICAgICAgICAgaWYgciA9PSByciB0aGVuIHRcbiAgICAgICAgICAgICAgZWxzZSBiYWwgbCB2IHJyXG5cbiAgICBsZXQgcmVjIHVuaW9uIHMxIHMyID1cbiAgICAgIG1hdGNoIChzMSwgczIpIHdpdGhcbiAgICAgICAgKEVtcHR5LCB0MikgLT4gdDJcbiAgICAgIHwgKHQxLCBFbXB0eSkgLT4gdDFcbiAgICAgIHwgKE5vZGV7bD1sMTsgdj12MTsgcj1yMTsgaD1oMX0sIE5vZGV7bD1sMjsgdj12Mjsgcj1yMjsgaD1oMn0pIC0+XG4gICAgICAgICAgaWYgaDEgPj0gaDIgdGhlblxuICAgICAgICAgICAgaWYgaDIgPSAxIHRoZW4gYWRkIHYyIHMxIGVsc2UgYmVnaW5cbiAgICAgICAgICAgICAgbGV0IChsMiwgXywgcjIpID0gc3BsaXQgdjEgczIgaW5cbiAgICAgICAgICAgICAgam9pbiAodW5pb24gbDEgbDIpIHYxICh1bmlvbiByMSByMilcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGlmIGgxID0gMSB0aGVuIGFkZCB2MSBzMiBlbHNlIGJlZ2luXG4gICAgICAgICAgICAgIGxldCAobDEsIF8sIHIxKSA9IHNwbGl0IHYyIHMxIGluXG4gICAgICAgICAgICAgIGpvaW4gKHVuaW9uIGwxIGwyKSB2MiAodW5pb24gcjEgcjIpXG4gICAgICAgICAgICBlbmRcblxuICAgIGxldCByZWMgaW50ZXIgczEgczIgPVxuICAgICAgbWF0Y2ggKHMxLCBzMikgd2l0aFxuICAgICAgICAoRW1wdHksIF8pIC0+IEVtcHR5XG4gICAgICB8IChfLCBFbXB0eSkgLT4gRW1wdHlcbiAgICAgIHwgKE5vZGV7bD1sMTsgdj12MTsgcj1yMX0sIHQyKSAtPlxuICAgICAgICAgIG1hdGNoIHNwbGl0IHYxIHQyIHdpdGhcbiAgICAgICAgICAgIChsMiwgZmFsc2UsIHIyKSAtPlxuICAgICAgICAgICAgICBjb25jYXQgKGludGVyIGwxIGwyKSAoaW50ZXIgcjEgcjIpXG4gICAgICAgICAgfCAobDIsIHRydWUsIHIyKSAtPlxuICAgICAgICAgICAgICBqb2luIChpbnRlciBsMSBsMikgdjEgKGludGVyIHIxIHIyKVxuXG4gICAgKCogU2FtZSBhcyBzcGxpdCwgYnV0IGNvbXB1dGUgdGhlIGxlZnQgYW5kIHJpZ2h0IHN1YnRyZWVzXG4gICAgICAgb25seSBpZiB0aGUgcGl2b3QgZWxlbWVudCBpcyBub3QgaW4gdGhlIHNldC4gIFRoZSByaWdodCBzdWJ0cmVlXG4gICAgICAgaXMgY29tcHV0ZWQgb24gZGVtYW5kLiAqKVxuXG4gICAgdHlwZSBzcGxpdF9iaXMgPVxuICAgICAgfCBGb3VuZFxuICAgICAgfCBOb3RGb3VuZCBvZiB0ICogKHVuaXQgLT4gdClcblxuICAgIGxldCByZWMgc3BsaXRfYmlzIHggPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIE5vdEZvdW5kIChFbXB0eSwgKGZ1biAoKSAtPiBFbXB0eSkpXG4gICAgICB8IE5vZGV7bDsgdjsgcjsgX30gLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gRm91bmRcbiAgICAgICAgICBlbHNlIGlmIGMgPCAwIHRoZW5cbiAgICAgICAgICAgIG1hdGNoIHNwbGl0X2JpcyB4IGwgd2l0aFxuICAgICAgICAgICAgfCBGb3VuZCAtPiBGb3VuZFxuICAgICAgICAgICAgfCBOb3RGb3VuZCAobGwsIHJsKSAtPiBOb3RGb3VuZCAobGwsIChmdW4gKCkgLT4gam9pbiAocmwgKCkpIHYgcikpXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbWF0Y2ggc3BsaXRfYmlzIHggciB3aXRoXG4gICAgICAgICAgICB8IEZvdW5kIC0+IEZvdW5kXG4gICAgICAgICAgICB8IE5vdEZvdW5kIChsciwgcnIpIC0+IE5vdEZvdW5kIChqb2luIGwgdiBsciwgcnIpXG5cbiAgICBsZXQgcmVjIGRpc2pvaW50IHMxIHMyID1cbiAgICAgIG1hdGNoIChzMSwgczIpIHdpdGhcbiAgICAgICAgKEVtcHR5LCBfKSB8IChfLCBFbXB0eSkgLT4gdHJ1ZVxuICAgICAgfCAoTm9kZXtsPWwxOyB2PXYxOyByPXIxfSwgdDIpIC0+XG4gICAgICAgICAgaWYgczEgPT0gczIgdGhlbiBmYWxzZVxuICAgICAgICAgIGVsc2UgbWF0Y2ggc3BsaXRfYmlzIHYxIHQyIHdpdGhcbiAgICAgICAgICAgICAgTm90Rm91bmQobDIsIHIyKSAtPiBkaXNqb2ludCBsMSBsMiAmJiBkaXNqb2ludCByMSAocjIgKCkpXG4gICAgICAgICAgICB8IEZvdW5kIC0+IGZhbHNlXG5cbiAgICBsZXQgcmVjIGRpZmYgczEgczIgPVxuICAgICAgbWF0Y2ggKHMxLCBzMikgd2l0aFxuICAgICAgICAoRW1wdHksIF8pIC0+IEVtcHR5XG4gICAgICB8ICh0MSwgRW1wdHkpIC0+IHQxXG4gICAgICB8IChOb2Rle2w9bDE7IHY9djE7IHI9cjF9LCB0MikgLT5cbiAgICAgICAgICBtYXRjaCBzcGxpdCB2MSB0MiB3aXRoXG4gICAgICAgICAgICAobDIsIGZhbHNlLCByMikgLT5cbiAgICAgICAgICAgICAgam9pbiAoZGlmZiBsMSBsMikgdjEgKGRpZmYgcjEgcjIpXG4gICAgICAgICAgfCAobDIsIHRydWUsIHIyKSAtPlxuICAgICAgICAgICAgICBjb25jYXQgKGRpZmYgbDEgbDIpIChkaWZmIHIxIHIyKVxuXG4gICAgdHlwZSBlbnVtZXJhdGlvbiA9IEVuZCB8IE1vcmUgb2YgZWx0ICogdCAqIGVudW1lcmF0aW9uXG5cbiAgICBsZXQgcmVjIGNvbnNfZW51bSBzIGUgPVxuICAgICAgbWF0Y2ggcyB3aXRoXG4gICAgICAgIEVtcHR5IC0+IGVcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPiBjb25zX2VudW0gbCAoTW9yZSh2LCByLCBlKSlcblxuICAgIGxldCByZWMgY29tcGFyZV9hdXggZTEgZTIgPVxuICAgICAgICBtYXRjaCAoZTEsIGUyKSB3aXRoXG4gICAgICAgIChFbmQsIEVuZCkgLT4gMFxuICAgICAgfCAoRW5kLCBfKSAgLT4gLTFcbiAgICAgIHwgKF8sIEVuZCkgLT4gMVxuICAgICAgfCAoTW9yZSh2MSwgcjEsIGUxKSwgTW9yZSh2MiwgcjIsIGUyKSkgLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHYxIHYyIGluXG4gICAgICAgICAgaWYgYyA8PiAwXG4gICAgICAgICAgdGhlbiBjXG4gICAgICAgICAgZWxzZSBjb21wYXJlX2F1eCAoY29uc19lbnVtIHIxIGUxKSAoY29uc19lbnVtIHIyIGUyKVxuXG4gICAgbGV0IGNvbXBhcmUgczEgczIgPVxuICAgICAgY29tcGFyZV9hdXggKGNvbnNfZW51bSBzMSBFbmQpIChjb25zX2VudW0gczIgRW5kKVxuXG4gICAgbGV0IGVxdWFsIHMxIHMyID1cbiAgICAgIGNvbXBhcmUgczEgczIgPSAwXG5cbiAgICBsZXQgcmVjIHN1YnNldCBzMSBzMiA9XG4gICAgICBtYXRjaCAoczEsIHMyKSB3aXRoXG4gICAgICAgIEVtcHR5LCBfIC0+XG4gICAgICAgICAgdHJ1ZVxuICAgICAgfCBfLCBFbXB0eSAtPlxuICAgICAgICAgIGZhbHNlXG4gICAgICB8IE5vZGUge2w9bDE7IHY9djE7IHI9cjF9LCAoTm9kZSB7bD1sMjsgdj12Mjsgcj1yMn0gYXMgdDIpIC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB2MSB2MiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW5cbiAgICAgICAgICAgIHN1YnNldCBsMSBsMiAmJiBzdWJzZXQgcjEgcjJcbiAgICAgICAgICBlbHNlIGlmIGMgPCAwIHRoZW5cbiAgICAgICAgICAgIHN1YnNldCAoTm9kZSB7bD1sMTsgdj12MTsgcj1FbXB0eTsgaD0wfSkgbDIgJiYgc3Vic2V0IHIxIHQyXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgc3Vic2V0IChOb2RlIHtsPUVtcHR5OyB2PXYxOyByPXIxOyBoPTB9KSByMiAmJiBzdWJzZXQgbDEgdDJcblxuICAgIGxldCByZWMgaXRlciBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gKClcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPiBpdGVyIGYgbDsgZiB2OyBpdGVyIGYgclxuXG4gICAgbGV0IHJlYyBmb2xkIGYgcyBhY2N1ID1cbiAgICAgIG1hdGNoIHMgd2l0aFxuICAgICAgICBFbXB0eSAtPiBhY2N1XG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT4gZm9sZCBmIHIgKGYgdiAoZm9sZCBmIGwgYWNjdSkpXG5cbiAgICBsZXQgcmVjIGZvcl9hbGwgcCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IHRydWVcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPiBwIHYgJiYgZm9yX2FsbCBwIGwgJiYgZm9yX2FsbCBwIHJcblxuICAgIGxldCByZWMgZXhpc3RzIHAgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBmYWxzZVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+IHAgdiB8fCBleGlzdHMgcCBsIHx8IGV4aXN0cyBwIHJcblxuICAgIGxldCByZWMgZmlsdGVyIHAgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBFbXB0eVxuICAgICAgfCAoTm9kZXtsOyB2OyByfSkgYXMgdCAtPlxuICAgICAgICAgICgqIGNhbGwgW3BdIGluIHRoZSBleHBlY3RlZCBsZWZ0LXRvLXJpZ2h0IG9yZGVyICopXG4gICAgICAgICAgbGV0IGwnID0gZmlsdGVyIHAgbCBpblxuICAgICAgICAgIGxldCBwdiA9IHAgdiBpblxuICAgICAgICAgIGxldCByJyA9IGZpbHRlciBwIHIgaW5cbiAgICAgICAgICBpZiBwdiB0aGVuXG4gICAgICAgICAgICBpZiBsPT1sJyAmJiByPT1yJyB0aGVuIHQgZWxzZSBqb2luIGwnIHYgcidcbiAgICAgICAgICBlbHNlIGNvbmNhdCBsJyByJ1xuXG4gICAgbGV0IHJlYyBwYXJ0aXRpb24gcCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IChFbXB0eSwgRW1wdHkpXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICAoKiBjYWxsIFtwXSBpbiB0aGUgZXhwZWN0ZWQgbGVmdC10by1yaWdodCBvcmRlciAqKVxuICAgICAgICAgIGxldCAobHQsIGxmKSA9IHBhcnRpdGlvbiBwIGwgaW5cbiAgICAgICAgICBsZXQgcHYgPSBwIHYgaW5cbiAgICAgICAgICBsZXQgKHJ0LCByZikgPSBwYXJ0aXRpb24gcCByIGluXG4gICAgICAgICAgaWYgcHZcbiAgICAgICAgICB0aGVuIChqb2luIGx0IHYgcnQsIGNvbmNhdCBsZiByZilcbiAgICAgICAgICBlbHNlIChjb25jYXQgbHQgcnQsIGpvaW4gbGYgdiByZilcblxuICAgIGxldCByZWMgY2FyZGluYWwgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiAwXG4gICAgICB8IE5vZGV7bDsgcn0gLT4gY2FyZGluYWwgbCArIDEgKyBjYXJkaW5hbCByXG5cbiAgICBsZXQgcmVjIGVsZW1lbnRzX2F1eCBhY2N1ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gYWNjdVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+IGVsZW1lbnRzX2F1eCAodiA6OiBlbGVtZW50c19hdXggYWNjdSByKSBsXG5cbiAgICBsZXQgZWxlbWVudHMgcyA9XG4gICAgICBlbGVtZW50c19hdXggW10gc1xuXG4gICAgbGV0IGNob29zZSA9IG1pbl9lbHRcblxuICAgIGxldCBjaG9vc2Vfb3B0ID0gbWluX2VsdF9vcHRcblxuICAgIGxldCByZWMgZmluZCB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gdlxuICAgICAgICAgIGVsc2UgZmluZCB4IChpZiBjIDwgMCB0aGVuIGwgZWxzZSByKVxuXG4gICAgbGV0IHJlYyBmaW5kX2ZpcnN0X2F1eCB2MCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICB2MFxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfZmlyc3RfYXV4IHYgZiBsXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9maXJzdF9hdXggdjAgZiByXG5cbiAgICBsZXQgcmVjIGZpbmRfZmlyc3QgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9maXJzdF9hdXggdiBmIGxcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2ZpcnN0IGYgclxuXG4gICAgbGV0IHJlYyBmaW5kX2ZpcnN0X29wdF9hdXggdjAgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgU29tZSB2MFxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfZmlyc3Rfb3B0X2F1eCB2IGYgbFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfZmlyc3Rfb3B0X2F1eCB2MCBmIHJcblxuICAgIGxldCByZWMgZmluZF9maXJzdF9vcHQgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgTm9uZVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfZmlyc3Rfb3B0X2F1eCB2IGYgbFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfZmlyc3Rfb3B0IGYgclxuXG4gICAgbGV0IHJlYyBmaW5kX2xhc3RfYXV4IHYwIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIHYwXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9sYXN0X2F1eCB2IGYgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfbGFzdF9hdXggdjAgZiBsXG5cbiAgICBsZXQgcmVjIGZpbmRfbGFzdCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2xhc3RfYXV4IHYgZiByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9sYXN0IGYgbFxuXG4gICAgbGV0IHJlYyBmaW5kX2xhc3Rfb3B0X2F1eCB2MCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBTb21lIHYwXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9sYXN0X29wdF9hdXggdiBmIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2xhc3Rfb3B0X2F1eCB2MCBmIGxcblxuICAgIGxldCByZWMgZmluZF9sYXN0X29wdCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBOb25lXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9sYXN0X29wdF9hdXggdiBmIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2xhc3Rfb3B0IGYgbFxuXG4gICAgbGV0IHJlYyBmaW5kX29wdCB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gTm9uZVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuIFNvbWUgdlxuICAgICAgICAgIGVsc2UgZmluZF9vcHQgeCAoaWYgYyA8IDAgdGhlbiBsIGVsc2UgcilcblxuICAgIGxldCB0cnlfam9pbiBsIHYgciA9XG4gICAgICAoKiBbam9pbiBsIHYgcl0gY2FuIG9ubHkgYmUgY2FsbGVkIHdoZW4gKGVsZW1lbnRzIG9mIGwgPCB2IDxcbiAgICAgICAgIGVsZW1lbnRzIG9mIHIpOyB1c2UgW3RyeV9qb2luIGwgdiByXSB3aGVuIHRoaXMgcHJvcGVydHkgbWF5XG4gICAgICAgICBub3QgaG9sZCwgYnV0IHlvdSBob3BlIGl0IGRvZXMgaG9sZCBpbiB0aGUgY29tbW9uIGNhc2UgKilcbiAgICAgIGlmIChsID0gRW1wdHkgfHwgT3JkLmNvbXBhcmUgKG1heF9lbHQgbCkgdiA8IDApXG4gICAgICAmJiAociA9IEVtcHR5IHx8IE9yZC5jb21wYXJlIHYgKG1pbl9lbHQgcikgPCAwKVxuICAgICAgdGhlbiBqb2luIGwgdiByXG4gICAgICBlbHNlIHVuaW9uIGwgKGFkZCB2IHIpXG5cbiAgICBsZXQgcmVjIG1hcCBmID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT4gRW1wdHlcbiAgICAgIHwgTm9kZXtsOyB2OyByfSBhcyB0IC0+XG4gICAgICAgICAoKiBlbmZvcmNlIGxlZnQtdG8tcmlnaHQgZXZhbHVhdGlvbiBvcmRlciAqKVxuICAgICAgICAgbGV0IGwnID0gbWFwIGYgbCBpblxuICAgICAgICAgbGV0IHYnID0gZiB2IGluXG4gICAgICAgICBsZXQgcicgPSBtYXAgZiByIGluXG4gICAgICAgICBpZiBsID09IGwnICYmIHYgPT0gdicgJiYgciA9PSByJyB0aGVuIHRcbiAgICAgICAgIGVsc2UgdHJ5X2pvaW4gbCcgdicgcidcblxuICAgIGxldCB0cnlfY29uY2F0IHQxIHQyID1cbiAgICAgIG1hdGNoICh0MSwgdDIpIHdpdGhcbiAgICAgICAgKEVtcHR5LCB0KSAtPiB0XG4gICAgICB8ICh0LCBFbXB0eSkgLT4gdFxuICAgICAgfCAoXywgXykgLT4gdHJ5X2pvaW4gdDEgKG1pbl9lbHQgdDIpIChyZW1vdmVfbWluX2VsdCB0MilcblxuICAgIGxldCByZWMgZmlsdGVyX21hcCBmID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT4gRW1wdHlcbiAgICAgIHwgTm9kZXtsOyB2OyByfSBhcyB0IC0+XG4gICAgICAgICAoKiBlbmZvcmNlIGxlZnQtdG8tcmlnaHQgZXZhbHVhdGlvbiBvcmRlciAqKVxuICAgICAgICAgbGV0IGwnID0gZmlsdGVyX21hcCBmIGwgaW5cbiAgICAgICAgIGxldCB2JyA9IGYgdiBpblxuICAgICAgICAgbGV0IHInID0gZmlsdGVyX21hcCBmIHIgaW5cbiAgICAgICAgIGJlZ2luIG1hdGNoIHYnIHdpdGhcbiAgICAgICAgICAgfCBTb21lIHYnIC0+XG4gICAgICAgICAgICAgIGlmIGwgPT0gbCcgJiYgdiA9PSB2JyAmJiByID09IHInIHRoZW4gdFxuICAgICAgICAgICAgICBlbHNlIHRyeV9qb2luIGwnIHYnIHInXG4gICAgICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgICAgICB0cnlfY29uY2F0IGwnIHInXG4gICAgICAgICBlbmRcblxuICAgIGxldCBvZl9zb3J0ZWRfbGlzdCBsID1cbiAgICAgIGxldCByZWMgc3ViIG4gbCA9XG4gICAgICAgIG1hdGNoIG4sIGwgd2l0aFxuICAgICAgICB8IDAsIGwgLT4gRW1wdHksIGxcbiAgICAgICAgfCAxLCB4MCA6OiBsIC0+IE5vZGUge2w9RW1wdHk7IHY9eDA7IHI9RW1wdHk7IGg9MX0sIGxcbiAgICAgICAgfCAyLCB4MCA6OiB4MSA6OiBsIC0+XG4gICAgICAgICAgICBOb2Rle2w9Tm9kZXtsPUVtcHR5OyB2PXgwOyByPUVtcHR5OyBoPTF9OyB2PXgxOyByPUVtcHR5OyBoPTJ9LCBsXG4gICAgICAgIHwgMywgeDAgOjogeDEgOjogeDIgOjogbCAtPlxuICAgICAgICAgICAgTm9kZXtsPU5vZGV7bD1FbXB0eTsgdj14MDsgcj1FbXB0eTsgaD0xfTsgdj14MTtcbiAgICAgICAgICAgICAgICAgcj1Ob2Rle2w9RW1wdHk7IHY9eDI7IHI9RW1wdHk7IGg9MX07IGg9Mn0sIGxcbiAgICAgICAgfCBuLCBsIC0+XG4gICAgICAgICAgbGV0IG5sID0gbiAvIDIgaW5cbiAgICAgICAgICBsZXQgbGVmdCwgbCA9IHN1YiBubCBsIGluXG4gICAgICAgICAgbWF0Y2ggbCB3aXRoXG4gICAgICAgICAgfCBbXSAtPiBhc3NlcnQgZmFsc2VcbiAgICAgICAgICB8IG1pZCA6OiBsIC0+XG4gICAgICAgICAgICBsZXQgcmlnaHQsIGwgPSBzdWIgKG4gLSBubCAtIDEpIGwgaW5cbiAgICAgICAgICAgIGNyZWF0ZSBsZWZ0IG1pZCByaWdodCwgbFxuICAgICAgaW5cbiAgICAgIGZzdCAoc3ViIChMaXN0Lmxlbmd0aCBsKSBsKVxuXG4gICAgbGV0IG9mX2xpc3QgbCA9XG4gICAgICBtYXRjaCBsIHdpdGhcbiAgICAgIHwgW10gLT4gZW1wdHlcbiAgICAgIHwgW3gwXSAtPiBzaW5nbGV0b24geDBcbiAgICAgIHwgW3gwOyB4MV0gLT4gYWRkIHgxIChzaW5nbGV0b24geDApXG4gICAgICB8IFt4MDsgeDE7IHgyXSAtPiBhZGQgeDIgKGFkZCB4MSAoc2luZ2xldG9uIHgwKSlcbiAgICAgIHwgW3gwOyB4MTsgeDI7IHgzXSAtPiBhZGQgeDMgKGFkZCB4MiAoYWRkIHgxIChzaW5nbGV0b24geDApKSlcbiAgICAgIHwgW3gwOyB4MTsgeDI7IHgzOyB4NF0gLT4gYWRkIHg0IChhZGQgeDMgKGFkZCB4MiAoYWRkIHgxIChzaW5nbGV0b24geDApKSkpXG4gICAgICB8IF8gLT4gb2Zfc29ydGVkX2xpc3QgKExpc3Quc29ydF91bmlxIE9yZC5jb21wYXJlIGwpXG5cbiAgICBsZXQgYWRkX3NlcSBpIG0gPVxuICAgICAgU2VxLmZvbGRfbGVmdCAoZnVuIHMgeCAtPiBhZGQgeCBzKSBtIGlcblxuICAgIGxldCBvZl9zZXEgaSA9IGFkZF9zZXEgaSBlbXB0eVxuXG4gICAgbGV0IHJlYyBzZXFfb2ZfZW51bV8gYyAoKSA9IG1hdGNoIGMgd2l0aFxuICAgICAgfCBFbmQgLT4gU2VxLk5pbFxuICAgICAgfCBNb3JlICh4LCB0LCByZXN0KSAtPiBTZXEuQ29ucyAoeCwgc2VxX29mX2VudW1fIChjb25zX2VudW0gdCByZXN0KSlcblxuICAgIGxldCB0b19zZXEgYyA9IHNlcV9vZl9lbnVtXyAoY29uc19lbnVtIGMgRW5kKVxuXG4gICAgbGV0IHJlYyBzbm9jX2VudW0gcyBlID1cbiAgICAgIG1hdGNoIHMgd2l0aFxuICAgICAgICBFbXB0eSAtPiBlXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT4gc25vY19lbnVtIHIgKE1vcmUodiwgbCwgZSkpXG5cbiAgICBsZXQgcmVjIHJldl9zZXFfb2ZfZW51bV8gYyAoKSA9IG1hdGNoIGMgd2l0aFxuICAgICAgfCBFbmQgLT4gU2VxLk5pbFxuICAgICAgfCBNb3JlICh4LCB0LCByZXN0KSAtPiBTZXEuQ29ucyAoeCwgcmV2X3NlcV9vZl9lbnVtXyAoc25vY19lbnVtIHQgcmVzdCkpXG5cbiAgICBsZXQgdG9fcmV2X3NlcSBjID0gcmV2X3NlcV9vZl9lbnVtXyAoc25vY19lbnVtIGMgRW5kKVxuXG4gICAgbGV0IHRvX3NlcV9mcm9tIGxvdyBzID1cbiAgICAgIGxldCByZWMgYXV4IGxvdyBzIGMgPSBtYXRjaCBzIHdpdGhcbiAgICAgICAgfCBFbXB0eSAtPiBjXG4gICAgICAgIHwgTm9kZSB7bDsgcjsgdjsgX30gLT5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIE9yZC5jb21wYXJlIHYgbG93IHdpdGhcbiAgICAgICAgICAgICAgfCAwIC0+IE1vcmUgKHYsIHIsIGMpXG4gICAgICAgICAgICAgIHwgbiB3aGVuIG48MCAtPiBhdXggbG93IHIgY1xuICAgICAgICAgICAgICB8IF8gLT4gYXV4IGxvdyBsIChNb3JlICh2LCByLCBjKSlcbiAgICAgICAgICAgIGVuZFxuICAgICAgaW5cbiAgICAgIHNlcV9vZl9lbnVtXyAoYXV4IGxvdyBzIEVuZClcbiAgZW5kXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbm1vZHVsZSB0eXBlIE9yZGVyZWRUeXBlID1cbiAgc2lnXG4gICAgdHlwZSB0XG4gICAgdmFsIGNvbXBhcmU6IHQgLT4gdCAtPiBpbnRcbiAgZW5kXG5cbm1vZHVsZSB0eXBlIFMgPVxuICBzaWdcbiAgICB0eXBlIGtleVxuICAgIHR5cGUgISsnYSB0XG4gICAgdmFsIGVtcHR5OiAnYSB0XG4gICAgdmFsIGlzX2VtcHR5OiAnYSB0IC0+IGJvb2xcbiAgICB2YWwgbWVtOiAga2V5IC0+ICdhIHQgLT4gYm9vbFxuICAgIHZhbCBhZGQ6IGtleSAtPiAnYSAtPiAnYSB0IC0+ICdhIHRcbiAgICB2YWwgdXBkYXRlOiBrZXkgLT4gKCdhIG9wdGlvbiAtPiAnYSBvcHRpb24pIC0+ICdhIHQgLT4gJ2EgdFxuICAgIHZhbCBzaW5nbGV0b246IGtleSAtPiAnYSAtPiAnYSB0XG4gICAgdmFsIHJlbW92ZToga2V5IC0+ICdhIHQgLT4gJ2EgdFxuICAgIHZhbCBtZXJnZTpcbiAgICAgICAgICAoa2V5IC0+ICdhIG9wdGlvbiAtPiAnYiBvcHRpb24gLT4gJ2Mgb3B0aW9uKSAtPiAnYSB0IC0+ICdiIHQgLT4gJ2MgdFxuICAgIHZhbCB1bmlvbjogKGtleSAtPiAnYSAtPiAnYSAtPiAnYSBvcHRpb24pIC0+ICdhIHQgLT4gJ2EgdCAtPiAnYSB0XG4gICAgdmFsIGNvbXBhcmU6ICgnYSAtPiAnYSAtPiBpbnQpIC0+ICdhIHQgLT4gJ2EgdCAtPiBpbnRcbiAgICB2YWwgZXF1YWw6ICgnYSAtPiAnYSAtPiBib29sKSAtPiAnYSB0IC0+ICdhIHQgLT4gYm9vbFxuICAgIHZhbCBpdGVyOiAoa2V5IC0+ICdhIC0+IHVuaXQpIC0+ICdhIHQgLT4gdW5pdFxuICAgIHZhbCBmb2xkOiAoa2V5IC0+ICdhIC0+ICdiIC0+ICdiKSAtPiAnYSB0IC0+ICdiIC0+ICdiXG4gICAgdmFsIGZvcl9hbGw6IChrZXkgLT4gJ2EgLT4gYm9vbCkgLT4gJ2EgdCAtPiBib29sXG4gICAgdmFsIGV4aXN0czogKGtleSAtPiAnYSAtPiBib29sKSAtPiAnYSB0IC0+IGJvb2xcbiAgICB2YWwgZmlsdGVyOiAoa2V5IC0+ICdhIC0+IGJvb2wpIC0+ICdhIHQgLT4gJ2EgdFxuICAgIHZhbCBmaWx0ZXJfbWFwOiAoa2V5IC0+ICdhIC0+ICdiIG9wdGlvbikgLT4gJ2EgdCAtPiAnYiB0XG4gICAgdmFsIHBhcnRpdGlvbjogKGtleSAtPiAnYSAtPiBib29sKSAtPiAnYSB0IC0+ICdhIHQgKiAnYSB0XG4gICAgdmFsIGNhcmRpbmFsOiAnYSB0IC0+IGludFxuICAgIHZhbCBiaW5kaW5nczogJ2EgdCAtPiAoa2V5ICogJ2EpIGxpc3RcbiAgICB2YWwgbWluX2JpbmRpbmc6ICdhIHQgLT4gKGtleSAqICdhKVxuICAgIHZhbCBtaW5fYmluZGluZ19vcHQ6ICdhIHQgLT4gKGtleSAqICdhKSBvcHRpb25cbiAgICB2YWwgbWF4X2JpbmRpbmc6ICdhIHQgLT4gKGtleSAqICdhKVxuICAgIHZhbCBtYXhfYmluZGluZ19vcHQ6ICdhIHQgLT4gKGtleSAqICdhKSBvcHRpb25cbiAgICB2YWwgY2hvb3NlOiAnYSB0IC0+IChrZXkgKiAnYSlcbiAgICB2YWwgY2hvb3NlX29wdDogJ2EgdCAtPiAoa2V5ICogJ2EpIG9wdGlvblxuICAgIHZhbCBzcGxpdDoga2V5IC0+ICdhIHQgLT4gJ2EgdCAqICdhIG9wdGlvbiAqICdhIHRcbiAgICB2YWwgZmluZDoga2V5IC0+ICdhIHQgLT4gJ2FcbiAgICB2YWwgZmluZF9vcHQ6IGtleSAtPiAnYSB0IC0+ICdhIG9wdGlvblxuICAgIHZhbCBmaW5kX2ZpcnN0OiAoa2V5IC0+IGJvb2wpIC0+ICdhIHQgLT4ga2V5ICogJ2FcbiAgICB2YWwgZmluZF9maXJzdF9vcHQ6IChrZXkgLT4gYm9vbCkgLT4gJ2EgdCAtPiAoa2V5ICogJ2EpIG9wdGlvblxuICAgIHZhbCBmaW5kX2xhc3Q6IChrZXkgLT4gYm9vbCkgLT4gJ2EgdCAtPiBrZXkgKiAnYVxuICAgIHZhbCBmaW5kX2xhc3Rfb3B0OiAoa2V5IC0+IGJvb2wpIC0+ICdhIHQgLT4gKGtleSAqICdhKSBvcHRpb25cbiAgICB2YWwgbWFwOiAoJ2EgLT4gJ2IpIC0+ICdhIHQgLT4gJ2IgdFxuICAgIHZhbCBtYXBpOiAoa2V5IC0+ICdhIC0+ICdiKSAtPiAnYSB0IC0+ICdiIHRcbiAgICB2YWwgdG9fc2VxIDogJ2EgdCAtPiAoa2V5ICogJ2EpIFNlcS50XG4gICAgdmFsIHRvX3Jldl9zZXEgOiAnYSB0IC0+IChrZXkgKiAnYSkgU2VxLnRcbiAgICB2YWwgdG9fc2VxX2Zyb20gOiBrZXkgLT4gJ2EgdCAtPiAoa2V5ICogJ2EpIFNlcS50XG4gICAgdmFsIGFkZF9zZXEgOiAoa2V5ICogJ2EpIFNlcS50IC0+ICdhIHQgLT4gJ2EgdFxuICAgIHZhbCBvZl9zZXEgOiAoa2V5ICogJ2EpIFNlcS50IC0+ICdhIHRcbiAgZW5kXG5cbm1vZHVsZSBNYWtlKE9yZDogT3JkZXJlZFR5cGUpID0gc3RydWN0XG5cbiAgICB0eXBlIGtleSA9IE9yZC50XG5cbiAgICB0eXBlICdhIHQgPVxuICAgICAgICBFbXB0eVxuICAgICAgfCBOb2RlIG9mIHtsOidhIHQ7IHY6a2V5OyBkOidhOyByOidhIHQ7IGg6aW50fVxuXG4gICAgbGV0IGhlaWdodCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IDBcbiAgICAgIHwgTm9kZSB7aH0gLT4gaFxuXG4gICAgbGV0IGNyZWF0ZSBsIHggZCByID1cbiAgICAgIGxldCBobCA9IGhlaWdodCBsIGFuZCBociA9IGhlaWdodCByIGluXG4gICAgICBOb2Rle2w7IHY9eDsgZDsgcjsgaD0oaWYgaGwgPj0gaHIgdGhlbiBobCArIDEgZWxzZSBociArIDEpfVxuXG4gICAgbGV0IHNpbmdsZXRvbiB4IGQgPSBOb2Rle2w9RW1wdHk7IHY9eDsgZDsgcj1FbXB0eTsgaD0xfVxuXG4gICAgbGV0IGJhbCBsIHggZCByID1cbiAgICAgIGxldCBobCA9IG1hdGNoIGwgd2l0aCBFbXB0eSAtPiAwIHwgTm9kZSB7aH0gLT4gaCBpblxuICAgICAgbGV0IGhyID0gbWF0Y2ggciB3aXRoIEVtcHR5IC0+IDAgfCBOb2RlIHtofSAtPiBoIGluXG4gICAgICBpZiBobCA+IGhyICsgMiB0aGVuIGJlZ2luXG4gICAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgICAgIEVtcHR5IC0+IGludmFsaWRfYXJnIFwiTWFwLmJhbFwiXG4gICAgICAgIHwgTm9kZXtsPWxsOyB2PWx2OyBkPWxkOyByPWxyfSAtPlxuICAgICAgICAgICAgaWYgaGVpZ2h0IGxsID49IGhlaWdodCBsciB0aGVuXG4gICAgICAgICAgICAgIGNyZWF0ZSBsbCBsdiBsZCAoY3JlYXRlIGxyIHggZCByKVxuICAgICAgICAgICAgZWxzZSBiZWdpblxuICAgICAgICAgICAgICBtYXRjaCBsciB3aXRoXG4gICAgICAgICAgICAgICAgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJNYXAuYmFsXCJcbiAgICAgICAgICAgICAgfCBOb2Rle2w9bHJsOyB2PWxydjsgZD1scmQ7IHI9bHJyfS0+XG4gICAgICAgICAgICAgICAgICBjcmVhdGUgKGNyZWF0ZSBsbCBsdiBsZCBscmwpIGxydiBscmQgKGNyZWF0ZSBscnIgeCBkIHIpXG4gICAgICAgICAgICBlbmRcbiAgICAgIGVuZCBlbHNlIGlmIGhyID4gaGwgKyAyIHRoZW4gYmVnaW5cbiAgICAgICAgbWF0Y2ggciB3aXRoXG4gICAgICAgICAgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJNYXAuYmFsXCJcbiAgICAgICAgfCBOb2Rle2w9cmw7IHY9cnY7IGQ9cmQ7IHI9cnJ9IC0+XG4gICAgICAgICAgICBpZiBoZWlnaHQgcnIgPj0gaGVpZ2h0IHJsIHRoZW5cbiAgICAgICAgICAgICAgY3JlYXRlIChjcmVhdGUgbCB4IGQgcmwpIHJ2IHJkIHJyXG4gICAgICAgICAgICBlbHNlIGJlZ2luXG4gICAgICAgICAgICAgIG1hdGNoIHJsIHdpdGhcbiAgICAgICAgICAgICAgICBFbXB0eSAtPiBpbnZhbGlkX2FyZyBcIk1hcC5iYWxcIlxuICAgICAgICAgICAgICB8IE5vZGV7bD1ybGw7IHY9cmx2OyBkPXJsZDsgcj1ybHJ9IC0+XG4gICAgICAgICAgICAgICAgICBjcmVhdGUgKGNyZWF0ZSBsIHggZCBybGwpIHJsdiBybGQgKGNyZWF0ZSBybHIgcnYgcmQgcnIpXG4gICAgICAgICAgICBlbmRcbiAgICAgIGVuZCBlbHNlXG4gICAgICAgIE5vZGV7bDsgdj14OyBkOyByOyBoPShpZiBobCA+PSBociB0aGVuIGhsICsgMSBlbHNlIGhyICsgMSl9XG5cbiAgICBsZXQgZW1wdHkgPSBFbXB0eVxuXG4gICAgbGV0IGlzX2VtcHR5ID0gZnVuY3Rpb24gRW1wdHkgLT4gdHJ1ZSB8IF8gLT4gZmFsc2VcblxuICAgIGxldCByZWMgYWRkIHggZGF0YSA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgTm9kZXtsPUVtcHR5OyB2PXg7IGQ9ZGF0YTsgcj1FbXB0eTsgaD0xfVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByOyBofSBhcyBtIC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuXG4gICAgICAgICAgICBpZiBkID09IGRhdGEgdGhlbiBtIGVsc2UgTm9kZXtsOyB2PXg7IGQ9ZGF0YTsgcjsgaH1cbiAgICAgICAgICBlbHNlIGlmIGMgPCAwIHRoZW5cbiAgICAgICAgICAgIGxldCBsbCA9IGFkZCB4IGRhdGEgbCBpblxuICAgICAgICAgICAgaWYgbCA9PSBsbCB0aGVuIG0gZWxzZSBiYWwgbGwgdiBkIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsZXQgcnIgPSBhZGQgeCBkYXRhIHIgaW5cbiAgICAgICAgICAgIGlmIHIgPT0gcnIgdGhlbiBtIGVsc2UgYmFsIGwgdiBkIHJyXG5cbiAgICBsZXQgcmVjIGZpbmQgeCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuIGRcbiAgICAgICAgICBlbHNlIGZpbmQgeCAoaWYgYyA8IDAgdGhlbiBsIGVsc2UgcilcblxuICAgIGxldCByZWMgZmluZF9maXJzdF9hdXggdjAgZDAgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgKHYwLCBkMClcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9maXJzdF9hdXggdiBkIGYgbFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfZmlyc3RfYXV4IHYwIGQwIGYgclxuXG4gICAgbGV0IHJlYyBmaW5kX2ZpcnN0IGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X2F1eCB2IGQgZiBsXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9maXJzdCBmIHJcblxuICAgIGxldCByZWMgZmluZF9maXJzdF9vcHRfYXV4IHYwIGQwIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIFNvbWUgKHYwLCBkMClcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9maXJzdF9vcHRfYXV4IHYgZCBmIGxcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X29wdF9hdXggdjAgZDAgZiByXG5cbiAgICBsZXQgcmVjIGZpbmRfZmlyc3Rfb3B0IGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIE5vbmVcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9maXJzdF9vcHRfYXV4IHYgZCBmIGxcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X29wdCBmIHJcblxuICAgIGxldCByZWMgZmluZF9sYXN0X2F1eCB2MCBkMCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICAodjAsIGQwKVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2xhc3RfYXV4IHYgZCBmIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2xhc3RfYXV4IHYwIGQwIGYgbFxuXG4gICAgbGV0IHJlYyBmaW5kX2xhc3QgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfbGFzdF9hdXggdiBkIGYgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfbGFzdCBmIGxcblxuICAgIGxldCByZWMgZmluZF9sYXN0X29wdF9hdXggdjAgZDAgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgU29tZSAodjAsIGQwKVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2xhc3Rfb3B0X2F1eCB2IGQgZiByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9sYXN0X29wdF9hdXggdjAgZDAgZiBsXG5cbiAgICBsZXQgcmVjIGZpbmRfbGFzdF9vcHQgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgTm9uZVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2xhc3Rfb3B0X2F1eCB2IGQgZiByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9sYXN0X29wdCBmIGxcblxuICAgIGxldCByZWMgZmluZF9vcHQgeCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgTm9uZVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiBTb21lIGRcbiAgICAgICAgICBlbHNlIGZpbmRfb3B0IHggKGlmIGMgPCAwIHRoZW4gbCBlbHNlIHIpXG5cbiAgICBsZXQgcmVjIG1lbSB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBmYWxzZVxuICAgICAgfCBOb2RlIHtsOyB2OyByfSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgYyA9IDAgfHwgbWVtIHggKGlmIGMgPCAwIHRoZW4gbCBlbHNlIHIpXG5cbiAgICBsZXQgcmVjIG1pbl9iaW5kaW5nID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IE5vZGUge2w9RW1wdHk7IHY7IGR9IC0+ICh2LCBkKVxuICAgICAgfCBOb2RlIHtsfSAtPiBtaW5fYmluZGluZyBsXG5cbiAgICBsZXQgcmVjIG1pbl9iaW5kaW5nX29wdCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IE5vbmVcbiAgICAgIHwgTm9kZSB7bD1FbXB0eTsgdjsgZH0gLT4gU29tZSAodiwgZClcbiAgICAgIHwgTm9kZSB7bH0tPiBtaW5fYmluZGluZ19vcHQgbFxuXG4gICAgbGV0IHJlYyBtYXhfYmluZGluZyA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBOb2RlIHt2OyBkOyByPUVtcHR5fSAtPiAodiwgZClcbiAgICAgIHwgTm9kZSB7cn0gLT4gbWF4X2JpbmRpbmcgclxuXG4gICAgbGV0IHJlYyBtYXhfYmluZGluZ19vcHQgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBOb25lXG4gICAgICB8IE5vZGUge3Y7IGQ7IHI9RW1wdHl9IC0+IFNvbWUgKHYsIGQpXG4gICAgICB8IE5vZGUge3J9IC0+IG1heF9iaW5kaW5nX29wdCByXG5cbiAgICBsZXQgcmVjIHJlbW92ZV9taW5fYmluZGluZyA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IGludmFsaWRfYXJnIFwiTWFwLnJlbW92ZV9taW5fZWx0XCJcbiAgICAgIHwgTm9kZSB7bD1FbXB0eTsgcn0gLT4gclxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPiBiYWwgKHJlbW92ZV9taW5fYmluZGluZyBsKSB2IGQgclxuXG4gICAgbGV0IG1lcmdlIHQxIHQyID1cbiAgICAgIG1hdGNoICh0MSwgdDIpIHdpdGhcbiAgICAgICAgKEVtcHR5LCB0KSAtPiB0XG4gICAgICB8ICh0LCBFbXB0eSkgLT4gdFxuICAgICAgfCAoXywgXykgLT5cbiAgICAgICAgICBsZXQgKHgsIGQpID0gbWluX2JpbmRpbmcgdDIgaW5cbiAgICAgICAgICBiYWwgdDEgeCBkIChyZW1vdmVfbWluX2JpbmRpbmcgdDIpXG5cbiAgICBsZXQgcmVjIHJlbW92ZSB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBFbXB0eVxuICAgICAgfCAoTm9kZSB7bDsgdjsgZDsgcn0gYXMgbSkgLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gbWVyZ2UgbCByXG4gICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuXG4gICAgICAgICAgICBsZXQgbGwgPSByZW1vdmUgeCBsIGluIGlmIGwgPT0gbGwgdGhlbiBtIGVsc2UgYmFsIGxsIHYgZCByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbGV0IHJyID0gcmVtb3ZlIHggciBpbiBpZiByID09IHJyIHRoZW4gbSBlbHNlIGJhbCBsIHYgZCByclxuXG4gICAgbGV0IHJlYyB1cGRhdGUgeCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBiZWdpbiBtYXRjaCBmIE5vbmUgd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPiBFbXB0eVxuICAgICAgICAgIHwgU29tZSBkYXRhIC0+IE5vZGV7bD1FbXB0eTsgdj14OyBkPWRhdGE7IHI9RW1wdHk7IGg9MX1cbiAgICAgICAgICBlbmRcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcjsgaH0gYXMgbSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiBiZWdpblxuICAgICAgICAgICAgbWF0Y2ggZiAoU29tZSBkKSB3aXRoXG4gICAgICAgICAgICB8IE5vbmUgLT4gbWVyZ2UgbCByXG4gICAgICAgICAgICB8IFNvbWUgZGF0YSAtPlxuICAgICAgICAgICAgICAgIGlmIGQgPT0gZGF0YSB0aGVuIG0gZWxzZSBOb2Rle2w7IHY9eDsgZD1kYXRhOyByOyBofVxuICAgICAgICAgIGVuZCBlbHNlIGlmIGMgPCAwIHRoZW5cbiAgICAgICAgICAgIGxldCBsbCA9IHVwZGF0ZSB4IGYgbCBpblxuICAgICAgICAgICAgaWYgbCA9PSBsbCB0aGVuIG0gZWxzZSBiYWwgbGwgdiBkIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsZXQgcnIgPSB1cGRhdGUgeCBmIHIgaW5cbiAgICAgICAgICAgIGlmIHIgPT0gcnIgdGhlbiBtIGVsc2UgYmFsIGwgdiBkIHJyXG5cbiAgICBsZXQgcmVjIGl0ZXIgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+ICgpXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgaXRlciBmIGw7IGYgdiBkOyBpdGVyIGYgclxuXG4gICAgbGV0IHJlYyBtYXAgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgRW1wdHlcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcjsgaH0gLT5cbiAgICAgICAgICBsZXQgbCcgPSBtYXAgZiBsIGluXG4gICAgICAgICAgbGV0IGQnID0gZiBkIGluXG4gICAgICAgICAgbGV0IHInID0gbWFwIGYgciBpblxuICAgICAgICAgIE5vZGV7bD1sJzsgdjsgZD1kJzsgcj1yJzsgaH1cblxuICAgIGxldCByZWMgbWFwaSBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBFbXB0eVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByOyBofSAtPlxuICAgICAgICAgIGxldCBsJyA9IG1hcGkgZiBsIGluXG4gICAgICAgICAgbGV0IGQnID0gZiB2IGQgaW5cbiAgICAgICAgICBsZXQgcicgPSBtYXBpIGYgciBpblxuICAgICAgICAgIE5vZGV7bD1sJzsgdjsgZD1kJzsgcj1yJzsgaH1cblxuICAgIGxldCByZWMgZm9sZCBmIG0gYWNjdSA9XG4gICAgICBtYXRjaCBtIHdpdGhcbiAgICAgICAgRW1wdHkgLT4gYWNjdVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGZvbGQgZiByIChmIHYgZCAoZm9sZCBmIGwgYWNjdSkpXG5cbiAgICBsZXQgcmVjIGZvcl9hbGwgcCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IHRydWVcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT4gcCB2IGQgJiYgZm9yX2FsbCBwIGwgJiYgZm9yX2FsbCBwIHJcblxuICAgIGxldCByZWMgZXhpc3RzIHAgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBmYWxzZVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPiBwIHYgZCB8fCBleGlzdHMgcCBsIHx8IGV4aXN0cyBwIHJcblxuICAgICgqIEJld2FyZTogdGhvc2UgdHdvIGZ1bmN0aW9ucyBhc3N1bWUgdGhhdCB0aGUgYWRkZWQgayBpcyAqc3RyaWN0bHkqXG4gICAgICAgc21hbGxlciAob3IgYmlnZ2VyKSB0aGFuIGFsbCB0aGUgcHJlc2VudCBrZXlzIGluIHRoZSB0cmVlOyBpdFxuICAgICAgIGRvZXMgbm90IHRlc3QgZm9yIGVxdWFsaXR5IHdpdGggdGhlIGN1cnJlbnQgbWluIChvciBtYXgpIGtleS5cblxuICAgICAgIEluZGVlZCwgdGhleSBhcmUgb25seSB1c2VkIGR1cmluZyB0aGUgXCJqb2luXCIgb3BlcmF0aW9uIHdoaWNoXG4gICAgICAgcmVzcGVjdHMgdGhpcyBwcmVjb25kaXRpb24uXG4gICAgKilcblxuICAgIGxldCByZWMgYWRkX21pbl9iaW5kaW5nIGsgeCA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+IHNpbmdsZXRvbiBrIHhcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgYmFsIChhZGRfbWluX2JpbmRpbmcgayB4IGwpIHYgZCByXG5cbiAgICBsZXQgcmVjIGFkZF9tYXhfYmluZGluZyBrIHggPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiBzaW5nbGV0b24gayB4XG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgIGJhbCBsIHYgZCAoYWRkX21heF9iaW5kaW5nIGsgeCByKVxuXG4gICAgKCogU2FtZSBhcyBjcmVhdGUgYW5kIGJhbCwgYnV0IG5vIGFzc3VtcHRpb25zIGFyZSBtYWRlIG9uIHRoZVxuICAgICAgIHJlbGF0aXZlIGhlaWdodHMgb2YgbCBhbmQgci4gKilcblxuICAgIGxldCByZWMgam9pbiBsIHYgZCByID1cbiAgICAgIG1hdGNoIChsLCByKSB3aXRoXG4gICAgICAgIChFbXB0eSwgXykgLT4gYWRkX21pbl9iaW5kaW5nIHYgZCByXG4gICAgICB8IChfLCBFbXB0eSkgLT4gYWRkX21heF9iaW5kaW5nIHYgZCBsXG4gICAgICB8IChOb2Rle2w9bGw7IHY9bHY7IGQ9bGQ7IHI9bHI7IGg9bGh9LFxuICAgICAgICAgTm9kZXtsPXJsOyB2PXJ2OyBkPXJkOyByPXJyOyBoPXJofSkgLT5cbiAgICAgICAgICBpZiBsaCA+IHJoICsgMiB0aGVuIGJhbCBsbCBsdiBsZCAoam9pbiBsciB2IGQgcikgZWxzZVxuICAgICAgICAgIGlmIHJoID4gbGggKyAyIHRoZW4gYmFsIChqb2luIGwgdiBkIHJsKSBydiByZCByciBlbHNlXG4gICAgICAgICAgY3JlYXRlIGwgdiBkIHJcblxuICAgICgqIE1lcmdlIHR3byB0cmVlcyBsIGFuZCByIGludG8gb25lLlxuICAgICAgIEFsbCBlbGVtZW50cyBvZiBsIG11c3QgcHJlY2VkZSB0aGUgZWxlbWVudHMgb2Ygci5cbiAgICAgICBObyBhc3N1bXB0aW9uIG9uIHRoZSBoZWlnaHRzIG9mIGwgYW5kIHIuICopXG5cbiAgICBsZXQgY29uY2F0IHQxIHQyID1cbiAgICAgIG1hdGNoICh0MSwgdDIpIHdpdGhcbiAgICAgICAgKEVtcHR5LCB0KSAtPiB0XG4gICAgICB8ICh0LCBFbXB0eSkgLT4gdFxuICAgICAgfCAoXywgXykgLT5cbiAgICAgICAgICBsZXQgKHgsIGQpID0gbWluX2JpbmRpbmcgdDIgaW5cbiAgICAgICAgICBqb2luIHQxIHggZCAocmVtb3ZlX21pbl9iaW5kaW5nIHQyKVxuXG4gICAgbGV0IGNvbmNhdF9vcl9qb2luIHQxIHYgZCB0MiA9XG4gICAgICBtYXRjaCBkIHdpdGhcbiAgICAgIHwgU29tZSBkIC0+IGpvaW4gdDEgdiBkIHQyXG4gICAgICB8IE5vbmUgLT4gY29uY2F0IHQxIHQyXG5cbiAgICBsZXQgcmVjIHNwbGl0IHggPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIChFbXB0eSwgTm9uZSwgRW1wdHkpXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuIChsLCBTb21lIGQsIHIpXG4gICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuXG4gICAgICAgICAgICBsZXQgKGxsLCBwcmVzLCBybCkgPSBzcGxpdCB4IGwgaW4gKGxsLCBwcmVzLCBqb2luIHJsIHYgZCByKVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxldCAobHIsIHByZXMsIHJyKSA9IHNwbGl0IHggciBpbiAoam9pbiBsIHYgZCBsciwgcHJlcywgcnIpXG5cbiAgICBsZXQgcmVjIG1lcmdlIGYgczEgczIgPVxuICAgICAgbWF0Y2ggKHMxLCBzMikgd2l0aFxuICAgICAgICAoRW1wdHksIEVtcHR5KSAtPiBFbXB0eVxuICAgICAgfCAoTm9kZSB7bD1sMTsgdj12MTsgZD1kMTsgcj1yMTsgaD1oMX0sIF8pIHdoZW4gaDEgPj0gaGVpZ2h0IHMyIC0+XG4gICAgICAgICAgbGV0IChsMiwgZDIsIHIyKSA9IHNwbGl0IHYxIHMyIGluXG4gICAgICAgICAgY29uY2F0X29yX2pvaW4gKG1lcmdlIGYgbDEgbDIpIHYxIChmIHYxIChTb21lIGQxKSBkMikgKG1lcmdlIGYgcjEgcjIpXG4gICAgICB8IChfLCBOb2RlIHtsPWwyOyB2PXYyOyBkPWQyOyByPXIyfSkgLT5cbiAgICAgICAgICBsZXQgKGwxLCBkMSwgcjEpID0gc3BsaXQgdjIgczEgaW5cbiAgICAgICAgICBjb25jYXRfb3Jfam9pbiAobWVyZ2UgZiBsMSBsMikgdjIgKGYgdjIgZDEgKFNvbWUgZDIpKSAobWVyZ2UgZiByMSByMilcbiAgICAgIHwgXyAtPlxuICAgICAgICAgIGFzc2VydCBmYWxzZVxuXG4gICAgbGV0IHJlYyB1bmlvbiBmIHMxIHMyID1cbiAgICAgIG1hdGNoIChzMSwgczIpIHdpdGhcbiAgICAgIHwgKEVtcHR5LCBzKSB8IChzLCBFbXB0eSkgLT4gc1xuICAgICAgfCAoTm9kZSB7bD1sMTsgdj12MTsgZD1kMTsgcj1yMTsgaD1oMX0sXG4gICAgICAgICBOb2RlIHtsPWwyOyB2PXYyOyBkPWQyOyByPXIyOyBoPWgyfSkgLT5cbiAgICAgICAgICBpZiBoMSA+PSBoMiB0aGVuXG4gICAgICAgICAgICBsZXQgKGwyLCBkMiwgcjIpID0gc3BsaXQgdjEgczIgaW5cbiAgICAgICAgICAgIGxldCBsID0gdW5pb24gZiBsMSBsMiBhbmQgciA9IHVuaW9uIGYgcjEgcjIgaW5cbiAgICAgICAgICAgIG1hdGNoIGQyIHdpdGhcbiAgICAgICAgICAgIHwgTm9uZSAtPiBqb2luIGwgdjEgZDEgclxuICAgICAgICAgICAgfCBTb21lIGQyIC0+IGNvbmNhdF9vcl9qb2luIGwgdjEgKGYgdjEgZDEgZDIpIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsZXQgKGwxLCBkMSwgcjEpID0gc3BsaXQgdjIgczEgaW5cbiAgICAgICAgICAgIGxldCBsID0gdW5pb24gZiBsMSBsMiBhbmQgciA9IHVuaW9uIGYgcjEgcjIgaW5cbiAgICAgICAgICAgIG1hdGNoIGQxIHdpdGhcbiAgICAgICAgICAgIHwgTm9uZSAtPiBqb2luIGwgdjIgZDIgclxuICAgICAgICAgICAgfCBTb21lIGQxIC0+IGNvbmNhdF9vcl9qb2luIGwgdjIgKGYgdjIgZDEgZDIpIHJcblxuICAgIGxldCByZWMgZmlsdGVyIHAgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBFbXB0eVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSBhcyBtIC0+XG4gICAgICAgICAgKCogY2FsbCBbcF0gaW4gdGhlIGV4cGVjdGVkIGxlZnQtdG8tcmlnaHQgb3JkZXIgKilcbiAgICAgICAgICBsZXQgbCcgPSBmaWx0ZXIgcCBsIGluXG4gICAgICAgICAgbGV0IHB2ZCA9IHAgdiBkIGluXG4gICAgICAgICAgbGV0IHInID0gZmlsdGVyIHAgciBpblxuICAgICAgICAgIGlmIHB2ZCB0aGVuIGlmIGw9PWwnICYmIHI9PXInIHRoZW4gbSBlbHNlIGpvaW4gbCcgdiBkIHInXG4gICAgICAgICAgZWxzZSBjb25jYXQgbCcgcidcblxuICAgIGxldCByZWMgZmlsdGVyX21hcCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gRW1wdHlcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICAoKiBjYWxsIFtmXSBpbiB0aGUgZXhwZWN0ZWQgbGVmdC10by1yaWdodCBvcmRlciAqKVxuICAgICAgICAgIGxldCBsJyA9IGZpbHRlcl9tYXAgZiBsIGluXG4gICAgICAgICAgbGV0IGZ2ZCA9IGYgdiBkIGluXG4gICAgICAgICAgbGV0IHInID0gZmlsdGVyX21hcCBmIHIgaW5cbiAgICAgICAgICBiZWdpbiBtYXRjaCBmdmQgd2l0aFxuICAgICAgICAgICAgfCBTb21lIGQnIC0+IGpvaW4gbCcgdiBkJyByJ1xuICAgICAgICAgICAgfCBOb25lIC0+IGNvbmNhdCBsJyByJ1xuICAgICAgICAgIGVuZFxuXG4gICAgbGV0IHJlYyBwYXJ0aXRpb24gcCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IChFbXB0eSwgRW1wdHkpXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgKCogY2FsbCBbcF0gaW4gdGhlIGV4cGVjdGVkIGxlZnQtdG8tcmlnaHQgb3JkZXIgKilcbiAgICAgICAgICBsZXQgKGx0LCBsZikgPSBwYXJ0aXRpb24gcCBsIGluXG4gICAgICAgICAgbGV0IHB2ZCA9IHAgdiBkIGluXG4gICAgICAgICAgbGV0IChydCwgcmYpID0gcGFydGl0aW9uIHAgciBpblxuICAgICAgICAgIGlmIHB2ZFxuICAgICAgICAgIHRoZW4gKGpvaW4gbHQgdiBkIHJ0LCBjb25jYXQgbGYgcmYpXG4gICAgICAgICAgZWxzZSAoY29uY2F0IGx0IHJ0LCBqb2luIGxmIHYgZCByZilcblxuICAgIHR5cGUgJ2EgZW51bWVyYXRpb24gPSBFbmQgfCBNb3JlIG9mIGtleSAqICdhICogJ2EgdCAqICdhIGVudW1lcmF0aW9uXG5cbiAgICBsZXQgcmVjIGNvbnNfZW51bSBtIGUgPVxuICAgICAgbWF0Y2ggbSB3aXRoXG4gICAgICAgIEVtcHR5IC0+IGVcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT4gY29uc19lbnVtIGwgKE1vcmUodiwgZCwgciwgZSkpXG5cbiAgICBsZXQgY29tcGFyZSBjbXAgbTEgbTIgPVxuICAgICAgbGV0IHJlYyBjb21wYXJlX2F1eCBlMSBlMiA9XG4gICAgICAgICAgbWF0Y2ggKGUxLCBlMikgd2l0aFxuICAgICAgICAgIChFbmQsIEVuZCkgLT4gMFxuICAgICAgICB8IChFbmQsIF8pICAtPiAtMVxuICAgICAgICB8IChfLCBFbmQpIC0+IDFcbiAgICAgICAgfCAoTW9yZSh2MSwgZDEsIHIxLCBlMSksIE1vcmUodjIsIGQyLCByMiwgZTIpKSAtPlxuICAgICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB2MSB2MiBpblxuICAgICAgICAgICAgaWYgYyA8PiAwIHRoZW4gYyBlbHNlXG4gICAgICAgICAgICBsZXQgYyA9IGNtcCBkMSBkMiBpblxuICAgICAgICAgICAgaWYgYyA8PiAwIHRoZW4gYyBlbHNlXG4gICAgICAgICAgICBjb21wYXJlX2F1eCAoY29uc19lbnVtIHIxIGUxKSAoY29uc19lbnVtIHIyIGUyKVxuICAgICAgaW4gY29tcGFyZV9hdXggKGNvbnNfZW51bSBtMSBFbmQpIChjb25zX2VudW0gbTIgRW5kKVxuXG4gICAgbGV0IGVxdWFsIGNtcCBtMSBtMiA9XG4gICAgICBsZXQgcmVjIGVxdWFsX2F1eCBlMSBlMiA9XG4gICAgICAgICAgbWF0Y2ggKGUxLCBlMikgd2l0aFxuICAgICAgICAgIChFbmQsIEVuZCkgLT4gdHJ1ZVxuICAgICAgICB8IChFbmQsIF8pICAtPiBmYWxzZVxuICAgICAgICB8IChfLCBFbmQpIC0+IGZhbHNlXG4gICAgICAgIHwgKE1vcmUodjEsIGQxLCByMSwgZTEpLCBNb3JlKHYyLCBkMiwgcjIsIGUyKSkgLT5cbiAgICAgICAgICAgIE9yZC5jb21wYXJlIHYxIHYyID0gMCAmJiBjbXAgZDEgZDIgJiZcbiAgICAgICAgICAgIGVxdWFsX2F1eCAoY29uc19lbnVtIHIxIGUxKSAoY29uc19lbnVtIHIyIGUyKVxuICAgICAgaW4gZXF1YWxfYXV4IChjb25zX2VudW0gbTEgRW5kKSAoY29uc19lbnVtIG0yIEVuZClcblxuICAgIGxldCByZWMgY2FyZGluYWwgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiAwXG4gICAgICB8IE5vZGUge2w7IHJ9IC0+IGNhcmRpbmFsIGwgKyAxICsgY2FyZGluYWwgclxuXG4gICAgbGV0IHJlYyBiaW5kaW5nc19hdXggYWNjdSA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IGFjY3VcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT4gYmluZGluZ3NfYXV4ICgodiwgZCkgOjogYmluZGluZ3NfYXV4IGFjY3UgcikgbFxuXG4gICAgbGV0IGJpbmRpbmdzIHMgPVxuICAgICAgYmluZGluZ3NfYXV4IFtdIHNcblxuICAgIGxldCBjaG9vc2UgPSBtaW5fYmluZGluZ1xuXG4gICAgbGV0IGNob29zZV9vcHQgPSBtaW5fYmluZGluZ19vcHRcblxuICAgIGxldCBhZGRfc2VxIGkgbSA9XG4gICAgICBTZXEuZm9sZF9sZWZ0IChmdW4gbSAoayx2KSAtPiBhZGQgayB2IG0pIG0gaVxuXG4gICAgbGV0IG9mX3NlcSBpID0gYWRkX3NlcSBpIGVtcHR5XG5cbiAgICBsZXQgcmVjIHNlcV9vZl9lbnVtXyBjICgpID0gbWF0Y2ggYyB3aXRoXG4gICAgICB8IEVuZCAtPiBTZXEuTmlsXG4gICAgICB8IE1vcmUgKGssdix0LHJlc3QpIC0+IFNlcS5Db25zICgoayx2KSwgc2VxX29mX2VudW1fIChjb25zX2VudW0gdCByZXN0KSlcblxuICAgIGxldCB0b19zZXEgbSA9XG4gICAgICBzZXFfb2ZfZW51bV8gKGNvbnNfZW51bSBtIEVuZClcblxuICAgIGxldCByZWMgc25vY19lbnVtIHMgZSA9XG4gICAgICBtYXRjaCBzIHdpdGhcbiAgICAgICAgRW1wdHkgLT4gZVxuICAgICAgfCBOb2Rle2w7IHY7IGQ7IHJ9IC0+IHNub2NfZW51bSByIChNb3JlKHYsIGQsIGwsIGUpKVxuXG4gICAgbGV0IHJlYyByZXZfc2VxX29mX2VudW1fIGMgKCkgPSBtYXRjaCBjIHdpdGhcbiAgICAgIHwgRW5kIC0+IFNlcS5OaWxcbiAgICAgIHwgTW9yZSAoayx2LHQscmVzdCkgLT5cbiAgICAgICAgICBTZXEuQ29ucyAoKGssdiksIHJldl9zZXFfb2ZfZW51bV8gKHNub2NfZW51bSB0IHJlc3QpKVxuXG4gICAgbGV0IHRvX3Jldl9zZXEgYyA9XG4gICAgICByZXZfc2VxX29mX2VudW1fIChzbm9jX2VudW0gYyBFbmQpXG5cbiAgICBsZXQgdG9fc2VxX2Zyb20gbG93IG0gPVxuICAgICAgbGV0IHJlYyBhdXggbG93IG0gYyA9IG1hdGNoIG0gd2l0aFxuICAgICAgICB8IEVtcHR5IC0+IGNcbiAgICAgICAgfCBOb2RlIHtsOyB2OyBkOyByOyBffSAtPlxuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggT3JkLmNvbXBhcmUgdiBsb3cgd2l0aFxuICAgICAgICAgICAgICB8IDAgLT4gTW9yZSAodiwgZCwgciwgYylcbiAgICAgICAgICAgICAgfCBuIHdoZW4gbjwwIC0+IGF1eCBsb3cgciBjXG4gICAgICAgICAgICAgIHwgXyAtPiBhdXggbG93IGwgKE1vcmUgKHYsIGQsIHIsIGMpKVxuICAgICAgICAgICAgZW5kXG4gICAgICBpblxuICAgICAgc2VxX29mX2VudW1fIChhdXggbG93IG0gRW5kKVxuZW5kXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUgJ2EgdCA9IHsgbXV0YWJsZSBjIDogJ2EgbGlzdDsgbXV0YWJsZSBsZW4gOiBpbnQ7IH1cblxuZXhjZXB0aW9uIEVtcHR5XG5cbmxldCBjcmVhdGUgKCkgPSB7IGMgPSBbXTsgbGVuID0gMDsgfVxuXG5sZXQgY2xlYXIgcyA9IHMuYyA8LSBbXTsgcy5sZW4gPC0gMFxuXG5sZXQgY29weSBzID0geyBjID0gcy5jOyBsZW4gPSBzLmxlbjsgfVxuXG5sZXQgcHVzaCB4IHMgPSBzLmMgPC0geCA6OiBzLmM7IHMubGVuIDwtIHMubGVuICsgMVxuXG5sZXQgcG9wIHMgPVxuICBtYXRjaCBzLmMgd2l0aFxuICB8IGhkOjp0bCAtPiBzLmMgPC0gdGw7IHMubGVuIDwtIHMubGVuIC0gMTsgaGRcbiAgfCBbXSAgICAgLT4gcmFpc2UgRW1wdHlcblxubGV0IHBvcF9vcHQgcyA9XG4gIG1hdGNoIHMuYyB3aXRoXG4gIHwgaGQ6OnRsIC0+IHMuYyA8LSB0bDsgcy5sZW4gPC0gcy5sZW4gLSAxOyBTb21lIGhkXG4gIHwgW10gICAgIC0+IE5vbmVcblxubGV0IHRvcCBzID1cbiAgbWF0Y2ggcy5jIHdpdGhcbiAgfCBoZDo6XyAtPiBoZFxuICB8IFtdICAgIC0+IHJhaXNlIEVtcHR5XG5cbmxldCB0b3Bfb3B0IHMgPVxuICBtYXRjaCBzLmMgd2l0aFxuICB8IGhkOjpfIC0+IFNvbWUgaGRcbiAgfCBbXSAgICAtPiBOb25lXG5cbmxldCBpc19lbXB0eSBzID0gKHMuYyA9IFtdKVxuXG5sZXQgbGVuZ3RoIHMgPSBzLmxlblxuXG5sZXQgaXRlciBmIHMgPSBMaXN0Lml0ZXIgZiBzLmNcblxubGV0IGZvbGQgZiBhY2MgcyA9IExpc3QuZm9sZF9sZWZ0IGYgYWNjIHMuY1xuXG4oKiogezEgSXRlcmF0b3JzfSAqKVxuXG5sZXQgdG9fc2VxIHMgPSBMaXN0LnRvX3NlcSBzLmNcblxubGV0IGFkZF9zZXEgcSBpID0gU2VxLml0ZXIgKGZ1biB4IC0+IHB1c2ggeCBxKSBpXG5cbmxldCBvZl9zZXEgZyA9XG4gIGxldCBzID0gY3JlYXRlKCkgaW5cbiAgYWRkX3NlcSBzIGc7XG4gIHNcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgRnJhbmNvaXMgUG90dGllciwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgSmVyZW1pZSBEaW1pbm8sIEphbmUgU3RyZWV0IEV1cm9wZSAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMDIgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuZXhjZXB0aW9uIEVtcHR5XG5cbnR5cGUgJ2EgY2VsbCA9XG4gIHwgTmlsXG4gIHwgQ29ucyBvZiB7IGNvbnRlbnQ6ICdhOyBtdXRhYmxlIG5leHQ6ICdhIGNlbGwgfVxuXG50eXBlICdhIHQgPSB7XG4gIG11dGFibGUgbGVuZ3RoOiBpbnQ7XG4gIG11dGFibGUgZmlyc3Q6ICdhIGNlbGw7XG4gIG11dGFibGUgbGFzdDogJ2EgY2VsbFxufVxuXG5sZXQgY3JlYXRlICgpID0ge1xuICBsZW5ndGggPSAwO1xuICBmaXJzdCA9IE5pbDtcbiAgbGFzdCA9IE5pbFxufVxuXG5sZXQgY2xlYXIgcSA9XG4gIHEubGVuZ3RoIDwtIDA7XG4gIHEuZmlyc3QgPC0gTmlsO1xuICBxLmxhc3QgPC0gTmlsXG5cbmxldCBhZGQgeCBxID1cbiAgbGV0IGNlbGwgPSBDb25zIHtcbiAgICBjb250ZW50ID0geDtcbiAgICBuZXh0ID0gTmlsXG4gIH0gaW5cbiAgbWF0Y2ggcS5sYXN0IHdpdGhcbiAgfCBOaWwgLT5cbiAgICBxLmxlbmd0aCA8LSAxO1xuICAgIHEuZmlyc3QgPC0gY2VsbDtcbiAgICBxLmxhc3QgPC0gY2VsbFxuICB8IENvbnMgbGFzdCAtPlxuICAgIHEubGVuZ3RoIDwtIHEubGVuZ3RoICsgMTtcbiAgICBsYXN0Lm5leHQgPC0gY2VsbDtcbiAgICBxLmxhc3QgPC0gY2VsbFxuXG5sZXQgcHVzaCA9XG4gIGFkZFxuXG5sZXQgcGVlayBxID1cbiAgbWF0Y2ggcS5maXJzdCB3aXRoXG4gIHwgTmlsIC0+IHJhaXNlIEVtcHR5XG4gIHwgQ29ucyB7IGNvbnRlbnQgfSAtPiBjb250ZW50XG5cbmxldCBwZWVrX29wdCBxID1cbiAgbWF0Y2ggcS5maXJzdCB3aXRoXG4gIHwgTmlsIC0+IE5vbmVcbiAgfCBDb25zIHsgY29udGVudCB9IC0+IFNvbWUgY29udGVudFxuXG5sZXQgdG9wID1cbiAgcGVla1xuXG5sZXQgdGFrZSBxID1cbiAgbWF0Y2ggcS5maXJzdCB3aXRoXG4gIHwgTmlsIC0+IHJhaXNlIEVtcHR5XG4gIHwgQ29ucyB7IGNvbnRlbnQ7IG5leHQgPSBOaWwgfSAtPlxuICAgIGNsZWFyIHE7XG4gICAgY29udGVudFxuICB8IENvbnMgeyBjb250ZW50OyBuZXh0IH0gLT5cbiAgICBxLmxlbmd0aCA8LSBxLmxlbmd0aCAtIDE7XG4gICAgcS5maXJzdCA8LSBuZXh0O1xuICAgIGNvbnRlbnRcblxubGV0IHRha2Vfb3B0IHEgPVxuICBtYXRjaCBxLmZpcnN0IHdpdGhcbiAgfCBOaWwgLT4gTm9uZVxuICB8IENvbnMgeyBjb250ZW50OyBuZXh0ID0gTmlsIH0gLT5cbiAgICBjbGVhciBxO1xuICAgIFNvbWUgY29udGVudFxuICB8IENvbnMgeyBjb250ZW50OyBuZXh0IH0gLT5cbiAgICBxLmxlbmd0aCA8LSBxLmxlbmd0aCAtIDE7XG4gICAgcS5maXJzdCA8LSBuZXh0O1xuICAgIFNvbWUgY29udGVudFxuXG5sZXQgcG9wID1cbiAgdGFrZVxuXG5sZXQgY29weSA9XG4gIGxldCByZWMgY29weSBxX3JlcyBwcmV2IGNlbGwgPVxuICAgIG1hdGNoIGNlbGwgd2l0aFxuICAgIHwgTmlsIC0+IHFfcmVzLmxhc3QgPC0gcHJldjsgcV9yZXNcbiAgICB8IENvbnMgeyBjb250ZW50OyBuZXh0IH0gLT5cbiAgICAgIGxldCByZXMgPSBDb25zIHsgY29udGVudDsgbmV4dCA9IE5pbCB9IGluXG4gICAgICBiZWdpbiBtYXRjaCBwcmV2IHdpdGhcbiAgICAgIHwgTmlsIC0+IHFfcmVzLmZpcnN0IDwtIHJlc1xuICAgICAgfCBDb25zIHAgLT4gcC5uZXh0IDwtIHJlc1xuICAgICAgZW5kO1xuICAgICAgY29weSBxX3JlcyByZXMgbmV4dFxuICBpblxuICBmdW4gcSAtPiBjb3B5IHsgbGVuZ3RoID0gcS5sZW5ndGg7IGZpcnN0ID0gTmlsOyBsYXN0ID0gTmlsIH0gTmlsIHEuZmlyc3RcblxubGV0IGlzX2VtcHR5IHEgPVxuICBxLmxlbmd0aCA9IDBcblxubGV0IGxlbmd0aCBxID1cbiAgcS5sZW5ndGhcblxubGV0IGl0ZXIgPVxuICBsZXQgcmVjIGl0ZXIgZiBjZWxsID1cbiAgICBtYXRjaCBjZWxsIHdpdGhcbiAgICB8IE5pbCAtPiAoKVxuICAgIHwgQ29ucyB7IGNvbnRlbnQ7IG5leHQgfSAtPlxuICAgICAgZiBjb250ZW50O1xuICAgICAgaXRlciBmIG5leHRcbiAgaW5cbiAgZnVuIGYgcSAtPiBpdGVyIGYgcS5maXJzdFxuXG5sZXQgZm9sZCA9XG4gIGxldCByZWMgZm9sZCBmIGFjY3UgY2VsbCA9XG4gICAgbWF0Y2ggY2VsbCB3aXRoXG4gICAgfCBOaWwgLT4gYWNjdVxuICAgIHwgQ29ucyB7IGNvbnRlbnQ7IG5leHQgfSAtPlxuICAgICAgbGV0IGFjY3UgPSBmIGFjY3UgY29udGVudCBpblxuICAgICAgZm9sZCBmIGFjY3UgbmV4dFxuICBpblxuICBmdW4gZiBhY2N1IHEgLT4gZm9sZCBmIGFjY3UgcS5maXJzdFxuXG5sZXQgdHJhbnNmZXIgcTEgcTIgPVxuICBpZiBxMS5sZW5ndGggPiAwIHRoZW5cbiAgICBtYXRjaCBxMi5sYXN0IHdpdGhcbiAgICB8IE5pbCAtPlxuICAgICAgcTIubGVuZ3RoIDwtIHExLmxlbmd0aDtcbiAgICAgIHEyLmZpcnN0IDwtIHExLmZpcnN0O1xuICAgICAgcTIubGFzdCA8LSBxMS5sYXN0O1xuICAgICAgY2xlYXIgcTFcbiAgICB8IENvbnMgbGFzdCAtPlxuICAgICAgcTIubGVuZ3RoIDwtIHEyLmxlbmd0aCArIHExLmxlbmd0aDtcbiAgICAgIGxhc3QubmV4dCA8LSBxMS5maXJzdDtcbiAgICAgIHEyLmxhc3QgPC0gcTEubGFzdDtcbiAgICAgIGNsZWFyIHExXG5cbigqKiB7MSBJdGVyYXRvcnN9ICopXG5cbmxldCB0b19zZXEgcSA9XG4gIGxldCByZWMgYXV4IGMgKCkgPSBtYXRjaCBjIHdpdGhcbiAgICB8IE5pbCAtPiBTZXEuTmlsXG4gICAgfCBDb25zIHsgY29udGVudD14OyBuZXh0OyB9IC0+IFNlcS5Db25zICh4LCBhdXggbmV4dClcbiAgaW5cbiAgYXV4IHEuZmlyc3RcblxubGV0IGFkZF9zZXEgcSBpID0gU2VxLml0ZXIgKGZ1biB4IC0+IHB1c2ggeCBxKSBpXG5cbmxldCBvZl9zZXEgZyA9XG4gIGxldCBxID0gY3JlYXRlKCkgaW5cbiAgYWRkX3NlcSBxIGc7XG4gIHFcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgRGFuaWVsIGRlIFJhdWdsYXVkcmUsIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTcgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxudHlwZSAnYSB0ID0gJ2EgY2VsbCBvcHRpb25cbmFuZCAnYSBjZWxsID0geyBtdXRhYmxlIGNvdW50IDogaW50OyBtdXRhYmxlIGRhdGEgOiAnYSBkYXRhIH1cbmFuZCAnYSBkYXRhID1cbiAgICBTZW1wdHlcbiAgfCBTY29ucyBvZiAnYSAqICdhIGRhdGFcbiAgfCBTYXBwIG9mICdhIGRhdGEgKiAnYSBkYXRhXG4gIHwgU2xhenkgb2YgJ2EgZGF0YSBMYXp5LnRcbiAgfCBTZ2VuIG9mICdhIGdlblxuICB8IFNidWZmaW8gOiBidWZmaW8gLT4gY2hhciBkYXRhXG5hbmQgJ2EgZ2VuID0geyBtdXRhYmxlIGN1cnIgOiAnYSBvcHRpb24gb3B0aW9uOyBmdW5jIDogaW50IC0+ICdhIG9wdGlvbiB9XG5hbmQgYnVmZmlvID1cbiAgeyBpYyA6IGluX2NoYW5uZWw7IGJ1ZmYgOiBieXRlczsgbXV0YWJsZSBsZW4gOiBpbnQ7IG11dGFibGUgaW5kIDogaW50IH1cblxuZXhjZXB0aW9uIEZhaWx1cmVcbmV4Y2VwdGlvbiBFcnJvciBvZiBzdHJpbmdcblxubGV0IGNvdW50ID0gZnVuY3Rpb25cbiAgfCBOb25lIC0+IDBcbiAgfCBTb21lIHsgY291bnQgfSAtPiBjb3VudFxubGV0IGRhdGEgPSBmdW5jdGlvblxuICB8IE5vbmUgLT4gU2VtcHR5XG4gIHwgU29tZSB7IGRhdGEgfSAtPiBkYXRhXG5cbmxldCBmaWxsX2J1ZmYgYiA9XG4gIGIubGVuIDwtIGlucHV0IGIuaWMgYi5idWZmIDAgKEJ5dGVzLmxlbmd0aCBiLmJ1ZmYpOyBiLmluZCA8LSAwXG5cblxubGV0IHJlYyBnZXRfZGF0YSA6IHR5cGUgdi4gaW50IC0+IHYgZGF0YSAtPiB2IGRhdGEgPSBmdW4gY291bnQgZCAtPiBtYXRjaCBkIHdpdGhcbiAoKiBSZXR1cm5zIGVpdGhlciBTZW1wdHkgb3IgU2NvbnMoYSwgXykgZXZlbiB3aGVuIGQgaXMgYSBnZW5lcmF0b3JcbiAgICBvciBhIGJ1ZmZlci4gSW4gdGhvc2UgY2FzZXMsIHRoZSBpdGVtIGEgaXMgc2VlbiBhcyBleHRyYWN0ZWQgZnJvbVxuIHRoZSBnZW5lcmF0b3IvYnVmZmVyLlxuIFRoZSBjb3VudCBwYXJhbWV0ZXIgaXMgdXNlZCBmb3IgY2FsbGluZyBgU2dlbi1mdW5jdGlvbnMnLiAgKilcbiAgIFNlbXB0eSB8IFNjb25zIChfLCBfKSAtPiBkXG4gfCBTYXBwIChkMSwgZDIpIC0+XG4gICAgIGJlZ2luIG1hdGNoIGdldF9kYXRhIGNvdW50IGQxIHdpdGhcbiAgICAgICBTY29ucyAoYSwgZDExKSAtPiBTY29ucyAoYSwgU2FwcCAoZDExLCBkMikpXG4gICAgIHwgU2VtcHR5IC0+IGdldF9kYXRhIGNvdW50IGQyXG4gICAgIHwgXyAtPiBhc3NlcnQgZmFsc2VcbiAgICAgZW5kXG4gfCBTZ2VuIHtjdXJyID0gU29tZSBOb25lfSAtPiBTZW1wdHlcbiB8IFNnZW4gKHtjdXJyID0gU29tZShTb21lIGEpfSBhcyBnKSAtPlxuICAgICBnLmN1cnIgPC0gTm9uZTsgU2NvbnMoYSwgZClcbiB8IFNnZW4gZyAtPlxuICAgICBiZWdpbiBtYXRjaCBnLmZ1bmMgY291bnQgd2l0aFxuICAgICAgIE5vbmUgLT4gZy5jdXJyIDwtIFNvbWUoTm9uZSk7IFNlbXB0eVxuICAgICB8IFNvbWUgYSAtPiBTY29ucyhhLCBkKVxuICAgICAgICAgKCogV2FybmluZzogYW55b25lIHVzaW5nIGcgdGhpbmtzIHRoYXQgYW4gaXRlbSBoYXMgYmVlbiByZWFkICopXG4gICAgIGVuZFxuIHwgU2J1ZmZpbyBiIC0+XG4gICAgIGlmIGIuaW5kID49IGIubGVuIHRoZW4gZmlsbF9idWZmIGI7XG4gICAgIGlmIGIubGVuID09IDAgdGhlbiBTZW1wdHkgZWxzZVxuICAgICAgIGxldCByID0gQnl0ZXMudW5zYWZlX2dldCBiLmJ1ZmYgYi5pbmQgaW5cbiAgICAgICAoKiBXYXJuaW5nOiBhbnlvbmUgdXNpbmcgZyB0aGlua3MgdGhhdCBhbiBpdGVtIGhhcyBiZWVuIHJlYWQgKilcbiAgICAgICBiLmluZCA8LSBzdWNjIGIuaW5kOyBTY29ucyhyLCBkKVxuIHwgU2xhenkgZiAtPiBnZXRfZGF0YSBjb3VudCAoTGF6eS5mb3JjZSBmKVxuXG5cbmxldCByZWMgcGVla19kYXRhIDogdHlwZSB2LiB2IGNlbGwgLT4gdiBvcHRpb24gPSBmdW4gcyAtPlxuICgqIGNvbnN1bHQgdGhlIGZpcnN0IGl0ZW0gb2YgcyAqKVxuIG1hdGNoIHMuZGF0YSB3aXRoXG4gICBTZW1wdHkgLT4gTm9uZVxuIHwgU2NvbnMgKGEsIF8pIC0+IFNvbWUgYVxuIHwgU2FwcCAoXywgXykgLT5cbiAgICAgYmVnaW4gbWF0Y2ggZ2V0X2RhdGEgcy5jb3VudCBzLmRhdGEgd2l0aFxuICAgICAgIFNjb25zKGEsIF8pIGFzIGQgLT4gcy5kYXRhIDwtIGQ7IFNvbWUgYVxuICAgICB8IFNlbXB0eSAtPiBOb25lXG4gICAgIHwgXyAtPiBhc3NlcnQgZmFsc2VcbiAgICAgZW5kXG4gfCBTbGF6eSBmIC0+IHMuZGF0YSA8LSAoTGF6eS5mb3JjZSBmKTsgcGVla19kYXRhIHNcbiB8IFNnZW4ge2N1cnIgPSBTb21lIGF9IC0+IGFcbiB8IFNnZW4gZyAtPiBsZXQgeCA9IGcuZnVuYyBzLmNvdW50IGluIGcuY3VyciA8LSBTb21lIHg7IHhcbiB8IFNidWZmaW8gYiAtPlxuICAgICBpZiBiLmluZCA+PSBiLmxlbiB0aGVuIGZpbGxfYnVmZiBiO1xuICAgICBpZiBiLmxlbiA9PSAwIHRoZW4gYmVnaW4gcy5kYXRhIDwtIFNlbXB0eTsgTm9uZSBlbmRcbiAgICAgZWxzZSBTb21lIChCeXRlcy51bnNhZmVfZ2V0IGIuYnVmZiBiLmluZClcblxuXG5sZXQgcGVlayA9IGZ1bmN0aW9uXG4gIHwgTm9uZSAtPiBOb25lXG4gIHwgU29tZSBzIC0+IHBlZWtfZGF0YSBzXG5cblxubGV0IHJlYyBqdW5rX2RhdGEgOiB0eXBlIHYuIHYgY2VsbCAtPiB1bml0ID0gZnVuIHMgLT5cbiAgbWF0Y2ggcy5kYXRhIHdpdGhcbiAgICBTY29ucyAoXywgZCkgLT4gcy5jb3VudCA8LSAoc3VjYyBzLmNvdW50KTsgcy5kYXRhIDwtIGRcbiAgfCBTZ2VuICh7Y3VyciA9IFNvbWUgX30gYXMgZykgLT4gcy5jb3VudCA8LSAoc3VjYyBzLmNvdW50KTsgZy5jdXJyIDwtIE5vbmVcbiAgfCBTYnVmZmlvIGIgLT5cbiAgICAgIGlmIGIuaW5kID49IGIubGVuIHRoZW4gZmlsbF9idWZmIGI7XG4gICAgICBpZiBiLmxlbiA9PSAwIHRoZW4gcy5kYXRhIDwtIFNlbXB0eVxuICAgICAgZWxzZSAocy5jb3VudCA8LSAoc3VjYyBzLmNvdW50KTsgYi5pbmQgPC0gc3VjYyBiLmluZClcbiAgfCBfIC0+XG4gICAgICBtYXRjaCBwZWVrX2RhdGEgcyB3aXRoXG4gICAgICAgIE5vbmUgLT4gKClcbiAgICAgIHwgU29tZSBfIC0+IGp1bmtfZGF0YSBzXG5cblxubGV0IGp1bmsgPSBmdW5jdGlvblxuICB8IE5vbmUgLT4gKClcbiAgfCBTb21lIGRhdGEgLT4ganVua19kYXRhIGRhdGFcblxubGV0IHJlYyBuZ2V0X2RhdGEgbiBzID1cbiAgaWYgbiA8PSAwIHRoZW4gW10sIHMuZGF0YSwgMFxuICBlbHNlXG4gICAgbWF0Y2ggcGVla19kYXRhIHMgd2l0aFxuICAgICAgU29tZSBhIC0+XG4gICAgICAgIGp1bmtfZGF0YSBzO1xuICAgICAgICBsZXQgKGFsLCBkLCBrKSA9IG5nZXRfZGF0YSAocHJlZCBuKSBzIGluIGEgOjogYWwsIFNjb25zIChhLCBkKSwgc3VjYyBrXG4gICAgfCBOb25lIC0+IFtdLCBzLmRhdGEsIDBcblxuXG5sZXQgbnBlZWtfZGF0YSBuIHMgPVxuICBsZXQgKGFsLCBkLCBsZW4pID0gbmdldF9kYXRhIG4gcyBpblxuICBzLmNvdW50IDwtIChzLmNvdW50IC0gbGVuKTtcbiAgcy5kYXRhIDwtIGQ7XG4gIGFsXG5cblxubGV0IG5wZWVrIG4gPSBmdW5jdGlvblxuICB8IE5vbmUgLT4gW11cbiAgfCBTb21lIGQgLT4gbnBlZWtfZGF0YSBuIGRcblxubGV0IG5leHQgcyA9XG4gIG1hdGNoIHBlZWsgcyB3aXRoXG4gICAgU29tZSBhIC0+IGp1bmsgczsgYVxuICB8IE5vbmUgLT4gcmFpc2UgRmFpbHVyZVxuXG5cbmxldCBlbXB0eSBzID1cbiAgbWF0Y2ggcGVlayBzIHdpdGhcbiAgICBTb21lIF8gLT4gcmFpc2UgRmFpbHVyZVxuICB8IE5vbmUgLT4gKClcblxuXG5sZXQgaXRlciBmIHN0cm0gPVxuICBsZXQgcmVjIGRvX3JlYyAoKSA9XG4gICAgbWF0Y2ggcGVlayBzdHJtIHdpdGhcbiAgICAgIFNvbWUgYSAtPiBqdW5rIHN0cm07IGlnbm9yZShmIGEpOyBkb19yZWMgKClcbiAgICB8IE5vbmUgLT4gKClcbiAgaW5cbiAgZG9fcmVjICgpXG5cblxuKCogU3RyZWFtIGJ1aWxkaW5nIGZ1bmN0aW9ucyAqKVxuXG5sZXQgZnJvbSBmID0gU29tZSB7Y291bnQgPSAwOyBkYXRhID0gU2dlbiB7Y3VyciA9IE5vbmU7IGZ1bmMgPSBmfX1cblxubGV0IG9mX2xpc3QgbCA9XG4gIFNvbWUge2NvdW50ID0gMDsgZGF0YSA9IExpc3QuZm9sZF9yaWdodCAoZnVuIHggbCAtPiBTY29ucyAoeCwgbCkpIGwgU2VtcHR5fVxuXG5cbmxldCBvZl9zdHJpbmcgcyA9XG4gIGxldCBjb3VudCA9IHJlZiAwIGluXG4gIGZyb20gKGZ1biBfIC0+XG4gICAgKCogV2UgY2Fubm90IHVzZSB0aGUgaW5kZXggcGFzc2VkIGJ5IHRoZSBbZnJvbV0gZnVuY3Rpb24gZGlyZWN0bHlcbiAgICAgICBiZWNhdXNlIGl0IHJldHVybnMgdGhlIGN1cnJlbnQgc3RyZWFtIGNvdW50LCB3aXRoIGFic29sdXRlbHkgbm9cbiAgICAgICBndWFyYW50ZWUgdGhhdCBpdCB3aWxsIHN0YXJ0IGZyb20gMC4gRm9yIGV4YW1wbGUsIGluIHRoZSBjYXNlXG4gICAgICAgb2YgW1N0cmVhbS5pY29ucyAnYycgKFN0cmVhbS5mcm9tX3N0cmluZyBcImFiXCIpXSwgdGhlIGZpcnN0XG4gICAgICAgYWNjZXNzIHRvIHRoZSBzdHJpbmcgd2lsbCBiZSBtYWRlIHdpdGggY291bnQgWzFdIGFscmVhZHkuXG4gICAgKilcbiAgICBsZXQgYyA9ICFjb3VudCBpblxuICAgIGlmIGMgPCBTdHJpbmcubGVuZ3RoIHNcbiAgICB0aGVuIChpbmNyIGNvdW50OyBTb21lIHMuW2NdKVxuICAgIGVsc2UgTm9uZSlcblxuXG5sZXQgb2ZfYnl0ZXMgcyA9XG4gIGxldCBjb3VudCA9IHJlZiAwIGluXG4gIGZyb20gKGZ1biBfIC0+XG4gICAgbGV0IGMgPSAhY291bnQgaW5cbiAgICBpZiBjIDwgQnl0ZXMubGVuZ3RoIHNcbiAgICB0aGVuIChpbmNyIGNvdW50OyBTb21lIChCeXRlcy5nZXQgcyBjKSlcbiAgICBlbHNlIE5vbmUpXG5cblxubGV0IG9mX2NoYW5uZWwgaWMgPVxuICBTb21lIHtjb3VudCA9IDA7XG4gICAgICAgIGRhdGEgPSBTYnVmZmlvIHtpYyA9IGljOyBidWZmID0gQnl0ZXMuY3JlYXRlIDQwOTY7IGxlbiA9IDA7IGluZCA9IDB9fVxuXG5cbigqIFN0cmVhbSBleHByZXNzaW9ucyBidWlsZGVycyAqKVxuXG5sZXQgaWFwcCBpIHMgPSBTb21lIHtjb3VudCA9IDA7IGRhdGEgPSBTYXBwIChkYXRhIGksIGRhdGEgcyl9XG5sZXQgaWNvbnMgaSBzID0gU29tZSB7Y291bnQgPSAwOyBkYXRhID0gU2NvbnMgKGksIGRhdGEgcyl9XG5sZXQgaXNpbmcgaSA9IFNvbWUge2NvdW50ID0gMDsgZGF0YSA9IFNjb25zIChpLCBTZW1wdHkpfVxuXG5sZXQgbGFwcCBmIHMgPVxuICBTb21lIHtjb3VudCA9IDA7IGRhdGEgPSBTbGF6eSAobGF6eShTYXBwIChkYXRhIChmICgpKSwgZGF0YSBzKSkpfVxuXG5sZXQgbGNvbnMgZiBzID0gU29tZSB7Y291bnQgPSAwOyBkYXRhID0gU2xhenkgKGxhenkoU2NvbnMgKGYgKCksIGRhdGEgcykpKX1cbmxldCBsc2luZyBmID0gU29tZSB7Y291bnQgPSAwOyBkYXRhID0gU2xhenkgKGxhenkoU2NvbnMgKGYgKCksIFNlbXB0eSkpKX1cblxubGV0IHNlbXB0eSA9IE5vbmVcbmxldCBzbGF6eSBmID0gU29tZSB7Y291bnQgPSAwOyBkYXRhID0gU2xhenkgKGxhenkoZGF0YSAoZiAoKSkpKX1cblxuKCogRm9yIGRlYnVnZ2luZyB1c2UgKilcblxubGV0IHJlYyBkdW1wIDogdHlwZSB2LiAodiAtPiB1bml0KSAtPiB2IHQgLT4gdW5pdCA9IGZ1biBmIHMgLT5cbiAgcHJpbnRfc3RyaW5nIFwie2NvdW50ID0gXCI7XG4gIHByaW50X2ludCAoY291bnQgcyk7XG4gIHByaW50X3N0cmluZyBcIjsgZGF0YSA9IFwiO1xuICBkdW1wX2RhdGEgZiAoZGF0YSBzKTtcbiAgcHJpbnRfc3RyaW5nIFwifVwiO1xuICBwcmludF9uZXdsaW5lICgpXG5hbmQgZHVtcF9kYXRhIDogdHlwZSB2LiAodiAtPiB1bml0KSAtPiB2IGRhdGEgLT4gdW5pdCA9IGZ1biBmIC0+XG4gIGZ1bmN0aW9uXG4gICAgU2VtcHR5IC0+IHByaW50X3N0cmluZyBcIlNlbXB0eVwiXG4gIHwgU2NvbnMgKGEsIGQpIC0+XG4gICAgICBwcmludF9zdHJpbmcgXCJTY29ucyAoXCI7XG4gICAgICBmIGE7XG4gICAgICBwcmludF9zdHJpbmcgXCIsIFwiO1xuICAgICAgZHVtcF9kYXRhIGYgZDtcbiAgICAgIHByaW50X3N0cmluZyBcIilcIlxuICB8IFNhcHAgKGQxLCBkMikgLT5cbiAgICAgIHByaW50X3N0cmluZyBcIlNhcHAgKFwiO1xuICAgICAgZHVtcF9kYXRhIGYgZDE7XG4gICAgICBwcmludF9zdHJpbmcgXCIsIFwiO1xuICAgICAgZHVtcF9kYXRhIGYgZDI7XG4gICAgICBwcmludF9zdHJpbmcgXCIpXCJcbiAgfCBTbGF6eSBfIC0+IHByaW50X3N0cmluZyBcIlNsYXp5XCJcbiAgfCBTZ2VuIF8gLT4gcHJpbnRfc3RyaW5nIFwiU2dlblwiXG4gIHwgU2J1ZmZpbyBfIC0+IHByaW50X3N0cmluZyBcIlNidWZmaW9cIlxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgUGllcnJlIFdlaXMgYW5kIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5OSBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBFeHRlbnNpYmxlIGJ1ZmZlcnMgKilcblxudHlwZSB0ID1cbiB7bXV0YWJsZSBidWZmZXIgOiBieXRlcztcbiAgbXV0YWJsZSBwb3NpdGlvbiA6IGludDtcbiAgbXV0YWJsZSBsZW5ndGggOiBpbnQ7XG4gIGluaXRpYWxfYnVmZmVyIDogYnl0ZXN9XG4oKiBJbnZhcmlhbnRzOiBhbGwgcGFydHMgb2YgdGhlIGNvZGUgcHJlc2VydmUgdGhlIGludmFyaWFudHMgdGhhdDpcbiAgIC0gWzAgPD0gYi5wb3NpdGlvbiA8PSBiLmxlbmd0aF1cbiAgIC0gW2IubGVuZ3RoID0gQnl0ZXMubGVuZ3RoIGIuYnVmZmVyXVxuXG4gICBOb3RlIGluIHBhcnRpY3VsYXIgdGhhdCBbYi5wb3NpdGlvbiA9IGIubGVuZ3RoXSBpcyBsZWdhbCxcbiAgIGl0IG1lYW5zIHRoYXQgdGhlIGJ1ZmZlciBpcyBmdWxsIGFuZCB3aWxsIGhhdmUgdG8gYmUgZXh0ZW5kZWRcbiAgIGJlZm9yZSBhbnkgZnVydGhlciBhZGRpdGlvbi4gKilcblxubGV0IGNyZWF0ZSBuID1cbiBsZXQgbiA9IGlmIG4gPCAxIHRoZW4gMSBlbHNlIG4gaW5cbiBsZXQgbiA9IGlmIG4gPiBTeXMubWF4X3N0cmluZ19sZW5ndGggdGhlbiBTeXMubWF4X3N0cmluZ19sZW5ndGggZWxzZSBuIGluXG4gbGV0IHMgPSBCeXRlcy5jcmVhdGUgbiBpblxuIHtidWZmZXIgPSBzOyBwb3NpdGlvbiA9IDA7IGxlbmd0aCA9IG47IGluaXRpYWxfYnVmZmVyID0gc31cblxubGV0IGNvbnRlbnRzIGIgPSBCeXRlcy5zdWJfc3RyaW5nIGIuYnVmZmVyIDAgYi5wb3NpdGlvblxubGV0IHRvX2J5dGVzIGIgPSBCeXRlcy5zdWIgYi5idWZmZXIgMCBiLnBvc2l0aW9uXG5cbmxldCBzdWIgYiBvZnMgbGVuID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IGIucG9zaXRpb24gLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIkJ1ZmZlci5zdWJcIlxuICBlbHNlIEJ5dGVzLnN1Yl9zdHJpbmcgYi5idWZmZXIgb2ZzIGxlblxuXG5cbmxldCBibGl0IHNyYyBzcmNvZmYgZHN0IGRzdG9mZiBsZW4gPVxuICBpZiBsZW4gPCAwIHx8IHNyY29mZiA8IDAgfHwgc3Jjb2ZmID4gc3JjLnBvc2l0aW9uIC0gbGVuXG4gICAgICAgICAgICAgfHwgZHN0b2ZmIDwgMCB8fCBkc3RvZmYgPiAoQnl0ZXMubGVuZ3RoIGRzdCkgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIkJ1ZmZlci5ibGl0XCJcbiAgZWxzZVxuICAgIEJ5dGVzLnVuc2FmZV9ibGl0IHNyYy5idWZmZXIgc3Jjb2ZmIGRzdCBkc3RvZmYgbGVuXG5cblxubGV0IG50aCBiIG9mcyA9XG4gIGlmIG9mcyA8IDAgfHwgb2ZzID49IGIucG9zaXRpb24gdGhlblxuICAgaW52YWxpZF9hcmcgXCJCdWZmZXIubnRoXCJcbiAgZWxzZSBCeXRlcy51bnNhZmVfZ2V0IGIuYnVmZmVyIG9mc1xuXG5cbmxldCBsZW5ndGggYiA9IGIucG9zaXRpb25cblxubGV0IGNsZWFyIGIgPSBiLnBvc2l0aW9uIDwtIDBcblxubGV0IHJlc2V0IGIgPVxuICBiLnBvc2l0aW9uIDwtIDA7XG4gIGIuYnVmZmVyIDwtIGIuaW5pdGlhbF9idWZmZXI7XG4gIGIubGVuZ3RoIDwtIEJ5dGVzLmxlbmd0aCBiLmJ1ZmZlclxuXG4oKiBbcmVzaXplIGIgbW9yZV0gZW5zdXJlcyB0aGF0IFtiLnBvc2l0aW9uICsgbW9yZSA8PSBiLmxlbmd0aF0gaG9sZHNcbiAgIGJ5IGR5bmFtaWNhbGx5IGV4dGVuZGluZyBbYi5idWZmZXJdIGlmIG5lY2Vzc2FyeSAtLSBhbmQgdGh1c1xuICAgaW5jcmVhc2luZyBbYi5sZW5ndGhdLlxuXG4gICBJbiBwYXJ0aWN1bGFyLCBhZnRlciBbcmVzaXplIGIgbW9yZV0gaXMgY2FsbGVkLCBhIGRpcmVjdCBhY2Nlc3Mgb2ZcbiAgIHNpemUgW21vcmVdIGF0IFtiLnBvc2l0aW9uXSB3aWxsIGFsd2F5cyBiZSBpbi1ib3VuZHMsIHNvIHRoYXRcbiAgICh1bnNhZmVfe2dldCxzZXR9KSBtYXkgYmUgdXNlZCBmb3IgcGVyZm9ybWFuY2UuXG4qKVxubGV0IHJlc2l6ZSBiIG1vcmUgPVxuICBsZXQgb2xkX3BvcyA9IGIucG9zaXRpb24gaW5cbiAgbGV0IG9sZF9sZW4gPSBiLmxlbmd0aCBpblxuICBsZXQgbmV3X2xlbiA9IHJlZiBvbGRfbGVuIGluXG4gIHdoaWxlIG9sZF9wb3MgKyBtb3JlID4gIW5ld19sZW4gZG8gbmV3X2xlbiA6PSAyICogIW5ld19sZW4gZG9uZTtcbiAgaWYgIW5ld19sZW4gPiBTeXMubWF4X3N0cmluZ19sZW5ndGggdGhlbiBiZWdpblxuICAgIGlmIG9sZF9wb3MgKyBtb3JlIDw9IFN5cy5tYXhfc3RyaW5nX2xlbmd0aFxuICAgIHRoZW4gbmV3X2xlbiA6PSBTeXMubWF4X3N0cmluZ19sZW5ndGhcbiAgICBlbHNlIGZhaWx3aXRoIFwiQnVmZmVyLmFkZDogY2Fubm90IGdyb3cgYnVmZmVyXCJcbiAgZW5kO1xuICBsZXQgbmV3X2J1ZmZlciA9IEJ5dGVzLmNyZWF0ZSAhbmV3X2xlbiBpblxuICAoKiBQUiM2MTQ4OiBsZXQncyBrZWVwIHVzaW5nIFtibGl0XSByYXRoZXIgdGhhbiBbdW5zYWZlX2JsaXRdIGluXG4gICAgIHRoaXMgdHJpY2t5IGZ1bmN0aW9uIHRoYXQgaXMgc2xvdyBhbnl3YXkuICopXG4gIEJ5dGVzLmJsaXQgYi5idWZmZXIgMCBuZXdfYnVmZmVyIDAgYi5wb3NpdGlvbjtcbiAgYi5idWZmZXIgPC0gbmV3X2J1ZmZlcjtcbiAgYi5sZW5ndGggPC0gIW5ld19sZW47XG4gIGFzc2VydCAoYi5wb3NpdGlvbiArIG1vcmUgPD0gYi5sZW5ndGgpO1xuICBhc3NlcnQgKG9sZF9wb3MgKyBtb3JlIDw9IGIubGVuZ3RoKTtcbiAgKClcbiAgKCogTm90ZTogdGhlcmUgYXJlIHZhcmlvdXMgc2l0dWF0aW9ucyAocHJlZW1wdGl2ZSB0aHJlYWRzLCBzaWduYWxzIGFuZFxuICAgICBnYyBmaW5hbGl6ZXJzKSB3aGVyZSBPQ2FtbCBjb2RlIG1heSBiZSBydW4gYXN5bmNocm9ub3VzbHk7IGluXG4gICAgIHBhcnRpY3VsYXIsIHRoZXJlIG1heSBiZSBhIHJhY2Ugd2l0aCBhbm90aGVyIHVzZXIgb2YgW2JdLCBjaGFuZ2luZ1xuICAgICBpdHMgbXV0YWJsZSBmaWVsZHMgaW4gdGhlIG1pZGRsZSBvZiB0aGUgW3Jlc2l6ZV0gY2FsbC4gVGhlIEJ1ZmZlclxuICAgICBtb2R1bGUgZG9lcyBub3QgcHJvdmlkZSBhbnkgY29ycmVjdG5lc3MgZ3VhcmFudGVlIGlmIHRoYXQgaGFwcGVucyxcbiAgICAgYnV0IHdlIG11c3Qgc3RpbGwgZW5zdXJlIHRoYXQgdGhlIGRhdGFzdHJ1Y3R1cmUgaW52YXJpYW50cyBob2xkIGZvclxuICAgICBtZW1vcnktc2FmZXR5IC0tIGFzIHdlIHBsYW4gdG8gdXNlIFt1bnNhZmVfe2dldCxzZXR9XS5cblxuICAgICBUaGVyZSBhcmUgdHdvIHBvdGVudGlhbCBhbGxvY2F0aW9uIHBvaW50cyBpbiB0aGlzIGZ1bmN0aW9uLFxuICAgICBbcmVmXSBhbmQgW0J5dGVzLmNyZWF0ZV0sIGJ1dCBhbGwgcmVhZHMgYW5kIHdyaXRlcyB0byB0aGUgZmllbGRzXG4gICAgIG9mIFtiXSBoYXBwZW4gYmVmb3JlIGJvdGggb2YgdGhlbSBvciBhZnRlciBib3RoIG9mIHRoZW0uXG5cbiAgICAgV2UgdGhlcmVmb3JlIGFzc3VtZSB0aGF0IFtiLnBvc2l0aW9uXSBtYXkgY2hhbmdlIGF0IHRoZXNlIGFsbG9jYXRpb25zLFxuICAgICBhbmQgY2hlY2sgdGhhdCB0aGUgW2IucG9zaXRpb24gKyBtb3JlIDw9IGIubGVuZ3RoXSBwb3N0Y29uZGl0aW9uXG4gICAgIGhvbGRzIGZvciBib3RoIHZhbHVlcyBvZiBbYi5wb3NpdGlvbl0sIGJlZm9yZSBvciBhZnRlciB0aGUgZnVuY3Rpb25cbiAgICAgaXMgY2FsbGVkLiBNb3JlIHByZWNpc2VseSwgdGhlIGZvbGxvd2luZyBpbnZhcmlhbnRzIG11c3QgaG9sZCBpZiB0aGVcbiAgICAgZnVuY3Rpb24gcmV0dXJucyBjb3JyZWN0bHksIGluIGFkZGl0aW9uIHRvIHRoZSB1c3VhbCBidWZmZXIgaW52YXJpYW50czpcbiAgICAgLSBbb2xkKGIucG9zaXRpb24pICsgbW9yZSA8PSBuZXcoYi5sZW5ndGgpXVxuICAgICAtIFtuZXcoYi5wb3NpdGlvbikgKyBtb3JlIDw9IG5ldyhiLmxlbmd0aCldXG4gICAgIC0gW29sZChiLmxlbmd0aCkgPD0gbmV3KGIubGVuZ3RoKV1cblxuICAgICBOb3RlOiBbYi5wb3NpdGlvbiArIG1vcmUgPD0gb2xkKGIubGVuZ3RoKV0gZG9lcyAqbm90KlxuICAgICBob2xkIGluIGdlbmVyYWwsIGFzIGl0IGlzIHByZWNpc2VseSB0aGUgY2FzZSB3aGVyZSB5b3UgbmVlZFxuICAgICB0byBjYWxsIFtyZXNpemVdIHRvIGluY3JlYXNlIFtiLmxlbmd0aF0uXG5cbiAgICAgTm90ZTogW2Fzc2VydF0gYWJvdmUgZG9lcyBub3QgbWVhbiB0aGF0IHdlIGtub3cgdGhlIGNvbmRpdGlvbnNcbiAgICAgYWx3YXlzIGhvbGQsIGJ1dCB0aGF0IHRoZSBmdW5jdGlvbiBtYXkgcmV0dXJuIGNvcnJlY3RseVxuICAgICBvbmx5IGlmIHRoZXkgaG9sZC5cblxuICAgICBOb3RlOiB0aGUgb3RoZXIgZnVuY3Rpb25zIGluIHRoaXMgbW9kdWxlIGRvZXMgbm90IG5lZWRcbiAgICAgdG8gYmUgY2hlY2tlZCB3aXRoIHRoaXMgbGV2ZWwgb2Ygc2NydXRpbnksIGdpdmVuIHRoYXQgdGhleVxuICAgICByZWFkL3dyaXRlIHRoZSBidWZmZXIgaW1tZWRpYXRlbHkgYWZ0ZXIgY2hlY2tpbmcgdGhhdFxuICAgICBbYi5wb3NpdGlvbiArIG1vcmUgPD0gYi5sZW5ndGhdIGhvbGQgb3IgY2FsbGluZyBbcmVzaXplXS5cbiAgKilcblxubGV0IGFkZF9jaGFyIGIgYyA9XG4gIGxldCBwb3MgPSBiLnBvc2l0aW9uIGluXG4gIGlmIHBvcyA+PSBiLmxlbmd0aCB0aGVuIHJlc2l6ZSBiIDE7XG4gIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgcG9zIGM7XG4gIGIucG9zaXRpb24gPC0gcG9zICsgMVxuXG5sZXQgdWNoYXJfdXRmXzhfYnl0ZV9sZW5ndGhfbWF4ID0gNFxubGV0IHVjaGFyX3V0Zl8xNl9ieXRlX2xlbmd0aF9tYXggPSA0XG5cbmxldCByZWMgYWRkX3V0Zl84X3VjaGFyIGIgdSA9XG4gIGxldCBwb3MgPSBiLnBvc2l0aW9uIGluXG4gIGlmIHBvcyA+PSBiLmxlbmd0aCB0aGVuIHJlc2l6ZSBiIHVjaGFyX3V0Zl84X2J5dGVfbGVuZ3RoX21heDtcbiAgbGV0IG4gPSBCeXRlcy5zZXRfdXRmXzhfdWNoYXIgYi5idWZmZXIgcG9zIHUgaW5cbiAgaWYgbiA9IDBcbiAgdGhlbiAocmVzaXplIGIgdWNoYXJfdXRmXzhfYnl0ZV9sZW5ndGhfbWF4OyBhZGRfdXRmXzhfdWNoYXIgYiB1KVxuICBlbHNlIChiLnBvc2l0aW9uIDwtIHBvcyArIG4pXG5cbmxldCByZWMgYWRkX3V0Zl8xNmJlX3VjaGFyIGIgdSA9XG4gIGxldCBwb3MgPSBiLnBvc2l0aW9uIGluXG4gIGlmIHBvcyA+PSBiLmxlbmd0aCB0aGVuIHJlc2l6ZSBiIHVjaGFyX3V0Zl8xNl9ieXRlX2xlbmd0aF9tYXg7XG4gIGxldCBuID0gQnl0ZXMuc2V0X3V0Zl8xNmJlX3VjaGFyIGIuYnVmZmVyIHBvcyB1IGluXG4gIGlmIG4gPSAwXG4gIHRoZW4gKHJlc2l6ZSBiIHVjaGFyX3V0Zl8xNl9ieXRlX2xlbmd0aF9tYXg7IGFkZF91dGZfMTZiZV91Y2hhciBiIHUpXG4gIGVsc2UgKGIucG9zaXRpb24gPC0gcG9zICsgbilcblxubGV0IHJlYyBhZGRfdXRmXzE2bGVfdWNoYXIgYiB1ID1cbiAgbGV0IHBvcyA9IGIucG9zaXRpb24gaW5cbiAgaWYgcG9zID49IGIubGVuZ3RoIHRoZW4gcmVzaXplIGIgdWNoYXJfdXRmXzE2X2J5dGVfbGVuZ3RoX21heDtcbiAgbGV0IG4gPSBCeXRlcy5zZXRfdXRmXzE2bGVfdWNoYXIgYi5idWZmZXIgcG9zIHUgaW5cbiAgaWYgbiA9IDBcbiAgdGhlbiAocmVzaXplIGIgdWNoYXJfdXRmXzE2X2J5dGVfbGVuZ3RoX21heDsgYWRkX3V0Zl8xNmxlX3VjaGFyIGIgdSlcbiAgZWxzZSAoYi5wb3NpdGlvbiA8LSBwb3MgKyBuKVxuXG5sZXQgYWRkX3N1YnN0cmluZyBiIHMgb2Zmc2V0IGxlbiA9XG4gIGlmIG9mZnNldCA8IDAgfHwgbGVuIDwgMCB8fCBvZmZzZXQgPiBTdHJpbmcubGVuZ3RoIHMgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIkJ1ZmZlci5hZGRfc3Vic3RyaW5nL2FkZF9zdWJieXRlc1wiO1xuICBsZXQgbmV3X3Bvc2l0aW9uID0gYi5wb3NpdGlvbiArIGxlbiBpblxuICBpZiBuZXdfcG9zaXRpb24gPiBiLmxlbmd0aCB0aGVuIHJlc2l6ZSBiIGxlbjtcbiAgQnl0ZXMudW5zYWZlX2JsaXRfc3RyaW5nIHMgb2Zmc2V0IGIuYnVmZmVyIGIucG9zaXRpb24gbGVuO1xuICBiLnBvc2l0aW9uIDwtIG5ld19wb3NpdGlvblxuXG5sZXQgYWRkX3N1YmJ5dGVzIGIgcyBvZmZzZXQgbGVuID1cbiAgYWRkX3N1YnN0cmluZyBiIChCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHMpIG9mZnNldCBsZW5cblxubGV0IGFkZF9zdHJpbmcgYiBzID1cbiAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggcyBpblxuICBsZXQgbmV3X3Bvc2l0aW9uID0gYi5wb3NpdGlvbiArIGxlbiBpblxuICBpZiBuZXdfcG9zaXRpb24gPiBiLmxlbmd0aCB0aGVuIHJlc2l6ZSBiIGxlbjtcbiAgQnl0ZXMudW5zYWZlX2JsaXRfc3RyaW5nIHMgMCBiLmJ1ZmZlciBiLnBvc2l0aW9uIGxlbjtcbiAgYi5wb3NpdGlvbiA8LSBuZXdfcG9zaXRpb25cblxubGV0IGFkZF9ieXRlcyBiIHMgPSBhZGRfc3RyaW5nIGIgKEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcylcblxubGV0IGFkZF9idWZmZXIgYiBicyA9XG4gIGFkZF9zdWJieXRlcyBiIGJzLmJ1ZmZlciAwIGJzLnBvc2l0aW9uXG5cbigqIHRoaXMgKHByaXZhdGUpIGZ1bmN0aW9uIGNvdWxkIG1vdmUgaW50byB0aGUgc3RhbmRhcmQgbGlicmFyeSAqKVxubGV0IHJlYWxseV9pbnB1dF91cF90byBpYyBidWYgb2ZzIGxlbiA9XG4gIGxldCByZWMgbG9vcCBpYyBidWYgfmFscmVhZHlfcmVhZCB+b2ZzIH50b19yZWFkID1cbiAgICBpZiB0b19yZWFkID0gMCB0aGVuIGFscmVhZHlfcmVhZFxuICAgIGVsc2UgYmVnaW5cbiAgICAgIGxldCByID0gaW5wdXQgaWMgYnVmIG9mcyB0b19yZWFkIGluXG4gICAgICBpZiByID0gMCB0aGVuIGFscmVhZHlfcmVhZFxuICAgICAgZWxzZSBiZWdpblxuICAgICAgICBsZXQgYWxyZWFkeV9yZWFkID0gYWxyZWFkeV9yZWFkICsgciBpblxuICAgICAgICBsZXQgb2ZzID0gb2ZzICsgciBpblxuICAgICAgICBsZXQgdG9fcmVhZCA9IHRvX3JlYWQgLSByIGluXG4gICAgICAgIGxvb3AgaWMgYnVmIH5hbHJlYWR5X3JlYWQgfm9mcyB+dG9fcmVhZFxuICAgICAgZW5kXG4gICAgZW5kXG4gIGluIGxvb3AgaWMgYnVmIH5hbHJlYWR5X3JlYWQ6MCB+b2ZzIH50b19yZWFkOmxlblxuXG5cbmxldCB1bnNhZmVfYWRkX2NoYW5uZWxfdXBfdG8gYiBpYyBsZW4gPVxuICBpZiBiLnBvc2l0aW9uICsgbGVuID4gYi5sZW5ndGggdGhlbiByZXNpemUgYiBsZW47XG4gIGxldCBuID0gcmVhbGx5X2lucHV0X3VwX3RvIGljIGIuYnVmZmVyIGIucG9zaXRpb24gbGVuIGluXG4gICgqIFRoZSBhc3NlcnRpb24gYmVsb3cgbWF5IGZhaWwgaW4gd2VpcmQgc2NlbmFyaW8gd2hlcmVcbiAgICAgdGhyZWFkZWQvZmluYWxpemVyIGNvZGUsIHJ1biBhc3luY2hyb25vdXNseSBkdXJpbmcgdGhlXG4gICAgIFtyZWFsbHlfaW5wdXRfdXBfdG9dIGNhbGwsIHJhY2VzIG9uIHRoZSBidWZmZXI7IHdlIGRvbid0IGVuc3VyZVxuICAgICBjb3JyZWN0bmVzcyBpbiB0aGlzIGNhc2UsIGJ1dCBuZWVkIHRvIHByZXNlcnZlIHRoZSBpbnZhcmlhbnRzIGZvclxuICAgICBtZW1vcnktc2FmZXR5IChzZWUgZGlzY3Vzc2lvbiBvZiBbcmVzaXplXSkuICopXG4gIGFzc2VydCAoYi5wb3NpdGlvbiArIG4gPD0gYi5sZW5ndGgpO1xuICBiLnBvc2l0aW9uIDwtIGIucG9zaXRpb24gKyBuO1xuICBuXG5cbmxldCBhZGRfY2hhbm5lbCBiIGljIGxlbiA9XG4gIGlmIGxlbiA8IDAgfHwgbGVuID4gU3lzLm1heF9zdHJpbmdfbGVuZ3RoIHRoZW4gICAoKiBQUiM1MDA0ICopXG4gICAgaW52YWxpZF9hcmcgXCJCdWZmZXIuYWRkX2NoYW5uZWxcIjtcbiAgbGV0IG4gPSB1bnNhZmVfYWRkX2NoYW5uZWxfdXBfdG8gYiBpYyBsZW4gaW5cbiAgKCogSXQgaXMgaW50ZW50aW9uYWwgdGhhdCBhIGNvbnN1bWVyIGNhdGNoaW5nIEVuZF9vZl9maWxlXG4gICAgIHdpbGwgc2VlIHRoZSBkYXRhIHdyaXR0ZW4gKHNlZSAjNjcxOSwgIzcxMzYpLiAqKVxuICBpZiBuIDwgbGVuIHRoZW4gcmFpc2UgRW5kX29mX2ZpbGU7XG4gICgpXG5cbmxldCBvdXRwdXRfYnVmZmVyIG9jIGIgPVxuICBvdXRwdXQgb2MgYi5idWZmZXIgMCBiLnBvc2l0aW9uXG5cbmxldCBjbG9zaW5nID0gZnVuY3Rpb25cbiAgfCAnKCcgLT4gJyknXG4gIHwgJ3snIC0+ICd9J1xuICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbigqIG9wZW5pbmcgYW5kIGNsb3Npbmc6IG9wZW4gYW5kIGNsb3NlIGNoYXJhY3RlcnMsIHR5cGljYWxseSAoIGFuZCApXG4gICBrOiBiYWxhbmNlIG9mIG9wZW5pbmcgYW5kIGNsb3NpbmcgY2hhcnNcbiAgIHM6IHRoZSBzdHJpbmcgd2hlcmUgd2UgYXJlIHNlYXJjaGluZ1xuICAgc3RhcnQ6IHRoZSBpbmRleCB3aGVyZSB3ZSBzdGFydCB0aGUgc2VhcmNoLiAqKVxubGV0IGFkdmFuY2VfdG9fY2xvc2luZyBvcGVuaW5nIGNsb3NpbmcgayBzIHN0YXJ0ID1cbiAgbGV0IHJlYyBhZHZhbmNlIGsgaSBsaW0gPVxuICAgIGlmIGkgPj0gbGltIHRoZW4gcmFpc2UgTm90X2ZvdW5kIGVsc2VcbiAgICBpZiBzLltpXSA9IG9wZW5pbmcgdGhlbiBhZHZhbmNlIChrICsgMSkgKGkgKyAxKSBsaW0gZWxzZVxuICAgIGlmIHMuW2ldID0gY2xvc2luZyB0aGVuXG4gICAgICBpZiBrID0gMCB0aGVuIGkgZWxzZSBhZHZhbmNlIChrIC0gMSkgKGkgKyAxKSBsaW1cbiAgICBlbHNlIGFkdmFuY2UgayAoaSArIDEpIGxpbSBpblxuICBhZHZhbmNlIGsgc3RhcnQgKFN0cmluZy5sZW5ndGggcylcblxubGV0IGFkdmFuY2VfdG9fbm9uX2FscGhhIHMgc3RhcnQgPVxuICBsZXQgcmVjIGFkdmFuY2UgaSBsaW0gPVxuICAgIGlmIGkgPj0gbGltIHRoZW4gbGltIGVsc2VcbiAgICBtYXRjaCBzLltpXSB3aXRoXG4gICAgfCAnYScgLi4gJ3onIHwgJ0EnIC4uICdaJyB8ICcwJyAuLiAnOScgfCAnXycgLT4gYWR2YW5jZSAoaSArIDEpIGxpbVxuICAgIHwgXyAtPiBpIGluXG4gIGFkdmFuY2Ugc3RhcnQgKFN0cmluZy5sZW5ndGggcylcblxuKCogV2UgYXJlIGp1c3QgYXQgdGhlIGJlZ2lubmluZyBvZiBhbiBpZGVudCBpbiBzLCBzdGFydGluZyBhdCBzdGFydC4gKilcbmxldCBmaW5kX2lkZW50IHMgc3RhcnQgbGltID1cbiAgaWYgc3RhcnQgPj0gbGltIHRoZW4gcmFpc2UgTm90X2ZvdW5kIGVsc2VcbiAgbWF0Y2ggcy5bc3RhcnRdIHdpdGhcbiAgKCogUGFyZW50aGVzaXplZCBpZGVudCA/ICopXG4gIHwgJygnIHwgJ3snIGFzIGMgLT5cbiAgICAgbGV0IG5ld19zdGFydCA9IHN0YXJ0ICsgMSBpblxuICAgICBsZXQgc3RvcCA9IGFkdmFuY2VfdG9fY2xvc2luZyBjIChjbG9zaW5nIGMpIDAgcyBuZXdfc3RhcnQgaW5cbiAgICAgU3RyaW5nLnN1YiBzIG5ld19zdGFydCAoc3RvcCAtIHN0YXJ0IC0gMSksIHN0b3AgKyAxXG4gICgqIFJlZ3VsYXIgaWRlbnQgKilcbiAgfCBfIC0+XG4gICAgIGxldCBzdG9wID0gYWR2YW5jZV90b19ub25fYWxwaGEgcyAoc3RhcnQgKyAxKSBpblxuICAgICBTdHJpbmcuc3ViIHMgc3RhcnQgKHN0b3AgLSBzdGFydCksIHN0b3BcblxuKCogU3Vic3RpdHV0ZSAkaWRlbnQsICQoaWRlbnQpLCBvciAke2lkZW50fSBpbiBzLFxuICAgIGFjY29yZGluZyB0byB0aGUgZnVuY3Rpb24gbWFwcGluZyBmLiAqKVxubGV0IGFkZF9zdWJzdGl0dXRlIGIgZiBzID1cbiAgbGV0IGxpbSA9IFN0cmluZy5sZW5ndGggcyBpblxuICBsZXQgcmVjIHN1YnN0IHByZXZpb3VzIGkgPVxuICAgIGlmIGkgPCBsaW0gdGhlbiBiZWdpblxuICAgICAgbWF0Y2ggcy5baV0gd2l0aFxuICAgICAgfCAnJCcgYXMgY3VycmVudCB3aGVuIHByZXZpb3VzID0gJ1xcXFwnIC0+XG4gICAgICAgICBhZGRfY2hhciBiIGN1cnJlbnQ7XG4gICAgICAgICBzdWJzdCAnICcgKGkgKyAxKVxuICAgICAgfCAnJCcgLT5cbiAgICAgICAgIGxldCBqID0gaSArIDEgaW5cbiAgICAgICAgIGxldCBpZGVudCwgbmV4dF9pID0gZmluZF9pZGVudCBzIGogbGltIGluXG4gICAgICAgICBhZGRfc3RyaW5nIGIgKGYgaWRlbnQpO1xuICAgICAgICAgc3Vic3QgJyAnIG5leHRfaVxuICAgICAgfCBjdXJyZW50IHdoZW4gcHJldmlvdXMgPT0gJ1xcXFwnIC0+XG4gICAgICAgICBhZGRfY2hhciBiICdcXFxcJztcbiAgICAgICAgIGFkZF9jaGFyIGIgY3VycmVudDtcbiAgICAgICAgIHN1YnN0ICcgJyAoaSArIDEpXG4gICAgICB8ICdcXFxcJyBhcyBjdXJyZW50IC0+XG4gICAgICAgICBzdWJzdCBjdXJyZW50IChpICsgMSlcbiAgICAgIHwgY3VycmVudCAtPlxuICAgICAgICAgYWRkX2NoYXIgYiBjdXJyZW50O1xuICAgICAgICAgc3Vic3QgY3VycmVudCAoaSArIDEpXG4gICAgZW5kIGVsc2VcbiAgICBpZiBwcmV2aW91cyA9ICdcXFxcJyB0aGVuIGFkZF9jaGFyIGIgcHJldmlvdXMgaW5cbiAgc3Vic3QgJyAnIDBcblxubGV0IHRydW5jYXRlIGIgbGVuID1cbiAgICBpZiBsZW4gPCAwIHx8IGxlbiA+IGxlbmd0aCBiIHRoZW5cbiAgICAgIGludmFsaWRfYXJnIFwiQnVmZmVyLnRydW5jYXRlXCJcbiAgICBlbHNlXG4gICAgICBiLnBvc2l0aW9uIDwtIGxlblxuXG4oKiogezEgSXRlcmF0b3JzfSAqKVxuXG5sZXQgdG9fc2VxIGIgPVxuICBsZXQgcmVjIGF1eCBpICgpID1cbiAgICAoKiBOb3RlIHRoYXQgYi5wb3NpdGlvbiBpcyBub3QgYSBjb25zdGFudCBhbmQgY2Fubm90IGJlIGxpZnRlZCBvdXQgb2YgYXV4ICopXG4gICAgaWYgaSA+PSBiLnBvc2l0aW9uIHRoZW4gU2VxLk5pbFxuICAgIGVsc2VcbiAgICAgIGxldCB4ID0gQnl0ZXMudW5zYWZlX2dldCBiLmJ1ZmZlciBpIGluXG4gICAgICBTZXEuQ29ucyAoeCwgYXV4IChpKzEpKVxuICBpblxuICBhdXggMFxuXG5sZXQgdG9fc2VxaSBiID1cbiAgbGV0IHJlYyBhdXggaSAoKSA9XG4gICAgKCogTm90ZSB0aGF0IGIucG9zaXRpb24gaXMgbm90IGEgY29uc3RhbnQgYW5kIGNhbm5vdCBiZSBsaWZ0ZWQgb3V0IG9mIGF1eCAqKVxuICAgIGlmIGkgPj0gYi5wb3NpdGlvbiB0aGVuIFNlcS5OaWxcbiAgICBlbHNlXG4gICAgICBsZXQgeCA9IEJ5dGVzLnVuc2FmZV9nZXQgYi5idWZmZXIgaSBpblxuICAgICAgU2VxLkNvbnMgKChpLHgpLCBhdXggKGkrMSkpXG4gIGluXG4gIGF1eCAwXG5cbmxldCBhZGRfc2VxIGIgc2VxID0gU2VxLml0ZXIgKGFkZF9jaGFyIGIpIHNlcVxuXG5sZXQgb2Zfc2VxIGkgPVxuICBsZXQgYiA9IGNyZWF0ZSAzMiBpblxuICBhZGRfc2VxIGIgaTtcbiAgYlxuXG4oKiogezYgQmluYXJ5IGVuY29kaW5nIG9mIGludGVnZXJzfSAqKVxuXG5leHRlcm5hbCB1bnNhZmVfc2V0X2ludDggOiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IHVuaXQgPSBcIiVieXRlc191bnNhZmVfc2V0XCJcbmV4dGVybmFsIHVuc2FmZV9zZXRfaW50MTYgOiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IHVuaXQgPSBcIiVjYW1sX2J5dGVzX3NldDE2dVwiXG5leHRlcm5hbCB1bnNhZmVfc2V0X2ludDMyIDogYnl0ZXMgLT4gaW50IC0+IGludDMyIC0+IHVuaXQgPSBcIiVjYW1sX2J5dGVzX3NldDMydVwiXG5leHRlcm5hbCB1bnNhZmVfc2V0X2ludDY0IDogYnl0ZXMgLT4gaW50IC0+IGludDY0IC0+IHVuaXQgPSBcIiVjYW1sX2J5dGVzX3NldDY0dVwiXG5leHRlcm5hbCBzd2FwMTYgOiBpbnQgLT4gaW50ID0gXCIlYnN3YXAxNlwiXG5leHRlcm5hbCBzd2FwMzIgOiBpbnQzMiAtPiBpbnQzMiA9IFwiJWJzd2FwX2ludDMyXCJcbmV4dGVybmFsIHN3YXA2NCA6IGludDY0IC0+IGludDY0ID0gXCIlYnN3YXBfaW50NjRcIlxuXG5cbmxldCBhZGRfaW50OCBiIHggPVxuICBsZXQgbmV3X3Bvc2l0aW9uID0gYi5wb3NpdGlvbiArIDEgaW5cbiAgaWYgbmV3X3Bvc2l0aW9uID4gYi5sZW5ndGggdGhlbiByZXNpemUgYiAxO1xuICB1bnNhZmVfc2V0X2ludDggYi5idWZmZXIgYi5wb3NpdGlvbiB4O1xuICBiLnBvc2l0aW9uIDwtIG5ld19wb3NpdGlvblxuXG5sZXQgYWRkX2ludDE2X25lIGIgeCA9XG4gIGxldCBuZXdfcG9zaXRpb24gPSBiLnBvc2l0aW9uICsgMiBpblxuICBpZiBuZXdfcG9zaXRpb24gPiBiLmxlbmd0aCB0aGVuIHJlc2l6ZSBiIDI7XG4gIHVuc2FmZV9zZXRfaW50MTYgYi5idWZmZXIgYi5wb3NpdGlvbiB4O1xuICBiLnBvc2l0aW9uIDwtIG5ld19wb3NpdGlvblxuXG5sZXQgYWRkX2ludDMyX25lIGIgeCA9XG4gIGxldCBuZXdfcG9zaXRpb24gPSBiLnBvc2l0aW9uICsgNCBpblxuICBpZiBuZXdfcG9zaXRpb24gPiBiLmxlbmd0aCB0aGVuIHJlc2l6ZSBiIDQ7XG4gIHVuc2FmZV9zZXRfaW50MzIgYi5idWZmZXIgYi5wb3NpdGlvbiB4O1xuICBiLnBvc2l0aW9uIDwtIG5ld19wb3NpdGlvblxuXG5sZXQgYWRkX2ludDY0X25lIGIgeCA9XG4gIGxldCBuZXdfcG9zaXRpb24gPSBiLnBvc2l0aW9uICsgOCBpblxuICBpZiBuZXdfcG9zaXRpb24gPiBiLmxlbmd0aCB0aGVuIHJlc2l6ZSBiIDg7XG4gIHVuc2FmZV9zZXRfaW50NjQgYi5idWZmZXIgYi5wb3NpdGlvbiB4O1xuICBiLnBvc2l0aW9uIDwtIG5ld19wb3NpdGlvblxuXG5sZXQgYWRkX2ludDE2X2xlIGIgeCA9XG4gIGFkZF9pbnQxNl9uZSBiIChpZiBTeXMuYmlnX2VuZGlhbiB0aGVuIHN3YXAxNiB4IGVsc2UgeClcblxubGV0IGFkZF9pbnQxNl9iZSBiIHggPVxuICBhZGRfaW50MTZfbmUgYiAoaWYgU3lzLmJpZ19lbmRpYW4gdGhlbiB4IGVsc2Ugc3dhcDE2IHgpXG5cbmxldCBhZGRfaW50MzJfbGUgYiB4ID1cbiAgYWRkX2ludDMyX25lIGIgKGlmIFN5cy5iaWdfZW5kaWFuIHRoZW4gc3dhcDMyIHggZWxzZSB4KVxuXG5sZXQgYWRkX2ludDMyX2JlIGIgeCA9XG4gIGFkZF9pbnQzMl9uZSBiIChpZiBTeXMuYmlnX2VuZGlhbiB0aGVuIHggZWxzZSBzd2FwMzIgeClcblxubGV0IGFkZF9pbnQ2NF9sZSBiIHggPVxuICBhZGRfaW50NjRfbmUgYiAoaWYgU3lzLmJpZ19lbmRpYW4gdGhlbiBzd2FwNjQgeCBlbHNlIHgpXG5cbmxldCBhZGRfaW50NjRfYmUgYiB4ID1cbiAgYWRkX2ludDY0X25lIGIgKGlmIFN5cy5iaWdfZW5kaWFuIHRoZW4geCBlbHNlIHN3YXA2NCB4KVxuXG5sZXQgYWRkX3VpbnQ4ID0gYWRkX2ludDhcbmxldCBhZGRfdWludDE2X25lID0gYWRkX2ludDE2X25lXG5sZXQgYWRkX3VpbnQxNl9sZSA9IGFkZF9pbnQxNl9sZVxubGV0IGFkZF91aW50MTZfYmUgPSBhZGRfaW50MTZfYmVcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICBCZW5vaXQgVmF1Z29uLCBFTlNUQSAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMTQgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxub3BlbiBDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3NcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgKCogVG9vbHMgdG8gbWFuaXB1bGF0ZSBzY2FubmluZyBzZXQgb2YgY2hhcnMgKHNlZSAlWy4uLl0pICopXG5cbnR5cGUgbXV0YWJsZV9jaGFyX3NldCA9IGJ5dGVzXG5cbigqIENyZWF0ZSBhIGZyZXNoLCBlbXB0eSwgbXV0YWJsZSBjaGFyIHNldC4gKilcbmxldCBjcmVhdGVfY2hhcl9zZXQgKCkgPSBCeXRlcy5tYWtlIDMyICdcXDAwMCdcblxuKCogQWRkIGEgY2hhciBpbiBhIG11dGFibGUgY2hhciBzZXQuICopXG5sZXQgYWRkX2luX2NoYXJfc2V0IGNoYXJfc2V0IGMgPVxuICBsZXQgaW5kID0gaW50X29mX2NoYXIgYyBpblxuICBsZXQgc3RyX2luZCA9IGluZCBsc3IgMyBhbmQgbWFzayA9IDEgbHNsIChpbmQgbGFuZCAwYjExMSkgaW5cbiAgQnl0ZXMuc2V0IGNoYXJfc2V0IHN0cl9pbmRcbiAgICAoY2hhcl9vZl9pbnQgKGludF9vZl9jaGFyIChCeXRlcy5nZXQgY2hhcl9zZXQgc3RyX2luZCkgbG9yIG1hc2spKVxuXG5sZXQgZnJlZXplX2NoYXJfc2V0IGNoYXJfc2V0ID1cbiAgQnl0ZXMudG9fc3RyaW5nIGNoYXJfc2V0XG5cbigqIENvbXB1dGUgdGhlIGNvbXBsZW1lbnQgb2YgYSBjaGFyIHNldC4gKilcbmxldCByZXZfY2hhcl9zZXQgY2hhcl9zZXQgPVxuICBsZXQgY2hhcl9zZXQnID0gY3JlYXRlX2NoYXJfc2V0ICgpIGluXG4gIGZvciBpID0gMCB0byAzMSBkb1xuICAgIEJ5dGVzLnNldCBjaGFyX3NldCcgaVxuICAgICAgKGNoYXJfb2ZfaW50IChpbnRfb2ZfY2hhciAoU3RyaW5nLmdldCBjaGFyX3NldCBpKSBseG9yIDB4RkYpKTtcbiAgZG9uZTtcbiAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBjaGFyX3NldCdcblxuKCogUmV0dXJuIHRydWUgaWYgYSBgYycgaXMgaW4gYGNoYXJfc2V0Jy4gKilcbmxldCBpc19pbl9jaGFyX3NldCBjaGFyX3NldCBjID1cbiAgbGV0IGluZCA9IGludF9vZl9jaGFyIGMgaW5cbiAgbGV0IHN0cl9pbmQgPSBpbmQgbHNyIDMgYW5kIG1hc2sgPSAxIGxzbCAoaW5kIGxhbmQgMGIxMTEpIGluXG4gIChpbnRfb2ZfY2hhciAoU3RyaW5nLmdldCBjaGFyX3NldCBzdHJfaW5kKSBsYW5kIG1hc2spIDw+IDBcblxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICgqIElnbm9yZWQgcGFyYW0gY29udmVyc2lvbiAqKVxuXG4oKiBHQURUIHVzZWQgdG8gYWJzdHJhY3QgYW4gZXhpc3RlbnRpYWwgdHlwZSBwYXJhbWV0ZXIuICopXG4oKiBTZWUgcGFyYW1fZm9ybWF0X29mX2lnbm9yZWRfZm9ybWF0LiAqKVxudHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgcGFyYW1fZm9ybWF0X2ViYiA9IFBhcmFtX2Zvcm1hdF9FQkIgOlxuICAgICgneCAtPiAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgcGFyYW1fZm9ybWF0X2ViYlxuXG4oKiBDb21wdXRlIGEgcGFkZGluZyBhc3NvY2lhdGVkIHRvIGEgcGFkX29wdGlvbiAoc2VlIFwiJV80MmRcIikuICopXG5sZXQgcGFkX29mX3BhZF9vcHQgcGFkX29wdCA9IG1hdGNoIHBhZF9vcHQgd2l0aFxuICB8IE5vbmUgLT4gTm9fcGFkZGluZ1xuICB8IFNvbWUgd2lkdGggLT4gTGl0X3BhZGRpbmcgKFJpZ2h0LCB3aWR0aClcblxuKCogQ29tcHV0ZSBhIHByZWNpc2lvbiBhc3NvY2lhdGVkIHRvIGEgcHJlY19vcHRpb24gKHNlZSBcIiVfLjQyZlwiKS4gKilcbmxldCBwcmVjX29mX3ByZWNfb3B0IHByZWNfb3B0ID0gbWF0Y2ggcHJlY19vcHQgd2l0aFxuICB8IE5vbmUgLT4gTm9fcHJlY2lzaW9uXG4gIHwgU29tZSBuZGVjIC0+IExpdF9wcmVjaXNpb24gbmRlY1xuXG4oKiBUdXJuIGFuIGlnbm9yZWQgcGFyYW0gaW50byBpdHMgZXF1aXZhbGVudCBub3QtaWdub3JlZCBmb3JtYXQgbm9kZS4gKilcbigqIFVzZWQgZm9yIGZvcm1hdCBwcmV0dHktcHJpbnRpbmcgYW5kIFNjYW5mLiAqKVxubGV0IHBhcmFtX2Zvcm1hdF9vZl9pZ25vcmVkX2Zvcm1hdCA6IHR5cGUgYSBiIGMgZCBlIGYgeCB5IC5cbiAgICAoYSwgYiwgYywgZCwgeSwgeCkgaWdub3JlZCAtPiAoeCwgYiwgYywgeSwgZSwgZikgZm10IC0+XG4gICAgICAoYSwgYiwgYywgZCwgZSwgZikgcGFyYW1fZm9ybWF0X2ViYiA9XG5mdW4gaWduIGZtdCAtPiBtYXRjaCBpZ24gd2l0aFxuICB8IElnbm9yZWRfY2hhciAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkIgKENoYXIgZm10KVxuICB8IElnbm9yZWRfY2FtbF9jaGFyIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQiAoQ2FtbF9jaGFyIGZtdClcbiAgfCBJZ25vcmVkX3N0cmluZyBwYWRfb3B0IC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQiAoU3RyaW5nIChwYWRfb2ZfcGFkX29wdCBwYWRfb3B0LCBmbXQpKVxuICB8IElnbm9yZWRfY2FtbF9zdHJpbmcgcGFkX29wdCAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkIgKENhbWxfc3RyaW5nIChwYWRfb2ZfcGFkX29wdCBwYWRfb3B0LCBmbXQpKVxuICB8IElnbm9yZWRfaW50IChpY29udiwgcGFkX29wdCkgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChJbnQgKGljb252LCBwYWRfb2ZfcGFkX29wdCBwYWRfb3B0LCBOb19wcmVjaXNpb24sIGZtdCkpXG4gIHwgSWdub3JlZF9pbnQzMiAoaWNvbnYsIHBhZF9vcHQpIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQlxuICAgICAgKEludDMyIChpY29udiwgcGFkX29mX3BhZF9vcHQgcGFkX29wdCwgTm9fcHJlY2lzaW9uLCBmbXQpKVxuICB8IElnbm9yZWRfbmF0aXZlaW50IChpY29udiwgcGFkX29wdCkgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCXG4gICAgICAoTmF0aXZlaW50IChpY29udiwgcGFkX29mX3BhZF9vcHQgcGFkX29wdCwgTm9fcHJlY2lzaW9uLCBmbXQpKVxuICB8IElnbm9yZWRfaW50NjQgKGljb252LCBwYWRfb3B0KSAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkJcbiAgICAgIChJbnQ2NCAoaWNvbnYsIHBhZF9vZl9wYWRfb3B0IHBhZF9vcHQsIE5vX3ByZWNpc2lvbiwgZm10KSlcbiAgfCBJZ25vcmVkX2Zsb2F0IChwYWRfb3B0LCBwcmVjX29wdCkgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCXG4gICAgICAoRmxvYXQgKChGbG9hdF9mbGFnXywgRmxvYXRfZiksXG4gICAgICAgICAgICAgIHBhZF9vZl9wYWRfb3B0IHBhZF9vcHQsIHByZWNfb2ZfcHJlY19vcHQgcHJlY19vcHQsIGZtdCkpXG4gIHwgSWdub3JlZF9ib29sIHBhZF9vcHQgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChCb29sIChwYWRfb2ZfcGFkX29wdCBwYWRfb3B0LCBmbXQpKVxuICB8IElnbm9yZWRfZm9ybWF0X2FyZyAocGFkX29wdCwgZm10dHkpIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQiAoRm9ybWF0X2FyZyAocGFkX29wdCwgZm10dHksIGZtdCkpXG4gIHwgSWdub3JlZF9mb3JtYXRfc3Vic3QgKHBhZF9vcHQsIGZtdHR5KSAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkJcbiAgICAgIChGb3JtYXRfc3Vic3QgKHBhZF9vcHQsIGZtdHR5LCBmbXQpKVxuICB8IElnbm9yZWRfcmVhZGVyIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQiAoUmVhZGVyIGZtdClcbiAgfCBJZ25vcmVkX3NjYW5fY2hhcl9zZXQgKHdpZHRoX29wdCwgY2hhcl9zZXQpIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQiAoU2Nhbl9jaGFyX3NldCAod2lkdGhfb3B0LCBjaGFyX3NldCwgZm10KSlcbiAgfCBJZ25vcmVkX3NjYW5fZ2V0X2NvdW50ZXIgY291bnRlciAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkIgKFNjYW5fZ2V0X2NvdW50ZXIgKGNvdW50ZXIsIGZtdCkpXG4gIHwgSWdub3JlZF9zY2FuX25leHRfY2hhciAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkIgKFNjYW5fbmV4dF9jaGFyIGZtdClcblxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogVHlwZXMgKilcblxudHlwZSAoJ2IsICdjKSBhY2NfZm9ybWF0dGluZ19nZW4gPVxuICB8IEFjY19vcGVuX3RhZyBvZiAoJ2IsICdjKSBhY2NcbiAgfCBBY2Nfb3Blbl9ib3ggb2YgKCdiLCAnYykgYWNjXG5cbigqIFJldmVyc2VkIGxpc3Qgb2YgcHJpbnRpbmcgYXRvbXMuICopXG4oKiBVc2VkIHRvIGFjY3VtdWxhdGUgcHJpbnRmIGFyZ3VtZW50cy4gKilcbmFuZCAoJ2IsICdjKSBhY2MgPVxuICB8IEFjY19mb3JtYXR0aW5nX2xpdCBvZiAoJ2IsICdjKSBhY2MgKiBmb3JtYXR0aW5nX2xpdFxuICAgICAgKCogU3BlY2lhbCBmbXR0aW5nIChib3gpICopXG4gIHwgQWNjX2Zvcm1hdHRpbmdfZ2VuIG9mICgnYiwgJ2MpIGFjYyAqICgnYiwgJ2MpIGFjY19mb3JtYXR0aW5nX2dlblxuICAgICAgKCogU3BlY2lhbCBmbXR0aW5nIChib3gpICopXG4gIHwgQWNjX3N0cmluZ19saXRlcmFsIG9mICgnYiwgJ2MpIGFjYyAqIHN0cmluZyAgICAgKCogTGl0ZXJhbCBzdHJpbmcgKilcbiAgfCBBY2NfY2hhcl9saXRlcmFsICAgb2YgKCdiLCAnYykgYWNjICogY2hhciAgICAgICAoKiBMaXRlcmFsIGNoYXIgKilcbiAgfCBBY2NfZGF0YV9zdHJpbmcgICAgb2YgKCdiLCAnYykgYWNjICogc3RyaW5nICAgICAoKiBHZW5lcmF0ZWQgc3RyaW5nICopXG4gIHwgQWNjX2RhdGFfY2hhciAgICAgIG9mICgnYiwgJ2MpIGFjYyAqIGNoYXIgICAgICAgKCogR2VuZXJhdGVkIGNoYXIgKilcbiAgfCBBY2NfZGVsYXkgICAgICAgICAgb2YgKCdiLCAnYykgYWNjICogKCdiIC0+ICdjKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogRGVsYXllZCBwcmludGluZyAoJWEsICV0KSAqKVxuICB8IEFjY19mbHVzaCAgICAgICAgICBvZiAoJ2IsICdjKSBhY2MgICAgICAgICAgICAgICgqIEZsdXNoICopXG4gIHwgQWNjX2ludmFsaWRfYXJnICAgIG9mICgnYiwgJ2MpIGFjYyAqIHN0cmluZ1xuICAgICAgKCogUmFpc2UgSW52YWxpZF9hcmd1bWVudCBtc2cgKilcbiAgfCBFbmRfb2ZfYWNjXG5cbigqIExpc3Qgb2YgaGV0ZXJvZ2VuZW91cyB2YWx1ZXMuICopXG4oKiBVc2VkIHRvIGFjY3VtdWxhdGUgc2NhbmYgY2FsbGJhY2sgYXJndW1lbnRzLiAqKVxudHlwZSAoJ2EsICdiKSBoZXRlcl9saXN0ID1cbiAgfCBDb25zIDogJ2MgKiAoJ2EsICdiKSBoZXRlcl9saXN0IC0+ICgnYyAtPiAnYSwgJ2IpIGhldGVyX2xpc3RcbiAgfCBOaWwgOiAoJ2IsICdiKSBoZXRlcl9saXN0XG5cbigqIEV4aXN0ZW50aWFsIEJsYWNrIEJveGVzLiAqKVxuKCogVXNlZCB0byBhYnN0cmFjdCBzb21lIGV4aXN0ZW50aWFsIHR5cGUgcGFyYW1ldGVycy4gKilcblxuKCogR0FEVCB0eXBlIGFzc29jaWF0aW5nIGEgcGFkZGluZyBhbmQgYW4gZm10dHkuICopXG4oKiBTZWUgdGhlIHR5cGVfcGFkZGluZyBmdW5jdGlvbi4gKilcbnR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIHBhZGRpbmdfZm10dHlfZWJiID0gUGFkZGluZ19mbXR0eV9FQkIgOlxuICAgICAoJ3gsICd5KSBwYWRkaW5nICogKCd5LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdHR5IC0+XG4gICAgICgneCwgJ2IsICdjLCAnZCwgJ2UsICdmKSBwYWRkaW5nX2ZtdHR5X2ViYlxuXG4oKiBHQURUIHR5cGUgYXNzb2NpYXRpbmcgYSBwYWRkaW5nLCBhIHByZWNpc2lvbiBhbmQgYW4gZm10dHkuICopXG4oKiBTZWUgdGhlIHR5cGVfcGFkcHJlYyBmdW5jdGlvbi4gKilcbnR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIHBhZHByZWNfZm10dHlfZWJiID0gUGFkcHJlY19mbXR0eV9FQkIgOlxuICAgICAoJ3gsICd5KSBwYWRkaW5nICogKCd5LCAneikgcHJlY2lzaW9uICogKCd6LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdHR5IC0+XG4gICAgICgneCwgJ2IsICdjLCAnZCwgJ2UsICdmKSBwYWRwcmVjX2ZtdHR5X2ViYlxuXG4oKiBHQURUIHR5cGUgYXNzb2NpYXRpbmcgYSBwYWRkaW5nIGFuZCBhbiBmbXQuICopXG4oKiBTZWUgbWFrZV9wYWRkaW5nX2ZtdF9lYmIgYW5kIHBhcnNlX2Zvcm1hdCBmdW5jdGlvbnMuICopXG50eXBlICgnYSwgJ2IsICdjLCAnZSwgJ2YpIHBhZGRpbmdfZm10X2ViYiA9IFBhZGRpbmdfZm10X0VCQiA6XG4gICAgIChfLCAneCAtPiAnYSkgcGFkZGluZyAqXG4gICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgKCd4LCAnYiwgJ2MsICdlLCAnZikgcGFkZGluZ19mbXRfZWJiXG5cbigqIEdBRFQgdHlwZSBhc3NvY2lhdGluZyBhIHByZWNpc2lvbiBhbmQgYW4gZm10LiAqKVxuKCogU2VlIG1ha2VfcHJlY2lzaW9uX2ZtdF9lYmIgYW5kIHBhcnNlX2Zvcm1hdCBmdW5jdGlvbnMuICopXG50eXBlICgnYSwgJ2IsICdjLCAnZSwgJ2YpIHByZWNpc2lvbl9mbXRfZWJiID0gUHJlY2lzaW9uX2ZtdF9FQkIgOlxuICAgICAoXywgJ3ggLT4gJ2EpIHByZWNpc2lvbiAqXG4gICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgKCd4LCAnYiwgJ2MsICdlLCAnZikgcHJlY2lzaW9uX2ZtdF9lYmJcblxuKCogR0FEVCB0eXBlIGFzc29jaWF0aW5nIGEgcGFkZGluZywgYSBwcmVjaXNpb24gYW5kIGFuIGZtdC4gKilcbigqIFNlZSBtYWtlX3BhZHByZWNfZm10X2ViYiBhbmQgcGFyc2VfZm9ybWF0IGZ1bmN0aW9ucy4gKilcbnR5cGUgKCdwLCAnYiwgJ2MsICdlLCAnZikgcGFkcHJlY19mbXRfZWJiID0gUGFkcHJlY19mbXRfRUJCIDpcbiAgICAgKCd4LCAneSkgcGFkZGluZyAqICgneSwgJ3AgLT4gJ2EpIHByZWNpc2lvbiAqXG4gICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgKCdwLCAnYiwgJ2MsICdlLCAnZikgcGFkcHJlY19mbXRfZWJiXG5cbigqIEFic3RyYWN0IHRoZSAnYSBhbmQgJ2QgcGFyYW1ldGVycyBvZiBhbiBmbXQuICopXG4oKiBPdXRwdXQgdHlwZSBvZiB0aGUgZm9ybWF0IHBhcnNpbmcgZnVuY3Rpb24uICopXG50eXBlICgnYiwgJ2MsICdlLCAnZikgZm10X2ViYiA9IEZtdF9FQkIgOlxuICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICgnYiwgJ2MsICdlLCAnZikgZm10X2ViYlxuXG4oKiBHQURUIHR5cGUgYXNzb2NpYXRpbmcgYW4gZm10dHkgYW5kIGFuIGZtdC4gKilcbigqIFNlZSB0aGUgdHlwZV9mb3JtYXRfZ2VuIGZ1bmN0aW9uLiAqKVxudHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10X2ZtdHR5X2ViYiA9IEZtdF9mbXR0eV9FQkIgOlxuICAgICAoJ2EsICdiLCAnYywgJ2QsICd5LCAneCkgZm10ICpcbiAgICAgKCd4LCAnYiwgJ2MsICd5LCAnZSwgJ2YpIGZtdHR5IC0+XG4gICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRfZm10dHlfZWJiXG5cbigqIEdBRFQgdHlwZSBhc3NvY2lhdGluZyBhbiBmbXR0eSBhbmQgYW4gZm10LiAqKVxuKCogU2VlIHRoZSB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBmdW5jdGlvbi4gKilcbnR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdHR5X2ZtdF9lYmIgPSBGbXR0eV9mbXRfRUJCIDpcbiAgICAgKCdhLCAnYiwgJ2MsICdkLCAneSwgJ3gpIGZtdHR5ICpcbiAgICAgKCd4LCAnYiwgJ2MsICd5LCAnZSwgJ2YpIGZtdF9mbXR0eV9lYmIgLT5cbiAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdHR5X2ZtdF9lYmJcblxuKCogQWJzdHJhY3QgYWxsIGZtdHR5IHR5cGUgcGFyYW1ldGVycy4gKilcbigqIFVzZWQgdG8gY29tcGFyZSBmb3JtYXQgdHlwZXMuICopXG50eXBlIGZtdHR5X2ViYiA9IEZtdHR5X0VCQiA6ICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXR0eSAtPiBmbXR0eV9lYmJcblxuKCogQWJzdHJhY3QgYWxsIHBhZGRpbmcgdHlwZSBwYXJhbWV0ZXJzLiAqKVxuKCogVXNlZCB0byBjb21wYXJlIHBhZGRpbmdzLiAqKVxudHlwZSBwYWRkaW5nX2ViYiA9IFBhZGRpbmdfRUJCIDogKCdhLCAnYikgcGFkZGluZyAtPiBwYWRkaW5nX2ViYlxuXG4oKiBBYnN0cmFjdCBhbGwgcHJlY2lzaW9uIHR5cGUgcGFyYW1ldGVycy4gKilcbigqIFVzZWQgdG8gY29tcGFyZSBwcmVjaXNpb25zLiAqKVxudHlwZSBwcmVjaXNpb25fZWJiID0gUHJlY2lzaW9uX0VCQiA6ICgnYSwgJ2IpIHByZWNpc2lvbiAtPiBwcmVjaXNpb25fZWJiXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQ29uc3RhbnRzICopXG5cbigqIERlZmF1bHQgcHJlY2lzaW9uIGZvciBmbG9hdCBwcmludGluZy4gKilcbmxldCBkZWZhdWx0X2Zsb2F0X3ByZWNpc2lvbiBmY29udiA9XG4gIG1hdGNoIHNuZCBmY29udiB3aXRoXG4gIHwgRmxvYXRfZiB8IEZsb2F0X2UgfCBGbG9hdF9FIHwgRmxvYXRfZyB8IEZsb2F0X0cgfCBGbG9hdF9oIHwgRmxvYXRfSFxuICB8IEZsb2F0X0NGIC0+IC02XG4gICgqIEZvciAlaCAlSCBhbmQgJSNGIGZvcm1hdHMsIGEgbmVnYXRpdmUgcHJlY2lzaW9uIG1lYW5zIFwiYXMgbWFueSBkaWdpdHMgYXNcbiAgICAgbmVjZXNzYXJ5XCIuICBGb3IgdGhlIG90aGVyIEZQIGZvcm1hdHMsIHdlIHRha2UgdGhlIGFic29sdXRlIHZhbHVlXG4gICAgIG9mIHRoZSBwcmVjaXNpb24sIGhlbmNlIDYgZGlnaXRzIGJ5IGRlZmF1bHQuICopXG4gIHwgRmxvYXRfRiAtPiAxMlxuICAoKiBEZWZhdWx0IHByZWNpc2lvbiBmb3IgT0NhbWwgZmxvYXQgcHJpbnRpbmcgKCVGKS4gKilcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBFeHRlcm5hbHMgKilcblxuZXh0ZXJuYWwgZm9ybWF0X2Zsb2F0OiBzdHJpbmcgLT4gZmxvYXQgLT4gc3RyaW5nXG4gID0gXCJjYW1sX2Zvcm1hdF9mbG9hdFwiXG5leHRlcm5hbCBmb3JtYXRfaW50OiBzdHJpbmcgLT4gaW50IC0+IHN0cmluZ1xuICA9IFwiY2FtbF9mb3JtYXRfaW50XCJcbmV4dGVybmFsIGZvcm1hdF9pbnQzMjogc3RyaW5nIC0+IGludDMyIC0+IHN0cmluZ1xuICA9IFwiY2FtbF9pbnQzMl9mb3JtYXRcIlxuZXh0ZXJuYWwgZm9ybWF0X25hdGl2ZWludDogc3RyaW5nIC0+IG5hdGl2ZWludCAtPiBzdHJpbmdcbiAgPSBcImNhbWxfbmF0aXZlaW50X2Zvcm1hdFwiXG5leHRlcm5hbCBmb3JtYXRfaW50NjQ6IHN0cmluZyAtPiBpbnQ2NCAtPiBzdHJpbmdcbiAgPSBcImNhbWxfaW50NjRfZm9ybWF0XCJcbmV4dGVybmFsIGhleHN0cmluZ19vZl9mbG9hdDogZmxvYXQgLT4gaW50IC0+IGNoYXIgLT4gc3RyaW5nXG4gID0gXCJjYW1sX2hleHN0cmluZ19vZl9mbG9hdFwiXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAoKiBUb29scyB0byBwcmV0dHktcHJpbnQgZm9ybWF0cyAqKVxuXG4oKiBUeXBlIG9mIGV4dGVuc2libGUgY2hhcmFjdGVyIGJ1ZmZlcnMuICopXG50eXBlIGJ1ZmZlciA9IHtcbiAgbXV0YWJsZSBpbmQgOiBpbnQ7XG4gIG11dGFibGUgYnl0ZXMgOiBieXRlcztcbn1cblxuKCogQ3JlYXRlIGEgZnJlc2ggYnVmZmVyLiAqKVxubGV0IGJ1ZmZlcl9jcmVhdGUgaW5pdF9zaXplID0geyBpbmQgPSAwOyBieXRlcyA9IEJ5dGVzLmNyZWF0ZSBpbml0X3NpemUgfVxuXG4oKiBDaGVjayBzaXplIG9mIHRoZSBidWZmZXIgYW5kIGdyb3cgaXQgaWYgbmVlZGVkLiAqKVxubGV0IGJ1ZmZlcl9jaGVja19zaXplIGJ1ZiBvdmVyaGVhZCA9XG4gIGxldCBsZW4gPSBCeXRlcy5sZW5ndGggYnVmLmJ5dGVzIGluXG4gIGxldCBtaW5fbGVuID0gYnVmLmluZCArIG92ZXJoZWFkIGluXG4gIGlmIG1pbl9sZW4gPiBsZW4gdGhlbiAoXG4gICAgbGV0IG5ld19sZW4gPSBJbnQubWF4IChsZW4gKiAyKSBtaW5fbGVuIGluXG4gICAgbGV0IG5ld19zdHIgPSBCeXRlcy5jcmVhdGUgbmV3X2xlbiBpblxuICAgIEJ5dGVzLmJsaXQgYnVmLmJ5dGVzIDAgbmV3X3N0ciAwIGxlbjtcbiAgICBidWYuYnl0ZXMgPC0gbmV3X3N0cjtcbiAgKVxuXG4oKiBBZGQgdGhlIGNoYXJhY3RlciBgYycgdG8gdGhlIGJ1ZmZlciBgYnVmJy4gKilcbmxldCBidWZmZXJfYWRkX2NoYXIgYnVmIGMgPVxuICBidWZmZXJfY2hlY2tfc2l6ZSBidWYgMTtcbiAgQnl0ZXMuc2V0IGJ1Zi5ieXRlcyBidWYuaW5kIGM7XG4gIGJ1Zi5pbmQgPC0gYnVmLmluZCArIDFcblxuKCogQWRkIHRoZSBzdHJpbmcgYHMnIHRvIHRoZSBidWZmZXIgYGJ1ZicuICopXG5sZXQgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIHMgPVxuICBsZXQgc3RyX2xlbiA9IFN0cmluZy5sZW5ndGggcyBpblxuICBidWZmZXJfY2hlY2tfc2l6ZSBidWYgc3RyX2xlbjtcbiAgU3RyaW5nLmJsaXQgcyAwIGJ1Zi5ieXRlcyBidWYuaW5kIHN0cl9sZW47XG4gIGJ1Zi5pbmQgPC0gYnVmLmluZCArIHN0cl9sZW5cblxuKCogR2V0IHRoZSBjb250ZW50IG9mIHRoZSBidWZmZXIuICopXG5sZXQgYnVmZmVyX2NvbnRlbnRzIGJ1ZiA9XG4gIEJ5dGVzLnN1Yl9zdHJpbmcgYnVmLmJ5dGVzIDAgYnVmLmluZFxuXG4oKioqKVxuXG4oKiBDb252ZXJ0IGFuIGludGVnZXIgY29udmVyc2lvbiB0byBjaGFyLiAqKVxubGV0IGNoYXJfb2ZfaWNvbnYgaWNvbnYgPSBtYXRjaCBpY29udiB3aXRoXG4gIHwgSW50X2QgfCBJbnRfcGQgfCBJbnRfc2QgfCBJbnRfQ2QgLT4gJ2QnIHwgSW50X2kgfCBJbnRfcGkgfCBJbnRfc2lcbiAgfCBJbnRfQ2kgLT4gJ2knIHwgSW50X3ggfCBJbnRfQ3ggLT4gJ3gnIHwgSW50X1ggfCBJbnRfQ1ggLT4gJ1gnIHwgSW50X29cbiAgfCBJbnRfQ28gLT4gJ28nIHwgSW50X3UgfCBJbnRfQ3UgLT4gJ3UnXG5cbigqIENvbnZlcnQgYSBmbG9hdCBjb252ZXJzaW9uIHRvIGNoYXIuICopXG4oKiBgY0YnIHdpbGwgYmUgJ0YnIGZvciBkaXNwbGF5aW5nIGZvcm1hdCBhbmQgJ2cnIHRvIGNhbGwgbGliYyBwcmludGYgKilcbmxldCBjaGFyX29mX2Zjb252ID8oY0Y9J0YnKSBmY29udiA9IG1hdGNoIHNuZCBmY29udiB3aXRoXG4gIHwgRmxvYXRfZiAtPiAnZicgfCBGbG9hdF9lIC0+ICdlJ1xuICB8IEZsb2F0X0UgLT4gJ0UnIHwgRmxvYXRfZyAtPiAnZydcbiAgfCBGbG9hdF9HIC0+ICdHJyB8IEZsb2F0X0YgLT4gY0ZcbiAgfCBGbG9hdF9oIC0+ICdoJyB8IEZsb2F0X0ggLT4gJ0gnXG4gIHwgRmxvYXRfQ0YgLT4gJ0YnXG5cblxuKCogQ29udmVydCBhIHNjYW5uaW5nIGNvdW50ZXIgdG8gY2hhci4gKilcbmxldCBjaGFyX29mX2NvdW50ZXIgY291bnRlciA9IG1hdGNoIGNvdW50ZXIgd2l0aFxuICB8IExpbmVfY291bnRlciAgLT4gJ2wnXG4gIHwgQ2hhcl9jb3VudGVyICAtPiAnbidcbiAgfCBUb2tlbl9jb3VudGVyIC0+ICdOJ1xuXG4oKioqKVxuXG4oKiBQcmludCBhIGNoYXJfc2V0IGluIGEgYnVmZmVyIHdpdGggdGhlIE9DYW1sIGZvcm1hdCBsZXhpY2FsIGNvbnZlbnRpb24uICopXG5sZXQgYnByaW50X2NoYXJfc2V0IGJ1ZiBjaGFyX3NldCA9XG4gIGxldCByZWMgcHJpbnRfc3RhcnQgc2V0ID1cbiAgICBsZXQgaXNfYWxvbmUgYyA9XG4gICAgICBsZXQgYmVmb3JlLCBhZnRlciA9IENoYXIuKGNociAoY29kZSBjIC0gMSksIGNociAoY29kZSBjICsgMSkpIGluXG4gICAgICBpc19pbl9jaGFyX3NldCBzZXQgY1xuICAgICAgJiYgbm90IChpc19pbl9jaGFyX3NldCBzZXQgYmVmb3JlICYmIGlzX2luX2NoYXJfc2V0IHNldCBhZnRlcikgaW5cbiAgICBpZiBpc19hbG9uZSAnXScgdGhlbiBidWZmZXJfYWRkX2NoYXIgYnVmICddJztcbiAgICBwcmludF9vdXQgc2V0IDE7XG4gICAgaWYgaXNfYWxvbmUgJy0nIHRoZW4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnLSc7XG4gIGFuZCBwcmludF9vdXQgc2V0IGkgPVxuICAgIGlmIGkgPCAyNTYgdGhlblxuICAgICAgaWYgaXNfaW5fY2hhcl9zZXQgc2V0IChjaGFyX29mX2ludCBpKSB0aGVuIHByaW50X2ZpcnN0IHNldCBpXG4gICAgICBlbHNlIHByaW50X291dCBzZXQgKGkgKyAxKVxuICBhbmQgcHJpbnRfZmlyc3Qgc2V0IGkgPVxuICAgIG1hdGNoIGNoYXJfb2ZfaW50IGkgd2l0aFxuICAgIHwgJ1xcMjU1JyAtPiBwcmludF9jaGFyIGJ1ZiAyNTU7XG4gICAgfCAnXScgfCAnLScgLT4gcHJpbnRfb3V0IHNldCAoaSArIDEpO1xuICAgIHwgXyAtPiBwcmludF9zZWNvbmQgc2V0IChpICsgMSk7XG4gIGFuZCBwcmludF9zZWNvbmQgc2V0IGkgPVxuICAgIGlmIGlzX2luX2NoYXJfc2V0IHNldCAoY2hhcl9vZl9pbnQgaSkgdGhlblxuICAgICAgbWF0Y2ggY2hhcl9vZl9pbnQgaSB3aXRoXG4gICAgICB8ICdcXDI1NScgLT5cbiAgICAgICAgcHJpbnRfY2hhciBidWYgMjU0O1xuICAgICAgICBwcmludF9jaGFyIGJ1ZiAyNTU7XG4gICAgICB8ICddJyB8ICctJyB3aGVuIG5vdCAoaXNfaW5fY2hhcl9zZXQgc2V0IChjaGFyX29mX2ludCAoaSArIDEpKSkgLT5cbiAgICAgICAgcHJpbnRfY2hhciBidWYgKGkgLSAxKTtcbiAgICAgICAgcHJpbnRfb3V0IHNldCAoaSArIDEpO1xuICAgICAgfCBfIHdoZW4gbm90IChpc19pbl9jaGFyX3NldCBzZXQgKGNoYXJfb2ZfaW50IChpICsgMSkpKSAtPlxuICAgICAgICBwcmludF9jaGFyIGJ1ZiAoaSAtIDEpO1xuICAgICAgICBwcmludF9jaGFyIGJ1ZiBpO1xuICAgICAgICBwcmludF9vdXQgc2V0IChpICsgMik7XG4gICAgICB8IF8gLT5cbiAgICAgICAgcHJpbnRfaW4gc2V0IChpIC0gMSkgKGkgKyAyKTtcbiAgICBlbHNlIChcbiAgICAgIHByaW50X2NoYXIgYnVmIChpIC0gMSk7XG4gICAgICBwcmludF9vdXQgc2V0IChpICsgMSk7XG4gICAgKVxuICBhbmQgcHJpbnRfaW4gc2V0IGkgaiA9XG4gICAgaWYgaiA9IDI1NiB8fCBub3QgKGlzX2luX2NoYXJfc2V0IHNldCAoY2hhcl9vZl9pbnQgaikpIHRoZW4gKFxuICAgICAgcHJpbnRfY2hhciBidWYgaTtcbiAgICAgIHByaW50X2NoYXIgYnVmIChpbnRfb2ZfY2hhciAnLScpO1xuICAgICAgcHJpbnRfY2hhciBidWYgKGogLSAxKTtcbiAgICAgIGlmIGogPCAyNTYgdGhlbiBwcmludF9vdXQgc2V0IChqICsgMSk7XG4gICAgKSBlbHNlXG4gICAgICBwcmludF9pbiBzZXQgaSAoaiArIDEpO1xuICBhbmQgcHJpbnRfY2hhciBidWYgaSA9IG1hdGNoIGNoYXJfb2ZfaW50IGkgd2l0aFxuICAgIHwgJyUnIC0+IGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBidWZmZXJfYWRkX2NoYXIgYnVmICclJztcbiAgICB8ICdAJyAtPiBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnQCc7XG4gICAgfCBjICAgLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiBjO1xuICBpblxuICBidWZmZXJfYWRkX2NoYXIgYnVmICdbJztcbiAgcHJpbnRfc3RhcnQgKFxuICAgIGlmIGlzX2luX2NoYXJfc2V0IGNoYXJfc2V0ICdcXDAwMCdcbiAgICB0aGVuICggYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnXic7IHJldl9jaGFyX3NldCBjaGFyX3NldCApXG4gICAgZWxzZSBjaGFyX3NldFxuICApO1xuICBidWZmZXJfYWRkX2NoYXIgYnVmICddJ1xuXG4oKioqKVxuXG4oKiBQcmludCBhIHBhZHR5IGluIGEgYnVmZmVyIHdpdGggdGhlIGZvcm1hdC1saWtlIHN5bnRheC4gKilcbmxldCBicHJpbnRfcGFkdHkgYnVmIHBhZHR5ID0gbWF0Y2ggcGFkdHkgd2l0aFxuICB8IExlZnQgIC0+IGJ1ZmZlcl9hZGRfY2hhciBidWYgJy0nXG4gIHwgUmlnaHQgLT4gKClcbiAgfCBaZXJvcyAtPiBidWZmZXJfYWRkX2NoYXIgYnVmICcwJ1xuXG4oKiBQcmludCB0aGUgJ18nIG9mIGFuIGlnbm9yZWQgZmxhZyBpZiBuZWVkZWQuICopXG5sZXQgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWcgPVxuICBpZiBpZ25fZmxhZyB0aGVuIGJ1ZmZlcl9hZGRfY2hhciBidWYgJ18nXG5cbigqKiopXG5cbmxldCBicHJpbnRfcGFkX29wdCBidWYgcGFkX29wdCA9IG1hdGNoIHBhZF9vcHQgd2l0aFxuICB8IE5vbmUgLT4gKClcbiAgfCBTb21lIHdpZHRoIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiAoSW50LnRvX3N0cmluZyB3aWR0aClcblxuKCoqKilcblxuKCogUHJpbnQgcGFkZGluZyBpbiBhIGJ1ZmZlciB3aXRoIHRoZSBmb3JtYXQtbGlrZSBzeW50YXguICopXG5sZXQgYnByaW50X3BhZGRpbmcgOiB0eXBlIGEgYiAuIGJ1ZmZlciAtPiAoYSwgYikgcGFkZGluZyAtPiB1bml0ID1cbmZ1biBidWYgcGFkIC0+IG1hdGNoIHBhZCB3aXRoXG4gIHwgTm9fcGFkZGluZyAtPiAoKVxuICB8IExpdF9wYWRkaW5nIChwYWR0eSwgbikgLT5cbiAgICBicHJpbnRfcGFkdHkgYnVmIHBhZHR5O1xuICAgIGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiAoSW50LnRvX3N0cmluZyBuKTtcbiAgfCBBcmdfcGFkZGluZyBwYWR0eSAtPlxuICAgIGJwcmludF9wYWR0eSBidWYgcGFkdHk7XG4gICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnKidcblxuKCogUHJpbnQgcHJlY2lzaW9uIGluIGEgYnVmZmVyIHdpdGggdGhlIGZvcm1hdC1saWtlIHN5bnRheC4gKilcbmxldCBicHJpbnRfcHJlY2lzaW9uIDogdHlwZSBhIGIgLiBidWZmZXIgLT4gKGEsIGIpIHByZWNpc2lvbiAtPiB1bml0ID1cbiAgZnVuIGJ1ZiBwcmVjIC0+IG1hdGNoIHByZWMgd2l0aFxuICB8IE5vX3ByZWNpc2lvbiAtPiAoKVxuICB8IExpdF9wcmVjaXNpb24gbiAtPlxuICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJy4nO1xuICAgIGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiAoSW50LnRvX3N0cmluZyBuKTtcbiAgfCBBcmdfcHJlY2lzaW9uIC0+XG4gICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiLipcIlxuXG4oKioqKVxuXG4oKiBQcmludCB0aGUgb3B0aW9uYWwgJysnLCAnICcgb3IgJyMnIGFzc29jaWF0ZWQgdG8gYW4gaW50IGNvbnZlcnNpb24uICopXG5sZXQgYnByaW50X2ljb252X2ZsYWcgYnVmIGljb252ID0gbWF0Y2ggaWNvbnYgd2l0aFxuICB8IEludF9wZCB8IEludF9waSAtPiBidWZmZXJfYWRkX2NoYXIgYnVmICcrJ1xuICB8IEludF9zZCB8IEludF9zaSAtPiBidWZmZXJfYWRkX2NoYXIgYnVmICcgJ1xuICB8IEludF9DeCB8IEludF9DWCB8IEludF9DbyB8IEludF9DZCB8IEludF9DaSB8IEludF9DdSAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnIydcbiAgfCBJbnRfZCB8IEludF9pIHwgSW50X3ggfCBJbnRfWCB8IEludF9vIHwgSW50X3UgLT4gKClcblxuKCogUHJpbnQgYW4gY29tcGxldGUgaW50IGZvcm1hdCBpbiBhIGJ1ZmZlciAoZXg6IFwiJTMuKmRcIikuICopXG5sZXQgYnByaW50X2ludF9mbXQgYnVmIGlnbl9mbGFnIGljb252IHBhZCBwcmVjID1cbiAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7XG4gIGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICBicHJpbnRfaWNvbnZfZmxhZyBidWYgaWNvbnY7XG4gIGJwcmludF9wYWRkaW5nIGJ1ZiBwYWQ7XG4gIGJwcmludF9wcmVjaXNpb24gYnVmIHByZWM7XG4gIGJ1ZmZlcl9hZGRfY2hhciBidWYgKGNoYXJfb2ZfaWNvbnYgaWNvbnYpXG5cbigqIFByaW50IGEgY29tcGxldGUgaW50MzIsIG5hdGl2ZWludCBvciBpbnQ2NCBmb3JtYXQgaW4gYSBidWZmZXIuICopXG5sZXQgYnByaW50X2FsdGludF9mbXQgYnVmIGlnbl9mbGFnIGljb252IHBhZCBwcmVjIGMgPVxuICBidWZmZXJfYWRkX2NoYXIgYnVmICclJztcbiAgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gIGJwcmludF9pY29udl9mbGFnIGJ1ZiBpY29udjtcbiAgYnByaW50X3BhZGRpbmcgYnVmIHBhZDtcbiAgYnByaW50X3ByZWNpc2lvbiBidWYgcHJlYztcbiAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiBjO1xuICBidWZmZXJfYWRkX2NoYXIgYnVmIChjaGFyX29mX2ljb252IGljb252KVxuXG4oKioqKVxuXG4oKiBQcmludCB0aGUgb3B0aW9uYWwgJysnLCAnICcgYW5kL29yICcjJyBhc3NvY2lhdGVkIHRvIGEgZmxvYXQgY29udmVyc2lvbi4gKilcbmxldCBicHJpbnRfZmNvbnZfZmxhZyBidWYgZmNvbnYgPVxuICBiZWdpbiBtYXRjaCBmc3QgZmNvbnYgd2l0aFxuICB8IEZsb2F0X2ZsYWdfcCAtPiBidWZmZXJfYWRkX2NoYXIgYnVmICcrJ1xuICB8IEZsb2F0X2ZsYWdfcyAtPiBidWZmZXJfYWRkX2NoYXIgYnVmICcgJ1xuICB8IEZsb2F0X2ZsYWdfIC0+ICgpIGVuZDtcbiAgbWF0Y2ggc25kIGZjb252IHdpdGhcbiAgfCBGbG9hdF9DRiAtPiBidWZmZXJfYWRkX2NoYXIgYnVmICcjJ1xuICB8IEZsb2F0X2YgfCBGbG9hdF9lIHwgRmxvYXRfRSB8IEZsb2F0X2cgfCBGbG9hdF9HXG4gIHwgRmxvYXRfRiB8IEZsb2F0X2ggfCBGbG9hdF9IIC0+ICgpXG5cbigqIFByaW50IGEgY29tcGxldGUgZmxvYXQgZm9ybWF0IGluIGEgYnVmZmVyIChleDogXCIlKyouM2ZcIikuICopXG5sZXQgYnByaW50X2Zsb2F0X2ZtdCBidWYgaWduX2ZsYWcgZmNvbnYgcGFkIHByZWMgPVxuICBidWZmZXJfYWRkX2NoYXIgYnVmICclJztcbiAgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gIGJwcmludF9mY29udl9mbGFnIGJ1ZiBmY29udjtcbiAgYnByaW50X3BhZGRpbmcgYnVmIHBhZDtcbiAgYnByaW50X3ByZWNpc2lvbiBidWYgcHJlYztcbiAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAoY2hhcl9vZl9mY29udiBmY29udilcblxuKCogQ29tcHV0ZSB0aGUgbGl0ZXJhbCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBGb3JtYXR0aW5nX2xpdC4gKilcbigqIFVzZWQgYnkgUHJpbnRmIGFuZCBTY2FuZiB3aGVyZSBmb3JtYXR0aW5nIGlzIG5vdCBpbnRlcnByZXRlZC4gKilcbmxldCBzdHJpbmdfb2ZfZm9ybWF0dGluZ19saXQgZm9ybWF0dGluZ19saXQgPSBtYXRjaCBmb3JtYXR0aW5nX2xpdCB3aXRoXG4gIHwgQ2xvc2VfYm94ICAgICAgICAgICAgLT4gXCJAXVwiXG4gIHwgQ2xvc2VfdGFnICAgICAgICAgICAgLT4gXCJAfVwiXG4gIHwgQnJlYWsgKHN0ciwgXywgXykgICAgLT4gc3RyXG4gIHwgRkZsdXNoICAgICAgICAgICAgICAgLT4gXCJAP1wiXG4gIHwgRm9yY2VfbmV3bGluZSAgICAgICAgLT4gXCJAXFxuXCJcbiAgfCBGbHVzaF9uZXdsaW5lICAgICAgICAtPiBcIkAuXCJcbiAgfCBNYWdpY19zaXplIChzdHIsIF8pICAtPiBzdHJcbiAgfCBFc2NhcGVkX2F0ICAgICAgICAgICAtPiBcIkBAXCJcbiAgfCBFc2NhcGVkX3BlcmNlbnQgICAgICAtPiBcIkAlXCJcbiAgfCBTY2FuX2luZGljIGMgLT4gXCJAXCIgXiAoU3RyaW5nLm1ha2UgMSBjKVxuXG4oKioqKVxuXG4oKiBQcmludCBhIGxpdGVyYWwgY2hhciBpbiBhIGJ1ZmZlciwgZXNjYXBlICclJyBieSBcIiUlXCIuICopXG5sZXQgYnByaW50X2NoYXJfbGl0ZXJhbCBidWYgY2hyID0gbWF0Y2ggY2hyIHdpdGhcbiAgfCAnJScgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJSVcIlxuICB8IF8gLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiBjaHJcblxuKCogUHJpbnQgYSBsaXRlcmFsIHN0cmluZyBpbiBhIGJ1ZmZlciwgZXNjYXBlIGFsbCAnJScgYnkgXCIlJVwiLiAqKVxubGV0IGJwcmludF9zdHJpbmdfbGl0ZXJhbCBidWYgc3RyID1cbiAgZm9yIGkgPSAwIHRvIFN0cmluZy5sZW5ndGggc3RyIC0gMSBkb1xuICAgIGJwcmludF9jaGFyX2xpdGVyYWwgYnVmIHN0ci5baV1cbiAgZG9uZVxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBGb3JtYXQgcHJldHR5LXByaW50aW5nICopXG5cbigqIFByaW50IGEgY29tcGxldGUgZm9ybWF0IHR5cGUgKGFuIGZtdHR5KSBpbiBhIGJ1ZmZlci4gKilcbmxldCByZWMgYnByaW50X2ZtdHR5IDogdHlwZSBhIGIgYyBkIGUgZiBnIGggaSBqIGsgbCAuXG4gICAgYnVmZmVyIC0+IChhLCBiLCBjLCBkLCBlLCBmLCBnLCBoLCBpLCBqLCBrLCBsKSBmbXR0eV9yZWwgLT4gdW5pdCA9XG5mdW4gYnVmIGZtdHR5IC0+IG1hdGNoIGZtdHR5IHdpdGhcbiAgfCBDaGFyX3R5IHJlc3QgICAgICAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlY1wiOyAgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IFN0cmluZ190eSByZXN0ICAgIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiVzXCI7ICBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgSW50X3R5IHJlc3QgICAgICAgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJWlcIjsgIGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBJbnQzMl90eSByZXN0ICAgICAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlbGlcIjsgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IE5hdGl2ZWludF90eSByZXN0IC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiVuaVwiOyBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgSW50NjRfdHkgcmVzdCAgICAgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJUxpXCI7IGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBGbG9hdF90eSByZXN0ICAgICAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlZlwiOyAgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IEJvb2xfdHkgcmVzdCAgICAgIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiVCXCI7ICBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgQWxwaGFfdHkgcmVzdCAgICAgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJWFcIjsgIGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBUaGV0YV90eSByZXN0ICAgICAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIldFwiOyAgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IEFueV90eSByZXN0ICAgICAgIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiU/XCI7ICBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgUmVhZGVyX3R5IHJlc3QgICAgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJXJcIjsgIGJwcmludF9mbXR0eSBidWYgcmVzdDtcblxuICB8IElnbm9yZWRfcmVhZGVyX3R5IHJlc3QgLT5cbiAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlX3JcIjtcbiAgICBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG5cbiAgfCBGb3JtYXRfYXJnX3R5IChzdWJfZm10dHksIHJlc3QpIC0+XG4gICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJXtcIjsgYnByaW50X2ZtdHR5IGJ1ZiBzdWJfZm10dHk7XG4gICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJX1cIjsgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IEZvcm1hdF9zdWJzdF90eSAoc3ViX2ZtdHR5LCBfLCByZXN0KSAtPlxuICAgIGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiUoXCI7IGJwcmludF9mbXR0eSBidWYgc3ViX2ZtdHR5O1xuICAgIGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiUpXCI7IGJwcmludF9mbXR0eSBidWYgcmVzdDtcblxuICB8IEVuZF9vZl9mbXR0eSAtPiAoKVxuXG4oKioqKVxuXG5sZXQgcmVjIGludF9vZl9jdXN0b21fYXJpdHkgOiB0eXBlIGEgYiBjIC5cbiAgKGEsIGIsIGMpIGN1c3RvbV9hcml0eSAtPiBpbnQgPVxuICBmdW5jdGlvblxuICB8IEN1c3RvbV96ZXJvIC0+IDBcbiAgfCBDdXN0b21fc3VjYyB4IC0+IDEgKyBpbnRfb2ZfY3VzdG9tX2FyaXR5IHhcblxuKCogUHJpbnQgYSBjb21wbGV0ZSBmb3JtYXQgaW4gYSBidWZmZXIuICopXG5sZXQgYnByaW50X2ZtdCBidWYgZm10ID1cbiAgbGV0IHJlYyBmbXRpdGVyIDogdHlwZSBhIGIgYyBkIGUgZiAuXG4gICAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+IGJvb2wgLT4gdW5pdCA9XG4gIGZ1biBmbXQgaWduX2ZsYWcgLT4gbWF0Y2ggZm10IHdpdGhcbiAgICB8IFN0cmluZyAocGFkLCByZXN0KSAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnByaW50X3BhZGRpbmcgYnVmIHBhZDsgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAncyc7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBDYW1sX3N0cmluZyAocGFkLCByZXN0KSAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnByaW50X3BhZGRpbmcgYnVmIHBhZDsgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnUyc7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG5cbiAgICB8IEludCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICAgIGJwcmludF9pbnRfZm10IGJ1ZiBpZ25fZmxhZyBpY29udiBwYWQgcHJlYztcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IEludDMyIChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgICAgYnByaW50X2FsdGludF9mbXQgYnVmIGlnbl9mbGFnIGljb252IHBhZCBwcmVjICdsJztcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IE5hdGl2ZWludCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICAgIGJwcmludF9hbHRpbnRfZm10IGJ1ZiBpZ25fZmxhZyBpY29udiBwYWQgcHJlYyAnbic7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBJbnQ2NCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICAgIGJwcmludF9hbHRpbnRfZm10IGJ1ZiBpZ25fZmxhZyBpY29udiBwYWQgcHJlYyAnTCc7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBGbG9hdCAoZmNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICAgIGJwcmludF9mbG9hdF9mbXQgYnVmIGlnbl9mbGFnIGZjb252IHBhZCBwcmVjO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuXG4gICAgfCBDaGFyIHJlc3QgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJ2MnOyBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBDYW1sX2NoYXIgcmVzdCAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnQyc7IGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IEJvb2wgKHBhZCwgcmVzdCkgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJwcmludF9wYWRkaW5nIGJ1ZiBwYWQ7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJ0InO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgQWxwaGEgcmVzdCAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnYSc7IGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IFRoZXRhIHJlc3QgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJ3QnOyBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBDdXN0b20gKGFyaXR5LCBfLCByZXN0KSAtPlxuICAgICAgZm9yIF9pID0gMSB0byBpbnRfb2ZfY3VzdG9tX2FyaXR5IGFyaXR5IGRvXG4gICAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnPyc7XG4gICAgICBkb25lO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgUmVhZGVyIHJlc3QgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJ3InOyBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBGbHVzaCByZXN0IC0+XG4gICAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlIVwiO1xuICAgICAgZm10aXRlciByZXN0IGlnbl9mbGFnO1xuXG4gICAgfCBTdHJpbmdfbGl0ZXJhbCAoc3RyLCByZXN0KSAtPlxuICAgICAgYnByaW50X3N0cmluZ19saXRlcmFsIGJ1ZiBzdHI7XG4gICAgICBmbXRpdGVyIHJlc3QgaWduX2ZsYWc7XG4gICAgfCBDaGFyX2xpdGVyYWwgKGNociwgcmVzdCkgLT5cbiAgICAgIGJwcmludF9jaGFyX2xpdGVyYWwgYnVmIGNocjtcbiAgICAgIGZtdGl0ZXIgcmVzdCBpZ25fZmxhZztcblxuICAgIHwgRm9ybWF0X2FyZyAocGFkX29wdCwgZm10dHksIHJlc3QpIC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBicHJpbnRfcGFkX29wdCBidWYgcGFkX29wdDsgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAneyc7XG4gICAgICBicHJpbnRfZm10dHkgYnVmIGZtdHR5OyBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnfSc7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBGb3JtYXRfc3Vic3QgKHBhZF9vcHQsIGZtdHR5LCByZXN0KSAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnByaW50X3BhZF9vcHQgYnVmIHBhZF9vcHQ7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJygnO1xuICAgICAgYnByaW50X2ZtdHR5IGJ1ZiBmbXR0eTsgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJyknO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuXG4gICAgfCBTY2FuX2NoYXJfc2V0ICh3aWR0aF9vcHQsIGNoYXJfc2V0LCByZXN0KSAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnByaW50X3BhZF9vcHQgYnVmIHdpZHRoX29wdDsgYnByaW50X2NoYXJfc2V0IGJ1ZiBjaGFyX3NldDtcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IFNjYW5fZ2V0X2NvdW50ZXIgKGNvdW50ZXIsIHJlc3QpIC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmIChjaGFyX29mX2NvdW50ZXIgY291bnRlcik7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBTY2FuX25leHRfY2hhciByZXN0IC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBicHJpbnRfc3RyaW5nX2xpdGVyYWwgYnVmIFwiMGNcIjsgZm10aXRlciByZXN0IGZhbHNlO1xuXG4gICAgfCBJZ25vcmVkX3BhcmFtIChpZ24sIHJlc3QpIC0+XG4gICAgICBsZXQgUGFyYW1fZm9ybWF0X0VCQiBmbXQnID0gcGFyYW1fZm9ybWF0X29mX2lnbm9yZWRfZm9ybWF0IGlnbiByZXN0IGluXG4gICAgICBmbXRpdGVyIGZtdCcgdHJ1ZTtcblxuICAgIHwgRm9ybWF0dGluZ19saXQgKGZtdGluZ19saXQsIHJlc3QpIC0+XG4gICAgICBicHJpbnRfc3RyaW5nX2xpdGVyYWwgYnVmIChzdHJpbmdfb2ZfZm9ybWF0dGluZ19saXQgZm10aW5nX2xpdCk7XG4gICAgICBmbXRpdGVyIHJlc3QgaWduX2ZsYWc7XG4gICAgfCBGb3JtYXR0aW5nX2dlbiAoZm10aW5nX2dlbiwgcmVzdCkgLT5cbiAgICAgIGJlZ2luIG1hdGNoIGZtdGluZ19nZW4gd2l0aFxuICAgICAgfCBPcGVuX3RhZyAoRm9ybWF0IChfLCBzdHIpKSAtPlxuICAgICAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgXCJAe1wiOyBidWZmZXJfYWRkX3N0cmluZyBidWYgc3RyXG4gICAgICB8IE9wZW5fYm94IChGb3JtYXQgKF8sIHN0cikpIC0+XG4gICAgICAgIGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIkBbXCI7IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBzdHJcbiAgICAgIGVuZDtcbiAgICAgIGZtdGl0ZXIgcmVzdCBpZ25fZmxhZztcblxuICAgIHwgRW5kX29mX2Zvcm1hdCAtPiAoKVxuXG4gIGluIGZtdGl0ZXIgZm10IGZhbHNlXG5cbigqKiopXG5cbigqIENvbnZlcnQgYSBmb3JtYXQgdG8gc3RyaW5nLiAqKVxubGV0IHN0cmluZ19vZl9mbXQgZm10ID1cbiAgbGV0IGJ1ZiA9IGJ1ZmZlcl9jcmVhdGUgMTYgaW5cbiAgYnByaW50X2ZtdCBidWYgZm10O1xuICBidWZmZXJfY29udGVudHMgYnVmXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICgqIFR5cGUgZXh0cmFjdGlvbiAqKVxuXG50eXBlIChfLCBfKSBlcSA9IFJlZmwgOiAoJ2EsICdhKSBlcVxuXG4oKiBJbnZhcmlhbnQ6IHRoaXMgZnVuY3Rpb24gaXMgdGhlIGlkZW50aXR5IG9uIHZhbHVlcy5cblxuICAgSW4gcGFydGljdWxhciwgaWYgKHR5MSwgdHkyKSBoYXZlIGVxdWFsIHZhbHVlcywgdGhlblxuICAgKHRyYW5zIChzeW1tIHR5MSkgdHkyKSByZXNwZWN0cyB0aGUgJ3RyYW5zJyBwcmVjb25kaXRpb24uICopXG5sZXQgcmVjIHN5bW0gOiB0eXBlIGExIGIxIGMxIGQxIGUxIGYxIGEyIGIyIGMyIGQyIGUyIGYyIC5cbiAgIChhMSwgYjEsIGMxLCBkMSwgZTEsIGYxLFxuICAgIGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIpIGZtdHR5X3JlbFxuLT4gKGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIsXG4gICAgYTEsIGIxLCBjMSwgZDEsIGUxLCBmMSkgZm10dHlfcmVsXG49IGZ1bmN0aW9uXG4gIHwgQ2hhcl90eSByZXN0IC0+IENoYXJfdHkgKHN5bW0gcmVzdClcbiAgfCBJbnRfdHkgcmVzdCAtPiBJbnRfdHkgKHN5bW0gcmVzdClcbiAgfCBJbnQzMl90eSByZXN0IC0+IEludDMyX3R5IChzeW1tIHJlc3QpXG4gIHwgSW50NjRfdHkgcmVzdCAtPiBJbnQ2NF90eSAoc3ltbSByZXN0KVxuICB8IE5hdGl2ZWludF90eSByZXN0IC0+IE5hdGl2ZWludF90eSAoc3ltbSByZXN0KVxuICB8IEZsb2F0X3R5IHJlc3QgLT4gRmxvYXRfdHkgKHN5bW0gcmVzdClcbiAgfCBCb29sX3R5IHJlc3QgLT4gQm9vbF90eSAoc3ltbSByZXN0KVxuICB8IFN0cmluZ190eSByZXN0IC0+IFN0cmluZ190eSAoc3ltbSByZXN0KVxuICB8IFRoZXRhX3R5IHJlc3QgLT4gVGhldGFfdHkgKHN5bW0gcmVzdClcbiAgfCBBbHBoYV90eSByZXN0IC0+IEFscGhhX3R5IChzeW1tIHJlc3QpXG4gIHwgQW55X3R5IHJlc3QgLT4gQW55X3R5IChzeW1tIHJlc3QpXG4gIHwgUmVhZGVyX3R5IHJlc3QgLT4gUmVhZGVyX3R5IChzeW1tIHJlc3QpXG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgcmVzdCAtPiBJZ25vcmVkX3JlYWRlcl90eSAoc3ltbSByZXN0KVxuICB8IEZvcm1hdF9hcmdfdHkgKHR5LCByZXN0KSAtPlxuICAgIEZvcm1hdF9hcmdfdHkgKHR5LCBzeW1tIHJlc3QpXG4gIHwgRm9ybWF0X3N1YnN0X3R5ICh0eTEsIHR5MiwgcmVzdCkgLT5cbiAgICBGb3JtYXRfc3Vic3RfdHkgKHR5MiwgdHkxLCBzeW1tIHJlc3QpXG4gIHwgRW5kX29mX2ZtdHR5IC0+IEVuZF9vZl9mbXR0eVxuXG5sZXQgcmVjIGZtdHR5X3JlbF9kZXQgOiB0eXBlIGExIGIgYyBkMSBlMSBmMSBhMiBkMiBlMiBmMiAuXG4gIChhMSwgYiwgYywgZDEsIGUxLCBmMSxcbiAgIGEyLCBiLCBjLCBkMiwgZTIsIGYyKSBmbXR0eV9yZWwgLT5cbiAgICAoKGYxLCBmMikgZXEgLT4gKGExLCBhMikgZXEpXG4gICogKChhMSwgYTIpIGVxIC0+IChmMSwgZjIpIGVxKVxuICAqICgoZTEsIGUyKSBlcSAtPiAoZDEsIGQyKSBlcSlcbiAgKiAoKGQxLCBkMikgZXEgLT4gKGUxLCBlMikgZXEpXG49IGZ1bmN0aW9uXG4gIHwgRW5kX29mX2ZtdHR5IC0+XG4gICAgKGZ1biBSZWZsIC0+IFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IFJlZmwpXG4gIHwgQ2hhcl90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuICB8IFN0cmluZ190eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuICB8IEludF90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuICB8IEludDMyX3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG4gIHwgSW50NjRfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcbiAgfCBOYXRpdmVpbnRfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcbiAgfCBGbG9hdF90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuICB8IEJvb2xfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcblxuICB8IFRoZXRhX3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG4gIHwgQWxwaGFfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcbiAgfCBBbnlfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcbiAgfCBSZWFkZXJfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBlZCBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGRlIFJlZmwgaW4gUmVmbClcbiAgfCBJZ25vcmVkX3JlYWRlcl90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGVkIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZGUgUmVmbCBpbiBSZWZsKVxuICB8IEZvcm1hdF9hcmdfdHkgKF90eSwgcmVzdCkgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG4gIHwgRm9ybWF0X3N1YnN0X3R5ICh0eTEsIHR5MiwgcmVzdCkgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICBsZXQgdHkgPSB0cmFucyAoc3ltbSB0eTEpIHR5MiBpblxuICAgIGxldCBhZywgZ2EsIGRqLCBqZCA9IGZtdHR5X3JlbF9kZXQgdHkgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIGxldCBSZWZsID0gYWcgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBnYSBSZWZsIGluIGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBlZCBSZWZsIGluIGxldCBSZWZsID0gZGogUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBqZCBSZWZsIGluIGxldCBSZWZsID0gZGUgUmVmbCBpbiBSZWZsKVxuXG4oKiBQcmVjb25kaXRpb246IHdlIGFzc3VtZSB0aGF0IHRoZSB0d28gZm10dHlfcmVsIGFyZ3VtZW50cyBoYXZlIGVxdWFsXG4gICB2YWx1ZXMgKGF0IHBvc3NpYmx5IGRpc3RpbmN0IHR5cGVzKTsgdGhpcyBpbnZhcmlhbnQgY29tZXMgZnJvbSB0aGUgd2F5XG4gICBmbXR0eV9yZWwgd2l0bmVzc2VzIGFyZSBwcm9kdWNlZCBieSB0aGUgdHlwZS1jaGVja2VyXG5cbiAgIFRoZSBjb2RlIGJlbG93IHVzZXMgKGFzc2VydCBmYWxzZSkgd2hlbiB0aGlzIGFzc3VtcHRpb24gaXMgYnJva2VuLiBUaGVcbiAgIGNvZGUgcGF0dGVybiBpcyB0aGUgZm9sbG93aW5nOlxuXG4gICAgIHwgRm9vIHgsIEZvbyB5IC0+XG4gICAgICAgKCogY2FzZSB3aGVyZSBpbmRlZWQgYm90aCB2YWx1ZXNcbiAgICAgICAgICBzdGFydCB3aXRoIGNvbnN0cnVjdG9yIEZvbyAqKVxuICAgICB8IEZvbyBfLCBfXG4gICAgIHwgXywgRm9vIF8gLT5cbiAgICAgICAoKiBkaWZmZXJlbnQgaGVhZCBjb25zdHJ1Y3RvcnM6IGJyb2tlbiBwcmVjb25kaXRpb24gKilcbiAgICAgICBhc3NlcnQgZmFsc2VcbiopXG5hbmQgdHJhbnMgOiB0eXBlXG4gIGExIGIxIGMxIGQxIGUxIGYxXG4gIGEyIGIyIGMyIGQyIGUyIGYyXG4gIGEzIGIzIGMzIGQzIGUzIGYzXG4uXG4gICAoYTEsIGIxLCBjMSwgZDEsIGUxLCBmMSxcbiAgICBhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXR0eV9yZWxcbi0+IChhMiwgYjIsIGMyLCBkMiwgZTIsIGYyLFxuICAgIGEzLCBiMywgYzMsIGQzLCBlMywgZjMpIGZtdHR5X3JlbFxuLT4gKGExLCBiMSwgYzEsIGQxLCBlMSwgZjEsXG4gICAgYTMsIGIzLCBjMywgZDMsIGUzLCBmMykgZm10dHlfcmVsXG49IGZ1biB0eTEgdHkyIC0+IG1hdGNoIHR5MSwgdHkyIHdpdGhcbiAgfCBDaGFyX3R5IHJlc3QxLCBDaGFyX3R5IHJlc3QyIC0+IENoYXJfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IFN0cmluZ190eSByZXN0MSwgU3RyaW5nX3R5IHJlc3QyIC0+IFN0cmluZ190eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgQm9vbF90eSByZXN0MSwgQm9vbF90eSByZXN0MiAtPiBCb29sX3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBJbnRfdHkgcmVzdDEsIEludF90eSByZXN0MiAtPiBJbnRfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IEludDMyX3R5IHJlc3QxLCBJbnQzMl90eSByZXN0MiAtPiBJbnQzMl90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgSW50NjRfdHkgcmVzdDEsIEludDY0X3R5IHJlc3QyIC0+IEludDY0X3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBOYXRpdmVpbnRfdHkgcmVzdDEsIE5hdGl2ZWludF90eSByZXN0MiAtPiBOYXRpdmVpbnRfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IEZsb2F0X3R5IHJlc3QxLCBGbG9hdF90eSByZXN0MiAtPiBGbG9hdF90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG5cbiAgfCBBbHBoYV90eSByZXN0MSwgQWxwaGFfdHkgcmVzdDIgLT4gQWxwaGFfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IEFscGhhX3R5IF8sIF8gLT4gYXNzZXJ0IGZhbHNlXG4gIHwgXywgQWxwaGFfdHkgXyAtPiBhc3NlcnQgZmFsc2VcblxuICB8IFRoZXRhX3R5IHJlc3QxLCBUaGV0YV90eSByZXN0MiAtPiBUaGV0YV90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgVGhldGFfdHkgXywgXyAtPiBhc3NlcnQgZmFsc2VcbiAgfCBfLCBUaGV0YV90eSBfIC0+IGFzc2VydCBmYWxzZVxuXG4gIHwgQW55X3R5IHJlc3QxLCBBbnlfdHkgcmVzdDIgLT4gQW55X3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBBbnlfdHkgXywgXyAtPiBhc3NlcnQgZmFsc2VcbiAgfCBfLCBBbnlfdHkgXyAtPiBhc3NlcnQgZmFsc2VcblxuICB8IFJlYWRlcl90eSByZXN0MSwgUmVhZGVyX3R5IHJlc3QyIC0+IFJlYWRlcl90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgUmVhZGVyX3R5IF8sIF8gLT4gYXNzZXJ0IGZhbHNlXG4gIHwgXywgUmVhZGVyX3R5IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiAgfCBJZ25vcmVkX3JlYWRlcl90eSByZXN0MSwgSWdub3JlZF9yZWFkZXJfdHkgcmVzdDIgLT5cbiAgICBJZ25vcmVkX3JlYWRlcl90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgXywgXyAtPiBhc3NlcnQgZmFsc2VcbiAgfCBfLCBJZ25vcmVkX3JlYWRlcl90eSBfIC0+IGFzc2VydCBmYWxzZVxuXG4gIHwgRm9ybWF0X2FyZ190eSAodHkxLCByZXN0MSksIEZvcm1hdF9hcmdfdHkgKHR5MiwgcmVzdDIpIC0+XG4gICAgRm9ybWF0X2FyZ190eSAodHJhbnMgdHkxIHR5MiwgdHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgRm9ybWF0X2FyZ190eSBfLCBfIC0+IGFzc2VydCBmYWxzZVxuICB8IF8sIEZvcm1hdF9hcmdfdHkgXyAtPiBhc3NlcnQgZmFsc2VcblxuICB8IEZvcm1hdF9zdWJzdF90eSAodHkxMSwgdHkxMiwgcmVzdDEpLFxuICAgIEZvcm1hdF9zdWJzdF90eSAodHkyMSwgdHkyMiwgcmVzdDIpIC0+XG4gICAgbGV0IHR5ID0gdHJhbnMgKHN5bW0gdHkxMikgdHkyMSBpblxuICAgIGxldCBfLCBmMiwgXywgZjQgPSBmbXR0eV9yZWxfZGV0IHR5IGluXG4gICAgbGV0IFJlZmwgPSBmMiBSZWZsIGluXG4gICAgbGV0IFJlZmwgPSBmNCBSZWZsIGluXG4gICAgRm9ybWF0X3N1YnN0X3R5ICh0eTExLCB0eTIyLCB0cmFucyByZXN0MSByZXN0MilcbiAgfCBGb3JtYXRfc3Vic3RfdHkgXywgXyAtPiBhc3NlcnQgZmFsc2VcbiAgfCBfLCBGb3JtYXRfc3Vic3RfdHkgXyAtPiBhc3NlcnQgZmFsc2VcblxuICB8IEVuZF9vZl9mbXR0eSwgRW5kX29mX2ZtdHR5IC0+IEVuZF9vZl9mbXR0eVxuICB8IEVuZF9vZl9mbXR0eSwgXyAtPiBhc3NlcnQgZmFsc2VcbiAgfCBfLCBFbmRfb2ZfZm10dHkgLT4gYXNzZXJ0IGZhbHNlXG5cbmxldCByZWMgZm10dHlfb2ZfZm9ybWF0dGluZ19nZW4gOiB0eXBlIGEgYiBjIGQgZSBmIC5cbiAgKGEsIGIsIGMsIGQsIGUsIGYpIGZvcm1hdHRpbmdfZ2VuIC0+XG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5ID1cbmZ1biBmb3JtYXR0aW5nX2dlbiAtPiBtYXRjaCBmb3JtYXR0aW5nX2dlbiB3aXRoXG4gIHwgT3Blbl90YWcgKEZvcm1hdCAoZm10LCBfKSkgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IE9wZW5fYm94IChGb3JtYXQgKGZtdCwgXykpIC0+IGZtdHR5X29mX2ZtdCBmbXRcblxuKCogRXh0cmFjdCB0aGUgdHlwZSByZXByZXNlbnRhdGlvbiAoYW4gZm10dHkpIG9mIGEgZm9ybWF0LiAqKVxuYW5kIGZtdHR5X29mX2ZtdCA6IHR5cGUgYSBiIGMgZCBlIGYgLlxuICAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+IChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSA9XG5mdW4gZm10dHkgLT4gbWF0Y2ggZm10dHkgd2l0aFxuICB8IFN0cmluZyAocGFkLCByZXN0KSAtPlxuICAgIGZtdHR5X29mX3BhZGRpbmdfZm10dHkgcGFkIChTdHJpbmdfdHkgKGZtdHR5X29mX2ZtdCByZXN0KSlcbiAgfCBDYW1sX3N0cmluZyAocGFkLCByZXN0KSAtPlxuICAgIGZtdHR5X29mX3BhZGRpbmdfZm10dHkgcGFkIChTdHJpbmdfdHkgKGZtdHR5X29mX2ZtdCByZXN0KSlcblxuICB8IEludCAoXywgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIGxldCB0eV9yZXN0ID0gZm10dHlfb2ZfZm10IHJlc3QgaW5cbiAgICBsZXQgcHJlY190eSA9IGZtdHR5X29mX3ByZWNpc2lvbl9mbXR0eSBwcmVjIChJbnRfdHkgdHlfcmVzdCkgaW5cbiAgICBmbXR0eV9vZl9wYWRkaW5nX2ZtdHR5IHBhZCBwcmVjX3R5XG4gIHwgSW50MzIgKF8sIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBsZXQgdHlfcmVzdCA9IGZtdHR5X29mX2ZtdCByZXN0IGluXG4gICAgbGV0IHByZWNfdHkgPSBmbXR0eV9vZl9wcmVjaXNpb25fZm10dHkgcHJlYyAoSW50MzJfdHkgdHlfcmVzdCkgaW5cbiAgICBmbXR0eV9vZl9wYWRkaW5nX2ZtdHR5IHBhZCBwcmVjX3R5XG4gIHwgTmF0aXZlaW50IChfLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbGV0IHR5X3Jlc3QgPSBmbXR0eV9vZl9mbXQgcmVzdCBpblxuICAgIGxldCBwcmVjX3R5ID0gZm10dHlfb2ZfcHJlY2lzaW9uX2ZtdHR5IHByZWMgKE5hdGl2ZWludF90eSB0eV9yZXN0KSBpblxuICAgIGZtdHR5X29mX3BhZGRpbmdfZm10dHkgcGFkIHByZWNfdHlcbiAgfCBJbnQ2NCAoXywgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIGxldCB0eV9yZXN0ID0gZm10dHlfb2ZfZm10IHJlc3QgaW5cbiAgICBsZXQgcHJlY190eSA9IGZtdHR5X29mX3ByZWNpc2lvbl9mbXR0eSBwcmVjIChJbnQ2NF90eSB0eV9yZXN0KSBpblxuICAgIGZtdHR5X29mX3BhZGRpbmdfZm10dHkgcGFkIHByZWNfdHlcbiAgfCBGbG9hdCAoXywgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIGxldCB0eV9yZXN0ID0gZm10dHlfb2ZfZm10IHJlc3QgaW5cbiAgICBsZXQgcHJlY190eSA9IGZtdHR5X29mX3ByZWNpc2lvbl9mbXR0eSBwcmVjIChGbG9hdF90eSB0eV9yZXN0KSBpblxuICAgIGZtdHR5X29mX3BhZGRpbmdfZm10dHkgcGFkIHByZWNfdHlcblxuICB8IENoYXIgcmVzdCAgICAgICAgICAgICAgICAgIC0+IENoYXJfdHkgKGZtdHR5X29mX2ZtdCByZXN0KVxuICB8IENhbWxfY2hhciByZXN0ICAgICAgICAgICAgIC0+IENoYXJfdHkgKGZtdHR5X29mX2ZtdCByZXN0KVxuICB8IEJvb2wgKHBhZCwgcmVzdCkgICAgICAgICAgIC0+XG4gICAgICBmbXR0eV9vZl9wYWRkaW5nX2ZtdHR5IHBhZCAoQm9vbF90eSAoZm10dHlfb2ZfZm10IHJlc3QpKVxuICB8IEFscGhhIHJlc3QgICAgICAgICAgICAgICAgIC0+IEFscGhhX3R5IChmbXR0eV9vZl9mbXQgcmVzdClcbiAgfCBUaGV0YSByZXN0ICAgICAgICAgICAgICAgICAtPiBUaGV0YV90eSAoZm10dHlfb2ZfZm10IHJlc3QpXG4gIHwgQ3VzdG9tIChhcml0eSwgXywgcmVzdCkgICAgLT4gZm10dHlfb2ZfY3VzdG9tIGFyaXR5IChmbXR0eV9vZl9mbXQgcmVzdClcbiAgfCBSZWFkZXIgcmVzdCAgICAgICAgICAgICAgICAtPiBSZWFkZXJfdHkgKGZtdHR5X29mX2ZtdCByZXN0KVxuXG4gIHwgRm9ybWF0X2FyZyAoXywgdHksIHJlc3QpIC0+XG4gICAgRm9ybWF0X2FyZ190eSAodHksIGZtdHR5X29mX2ZtdCByZXN0KVxuICB8IEZvcm1hdF9zdWJzdCAoXywgdHksIHJlc3QpIC0+XG4gICAgRm9ybWF0X3N1YnN0X3R5ICh0eSwgdHksIGZtdHR5X29mX2ZtdCByZXN0KVxuXG4gIHwgRmx1c2ggcmVzdCAgICAgICAgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IHJlc3RcbiAgfCBTdHJpbmdfbGl0ZXJhbCAoXywgcmVzdCkgICAtPiBmbXR0eV9vZl9mbXQgcmVzdFxuICB8IENoYXJfbGl0ZXJhbCAoXywgcmVzdCkgICAgIC0+IGZtdHR5X29mX2ZtdCByZXN0XG5cbiAgfCBTY2FuX2NoYXJfc2V0IChfLCBfLCByZXN0KSAtPiBTdHJpbmdfdHkgKGZtdHR5X29mX2ZtdCByZXN0KVxuICB8IFNjYW5fZ2V0X2NvdW50ZXIgKF8sIHJlc3QpIC0+IEludF90eSAoZm10dHlfb2ZfZm10IHJlc3QpXG4gIHwgU2Nhbl9uZXh0X2NoYXIgcmVzdCAgICAgICAgLT4gQ2hhcl90eSAoZm10dHlfb2ZfZm10IHJlc3QpXG4gIHwgSWdub3JlZF9wYXJhbSAoaWduLCByZXN0KSAgLT4gZm10dHlfb2ZfaWdub3JlZF9mb3JtYXQgaWduIHJlc3RcbiAgfCBGb3JtYXR0aW5nX2xpdCAoXywgcmVzdCkgICAtPiBmbXR0eV9vZl9mbXQgcmVzdFxuICB8IEZvcm1hdHRpbmdfZ2VuIChmbXRpbmdfZ2VuLCByZXN0KSAgLT5cbiAgICBjb25jYXRfZm10dHkgKGZtdHR5X29mX2Zvcm1hdHRpbmdfZ2VuIGZtdGluZ19nZW4pIChmbXR0eV9vZl9mbXQgcmVzdClcblxuICB8IEVuZF9vZl9mb3JtYXQgICAgICAgICAgICAgIC0+IEVuZF9vZl9mbXR0eVxuXG5hbmQgZm10dHlfb2ZfY3VzdG9tIDogdHlwZSB4IHkgYSBiIGMgZCBlIGYgLlxuICAoYSwgeCwgeSkgY3VzdG9tX2FyaXR5IC0+IChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSAtPlxuICAoeSwgYiwgYywgZCwgZSwgZikgZm10dHkgPVxuZnVuIGFyaXR5IGZtdHR5IC0+IG1hdGNoIGFyaXR5IHdpdGhcbiAgfCBDdXN0b21femVybyAtPiBmbXR0eVxuICB8IEN1c3RvbV9zdWNjIGFyaXR5IC0+IEFueV90eSAoZm10dHlfb2ZfY3VzdG9tIGFyaXR5IGZtdHR5KVxuXG4oKiBFeHRyYWN0IHRoZSBmbXR0eSBvZiBhbiBpZ25vcmVkIHBhcmFtZXRlciBmb2xsb3dlZCBieSB0aGUgcmVzdCBvZlxuICAgdGhlIGZvcm1hdC4gKilcbmFuZCBmbXR0eV9vZl9pZ25vcmVkX2Zvcm1hdCA6IHR5cGUgeCB5IGEgYiBjIGQgZSBmIC5cbiAgICAoYSwgYiwgYywgZCwgeSwgeCkgaWdub3JlZCAtPlxuICAgICh4LCBiLCBjLCB5LCBlLCBmKSBmbXQgLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10dHkgPVxuZnVuIGlnbiBmbXQgLT4gbWF0Y2ggaWduIHdpdGhcbiAgfCBJZ25vcmVkX2NoYXIgICAgICAgICAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX2NhbWxfY2hhciAgICAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX3N0cmluZyBfICAgICAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX2NhbWxfc3RyaW5nIF8gICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX2ludCAoXywgXykgICAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX2ludDMyIChfLCBfKSAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX25hdGl2ZWludCAoXywgXykgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX2ludDY0IChfLCBfKSAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX2Zsb2F0IChfLCBfKSAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX2Jvb2wgXyAgICAgICAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX2Zvcm1hdF9hcmcgXyAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX2Zvcm1hdF9zdWJzdCAoXywgZm10dHkpIC0+IGNvbmNhdF9mbXR0eSBmbXR0eSAoZm10dHlfb2ZfZm10IGZtdClcbiAgfCBJZ25vcmVkX3JlYWRlciAgICAgICAgICAgICAgICAgIC0+IElnbm9yZWRfcmVhZGVyX3R5IChmbXR0eV9vZl9mbXQgZm10KVxuICB8IElnbm9yZWRfc2Nhbl9jaGFyX3NldCBfICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfc2Nhbl9nZXRfY291bnRlciBfICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfc2Nhbl9uZXh0X2NoYXIgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuXG4oKiBBZGQgYW4gSW50X3R5IG5vZGUgaWYgcGFkZGluZyBpcyB0YWtlbiBhcyBhbiBleHRyYSBhcmd1bWVudCAoZXg6IFwiJSpzXCIpLiAqKVxuYW5kIGZtdHR5X29mX3BhZGRpbmdfZm10dHkgOiB0eXBlIHggYSBiIGMgZCBlIGYgLlxuICAgICh4LCBhKSBwYWRkaW5nIC0+IChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSAtPiAoeCwgYiwgYywgZCwgZSwgZikgZm10dHkgPVxuICBmdW4gcGFkIGZtdHR5IC0+IG1hdGNoIHBhZCB3aXRoXG4gICAgfCBOb19wYWRkaW5nICAgIC0+IGZtdHR5XG4gICAgfCBMaXRfcGFkZGluZyBfIC0+IGZtdHR5XG4gICAgfCBBcmdfcGFkZGluZyBfIC0+IEludF90eSBmbXR0eVxuXG4oKiBBZGQgYW4gSW50X3R5IG5vZGUgaWYgcHJlY2lzaW9uIGlzIHRha2VuIGFzIGFuIGV4dHJhIGFyZ3VtZW50IChleDogXCIlLipmXCIpLiopXG5hbmQgZm10dHlfb2ZfcHJlY2lzaW9uX2ZtdHR5IDogdHlwZSB4IGEgYiBjIGQgZSBmIC5cbiAgICAoeCwgYSkgcHJlY2lzaW9uIC0+IChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSAtPiAoeCwgYiwgYywgZCwgZSwgZikgZm10dHkgPVxuICBmdW4gcHJlYyBmbXR0eSAtPiBtYXRjaCBwcmVjIHdpdGhcbiAgICB8IE5vX3ByZWNpc2lvbiAgICAtPiBmbXR0eVxuICAgIHwgTGl0X3ByZWNpc2lvbiBfIC0+IGZtdHR5XG4gICAgfCBBcmdfcHJlY2lzaW9uICAgLT4gSW50X3R5IGZtdHR5XG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogRm9ybWF0IHR5cGluZyAqKVxuXG4oKiBFeGNlcHRpb24gcmFpc2VkIHdoZW4gYSBmb3JtYXQgZG9lcyBub3QgbWF0Y2ggYSBnaXZlbiBmb3JtYXQgdHlwZS4gKilcbmV4Y2VwdGlvbiBUeXBlX21pc21hdGNoXG5cbigqIFR5cGUgYSBwYWRkaW5nLiAqKVxuKCogVGFrZSBhbiBJbnRfdHkgZnJvbSB0aGUgZm10dHkgaWYgdGhlIGludGVnZXIgc2hvdWxkIGJlIGtlcHQgYXMgYXJndW1lbnQuICopXG4oKiBSYWlzZSBUeXBlX21pc21hdGNoIGluIGNhc2Ugb2YgdHlwZSBtaXNtYXRjaC4gKilcbmxldCB0eXBlX3BhZGRpbmcgOiB0eXBlIGEgYiBjIGQgZSBmIHggeSAuXG4gICAgKHgsIHkpIHBhZGRpbmcgLT4gKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5IC0+XG4gICAgICAoYSwgYiwgYywgZCwgZSwgZikgcGFkZGluZ19mbXR0eV9lYmIgPVxuZnVuIHBhZCBmbXR0eSAtPiBtYXRjaCBwYWQsIGZtdHR5IHdpdGhcbiAgfCBOb19wYWRkaW5nLCBfIC0+IFBhZGRpbmdfZm10dHlfRUJCIChOb19wYWRkaW5nLCBmbXR0eSlcbiAgfCBMaXRfcGFkZGluZyAocGFkdHksIHcpLCBfIC0+IFBhZGRpbmdfZm10dHlfRUJCIChMaXRfcGFkZGluZyAocGFkdHksdyksZm10dHkpXG4gIHwgQXJnX3BhZGRpbmcgcGFkdHksIEludF90eSByZXN0IC0+IFBhZGRpbmdfZm10dHlfRUJCIChBcmdfcGFkZGluZyBwYWR0eSxyZXN0KVxuICB8IF8gLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuXG4oKiBDb252ZXJ0IGEgKHVwYWRkaW5nLCB1cHJlY2lzaW9uKSB0byBhIChwYWRkaW5nLCBwcmVjaXNpb24pLiAqKVxuKCogVGFrZSBvbmUgb3IgdHdvIEludF90eSBmcm9tIHRoZSBmbXR0eSBpZiBuZWVkZWQuICopXG4oKiBSYWlzZSBUeXBlX21pc21hdGNoIGluIGNhc2Ugb2YgdHlwZSBtaXNtYXRjaC4gKilcbmxldCB0eXBlX3BhZHByZWMgOiB0eXBlIGEgYiBjIGQgZSBmIHggeSB6IC5cbiAgKHgsIHkpIHBhZGRpbmcgLT4gKHksIHopIHByZWNpc2lvbiAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10dHkgLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgcGFkcHJlY19mbXR0eV9lYmIgPVxuZnVuIHBhZCBwcmVjIGZtdHR5IC0+IG1hdGNoIHByZWMsIHR5cGVfcGFkZGluZyBwYWQgZm10dHkgd2l0aFxuICB8IE5vX3ByZWNpc2lvbiwgUGFkZGluZ19mbXR0eV9FQkIgKHBhZCwgcmVzdCkgLT5cbiAgICBQYWRwcmVjX2ZtdHR5X0VCQiAocGFkLCBOb19wcmVjaXNpb24sIHJlc3QpXG4gIHwgTGl0X3ByZWNpc2lvbiBwLCBQYWRkaW5nX2ZtdHR5X0VCQiAocGFkLCByZXN0KSAtPlxuICAgIFBhZHByZWNfZm10dHlfRUJCIChwYWQsIExpdF9wcmVjaXNpb24gcCwgcmVzdClcbiAgfCBBcmdfcHJlY2lzaW9uLCBQYWRkaW5nX2ZtdHR5X0VCQiAocGFkLCBJbnRfdHkgcmVzdCkgLT5cbiAgICBQYWRwcmVjX2ZtdHR5X0VCQiAocGFkLCBBcmdfcHJlY2lzaW9uLCByZXN0KVxuICB8IF8sIFBhZGRpbmdfZm10dHlfRUJCIChfLCBfKSAtPiByYWlzZSBUeXBlX21pc21hdGNoXG5cbigqIFR5cGUgYSBmb3JtYXQgYWNjb3JkaW5nIHRvIGFuIGZtdHR5LiAqKVxuKCogSWYgdHlwaW5nIHN1Y2NlZWQsIGdlbmVyYXRlIGEgY29weSBvZiB0aGUgZm9ybWF0IHdpdGggdGhlIHNhbWVcbiAgICB0eXBlIHBhcmFtZXRlcnMgYXMgdGhlIGZtdHR5LiAqKVxuKCogUmFpc2UgW0ZhaWx1cmVdIHdpdGggYW4gZXJyb3IgbWVzc2FnZSBpbiBjYXNlIG9mIHR5cGUgbWlzbWF0Y2guICopXG5sZXQgcmVjIHR5cGVfZm9ybWF0IDpcbiAgdHlwZSBhMSBiMSBjMSBkMSBlMSBmMVxuICAgICAgIGEyIGIyIGMyIGQyIGUyIGYyICAuXG4gICAgIChhMSwgYjEsIGMxLCBkMSwgZTEsIGYxKSBmbXRcbiAgLT4gKGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIpIGZtdHR5XG4gIC0+IChhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXRcbj0gZnVuIGZtdCBmbXR0eSAtPiBtYXRjaCB0eXBlX2Zvcm1hdF9nZW4gZm10IGZtdHR5IHdpdGhcbiAgfCBGbXRfZm10dHlfRUJCIChmbXQnLCBFbmRfb2ZfZm10dHkpIC0+IGZtdCdcbiAgfCBfIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcblxuYW5kIHR5cGVfZm9ybWF0X2dlbiA6XG4gIHR5cGUgYTEgYjEgYzEgZDEgZTEgZjFcbiAgICAgICBhMiBiMiBjMiBkMiBlMiBmMiAgLlxuICAgICAoYTEsIGIxLCBjMSwgZDEsIGUxLCBmMSkgZm10XG4gIC0+IChhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXR0eVxuICAtPiAoYTIsIGIyLCBjMiwgZDIsIGUyLCBmMikgZm10X2ZtdHR5X2ViYlxuPSBmdW4gZm10IGZtdHR5IC0+IG1hdGNoIGZtdCwgZm10dHkgd2l0aFxuICB8IENoYXIgZm10X3Jlc3QsIENoYXJfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChDaGFyIGZtdCcsIGZtdHR5JylcbiAgfCBDYW1sX2NoYXIgZm10X3Jlc3QsIENoYXJfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChDYW1sX2NoYXIgZm10JywgZm10dHknKVxuICB8IFN0cmluZyAocGFkLCBmbXRfcmVzdCksIF8gLT4gKFxuICAgIG1hdGNoIHR5cGVfcGFkZGluZyBwYWQgZm10dHkgd2l0aFxuICAgIHwgUGFkZGluZ19mbXR0eV9FQkIgKHBhZCwgU3RyaW5nX3R5IGZtdHR5X3Jlc3QpIC0+XG4gICAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgICBGbXRfZm10dHlfRUJCIChTdHJpbmcgKHBhZCwgZm10JyksIGZtdHR5JylcbiAgICB8IFBhZGRpbmdfZm10dHlfRUJCIChfLCBfKSAtPiByYWlzZSBUeXBlX21pc21hdGNoXG4gIClcbiAgfCBDYW1sX3N0cmluZyAocGFkLCBmbXRfcmVzdCksIF8gLT4gKFxuICAgIG1hdGNoIHR5cGVfcGFkZGluZyBwYWQgZm10dHkgd2l0aFxuICAgIHwgUGFkZGluZ19mbXR0eV9FQkIgKHBhZCwgU3RyaW5nX3R5IGZtdHR5X3Jlc3QpIC0+XG4gICAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgICBGbXRfZm10dHlfRUJCIChDYW1sX3N0cmluZyAocGFkLCBmbXQnKSwgZm10dHknKVxuICAgIHwgUGFkZGluZ19mbXR0eV9FQkIgKF8sIF8pIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcbiAgKVxuICB8IEludCAoaWNvbnYsIHBhZCwgcHJlYywgZm10X3Jlc3QpLCBfIC0+IChcbiAgICBtYXRjaCB0eXBlX3BhZHByZWMgcGFkIHByZWMgZm10dHkgd2l0aFxuICAgIHwgUGFkcHJlY19mbXR0eV9FQkIgKHBhZCwgcHJlYywgSW50X3R5IGZtdHR5X3Jlc3QpIC0+XG4gICAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgICBGbXRfZm10dHlfRUJCIChJbnQgKGljb252LCBwYWQsIHByZWMsIGZtdCcpLCBmbXR0eScpXG4gICAgfCBQYWRwcmVjX2ZtdHR5X0VCQiAoXywgXywgXykgLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuICApXG4gIHwgSW50MzIgKGljb252LCBwYWQsIHByZWMsIGZtdF9yZXN0KSwgXyAtPiAoXG4gICAgbWF0Y2ggdHlwZV9wYWRwcmVjIHBhZCBwcmVjIGZtdHR5IHdpdGhcbiAgICB8IFBhZHByZWNfZm10dHlfRUJCIChwYWQsIHByZWMsIEludDMyX3R5IGZtdHR5X3Jlc3QpIC0+XG4gICAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgICBGbXRfZm10dHlfRUJCIChJbnQzMiAoaWNvbnYsIHBhZCwgcHJlYywgZm10JyksIGZtdHR5JylcbiAgICB8IFBhZHByZWNfZm10dHlfRUJCIChfLCBfLCBfKSAtPiByYWlzZSBUeXBlX21pc21hdGNoXG4gIClcbiAgfCBOYXRpdmVpbnQgKGljb252LCBwYWQsIHByZWMsIGZtdF9yZXN0KSwgXyAtPiAoXG4gICAgbWF0Y2ggdHlwZV9wYWRwcmVjIHBhZCBwcmVjIGZtdHR5IHdpdGhcbiAgICB8IFBhZHByZWNfZm10dHlfRUJCIChwYWQsIHByZWMsIE5hdGl2ZWludF90eSBmbXR0eV9yZXN0KSAtPlxuICAgICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgICAgRm10X2ZtdHR5X0VCQiAoTmF0aXZlaW50IChpY29udiwgcGFkLCBwcmVjLCBmbXQnKSwgZm10dHknKVxuICAgIHwgUGFkcHJlY19mbXR0eV9FQkIgKF8sIF8sIF8pIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcbiAgKVxuICB8IEludDY0IChpY29udiwgcGFkLCBwcmVjLCBmbXRfcmVzdCksIF8gLT4gKFxuICAgIG1hdGNoIHR5cGVfcGFkcHJlYyBwYWQgcHJlYyBmbXR0eSB3aXRoXG4gICAgfCBQYWRwcmVjX2ZtdHR5X0VCQiAocGFkLCBwcmVjLCBJbnQ2NF90eSBmbXR0eV9yZXN0KSAtPlxuICAgICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgICAgRm10X2ZtdHR5X0VCQiAoSW50NjQgKGljb252LCBwYWQsIHByZWMsIGZtdCcpLCBmbXR0eScpXG4gICAgfCBQYWRwcmVjX2ZtdHR5X0VCQiAoXywgXywgXykgLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuICApXG4gIHwgRmxvYXQgKGZjb252LCBwYWQsIHByZWMsIGZtdF9yZXN0KSwgXyAtPiAoXG4gICAgbWF0Y2ggdHlwZV9wYWRwcmVjIHBhZCBwcmVjIGZtdHR5IHdpdGhcbiAgICB8IFBhZHByZWNfZm10dHlfRUJCIChwYWQsIHByZWMsIEZsb2F0X3R5IGZtdHR5X3Jlc3QpIC0+XG4gICAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgICBGbXRfZm10dHlfRUJCIChGbG9hdCAoZmNvbnYsIHBhZCwgcHJlYywgZm10JyksIGZtdHR5JylcbiAgICB8IFBhZHByZWNfZm10dHlfRUJCIChfLCBfLCBfKSAtPiByYWlzZSBUeXBlX21pc21hdGNoXG4gIClcbiAgfCBCb29sIChwYWQsIGZtdF9yZXN0KSwgXyAtPiAoXG4gICAgbWF0Y2ggdHlwZV9wYWRkaW5nIHBhZCBmbXR0eSB3aXRoXG4gICAgfCBQYWRkaW5nX2ZtdHR5X0VCQiAocGFkLCBCb29sX3R5IGZtdHR5X3Jlc3QpIC0+XG4gICAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgICBGbXRfZm10dHlfRUJCIChCb29sIChwYWQsIGZtdCcpLCBmbXR0eScpXG4gICAgfCBQYWRkaW5nX2ZtdHR5X0VCQiAoXywgXykgLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuICApXG4gIHwgRmx1c2ggZm10X3Jlc3QsIGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoRmx1c2ggZm10JywgZm10dHknKVxuXG4gIHwgU3RyaW5nX2xpdGVyYWwgKHN0ciwgZm10X3Jlc3QpLCBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKFN0cmluZ19saXRlcmFsIChzdHIsIGZtdCcpLCBmbXR0eScpXG4gIHwgQ2hhcl9saXRlcmFsIChjaHIsIGZtdF9yZXN0KSwgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChDaGFyX2xpdGVyYWwgKGNociwgZm10JyksIGZtdHR5JylcblxuICB8IEZvcm1hdF9hcmcgKHBhZF9vcHQsIHN1Yl9mbXR0eSwgZm10X3Jlc3QpLFxuICAgIEZvcm1hdF9hcmdfdHkgKHN1Yl9mbXR0eScsIGZtdHR5X3Jlc3QpIC0+XG4gICAgaWYgRm10dHlfRUJCIHN1Yl9mbXR0eSA8PiBGbXR0eV9FQkIgc3ViX2ZtdHR5JyB0aGVuIHJhaXNlIFR5cGVfbWlzbWF0Y2g7XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKEZvcm1hdF9hcmcgKHBhZF9vcHQsIHN1Yl9mbXR0eScsIGZtdCcpLCBmbXR0eScpXG4gIHwgRm9ybWF0X3N1YnN0IChwYWRfb3B0LCBzdWJfZm10dHksIGZtdF9yZXN0KSxcbiAgICBGb3JtYXRfc3Vic3RfdHkgKHN1Yl9mbXR0eTEsIF9zdWJfZm10dHkyLCBmbXR0eV9yZXN0KSAtPlxuICAgIGlmIEZtdHR5X0VCQiAoZXJhc2VfcmVsIHN1Yl9mbXR0eSkgPD4gRm10dHlfRUJCIChlcmFzZV9yZWwgc3ViX2ZtdHR5MSkgdGhlblxuICAgICAgcmFpc2UgVHlwZV9taXNtYXRjaDtcbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9XG4gICAgICB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgKGVyYXNlX3JlbCBmbXR0eV9yZXN0KVxuICAgIGluXG4gICAgRm10X2ZtdHR5X0VCQiAoRm9ybWF0X3N1YnN0IChwYWRfb3B0LCBzdWJfZm10dHkxLCBmbXQnKSwgZm10dHknKVxuICAoKiBQcmludGYgYW5kIEZvcm1hdCBzcGVjaWZpYyBjb25zdHJ1Y3RvcnM6ICopXG4gIHwgQWxwaGEgZm10X3Jlc3QsIEFscGhhX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoQWxwaGEgZm10JywgZm10dHknKVxuICB8IFRoZXRhIGZtdF9yZXN0LCBUaGV0YV90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKFRoZXRhIGZtdCcsIGZtdHR5JylcblxuICAoKiBGb3JtYXQgc3BlY2lmaWMgY29uc3RydWN0b3JzOiAqKVxuICB8IEZvcm1hdHRpbmdfbGl0IChmb3JtYXR0aW5nX2xpdCwgZm10X3Jlc3QpLCBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKEZvcm1hdHRpbmdfbGl0IChmb3JtYXR0aW5nX2xpdCwgZm10JyksIGZtdHR5JylcbiAgfCBGb3JtYXR0aW5nX2dlbiAoZm9ybWF0dGluZ19nZW4sIGZtdF9yZXN0KSwgZm10dHlfcmVzdCAtPlxuICAgIHR5cGVfZm9ybWF0dGluZ19nZW4gZm9ybWF0dGluZ19nZW4gZm10X3Jlc3QgZm10dHlfcmVzdFxuXG4gICgqIFNjYW5mIHNwZWNpZmljIGNvbnN0cnVjdG9yczogKilcbiAgfCBSZWFkZXIgZm10X3Jlc3QsIFJlYWRlcl90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKFJlYWRlciBmbXQnLCBmbXR0eScpXG4gIHwgU2Nhbl9jaGFyX3NldCAod2lkdGhfb3B0LCBjaGFyX3NldCwgZm10X3Jlc3QpLCBTdHJpbmdfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChTY2FuX2NoYXJfc2V0ICh3aWR0aF9vcHQsIGNoYXJfc2V0LCBmbXQnKSwgZm10dHknKVxuICB8IFNjYW5fZ2V0X2NvdW50ZXIgKGNvdW50ZXIsIGZtdF9yZXN0KSwgSW50X3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoU2Nhbl9nZXRfY291bnRlciAoY291bnRlciwgZm10JyksIGZtdHR5JylcbiAgfCBJZ25vcmVkX3BhcmFtIChpZ24sIHJlc3QpLCBmbXR0eV9yZXN0IC0+XG4gICAgdHlwZV9pZ25vcmVkX3BhcmFtIGlnbiByZXN0IGZtdHR5X3Jlc3RcblxuICB8IEVuZF9vZl9mb3JtYXQsIGZtdHR5X3Jlc3QgLT4gRm10X2ZtdHR5X0VCQiAoRW5kX29mX2Zvcm1hdCwgZm10dHlfcmVzdClcblxuICB8IF8gLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuXG5hbmQgdHlwZV9mb3JtYXR0aW5nX2dlbiA6IHR5cGUgYTEgYTMgYjEgYjMgYzEgYzMgZDEgZDMgZTEgZTIgZTMgZjEgZjIgZjMgLlxuICAgIChhMSwgYjEsIGMxLCBkMSwgZTEsIGYxKSBmb3JtYXR0aW5nX2dlbiAtPlxuICAgIChmMSwgYjEsIGMxLCBlMSwgZTIsIGYyKSBmbXQgLT5cbiAgICAoYTMsIGIzLCBjMywgZDMsIGUzLCBmMykgZm10dHkgLT5cbiAgICAoYTMsIGIzLCBjMywgZDMsIGUzLCBmMykgZm10X2ZtdHR5X2ViYiA9XG5mdW4gZm9ybWF0dGluZ19nZW4gZm10MCBmbXR0eTAgLT4gbWF0Y2ggZm9ybWF0dGluZ19nZW4gd2l0aFxuICB8IE9wZW5fdGFnIChGb3JtYXQgKGZtdDEsIHN0cikpIC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdDIsIGZtdHR5MikgPSB0eXBlX2Zvcm1hdF9nZW4gZm10MSBmbXR0eTAgaW5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10MywgZm10dHkzKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXQwIGZtdHR5MiBpblxuICAgIEZtdF9mbXR0eV9FQkIgKEZvcm1hdHRpbmdfZ2VuIChPcGVuX3RhZyAoRm9ybWF0IChmbXQyLCBzdHIpKSwgZm10MyksIGZtdHR5MylcbiAgfCBPcGVuX2JveCAoRm9ybWF0IChmbXQxLCBzdHIpKSAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQyLCBmbXR0eTIpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdDEgZm10dHkwIGluXG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdDMsIGZtdHR5MykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10MCBmbXR0eTIgaW5cbiAgICBGbXRfZm10dHlfRUJCIChGb3JtYXR0aW5nX2dlbiAoT3Blbl9ib3ggKEZvcm1hdCAoZm10Miwgc3RyKSksIGZtdDMpLCBmbXR0eTMpXG5cbigqIFR5cGUgYW4gSWdub3JlZF9wYXJhbSBub2RlIGFjY29yZGluZyB0byBhbiBmbXR0eS4gKilcbmFuZCB0eXBlX2lnbm9yZWRfcGFyYW0gOiB0eXBlIHAgcSB4IHkgeiB0IHUgdiBhIGIgYyBkIGUgZiAuXG4gICAgKHgsIHksIHosIHQsIHEsIHApIGlnbm9yZWQgLT5cbiAgICAocCwgeSwgeiwgcSwgdSwgdikgZm10IC0+XG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5IC0+XG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdF9mbXR0eV9lYmIgPVxuZnVuIGlnbiBmbXQgZm10dHkgLT4gbWF0Y2ggaWduIHdpdGhcbiAgfCBJZ25vcmVkX2NoYXIgICAgICAgICAgICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX2NhbWxfY2hhciAgICAgICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX3N0cmluZyBfICAgICAgICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX2NhbWxfc3RyaW5nIF8gICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX2ludCBfICAgICAgICAgICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX2ludDMyIF8gICAgICAgICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX25hdGl2ZWludCBfICAgICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX2ludDY0IF8gICAgICAgICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX2Zsb2F0IF8gICAgICAgICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX2Jvb2wgXyAgICAgICAgICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX3NjYW5fY2hhcl9zZXQgXyAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX3NjYW5fZ2V0X2NvdW50ZXIgXyBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX3NjYW5fbmV4dF9jaGFyICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX2Zvcm1hdF9hcmcgKHBhZF9vcHQsIHN1Yl9mbXR0eSkgLT5cbiAgICB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIChJZ25vcmVkX2Zvcm1hdF9hcmcgKHBhZF9vcHQsIHN1Yl9mbXR0eSkpIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfZm9ybWF0X3N1YnN0IChwYWRfb3B0LCBzdWJfZm10dHkpIC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eScsIEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eSBmbXQgZm10dHkgaW5cbiAgICBGbXRfZm10dHlfRUJCIChJZ25vcmVkX3BhcmFtIChJZ25vcmVkX2Zvcm1hdF9zdWJzdCAocGFkX29wdCwgc3ViX2ZtdHR5JyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm10JyksXG4gICAgICAgICAgICAgICAgICAgZm10dHknKVxuICB8IElnbm9yZWRfcmVhZGVyIC0+IChcbiAgICBtYXRjaCBmbXR0eSB3aXRoXG4gICAgfCBJZ25vcmVkX3JlYWRlcl90eSBmbXR0eV9yZXN0IC0+XG4gICAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXQgZm10dHlfcmVzdCBpblxuICAgICAgRm10X2ZtdHR5X0VCQiAoSWdub3JlZF9wYXJhbSAoSWdub3JlZF9yZWFkZXIsIGZtdCcpLCBmbXR0eScpXG4gICAgfCBfIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcbiAgKVxuXG5hbmQgdHlwZV9pZ25vcmVkX3BhcmFtX29uZSA6IHR5cGUgYTEgYTIgYjEgYjIgYzEgYzIgZDEgZDIgZTEgZTIgZjEgZjIgLlxuICAgIChhMiwgYjIsIGMyLCBkMiwgZDIsIGEyKSBpZ25vcmVkIC0+XG4gICAgKGExLCBiMSwgYzEsIGQxLCBlMSwgZjEpIGZtdCAtPlxuICAgIChhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXR0eSAtPlxuICAgIChhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXRfZm10dHlfZWJiXG49IGZ1biBpZ24gZm10IGZtdHR5IC0+XG4gIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdCBmbXR0eSBpblxuICBGbXRfZm10dHlfRUJCIChJZ25vcmVkX3BhcmFtIChpZ24sIGZtdCcpLCBmbXR0eScpXG5cbigqIFR5cGluZyBvZiB0aGUgY29tcGxleCBjYXNlOiBcIiVfKC4uLiUpXCIuICopXG5hbmQgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gOiB0eXBlIHcgeCB5IHogcCBzIHQgdSBhIGIgYyBkIGUgZiAuXG4gICAgKHcsIHgsIHksIHosIHMsIHApIGZtdHR5IC0+XG4gICAgKHAsIHgsIHksIHMsIHQsIHUpIGZtdCAtPlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10dHlfZm10X2ViYiA9XG5mdW4gc3ViX2ZtdHR5IGZtdCBmbXR0eSAtPiBtYXRjaCBzdWJfZm10dHksIGZtdHR5IHdpdGhcbiAgfCBDaGFyX3R5IHN1Yl9mbXR0eV9yZXN0LCBDaGFyX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKENoYXJfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuICB8IFN0cmluZ190eSBzdWJfZm10dHlfcmVzdCwgU3RyaW5nX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKFN0cmluZ190eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG4gIHwgSW50X3R5IHN1Yl9mbXR0eV9yZXN0LCBJbnRfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoSW50X3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcbiAgfCBJbnQzMl90eSBzdWJfZm10dHlfcmVzdCwgSW50MzJfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoSW50MzJfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuICB8IE5hdGl2ZWludF90eSBzdWJfZm10dHlfcmVzdCwgTmF0aXZlaW50X3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKE5hdGl2ZWludF90eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG4gIHwgSW50NjRfdHkgc3ViX2ZtdHR5X3Jlc3QsIEludDY0X3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKEludDY0X3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcbiAgfCBGbG9hdF90eSBzdWJfZm10dHlfcmVzdCwgRmxvYXRfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoRmxvYXRfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuICB8IEJvb2xfdHkgc3ViX2ZtdHR5X3Jlc3QsIEJvb2xfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoQm9vbF90eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG4gIHwgQWxwaGFfdHkgc3ViX2ZtdHR5X3Jlc3QsIEFscGhhX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKEFscGhhX3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcbiAgfCBUaGV0YV90eSBzdWJfZm10dHlfcmVzdCwgVGhldGFfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoVGhldGFfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuICB8IFJlYWRlcl90eSBzdWJfZm10dHlfcmVzdCwgUmVhZGVyX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKFJlYWRlcl90eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgc3ViX2ZtdHR5X3Jlc3QsIElnbm9yZWRfcmVhZGVyX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKElnbm9yZWRfcmVhZGVyX3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcblxuICB8IEZvcm1hdF9hcmdfdHkgKHN1YjJfZm10dHksIHN1Yl9mbXR0eV9yZXN0KSxcbiAgICBGb3JtYXRfYXJnX3R5IChzdWIyX2ZtdHR5JywgZm10dHlfcmVzdCkgLT5cbiAgICBpZiBGbXR0eV9FQkIgc3ViMl9mbXR0eSA8PiBGbXR0eV9FQkIgc3ViMl9mbXR0eScgdGhlbiByYWlzZSBUeXBlX21pc21hdGNoO1xuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoRm9ybWF0X2FyZ190eSAoc3ViMl9mbXR0eScsIHN1Yl9mbXR0eV9yZXN0JyksIGZtdCcpXG4gIHwgRm9ybWF0X3N1YnN0X3R5IChzdWIxX2ZtdHR5LCAgc3ViMl9mbXR0eSwgIHN1Yl9mbXR0eV9yZXN0KSxcbiAgICBGb3JtYXRfc3Vic3RfdHkgKHN1YjFfZm10dHknLCBzdWIyX2ZtdHR5JywgZm10dHlfcmVzdCkgLT5cbiAgICAoKiBUT0RPIGRlZmluZSBGbXR0eV9yZWxfRUJCIHRvIHJlbW92ZSB0aG9zZSBlcmFzZV9yZWwgKilcbiAgICBpZiBGbXR0eV9FQkIgKGVyYXNlX3JlbCBzdWIxX2ZtdHR5KSA8PiBGbXR0eV9FQkIgKGVyYXNlX3JlbCBzdWIxX2ZtdHR5JylcbiAgICB0aGVuIHJhaXNlIFR5cGVfbWlzbWF0Y2g7XG4gICAgaWYgRm10dHlfRUJCIChlcmFzZV9yZWwgc3ViMl9mbXR0eSkgPD4gRm10dHlfRUJCIChlcmFzZV9yZWwgc3ViMl9mbXR0eScpXG4gICAgdGhlbiByYWlzZSBUeXBlX21pc21hdGNoO1xuICAgIGxldCBzdWJfZm10dHknID0gdHJhbnMgKHN5bW0gc3ViMV9mbXR0eScpIHN1YjJfZm10dHknIGluXG4gICAgbGV0IF8sIGYyLCBfLCBmNCA9IGZtdHR5X3JlbF9kZXQgc3ViX2ZtdHR5JyBpblxuICAgIGxldCBSZWZsID0gZjIgUmVmbCBpblxuICAgIGxldCBSZWZsID0gZjQgUmVmbCBpblxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIChlcmFzZV9yZWwgc3ViX2ZtdHR5X3Jlc3QpIGZtdCBmbXR0eV9yZXN0XG4gICAgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChGb3JtYXRfc3Vic3RfdHkgKHN1YjFfZm10dHknLCBzdWIyX2ZtdHR5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bW0gc3ViX2ZtdHR5X3Jlc3QnKSxcbiAgICAgICAgICAgICAgICAgICBmbXQnKVxuICB8IEVuZF9vZl9mbXR0eSwgZm10dHkgLT5cbiAgICBGbXR0eV9mbXRfRUJCIChFbmRfb2ZfZm10dHksIHR5cGVfZm9ybWF0X2dlbiBmbXQgZm10dHkpXG4gIHwgXyAtPiByYWlzZSBUeXBlX21pc21hdGNoXG5cbigqIFRoaXMgaW1wbGVtZW50YXRpb24gb2YgYHJlY2FzdGAgaXMgYSBiaXQgZGlzYXBwb2ludGluZy4gVGhlXG4gICBpbnZhcmlhbnQgcHJvdmlkZWQgYnkgdGhlIHR5cGUgYXJlIHZlcnkgc3Ryb25nOiB0aGUgaW5wdXQgZm9ybWF0J3NcbiAgIHR5cGUgaXMgaW4gcmVsYXRpb24gdG8gdGhlIG91dHB1dCB0eXBlJ3MgYXMgd2l0bmVzc2VkIGJ5IHRoZVxuICAgZm10dHlfcmVsIGFyZ3VtZW50LiBPbmUgd291bGQgYXQgZmlyc3QgZXhwZWN0IHRoaXMgZnVuY3Rpb24gdG8gYmVcbiAgIHRvdGFsLCBhbmQgaW1wbGVtZW50YWJsZSBieSBleGhhdXN0aXZlIHBhdHRlcm4gbWF0Y2hpbmcuIEluc3RlYWQsXG4gICB3ZSByZXVzZSB0aGUgaGlnaGx5IHBhcnRpYWwgYW5kIG11Y2ggbGVzcyB3ZWxsLWRlZmluZWQgZnVuY3Rpb25cbiAgIGB0eXBlX2Zvcm1hdGAgdGhhdCBoYXMgbG9zdCBhbGwga25vd2xlZGdlIG9mIHRoZSBjb3JyZXNwb25kZW5jZVxuICAgYmV0d2VlbiB0aGUgYXJndW1lbnQncyB0eXBlcy5cblxuICAgQmVzaWRlcyB0aGUgZmFjdCB0aGF0IHRoaXMgZnVuY3Rpb24gcmV1c2VzIGEgbG90IG9mIHRoZVxuICAgYHR5cGVfZm9ybWF0YCBsb2dpYyAoZWcuOiBzZWVpbmcgSW50X3R5IGluIHRoZSBmbXR0eSBwYXJhbWV0ZXIgZG9lc1xuICAgbm90IGxldCB5b3UgbWF0Y2ggb24gSW50IG9ubHksIGFzIHlvdSBtYXkgaW4gZmFjdCBoYXZlIEZsb2F0XG4gICAoQXJnX3BhZGRpbmcsIC4uLikgKFwiJS4qZFwiKSBiZWdpbm5pbmcgd2l0aCBhbiBJbnRfdHkpLCBpdCBpcyBhbHNvXG4gICBhIHBhcnRpYWwgZnVuY3Rpb24sIGJlY2F1c2UgdGhlIHR5cGluZyBpbmZvcm1hdGlvbiBpbiBhIGZvcm1hdCBpc1xuICAgbm90IHF1aXRlIGVub3VnaCB0byByZWNvbnN0cnVjdCBpdCB1bmFtYmlndW91c2x5LiBGb3IgZXhhbXBsZSwgdGhlXG4gICBmb3JtYXQgdHlwZXMgb2YgXCIlZCVfclwiIGFuZCBcIiVfciVkXCIgaGF2ZSB0aGUgc2FtZSBmb3JtYXQ2XG4gICBwYXJhbWV0ZXJzLCBidXQgdGhleSBhcmUgbm90IGF0IGFsbCBleGNoYW5nZWFibGUsIGFuZCBwdXR0aW5nIG9uZVxuICAgaW4gcGxhY2Ugb2YgdGhlIG90aGVyIG11c3QgcmVzdWx0IGluIGEgZHluYW1pYyBmYWlsdXJlLlxuXG4gICBHaXZlbiB0aGF0OlxuICAgLSB3ZSdkIGhhdmUgdG8gZHVwbGljYXRlIGEgbG90IG9mIG5vbi10cml2aWFsIHR5cGluZyBsb2dpYyBmcm9tIHR5cGVfZm9ybWF0XG4gICAtIHRoaXMgd291bGRuJ3QgZXZlbiBlbGltaW5hdGUgKGFsbCkgdGhlIGR5bmFtaWMgZmFpbHVyZXNcbiAgIHdlIGRlY2lkZWQgdG8ganVzdCByZXVzZSB0eXBlX2Zvcm1hdCBkaXJlY3RseSBmb3Igbm93LlxuKilcbmxldCByZWNhc3QgOlxuICB0eXBlIGExIGIxIGMxIGQxIGUxIGYxXG4gICAgICAgYTIgYjIgYzIgZDIgZTIgZjJcbiAgLlxuICAgICAoYTEsIGIxLCBjMSwgZDEsIGUxLCBmMSkgZm10XG4gIC0+IChhMSwgYjEsIGMxLCBkMSwgZTEsIGYxLFxuICAgICAgYTIsIGIyLCBjMiwgZDIsIGUyLCBmMikgZm10dHlfcmVsXG4gIC0+IChhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXRcbj0gZnVuIGZtdCBmbXR0eSAtPlxuICB0eXBlX2Zvcm1hdCBmbXQgKGVyYXNlX3JlbCAoc3ltbSBmbXR0eSkpXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIFByaW50aW5nIHRvb2xzICopXG5cbigqIEFkZCBwYWRkaW5nIHNwYWNlcyBhcm91bmQgYSBzdHJpbmcuICopXG5sZXQgZml4X3BhZGRpbmcgcGFkdHkgd2lkdGggc3RyID1cbiAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggc3RyIGluXG4gIGxldCB3aWR0aCwgcGFkdHkgPVxuICAgIGFicyB3aWR0aCxcbiAgICAoKiB3aGlsZSBsaXRlcmFsIHBhZGRpbmcgd2lkdGhzIGFyZSBhbHdheXMgbm9uLW5lZ2F0aXZlLFxuICAgICAgIGR5bmFtaWNhbGx5LXNldCB3aWR0aHMgKEFyZ19wYWRkaW5nLCBlZy4gJSpkKSBtYXkgYmUgbmVnYXRpdmU7XG4gICAgICAgd2UgaW50ZXJwcmV0IHRob3NlIGFzIHNwZWNpZnlpbmcgYSBwYWRkaW5nLXRvLXRoZS1sZWZ0OyB0aGlzXG4gICAgICAgbWVhbnMgdGhhdCAnMCcgbWF5IGdldCBkcm9wcGVkIGV2ZW4gaWYgaXQgd2FzIGV4cGxpY2l0bHkgc2V0LFxuICAgICAgIGJ1dDpcbiAgICAgICAtIHRoaXMgaXMgd2hhdCB0aGUgbGVnYWN5IGltcGxlbWVudGF0aW9uIGRvZXMsIGFuZFxuICAgICAgICAgd2UgcHJlc2VydmUgY29tcGF0aWJpbGl0eSBpZiBwb3NzaWJsZVxuICAgICAgIC0gd2UgY291bGQgb25seSBzaWduYWwgdGhpcyBpc3N1ZSBieSBmYWlsaW5nIGF0IHJ1bnRpbWUsXG4gICAgICAgICB3aGljaCBpcyBub3QgdmVyeSBuaWNlLi4uICopXG4gICAgaWYgd2lkdGggPCAwIHRoZW4gTGVmdCBlbHNlIHBhZHR5IGluXG4gIGlmIHdpZHRoIDw9IGxlbiB0aGVuIHN0ciBlbHNlXG4gICAgbGV0IHJlcyA9IEJ5dGVzLm1ha2Ugd2lkdGggKGlmIHBhZHR5ID0gWmVyb3MgdGhlbiAnMCcgZWxzZSAnICcpIGluXG4gICAgYmVnaW4gbWF0Y2ggcGFkdHkgd2l0aFxuICAgIHwgTGVmdCAgLT4gU3RyaW5nLmJsaXQgc3RyIDAgcmVzIDAgbGVuXG4gICAgfCBSaWdodCAtPiBTdHJpbmcuYmxpdCBzdHIgMCByZXMgKHdpZHRoIC0gbGVuKSBsZW5cbiAgICB8IFplcm9zIHdoZW4gbGVuID4gMCAmJiAoc3RyLlswXSA9ICcrJyB8fCBzdHIuWzBdID0gJy0nIHx8IHN0ci5bMF0gPSAnICcpIC0+XG4gICAgICBCeXRlcy5zZXQgcmVzIDAgc3RyLlswXTtcbiAgICAgIFN0cmluZy5ibGl0IHN0ciAxIHJlcyAod2lkdGggLSBsZW4gKyAxKSAobGVuIC0gMSlcbiAgICB8IFplcm9zIHdoZW4gbGVuID4gMSAmJiBzdHIuWzBdID0gJzAnICYmIChzdHIuWzFdID0gJ3gnIHx8IHN0ci5bMV0gPSAnWCcpIC0+XG4gICAgICBCeXRlcy5zZXQgcmVzIDEgc3RyLlsxXTtcbiAgICAgIFN0cmluZy5ibGl0IHN0ciAyIHJlcyAod2lkdGggLSBsZW4gKyAyKSAobGVuIC0gMilcbiAgICB8IFplcm9zIC0+XG4gICAgICBTdHJpbmcuYmxpdCBzdHIgMCByZXMgKHdpZHRoIC0gbGVuKSBsZW5cbiAgICBlbmQ7XG4gICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyByZXNcblxuKCogQWRkICcwJyBwYWRkaW5nIHRvIGludCwgaW50MzIsIG5hdGl2ZWludCBvciBpbnQ2NCBzdHJpbmcgcmVwcmVzZW50YXRpb24uICopXG5sZXQgZml4X2ludF9wcmVjaXNpb24gcHJlYyBzdHIgPVxuICBsZXQgcHJlYyA9IGFicyBwcmVjIGluXG4gIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHN0ciBpblxuICBtYXRjaCBzdHIuWzBdIHdpdGhcbiAgfCAoJysnIHwgJy0nIHwgJyAnKSBhcyBjIHdoZW4gcHJlYyArIDEgPiBsZW4gLT5cbiAgICBsZXQgcmVzID0gQnl0ZXMubWFrZSAocHJlYyArIDEpICcwJyBpblxuICAgIEJ5dGVzLnNldCByZXMgMCBjO1xuICAgIFN0cmluZy5ibGl0IHN0ciAxIHJlcyAocHJlYyAtIGxlbiArIDIpIChsZW4gLSAxKTtcbiAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHJlc1xuICB8ICcwJyB3aGVuIHByZWMgKyAyID4gbGVuICYmIGxlbiA+IDEgJiYgKHN0ci5bMV0gPSAneCcgfHwgc3RyLlsxXSA9ICdYJykgLT5cbiAgICBsZXQgcmVzID0gQnl0ZXMubWFrZSAocHJlYyArIDIpICcwJyBpblxuICAgIEJ5dGVzLnNldCByZXMgMSBzdHIuWzFdO1xuICAgIFN0cmluZy5ibGl0IHN0ciAyIHJlcyAocHJlYyAtIGxlbiArIDQpIChsZW4gLSAyKTtcbiAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHJlc1xuICB8ICcwJyAuLiAnOScgfCAnYScgLi4gJ2YnIHwgJ0EnIC4uICdGJyB3aGVuIHByZWMgPiBsZW4gLT5cbiAgICBsZXQgcmVzID0gQnl0ZXMubWFrZSBwcmVjICcwJyBpblxuICAgIFN0cmluZy5ibGl0IHN0ciAwIHJlcyAocHJlYyAtIGxlbikgbGVuO1xuICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcmVzXG4gIHwgXyAtPlxuICAgIHN0clxuXG4oKiBFc2NhcGUgYSBzdHJpbmcgYWNjb3JkaW5nIHRvIHRoZSBPQ2FtbCBsZXhpbmcgY29udmVudGlvbi4gKilcbmxldCBzdHJpbmdfdG9fY2FtbF9zdHJpbmcgc3RyID1cbiAgbGV0IHN0ciA9IFN0cmluZy5lc2NhcGVkIHN0ciBpblxuICBsZXQgbCA9IFN0cmluZy5sZW5ndGggc3RyIGluXG4gIGxldCByZXMgPSBCeXRlcy5tYWtlIChsICsgMikgJ1xcXCInIGluXG4gIFN0cmluZy51bnNhZmVfYmxpdCBzdHIgMCByZXMgMSBsO1xuICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHJlc1xuXG4oKiBHZW5lcmF0ZSB0aGUgZm9ybWF0X2ludC9pbnQzMi9uYXRpdmVpbnQvaW50NjQgZmlyc3QgYXJndW1lbnRcbiAgIGZyb20gYW4gaW50X2NvbnYuICopXG5sZXQgZm9ybWF0X29mX2ljb252ID0gZnVuY3Rpb25cbiAgfCBJbnRfZCB8IEludF9DZCAtPiBcIiVkXCIgfCBJbnRfcGQgLT4gXCIlK2RcIiB8IEludF9zZCAtPiBcIiUgZFwiXG4gIHwgSW50X2kgfCBJbnRfQ2kgLT4gXCIlaVwiIHwgSW50X3BpIC0+IFwiJStpXCIgfCBJbnRfc2kgLT4gXCIlIGlcIlxuICB8IEludF94IC0+IFwiJXhcIiB8IEludF9DeCAtPiBcIiUjeFwiXG4gIHwgSW50X1ggLT4gXCIlWFwiIHwgSW50X0NYIC0+IFwiJSNYXCJcbiAgfCBJbnRfbyAtPiBcIiVvXCIgfCBJbnRfQ28gLT4gXCIlI29cIlxuICB8IEludF91IHwgSW50X0N1IC0+IFwiJXVcIlxuXG5sZXQgZm9ybWF0X29mX2ljb252TCA9IGZ1bmN0aW9uXG4gIHwgSW50X2QgfCBJbnRfQ2QgLT4gXCIlTGRcIiB8IEludF9wZCAtPiBcIiUrTGRcIiB8IEludF9zZCAtPiBcIiUgTGRcIlxuICB8IEludF9pIHwgSW50X0NpIC0+IFwiJUxpXCIgfCBJbnRfcGkgLT4gXCIlK0xpXCIgfCBJbnRfc2kgLT4gXCIlIExpXCJcbiAgfCBJbnRfeCAtPiBcIiVMeFwiIHwgSW50X0N4IC0+IFwiJSNMeFwiXG4gIHwgSW50X1ggLT4gXCIlTFhcIiB8IEludF9DWCAtPiBcIiUjTFhcIlxuICB8IEludF9vIC0+IFwiJUxvXCIgfCBJbnRfQ28gLT4gXCIlI0xvXCJcbiAgfCBJbnRfdSB8IEludF9DdSAtPiBcIiVMdVwiXG5cbmxldCBmb3JtYXRfb2ZfaWNvbnZsID0gZnVuY3Rpb25cbiAgfCBJbnRfZCB8IEludF9DZCAtPiBcIiVsZFwiIHwgSW50X3BkIC0+IFwiJStsZFwiIHwgSW50X3NkIC0+IFwiJSBsZFwiXG4gIHwgSW50X2kgfCBJbnRfQ2kgLT4gXCIlbGlcIiB8IEludF9waSAtPiBcIiUrbGlcIiB8IEludF9zaSAtPiBcIiUgbGlcIlxuICB8IEludF94IC0+IFwiJWx4XCIgfCBJbnRfQ3ggLT4gXCIlI2x4XCJcbiAgfCBJbnRfWCAtPiBcIiVsWFwiIHwgSW50X0NYIC0+IFwiJSNsWFwiXG4gIHwgSW50X28gLT4gXCIlbG9cIiB8IEludF9DbyAtPiBcIiUjbG9cIlxuICB8IEludF91IHwgSW50X0N1IC0+IFwiJWx1XCJcblxubGV0IGZvcm1hdF9vZl9pY29udm4gPSBmdW5jdGlvblxuICB8IEludF9kIHwgSW50X0NkIC0+IFwiJW5kXCIgfCBJbnRfcGQgLT4gXCIlK25kXCIgfCBJbnRfc2QgLT4gXCIlIG5kXCJcbiAgfCBJbnRfaSB8IEludF9DaSAtPiBcIiVuaVwiIHwgSW50X3BpIC0+IFwiJStuaVwiIHwgSW50X3NpIC0+IFwiJSBuaVwiXG4gIHwgSW50X3ggLT4gXCIlbnhcIiB8IEludF9DeCAtPiBcIiUjbnhcIlxuICB8IEludF9YIC0+IFwiJW5YXCIgfCBJbnRfQ1ggLT4gXCIlI25YXCJcbiAgfCBJbnRfbyAtPiBcIiVub1wiIHwgSW50X0NvIC0+IFwiJSNub1wiXG4gIHwgSW50X3UgfCBJbnRfQ3UgLT4gXCIlbnVcIlxuXG4oKiBHZW5lcmF0ZSB0aGUgZm9ybWF0X2Zsb2F0IGZpcnN0IGFyZ3VtZW50IGZyb20gYSBmbG9hdF9jb252LiAqKVxubGV0IGZvcm1hdF9vZl9mY29udiBmY29udiBwcmVjID1cbiAgICBsZXQgcHJlYyA9IGFicyBwcmVjIGluXG4gICAgbGV0IHN5bWIgPSBjaGFyX29mX2Zjb252IH5jRjonZycgZmNvbnYgaW5cbiAgICBsZXQgYnVmID0gYnVmZmVyX2NyZWF0ZSAxNiBpblxuICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnO1xuICAgIGJwcmludF9mY29udl9mbGFnIGJ1ZiBmY29udjtcbiAgICBidWZmZXJfYWRkX2NoYXIgYnVmICcuJztcbiAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgKEludC50b19zdHJpbmcgcHJlYyk7XG4gICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiBzeW1iO1xuICAgIGJ1ZmZlcl9jb250ZW50cyBidWZcblxubGV0IHRyYW5zZm9ybV9pbnRfYWx0IGljb252IHMgPVxuICBtYXRjaCBpY29udiB3aXRoXG4gIHwgSW50X0NkIHwgSW50X0NpIHwgSW50X0N1IC0+XG4gICAgbGV0IGRpZ2l0cyA9XG4gICAgICBsZXQgbiA9IHJlZiAwIGluXG4gICAgICBmb3IgaSA9IDAgdG8gU3RyaW5nLmxlbmd0aCBzIC0gMSBkb1xuICAgICAgICBtYXRjaCBTdHJpbmcudW5zYWZlX2dldCBzIGkgd2l0aFxuICAgICAgICB8ICcwJy4uJzknIC0+IGluY3IgblxuICAgICAgICB8IF8gLT4gKClcbiAgICAgIGRvbmU7XG4gICAgICAhblxuICAgIGluXG4gICAgbGV0IGJ1ZiA9IEJ5dGVzLmNyZWF0ZSAoU3RyaW5nLmxlbmd0aCBzICsgKGRpZ2l0cyAtIDEpIC8gMykgaW5cbiAgICBsZXQgcG9zID0gcmVmIDAgaW5cbiAgICBsZXQgcHV0IGMgPSBCeXRlcy5zZXQgYnVmICFwb3MgYzsgaW5jciBwb3MgaW5cbiAgICBsZXQgbGVmdCA9IHJlZiAoKGRpZ2l0cyAtIDEpIG1vZCAzICsgMSkgaW5cbiAgICBmb3IgaSA9IDAgdG8gU3RyaW5nLmxlbmd0aCBzIC0gMSBkb1xuICAgICAgbWF0Y2ggU3RyaW5nLnVuc2FmZV9nZXQgcyBpIHdpdGhcbiAgICAgIHwgJzAnLi4nOScgYXMgYyAtPlxuICAgICAgICAgIGlmICFsZWZ0ID0gMCB0aGVuIChwdXQgJ18nOyBsZWZ0IDo9IDMpOyBkZWNyIGxlZnQ7IHB1dCBjXG4gICAgICB8IGMgLT4gcHV0IGNcbiAgICBkb25lO1xuICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgYnVmXG4gIHwgXyAtPiBzXG5cbigqIENvbnZlcnQgYW4gaW50ZWdlciB0byBhIHN0cmluZyBhY2NvcmRpbmcgdG8gYSBjb252ZXJzaW9uLiAqKVxubGV0IGNvbnZlcnRfaW50IGljb252IG4gPVxuICB0cmFuc2Zvcm1faW50X2FsdCBpY29udiAoZm9ybWF0X2ludCAoZm9ybWF0X29mX2ljb252IGljb252KSBuKVxubGV0IGNvbnZlcnRfaW50MzIgaWNvbnYgbiA9XG4gIHRyYW5zZm9ybV9pbnRfYWx0IGljb252IChmb3JtYXRfaW50MzIgKGZvcm1hdF9vZl9pY29udmwgaWNvbnYpIG4pXG5sZXQgY29udmVydF9uYXRpdmVpbnQgaWNvbnYgbiA9XG4gIHRyYW5zZm9ybV9pbnRfYWx0IGljb252IChmb3JtYXRfbmF0aXZlaW50IChmb3JtYXRfb2ZfaWNvbnZuIGljb252KSBuKVxubGV0IGNvbnZlcnRfaW50NjQgaWNvbnYgbiA9XG4gIHRyYW5zZm9ybV9pbnRfYWx0IGljb252IChmb3JtYXRfaW50NjQgKGZvcm1hdF9vZl9pY29udkwgaWNvbnYpIG4pXG5cbigqIENvbnZlcnQgYSBmbG9hdCB0byBzdHJpbmcuICopXG4oKiBGaXggc3BlY2lhbCBjYXNlIG9mIFwiT0NhbWwgZmxvYXQgZm9ybWF0XCIuICopXG5sZXQgY29udmVydF9mbG9hdCBmY29udiBwcmVjIHggPVxuICBsZXQgaGV4ICgpID1cbiAgICBsZXQgc2lnbiA9XG4gICAgICBtYXRjaCBmc3QgZmNvbnYgd2l0aFxuICAgICAgfCBGbG9hdF9mbGFnX3AgLT4gJysnXG4gICAgICB8IEZsb2F0X2ZsYWdfcyAtPiAnICdcbiAgICAgIHwgXyAtPiAnLScgaW5cbiAgICBoZXhzdHJpbmdfb2ZfZmxvYXQgeCBwcmVjIHNpZ24gaW5cbiAgbGV0IGFkZF9kb3RfaWZfbmVlZGVkIHN0ciA9XG4gICAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggc3RyIGluXG4gICAgbGV0IHJlYyBpc192YWxpZCBpID1cbiAgICAgIGlmIGkgPSBsZW4gdGhlbiBmYWxzZSBlbHNlXG4gICAgICAgIG1hdGNoIHN0ci5baV0gd2l0aFxuICAgICAgICB8ICcuJyB8ICdlJyB8ICdFJyAtPiB0cnVlXG4gICAgICAgIHwgXyAtPiBpc192YWxpZCAoaSArIDEpIGluXG4gICAgaWYgaXNfdmFsaWQgMCB0aGVuIHN0ciBlbHNlIHN0ciBeIFwiLlwiIGluXG4gIGxldCBjYW1sX3NwZWNpYWxfdmFsIHN0ciA9IG1hdGNoIGNsYXNzaWZ5X2Zsb2F0IHggd2l0aFxuICAgIHwgRlBfbm9ybWFsIHwgRlBfc3Vibm9ybWFsIHwgRlBfemVybyAtPiBzdHJcbiAgICB8IEZQX2luZmluaXRlIC0+IGlmIHggPCAwLjAgdGhlbiBcIm5lZ19pbmZpbml0eVwiIGVsc2UgXCJpbmZpbml0eVwiXG4gICAgfCBGUF9uYW4gLT4gXCJuYW5cIiBpblxuICBtYXRjaCBzbmQgZmNvbnYgd2l0aFxuICB8IEZsb2F0X2ggLT4gaGV4ICgpXG4gIHwgRmxvYXRfSCAtPiBTdHJpbmcudXBwZXJjYXNlX2FzY2lpIChoZXggKCkpXG4gIHwgRmxvYXRfQ0YgLT4gY2FtbF9zcGVjaWFsX3ZhbCAoaGV4ICgpKVxuICB8IEZsb2F0X0YgLT5cbiAgICBsZXQgc3RyID0gZm9ybWF0X2Zsb2F0IChmb3JtYXRfb2ZfZmNvbnYgZmNvbnYgcHJlYykgeCBpblxuICAgIGNhbWxfc3BlY2lhbF92YWwgKGFkZF9kb3RfaWZfbmVlZGVkIHN0cilcbiAgfCBGbG9hdF9mIHwgRmxvYXRfZSB8IEZsb2F0X0UgfCBGbG9hdF9nIHwgRmxvYXRfRyAtPlxuICAgIGZvcm1hdF9mbG9hdCAoZm9ybWF0X29mX2Zjb252IGZjb252IHByZWMpIHhcblxuKCogQ29udmVydCBhIGNoYXIgdG8gYSBzdHJpbmcgYWNjb3JkaW5nIHRvIHRoZSBPQ2FtbCBsZXhpY2FsIGNvbnZlbnRpb24uICopXG5sZXQgZm9ybWF0X2NhbWxfY2hhciBjID1cbiAgbGV0IHN0ciA9IENoYXIuZXNjYXBlZCBjIGluXG4gIGxldCBsID0gU3RyaW5nLmxlbmd0aCBzdHIgaW5cbiAgbGV0IHJlcyA9IEJ5dGVzLm1ha2UgKGwgKyAyKSAnXFwnJyBpblxuICBTdHJpbmcudW5zYWZlX2JsaXQgc3RyIDAgcmVzIDEgbDtcbiAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyByZXNcblxuKCogQ29udmVydCBhIGZvcm1hdCB0eXBlIHRvIHN0cmluZyAqKVxubGV0IHN0cmluZ19vZl9mbXR0eSBmbXR0eSA9XG4gIGxldCBidWYgPSBidWZmZXJfY3JlYXRlIDE2IGluXG4gIGJwcmludF9mbXR0eSBidWYgZm10dHk7XG4gIGJ1ZmZlcl9jb250ZW50cyBidWZcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICgqIEdlbmVyaWMgcHJpbnRpbmcgZnVuY3Rpb24gKilcblxuKCogTWFrZSBhIGdlbmVyaWMgcHJpbnRpbmcgZnVuY3Rpb24uICopXG4oKiBVc2VkIHRvIGdlbmVyYXRlIFByaW50ZiBhbmQgRm9ybWF0IHByaW50aW5nIGZ1bmN0aW9ucy4gKilcbigqIFBhcmFtZXRlcnM6XG4gICAgIGs6IGEgY29udGludWF0aW9uIGZpbmFsbHkgYXBwbGllZCB0byB0aGUgb3V0cHV0IHN0cmVhbSBhbmQgdGhlIGFjY3VtdWxhdG9yLlxuICAgICBvOiB0aGUgb3V0cHV0IHN0cmVhbSAoc2VlIGssICVhIGFuZCAldCkuXG4gICAgIGFjYzogcmV2IGxpc3Qgb2YgcHJpbnRpbmcgZW50aXRpZXMgKHN0cmluZywgY2hhciwgZmx1c2gsIGZvcm1hdHRpbmcsIC4uLikuXG4gICAgIGZtdDogdGhlIGZvcm1hdC4gKilcbmxldCByZWMgbWFrZV9wcmludGYgOiB0eXBlIGEgYiBjIGQgZSBmIC5cbiAgICAoKGIsIGMpIGFjYyAtPiBmKSAtPiAoYiwgYykgYWNjIC0+XG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPiBhID1cbmZ1biBrIGFjYyBmbXQgLT4gbWF0Y2ggZm10IHdpdGhcbiAgfCBDaGFyIHJlc3QgLT5cbiAgICBmdW4gYyAtPlxuICAgICAgbGV0IG5ld19hY2MgPSBBY2NfZGF0YV9jaGFyIChhY2MsIGMpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG5ld19hY2MgcmVzdFxuICB8IENhbWxfY2hhciByZXN0IC0+XG4gICAgZnVuIGMgLT5cbiAgICAgIGxldCBuZXdfYWNjID0gQWNjX2RhdGFfc3RyaW5nIChhY2MsIGZvcm1hdF9jYW1sX2NoYXIgYykgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgbmV3X2FjYyByZXN0XG4gIHwgU3RyaW5nIChwYWQsIHJlc3QpIC0+XG4gICAgbWFrZV9wYWRkaW5nIGsgYWNjIHJlc3QgcGFkIChmdW4gc3RyIC0+IHN0cilcbiAgfCBDYW1sX3N0cmluZyAocGFkLCByZXN0KSAtPlxuICAgIG1ha2VfcGFkZGluZyBrIGFjYyByZXN0IHBhZCBzdHJpbmdfdG9fY2FtbF9zdHJpbmdcbiAgfCBJbnQgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbWFrZV9pbnRfcGFkZGluZ19wcmVjaXNpb24gayBhY2MgcmVzdCBwYWQgcHJlYyBjb252ZXJ0X2ludCBpY29udlxuICB8IEludDMyIChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIG1ha2VfaW50X3BhZGRpbmdfcHJlY2lzaW9uIGsgYWNjIHJlc3QgcGFkIHByZWMgY29udmVydF9pbnQzMiBpY29udlxuICB8IE5hdGl2ZWludCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBtYWtlX2ludF9wYWRkaW5nX3ByZWNpc2lvbiBrIGFjYyByZXN0IHBhZCBwcmVjIGNvbnZlcnRfbmF0aXZlaW50IGljb252XG4gIHwgSW50NjQgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbWFrZV9pbnRfcGFkZGluZ19wcmVjaXNpb24gayBhY2MgcmVzdCBwYWQgcHJlYyBjb252ZXJ0X2ludDY0IGljb252XG4gIHwgRmxvYXQgKGZjb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbWFrZV9mbG9hdF9wYWRkaW5nX3ByZWNpc2lvbiBrIGFjYyByZXN0IHBhZCBwcmVjIGZjb252XG4gIHwgQm9vbCAocGFkLCByZXN0KSAtPlxuICAgIG1ha2VfcGFkZGluZyBrIGFjYyByZXN0IHBhZCBzdHJpbmdfb2ZfYm9vbFxuICB8IEFscGhhIHJlc3QgLT5cbiAgICBmdW4gZiB4IC0+IG1ha2VfcHJpbnRmIGsgKEFjY19kZWxheSAoYWNjLCBmdW4gbyAtPiBmIG8geCkpIHJlc3RcbiAgfCBUaGV0YSByZXN0IC0+XG4gICAgZnVuIGYgLT4gbWFrZV9wcmludGYgayAoQWNjX2RlbGF5IChhY2MsIGYpKSByZXN0XG4gIHwgQ3VzdG9tIChhcml0eSwgZiwgcmVzdCkgLT5cbiAgICBtYWtlX2N1c3RvbSBrIGFjYyByZXN0IGFyaXR5IChmICgpKVxuICB8IFJlYWRlciBfIC0+XG4gICAgKCogVGhpcyBjYXNlIGlzIGltcG9zc2libGUsIGJ5IHR5cGluZyBvZiBmb3JtYXRzLiAqKVxuICAgICgqIEluZGVlZCwgc2luY2UgcHJpbnRmIGFuZCBjby4gdGFrZSBhIGZvcm1hdDQgYXMgYXJndW1lbnQsIHRoZSAnZCBhbmQgJ2VcbiAgICAgICB0eXBlIHBhcmFtZXRlcnMgb2YgZm10IGFyZSBvYnZpb3VzbHkgZXF1YWxzLiBUaGUgUmVhZGVyIGlzIHRoZVxuICAgICAgIG9ubHkgY29uc3RydWN0b3Igd2hpY2ggdG91Y2ggJ2QgYW5kICdlIHR5cGUgcGFyYW1ldGVycyBvZiB0aGUgZm9ybWF0XG4gICAgICAgdHlwZSwgaXQgYWRkcyBhbiAoLT4pIHRvIHRoZSAnZCBwYXJhbWV0ZXJzLiBDb25zZXF1ZW50bHksIGEgZm9ybWF0NFxuICAgICAgIGNhbm5vdCBjb250YWluIGEgUmVhZGVyIG5vZGUsIGV4Y2VwdCBpbiB0aGUgc3ViLWZvcm1hdCBhc3NvY2lhdGVkIHRvXG4gICAgICAgYW4gJXsuLi4lfS4gSXQncyBub3QgYSBwcm9ibGVtIGJlY2F1c2UgbWFrZV9wcmludGYgZG8gbm90IGNhbGxcbiAgICAgICBpdHNlbGYgcmVjdXJzaXZlbHkgb24gdGhlIHN1Yi1mb3JtYXQgYXNzb2NpYXRlZCB0byAley4uLiV9LiAqKVxuICAgIGFzc2VydCBmYWxzZVxuICB8IEZsdXNoIHJlc3QgLT5cbiAgICBtYWtlX3ByaW50ZiBrIChBY2NfZmx1c2ggYWNjKSByZXN0XG5cbiAgfCBTdHJpbmdfbGl0ZXJhbCAoc3RyLCByZXN0KSAtPlxuICAgIG1ha2VfcHJpbnRmIGsgKEFjY19zdHJpbmdfbGl0ZXJhbCAoYWNjLCBzdHIpKSByZXN0XG4gIHwgQ2hhcl9saXRlcmFsIChjaHIsIHJlc3QpIC0+XG4gICAgbWFrZV9wcmludGYgayAoQWNjX2NoYXJfbGl0ZXJhbCAoYWNjLCBjaHIpKSByZXN0XG5cbiAgfCBGb3JtYXRfYXJnIChfLCBzdWJfZm10dHksIHJlc3QpIC0+XG4gICAgbGV0IHR5ID0gc3RyaW5nX29mX2ZtdHR5IHN1Yl9mbXR0eSBpblxuICAgIChmdW4gc3RyIC0+XG4gICAgICBpZ25vcmUgc3RyO1xuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHR5KSkgcmVzdClcbiAgfCBGb3JtYXRfc3Vic3QgKF8sIGZtdHR5LCByZXN0KSAtPlxuICAgIGZ1biAoRm9ybWF0IChmbXQsIF8pKSAtPiBtYWtlX3ByaW50ZiBrIGFjY1xuICAgICAgKGNvbmNhdF9mbXQgKHJlY2FzdCBmbXQgZm10dHkpIHJlc3QpXG5cbiAgfCBTY2FuX2NoYXJfc2V0IChfLCBfLCByZXN0KSAtPlxuICAgIGxldCBuZXdfYWNjID0gQWNjX2ludmFsaWRfYXJnIChhY2MsIFwiUHJpbnRmOiBiYWQgY29udmVyc2lvbiAlW1wiKSBpblxuICAgIGZ1biBfIC0+IG1ha2VfcHJpbnRmIGsgbmV3X2FjYyByZXN0XG4gIHwgU2Nhbl9nZXRfY291bnRlciAoXywgcmVzdCkgLT5cbiAgICAoKiBUaGlzIGNhc2Ugc2hvdWxkIGJlIHJlZnVzZWQgZm9yIFByaW50Zi4gKilcbiAgICAoKiBBY2NlcHRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eS4gKilcbiAgICAoKiBJbnRlcnByZXQgJWwsICVuIGFuZCAlTCBhcyAldS4gKilcbiAgICBmdW4gbiAtPlxuICAgICAgbGV0IG5ld19hY2MgPSBBY2NfZGF0YV9zdHJpbmcgKGFjYywgZm9ybWF0X2ludCBcIiV1XCIgbikgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgbmV3X2FjYyByZXN0XG4gIHwgU2Nhbl9uZXh0X2NoYXIgcmVzdCAtPlxuICAgIGZ1biBjIC0+XG4gICAgICBsZXQgbmV3X2FjYyA9IEFjY19kYXRhX2NoYXIgKGFjYywgYykgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgbmV3X2FjYyByZXN0XG4gIHwgSWdub3JlZF9wYXJhbSAoaWduLCByZXN0KSAtPlxuICAgIG1ha2VfaWdub3JlZF9wYXJhbSBrIGFjYyBpZ24gcmVzdFxuXG4gIHwgRm9ybWF0dGluZ19saXQgKGZtdGluZ19saXQsIHJlc3QpIC0+XG4gICAgbWFrZV9wcmludGYgayAoQWNjX2Zvcm1hdHRpbmdfbGl0IChhY2MsIGZtdGluZ19saXQpKSByZXN0XG4gIHwgRm9ybWF0dGluZ19nZW4gKE9wZW5fdGFnIChGb3JtYXQgKGZtdCcsIF8pKSwgcmVzdCkgLT5cbiAgICBsZXQgaycga2FjYyA9XG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZm9ybWF0dGluZ19nZW4gKGFjYywgQWNjX29wZW5fdGFnIGthY2MpKSByZXN0IGluXG4gICAgbWFrZV9wcmludGYgaycgRW5kX29mX2FjYyBmbXQnXG4gIHwgRm9ybWF0dGluZ19nZW4gKE9wZW5fYm94IChGb3JtYXQgKGZtdCcsIF8pKSwgcmVzdCkgLT5cbiAgICBsZXQgaycga2FjYyA9XG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZm9ybWF0dGluZ19nZW4gKGFjYywgQWNjX29wZW5fYm94IGthY2MpKSByZXN0IGluXG4gICAgbWFrZV9wcmludGYgaycgRW5kX29mX2FjYyBmbXQnXG5cbiAgfCBFbmRfb2ZfZm9ybWF0IC0+XG4gICAgayBhY2NcblxuKCogRGVsYXkgdGhlIGVycm9yIChJbnZhbGlkX2FyZ3VtZW50IFwiUHJpbnRmOiBiYWQgY29udmVyc2lvbiAlX1wiKS4gKilcbigqIEdlbmVyYXRlIGZ1bmN0aW9ucyB0byB0YWtlIHJlbWFpbmluZyBhcmd1bWVudHMgKGFmdGVyIHRoZSBcIiVfXCIpLiAqKVxuYW5kIG1ha2VfaWdub3JlZF9wYXJhbSA6IHR5cGUgeCB5IGEgYiBjIGQgZSBmIC5cbiAgICAoKGIsIGMpIGFjYyAtPiBmKSAtPiAoYiwgYykgYWNjIC0+XG4gICAgKGEsIGIsIGMsIGQsIHksIHgpIGlnbm9yZWQgLT5cbiAgICAoeCwgYiwgYywgeSwgZSwgZikgZm10IC0+IGEgPVxuZnVuIGsgYWNjIGlnbiBmbXQgLT4gbWF0Y2ggaWduIHdpdGhcbiAgfCBJZ25vcmVkX2NoYXIgICAgICAgICAgICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG4gIHwgSWdub3JlZF9jYW1sX2NoYXIgICAgICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuICB8IElnbm9yZWRfc3RyaW5nIF8gICAgICAgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcbiAgfCBJZ25vcmVkX2NhbWxfc3RyaW5nIF8gICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG4gIHwgSWdub3JlZF9pbnQgKF8sIF8pICAgICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuICB8IElnbm9yZWRfaW50MzIgKF8sIF8pICAgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcbiAgfCBJZ25vcmVkX25hdGl2ZWludCAoXywgXykgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG4gIHwgSWdub3JlZF9pbnQ2NCAoXywgXykgICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuICB8IElnbm9yZWRfZmxvYXQgKF8sIF8pICAgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcbiAgfCBJZ25vcmVkX2Jvb2wgXyAgICAgICAgICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG4gIHwgSWdub3JlZF9mb3JtYXRfYXJnIF8gICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuICB8IElnbm9yZWRfZm9ybWF0X3N1YnN0IChfLCBmbXR0eSkgLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIGZtdHR5IGZtdFxuICB8IElnbm9yZWRfcmVhZGVyICAgICAgICAgICAgICAgICAgLT4gYXNzZXJ0IGZhbHNlXG4gIHwgSWdub3JlZF9zY2FuX2NoYXJfc2V0IF8gICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuICB8IElnbm9yZWRfc2Nhbl9nZXRfY291bnRlciBfICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcbiAgfCBJZ25vcmVkX3NjYW5fbmV4dF9jaGFyICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG5cblxuKCogU3BlY2lhbCBjYXNlIG9mIHByaW50ZiBcIiVfKFwiLiAqKVxuYW5kIG1ha2VfZnJvbV9mbXR0eSA6IHR5cGUgeCB5IGEgYiBjIGQgZSBmIC5cbiAgICAoKGIsIGMpIGFjYyAtPiBmKSAtPiAoYiwgYykgYWNjIC0+XG4gICAgKGEsIGIsIGMsIGQsIHksIHgpIGZtdHR5IC0+XG4gICAgKHgsIGIsIGMsIHksIGUsIGYpIGZtdCAtPiBhID1cbmZ1biBrIGFjYyBmbXR0eSBmbXQgLT4gbWF0Y2ggZm10dHkgd2l0aFxuICB8IENoYXJfdHkgcmVzdCAgICAgICAgICAgIC0+IGZ1biBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIGFjYyByZXN0IGZtdFxuICB8IFN0cmluZ190eSByZXN0ICAgICAgICAgIC0+IGZ1biBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIGFjYyByZXN0IGZtdFxuICB8IEludF90eSByZXN0ICAgICAgICAgICAgIC0+IGZ1biBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIGFjYyByZXN0IGZtdFxuICB8IEludDMyX3R5IHJlc3QgICAgICAgICAgIC0+IGZ1biBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIGFjYyByZXN0IGZtdFxuICB8IE5hdGl2ZWludF90eSByZXN0ICAgICAgIC0+IGZ1biBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIGFjYyByZXN0IGZtdFxuICB8IEludDY0X3R5IHJlc3QgICAgICAgICAgIC0+IGZ1biBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIGFjYyByZXN0IGZtdFxuICB8IEZsb2F0X3R5IHJlc3QgICAgICAgICAgIC0+IGZ1biBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIGFjYyByZXN0IGZtdFxuICB8IEJvb2xfdHkgcmVzdCAgICAgICAgICAgIC0+IGZ1biBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIGFjYyByZXN0IGZtdFxuICB8IEFscGhhX3R5IHJlc3QgICAgICAgICAgIC0+IGZ1biBfIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIHJlc3QgZm10XG4gIHwgVGhldGFfdHkgcmVzdCAgICAgICAgICAgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIHJlc3QgZm10XG4gIHwgQW55X3R5IHJlc3QgICAgICAgICAgICAgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIHJlc3QgZm10XG4gIHwgUmVhZGVyX3R5IF8gICAgICAgICAgICAgLT4gYXNzZXJ0IGZhbHNlXG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgXyAgICAgLT4gYXNzZXJ0IGZhbHNlXG4gIHwgRm9ybWF0X2FyZ190eSAoXywgcmVzdCkgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIHJlc3QgZm10XG4gIHwgRW5kX29mX2ZtdHR5ICAgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcbiAgfCBGb3JtYXRfc3Vic3RfdHkgKHR5MSwgdHkyLCByZXN0KSAtPlxuICAgIGxldCB0eSA9IHRyYW5zIChzeW1tIHR5MSkgdHkyIGluXG4gICAgZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIChjb25jYXRfZm10dHkgdHkgcmVzdCkgZm10XG5cbigqIEluc2VydCBhbiBBY2NfaW52YWxpZF9hcmcgaW4gdGhlIGFjY3VtdWxhdG9yIGFuZCBjb250aW51ZSB0byBnZW5lcmF0ZVxuICAgY2xvc3VyZXMgdG8gZ2V0IHRoZSByZW1haW5pbmcgYXJndW1lbnRzLiAqKVxuYW5kIG1ha2VfaW52YWxpZF9hcmcgOiB0eXBlIGEgYiBjIGQgZSBmIC5cbiAgICAoKGIsIGMpIGFjYyAtPiBmKSAtPiAoYiwgYykgYWNjIC0+XG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPiBhID1cbmZ1biBrIGFjYyBmbXQgLT5cbiAgbWFrZV9wcmludGYgayAoQWNjX2ludmFsaWRfYXJnIChhY2MsIFwiUHJpbnRmOiBiYWQgY29udmVyc2lvbiAlX1wiKSkgZm10XG5cbigqIEZpeCBwYWRkaW5nLCB0YWtlIGl0IGFzIGFuIGV4dHJhIGludGVnZXIgYXJndW1lbnQgaWYgbmVlZGVkLiAqKVxuYW5kIG1ha2VfcGFkZGluZyA6IHR5cGUgeCB6IGEgYiBjIGQgZSBmIC5cbiAgICAoKGIsIGMpIGFjYyAtPiBmKSAtPiAoYiwgYykgYWNjIC0+XG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPlxuICAgICh4LCB6IC0+IGEpIHBhZGRpbmcgLT4gKHogLT4gc3RyaW5nKSAtPiB4ID1cbiAgZnVuIGsgYWNjIGZtdCBwYWQgdHJhbnMgLT4gbWF0Y2ggcGFkIHdpdGhcbiAgfCBOb19wYWRkaW5nIC0+XG4gICAgZnVuIHggLT5cbiAgICAgIGxldCBuZXdfYWNjID0gQWNjX2RhdGFfc3RyaW5nIChhY2MsIHRyYW5zIHgpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG5ld19hY2MgZm10XG4gIHwgTGl0X3BhZGRpbmcgKHBhZHR5LCB3aWR0aCkgLT5cbiAgICBmdW4geCAtPlxuICAgICAgbGV0IG5ld19hY2MgPSBBY2NfZGF0YV9zdHJpbmcgKGFjYywgZml4X3BhZGRpbmcgcGFkdHkgd2lkdGggKHRyYW5zIHgpKSBpblxuICAgICAgbWFrZV9wcmludGYgayBuZXdfYWNjIGZtdFxuICB8IEFyZ19wYWRkaW5nIHBhZHR5IC0+XG4gICAgZnVuIHcgeCAtPlxuICAgICAgbGV0IG5ld19hY2MgPSBBY2NfZGF0YV9zdHJpbmcgKGFjYywgZml4X3BhZGRpbmcgcGFkdHkgdyAodHJhbnMgeCkpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG5ld19hY2MgZm10XG5cbigqIEZpeCBwYWRkaW5nIGFuZCBwcmVjaXNpb24gZm9yIGludCwgaW50MzIsIG5hdGl2ZWludCBvciBpbnQ2NC4gKilcbigqIFRha2Ugb25lIG9yIHR3byBleHRyYSBpbnRlZ2VyIGFyZ3VtZW50cyBpZiBuZWVkZWQuICopXG5hbmQgbWFrZV9pbnRfcGFkZGluZ19wcmVjaXNpb24gOiB0eXBlIHggeSB6IGEgYiBjIGQgZSBmIC5cbiAgICAoKGIsIGMpIGFjYyAtPiBmKSAtPiAoYiwgYykgYWNjIC0+XG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPlxuICAgICh4LCB5KSBwYWRkaW5nIC0+ICh5LCB6IC0+IGEpIHByZWNpc2lvbiAtPiAoaW50X2NvbnYgLT4geiAtPiBzdHJpbmcpIC0+XG4gICAgaW50X2NvbnYgLT4geCA9XG4gIGZ1biBrIGFjYyBmbXQgcGFkIHByZWMgdHJhbnMgaWNvbnYgLT4gbWF0Y2ggcGFkLCBwcmVjIHdpdGhcbiAgfCBOb19wYWRkaW5nLCBOb19wcmVjaXNpb24gLT5cbiAgICBmdW4geCAtPlxuICAgICAgbGV0IHN0ciA9IHRyYW5zIGljb252IHggaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBOb19wYWRkaW5nLCBMaXRfcHJlY2lzaW9uIHAgLT5cbiAgICBmdW4geCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9pbnRfcHJlY2lzaW9uIHAgKHRyYW5zIGljb252IHgpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgTm9fcGFkZGluZywgQXJnX3ByZWNpc2lvbiAtPlxuICAgIGZ1biBwIHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfaW50X3ByZWNpc2lvbiBwICh0cmFucyBpY29udiB4KSBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IExpdF9wYWRkaW5nIChwYWR0eSwgdyksIE5vX3ByZWNpc2lvbiAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X3BhZGRpbmcgcGFkdHkgdyAodHJhbnMgaWNvbnYgeCkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBMaXRfcGFkZGluZyAocGFkdHksIHcpLCBMaXRfcHJlY2lzaW9uIHAgLT5cbiAgICBmdW4geCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgKGZpeF9pbnRfcHJlY2lzaW9uIHAgKHRyYW5zIGljb252IHgpKSBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IExpdF9wYWRkaW5nIChwYWR0eSwgdyksIEFyZ19wcmVjaXNpb24gLT5cbiAgICBmdW4gcCB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X3BhZGRpbmcgcGFkdHkgdyAoZml4X2ludF9wcmVjaXNpb24gcCAodHJhbnMgaWNvbnYgeCkpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgQXJnX3BhZGRpbmcgcGFkdHksIE5vX3ByZWNpc2lvbiAtPlxuICAgIGZ1biB3IHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfcGFkZGluZyBwYWR0eSB3ICh0cmFucyBpY29udiB4KSBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IEFyZ19wYWRkaW5nIHBhZHR5LCBMaXRfcHJlY2lzaW9uIHAgLT5cbiAgICBmdW4gdyB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X3BhZGRpbmcgcGFkdHkgdyAoZml4X2ludF9wcmVjaXNpb24gcCAodHJhbnMgaWNvbnYgeCkpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgQXJnX3BhZGRpbmcgcGFkdHksIEFyZ19wcmVjaXNpb24gLT5cbiAgICBmdW4gdyBwIHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfcGFkZGluZyBwYWR0eSB3IChmaXhfaW50X3ByZWNpc2lvbiBwICh0cmFucyBpY29udiB4KSkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcblxuKCogQ29udmVydCBhIGZsb2F0LCBmaXggcGFkZGluZyBhbmQgcHJlY2lzaW9uIGlmIG5lZWRlZC4gKilcbigqIFRha2UgdGhlIGZsb2F0IGFyZ3VtZW50IGFuZCBvbmUgb3IgdHdvIGV4dHJhIGludGVnZXIgYXJndW1lbnRzIGlmIG5lZWRlZC4gKilcbmFuZCBtYWtlX2Zsb2F0X3BhZGRpbmdfcHJlY2lzaW9uIDogdHlwZSB4IHkgYSBiIGMgZCBlIGYgLlxuICAgICgoYiwgYykgYWNjIC0+IGYpIC0+IChiLCBjKSBhY2MgLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+XG4gICAgKHgsIHkpIHBhZGRpbmcgLT4gKHksIGZsb2F0IC0+IGEpIHByZWNpc2lvbiAtPiBmbG9hdF9jb252IC0+IHggPVxuICBmdW4gayBhY2MgZm10IHBhZCBwcmVjIGZjb252IC0+IG1hdGNoIHBhZCwgcHJlYyB3aXRoXG4gIHwgTm9fcGFkZGluZywgTm9fcHJlY2lzaW9uIC0+XG4gICAgZnVuIHggLT5cbiAgICAgIGxldCBzdHIgPSBjb252ZXJ0X2Zsb2F0IGZjb252IChkZWZhdWx0X2Zsb2F0X3ByZWNpc2lvbiBmY29udikgeCBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IE5vX3BhZGRpbmcsIExpdF9wcmVjaXNpb24gcCAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBsZXQgc3RyID0gY29udmVydF9mbG9hdCBmY29udiBwIHggaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBOb19wYWRkaW5nLCBBcmdfcHJlY2lzaW9uIC0+XG4gICAgZnVuIHAgeCAtPlxuICAgICAgbGV0IHN0ciA9IGNvbnZlcnRfZmxvYXQgZmNvbnYgcCB4IGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgTGl0X3BhZGRpbmcgKHBhZHR5LCB3KSwgTm9fcHJlY2lzaW9uIC0+XG4gICAgZnVuIHggLT5cbiAgICAgIGxldCBzdHIgPSBjb252ZXJ0X2Zsb2F0IGZjb252IChkZWZhdWx0X2Zsb2F0X3ByZWNpc2lvbiBmY29udikgeCBpblxuICAgICAgbGV0IHN0cicgPSBmaXhfcGFkZGluZyBwYWR0eSB3IHN0ciBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cicpKSBmbXRcbiAgfCBMaXRfcGFkZGluZyAocGFkdHksIHcpLCBMaXRfcHJlY2lzaW9uIHAgLT5cbiAgICBmdW4geCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgKGNvbnZlcnRfZmxvYXQgZmNvbnYgcCB4KSBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IExpdF9wYWRkaW5nIChwYWR0eSwgdyksIEFyZ19wcmVjaXNpb24gLT5cbiAgICBmdW4gcCB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X3BhZGRpbmcgcGFkdHkgdyAoY29udmVydF9mbG9hdCBmY29udiBwIHgpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgQXJnX3BhZGRpbmcgcGFkdHksIE5vX3ByZWNpc2lvbiAtPlxuICAgIGZ1biB3IHggLT5cbiAgICAgIGxldCBzdHIgPSBjb252ZXJ0X2Zsb2F0IGZjb252IChkZWZhdWx0X2Zsb2F0X3ByZWNpc2lvbiBmY29udikgeCBpblxuICAgICAgbGV0IHN0cicgPSBmaXhfcGFkZGluZyBwYWR0eSB3IHN0ciBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cicpKSBmbXRcbiAgfCBBcmdfcGFkZGluZyBwYWR0eSwgTGl0X3ByZWNpc2lvbiBwIC0+XG4gICAgZnVuIHcgeCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgKGNvbnZlcnRfZmxvYXQgZmNvbnYgcCB4KSBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IEFyZ19wYWRkaW5nIHBhZHR5LCBBcmdfcHJlY2lzaW9uIC0+XG4gICAgZnVuIHcgcCB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X3BhZGRpbmcgcGFkdHkgdyAoY29udmVydF9mbG9hdCBmY29udiBwIHgpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG5hbmQgbWFrZV9jdXN0b20gOiB0eXBlIHggeSBhIGIgYyBkIGUgZiAuXG4gICgoYiwgYykgYWNjIC0+IGYpIC0+IChiLCBjKSBhY2MgLT5cbiAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPlxuICAoYSwgeCwgeSkgY3VzdG9tX2FyaXR5IC0+IHggLT4geSA9XG4gIGZ1biBrIGFjYyByZXN0IGFyaXR5IGYgLT4gbWF0Y2ggYXJpdHkgd2l0aFxuICB8IEN1c3RvbV96ZXJvIC0+IG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBmKSkgcmVzdFxuICB8IEN1c3RvbV9zdWNjIGFyaXR5IC0+XG4gICAgZnVuIHggLT5cbiAgICAgIG1ha2VfY3VzdG9tIGsgYWNjIHJlc3QgYXJpdHkgKGYgeClcblxubGV0IGNvbnN0IHggXyA9IHhcblxubGV0IHJlYyBtYWtlX2lwcmludGYgOiB0eXBlIGEgYiBjIGQgZSBmIHN0YXRlLlxuICAoc3RhdGUgLT4gZikgLT4gc3RhdGUgLT4gKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPiBhID1cbiAgZnVuIGsgbyBmbXQgLT4gbWF0Y2ggZm10IHdpdGhcbiAgICB8IENoYXIgcmVzdCAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgQ2FtbF9jaGFyIHJlc3QgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IFN0cmluZyAoTm9fcGFkZGluZywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IFN0cmluZyAoTGl0X3BhZGRpbmcgXywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IFN0cmluZyAoQXJnX3BhZGRpbmcgXywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpKVxuICAgIHwgQ2FtbF9zdHJpbmcgKE5vX3BhZGRpbmcsIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBDYW1sX3N0cmluZyAoTGl0X3BhZGRpbmcgXywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IENhbWxfc3RyaW5nIChBcmdfcGFkZGluZyBfLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAoY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdCkpXG4gICAgfCBJbnQgKF8sIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICAgICAgZm5fb2ZfcGFkZGluZ19wcmVjaXNpb24gayBvIHJlc3QgcGFkIHByZWNcbiAgICB8IEludDMyIChfLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgICAgIGZuX29mX3BhZGRpbmdfcHJlY2lzaW9uIGsgbyByZXN0IHBhZCBwcmVjXG4gICAgfCBOYXRpdmVpbnQgKF8sIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICAgICAgZm5fb2ZfcGFkZGluZ19wcmVjaXNpb24gayBvIHJlc3QgcGFkIHByZWNcbiAgICB8IEludDY0IChfLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgICAgIGZuX29mX3BhZGRpbmdfcHJlY2lzaW9uIGsgbyByZXN0IHBhZCBwcmVjXG4gICAgfCBGbG9hdCAoXywgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgICAgICBmbl9vZl9wYWRkaW5nX3ByZWNpc2lvbiBrIG8gcmVzdCBwYWQgcHJlY1xuICAgIHwgQm9vbCAoTm9fcGFkZGluZywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IEJvb2wgKExpdF9wYWRkaW5nIF8sIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBCb29sIChBcmdfcGFkZGluZyBfLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAoY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdCkpXG4gICAgfCBBbHBoYSByZXN0IC0+XG4gICAgICAgIGNvbnN0IChjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KSlcbiAgICB8IFRoZXRhIHJlc3QgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IEN1c3RvbSAoYXJpdHksIF8sIHJlc3QpIC0+XG4gICAgICAgIGZuX29mX2N1c3RvbV9hcml0eSBrIG8gcmVzdCBhcml0eVxuICAgIHwgUmVhZGVyIF8gLT5cbiAgICAgICAgKCogVGhpcyBjYXNlIGlzIGltcG9zc2libGUsIGJ5IHR5cGluZyBvZiBmb3JtYXRzLiAgU2VlIHRoZVxuICAgICAgICAgICBub3RlIGluIHRoZSBjb3JyZXNwb25kaW5nIGNhc2UgZm9yIG1ha2VfcHJpbnRmLiAqKVxuICAgICAgICBhc3NlcnQgZmFsc2VcbiAgICB8IEZsdXNoIHJlc3QgLT5cbiAgICAgICAgbWFrZV9pcHJpbnRmIGsgbyByZXN0XG4gICAgfCBTdHJpbmdfbGl0ZXJhbCAoXywgcmVzdCkgLT5cbiAgICAgICAgbWFrZV9pcHJpbnRmIGsgbyByZXN0XG4gICAgfCBDaGFyX2xpdGVyYWwgKF8sIHJlc3QpIC0+XG4gICAgICAgIG1ha2VfaXByaW50ZiBrIG8gcmVzdFxuICAgIHwgRm9ybWF0X2FyZyAoXywgXywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IEZvcm1hdF9zdWJzdCAoXywgZm10dHksIHJlc3QpIC0+XG4gICAgICAgIGZ1biAoRm9ybWF0IChmbXQsIF8pKSAtPlxuICAgICAgICAgIG1ha2VfaXByaW50ZiBrIG9cbiAgICAgICAgICAgIChjb25jYXRfZm10IChyZWNhc3QgZm10IGZtdHR5KSByZXN0KVxuICAgIHwgU2Nhbl9jaGFyX3NldCAoXywgXywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IFNjYW5fZ2V0X2NvdW50ZXIgKF8sIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBTY2FuX25leHRfY2hhciByZXN0IC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBJZ25vcmVkX3BhcmFtIChpZ24sIHJlc3QpIC0+XG4gICAgICAgIG1ha2VfaWdub3JlZF9wYXJhbSAoZnVuIF8gLT4gayBvKSAoRW5kX29mX2FjYykgaWduIHJlc3RcbiAgICB8IEZvcm1hdHRpbmdfbGl0IChfLCByZXN0KSAtPlxuICAgICAgICBtYWtlX2lwcmludGYgayBvIHJlc3RcbiAgICB8IEZvcm1hdHRpbmdfZ2VuIChPcGVuX3RhZyAoRm9ybWF0IChmbXQnLCBfKSksIHJlc3QpIC0+XG4gICAgICAgIG1ha2VfaXByaW50ZiAoZnVuIGtvYyAtPiBtYWtlX2lwcmludGYgayBrb2MgcmVzdCkgbyBmbXQnXG4gICAgfCBGb3JtYXR0aW5nX2dlbiAoT3Blbl9ib3ggKEZvcm1hdCAoZm10JywgXykpLCByZXN0KSAtPlxuICAgICAgICBtYWtlX2lwcmludGYgKGZ1biBrb2MgLT4gbWFrZV9pcHJpbnRmIGsga29jIHJlc3QpIG8gZm10J1xuICAgIHwgRW5kX29mX2Zvcm1hdCAtPlxuICAgICAgICBrIG9cbmFuZCBmbl9vZl9wYWRkaW5nX3ByZWNpc2lvbiA6XG4gIHR5cGUgeCB5IHogYSBiIGMgZCBlIGYgc3RhdGUuXG4gIChzdGF0ZSAtPiBmKSAtPiBzdGF0ZSAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+XG4gICh4LCB5KSBwYWRkaW5nIC0+ICh5LCB6IC0+IGEpIHByZWNpc2lvbiAtPiB4ID1cbiAgZnVuIGsgbyBmbXQgcGFkIHByZWMgLT4gbWF0Y2ggcGFkLCBwcmVjIHdpdGhcbiAgICB8IE5vX3BhZGRpbmcgICAsIE5vX3ByZWNpc2lvbiAgICAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyBmbXQpXG4gICAgfCBOb19wYWRkaW5nICAgLCBMaXRfcHJlY2lzaW9uIF8gLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gZm10KVxuICAgIHwgTm9fcGFkZGluZyAgICwgQXJnX3ByZWNpc2lvbiAgIC0+XG4gICAgICAgIGNvbnN0IChjb25zdCAobWFrZV9pcHJpbnRmIGsgbyBmbXQpKVxuICAgIHwgTGl0X3BhZGRpbmcgXywgTm9fcHJlY2lzaW9uICAgIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIGZtdClcbiAgICB8IExpdF9wYWRkaW5nIF8sIExpdF9wcmVjaXNpb24gXyAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyBmbXQpXG4gICAgfCBMaXRfcGFkZGluZyBfLCBBcmdfcHJlY2lzaW9uICAgLT5cbiAgICAgICAgY29uc3QgKGNvbnN0IChtYWtlX2lwcmludGYgayBvIGZtdCkpXG4gICAgfCBBcmdfcGFkZGluZyBfLCBOb19wcmVjaXNpb24gICAgLT5cbiAgICAgICAgY29uc3QgKGNvbnN0IChtYWtlX2lwcmludGYgayBvIGZtdCkpXG4gICAgfCBBcmdfcGFkZGluZyBfLCBMaXRfcHJlY2lzaW9uIF8gLT5cbiAgICAgICAgY29uc3QgKGNvbnN0IChtYWtlX2lwcmludGYgayBvIGZtdCkpXG4gICAgfCBBcmdfcGFkZGluZyBfLCBBcmdfcHJlY2lzaW9uICAgLT5cbiAgICAgICAgY29uc3QgKGNvbnN0IChjb25zdCAobWFrZV9pcHJpbnRmIGsgbyBmbXQpKSlcbmFuZCBmbl9vZl9jdXN0b21fYXJpdHkgOiB0eXBlIHggeSBhIGIgYyBkIGUgZiBzdGF0ZS5cbiAgKHN0YXRlIC0+IGYpIC0+XG4gIHN0YXRlIC0+IChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT4gKGEsIHgsIHkpIGN1c3RvbV9hcml0eSAtPiB5ID1cbiAgZnVuIGsgbyBmbXQgLT4gZnVuY3Rpb25cbiAgICB8IEN1c3RvbV96ZXJvIC0+XG4gICAgICAgIG1ha2VfaXByaW50ZiBrIG8gZm10XG4gICAgfCBDdXN0b21fc3VjYyBhcml0eSAtPlxuICAgICAgICBjb25zdCAoZm5fb2ZfY3VzdG9tX2FyaXR5IGsgbyBmbXQgYXJpdHkpXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICgqIENvbnRpbnVhdGlvbnMgZm9yIG1ha2VfcHJpbnRmICopXG5cbigqIFJlY3Vyc2l2ZWx5IG91dHB1dCBhbiBcImFjY3VtdWxhdG9yXCIgY29udGFpbmluZyBhIHJldmVyc2VkIGxpc3Qgb2ZcbiAgIHByaW50aW5nIGVudGl0aWVzIChzdHJpbmcsIGNoYXIsIGZsdXMsIC4uLikgaW4gYW4gb3V0cHV0X3N0cmVhbS4gKilcbigqIFVzZWQgYXMgYSBjb250aW51YXRpb24gb2YgbWFrZV9wcmludGYuICopXG5sZXQgcmVjIG91dHB1dF9hY2MgbyBhY2MgPSBtYXRjaCBhY2Mgd2l0aFxuICB8IEFjY19mb3JtYXR0aW5nX2xpdCAocCwgZm10aW5nX2xpdCkgLT5cbiAgICBsZXQgcyA9IHN0cmluZ19vZl9mb3JtYXR0aW5nX2xpdCBmbXRpbmdfbGl0IGluXG4gICAgb3V0cHV0X2FjYyBvIHA7IG91dHB1dF9zdHJpbmcgbyBzO1xuICB8IEFjY19mb3JtYXR0aW5nX2dlbiAocCwgQWNjX29wZW5fdGFnIGFjYycpIC0+XG4gICAgb3V0cHV0X2FjYyBvIHA7IG91dHB1dF9zdHJpbmcgbyBcIkB7XCI7IG91dHB1dF9hY2MgbyBhY2MnO1xuICB8IEFjY19mb3JtYXR0aW5nX2dlbiAocCwgQWNjX29wZW5fYm94IGFjYycpIC0+XG4gICAgb3V0cHV0X2FjYyBvIHA7IG91dHB1dF9zdHJpbmcgbyBcIkBbXCI7IG91dHB1dF9hY2MgbyBhY2MnO1xuICB8IEFjY19zdHJpbmdfbGl0ZXJhbCAocCwgcylcbiAgfCBBY2NfZGF0YV9zdHJpbmcgKHAsIHMpICAgLT4gb3V0cHV0X2FjYyBvIHA7IG91dHB1dF9zdHJpbmcgbyBzXG4gIHwgQWNjX2NoYXJfbGl0ZXJhbCAocCwgYylcbiAgfCBBY2NfZGF0YV9jaGFyIChwLCBjKSAgICAgLT4gb3V0cHV0X2FjYyBvIHA7IG91dHB1dF9jaGFyIG8gY1xuICB8IEFjY19kZWxheSAocCwgZikgICAgICAgICAtPiBvdXRwdXRfYWNjIG8gcDsgZiBvXG4gIHwgQWNjX2ZsdXNoIHAgICAgICAgICAgICAgIC0+IG91dHB1dF9hY2MgbyBwOyBmbHVzaCBvXG4gIHwgQWNjX2ludmFsaWRfYXJnIChwLCBtc2cpIC0+IG91dHB1dF9hY2MgbyBwOyBpbnZhbGlkX2FyZyBtc2c7XG4gIHwgRW5kX29mX2FjYyAgICAgICAgICAgICAgIC0+ICgpXG5cbigqIFJlY3Vyc2l2ZWx5IG91dHB1dCBhbiBcImFjY3VtdWxhdG9yXCIgY29udGFpbmluZyBhIHJldmVyc2VkIGxpc3Qgb2ZcbiAgIHByaW50aW5nIGVudGl0aWVzIChzdHJpbmcsIGNoYXIsIGZsdXMsIC4uLikgaW4gYSBidWZmZXIuICopXG4oKiBVc2VkIGFzIGEgY29udGludWF0aW9uIG9mIG1ha2VfcHJpbnRmLiAqKVxubGV0IHJlYyBidWZwdXRfYWNjIGIgYWNjID0gbWF0Y2ggYWNjIHdpdGhcbiAgfCBBY2NfZm9ybWF0dGluZ19saXQgKHAsIGZtdGluZ19saXQpIC0+XG4gICAgbGV0IHMgPSBzdHJpbmdfb2ZfZm9ybWF0dGluZ19saXQgZm10aW5nX2xpdCBpblxuICAgIGJ1ZnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX3N0cmluZyBiIHM7XG4gIHwgQWNjX2Zvcm1hdHRpbmdfZ2VuIChwLCBBY2Nfb3Blbl90YWcgYWNjJykgLT5cbiAgICBidWZwdXRfYWNjIGIgcDsgQnVmZmVyLmFkZF9zdHJpbmcgYiBcIkB7XCI7IGJ1ZnB1dF9hY2MgYiBhY2MnO1xuICB8IEFjY19mb3JtYXR0aW5nX2dlbiAocCwgQWNjX29wZW5fYm94IGFjYycpIC0+XG4gICAgYnVmcHV0X2FjYyBiIHA7IEJ1ZmZlci5hZGRfc3RyaW5nIGIgXCJAW1wiOyBidWZwdXRfYWNjIGIgYWNjJztcbiAgfCBBY2Nfc3RyaW5nX2xpdGVyYWwgKHAsIHMpXG4gIHwgQWNjX2RhdGFfc3RyaW5nIChwLCBzKSAgIC0+IGJ1ZnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX3N0cmluZyBiIHNcbiAgfCBBY2NfY2hhcl9saXRlcmFsIChwLCBjKVxuICB8IEFjY19kYXRhX2NoYXIgKHAsIGMpICAgICAtPiBidWZwdXRfYWNjIGIgcDsgQnVmZmVyLmFkZF9jaGFyIGIgY1xuICB8IEFjY19kZWxheSAocCwgZikgICAgICAgICAtPiBidWZwdXRfYWNjIGIgcDsgZiBiXG4gIHwgQWNjX2ZsdXNoIHAgICAgICAgICAgICAgIC0+IGJ1ZnB1dF9hY2MgYiBwO1xuICB8IEFjY19pbnZhbGlkX2FyZyAocCwgbXNnKSAtPiBidWZwdXRfYWNjIGIgcDsgaW52YWxpZF9hcmcgbXNnO1xuICB8IEVuZF9vZl9hY2MgICAgICAgICAgICAgICAtPiAoKVxuXG4oKiBSZWN1cnNpdmVseSBvdXRwdXQgYW4gXCJhY2N1bXVsYXRvclwiIGNvbnRhaW5pbmcgYSByZXZlcnNlZCBsaXN0IG9mXG4gICBwcmludGluZyBlbnRpdGllcyAoc3RyaW5nLCBjaGFyLCBmbHVzLCAuLi4pIGluIGEgYnVmZmVyLiAqKVxuKCogRGlmZmVyIGZyb20gYnVmcHV0X2FjYyBieSB0aGUgaW50ZXJwcmV0YXRpb24gb2YgJWEgYW5kICV0LiAqKVxuKCogVXNlZCBhcyBhIGNvbnRpbnVhdGlvbiBvZiBtYWtlX3ByaW50Zi4gKilcbmxldCByZWMgc3RycHV0X2FjYyBiIGFjYyA9IG1hdGNoIGFjYyB3aXRoXG4gIHwgQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBmbXRpbmdfbGl0KSAtPlxuICAgIGxldCBzID0gc3RyaW5nX29mX2Zvcm1hdHRpbmdfbGl0IGZtdGluZ19saXQgaW5cbiAgICBzdHJwdXRfYWNjIGIgcDsgQnVmZmVyLmFkZF9zdHJpbmcgYiBzO1xuICB8IEFjY19mb3JtYXR0aW5nX2dlbiAocCwgQWNjX29wZW5fdGFnIGFjYycpIC0+XG4gICAgc3RycHV0X2FjYyBiIHA7IEJ1ZmZlci5hZGRfc3RyaW5nIGIgXCJAe1wiOyBzdHJwdXRfYWNjIGIgYWNjJztcbiAgfCBBY2NfZm9ybWF0dGluZ19nZW4gKHAsIEFjY19vcGVuX2JveCBhY2MnKSAtPlxuICAgIHN0cnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX3N0cmluZyBiIFwiQFtcIjsgc3RycHV0X2FjYyBiIGFjYyc7XG4gIHwgQWNjX3N0cmluZ19saXRlcmFsIChwLCBzKVxuICB8IEFjY19kYXRhX3N0cmluZyAocCwgcykgICAtPiBzdHJwdXRfYWNjIGIgcDsgQnVmZmVyLmFkZF9zdHJpbmcgYiBzXG4gIHwgQWNjX2NoYXJfbGl0ZXJhbCAocCwgYylcbiAgfCBBY2NfZGF0YV9jaGFyIChwLCBjKSAgICAgLT4gc3RycHV0X2FjYyBiIHA7IEJ1ZmZlci5hZGRfY2hhciBiIGNcbiAgfCBBY2NfZGVsYXkgKHAsIGYpICAgICAgICAgLT4gc3RycHV0X2FjYyBiIHA7IEJ1ZmZlci5hZGRfc3RyaW5nIGIgKGYgKCkpXG4gIHwgQWNjX2ZsdXNoIHAgICAgICAgICAgICAgIC0+IHN0cnB1dF9hY2MgYiBwO1xuICB8IEFjY19pbnZhbGlkX2FyZyAocCwgbXNnKSAtPiBzdHJwdXRfYWNjIGIgcDsgaW52YWxpZF9hcmcgbXNnO1xuICB8IEVuZF9vZl9hY2MgICAgICAgICAgICAgICAtPiAoKVxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBFcnJvciBtYW5hZ2VtZW50ICopXG5cbigqIFJhaXNlIFtGYWlsdXJlXSB3aXRoIGEgcHJldHR5LXByaW50ZWQgZXJyb3IgbWVzc2FnZS4gKilcbmxldCBmYWlsd2l0aF9tZXNzYWdlIChGb3JtYXQgKGZtdCwgXykpID1cbiAgbGV0IGJ1ZiA9IEJ1ZmZlci5jcmVhdGUgMjU2IGluXG4gIGxldCBrIGFjYyA9IHN0cnB1dF9hY2MgYnVmIGFjYzsgZmFpbHdpdGggKEJ1ZmZlci5jb250ZW50cyBidWYpIGluXG4gIG1ha2VfcHJpbnRmIGsgRW5kX29mX2FjYyBmbXRcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBGb3JtYXR0aW5nIHRvb2xzICopXG5cbigqIENvbnZlcnQgYSBzdHJpbmcgdG8gYW4gb3BlbiBibG9jayBkZXNjcmlwdGlvbiAoaW5kZW50LCBibG9ja190eXBlKSAqKVxubGV0IG9wZW5fYm94X29mX3N0cmluZyBzdHIgPVxuICBpZiBzdHIgPSBcIlwiIHRoZW4gKDAsIFBwX2JveCkgZWxzZVxuICAgIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHN0ciBpblxuICAgIGxldCBpbnZhbGlkX2JveCAoKSA9IGZhaWx3aXRoX21lc3NhZ2UgXCJpbnZhbGlkIGJveCBkZXNjcmlwdGlvbiAlU1wiIHN0ciBpblxuICAgIGxldCByZWMgcGFyc2Vfc3BhY2VzIGkgPVxuICAgICAgaWYgaSA9IGxlbiB0aGVuIGkgZWxzZVxuICAgICAgICBtYXRjaCBzdHIuW2ldIHdpdGhcbiAgICAgICAgfCAnICcgfCAnXFx0JyAtPiBwYXJzZV9zcGFjZXMgKGkgKyAxKVxuICAgICAgICB8IF8gLT4gaVxuICAgIGFuZCBwYXJzZV9sd29yZCBpIGogPVxuICAgICAgaWYgaiA9IGxlbiB0aGVuIGogZWxzZVxuICAgICAgICBtYXRjaCBzdHIuW2pdIHdpdGhcbiAgICAgICAgfCAnYScgLi4gJ3onIC0+IHBhcnNlX2x3b3JkIGkgKGogKyAxKVxuICAgICAgICB8IF8gLT4galxuICAgIGFuZCBwYXJzZV9pbnQgaSBqID1cbiAgICAgIGlmIGogPSBsZW4gdGhlbiBqIGVsc2VcbiAgICAgICAgbWF0Y2ggc3RyLltqXSB3aXRoXG4gICAgICAgIHwgJzAnIC4uICc5JyB8ICctJyAtPiBwYXJzZV9pbnQgaSAoaiArIDEpXG4gICAgICAgIHwgXyAtPiBqIGluXG4gICAgbGV0IHdzdGFydCA9IHBhcnNlX3NwYWNlcyAwIGluXG4gICAgbGV0IHdlbmQgPSBwYXJzZV9sd29yZCB3c3RhcnQgd3N0YXJ0IGluXG4gICAgbGV0IGJveF9uYW1lID0gU3RyaW5nLnN1YiBzdHIgd3N0YXJ0ICh3ZW5kIC0gd3N0YXJ0KSBpblxuICAgIGxldCBuc3RhcnQgPSBwYXJzZV9zcGFjZXMgd2VuZCBpblxuICAgIGxldCBuZW5kID0gcGFyc2VfaW50IG5zdGFydCBuc3RhcnQgaW5cbiAgICBsZXQgaW5kZW50ID1cbiAgICAgIGlmIG5zdGFydCA9IG5lbmQgdGhlbiAwIGVsc2VcbiAgICAgICAgdHJ5IGludF9vZl9zdHJpbmcgKFN0cmluZy5zdWIgc3RyIG5zdGFydCAobmVuZCAtIG5zdGFydCkpXG4gICAgICAgIHdpdGggRmFpbHVyZSBfIC0+IGludmFsaWRfYm94ICgpIGluXG4gICAgbGV0IGV4cF9lbmQgPSBwYXJzZV9zcGFjZXMgbmVuZCBpblxuICAgIGlmIGV4cF9lbmQgPD4gbGVuIHRoZW4gaW52YWxpZF9ib3ggKCk7XG4gICAgbGV0IGJveF90eXBlID0gbWF0Y2ggYm94X25hbWUgd2l0aFxuICAgICAgfCBcIlwiIHwgXCJiXCIgLT4gUHBfYm94XG4gICAgICB8IFwiaFwiICAgICAgLT4gUHBfaGJveFxuICAgICAgfCBcInZcIiAgICAgIC0+IFBwX3Zib3hcbiAgICAgIHwgXCJodlwiICAgICAtPiBQcF9odmJveFxuICAgICAgfCBcImhvdlwiICAgIC0+IFBwX2hvdmJveFxuICAgICAgfCBfICAgICAgICAtPiBpbnZhbGlkX2JveCAoKSBpblxuICAgIChpbmRlbnQsIGJveF90eXBlKVxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIFBhcnNpbmcgdG9vbHMgKilcblxuKCogQ3JlYXRlIGEgcGFkZGluZ19mbXRfZWJiIGZyb20gYSBwYWRkaW5nIGFuZCBhIGZvcm1hdC4gKilcbigqIENvcHkgdGhlIHBhZGRpbmcgdG8gZGlzam9pbiB0aGUgdHlwZSBwYXJhbWV0ZXJzIG9mIGFyZ3VtZW50IGFuZCByZXN1bHQuICopXG5sZXQgbWFrZV9wYWRkaW5nX2ZtdF9lYmIgOiB0eXBlIHggeSAuXG4gICAgKHgsIHkpIHBhZGRpbmcgLT4gKF8sIF8sIF8sIF8sIF8sIF8pIGZtdCAtPlxuICAgICAgKF8sIF8sIF8sIF8sIF8pIHBhZGRpbmdfZm10X2ViYiA9XG5mdW4gcGFkIGZtdCAtPiBtYXRjaCBwYWQgd2l0aFxuICB8IE5vX3BhZGRpbmcgICAgICAgICAtPiBQYWRkaW5nX2ZtdF9FQkIgKE5vX3BhZGRpbmcsIGZtdClcbiAgfCBMaXRfcGFkZGluZyAocywgdykgLT4gUGFkZGluZ19mbXRfRUJCIChMaXRfcGFkZGluZyAocywgdyksIGZtdClcbiAgfCBBcmdfcGFkZGluZyBzICAgICAgLT4gUGFkZGluZ19mbXRfRUJCIChBcmdfcGFkZGluZyBzLCBmbXQpXG5cbigqIENyZWF0ZSBhIHByZWNpc2lvbl9mbXRfZWJiIGZyb20gYSBwcmVjaXNpb24gYW5kIGEgZm9ybWF0LiAqKVxuKCogQ29weSB0aGUgcHJlY2lzaW9uIHRvIGRpc2pvaW4gdGhlIHR5cGUgcGFyYW1ldGVycyBvZiBhcmd1bWVudCBhbmQgcmVzdWx0LiAqKVxubGV0IG1ha2VfcHJlY2lzaW9uX2ZtdF9lYmIgOiB0eXBlIHggeSAuXG4gICAgKHgsIHkpIHByZWNpc2lvbiAtPiAoXywgXywgXywgXywgXywgXykgZm10IC0+XG4gICAgICAoXywgXywgXywgXywgXykgcHJlY2lzaW9uX2ZtdF9lYmIgPVxuZnVuIHByZWMgZm10IC0+IG1hdGNoIHByZWMgd2l0aFxuICB8IE5vX3ByZWNpc2lvbiAgICAtPiBQcmVjaXNpb25fZm10X0VCQiAoTm9fcHJlY2lzaW9uLCBmbXQpXG4gIHwgTGl0X3ByZWNpc2lvbiBwIC0+IFByZWNpc2lvbl9mbXRfRUJCIChMaXRfcHJlY2lzaW9uIHAsIGZtdClcbiAgfCBBcmdfcHJlY2lzaW9uICAgLT4gUHJlY2lzaW9uX2ZtdF9FQkIgKEFyZ19wcmVjaXNpb24sIGZtdClcblxuKCogQ3JlYXRlIGEgcGFkcHJlY19mbXRfZWJiIGZyb20gYSBwYWRkaW5nLCBhIHByZWNpc2lvbiBhbmQgYSBmb3JtYXQuICopXG4oKiBDb3B5IHRoZSBwYWRkaW5nIGFuZCB0aGUgcHJlY2lzaW9uIHRvIGRpc2pvaW4gdHlwZSBwYXJhbWV0ZXJzIG9mIGFyZ3VtZW50c1xuICAgYW5kIHJlc3VsdC4gKilcbmxldCBtYWtlX3BhZHByZWNfZm10X2ViYiA6IHR5cGUgeCB5IHogdCAuXG4gICAgKHgsIHkpIHBhZGRpbmcgLT4gKHosIHQpIHByZWNpc2lvbiAtPlxuICAgIChfLCBfLCBfLCBfLCBfLCBfKSBmbXQgLT5cbiAgICAoXywgXywgXywgXywgXykgcGFkcHJlY19mbXRfZWJiID1cbmZ1biBwYWQgcHJlYyBmbXQgLT5cbiAgbGV0IFByZWNpc2lvbl9mbXRfRUJCIChwcmVjLCBmbXQnKSA9IG1ha2VfcHJlY2lzaW9uX2ZtdF9lYmIgcHJlYyBmbXQgaW5cbiAgbWF0Y2ggcGFkIHdpdGhcbiAgfCBOb19wYWRkaW5nICAgICAgICAgLT4gUGFkcHJlY19mbXRfRUJCIChOb19wYWRkaW5nLCBwcmVjLCBmbXQnKVxuICB8IExpdF9wYWRkaW5nIChzLCB3KSAtPiBQYWRwcmVjX2ZtdF9FQkIgKExpdF9wYWRkaW5nIChzLCB3KSwgcHJlYywgZm10JylcbiAgfCBBcmdfcGFkZGluZyBzICAgICAgLT4gUGFkcHJlY19mbXRfRUJCIChBcmdfcGFkZGluZyBzLCBwcmVjLCBmbXQnKVxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBGb3JtYXQgcGFyc2luZyAqKVxuXG4oKiBQYXJzZSBhIHN0cmluZyByZXByZXNlbnRpbmcgYSBmb3JtYXQgYW5kIGNyZWF0ZSBhIGZtdF9lYmIuICopXG4oKiBSYWlzZSBbRmFpbHVyZV0gaW4gY2FzZSBvZiBpbnZhbGlkIGZvcm1hdC4gKilcbmxldCBmbXRfZWJiX29mX3N0cmluZyA/bGVnYWN5X2JlaGF2aW9yIHN0ciA9XG4gICgqIFBhcmFtZXRlcnMgbmFtaW5nIGNvbnZlbnRpb246ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbiAgKCogICAtIGxpdF9zdGFydDogc3RhcnQgb2YgdGhlIGxpdGVyYWwgc2VxdWVuY2UuICAgICAgICAgICAgICAgICAgICAqKVxuICAoKiAgIC0gc3RyX2luZDogY3VycmVudCBpbmRleCBpbiB0aGUgc3RyaW5nLiAgICAgICAgICAgICAgICAgICAgICAgICopXG4gICgqICAgLSBlbmRfaW5kOiBlbmQgb2YgdGhlIGN1cnJlbnQgKHN1Yi0pZm9ybWF0LiAgICAgICAgICAgICAgICAgICAgKilcbiAgKCogICAtIHBjdF9pbmQ6IGluZGV4IG9mIHRoZSAnJScgaW4gdGhlIGN1cnJlbnQgbWljcm8tZm9ybWF0LiAgICAgICAqKVxuICAoKiAgIC0gemVybzogIGlzIHRoZSAnMCcgZmxhZyBkZWZpbmVkIGluIHRoZSBjdXJyZW50IG1pY3JvLWZvcm1hdC4gICopXG4gICgqICAgLSBtaW51czogaXMgdGhlICctJyBmbGFnIGRlZmluZWQgaW4gdGhlIGN1cnJlbnQgbWljcm8tZm9ybWF0LiAgKilcbiAgKCogICAtIHBsdXM6ICBpcyB0aGUgJysnIGZsYWcgZGVmaW5lZCBpbiB0aGUgY3VycmVudCBtaWNyby1mb3JtYXQuICAqKVxuICAoKiAgIC0gaGFzaDogIGlzIHRoZSAnIycgZmxhZyBkZWZpbmVkIGluIHRoZSBjdXJyZW50IG1pY3JvLWZvcm1hdC4gICopXG4gICgqICAgLSBzcGFjZTogaXMgdGhlICcgJyBmbGFnIGRlZmluZWQgaW4gdGhlIGN1cnJlbnQgbWljcm8tZm9ybWF0LiAgKilcbiAgKCogICAtIGlnbjogICBpcyB0aGUgJ18nIGZsYWcgZGVmaW5lZCBpbiB0aGUgY3VycmVudCBtaWNyby1mb3JtYXQuICAqKVxuICAoKiAgIC0gcGFkOiBwYWRkaW5nIG9mIHRoZSBjdXJyZW50IG1pY3JvLWZvcm1hdC4gICAgICAgICAgICAgICAgICAgICopXG4gICgqICAgLSBwcmVjOiBwcmVjaXNpb24gb2YgdGhlIGN1cnJlbnQgbWljcm8tZm9ybWF0LiAgICAgICAgICAgICAgICAgKilcbiAgKCogICAtIHN5bWI6IGNoYXIgcmVwcmVzZW50aW5nIHRoZSBjb252ZXJzaW9uICgnYycsICdzJywgJ2QnLCAuLi4pLiAqKVxuICAoKiAgIC0gY2hhcl9zZXQ6IHNldCBvZiBjaGFyYWN0ZXJzIGFzIGJpdG1hcCAoc2VlIHNjYW5mICVbLi4uXSkuICAgICopXG5cbiAgbGV0IGxlZ2FjeV9iZWhhdmlvciA9IG1hdGNoIGxlZ2FjeV9iZWhhdmlvciB3aXRoXG4gICAgfCBTb21lIGZsYWcgLT4gZmxhZ1xuICAgIHwgTm9uZSAtPiB0cnVlXG4gICgqICBXaGVuIHRoaXMgZmxhZyBpcyBlbmFibGVkLCB0aGUgZm9ybWF0IHBhcnNlciB0cmllcyB0byBiZWhhdmUgYXNcbiAgICAgIHRoZSA8NC4wMiBpbXBsZW1lbnRhdGlvbnMsIGluIHBhcnRpY3VsYXIgaXQgaWdub3JlcyBtb3N0IGJlbmluZVxuICAgICAgbm9uc2Vuc2ljYWwgZm9ybWF0LiBXaGVuIHRoZSBmbGFnIGlzIGRpc2FibGVkLCBpdCB3aWxsIHJlamVjdCBhbnlcbiAgICAgIGZvcm1hdCB0aGF0IGlzIG5vdCBhY2NlcHRlZCBieSB0aGUgc3BlY2lmaWNhdGlvbi5cblxuICAgICAgQSB0eXBpY2FsIGV4YW1wbGUgd291bGQgYmUgXCIlKyBkXCI6IHNwZWNpZnlpbmcgYm90aCAnKycgKGlmIHRoZVxuICAgICAgbnVtYmVyIGlzIHBvc2l0aXZlLCBwYWQgd2l0aCBhICcrJyB0byBnZXQgdGhlIHNhbWUgd2lkdGggYXNcbiAgICAgIG5lZ2F0aXZlIG51bWJlcnMpIGFuZCAnICcgKGlmIHRoZSBudW1iZXIgaXMgcG9zaXRpdmUsIHBhZCB3aXRoXG4gICAgICBhIHNwYWNlKSBkb2VzIG5vdCBtYWtlIHNlbnNlLCBidXQgdGhlIGxlZ2FjeSAoPCA0LjAyKVxuICAgICAgaW1wbGVtZW50YXRpb24gd2FzIGhhcHB5IHRvIGp1c3QgaWdub3JlIHRoZSBzcGFjZS5cbiAgKilcbiAgaW5cblxuICAoKiBSYWlzZSBbRmFpbHVyZV0gd2l0aCBhIGZyaWVuZGx5IGVycm9yIG1lc3NhZ2UuICopXG4gIGxldCBpbnZhbGlkX2Zvcm1hdF9tZXNzYWdlIHN0cl9pbmQgbXNnID1cbiAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICBcImludmFsaWQgZm9ybWF0ICVTOiBhdCBjaGFyYWN0ZXIgbnVtYmVyICVkLCAlc1wiXG4gICAgICBzdHIgc3RyX2luZCBtc2dcbiAgaW5cblxuICAoKiBVc2VkIHdoZW4gdGhlIGVuZCBvZiB0aGUgZm9ybWF0IChvciB0aGUgY3VycmVudCBzdWItZm9ybWF0KSB3YXMgZW5jb3VudGVyZWRcbiAgICAgIHVuZXhwZWN0ZWRseS4gKilcbiAgbGV0IHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kID1cbiAgICBpbnZhbGlkX2Zvcm1hdF9tZXNzYWdlIGVuZF9pbmRcbiAgICAgIFwidW5leHBlY3RlZCBlbmQgb2YgZm9ybWF0XCJcbiAgaW5cblxuICAoKiBVc2VkIGZvciAlMGM6IG5vIG90aGVyIHdpZHRocyBhcmUgaW1wbGVtZW50ZWQgKilcbiAgbGV0IGludmFsaWRfbm9ubnVsbF9jaGFyX3dpZHRoIHN0cl9pbmQgPVxuICAgIGludmFsaWRfZm9ybWF0X21lc3NhZ2Ugc3RyX2luZFxuICAgICAgXCJub24temVybyB3aWR0aHMgYXJlIHVuc3VwcG9ydGVkIGZvciAlYyBjb252ZXJzaW9uc1wiXG4gIGluXG4gICgqIFJhaXNlIFtGYWlsdXJlXSB3aXRoIGEgZnJpZW5kbHkgZXJyb3IgbWVzc2FnZSBhYm91dCBhbiBvcHRpb24gZGVwZW5kZW5jeVxuICAgICBwcm9ibGVtLiAqKVxuICBsZXQgaW52YWxpZF9mb3JtYXRfd2l0aG91dCBzdHJfaW5kIGMgcyA9XG4gICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgXCJpbnZhbGlkIGZvcm1hdCAlUzogYXQgY2hhcmFjdGVyIG51bWJlciAlZCwgJyVjJyB3aXRob3V0ICVzXCJcbiAgICAgIHN0ciBzdHJfaW5kIGMgc1xuICBpblxuXG4gICgqIFJhaXNlIFtGYWlsdXJlXSB3aXRoIGEgZnJpZW5kbHkgZXJyb3IgbWVzc2FnZSBhYm91dCBhbiB1bmV4cGVjdGVkXG4gICAgIGNoYXJhY3Rlci4gKilcbiAgbGV0IGV4cGVjdGVkX2NoYXJhY3RlciBzdHJfaW5kIGV4cGVjdGVkIHJlYWQgPVxuICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgXCJpbnZhbGlkIGZvcm1hdCAlUzogYXQgY2hhcmFjdGVyIG51bWJlciAlZCwgJXMgZXhwZWN0ZWQsIHJlYWQgJUNcIlxuICAgICAgc3RyIHN0cl9pbmQgZXhwZWN0ZWQgcmVhZFxuICBpblxuXG4gICgqIFBhcnNlIHRoZSBzdHJpbmcgZnJvbSBiZWdfaW5kIChpbmNsdWRlZCkgdG8gZW5kX2luZCAoZXhjbHVkZWQpLiAqKVxuICBsZXQgcmVjIHBhcnNlIDogdHlwZSBlIGYgLiBpbnQgLT4gaW50IC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIGJlZ19pbmQgZW5kX2luZCAtPiBwYXJzZV9saXRlcmFsIGJlZ19pbmQgYmVnX2luZCBlbmRfaW5kXG5cbiAgKCogUmVhZCBsaXRlcmFsIGNoYXJhY3RlcnMgdXAgdG8gJyUnIG9yICdAJyBzcGVjaWFsIGNoYXJhY3RlcnMuICopXG4gIGFuZCBwYXJzZV9saXRlcmFsIDogdHlwZSBlIGYgLiBpbnQgLT4gaW50IC0+IGludCAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBsaXRfc3RhcnQgc3RyX2luZCBlbmRfaW5kIC0+XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiBhZGRfbGl0ZXJhbCBsaXRfc3RhcnQgc3RyX2luZCBFbmRfb2ZfZm9ybWF0IGVsc2VcbiAgICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgICAgfCAnJScgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZV9mb3JtYXQgc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICAgIGFkZF9saXRlcmFsIGxpdF9zdGFydCBzdHJfaW5kIGZtdF9yZXN0XG4gICAgICB8ICdAJyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlX2FmdGVyX2F0IChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBhZGRfbGl0ZXJhbCBsaXRfc3RhcnQgc3RyX2luZCBmbXRfcmVzdFxuICAgICAgfCBfIC0+XG4gICAgICAgIHBhcnNlX2xpdGVyYWwgbGl0X3N0YXJ0IChzdHJfaW5kICsgMSkgZW5kX2luZFxuXG4gICgqIFBhcnNlIGEgZm9ybWF0IGFmdGVyICclJyAqKVxuICBhbmQgcGFyc2VfZm9ybWF0IDogdHlwZSBlIGYgLiBpbnQgLT4gaW50IC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIHBjdF9pbmQgZW5kX2luZCAtPiBwYXJzZV9pZ24gcGN0X2luZCAocGN0X2luZCArIDEpIGVuZF9pbmRcblxuICBhbmQgcGFyc2VfaWduIDogdHlwZSBlIGYgLiBpbnQgLT4gaW50IC0+IGludCAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCAtPlxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgICB8ICdfJyAtPiBwYXJzZV9mbGFncyBwY3RfaW5kIChzdHJfaW5kKzEpIGVuZF9pbmQgdHJ1ZVxuICAgICAgfCBfIC0+IHBhcnNlX2ZsYWdzIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIGZhbHNlXG5cbiAgYW5kIHBhcnNlX2ZsYWdzIDogdHlwZSBlIGYgLiBpbnQgLT4gaW50IC0+IGludCAtPiBib29sIC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiXG4gID1cbiAgZnVuIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIGlnbiAtPlxuICAgIGxldCB6ZXJvID0gcmVmIGZhbHNlIGFuZCBtaW51cyA9IHJlZiBmYWxzZVxuICAgIGFuZCBwbHVzID0gcmVmIGZhbHNlIGFuZCBzcGFjZSA9IHJlZiBmYWxzZVxuICAgIGFuZCBoYXNoID0gcmVmIGZhbHNlIGluXG4gICAgbGV0IHNldF9mbGFnIHN0cl9pbmQgZmxhZyA9XG4gICAgICAoKiBpbiBsZWdhY3kgbW9kZSwgZHVwbGljYXRlIGZsYWdzIGFyZSBhY2NlcHRlZCAqKVxuICAgICAgaWYgIWZsYWcgJiYgbm90IGxlZ2FjeV9iZWhhdmlvciB0aGVuXG4gICAgICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgICAgICBcImludmFsaWQgZm9ybWF0ICVTOiBhdCBjaGFyYWN0ZXIgbnVtYmVyICVkLCBkdXBsaWNhdGUgZmxhZyAlQ1wiXG4gICAgICAgICAgc3RyIHN0cl9pbmQgc3RyLltzdHJfaW5kXTtcbiAgICAgIGZsYWcgOj0gdHJ1ZTtcbiAgICBpblxuICAgIGxldCByZWMgcmVhZF9mbGFncyBzdHJfaW5kID1cbiAgICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgICBiZWdpbiBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICAgIHwgJzAnIC0+IHNldF9mbGFnIHN0cl9pbmQgemVybzsgIHJlYWRfZmxhZ3MgKHN0cl9pbmQgKyAxKVxuICAgICAgfCAnLScgLT4gc2V0X2ZsYWcgc3RyX2luZCBtaW51czsgcmVhZF9mbGFncyAoc3RyX2luZCArIDEpXG4gICAgICB8ICcrJyAtPiBzZXRfZmxhZyBzdHJfaW5kIHBsdXM7ICByZWFkX2ZsYWdzIChzdHJfaW5kICsgMSlcbiAgICAgIHwgJyMnIC0+IHNldF9mbGFnIHN0cl9pbmQgaGFzaDsgcmVhZF9mbGFncyAoc3RyX2luZCArIDEpXG4gICAgICB8ICcgJyAtPiBzZXRfZmxhZyBzdHJfaW5kIHNwYWNlOyByZWFkX2ZsYWdzIChzdHJfaW5kICsgMSlcbiAgICAgIHwgXyAtPlxuICAgICAgICBwYXJzZV9wYWRkaW5nIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kXG4gICAgICAgICAgIXplcm8gIW1pbnVzICFwbHVzICFoYXNoICFzcGFjZSBpZ25cbiAgICAgIGVuZFxuICAgIGluXG4gICAgcmVhZF9mbGFncyBzdHJfaW5kXG5cbiAgKCogVHJ5IHRvIHJlYWQgYSBkaWdpdGFsIG9yIGEgJyonIHBhZGRpbmcuICopXG4gIGFuZCBwYXJzZV9wYWRkaW5nIDogdHlwZSBlIGYgLlxuICAgICAgaW50IC0+IGludCAtPiBpbnQgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT5cbiAgICAgICAgKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgemVybyBtaW51cyBwbHVzIGhhc2ggc3BhY2UgaWduIC0+XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICBsZXQgcGFkdHkgPSBtYXRjaCB6ZXJvLCBtaW51cyB3aXRoXG4gICAgICB8IGZhbHNlLCBmYWxzZSAtPiBSaWdodFxuICAgICAgfCBmYWxzZSwgdHJ1ZSAgLT4gTGVmdFxuICAgICAgfCAgdHJ1ZSwgZmFsc2UgLT4gWmVyb3NcbiAgICAgIHwgIHRydWUsIHRydWUgIC0+XG4gICAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuIExlZnRcbiAgICAgICAgZWxzZSBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgJy0nIFwiMFwiIGluXG4gICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgfCAnMCcgLi4gJzknIC0+XG4gICAgICBsZXQgbmV3X2luZCwgd2lkdGggPSBwYXJzZV9wb3NpdGl2ZSBzdHJfaW5kIGVuZF9pbmQgMCBpblxuICAgICAgcGFyc2VfYWZ0ZXJfcGFkZGluZyBwY3RfaW5kIG5ld19pbmQgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2UgaWduXG4gICAgICAgIChMaXRfcGFkZGluZyAocGFkdHksIHdpZHRoKSlcbiAgICB8ICcqJyAtPlxuICAgICAgcGFyc2VfYWZ0ZXJfcGFkZGluZyBwY3RfaW5kIChzdHJfaW5kICsgMSkgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2VcbiAgICAgICAgaWduIChBcmdfcGFkZGluZyBwYWR0eSlcbiAgICB8IF8gLT5cbiAgICAgIGJlZ2luIG1hdGNoIHBhZHR5IHdpdGhcbiAgICAgIHwgTGVmdCAgLT5cbiAgICAgICAgaWYgbm90IGxlZ2FjeV9iZWhhdmlvciB0aGVuXG4gICAgICAgICAgaW52YWxpZF9mb3JtYXRfd2l0aG91dCAoc3RyX2luZCAtIDEpICctJyBcInBhZGRpbmdcIjtcbiAgICAgICAgcGFyc2VfYWZ0ZXJfcGFkZGluZyBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2UgaWduXG4gICAgICAgICAgTm9fcGFkZGluZ1xuICAgICAgfCBaZXJvcyAtPlxuICAgICAgICAgKCogYSAnMCcgcGFkZGluZyBpbmRpY2F0aW9uIG5vdCBmb2xsb3dlZCBieSBhbnl0aGluZyBzaG91bGRcbiAgICAgICAgICAgYmUgaW50ZXJwcmV0ZWQgYXMgYSBSaWdodCBwYWRkaW5nIG9mIHdpZHRoIDAuIFRoaXMgaXMgdXNlZFxuICAgICAgICAgICBieSBzY2FubmluZyBjb252ZXJzaW9ucyAlMHMgYW5kICUwYyAqKVxuICAgICAgICBwYXJzZV9hZnRlcl9wYWRkaW5nIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZSBpZ25cbiAgICAgICAgICAoTGl0X3BhZGRpbmcgKFJpZ2h0LCAwKSlcbiAgICAgIHwgUmlnaHQgLT5cbiAgICAgICAgcGFyc2VfYWZ0ZXJfcGFkZGluZyBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2UgaWduXG4gICAgICAgICAgTm9fcGFkZGluZ1xuICAgICAgZW5kXG5cbiAgKCogSXMgcHJlY2lzaW9uIGRlZmluZWQ/ICopXG4gIGFuZCBwYXJzZV9hZnRlcl9wYWRkaW5nIDogdHlwZSB4IGUgZiAuXG4gICAgICBpbnQgLT4gaW50IC0+IGludCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT5cbiAgICAgICAgKHgsIF8pIHBhZGRpbmcgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlIGlnbiBwYWQgLT5cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgIHwgJy4nIC0+XG4gICAgICBwYXJzZV9wcmVjaXNpb24gcGN0X2luZCAoc3RyX2luZCArIDEpIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlIGlnblxuICAgICAgICBwYWRcbiAgICB8IHN5bWIgLT5cbiAgICAgIHBhcnNlX2NvbnZlcnNpb24gcGN0X2luZCAoc3RyX2luZCArIDEpIGVuZF9pbmQgcGx1cyBoYXNoIHNwYWNlIGlnbiBwYWRcbiAgICAgICAgTm9fcHJlY2lzaW9uIHBhZCBzeW1iXG5cbiAgKCogUmVhZCB0aGUgZGlnaXRhbCBvciAnKicgcHJlY2lzaW9uLiAqKVxuICBhbmQgcGFyc2VfcHJlY2lzaW9uIDogdHlwZSB4IGUgZiAuXG4gICAgICBpbnQgLT4gaW50IC0+IGludCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT5cbiAgICAgICAgKHgsIF8pIHBhZGRpbmcgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlIGlnbiBwYWQgLT5cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgIGxldCBwYXJzZV9saXRlcmFsIG1pbnVzIHN0cl9pbmQgPVxuICAgICAgbGV0IG5ld19pbmQsIHByZWMgPSBwYXJzZV9wb3NpdGl2ZSBzdHJfaW5kIGVuZF9pbmQgMCBpblxuICAgICAgcGFyc2VfYWZ0ZXJfcHJlY2lzaW9uIHBjdF9pbmQgbmV3X2luZCBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZSBpZ25cbiAgICAgICAgcGFkIChMaXRfcHJlY2lzaW9uIHByZWMpIGluXG4gICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgfCAnMCcgLi4gJzknIC0+IHBhcnNlX2xpdGVyYWwgbWludXMgc3RyX2luZFxuICAgIHwgKCcrJyB8ICctJykgYXMgc3ltYiB3aGVuIGxlZ2FjeV9iZWhhdmlvciAtPlxuICAgICAgKCogTGVnYWN5IG1vZGUgd291bGQgYWNjZXB0IGFuZCBpZ25vcmUgJysnIG9yICctJyBiZWZvcmUgdGhlXG4gICAgICAgICBpbnRlZ2VyIGRlc2NyaWJpbmcgdGhlIGRlc2lyZWQgcHJlY2lzaW9uOyBub3RlIHRoYXQgdGhpc1xuICAgICAgICAgY2Fubm90IGhhcHBlbiBmb3IgcGFkZGluZyB3aWR0aCwgYXMgJysnIGFuZCAnLScgYWxyZWFkeSBoYXZlXG4gICAgICAgICBhIHNlbWFudGljcyB0aGVyZS5cblxuICAgICAgICAgVGhhdCBzYWlkLCB0aGUgaWRlYSAoc3VwcG9ydGVkIGJ5IHRoaXMgdHdlYWspIHRoYXQgd2lkdGggYW5kXG4gICAgICAgICBwcmVjaXNpb24gbGl0ZXJhbHMgYXJlIFwiaW50ZWdlciBsaXRlcmFsc1wiIGluIHRoZSBPQ2FtbCBzZW5zZSBpc1xuICAgICAgICAgc3RpbGwgYmxhdGFudGx5IHdyb25nLCBhcyAxMjNfNDU2IG9yIDB4RkYgYXJlIHJlamVjdGVkLiAqKVxuICAgICAgcGFyc2VfbGl0ZXJhbCAobWludXMgfHwgc3ltYiA9ICctJykgKHN0cl9pbmQgKyAxKVxuICAgIHwgJyonIC0+XG4gICAgICBwYXJzZV9hZnRlcl9wcmVjaXNpb24gcGN0X2luZCAoc3RyX2luZCArIDEpIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlXG4gICAgICAgIGlnbiBwYWQgQXJnX3ByZWNpc2lvblxuICAgIHwgXyAtPlxuICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW5cbiAgICAgICAgKCogbm90ZSB0aGF0IGxlZ2FjeSBpbXBsZW1lbnRhdGlvbiBkaWQgbm90IGlnbm9yZSAnLicgd2l0aG91dFxuICAgICAgICAgICBhIG51bWJlciAoYXMgaXQgZG9lcyBmb3IgcGFkZGluZyBpbmRpY2F0aW9ucyksIGJ1dFxuICAgICAgICAgICBpbnRlcnByZXRzIGl0IGFzICcuMCcgKilcbiAgICAgICAgcGFyc2VfYWZ0ZXJfcHJlY2lzaW9uIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZSBpZ25cbiAgICAgICAgICBwYWQgKExpdF9wcmVjaXNpb24gMClcbiAgICAgIGVsc2VcbiAgICAgICAgaW52YWxpZF9mb3JtYXRfd2l0aG91dCAoc3RyX2luZCAtIDEpICcuJyBcInByZWNpc2lvblwiXG5cbiAgKCogVHJ5IHRvIHJlYWQgdGhlIGNvbnZlcnNpb24uICopXG4gIGFuZCBwYXJzZV9hZnRlcl9wcmVjaXNpb24gOiB0eXBlIHggeSB6IHQgZSBmIC5cbiAgICAgIGludCAtPiBpbnQgLT4gaW50IC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPlxuICAgICAgICAoeCwgeSkgcGFkZGluZyAtPiAoeiwgdCkgcHJlY2lzaW9uIC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZSBpZ24gcGFkIHByZWMgLT5cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgIGxldCBwYXJzZV9jb252ICh0eXBlIHUpICh0eXBlIHYpIChwYWRwcmVjIDogKHUsIHYpIHBhZGRpbmcpID1cbiAgICAgIHBhcnNlX2NvbnZlcnNpb24gcGN0X2luZCAoc3RyX2luZCArIDEpIGVuZF9pbmQgcGx1cyBoYXNoIHNwYWNlIGlnbiBwYWRcbiAgICAgICAgcHJlYyBwYWRwcmVjIHN0ci5bc3RyX2luZF0gaW5cbiAgICAoKiBpbiBsZWdhY3kgbW9kZSwgc29tZSBmb3JtYXRzICglcyBhbmQgJVMpIGFjY2VwdCBhIHdlaXJkIG1peCBvZlxuICAgICAgIHBhZGRpbmcgYW5kIHByZWNpc2lvbiwgd2hpY2ggaXMgbWVyZ2VkIGFzIGEgc2luZ2xlIHBhZGRpbmdcbiAgICAgICBpbmZvcm1hdGlvbi4gRm9yIGV4YW1wbGUsIGluICUuMTBzIHRoZSBwcmVjaXNpb24gaXMgaW1wbGljaXRseVxuICAgICAgIHVuZGVyc3Rvb2QgYXMgcGFkZGluZyAlMTBzLCBidXQgdGhlIGxlZnQtcGFkZGluZyBjb21wb25lbnQgbWF5XG4gICAgICAgYmUgc3BlY2lmaWVkIGVpdGhlciBhcyBhIGxlZnQgcGFkZGluZyBvciBhIG5lZ2F0aXZlIHByZWNpc2lvbjpcbiAgICAgICAlLS4zcyBhbmQgJS4tM3MgYXJlIGVxdWl2YWxlbnQgdG8gJS0zcyAqKVxuICAgIG1hdGNoIHBhZCB3aXRoXG4gICAgfCBOb19wYWRkaW5nIC0+IChcbiAgICAgIG1hdGNoIG1pbnVzLCBwcmVjIHdpdGhcbiAgICAgICAgfCBfLCBOb19wcmVjaXNpb24gLT4gcGFyc2VfY29udiBOb19wYWRkaW5nXG4gICAgICAgIHwgZmFsc2UsIExpdF9wcmVjaXNpb24gbiAtPiBwYXJzZV9jb252IChMaXRfcGFkZGluZyAoUmlnaHQsIG4pKVxuICAgICAgICB8IHRydWUsIExpdF9wcmVjaXNpb24gbiAtPiBwYXJzZV9jb252IChMaXRfcGFkZGluZyAoTGVmdCwgbikpXG4gICAgICAgIHwgZmFsc2UsIEFyZ19wcmVjaXNpb24gLT4gcGFyc2VfY29udiAoQXJnX3BhZGRpbmcgUmlnaHQpXG4gICAgICAgIHwgdHJ1ZSwgQXJnX3ByZWNpc2lvbiAtPiBwYXJzZV9jb252IChBcmdfcGFkZGluZyBMZWZ0KVxuICAgIClcbiAgICB8IHBhZCAtPiBwYXJzZV9jb252IHBhZFxuXG4gICgqIENhc2UgYW5hbHlzaXMgb24gY29udmVyc2lvbi4gKilcbiAgYW5kIHBhcnNlX2NvbnZlcnNpb24gOiB0eXBlIHggeSB6IHQgdSB2IGUgZiAuXG4gICAgICBpbnQgLT4gaW50IC0+IGludCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+ICh4LCB5KSBwYWRkaW5nIC0+XG4gICAgICAgICh6LCB0KSBwcmVjaXNpb24gLT4gKHUsIHYpIHBhZGRpbmcgLT4gY2hhciAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCBwbHVzIGhhc2ggc3BhY2UgaWduIHBhZCBwcmVjIHBhZHByZWMgc3ltYiAtPlxuICAgICgqIEZsYWdzIHVzZWQgdG8gY2hlY2sgb3B0aW9uIHVzYWdlcy9jb21wYXRpYmlsaXRpZXMuICopXG4gICAgbGV0IHBsdXNfdXNlZCAgPSByZWYgZmFsc2UgYW5kIGhhc2hfdXNlZCA9IHJlZiBmYWxzZVxuICAgIGFuZCBzcGFjZV91c2VkID0gcmVmIGZhbHNlIGFuZCBpZ25fdXNlZCAgID0gcmVmIGZhbHNlXG4gICAgYW5kIHBhZF91c2VkICAgPSByZWYgZmFsc2UgYW5kIHByZWNfdXNlZCAgPSByZWYgZmFsc2UgaW5cblxuICAgICgqIEFjY2VzcyB0byBvcHRpb25zLCB1cGRhdGUgZmxhZ3MuICopXG4gICAgbGV0IGdldF9wbHVzICAgICgpID0gcGx1c191c2VkICA6PSB0cnVlOyBwbHVzXG4gICAgYW5kIGdldF9oYXNoICAgKCkgPSBoYXNoX3VzZWQgOj0gdHJ1ZTsgaGFzaFxuICAgIGFuZCBnZXRfc3BhY2UgICAoKSA9IHNwYWNlX3VzZWQgOj0gdHJ1ZTsgc3BhY2VcbiAgICBhbmQgZ2V0X2lnbiAgICAgKCkgPSBpZ25fdXNlZCAgIDo9IHRydWU7IGlnblxuICAgIGFuZCBnZXRfcGFkICAgICAoKSA9IHBhZF91c2VkICAgOj0gdHJ1ZTsgcGFkXG4gICAgYW5kIGdldF9wcmVjICAgICgpID0gcHJlY191c2VkICA6PSB0cnVlOyBwcmVjXG4gICAgYW5kIGdldF9wYWRwcmVjICgpID0gcGFkX3VzZWQgICA6PSB0cnVlOyBwYWRwcmVjIGluXG5cbiAgICBsZXQgZ2V0X2ludF9wYWQgKCkgOiAoeCx5KSBwYWRkaW5nID1cbiAgICAgICgqICU1LjNkIGlzIGFjY2VwdGVkIGFuZCBtZWFuaW5nZnVsOiBwYWQgdG8gbGVuZ3RoIDUgd2l0aFxuICAgICAgICAgc3BhY2VzLCBidXQgZmlyc3QgcGFkIHdpdGggemVyb3MgdXB0byBsZW5ndGggMyAoMC1wYWRkaW5nXG4gICAgICAgICBpcyB0aGUgaW50ZXJwcmV0YXRpb24gb2YgXCJwcmVjaXNpb25cIiBmb3IgaW50ZWdlciBmb3JtYXRzKS5cblxuICAgICAgICAgJTA1LjNkIGlzIHJlZHVuZGFudDogcGFkIHRvIGxlbmd0aCA1ICp3aXRoIHplcm9zKiwgYnV0XG4gICAgICAgICBmaXJzdCBwYWQgd2l0aCB6ZXJvcy4uLiBUbyBhZGQgaW5zdWx0IHRvIHRoZSBpbmp1cnksIHRoZVxuICAgICAgICAgbGVnYWN5IGltcGxlbWVudGF0aW9uIGlnbm9yZXMgdGhlIDAtcGFkZGluZyBpbmRpY2F0aW9uIGFuZFxuICAgICAgICAgZG9lcyB0aGUgNSBwYWRkaW5nIHdpdGggc3BhY2VzIGluc3RlYWQuIFdlIHJldXNlIHRoaXNcbiAgICAgICAgIGludGVycHJldGF0aW9uIGZvciBjb21wYXRpYmlsaXR5LCBidXQgc3RhdGljYWxseSByZWplY3QgdGhpc1xuICAgICAgICAgZm9ybWF0IHdoZW4gdGhlIGxlZ2FjeSBtb2RlIGlzIGRpc2FibGVkLCB0byBwcm90ZWN0IHN0cmljdFxuICAgICAgICAgdXNlcnMgZnJvbSB0aGlzIGNvcm5lciBjYXNlLiAqKVxuICAgICAgIG1hdGNoIGdldF9wYWQgKCksIGdldF9wcmVjICgpIHdpdGhcbiAgICAgICAgIHwgcGFkLCBOb19wcmVjaXNpb24gLT4gcGFkXG4gICAgICAgICB8IE5vX3BhZGRpbmcsIF8gICAgIC0+IE5vX3BhZGRpbmdcbiAgICAgICAgIHwgTGl0X3BhZGRpbmcgKFplcm9zLCBuKSwgXyAtPlxuICAgICAgICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiBMaXRfcGFkZGluZyAoUmlnaHQsIG4pXG4gICAgICAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kICcwJyBcInByZWNpc2lvblwiXG4gICAgICAgICB8IEFyZ19wYWRkaW5nIFplcm9zLCBfIC0+XG4gICAgICAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuIEFyZ19wYWRkaW5nIFJpZ2h0XG4gICAgICAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kICcwJyBcInByZWNpc2lvblwiXG4gICAgICAgICB8IExpdF9wYWRkaW5nIF8gYXMgcGFkLCBfIC0+IHBhZFxuICAgICAgICAgfCBBcmdfcGFkZGluZyBfIGFzIHBhZCwgXyAtPiBwYWQgaW5cblxuICAgICgqIENoZWNrIHRoYXQgcGFkdHkgPD4gWmVyb3MuICopXG4gICAgbGV0IGNoZWNrX25vXzAgc3ltYiAodHlwZSBhIGIpIChwYWQgOiAoYSwgYikgcGFkZGluZykgOiAoYSxiKSBwYWRkaW5nID1cbiAgICAgIG1hdGNoIHBhZCB3aXRoXG4gICAgICB8IE5vX3BhZGRpbmcgLT4gcGFkXG4gICAgICB8IExpdF9wYWRkaW5nICgoTGVmdCB8IFJpZ2h0KSwgXykgLT4gcGFkXG4gICAgICB8IEFyZ19wYWRkaW5nIChMZWZ0IHwgUmlnaHQpIC0+IHBhZFxuICAgICAgfCBMaXRfcGFkZGluZyAoWmVyb3MsIHdpZHRoKSAtPlxuICAgICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiBMaXRfcGFkZGluZyAoUmlnaHQsIHdpZHRoKVxuICAgICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiMFwiXG4gICAgICB8IEFyZ19wYWRkaW5nIFplcm9zIC0+XG4gICAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuIEFyZ19wYWRkaW5nIFJpZ2h0XG4gICAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIHN5bWIgXCIwXCJcbiAgICBpblxuXG4gICAgKCogR2V0IHBhZGRpbmcgYXMgYSBwYWRfb3B0aW9uIChzZWUgXCIlX1wiLCBcIiV7XCIsIFwiJShcIiBhbmQgXCIlW1wiKS5cbiAgICAgICAobm8gbmVlZCBmb3IgbGVnYWN5IG1vZGUgdHdlYWtpbmcsIHRob3NlIHdlcmUgcmVqZWN0ZWQgYnkgdGhlXG4gICAgICAgbGVnYWN5IHBhcnNlciBhcyB3ZWxsKSAqKVxuICAgIGxldCBvcHRfb2ZfcGFkIGMgKHR5cGUgYSkgKHR5cGUgYikgKHBhZCA6IChhLCBiKSBwYWRkaW5nKSA9IG1hdGNoIHBhZCB3aXRoXG4gICAgICB8IE5vX3BhZGRpbmcgLT4gTm9uZVxuICAgICAgfCBMaXRfcGFkZGluZyAoUmlnaHQsIHdpZHRoKSAtPiBTb21lIHdpZHRoXG4gICAgICB8IExpdF9wYWRkaW5nIChaZXJvcywgd2lkdGgpIC0+XG4gICAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuIFNvbWUgd2lkdGhcbiAgICAgICAgZWxzZSBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgYyBcIicwJ1wiXG4gICAgICB8IExpdF9wYWRkaW5nIChMZWZ0LCB3aWR0aCkgLT5cbiAgICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW4gU29tZSB3aWR0aFxuICAgICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBjIFwiJy0nXCJcbiAgICAgIHwgQXJnX3BhZGRpbmcgXyAtPiBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgYyBcIicqJ1wiXG4gICAgaW5cbiAgICBsZXQgZ2V0X3BhZF9vcHQgYyA9IG9wdF9vZl9wYWQgYyAoZ2V0X3BhZCAoKSkgaW5cbiAgICBsZXQgZ2V0X3BhZHByZWNfb3B0IGMgPSBvcHRfb2ZfcGFkIGMgKGdldF9wYWRwcmVjICgpKSBpblxuXG4gICAgKCogR2V0IHByZWNpc2lvbiBhcyBhIHByZWNfb3B0aW9uIChzZWUgXCIlX2ZcIikuXG4gICAgICAgKG5vIG5lZWQgZm9yIGxlZ2FjeSBtb2RlIHR3ZWFraW5nLCB0aG9zZSB3ZXJlIHJlamVjdGVkIGJ5IHRoZVxuICAgICAgIGxlZ2FjeSBwYXJzZXIgYXMgd2VsbCkgKilcbiAgICBsZXQgZ2V0X3ByZWNfb3B0ICgpID0gbWF0Y2ggZ2V0X3ByZWMgKCkgd2l0aFxuICAgICAgfCBOb19wcmVjaXNpb24gICAgICAgLT4gTm9uZVxuICAgICAgfCBMaXRfcHJlY2lzaW9uIG5kZWMgLT4gU29tZSBuZGVjXG4gICAgICB8IEFyZ19wcmVjaXNpb24gICAgICAtPiBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgJ18nIFwiJyonXCJcbiAgICBpblxuXG4gICAgbGV0IGZtdF9yZXN1bHQgPSBtYXRjaCBzeW1iIHdpdGhcbiAgICB8ICcsJyAtPlxuICAgICAgcGFyc2Ugc3RyX2luZCBlbmRfaW5kXG4gICAgfCAnYycgLT5cbiAgICAgIGxldCBjaGFyX2Zvcm1hdCBmbXRfcmVzdCA9ICgqICVjICopXG4gICAgICAgIGlmIGdldF9pZ24gKClcbiAgICAgICAgdGhlbiBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChJZ25vcmVkX2NoYXIsIGZtdF9yZXN0KSlcbiAgICAgICAgZWxzZSBGbXRfRUJCIChDaGFyIGZtdF9yZXN0KVxuICAgICAgaW5cbiAgICAgIGxldCBzY2FuX2Zvcm1hdCBmbXRfcmVzdCA9ICgqICUwYyAqKVxuICAgICAgICBpZiBnZXRfaWduICgpXG4gICAgICAgIHRoZW4gRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoSWdub3JlZF9zY2FuX25leHRfY2hhciwgZm10X3Jlc3QpKVxuICAgICAgICBlbHNlIEZtdF9FQkIgKFNjYW5fbmV4dF9jaGFyIGZtdF9yZXN0KVxuICAgICAgaW5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBiZWdpbiBtYXRjaCBnZXRfcGFkX29wdCAnYycgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gY2hhcl9mb3JtYXQgZm10X3Jlc3RcbiAgICAgICAgfCBTb21lIDAgLT4gc2Nhbl9mb3JtYXQgZm10X3Jlc3RcbiAgICAgICAgfCBTb21lIF9uIC0+XG4gICAgICAgICAgIGlmIG5vdCBsZWdhY3lfYmVoYXZpb3JcbiAgICAgICAgICAgdGhlbiBpbnZhbGlkX25vbm51bGxfY2hhcl93aWR0aCBzdHJfaW5kXG4gICAgICAgICAgIGVsc2UgKCogbGVnYWN5IGlnbm9yZXMgJWMgd2lkdGhzICopIGNoYXJfZm9ybWF0IGZtdF9yZXN0XG4gICAgICBlbmRcbiAgICB8ICdDJyAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlbiBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChJZ25vcmVkX2NhbWxfY2hhcixmbXRfcmVzdCkpXG4gICAgICBlbHNlIEZtdF9FQkIgKENhbWxfY2hhciBmbXRfcmVzdClcbiAgICB8ICdzJyAtPlxuICAgICAgbGV0IHBhZCA9IGNoZWNrX25vXzAgc3ltYiAoZ2V0X3BhZHByZWMgKCkpIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9zdHJpbmcgKGdldF9wYWRwcmVjX29wdCAnXycpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IFBhZGRpbmdfZm10X0VCQiAocGFkJywgZm10X3Jlc3QnKSA9XG4gICAgICAgICAgbWFrZV9wYWRkaW5nX2ZtdF9lYmIgcGFkIGZtdF9yZXN0IGluXG4gICAgICAgIEZtdF9FQkIgKFN0cmluZyAocGFkJywgZm10X3Jlc3QnKSlcbiAgICB8ICdTJyAtPlxuICAgICAgbGV0IHBhZCA9IGNoZWNrX25vXzAgc3ltYiAoZ2V0X3BhZHByZWMgKCkpIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9jYW1sX3N0cmluZyAoZ2V0X3BhZHByZWNfb3B0ICdfJykgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBsZXQgUGFkZGluZ19mbXRfRUJCIChwYWQnLCBmbXRfcmVzdCcpID1cbiAgICAgICAgICBtYWtlX3BhZGRpbmdfZm10X2ViYiBwYWQgZm10X3Jlc3QgaW5cbiAgICAgICAgRm10X0VCQiAoQ2FtbF9zdHJpbmcgKHBhZCcsIGZtdF9yZXN0JykpXG4gICAgfCAnZCcgfCAnaScgfCAneCcgfCAnWCcgfCAnbycgfCAndScgLT5cbiAgICAgIGxldCBpY29udiA9IGNvbXB1dGVfaW50X2NvbnYgcGN0X2luZCBzdHJfaW5kIChnZXRfcGx1cyAoKSkgKGdldF9oYXNoICgpKVxuICAgICAgICAoZ2V0X3NwYWNlICgpKSBzeW1iIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9pbnQgKGljb252LCBnZXRfcGFkX29wdCAnXycpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IFBhZHByZWNfZm10X0VCQiAocGFkJywgcHJlYycsIGZtdF9yZXN0JykgPVxuICAgICAgICAgIG1ha2VfcGFkcHJlY19mbXRfZWJiIChnZXRfaW50X3BhZCAoKSkgKGdldF9wcmVjICgpKSBmbXRfcmVzdCBpblxuICAgICAgICBGbXRfRUJCIChJbnQgKGljb252LCBwYWQnLCBwcmVjJywgZm10X3Jlc3QnKSlcbiAgICB8ICdOJyAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGxldCBjb3VudGVyID0gVG9rZW5fY291bnRlciBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9zY2FuX2dldF9jb3VudGVyIGNvdW50ZXIgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBGbXRfRUJCIChTY2FuX2dldF9jb3VudGVyIChjb3VudGVyLCBmbXRfcmVzdCkpXG4gICAgfCAnbCcgfCAnbicgfCAnTCcgd2hlbiBzdHJfaW5kPWVuZF9pbmQgfHwgbm90IChpc19pbnRfYmFzZSBzdHIuW3N0cl9pbmRdKSAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGxldCBjb3VudGVyID0gY291bnRlcl9vZl9jaGFyIHN5bWIgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfc2Nhbl9nZXRfY291bnRlciBjb3VudGVyIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgRm10X0VCQiAoU2Nhbl9nZXRfY291bnRlciAoY291bnRlciwgZm10X3Jlc3QpKVxuICAgIHwgJ2wnIC0+XG4gICAgICBsZXQgaWNvbnYgPVxuICAgICAgICBjb21wdXRlX2ludF9jb252IHBjdF9pbmQgKHN0cl9pbmQgKyAxKSAoZ2V0X3BsdXMgKCkpIChnZXRfaGFzaCAoKSlcbiAgICAgICAgICAoZ2V0X3NwYWNlICgpKSBzdHIuW3N0cl9pbmRdIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9pbnQzMiAoaWNvbnYsIGdldF9wYWRfb3B0ICdfJykgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBsZXQgUGFkcHJlY19mbXRfRUJCIChwYWQnLCBwcmVjJywgZm10X3Jlc3QnKSA9XG4gICAgICAgICAgbWFrZV9wYWRwcmVjX2ZtdF9lYmIgKGdldF9pbnRfcGFkICgpKSAoZ2V0X3ByZWMgKCkpIGZtdF9yZXN0IGluXG4gICAgICAgIEZtdF9FQkIgKEludDMyIChpY29udiwgcGFkJywgcHJlYycsIGZtdF9yZXN0JykpXG4gICAgfCAnbicgLT5cbiAgICAgIGxldCBpY29udiA9XG4gICAgICAgIGNvbXB1dGVfaW50X2NvbnYgcGN0X2luZCAoc3RyX2luZCArIDEpIChnZXRfcGx1cyAoKSlcbiAgICAgICAgICAoZ2V0X2hhc2ggKCkpIChnZXRfc3BhY2UgKCkpIHN0ci5bc3RyX2luZF0gaW5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBJZ25vcmVkX25hdGl2ZWludCAoaWNvbnYsIGdldF9wYWRfb3B0ICdfJykgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBsZXQgUGFkcHJlY19mbXRfRUJCIChwYWQnLCBwcmVjJywgZm10X3Jlc3QnKSA9XG4gICAgICAgICAgbWFrZV9wYWRwcmVjX2ZtdF9lYmIgKGdldF9pbnRfcGFkICgpKSAoZ2V0X3ByZWMgKCkpIGZtdF9yZXN0IGluXG4gICAgICAgIEZtdF9FQkIgKE5hdGl2ZWludCAoaWNvbnYsIHBhZCcsIHByZWMnLCBmbXRfcmVzdCcpKVxuICAgIHwgJ0wnIC0+XG4gICAgICBsZXQgaWNvbnYgPVxuICAgICAgICBjb21wdXRlX2ludF9jb252IHBjdF9pbmQgKHN0cl9pbmQgKyAxKSAoZ2V0X3BsdXMgKCkpIChnZXRfaGFzaCAoKSlcbiAgICAgICAgICAoZ2V0X3NwYWNlICgpKSBzdHIuW3N0cl9pbmRdIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9pbnQ2NCAoaWNvbnYsIGdldF9wYWRfb3B0ICdfJykgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBsZXQgUGFkcHJlY19mbXRfRUJCIChwYWQnLCBwcmVjJywgZm10X3Jlc3QnKSA9XG4gICAgICAgICAgbWFrZV9wYWRwcmVjX2ZtdF9lYmIgKGdldF9pbnRfcGFkICgpKSAoZ2V0X3ByZWMgKCkpIGZtdF9yZXN0IGluXG4gICAgICAgIEZtdF9FQkIgKEludDY0IChpY29udiwgcGFkJywgcHJlYycsIGZtdF9yZXN0JykpXG4gICAgfCAnZicgfCAnZScgfCAnRScgfCAnZycgfCAnRycgfCAnRicgfCAnaCcgfCAnSCcgLT5cbiAgICAgIGxldCBmY29udiA9XG4gICAgICAgIGNvbXB1dGVfZmxvYXRfY29udiBwY3RfaW5kIHN0cl9pbmRcbiAgICAgICAgICAoZ2V0X3BsdXMgKCkpIChnZXRfaGFzaCAoKSkgKGdldF9zcGFjZSAoKSkgc3ltYiBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfZmxvYXQgKGdldF9wYWRfb3B0ICdfJywgZ2V0X3ByZWNfb3B0ICgpKSBpblxuICAgICAgICBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChpZ25vcmVkLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlXG4gICAgICAgIGxldCBQYWRwcmVjX2ZtdF9FQkIgKHBhZCcsIHByZWMnLCBmbXRfcmVzdCcpID1cbiAgICAgICAgICBtYWtlX3BhZHByZWNfZm10X2ViYiAoZ2V0X3BhZCAoKSkgKGdldF9wcmVjICgpKSBmbXRfcmVzdCBpblxuICAgICAgICBGbXRfRUJCIChGbG9hdCAoZmNvbnYsIHBhZCcsIHByZWMnLCBmbXRfcmVzdCcpKVxuICAgIHwgJ2InIHwgJ0InIC0+XG4gICAgICBsZXQgcGFkID0gY2hlY2tfbm9fMCBzeW1iIChnZXRfcGFkcHJlYyAoKSkgaW5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBJZ25vcmVkX2Jvb2wgKGdldF9wYWRwcmVjX29wdCAnXycpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IFBhZGRpbmdfZm10X0VCQiAocGFkJywgZm10X3Jlc3QnKSA9XG4gICAgICAgICAgbWFrZV9wYWRkaW5nX2ZtdF9lYmIgcGFkIGZtdF9yZXN0IGluXG4gICAgICAgIEZtdF9FQkIgKEJvb2wgKHBhZCcsIGZtdF9yZXN0JykpXG4gICAgfCAnYScgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBGbXRfRUJCIChBbHBoYSBmbXRfcmVzdClcbiAgICB8ICd0JyAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIEZtdF9FQkIgKFRoZXRhIGZtdF9yZXN0KVxuICAgIHwgJ3InIC0+XG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKElnbm9yZWRfcmVhZGVyLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlIEZtdF9FQkIgKFJlYWRlciBmbXRfcmVzdClcbiAgICB8ICchJyAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIEZtdF9FQkIgKEZsdXNoIGZtdF9yZXN0KVxuICAgIHwgKCclJyB8ICdAJykgYXMgYyAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIEZtdF9FQkIgKENoYXJfbGl0ZXJhbCAoYywgZm10X3Jlc3QpKVxuICAgIHwgJ3snIC0+XG4gICAgICBsZXQgc3ViX2VuZCA9IHNlYXJjaF9zdWJmb3JtYXRfZW5kIHN0cl9pbmQgZW5kX2luZCAnfScgaW5cbiAgICAgIGxldCBGbXRfRUJCIHN1Yl9mbXQgPSBwYXJzZSBzdHJfaW5kIHN1Yl9lbmQgaW5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN1Yl9lbmQgKyAyKSBlbmRfaW5kIGluXG4gICAgICBsZXQgc3ViX2ZtdHR5ID0gZm10dHlfb2ZfZm10IHN1Yl9mbXQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfZm9ybWF0X2FyZyAoZ2V0X3BhZF9vcHQgJ18nLCBzdWJfZm10dHkpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgRm10X0VCQiAoRm9ybWF0X2FyZyAoZ2V0X3BhZF9vcHQgJ3snLCBzdWJfZm10dHksIGZtdF9yZXN0KSlcbiAgICB8ICcoJyAtPlxuICAgICAgbGV0IHN1Yl9lbmQgPSBzZWFyY2hfc3ViZm9ybWF0X2VuZCBzdHJfaW5kIGVuZF9pbmQgJyknIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdWJfZW5kICsgMikgZW5kX2luZCBpblxuICAgICAgbGV0IEZtdF9FQkIgc3ViX2ZtdCA9IHBhcnNlIHN0cl9pbmQgc3ViX2VuZCBpblxuICAgICAgbGV0IHN1Yl9mbXR0eSA9IGZtdHR5X29mX2ZtdCBzdWJfZm10IGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBJZ25vcmVkX2Zvcm1hdF9zdWJzdCAoZ2V0X3BhZF9vcHQgJ18nLCBzdWJfZm10dHkpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgRm10X0VCQiAoRm9ybWF0X3N1YnN0IChnZXRfcGFkX29wdCAnKCcsIHN1Yl9mbXR0eSwgZm10X3Jlc3QpKVxuICAgIHwgJ1snIC0+XG4gICAgICBsZXQgbmV4dF9pbmQsIGNoYXJfc2V0ID0gcGFyc2VfY2hhcl9zZXQgc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIG5leHRfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfc2Nhbl9jaGFyX3NldCAoZ2V0X3BhZF9vcHQgJ18nLCBjaGFyX3NldCkgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBGbXRfRUJCIChTY2FuX2NoYXJfc2V0IChnZXRfcGFkX29wdCAnWycsIGNoYXJfc2V0LCBmbXRfcmVzdCkpXG4gICAgfCAnLScgfCAnKycgfCAnIycgfCAnICcgfCAnXycgLT5cbiAgICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgICAgXCJpbnZhbGlkIGZvcm1hdCAlUzogYXQgY2hhcmFjdGVyIG51bWJlciAlZCwgXFxcbiAgICAgICAgIGZsYWcgJUMgaXMgb25seSBhbGxvd2VkIGFmdGVyIHRoZSAnJSUnLCBiZWZvcmUgcGFkZGluZyBhbmQgcHJlY2lzaW9uXCJcbiAgICAgICAgc3RyIHBjdF9pbmQgc3ltYlxuICAgIHwgXyAtPlxuICAgICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgICBcImludmFsaWQgZm9ybWF0ICVTOiBhdCBjaGFyYWN0ZXIgbnVtYmVyICVkLCBcXFxuICAgICAgICAgaW52YWxpZCBjb252ZXJzaW9uIFxcXCIlJSVjXFxcIlwiIHN0ciAoc3RyX2luZCAtIDEpIHN5bWJcbiAgICBpblxuICAgICgqIENoZWNrIGZvciB1bnVzZWQgb3B0aW9ucywgYW5kIHJlamVjdCB0aGVtIGFzIGluY29tcGF0aWJsZS5cblxuICAgICAgIFN1Y2ggY2hlY2tzIG5lZWQgdG8gYmUgZGlzYWJsZWQgaW4gbGVnYWN5IG1vZGUsIGFzIHRoZSBsZWdhY3lcbiAgICAgICBwYXJzZXIgc2lsZW50bHkgaWdub3JlZCBpbmNvbXBhdGlibGUgZmxhZ3MuICopXG4gICAgaWYgbm90IGxlZ2FjeV9iZWhhdmlvciB0aGVuIGJlZ2luXG4gICAgaWYgbm90ICFwbHVzX3VzZWQgJiYgcGx1cyB0aGVuXG4gICAgICBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgc3ltYiBcIicrJ1wiO1xuICAgIGlmIG5vdCAhaGFzaF91c2VkICYmIGhhc2ggdGhlblxuICAgICAgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIHN5bWIgXCInIydcIjtcbiAgICBpZiBub3QgIXNwYWNlX3VzZWQgJiYgc3BhY2UgdGhlblxuICAgICAgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIHN5bWIgXCInICdcIjtcbiAgICBpZiBub3QgIXBhZF91c2VkICAmJiBQYWRkaW5nX0VCQiBwYWQgPD4gUGFkZGluZ19FQkIgTm9fcGFkZGluZyB0aGVuXG4gICAgICBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgc3ltYiBcImBwYWRkaW5nJ1wiO1xuICAgIGlmIG5vdCAhcHJlY191c2VkICYmIFByZWNpc2lvbl9FQkIgcHJlYyA8PiBQcmVjaXNpb25fRUJCIE5vX3ByZWNpc2lvbiB0aGVuXG4gICAgICBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgKGlmIGlnbiB0aGVuICdfJyBlbHNlIHN5bWIpXG4gICAgICAgIFwiYHByZWNpc2lvbidcIjtcbiAgICBpZiBpZ24gJiYgcGx1cyB0aGVuIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCAnXycgXCInKydcIjtcbiAgICBlbmQ7XG4gICAgKCogdGhpcyBsYXN0IHRlc3QgbXVzdCBub3QgYmUgZGlzYWJsZWQgaW4gbGVnYWN5IG1vZGUsXG4gICAgICAgYXMgaWdub3JpbmcgaXQgd291bGQgdHlwaWNhbGx5IHJlc3VsdCBpbiBhIGRpZmZlcmVudCB0eXBpbmdcbiAgICAgICB0aGFuIHdoYXQgdGhlIGxlZ2FjeSBwYXJzZXIgdXNlZCAqKVxuICAgIGlmIG5vdCAhaWduX3VzZWQgJiYgaWduIHRoZW5cbiAgICAgIGJlZ2luIG1hdGNoIHN5bWIgd2l0aFxuICAgICAgICAoKiBhcmd1bWVudC1sZXNzIGZvcm1hdHMgY2FuIHNhZmVseSBiZSBpZ25vcmVkIGluIGxlZ2FjeSBtb2RlICopXG4gICAgICAgIHwgKCdAJyB8ICclJyB8ICchJyB8ICcsJykgd2hlbiBsZWdhY3lfYmVoYXZpb3IgLT4gKClcbiAgICAgICAgfCBfIC0+XG4gICAgICAgICAgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIHN5bWIgXCInXydcIlxuICAgICAgZW5kO1xuICAgIGZtdF9yZXN1bHRcblxuICAoKiBQYXJzZSBmb3JtYXR0aW5nIGluZm9ybWF0aW9uIChhZnRlciAnQCcpLiAqKVxuICBhbmQgcGFyc2VfYWZ0ZXJfYXQgOiB0eXBlIGUgZiAuIGludCAtPiBpbnQgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gc3RyX2luZCBlbmRfaW5kIC0+XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiBGbXRfRUJCIChDaGFyX2xpdGVyYWwgKCdAJywgRW5kX29mX2Zvcm1hdCkpXG4gICAgZWxzZVxuICAgICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgICB8ICdbJyAtPlxuICAgICAgICBwYXJzZV90YWcgZmFsc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kXG4gICAgICB8ICddJyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoQ2xvc2VfYm94LCBmbXRfcmVzdCkpXG4gICAgICB8ICd7JyAtPlxuICAgICAgICBwYXJzZV90YWcgdHJ1ZSAoc3RyX2luZCArIDEpIGVuZF9pbmRcbiAgICAgIHwgJ30nIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChDbG9zZV90YWcsIGZtdF9yZXN0KSlcbiAgICAgIHwgJywnIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChCcmVhayAoXCJALFwiLCAwLCAwKSwgZm10X3Jlc3QpKVxuICAgICAgfCAnICcgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKEJyZWFrIChcIkAgXCIsIDEsIDApLCBmbXRfcmVzdCkpXG4gICAgICB8ICc7JyAtPlxuICAgICAgICBwYXJzZV9nb29kX2JyZWFrIChzdHJfaW5kICsgMSkgZW5kX2luZFxuICAgICAgfCAnPycgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKEZGbHVzaCwgZm10X3Jlc3QpKVxuICAgICAgfCAnXFxuJyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoRm9yY2VfbmV3bGluZSwgZm10X3Jlc3QpKVxuICAgICAgfCAnLicgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKEZsdXNoX25ld2xpbmUsIGZtdF9yZXN0KSlcbiAgICAgIHwgJzwnIC0+XG4gICAgICAgIHBhcnNlX21hZ2ljX3NpemUgKHN0cl9pbmQgKyAxKSBlbmRfaW5kXG4gICAgICB8ICdAJyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoRXNjYXBlZF9hdCwgZm10X3Jlc3QpKVxuICAgICAgfCAnJScgd2hlbiBzdHJfaW5kICsgMSA8IGVuZF9pbmQgJiYgc3RyLltzdHJfaW5kICsgMV0gPSAnJScgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDIpIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKEVzY2FwZWRfcGVyY2VudCwgZm10X3Jlc3QpKVxuICAgICAgfCAnJScgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoQ2hhcl9saXRlcmFsICgnQCcsIGZtdF9yZXN0KSlcbiAgICAgIHwgYyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoU2Nhbl9pbmRpYyBjLCBmbXRfcmVzdCkpXG5cbiAgKCogVHJ5IHRvIHJlYWQgdGhlIG9wdGlvbmFsIDxuYW1lPiBhZnRlciBcIkB7XCIgb3IgXCJAW1wiLiAqKVxuICBhbmQgcGFyc2VfdGFnIDogdHlwZSBlIGYgLiBib29sIC0+IGludCAtPiBpbnQgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gaXNfb3Blbl90YWcgc3RyX2luZCBlbmRfaW5kIC0+XG4gICAgdHJ5XG4gICAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHJhaXNlIE5vdF9mb3VuZDtcbiAgICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgICAgfCAnPCcgLT5cbiAgICAgICAgbGV0IGluZCA9IFN0cmluZy5pbmRleF9mcm9tIHN0ciAoc3RyX2luZCArIDEpICc+JyBpblxuICAgICAgICBpZiBpbmQgPj0gZW5kX2luZCB0aGVuIHJhaXNlIE5vdF9mb3VuZDtcbiAgICAgICAgbGV0IHN1Yl9zdHIgPSBTdHJpbmcuc3ViIHN0ciBzdHJfaW5kIChpbmQgLSBzdHJfaW5kICsgMSkgaW5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBsZXQgRm10X0VCQiBzdWJfZm10ID0gcGFyc2Ugc3RyX2luZCAoaW5kICsgMSkgaW5cbiAgICAgICAgbGV0IHN1Yl9mb3JtYXQgPSBGb3JtYXQgKHN1Yl9mbXQsIHN1Yl9zdHIpIGluXG4gICAgICAgIGxldCBmb3JtYXR0aW5nID1cbiAgICAgICAgICBpZiBpc19vcGVuX3RhZyB0aGVuIE9wZW5fdGFnIHN1Yl9mb3JtYXQgZWxzZSBPcGVuX2JveCBzdWJfZm9ybWF0IGluXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfZ2VuIChmb3JtYXR0aW5nLCBmbXRfcmVzdCkpXG4gICAgICB8IF8gLT5cbiAgICAgICAgcmFpc2UgTm90X2ZvdW5kXG4gICAgd2l0aCBOb3RfZm91bmQgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBsZXQgc3ViX2Zvcm1hdCA9IEZvcm1hdCAoRW5kX29mX2Zvcm1hdCwgXCJcIikgaW5cbiAgICAgIGxldCBmb3JtYXR0aW5nID1cbiAgICAgICAgaWYgaXNfb3Blbl90YWcgdGhlbiBPcGVuX3RhZyBzdWJfZm9ybWF0IGVsc2UgT3Blbl9ib3ggc3ViX2Zvcm1hdCBpblxuICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19nZW4gKGZvcm1hdHRpbmcsIGZtdF9yZXN0KSlcblxuICAoKiBUcnkgdG8gcmVhZCB0aGUgb3B0aW9uYWwgPHdpZHRoIG9mZnNldD4gYWZ0ZXIgXCJAO1wiLiAqKVxuICBhbmQgcGFyc2VfZ29vZF9icmVhayA6IHR5cGUgZSBmIC4gaW50IC0+IGludCAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBzdHJfaW5kIGVuZF9pbmQgLT5cbiAgICBsZXQgbmV4dF9pbmQsIGZvcm1hdHRpbmdfbGl0ID1cbiAgICAgIHRyeVxuICAgICAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB8fCBzdHIuW3N0cl9pbmRdIDw+ICc8JyB0aGVuIHJhaXNlIE5vdF9mb3VuZDtcbiAgICAgICAgbGV0IHN0cl9pbmRfMSA9IHBhcnNlX3NwYWNlcyAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgbWF0Y2ggc3RyLltzdHJfaW5kXzFdIHdpdGhcbiAgICAgICAgfCAnMCcgLi4gJzknIHwgJy0nIC0+IChcbiAgICAgICAgICBsZXQgc3RyX2luZF8yLCB3aWR0aCA9IHBhcnNlX2ludGVnZXIgc3RyX2luZF8xIGVuZF9pbmQgaW5cbiAgICAgICAgICAgIGxldCBzdHJfaW5kXzMgPSBwYXJzZV9zcGFjZXMgc3RyX2luZF8yIGVuZF9pbmQgaW5cbiAgICAgICAgICAgIG1hdGNoIHN0ci5bc3RyX2luZF8zXSB3aXRoXG4gICAgICAgICAgICAgIHwgJz4nIC0+XG4gICAgICAgICAgICAgICAgbGV0IHMgPSBTdHJpbmcuc3ViIHN0ciAoc3RyX2luZC0yKSAoc3RyX2luZF8zLXN0cl9pbmQrMykgaW5cbiAgICAgICAgICAgICAgICBzdHJfaW5kXzMgKyAxLCBCcmVhayAocywgd2lkdGgsIDApXG4gICAgICAgICAgICAgIHwgJzAnIC4uICc5JyB8ICctJyAtPlxuICAgICAgICAgICAgICAgIGxldCBzdHJfaW5kXzQsIG9mZnNldCA9IHBhcnNlX2ludGVnZXIgc3RyX2luZF8zIGVuZF9pbmQgaW5cbiAgICAgICAgICAgICAgICBsZXQgc3RyX2luZF81ID0gcGFyc2Vfc3BhY2VzIHN0cl9pbmRfNCBlbmRfaW5kIGluXG4gICAgICAgICAgICAgICAgaWYgc3RyLltzdHJfaW5kXzVdIDw+ICc+JyB0aGVuIHJhaXNlIE5vdF9mb3VuZDtcbiAgICAgICAgICAgICAgICBsZXQgcyA9IFN0cmluZy5zdWIgc3RyIChzdHJfaW5kLTIpIChzdHJfaW5kXzUtc3RyX2luZCszKSBpblxuICAgICAgICAgICAgICAgIHN0cl9pbmRfNSArIDEsIEJyZWFrIChzLCB3aWR0aCwgb2Zmc2V0KVxuICAgICAgICAgICAgICB8IF8gLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICAgIClcbiAgICAgICAgfCBfIC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgd2l0aCBOb3RfZm91bmQgfCBGYWlsdXJlIF8gLT5cbiAgICAgICAgc3RyX2luZCwgQnJlYWsgKFwiQDtcIiwgMSwgMClcbiAgICBpblxuICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgbmV4dF9pbmQgZW5kX2luZCBpblxuICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChmb3JtYXR0aW5nX2xpdCwgZm10X3Jlc3QpKVxuXG4gICgqIFBhcnNlIHRoZSBzaXplIGluIGEgPG4+LiAqKVxuICBhbmQgcGFyc2VfbWFnaWNfc2l6ZSA6IHR5cGUgZSBmIC4gaW50IC0+IGludCAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBzdHJfaW5kIGVuZF9pbmQgLT5cbiAgICBtYXRjaFxuICAgICAgdHJ5XG4gICAgICAgIGxldCBzdHJfaW5kXzEgPSBwYXJzZV9zcGFjZXMgc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICAgIG1hdGNoIHN0ci5bc3RyX2luZF8xXSB3aXRoXG4gICAgICAgIHwgJzAnIC4uICc5JyB8ICctJyAtPlxuICAgICAgICAgIGxldCBzdHJfaW5kXzIsIHNpemUgPSBwYXJzZV9pbnRlZ2VyIHN0cl9pbmRfMSBlbmRfaW5kIGluXG4gICAgICAgICAgbGV0IHN0cl9pbmRfMyA9IHBhcnNlX3NwYWNlcyBzdHJfaW5kXzIgZW5kX2luZCBpblxuICAgICAgICAgIGlmIHN0ci5bc3RyX2luZF8zXSA8PiAnPicgdGhlbiByYWlzZSBOb3RfZm91bmQ7XG4gICAgICAgICAgbGV0IHMgPSBTdHJpbmcuc3ViIHN0ciAoc3RyX2luZCAtIDIpIChzdHJfaW5kXzMgLSBzdHJfaW5kICsgMykgaW5cbiAgICAgICAgICBTb21lIChzdHJfaW5kXzMgKyAxLCBNYWdpY19zaXplIChzLCBzaXplKSlcbiAgICAgICAgfCBfIC0+IE5vbmVcbiAgICAgIHdpdGggTm90X2ZvdW5kIHwgRmFpbHVyZSBfIC0+XG4gICAgICAgIE5vbmVcbiAgICB3aXRoXG4gICAgfCBTb21lIChuZXh0X2luZCwgZm9ybWF0dGluZ19saXQpIC0+XG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIG5leHRfaW5kIGVuZF9pbmQgaW5cbiAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChmb3JtYXR0aW5nX2xpdCwgZm10X3Jlc3QpKVxuICAgIHwgTm9uZSAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChTY2FuX2luZGljICc8JywgZm10X3Jlc3QpKVxuXG4gICgqIFBhcnNlIGFuZCBjb25zdHJ1Y3QgYSBjaGFyIHNldC4gKilcbiAgYW5kIHBhcnNlX2NoYXJfc2V0IHN0cl9pbmQgZW5kX2luZCA9XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcblxuICAgIGxldCBjaGFyX3NldCA9IGNyZWF0ZV9jaGFyX3NldCAoKSBpblxuICAgIGxldCBhZGRfY2hhciBjID1cbiAgICAgIGFkZF9pbl9jaGFyX3NldCBjaGFyX3NldCBjO1xuICAgIGluXG4gICAgbGV0IGFkZF9yYW5nZSBjIGMnID1cbiAgICAgIGZvciBpID0gaW50X29mX2NoYXIgYyB0byBpbnRfb2ZfY2hhciBjJyBkb1xuICAgICAgICBhZGRfaW5fY2hhcl9zZXQgY2hhcl9zZXQgKGNoYXJfb2ZfaW50IGkpO1xuICAgICAgZG9uZTtcbiAgICBpblxuXG4gICAgbGV0IGZhaWxfc2luZ2xlX3BlcmNlbnQgc3RyX2luZCA9XG4gICAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICAgIFwiaW52YWxpZCBmb3JtYXQgJVM6ICclJScgYWxvbmUgaXMgbm90IGFjY2VwdGVkIGluIGNoYXJhY3RlciBzZXRzLCBcXFxuICAgICAgICAgdXNlICUlJSUgaW5zdGVhZCBhdCBwb3NpdGlvbiAlZC5cIiBzdHIgc3RyX2luZFxuICAgIGluXG5cbiAgICAoKiBQYXJzZSB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGEgY2hhciBzZXQuICopXG4gICAgbGV0IHJlYyBwYXJzZV9jaGFyX3NldF9zdGFydCBzdHJfaW5kIGVuZF9pbmQgPVxuICAgICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICAgIGxldCBjID0gc3RyLltzdHJfaW5kXSBpblxuICAgICAgcGFyc2VfY2hhcl9zZXRfYWZ0ZXJfY2hhciAoc3RyX2luZCArIDEpIGVuZF9pbmQgY1xuXG4gICAgKCogUGFyc2UgdGhlIGNvbnRlbnQgb2YgYSBjaGFyIHNldCB1bnRpbCB0aGUgZmlyc3QgJ10nLiAqKVxuICAgIGFuZCBwYXJzZV9jaGFyX3NldF9jb250ZW50IHN0cl9pbmQgZW5kX2luZCA9XG4gICAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgICB8ICddJyAtPlxuICAgICAgICBzdHJfaW5kICsgMVxuICAgICAgfCAnLScgLT5cbiAgICAgICAgYWRkX2NoYXIgJy0nO1xuICAgICAgICBwYXJzZV9jaGFyX3NldF9jb250ZW50IChzdHJfaW5kICsgMSkgZW5kX2luZFxuICAgICAgfCBjIC0+XG4gICAgICAgIHBhcnNlX2NoYXJfc2V0X2FmdGVyX2NoYXIgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGNcblxuICAgICgqIFRlc3QgZm9yIHJhbmdlIGluIGNoYXIgc2V0LiAqKVxuICAgIGFuZCBwYXJzZV9jaGFyX3NldF9hZnRlcl9jaGFyIHN0cl9pbmQgZW5kX2luZCBjID1cbiAgICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICAgIHwgJ10nIC0+XG4gICAgICAgIGFkZF9jaGFyIGM7XG4gICAgICAgIHN0cl9pbmQgKyAxXG4gICAgICB8ICctJyAtPlxuICAgICAgICBwYXJzZV9jaGFyX3NldF9hZnRlcl9taW51cyAoc3RyX2luZCArIDEpIGVuZF9pbmQgY1xuICAgICAgfCAoJyUnIHwgJ0AnKSBhcyBjJyB3aGVuIGMgPSAnJScgLT5cbiAgICAgICAgYWRkX2NoYXIgYyc7XG4gICAgICAgIHBhcnNlX2NoYXJfc2V0X2NvbnRlbnQgKHN0cl9pbmQgKyAxKSBlbmRfaW5kXG4gICAgICB8IGMnIC0+XG4gICAgICAgIGlmIGMgPSAnJScgdGhlbiBmYWlsX3NpbmdsZV9wZXJjZW50IHN0cl9pbmQ7XG4gICAgICAgICgqIG5vdGUgdGhhdCAnQCcgYWxvbmUgaXMgYWNjZXB0ZWQsIGFzIGRvbmUgYnkgdGhlIGxlZ2FjeVxuICAgICAgICAgICBpbXBsZW1lbnRhdGlvbjsgdGhlIGRvY3VtZW50YXRpb24gc3BlY2lmaWNhbGx5IHJlcXVpcmVzICVAXG4gICAgICAgICAgIHNvIHdlIGNvdWxkIHdhcm4gb24gdGhhdCAqKVxuICAgICAgICBhZGRfY2hhciBjO1xuICAgICAgICBwYXJzZV9jaGFyX3NldF9hZnRlcl9jaGFyIChzdHJfaW5kICsgMSkgZW5kX2luZCBjJ1xuXG4gICAgKCogTWFuYWdlIHJhbmdlIGluIGNoYXIgc2V0IChleGNlcHQgaWYgdGhlICctJyB0aGUgbGFzdCBjaGFyIGJlZm9yZSAnXScpICopXG4gICAgYW5kIHBhcnNlX2NoYXJfc2V0X2FmdGVyX21pbnVzIHN0cl9pbmQgZW5kX2luZCBjID1cbiAgICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICAgIHwgJ10nIC0+XG4gICAgICAgIGFkZF9jaGFyIGM7XG4gICAgICAgIGFkZF9jaGFyICctJztcbiAgICAgICAgc3RyX2luZCArIDFcbiAgICAgIHwgJyUnIC0+XG4gICAgICAgIGlmIHN0cl9pbmQgKyAxID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgICBiZWdpbiBtYXRjaCBzdHIuW3N0cl9pbmQgKyAxXSB3aXRoXG4gICAgICAgICAgfCAoJyUnIHwgJ0AnKSBhcyBjJyAtPlxuICAgICAgICAgICAgYWRkX3JhbmdlIGMgYyc7XG4gICAgICAgICAgICBwYXJzZV9jaGFyX3NldF9jb250ZW50IChzdHJfaW5kICsgMikgZW5kX2luZFxuICAgICAgICAgIHwgXyAtPiBmYWlsX3NpbmdsZV9wZXJjZW50IHN0cl9pbmRcbiAgICAgICAgZW5kXG4gICAgICB8IGMnIC0+XG4gICAgICAgIGFkZF9yYW5nZSBjIGMnO1xuICAgICAgICBwYXJzZV9jaGFyX3NldF9jb250ZW50IChzdHJfaW5kICsgMSkgZW5kX2luZFxuICAgIGluXG4gICAgbGV0IHN0cl9pbmQsIHJldmVyc2UgPVxuICAgICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgICAgICB8ICdeJyAtPiBzdHJfaW5kICsgMSwgdHJ1ZVxuICAgICAgICB8IF8gLT4gc3RyX2luZCwgZmFsc2UgaW5cbiAgICBsZXQgbmV4dF9pbmQgPSBwYXJzZV9jaGFyX3NldF9zdGFydCBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICBsZXQgY2hhcl9zZXQgPSBmcmVlemVfY2hhcl9zZXQgY2hhcl9zZXQgaW5cbiAgICBuZXh0X2luZCwgKGlmIHJldmVyc2UgdGhlbiByZXZfY2hhcl9zZXQgY2hhcl9zZXQgZWxzZSBjaGFyX3NldClcblxuICAoKiBDb25zdW1lIGFsbCBuZXh0IHNwYWNlcywgcmFpc2UgYW4gRmFpbHVyZSBpZiBlbmRfaW5kIGlzIHJlYWNoZWQuICopXG4gIGFuZCBwYXJzZV9zcGFjZXMgc3RyX2luZCBlbmRfaW5kID1cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgIGlmIHN0ci5bc3RyX2luZF0gPSAnICcgdGhlbiBwYXJzZV9zcGFjZXMgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGVsc2Ugc3RyX2luZFxuXG4gICgqIFJlYWQgYSBwb3NpdGl2ZSBpbnRlZ2VyIGZyb20gdGhlIHN0cmluZywgcmFpc2UgYSBGYWlsdXJlIGlmIGVuZF9pbmQgaXNcbiAgICAgcmVhY2hlZC4gKilcbiAgYW5kIHBhcnNlX3Bvc2l0aXZlIHN0cl9pbmQgZW5kX2luZCBhY2MgPVxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgfCAnMCcgLi4gJzknIGFzIGMgLT5cbiAgICAgIGxldCBuZXdfYWNjID0gYWNjICogMTAgKyAoaW50X29mX2NoYXIgYyAtIGludF9vZl9jaGFyICcwJykgaW5cbiAgICAgIGlmIG5ld19hY2MgPiBTeXMubWF4X3N0cmluZ19sZW5ndGggdGhlblxuICAgICAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICAgICAgXCJpbnZhbGlkIGZvcm1hdCAlUzogaW50ZWdlciAlZCBpcyBncmVhdGVyIHRoYW4gdGhlIGxpbWl0ICVkXCJcbiAgICAgICAgICBzdHIgbmV3X2FjYyBTeXMubWF4X3N0cmluZ19sZW5ndGhcbiAgICAgIGVsc2VcbiAgICAgICAgcGFyc2VfcG9zaXRpdmUgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIG5ld19hY2NcbiAgICB8IF8gLT4gc3RyX2luZCwgYWNjXG5cbiAgKCogUmVhZCBhIHBvc2l0aXZlIG9yIG5lZ2F0aXZlIGludGVnZXIgZnJvbSB0aGUgc3RyaW5nLCByYWlzZSBhIEZhaWx1cmVcbiAgICAgaWYgZW5kX2luZCBpcyByZWFjaGVkLiAqKVxuICBhbmQgcGFyc2VfaW50ZWdlciBzdHJfaW5kIGVuZF9pbmQgPVxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgfCAnMCcgLi4gJzknIC0+IHBhcnNlX3Bvc2l0aXZlIHN0cl9pbmQgZW5kX2luZCAwXG4gICAgfCAnLScgLT4gKFxuICAgICAgaWYgc3RyX2luZCArIDEgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgICBtYXRjaCBzdHIuW3N0cl9pbmQgKyAxXSB3aXRoXG4gICAgICB8ICcwJyAuLiAnOScgLT5cbiAgICAgICAgbGV0IG5leHRfaW5kLCBuID0gcGFyc2VfcG9zaXRpdmUgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIDAgaW5cbiAgICAgICAgbmV4dF9pbmQsIC1uXG4gICAgICB8IGMgLT5cbiAgICAgICAgZXhwZWN0ZWRfY2hhcmFjdGVyIChzdHJfaW5kICsgMSkgXCJkaWdpdFwiIGNcbiAgICApXG4gICAgfCBfIC0+IGFzc2VydCBmYWxzZVxuXG4gICgqIEFkZCBhIGxpdGVyYWwgdG8gYSBmb3JtYXQgZnJvbSBhIGxpdGVyYWwgY2hhcmFjdGVyIHN1Yi1zZXF1ZW5jZS4gKilcbiAgYW5kIGFkZF9saXRlcmFsIDogdHlwZSBhIGQgZSBmIC5cbiAgICAgIGludCAtPiBpbnQgLT4gKGEsIF8sIF8sIGQsIGUsIGYpIGZtdCAtPlxuICAgICAgKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gbGl0X3N0YXJ0IHN0cl9pbmQgZm10IC0+IG1hdGNoIHN0cl9pbmQgLSBsaXRfc3RhcnQgd2l0aFxuICAgIHwgMCAgICAtPiBGbXRfRUJCIGZtdFxuICAgIHwgMSAgICAtPiBGbXRfRUJCIChDaGFyX2xpdGVyYWwgKHN0ci5bbGl0X3N0YXJ0XSwgZm10KSlcbiAgICB8IHNpemUgLT4gRm10X0VCQiAoU3RyaW5nX2xpdGVyYWwgKFN0cmluZy5zdWIgc3RyIGxpdF9zdGFydCBzaXplLCBmbXQpKVxuXG4gICgqIFNlYXJjaCB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IHN1Yi1mb3JtYXRcbiAgICAgKGkuZS4gdGhlIGNvcnJlc3BvbmRpbmcgXCIlfVwiIG9yIFwiJSlcIikgKilcbiAgYW5kIHNlYXJjaF9zdWJmb3JtYXRfZW5kIHN0cl9pbmQgZW5kX2luZCBjID1cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuXG4gICAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICAgIFwiaW52YWxpZCBmb3JtYXQgJVM6IHVuY2xvc2VkIHN1Yi1mb3JtYXQsIFxcXG4gICAgICAgICBleHBlY3RlZCBcXFwiJSUlY1xcXCIgYXQgY2hhcmFjdGVyIG51bWJlciAlZFwiIHN0ciBjIGVuZF9pbmQ7XG4gICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgfCAnJScgLT5cbiAgICAgIGlmIHN0cl9pbmQgKyAxID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgaWYgc3RyLltzdHJfaW5kICsgMV0gPSBjIHRoZW4gKCogRW5kIG9mIGZvcm1hdCBmb3VuZCAqKSBzdHJfaW5kIGVsc2VcbiAgICAgICAgYmVnaW4gbWF0Y2ggc3RyLltzdHJfaW5kICsgMV0gd2l0aFxuICAgICAgICB8ICdfJyAtPlxuICAgICAgICAgICgqIFNlYXJjaCBmb3IgXCIlXyhcIiBvciBcIiVfe1wiLiAqKVxuICAgICAgICAgIGlmIHN0cl9pbmQgKyAyID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgICAgIGJlZ2luIG1hdGNoIHN0ci5bc3RyX2luZCArIDJdIHdpdGhcbiAgICAgICAgICB8ICd7JyAtPlxuICAgICAgICAgICAgbGV0IHN1Yl9lbmQgPSBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3RyX2luZCArIDMpIGVuZF9pbmQgJ30nIGluXG4gICAgICAgICAgICBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3ViX2VuZCArIDIpIGVuZF9pbmQgY1xuICAgICAgICAgIHwgJygnIC0+XG4gICAgICAgICAgICBsZXQgc3ViX2VuZCA9IHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdHJfaW5kICsgMykgZW5kX2luZCAnKScgaW5cbiAgICAgICAgICAgIHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdWJfZW5kICsgMikgZW5kX2luZCBjXG4gICAgICAgICAgfCBfIC0+IHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdHJfaW5kICsgMykgZW5kX2luZCBjXG4gICAgICAgICAgZW5kXG4gICAgICAgIHwgJ3snIC0+XG4gICAgICAgICAgKCogJXsuLi4lfSBzdWItZm9ybWF0IGZvdW5kLiAqKVxuICAgICAgICAgIGxldCBzdWJfZW5kID0gc2VhcmNoX3N1YmZvcm1hdF9lbmQgKHN0cl9pbmQgKyAyKSBlbmRfaW5kICd9JyBpblxuICAgICAgICAgIHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdWJfZW5kICsgMikgZW5kX2luZCBjXG4gICAgICAgIHwgJygnIC0+XG4gICAgICAgICAgKCogJSguLi4lKSBzdWItZm9ybWF0IGZvdW5kLiAqKVxuICAgICAgICAgIGxldCBzdWJfZW5kID0gc2VhcmNoX3N1YmZvcm1hdF9lbmQgKHN0cl9pbmQgKyAyKSBlbmRfaW5kICcpJyBpblxuICAgICAgICAgIHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdWJfZW5kICsgMikgZW5kX2luZCBjXG4gICAgICAgIHwgJ30nIC0+XG4gICAgICAgICAgKCogRXJyb3I6ICUoLi4uJX0uICopXG4gICAgICAgICAgZXhwZWN0ZWRfY2hhcmFjdGVyIChzdHJfaW5kICsgMSkgXCJjaGFyYWN0ZXIgJyknXCIgJ30nXG4gICAgICAgIHwgJyknIC0+XG4gICAgICAgICAgKCogRXJyb3I6ICV7Li4uJSkuICopXG4gICAgICAgICAgZXhwZWN0ZWRfY2hhcmFjdGVyIChzdHJfaW5kICsgMSkgXCJjaGFyYWN0ZXIgJ30nXCIgJyknXG4gICAgICAgIHwgXyAtPlxuICAgICAgICAgIHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdHJfaW5kICsgMikgZW5kX2luZCBjXG4gICAgICAgIGVuZFxuICAgIHwgXyAtPiBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3RyX2luZCArIDEpIGVuZF9pbmQgY1xuXG4gICgqIENoZWNrIGlmIHN5bWIgaXMgYSB2YWxpZCBpbnQgY29udmVyc2lvbiBhZnRlciBcIiVsXCIsIFwiJW5cIiBvciBcIiVMXCIgKilcbiAgYW5kIGlzX2ludF9iYXNlIHN5bWIgPSBtYXRjaCBzeW1iIHdpdGhcbiAgICB8ICdkJyB8ICdpJyB8ICd4JyB8ICdYJyB8ICdvJyB8ICd1JyAtPiB0cnVlXG4gICAgfCBfIC0+IGZhbHNlXG5cbiAgKCogQ29udmVydCBhIGNoYXIgKGwsIG4gb3IgTCkgdG8gaXRzIGFzc29jaWF0ZWQgY291bnRlci4gKilcbiAgYW5kIGNvdW50ZXJfb2ZfY2hhciBzeW1iID0gbWF0Y2ggc3ltYiB3aXRoXG4gICAgfCAnbCcgLT4gTGluZV9jb3VudGVyICB8ICduJyAtPiBDaGFyX2NvdW50ZXJcbiAgICB8ICdMJyAtPiBUb2tlbl9jb3VudGVyIHwgXyAtPiBhc3NlcnQgZmFsc2VcblxuICAoKiBDb252ZXJ0IChwbHVzLCBzeW1iKSB0byBpdHMgYXNzb2NpYXRlZCBpbnRfY29udi4gKilcbiAgYW5kIGNvbXB1dGVfaW50X2NvbnYgcGN0X2luZCBzdHJfaW5kIHBsdXMgaGFzaCBzcGFjZSBzeW1iID1cbiAgICBtYXRjaCBwbHVzLCBoYXNoLCBzcGFjZSwgc3ltYiB3aXRoXG4gICAgfCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAnZCcgLT4gSW50X2QgIHwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgJ2knIC0+IEludF9pXG4gICAgfCBmYWxzZSwgZmFsc2UsICB0cnVlLCAnZCcgLT4gSW50X3NkIHwgZmFsc2UsIGZhbHNlLCAgdHJ1ZSwgJ2knIC0+IEludF9zaVxuICAgIHwgIHRydWUsIGZhbHNlLCBmYWxzZSwgJ2QnIC0+IEludF9wZCB8ICB0cnVlLCBmYWxzZSwgZmFsc2UsICdpJyAtPiBJbnRfcGlcbiAgICB8IGZhbHNlLCBmYWxzZSwgZmFsc2UsICd4JyAtPiBJbnRfeCAgfCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAnWCcgLT4gSW50X1hcbiAgICB8IGZhbHNlLCAgdHJ1ZSwgZmFsc2UsICd4JyAtPiBJbnRfQ3ggfCBmYWxzZSwgIHRydWUsIGZhbHNlLCAnWCcgLT4gSW50X0NYXG4gICAgfCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAnbycgLT4gSW50X29cbiAgICB8IGZhbHNlLCAgdHJ1ZSwgZmFsc2UsICdvJyAtPiBJbnRfQ29cbiAgICB8IGZhbHNlLCBmYWxzZSwgZmFsc2UsICd1JyAtPiBJbnRfdVxuICAgIHwgZmFsc2UsICB0cnVlLCBmYWxzZSwgJ2QnIC0+IEludF9DZFxuICAgIHwgZmFsc2UsICB0cnVlLCBmYWxzZSwgJ2knIC0+IEludF9DaVxuICAgIHwgZmFsc2UsICB0cnVlLCBmYWxzZSwgJ3UnIC0+IEludF9DdVxuICAgIHwgXywgdHJ1ZSwgXywgJ3gnIHdoZW4gbGVnYWN5X2JlaGF2aW9yIC0+IEludF9DeFxuICAgIHwgXywgdHJ1ZSwgXywgJ1gnIHdoZW4gbGVnYWN5X2JlaGF2aW9yIC0+IEludF9DWFxuICAgIHwgXywgdHJ1ZSwgXywgJ28nIHdoZW4gbGVnYWN5X2JlaGF2aW9yIC0+IEludF9Db1xuICAgIHwgXywgdHJ1ZSwgXywgKCdkJyB8ICdpJyB8ICd1JykgLT5cbiAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuICgqIGlnbm9yZSAqKVxuICAgICAgICBjb21wdXRlX2ludF9jb252IHBjdF9pbmQgc3RyX2luZCBwbHVzIGZhbHNlIHNwYWNlIHN5bWJcbiAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIHN5bWIgXCInIydcIlxuICAgIHwgdHJ1ZSwgXywgdHJ1ZSwgXyAtPlxuICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW5cbiAgICAgICAgKCogcGx1cyBhbmQgc3BhY2U6IGxlZ2FjeSBpbXBsZW1lbnRhdGlvbiBwcmVmZXJzIHBsdXMgKilcbiAgICAgICAgY29tcHV0ZV9pbnRfY29udiBwY3RfaW5kIHN0cl9pbmQgcGx1cyBoYXNoIGZhbHNlIHN5bWJcbiAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kICcgJyBcIicrJ1wiXG4gICAgfCBmYWxzZSwgXywgdHJ1ZSwgXyAgICAtPlxuICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW4gKCogaWdub3JlICopXG4gICAgICAgIGNvbXB1dGVfaW50X2NvbnYgcGN0X2luZCBzdHJfaW5kIHBsdXMgaGFzaCBmYWxzZSBzeW1iXG4gICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiJyAnXCJcbiAgICB8IHRydWUsIF8sIGZhbHNlLCBfICAgIC0+XG4gICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiAoKiBpZ25vcmUgKilcbiAgICAgICAgY29tcHV0ZV9pbnRfY29udiBwY3RfaW5kIHN0cl9pbmQgZmFsc2UgaGFzaCBzcGFjZSBzeW1iXG4gICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiJysnXCJcbiAgICB8IGZhbHNlLCBfLCBmYWxzZSwgXyAtPiBhc3NlcnQgZmFsc2VcblxuICAoKiBDb252ZXJ0IChwbHVzLCBzcGFjZSwgc3ltYikgdG8gaXRzIGFzc29jaWF0ZWQgZmxvYXRfY29udi4gKilcbiAgYW5kIGNvbXB1dGVfZmxvYXRfY29udiBwY3RfaW5kIHN0cl9pbmQgcGx1cyBoYXNoIHNwYWNlIHN5bWIgPVxuICAgIGxldCBmbGFnID0gbWF0Y2ggcGx1cywgc3BhY2Ugd2l0aFxuICAgIHwgZmFsc2UsIGZhbHNlIC0+IEZsb2F0X2ZsYWdfXG4gICAgfCBmYWxzZSwgIHRydWUgLT4gRmxvYXRfZmxhZ19zXG4gICAgfCAgdHJ1ZSwgZmFsc2UgLT4gRmxvYXRfZmxhZ19wXG4gICAgfCAgdHJ1ZSwgIHRydWUgLT5cbiAgICAgICgqIHBsdXMgYW5kIHNwYWNlOiBsZWdhY3kgaW1wbGVtZW50YXRpb24gcHJlZmVycyBwbHVzICopXG4gICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiBGbG9hdF9mbGFnX3BcbiAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kICcgJyBcIicrJ1wiIGluXG4gICAgbGV0IGtpbmQgPSBtYXRjaCBoYXNoLCBzeW1iIHdpdGhcbiAgICB8IF8sICdmJyAtPiBGbG9hdF9mXG4gICAgfCBfLCAnZScgLT4gRmxvYXRfZVxuICAgIHwgXywgJ0UnIC0+IEZsb2F0X0VcbiAgICB8IF8sICdnJyAtPiBGbG9hdF9nXG4gICAgfCBfLCAnRycgLT4gRmxvYXRfR1xuICAgIHwgXywgJ2gnIC0+IEZsb2F0X2hcbiAgICB8IF8sICdIJyAtPiBGbG9hdF9IXG4gICAgfCBmYWxzZSwgJ0YnIC0+IEZsb2F0X0ZcbiAgICB8IHRydWUsICdGJyAtPiBGbG9hdF9DRlxuICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UgaW5cbiAgICBmbGFnLCBraW5kXG5cbiAgKCogUmFpc2UgW0ZhaWx1cmVdIHdpdGggYSBmcmllbmRseSBlcnJvciBtZXNzYWdlIGFib3V0IGluY29tcGF0aWJsZSBvcHRpb25zLiopXG4gIGFuZCBpbmNvbXBhdGlibGVfZmxhZyA6IHR5cGUgYSAuIGludCAtPiBpbnQgLT4gY2hhciAtPiBzdHJpbmcgLT4gYSA9XG4gICAgZnVuIHBjdF9pbmQgc3RyX2luZCBzeW1iIG9wdGlvbiAtPlxuICAgICAgbGV0IHN1YmZtdCA9IFN0cmluZy5zdWIgc3RyIHBjdF9pbmQgKHN0cl9pbmQgLSBwY3RfaW5kKSBpblxuICAgICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgICBcImludmFsaWQgZm9ybWF0ICVTOiBhdCBjaGFyYWN0ZXIgbnVtYmVyICVkLCBcXFxuICAgICAgICAgJXMgaXMgaW5jb21wYXRpYmxlIHdpdGggJyVjJyBpbiBzdWItZm9ybWF0ICVTXCJcbiAgICAgICAgc3RyIHBjdF9pbmQgb3B0aW9uIHN5bWIgc3ViZm10XG5cbiAgaW4gcGFyc2UgMCAoU3RyaW5nLmxlbmd0aCBzdHIpXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAoKiBHdWFyZGVkIHN0cmluZyB0byBmb3JtYXQgY29udmVyc2lvbnMgKilcblxuKCogQ29udmVydCBhIHN0cmluZyB0byBhIGZvcm1hdCBhY2NvcmRpbmcgdG8gYW4gZm10dHkuICopXG4oKiBSYWlzZSBbRmFpbHVyZV0gd2l0aCBhbiBlcnJvciBtZXNzYWdlIGluIGNhc2Ugb2YgdHlwZSBtaXNtYXRjaC4gKilcbmxldCBmb3JtYXRfb2Zfc3RyaW5nX2ZtdHR5IHN0ciBmbXR0eSA9XG4gIGxldCBGbXRfRUJCIGZtdCA9IGZtdF9lYmJfb2Zfc3RyaW5nIHN0ciBpblxuICB0cnkgRm9ybWF0ICh0eXBlX2Zvcm1hdCBmbXQgZm10dHksIHN0cilcbiAgd2l0aCBUeXBlX21pc21hdGNoIC0+XG4gICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgXCJiYWQgaW5wdXQ6IGZvcm1hdCB0eXBlIG1pc21hdGNoIGJldHdlZW4gJVMgYW5kICVTXCJcbiAgICAgIHN0ciAoc3RyaW5nX29mX2ZtdHR5IGZtdHR5KVxuXG4oKiBDb252ZXJ0IGEgc3RyaW5nIHRvIGEgZm9ybWF0IGNvbXBhdGlibGUgd2l0aCBhbiBvdGhlciBmb3JtYXQuICopXG4oKiBSYWlzZSBbRmFpbHVyZV0gd2l0aCBhbiBlcnJvciBtZXNzYWdlIGluIGNhc2Ugb2YgdHlwZSBtaXNtYXRjaC4gKilcbmxldCBmb3JtYXRfb2Zfc3RyaW5nX2Zvcm1hdCBzdHIgKEZvcm1hdCAoZm10Jywgc3RyJykpID1cbiAgbGV0IEZtdF9FQkIgZm10ID0gZm10X2ViYl9vZl9zdHJpbmcgc3RyIGluXG4gIHRyeSBGb3JtYXQgKHR5cGVfZm9ybWF0IGZtdCAoZm10dHlfb2ZfZm10IGZtdCcpLCBzdHIpXG4gIHdpdGggVHlwZV9taXNtYXRjaCAtPlxuICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgIFwiYmFkIGlucHV0OiBmb3JtYXQgdHlwZSBtaXNtYXRjaCBiZXR3ZWVuICVTIGFuZCAlU1wiIHN0ciBzdHInXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIFhhdmllciBMZXJveSBhbmQgUGllcnJlIFdlaXMsIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbm9wZW4gQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzXG5vcGVuIENhbWxpbnRlcm5hbEZvcm1hdFxuXG5sZXQga2ZwcmludGYgayBvIChGb3JtYXQgKGZtdCwgXykpID1cbiAgbWFrZV9wcmludGYgKGZ1biBhY2MgLT4gb3V0cHV0X2FjYyBvIGFjYzsgayBvKSBFbmRfb2ZfYWNjIGZtdFxubGV0IGticHJpbnRmIGsgYiAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIG1ha2VfcHJpbnRmIChmdW4gYWNjIC0+IGJ1ZnB1dF9hY2MgYiBhY2M7IGsgYikgRW5kX29mX2FjYyBmbXRcbmxldCBpa2ZwcmludGYgayBvYyAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIG1ha2VfaXByaW50ZiBrIG9jIGZtdFxubGV0IGlrYnByaW50ZiA9IGlrZnByaW50ZlxuXG5sZXQgZnByaW50ZiBvYyBmbXQgPSBrZnByaW50ZiBpZ25vcmUgb2MgZm10XG5sZXQgYnByaW50ZiBiIGZtdCA9IGticHJpbnRmIGlnbm9yZSBiIGZtdFxubGV0IGlmcHJpbnRmIG9jIGZtdCA9IGlrZnByaW50ZiBpZ25vcmUgb2MgZm10XG5sZXQgaWJwcmludGYgYiBmbXQgPSBpa2JwcmludGYgaWdub3JlIGIgZm10XG5sZXQgcHJpbnRmIGZtdCA9IGZwcmludGYgc3Rkb3V0IGZtdFxubGV0IGVwcmludGYgZm10ID0gZnByaW50ZiBzdGRlcnIgZm10XG5cbmxldCBrc3ByaW50ZiBrIChGb3JtYXQgKGZtdCwgXykpID1cbiAgbGV0IGsnIGFjYyA9XG4gICAgbGV0IGJ1ZiA9IEJ1ZmZlci5jcmVhdGUgNjQgaW5cbiAgICBzdHJwdXRfYWNjIGJ1ZiBhY2M7XG4gICAgayAoQnVmZmVyLmNvbnRlbnRzIGJ1ZikgaW5cbiAgbWFrZV9wcmludGYgaycgRW5kX29mX2FjYyBmbXRcblxubGV0IHNwcmludGYgZm10ID0ga3NwcmludGYgKGZ1biBzIC0+IHMpIGZtdFxuXG5sZXQga3ByaW50ZiA9IGtzcHJpbnRmXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgRGFtaWVuIERvbGlnZXosIHByb2pldCBQYXJhLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUga2V5ID0gc3RyaW5nXG50eXBlIGRvYyA9IHN0cmluZ1xudHlwZSB1c2FnZV9tc2cgPSBzdHJpbmdcbnR5cGUgYW5vbl9mdW4gPSAoc3RyaW5nIC0+IHVuaXQpXG5cbnR5cGUgc3BlYyA9XG4gIHwgVW5pdCBvZiAodW5pdCAtPiB1bml0KSAgICAgKCogQ2FsbCB0aGUgZnVuY3Rpb24gd2l0aCB1bml0IGFyZ3VtZW50ICopXG4gIHwgQm9vbCBvZiAoYm9vbCAtPiB1bml0KSAgICAgKCogQ2FsbCB0aGUgZnVuY3Rpb24gd2l0aCBhIGJvb2wgYXJndW1lbnQgKilcbiAgfCBTZXQgb2YgYm9vbCByZWYgICAgICAgICAgICAoKiBTZXQgdGhlIHJlZmVyZW5jZSB0byB0cnVlICopXG4gIHwgQ2xlYXIgb2YgYm9vbCByZWYgICAgICAgICAgKCogU2V0IHRoZSByZWZlcmVuY2UgdG8gZmFsc2UgKilcbiAgfCBTdHJpbmcgb2YgKHN0cmluZyAtPiB1bml0KSAoKiBDYWxsIHRoZSBmdW5jdGlvbiB3aXRoIGEgc3RyaW5nIGFyZ3VtZW50ICopXG4gIHwgU2V0X3N0cmluZyBvZiBzdHJpbmcgcmVmICAgKCogU2V0IHRoZSByZWZlcmVuY2UgdG8gdGhlIHN0cmluZyBhcmd1bWVudCAqKVxuICB8IEludCBvZiAoaW50IC0+IHVuaXQpICAgICAgICgqIENhbGwgdGhlIGZ1bmN0aW9uIHdpdGggYW4gaW50IGFyZ3VtZW50ICopXG4gIHwgU2V0X2ludCBvZiBpbnQgcmVmICAgICAgICAgKCogU2V0IHRoZSByZWZlcmVuY2UgdG8gdGhlIGludCBhcmd1bWVudCAqKVxuICB8IEZsb2F0IG9mIChmbG9hdCAtPiB1bml0KSAgICgqIENhbGwgdGhlIGZ1bmN0aW9uIHdpdGggYSBmbG9hdCBhcmd1bWVudCAqKVxuICB8IFNldF9mbG9hdCBvZiBmbG9hdCByZWYgICAgICgqIFNldCB0aGUgcmVmZXJlbmNlIHRvIHRoZSBmbG9hdCBhcmd1bWVudCAqKVxuICB8IFR1cGxlIG9mIHNwZWMgbGlzdCAgICAgICAgICgqIFRha2Ugc2V2ZXJhbCBhcmd1bWVudHMgYWNjb3JkaW5nIHRvIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwZWMgbGlzdCAqKVxuICB8IFN5bWJvbCBvZiBzdHJpbmcgbGlzdCAqIChzdHJpbmcgLT4gdW5pdClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBUYWtlIG9uZSBvZiB0aGUgc3ltYm9scyBhcyBhcmd1bWVudCBhbmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsIHRoZSBmdW5jdGlvbiB3aXRoIHRoZSBzeW1ib2wuICopXG4gIHwgUmVzdCBvZiAoc3RyaW5nIC0+IHVuaXQpICAgKCogU3RvcCBpbnRlcnByZXRpbmcga2V5d29yZHMgYW5kIGNhbGwgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gd2l0aCBlYWNoIHJlbWFpbmluZyBhcmd1bWVudCAqKVxuICB8IFJlc3RfYWxsIG9mIChzdHJpbmcgbGlzdCAtPiB1bml0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIFN0b3AgaW50ZXJwcmV0aW5nIGtleXdvcmRzIGFuZCBjYWxsIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHdpdGggYWxsIHJlbWFpbmluZyBhcmd1bWVudHMuICopXG4gIHwgRXhwYW5kIG9mIChzdHJpbmcgLT4gc3RyaW5nIGFycmF5KSAoKiBJZiB0aGUgcmVtYWluaW5nIGFyZ3VtZW50cyB0byBwcm9jZXNzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmUgb2YgdGhlIGZvcm1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtbXCItZm9vXCI7IFwiYXJnXCJdIEAgcmVzdF0gd2hlcmUgXCJmb29cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXMgcmVnaXN0ZXJlZCBhcyBbRXhwYW5kIGZdLCB0aGVuIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzIFtmIFwiYXJnXCIgQCByZXN0XSBhcmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3NlZC4gT25seSBhbGxvd2VkIGluXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbcGFyc2VfYW5kX2V4cGFuZF9hcmd2X2R5bmFtaWNdLiAqKVxuXG5leGNlcHRpb24gQmFkIG9mIHN0cmluZ1xuZXhjZXB0aW9uIEhlbHAgb2Ygc3RyaW5nXG5cbnR5cGUgZXJyb3IgPVxuICB8IFVua25vd24gb2Ygc3RyaW5nXG4gIHwgV3Jvbmcgb2Ygc3RyaW5nICogc3RyaW5nICogc3RyaW5nICAoKiBvcHRpb24sIGFjdHVhbCwgZXhwZWN0ZWQgKilcbiAgfCBNaXNzaW5nIG9mIHN0cmluZ1xuICB8IE1lc3NhZ2Ugb2Ygc3RyaW5nXG5cbmV4Y2VwdGlvbiBTdG9wIG9mIGVycm9yICgqIHVzZWQgaW50ZXJuYWxseSAqKVxuXG5vcGVuIFByaW50ZlxuXG5sZXQgcmVjIGFzc29jMyB4IGwgPVxuICBtYXRjaCBsIHdpdGhcbiAgfCBbXSAtPiByYWlzZSBOb3RfZm91bmRcbiAgfCAoeTEsIHkyLCBfKSA6OiBfIHdoZW4geTEgPSB4IC0+IHkyXG4gIHwgXyA6OiB0IC0+IGFzc29jMyB4IHRcblxuXG5sZXQgc3BsaXQgcyA9XG4gIGxldCBpID0gU3RyaW5nLmluZGV4IHMgJz0nIGluXG4gIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgU3RyaW5nLnN1YiBzIDAgaSwgU3RyaW5nLnN1YiBzIChpKzEpIChsZW4tKGkrMSkpXG5cblxubGV0IG1ha2Vfc3ltbGlzdCBwcmVmaXggc2VwIHN1ZmZpeCBsID1cbiAgbWF0Y2ggbCB3aXRoXG4gIHwgW10gLT4gXCI8bm9uZT5cIlxuICB8IGg6OnQgLT4gKExpc3QuZm9sZF9sZWZ0IChmdW4geCB5IC0+IHggXiBzZXAgXiB5KSAocHJlZml4IF4gaCkgdCkgXiBzdWZmaXhcblxuXG5sZXQgcHJpbnRfc3BlYyBidWYgKGtleSwgc3BlYywgZG9jKSA9XG4gIGlmIFN0cmluZy5sZW5ndGggZG9jID4gMCB0aGVuXG4gICAgbWF0Y2ggc3BlYyB3aXRoXG4gICAgfCBTeW1ib2wgKGwsIF8pIC0+XG4gICAgICAgIGJwcmludGYgYnVmIFwiICAlcyAlcyVzXFxuXCIga2V5IChtYWtlX3N5bWxpc3QgXCJ7XCIgXCJ8XCIgXCJ9XCIgbCkgZG9jXG4gICAgfCBfIC0+XG4gICAgICAgIGJwcmludGYgYnVmIFwiICAlcyAlc1xcblwiIGtleSBkb2NcblxuXG5sZXQgaGVscF9hY3Rpb24gKCkgPSByYWlzZSAoU3RvcCAoVW5rbm93biBcIi1oZWxwXCIpKVxuXG5sZXQgYWRkX2hlbHAgc3BlY2xpc3QgPVxuICBsZXQgYWRkMSA9XG4gICAgdHJ5IGlnbm9yZSAoYXNzb2MzIFwiLWhlbHBcIiBzcGVjbGlzdCk7IFtdXG4gICAgd2l0aCBOb3RfZm91bmQgLT5cbiAgICAgICAgICAgIFtcIi1oZWxwXCIsIFVuaXQgaGVscF9hY3Rpb24sIFwiIERpc3BsYXkgdGhpcyBsaXN0IG9mIG9wdGlvbnNcIl1cbiAgYW5kIGFkZDIgPVxuICAgIHRyeSBpZ25vcmUgKGFzc29jMyBcIi0taGVscFwiIHNwZWNsaXN0KTsgW11cbiAgICB3aXRoIE5vdF9mb3VuZCAtPlxuICAgICAgICAgICAgW1wiLS1oZWxwXCIsIFVuaXQgaGVscF9hY3Rpb24sIFwiIERpc3BsYXkgdGhpcyBsaXN0IG9mIG9wdGlvbnNcIl1cbiAgaW5cbiAgc3BlY2xpc3QgQCAoYWRkMSBAIGFkZDIpXG5cblxubGV0IHVzYWdlX2IgYnVmIHNwZWNsaXN0IGVycm1zZyA9XG4gIGJwcmludGYgYnVmIFwiJXNcXG5cIiBlcnJtc2c7XG4gIExpc3QuaXRlciAocHJpbnRfc3BlYyBidWYpIChhZGRfaGVscCBzcGVjbGlzdClcblxuXG5sZXQgdXNhZ2Vfc3RyaW5nIHNwZWNsaXN0IGVycm1zZyA9XG4gIGxldCBiID0gQnVmZmVyLmNyZWF0ZSAyMDAgaW5cbiAgdXNhZ2VfYiBiIHNwZWNsaXN0IGVycm1zZztcbiAgQnVmZmVyLmNvbnRlbnRzIGJcblxuXG5sZXQgdXNhZ2Ugc3BlY2xpc3QgZXJybXNnID1cbiAgZXByaW50ZiBcIiVzXCIgKHVzYWdlX3N0cmluZyBzcGVjbGlzdCBlcnJtc2cpXG5cblxubGV0IGN1cnJlbnQgPSByZWYgMFxuXG5sZXQgYm9vbF9vZl9zdHJpbmdfb3B0IHggPVxuICB0cnkgU29tZSAoYm9vbF9vZl9zdHJpbmcgeClcbiAgd2l0aCBJbnZhbGlkX2FyZ3VtZW50IF8gLT4gTm9uZVxuXG5sZXQgaW50X29mX3N0cmluZ19vcHQgeCA9XG4gIHRyeSBTb21lIChpbnRfb2Zfc3RyaW5nIHgpXG4gIHdpdGggRmFpbHVyZSBfIC0+IE5vbmVcblxubGV0IGZsb2F0X29mX3N0cmluZ19vcHQgeCA9XG4gIHRyeSBTb21lIChmbG9hdF9vZl9zdHJpbmcgeClcbiAgd2l0aCBGYWlsdXJlIF8gLT4gTm9uZVxuXG5sZXQgcGFyc2VfYW5kX2V4cGFuZF9hcmd2X2R5bmFtaWNfYXV4IGFsbG93X2V4cGFuZCBjdXJyZW50IGFyZ3Ygc3BlY2xpc3QgYW5vbmZ1blxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJtc2cgPVxuICBsZXQgaW5pdHBvcyA9ICFjdXJyZW50IGluXG4gIGxldCBjb252ZXJ0X2Vycm9yIGVycm9yID1cbiAgICAoKiBjb252ZXJ0IGFuIGludGVybmFsIGVycm9yIHRvIGEgQmFkL0hlbHAgZXhjZXB0aW9uXG4gICAgICAgKm9yKiBhZGQgdGhlIHByb2dyYW0gbmFtZSBhcyBhIHByZWZpeCBhbmQgdGhlIHVzYWdlIG1lc3NhZ2UgYXMgYSBzdWZmaXhcbiAgICAgICB0byBhbiB1c2VyLXJhaXNlZCBCYWQgZXhjZXB0aW9uLlxuICAgICopXG4gICAgbGV0IGIgPSBCdWZmZXIuY3JlYXRlIDIwMCBpblxuICAgIGxldCBwcm9nbmFtZSA9XG4gICAgICBpZiBpbml0cG9zIDwgKEFycmF5Lmxlbmd0aCAhYXJndikgdGhlbiAhYXJndi4oaW5pdHBvcykgZWxzZSBcIig/KVwiIGluXG4gICAgYmVnaW4gbWF0Y2ggZXJyb3Igd2l0aFxuICAgICAgfCBVbmtub3duIFwiLWhlbHBcIiAtPiAoKVxuICAgICAgfCBVbmtub3duIFwiLS1oZWxwXCIgLT4gKClcbiAgICAgIHwgVW5rbm93biBzIC0+XG4gICAgICAgICAgYnByaW50ZiBiIFwiJXM6IHVua25vd24gb3B0aW9uICclcycuXFxuXCIgcHJvZ25hbWUgc1xuICAgICAgfCBNaXNzaW5nIHMgLT5cbiAgICAgICAgICBicHJpbnRmIGIgXCIlczogb3B0aW9uICclcycgbmVlZHMgYW4gYXJndW1lbnQuXFxuXCIgcHJvZ25hbWUgc1xuICAgICAgfCBXcm9uZyAob3B0LCBhcmcsIGV4cGVjdGVkKSAtPlxuICAgICAgICAgIGJwcmludGYgYiBcIiVzOiB3cm9uZyBhcmd1bWVudCAnJXMnOyBvcHRpb24gJyVzJyBleHBlY3RzICVzLlxcblwiXG4gICAgICAgICAgICAgICAgICBwcm9nbmFtZSBhcmcgb3B0IGV4cGVjdGVkXG4gICAgICB8IE1lc3NhZ2UgcyAtPiAoKiB1c2VyIGVycm9yIG1lc3NhZ2UgKilcbiAgICAgICAgICBicHJpbnRmIGIgXCIlczogJXMuXFxuXCIgcHJvZ25hbWUgc1xuICAgIGVuZDtcbiAgICB1c2FnZV9iIGIgIXNwZWNsaXN0IGVycm1zZztcbiAgICBpZiBlcnJvciA9IFVua25vd24gXCItaGVscFwiIHx8IGVycm9yID0gVW5rbm93biBcIi0taGVscFwiXG4gICAgdGhlbiBIZWxwIChCdWZmZXIuY29udGVudHMgYilcbiAgICBlbHNlIEJhZCAoQnVmZmVyLmNvbnRlbnRzIGIpXG4gIGluXG4gIGluY3IgY3VycmVudDtcbiAgd2hpbGUgIWN1cnJlbnQgPCAoQXJyYXkubGVuZ3RoICFhcmd2KSBkb1xuICAgIGJlZ2luIHRyeVxuICAgICAgbGV0IHMgPSAhYXJndi4oIWN1cnJlbnQpIGluXG4gICAgICBpZiBTdHJpbmcubGVuZ3RoIHMgPj0gMSAmJiBzLlswXSA9ICctJyB0aGVuIGJlZ2luXG4gICAgICAgIGxldCBhY3Rpb24sIGZvbGxvdyA9XG4gICAgICAgICAgdHJ5IGFzc29jMyBzICFzcGVjbGlzdCwgTm9uZVxuICAgICAgICAgIHdpdGggTm90X2ZvdW5kIC0+XG4gICAgICAgICAgdHJ5XG4gICAgICAgICAgICBsZXQga2V5d29yZCwgYXJnID0gc3BsaXQgcyBpblxuICAgICAgICAgICAgYXNzb2MzIGtleXdvcmQgIXNwZWNsaXN0LCBTb21lIGFyZ1xuICAgICAgICAgIHdpdGggTm90X2ZvdW5kIC0+IHJhaXNlIChTdG9wIChVbmtub3duIHMpKVxuICAgICAgICBpblxuICAgICAgICBsZXQgbm9fYXJnICgpID1cbiAgICAgICAgICBtYXRjaCBmb2xsb3cgd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPiAoKVxuICAgICAgICAgIHwgU29tZSBhcmcgLT4gcmFpc2UgKFN0b3AgKFdyb25nIChzLCBhcmcsIFwibm8gYXJndW1lbnRcIikpKSBpblxuICAgICAgICBsZXQgZ2V0X2FyZyAoKSA9XG4gICAgICAgICAgbWF0Y2ggZm9sbG93IHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgICAgaWYgIWN1cnJlbnQgKyAxIDwgKEFycmF5Lmxlbmd0aCAhYXJndikgdGhlbiAhYXJndi4oIWN1cnJlbnQgKyAxKVxuICAgICAgICAgICAgICBlbHNlIHJhaXNlIChTdG9wIChNaXNzaW5nIHMpKVxuICAgICAgICAgIHwgU29tZSBhcmcgLT4gYXJnXG4gICAgICAgIGluXG4gICAgICAgIGxldCBjb25zdW1lX2FyZyAoKSA9XG4gICAgICAgICAgbWF0Y2ggZm9sbG93IHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gaW5jciBjdXJyZW50XG4gICAgICAgICAgfCBTb21lIF8gLT4gKClcbiAgICAgICAgaW5cbiAgICAgICAgbGV0IHJlYyB0cmVhdF9hY3Rpb24gPSBmdW5jdGlvblxuICAgICAgICB8IFVuaXQgZiAtPiBub19hcmcgKCk7IGYgKCk7XG4gICAgICAgIHwgQm9vbCBmIC0+XG4gICAgICAgICAgICBsZXQgYXJnID0gZ2V0X2FyZyAoKSBpblxuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggYm9vbF9vZl9zdHJpbmdfb3B0IGFyZyB3aXRoXG4gICAgICAgICAgICB8IE5vbmUgLT4gcmFpc2UgKFN0b3AgKFdyb25nIChzLCBhcmcsIFwiYSBib29sZWFuXCIpKSlcbiAgICAgICAgICAgIHwgU29tZSBzIC0+IGYgc1xuICAgICAgICAgICAgZW5kO1xuICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgIHwgU2V0IHIgLT4gbm9fYXJnICgpOyByIDo9IHRydWU7XG4gICAgICAgIHwgQ2xlYXIgciAtPiBub19hcmcgKCk7IHIgOj0gZmFsc2U7XG4gICAgICAgIHwgU3RyaW5nIGYgLT5cbiAgICAgICAgICAgIGxldCBhcmcgPSBnZXRfYXJnICgpIGluXG4gICAgICAgICAgICBmIGFyZztcbiAgICAgICAgICAgIGNvbnN1bWVfYXJnICgpO1xuICAgICAgICB8IFN5bWJvbCAoc3ltYiwgZikgLT5cbiAgICAgICAgICAgIGxldCBhcmcgPSBnZXRfYXJnICgpIGluXG4gICAgICAgICAgICBpZiBMaXN0Lm1lbSBhcmcgc3ltYiB0aGVuIGJlZ2luXG4gICAgICAgICAgICAgIGYgYXJnO1xuICAgICAgICAgICAgICBjb25zdW1lX2FyZyAoKTtcbiAgICAgICAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgICAgICAgIHJhaXNlIChTdG9wIChXcm9uZyAocywgYXJnLCBcIm9uZSBvZjogXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF4gKG1ha2Vfc3ltbGlzdCBcIlwiIFwiIFwiIFwiXCIgc3ltYikpKSlcbiAgICAgICAgICAgIGVuZFxuICAgICAgICB8IFNldF9zdHJpbmcgciAtPlxuICAgICAgICAgICAgciA6PSBnZXRfYXJnICgpO1xuICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgIHwgSW50IGYgLT5cbiAgICAgICAgICAgIGxldCBhcmcgPSBnZXRfYXJnICgpIGluXG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBpbnRfb2Zfc3RyaW5nX29wdCBhcmcgd2l0aFxuICAgICAgICAgICAgfCBOb25lIC0+IHJhaXNlIChTdG9wIChXcm9uZyAocywgYXJnLCBcImFuIGludGVnZXJcIikpKVxuICAgICAgICAgICAgfCBTb21lIHggLT4gZiB4XG4gICAgICAgICAgICBlbmQ7XG4gICAgICAgICAgICBjb25zdW1lX2FyZyAoKTtcbiAgICAgICAgfCBTZXRfaW50IHIgLT5cbiAgICAgICAgICAgIGxldCBhcmcgPSBnZXRfYXJnICgpIGluXG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBpbnRfb2Zfc3RyaW5nX29wdCBhcmcgd2l0aFxuICAgICAgICAgICAgfCBOb25lIC0+IHJhaXNlIChTdG9wIChXcm9uZyAocywgYXJnLCBcImFuIGludGVnZXJcIikpKVxuICAgICAgICAgICAgfCBTb21lIHggLT4gciA6PSB4XG4gICAgICAgICAgICBlbmQ7XG4gICAgICAgICAgICBjb25zdW1lX2FyZyAoKTtcbiAgICAgICAgfCBGbG9hdCBmIC0+XG4gICAgICAgICAgICBsZXQgYXJnID0gZ2V0X2FyZyAoKSBpblxuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggZmxvYXRfb2Zfc3RyaW5nX29wdCBhcmcgd2l0aFxuICAgICAgICAgICAgfCBOb25lIC0+IHJhaXNlIChTdG9wIChXcm9uZyAocywgYXJnLCBcImEgZmxvYXRcIikpKVxuICAgICAgICAgICAgfCBTb21lIHggLT4gZiB4XG4gICAgICAgICAgICBlbmQ7XG4gICAgICAgICAgICBjb25zdW1lX2FyZyAoKTtcbiAgICAgICAgfCBTZXRfZmxvYXQgciAtPlxuICAgICAgICAgICAgbGV0IGFyZyA9IGdldF9hcmcgKCkgaW5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIGZsb2F0X29mX3N0cmluZ19vcHQgYXJnIHdpdGhcbiAgICAgICAgICAgIHwgTm9uZSAtPiByYWlzZSAoU3RvcCAoV3JvbmcgKHMsIGFyZywgXCJhIGZsb2F0XCIpKSlcbiAgICAgICAgICAgIHwgU29tZSB4IC0+IHIgOj0geFxuICAgICAgICAgICAgZW5kO1xuICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgIHwgVHVwbGUgc3BlY3MgLT5cbiAgICAgICAgICAgIG5vX2FyZyAoKTtcbiAgICAgICAgICAgIExpc3QuaXRlciB0cmVhdF9hY3Rpb24gc3BlY3M7XG4gICAgICAgIHwgUmVzdCBmIC0+XG4gICAgICAgICAgICBub19hcmcgKCk7XG4gICAgICAgICAgICB3aGlsZSAhY3VycmVudCA8IChBcnJheS5sZW5ndGggIWFyZ3YpIC0gMSBkb1xuICAgICAgICAgICAgICBmICFhcmd2LighY3VycmVudCArIDEpO1xuICAgICAgICAgICAgICBjb25zdW1lX2FyZyAoKTtcbiAgICAgICAgICAgIGRvbmU7XG4gICAgICAgIHwgUmVzdF9hbGwgZiAtPlxuICAgICAgICAgICAgbm9fYXJnICgpO1xuICAgICAgICAgICAgbGV0IGFjYyA9IHJlZiBbXSBpblxuICAgICAgICAgICAgd2hpbGUgIWN1cnJlbnQgPCBBcnJheS5sZW5ndGggIWFyZ3YgLSAxIGRvXG4gICAgICAgICAgICAgIGFjYyA6PSAhYXJndi4oIWN1cnJlbnQgKyAxKSA6OiAhYWNjO1xuICAgICAgICAgICAgICBjb25zdW1lX2FyZyAoKTtcbiAgICAgICAgICAgIGRvbmU7XG4gICAgICAgICAgICBmIChMaXN0LnJldiAhYWNjKVxuICAgICAgICB8IEV4cGFuZCBmIC0+XG4gICAgICAgICAgICBpZiBub3QgYWxsb3dfZXhwYW5kIHRoZW5cbiAgICAgICAgICAgICAgcmFpc2UgKEludmFsaWRfYXJndW1lbnQgXCJBcmcuRXhwYW5kIGlzIGlzIG9ubHkgYWxsb3dlZCB3aXRoIFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBcmcucGFyc2VfYW5kX2V4cGFuZF9hcmd2X2R5bmFtaWNcIik7XG4gICAgICAgICAgICBsZXQgYXJnID0gZ2V0X2FyZyAoKSBpblxuICAgICAgICAgICAgbGV0IG5ld2FyZyA9IGYgYXJnIGluXG4gICAgICAgICAgICBjb25zdW1lX2FyZyAoKTtcbiAgICAgICAgICAgIGxldCBiZWZvcmUgPSBBcnJheS5zdWIgIWFyZ3YgMCAoIWN1cnJlbnQgKyAxKVxuICAgICAgICAgICAgYW5kIGFmdGVyID1cbiAgICAgICAgICAgICAgQXJyYXkuc3ViICFhcmd2ICghY3VycmVudCArIDEpXG4gICAgICAgICAgICAgICAgICAgICAgICAoKEFycmF5Lmxlbmd0aCAhYXJndikgLSAhY3VycmVudCAtIDEpIGluXG4gICAgICAgICAgICBhcmd2Oj0gQXJyYXkuY29uY2F0IFtiZWZvcmU7bmV3YXJnO2FmdGVyXTtcbiAgICAgICAgaW5cbiAgICAgICAgdHJlYXRfYWN0aW9uIGFjdGlvbiBlbmRcbiAgICAgIGVsc2UgYW5vbmZ1biBzXG4gICAgd2l0aCB8IEJhZCBtIC0+IHJhaXNlIChjb252ZXJ0X2Vycm9yIChNZXNzYWdlIG0pKTtcbiAgICAgICAgIHwgU3RvcCBlIC0+IHJhaXNlIChjb252ZXJ0X2Vycm9yIGUpO1xuICAgIGVuZDtcbiAgICBpbmNyIGN1cnJlbnRcbiAgZG9uZVxuXG5sZXQgcGFyc2VfYW5kX2V4cGFuZF9hcmd2X2R5bmFtaWMgY3VycmVudCBhcmd2IHNwZWNsaXN0IGFub25mdW4gZXJybXNnID1cbiAgcGFyc2VfYW5kX2V4cGFuZF9hcmd2X2R5bmFtaWNfYXV4IHRydWUgY3VycmVudCBhcmd2IHNwZWNsaXN0IGFub25mdW4gZXJybXNnXG5cbmxldCBwYXJzZV9hcmd2X2R5bmFtaWMgPyhjdXJyZW50PWN1cnJlbnQpIGFyZ3Ygc3BlY2xpc3QgYW5vbmZ1biBlcnJtc2cgPVxuICBwYXJzZV9hbmRfZXhwYW5kX2FyZ3ZfZHluYW1pY19hdXggZmFsc2UgY3VycmVudCAocmVmIGFyZ3YpIHNwZWNsaXN0IGFub25mdW5cbiAgICBlcnJtc2dcblxuXG5sZXQgcGFyc2VfYXJndiA/KGN1cnJlbnQ9Y3VycmVudCkgYXJndiBzcGVjbGlzdCBhbm9uZnVuIGVycm1zZyA9XG4gIHBhcnNlX2FyZ3ZfZHluYW1pYyB+Y3VycmVudDpjdXJyZW50IGFyZ3YgKHJlZiBzcGVjbGlzdCkgYW5vbmZ1biBlcnJtc2dcblxuXG5sZXQgcGFyc2UgbCBmIG1zZyA9XG4gIHRyeVxuICAgIHBhcnNlX2FyZ3YgU3lzLmFyZ3YgbCBmIG1zZ1xuICB3aXRoXG4gIHwgQmFkIG1zZyAtPiBlcHJpbnRmIFwiJXNcIiBtc2c7IGV4aXQgMlxuICB8IEhlbHAgbXNnIC0+IHByaW50ZiBcIiVzXCIgbXNnOyBleGl0IDBcblxuXG5sZXQgcGFyc2VfZHluYW1pYyBsIGYgbXNnID1cbiAgdHJ5XG4gICAgcGFyc2VfYXJndl9keW5hbWljIFN5cy5hcmd2IGwgZiBtc2dcbiAgd2l0aFxuICB8IEJhZCBtc2cgLT4gZXByaW50ZiBcIiVzXCIgbXNnOyBleGl0IDJcbiAgfCBIZWxwIG1zZyAtPiBwcmludGYgXCIlc1wiIG1zZzsgZXhpdCAwXG5cbmxldCBwYXJzZV9leHBhbmQgbCBmIG1zZyA9XG4gIHRyeVxuICAgIGxldCBhcmd2ID0gcmVmIFN5cy5hcmd2IGluXG4gICAgbGV0IHNwZWMgPSByZWYgbCBpblxuICAgIGxldCBjdXJyZW50ID0gcmVmICghY3VycmVudCkgaW5cbiAgICBwYXJzZV9hbmRfZXhwYW5kX2FyZ3ZfZHluYW1pYyBjdXJyZW50IGFyZ3Ygc3BlYyBmIG1zZ1xuICB3aXRoXG4gIHwgQmFkIG1zZyAtPiBlcHJpbnRmIFwiJXNcIiBtc2c7IGV4aXQgMlxuICB8IEhlbHAgbXNnIC0+IHByaW50ZiBcIiVzXCIgbXNnOyBleGl0IDBcblxuXG5sZXQgc2Vjb25kX3dvcmQgcyA9XG4gIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgbGV0IHJlYyBsb29wIG4gPVxuICAgIGlmIG4gPj0gbGVuIHRoZW4gbGVuXG4gICAgZWxzZSBpZiBzLltuXSA9ICcgJyB0aGVuIGxvb3AgKG4rMSlcbiAgICBlbHNlIG5cbiAgaW5cbiAgbWF0Y2ggU3RyaW5nLmluZGV4IHMgJ1xcdCcgd2l0aFxuICB8IG4gLT4gbG9vcCAobisxKVxuICB8IGV4Y2VwdGlvbiBOb3RfZm91bmQgLT5cbiAgICAgIGJlZ2luIG1hdGNoIFN0cmluZy5pbmRleCBzICcgJyB3aXRoXG4gICAgICB8IG4gLT4gbG9vcCAobisxKVxuICAgICAgfCBleGNlcHRpb24gTm90X2ZvdW5kIC0+IGxlblxuICAgICAgZW5kXG5cblxubGV0IG1heF9hcmdfbGVuIGN1ciAoa3dkLCBzcGVjLCBkb2MpID1cbiAgbWF0Y2ggc3BlYyB3aXRoXG4gIHwgU3ltYm9sIF8gLT4gSW50Lm1heCBjdXIgKFN0cmluZy5sZW5ndGgga3dkKVxuICB8IF8gLT4gSW50Lm1heCBjdXIgKFN0cmluZy5sZW5ndGgga3dkICsgc2Vjb25kX3dvcmQgZG9jKVxuXG5cbmxldCByZXBsYWNlX2xlYWRpbmdfdGFiIHMgPVxuICBsZXQgc2VlbiA9IHJlZiBmYWxzZSBpblxuICBTdHJpbmcubWFwIChmdW5jdGlvbiAnXFx0JyB3aGVuIG5vdCAhc2VlbiAtPiBzZWVuIDo9IHRydWU7ICcgJyB8IGMgLT4gYykgc1xuXG5sZXQgYWRkX3BhZGRpbmcgbGVuIGtzZCA9XG4gIG1hdGNoIGtzZCB3aXRoXG4gIHwgKF8sIF8sIFwiXCIpIC0+XG4gICAgICAoKiBEbyBub3QgcGFkIHVuZG9jdW1lbnRlZCBvcHRpb25zLCBzbyB0aGF0IHRoZXkgc3RpbGwgZG9uJ3Qgc2hvdyB1cCB3aGVuXG4gICAgICAgKiBydW4gdGhyb3VnaCBbdXNhZ2VdIG9yIFtwYXJzZV0uICopXG4gICAgICBrc2RcbiAgfCAoa3dkLCAoU3ltYm9sIF8gYXMgc3BlYyksIG1zZykgLT5cbiAgICAgIGxldCBjdXRjb2wgPSBzZWNvbmRfd29yZCBtc2cgaW5cbiAgICAgIGxldCBzcGFjZXMgPSBTdHJpbmcubWFrZSAoKEludC5tYXggMCAobGVuIC0gY3V0Y29sKSkgKyAzKSAnICcgaW5cbiAgICAgIChrd2QsIHNwZWMsIFwiXFxuXCIgXiBzcGFjZXMgXiByZXBsYWNlX2xlYWRpbmdfdGFiIG1zZylcbiAgfCAoa3dkLCBzcGVjLCBtc2cpIC0+XG4gICAgICBsZXQgY3V0Y29sID0gc2Vjb25kX3dvcmQgbXNnIGluXG4gICAgICBsZXQga3dkX2xlbiA9IFN0cmluZy5sZW5ndGgga3dkIGluXG4gICAgICBsZXQgZGlmZiA9IGxlbiAtIGt3ZF9sZW4gLSBjdXRjb2wgaW5cbiAgICAgIGlmIGRpZmYgPD0gMCB0aGVuXG4gICAgICAgIChrd2QsIHNwZWMsIHJlcGxhY2VfbGVhZGluZ190YWIgbXNnKVxuICAgICAgZWxzZVxuICAgICAgICBsZXQgc3BhY2VzID0gU3RyaW5nLm1ha2UgZGlmZiAnICcgaW5cbiAgICAgICAgbGV0IHByZWZpeCA9IFN0cmluZy5zdWIgKHJlcGxhY2VfbGVhZGluZ190YWIgbXNnKSAwIGN1dGNvbCBpblxuICAgICAgICBsZXQgc3VmZml4ID0gU3RyaW5nLnN1YiBtc2cgY3V0Y29sIChTdHJpbmcubGVuZ3RoIG1zZyAtIGN1dGNvbCkgaW5cbiAgICAgICAgKGt3ZCwgc3BlYywgcHJlZml4IF4gc3BhY2VzIF4gc3VmZml4KVxuXG5cbmxldCBhbGlnbiA/KGxpbWl0PW1heF9pbnQpIHNwZWNsaXN0ID1cbiAgbGV0IGNvbXBsZXRlZCA9IGFkZF9oZWxwIHNwZWNsaXN0IGluXG4gIGxldCBsZW4gPSBMaXN0LmZvbGRfbGVmdCBtYXhfYXJnX2xlbiAwIGNvbXBsZXRlZCBpblxuICBsZXQgbGVuID0gSW50Lm1pbiBsZW4gbGltaXQgaW5cbiAgTGlzdC5tYXAgKGFkZF9wYWRkaW5nIGxlbikgY29tcGxldGVkXG5cbmxldCB0cmltX2NyIHMgPVxuICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gIGlmIGxlbiA+IDAgJiYgU3RyaW5nLmdldCBzIChsZW4gLSAxKSA9ICdcXHInIHRoZW5cbiAgICBTdHJpbmcuc3ViIHMgMCAobGVuIC0gMSlcbiAgZWxzZVxuICAgIHNcblxubGV0IHJlYWRfYXV4IHRyaW0gc2VwIGZpbGUgPVxuICBsZXQgaWMgPSBvcGVuX2luX2JpbiBmaWxlIGluXG4gIGxldCBidWYgPSBCdWZmZXIuY3JlYXRlIDIwMCBpblxuICBsZXQgd29yZHMgPSByZWYgW10gaW5cbiAgbGV0IHN0YXNoICgpID1cbiAgICBsZXQgd29yZCA9IEJ1ZmZlci5jb250ZW50cyBidWYgaW5cbiAgICBsZXQgd29yZCA9IGlmIHRyaW0gdGhlbiB0cmltX2NyIHdvcmQgZWxzZSB3b3JkIGluXG4gICAgd29yZHMgOj0gd29yZCA6OiAhd29yZHM7XG4gICAgQnVmZmVyLmNsZWFyIGJ1ZlxuICBpblxuICBiZWdpblxuICAgIHRyeSB3aGlsZSB0cnVlIGRvXG4gICAgICAgIGxldCBjID0gaW5wdXRfY2hhciBpYyBpblxuICAgICAgICBpZiBjID0gc2VwIHRoZW4gc3Rhc2ggKCkgZWxzZSBCdWZmZXIuYWRkX2NoYXIgYnVmIGNcbiAgICAgIGRvbmVcbiAgICB3aXRoIEVuZF9vZl9maWxlIC0+ICgpXG4gIGVuZDtcbiAgaWYgQnVmZmVyLmxlbmd0aCBidWYgPiAwIHRoZW4gc3Rhc2ggKCk7XG4gIGNsb3NlX2luIGljO1xuICBBcnJheS5vZl9saXN0IChMaXN0LnJldiAhd29yZHMpXG5cbmxldCByZWFkX2FyZyA9IHJlYWRfYXV4IHRydWUgJ1xcbidcblxubGV0IHJlYWRfYXJnMCA9IHJlYWRfYXV4IGZhbHNlICdcXHgwMCdcblxubGV0IHdyaXRlX2F1eCBzZXAgZmlsZSBhcmdzID1cbiAgbGV0IG9jID0gb3Blbl9vdXRfYmluIGZpbGUgaW5cbiAgQXJyYXkuaXRlciAoZnVuIHMgLT4gZnByaW50ZiBvYyBcIiVzJWNcIiBzIHNlcCkgYXJncztcbiAgY2xvc2Vfb3V0IG9jXG5cbmxldCB3cml0ZV9hcmcgPSB3cml0ZV9hdXggJ1xcbidcblxubGV0IHdyaXRlX2FyZzAgPSB3cml0ZV9hdXggJ1xceDAwJ1xuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5vcGVuIFByaW50ZlxuXG50eXBlIHQgPSBleG4gPSAuLlxuXG5sZXQgcHJpbnRlcnMgPSBBdG9taWMubWFrZSBbXVxuXG5sZXQgbG9jZm10ID0gZm9ybWF0X29mX3N0cmluZyBcIkZpbGUgXFxcIiVzXFxcIiwgbGluZSAlZCwgY2hhcmFjdGVycyAlZC0lZDogJXNcIlxuXG5sZXQgZmllbGQgeCBpID1cbiAgbGV0IGYgPSBPYmouZmllbGQgeCBpIGluXG4gIGlmIG5vdCAoT2JqLmlzX2Jsb2NrIGYpIHRoZW5cbiAgICBzcHJpbnRmIFwiJWRcIiAoT2JqLm1hZ2ljIGYgOiBpbnQpICAgICAgICAgICAoKiBjYW4gYWxzbyBiZSBhIGNoYXIgKilcbiAgZWxzZSBpZiBPYmoudGFnIGYgPSBPYmouc3RyaW5nX3RhZyB0aGVuXG4gICAgc3ByaW50ZiBcIiVTXCIgKE9iai5tYWdpYyBmIDogc3RyaW5nKVxuICBlbHNlIGlmIE9iai50YWcgZiA9IE9iai5kb3VibGVfdGFnIHRoZW5cbiAgICBzdHJpbmdfb2ZfZmxvYXQgKE9iai5tYWdpYyBmIDogZmxvYXQpXG4gIGVsc2VcbiAgICBcIl9cIlxuXG5sZXQgcmVjIG90aGVyX2ZpZWxkcyB4IGkgPVxuICBpZiBpID49IE9iai5zaXplIHggdGhlbiBcIlwiXG4gIGVsc2Ugc3ByaW50ZiBcIiwgJXMlc1wiIChmaWVsZCB4IGkpIChvdGhlcl9maWVsZHMgeCAoaSsxKSlcblxubGV0IGZpZWxkcyB4ID1cbiAgbWF0Y2ggT2JqLnNpemUgeCB3aXRoXG4gIHwgMCAtPiBcIlwiXG4gIHwgMSAtPiBcIlwiXG4gIHwgMiAtPiBzcHJpbnRmIFwiKCVzKVwiIChmaWVsZCB4IDEpXG4gIHwgXyAtPiBzcHJpbnRmIFwiKCVzJXMpXCIgKGZpZWxkIHggMSkgKG90aGVyX2ZpZWxkcyB4IDIpXG5cbmxldCB1c2VfcHJpbnRlcnMgeCA9XG4gIGxldCByZWMgY29udiA9IGZ1bmN0aW9uXG4gICAgfCBoZCA6OiB0bCAtPlxuICAgICAgICAobWF0Y2ggaGQgeCB3aXRoXG4gICAgICAgICB8IE5vbmUgfCBleGNlcHRpb24gXyAtPiBjb252IHRsXG4gICAgICAgICB8IFNvbWUgcyAtPiBTb21lIHMpXG4gICAgfCBbXSAtPiBOb25lIGluXG4gIGNvbnYgKEF0b21pYy5nZXQgcHJpbnRlcnMpXG5cbmxldCB0b19zdHJpbmdfZGVmYXVsdCA9IGZ1bmN0aW9uXG4gIHwgT3V0X29mX21lbW9yeSAtPiBcIk91dCBvZiBtZW1vcnlcIlxuICB8IFN0YWNrX292ZXJmbG93IC0+IFwiU3RhY2sgb3ZlcmZsb3dcIlxuICB8IE1hdGNoX2ZhaWx1cmUoZmlsZSwgbGluZSwgY2hhcikgLT5cbiAgICAgIHNwcmludGYgbG9jZm10IGZpbGUgbGluZSBjaGFyIChjaGFyKzUpIFwiUGF0dGVybiBtYXRjaGluZyBmYWlsZWRcIlxuICB8IEFzc2VydF9mYWlsdXJlKGZpbGUsIGxpbmUsIGNoYXIpIC0+XG4gICAgICBzcHJpbnRmIGxvY2ZtdCBmaWxlIGxpbmUgY2hhciAoY2hhcis2KSBcIkFzc2VydGlvbiBmYWlsZWRcIlxuICB8IFVuZGVmaW5lZF9yZWN1cnNpdmVfbW9kdWxlKGZpbGUsIGxpbmUsIGNoYXIpIC0+XG4gICAgICBzcHJpbnRmIGxvY2ZtdCBmaWxlIGxpbmUgY2hhciAoY2hhcis2KSBcIlVuZGVmaW5lZCByZWN1cnNpdmUgbW9kdWxlXCJcbiAgfCB4IC0+XG4gICAgICBsZXQgeCA9IE9iai5yZXByIHggaW5cbiAgICAgIGlmIE9iai50YWcgeCA8PiAwIHRoZW5cbiAgICAgICAgKE9iai5tYWdpYyAoT2JqLmZpZWxkIHggMCkgOiBzdHJpbmcpXG4gICAgICBlbHNlXG4gICAgICAgIGxldCBjb25zdHJ1Y3RvciA9XG4gICAgICAgICAgKE9iai5tYWdpYyAoT2JqLmZpZWxkIChPYmouZmllbGQgeCAwKSAwKSA6IHN0cmluZykgaW5cbiAgICAgICAgY29uc3RydWN0b3IgXiAoZmllbGRzIHgpXG5cbmxldCB0b19zdHJpbmcgZSA9XG4gIG1hdGNoIHVzZV9wcmludGVycyBlIHdpdGhcbiAgfCBTb21lIHMgLT4gc1xuICB8IE5vbmUgLT4gdG9fc3RyaW5nX2RlZmF1bHQgZVxuXG5sZXQgcHJpbnQgZmN0IGFyZyA9XG4gIHRyeVxuICAgIGZjdCBhcmdcbiAgd2l0aCB4IC0+XG4gICAgZXByaW50ZiBcIlVuY2F1Z2h0IGV4Y2VwdGlvbjogJXNcXG5cIiAodG9fc3RyaW5nIHgpO1xuICAgIGZsdXNoIHN0ZGVycjtcbiAgICByYWlzZSB4XG5cbmxldCBjYXRjaCBmY3QgYXJnID1cbiAgdHJ5XG4gICAgZmN0IGFyZ1xuICB3aXRoIHggLT5cbiAgICBmbHVzaCBzdGRvdXQ7XG4gICAgZXByaW50ZiBcIlVuY2F1Z2h0IGV4Y2VwdGlvbjogJXNcXG5cIiAodG9fc3RyaW5nIHgpO1xuICAgIGV4aXQgMlxuXG50eXBlIHJhd19iYWNrdHJhY2Vfc2xvdFxudHlwZSByYXdfYmFja3RyYWNlX2VudHJ5ID0gcHJpdmF0ZSBpbnRcbnR5cGUgcmF3X2JhY2t0cmFjZSA9IHJhd19iYWNrdHJhY2VfZW50cnkgYXJyYXlcblxubGV0IHJhd19iYWNrdHJhY2VfZW50cmllcyBidCA9IGJ0XG5cbmV4dGVybmFsIGdldF9yYXdfYmFja3RyYWNlOlxuICB1bml0IC0+IHJhd19iYWNrdHJhY2UgPSBcImNhbWxfZ2V0X2V4Y2VwdGlvbl9yYXdfYmFja3RyYWNlXCJcblxuZXh0ZXJuYWwgcmFpc2Vfd2l0aF9iYWNrdHJhY2U6IGV4biAtPiByYXdfYmFja3RyYWNlIC0+ICdhXG4gID0gXCIlcmFpc2Vfd2l0aF9iYWNrdHJhY2VcIlxuXG50eXBlIGJhY2t0cmFjZV9zbG90ID1cbiAgfCBLbm93bl9sb2NhdGlvbiBvZiB7XG4gICAgICBpc19yYWlzZSAgICA6IGJvb2w7XG4gICAgICBmaWxlbmFtZSAgICA6IHN0cmluZztcbiAgICAgIGxpbmVfbnVtYmVyIDogaW50O1xuICAgICAgc3RhcnRfY2hhciAgOiBpbnQ7XG4gICAgICBlbmRfY2hhciAgICA6IGludDtcbiAgICAgIGlzX2lubGluZSAgIDogYm9vbDtcbiAgICAgIGRlZm5hbWUgICAgIDogc3RyaW5nO1xuICAgIH1cbiAgfCBVbmtub3duX2xvY2F0aW9uIG9mIHtcbiAgICAgIGlzX3JhaXNlIDogYm9vbFxuICAgIH1cblxuKCogdG8gYXZvaWQgd2FybmluZyAqKVxubGV0IF8gPSBbS25vd25fbG9jYXRpb24geyBpc19yYWlzZSA9IGZhbHNlOyBmaWxlbmFtZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVfbnVtYmVyID0gMDsgc3RhcnRfY2hhciA9IDA7IGVuZF9jaGFyID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaXNfaW5saW5lID0gZmFsc2U7IGRlZm5hbWUgPSBcIlwiIH07XG4gICAgICAgICBVbmtub3duX2xvY2F0aW9uIHsgaXNfcmFpc2UgPSBmYWxzZSB9XVxuXG5leHRlcm5hbCBjb252ZXJ0X3Jhd19iYWNrdHJhY2Vfc2xvdDpcbiAgcmF3X2JhY2t0cmFjZV9zbG90IC0+IGJhY2t0cmFjZV9zbG90ID0gXCJjYW1sX2NvbnZlcnRfcmF3X2JhY2t0cmFjZV9zbG90XCJcblxuZXh0ZXJuYWwgY29udmVydF9yYXdfYmFja3RyYWNlOlxuICByYXdfYmFja3RyYWNlIC0+IGJhY2t0cmFjZV9zbG90IGFycmF5ID0gXCJjYW1sX2NvbnZlcnRfcmF3X2JhY2t0cmFjZVwiXG5cbmxldCBjb252ZXJ0X3Jhd19iYWNrdHJhY2UgYnQgPVxuICB0cnkgU29tZSAoY29udmVydF9yYXdfYmFja3RyYWNlIGJ0KVxuICB3aXRoIEZhaWx1cmUgXyAtPiBOb25lXG5cbmxldCBmb3JtYXRfYmFja3RyYWNlX3Nsb3QgcG9zIHNsb3QgPVxuICBsZXQgaW5mbyBpc19yYWlzZSA9XG4gICAgaWYgaXNfcmFpc2UgdGhlblxuICAgICAgaWYgcG9zID0gMCB0aGVuIFwiUmFpc2VkIGF0XCIgZWxzZSBcIlJlLXJhaXNlZCBhdFwiXG4gICAgZWxzZVxuICAgICAgaWYgcG9zID0gMCB0aGVuIFwiUmFpc2VkIGJ5IHByaW1pdGl2ZSBvcGVyYXRpb24gYXRcIiBlbHNlIFwiQ2FsbGVkIGZyb21cIlxuICBpblxuICBtYXRjaCBzbG90IHdpdGhcbiAgfCBVbmtub3duX2xvY2F0aW9uIGwgLT5cbiAgICAgIGlmIGwuaXNfcmFpc2UgdGhlblxuICAgICAgICAoKiBjb21waWxlci1pbnNlcnRlZCByZS1yYWlzZSwgc2tpcHBlZCAqKSBOb25lXG4gICAgICBlbHNlXG4gICAgICAgIFNvbWUgKHNwcmludGYgXCIlcyB1bmtub3duIGxvY2F0aW9uXCIgKGluZm8gZmFsc2UpKVxuICB8IEtub3duX2xvY2F0aW9uIGwgLT5cbiAgICAgIFNvbWUgKHNwcmludGYgXCIlcyAlcyBpbiBmaWxlIFxcXCIlc1xcXCIlcywgbGluZSAlZCwgY2hhcmFjdGVycyAlZC0lZFwiXG4gICAgICAgICAgICAgIChpbmZvIGwuaXNfcmFpc2UpIGwuZGVmbmFtZSBsLmZpbGVuYW1lXG4gICAgICAgICAgICAgIChpZiBsLmlzX2lubGluZSB0aGVuIFwiIChpbmxpbmVkKVwiIGVsc2UgXCJcIilcbiAgICAgICAgICAgICAgbC5saW5lX251bWJlciBsLnN0YXJ0X2NoYXIgbC5lbmRfY2hhcilcblxubGV0IHByaW50X2V4Y2VwdGlvbl9iYWNrdHJhY2Ugb3V0Y2hhbiBiYWNrdHJhY2UgPVxuICBtYXRjaCBiYWNrdHJhY2Ugd2l0aFxuICB8IE5vbmUgLT5cbiAgICAgIGZwcmludGYgb3V0Y2hhblxuICAgICAgICBcIihQcm9ncmFtIG5vdCBsaW5rZWQgd2l0aCAtZywgY2Fubm90IHByaW50IHN0YWNrIGJhY2t0cmFjZSlcXG5cIlxuICB8IFNvbWUgYSAtPlxuICAgICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCBhIC0gMSBkb1xuICAgICAgICBtYXRjaCBmb3JtYXRfYmFja3RyYWNlX3Nsb3QgaSBhLihpKSB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+ICgpXG4gICAgICAgICAgfCBTb21lIHN0ciAtPiBmcHJpbnRmIG91dGNoYW4gXCIlc1xcblwiIHN0clxuICAgICAgZG9uZVxuXG5sZXQgcHJpbnRfcmF3X2JhY2t0cmFjZSBvdXRjaGFuIHJhd19iYWNrdHJhY2UgPVxuICBwcmludF9leGNlcHRpb25fYmFja3RyYWNlIG91dGNoYW4gKGNvbnZlcnRfcmF3X2JhY2t0cmFjZSByYXdfYmFja3RyYWNlKVxuXG4oKiBjb25mdXNpbmdseSBuYW1lZDogcHJpbnRzIHRoZSBnbG9iYWwgY3VycmVudCBiYWNrdHJhY2UgKilcbmxldCBwcmludF9iYWNrdHJhY2Ugb3V0Y2hhbiA9XG4gIHByaW50X3Jhd19iYWNrdHJhY2Ugb3V0Y2hhbiAoZ2V0X3Jhd19iYWNrdHJhY2UgKCkpXG5cbmxldCBiYWNrdHJhY2VfdG9fc3RyaW5nIGJhY2t0cmFjZSA9XG4gIG1hdGNoIGJhY2t0cmFjZSB3aXRoXG4gIHwgTm9uZSAtPlxuICAgICBcIihQcm9ncmFtIG5vdCBsaW5rZWQgd2l0aCAtZywgY2Fubm90IHByaW50IHN0YWNrIGJhY2t0cmFjZSlcXG5cIlxuICB8IFNvbWUgYSAtPlxuICAgICAgbGV0IGIgPSBCdWZmZXIuY3JlYXRlIDEwMjQgaW5cbiAgICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggYSAtIDEgZG9cbiAgICAgICAgbWF0Y2ggZm9ybWF0X2JhY2t0cmFjZV9zbG90IGkgYS4oaSkgd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPiAoKVxuICAgICAgICAgIHwgU29tZSBzdHIgLT4gYnByaW50ZiBiIFwiJXNcXG5cIiBzdHJcbiAgICAgIGRvbmU7XG4gICAgICBCdWZmZXIuY29udGVudHMgYlxuXG5sZXQgcmF3X2JhY2t0cmFjZV90b19zdHJpbmcgcmF3X2JhY2t0cmFjZSA9XG4gIGJhY2t0cmFjZV90b19zdHJpbmcgKGNvbnZlcnRfcmF3X2JhY2t0cmFjZSByYXdfYmFja3RyYWNlKVxuXG5sZXQgYmFja3RyYWNlX3Nsb3RfaXNfcmFpc2UgPSBmdW5jdGlvblxuICB8IEtub3duX2xvY2F0aW9uIGwgLT4gbC5pc19yYWlzZVxuICB8IFVua25vd25fbG9jYXRpb24gbCAtPiBsLmlzX3JhaXNlXG5cbmxldCBiYWNrdHJhY2Vfc2xvdF9pc19pbmxpbmUgPSBmdW5jdGlvblxuICB8IEtub3duX2xvY2F0aW9uIGwgLT4gbC5pc19pbmxpbmVcbiAgfCBVbmtub3duX2xvY2F0aW9uIF8gLT4gZmFsc2VcblxudHlwZSBsb2NhdGlvbiA9IHtcbiAgZmlsZW5hbWUgOiBzdHJpbmc7XG4gIGxpbmVfbnVtYmVyIDogaW50O1xuICBzdGFydF9jaGFyIDogaW50O1xuICBlbmRfY2hhciA6IGludDtcbn1cblxubGV0IGJhY2t0cmFjZV9zbG90X2xvY2F0aW9uID0gZnVuY3Rpb25cbiAgfCBVbmtub3duX2xvY2F0aW9uIF8gLT4gTm9uZVxuICB8IEtub3duX2xvY2F0aW9uIGwgLT5cbiAgICBTb21lIHtcbiAgICAgIGZpbGVuYW1lICAgID0gbC5maWxlbmFtZTtcbiAgICAgIGxpbmVfbnVtYmVyID0gbC5saW5lX251bWJlcjtcbiAgICAgIHN0YXJ0X2NoYXIgID0gbC5zdGFydF9jaGFyO1xuICAgICAgZW5kX2NoYXIgICAgPSBsLmVuZF9jaGFyO1xuICAgIH1cblxubGV0IGJhY2t0cmFjZV9zbG90X2RlZm5hbWUgPSBmdW5jdGlvblxuICB8IFVua25vd25fbG9jYXRpb24gX1xuICB8IEtub3duX2xvY2F0aW9uIHsgZGVmbmFtZSA9IFwiXCIgfSAtPiBOb25lXG4gIHwgS25vd25fbG9jYXRpb24gbCAtPiBTb21lIGwuZGVmbmFtZVxuXG5sZXQgYmFja3RyYWNlX3Nsb3RzIHJhd19iYWNrdHJhY2UgPVxuICAoKiBUaGUgZG9jdW1lbnRhdGlvbiBvZiB0aGlzIGZ1bmN0aW9uIGd1YXJhbnRlZXMgdGhhdCBTb21lIGlzXG4gICAgIHJldHVybmVkIG9ubHkgaWYgYSBwYXJ0IG9mIHRoZSB0cmFjZSBpcyB1c2FibGUuIFRoaXMgZ2l2ZXMgdXNcbiAgICAgYSBiaXQgbW9yZSB3b3JrIHRoYW4ganVzdCBjb252ZXJ0X3Jhd19iYWNrdHJhY2UsIGJ1dCBpdCBtYWtlcyB0aGVcbiAgICAgQVBJIG1vcmUgdXNlci1mcmllbmRseSAtLSBvdGhlcndpc2UgbW9zdCB1c2VycyB3b3VsZCBoYXZlIHRvXG4gICAgIHJlaW1wbGVtZW50IHRoZSBcIlByb2dyYW0gbm90IGxpbmtlZCB3aXRoIC1nLCBzb3JyeVwiIGxvZ2ljXG4gICAgIHRoZW1zZWx2ZXMuICopXG4gIG1hdGNoIGNvbnZlcnRfcmF3X2JhY2t0cmFjZSByYXdfYmFja3RyYWNlIHdpdGhcbiAgICB8IE5vbmUgLT4gTm9uZVxuICAgIHwgU29tZSBiYWNrdHJhY2UgLT5cbiAgICAgIGxldCB1c2FibGVfc2xvdCA9IGZ1bmN0aW9uXG4gICAgICAgIHwgVW5rbm93bl9sb2NhdGlvbiBfIC0+IGZhbHNlXG4gICAgICAgIHwgS25vd25fbG9jYXRpb24gXyAtPiB0cnVlIGluXG4gICAgICBsZXQgcmVjIGV4aXN0c191c2FibGUgPSBmdW5jdGlvblxuICAgICAgICB8ICgtMSkgLT4gZmFsc2VcbiAgICAgICAgfCBpIC0+IHVzYWJsZV9zbG90IGJhY2t0cmFjZS4oaSkgfHwgZXhpc3RzX3VzYWJsZSAoaSAtIDEpIGluXG4gICAgICBpZiBleGlzdHNfdXNhYmxlIChBcnJheS5sZW5ndGggYmFja3RyYWNlIC0gMSlcbiAgICAgIHRoZW4gU29tZSBiYWNrdHJhY2VcbiAgICAgIGVsc2UgTm9uZVxuXG5sZXQgYmFja3RyYWNlX3Nsb3RzX29mX3Jhd19lbnRyeSBlbnRyeSA9XG4gIGJhY2t0cmFjZV9zbG90cyBbfCBlbnRyeSB8XVxuXG5tb2R1bGUgU2xvdCA9IHN0cnVjdFxuICB0eXBlIHQgPSBiYWNrdHJhY2Vfc2xvdFxuICBsZXQgZm9ybWF0ID0gZm9ybWF0X2JhY2t0cmFjZV9zbG90XG4gIGxldCBpc19yYWlzZSA9IGJhY2t0cmFjZV9zbG90X2lzX3JhaXNlXG4gIGxldCBpc19pbmxpbmUgPSBiYWNrdHJhY2Vfc2xvdF9pc19pbmxpbmVcbiAgbGV0IGxvY2F0aW9uID0gYmFja3RyYWNlX3Nsb3RfbG9jYXRpb25cbiAgbGV0IG5hbWUgPSBiYWNrdHJhY2Vfc2xvdF9kZWZuYW1lXG5lbmRcblxubGV0IHJhd19iYWNrdHJhY2VfbGVuZ3RoIGJ0ID0gQXJyYXkubGVuZ3RoIGJ0XG5cbmV4dGVybmFsIGdldF9yYXdfYmFja3RyYWNlX3Nsb3QgOlxuICByYXdfYmFja3RyYWNlIC0+IGludCAtPiByYXdfYmFja3RyYWNlX3Nsb3QgPSBcImNhbWxfcmF3X2JhY2t0cmFjZV9zbG90XCJcblxuZXh0ZXJuYWwgZ2V0X3Jhd19iYWNrdHJhY2VfbmV4dF9zbG90IDpcbiAgcmF3X2JhY2t0cmFjZV9zbG90IC0+IHJhd19iYWNrdHJhY2Vfc2xvdCBvcHRpb25cbiAgPSBcImNhbWxfcmF3X2JhY2t0cmFjZV9uZXh0X3Nsb3RcIlxuXG4oKiBjb25mdXNpbmdseSBuYW1lZDpcbiAgIHJldHVybnMgdGhlICpzdHJpbmcqIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdsb2JhbCBjdXJyZW50IGJhY2t0cmFjZSAqKVxubGV0IGdldF9iYWNrdHJhY2UgKCkgPSByYXdfYmFja3RyYWNlX3RvX3N0cmluZyAoZ2V0X3Jhd19iYWNrdHJhY2UgKCkpXG5cbmV4dGVybmFsIHJlY29yZF9iYWNrdHJhY2U6IGJvb2wgLT4gdW5pdCA9IFwiY2FtbF9yZWNvcmRfYmFja3RyYWNlXCJcbmV4dGVybmFsIGJhY2t0cmFjZV9zdGF0dXM6IHVuaXQgLT4gYm9vbCA9IFwiY2FtbF9iYWNrdHJhY2Vfc3RhdHVzXCJcblxubGV0IHJlYyByZWdpc3Rlcl9wcmludGVyIGZuID1cbiAgbGV0IG9sZF9wcmludGVycyA9IEF0b21pYy5nZXQgcHJpbnRlcnMgaW5cbiAgbGV0IG5ld19wcmludGVycyA9IGZuIDo6IG9sZF9wcmludGVycyBpblxuICBsZXQgc3VjY2VzcyA9IEF0b21pYy5jb21wYXJlX2FuZF9zZXQgcHJpbnRlcnMgb2xkX3ByaW50ZXJzIG5ld19wcmludGVycyBpblxuICBpZiBub3Qgc3VjY2VzcyB0aGVuIHJlZ2lzdGVyX3ByaW50ZXIgZm5cblxuZXh0ZXJuYWwgZ2V0X2NhbGxzdGFjazogaW50IC0+IHJhd19iYWNrdHJhY2UgPSBcImNhbWxfZ2V0X2N1cnJlbnRfY2FsbHN0YWNrXCJcblxubGV0IGV4bl9zbG90IHggPVxuICBsZXQgeCA9IE9iai5yZXByIHggaW5cbiAgaWYgT2JqLnRhZyB4ID0gMCB0aGVuIE9iai5maWVsZCB4IDAgZWxzZSB4XG5cbmxldCBleG5fc2xvdF9pZCB4ID1cbiAgbGV0IHNsb3QgPSBleG5fc2xvdCB4IGluXG4gIChPYmoub2JqIChPYmouZmllbGQgc2xvdCAxKSA6IGludClcblxubGV0IGV4bl9zbG90X25hbWUgeCA9XG4gIGxldCBzbG90ID0gZXhuX3Nsb3QgeCBpblxuICAoT2JqLm9iaiAoT2JqLmZpZWxkIHNsb3QgMCkgOiBzdHJpbmcpXG5cbmV4dGVybmFsIGdldF9kZWJ1Z19pbmZvX3N0YXR1cyA6IHVuaXQgLT4gaW50ID0gXCJjYW1sX21sX2RlYnVnX2luZm9fc3RhdHVzXCJcblxuKCogRGVzY3JpcHRpb25zIGZvciBlcnJvcnMgaW4gc3RhcnR1cC5oLiBTZWUgYWxzbyBiYWNrdHJhY2UuYyAqKVxubGV0IGVycm9ycyA9IFt8IFwiXCI7XG4gICgqIEZJTEVfTk9UX0ZPVU5EICopXG4gIFwiKENhbm5vdCBwcmludCBsb2NhdGlvbnM6XFxuIFxcXG4gICAgICBieXRlY29kZSBleGVjdXRhYmxlIHByb2dyYW0gZmlsZSBub3QgZm91bmQpXCI7XG4gICgqIEJBRF9CWVRFQ09ERSAqKVxuICBcIihDYW5ub3QgcHJpbnQgbG9jYXRpb25zOlxcbiBcXFxuICAgICAgYnl0ZWNvZGUgZXhlY3V0YWJsZSBwcm9ncmFtIGZpbGUgYXBwZWFycyB0byBiZSBjb3JydXB0KVwiO1xuICAoKiBXUk9OR19NQUdJQyAqKVxuICBcIihDYW5ub3QgcHJpbnQgbG9jYXRpb25zOlxcbiBcXFxuICAgICAgYnl0ZWNvZGUgZXhlY3V0YWJsZSBwcm9ncmFtIGZpbGUgaGFzIHdyb25nIG1hZ2ljIG51bWJlcilcIjtcbiAgKCogTk9fRkRTICopXG4gIFwiKENhbm5vdCBwcmludCBsb2NhdGlvbnM6XFxuIFxcXG4gICAgICBieXRlY29kZSBleGVjdXRhYmxlIHByb2dyYW0gZmlsZSBjYW5ub3QgYmUgb3BlbmVkO1xcbiBcXFxuICAgICAgLS0gdG9vIG1hbnkgb3BlbiBmaWxlcy4gVHJ5IHJ1bm5pbmcgd2l0aCBPQ0FNTFJVTlBBUkFNPWI9MilcIlxufF1cblxubGV0IGRlZmF1bHRfdW5jYXVnaHRfZXhjZXB0aW9uX2hhbmRsZXIgZXhuIHJhd19iYWNrdHJhY2UgPVxuICBlcHJpbnRmIFwiRmF0YWwgZXJyb3I6IGV4Y2VwdGlvbiAlc1xcblwiICh0b19zdHJpbmcgZXhuKTtcbiAgcHJpbnRfcmF3X2JhY2t0cmFjZSBzdGRlcnIgcmF3X2JhY2t0cmFjZTtcbiAgbGV0IHN0YXR1cyA9IGdldF9kZWJ1Z19pbmZvX3N0YXR1cyAoKSBpblxuICBpZiBzdGF0dXMgPCAwIHRoZW5cbiAgICBwcmVycl9lbmRsaW5lIGVycm9ycy4oYWJzIHN0YXR1cyk7XG4gIGZsdXNoIHN0ZGVyclxuXG5sZXQgdW5jYXVnaHRfZXhjZXB0aW9uX2hhbmRsZXIgPSByZWYgZGVmYXVsdF91bmNhdWdodF9leGNlcHRpb25faGFuZGxlclxuXG5sZXQgc2V0X3VuY2F1Z2h0X2V4Y2VwdGlvbl9oYW5kbGVyIGZuID0gdW5jYXVnaHRfZXhjZXB0aW9uX2hhbmRsZXIgOj0gZm5cblxubGV0IGVtcHR5X2JhY2t0cmFjZSA6IHJhd19iYWNrdHJhY2UgPSBbfCB8XVxuXG5sZXQgdHJ5X2dldF9yYXdfYmFja3RyYWNlICgpID1cbiAgdHJ5XG4gICAgZ2V0X3Jhd19iYWNrdHJhY2UgKClcbiAgd2l0aCBfICgqIE91dF9vZl9tZW1vcnk/ICopIC0+XG4gICAgZW1wdHlfYmFja3RyYWNlXG5cbmxldCBoYW5kbGVfdW5jYXVnaHRfZXhjZXB0aW9uJyBleG4gZGVidWdnZXJfaW5fdXNlID1cbiAgdHJ5XG4gICAgKCogR2V0IHRoZSBiYWNrdHJhY2Ugbm93LCBpbiBjYXNlIG9uZSBvZiB0aGUgW2F0X2V4aXRdIGZ1bmN0aW9uXG4gICAgICAgZGVzdHJveXMgaXQuICopXG4gICAgbGV0IHJhd19iYWNrdHJhY2UgPVxuICAgICAgaWYgZGVidWdnZXJfaW5fdXNlICgqIFNhbWUgdGVzdCBhcyBpbiBbcnVudGltZS9wcmludGV4Yy5jXSAqKSB0aGVuXG4gICAgICAgIGVtcHR5X2JhY2t0cmFjZVxuICAgICAgZWxzZVxuICAgICAgICB0cnlfZ2V0X3Jhd19iYWNrdHJhY2UgKClcbiAgICBpblxuICAgICh0cnkgU3RkbGliLmRvX2F0X2V4aXQgKCkgd2l0aCBfIC0+ICgpKTtcbiAgICB0cnlcbiAgICAgICF1bmNhdWdodF9leGNlcHRpb25faGFuZGxlciBleG4gcmF3X2JhY2t0cmFjZVxuICAgIHdpdGggZXhuJyAtPlxuICAgICAgbGV0IHJhd19iYWNrdHJhY2UnID0gdHJ5X2dldF9yYXdfYmFja3RyYWNlICgpIGluXG4gICAgICBlcHJpbnRmIFwiRmF0YWwgZXJyb3I6IGV4Y2VwdGlvbiAlc1xcblwiICh0b19zdHJpbmcgZXhuKTtcbiAgICAgIHByaW50X3Jhd19iYWNrdHJhY2Ugc3RkZXJyIHJhd19iYWNrdHJhY2U7XG4gICAgICBlcHJpbnRmIFwiRmF0YWwgZXJyb3IgaW4gdW5jYXVnaHQgZXhjZXB0aW9uIGhhbmRsZXI6IGV4Y2VwdGlvbiAlc1xcblwiXG4gICAgICAgICh0b19zdHJpbmcgZXhuJyk7XG4gICAgICBwcmludF9yYXdfYmFja3RyYWNlIHN0ZGVyciByYXdfYmFja3RyYWNlJztcbiAgICAgIGZsdXNoIHN0ZGVyclxuICB3aXRoXG4gICAgfCBPdXRfb2ZfbWVtb3J5IC0+XG4gICAgICAgIHByZXJyX2VuZGxpbmVcbiAgICAgICAgICBcIkZhdGFsIGVycm9yOiBvdXQgb2YgbWVtb3J5IGluIHVuY2F1Z2h0IGV4Y2VwdGlvbiBoYW5kbGVyXCJcblxuKCogVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgYnkgW2NhbWxfZmF0YWxfdW5jYXVnaHRfZXhjZXB0aW9uXSBpblxuICAgW3J1bnRpbWUvcHJpbnRleGMuY10gd2hpY2ggZXhwZWN0cyBubyBleGNlcHRpb24gaXMgcmFpc2VkLiAqKVxubGV0IGhhbmRsZV91bmNhdWdodF9leGNlcHRpb24gZXhuIGRlYnVnZ2VyX2luX3VzZSA9XG4gIHRyeVxuICAgIGhhbmRsZV91bmNhdWdodF9leGNlcHRpb24nIGV4biBkZWJ1Z2dlcl9pbl91c2VcbiAgd2l0aCBfIC0+XG4gICAgKCogVGhlcmUgaXMgbm90IG11Y2ggd2UgY2FuIGRvIGF0IHRoaXMgcG9pbnQgKilcbiAgICAoKVxuXG5leHRlcm5hbCByZWdpc3Rlcl9uYW1lZF92YWx1ZSA6IHN0cmluZyAtPiAnYSAtPiB1bml0XG4gID0gXCJjYW1sX3JlZ2lzdGVyX25hbWVkX3ZhbHVlXCJcblxubGV0ICgpID1cbiAgcmVnaXN0ZXJfbmFtZWRfdmFsdWUgXCJQcmludGV4Yy5oYW5kbGVfdW5jYXVnaHRfZXhjZXB0aW9uXCJcbiAgICBoYW5kbGVfdW5jYXVnaHRfZXhjZXB0aW9uXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgT0NhbWwgcHJvZ3JhbW1lcnMgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE4IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbmV4dGVybmFsIGlkIDogJ2EgLT4gJ2EgPSBcIiVpZGVudGl0eVwiXG5sZXQgY29uc3QgYyBfID0gY1xubGV0IGZsaXAgZiB4IHkgPSBmIHkgeFxubGV0IG5lZ2F0ZSBwIHYgPSBub3QgKHAgdilcblxuZXhjZXB0aW9uIEZpbmFsbHlfcmFpc2VkIG9mIGV4blxuXG5sZXQgKCkgPSBQcmludGV4Yy5yZWdpc3Rlcl9wcmludGVyIEBAIGZ1bmN0aW9uXG58IEZpbmFsbHlfcmFpc2VkIGV4biAtPiBTb21lIChcIkZ1bi5GaW5hbGx5X3JhaXNlZDogXCIgXiBQcmludGV4Yy50b19zdHJpbmcgZXhuKVxufCBfIC0+IE5vbmVcblxubGV0IHByb3RlY3QgfihmaW5hbGx5IDogdW5pdCAtPiB1bml0KSB3b3JrID1cbiAgbGV0IGZpbmFsbHlfbm9fZXhuICgpID1cbiAgICB0cnkgZmluYWxseSAoKSB3aXRoIGUgLT5cbiAgICAgIGxldCBidCA9IFByaW50ZXhjLmdldF9yYXdfYmFja3RyYWNlICgpIGluXG4gICAgICBQcmludGV4Yy5yYWlzZV93aXRoX2JhY2t0cmFjZSAoRmluYWxseV9yYWlzZWQgZSkgYnRcbiAgaW5cbiAgbWF0Y2ggd29yayAoKSB3aXRoXG4gIHwgcmVzdWx0IC0+IGZpbmFsbHlfbm9fZXhuICgpIDsgcmVzdWx0XG4gIHwgZXhjZXB0aW9uIHdvcmtfZXhuIC0+XG4gICAgICBsZXQgd29ya19idCA9IFByaW50ZXhjLmdldF9yYXdfYmFja3RyYWNlICgpIGluXG4gICAgICBmaW5hbGx5X25vX2V4biAoKSA7XG4gICAgICBQcmludGV4Yy5yYWlzZV93aXRoX2JhY2t0cmFjZSB3b3JrX2V4biB3b3JrX2J0XG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgIERhbWllbiBEb2xpZ2V6LCBwcm9qZXQgUGFyYSwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgIEphY3F1ZXMtSGVucmkgSm91cmRhbiwgcHJvamV0IEdhbGxpdW0sIElOUklBIFBhcmlzICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2LTIwMTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSAgICopXG4oKiAgICAgZXQgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUgc3RhdCA9IHtcbiAgbWlub3Jfd29yZHMgOiBmbG9hdDtcbiAgcHJvbW90ZWRfd29yZHMgOiBmbG9hdDtcbiAgbWFqb3Jfd29yZHMgOiBmbG9hdDtcbiAgbWlub3JfY29sbGVjdGlvbnMgOiBpbnQ7XG4gIG1ham9yX2NvbGxlY3Rpb25zIDogaW50O1xuICBoZWFwX3dvcmRzIDogaW50O1xuICBoZWFwX2NodW5rcyA6IGludDtcbiAgbGl2ZV93b3JkcyA6IGludDtcbiAgbGl2ZV9ibG9ja3MgOiBpbnQ7XG4gIGZyZWVfd29yZHMgOiBpbnQ7XG4gIGZyZWVfYmxvY2tzIDogaW50O1xuICBsYXJnZXN0X2ZyZWUgOiBpbnQ7XG4gIGZyYWdtZW50cyA6IGludDtcbiAgY29tcGFjdGlvbnMgOiBpbnQ7XG4gIHRvcF9oZWFwX3dvcmRzIDogaW50O1xuICBzdGFja19zaXplIDogaW50O1xuICBmb3JjZWRfbWFqb3JfY29sbGVjdGlvbnM6IGludDtcbn1cblxudHlwZSBjb250cm9sID0ge1xuICBtdXRhYmxlIG1pbm9yX2hlYXBfc2l6ZSA6IGludDtcbiAgbXV0YWJsZSBtYWpvcl9oZWFwX2luY3JlbWVudCA6IGludDtcbiAgbXV0YWJsZSBzcGFjZV9vdmVyaGVhZCA6IGludDtcbiAgbXV0YWJsZSB2ZXJib3NlIDogaW50O1xuICBtdXRhYmxlIG1heF9vdmVyaGVhZCA6IGludDtcbiAgbXV0YWJsZSBzdGFja19saW1pdCA6IGludDtcbiAgbXV0YWJsZSBhbGxvY2F0aW9uX3BvbGljeSA6IGludDtcbiAgd2luZG93X3NpemUgOiBpbnQ7XG4gIGN1c3RvbV9tYWpvcl9yYXRpbyA6IGludDtcbiAgY3VzdG9tX21pbm9yX3JhdGlvIDogaW50O1xuICBjdXN0b21fbWlub3JfbWF4X3NpemUgOiBpbnQ7XG59XG5cbmV4dGVybmFsIHN0YXQgOiB1bml0IC0+IHN0YXQgPSBcImNhbWxfZ2Nfc3RhdFwiXG5leHRlcm5hbCBxdWlja19zdGF0IDogdW5pdCAtPiBzdGF0ID0gXCJjYW1sX2djX3F1aWNrX3N0YXRcIlxuZXh0ZXJuYWwgY291bnRlcnMgOiB1bml0IC0+IChmbG9hdCAqIGZsb2F0ICogZmxvYXQpID0gXCJjYW1sX2djX2NvdW50ZXJzXCJcbmV4dGVybmFsIG1pbm9yX3dvcmRzIDogdW5pdCAtPiAoZmxvYXQgW0B1bmJveGVkXSlcbiAgPSBcImNhbWxfZ2NfbWlub3Jfd29yZHNcIiBcImNhbWxfZ2NfbWlub3Jfd29yZHNfdW5ib3hlZFwiXG5leHRlcm5hbCBnZXQgOiB1bml0IC0+IGNvbnRyb2wgPSBcImNhbWxfZ2NfZ2V0XCJcbmV4dGVybmFsIHNldCA6IGNvbnRyb2wgLT4gdW5pdCA9IFwiY2FtbF9nY19zZXRcIlxuZXh0ZXJuYWwgbWlub3IgOiB1bml0IC0+IHVuaXQgPSBcImNhbWxfZ2NfbWlub3JcIlxuZXh0ZXJuYWwgbWFqb3Jfc2xpY2UgOiBpbnQgLT4gaW50ID0gXCJjYW1sX2djX21ham9yX3NsaWNlXCJcbmV4dGVybmFsIG1ham9yIDogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2djX21ham9yXCJcbmV4dGVybmFsIGZ1bGxfbWFqb3IgOiB1bml0IC0+IHVuaXQgPSBcImNhbWxfZ2NfZnVsbF9tYWpvclwiXG5leHRlcm5hbCBjb21wYWN0IDogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2djX2NvbXBhY3Rpb25cIlxuZXh0ZXJuYWwgZ2V0X21pbm9yX2ZyZWUgOiB1bml0IC0+IGludCA9IFwiY2FtbF9nZXRfbWlub3JfZnJlZVwiXG5leHRlcm5hbCBnZXRfYnVja2V0IDogaW50IC0+IGludCA9IFwiY2FtbF9nZXRfbWFqb3JfYnVja2V0XCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIGdldF9jcmVkaXQgOiB1bml0IC0+IGludCA9IFwiY2FtbF9nZXRfbWFqb3JfY3JlZGl0XCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIGh1Z2VfZmFsbGJhY2tfY291bnQgOiB1bml0IC0+IGludCA9IFwiY2FtbF9nY19odWdlX2ZhbGxiYWNrX2NvdW50XCJcbmV4dGVybmFsIGV2ZW50bG9nX3BhdXNlIDogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2V2ZW50bG9nX3BhdXNlXCJcbmV4dGVybmFsIGV2ZW50bG9nX3Jlc3VtZSA6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9ldmVudGxvZ19yZXN1bWVcIlxuXG5vcGVuIFByaW50ZlxuXG5sZXQgcHJpbnRfc3RhdCBjID1cbiAgbGV0IHN0ID0gc3RhdCAoKSBpblxuICBmcHJpbnRmIGMgXCJtaW5vcl9jb2xsZWN0aW9uczogICAgICAlZFxcblwiIHN0Lm1pbm9yX2NvbGxlY3Rpb25zO1xuICBmcHJpbnRmIGMgXCJtYWpvcl9jb2xsZWN0aW9uczogICAgICAlZFxcblwiIHN0Lm1ham9yX2NvbGxlY3Rpb25zO1xuICBmcHJpbnRmIGMgXCJjb21wYWN0aW9uczogICAgICAgICAgICAlZFxcblwiIHN0LmNvbXBhY3Rpb25zO1xuICBmcHJpbnRmIGMgXCJmb3JjZWRfbWFqb3JfY29sbGVjdGlvbnM6ICVkXFxuXCIgc3QuZm9yY2VkX21ham9yX2NvbGxlY3Rpb25zO1xuICBmcHJpbnRmIGMgXCJcXG5cIjtcbiAgbGV0IGwxID0gU3RyaW5nLmxlbmd0aCAoc3ByaW50ZiBcIiUuMGZcIiBzdC5taW5vcl93b3JkcykgaW5cbiAgZnByaW50ZiBjIFwibWlub3Jfd29yZHM6ICAgICUqLjBmXFxuXCIgbDEgc3QubWlub3Jfd29yZHM7XG4gIGZwcmludGYgYyBcInByb21vdGVkX3dvcmRzOiAlKi4wZlxcblwiIGwxIHN0LnByb21vdGVkX3dvcmRzO1xuICBmcHJpbnRmIGMgXCJtYWpvcl93b3JkczogICAgJSouMGZcXG5cIiBsMSBzdC5tYWpvcl93b3JkcztcbiAgZnByaW50ZiBjIFwiXFxuXCI7XG4gIGxldCBsMiA9IFN0cmluZy5sZW5ndGggKHNwcmludGYgXCIlZFwiIHN0LnRvcF9oZWFwX3dvcmRzKSBpblxuICBmcHJpbnRmIGMgXCJ0b3BfaGVhcF93b3JkczogJSpkXFxuXCIgbDIgc3QudG9wX2hlYXBfd29yZHM7XG4gIGZwcmludGYgYyBcImhlYXBfd29yZHM6ICAgICAlKmRcXG5cIiBsMiBzdC5oZWFwX3dvcmRzO1xuICBmcHJpbnRmIGMgXCJsaXZlX3dvcmRzOiAgICAgJSpkXFxuXCIgbDIgc3QubGl2ZV93b3JkcztcbiAgZnByaW50ZiBjIFwiZnJlZV93b3JkczogICAgICUqZFxcblwiIGwyIHN0LmZyZWVfd29yZHM7XG4gIGZwcmludGYgYyBcImxhcmdlc3RfZnJlZTogICAlKmRcXG5cIiBsMiBzdC5sYXJnZXN0X2ZyZWU7XG4gIGZwcmludGYgYyBcImZyYWdtZW50czogICAgICAlKmRcXG5cIiBsMiBzdC5mcmFnbWVudHM7XG4gIGZwcmludGYgYyBcIlxcblwiO1xuICBmcHJpbnRmIGMgXCJsaXZlX2Jsb2NrczogJWRcXG5cIiBzdC5saXZlX2Jsb2NrcztcbiAgZnByaW50ZiBjIFwiZnJlZV9ibG9ja3M6ICVkXFxuXCIgc3QuZnJlZV9ibG9ja3M7XG4gIGZwcmludGYgYyBcImhlYXBfY2h1bmtzOiAlZFxcblwiIHN0LmhlYXBfY2h1bmtzXG5cblxubGV0IGFsbG9jYXRlZF9ieXRlcyAoKSA9XG4gIGxldCAobWksIHBybywgbWEpID0gY291bnRlcnMgKCkgaW5cbiAgKG1pICsuIG1hIC0uIHBybykgKi4gZmxvYXRfb2ZfaW50IChTeXMud29yZF9zaXplIC8gOClcblxuXG5leHRlcm5hbCBmaW5hbGlzZSA6ICgnYSAtPiB1bml0KSAtPiAnYSAtPiB1bml0ID0gXCJjYW1sX2ZpbmFsX3JlZ2lzdGVyXCJcbmV4dGVybmFsIGZpbmFsaXNlX2xhc3QgOiAodW5pdCAtPiB1bml0KSAtPiAnYSAtPiB1bml0ID1cbiAgXCJjYW1sX2ZpbmFsX3JlZ2lzdGVyX2NhbGxlZF93aXRob3V0X3ZhbHVlXCJcbmV4dGVybmFsIGZpbmFsaXNlX3JlbGVhc2UgOiB1bml0IC0+IHVuaXQgPSBcImNhbWxfZmluYWxfcmVsZWFzZVwiXG5cblxudHlwZSBhbGFybSA9IGJvb2wgcmVmXG50eXBlIGFsYXJtX3JlYyA9IHthY3RpdmUgOiBhbGFybTsgZiA6IHVuaXQgLT4gdW5pdH1cblxubGV0IHJlYyBjYWxsX2FsYXJtIGFyZWMgPVxuICBpZiAhKGFyZWMuYWN0aXZlKSB0aGVuIGJlZ2luXG4gICAgZmluYWxpc2UgY2FsbF9hbGFybSBhcmVjO1xuICAgIGFyZWMuZiAoKTtcbiAgZW5kXG5cblxubGV0IGNyZWF0ZV9hbGFybSBmID1cbiAgbGV0IGFyZWMgPSB7IGFjdGl2ZSA9IHJlZiB0cnVlOyBmID0gZiB9IGluXG4gIGZpbmFsaXNlIGNhbGxfYWxhcm0gYXJlYztcbiAgYXJlYy5hY3RpdmVcblxuXG5sZXQgZGVsZXRlX2FsYXJtIGEgPSBhIDo9IGZhbHNlXG5cbm1vZHVsZSBNZW1wcm9mID1cbiAgc3RydWN0XG4gICAgdHlwZSBhbGxvY2F0aW9uX3NvdXJjZSA9IE5vcm1hbCB8IE1hcnNoYWwgfCBDdXN0b21cbiAgICB0eXBlIGFsbG9jYXRpb24gPVxuICAgICAgeyBuX3NhbXBsZXMgOiBpbnQ7XG4gICAgICAgIHNpemUgOiBpbnQ7XG4gICAgICAgIHNvdXJjZSA6IGFsbG9jYXRpb25fc291cmNlO1xuICAgICAgICBjYWxsc3RhY2sgOiBQcmludGV4Yy5yYXdfYmFja3RyYWNlIH1cblxuICAgIHR5cGUgKCdtaW5vciwgJ21ham9yKSB0cmFja2VyID0ge1xuICAgICAgYWxsb2NfbWlub3I6IGFsbG9jYXRpb24gLT4gJ21pbm9yIG9wdGlvbjtcbiAgICAgIGFsbG9jX21ham9yOiBhbGxvY2F0aW9uIC0+ICdtYWpvciBvcHRpb247XG4gICAgICBwcm9tb3RlOiAnbWlub3IgLT4gJ21ham9yIG9wdGlvbjtcbiAgICAgIGRlYWxsb2NfbWlub3I6ICdtaW5vciAtPiB1bml0O1xuICAgICAgZGVhbGxvY19tYWpvcjogJ21ham9yIC0+IHVuaXQ7XG4gICAgfVxuXG4gICAgbGV0IG51bGxfdHJhY2tlciA9IHtcbiAgICAgIGFsbG9jX21pbm9yID0gKGZ1biBfIC0+IE5vbmUpO1xuICAgICAgYWxsb2NfbWFqb3IgPSAoZnVuIF8gLT4gTm9uZSk7XG4gICAgICBwcm9tb3RlID0gKGZ1biBfIC0+IE5vbmUpO1xuICAgICAgZGVhbGxvY19taW5vciA9IChmdW4gXyAtPiAoKSk7XG4gICAgICBkZWFsbG9jX21ham9yID0gKGZ1biBfIC0+ICgpKTtcbiAgICB9XG5cbiAgICBleHRlcm5hbCBjX3N0YXJ0IDpcbiAgICAgIGZsb2F0IC0+IGludCAtPiAoJ21pbm9yLCAnbWFqb3IpIHRyYWNrZXIgLT4gdW5pdFxuICAgICAgPSBcImNhbWxfbWVtcHJvZl9zdGFydFwiXG5cbiAgICBsZXQgc3RhcnRcbiAgICAgIH5zYW1wbGluZ19yYXRlXG4gICAgICA/KGNhbGxzdGFja19zaXplID0gbWF4X2ludClcbiAgICAgIHRyYWNrZXIgPVxuICAgICAgY19zdGFydCBzYW1wbGluZ19yYXRlIGNhbGxzdGFja19zaXplIHRyYWNrZXJcblxuICAgIGV4dGVybmFsIHN0b3AgOiB1bml0IC0+IHVuaXQgPSBcImNhbWxfbWVtcHJvZl9zdG9wXCJcbiAgZW5kXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIE1lc3NhZ2UgZGlnZXN0IChNRDUpICopXG5cbnR5cGUgdCA9IHN0cmluZ1xuXG5sZXQgY29tcGFyZSA9IFN0cmluZy5jb21wYXJlXG5sZXQgZXF1YWwgPSBTdHJpbmcuZXF1YWxcblxuZXh0ZXJuYWwgdW5zYWZlX3N0cmluZzogc3RyaW5nIC0+IGludCAtPiBpbnQgLT4gdCA9IFwiY2FtbF9tZDVfc3RyaW5nXCJcbmV4dGVybmFsIGNoYW5uZWw6IGluX2NoYW5uZWwgLT4gaW50IC0+IHQgPSBcImNhbWxfbWQ1X2NoYW5cIlxuXG5sZXQgc3RyaW5nIHN0ciA9XG4gIHVuc2FmZV9zdHJpbmcgc3RyIDAgKFN0cmluZy5sZW5ndGggc3RyKVxuXG5sZXQgYnl0ZXMgYiA9IHN0cmluZyAoQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBiKVxuXG5sZXQgc3Vic3RyaW5nIHN0ciBvZnMgbGVuID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IFN0cmluZy5sZW5ndGggc3RyIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJEaWdlc3Quc3Vic3RyaW5nXCJcbiAgZWxzZSB1bnNhZmVfc3RyaW5nIHN0ciBvZnMgbGVuXG5cbmxldCBzdWJieXRlcyBiIG9mcyBsZW4gPSBzdWJzdHJpbmcgKEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgYikgb2ZzIGxlblxuXG5sZXQgZmlsZSBmaWxlbmFtZSA9XG4gIGxldCBpYyA9IG9wZW5faW5fYmluIGZpbGVuYW1lIGluXG4gIG1hdGNoIGNoYW5uZWwgaWMgKC0xKSB3aXRoXG4gICAgfCBkIC0+IGNsb3NlX2luIGljOyBkXG4gICAgfCBleGNlcHRpb24gZSAtPiBjbG9zZV9pbiBpYzsgcmFpc2UgZVxuXG5sZXQgb3V0cHV0IGNoYW4gZGlnZXN0ID1cbiAgb3V0cHV0X3N0cmluZyBjaGFuIGRpZ2VzdFxuXG5sZXQgaW5wdXQgY2hhbiA9IHJlYWxseV9pbnB1dF9zdHJpbmcgY2hhbiAxNlxuXG5sZXQgY2hhcl9oZXggbiA9XG4gIENoYXIudW5zYWZlX2NociAobiArIGlmIG4gPCAxMCB0aGVuIENoYXIuY29kZSAnMCcgZWxzZSAoQ2hhci5jb2RlICdhJyAtIDEwKSlcblxubGV0IHRvX2hleCBkID1cbiAgaWYgU3RyaW5nLmxlbmd0aCBkIDw+IDE2IHRoZW4gaW52YWxpZF9hcmcgXCJEaWdlc3QudG9faGV4XCI7XG4gIGxldCByZXN1bHQgPSBCeXRlcy5jcmVhdGUgMzIgaW5cbiAgZm9yIGkgPSAwIHRvIDE1IGRvXG4gICAgbGV0IHggPSBDaGFyLmNvZGUgZC5baV0gaW5cbiAgICBCeXRlcy51bnNhZmVfc2V0IHJlc3VsdCAoaSoyKSAoY2hhcl9oZXggKHggbHNyIDQpKTtcbiAgICBCeXRlcy51bnNhZmVfc2V0IHJlc3VsdCAoaSoyKzEpIChjaGFyX2hleCAoeCBsYW5kIDB4MGYpKTtcbiAgZG9uZTtcbiAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyByZXN1bHRcblxubGV0IGZyb21faGV4IHMgPVxuICBpZiBTdHJpbmcubGVuZ3RoIHMgPD4gMzIgdGhlbiBpbnZhbGlkX2FyZyBcIkRpZ2VzdC5mcm9tX2hleFwiO1xuICBsZXQgZGlnaXQgYyA9XG4gICAgbWF0Y2ggYyB3aXRoXG4gICAgfCAnMCcuLic5JyAtPiBDaGFyLmNvZGUgYyAtIENoYXIuY29kZSAnMCdcbiAgICB8ICdBJy4uJ0YnIC0+IENoYXIuY29kZSBjIC0gQ2hhci5jb2RlICdBJyArIDEwXG4gICAgfCAnYScuLidmJyAtPiBDaGFyLmNvZGUgYyAtIENoYXIuY29kZSAnYScgKyAxMFxuICAgIHwgXyAtPiByYWlzZSAoSW52YWxpZF9hcmd1bWVudCBcIkRpZ2VzdC5mcm9tX2hleFwiKVxuICBpblxuICBsZXQgYnl0ZSBpID0gZGlnaXQgcy5baV0gbHNsIDQgKyBkaWdpdCBzLltpKzFdIGluXG4gIGxldCByZXN1bHQgPSBCeXRlcy5jcmVhdGUgMTYgaW5cbiAgZm9yIGkgPSAwIHRvIDE1IGRvXG4gICAgQnl0ZXMuc2V0IHJlc3VsdCBpIChDaGFyLmNociAoYnl0ZSAoMiAqIGkpKSk7XG4gIGRvbmU7XG4gIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcmVzdWx0XG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgIERhbWllbiBEb2xpZ2V6LCBwcm9qZXQgUGFyYSwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIFBzZXVkby1yYW5kb20gbnVtYmVyIGdlbmVyYXRvclxuICAgVGhpcyBpcyBhIGxhZ2dlZC1GaWJvbmFjY2kgRig1NSwgMjQsICspIHdpdGggYSBtb2RpZmllZCBhZGRpdGlvblxuICAgZnVuY3Rpb24gdG8gZW5oYW5jZSB0aGUgbWl4aW5nIG9mIGJpdHMuXG4gICBJZiB3ZSB1c2Ugbm9ybWFsIGFkZGl0aW9uLCB0aGUgbG93LW9yZGVyIGJpdCBmYWlscyB0ZXN0cyAxIGFuZCA3XG4gICBvZiB0aGUgRGllaGFyZCB0ZXN0IHN1aXRlLCBhbmQgYml0cyAxIGFuZCAyIGFsc28gZmFpbCB0ZXN0IDcuXG4gICBJZiB3ZSB1c2UgbXVsdGlwbGljYXRpb24gYXMgc3VnZ2VzdGVkIGJ5IE1hcnNhZ2xpYSwgaXQgZG9lc24ndCBmYXJlXG4gICBtdWNoIGJldHRlci5cbiAgIEJ5IG1peGluZyB0aGUgYml0cyBvZiBvbmUgb2YgdGhlIG51bWJlcnMgYmVmb3JlIGFkZGl0aW9uIChYT1IgdGhlXG4gICA1IGhpZ2gtb3JkZXIgYml0cyBpbnRvIHRoZSBsb3ctb3JkZXIgYml0cyksIHdlIGdldCBhIGdlbmVyYXRvciB0aGF0XG4gICBwYXNzZXMgYWxsIHRoZSBEaWVoYXJkIHRlc3RzLlxuKilcblxuZXh0ZXJuYWwgcmFuZG9tX3NlZWQ6IHVuaXQgLT4gaW50IGFycmF5ID0gXCJjYW1sX3N5c19yYW5kb21fc2VlZFwiXG5cbm1vZHVsZSBTdGF0ZSA9IHN0cnVjdFxuXG4gIHR5cGUgdCA9IHsgc3QgOiBpbnQgYXJyYXk7IG11dGFibGUgaWR4IDogaW50IH1cblxuICBsZXQgbmV3X3N0YXRlICgpID0geyBzdCA9IEFycmF5Lm1ha2UgNTUgMDsgaWR4ID0gMCB9XG4gIGxldCBhc3NpZ24gc3QxIHN0MiA9XG4gICAgQXJyYXkuYmxpdCBzdDIuc3QgMCBzdDEuc3QgMCA1NTtcbiAgICBzdDEuaWR4IDwtIHN0Mi5pZHhcblxuXG4gIGxldCBmdWxsX2luaXQgcyBzZWVkID1cbiAgICBsZXQgY29tYmluZSBhY2N1IHggPSBEaWdlc3Quc3RyaW5nIChhY2N1IF4gSW50LnRvX3N0cmluZyB4KSBpblxuICAgIGxldCBleHRyYWN0IGQgPVxuICAgICAgQ2hhci5jb2RlIGQuWzBdICsgKENoYXIuY29kZSBkLlsxXSBsc2wgOCkgKyAoQ2hhci5jb2RlIGQuWzJdIGxzbCAxNilcbiAgICAgICsgKENoYXIuY29kZSBkLlszXSBsc2wgMjQpXG4gICAgaW5cbiAgICBsZXQgc2VlZCA9IGlmIEFycmF5Lmxlbmd0aCBzZWVkID0gMCB0aGVuIFt8IDAgfF0gZWxzZSBzZWVkIGluXG4gICAgbGV0IGwgPSBBcnJheS5sZW5ndGggc2VlZCBpblxuICAgIGZvciBpID0gMCB0byA1NCBkb1xuICAgICAgcy5zdC4oaSkgPC0gaTtcbiAgICBkb25lO1xuICAgIGxldCBhY2N1ID0gcmVmIFwieFwiIGluXG4gICAgZm9yIGkgPSAwIHRvIDU0ICsgSW50Lm1heCA1NSBsIGRvXG4gICAgICBsZXQgaiA9IGkgbW9kIDU1IGluXG4gICAgICBsZXQgayA9IGkgbW9kIGwgaW5cbiAgICAgIGFjY3UgOj0gY29tYmluZSAhYWNjdSBzZWVkLihrKTtcbiAgICAgIHMuc3QuKGopIDwtIChzLnN0LihqKSBseG9yIGV4dHJhY3QgIWFjY3UpIGxhbmQgMHgzRkZGRkZGRjsgICgqIFBSIzU1NzUgKilcbiAgICBkb25lO1xuICAgIHMuaWR4IDwtIDBcblxuXG4gIGxldCBtYWtlIHNlZWQgPVxuICAgIGxldCByZXN1bHQgPSBuZXdfc3RhdGUgKCkgaW5cbiAgICBmdWxsX2luaXQgcmVzdWx0IHNlZWQ7XG4gICAgcmVzdWx0XG5cblxuICBsZXQgbWFrZV9zZWxmX2luaXQgKCkgPSBtYWtlIChyYW5kb21fc2VlZCAoKSlcblxuICBsZXQgY29weSBzID1cbiAgICBsZXQgcmVzdWx0ID0gbmV3X3N0YXRlICgpIGluXG4gICAgYXNzaWduIHJlc3VsdCBzO1xuICAgIHJlc3VsdFxuXG5cbiAgKCogUmV0dXJucyAzMCByYW5kb20gYml0cyBhcyBhbiBpbnRlZ2VyIDAgPD0geCA8IDEwNzM3NDE4MjQgKilcbiAgbGV0IGJpdHMgcyA9XG4gICAgcy5pZHggPC0gKHMuaWR4ICsgMSkgbW9kIDU1O1xuICAgIGxldCBjdXJ2YWwgPSBzLnN0LihzLmlkeCkgaW5cbiAgICBsZXQgbmV3dmFsID0gcy5zdC4oKHMuaWR4ICsgMjQpIG1vZCA1NSlcbiAgICAgICAgICAgICAgICAgKyAoY3VydmFsIGx4b3IgKChjdXJ2YWwgbHNyIDI1KSBsYW5kIDB4MUYpKSBpblxuICAgIGxldCBuZXd2YWwzMCA9IG5ld3ZhbCBsYW5kIDB4M0ZGRkZGRkYgaW4gICgqIFBSIzU1NzUgKilcbiAgICBzLnN0LihzLmlkeCkgPC0gbmV3dmFsMzA7XG4gICAgbmV3dmFsMzBcblxuXG4gIGxldCByZWMgaW50YXV4IHMgbiA9XG4gICAgbGV0IHIgPSBiaXRzIHMgaW5cbiAgICBsZXQgdiA9IHIgbW9kIG4gaW5cbiAgICBpZiByIC0gdiA+IDB4M0ZGRkZGRkYgLSBuICsgMSB0aGVuIGludGF1eCBzIG4gZWxzZSB2XG5cbiAgbGV0IGludCBzIGJvdW5kID1cbiAgICBpZiBib3VuZCA+IDB4M0ZGRkZGRkYgfHwgYm91bmQgPD0gMFxuICAgIHRoZW4gaW52YWxpZF9hcmcgXCJSYW5kb20uaW50XCJcbiAgICBlbHNlIGludGF1eCBzIGJvdW5kXG5cbiAgbGV0IHJlYyBpbnQ2M2F1eCBzIG4gPVxuICAgIGxldCBtYXhfaW50XzMyID0gKDEgbHNsIDMwKSArIDB4M0ZGRkZGRkYgaW4gKCogMHg3RkZGRkZGRiAqKVxuICAgIGxldCBiMSA9IGJpdHMgcyBpblxuICAgIGxldCBiMiA9IGJpdHMgcyBpblxuICAgIGxldCAociwgbWF4X2ludCkgPVxuICAgICAgaWYgbiA8PSBtYXhfaW50XzMyIHRoZW5cbiAgICAgICAgKCogMzEgcmFuZG9tIGJpdHMgb24gYm90aCA2NC1iaXQgT0NhbWwgYW5kIEphdmFTY3JpcHQuXG4gICAgICAgICAgIFVzZSB1cHBlciAxNSBiaXRzIG9mIGIxIGFuZCAxNiBiaXRzIG9mIGIyLiAqKVxuICAgICAgICBsZXQgYnBvcyA9XG4gICAgICAgICAgKCgoYjIgbGFuZCAweDNGRkZDMDAwKSBsc2wgMSkgbG9yIChiMSBsc3IgMTUpKVxuICAgICAgICBpblxuICAgICAgICAgIChicG9zLCBtYXhfaW50XzMyKVxuICAgICAgZWxzZVxuICAgICAgICBsZXQgYjMgPSBiaXRzIHMgaW5cbiAgICAgICAgKCogNjIgcmFuZG9tIGJpdHMgb24gNjQtYml0IE9DYW1sOyB1bnJlYWNoYWJsZSBvbiBKYXZhU2NyaXB0LlxuICAgICAgICAgICBVc2UgdXBwZXIgMjAgYml0cyBvZiBiMSBhbmQgMjEgYml0cyBvZiBiMiBhbmQgYjMuICopXG4gICAgICAgIGxldCBicG9zID1cbiAgICAgICAgICAoKCgoYjMgbGFuZCAweDNGRkZGRTAwKSBsc2wgMTIpIGxvciAoYjIgbHNyIDkpKSBsc2wgMjApXG4gICAgICAgICAgICBsb3IgKGIxIGxzciAxMClcbiAgICAgICAgaW5cbiAgICAgICAgICAoYnBvcywgbWF4X2ludClcbiAgICBpblxuICAgIGxldCB2ID0gciBtb2QgbiBpblxuICAgIGlmIHIgLSB2ID4gbWF4X2ludCAtIG4gKyAxIHRoZW4gaW50NjNhdXggcyBuIGVsc2UgdlxuXG4gIGxldCBmdWxsX2ludCBzIGJvdW5kID1cbiAgICBpZiBib3VuZCA8PSAwIHRoZW5cbiAgICAgIGludmFsaWRfYXJnIFwiUmFuZG9tLmZ1bGxfaW50XCJcbiAgICBlbHNlIGlmIGJvdW5kID4gMHgzRkZGRkZGRiB0aGVuXG4gICAgICBpbnQ2M2F1eCBzIGJvdW5kXG4gICAgZWxzZVxuICAgICAgaW50YXV4IHMgYm91bmRcblxuXG4gIGxldCByZWMgaW50MzJhdXggcyBuID1cbiAgICBsZXQgYjEgPSBJbnQzMi5vZl9pbnQgKGJpdHMgcykgaW5cbiAgICBsZXQgYjIgPSBJbnQzMi5zaGlmdF9sZWZ0IChJbnQzMi5vZl9pbnQgKGJpdHMgcyBsYW5kIDEpKSAzMCBpblxuICAgIGxldCByID0gSW50MzIubG9nb3IgYjEgYjIgaW5cbiAgICBsZXQgdiA9IEludDMyLnJlbSByIG4gaW5cbiAgICBpZiBJbnQzMi5zdWIgciB2ID4gSW50MzIuYWRkIChJbnQzMi5zdWIgSW50MzIubWF4X2ludCBuKSAxbFxuICAgIHRoZW4gaW50MzJhdXggcyBuXG4gICAgZWxzZSB2XG5cbiAgbGV0IGludDMyIHMgYm91bmQgPVxuICAgIGlmIGJvdW5kIDw9IDBsXG4gICAgdGhlbiBpbnZhbGlkX2FyZyBcIlJhbmRvbS5pbnQzMlwiXG4gICAgZWxzZSBpbnQzMmF1eCBzIGJvdW5kXG5cblxuICBsZXQgcmVjIGludDY0YXV4IHMgbiA9XG4gICAgbGV0IGIxID0gSW50NjQub2ZfaW50IChiaXRzIHMpIGluXG4gICAgbGV0IGIyID0gSW50NjQuc2hpZnRfbGVmdCAoSW50NjQub2ZfaW50IChiaXRzIHMpKSAzMCBpblxuICAgIGxldCBiMyA9IEludDY0LnNoaWZ0X2xlZnQgKEludDY0Lm9mX2ludCAoYml0cyBzIGxhbmQgNykpIDYwIGluXG4gICAgbGV0IHIgPSBJbnQ2NC5sb2dvciBiMSAoSW50NjQubG9nb3IgYjIgYjMpIGluXG4gICAgbGV0IHYgPSBJbnQ2NC5yZW0gciBuIGluXG4gICAgaWYgSW50NjQuc3ViIHIgdiA+IEludDY0LmFkZCAoSW50NjQuc3ViIEludDY0Lm1heF9pbnQgbikgMUxcbiAgICB0aGVuIGludDY0YXV4IHMgblxuICAgIGVsc2UgdlxuXG4gIGxldCBpbnQ2NCBzIGJvdW5kID1cbiAgICBpZiBib3VuZCA8PSAwTFxuICAgIHRoZW4gaW52YWxpZF9hcmcgXCJSYW5kb20uaW50NjRcIlxuICAgIGVsc2UgaW50NjRhdXggcyBib3VuZFxuXG5cbiAgbGV0IG5hdGl2ZWludCA9XG4gICAgaWYgTmF0aXZlaW50LnNpemUgPSAzMlxuICAgIHRoZW4gZnVuIHMgYm91bmQgLT4gTmF0aXZlaW50Lm9mX2ludDMyIChpbnQzMiBzIChOYXRpdmVpbnQudG9faW50MzIgYm91bmQpKVxuICAgIGVsc2UgZnVuIHMgYm91bmQgLT4gSW50NjQudG9fbmF0aXZlaW50IChpbnQ2NCBzIChJbnQ2NC5vZl9uYXRpdmVpbnQgYm91bmQpKVxuXG5cbiAgKCogUmV0dXJucyBhIGZsb2F0IDAgPD0geCA8PSAxIHdpdGggYXQgbW9zdCA2MCBiaXRzIG9mIHByZWNpc2lvbi4gKilcbiAgbGV0IHJhd2Zsb2F0IHMgPVxuICAgIGxldCBzY2FsZSA9IDEwNzM3NDE4MjQuMCAgKCogMl4zMCAqKVxuICAgIGFuZCByMSA9IFN0ZGxpYi5mbG9hdCAoYml0cyBzKVxuICAgIGFuZCByMiA9IFN0ZGxpYi5mbG9hdCAoYml0cyBzKVxuICAgIGluIChyMSAvLiBzY2FsZSArLiByMikgLy4gc2NhbGVcblxuXG4gIGxldCBmbG9hdCBzIGJvdW5kID0gcmF3ZmxvYXQgcyAqLiBib3VuZFxuXG4gIGxldCBib29sIHMgPSAoYml0cyBzIGxhbmQgMSA9IDApXG5cbiAgbGV0IGJpdHMzMiBzID1cbiAgICBsZXQgYjEgPSBJbnQzMi4oc2hpZnRfcmlnaHRfbG9naWNhbCAob2ZfaW50IChiaXRzIHMpKSAxNCkgaW4gICgqIDE2IGJpdHMgKilcbiAgICBsZXQgYjIgPSBJbnQzMi4oc2hpZnRfcmlnaHRfbG9naWNhbCAob2ZfaW50IChiaXRzIHMpKSAxNCkgaW4gICgqIDE2IGJpdHMgKilcbiAgICBJbnQzMi4obG9nb3IgYjEgKHNoaWZ0X2xlZnQgYjIgMTYpKVxuXG4gIGxldCBiaXRzNjQgcyA9XG4gICAgbGV0IGIxID0gSW50NjQuKHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgKG9mX2ludCAoYml0cyBzKSkgOSkgaW4gICgqIDIxIGJpdHMgKilcbiAgICBsZXQgYjIgPSBJbnQ2NC4oc2hpZnRfcmlnaHRfbG9naWNhbCAob2ZfaW50IChiaXRzIHMpKSA5KSBpbiAgKCogMjEgYml0cyAqKVxuICAgIGxldCBiMyA9IEludDY0LihzaGlmdF9yaWdodF9sb2dpY2FsIChvZl9pbnQgKGJpdHMgcykpIDgpIGluICAoKiAyMiBiaXRzICopXG4gICAgSW50NjQuKGxvZ29yIGIxIChsb2dvciAoc2hpZnRfbGVmdCBiMiAyMSkgKHNoaWZ0X2xlZnQgYjMgNDIpKSlcblxuICBsZXQgbmF0aXZlYml0cyA9XG4gICAgaWYgTmF0aXZlaW50LnNpemUgPSAzMlxuICAgIHRoZW4gZnVuIHMgLT4gTmF0aXZlaW50Lm9mX2ludDMyIChiaXRzMzIgcylcbiAgICBlbHNlIGZ1biBzIC0+IEludDY0LnRvX25hdGl2ZWludCAoYml0czY0IHMpXG5cbmVuZFxuXG4oKiBUaGlzIGlzIHRoZSBzdGF0ZSB5b3UgZ2V0IHdpdGggW2luaXQgMjcxODI4MThdIGFuZCB0aGVuIGFwcGx5aW5nXG4gICB0aGUgXCJsYW5kIDB4M0ZGRkZGRkZcIiBmaWx0ZXIgdG8gdGhlbS4gIFNlZSAjNTU3NSwgIzU3OTMsICM1OTc3LiAqKVxubGV0IGRlZmF1bHQgPSB7XG4gIFN0YXRlLnN0ID0gW3xcbiAgICAgIDB4M2FlMjUyMmI7IDB4MWQ4ZDQ2MzQ7IDB4MTViNGZhZDA7IDB4MThiMTRhY2U7IDB4MTJmOGEzYzQ7IDB4M2IwODZjNDc7XG4gICAgICAweDE2ZDQ2N2Q2OyAweDEwMWQ5MWM3OyAweDMyMWRmMTc3OyAweDAxNzZjMTkzOyAweDFmZjcyYmYxOyAweDFlODg5MTA5O1xuICAgICAgMHgwYjQ2NGIxODsgMHgyYjg2Yjk3YzsgMHgwODkxZGE0ODsgMHgwMzEzNzQ2MzsgMHgwODVhYzVhMTsgMHgxNWQ2MWYyZjtcbiAgICAgIDB4M2JjZWQzNTk7IDB4MjljMWMxMzI7IDB4M2E4Njc2NmU7IDB4MzY2ZDhjODY7IDB4MWY1YjYyMjI7IDB4M2NlMWI1OWY7XG4gICAgICAweDJlYmY3OGUxOyAweDI3Y2QxYjg2OyAweDI1OGYzZGMzOyAweDM4OWE4MTk0OyAweDAyZTRjNDRjOyAweDE4YzQzZjdkO1xuICAgICAgMHgwZjZlNTM0ZjsgMHgxZTdkZjM1OTsgMHgwNTVkMGI3ZTsgMHgxMGU4NGU3ZTsgMHgxMjYxOThlNDsgMHgwZTc3MjJjYjtcbiAgICAgIDB4MWNiZWRlMjg7IDB4MzM5MWI5NjQ7IDB4M2Q0MGU5MmE7IDB4MGM1OTkzM2Q7IDB4MGI4Y2QwYjc7IDB4MjRlZmZmMWM7XG4gICAgICAweDI4MDNmZGFhOyAweDA4ZWJjNzJlOyAweDBmNTIyZTMyOyAweDA1Mzk4ZWRjOyAweDIxNDRhMDRjOyAweDBhZWYzY2JkO1xuICAgICAgMHgwMWFkNDcxOTsgMHgzNWI5M2NkNjsgMHgyYTU1OWQ0ZjsgMHgxZTZmZDc2ODsgMHgyNmUyN2YzNjsgMHgxODZmMThjMztcbiAgICAgIDB4MmZiZjk2N2E7XG4gICAgfF07XG4gIFN0YXRlLmlkeCA9IDA7XG59XG5cbmxldCBiaXRzICgpID0gU3RhdGUuYml0cyBkZWZhdWx0XG5sZXQgaW50IGJvdW5kID0gU3RhdGUuaW50IGRlZmF1bHQgYm91bmRcbmxldCBmdWxsX2ludCBib3VuZCA9IFN0YXRlLmZ1bGxfaW50IGRlZmF1bHQgYm91bmRcbmxldCBpbnQzMiBib3VuZCA9IFN0YXRlLmludDMyIGRlZmF1bHQgYm91bmRcbmxldCBuYXRpdmVpbnQgYm91bmQgPSBTdGF0ZS5uYXRpdmVpbnQgZGVmYXVsdCBib3VuZFxubGV0IGludDY0IGJvdW5kID0gU3RhdGUuaW50NjQgZGVmYXVsdCBib3VuZFxubGV0IGZsb2F0IHNjYWxlID0gU3RhdGUuZmxvYXQgZGVmYXVsdCBzY2FsZVxubGV0IGJvb2wgKCkgPSBTdGF0ZS5ib29sIGRlZmF1bHRcbmxldCBiaXRzMzIgKCkgPSBTdGF0ZS5iaXRzMzIgZGVmYXVsdFxubGV0IGJpdHM2NCAoKSA9IFN0YXRlLmJpdHM2NCBkZWZhdWx0XG5sZXQgbmF0aXZlYml0cyAoKSA9IFN0YXRlLm5hdGl2ZWJpdHMgZGVmYXVsdFxuXG5sZXQgZnVsbF9pbml0IHNlZWQgPSBTdGF0ZS5mdWxsX2luaXQgZGVmYXVsdCBzZWVkXG5sZXQgaW5pdCBzZWVkID0gU3RhdGUuZnVsbF9pbml0IGRlZmF1bHQgW3wgc2VlZCB8XVxubGV0IHNlbGZfaW5pdCAoKSA9IGZ1bGxfaW5pdCAocmFuZG9tX3NlZWQoKSlcblxuKCogTWFuaXB1bGF0aW5nIHRoZSBjdXJyZW50IHN0YXRlLiAqKVxuXG5sZXQgZ2V0X3N0YXRlICgpID0gU3RhdGUuY29weSBkZWZhdWx0XG5sZXQgc2V0X3N0YXRlIHMgPSBTdGF0ZS5hc3NpZ24gZGVmYXVsdCBzXG5cbigqKioqKioqKioqKioqKioqKioqKlxuXG4oKiBUZXN0IGZ1bmN0aW9ucy4gIE5vdCBpbmNsdWRlZCBpbiB0aGUgbGlicmFyeS5cbiAgIFRoZSBbY2hpc3F1YXJlXSBmdW5jdGlvbiBzaG91bGQgYmUgY2FsbGVkIHdpdGggbiA+IDEwci5cbiAgIEl0IHJldHVybnMgYSB0cmlwbGUgKGxvdywgYWN0dWFsLCBoaWdoKS5cbiAgIElmIGxvdyA8PSBhY3R1YWwgPD0gaGlnaCwgdGhlIFtnXSBmdW5jdGlvbiBwYXNzZWQgdGhlIHRlc3QsXG4gICBvdGhlcndpc2UgaXQgZmFpbGVkLlxuXG4gIFNvbWUgcmVzdWx0czpcblxuaW5pdCAyNzE4MjgxODsgY2hpc3F1YXJlIGludCAxMDAwMDAgMTAwMFxuaW5pdCAyNzE4MjgxODsgY2hpc3F1YXJlIGludCAxMDAwMDAgMTAwXG5pbml0IDI3MTgyODE4OyBjaGlzcXVhcmUgaW50IDEwMDAwMCA1MDAwXG5pbml0IDI3MTgyODE4OyBjaGlzcXVhcmUgaW50IDEwMDAwMDAgMTAwMFxuaW5pdCAyNzE4MjgxODsgY2hpc3F1YXJlIGludCAxMDAwMDAgMTAyNFxuaW5pdCAyOTk3OTI2NDM7IGNoaXNxdWFyZSBpbnQgMTAwMDAwIDEwMjRcbmluaXQgMTQxNDIxMzY7IGNoaXNxdWFyZSBpbnQgMTAwMDAwIDEwMjRcbmluaXQgMjcxODI4MTg7IGluaXRfZGlmZiAxMDI0OyBjaGlzcXVhcmUgZGlmZiAxMDAwMDAgMTAyNFxuaW5pdCAyNzE4MjgxODsgaW5pdF9kaWZmIDEwMDsgY2hpc3F1YXJlIGRpZmYgMTAwMDAwIDEwMFxuaW5pdCAyNzE4MjgxODsgaW5pdF9kaWZmMiAxMDI0OyBjaGlzcXVhcmUgZGlmZjIgMTAwMDAwIDEwMjRcbmluaXQgMjcxODI4MTg7IGluaXRfZGlmZjIgMTAwOyBjaGlzcXVhcmUgZGlmZjIgMTAwMDAwIDEwMFxuaW5pdCAxNDE0MjEzNjsgaW5pdF9kaWZmMiAxMDA7IGNoaXNxdWFyZSBkaWZmMiAxMDAwMDAgMTAwXG5pbml0IDI5OTc5MjY0MzsgaW5pdF9kaWZmMiAxMDA7IGNoaXNxdWFyZSBkaWZmMiAxMDAwMDAgMTAwXG4tIDogZmxvYXQgKiBmbG9hdCAqIGZsb2F0ID0gKDkzNi43NTQ0NDY3OTY2MzI0NjUsIDk5Ny41LCAxMDYzLjI0NTU1MzIwMzM2NzU0KVxuIyAtIDogZmxvYXQgKiBmbG9hdCAqIGZsb2F0ID0gKDgwLiwgODkuNzQwMDAwMDAwMDA1MjM4NywgMTIwLilcbiMgLSA6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCA9ICg0ODU4LjU3ODY0Mzc2MjY5LCA1MDQ1LjUsIDUxNDEuNDIxMzU2MjM3MzEpXG4jIC0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPVxuKDkzNi43NTQ0NDY3OTY2MzI0NjUsIDk0NC44MDU5OTk5OTk5ODIzMDUsIDEwNjMuMjQ1NTUzMjAzMzY3NTQpXG4jIC0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPSAoOTYwLiwgMTAxOS4xOTc0NDAwMDAwMDM1NSwgMTA4OC4pXG4jIC0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPSAoOTYwLiwgMTA1OS4zMTc3NjAwMDAwMDUzNiwgMTA4OC4pXG4jIC0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPSAoOTYwLiwgMTAzOS45ODQ2Mzk5OTk5OTUxMiwgMTA4OC4pXG4jIC0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPSAoOTYwLiwgMTA1NC4zODIwNzk5OTk5OTU3NywgMTA4OC4pXG4jIC0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPSAoODAuLCA5MC4wOTYwMDAwMDAwMDUsIDEyMC4pXG4jIC0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPSAoOTYwLiwgMTA3Ni43ODcyMDAwMDAwMDYxMiwgMTA4OC4pXG4jIC0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPSAoODAuLCA4NS4xNzYwMDAwMDAwMDY3NTIxLCAxMjAuKVxuIyAtIDogZmxvYXQgKiBmbG9hdCAqIGZsb2F0ID0gKDgwLiwgODUuMjE2MDAwMDAwMDAwMzQ5MiwgMTIwLilcbiMgLSA6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCA9ICg4MC4sIDgwLjYyMjAwMDAwMDAwMzAyNjgsIDEyMC4pXG5cbiopXG5cbigqIFJldHVybiB0aGUgc3VtIG9mIHRoZSBzcXVhcmVzIG9mIHZbaTAsaTFbICopXG5sZXQgcmVjIHN1bXNxIHYgaTAgaTEgPVxuICBpZiBpMCA+PSBpMSB0aGVuIDAuMFxuICBlbHNlIGlmIGkxID0gaTAgKyAxIHRoZW4gU3RkbGliLmZsb2F0IHYuKGkwKSAqLiBTdGRsaWIuZmxvYXQgdi4oaTApXG4gIGVsc2Ugc3Vtc3EgdiBpMCAoKGkwK2kxKS8yKSArLiBzdW1zcSB2ICgoaTAraTEpLzIpIGkxXG5cblxubGV0IGNoaXNxdWFyZSBnIG4gciA9XG4gIGlmIG4gPD0gMTAgKiByIHRoZW4gaW52YWxpZF9hcmcgXCJjaGlzcXVhcmVcIjtcbiAgbGV0IGYgPSBBcnJheS5tYWtlIHIgMCBpblxuICBmb3IgaSA9IDEgdG8gbiBkb1xuICAgIGxldCB0ID0gZyByIGluXG4gICAgZi4odCkgPC0gZi4odCkgKyAxXG4gIGRvbmU7XG4gIGxldCB0ID0gc3Vtc3EgZiAwIHJcbiAgYW5kIHIgPSBTdGRsaWIuZmxvYXQgclxuICBhbmQgbiA9IFN0ZGxpYi5mbG9hdCBuIGluXG4gIGxldCBzciA9IDIuMCAqLiBzcXJ0IHIgaW5cbiAgKHIgLS4gc3IsICAgKHIgKi4gdCAvLiBuKSAtLiBuLCAgIHIgKy4gc3IpXG5cblxuKCogVGhpcyBpcyB0byB0ZXN0IGZvciBsaW5lYXIgZGVwZW5kZW5jaWVzIGJldHdlZW4gc3VjY2Vzc2l2ZSByYW5kb20gbnVtYmVycy5cbiopXG5sZXQgc3QgPSByZWYgMFxubGV0IGluaXRfZGlmZiByID0gc3QgOj0gaW50IHJcbmxldCBkaWZmIHIgPVxuICBsZXQgeDEgPSAhc3RcbiAgYW5kIHgyID0gaW50IHJcbiAgaW5cbiAgc3QgOj0geDI7XG4gIGlmIHgxID49IHgyIHRoZW5cbiAgICB4MSAtIHgyXG4gIGVsc2VcbiAgICByICsgeDEgLSB4MlxuXG5cbmxldCBzdDEgPSByZWYgMFxuYW5kIHN0MiA9IHJlZiAwXG5cblxuKCogVGhpcyBpcyB0byB0ZXN0IGZvciBxdWFkcmF0aWMgZGVwZW5kZW5jaWVzIGJldHdlZW4gc3VjY2Vzc2l2ZSByYW5kb21cbiAgIG51bWJlcnMuXG4qKVxubGV0IGluaXRfZGlmZjIgciA9IHN0MSA6PSBpbnQgcjsgc3QyIDo9IGludCByXG5sZXQgZGlmZjIgciA9XG4gIGxldCB4MSA9ICFzdDFcbiAgYW5kIHgyID0gIXN0MlxuICBhbmQgeDMgPSBpbnQgclxuICBpblxuICBzdDEgOj0geDI7XG4gIHN0MiA6PSB4MztcbiAgKHgzIC0geDIgLSB4MiArIHgxICsgMipyKSBtb2QgclxuXG5cbioqKioqKioqKioqKioqKioqKioqKVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBIYXNoIHRhYmxlcyAqKVxuXG4oKiBXZSBkbyBkeW5hbWljIGhhc2hpbmcsIGFuZCByZXNpemUgdGhlIHRhYmxlIGFuZCByZWhhc2ggdGhlIGVsZW1lbnRzXG4gICB3aGVuIGJ1Y2tldHMgYmVjb21lIHRvbyBsb25nLiAqKVxuXG50eXBlICgnYSwgJ2IpIHQgPVxuICB7IG11dGFibGUgc2l6ZTogaW50OyAgICAgICAgICAgICAgICAgICAgICAgICgqIG51bWJlciBvZiBlbnRyaWVzICopXG4gICAgbXV0YWJsZSBkYXRhOiAoJ2EsICdiKSBidWNrZXRsaXN0IGFycmF5OyAgKCogdGhlIGJ1Y2tldHMgKilcbiAgICBzZWVkOiBpbnQ7ICAgICAgICAgICAgICAgICAgICAgICAgKCogZm9yIHJhbmRvbWl6YXRpb24gKilcbiAgICBtdXRhYmxlIGluaXRpYWxfc2l6ZTogaW50OyAgICAgICAgICAgICAgICAoKiBpbml0aWFsIGFycmF5IHNpemUgKilcbiAgfVxuXG5hbmQgKCdhLCAnYikgYnVja2V0bGlzdCA9XG4gICAgRW1wdHlcbiAgfCBDb25zIG9mIHsgbXV0YWJsZSBrZXk6ICdhO1xuICAgICAgICAgICAgICBtdXRhYmxlIGRhdGE6ICdiO1xuICAgICAgICAgICAgICBtdXRhYmxlIG5leHQ6ICgnYSwgJ2IpIGJ1Y2tldGxpc3QgfVxuXG4oKiBUaGUgc2lnbiBvZiBpbml0aWFsX3NpemUgZW5jb2RlcyB0aGUgZmFjdCB0aGF0IGEgdHJhdmVyc2FsIGlzXG4gICBvbmdvaW5nIG9yIG5vdC5cblxuICAgVGhpcyBkaXNhYmxlcyB0aGUgZWZmaWNpZW50IGluIHBsYWNlIGltcGxlbWVudGF0aW9uIG9mIHJlc2l6aW5nLlxuKilcblxubGV0IG9uZ29pbmdfdHJhdmVyc2FsIGggPVxuICBPYmouc2l6ZSAoT2JqLnJlcHIgaCkgPCA0ICgqIGNvbXBhdGliaWxpdHkgd2l0aCBvbGQgaGFzaCB0YWJsZXMgKilcbiAgfHwgaC5pbml0aWFsX3NpemUgPCAwXG5cbmxldCBmbGlwX29uZ29pbmdfdHJhdmVyc2FsIGggPVxuICBoLmluaXRpYWxfc2l6ZSA8LSAtIGguaW5pdGlhbF9zaXplXG5cbigqIFRvIHBpY2sgcmFuZG9tIHNlZWRzIGlmIHJlcXVlc3RlZCAqKVxuXG5sZXQgcmFuZG9taXplZF9kZWZhdWx0ID1cbiAgbGV0IHBhcmFtcyA9XG4gICAgdHJ5IFN5cy5nZXRlbnYgXCJPQ0FNTFJVTlBBUkFNXCIgd2l0aCBOb3RfZm91bmQgLT5cbiAgICB0cnkgU3lzLmdldGVudiBcIkNBTUxSVU5QQVJBTVwiIHdpdGggTm90X2ZvdW5kIC0+IFwiXCIgaW5cbiAgU3RyaW5nLmNvbnRhaW5zIHBhcmFtcyAnUidcblxubGV0IHJhbmRvbWl6ZWQgPSByZWYgcmFuZG9taXplZF9kZWZhdWx0XG5cbmxldCByYW5kb21pemUgKCkgPSByYW5kb21pemVkIDo9IHRydWVcbmxldCBpc19yYW5kb21pemVkICgpID0gIXJhbmRvbWl6ZWRcblxubGV0IHBybmcgPSBsYXp5IChSYW5kb20uU3RhdGUubWFrZV9zZWxmX2luaXQoKSlcblxuKCogRnVuY3Rpb25zIHdoaWNoIGFwcGVhciBiZWZvcmUgdGhlIGZ1bmN0b3JpYWwgaW50ZXJmYWNlIG11c3QgZWl0aGVyIGJlXG4gICBpbmRlcGVuZGVudCBvZiB0aGUgaGFzaCBmdW5jdGlvbiBvciB0YWtlIGl0IGFzIGEgcGFyYW1ldGVyIChzZWUgIzIyMDIgYW5kXG4gICBjb2RlIGJlbG93IHRoZSBmdW5jdG9yIGRlZmluaXRpb25zLiAqKVxuXG4oKiBDcmVhdGluZyBhIGZyZXNoLCBlbXB0eSB0YWJsZSAqKVxuXG5sZXQgcmVjIHBvd2VyXzJfYWJvdmUgeCBuID1cbiAgaWYgeCA+PSBuIHRoZW4geFxuICBlbHNlIGlmIHggKiAyID4gU3lzLm1heF9hcnJheV9sZW5ndGggdGhlbiB4XG4gIGVsc2UgcG93ZXJfMl9hYm92ZSAoeCAqIDIpIG5cblxubGV0IGNyZWF0ZSA/KHJhbmRvbSA9ICFyYW5kb21pemVkKSBpbml0aWFsX3NpemUgPVxuICBsZXQgcyA9IHBvd2VyXzJfYWJvdmUgMTYgaW5pdGlhbF9zaXplIGluXG4gIGxldCBzZWVkID0gaWYgcmFuZG9tIHRoZW4gUmFuZG9tLlN0YXRlLmJpdHMgKExhenkuZm9yY2UgcHJuZykgZWxzZSAwIGluXG4gIHsgaW5pdGlhbF9zaXplID0gczsgc2l6ZSA9IDA7IHNlZWQgPSBzZWVkOyBkYXRhID0gQXJyYXkubWFrZSBzIEVtcHR5IH1cblxubGV0IGNsZWFyIGggPVxuICBpZiBoLnNpemUgPiAwIHRoZW4gYmVnaW5cbiAgICBoLnNpemUgPC0gMDtcbiAgICBBcnJheS5maWxsIGguZGF0YSAwIChBcnJheS5sZW5ndGggaC5kYXRhKSBFbXB0eVxuICBlbmRcblxubGV0IHJlc2V0IGggPVxuICBsZXQgbGVuID0gQXJyYXkubGVuZ3RoIGguZGF0YSBpblxuICBpZiBPYmouc2l6ZSAoT2JqLnJlcHIgaCkgPCA0ICgqIGNvbXBhdGliaWxpdHkgd2l0aCBvbGQgaGFzaCB0YWJsZXMgKilcbiAgICB8fCBsZW4gPSBhYnMgaC5pbml0aWFsX3NpemUgdGhlblxuICAgIGNsZWFyIGhcbiAgZWxzZSBiZWdpblxuICAgIGguc2l6ZSA8LSAwO1xuICAgIGguZGF0YSA8LSBBcnJheS5tYWtlIChhYnMgaC5pbml0aWFsX3NpemUpIEVtcHR5XG4gIGVuZFxuXG5sZXQgY29weV9idWNrZXRsaXN0ID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPiBFbXB0eVxuICB8IENvbnMge2tleTsgZGF0YTsgbmV4dH0gLT5cbiAgICAgIGxldCByZWMgbG9vcCBwcmVjID0gZnVuY3Rpb25cbiAgICAgICAgfCBFbXB0eSAtPiAoKVxuICAgICAgICB8IENvbnMge2tleTsgZGF0YTsgbmV4dH0gLT5cbiAgICAgICAgICAgIGxldCByID0gQ29ucyB7a2V5OyBkYXRhOyBuZXh0fSBpblxuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggcHJlYyB3aXRoXG4gICAgICAgICAgICB8IEVtcHR5IC0+IGFzc2VydCBmYWxzZVxuICAgICAgICAgICAgfCBDb25zIHByZWMgLT4gIHByZWMubmV4dCA8LSByXG4gICAgICAgICAgICBlbmQ7XG4gICAgICAgICAgICBsb29wIHIgbmV4dFxuICAgICAgaW5cbiAgICAgIGxldCByID0gQ29ucyB7a2V5OyBkYXRhOyBuZXh0fSBpblxuICAgICAgbG9vcCByIG5leHQ7XG4gICAgICByXG5cbmxldCBjb3B5IGggPSB7IGggd2l0aCBkYXRhID0gQXJyYXkubWFwIGNvcHlfYnVja2V0bGlzdCBoLmRhdGEgfVxuXG5sZXQgbGVuZ3RoIGggPSBoLnNpemVcblxubGV0IGluc2VydF9hbGxfYnVja2V0cyBpbmRleGZ1biBpbnBsYWNlIG9kYXRhIG5kYXRhID1cbiAgbGV0IG5zaXplID0gQXJyYXkubGVuZ3RoIG5kYXRhIGluXG4gIGxldCBuZGF0YV90YWlsID0gQXJyYXkubWFrZSBuc2l6ZSBFbXB0eSBpblxuICBsZXQgcmVjIGluc2VydF9idWNrZXQgPSBmdW5jdGlvblxuICAgIHwgRW1wdHkgLT4gKClcbiAgICB8IENvbnMge2tleTsgZGF0YTsgbmV4dH0gYXMgY2VsbCAtPlxuICAgICAgICBsZXQgY2VsbCA9XG4gICAgICAgICAgaWYgaW5wbGFjZSB0aGVuIGNlbGxcbiAgICAgICAgICBlbHNlIENvbnMge2tleTsgZGF0YTsgbmV4dCA9IEVtcHR5fVxuICAgICAgICBpblxuICAgICAgICBsZXQgbmlkeCA9IGluZGV4ZnVuIGtleSBpblxuICAgICAgICBiZWdpbiBtYXRjaCBuZGF0YV90YWlsLihuaWR4KSB3aXRoXG4gICAgICAgIHwgRW1wdHkgLT4gbmRhdGEuKG5pZHgpIDwtIGNlbGw7XG4gICAgICAgIHwgQ29ucyB0YWlsIC0+IHRhaWwubmV4dCA8LSBjZWxsO1xuICAgICAgICBlbmQ7XG4gICAgICAgIG5kYXRhX3RhaWwuKG5pZHgpIDwtIGNlbGw7XG4gICAgICAgIGluc2VydF9idWNrZXQgbmV4dFxuICBpblxuICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIG9kYXRhIC0gMSBkb1xuICAgIGluc2VydF9idWNrZXQgb2RhdGEuKGkpXG4gIGRvbmU7XG4gIGlmIGlucGxhY2UgdGhlblxuICAgIGZvciBpID0gMCB0byBuc2l6ZSAtIDEgZG9cbiAgICAgIG1hdGNoIG5kYXRhX3RhaWwuKGkpIHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gKClcbiAgICAgIHwgQ29ucyB0YWlsIC0+IHRhaWwubmV4dCA8LSBFbXB0eVxuICAgIGRvbmVcblxubGV0IHJlc2l6ZSBpbmRleGZ1biBoID1cbiAgbGV0IG9kYXRhID0gaC5kYXRhIGluXG4gIGxldCBvc2l6ZSA9IEFycmF5Lmxlbmd0aCBvZGF0YSBpblxuICBsZXQgbnNpemUgPSBvc2l6ZSAqIDIgaW5cbiAgaWYgbnNpemUgPCBTeXMubWF4X2FycmF5X2xlbmd0aCB0aGVuIGJlZ2luXG4gICAgbGV0IG5kYXRhID0gQXJyYXkubWFrZSBuc2l6ZSBFbXB0eSBpblxuICAgIGxldCBpbnBsYWNlID0gbm90IChvbmdvaW5nX3RyYXZlcnNhbCBoKSBpblxuICAgIGguZGF0YSA8LSBuZGF0YTsgICAgICAgICAgKCogc28gdGhhdCBpbmRleGZ1biBzZWVzIHRoZSBuZXcgYnVja2V0IGNvdW50ICopXG4gICAgaW5zZXJ0X2FsbF9idWNrZXRzIChpbmRleGZ1biBoKSBpbnBsYWNlIG9kYXRhIG5kYXRhXG4gIGVuZFxuXG5sZXQgaXRlciBmIGggPVxuICBsZXQgcmVjIGRvX2J1Y2tldCA9IGZ1bmN0aW9uXG4gICAgfCBFbXB0eSAtPlxuICAgICAgICAoKVxuICAgIHwgQ29uc3trZXk7IGRhdGE7IG5leHR9IC0+XG4gICAgICAgIGYga2V5IGRhdGE7IGRvX2J1Y2tldCBuZXh0IGluXG4gIGxldCBvbGRfdHJhdiA9IG9uZ29pbmdfdHJhdmVyc2FsIGggaW5cbiAgaWYgbm90IG9sZF90cmF2IHRoZW4gZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoO1xuICB0cnlcbiAgICBsZXQgZCA9IGguZGF0YSBpblxuICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggZCAtIDEgZG9cbiAgICAgIGRvX2J1Y2tldCBkLihpKVxuICAgIGRvbmU7XG4gICAgaWYgbm90IG9sZF90cmF2IHRoZW4gZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoO1xuICB3aXRoIGV4biB3aGVuIG5vdCBvbGRfdHJhdiAtPlxuICAgIGZsaXBfb25nb2luZ190cmF2ZXJzYWwgaDtcbiAgICByYWlzZSBleG5cblxubGV0IHJlYyBmaWx0ZXJfbWFwX2lucGxhY2VfYnVja2V0IGYgaCBpIHByZWMgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+XG4gICAgICBiZWdpbiBtYXRjaCBwcmVjIHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gaC5kYXRhLihpKSA8LSBFbXB0eVxuICAgICAgfCBDb25zIGMgLT4gYy5uZXh0IDwtIEVtcHR5XG4gICAgICBlbmRcbiAgfCAoQ29ucyAoe2tleTsgZGF0YTsgbmV4dH0gYXMgYykpIGFzIHNsb3QgLT5cbiAgICAgIGJlZ2luIG1hdGNoIGYga2V5IGRhdGEgd2l0aFxuICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgaC5zaXplIDwtIGguc2l6ZSAtIDE7XG4gICAgICAgICAgZmlsdGVyX21hcF9pbnBsYWNlX2J1Y2tldCBmIGggaSBwcmVjIG5leHRcbiAgICAgIHwgU29tZSBkYXRhIC0+XG4gICAgICAgICAgYmVnaW4gbWF0Y2ggcHJlYyB3aXRoXG4gICAgICAgICAgfCBFbXB0eSAtPiBoLmRhdGEuKGkpIDwtIHNsb3RcbiAgICAgICAgICB8IENvbnMgYyAtPiBjLm5leHQgPC0gc2xvdFxuICAgICAgICAgIGVuZDtcbiAgICAgICAgICBjLmRhdGEgPC0gZGF0YTtcbiAgICAgICAgICBmaWx0ZXJfbWFwX2lucGxhY2VfYnVja2V0IGYgaCBpIHNsb3QgbmV4dFxuICAgICAgZW5kXG5cbmxldCBmaWx0ZXJfbWFwX2lucGxhY2UgZiBoID1cbiAgbGV0IGQgPSBoLmRhdGEgaW5cbiAgbGV0IG9sZF90cmF2ID0gb25nb2luZ190cmF2ZXJzYWwgaCBpblxuICBpZiBub3Qgb2xkX3RyYXYgdGhlbiBmbGlwX29uZ29pbmdfdHJhdmVyc2FsIGg7XG4gIHRyeVxuICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggZCAtIDEgZG9cbiAgICAgIGZpbHRlcl9tYXBfaW5wbGFjZV9idWNrZXQgZiBoIGkgRW1wdHkgaC5kYXRhLihpKVxuICAgIGRvbmU7XG4gICAgaWYgbm90IG9sZF90cmF2IHRoZW4gZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoXG4gIHdpdGggZXhuIHdoZW4gbm90IG9sZF90cmF2IC0+XG4gICAgZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoO1xuICAgIHJhaXNlIGV4blxuXG5sZXQgZm9sZCBmIGggaW5pdCA9XG4gIGxldCByZWMgZG9fYnVja2V0IGIgYWNjdSA9XG4gICAgbWF0Y2ggYiB3aXRoXG4gICAgICBFbXB0eSAtPlxuICAgICAgICBhY2N1XG4gICAgfCBDb25ze2tleTsgZGF0YTsgbmV4dH0gLT5cbiAgICAgICAgZG9fYnVja2V0IG5leHQgKGYga2V5IGRhdGEgYWNjdSkgaW5cbiAgbGV0IG9sZF90cmF2ID0gb25nb2luZ190cmF2ZXJzYWwgaCBpblxuICBpZiBub3Qgb2xkX3RyYXYgdGhlbiBmbGlwX29uZ29pbmdfdHJhdmVyc2FsIGg7XG4gIHRyeVxuICAgIGxldCBkID0gaC5kYXRhIGluXG4gICAgbGV0IGFjY3UgPSByZWYgaW5pdCBpblxuICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggZCAtIDEgZG9cbiAgICAgIGFjY3UgOj0gZG9fYnVja2V0IGQuKGkpICFhY2N1XG4gICAgZG9uZTtcbiAgICBpZiBub3Qgb2xkX3RyYXYgdGhlbiBmbGlwX29uZ29pbmdfdHJhdmVyc2FsIGg7XG4gICAgIWFjY3VcbiAgd2l0aCBleG4gd2hlbiBub3Qgb2xkX3RyYXYgLT5cbiAgICBmbGlwX29uZ29pbmdfdHJhdmVyc2FsIGg7XG4gICAgcmFpc2UgZXhuXG5cbnR5cGUgc3RhdGlzdGljcyA9IHtcbiAgbnVtX2JpbmRpbmdzOiBpbnQ7XG4gIG51bV9idWNrZXRzOiBpbnQ7XG4gIG1heF9idWNrZXRfbGVuZ3RoOiBpbnQ7XG4gIGJ1Y2tldF9oaXN0b2dyYW06IGludCBhcnJheVxufVxuXG5sZXQgcmVjIGJ1Y2tldF9sZW5ndGggYWNjdSA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT4gYWNjdVxuICB8IENvbnN7bmV4dH0gLT4gYnVja2V0X2xlbmd0aCAoYWNjdSArIDEpIG5leHRcblxubGV0IHN0YXRzIGggPVxuICBsZXQgbWJsID1cbiAgICBBcnJheS5mb2xkX2xlZnQgKGZ1biBtIGIgLT4gSW50Lm1heCBtIChidWNrZXRfbGVuZ3RoIDAgYikpIDAgaC5kYXRhIGluXG4gIGxldCBoaXN0byA9IEFycmF5Lm1ha2UgKG1ibCArIDEpIDAgaW5cbiAgQXJyYXkuaXRlclxuICAgIChmdW4gYiAtPlxuICAgICAgbGV0IGwgPSBidWNrZXRfbGVuZ3RoIDAgYiBpblxuICAgICAgaGlzdG8uKGwpIDwtIGhpc3RvLihsKSArIDEpXG4gICAgaC5kYXRhO1xuICB7IG51bV9iaW5kaW5ncyA9IGguc2l6ZTtcbiAgICBudW1fYnVja2V0cyA9IEFycmF5Lmxlbmd0aCBoLmRhdGE7XG4gICAgbWF4X2J1Y2tldF9sZW5ndGggPSBtYmw7XG4gICAgYnVja2V0X2hpc3RvZ3JhbSA9IGhpc3RvIH1cblxuKCoqIHsxIEl0ZXJhdG9yc30gKilcblxubGV0IHRvX3NlcSB0YmwgPVxuICAoKiBjYXB0dXJlIGN1cnJlbnQgYXJyYXksIHNvIHRoYXQgZXZlbiBpZiB0aGUgdGFibGUgaXMgcmVzaXplZCB3ZVxuICAgICBrZWVwIGl0ZXJhdGluZyBvbiB0aGUgc2FtZSBhcnJheSAqKVxuICBsZXQgdGJsX2RhdGEgPSB0YmwuZGF0YSBpblxuICAoKiBzdGF0ZTogaW5kZXggKiBuZXh0IGJ1Y2tldCB0byB0cmF2ZXJzZSAqKVxuICBsZXQgcmVjIGF1eCBpIGJ1Y2sgKCkgPSBtYXRjaCBidWNrIHdpdGhcbiAgICB8IEVtcHR5IC0+XG4gICAgICAgIGlmIGkgPSBBcnJheS5sZW5ndGggdGJsX2RhdGFcbiAgICAgICAgdGhlbiBTZXEuTmlsXG4gICAgICAgIGVsc2UgYXV4KGkrMSkgdGJsX2RhdGEuKGkpICgpXG4gICAgfCBDb25zIHtrZXk7IGRhdGE7IG5leHR9IC0+XG4gICAgICAgIFNlcS5Db25zICgoa2V5LCBkYXRhKSwgYXV4IGkgbmV4dClcbiAgaW5cbiAgYXV4IDAgRW1wdHlcblxubGV0IHRvX3NlcV9rZXlzIG0gPSBTZXEubWFwIGZzdCAodG9fc2VxIG0pXG5cbmxldCB0b19zZXFfdmFsdWVzIG0gPSBTZXEubWFwIHNuZCAodG9fc2VxIG0pXG5cbigqIEZ1bmN0b3JpYWwgaW50ZXJmYWNlICopXG5cbm1vZHVsZSB0eXBlIEhhc2hlZFR5cGUgPVxuICBzaWdcbiAgICB0eXBlIHRcbiAgICB2YWwgZXF1YWw6IHQgLT4gdCAtPiBib29sXG4gICAgdmFsIGhhc2g6IHQgLT4gaW50XG4gIGVuZFxuXG5tb2R1bGUgdHlwZSBTZWVkZWRIYXNoZWRUeXBlID1cbiAgc2lnXG4gICAgdHlwZSB0XG4gICAgdmFsIGVxdWFsOiB0IC0+IHQgLT4gYm9vbFxuICAgIHZhbCBoYXNoOiBpbnQgLT4gdCAtPiBpbnRcbiAgZW5kXG5cbm1vZHVsZSB0eXBlIFMgPVxuICBzaWdcbiAgICB0eXBlIGtleVxuICAgIHR5cGUgISdhIHRcbiAgICB2YWwgY3JlYXRlOiBpbnQgLT4gJ2EgdFxuICAgIHZhbCBjbGVhciA6ICdhIHQgLT4gdW5pdFxuICAgIHZhbCByZXNldCA6ICdhIHQgLT4gdW5pdFxuICAgIHZhbCBjb3B5OiAnYSB0IC0+ICdhIHRcbiAgICB2YWwgYWRkOiAnYSB0IC0+IGtleSAtPiAnYSAtPiB1bml0XG4gICAgdmFsIHJlbW92ZTogJ2EgdCAtPiBrZXkgLT4gdW5pdFxuICAgIHZhbCBmaW5kOiAnYSB0IC0+IGtleSAtPiAnYVxuICAgIHZhbCBmaW5kX29wdDogJ2EgdCAtPiBrZXkgLT4gJ2Egb3B0aW9uXG4gICAgdmFsIGZpbmRfYWxsOiAnYSB0IC0+IGtleSAtPiAnYSBsaXN0XG4gICAgdmFsIHJlcGxhY2UgOiAnYSB0IC0+IGtleSAtPiAnYSAtPiB1bml0XG4gICAgdmFsIG1lbSA6ICdhIHQgLT4ga2V5IC0+IGJvb2xcbiAgICB2YWwgaXRlcjogKGtleSAtPiAnYSAtPiB1bml0KSAtPiAnYSB0IC0+IHVuaXRcbiAgICB2YWwgZmlsdGVyX21hcF9pbnBsYWNlOiAoa2V5IC0+ICdhIC0+ICdhIG9wdGlvbikgLT4gJ2EgdCAtPiB1bml0XG4gICAgdmFsIGZvbGQ6IChrZXkgLT4gJ2EgLT4gJ2IgLT4gJ2IpIC0+ICdhIHQgLT4gJ2IgLT4gJ2JcbiAgICB2YWwgbGVuZ3RoOiAnYSB0IC0+IGludFxuICAgIHZhbCBzdGF0czogJ2EgdCAtPiBzdGF0aXN0aWNzXG4gICAgdmFsIHRvX3NlcSA6ICdhIHQgLT4gKGtleSAqICdhKSBTZXEudFxuICAgIHZhbCB0b19zZXFfa2V5cyA6IF8gdCAtPiBrZXkgU2VxLnRcbiAgICB2YWwgdG9fc2VxX3ZhbHVlcyA6ICdhIHQgLT4gJ2EgU2VxLnRcbiAgICB2YWwgYWRkX3NlcSA6ICdhIHQgLT4gKGtleSAqICdhKSBTZXEudCAtPiB1bml0XG4gICAgdmFsIHJlcGxhY2Vfc2VxIDogJ2EgdCAtPiAoa2V5ICogJ2EpIFNlcS50IC0+IHVuaXRcbiAgICB2YWwgb2Zfc2VxIDogKGtleSAqICdhKSBTZXEudCAtPiAnYSB0XG4gIGVuZFxuXG5tb2R1bGUgdHlwZSBTZWVkZWRTID1cbiAgc2lnXG4gICAgdHlwZSBrZXlcbiAgICB0eXBlICEnYSB0XG4gICAgdmFsIGNyZWF0ZSA6ID9yYW5kb206Ym9vbCAtPiBpbnQgLT4gJ2EgdFxuICAgIHZhbCBjbGVhciA6ICdhIHQgLT4gdW5pdFxuICAgIHZhbCByZXNldCA6ICdhIHQgLT4gdW5pdFxuICAgIHZhbCBjb3B5IDogJ2EgdCAtPiAnYSB0XG4gICAgdmFsIGFkZCA6ICdhIHQgLT4ga2V5IC0+ICdhIC0+IHVuaXRcbiAgICB2YWwgcmVtb3ZlIDogJ2EgdCAtPiBrZXkgLT4gdW5pdFxuICAgIHZhbCBmaW5kIDogJ2EgdCAtPiBrZXkgLT4gJ2FcbiAgICB2YWwgZmluZF9vcHQ6ICdhIHQgLT4ga2V5IC0+ICdhIG9wdGlvblxuICAgIHZhbCBmaW5kX2FsbCA6ICdhIHQgLT4ga2V5IC0+ICdhIGxpc3RcbiAgICB2YWwgcmVwbGFjZSA6ICdhIHQgLT4ga2V5IC0+ICdhIC0+IHVuaXRcbiAgICB2YWwgbWVtIDogJ2EgdCAtPiBrZXkgLT4gYm9vbFxuICAgIHZhbCBpdGVyIDogKGtleSAtPiAnYSAtPiB1bml0KSAtPiAnYSB0IC0+IHVuaXRcbiAgICB2YWwgZmlsdGVyX21hcF9pbnBsYWNlOiAoa2V5IC0+ICdhIC0+ICdhIG9wdGlvbikgLT4gJ2EgdCAtPiB1bml0XG4gICAgdmFsIGZvbGQgOiAoa2V5IC0+ICdhIC0+ICdiIC0+ICdiKSAtPiAnYSB0IC0+ICdiIC0+ICdiXG4gICAgdmFsIGxlbmd0aCA6ICdhIHQgLT4gaW50XG4gICAgdmFsIHN0YXRzOiAnYSB0IC0+IHN0YXRpc3RpY3NcbiAgICB2YWwgdG9fc2VxIDogJ2EgdCAtPiAoa2V5ICogJ2EpIFNlcS50XG4gICAgdmFsIHRvX3NlcV9rZXlzIDogXyB0IC0+IGtleSBTZXEudFxuICAgIHZhbCB0b19zZXFfdmFsdWVzIDogJ2EgdCAtPiAnYSBTZXEudFxuICAgIHZhbCBhZGRfc2VxIDogJ2EgdCAtPiAoa2V5ICogJ2EpIFNlcS50IC0+IHVuaXRcbiAgICB2YWwgcmVwbGFjZV9zZXEgOiAnYSB0IC0+IChrZXkgKiAnYSkgU2VxLnQgLT4gdW5pdFxuICAgIHZhbCBvZl9zZXEgOiAoa2V5ICogJ2EpIFNlcS50IC0+ICdhIHRcbiAgZW5kXG5cbm1vZHVsZSBNYWtlU2VlZGVkKEg6IFNlZWRlZEhhc2hlZFR5cGUpOiAoU2VlZGVkUyB3aXRoIHR5cGUga2V5ID0gSC50KSA9XG4gIHN0cnVjdFxuICAgIHR5cGUga2V5ID0gSC50XG4gICAgdHlwZSAnYSBoYXNodGJsID0gKGtleSwgJ2EpIHRcbiAgICB0eXBlICdhIHQgPSAnYSBoYXNodGJsXG4gICAgbGV0IGNyZWF0ZSA9IGNyZWF0ZVxuICAgIGxldCBjbGVhciA9IGNsZWFyXG4gICAgbGV0IHJlc2V0ID0gcmVzZXRcbiAgICBsZXQgY29weSA9IGNvcHlcblxuICAgIGxldCBrZXlfaW5kZXggaCBrZXkgPVxuICAgICAgKEguaGFzaCBoLnNlZWQga2V5KSBsYW5kIChBcnJheS5sZW5ndGggaC5kYXRhIC0gMSlcblxuICAgIGxldCBhZGQgaCBrZXkgZGF0YSA9XG4gICAgICBsZXQgaSA9IGtleV9pbmRleCBoIGtleSBpblxuICAgICAgbGV0IGJ1Y2tldCA9IENvbnN7a2V5OyBkYXRhOyBuZXh0PWguZGF0YS4oaSl9IGluXG4gICAgICBoLmRhdGEuKGkpIDwtIGJ1Y2tldDtcbiAgICAgIGguc2l6ZSA8LSBoLnNpemUgKyAxO1xuICAgICAgaWYgaC5zaXplID4gQXJyYXkubGVuZ3RoIGguZGF0YSBsc2wgMSB0aGVuIHJlc2l6ZSBrZXlfaW5kZXggaFxuXG4gICAgbGV0IHJlYyByZW1vdmVfYnVja2V0IGggaSBrZXkgcHJlYyA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgKClcbiAgICAgIHwgKENvbnMge2tleT1rOyBuZXh0fSkgYXMgYyAtPlxuICAgICAgICAgIGlmIEguZXF1YWwgayBrZXlcbiAgICAgICAgICB0aGVuIGJlZ2luXG4gICAgICAgICAgICBoLnNpemUgPC0gaC5zaXplIC0gMTtcbiAgICAgICAgICAgIG1hdGNoIHByZWMgd2l0aFxuICAgICAgICAgICAgfCBFbXB0eSAtPiBoLmRhdGEuKGkpIDwtIG5leHRcbiAgICAgICAgICAgIHwgQ29ucyBjIC0+IGMubmV4dCA8LSBuZXh0XG4gICAgICAgICAgZW5kXG4gICAgICAgICAgZWxzZSByZW1vdmVfYnVja2V0IGggaSBrZXkgYyBuZXh0XG5cbiAgICBsZXQgcmVtb3ZlIGgga2V5ID1cbiAgICAgIGxldCBpID0ga2V5X2luZGV4IGgga2V5IGluXG4gICAgICByZW1vdmVfYnVja2V0IGggaSBrZXkgRW1wdHkgaC5kYXRhLihpKVxuXG4gICAgbGV0IHJlYyBmaW5kX3JlYyBrZXkgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgIHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBDb25ze2tleT1rOyBkYXRhOyBuZXh0fSAtPlxuICAgICAgICAgIGlmIEguZXF1YWwga2V5IGsgdGhlbiBkYXRhIGVsc2UgZmluZF9yZWMga2V5IG5leHRcblxuICAgIGxldCBmaW5kIGgga2V5ID1cbiAgICAgIG1hdGNoIGguZGF0YS4oa2V5X2luZGV4IGgga2V5KSB3aXRoXG4gICAgICB8IEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBDb25ze2tleT1rMTsgZGF0YT1kMTsgbmV4dD1uZXh0MX0gLT5cbiAgICAgICAgICBpZiBILmVxdWFsIGtleSBrMSB0aGVuIGQxIGVsc2VcbiAgICAgICAgICBtYXRjaCBuZXh0MSB3aXRoXG4gICAgICAgICAgfCBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgICAgICB8IENvbnN7a2V5PWsyOyBkYXRhPWQyOyBuZXh0PW5leHQyfSAtPlxuICAgICAgICAgICAgICBpZiBILmVxdWFsIGtleSBrMiB0aGVuIGQyIGVsc2VcbiAgICAgICAgICAgICAgbWF0Y2ggbmV4dDIgd2l0aFxuICAgICAgICAgICAgICB8IEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgICAgICAgICB8IENvbnN7a2V5PWszOyBkYXRhPWQzOyBuZXh0PW5leHQzfSAtPlxuICAgICAgICAgICAgICAgICAgaWYgSC5lcXVhbCBrZXkgazMgdGhlbiBkMyBlbHNlIGZpbmRfcmVjIGtleSBuZXh0M1xuXG4gICAgbGV0IHJlYyBmaW5kX3JlY19vcHQga2V5ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICBOb25lXG4gICAgICB8IENvbnN7a2V5PWs7IGRhdGE7IG5leHR9IC0+XG4gICAgICAgICAgaWYgSC5lcXVhbCBrZXkgayB0aGVuIFNvbWUgZGF0YSBlbHNlIGZpbmRfcmVjX29wdCBrZXkgbmV4dFxuXG4gICAgbGV0IGZpbmRfb3B0IGgga2V5ID1cbiAgICAgIG1hdGNoIGguZGF0YS4oa2V5X2luZGV4IGgga2V5KSB3aXRoXG4gICAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICAgIHwgQ29uc3trZXk9azE7IGRhdGE9ZDE7IG5leHQ9bmV4dDF9IC0+XG4gICAgICAgICAgaWYgSC5lcXVhbCBrZXkgazEgdGhlbiBTb21lIGQxIGVsc2VcbiAgICAgICAgICBtYXRjaCBuZXh0MSB3aXRoXG4gICAgICAgICAgfCBFbXB0eSAtPiBOb25lXG4gICAgICAgICAgfCBDb25ze2tleT1rMjsgZGF0YT1kMjsgbmV4dD1uZXh0Mn0gLT5cbiAgICAgICAgICAgICAgaWYgSC5lcXVhbCBrZXkgazIgdGhlbiBTb21lIGQyIGVsc2VcbiAgICAgICAgICAgICAgbWF0Y2ggbmV4dDIgd2l0aFxuICAgICAgICAgICAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICAgICAgICAgICAgfCBDb25ze2tleT1rMzsgZGF0YT1kMzsgbmV4dD1uZXh0M30gLT5cbiAgICAgICAgICAgICAgICAgIGlmIEguZXF1YWwga2V5IGszIHRoZW4gU29tZSBkMyBlbHNlIGZpbmRfcmVjX29wdCBrZXkgbmV4dDNcblxuICAgIGxldCBmaW5kX2FsbCBoIGtleSA9XG4gICAgICBsZXQgcmVjIGZpbmRfaW5fYnVja2V0ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICBbXVxuICAgICAgfCBDb25ze2tleT1rOyBkYXRhPWQ7IG5leHR9IC0+XG4gICAgICAgICAgaWYgSC5lcXVhbCBrIGtleVxuICAgICAgICAgIHRoZW4gZCA6OiBmaW5kX2luX2J1Y2tldCBuZXh0XG4gICAgICAgICAgZWxzZSBmaW5kX2luX2J1Y2tldCBuZXh0IGluXG4gICAgICBmaW5kX2luX2J1Y2tldCBoLmRhdGEuKGtleV9pbmRleCBoIGtleSlcblxuICAgIGxldCByZWMgcmVwbGFjZV9idWNrZXQga2V5IGRhdGEgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgIHRydWVcbiAgICAgIHwgQ29ucyAoe2tleT1rOyBuZXh0fSBhcyBzbG90KSAtPlxuICAgICAgICAgIGlmIEguZXF1YWwgayBrZXlcbiAgICAgICAgICB0aGVuIChzbG90LmtleSA8LSBrZXk7IHNsb3QuZGF0YSA8LSBkYXRhOyBmYWxzZSlcbiAgICAgICAgICBlbHNlIHJlcGxhY2VfYnVja2V0IGtleSBkYXRhIG5leHRcblxuICAgIGxldCByZXBsYWNlIGgga2V5IGRhdGEgPVxuICAgICAgbGV0IGkgPSBrZXlfaW5kZXggaCBrZXkgaW5cbiAgICAgIGxldCBsID0gaC5kYXRhLihpKSBpblxuICAgICAgaWYgcmVwbGFjZV9idWNrZXQga2V5IGRhdGEgbCB0aGVuIGJlZ2luXG4gICAgICAgIGguZGF0YS4oaSkgPC0gQ29uc3trZXk7IGRhdGE7IG5leHQ9bH07XG4gICAgICAgIGguc2l6ZSA8LSBoLnNpemUgKyAxO1xuICAgICAgICBpZiBoLnNpemUgPiBBcnJheS5sZW5ndGggaC5kYXRhIGxzbCAxIHRoZW4gcmVzaXplIGtleV9pbmRleCBoXG4gICAgICBlbmRcblxuICAgIGxldCBtZW0gaCBrZXkgPVxuICAgICAgbGV0IHJlYyBtZW1faW5fYnVja2V0ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICBmYWxzZVxuICAgICAgfCBDb25ze2tleT1rOyBuZXh0fSAtPlxuICAgICAgICAgIEguZXF1YWwgayBrZXkgfHwgbWVtX2luX2J1Y2tldCBuZXh0IGluXG4gICAgICBtZW1faW5fYnVja2V0IGguZGF0YS4oa2V5X2luZGV4IGgga2V5KVxuXG4gICAgbGV0IGFkZF9zZXEgdGJsIGkgPVxuICAgICAgU2VxLml0ZXIgKGZ1biAoayx2KSAtPiBhZGQgdGJsIGsgdikgaVxuXG4gICAgbGV0IHJlcGxhY2Vfc2VxIHRibCBpID1cbiAgICAgIFNlcS5pdGVyIChmdW4gKGssdikgLT4gcmVwbGFjZSB0YmwgayB2KSBpXG5cbiAgICBsZXQgb2Zfc2VxIGkgPVxuICAgICAgbGV0IHRibCA9IGNyZWF0ZSAxNiBpblxuICAgICAgcmVwbGFjZV9zZXEgdGJsIGk7XG4gICAgICB0YmxcblxuICAgIGxldCBpdGVyID0gaXRlclxuICAgIGxldCBmaWx0ZXJfbWFwX2lucGxhY2UgPSBmaWx0ZXJfbWFwX2lucGxhY2VcbiAgICBsZXQgZm9sZCA9IGZvbGRcbiAgICBsZXQgbGVuZ3RoID0gbGVuZ3RoXG4gICAgbGV0IHN0YXRzID0gc3RhdHNcbiAgICBsZXQgdG9fc2VxID0gdG9fc2VxXG4gICAgbGV0IHRvX3NlcV9rZXlzID0gdG9fc2VxX2tleXNcbiAgICBsZXQgdG9fc2VxX3ZhbHVlcyA9IHRvX3NlcV92YWx1ZXNcbiAgZW5kXG5cbm1vZHVsZSBNYWtlKEg6IEhhc2hlZFR5cGUpOiAoUyB3aXRoIHR5cGUga2V5ID0gSC50KSA9XG4gIHN0cnVjdFxuICAgIGluY2x1ZGUgTWFrZVNlZWRlZChzdHJ1Y3RcbiAgICAgICAgdHlwZSB0ID0gSC50XG4gICAgICAgIGxldCBlcXVhbCA9IEguZXF1YWxcbiAgICAgICAgbGV0IGhhc2ggKF9zZWVkOiBpbnQpIHggPSBILmhhc2ggeFxuICAgICAgZW5kKVxuICAgIGxldCBjcmVhdGUgc3ogPSBjcmVhdGUgfnJhbmRvbTpmYWxzZSBzelxuICAgIGxldCBvZl9zZXEgaSA9XG4gICAgICBsZXQgdGJsID0gY3JlYXRlIDE2IGluXG4gICAgICByZXBsYWNlX3NlcSB0YmwgaTtcbiAgICAgIHRibFxuICBlbmRcblxuKCogUG9seW1vcnBoaWMgaGFzaCBmdW5jdGlvbi1iYXNlZCB0YWJsZXMgKilcbigqIENvZGUgaW5jbHVkZWQgYmVsb3cgdGhlIGZ1bmN0b3JpYWwgaW50ZXJmYWNlIHRvIGd1YXJkIGFnYWluc3QgYWNjaWRlbnRhbFxuICAgdXNlIC0gc2VlICMyMjAyICopXG5cbmV4dGVybmFsIHNlZWRlZF9oYXNoX3BhcmFtIDpcbiAgaW50IC0+IGludCAtPiBpbnQgLT4gJ2EgLT4gaW50ID0gXCJjYW1sX2hhc2hcIiBbQEBub2FsbG9jXVxuXG5sZXQgaGFzaCB4ID0gc2VlZGVkX2hhc2hfcGFyYW0gMTAgMTAwIDAgeFxubGV0IGhhc2hfcGFyYW0gbjEgbjIgeCA9IHNlZWRlZF9oYXNoX3BhcmFtIG4xIG4yIDAgeFxubGV0IHNlZWRlZF9oYXNoIHNlZWQgeCA9IHNlZWRlZF9oYXNoX3BhcmFtIDEwIDEwMCBzZWVkIHhcblxubGV0IGtleV9pbmRleCBoIGtleSA9XG4gIGlmIE9iai5zaXplIChPYmoucmVwciBoKSA+PSA0XG4gIHRoZW4gKHNlZWRlZF9oYXNoX3BhcmFtIDEwIDEwMCBoLnNlZWQga2V5KSBsYW5kIChBcnJheS5sZW5ndGggaC5kYXRhIC0gMSlcbiAgZWxzZSBpbnZhbGlkX2FyZyBcIkhhc2h0Ymw6IHVuc3VwcG9ydGVkIGhhc2ggdGFibGUgZm9ybWF0XCJcblxubGV0IGFkZCBoIGtleSBkYXRhID1cbiAgbGV0IGkgPSBrZXlfaW5kZXggaCBrZXkgaW5cbiAgbGV0IGJ1Y2tldCA9IENvbnN7a2V5OyBkYXRhOyBuZXh0PWguZGF0YS4oaSl9IGluXG4gIGguZGF0YS4oaSkgPC0gYnVja2V0O1xuICBoLnNpemUgPC0gaC5zaXplICsgMTtcbiAgaWYgaC5zaXplID4gQXJyYXkubGVuZ3RoIGguZGF0YSBsc2wgMSB0aGVuIHJlc2l6ZSBrZXlfaW5kZXggaFxuXG5sZXQgcmVjIHJlbW92ZV9idWNrZXQgaCBpIGtleSBwcmVjID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPlxuICAgICAgKClcbiAgfCAoQ29ucyB7a2V5PWs7IG5leHR9KSBhcyBjIC0+XG4gICAgICBpZiBjb21wYXJlIGsga2V5ID0gMFxuICAgICAgdGhlbiBiZWdpblxuICAgICAgICBoLnNpemUgPC0gaC5zaXplIC0gMTtcbiAgICAgICAgbWF0Y2ggcHJlYyB3aXRoXG4gICAgICAgIHwgRW1wdHkgLT4gaC5kYXRhLihpKSA8LSBuZXh0XG4gICAgICAgIHwgQ29ucyBjIC0+IGMubmV4dCA8LSBuZXh0XG4gICAgICBlbmRcbiAgICAgIGVsc2UgcmVtb3ZlX2J1Y2tldCBoIGkga2V5IGMgbmV4dFxuXG5sZXQgcmVtb3ZlIGgga2V5ID1cbiAgbGV0IGkgPSBrZXlfaW5kZXggaCBrZXkgaW5cbiAgcmVtb3ZlX2J1Y2tldCBoIGkga2V5IEVtcHR5IGguZGF0YS4oaSlcblxubGV0IHJlYyBmaW5kX3JlYyBrZXkgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+XG4gICAgICByYWlzZSBOb3RfZm91bmRcbiAgfCBDb25ze2tleT1rOyBkYXRhOyBuZXh0fSAtPlxuICAgICAgaWYgY29tcGFyZSBrZXkgayA9IDAgdGhlbiBkYXRhIGVsc2UgZmluZF9yZWMga2V5IG5leHRcblxubGV0IGZpbmQgaCBrZXkgPVxuICBtYXRjaCBoLmRhdGEuKGtleV9pbmRleCBoIGtleSkgd2l0aFxuICB8IEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICB8IENvbnN7a2V5PWsxOyBkYXRhPWQxOyBuZXh0PW5leHQxfSAtPlxuICAgICAgaWYgY29tcGFyZSBrZXkgazEgPSAwIHRoZW4gZDEgZWxzZVxuICAgICAgbWF0Y2ggbmV4dDEgd2l0aFxuICAgICAgfCBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgQ29uc3trZXk9azI7IGRhdGE9ZDI7IG5leHQ9bmV4dDJ9IC0+XG4gICAgICAgICAgaWYgY29tcGFyZSBrZXkgazIgPSAwIHRoZW4gZDIgZWxzZVxuICAgICAgICAgIG1hdGNoIG5leHQyIHdpdGhcbiAgICAgICAgICB8IEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgICAgIHwgQ29uc3trZXk9azM7IGRhdGE9ZDM7IG5leHQ9bmV4dDN9IC0+XG4gICAgICAgICAgICAgIGlmIGNvbXBhcmUga2V5IGszID0gMCB0aGVuIGQzIGVsc2UgZmluZF9yZWMga2V5IG5leHQzXG5cbmxldCByZWMgZmluZF9yZWNfb3B0IGtleSA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT5cbiAgICAgIE5vbmVcbiAgfCBDb25ze2tleT1rOyBkYXRhOyBuZXh0fSAtPlxuICAgICAgaWYgY29tcGFyZSBrZXkgayA9IDAgdGhlbiBTb21lIGRhdGEgZWxzZSBmaW5kX3JlY19vcHQga2V5IG5leHRcblxubGV0IGZpbmRfb3B0IGgga2V5ID1cbiAgbWF0Y2ggaC5kYXRhLihrZXlfaW5kZXggaCBrZXkpIHdpdGhcbiAgfCBFbXB0eSAtPiBOb25lXG4gIHwgQ29uc3trZXk9azE7IGRhdGE9ZDE7IG5leHQ9bmV4dDF9IC0+XG4gICAgICBpZiBjb21wYXJlIGtleSBrMSA9IDAgdGhlbiBTb21lIGQxIGVsc2VcbiAgICAgIG1hdGNoIG5leHQxIHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgICAgfCBDb25ze2tleT1rMjsgZGF0YT1kMjsgbmV4dD1uZXh0Mn0gLT5cbiAgICAgICAgICBpZiBjb21wYXJlIGtleSBrMiA9IDAgdGhlbiBTb21lIGQyIGVsc2VcbiAgICAgICAgICBtYXRjaCBuZXh0MiB3aXRoXG4gICAgICAgICAgfCBFbXB0eSAtPiBOb25lXG4gICAgICAgICAgfCBDb25ze2tleT1rMzsgZGF0YT1kMzsgbmV4dD1uZXh0M30gLT5cbiAgICAgICAgICAgICAgaWYgY29tcGFyZSBrZXkgazMgPSAwIHRoZW4gU29tZSBkMyBlbHNlIGZpbmRfcmVjX29wdCBrZXkgbmV4dDNcblxubGV0IGZpbmRfYWxsIGgga2V5ID1cbiAgbGV0IHJlYyBmaW5kX2luX2J1Y2tldCA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT5cbiAgICAgIFtdXG4gIHwgQ29uc3trZXk9azsgZGF0YTsgbmV4dH0gLT5cbiAgICAgIGlmIGNvbXBhcmUgayBrZXkgPSAwXG4gICAgICB0aGVuIGRhdGEgOjogZmluZF9pbl9idWNrZXQgbmV4dFxuICAgICAgZWxzZSBmaW5kX2luX2J1Y2tldCBuZXh0IGluXG4gIGZpbmRfaW5fYnVja2V0IGguZGF0YS4oa2V5X2luZGV4IGgga2V5KVxuXG5sZXQgcmVjIHJlcGxhY2VfYnVja2V0IGtleSBkYXRhID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPlxuICAgICAgdHJ1ZVxuICB8IENvbnMgKHtrZXk9azsgbmV4dH0gYXMgc2xvdCkgLT5cbiAgICAgIGlmIGNvbXBhcmUgayBrZXkgPSAwXG4gICAgICB0aGVuIChzbG90LmtleSA8LSBrZXk7IHNsb3QuZGF0YSA8LSBkYXRhOyBmYWxzZSlcbiAgICAgIGVsc2UgcmVwbGFjZV9idWNrZXQga2V5IGRhdGEgbmV4dFxuXG5sZXQgcmVwbGFjZSBoIGtleSBkYXRhID1cbiAgbGV0IGkgPSBrZXlfaW5kZXggaCBrZXkgaW5cbiAgbGV0IGwgPSBoLmRhdGEuKGkpIGluXG4gIGlmIHJlcGxhY2VfYnVja2V0IGtleSBkYXRhIGwgdGhlbiBiZWdpblxuICAgIGguZGF0YS4oaSkgPC0gQ29uc3trZXk7IGRhdGE7IG5leHQ9bH07XG4gICAgaC5zaXplIDwtIGguc2l6ZSArIDE7XG4gICAgaWYgaC5zaXplID4gQXJyYXkubGVuZ3RoIGguZGF0YSBsc2wgMSB0aGVuIHJlc2l6ZSBrZXlfaW5kZXggaFxuICBlbmRcblxubGV0IG1lbSBoIGtleSA9XG4gIGxldCByZWMgbWVtX2luX2J1Y2tldCA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT5cbiAgICAgIGZhbHNlXG4gIHwgQ29uc3trZXk9azsgbmV4dH0gLT5cbiAgICAgIGNvbXBhcmUgayBrZXkgPSAwIHx8IG1lbV9pbl9idWNrZXQgbmV4dCBpblxuICBtZW1faW5fYnVja2V0IGguZGF0YS4oa2V5X2luZGV4IGgga2V5KVxuXG5sZXQgYWRkX3NlcSB0YmwgaSA9XG4gIFNlcS5pdGVyIChmdW4gKGssdikgLT4gYWRkIHRibCBrIHYpIGlcblxubGV0IHJlcGxhY2Vfc2VxIHRibCBpID1cbiAgU2VxLml0ZXIgKGZ1biAoayx2KSAtPiByZXBsYWNlIHRibCBrIHYpIGlcblxubGV0IG9mX3NlcSBpID1cbiAgbGV0IHRibCA9IGNyZWF0ZSAxNiBpblxuICByZXBsYWNlX3NlcSB0YmwgaTtcbiAgdGJsXG5cbmxldCByZWJ1aWxkID8ocmFuZG9tID0gIXJhbmRvbWl6ZWQpIGggPVxuICBsZXQgcyA9IHBvd2VyXzJfYWJvdmUgMTYgKEFycmF5Lmxlbmd0aCBoLmRhdGEpIGluXG4gIGxldCBzZWVkID1cbiAgICBpZiByYW5kb20gdGhlbiBSYW5kb20uU3RhdGUuYml0cyAoTGF6eS5mb3JjZSBwcm5nKVxuICAgIGVsc2UgaWYgT2JqLnNpemUgKE9iai5yZXByIGgpID49IDQgdGhlbiBoLnNlZWRcbiAgICBlbHNlIDAgaW5cbiAgbGV0IGgnID0ge1xuICAgIHNpemUgPSBoLnNpemU7XG4gICAgZGF0YSA9IEFycmF5Lm1ha2UgcyBFbXB0eTtcbiAgICBzZWVkID0gc2VlZDtcbiAgICBpbml0aWFsX3NpemUgPSBpZiBPYmouc2l6ZSAoT2JqLnJlcHIgaCkgPj0gNCB0aGVuIGguaW5pdGlhbF9zaXplIGVsc2Ugc1xuICB9IGluXG4gIGluc2VydF9hbGxfYnVja2V0cyAoa2V5X2luZGV4IGgnKSBmYWxzZSBoLmRhdGEgaCcuZGF0YTtcbiAgaCdcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIERhbWllbiBEb2xpZ2V6LCBwcm9qZXQgUGFyYSwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTcgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCoqIFdlYWsgYXJyYXkgb3BlcmF0aW9ucyAqKVxuXG50eXBlICEnYSB0XG5cbmV4dGVybmFsIGNyZWF0ZSA6IGludCAtPiAnYSB0ID0gXCJjYW1sX3dlYWtfY3JlYXRlXCJcblxubGV0IGNyZWF0ZSBsID1cbiAgaWYgbm90ICgwIDw9IGwgJiYgbCA8PSBPYmouRXBoZW1lcm9uLm1heF9lcGhlX2xlbmd0aCkgdGhlblxuICAgIGludmFsaWRfYXJnKFwiV2Vhay5jcmVhdGVcIik7XG4gIGNyZWF0ZSBsXG5cbigqKiBudW1iZXIgb2YgYWRkaXRpb25hbCB2YWx1ZXMgaW4gYSB3ZWFrIHBvaW50ZXIgKilcbmxldCBhZGRpdGlvbmFsX3ZhbHVlcyA9IDJcblxubGV0IGxlbmd0aCB4ID0gT2JqLnNpemUoT2JqLnJlcHIgeCkgLSBhZGRpdGlvbmFsX3ZhbHVlc1xuXG5sZXQgcmFpc2VfaWZfaW52YWxpZF9vZmZzZXQgZSBvIG1zZyA9XG4gIGlmIG5vdCAoMCA8PSBvICYmIG8gPCBsZW5ndGggZSkgdGhlblxuICAgIGludmFsaWRfYXJnKG1zZylcblxuZXh0ZXJuYWwgc2V0JyA6ICdhIHQgLT4gaW50IC0+ICdhIC0+IHVuaXQgPSBcImNhbWxfZXBoZV9zZXRfa2V5XCJcbmV4dGVybmFsIHVuc2V0IDogJ2EgdCAtPiBpbnQgLT4gdW5pdCA9IFwiY2FtbF9lcGhlX3Vuc2V0X2tleVwiXG5sZXQgc2V0IGUgbyB4ID1cbiAgcmFpc2VfaWZfaW52YWxpZF9vZmZzZXQgZSBvIFwiV2Vhay5zZXRcIjtcbiAgbWF0Y2ggeCB3aXRoXG4gIHwgTm9uZSAtPiB1bnNldCBlIG9cbiAgfCBTb21lIHggLT4gc2V0JyBlIG8geFxuXG5leHRlcm5hbCBnZXQgOiAnYSB0IC0+IGludCAtPiAnYSBvcHRpb24gPSBcImNhbWxfd2Vha19nZXRcIlxubGV0IGdldCBlIG8gPVxuICByYWlzZV9pZl9pbnZhbGlkX29mZnNldCBlIG8gXCJXZWFrLmdldFwiO1xuICBnZXQgZSBvXG5cbmV4dGVybmFsIGdldF9jb3B5IDogJ2EgdCAtPiBpbnQgLT4gJ2Egb3B0aW9uID0gXCJjYW1sX3dlYWtfZ2V0X2NvcHlcIlxubGV0IGdldF9jb3B5IGUgbyA9XG4gIHJhaXNlX2lmX2ludmFsaWRfb2Zmc2V0IGUgbyBcIldlYWsuZ2V0X2NvcHlcIjtcbiAgZ2V0X2NvcHkgZSBvXG5cbmV4dGVybmFsIGNoZWNrIDogJ2EgdCAtPiBpbnQgLT4gYm9vbCA9IFwiY2FtbF93ZWFrX2NoZWNrXCJcbmxldCBjaGVjayBlIG8gPVxuICByYWlzZV9pZl9pbnZhbGlkX29mZnNldCBlIG8gXCJXZWFrLmNoZWNrXCI7XG4gIGNoZWNrIGUgb1xuXG5leHRlcm5hbCBibGl0IDogJ2EgdCAtPiBpbnQgLT4gJ2EgdCAtPiBpbnQgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfd2Vha19ibGl0XCJcblxuKCogYmxpdDogc3JjIHNyY29mZiBkc3QgZHN0b2ZmIGxlbiAqKVxubGV0IGJsaXQgZTEgbzEgZTIgbzIgbCA9XG4gIGlmIGwgPCAwIHx8IG8xIDwgMCB8fCBvMSA+IGxlbmd0aCBlMSAtIGxcbiAgICAgfHwgbzIgPCAwIHx8IG8yID4gbGVuZ3RoIGUyIC0gbFxuICB0aGVuIGludmFsaWRfYXJnIFwiV2Vhay5ibGl0XCJcbiAgZWxzZSBpZiBsIDw+IDAgdGhlbiBibGl0IGUxIG8xIGUyIG8yIGxcblxubGV0IGZpbGwgYXIgb2ZzIGxlbiB4ID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IGxlbmd0aCBhciAtIGxlblxuICB0aGVuIHJhaXNlIChJbnZhbGlkX2FyZ3VtZW50IFwiV2Vhay5maWxsXCIpXG4gIGVsc2UgYmVnaW5cbiAgICBmb3IgaSA9IG9mcyB0byAob2ZzICsgbGVuIC0gMSkgZG9cbiAgICAgIHNldCBhciBpIHhcbiAgICBkb25lXG4gIGVuZFxuXG5cbigqKiBXZWFrIGhhc2ggdGFibGVzICopXG5cbm1vZHVsZSB0eXBlIFMgPSBzaWdcbiAgdHlwZSBkYXRhXG4gIHR5cGUgdFxuICB2YWwgY3JlYXRlIDogaW50IC0+IHRcbiAgdmFsIGNsZWFyIDogdCAtPiB1bml0XG4gIHZhbCBtZXJnZSA6IHQgLT4gZGF0YSAtPiBkYXRhXG4gIHZhbCBhZGQgOiB0IC0+IGRhdGEgLT4gdW5pdFxuICB2YWwgcmVtb3ZlIDogdCAtPiBkYXRhIC0+IHVuaXRcbiAgdmFsIGZpbmQgOiB0IC0+IGRhdGEgLT4gZGF0YVxuICB2YWwgZmluZF9vcHQgOiB0IC0+IGRhdGEgLT4gZGF0YSBvcHRpb25cbiAgdmFsIGZpbmRfYWxsIDogdCAtPiBkYXRhIC0+IGRhdGEgbGlzdFxuICB2YWwgbWVtIDogdCAtPiBkYXRhIC0+IGJvb2xcbiAgdmFsIGl0ZXIgOiAoZGF0YSAtPiB1bml0KSAtPiB0IC0+IHVuaXRcbiAgdmFsIGZvbGQgOiAoZGF0YSAtPiAnYSAtPiAnYSkgLT4gdCAtPiAnYSAtPiAnYVxuICB2YWwgY291bnQgOiB0IC0+IGludFxuICB2YWwgc3RhdHMgOiB0IC0+IGludCAqIGludCAqIGludCAqIGludCAqIGludCAqIGludFxuZW5kXG5cbm1vZHVsZSBNYWtlIChIIDogSGFzaHRibC5IYXNoZWRUeXBlKSA6IChTIHdpdGggdHlwZSBkYXRhID0gSC50KSA9IHN0cnVjdFxuXG4gIHR5cGUgJ2Egd2Vha190ID0gJ2EgdFxuICBsZXQgd2Vha19jcmVhdGUgPSBjcmVhdGVcbiAgbGV0IGVtcHR5YnVja2V0ID0gd2Vha19jcmVhdGUgMFxuXG4gIHR5cGUgZGF0YSA9IEgudFxuXG4gIHR5cGUgdCA9IHtcbiAgICBtdXRhYmxlIHRhYmxlIDogZGF0YSB3ZWFrX3QgYXJyYXk7XG4gICAgbXV0YWJsZSBoYXNoZXMgOiBpbnQgYXJyYXkgYXJyYXk7XG4gICAgbXV0YWJsZSBsaW1pdCA6IGludDsgICAgICAgICAgICAgICAoKiBidWNrZXQgc2l6ZSBsaW1pdCAqKVxuICAgIG11dGFibGUgb3ZlcnNpemUgOiBpbnQ7ICAgICAgICAgICAgKCogbnVtYmVyIG9mIG92ZXJzaXplIGJ1Y2tldHMgKilcbiAgICBtdXRhYmxlIHJvdmVyIDogaW50OyAgICAgICAgICAgICAgICgqIGZvciBpbnRlcm5hbCBib29ra2VlcGluZyAqKVxuICB9XG5cbiAgbGV0IGdldF9pbmRleCB0IGggPSAoaCBsYW5kIG1heF9pbnQpIG1vZCAoQXJyYXkubGVuZ3RoIHQudGFibGUpXG5cbiAgbGV0IGxpbWl0ID0gN1xuICBsZXQgb3Zlcl9saW1pdCA9IDJcblxuICBsZXQgY3JlYXRlIHN6ID1cbiAgICBsZXQgc3ogPSBpZiBzeiA8IDcgdGhlbiA3IGVsc2Ugc3ogaW5cbiAgICBsZXQgc3ogPSBpZiBzeiA+IFN5cy5tYXhfYXJyYXlfbGVuZ3RoIHRoZW4gU3lzLm1heF9hcnJheV9sZW5ndGggZWxzZSBzeiBpblxuICAgIHtcbiAgICAgIHRhYmxlID0gQXJyYXkubWFrZSBzeiBlbXB0eWJ1Y2tldDtcbiAgICAgIGhhc2hlcyA9IEFycmF5Lm1ha2Ugc3ogW3wgfF07XG4gICAgICBsaW1pdCA9IGxpbWl0O1xuICAgICAgb3ZlcnNpemUgPSAwO1xuICAgICAgcm92ZXIgPSAwO1xuICAgIH1cblxuICBsZXQgY2xlYXIgdCA9XG4gICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCB0LnRhYmxlIC0gMSBkb1xuICAgICAgdC50YWJsZS4oaSkgPC0gZW1wdHlidWNrZXQ7XG4gICAgICB0Lmhhc2hlcy4oaSkgPC0gW3wgfF07XG4gICAgZG9uZTtcbiAgICB0LmxpbWl0IDwtIGxpbWl0O1xuICAgIHQub3ZlcnNpemUgPC0gMFxuXG5cbiAgbGV0IGZvbGQgZiB0IGluaXQgPVxuICAgIGxldCByZWMgZm9sZF9idWNrZXQgaSBiIGFjY3UgPVxuICAgICAgaWYgaSA+PSBsZW5ndGggYiB0aGVuIGFjY3UgZWxzZVxuICAgICAgbWF0Y2ggZ2V0IGIgaSB3aXRoXG4gICAgICB8IFNvbWUgdiAtPiBmb2xkX2J1Y2tldCAoaSsxKSBiIChmIHYgYWNjdSlcbiAgICAgIHwgTm9uZSAtPiBmb2xkX2J1Y2tldCAoaSsxKSBiIGFjY3VcbiAgICBpblxuICAgIEFycmF5LmZvbGRfcmlnaHQgKGZvbGRfYnVja2V0IDApIHQudGFibGUgaW5pdFxuXG5cbiAgbGV0IGl0ZXIgZiB0ID1cbiAgICBsZXQgcmVjIGl0ZXJfYnVja2V0IGkgYiA9XG4gICAgICBpZiBpID49IGxlbmd0aCBiIHRoZW4gKCkgZWxzZVxuICAgICAgbWF0Y2ggZ2V0IGIgaSB3aXRoXG4gICAgICB8IFNvbWUgdiAtPiBmIHY7IGl0ZXJfYnVja2V0IChpKzEpIGJcbiAgICAgIHwgTm9uZSAtPiBpdGVyX2J1Y2tldCAoaSsxKSBiXG4gICAgaW5cbiAgICBBcnJheS5pdGVyIChpdGVyX2J1Y2tldCAwKSB0LnRhYmxlXG5cblxuICBsZXQgaXRlcl93ZWFrIGYgdCA9XG4gICAgbGV0IHJlYyBpdGVyX2J1Y2tldCBpIGogYiA9XG4gICAgICBpZiBpID49IGxlbmd0aCBiIHRoZW4gKCkgZWxzZVxuICAgICAgbWF0Y2ggY2hlY2sgYiBpIHdpdGhcbiAgICAgIHwgdHJ1ZSAtPiBmIGIgdC5oYXNoZXMuKGopIGk7IGl0ZXJfYnVja2V0IChpKzEpIGogYlxuICAgICAgfCBmYWxzZSAtPiBpdGVyX2J1Y2tldCAoaSsxKSBqIGJcbiAgICBpblxuICAgIEFycmF5Lml0ZXJpIChpdGVyX2J1Y2tldCAwKSB0LnRhYmxlXG5cblxuICBsZXQgcmVjIGNvdW50X2J1Y2tldCBpIGIgYWNjdSA9XG4gICAgaWYgaSA+PSBsZW5ndGggYiB0aGVuIGFjY3UgZWxzZVxuICAgIGNvdW50X2J1Y2tldCAoaSsxKSBiIChhY2N1ICsgKGlmIGNoZWNrIGIgaSB0aGVuIDEgZWxzZSAwKSlcblxuXG4gIGxldCBjb3VudCB0ID1cbiAgICBBcnJheS5mb2xkX3JpZ2h0IChjb3VudF9idWNrZXQgMCkgdC50YWJsZSAwXG5cblxuICBsZXQgbmV4dF9zeiBuID0gSW50Lm1pbiAoMyAqIG4gLyAyICsgMykgU3lzLm1heF9hcnJheV9sZW5ndGhcbiAgbGV0IHByZXZfc3ogbiA9ICgobiAtIDMpICogMiArIDIpIC8gM1xuXG4gIGxldCB0ZXN0X3Nocmlua19idWNrZXQgdCA9XG4gICAgbGV0IGJ1Y2tldCA9IHQudGFibGUuKHQucm92ZXIpIGluXG4gICAgbGV0IGhidWNrZXQgPSB0Lmhhc2hlcy4odC5yb3ZlcikgaW5cbiAgICBsZXQgbGVuID0gbGVuZ3RoIGJ1Y2tldCBpblxuICAgIGxldCBwcmV2X2xlbiA9IHByZXZfc3ogbGVuIGluXG4gICAgbGV0IGxpdmUgPSBjb3VudF9idWNrZXQgMCBidWNrZXQgMCBpblxuICAgIGlmIGxpdmUgPD0gcHJldl9sZW4gdGhlbiBiZWdpblxuICAgICAgbGV0IHJlYyBsb29wIGkgaiA9XG4gICAgICAgIGlmIGogPj0gcHJldl9sZW4gdGhlbiBiZWdpblxuICAgICAgICAgIGlmIGNoZWNrIGJ1Y2tldCBpIHRoZW4gbG9vcCAoaSArIDEpIGpcbiAgICAgICAgICBlbHNlIGlmIGNoZWNrIGJ1Y2tldCBqIHRoZW4gYmVnaW5cbiAgICAgICAgICAgIGJsaXQgYnVja2V0IGogYnVja2V0IGkgMTtcbiAgICAgICAgICAgIGhidWNrZXQuKGkpIDwtIGhidWNrZXQuKGopO1xuICAgICAgICAgICAgbG9vcCAoaSArIDEpIChqIC0gMSk7XG4gICAgICAgICAgZW5kIGVsc2UgbG9vcCBpIChqIC0gMSk7XG4gICAgICAgIGVuZDtcbiAgICAgIGluXG4gICAgICBsb29wIDAgKGxlbmd0aCBidWNrZXQgLSAxKTtcbiAgICAgIGlmIHByZXZfbGVuID0gMCB0aGVuIGJlZ2luXG4gICAgICAgIHQudGFibGUuKHQucm92ZXIpIDwtIGVtcHR5YnVja2V0O1xuICAgICAgICB0Lmhhc2hlcy4odC5yb3ZlcikgPC0gW3wgfF07XG4gICAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgICBsZXQgbmV3YnVja2V0ID0gd2Vha19jcmVhdGUgcHJldl9sZW4gaW5cbiAgICAgICAgYmxpdCBidWNrZXQgMCBuZXdidWNrZXQgMCBwcmV2X2xlbjtcbiAgICAgICAgdC50YWJsZS4odC5yb3ZlcikgPC0gbmV3YnVja2V0O1xuICAgICAgICB0Lmhhc2hlcy4odC5yb3ZlcikgPC0gQXJyYXkuc3ViIGhidWNrZXQgMCBwcmV2X2xlblxuICAgICAgZW5kO1xuICAgICAgaWYgbGVuID4gdC5saW1pdCAmJiBwcmV2X2xlbiA8PSB0LmxpbWl0IHRoZW4gdC5vdmVyc2l6ZSA8LSB0Lm92ZXJzaXplIC0gMTtcbiAgICBlbmQ7XG4gICAgdC5yb3ZlciA8LSAodC5yb3ZlciArIDEpIG1vZCAoQXJyYXkubGVuZ3RoIHQudGFibGUpXG5cblxuICBsZXQgcmVjIHJlc2l6ZSB0ID1cbiAgICBsZXQgb2xkbGVuID0gQXJyYXkubGVuZ3RoIHQudGFibGUgaW5cbiAgICBsZXQgbmV3bGVuID0gbmV4dF9zeiBvbGRsZW4gaW5cbiAgICBpZiBuZXdsZW4gPiBvbGRsZW4gdGhlbiBiZWdpblxuICAgICAgbGV0IG5ld3QgPSBjcmVhdGUgbmV3bGVuIGluXG4gICAgICBsZXQgYWRkX3dlYWsgb2Igb2ggb2kgPVxuICAgICAgICBsZXQgc2V0dGVyIG5iIG5pIF8gPSBibGl0IG9iIG9pIG5iIG5pIDEgaW5cbiAgICAgICAgbGV0IGggPSBvaC4ob2kpIGluXG4gICAgICAgIGFkZF9hdXggbmV3dCBzZXR0ZXIgTm9uZSBoIChnZXRfaW5kZXggbmV3dCBoKTtcbiAgICAgIGluXG4gICAgICBpdGVyX3dlYWsgYWRkX3dlYWsgdDtcbiAgICAgIHQudGFibGUgPC0gbmV3dC50YWJsZTtcbiAgICAgIHQuaGFzaGVzIDwtIG5ld3QuaGFzaGVzO1xuICAgICAgdC5saW1pdCA8LSBuZXd0LmxpbWl0O1xuICAgICAgdC5vdmVyc2l6ZSA8LSBuZXd0Lm92ZXJzaXplO1xuICAgICAgdC5yb3ZlciA8LSB0LnJvdmVyIG1vZCBBcnJheS5sZW5ndGggbmV3dC50YWJsZTtcbiAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgdC5saW1pdCA8LSBtYXhfaW50OyAgICAgICAgICAgICAoKiBtYXhpbXVtIHNpemUgYWxyZWFkeSByZWFjaGVkICopXG4gICAgICB0Lm92ZXJzaXplIDwtIDA7XG4gICAgZW5kXG5cbiAgYW5kIGFkZF9hdXggdCBzZXR0ZXIgZCBoIGluZGV4ID1cbiAgICBsZXQgYnVja2V0ID0gdC50YWJsZS4oaW5kZXgpIGluXG4gICAgbGV0IGhhc2hlcyA9IHQuaGFzaGVzLihpbmRleCkgaW5cbiAgICBsZXQgc3ogPSBsZW5ndGggYnVja2V0IGluXG4gICAgbGV0IHJlYyBsb29wIGkgPVxuICAgICAgaWYgaSA+PSBzeiB0aGVuIGJlZ2luXG4gICAgICAgIGxldCBuZXdzeiA9XG4gICAgICAgICAgSW50Lm1pbiAoMyAqIHN6IC8gMiArIDMpIChTeXMubWF4X2FycmF5X2xlbmd0aCAtIGFkZGl0aW9uYWxfdmFsdWVzKVxuICAgICAgICBpblxuICAgICAgICBpZiBuZXdzeiA8PSBzeiB0aGVuIGZhaWx3aXRoIFwiV2Vhay5NYWtlOiBoYXNoIGJ1Y2tldCBjYW5ub3QgZ3JvdyBtb3JlXCI7XG4gICAgICAgIGxldCBuZXdidWNrZXQgPSB3ZWFrX2NyZWF0ZSBuZXdzeiBpblxuICAgICAgICBsZXQgbmV3aGFzaGVzID0gQXJyYXkubWFrZSBuZXdzeiAwIGluXG4gICAgICAgIGJsaXQgYnVja2V0IDAgbmV3YnVja2V0IDAgc3o7XG4gICAgICAgIEFycmF5LmJsaXQgaGFzaGVzIDAgbmV3aGFzaGVzIDAgc3o7XG4gICAgICAgIHNldHRlciBuZXdidWNrZXQgc3ogZDtcbiAgICAgICAgbmV3aGFzaGVzLihzeikgPC0gaDtcbiAgICAgICAgdC50YWJsZS4oaW5kZXgpIDwtIG5ld2J1Y2tldDtcbiAgICAgICAgdC5oYXNoZXMuKGluZGV4KSA8LSBuZXdoYXNoZXM7XG4gICAgICAgIGlmIHN6IDw9IHQubGltaXQgJiYgbmV3c3ogPiB0LmxpbWl0IHRoZW4gYmVnaW5cbiAgICAgICAgICB0Lm92ZXJzaXplIDwtIHQub3ZlcnNpemUgKyAxO1xuICAgICAgICAgIGZvciBfaSA9IDAgdG8gb3Zlcl9saW1pdCBkbyB0ZXN0X3Nocmlua19idWNrZXQgdCBkb25lO1xuICAgICAgICBlbmQ7XG4gICAgICAgIGlmIHQub3ZlcnNpemUgPiBBcnJheS5sZW5ndGggdC50YWJsZSAvIG92ZXJfbGltaXQgdGhlbiByZXNpemUgdDtcbiAgICAgIGVuZCBlbHNlIGlmIGNoZWNrIGJ1Y2tldCBpIHRoZW4gYmVnaW5cbiAgICAgICAgbG9vcCAoaSArIDEpXG4gICAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgICBzZXR0ZXIgYnVja2V0IGkgZDtcbiAgICAgICAgaGFzaGVzLihpKSA8LSBoO1xuICAgICAgZW5kO1xuICAgIGluXG4gICAgbG9vcCAwXG5cblxuICBsZXQgYWRkIHQgZCA9XG4gICAgbGV0IGggPSBILmhhc2ggZCBpblxuICAgIGFkZF9hdXggdCBzZXQgKFNvbWUgZCkgaCAoZ2V0X2luZGV4IHQgaClcblxuXG4gIGxldCBmaW5kX29yIHQgZCBpZm5vdGZvdW5kID1cbiAgICBsZXQgaCA9IEguaGFzaCBkIGluXG4gICAgbGV0IGluZGV4ID0gZ2V0X2luZGV4IHQgaCBpblxuICAgIGxldCBidWNrZXQgPSB0LnRhYmxlLihpbmRleCkgaW5cbiAgICBsZXQgaGFzaGVzID0gdC5oYXNoZXMuKGluZGV4KSBpblxuICAgIGxldCBzeiA9IGxlbmd0aCBidWNrZXQgaW5cbiAgICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgICBpZiBpID49IHN6IHRoZW4gaWZub3Rmb3VuZCBoIGluZGV4XG4gICAgICBlbHNlIGlmIGggPSBoYXNoZXMuKGkpIHRoZW4gYmVnaW5cbiAgICAgICAgbWF0Y2ggZ2V0X2NvcHkgYnVja2V0IGkgd2l0aFxuICAgICAgICB8IFNvbWUgdiB3aGVuIEguZXF1YWwgdiBkXG4gICAgICAgICAgIC0+IGJlZ2luIG1hdGNoIGdldCBidWNrZXQgaSB3aXRoXG4gICAgICAgICAgICAgIHwgU29tZSB2IC0+IHZcbiAgICAgICAgICAgICAgfCBOb25lIC0+IGxvb3AgKGkgKyAxKVxuICAgICAgICAgICAgICBlbmRcbiAgICAgICAgfCBfIC0+IGxvb3AgKGkgKyAxKVxuICAgICAgZW5kIGVsc2UgbG9vcCAoaSArIDEpXG4gICAgaW5cbiAgICBsb29wIDBcblxuXG4gIGxldCBtZXJnZSB0IGQgPVxuICAgIGZpbmRfb3IgdCBkIChmdW4gaCBpbmRleCAtPiBhZGRfYXV4IHQgc2V0IChTb21lIGQpIGggaW5kZXg7IGQpXG5cblxuICBsZXQgZmluZCB0IGQgPSBmaW5kX29yIHQgZCAoZnVuIF9oIF9pbmRleCAtPiByYWlzZSBOb3RfZm91bmQpXG5cbiAgbGV0IGZpbmRfb3B0IHQgZCA9XG4gICAgbGV0IGggPSBILmhhc2ggZCBpblxuICAgIGxldCBpbmRleCA9IGdldF9pbmRleCB0IGggaW5cbiAgICBsZXQgYnVja2V0ID0gdC50YWJsZS4oaW5kZXgpIGluXG4gICAgbGV0IGhhc2hlcyA9IHQuaGFzaGVzLihpbmRleCkgaW5cbiAgICBsZXQgc3ogPSBsZW5ndGggYnVja2V0IGluXG4gICAgbGV0IHJlYyBsb29wIGkgPVxuICAgICAgaWYgaSA+PSBzeiB0aGVuIE5vbmVcbiAgICAgIGVsc2UgaWYgaCA9IGhhc2hlcy4oaSkgdGhlbiBiZWdpblxuICAgICAgICBtYXRjaCBnZXRfY29weSBidWNrZXQgaSB3aXRoXG4gICAgICAgIHwgU29tZSB2IHdoZW4gSC5lcXVhbCB2IGRcbiAgICAgICAgICAgLT4gYmVnaW4gbWF0Y2ggZ2V0IGJ1Y2tldCBpIHdpdGhcbiAgICAgICAgICAgICAgfCBTb21lIF8gYXMgdiAtPiB2XG4gICAgICAgICAgICAgIHwgTm9uZSAtPiBsb29wIChpICsgMSlcbiAgICAgICAgICAgICAgZW5kXG4gICAgICAgIHwgXyAtPiBsb29wIChpICsgMSlcbiAgICAgIGVuZCBlbHNlIGxvb3AgKGkgKyAxKVxuICAgIGluXG4gICAgbG9vcCAwXG5cblxuICBsZXQgZmluZF9zaGFkb3cgdCBkIGlmZm91bmQgaWZub3Rmb3VuZCA9XG4gICAgbGV0IGggPSBILmhhc2ggZCBpblxuICAgIGxldCBpbmRleCA9IGdldF9pbmRleCB0IGggaW5cbiAgICBsZXQgYnVja2V0ID0gdC50YWJsZS4oaW5kZXgpIGluXG4gICAgbGV0IGhhc2hlcyA9IHQuaGFzaGVzLihpbmRleCkgaW5cbiAgICBsZXQgc3ogPSBsZW5ndGggYnVja2V0IGluXG4gICAgbGV0IHJlYyBsb29wIGkgPVxuICAgICAgaWYgaSA+PSBzeiB0aGVuIGlmbm90Zm91bmRcbiAgICAgIGVsc2UgaWYgaCA9IGhhc2hlcy4oaSkgdGhlbiBiZWdpblxuICAgICAgICBtYXRjaCBnZXRfY29weSBidWNrZXQgaSB3aXRoXG4gICAgICAgIHwgU29tZSB2IHdoZW4gSC5lcXVhbCB2IGQgLT4gaWZmb3VuZCBidWNrZXQgaVxuICAgICAgICB8IF8gLT4gbG9vcCAoaSArIDEpXG4gICAgICBlbmQgZWxzZSBsb29wIChpICsgMSlcbiAgICBpblxuICAgIGxvb3AgMFxuXG5cbiAgbGV0IHJlbW92ZSB0IGQgPSBmaW5kX3NoYWRvdyB0IGQgKGZ1biB3IGkgLT4gc2V0IHcgaSBOb25lKSAoKVxuXG5cbiAgbGV0IG1lbSB0IGQgPSBmaW5kX3NoYWRvdyB0IGQgKGZ1biBfdyBfaSAtPiB0cnVlKSBmYWxzZVxuXG5cbiAgbGV0IGZpbmRfYWxsIHQgZCA9XG4gICAgbGV0IGggPSBILmhhc2ggZCBpblxuICAgIGxldCBpbmRleCA9IGdldF9pbmRleCB0IGggaW5cbiAgICBsZXQgYnVja2V0ID0gdC50YWJsZS4oaW5kZXgpIGluXG4gICAgbGV0IGhhc2hlcyA9IHQuaGFzaGVzLihpbmRleCkgaW5cbiAgICBsZXQgc3ogPSBsZW5ndGggYnVja2V0IGluXG4gICAgbGV0IHJlYyBsb29wIGkgYWNjdSA9XG4gICAgICBpZiBpID49IHN6IHRoZW4gYWNjdVxuICAgICAgZWxzZSBpZiBoID0gaGFzaGVzLihpKSB0aGVuIGJlZ2luXG4gICAgICAgIG1hdGNoIGdldF9jb3B5IGJ1Y2tldCBpIHdpdGhcbiAgICAgICAgfCBTb21lIHYgd2hlbiBILmVxdWFsIHYgZFxuICAgICAgICAgICAtPiBiZWdpbiBtYXRjaCBnZXQgYnVja2V0IGkgd2l0aFxuICAgICAgICAgICAgICB8IFNvbWUgdiAtPiBsb29wIChpICsgMSkgKHYgOjogYWNjdSlcbiAgICAgICAgICAgICAgfCBOb25lIC0+IGxvb3AgKGkgKyAxKSBhY2N1XG4gICAgICAgICAgICAgIGVuZFxuICAgICAgICB8IF8gLT4gbG9vcCAoaSArIDEpIGFjY3VcbiAgICAgIGVuZCBlbHNlIGxvb3AgKGkgKyAxKSBhY2N1XG4gICAgaW5cbiAgICBsb29wIDAgW11cblxuXG4gIGxldCBzdGF0cyB0ID1cbiAgICBsZXQgbGVuID0gQXJyYXkubGVuZ3RoIHQudGFibGUgaW5cbiAgICBsZXQgbGVucyA9IEFycmF5Lm1hcCBsZW5ndGggdC50YWJsZSBpblxuICAgIEFycmF5LnNvcnQgY29tcGFyZSBsZW5zO1xuICAgIGxldCB0b3RsZW4gPSBBcnJheS5mb2xkX2xlZnQgKCArICkgMCBsZW5zIGluXG4gICAgKGxlbiwgY291bnQgdCwgdG90bGVuLCBsZW5zLigwKSwgbGVucy4obGVuLzIpLCBsZW5zLihsZW4tMSkpXG5cblxuZW5kXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBQaWVycmUgV2VpcywgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIEEgcHJldHR5LXByaW50aW5nIGZhY2lsaXR5IGFuZCBkZWZpbml0aW9uIG9mIGZvcm1hdHRlcnMgZm9yICdwYXJhbGxlbCdcbiAgIChpLmUuIHVucmVsYXRlZCBvciBpbmRlcGVuZGVudCkgcHJldHR5LXByaW50aW5nIG9uIG11bHRpcGxlIG91dCBjaGFubmVscy4gKilcblxuKCpcbiAgIFRoZSBwcmV0dHktcHJpbnRpbmcgZW5naW5lIGludGVybmFsIGRhdGEgc3RydWN0dXJlcy5cbiopXG5cbmxldCBpZCB4ID0geFxuXG4oKiBBIGRldm90ZWQgdHlwZSBmb3Igc2l6ZXMgdG8gYXZvaWQgY29uZnVzaW9uXG4gICBiZXR3ZWVuIHNpemVzIGFuZCBtZXJlIGludGVnZXJzLiAqKVxubW9kdWxlIFNpemUgOiBzaWdcbiAgdHlwZSB0XG5cbiAgdmFsIHRvX2ludCA6IHQgLT4gaW50XG4gIHZhbCBvZl9pbnQgOiBpbnQgLT4gdFxuICB2YWwgemVybyA6IHRcbiAgdmFsIHVua25vd24gOiB0XG4gIHZhbCBpc19rbm93biA6IHQgLT4gYm9vbFxuZW5kICA9IHN0cnVjdFxuICB0eXBlIHQgPSBpbnRcblxuICBsZXQgdG9faW50ID0gaWRcbiAgbGV0IG9mX2ludCA9IGlkXG4gIGxldCB6ZXJvID0gMFxuICBsZXQgdW5rbm93biA9IC0xXG4gIGxldCBpc19rbm93biBuID0gbiA+PSAwXG5lbmRcblxuXG5cbigqIFRoZSBwcmV0dHktcHJpbnRpbmcgYm94ZXMgZGVmaW5pdGlvbjpcbiAgIGEgcHJldHR5LXByaW50aW5nIGJveCBpcyBlaXRoZXJcbiAgIC0gaGJveDogaG9yaXpvbnRhbCBib3ggKG5vIGxpbmUgc3BsaXR0aW5nKVxuICAgLSB2Ym94OiB2ZXJ0aWNhbCBib3ggKGV2ZXJ5IGJyZWFrIGhpbnQgc3BsaXRzIHRoZSBsaW5lKVxuICAgLSBodmJveDogaG9yaXpvbnRhbC92ZXJ0aWNhbCBib3hcbiAgICAgKHRoZSBib3ggYmVoYXZlcyBhcyBhbiBob3Jpem9udGFsIGJveCBpZiBpdCBmaXRzIG9uXG4gICAgICB0aGUgY3VycmVudCBsaW5lLCBvdGhlcndpc2UgdGhlIGJveCBiZWhhdmVzIGFzIGEgdmVydGljYWwgYm94KVxuICAgLSBob3Zib3g6IGhvcml6b250YWwgb3IgdmVydGljYWwgY29tcGFjdGluZyBib3hcbiAgICAgKHRoZSBib3ggaXMgY29tcGFjdGluZyBtYXRlcmlhbCwgcHJpbnRpbmcgYXMgbXVjaCBtYXRlcmlhbCBhcyBwb3NzaWJsZVxuICAgICAgb24gZXZlcnkgbGluZXMpXG4gICAtIGJveDogaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbCBjb21wYWN0aW5nIGJveCB3aXRoIGVuaGFuY2VkIGJveCBzdHJ1Y3R1cmVcbiAgICAgKHRoZSBib3ggYmVoYXZlcyBhcyBhbiBob3Jpem9udGFsIG9yIHZlcnRpY2FsIGJveCBidXQgYnJlYWsgaGludHMgc3BsaXRcbiAgICAgIHRoZSBsaW5lIGlmIHNwbGl0dGluZyB3b3VsZCBtb3ZlIHRvIHRoZSBsZWZ0KVxuKilcbnR5cGUgYm94X3R5cGUgPSBDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3MuYmxvY2tfdHlwZSA9XG4gIHwgUHBfaGJveCB8IFBwX3Zib3ggfCBQcF9odmJveCB8IFBwX2hvdmJveCB8IFBwX2JveCB8IFBwX2ZpdHNcblxuXG4oKiBUaGUgcHJldHR5LXByaW50aW5nIHRva2VucyBkZWZpbml0aW9uOlxuICAgYXJlIGVpdGhlciB0ZXh0IHRvIHByaW50IG9yIHByZXR0eSBwcmludGluZ1xuICAgZWxlbWVudHMgdGhhdCBkcml2ZSBpbmRlbnRhdGlvbiBhbmQgbGluZSBzcGxpdHRpbmcuICopXG50eXBlIHBwX3Rva2VuID1cbiAgfCBQcF90ZXh0IG9mIHN0cmluZyAgICAgICAgICAoKiBub3JtYWwgdGV4dCAqKVxuICB8IFBwX2JyZWFrIG9mIHsgICAgICAgICAgICAgICgqIGNvbXBsZXRlIGJyZWFrICopXG4gICAgICBmaXRzOiBzdHJpbmcgKiBpbnQgKiBzdHJpbmc7ICAgKCogbGluZSBpcyBub3Qgc3BsaXQgKilcbiAgICAgIGJyZWFrczogc3RyaW5nICogaW50ICogc3RyaW5nOyAoKiBsaW5lIGlzIHNwbGl0ICopXG4gICAgfVxuICB8IFBwX3RicmVhayBvZiBpbnQgKiBpbnQgICAgICgqIGdvIHRvIG5leHQgdGFidWxhdGlvbiAqKVxuICB8IFBwX3N0YWIgICAgICAgICAgICAgICAgICAgICgqIHNldCBhIHRhYnVsYXRpb24gKilcbiAgfCBQcF9iZWdpbiBvZiBpbnQgKiBib3hfdHlwZSAoKiBiZWdpbm5pbmcgb2YgYSBib3ggKilcbiAgfCBQcF9lbmQgICAgICAgICAgICAgICAgICAgICAoKiBlbmQgb2YgYSBib3ggKilcbiAgfCBQcF90YmVnaW4gb2YgdGJveCAgICAgICAgICAoKiBiZWdpbm5pbmcgb2YgYSB0YWJ1bGF0aW9uIGJveCAqKVxuICB8IFBwX3RlbmQgICAgICAgICAgICAgICAgICAgICgqIGVuZCBvZiBhIHRhYnVsYXRpb24gYm94ICopXG4gIHwgUHBfbmV3bGluZSAgICAgICAgICAgICAgICAgKCogdG8gZm9yY2UgYSBuZXdsaW5lIGluc2lkZSBhIGJveCAqKVxuICB8IFBwX2lmX25ld2xpbmUgICAgICAgICAgICAgICgqIHRvIGRvIHNvbWV0aGluZyBvbmx5IGlmIHRoaXMgdmVyeVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmUgaGFzIGJlZW4gYnJva2VuICopXG4gIHwgUHBfb3Blbl90YWcgb2Ygc3RhZyAgICAgICAgICgqIG9wZW5pbmcgYSB0YWcgbmFtZSAqKVxuICB8IFBwX2Nsb3NlX3RhZyAgICAgICAgICAgICAgICgqIGNsb3NpbmcgdGhlIG1vc3QgcmVjZW50bHkgb3BlbiB0YWcgKilcblxuYW5kIHN0YWcgPSAuLlxuXG5hbmQgdGJveCA9IFBwX3Rib3ggb2YgaW50IGxpc3QgcmVmICAoKiBUYWJ1bGF0aW9uIGJveCAqKVxuXG50eXBlIHRhZyA9IHN0cmluZ1xudHlwZSBzdGFnICs9IFN0cmluZ190YWcgb2YgdGFnXG5cblxuKCogVGhlIHByZXR0eS1wcmludGVyIHF1ZXVlOlxuICAgcHJldHR5LXByaW50aW5nIG1hdGVyaWFsIGlzIG5vdCB3cml0dGVuIGluIHRoZSBvdXRwdXQgYXMgc29vbiBhcyBlbWl0dGVkO1xuICAgaW5zdGVhZCwgdGhlIG1hdGVyaWFsIGlzIHNpbXBseSByZWNvcmRlZCBpbiB0aGUgcHJldHR5LXByaW50ZXIgcXVldWUsXG4gICB1bnRpbCB0aGUgZW5jbG9zaW5nIGJveCBoYXMgYSBrbm93biBjb21wdXRlZCBzaXplIGFuZCBwcm9wZXIgc3BsaXR0aW5nXG4gICBkZWNpc2lvbnMgY2FuIGJlIG1hZGUuXG5cbiAgIFRoZSBwcmV0dHktcHJpbnRlciBxdWV1ZSBjb250YWlucyBmb3JtYXR0aW5nIGVsZW1lbnRzIHRvIGJlIHByaW50ZWQuXG4gICBFYWNoIGZvcm1hdHRpbmcgZWxlbWVudCBpcyBhIHR1cGxlIChzaXplLCB0b2tlbiwgbGVuZ3RoKSwgd2hlcmVcbiAgIC0gbGVuZ3RoIGlzIHRoZSBkZWNsYXJlZCBsZW5ndGggb2YgdGhlIHRva2VuLFxuICAgLSBzaXplIGlzIGVmZmVjdGl2ZSBzaXplIG9mIHRoZSB0b2tlbiB3aGVuIGl0IGlzIHByaW50ZWRcbiAgICAgKHNpemUgaXMgc2V0IHdoZW4gdGhlIHNpemUgb2YgdGhlIGJveCBpcyBrbm93biwgc28gdGhhdCBzaXplIG9mIGJyZWFrXG4gICAgICBoaW50cyBhcmUgZGVmaW5pdGl2ZSkuICopXG50eXBlIHBwX3F1ZXVlX2VsZW0gPSB7XG4gIG11dGFibGUgc2l6ZSA6IFNpemUudDtcbiAgdG9rZW4gOiBwcF90b2tlbjtcbiAgbGVuZ3RoIDogaW50O1xufVxuXG5cbigqIFRoZSBwcmV0dHktcHJpbnRlciBxdWV1ZSBkZWZpbml0aW9uLiAqKVxudHlwZSBwcF9xdWV1ZSA9IHBwX3F1ZXVlX2VsZW0gUXVldWUudFxuXG4oKiBUaGUgcHJldHR5LXByaW50ZXIgc2Nhbm5pbmcgc3RhY2suICopXG5cbigqIFRoZSBwcmV0dHktcHJpbnRlciBzY2FubmluZyBzdGFjazogc2Nhbm5pbmcgZWxlbWVudCBkZWZpbml0aW9uLiAqKVxudHlwZSBwcF9zY2FuX2VsZW0gPSB7XG4gIGxlZnRfdG90YWwgOiBpbnQ7ICgqIFZhbHVlIG9mIHBwX2xlZnRfdG90YWwgd2hlbiB0aGUgZWxlbWVudCB3YXMgZW5xdWV1ZWQuICopXG4gIHF1ZXVlX2VsZW0gOiBwcF9xdWV1ZV9lbGVtXG59XG5cbigqIFRoZSBwcmV0dHktcHJpbnRlciBmb3JtYXR0aW5nIHN0YWNrOlxuICAgdGhlIGZvcm1hdHRpbmcgc3RhY2sgY29udGFpbnMgdGhlIGRlc2NyaXB0aW9uIG9mIGFsbCB0aGUgY3VycmVudGx5IGFjdGl2ZVxuICAgYm94ZXM7IHRoZSBwcmV0dHktcHJpbnRlciBmb3JtYXR0aW5nIHN0YWNrIGlzIHVzZWQgdG8gc3BsaXQgdGhlIGxpbmVzXG4gICB3aGlsZSBwcmludGluZyB0b2tlbnMuICopXG5cbigqIFRoZSBwcmV0dHktcHJpbnRlciBmb3JtYXR0aW5nIHN0YWNrOiBmb3JtYXR0aW5nIHN0YWNrIGVsZW1lbnQgZGVmaW5pdGlvbi5cbiAgIEVhY2ggc3RhY2sgZWxlbWVudCBkZXNjcmliZXMgYSBwcmV0dHktcHJpbnRpbmcgYm94LiAqKVxudHlwZSBwcF9mb3JtYXRfZWxlbSA9IHsgYm94X3R5cGUgOiBib3hfdHlwZTsgd2lkdGggOiBpbnQgfVxuXG4oKiBUaGUgZm9ybWF0dGVyIGRlZmluaXRpb24uXG4gICBFYWNoIGZvcm1hdHRlciB2YWx1ZSBpcyBhIHByZXR0eS1wcmludGVyIGluc3RhbmNlIHdpdGggYWxsIGl0c1xuICAgbWFjaGluZXJ5LiAqKVxudHlwZSBmb3JtYXR0ZXIgPSB7XG4gICgqIFRoZSBwcmV0dHktcHJpbnRlciBzY2FubmluZyBzdGFjay4gKilcbiAgcHBfc2Nhbl9zdGFjayA6IHBwX3NjYW5fZWxlbSBTdGFjay50O1xuICAoKiBUaGUgcHJldHR5LXByaW50ZXIgZm9ybWF0dGluZyBzdGFjay4gKilcbiAgcHBfZm9ybWF0X3N0YWNrIDogcHBfZm9ybWF0X2VsZW0gU3RhY2sudDtcbiAgcHBfdGJveF9zdGFjayA6IHRib3ggU3RhY2sudDtcbiAgKCogVGhlIHByZXR0eS1wcmludGVyIHNlbWFudGljcyB0YWcgc3RhY2suICopXG4gIHBwX3RhZ19zdGFjayA6IHN0YWcgU3RhY2sudDtcbiAgcHBfbWFya19zdGFjayA6IHN0YWcgU3RhY2sudDtcbiAgKCogVmFsdWUgb2YgcmlnaHQgbWFyZ2luLiAqKVxuICBtdXRhYmxlIHBwX21hcmdpbiA6IGludDtcbiAgKCogTWluaW1hbCBzcGFjZSBsZWZ0IGJlZm9yZSBtYXJnaW4sIHdoZW4gb3BlbmluZyBhIGJveC4gKilcbiAgbXV0YWJsZSBwcF9taW5fc3BhY2VfbGVmdCA6IGludDtcbiAgKCogTWF4aW11bSB2YWx1ZSBvZiBpbmRlbnRhdGlvbjpcbiAgICAgbm8gYm94IGNhbiBiZSBvcGVuZWQgZnVydGhlci4gKilcbiAgbXV0YWJsZSBwcF9tYXhfaW5kZW50IDogaW50O1xuICAoKiBTcGFjZSByZW1haW5pbmcgb24gdGhlIGN1cnJlbnQgbGluZS4gKilcbiAgbXV0YWJsZSBwcF9zcGFjZV9sZWZ0IDogaW50O1xuICAoKiBDdXJyZW50IHZhbHVlIG9mIGluZGVudGF0aW9uLiAqKVxuICBtdXRhYmxlIHBwX2N1cnJlbnRfaW5kZW50IDogaW50O1xuICAoKiBUcnVlIHdoZW4gdGhlIGxpbmUgaGFzIGJlZW4gYnJva2VuIGJ5IHRoZSBwcmV0dHktcHJpbnRlci4gKilcbiAgbXV0YWJsZSBwcF9pc19uZXdfbGluZSA6IGJvb2w7XG4gICgqIFRvdGFsIHdpZHRoIG9mIHRva2VucyBhbHJlYWR5IHByaW50ZWQuICopXG4gIG11dGFibGUgcHBfbGVmdF90b3RhbCA6IGludDtcbiAgKCogVG90YWwgd2lkdGggb2YgdG9rZW5zIGV2ZXIgcHV0IGluIHF1ZXVlLiAqKVxuICBtdXRhYmxlIHBwX3JpZ2h0X3RvdGFsIDogaW50O1xuICAoKiBDdXJyZW50IG51bWJlciBvZiBvcGVuIGJveGVzLiAqKVxuICBtdXRhYmxlIHBwX2N1cnJfZGVwdGggOiBpbnQ7XG4gICgqIE1heGltdW0gbnVtYmVyIG9mIGJveGVzIHdoaWNoIGNhbiBiZSBzaW11bHRhbmVvdXNseSBvcGVuLiAqKVxuICBtdXRhYmxlIHBwX21heF9ib3hlcyA6IGludDtcbiAgKCogRWxsaXBzaXMgc3RyaW5nLiAqKVxuICBtdXRhYmxlIHBwX2VsbGlwc2lzIDogc3RyaW5nO1xuICAoKiBPdXRwdXQgZnVuY3Rpb24uICopXG4gIG11dGFibGUgcHBfb3V0X3N0cmluZyA6IHN0cmluZyAtPiBpbnQgLT4gaW50IC0+IHVuaXQ7XG4gICgqIEZsdXNoaW5nIGZ1bmN0aW9uLiAqKVxuICBtdXRhYmxlIHBwX291dF9mbHVzaCA6IHVuaXQgLT4gdW5pdDtcbiAgKCogT3V0cHV0IG9mIG5ldyBsaW5lcy4gKilcbiAgbXV0YWJsZSBwcF9vdXRfbmV3bGluZSA6IHVuaXQgLT4gdW5pdDtcbiAgKCogT3V0cHV0IG9mIGJyZWFrIGhpbnRzIHNwYWNlcy4gKilcbiAgbXV0YWJsZSBwcF9vdXRfc3BhY2VzIDogaW50IC0+IHVuaXQ7XG4gICgqIE91dHB1dCBvZiBpbmRlbnRhdGlvbiBvZiBuZXcgbGluZXMuICopXG4gIG11dGFibGUgcHBfb3V0X2luZGVudCA6IGludCAtPiB1bml0O1xuICAoKiBBcmUgdGFncyBwcmludGVkID8gKilcbiAgbXV0YWJsZSBwcF9wcmludF90YWdzIDogYm9vbDtcbiAgKCogQXJlIHRhZ3MgbWFya2VkID8gKilcbiAgbXV0YWJsZSBwcF9tYXJrX3RhZ3MgOiBib29sO1xuICAoKiBGaW5kIG9wZW5pbmcgYW5kIGNsb3NpbmcgbWFya2VycyBvZiB0YWdzLiAqKVxuICBtdXRhYmxlIHBwX21hcmtfb3Blbl90YWcgOiBzdGFnIC0+IHN0cmluZztcbiAgbXV0YWJsZSBwcF9tYXJrX2Nsb3NlX3RhZyA6IHN0YWcgLT4gc3RyaW5nO1xuICBtdXRhYmxlIHBwX3ByaW50X29wZW5fdGFnIDogc3RhZyAtPiB1bml0O1xuICBtdXRhYmxlIHBwX3ByaW50X2Nsb3NlX3RhZyA6IHN0YWcgLT4gdW5pdDtcbiAgKCogVGhlIHByZXR0eS1wcmludGVyIHF1ZXVlLiAqKVxuICBwcF9xdWV1ZSA6IHBwX3F1ZXVlO1xufVxuXG5cbigqIFRoZSBmb3JtYXR0ZXIgc3BlY2lmaWMgdGFnIGhhbmRsaW5nIGZ1bmN0aW9ucy4gKilcbnR5cGUgZm9ybWF0dGVyX3N0YWdfZnVuY3Rpb25zID0ge1xuICBtYXJrX29wZW5fc3RhZyA6IHN0YWcgLT4gc3RyaW5nO1xuICBtYXJrX2Nsb3NlX3N0YWcgOiBzdGFnIC0+IHN0cmluZztcbiAgcHJpbnRfb3Blbl9zdGFnIDogc3RhZyAtPiB1bml0O1xuICBwcmludF9jbG9zZV9zdGFnIDogc3RhZyAtPiB1bml0O1xufVxuXG5cbigqIFRoZSBmb3JtYXR0ZXIgZnVuY3Rpb25zIHRvIG91dHB1dCBtYXRlcmlhbC4gKilcbnR5cGUgZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgPSB7XG4gIG91dF9zdHJpbmcgOiBzdHJpbmcgLT4gaW50IC0+IGludCAtPiB1bml0O1xuICBvdXRfZmx1c2ggOiB1bml0IC0+IHVuaXQ7XG4gIG91dF9uZXdsaW5lIDogdW5pdCAtPiB1bml0O1xuICBvdXRfc3BhY2VzIDogaW50IC0+IHVuaXQ7XG4gIG91dF9pbmRlbnQgOiBpbnQgLT4gdW5pdDtcbn1cblxuXG4oKlxuXG4gIEF1eGlsaWFyaWVzIGFuZCBiYXNpYyBmdW5jdGlvbnMuXG5cbiopXG5cbigqIEVudGVyIGEgdG9rZW4gaW4gdGhlIHByZXR0eS1wcmludGVyIHF1ZXVlLiAqKVxubGV0IHBwX2VucXVldWUgc3RhdGUgdG9rZW4gPVxuICBzdGF0ZS5wcF9yaWdodF90b3RhbCA8LSBzdGF0ZS5wcF9yaWdodF90b3RhbCArIHRva2VuLmxlbmd0aDtcbiAgUXVldWUuYWRkIHRva2VuIHN0YXRlLnBwX3F1ZXVlXG5cblxubGV0IHBwX2NsZWFyX3F1ZXVlIHN0YXRlID1cbiAgc3RhdGUucHBfbGVmdF90b3RhbCA8LSAxOyBzdGF0ZS5wcF9yaWdodF90b3RhbCA8LSAxO1xuICBRdWV1ZS5jbGVhciBzdGF0ZS5wcF9xdWV1ZVxuXG5cbigqIFBwX2luZmluaXR5OiBsYXJnZSB2YWx1ZSBmb3IgZGVmYXVsdCB0b2tlbnMgc2l6ZS5cblxuICAgUHBfaW5maW5pdHkgaXMgZG9jdW1lbnRlZCBhcyBiZWluZyBncmVhdGVyIHRoYW4gMWUxMDsgdG8gYXZvaWRcbiAgIGNvbmZ1c2lvbiBhYm91dCB0aGUgd29yZCAnZ3JlYXRlcicsIHdlIGNob29zZSBwcF9pbmZpbml0eSBncmVhdGVyXG4gICB0aGFuIDFlMTAgKyAxOyBmb3IgY29ycmVjdCBoYW5kbGluZyBvZiB0ZXN0cyBpbiB0aGUgYWxnb3JpdGhtLFxuICAgcHBfaW5maW5pdHkgbXVzdCBiZSBldmVuIG9uZSBtb3JlIHRoYW4gMWUxMCArIDE7IGxldCdzIHN0YW5kIG9uIHRoZVxuICAgc2FmZSBzaWRlIGJ5IGNob29zaW5nIDEuZTEwKzEwLlxuXG4gICBQcF9pbmZpbml0eSBjb3VsZCBwcm9iYWJseSBiZSAxMDczNzQxODIzIHRoYXQgaXMgMl4zMCAtIDEsIHRoYXQgaXNcbiAgIHRoZSBtaW5pbWFsIHVwcGVyIGJvdW5kIGZvciBpbnRlZ2Vyczsgbm93IHRoYXQgbWF4X2ludCBpcyBkZWZpbmVkLFxuICAgdGhpcyBsaW1pdCBjb3VsZCBhbHNvIGJlIGRlZmluZWQgYXMgbWF4X2ludCAtIDEuXG5cbiAgIEhvd2V2ZXIsIGJlZm9yZSBzZXR0aW5nIHBwX2luZmluaXR5IHRvIHNvbWV0aGluZyBhcm91bmQgbWF4X2ludCwgd2VcbiAgIG11c3QgY2FyZWZ1bGx5IGRvdWJsZS1jaGVjayBhbGwgdGhlIGludGVnZXIgYXJpdGhtZXRpYyBvcGVyYXRpb25zXG4gICB0aGF0IGludm9sdmUgcHBfaW5maW5pdHksIHNpbmNlIGFueSBvdmVyZmxvdyB3b3VsZCB3cmVjayBoYXZvYyB0aGVcbiAgIHByZXR0eS1wcmludGluZyBhbGdvcml0aG0ncyBpbnZhcmlhbnRzLiBHaXZlbiB0aGF0IHRoaXMgYXJpdGhtZXRpY1xuICAgY29ycmVjdG5lc3MgY2hlY2sgaXMgZGlmZmljdWx0IGFuZCBlcnJvciBwcm9uZSBhbmQgZ2l2ZW4gdGhhdCAxZTEwXG4gICArIDEgaXMgaW4gcHJhY3RpY2UgbGFyZ2UgZW5vdWdoLCB0aGVyZSBpcyBubyBuZWVkIHRvIGF0dGVtcHQgdG8gc2V0XG4gICBwcF9pbmZpbml0eSB0byB0aGUgdGhlb3JldGljYWxseSBtYXhpbXVtIGxpbWl0LiBJdCBpcyBub3Qgd29ydGggdGhlXG4gICBidXJkZW4gISAqKVxubGV0IHBwX2luZmluaXR5ID0gMTAwMDAwMDAxMFxuXG4oKiBPdXRwdXQgZnVuY3Rpb25zIGZvciB0aGUgZm9ybWF0dGVyLiAqKVxubGV0IHBwX291dHB1dF9zdHJpbmcgc3RhdGUgcyA9IHN0YXRlLnBwX291dF9zdHJpbmcgcyAwIChTdHJpbmcubGVuZ3RoIHMpXG5hbmQgcHBfb3V0cHV0X25ld2xpbmUgc3RhdGUgPSBzdGF0ZS5wcF9vdXRfbmV3bGluZSAoKVxuYW5kIHBwX291dHB1dF9zcGFjZXMgc3RhdGUgbiA9IHN0YXRlLnBwX291dF9zcGFjZXMgblxuYW5kIHBwX291dHB1dF9pbmRlbnQgc3RhdGUgbiA9IHN0YXRlLnBwX291dF9pbmRlbnQgblxuXG4oKiBGb3JtYXQgYSB0ZXh0dWFsIHRva2VuICopXG5sZXQgZm9ybWF0X3BwX3RleHQgc3RhdGUgc2l6ZSB0ZXh0ID1cbiAgc3RhdGUucHBfc3BhY2VfbGVmdCA8LSBzdGF0ZS5wcF9zcGFjZV9sZWZ0IC0gc2l6ZTtcbiAgcHBfb3V0cHV0X3N0cmluZyBzdGF0ZSB0ZXh0O1xuICBzdGF0ZS5wcF9pc19uZXdfbGluZSA8LSBmYWxzZVxuXG4oKiBGb3JtYXQgYSBzdHJpbmcgYnkgaXRzIGxlbmd0aCwgaWYgbm90IGVtcHR5ICopXG5sZXQgZm9ybWF0X3N0cmluZyBzdGF0ZSBzID1cbiAgaWYgcyA8PiBcIlwiIHRoZW4gZm9ybWF0X3BwX3RleHQgc3RhdGUgKFN0cmluZy5sZW5ndGggcykgc1xuXG4oKiBUbyBmb3JtYXQgYSBicmVhaywgaW5kZW50aW5nIGEgbmV3IGxpbmUuICopXG5sZXQgYnJlYWtfbmV3X2xpbmUgc3RhdGUgKGJlZm9yZSwgb2Zmc2V0LCBhZnRlcikgd2lkdGggPVxuICBmb3JtYXRfc3RyaW5nIHN0YXRlIGJlZm9yZTtcbiAgcHBfb3V0cHV0X25ld2xpbmUgc3RhdGU7XG4gIHN0YXRlLnBwX2lzX25ld19saW5lIDwtIHRydWU7XG4gIGxldCBpbmRlbnQgPSBzdGF0ZS5wcF9tYXJnaW4gLSB3aWR0aCArIG9mZnNldCBpblxuICAoKiBEb24ndCBpbmRlbnQgbW9yZSB0aGFuIHBwX21heF9pbmRlbnQuICopXG4gIGxldCByZWFsX2luZGVudCA9IEludC5taW4gc3RhdGUucHBfbWF4X2luZGVudCBpbmRlbnQgaW5cbiAgc3RhdGUucHBfY3VycmVudF9pbmRlbnQgPC0gcmVhbF9pbmRlbnQ7XG4gIHN0YXRlLnBwX3NwYWNlX2xlZnQgPC0gc3RhdGUucHBfbWFyZ2luIC0gc3RhdGUucHBfY3VycmVudF9pbmRlbnQ7XG4gIHBwX291dHB1dF9pbmRlbnQgc3RhdGUgc3RhdGUucHBfY3VycmVudF9pbmRlbnQ7XG4gIGZvcm1hdF9zdHJpbmcgc3RhdGUgYWZ0ZXJcblxuXG4oKiBUbyBmb3JjZSBhIGxpbmUgYnJlYWsgaW5zaWRlIGEgYm94OiBubyBvZmZzZXQgaXMgYWRkZWQuICopXG5sZXQgYnJlYWtfbGluZSBzdGF0ZSB3aWR0aCA9IGJyZWFrX25ld19saW5lIHN0YXRlIChcIlwiLCAwLCBcIlwiKSB3aWR0aFxuXG4oKiBUbyBmb3JtYXQgYSBicmVhayB0aGF0IGZpdHMgb24gdGhlIGN1cnJlbnQgbGluZS4gKilcbmxldCBicmVha19zYW1lX2xpbmUgc3RhdGUgKGJlZm9yZSwgd2lkdGgsIGFmdGVyKSA9XG4gIGZvcm1hdF9zdHJpbmcgc3RhdGUgYmVmb3JlO1xuICBzdGF0ZS5wcF9zcGFjZV9sZWZ0IDwtIHN0YXRlLnBwX3NwYWNlX2xlZnQgLSB3aWR0aDtcbiAgcHBfb3V0cHV0X3NwYWNlcyBzdGF0ZSB3aWR0aDtcbiAgZm9ybWF0X3N0cmluZyBzdGF0ZSBhZnRlclxuXG5cbigqIFRvIGluZGVudCBubyBtb3JlIHRoYW4gcHBfbWF4X2luZGVudCwgaWYgb25lIHRyaWVzIHRvIG9wZW4gYSBib3hcbiAgIGJleW9uZCBwcF9tYXhfaW5kZW50LCB0aGVuIHRoZSBib3ggaXMgcmVqZWN0ZWQgb24gdGhlIGxlZnRcbiAgIGJ5IHNpbXVsYXRpbmcgYSBicmVhay4gKilcbmxldCBwcF9mb3JjZV9icmVha19saW5lIHN0YXRlID1cbiAgbWF0Y2ggU3RhY2sudG9wX29wdCBzdGF0ZS5wcF9mb3JtYXRfc3RhY2sgd2l0aFxuICB8IE5vbmUgLT4gcHBfb3V0cHV0X25ld2xpbmUgc3RhdGVcbiAgfCBTb21lIHsgYm94X3R5cGU7IHdpZHRoIH0gLT5cbiAgICBpZiB3aWR0aCA+IHN0YXRlLnBwX3NwYWNlX2xlZnQgdGhlblxuICAgICAgbWF0Y2ggYm94X3R5cGUgd2l0aFxuICAgICAgfCBQcF9maXRzIHwgUHBfaGJveCAtPiAoKVxuICAgICAgfCBQcF92Ym94IHwgUHBfaHZib3ggfCBQcF9ob3Zib3ggfCBQcF9ib3ggLT4gYnJlYWtfbGluZSBzdGF0ZSB3aWR0aFxuXG5cbigqIFRvIHNraXAgYSB0b2tlbiwgaWYgdGhlIHByZXZpb3VzIGxpbmUgaGFzIGJlZW4gYnJva2VuLiAqKVxubGV0IHBwX3NraXBfdG9rZW4gc3RhdGUgPVxuICBtYXRjaCBRdWV1ZS50YWtlX29wdCBzdGF0ZS5wcF9xdWV1ZSB3aXRoXG4gIHwgTm9uZSAtPiAoKSAoKiBwcmludF9pZl9uZXdsaW5lIG11c3QgaGF2ZSBiZWVuIHRoZSBsYXN0IHByaW50aW5nIGNvbW1hbmQgKilcbiAgfCBTb21lIHsgc2l6ZTsgbGVuZ3RoOyBfIH0gLT5cbiAgICBzdGF0ZS5wcF9sZWZ0X3RvdGFsIDwtIHN0YXRlLnBwX2xlZnRfdG90YWwgLSBsZW5ndGg7XG4gICAgc3RhdGUucHBfc3BhY2VfbGVmdCA8LSBzdGF0ZS5wcF9zcGFjZV9sZWZ0ICsgU2l6ZS50b19pbnQgc2l6ZVxuXG5cbigqXG5cbiAgVGhlIG1haW4gcHJldHR5IHByaW50aW5nIGZ1bmN0aW9ucy5cblxuKilcblxuKCogRm9ybWF0dGluZyBhIHRva2VuIHdpdGggYSBnaXZlbiBzaXplLiAqKVxubGV0IGZvcm1hdF9wcF90b2tlbiBzdGF0ZSBzaXplID0gZnVuY3Rpb25cblxuICB8IFBwX3RleHQgcyAtPlxuICAgIGZvcm1hdF9wcF90ZXh0IHN0YXRlIHNpemUgc1xuXG4gIHwgUHBfYmVnaW4gKG9mZiwgdHkpIC0+XG4gICAgbGV0IGluc2VydGlvbl9wb2ludCA9IHN0YXRlLnBwX21hcmdpbiAtIHN0YXRlLnBwX3NwYWNlX2xlZnQgaW5cbiAgICBpZiBpbnNlcnRpb25fcG9pbnQgPiBzdGF0ZS5wcF9tYXhfaW5kZW50IHRoZW5cbiAgICAgICgqIGNhbiBub3Qgb3BlbiBhIGJveCByaWdodCB0aGVyZS4gKilcbiAgICAgIGJlZ2luIHBwX2ZvcmNlX2JyZWFrX2xpbmUgc3RhdGUgZW5kO1xuICAgIGxldCB3aWR0aCA9IHN0YXRlLnBwX3NwYWNlX2xlZnQgLSBvZmYgaW5cbiAgICBsZXQgYm94X3R5cGUgPVxuICAgICAgbWF0Y2ggdHkgd2l0aFxuICAgICAgfCBQcF92Ym94IC0+IFBwX3Zib3hcbiAgICAgIHwgUHBfaGJveCB8IFBwX2h2Ym94IHwgUHBfaG92Ym94IHwgUHBfYm94IHwgUHBfZml0cyAtPlxuICAgICAgICBpZiBzaXplID4gc3RhdGUucHBfc3BhY2VfbGVmdCB0aGVuIHR5IGVsc2UgUHBfZml0cyBpblxuICAgIFN0YWNrLnB1c2ggeyBib3hfdHlwZTsgd2lkdGggfSBzdGF0ZS5wcF9mb3JtYXRfc3RhY2tcblxuICB8IFBwX2VuZCAtPlxuICAgIFN0YWNrLnBvcF9vcHQgc3RhdGUucHBfZm9ybWF0X3N0YWNrIHw+IGlnbm9yZVxuXG4gIHwgUHBfdGJlZ2luIChQcF90Ym94IF8gYXMgdGJveCkgLT5cbiAgICBTdGFjay5wdXNoIHRib3ggc3RhdGUucHBfdGJveF9zdGFja1xuXG4gIHwgUHBfdGVuZCAtPlxuICAgIFN0YWNrLnBvcF9vcHQgc3RhdGUucHBfdGJveF9zdGFjayB8PiBpZ25vcmVcblxuICB8IFBwX3N0YWIgLT5cbiAgICBiZWdpbiBtYXRjaCBTdGFjay50b3Bfb3B0IHN0YXRlLnBwX3Rib3hfc3RhY2sgd2l0aFxuICAgIHwgTm9uZSAtPiAoKSAoKiBObyBvcGVuIHRhYnVsYXRpb24gYm94LiAqKVxuICAgIHwgU29tZSAoUHBfdGJveCB0YWJzKSAtPlxuICAgICAgbGV0IHJlYyBhZGRfdGFiIG4gPSBmdW5jdGlvblxuICAgICAgICB8IFtdIC0+IFtuXVxuICAgICAgICB8IHggOjogbCBhcyBscyAtPiBpZiBuIDwgeCB0aGVuIG4gOjogbHMgZWxzZSB4IDo6IGFkZF90YWIgbiBsIGluXG4gICAgICB0YWJzIDo9IGFkZF90YWIgKHN0YXRlLnBwX21hcmdpbiAtIHN0YXRlLnBwX3NwYWNlX2xlZnQpICF0YWJzXG4gICAgZW5kXG5cbiAgfCBQcF90YnJlYWsgKG4sIG9mZikgLT5cbiAgICBsZXQgaW5zZXJ0aW9uX3BvaW50ID0gc3RhdGUucHBfbWFyZ2luIC0gc3RhdGUucHBfc3BhY2VfbGVmdCBpblxuICAgIGJlZ2luIG1hdGNoIFN0YWNrLnRvcF9vcHQgc3RhdGUucHBfdGJveF9zdGFjayB3aXRoXG4gICAgfCBOb25lIC0+ICgpICgqIE5vIG9wZW4gdGFidWxhdGlvbiBib3guICopXG4gICAgfCBTb21lIChQcF90Ym94IHRhYnMpIC0+XG4gICAgICBsZXQgdGFiID1cbiAgICAgICAgbWF0Y2ggIXRhYnMgd2l0aFxuICAgICAgICB8IFtdIC0+IGluc2VydGlvbl9wb2ludFxuICAgICAgICB8IGZpcnN0IDo6IF8gLT5cbiAgICAgICAgICBsZXQgcmVjIGZpbmQgPSBmdW5jdGlvblxuICAgICAgICAgICAgfCBoZWFkIDo6IHRhaWwgLT5cbiAgICAgICAgICAgICAgaWYgaGVhZCA+PSBpbnNlcnRpb25fcG9pbnQgdGhlbiBoZWFkIGVsc2UgZmluZCB0YWlsXG4gICAgICAgICAgICB8IFtdIC0+IGZpcnN0IGluXG4gICAgICAgICAgZmluZCAhdGFicyBpblxuICAgICAgbGV0IG9mZnNldCA9IHRhYiAtIGluc2VydGlvbl9wb2ludCBpblxuICAgICAgaWYgb2Zmc2V0ID49IDBcbiAgICAgIHRoZW4gYnJlYWtfc2FtZV9saW5lIHN0YXRlIChcIlwiLCBvZmZzZXQgKyBuLCBcIlwiKVxuICAgICAgZWxzZSBicmVha19uZXdfbGluZSBzdGF0ZSAoXCJcIiwgdGFiICsgb2ZmLCBcIlwiKSBzdGF0ZS5wcF9tYXJnaW5cbiAgICBlbmRcblxuICB8IFBwX25ld2xpbmUgLT5cbiAgICBiZWdpbiBtYXRjaCBTdGFjay50b3Bfb3B0IHN0YXRlLnBwX2Zvcm1hdF9zdGFjayB3aXRoXG4gICAgfCBOb25lIC0+IHBwX291dHB1dF9uZXdsaW5lIHN0YXRlICgqIE5vIG9wZW4gYm94LiAqKVxuICAgIHwgU29tZSB7IHdpZHRoOyBffSAtPiBicmVha19saW5lIHN0YXRlIHdpZHRoXG4gICAgZW5kXG5cbiAgfCBQcF9pZl9uZXdsaW5lIC0+XG4gICAgaWYgc3RhdGUucHBfY3VycmVudF9pbmRlbnQgIT0gc3RhdGUucHBfbWFyZ2luIC0gc3RhdGUucHBfc3BhY2VfbGVmdFxuICAgIHRoZW4gcHBfc2tpcF90b2tlbiBzdGF0ZVxuXG4gIHwgUHBfYnJlYWsgeyBmaXRzOyBicmVha3MgfSAtPlxuICAgIGxldCBiZWZvcmUsIG9mZiwgXyA9IGJyZWFrcyBpblxuICAgIGJlZ2luIG1hdGNoIFN0YWNrLnRvcF9vcHQgc3RhdGUucHBfZm9ybWF0X3N0YWNrIHdpdGhcbiAgICB8IE5vbmUgLT4gKCkgKCogTm8gb3BlbiBib3guICopXG4gICAgfCBTb21lIHsgYm94X3R5cGU7IHdpZHRoIH0gLT5cbiAgICAgIGJlZ2luIG1hdGNoIGJveF90eXBlIHdpdGhcbiAgICAgIHwgUHBfaG92Ym94IC0+XG4gICAgICAgIGlmIHNpemUgKyBTdHJpbmcubGVuZ3RoIGJlZm9yZSA+IHN0YXRlLnBwX3NwYWNlX2xlZnRcbiAgICAgICAgdGhlbiBicmVha19uZXdfbGluZSBzdGF0ZSBicmVha3Mgd2lkdGhcbiAgICAgICAgZWxzZSBicmVha19zYW1lX2xpbmUgc3RhdGUgZml0c1xuICAgICAgfCBQcF9ib3ggLT5cbiAgICAgICAgKCogSGF2ZSB0aGUgbGluZSBqdXN0IGJlZW4gYnJva2VuIGhlcmUgPyAqKVxuICAgICAgICBpZiBzdGF0ZS5wcF9pc19uZXdfbGluZSB0aGVuIGJyZWFrX3NhbWVfbGluZSBzdGF0ZSBmaXRzIGVsc2VcbiAgICAgICAgaWYgc2l6ZSArIFN0cmluZy5sZW5ndGggYmVmb3JlID4gc3RhdGUucHBfc3BhY2VfbGVmdFxuICAgICAgICAgIHRoZW4gYnJlYWtfbmV3X2xpbmUgc3RhdGUgYnJlYWtzIHdpZHRoIGVsc2VcbiAgICAgICAgKCogYnJlYWsgdGhlIGxpbmUgaGVyZSBsZWFkcyB0byBuZXcgaW5kZW50YXRpb24gPyAqKVxuICAgICAgICBpZiBzdGF0ZS5wcF9jdXJyZW50X2luZGVudCA+IHN0YXRlLnBwX21hcmdpbiAtIHdpZHRoICsgb2ZmXG4gICAgICAgIHRoZW4gYnJlYWtfbmV3X2xpbmUgc3RhdGUgYnJlYWtzIHdpZHRoXG4gICAgICAgIGVsc2UgYnJlYWtfc2FtZV9saW5lIHN0YXRlIGZpdHNcbiAgICAgIHwgUHBfaHZib3ggLT4gYnJlYWtfbmV3X2xpbmUgc3RhdGUgYnJlYWtzIHdpZHRoXG4gICAgICB8IFBwX2ZpdHMgLT4gYnJlYWtfc2FtZV9saW5lIHN0YXRlIGZpdHNcbiAgICAgIHwgUHBfdmJveCAtPiBicmVha19uZXdfbGluZSBzdGF0ZSBicmVha3Mgd2lkdGhcbiAgICAgIHwgUHBfaGJveCAtPiBicmVha19zYW1lX2xpbmUgc3RhdGUgZml0c1xuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgIHwgUHBfb3Blbl90YWcgdGFnX25hbWUgLT5cbiAgICAgbGV0IG1hcmtlciA9IHN0YXRlLnBwX21hcmtfb3Blbl90YWcgdGFnX25hbWUgaW5cbiAgICAgcHBfb3V0cHV0X3N0cmluZyBzdGF0ZSBtYXJrZXI7XG4gICAgIFN0YWNrLnB1c2ggdGFnX25hbWUgc3RhdGUucHBfbWFya19zdGFja1xuXG4gICB8IFBwX2Nsb3NlX3RhZyAtPlxuICAgICBiZWdpbiBtYXRjaCBTdGFjay5wb3Bfb3B0IHN0YXRlLnBwX21hcmtfc3RhY2sgd2l0aFxuICAgICB8IE5vbmUgLT4gKCkgKCogTm8gbW9yZSB0YWcgdG8gY2xvc2UuICopXG4gICAgIHwgU29tZSB0YWdfbmFtZSAtPlxuICAgICAgIGxldCBtYXJrZXIgPSBzdGF0ZS5wcF9tYXJrX2Nsb3NlX3RhZyB0YWdfbmFtZSBpblxuICAgICAgIHBwX291dHB1dF9zdHJpbmcgc3RhdGUgbWFya2VyXG4gICAgIGVuZFxuXG5cbigqIFByaW50IGlmIHRva2VuIHNpemUgaXMga25vd24gZWxzZSBwcmludGluZyBpcyBkZWxheWVkLlxuICAgUHJpbnRpbmcgaXMgZGVsYXllZCB3aGVuIHRoZSB0ZXh0IHdhaXRpbmcgaW4gdGhlIHF1ZXVlIHJlcXVpcmVzXG4gICBtb3JlIHJvb20gdG8gZm9ybWF0IHRoYW4gZXhpc3RzIG9uIHRoZSBjdXJyZW50IGxpbmUuICopXG5sZXQgcmVjIGFkdmFuY2VfbGVmdCBzdGF0ZSA9XG4gIG1hdGNoIFF1ZXVlLnBlZWtfb3B0IHN0YXRlLnBwX3F1ZXVlIHdpdGhcbiAgfCBOb25lIC0+ICgpICgqIE5vIHRva2VucyB0byBwcmludCAqKVxuICB8IFNvbWUgeyBzaXplOyB0b2tlbjsgbGVuZ3RoIH0gLT5cbiAgICBsZXQgcGVuZGluZ19jb3VudCA9IHN0YXRlLnBwX3JpZ2h0X3RvdGFsIC0gc3RhdGUucHBfbGVmdF90b3RhbCBpblxuICAgIGlmIFNpemUuaXNfa25vd24gc2l6ZSB8fCBwZW5kaW5nX2NvdW50ID49IHN0YXRlLnBwX3NwYWNlX2xlZnQgdGhlbiBiZWdpblxuICAgICAgUXVldWUudGFrZSBzdGF0ZS5wcF9xdWV1ZSB8PiBpZ25vcmU7ICgqIE5vdCBlbXB0eTogd2UgcGVlayBpbnRvIGl0ICopXG4gICAgICBsZXQgc2l6ZSA9IGlmIFNpemUuaXNfa25vd24gc2l6ZSB0aGVuIFNpemUudG9faW50IHNpemUgZWxzZSBwcF9pbmZpbml0eSBpblxuICAgICAgZm9ybWF0X3BwX3Rva2VuIHN0YXRlIHNpemUgdG9rZW47XG4gICAgICBzdGF0ZS5wcF9sZWZ0X3RvdGFsIDwtIGxlbmd0aCArIHN0YXRlLnBwX2xlZnRfdG90YWw7XG4gICAgICAoYWR2YW5jZV9sZWZ0IFtAdGFpbGNhbGxdKSBzdGF0ZVxuICAgIGVuZFxuXG5cbigqIFRvIGVucXVldWUgYSB0b2tlbiA6IHRyeSB0byBhZHZhbmNlLiAqKVxubGV0IGVucXVldWVfYWR2YW5jZSBzdGF0ZSB0b2sgPSBwcF9lbnF1ZXVlIHN0YXRlIHRvazsgYWR2YW5jZV9sZWZ0IHN0YXRlXG5cblxuKCogVG8gZW5xdWV1ZSBzdHJpbmdzLiAqKVxubGV0IGVucXVldWVfc3RyaW5nX2FzIHN0YXRlIHNpemUgcyA9XG4gIGVucXVldWVfYWR2YW5jZSBzdGF0ZSB7IHNpemU7IHRva2VuID0gUHBfdGV4dCBzOyBsZW5ndGggPSBTaXplLnRvX2ludCBzaXplIH1cblxuXG5sZXQgZW5xdWV1ZV9zdHJpbmcgc3RhdGUgcyA9XG4gIGVucXVldWVfc3RyaW5nX2FzIHN0YXRlIChTaXplLm9mX2ludCAoU3RyaW5nLmxlbmd0aCBzKSkgc1xuXG5cbigqIFJvdXRpbmVzIGZvciBzY2FuIHN0YWNrXG4gICBkZXRlcm1pbmUgc2l6ZSBvZiBib3hlcy4gKilcblxuKCogVGhlIHNjYW5fc3RhY2sgaXMgbmV2ZXIgZW1wdHkuICopXG5sZXQgaW5pdGlhbGl6ZV9zY2FuX3N0YWNrIHN0YWNrID1cbiAgU3RhY2suY2xlYXIgc3RhY2s7XG4gIGxldCBxdWV1ZV9lbGVtID0geyBzaXplID0gU2l6ZS51bmtub3duOyB0b2tlbiA9IFBwX3RleHQgXCJcIjsgbGVuZ3RoID0gMCB9IGluXG4gIFN0YWNrLnB1c2ggeyBsZWZ0X3RvdGFsID0gLTE7IHF1ZXVlX2VsZW0gfSBzdGFja1xuXG4oKiBTZXR0aW5nIHRoZSBzaXplIG9mIGJveGVzIG9uIHNjYW4gc3RhY2s6XG4gICBpZiB0eSA9IHRydWUgdGhlbiBzaXplIG9mIGJyZWFrIGlzIHNldCBlbHNlIHNpemUgb2YgYm94IGlzIHNldDtcbiAgIGluIGVhY2ggY2FzZSBwcF9zY2FuX3N0YWNrIGlzIHBvcHBlZC5cblxuICAgTm90ZTpcbiAgIFBhdHRlcm4gbWF0Y2hpbmcgb24gc2NhbiBzdGFjayBpcyBleGhhdXN0aXZlLCBzaW5jZSBzY2FuX3N0YWNrIGlzIG5ldmVyXG4gICBlbXB0eS5cbiAgIFBhdHRlcm4gbWF0Y2hpbmcgb24gdG9rZW4gaW4gc2NhbiBzdGFjayBpcyBhbHNvIGV4aGF1c3RpdmUsXG4gICBzaW5jZSBzY2FuX3B1c2ggaXMgdXNlZCBvbiBicmVha3MgYW5kIG9wZW5pbmcgb2YgYm94ZXMuICopXG5sZXQgc2V0X3NpemUgc3RhdGUgdHkgPVxuICBtYXRjaCBTdGFjay50b3Bfb3B0IHN0YXRlLnBwX3NjYW5fc3RhY2sgd2l0aFxuICB8IE5vbmUgLT4gKCkgKCogc2Nhbl9zdGFjayBpcyBuZXZlciBlbXB0eS4gKilcbiAgfCBTb21lIHsgbGVmdF90b3RhbDsgcXVldWVfZWxlbSB9IC0+XG4gICAgbGV0IHNpemUgPSBTaXplLnRvX2ludCBxdWV1ZV9lbGVtLnNpemUgaW5cbiAgICAoKiB0ZXN0IGlmIHNjYW4gc3RhY2sgY29udGFpbnMgYW55IGRhdGEgdGhhdCBpcyBub3Qgb2Jzb2xldGUuICopXG4gICAgaWYgbGVmdF90b3RhbCA8IHN0YXRlLnBwX2xlZnRfdG90YWwgdGhlblxuICAgICAgaW5pdGlhbGl6ZV9zY2FuX3N0YWNrIHN0YXRlLnBwX3NjYW5fc3RhY2tcbiAgICBlbHNlXG4gICAgICBtYXRjaCBxdWV1ZV9lbGVtLnRva2VuIHdpdGhcbiAgICAgIHwgUHBfYnJlYWsgXyB8IFBwX3RicmVhayAoXywgXykgLT5cbiAgICAgICAgaWYgdHkgdGhlbiBiZWdpblxuICAgICAgICAgIHF1ZXVlX2VsZW0uc2l6ZSA8LSBTaXplLm9mX2ludCAoc3RhdGUucHBfcmlnaHRfdG90YWwgKyBzaXplKTtcbiAgICAgICAgICBTdGFjay5wb3Bfb3B0IHN0YXRlLnBwX3NjYW5fc3RhY2sgfD4gaWdub3JlXG4gICAgICAgIGVuZFxuICAgICAgfCBQcF9iZWdpbiAoXywgXykgLT5cbiAgICAgICAgaWYgbm90IHR5IHRoZW4gYmVnaW5cbiAgICAgICAgICBxdWV1ZV9lbGVtLnNpemUgPC0gU2l6ZS5vZl9pbnQgKHN0YXRlLnBwX3JpZ2h0X3RvdGFsICsgc2l6ZSk7XG4gICAgICAgICAgU3RhY2sucG9wX29wdCBzdGF0ZS5wcF9zY2FuX3N0YWNrIHw+IGlnbm9yZVxuICAgICAgICBlbmRcbiAgICAgIHwgUHBfdGV4dCBfIHwgUHBfc3RhYiB8IFBwX3RiZWdpbiBfIHwgUHBfdGVuZCB8IFBwX2VuZFxuICAgICAgfCBQcF9uZXdsaW5lIHwgUHBfaWZfbmV3bGluZSB8IFBwX29wZW5fdGFnIF8gfCBQcF9jbG9zZV90YWcgLT5cbiAgICAgICAgKCkgKCogc2Nhbl9wdXNoIGlzIG9ubHkgdXNlZCBmb3IgYnJlYWtzIGFuZCBib3hlcy4gKilcblxuXG4oKiBQdXNoIGEgdG9rZW4gb24gcHJldHR5LXByaW50ZXIgc2Nhbm5pbmcgc3RhY2suXG4gICBJZiBiIGlzIHRydWUgc2V0X3NpemUgaXMgY2FsbGVkLiAqKVxubGV0IHNjYW5fcHVzaCBzdGF0ZSBiIHRva2VuID1cbiAgcHBfZW5xdWV1ZSBzdGF0ZSB0b2tlbjtcbiAgaWYgYiB0aGVuIHNldF9zaXplIHN0YXRlIHRydWU7XG4gIGxldCBlbGVtID0geyBsZWZ0X3RvdGFsID0gc3RhdGUucHBfcmlnaHRfdG90YWw7IHF1ZXVlX2VsZW0gPSB0b2tlbiB9IGluXG4gIFN0YWNrLnB1c2ggZWxlbSBzdGF0ZS5wcF9zY2FuX3N0YWNrXG5cblxuKCogVG8gb3BlbiBhIG5ldyBib3ggOlxuICAgdGhlIHVzZXIgbWF5IHNldCB0aGUgZGVwdGggYm91bmQgcHBfbWF4X2JveGVzXG4gICBhbnkgdGV4dCBuZXN0ZWQgZGVlcGVyIGlzIHByaW50ZWQgYXMgdGhlIGVsbGlwc2lzIHN0cmluZy4gKilcbmxldCBwcF9vcGVuX2JveF9nZW4gc3RhdGUgaW5kZW50IGJyX3R5ID1cbiAgc3RhdGUucHBfY3Vycl9kZXB0aCA8LSBzdGF0ZS5wcF9jdXJyX2RlcHRoICsgMTtcbiAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA8IHN0YXRlLnBwX21heF9ib3hlcyB0aGVuXG4gICAgbGV0IHNpemUgPSBTaXplLm9mX2ludCAoLSBzdGF0ZS5wcF9yaWdodF90b3RhbCkgaW5cbiAgICBsZXQgZWxlbSA9IHsgc2l6ZTsgdG9rZW4gPSBQcF9iZWdpbiAoaW5kZW50LCBicl90eSk7IGxlbmd0aCA9IDAgfSBpblxuICAgIHNjYW5fcHVzaCBzdGF0ZSBmYWxzZSBlbGVtIGVsc2VcbiAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA9IHN0YXRlLnBwX21heF9ib3hlc1xuICB0aGVuIGVucXVldWVfc3RyaW5nIHN0YXRlIHN0YXRlLnBwX2VsbGlwc2lzXG5cblxuKCogVGhlIGJveCB3aGljaCBpcyBhbHdheXMgb3Blbi4gKilcbmxldCBwcF9vcGVuX3N5c19ib3ggc3RhdGUgPSBwcF9vcGVuX2JveF9nZW4gc3RhdGUgMCBQcF9ob3Zib3hcblxuKCogQ2xvc2UgYSBib3gsIHNldHRpbmcgc2l6ZXMgb2YgaXRzIHN1YiBib3hlcy4gKilcbmxldCBwcF9jbG9zZV9ib3ggc3RhdGUgKCkgPVxuICBpZiBzdGF0ZS5wcF9jdXJyX2RlcHRoID4gMSB0aGVuXG4gIGJlZ2luXG4gICAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA8IHN0YXRlLnBwX21heF9ib3hlcyB0aGVuXG4gICAgYmVnaW5cbiAgICAgIHBwX2VucXVldWUgc3RhdGUgeyBzaXplID0gU2l6ZS56ZXJvOyB0b2tlbiA9IFBwX2VuZDsgbGVuZ3RoID0gMCB9O1xuICAgICAgc2V0X3NpemUgc3RhdGUgdHJ1ZTsgc2V0X3NpemUgc3RhdGUgZmFsc2VcbiAgICBlbmQ7XG4gICAgc3RhdGUucHBfY3Vycl9kZXB0aCA8LSBzdGF0ZS5wcF9jdXJyX2RlcHRoIC0gMTtcbiAgZW5kXG5cblxuKCogT3BlbiBhIHRhZywgcHVzaGluZyBpdCBvbiB0aGUgdGFnIHN0YWNrLiAqKVxubGV0IHBwX29wZW5fc3RhZyBzdGF0ZSB0YWdfbmFtZSA9XG4gIGlmIHN0YXRlLnBwX3ByaW50X3RhZ3MgdGhlblxuICBiZWdpblxuICAgIFN0YWNrLnB1c2ggdGFnX25hbWUgc3RhdGUucHBfdGFnX3N0YWNrO1xuICAgIHN0YXRlLnBwX3ByaW50X29wZW5fdGFnIHRhZ19uYW1lXG4gIGVuZDtcbiAgaWYgc3RhdGUucHBfbWFya190YWdzIHRoZW5cbiAgICBsZXQgdG9rZW4gPSBQcF9vcGVuX3RhZyB0YWdfbmFtZSBpblxuICAgIHBwX2VucXVldWUgc3RhdGUgeyBzaXplID0gU2l6ZS56ZXJvOyB0b2tlbjsgbGVuZ3RoID0gMCB9XG5cblxuKCogQ2xvc2UgYSB0YWcsIHBvcHBpbmcgaXQgZnJvbSB0aGUgdGFnIHN0YWNrLiAqKVxubGV0IHBwX2Nsb3NlX3N0YWcgc3RhdGUgKCkgPVxuICBpZiBzdGF0ZS5wcF9tYXJrX3RhZ3MgdGhlblxuICAgIHBwX2VucXVldWUgc3RhdGUgeyBzaXplID0gU2l6ZS56ZXJvOyB0b2tlbiA9IFBwX2Nsb3NlX3RhZzsgbGVuZ3RoID0gMCB9O1xuICBpZiBzdGF0ZS5wcF9wcmludF90YWdzIHRoZW5cbiAgICBtYXRjaCBTdGFjay5wb3Bfb3B0IHN0YXRlLnBwX3RhZ19zdGFjayB3aXRoXG4gICAgfCBOb25lIC0+ICgpICgqIE5vIG1vcmUgdGFnIHRvIGNsb3NlLiAqKVxuICAgIHwgU29tZSB0YWdfbmFtZSAtPlxuICAgICAgc3RhdGUucHBfcHJpbnRfY2xvc2VfdGFnIHRhZ19uYW1lXG5cbmxldCBwcF9vcGVuX3RhZyBzdGF0ZSBzID0gcHBfb3Blbl9zdGFnIHN0YXRlIChTdHJpbmdfdGFnIHMpXG5sZXQgcHBfY2xvc2VfdGFnIHN0YXRlICgpID0gcHBfY2xvc2Vfc3RhZyBzdGF0ZSAoKVxuXG5sZXQgcHBfc2V0X3ByaW50X3RhZ3Mgc3RhdGUgYiA9IHN0YXRlLnBwX3ByaW50X3RhZ3MgPC0gYlxubGV0IHBwX3NldF9tYXJrX3RhZ3Mgc3RhdGUgYiA9IHN0YXRlLnBwX21hcmtfdGFncyA8LSBiXG5sZXQgcHBfZ2V0X3ByaW50X3RhZ3Mgc3RhdGUgKCkgPSBzdGF0ZS5wcF9wcmludF90YWdzXG5sZXQgcHBfZ2V0X21hcmtfdGFncyBzdGF0ZSAoKSA9IHN0YXRlLnBwX21hcmtfdGFnc1xubGV0IHBwX3NldF90YWdzIHN0YXRlIGIgPVxuICBwcF9zZXRfcHJpbnRfdGFncyBzdGF0ZSBiOyBwcF9zZXRfbWFya190YWdzIHN0YXRlIGJcblxuXG4oKiBIYW5kbGluZyB0YWcgaGFuZGxpbmcgZnVuY3Rpb25zOiBnZXQvc2V0IGZ1bmN0aW9ucy4gKilcbmxldCBwcF9nZXRfZm9ybWF0dGVyX3N0YWdfZnVuY3Rpb25zIHN0YXRlICgpID0ge1xuICBtYXJrX29wZW5fc3RhZyA9IHN0YXRlLnBwX21hcmtfb3Blbl90YWc7XG4gIG1hcmtfY2xvc2Vfc3RhZyA9IHN0YXRlLnBwX21hcmtfY2xvc2VfdGFnO1xuICBwcmludF9vcGVuX3N0YWcgPSBzdGF0ZS5wcF9wcmludF9vcGVuX3RhZztcbiAgcHJpbnRfY2xvc2Vfc3RhZyA9IHN0YXRlLnBwX3ByaW50X2Nsb3NlX3RhZztcbn1cblxuXG5sZXQgcHBfc2V0X2Zvcm1hdHRlcl9zdGFnX2Z1bmN0aW9ucyBzdGF0ZSB7XG4gICAgIG1hcmtfb3Blbl9zdGFnID0gbW90O1xuICAgICBtYXJrX2Nsb3NlX3N0YWcgPSBtY3Q7XG4gICAgIHByaW50X29wZW5fc3RhZyA9IHBvdDtcbiAgICAgcHJpbnRfY2xvc2Vfc3RhZyA9IHBjdDtcbiAgfSA9XG4gIHN0YXRlLnBwX21hcmtfb3Blbl90YWcgPC0gbW90O1xuICBzdGF0ZS5wcF9tYXJrX2Nsb3NlX3RhZyA8LSBtY3Q7XG4gIHN0YXRlLnBwX3ByaW50X29wZW5fdGFnIDwtIHBvdDtcbiAgc3RhdGUucHBfcHJpbnRfY2xvc2VfdGFnIDwtIHBjdFxuXG5cbigqIEluaXRpYWxpemUgcHJldHR5LXByaW50ZXIuICopXG5sZXQgcHBfcmluaXQgc3RhdGUgPVxuICBwcF9jbGVhcl9xdWV1ZSBzdGF0ZTtcbiAgaW5pdGlhbGl6ZV9zY2FuX3N0YWNrIHN0YXRlLnBwX3NjYW5fc3RhY2s7XG4gIFN0YWNrLmNsZWFyIHN0YXRlLnBwX2Zvcm1hdF9zdGFjaztcbiAgU3RhY2suY2xlYXIgc3RhdGUucHBfdGJveF9zdGFjaztcbiAgU3RhY2suY2xlYXIgc3RhdGUucHBfdGFnX3N0YWNrO1xuICBTdGFjay5jbGVhciBzdGF0ZS5wcF9tYXJrX3N0YWNrO1xuICBzdGF0ZS5wcF9jdXJyZW50X2luZGVudCA8LSAwO1xuICBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwtIDA7XG4gIHN0YXRlLnBwX3NwYWNlX2xlZnQgPC0gc3RhdGUucHBfbWFyZ2luO1xuICBwcF9vcGVuX3N5c19ib3ggc3RhdGVcblxubGV0IGNsZWFyX3RhZ19zdGFjayBzdGF0ZSA9XG4gIFN0YWNrLml0ZXIgKGZ1biBfIC0+IHBwX2Nsb3NlX3RhZyBzdGF0ZSAoKSkgc3RhdGUucHBfdGFnX3N0YWNrXG5cblxuKCogRmx1c2hpbmcgcHJldHR5LXByaW50ZXIgcXVldWUuICopXG5sZXQgcHBfZmx1c2hfcXVldWUgc3RhdGUgYiA9XG4gIGNsZWFyX3RhZ19zdGFjayBzdGF0ZTtcbiAgd2hpbGUgc3RhdGUucHBfY3Vycl9kZXB0aCA+IDEgZG9cbiAgICBwcF9jbG9zZV9ib3ggc3RhdGUgKClcbiAgZG9uZTtcbiAgc3RhdGUucHBfcmlnaHRfdG90YWwgPC0gcHBfaW5maW5pdHk7XG4gIGFkdmFuY2VfbGVmdCBzdGF0ZTtcbiAgaWYgYiB0aGVuIHBwX291dHB1dF9uZXdsaW5lIHN0YXRlO1xuICBwcF9yaW5pdCBzdGF0ZVxuXG4oKlxuXG4gIFByb2NlZHVyZXMgdG8gZm9ybWF0IHZhbHVlcyBhbmQgdXNlIGJveGVzLlxuXG4qKVxuXG4oKiBUbyBmb3JtYXQgYSBzdHJpbmcuICopXG5sZXQgcHBfcHJpbnRfYXNfc2l6ZSBzdGF0ZSBzaXplIHMgPVxuICBpZiBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwgc3RhdGUucHBfbWF4X2JveGVzXG4gIHRoZW4gZW5xdWV1ZV9zdHJpbmdfYXMgc3RhdGUgc2l6ZSBzXG5cblxubGV0IHBwX3ByaW50X2FzIHN0YXRlIGlzaXplIHMgPVxuICBwcF9wcmludF9hc19zaXplIHN0YXRlIChTaXplLm9mX2ludCBpc2l6ZSkgc1xuXG5cbmxldCBwcF9wcmludF9zdHJpbmcgc3RhdGUgcyA9XG4gIHBwX3ByaW50X2FzIHN0YXRlIChTdHJpbmcubGVuZ3RoIHMpIHNcblxubGV0IHBwX3ByaW50X2J5dGVzIHN0YXRlIHMgPVxuICBwcF9wcmludF9hcyBzdGF0ZSAoQnl0ZXMubGVuZ3RoIHMpIChCeXRlcy50b19zdHJpbmcgcylcblxuKCogVG8gZm9ybWF0IGFuIGludGVnZXIuICopXG5sZXQgcHBfcHJpbnRfaW50IHN0YXRlIGkgPSBwcF9wcmludF9zdHJpbmcgc3RhdGUgKEludC50b19zdHJpbmcgaSlcblxuKCogVG8gZm9ybWF0IGEgZmxvYXQuICopXG5sZXQgcHBfcHJpbnRfZmxvYXQgc3RhdGUgZiA9IHBwX3ByaW50X3N0cmluZyBzdGF0ZSAoc3RyaW5nX29mX2Zsb2F0IGYpXG5cbigqIFRvIGZvcm1hdCBhIGJvb2xlYW4uICopXG5sZXQgcHBfcHJpbnRfYm9vbCBzdGF0ZSBiID0gcHBfcHJpbnRfc3RyaW5nIHN0YXRlIChzdHJpbmdfb2ZfYm9vbCBiKVxuXG4oKiBUbyBmb3JtYXQgYSBjaGFyLiAqKVxubGV0IHBwX3ByaW50X2NoYXIgc3RhdGUgYyA9XG4gIHBwX3ByaW50X2FzIHN0YXRlIDEgKFN0cmluZy5tYWtlIDEgYylcblxuXG4oKiBPcGVuaW5nIGJveGVzLiAqKVxubGV0IHBwX29wZW5faGJveCBzdGF0ZSAoKSA9IHBwX29wZW5fYm94X2dlbiBzdGF0ZSAwIFBwX2hib3hcbmFuZCBwcF9vcGVuX3Zib3ggc3RhdGUgaW5kZW50ID0gcHBfb3Blbl9ib3hfZ2VuIHN0YXRlIGluZGVudCBQcF92Ym94XG5cbmFuZCBwcF9vcGVuX2h2Ym94IHN0YXRlIGluZGVudCA9IHBwX29wZW5fYm94X2dlbiBzdGF0ZSBpbmRlbnQgUHBfaHZib3hcbmFuZCBwcF9vcGVuX2hvdmJveCBzdGF0ZSBpbmRlbnQgPSBwcF9vcGVuX2JveF9nZW4gc3RhdGUgaW5kZW50IFBwX2hvdmJveFxuYW5kIHBwX29wZW5fYm94IHN0YXRlIGluZGVudCA9IHBwX29wZW5fYm94X2dlbiBzdGF0ZSBpbmRlbnQgUHBfYm94XG5cblxuKCogUHJpbnRpbmcgcXVldWVkIHRleHQuXG5cbiAgIFtwcF9wcmludF9mbHVzaF0gcHJpbnRzIGFsbCBwZW5kaW5nIGl0ZW1zIGluIHRoZSBwcmV0dHktcHJpbnRlciBxdWV1ZSBhbmRcbiAgIHRoZW4gZmx1c2hlcyB0aGUgbG93IGxldmVsIG91dHB1dCBkZXZpY2Ugb2YgdGhlIGZvcm1hdHRlciB0byBhY3R1YWxseVxuICAgZGlzcGxheSBwcmludGluZyBtYXRlcmlhbC5cblxuICAgW3BwX3ByaW50X25ld2xpbmVdIGJlaGF2ZXMgYXMgW3BwX3ByaW50X2ZsdXNoXSBhZnRlciBwcmludGluZyBhbiBhZGRpdGlvbmFsXG4gICBuZXcgbGluZS4gKilcbmxldCBwcF9wcmludF9uZXdsaW5lIHN0YXRlICgpID1cbiAgcHBfZmx1c2hfcXVldWUgc3RhdGUgdHJ1ZTsgc3RhdGUucHBfb3V0X2ZsdXNoICgpXG5hbmQgcHBfcHJpbnRfZmx1c2ggc3RhdGUgKCkgPVxuICBwcF9mbHVzaF9xdWV1ZSBzdGF0ZSBmYWxzZTsgc3RhdGUucHBfb3V0X2ZsdXNoICgpXG5cblxuKCogVG8gZ2V0IGEgbmV3bGluZSB3aGVuIG9uZSBkb2VzIG5vdCB3YW50IHRvIGNsb3NlIHRoZSBjdXJyZW50IGJveC4gKilcbmxldCBwcF9mb3JjZV9uZXdsaW5lIHN0YXRlICgpID1cbiAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA8IHN0YXRlLnBwX21heF9ib3hlcyB0aGVuXG4gICAgZW5xdWV1ZV9hZHZhbmNlIHN0YXRlIHsgc2l6ZSA9IFNpemUuemVybzsgdG9rZW4gPSBQcF9uZXdsaW5lOyBsZW5ndGggPSAwIH1cblxuXG4oKiBUbyBmb3JtYXQgc29tZXRoaW5nLCBvbmx5IGluIGNhc2UgdGhlIGxpbmUgaGFzIGp1c3QgYmVlbiBicm9rZW4uICopXG5sZXQgcHBfcHJpbnRfaWZfbmV3bGluZSBzdGF0ZSAoKSA9XG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXMgdGhlblxuICAgIGVucXVldWVfYWR2YW5jZSBzdGF0ZVxuICAgICAgeyBzaXplID0gU2l6ZS56ZXJvOyB0b2tlbiA9IFBwX2lmX25ld2xpbmU7IGxlbmd0aCA9IDAgfVxuXG5cbigqIEdlbmVyYWxpemVkIGJyZWFrIGhpbnQgdGhhdCBhbGxvd3MgcHJpbnRpbmcgc3RyaW5ncyBiZWZvcmUvYWZ0ZXJcbiAgIHNhbWUtbGluZSBvZmZzZXQgKHdpZHRoKSBvciBuZXctbGluZSBvZmZzZXQgKilcbmxldCBwcF9wcmludF9jdXN0b21fYnJlYWsgc3RhdGUgfmZpdHMgfmJyZWFrcyA9XG4gIGxldCBiZWZvcmUsIHdpZHRoLCBhZnRlciA9IGZpdHMgaW5cbiAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA8IHN0YXRlLnBwX21heF9ib3hlcyB0aGVuXG4gICAgbGV0IHNpemUgPSBTaXplLm9mX2ludCAoLSBzdGF0ZS5wcF9yaWdodF90b3RhbCkgaW5cbiAgICBsZXQgdG9rZW4gPSBQcF9icmVhayB7IGZpdHM7IGJyZWFrcyB9IGluXG4gICAgbGV0IGxlbmd0aCA9IFN0cmluZy5sZW5ndGggYmVmb3JlICsgd2lkdGggKyBTdHJpbmcubGVuZ3RoIGFmdGVyIGluXG4gICAgbGV0IGVsZW0gPSB7IHNpemU7IHRva2VuOyBsZW5ndGggfSBpblxuICAgIHNjYW5fcHVzaCBzdGF0ZSB0cnVlIGVsZW1cblxuKCogUHJpbnRpbmcgYnJlYWsgaGludHM6XG4gICBBIGJyZWFrIGhpbnQgaW5kaWNhdGVzIHdoZXJlIGEgYm94IG1heSBiZSBicm9rZW4uXG4gICBJZiBsaW5lIGlzIGJyb2tlbiB0aGVuIG9mZnNldCBpcyBhZGRlZCB0byB0aGUgaW5kZW50YXRpb24gb2YgdGhlIGN1cnJlbnRcbiAgIGJveCBlbHNlICh0aGUgdmFsdWUgb2YpIHdpZHRoIGJsYW5rcyBhcmUgcHJpbnRlZC4gKilcbmxldCBwcF9wcmludF9icmVhayBzdGF0ZSB3aWR0aCBvZmZzZXQgPVxuICBwcF9wcmludF9jdXN0b21fYnJlYWsgc3RhdGVcbiAgICB+Zml0czooXCJcIiwgd2lkdGgsIFwiXCIpIH5icmVha3M6KFwiXCIsIG9mZnNldCwgXCJcIilcblxuXG4oKiBQcmludCBhIHNwYWNlIDpcbiAgIGEgc3BhY2UgaXMgYSBicmVhayBoaW50IHRoYXQgcHJpbnRzIGEgc2luZ2xlIHNwYWNlIGlmIHRoZSBicmVhayBkb2VzIG5vdFxuICAgc3BsaXQgdGhlIGxpbmU7XG4gICBhIGN1dCBpcyBhIGJyZWFrIGhpbnQgdGhhdCBwcmludHMgbm90aGluZyBpZiB0aGUgYnJlYWsgZG9lcyBub3Qgc3BsaXQgdGhlXG4gICBsaW5lLiAqKVxubGV0IHBwX3ByaW50X3NwYWNlIHN0YXRlICgpID0gcHBfcHJpbnRfYnJlYWsgc3RhdGUgMSAwXG5hbmQgcHBfcHJpbnRfY3V0IHN0YXRlICgpID0gcHBfcHJpbnRfYnJlYWsgc3RhdGUgMCAwXG5cblxuKCogVGFidWxhdGlvbiBib3hlcy4gKilcbmxldCBwcF9vcGVuX3Rib3ggc3RhdGUgKCkgPVxuICBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwtIHN0YXRlLnBwX2N1cnJfZGVwdGggKyAxO1xuICBpZiBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwgc3RhdGUucHBfbWF4X2JveGVzIHRoZW5cbiAgICBsZXQgc2l6ZSA9IFNpemUuemVybyBpblxuICAgIGxldCBlbGVtID0geyBzaXplOyB0b2tlbiA9IFBwX3RiZWdpbiAoUHBfdGJveCAocmVmIFtdKSk7IGxlbmd0aCA9IDAgfSBpblxuICAgIGVucXVldWVfYWR2YW5jZSBzdGF0ZSBlbGVtXG5cblxuKCogQ2xvc2UgYSB0YWJ1bGF0aW9uIGJveC4gKilcbmxldCBwcF9jbG9zZV90Ym94IHN0YXRlICgpID1cbiAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA+IDEgdGhlblxuICBiZWdpblxuICAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA8IHN0YXRlLnBwX21heF9ib3hlcyB0aGVuXG4gICAgIGxldCBlbGVtID0geyBzaXplID0gU2l6ZS56ZXJvOyB0b2tlbiA9IFBwX3RlbmQ7IGxlbmd0aCA9IDAgfSBpblxuICAgICBlbnF1ZXVlX2FkdmFuY2Ugc3RhdGUgZWxlbTtcbiAgICAgc3RhdGUucHBfY3Vycl9kZXB0aCA8LSBzdGF0ZS5wcF9jdXJyX2RlcHRoIC0gMVxuICBlbmRcblxuXG4oKiBQcmludCBhIHRhYnVsYXRpb24gYnJlYWsuICopXG5sZXQgcHBfcHJpbnRfdGJyZWFrIHN0YXRlIHdpZHRoIG9mZnNldCA9XG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXMgdGhlblxuICAgIGxldCBzaXplID0gU2l6ZS5vZl9pbnQgKC0gc3RhdGUucHBfcmlnaHRfdG90YWwpIGluXG4gICAgbGV0IGVsZW0gPSB7IHNpemU7IHRva2VuID0gUHBfdGJyZWFrICh3aWR0aCwgb2Zmc2V0KTsgbGVuZ3RoID0gd2lkdGggfSBpblxuICAgIHNjYW5fcHVzaCBzdGF0ZSB0cnVlIGVsZW1cblxuXG5sZXQgcHBfcHJpbnRfdGFiIHN0YXRlICgpID0gcHBfcHJpbnRfdGJyZWFrIHN0YXRlIDAgMFxuXG5sZXQgcHBfc2V0X3RhYiBzdGF0ZSAoKSA9XG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXMgdGhlblxuICAgIGxldCBlbGVtID0geyBzaXplID0gU2l6ZS56ZXJvOyB0b2tlbiA9IFBwX3N0YWI7IGxlbmd0aCA9IDAgfSBpblxuICAgIGVucXVldWVfYWR2YW5jZSBzdGF0ZSBlbGVtXG5cblxuKCpcblxuICBQcm9jZWR1cmVzIHRvIGNvbnRyb2wgdGhlIHByZXR0eS1wcmludGVyc1xuXG4qKVxuXG4oKiBTZXRfbWF4X2JveGVzLiAqKVxubGV0IHBwX3NldF9tYXhfYm94ZXMgc3RhdGUgbiA9IGlmIG4gPiAxIHRoZW4gc3RhdGUucHBfbWF4X2JveGVzIDwtIG5cblxuKCogVG8ga25vdyB0aGUgY3VycmVudCBtYXhpbXVtIG51bWJlciBvZiBib3hlcyBhbGxvd2VkLiAqKVxubGV0IHBwX2dldF9tYXhfYm94ZXMgc3RhdGUgKCkgPSBzdGF0ZS5wcF9tYXhfYm94ZXNcblxubGV0IHBwX292ZXJfbWF4X2JveGVzIHN0YXRlICgpID0gc3RhdGUucHBfY3Vycl9kZXB0aCA9IHN0YXRlLnBwX21heF9ib3hlc1xuXG4oKiBFbGxpcHNpcy4gKilcbmxldCBwcF9zZXRfZWxsaXBzaXNfdGV4dCBzdGF0ZSBzID0gc3RhdGUucHBfZWxsaXBzaXMgPC0gc1xuYW5kIHBwX2dldF9lbGxpcHNpc190ZXh0IHN0YXRlICgpID0gc3RhdGUucHBfZWxsaXBzaXNcblxuXG4oKiBUbyBzZXQgdGhlIG1hcmdpbiBvZiBwcmV0dHktcHJpbnRlci4gKilcbmxldCBwcF9saW1pdCBuID1cbiAgaWYgbiA8IHBwX2luZmluaXR5IHRoZW4gbiBlbHNlIHByZWQgcHBfaW5maW5pdHlcblxuXG4oKiBJbnRlcm5hbCBwcmV0dHktcHJpbnRlciBmdW5jdGlvbnMuICopXG5sZXQgcHBfc2V0X21pbl9zcGFjZV9sZWZ0IHN0YXRlIG4gPVxuICBpZiBuID49IDEgdGhlblxuICAgIGxldCBuID0gcHBfbGltaXQgbiBpblxuICAgIHN0YXRlLnBwX21pbl9zcGFjZV9sZWZ0IDwtIG47XG4gICAgc3RhdGUucHBfbWF4X2luZGVudCA8LSBzdGF0ZS5wcF9tYXJnaW4gLSBzdGF0ZS5wcF9taW5fc3BhY2VfbGVmdDtcbiAgICBwcF9yaW5pdCBzdGF0ZVxuXG5cbigqIEluaXRpYWxseSwgd2UgaGF2ZSA6XG4gICBwcF9tYXhfaW5kZW50ID0gcHBfbWFyZ2luIC0gcHBfbWluX3NwYWNlX2xlZnQsIGFuZFxuICAgcHBfc3BhY2VfbGVmdCA9IHBwX21hcmdpbi4gKilcbmxldCBwcF9zZXRfbWF4X2luZGVudCBzdGF0ZSBuID1cbiAgaWYgbiA+IDEgdGhlblxuICAgIHBwX3NldF9taW5fc3BhY2VfbGVmdCBzdGF0ZSAoc3RhdGUucHBfbWFyZ2luIC0gbilcblxuXG5sZXQgcHBfZ2V0X21heF9pbmRlbnQgc3RhdGUgKCkgPSBzdGF0ZS5wcF9tYXhfaW5kZW50XG5cbmxldCBwcF9zZXRfbWFyZ2luIHN0YXRlIG4gPVxuICBpZiBuID49IDEgdGhlblxuICAgIGxldCBuID0gcHBfbGltaXQgbiBpblxuICAgIHN0YXRlLnBwX21hcmdpbiA8LSBuO1xuICAgIGxldCBuZXdfbWF4X2luZGVudCA9XG4gICAgICAoKiBUcnkgdG8gbWFpbnRhaW4gbWF4X2luZGVudCB0byBpdHMgYWN0dWFsIHZhbHVlLiAqKVxuICAgICAgaWYgc3RhdGUucHBfbWF4X2luZGVudCA8PSBzdGF0ZS5wcF9tYXJnaW5cbiAgICAgIHRoZW4gc3RhdGUucHBfbWF4X2luZGVudCBlbHNlXG4gICAgICAoKiBJZiBwb3NzaWJsZSBtYWludGFpbiBwcF9taW5fc3BhY2VfbGVmdCB0byBpdHMgYWN0dWFsIHZhbHVlLFxuICAgICAgICAgaWYgdGhpcyBsZWFkcyB0byBhIHRvbyBzbWFsbCBtYXhfaW5kZW50LCB0YWtlIGhhbGYgb2YgdGhlXG4gICAgICAgICBuZXcgbWFyZ2luLCBpZiBpdCBpcyBncmVhdGVyIHRoYW4gMS4gKilcbiAgICAgICBJbnQubWF4IChJbnQubWF4IChzdGF0ZS5wcF9tYXJnaW4gLSBzdGF0ZS5wcF9taW5fc3BhY2VfbGVmdClcbiAgICAgICAgICAgICAgICAoc3RhdGUucHBfbWFyZ2luIC8gMikpIDEgaW5cbiAgICAoKiBSZWJ1aWxkIGludmFyaWFudHMuICopXG4gICAgcHBfc2V0X21heF9pbmRlbnQgc3RhdGUgbmV3X21heF9pbmRlbnRcblxuXG4oKiogR2VvbWV0cnkgZnVuY3Rpb25zIGFuZCB0eXBlcyAqKVxudHlwZSBnZW9tZXRyeSA9IHsgbWF4X2luZGVudDppbnQ7IG1hcmdpbjogaW50fVxuXG5sZXQgdmFsaWRhdGVfZ2VvbWV0cnkge21hcmdpbjsgbWF4X2luZGVudH0gPVxuICBpZiBtYXhfaW5kZW50IDwgMiB0aGVuXG4gICAgRXJyb3IgXCJtYXhfaW5kZW50IDwgMlwiXG4gIGVsc2UgaWYgbWFyZ2luIDw9IG1heF9pbmRlbnQgdGhlblxuICAgIEVycm9yIFwibWFyZ2luIDw9IG1heF9pbmRlbnRcIlxuICBlbHNlIE9rICgpXG5cbmxldCBjaGVja19nZW9tZXRyeSBnZW9tZXRyeSA9XG4gIG1hdGNoIHZhbGlkYXRlX2dlb21ldHJ5IGdlb21ldHJ5IHdpdGhcbiAgfCBPayAoKSAtPiB0cnVlXG4gIHwgRXJyb3IgXyAtPiBmYWxzZVxuXG5sZXQgcHBfZ2V0X21hcmdpbiBzdGF0ZSAoKSA9IHN0YXRlLnBwX21hcmdpblxuXG5sZXQgcHBfc2V0X2Z1bGxfZ2VvbWV0cnkgc3RhdGUge21hcmdpbjsgbWF4X2luZGVudH0gPVxuICBwcF9zZXRfbWFyZ2luIHN0YXRlIG1hcmdpbjtcbiAgcHBfc2V0X21heF9pbmRlbnQgc3RhdGUgbWF4X2luZGVudDtcbiAgKClcblxubGV0IHBwX3NldF9nZW9tZXRyeSBzdGF0ZSB+bWF4X2luZGVudCB+bWFyZ2luID1cbiAgbGV0IGdlb21ldHJ5ID0geyBtYXhfaW5kZW50OyBtYXJnaW4gfSBpblxuICBtYXRjaCB2YWxpZGF0ZV9nZW9tZXRyeSBnZW9tZXRyeSB3aXRoXG4gIHwgRXJyb3IgbXNnIC0+XG4gICAgcmFpc2UgKEludmFsaWRfYXJndW1lbnQgKFwiRm9ybWF0LnBwX3NldF9nZW9tZXRyeTogXCIgXiBtc2cpKVxuICB8IE9rICgpIC0+XG4gICAgcHBfc2V0X2Z1bGxfZ2VvbWV0cnkgc3RhdGUgZ2VvbWV0cnlcblxubGV0IHBwX3NhZmVfc2V0X2dlb21ldHJ5IHN0YXRlIH5tYXhfaW5kZW50IH5tYXJnaW4gPVxuICBsZXQgZ2VvbWV0cnkgPSB7IG1heF9pbmRlbnQ7IG1hcmdpbiB9IGluXG4gIG1hdGNoIHZhbGlkYXRlX2dlb21ldHJ5IGdlb21ldHJ5IHdpdGhcbiAgfCBFcnJvciBfbXNnIC0+XG4gICAgICgpXG4gIHwgT2sgKCkgLT5cbiAgICBwcF9zZXRfZnVsbF9nZW9tZXRyeSBzdGF0ZSBnZW9tZXRyeVxuXG5sZXQgcHBfZ2V0X2dlb21ldHJ5IHN0YXRlICgpID1cbiAgeyBtYXJnaW4gPSBwcF9nZXRfbWFyZ2luIHN0YXRlICgpOyBtYXhfaW5kZW50ID0gcHBfZ2V0X21heF9pbmRlbnQgc3RhdGUgKCkgfVxuXG5sZXQgcHBfdXBkYXRlX2dlb21ldHJ5IHN0YXRlIHVwZGF0ZSA9XG4gIGxldCBnZW9tZXRyeSA9IHBwX2dldF9nZW9tZXRyeSBzdGF0ZSAoKSBpblxuICBwcF9zZXRfZnVsbF9nZW9tZXRyeSBzdGF0ZSAodXBkYXRlIGdlb21ldHJ5KVxuXG4oKiBTZXR0aW5nIGEgZm9ybWF0dGVyIGJhc2ljIG91dHB1dCBmdW5jdGlvbnMuICopXG5sZXQgcHBfc2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zIHN0YXRlIHtcbiAgICAgIG91dF9zdHJpbmcgPSBmO1xuICAgICAgb3V0X2ZsdXNoID0gZztcbiAgICAgIG91dF9uZXdsaW5lID0gaDtcbiAgICAgIG91dF9zcGFjZXMgPSBpO1xuICAgICAgb3V0X2luZGVudCA9IGo7XG4gICAgfSA9XG4gIHN0YXRlLnBwX291dF9zdHJpbmcgPC0gZjtcbiAgc3RhdGUucHBfb3V0X2ZsdXNoIDwtIGc7XG4gIHN0YXRlLnBwX291dF9uZXdsaW5lIDwtIGg7XG4gIHN0YXRlLnBwX291dF9zcGFjZXMgPC0gaTtcbiAgc3RhdGUucHBfb3V0X2luZGVudCA8LSBqXG5cbmxldCBwcF9nZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgc3RhdGUgKCkgPSB7XG4gIG91dF9zdHJpbmcgPSBzdGF0ZS5wcF9vdXRfc3RyaW5nO1xuICBvdXRfZmx1c2ggPSBzdGF0ZS5wcF9vdXRfZmx1c2g7XG4gIG91dF9uZXdsaW5lID0gc3RhdGUucHBfb3V0X25ld2xpbmU7XG4gIG91dF9zcGFjZXMgPSBzdGF0ZS5wcF9vdXRfc3BhY2VzO1xuICBvdXRfaW5kZW50ID0gc3RhdGUucHBfb3V0X2luZGVudDtcbn1cblxuXG4oKiBTZXR0aW5nIGEgZm9ybWF0dGVyIGJhc2ljIHN0cmluZyBvdXRwdXQgYW5kIGZsdXNoIGZ1bmN0aW9ucy4gKilcbmxldCBwcF9zZXRfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgc3RhdGUgZiBnID1cbiAgc3RhdGUucHBfb3V0X3N0cmluZyA8LSBmOyBzdGF0ZS5wcF9vdXRfZmx1c2ggPC0gZ1xuXG5sZXQgcHBfZ2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIHN0YXRlICgpID1cbiAgKHN0YXRlLnBwX291dF9zdHJpbmcsIHN0YXRlLnBwX291dF9mbHVzaClcblxuXG4oKiBUaGUgZGVmYXVsdCBmdW5jdGlvbiB0byBvdXRwdXQgbmV3IGxpbmVzLiAqKVxubGV0IGRpc3BsYXlfbmV3bGluZSBzdGF0ZSAoKSA9IHN0YXRlLnBwX291dF9zdHJpbmcgXCJcXG5cIiAwICAxXG5cbigqIFRoZSBkZWZhdWx0IGZ1bmN0aW9uIHRvIG91dHB1dCBzcGFjZXMuICopXG5sZXQgYmxhbmtfbGluZSA9IFN0cmluZy5tYWtlIDgwICcgJ1xubGV0IHJlYyBkaXNwbGF5X2JsYW5rcyBzdGF0ZSBuID1cbiAgaWYgbiA+IDAgdGhlblxuICBpZiBuIDw9IDgwIHRoZW4gc3RhdGUucHBfb3V0X3N0cmluZyBibGFua19saW5lIDAgbiBlbHNlXG4gIGJlZ2luXG4gICAgc3RhdGUucHBfb3V0X3N0cmluZyBibGFua19saW5lIDAgODA7XG4gICAgZGlzcGxheV9ibGFua3Mgc3RhdGUgKG4gLSA4MClcbiAgZW5kXG5cblxuKCogVGhlIGRlZmF1bHQgZnVuY3Rpb24gdG8gb3V0cHV0IGluZGVudGF0aW9uIG9mIG5ldyBsaW5lcy4gKilcbmxldCBkaXNwbGF5X2luZGVudCA9IGRpc3BsYXlfYmxhbmtzXG5cbigqIFNldHRpbmcgYSBmb3JtYXR0ZXIgYmFzaWMgb3V0cHV0IGZ1bmN0aW9ucyBhcyBwcmludGluZyB0byBhIGdpdmVuXG4gICBbUGVydmFzaXZlLm91dF9jaGFubmVsXSB2YWx1ZS4gKilcbmxldCBwcF9zZXRfZm9ybWF0dGVyX291dF9jaGFubmVsIHN0YXRlIG9jID1cbiAgc3RhdGUucHBfb3V0X3N0cmluZyA8LSBvdXRwdXRfc3Vic3RyaW5nIG9jO1xuICBzdGF0ZS5wcF9vdXRfZmx1c2ggPC0gKGZ1biAoKSAtPiBmbHVzaCBvYyk7XG4gIHN0YXRlLnBwX291dF9uZXdsaW5lIDwtIGRpc3BsYXlfbmV3bGluZSBzdGF0ZTtcbiAgc3RhdGUucHBfb3V0X3NwYWNlcyA8LSBkaXNwbGF5X2JsYW5rcyBzdGF0ZTtcbiAgc3RhdGUucHBfb3V0X2luZGVudCA8LSBkaXNwbGF5X2luZGVudCBzdGF0ZVxuXG4oKlxuXG4gIERlZmluaW5nIHNwZWNpZmljIGZvcm1hdHRlcnNcblxuKilcblxubGV0IGRlZmF1bHRfcHBfbWFya19vcGVuX3RhZyA9IGZ1bmN0aW9uXG4gIHwgU3RyaW5nX3RhZyBzIC0+IFwiPFwiIF4gcyBeIFwiPlwiXG4gIHwgXyAtPiBcIlwiXG5sZXQgZGVmYXVsdF9wcF9tYXJrX2Nsb3NlX3RhZyA9IGZ1bmN0aW9uXG4gIHwgU3RyaW5nX3RhZyBzIC0+IFwiPC9cIiBeIHMgXiBcIj5cIlxuICB8IF8gLT4gXCJcIlxuXG5sZXQgZGVmYXVsdF9wcF9wcmludF9vcGVuX3RhZyA9IGlnbm9yZVxubGV0IGRlZmF1bHRfcHBfcHJpbnRfY2xvc2VfdGFnID0gaWdub3JlXG5cbigqIEJ1aWxkaW5nIGEgZm9ybWF0dGVyIGdpdmVuIGl0cyBiYXNpYyBvdXRwdXQgZnVuY3Rpb25zLlxuICAgT3RoZXIgZmllbGRzIGdldCByZWFzb25hYmxlIGRlZmF1bHQgdmFsdWVzLiAqKVxubGV0IHBwX21ha2VfZm9ybWF0dGVyIGYgZyBoIGkgaiA9XG4gICgqIFRoZSBpbml0aWFsIHN0YXRlIG9mIHRoZSBmb3JtYXR0ZXIgY29udGFpbnMgYSBkdW1teSBib3guICopXG4gIGxldCBwcF9xdWV1ZSA9IFF1ZXVlLmNyZWF0ZSAoKSBpblxuICBsZXQgc3lzX3RvayA9XG4gICAgeyBzaXplID0gU2l6ZS51bmtub3duOyB0b2tlbiA9IFBwX2JlZ2luICgwLCBQcF9ob3Zib3gpOyBsZW5ndGggPSAwIH0gaW5cbiAgUXVldWUuYWRkIHN5c190b2sgcHBfcXVldWU7XG4gIGxldCBzY2FuX3N0YWNrID0gU3RhY2suY3JlYXRlICgpIGluXG4gIGluaXRpYWxpemVfc2Nhbl9zdGFjayBzY2FuX3N0YWNrO1xuICBTdGFjay5wdXNoIHsgbGVmdF90b3RhbCA9IDE7IHF1ZXVlX2VsZW0gPSBzeXNfdG9rIH0gc2Nhbl9zdGFjaztcbiAgbGV0IHBwX21hcmdpbiA9IDc4XG4gIGFuZCBwcF9taW5fc3BhY2VfbGVmdCA9IDEwIGluXG4gIHtcbiAgICBwcF9zY2FuX3N0YWNrID0gc2Nhbl9zdGFjaztcbiAgICBwcF9mb3JtYXRfc3RhY2sgPSBTdGFjay5jcmVhdGUgKCk7XG4gICAgcHBfdGJveF9zdGFjayA9IFN0YWNrLmNyZWF0ZSAoKTtcbiAgICBwcF90YWdfc3RhY2sgPSBTdGFjay5jcmVhdGUgKCk7XG4gICAgcHBfbWFya19zdGFjayA9IFN0YWNrLmNyZWF0ZSAoKTtcbiAgICBwcF9tYXJnaW4gPSBwcF9tYXJnaW47XG4gICAgcHBfbWluX3NwYWNlX2xlZnQgPSBwcF9taW5fc3BhY2VfbGVmdDtcbiAgICBwcF9tYXhfaW5kZW50ID0gcHBfbWFyZ2luIC0gcHBfbWluX3NwYWNlX2xlZnQ7XG4gICAgcHBfc3BhY2VfbGVmdCA9IHBwX21hcmdpbjtcbiAgICBwcF9jdXJyZW50X2luZGVudCA9IDA7XG4gICAgcHBfaXNfbmV3X2xpbmUgPSB0cnVlO1xuICAgIHBwX2xlZnRfdG90YWwgPSAxO1xuICAgIHBwX3JpZ2h0X3RvdGFsID0gMTtcbiAgICBwcF9jdXJyX2RlcHRoID0gMTtcbiAgICBwcF9tYXhfYm94ZXMgPSBtYXhfaW50O1xuICAgIHBwX2VsbGlwc2lzID0gXCIuXCI7XG4gICAgcHBfb3V0X3N0cmluZyA9IGY7XG4gICAgcHBfb3V0X2ZsdXNoID0gZztcbiAgICBwcF9vdXRfbmV3bGluZSA9IGg7XG4gICAgcHBfb3V0X3NwYWNlcyA9IGk7XG4gICAgcHBfb3V0X2luZGVudCA9IGo7XG4gICAgcHBfcHJpbnRfdGFncyA9IGZhbHNlO1xuICAgIHBwX21hcmtfdGFncyA9IGZhbHNlO1xuICAgIHBwX21hcmtfb3Blbl90YWcgPSBkZWZhdWx0X3BwX21hcmtfb3Blbl90YWc7XG4gICAgcHBfbWFya19jbG9zZV90YWcgPSBkZWZhdWx0X3BwX21hcmtfY2xvc2VfdGFnO1xuICAgIHBwX3ByaW50X29wZW5fdGFnID0gZGVmYXVsdF9wcF9wcmludF9vcGVuX3RhZztcbiAgICBwcF9wcmludF9jbG9zZV90YWcgPSBkZWZhdWx0X3BwX3ByaW50X2Nsb3NlX3RhZztcbiAgICBwcF9xdWV1ZSA9IHBwX3F1ZXVlO1xuICB9XG5cblxuKCogQnVpbGQgYSBmb3JtYXR0ZXIgb3V0IG9mIGl0cyBvdXQgZnVuY3Rpb25zLiAqKVxubGV0IGZvcm1hdHRlcl9vZl9vdXRfZnVuY3Rpb25zIG91dF9mdW5zID1cbiAgcHBfbWFrZV9mb3JtYXR0ZXJcbiAgICBvdXRfZnVucy5vdXRfc3RyaW5nXG4gICAgb3V0X2Z1bnMub3V0X2ZsdXNoXG4gICAgb3V0X2Z1bnMub3V0X25ld2xpbmVcbiAgICBvdXRfZnVucy5vdXRfc3BhY2VzXG4gICAgb3V0X2Z1bnMub3V0X2luZGVudFxuXG5cbigqIE1ha2UgYSBmb3JtYXR0ZXIgd2l0aCBkZWZhdWx0IGZ1bmN0aW9ucyB0byBvdXRwdXQgc3BhY2VzLFxuICBpbmRlbnRhdGlvbiwgYW5kIG5ldyBsaW5lcy4gKilcbmxldCBtYWtlX2Zvcm1hdHRlciBvdXRwdXQgZmx1c2ggPVxuICBsZXQgcHBmID0gcHBfbWFrZV9mb3JtYXR0ZXIgb3V0cHV0IGZsdXNoIGlnbm9yZSBpZ25vcmUgaWdub3JlIGluXG4gIHBwZi5wcF9vdXRfbmV3bGluZSA8LSBkaXNwbGF5X25ld2xpbmUgcHBmO1xuICBwcGYucHBfb3V0X3NwYWNlcyA8LSBkaXNwbGF5X2JsYW5rcyBwcGY7XG4gIHBwZi5wcF9vdXRfaW5kZW50IDwtIGRpc3BsYXlfaW5kZW50IHBwZjtcbiAgcHBmXG5cblxuKCogTWFrZSBhIGZvcm1hdHRlciB3cml0aW5nIHRvIGEgZ2l2ZW4gW1BlcnZhc2l2ZS5vdXRfY2hhbm5lbF0gdmFsdWUuICopXG5sZXQgZm9ybWF0dGVyX29mX291dF9jaGFubmVsIG9jID1cbiAgbWFrZV9mb3JtYXR0ZXIgKG91dHB1dF9zdWJzdHJpbmcgb2MpIChmdW4gKCkgLT4gZmx1c2ggb2MpXG5cblxuKCogTWFrZSBhIGZvcm1hdHRlciB3cml0aW5nIHRvIGEgZ2l2ZW4gW0J1ZmZlci50XSB2YWx1ZS4gKilcbmxldCBmb3JtYXR0ZXJfb2ZfYnVmZmVyIGIgPVxuICBtYWtlX2Zvcm1hdHRlciAoQnVmZmVyLmFkZF9zdWJzdHJpbmcgYikgaWdub3JlXG5cblxuKCogQWxsb2NhdGluZyBidWZmZXIgZm9yIHByZXR0eS1wcmludGluZyBwdXJwb3Nlcy5cbiAgIERlZmF1bHQgYnVmZmVyIHNpemUgaXMgcHBfYnVmZmVyX3NpemUgb3IgNTEyLlxuKilcbmxldCBwcF9idWZmZXJfc2l6ZSA9IDUxMlxubGV0IHBwX21ha2VfYnVmZmVyICgpID0gQnVmZmVyLmNyZWF0ZSBwcF9idWZmZXJfc2l6ZVxuXG4oKiBUaGUgc3RhbmRhcmQgKHNoYXJlZCkgYnVmZmVyLiAqKVxubGV0IHN0ZGJ1ZiA9IHBwX21ha2VfYnVmZmVyICgpXG5cbigqIFByZWRlZmluZWQgZm9ybWF0dGVycyBzdGFuZGFyZCBmb3JtYXR0ZXIgdG8gcHJpbnRcbiAgIHRvIFtTdGRsaWIuc3Rkb3V0XSwgW1N0ZGxpYi5zdGRlcnJdLCBhbmQgeyFzdGRidWZ9LiAqKVxubGV0IHN0ZF9mb3JtYXR0ZXIgPSBmb3JtYXR0ZXJfb2Zfb3V0X2NoYW5uZWwgU3RkbGliLnN0ZG91dFxuYW5kIGVycl9mb3JtYXR0ZXIgPSBmb3JtYXR0ZXJfb2Zfb3V0X2NoYW5uZWwgU3RkbGliLnN0ZGVyclxuYW5kIHN0cl9mb3JtYXR0ZXIgPSBmb3JtYXR0ZXJfb2ZfYnVmZmVyIHN0ZGJ1ZlxuXG5cbigqIFtmbHVzaF9idWZmZXJfZm9ybWF0dGVyIGJ1ZiBwcGZdIGZsdXNoZXMgZm9ybWF0dGVyIFtwcGZdLFxuICAgdGhlbiByZXR1cm5zIHRoZSBjb250ZW50cyBvZiBidWZmZXIgW2J1Zl0gdGhhdCBpcyByZXNldC5cbiAgIEZvcm1hdHRlciBbcHBmXSBpcyBzdXBwb3NlZCB0byBwcmludCB0byBidWZmZXIgW2J1Zl0sIG90aGVyd2lzZSB0aGlzXG4gICBmdW5jdGlvbiBpcyBub3QgcmVhbGx5IHVzZWZ1bC4gKilcbmxldCBmbHVzaF9idWZmZXJfZm9ybWF0dGVyIGJ1ZiBwcGYgPVxuICBwcF9mbHVzaF9xdWV1ZSBwcGYgZmFsc2U7XG4gIGxldCBzID0gQnVmZmVyLmNvbnRlbnRzIGJ1ZiBpblxuICBCdWZmZXIucmVzZXQgYnVmO1xuICBzXG5cblxuKCogRmx1c2ggW3N0cl9mb3JtYXR0ZXJdIGFuZCBnZXQgdGhlIGNvbnRlbnRzIG9mIFtzdGRidWZdLiAqKVxubGV0IGZsdXNoX3N0cl9mb3JtYXR0ZXIgKCkgPSBmbHVzaF9idWZmZXJfZm9ybWF0dGVyIHN0ZGJ1ZiBzdHJfZm9ybWF0dGVyXG5cbigqXG4gIFN5bWJvbGljIHByZXR0eS1wcmludGluZ1xuKilcblxuKCpcbiAgU3ltYm9saWMgcHJldHR5LXByaW50aW5nIGlzIHByZXR0eS1wcmludGluZyB3aXRoIG5vIGxvdyBsZXZlbCBvdXRwdXQuXG5cbiAgV2hlbiB1c2luZyBhIHN5bWJvbGljIGZvcm1hdHRlciwgYWxsIHJlZ3VsYXIgcHJldHR5LXByaW50aW5nIGFjdGl2aXRpZXNcbiAgb2NjdXIgYnV0IG91dHB1dCBtYXRlcmlhbCBpcyBzeW1ib2xpYyBhbmQgc3RvcmVkIGluIGEgYnVmZmVyIG9mIG91dHB1dFxuICBpdGVtcy4gQXQgdGhlIGVuZCBvZiBwcmV0dHktcHJpbnRpbmcsIGZsdXNoaW5nIHRoZSBvdXRwdXQgYnVmZmVyIGFsbG93c1xuICBwb3N0LXByb2Nlc3Npbmcgb2Ygc3ltYm9saWMgb3V0cHV0IGJlZm9yZSBsb3cgbGV2ZWwgb3V0cHV0IG9wZXJhdGlvbnMuXG4qKVxuXG50eXBlIHN5bWJvbGljX291dHB1dF9pdGVtID1cbiAgfCBPdXRwdXRfZmx1c2hcbiAgfCBPdXRwdXRfbmV3bGluZVxuICB8IE91dHB1dF9zdHJpbmcgb2Ygc3RyaW5nXG4gIHwgT3V0cHV0X3NwYWNlcyBvZiBpbnRcbiAgfCBPdXRwdXRfaW5kZW50IG9mIGludFxuXG50eXBlIHN5bWJvbGljX291dHB1dF9idWZmZXIgPSB7XG4gIG11dGFibGUgc3ltYm9saWNfb3V0cHV0X2NvbnRlbnRzIDogc3ltYm9saWNfb3V0cHV0X2l0ZW0gbGlzdDtcbn1cblxubGV0IG1ha2Vfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciAoKSA9XG4gIHsgc3ltYm9saWNfb3V0cHV0X2NvbnRlbnRzID0gW10gfVxuXG5sZXQgY2xlYXJfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciBzb2IgPVxuICBzb2Iuc3ltYm9saWNfb3V0cHV0X2NvbnRlbnRzIDwtIFtdXG5cbmxldCBnZXRfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciBzb2IgPVxuICBMaXN0LnJldiBzb2Iuc3ltYm9saWNfb3V0cHV0X2NvbnRlbnRzXG5cbmxldCBmbHVzaF9zeW1ib2xpY19vdXRwdXRfYnVmZmVyIHNvYiA9XG4gIGxldCBpdGVtcyA9IGdldF9zeW1ib2xpY19vdXRwdXRfYnVmZmVyIHNvYiBpblxuICBjbGVhcl9zeW1ib2xpY19vdXRwdXRfYnVmZmVyIHNvYjtcbiAgaXRlbXNcblxubGV0IGFkZF9zeW1ib2xpY19vdXRwdXRfaXRlbSBzb2IgaXRlbSA9XG4gIHNvYi5zeW1ib2xpY19vdXRwdXRfY29udGVudHMgPC0gaXRlbSA6OiBzb2Iuc3ltYm9saWNfb3V0cHV0X2NvbnRlbnRzXG5cbmxldCBmb3JtYXR0ZXJfb2Zfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciBzb2IgPVxuICBsZXQgc3ltYm9saWNfZmx1c2ggc29iICgpID1cbiAgICBhZGRfc3ltYm9saWNfb3V0cHV0X2l0ZW0gc29iIE91dHB1dF9mbHVzaFxuICBhbmQgc3ltYm9saWNfbmV3bGluZSBzb2IgKCkgPVxuICAgIGFkZF9zeW1ib2xpY19vdXRwdXRfaXRlbSBzb2IgT3V0cHV0X25ld2xpbmVcbiAgYW5kIHN5bWJvbGljX3N0cmluZyBzb2IgcyBpIG4gPVxuICAgIGFkZF9zeW1ib2xpY19vdXRwdXRfaXRlbSBzb2IgKE91dHB1dF9zdHJpbmcgKFN0cmluZy5zdWIgcyBpIG4pKVxuICBhbmQgc3ltYm9saWNfc3BhY2VzIHNvYiBuID1cbiAgICBhZGRfc3ltYm9saWNfb3V0cHV0X2l0ZW0gc29iIChPdXRwdXRfc3BhY2VzIG4pXG4gIGFuZCBzeW1ib2xpY19pbmRlbnQgc29iIG4gPVxuICAgIGFkZF9zeW1ib2xpY19vdXRwdXRfaXRlbSBzb2IgKE91dHB1dF9pbmRlbnQgbikgaW5cblxuICBsZXQgZiA9IHN5bWJvbGljX3N0cmluZyBzb2JcbiAgYW5kIGcgPSBzeW1ib2xpY19mbHVzaCBzb2JcbiAgYW5kIGggPSBzeW1ib2xpY19uZXdsaW5lIHNvYlxuICBhbmQgaSA9IHN5bWJvbGljX3NwYWNlcyBzb2JcbiAgYW5kIGogPSBzeW1ib2xpY19pbmRlbnQgc29iIGluXG4gIHBwX21ha2VfZm9ybWF0dGVyIGYgZyBoIGkgalxuXG4oKlxuXG4gIEJhc2ljIGZ1bmN0aW9ucyBvbiB0aGUgJ3N0YW5kYXJkJyBmb3JtYXR0ZXJcbiAgKHRoZSBmb3JtYXR0ZXIgdGhhdCBwcmludHMgdG8gW1N0ZGxpYi5zdGRvdXRdKS5cblxuKilcblxubGV0IG9wZW5faGJveCA9IHBwX29wZW5faGJveCBzdGRfZm9ybWF0dGVyXG5hbmQgb3Blbl92Ym94ID0gcHBfb3Blbl92Ym94IHN0ZF9mb3JtYXR0ZXJcbmFuZCBvcGVuX2h2Ym94ID0gcHBfb3Blbl9odmJveCBzdGRfZm9ybWF0dGVyXG5hbmQgb3Blbl9ob3Zib3ggPSBwcF9vcGVuX2hvdmJveCBzdGRfZm9ybWF0dGVyXG5hbmQgb3Blbl9ib3ggPSBwcF9vcGVuX2JveCBzdGRfZm9ybWF0dGVyXG5hbmQgY2xvc2VfYm94ID0gcHBfY2xvc2VfYm94IHN0ZF9mb3JtYXR0ZXJcbmFuZCBvcGVuX3RhZyA9IHBwX29wZW5fdGFnIHN0ZF9mb3JtYXR0ZXJcbmFuZCBjbG9zZV90YWcgPSBwcF9jbG9zZV90YWcgc3RkX2Zvcm1hdHRlclxuYW5kIG9wZW5fc3RhZyA9IHBwX29wZW5fc3RhZyBzdGRfZm9ybWF0dGVyXG5hbmQgY2xvc2Vfc3RhZyA9IHBwX2Nsb3NlX3N0YWcgc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X2FzID0gcHBfcHJpbnRfYXMgc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X3N0cmluZyA9IHBwX3ByaW50X3N0cmluZyBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfYnl0ZXMgPSBwcF9wcmludF9ieXRlcyBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfaW50ID0gcHBfcHJpbnRfaW50IHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF9mbG9hdCA9IHBwX3ByaW50X2Zsb2F0IHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF9jaGFyID0gcHBfcHJpbnRfY2hhciBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfYm9vbCA9IHBwX3ByaW50X2Jvb2wgc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X2JyZWFrID0gcHBfcHJpbnRfYnJlYWsgc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X2N1dCA9IHBwX3ByaW50X2N1dCBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfc3BhY2UgPSBwcF9wcmludF9zcGFjZSBzdGRfZm9ybWF0dGVyXG5hbmQgZm9yY2VfbmV3bGluZSA9IHBwX2ZvcmNlX25ld2xpbmUgc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X2ZsdXNoID0gcHBfcHJpbnRfZmx1c2ggc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X25ld2xpbmUgPSBwcF9wcmludF9uZXdsaW5lIHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF9pZl9uZXdsaW5lID0gcHBfcHJpbnRfaWZfbmV3bGluZSBzdGRfZm9ybWF0dGVyXG5cbmFuZCBvcGVuX3Rib3ggPSBwcF9vcGVuX3Rib3ggc3RkX2Zvcm1hdHRlclxuYW5kIGNsb3NlX3Rib3ggPSBwcF9jbG9zZV90Ym94IHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF90YnJlYWsgPSBwcF9wcmludF90YnJlYWsgc3RkX2Zvcm1hdHRlclxuXG5hbmQgc2V0X3RhYiA9IHBwX3NldF90YWIgc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X3RhYiA9IHBwX3ByaW50X3RhYiBzdGRfZm9ybWF0dGVyXG5cbmFuZCBzZXRfbWFyZ2luID0gcHBfc2V0X21hcmdpbiBzdGRfZm9ybWF0dGVyXG5hbmQgZ2V0X21hcmdpbiA9IHBwX2dldF9tYXJnaW4gc3RkX2Zvcm1hdHRlclxuXG5hbmQgc2V0X21heF9pbmRlbnQgPSBwcF9zZXRfbWF4X2luZGVudCBzdGRfZm9ybWF0dGVyXG5hbmQgZ2V0X21heF9pbmRlbnQgPSBwcF9nZXRfbWF4X2luZGVudCBzdGRfZm9ybWF0dGVyXG5cbmFuZCBzZXRfZ2VvbWV0cnkgPSBwcF9zZXRfZ2VvbWV0cnkgc3RkX2Zvcm1hdHRlclxuYW5kIHNhZmVfc2V0X2dlb21ldHJ5ID0gcHBfc2FmZV9zZXRfZ2VvbWV0cnkgc3RkX2Zvcm1hdHRlclxuYW5kIGdldF9nZW9tZXRyeSA9IHBwX2dldF9nZW9tZXRyeSBzdGRfZm9ybWF0dGVyXG5hbmQgdXBkYXRlX2dlb21ldHJ5ID0gcHBfdXBkYXRlX2dlb21ldHJ5IHN0ZF9mb3JtYXR0ZXJcblxuYW5kIHNldF9tYXhfYm94ZXMgPSBwcF9zZXRfbWF4X2JveGVzIHN0ZF9mb3JtYXR0ZXJcbmFuZCBnZXRfbWF4X2JveGVzID0gcHBfZ2V0X21heF9ib3hlcyBzdGRfZm9ybWF0dGVyXG5hbmQgb3Zlcl9tYXhfYm94ZXMgPSBwcF9vdmVyX21heF9ib3hlcyBzdGRfZm9ybWF0dGVyXG5cbmFuZCBzZXRfZWxsaXBzaXNfdGV4dCA9IHBwX3NldF9lbGxpcHNpc190ZXh0IHN0ZF9mb3JtYXR0ZXJcbmFuZCBnZXRfZWxsaXBzaXNfdGV4dCA9IHBwX2dldF9lbGxpcHNpc190ZXh0IHN0ZF9mb3JtYXR0ZXJcblxuYW5kIHNldF9mb3JtYXR0ZXJfb3V0X2NoYW5uZWwgPVxuICBwcF9zZXRfZm9ybWF0dGVyX291dF9jaGFubmVsIHN0ZF9mb3JtYXR0ZXJcblxuYW5kIHNldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyA9XG4gIHBwX3NldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyBzdGRfZm9ybWF0dGVyXG5hbmQgZ2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zID1cbiAgcHBfZ2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zIHN0ZF9mb3JtYXR0ZXJcblxuYW5kIHNldF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyA9XG4gIHBwX3NldF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyBzdGRfZm9ybWF0dGVyXG5hbmQgZ2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zID1cbiAgcHBfZ2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIHN0ZF9mb3JtYXR0ZXJcblxuYW5kIHNldF9mb3JtYXR0ZXJfc3RhZ19mdW5jdGlvbnMgPVxuICBwcF9zZXRfZm9ybWF0dGVyX3N0YWdfZnVuY3Rpb25zIHN0ZF9mb3JtYXR0ZXJcbmFuZCBnZXRfZm9ybWF0dGVyX3N0YWdfZnVuY3Rpb25zID1cbiAgcHBfZ2V0X2Zvcm1hdHRlcl9zdGFnX2Z1bmN0aW9ucyBzdGRfZm9ybWF0dGVyXG5hbmQgc2V0X3ByaW50X3RhZ3MgPVxuICBwcF9zZXRfcHJpbnRfdGFncyBzdGRfZm9ybWF0dGVyXG5hbmQgZ2V0X3ByaW50X3RhZ3MgPVxuICBwcF9nZXRfcHJpbnRfdGFncyBzdGRfZm9ybWF0dGVyXG5hbmQgc2V0X21hcmtfdGFncyA9XG4gIHBwX3NldF9tYXJrX3RhZ3Mgc3RkX2Zvcm1hdHRlclxuYW5kIGdldF9tYXJrX3RhZ3MgPVxuICBwcF9nZXRfbWFya190YWdzIHN0ZF9mb3JtYXR0ZXJcbmFuZCBzZXRfdGFncyA9XG4gIHBwX3NldF90YWdzIHN0ZF9mb3JtYXR0ZXJcblxuXG4oKiBDb252ZW5pZW5jZSBmdW5jdGlvbnMgKilcblxuKCogVG8gZm9ybWF0IGEgbGlzdCAqKVxubGV0IHJlYyBwcF9wcmludF9saXN0ID8ocHBfc2VwID0gcHBfcHJpbnRfY3V0KSBwcF92IHBwZiA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gKClcbiAgfCBbdl0gLT4gcHBfdiBwcGYgdlxuICB8IHYgOjogdnMgLT5cbiAgICBwcF92IHBwZiB2O1xuICAgIHBwX3NlcCBwcGYgKCk7XG4gICAgcHBfcHJpbnRfbGlzdCB+cHBfc2VwIHBwX3YgcHBmIHZzXG5cbigqIFRvIGZvcm1hdCBhIHNlcXVlbmNlICopXG5sZXQgcmVjIHBwX3ByaW50X3NlcV9pbiB+cHBfc2VwIHBwX3YgcHBmIHNlcSA9XG4gIG1hdGNoIHNlcSAoKSB3aXRoXG4gIHwgU2VxLk5pbCAtPiAoKVxuICB8IFNlcS5Db25zICh2LCBzZXEpIC0+XG4gICAgcHBfc2VwIHBwZiAoKTtcbiAgICBwcF92IHBwZiB2O1xuICAgIHBwX3ByaW50X3NlcV9pbiB+cHBfc2VwIHBwX3YgcHBmIHNlcVxuXG5sZXQgcHBfcHJpbnRfc2VxID8ocHBfc2VwID0gcHBfcHJpbnRfY3V0KSBwcF92IHBwZiBzZXEgPVxuICBtYXRjaCBzZXEgKCkgd2l0aFxuICB8IFNlcS5OaWwgLT4gKClcbiAgfCBTZXEuQ29ucyAodiwgc2VxKSAtPlxuICAgIHBwX3YgcHBmIHY7XG4gICAgcHBfcHJpbnRfc2VxX2luIH5wcF9zZXAgcHBfdiBwcGYgc2VxXG5cbigqIFRvIGZvcm1hdCBmcmVlLWZsb3dpbmcgdGV4dCAqKVxubGV0IHBwX3ByaW50X3RleHQgcHBmIHMgPVxuICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gIGxldCBsZWZ0ID0gcmVmIDAgaW5cbiAgbGV0IHJpZ2h0ID0gcmVmIDAgaW5cbiAgbGV0IGZsdXNoICgpID1cbiAgICBwcF9wcmludF9zdHJpbmcgcHBmIChTdHJpbmcuc3ViIHMgIWxlZnQgKCFyaWdodCAtICFsZWZ0KSk7XG4gICAgaW5jciByaWdodDsgbGVmdCA6PSAhcmlnaHQ7XG4gIGluXG4gIHdoaWxlICghcmlnaHQgPD4gbGVuKSBkb1xuICAgIG1hdGNoIHMuWyFyaWdodF0gd2l0aFxuICAgICAgfCAnXFxuJyAtPlxuICAgICAgICBmbHVzaCAoKTtcbiAgICAgICAgcHBfZm9yY2VfbmV3bGluZSBwcGYgKClcbiAgICAgIHwgJyAnIC0+XG4gICAgICAgIGZsdXNoICgpOyBwcF9wcmludF9zcGFjZSBwcGYgKClcbiAgICAgICgqIHRoZXJlIGlzIG5vIHNwZWNpZmljIHN1cHBvcnQgZm9yICdcXHQnXG4gICAgICAgICBhcyBpdCBpcyB1bmNsZWFyIHdoYXQgYSByaWdodCBzZW1hbnRpY3Mgd291bGQgYmUgKilcbiAgICAgIHwgXyAtPiBpbmNyIHJpZ2h0XG4gIGRvbmU7XG4gIGlmICFsZWZ0IDw+IGxlbiB0aGVuIGZsdXNoICgpXG5cbmxldCBwcF9wcmludF9vcHRpb24gPyhub25lID0gZnVuIF8gKCkgLT4gKCkpIHBwX3YgcHBmID0gZnVuY3Rpb25cbnwgTm9uZSAtPiBub25lIHBwZiAoKVxufCBTb21lIHYgLT4gcHBfdiBwcGYgdlxuXG5sZXQgcHBfcHJpbnRfcmVzdWx0IH5vayB+ZXJyb3IgcHBmID0gZnVuY3Rpb25cbnwgT2sgdiAtPiBvayBwcGYgdlxufCBFcnJvciBlIC0+IGVycm9yIHBwZiBlXG5cbmxldCBwcF9wcmludF9laXRoZXIgfmxlZnQgfnJpZ2h0IHBwZiA9IGZ1bmN0aW9uXG58IEVpdGhlci5MZWZ0IGwgLT4gbGVmdCBwcGYgbFxufCBFaXRoZXIuUmlnaHQgciAtPiByaWdodCBwcGYgclxuXG4gKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5sZXQgY29tcHV0ZV90YWcgb3V0cHV0IHRhZ19hY2MgPVxuICBsZXQgYnVmID0gQnVmZmVyLmNyZWF0ZSAxNiBpblxuICBsZXQgcHBmID0gZm9ybWF0dGVyX29mX2J1ZmZlciBidWYgaW5cbiAgb3V0cHV0IHBwZiB0YWdfYWNjO1xuICBwcF9wcmludF9mbHVzaCBwcGYgKCk7XG4gIGxldCBsZW4gPSBCdWZmZXIubGVuZ3RoIGJ1ZiBpblxuICBpZiBsZW4gPCAyIHRoZW4gQnVmZmVyLmNvbnRlbnRzIGJ1ZlxuICBlbHNlIEJ1ZmZlci5zdWIgYnVmIDEgKGxlbiAtIDIpXG5cbiAoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblxuICBEZWZpbmluZyBjb250aW51YXRpb25zIHRvIGJlIHBhc3NlZCBhcyBhcmd1bWVudHMgb2ZcbiAgQ2FtbGludGVybmFsRm9ybWF0Lm1ha2VfcHJpbnRmLlxuXG4gICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5vcGVuIENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljc1xub3BlbiBDYW1saW50ZXJuYWxGb3JtYXRcblxuKCogSW50ZXJwcmV0IGEgZm9ybWF0dGluZyBlbnRpdHkgb24gYSBmb3JtYXR0ZXIuICopXG5sZXQgb3V0cHV0X2Zvcm1hdHRpbmdfbGl0IHBwZiBmbXRpbmdfbGl0ID0gbWF0Y2ggZm10aW5nX2xpdCB3aXRoXG4gIHwgQ2xvc2VfYm94ICAgICAgICAgICAgICAgICAtPiBwcF9jbG9zZV9ib3ggcHBmICgpXG4gIHwgQ2xvc2VfdGFnICAgICAgICAgICAgICAgICAtPiBwcF9jbG9zZV90YWcgcHBmICgpXG4gIHwgQnJlYWsgKF8sIHdpZHRoLCBvZmZzZXQpICAtPiBwcF9wcmludF9icmVhayBwcGYgd2lkdGggb2Zmc2V0XG4gIHwgRkZsdXNoICAgICAgICAgICAgICAgICAgICAtPiBwcF9wcmludF9mbHVzaCBwcGYgKClcbiAgfCBGb3JjZV9uZXdsaW5lICAgICAgICAgICAgIC0+IHBwX2ZvcmNlX25ld2xpbmUgcHBmICgpXG4gIHwgRmx1c2hfbmV3bGluZSAgICAgICAgICAgICAtPiBwcF9wcmludF9uZXdsaW5lIHBwZiAoKVxuICB8IE1hZ2ljX3NpemUgKF8sIF8pICAgICAgICAgLT4gKClcbiAgfCBFc2NhcGVkX2F0ICAgICAgICAgICAgICAgIC0+IHBwX3ByaW50X2NoYXIgcHBmICdAJ1xuICB8IEVzY2FwZWRfcGVyY2VudCAgICAgICAgICAgLT4gcHBfcHJpbnRfY2hhciBwcGYgJyUnXG4gIHwgU2Nhbl9pbmRpYyBjICAgICAgICAgICAgICAtPiBwcF9wcmludF9jaGFyIHBwZiAnQCc7IHBwX3ByaW50X2NoYXIgcHBmIGNcblxuKCogUmVjdXJzaXZlbHkgb3V0cHV0IGFuIFwiYWNjdW11bGF0b3JcIiBjb250YWluaW5nIGEgcmV2ZXJzZWQgbGlzdCBvZlxuICAgcHJpbnRpbmcgZW50aXRpZXMgKHN0cmluZywgY2hhciwgZmx1cywgLi4uKSBpbiBhbiBvdXRwdXRfc3RyZWFtLiAqKVxuKCogRGlmZmVyIGZyb20gUHJpbnRmLm91dHB1dF9hY2MgYnkgdGhlIGludGVycHJldGF0aW9uIG9mIGZvcm1hdHRpbmcuICopXG4oKiBVc2VkIGFzIGEgY29udGludWF0aW9uIG9mIENhbWxpbnRlcm5hbEZvcm1hdC5tYWtlX3ByaW50Zi4gKilcbmxldCByZWMgb3V0cHV0X2FjYyBwcGYgYWNjID0gbWF0Y2ggYWNjIHdpdGhcbiAgfCBBY2Nfc3RyaW5nX2xpdGVyYWwgKEFjY19mb3JtYXR0aW5nX2xpdCAocCwgTWFnaWNfc2l6ZSAoXywgc2l6ZSkpLCBzKVxuICB8IEFjY19kYXRhX3N0cmluZyAoQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBNYWdpY19zaXplIChfLCBzaXplKSksIHMpIC0+XG4gICAgb3V0cHV0X2FjYyBwcGYgcDtcbiAgICBwcF9wcmludF9hc19zaXplIHBwZiAoU2l6ZS5vZl9pbnQgc2l6ZSkgcztcbiAgfCBBY2NfY2hhcl9saXRlcmFsIChBY2NfZm9ybWF0dGluZ19saXQgKHAsIE1hZ2ljX3NpemUgKF8sIHNpemUpKSwgYylcbiAgfCBBY2NfZGF0YV9jaGFyIChBY2NfZm9ybWF0dGluZ19saXQgKHAsIE1hZ2ljX3NpemUgKF8sIHNpemUpKSwgYykgLT5cbiAgICBvdXRwdXRfYWNjIHBwZiBwO1xuICAgIHBwX3ByaW50X2FzX3NpemUgcHBmIChTaXplLm9mX2ludCBzaXplKSAoU3RyaW5nLm1ha2UgMSBjKTtcbiAgfCBBY2NfZm9ybWF0dGluZ19saXQgKHAsIGYpIC0+XG4gICAgb3V0cHV0X2FjYyBwcGYgcDtcbiAgICBvdXRwdXRfZm9ybWF0dGluZ19saXQgcHBmIGY7XG4gIHwgQWNjX2Zvcm1hdHRpbmdfZ2VuIChwLCBBY2Nfb3Blbl90YWcgYWNjJykgLT5cbiAgICBvdXRwdXRfYWNjIHBwZiBwO1xuICAgIHBwX29wZW5fc3RhZyBwcGYgKFN0cmluZ190YWcgKGNvbXB1dGVfdGFnIG91dHB1dF9hY2MgYWNjJykpXG4gIHwgQWNjX2Zvcm1hdHRpbmdfZ2VuIChwLCBBY2Nfb3Blbl9ib3ggYWNjJykgLT5cbiAgICBvdXRwdXRfYWNjIHBwZiBwO1xuICAgIGxldCAoaW5kZW50LCBidHkpID0gb3Blbl9ib3hfb2Zfc3RyaW5nIChjb21wdXRlX3RhZyBvdXRwdXRfYWNjIGFjYycpIGluXG4gICAgcHBfb3Blbl9ib3hfZ2VuIHBwZiBpbmRlbnQgYnR5XG4gIHwgQWNjX3N0cmluZ19saXRlcmFsIChwLCBzKVxuICB8IEFjY19kYXRhX3N0cmluZyAocCwgcykgICAtPiBvdXRwdXRfYWNjIHBwZiBwOyBwcF9wcmludF9zdHJpbmcgcHBmIHM7XG4gIHwgQWNjX2NoYXJfbGl0ZXJhbCAocCwgYylcbiAgfCBBY2NfZGF0YV9jaGFyIChwLCBjKSAgICAgLT4gb3V0cHV0X2FjYyBwcGYgcDsgcHBfcHJpbnRfY2hhciBwcGYgYztcbiAgfCBBY2NfZGVsYXkgKHAsIGYpICAgICAgICAgLT4gb3V0cHV0X2FjYyBwcGYgcDsgZiBwcGY7XG4gIHwgQWNjX2ZsdXNoIHAgICAgICAgICAgICAgIC0+IG91dHB1dF9hY2MgcHBmIHA7IHBwX3ByaW50X2ZsdXNoIHBwZiAoKTtcbiAgfCBBY2NfaW52YWxpZF9hcmcgKHAsIG1zZykgLT4gb3V0cHV0X2FjYyBwcGYgcDsgaW52YWxpZF9hcmcgbXNnO1xuICB8IEVuZF9vZl9hY2MgICAgICAgICAgICAgICAtPiAoKVxuXG4oKiBSZWN1cnNpdmVseSBvdXRwdXQgYW4gXCJhY2N1bXVsYXRvclwiIGNvbnRhaW5pbmcgYSByZXZlcnNlZCBsaXN0IG9mXG4gICBwcmludGluZyBlbnRpdGllcyAoc3RyaW5nLCBjaGFyLCBmbHVzLCAuLi4pIGluIGEgYnVmZmVyLiAqKVxuKCogRGlmZmVyIGZyb20gUHJpbnRmLmJ1ZnB1dF9hY2MgYnkgdGhlIGludGVycHJldGF0aW9uIG9mIGZvcm1hdHRpbmcuICopXG4oKiBVc2VkIGFzIGEgY29udGludWF0aW9uIG9mIENhbWxpbnRlcm5hbEZvcm1hdC5tYWtlX3ByaW50Zi4gKilcbmxldCByZWMgc3RycHV0X2FjYyBwcGYgYWNjID0gbWF0Y2ggYWNjIHdpdGhcbiAgfCBBY2Nfc3RyaW5nX2xpdGVyYWwgKEFjY19mb3JtYXR0aW5nX2xpdCAocCwgTWFnaWNfc2l6ZSAoXywgc2l6ZSkpLCBzKVxuICB8IEFjY19kYXRhX3N0cmluZyAoQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBNYWdpY19zaXplIChfLCBzaXplKSksIHMpIC0+XG4gICAgc3RycHV0X2FjYyBwcGYgcDtcbiAgICBwcF9wcmludF9hc19zaXplIHBwZiAoU2l6ZS5vZl9pbnQgc2l6ZSkgcztcbiAgfCBBY2NfY2hhcl9saXRlcmFsIChBY2NfZm9ybWF0dGluZ19saXQgKHAsIE1hZ2ljX3NpemUgKF8sIHNpemUpKSwgYylcbiAgfCBBY2NfZGF0YV9jaGFyIChBY2NfZm9ybWF0dGluZ19saXQgKHAsIE1hZ2ljX3NpemUgKF8sIHNpemUpKSwgYykgLT5cbiAgICBzdHJwdXRfYWNjIHBwZiBwO1xuICAgIHBwX3ByaW50X2FzX3NpemUgcHBmIChTaXplLm9mX2ludCBzaXplKSAoU3RyaW5nLm1ha2UgMSBjKTtcbiAgfCBBY2NfZGVsYXkgKEFjY19mb3JtYXR0aW5nX2xpdCAocCwgTWFnaWNfc2l6ZSAoXywgc2l6ZSkpLCBmKSAtPlxuICAgIHN0cnB1dF9hY2MgcHBmIHA7XG4gICAgcHBfcHJpbnRfYXNfc2l6ZSBwcGYgKFNpemUub2ZfaW50IHNpemUpIChmICgpKTtcbiAgfCBBY2NfZm9ybWF0dGluZ19saXQgKHAsIGYpIC0+XG4gICAgc3RycHV0X2FjYyBwcGYgcDtcbiAgICBvdXRwdXRfZm9ybWF0dGluZ19saXQgcHBmIGY7XG4gIHwgQWNjX2Zvcm1hdHRpbmdfZ2VuIChwLCBBY2Nfb3Blbl90YWcgYWNjJykgLT5cbiAgICBzdHJwdXRfYWNjIHBwZiBwO1xuICAgIHBwX29wZW5fc3RhZyBwcGYgKFN0cmluZ190YWcgKGNvbXB1dGVfdGFnIHN0cnB1dF9hY2MgYWNjJykpXG4gIHwgQWNjX2Zvcm1hdHRpbmdfZ2VuIChwLCBBY2Nfb3Blbl9ib3ggYWNjJykgLT5cbiAgICBzdHJwdXRfYWNjIHBwZiBwO1xuICAgIGxldCAoaW5kZW50LCBidHkpID0gb3Blbl9ib3hfb2Zfc3RyaW5nIChjb21wdXRlX3RhZyBzdHJwdXRfYWNjIGFjYycpIGluXG4gICAgcHBfb3Blbl9ib3hfZ2VuIHBwZiBpbmRlbnQgYnR5XG4gIHwgQWNjX3N0cmluZ19saXRlcmFsIChwLCBzKVxuICB8IEFjY19kYXRhX3N0cmluZyAocCwgcykgICAtPiBzdHJwdXRfYWNjIHBwZiBwOyBwcF9wcmludF9zdHJpbmcgcHBmIHM7XG4gIHwgQWNjX2NoYXJfbGl0ZXJhbCAocCwgYylcbiAgfCBBY2NfZGF0YV9jaGFyIChwLCBjKSAgICAgLT4gc3RycHV0X2FjYyBwcGYgcDsgcHBfcHJpbnRfY2hhciBwcGYgYztcbiAgfCBBY2NfZGVsYXkgKHAsIGYpICAgICAgICAgLT4gc3RycHV0X2FjYyBwcGYgcDsgcHBfcHJpbnRfc3RyaW5nIHBwZiAoZiAoKSk7XG4gIHwgQWNjX2ZsdXNoIHAgICAgICAgICAgICAgIC0+IHN0cnB1dF9hY2MgcHBmIHA7IHBwX3ByaW50X2ZsdXNoIHBwZiAoKTtcbiAgfCBBY2NfaW52YWxpZF9hcmcgKHAsIG1zZykgLT4gc3RycHV0X2FjYyBwcGYgcDsgaW52YWxpZF9hcmcgbXNnO1xuICB8IEVuZF9vZl9hY2MgICAgICAgICAgICAgICAtPiAoKVxuXG4oKlxuXG4gIERlZmluaW5nIFtmcHJpbnRmXSBhbmQgdmFyaW91cyBmbGF2b3JzIG9mIFtmcHJpbnRmXS5cblxuKilcblxubGV0IGtmcHJpbnRmIGsgcHBmIChGb3JtYXQgKGZtdCwgXykpID1cbiAgbWFrZV9wcmludGZcbiAgICAoZnVuIGFjYyAtPiBvdXRwdXRfYWNjIHBwZiBhY2M7IGsgcHBmKVxuICAgIEVuZF9vZl9hY2MgZm10XG5cbmFuZCBpa2ZwcmludGYgayBwcGYgKEZvcm1hdCAoZm10LCBfKSkgPVxuICBtYWtlX2lwcmludGYgayBwcGYgZm10XG5cbmxldCBpZnByaW50ZiBfcHBmIChGb3JtYXQgKGZtdCwgXykpID1cbiAgbWFrZV9pcHJpbnRmIGlnbm9yZSAoKSBmbXRcblxubGV0IGZwcmludGYgcHBmID0ga2ZwcmludGYgaWdub3JlIHBwZlxubGV0IHByaW50ZiBmbXQgPSBmcHJpbnRmIHN0ZF9mb3JtYXR0ZXIgZm10XG5sZXQgZXByaW50ZiBmbXQgPSBmcHJpbnRmIGVycl9mb3JtYXR0ZXIgZm10XG5cbmxldCBrZHByaW50ZiBrIChGb3JtYXQgKGZtdCwgXykpID1cbiAgbWFrZV9wcmludGZcbiAgICAoZnVuIGFjYyAtPiBrIChmdW4gcHBmIC0+IG91dHB1dF9hY2MgcHBmIGFjYykpXG4gICAgRW5kX29mX2FjYyBmbXRcblxubGV0IGRwcmludGYgZm10ID0ga2RwcmludGYgKGZ1biBpIC0+IGkpIGZtdFxuXG5sZXQga3NwcmludGYgayAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIGxldCBiID0gcHBfbWFrZV9idWZmZXIgKCkgaW5cbiAgbGV0IHBwZiA9IGZvcm1hdHRlcl9vZl9idWZmZXIgYiBpblxuICBsZXQgayBhY2MgPVxuICAgIHN0cnB1dF9hY2MgcHBmIGFjYztcbiAgICBrIChmbHVzaF9idWZmZXJfZm9ybWF0dGVyIGIgcHBmKSBpblxuICBtYWtlX3ByaW50ZiBrIEVuZF9vZl9hY2MgZm10XG5cblxubGV0IHNwcmludGYgZm10ID0ga3NwcmludGYgaWQgZm10XG5cbmxldCBrYXNwcmludGYgayAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIGxldCBiID0gcHBfbWFrZV9idWZmZXIgKCkgaW5cbiAgbGV0IHBwZiA9IGZvcm1hdHRlcl9vZl9idWZmZXIgYiBpblxuICBsZXQgayBhY2MgPVxuICAgIG91dHB1dF9hY2MgcHBmIGFjYztcbiAgICBrIChmbHVzaF9idWZmZXJfZm9ybWF0dGVyIGIgcHBmKSBpblxuICBtYWtlX3ByaW50ZiBrIEVuZF9vZl9hY2MgZm10XG5cblxubGV0IGFzcHJpbnRmIGZtdCA9IGthc3ByaW50ZiBpZCBmbXRcblxuKCogRmx1c2hpbmcgc3RhbmRhcmQgZm9ybWF0dGVycyBhdCBlbmQgb2YgZXhlY3V0aW9uLiAqKVxuXG5sZXQgZmx1c2hfc3RhbmRhcmRfZm9ybWF0dGVycyAoKSA9XG4gIHBwX3ByaW50X2ZsdXNoIHN0ZF9mb3JtYXR0ZXIgKCk7XG4gIHBwX3ByaW50X2ZsdXNoIGVycl9mb3JtYXR0ZXIgKClcblxubGV0ICgpID0gYXRfZXhpdCBmbHVzaF9zdGFuZGFyZF9mb3JtYXR0ZXJzXG5cbigqXG5cbiAgRGVwcmVjYXRlZCBzdHVmZi5cblxuKilcblxuKCogRGVwcmVjYXRlZCA6IHN1YnN1bWVkIGJ5IHBwX3NldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyAqKVxubGV0IHBwX3NldF9hbGxfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgc3RhdGVcbiAgICB+b3V0OmYgfmZsdXNoOmcgfm5ld2xpbmU6aCB+c3BhY2VzOmkgPVxuICBwcF9zZXRfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgc3RhdGUgZiBnO1xuICBzdGF0ZS5wcF9vdXRfbmV3bGluZSA8LSBoO1xuICBzdGF0ZS5wcF9vdXRfc3BhY2VzIDwtIGlcblxuKCogRGVwcmVjYXRlZCA6IHN1YnN1bWVkIGJ5IHBwX2dldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyAqKVxubGV0IHBwX2dldF9hbGxfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgc3RhdGUgKCkgPVxuICAoc3RhdGUucHBfb3V0X3N0cmluZywgc3RhdGUucHBfb3V0X2ZsdXNoLFxuICAgc3RhdGUucHBfb3V0X25ld2xpbmUsIHN0YXRlLnBwX291dF9zcGFjZXMpXG5cblxuKCogRGVwcmVjYXRlZCA6IHN1YnN1bWVkIGJ5IHNldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyAqKVxubGV0IHNldF9hbGxfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgPVxuICBwcF9zZXRfYWxsX2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIHN0ZF9mb3JtYXR0ZXJcblxuXG4oKiBEZXByZWNhdGVkIDogc3Vic3VtZWQgYnkgZ2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zICopXG5sZXQgZ2V0X2FsbF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyA9XG4gIHBwX2dldF9hbGxfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgc3RkX2Zvcm1hdHRlclxuXG5cbigqIERlcHJlY2F0ZWQgOiBlcnJvciBwcm9uZSBmdW5jdGlvbiwgZG8gbm90IHVzZSBpdC5cbiAgIFRoaXMgZnVuY3Rpb24gaXMgbmVpdGhlciBjb21wb3NpdGlvbmFsIG5vciBpbmNyZW1lbnRhbCwgc2luY2UgaXQgZmx1c2hlc1xuICAgdGhlIHByZXR0eS1wcmludGVyIHF1ZXVlIGF0IGVhY2ggY2FsbC5cbiAgIFRvIGdldCB0aGUgc2FtZSBmdW5jdGlvbmFsaXR5LCBkZWZpbmUgYSBmb3JtYXR0ZXIgb2YgeW91ciBvd24gd3JpdGluZyB0b1xuICAgdGhlIGJ1ZmZlciBhcmd1bWVudCwgYXMgaW5cbiAgIGxldCBwcGYgPSBmb3JtYXR0ZXJfb2ZfYnVmZmVyIGJcbiAgIHRoZW4gdXNlIHshZnByaW50ZiBwcGZ9IGFzIHVzdWFsLiAqKVxubGV0IGJwcmludGYgYiAoRm9ybWF0IChmbXQsIF8pIDogKCdhLCBmb3JtYXR0ZXIsIHVuaXQpIGZvcm1hdCkgPVxuICBsZXQgcHBmID0gZm9ybWF0dGVyX29mX2J1ZmZlciBiIGluXG4gIGxldCBrIGFjYyA9IG91dHB1dF9hY2MgcHBmIGFjYzsgcHBfZmx1c2hfcXVldWUgcHBmIGZhbHNlIGluXG4gIG1ha2VfcHJpbnRmIGsgRW5kX29mX2FjYyBmbXRcblxuXG4oKiBEZXByZWNhdGVkIDogYWxpYXMgZm9yIGtzcHJpbnRmLiAqKVxubGV0IGtwcmludGYgPSBrc3ByaW50ZlxuXG5cblxuKCogRGVwcmVjYXRlZCB0YWcgZnVuY3Rpb25zICopXG5cbnR5cGUgZm9ybWF0dGVyX3RhZ19mdW5jdGlvbnMgPSB7XG4gIG1hcmtfb3Blbl90YWcgOiB0YWcgLT4gc3RyaW5nO1xuICBtYXJrX2Nsb3NlX3RhZyA6IHRhZyAtPiBzdHJpbmc7XG4gIHByaW50X29wZW5fdGFnIDogdGFnIC0+IHVuaXQ7XG4gIHByaW50X2Nsb3NlX3RhZyA6IHRhZyAtPiB1bml0O1xufVxuXG5cbmxldCBwcF9zZXRfZm9ybWF0dGVyX3RhZ19mdW5jdGlvbnMgc3RhdGUge1xuICAgICBtYXJrX29wZW5fdGFnID0gbW90O1xuICAgICBtYXJrX2Nsb3NlX3RhZyA9IG1jdDtcbiAgICAgcHJpbnRfb3Blbl90YWcgPSBwb3Q7XG4gICAgIHByaW50X2Nsb3NlX3RhZyA9IHBjdDtcbiAgIH0gPVxuICBsZXQgc3RyaW5naWZ5IGYgZSA9IGZ1bmN0aW9uIFN0cmluZ190YWcgcyAtPiBmIHMgfCBfIC0+IGUgaW5cbiAgc3RhdGUucHBfbWFya19vcGVuX3RhZyA8LSBzdHJpbmdpZnkgbW90IFwiXCI7XG4gIHN0YXRlLnBwX21hcmtfY2xvc2VfdGFnIDwtIHN0cmluZ2lmeSBtY3QgXCJcIjtcbiAgc3RhdGUucHBfcHJpbnRfb3Blbl90YWcgPC0gc3RyaW5naWZ5IHBvdCAoKTtcbiAgc3RhdGUucHBfcHJpbnRfY2xvc2VfdGFnIDwtIHN0cmluZ2lmeSBwY3QgKClcblxubGV0IHBwX2dldF9mb3JtYXR0ZXJfdGFnX2Z1bmN0aW9ucyBmbXQgKCkgPVxuICBsZXQgZnVucyA9IHBwX2dldF9mb3JtYXR0ZXJfc3RhZ19mdW5jdGlvbnMgZm10ICgpIGluXG4gIGxldCBtYXJrX29wZW5fdGFnIHMgPSBmdW5zLm1hcmtfb3Blbl9zdGFnIChTdHJpbmdfdGFnIHMpIGluXG4gIGxldCBtYXJrX2Nsb3NlX3RhZyBzID0gZnVucy5tYXJrX2Nsb3NlX3N0YWcgKFN0cmluZ190YWcgcykgaW5cbiAgbGV0IHByaW50X29wZW5fdGFnIHMgPSBmdW5zLnByaW50X29wZW5fc3RhZyAoU3RyaW5nX3RhZyBzKSBpblxuICBsZXQgcHJpbnRfY2xvc2VfdGFnIHMgPSBmdW5zLnByaW50X2Nsb3NlX3N0YWcgKFN0cmluZ190YWcgcykgaW5cbiAge21hcmtfb3Blbl90YWc7IG1hcmtfY2xvc2VfdGFnOyBwcmludF9vcGVuX3RhZzsgcHJpbnRfY2xvc2VfdGFnfVxuXG5sZXQgc2V0X2Zvcm1hdHRlcl90YWdfZnVuY3Rpb25zID1cbiAgcHBfc2V0X2Zvcm1hdHRlcl90YWdfZnVuY3Rpb25zIHN0ZF9mb3JtYXR0ZXJcbmFuZCBnZXRfZm9ybWF0dGVyX3RhZ19mdW5jdGlvbnMgPVxuICBwcF9nZXRfZm9ybWF0dGVyX3RhZ19mdW5jdGlvbnMgc3RkX2Zvcm1hdHRlclxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgUGllcnJlIFdlaXMsIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAwMiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5vcGVuIENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljc1xub3BlbiBDYW1saW50ZXJuYWxGb3JtYXRcblxuKCogYWxpYXMgdG8gYXZvaWQgd2FybmluZyBmb3IgYW1iaWd1aXR5IGJldHdlZW5cbiAgIFN0ZGxpYi5mb3JtYXQ2XG4gICBhbmQgQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzLmZvcm1hdDZcblxuICAgKHRoZSBmb3JtZXIgaXMgaW4gZmFjdCBhbiBhbGlhcyBmb3IgdGhlIGxhdHRlcixcbiAgICBidXQgdGhlIGFtYmlndWl0eSB3YXJuaW5nIGRvZXNuJ3QgY2FyZSlcbiopXG50eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2ID1cbiAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIFN0ZGxpYi5mb3JtYXQ2XG5cblxuKCogVGhlIHJ1bi10aW1lIGxpYnJhcnkgZm9yIHNjYW5uZXJzLiAqKVxuXG4oKiBTY2FubmluZyBidWZmZXJzLiAqKVxubW9kdWxlIHR5cGUgU0NBTk5JTkcgPSBzaWdcblxuICB0eXBlIGluX2NoYW5uZWxcblxuICB0eXBlIHNjYW5idWYgPSBpbl9jaGFubmVsXG5cbiAgdHlwZSBmaWxlX25hbWUgPSBzdHJpbmdcblxuICB2YWwgc3RkaW4gOiBpbl9jaGFubmVsXG4gICgqIFRoZSBzY2FubmluZyBidWZmZXIgcmVhZGluZyBmcm9tIFtTdGRsaWIuc3RkaW5dLlxuICAgICBbc3RkaWJdIGlzIGVxdWl2YWxlbnQgdG8gW1NjYW5uaW5nLmZyb21fY2hhbm5lbCBTdGRsaWIuc3RkaW5dLiAqKVxuXG4gIHZhbCBzdGRpYiA6IGluX2NoYW5uZWxcbiAgKCogQW4gYWxpYXMgZm9yIFtTY2FuZi5zdGRpbl0sIHRoZSBzY2FubmluZyBidWZmZXIgcmVhZGluZyBmcm9tXG4gICAgIFtTdGRsaWIuc3RkaW5dLiAqKVxuXG4gIHZhbCBuZXh0X2NoYXIgOiBzY2FuYnVmIC0+IGNoYXJcbiAgKCogW1NjYW5uaW5nLm5leHRfY2hhciBpYl0gYWR2YW5jZSB0aGUgc2Nhbm5pbmcgYnVmZmVyIGZvclxuICAgICBvbmUgY2hhcmFjdGVyLlxuICAgICBJZiBubyBtb3JlIGNoYXJhY3RlciBjYW4gYmUgcmVhZCwgc2V0cyBhIGVuZCBvZiBmaWxlIGNvbmRpdGlvbiBhbmRcbiAgICAgcmV0dXJucyAnXFwwMDAnLiAqKVxuXG4gIHZhbCBpbnZhbGlkYXRlX2N1cnJlbnRfY2hhciA6IHNjYW5idWYgLT4gdW5pdFxuICAoKiBbU2Nhbm5pbmcuaW52YWxpZGF0ZV9jdXJyZW50X2NoYXIgaWJdIG1hcmsgdGhlIGN1cnJlbnRfY2hhciBhcyBhbHJlYWR5XG4gICAgIHNjYW5uZWQuICopXG5cbiAgdmFsIHBlZWtfY2hhciA6IHNjYW5idWYgLT4gY2hhclxuICAoKiBbU2Nhbm5pbmcucGVla19jaGFyIGliXSByZXR1cm5zIHRoZSBjdXJyZW50IGNoYXIgYXZhaWxhYmxlIGluXG4gICAgIHRoZSBidWZmZXIgb3IgcmVhZHMgb25lIGlmIG5lY2Vzc2FyeSAod2hlbiB0aGUgY3VycmVudCBjaGFyYWN0ZXIgaXNcbiAgICAgYWxyZWFkeSBzY2FubmVkKS5cbiAgICAgSWYgbm8gY2hhcmFjdGVyIGNhbiBiZSByZWFkLCBzZXRzIGFuIGVuZCBvZiBmaWxlIGNvbmRpdGlvbiBhbmRcbiAgICAgcmV0dXJucyAnXFwwMDAnLiAqKVxuXG4gIHZhbCBjaGVja2VkX3BlZWtfY2hhciA6IHNjYW5idWYgLT4gY2hhclxuICAoKiBTYW1lIGFzIFtTY2FubmluZy5wZWVrX2NoYXJdIGFib3ZlIGJ1dCBhbHdheXMgcmV0dXJucyBhIHZhbGlkIGNoYXIgb3JcbiAgICAgZmFpbHM6IGluc3RlYWQgb2YgcmV0dXJuaW5nIGEgbnVsbCBjaGFyIHdoZW4gdGhlIHJlYWRpbmcgbWV0aG9kIG9mIHRoZVxuICAgICBpbnB1dCBidWZmZXIgaGFzIHJlYWNoZWQgYW4gZW5kIG9mIGZpbGUsIHRoZSBmdW5jdGlvbiByYWlzZXMgZXhjZXB0aW9uXG4gICAgIFtFbmRfb2ZfZmlsZV0uICopXG5cbiAgdmFsIHN0b3JlX2NoYXIgOiBpbnQgLT4gc2NhbmJ1ZiAtPiBjaGFyIC0+IGludFxuICAoKiBbU2Nhbm5pbmcuc3RvcmVfY2hhciBsaW0gaWIgY10gYWRkcyBbY10gdG8gdGhlIHRva2VuIGJ1ZmZlclxuICAgICBvZiB0aGUgc2Nhbm5pbmcgYnVmZmVyIFtpYl0uIEl0IGFsc28gYWR2YW5jZXMgdGhlIHNjYW5uaW5nIGJ1ZmZlciBmb3JcbiAgICAgb25lIGNoYXJhY3RlciBhbmQgcmV0dXJucyBbbGltIC0gMV0sIGluZGljYXRpbmcgdGhlIG5ldyBsaW1pdCBmb3IgdGhlXG4gICAgIGxlbmd0aCBvZiB0aGUgY3VycmVudCB0b2tlbi4gKilcblxuICB2YWwgc2tpcF9jaGFyIDogaW50IC0+IHNjYW5idWYgLT4gaW50XG4gICgqIFtTY2FubmluZy5za2lwX2NoYXIgbGltIGliXSBpZ25vcmVzIHRoZSBjdXJyZW50IGNoYXJhY3Rlci4gKilcblxuICB2YWwgaWdub3JlX2NoYXIgOiBpbnQgLT4gc2NhbmJ1ZiAtPiBpbnRcbiAgKCogW1NjYW5uaW5nLmlnbm9yZV9jaGFyIGliIGxpbV0gaWdub3JlcyB0aGUgY3VycmVudCBjaGFyYWN0ZXIgYW5kXG4gICAgIGRlY3JlbWVudHMgdGhlIGxpbWl0LiAqKVxuXG4gIHZhbCB0b2tlbiA6IHNjYW5idWYgLT4gc3RyaW5nXG4gICgqIFtTY2FubmluZy50b2tlbiBpYl0gcmV0dXJucyB0aGUgc3RyaW5nIHN0b3JlZCBpbnRvIHRoZSB0b2tlblxuICAgICBidWZmZXIgb2YgdGhlIHNjYW5uaW5nIGJ1ZmZlcjogaXQgcmV0dXJucyB0aGUgdG9rZW4gbWF0Y2hlZCBieSB0aGVcbiAgICAgZm9ybWF0LiAqKVxuXG4gIHZhbCByZXNldF90b2tlbiA6IHNjYW5idWYgLT4gdW5pdFxuICAoKiBbU2Nhbm5pbmcucmVzZXRfdG9rZW4gaWJdIHJlc2V0cyB0aGUgdG9rZW4gYnVmZmVyIG9mXG4gICAgIHRoZSBnaXZlbiBzY2FubmluZyBidWZmZXIuICopXG5cbiAgdmFsIGNoYXJfY291bnQgOiBzY2FuYnVmIC0+IGludFxuICAoKiBbU2Nhbm5pbmcuY2hhcl9jb3VudCBpYl0gcmV0dXJucyB0aGUgbnVtYmVyIG9mIGNoYXJhY3RlcnNcbiAgICAgcmVhZCBzbyBmYXIgZnJvbSB0aGUgZ2l2ZW4gYnVmZmVyLiAqKVxuXG4gIHZhbCBsaW5lX2NvdW50IDogc2NhbmJ1ZiAtPiBpbnRcbiAgKCogW1NjYW5uaW5nLmxpbmVfY291bnQgaWJdIHJldHVybnMgdGhlIG51bWJlciBvZiBuZXcgbGluZVxuICAgICBjaGFyYWN0ZXJzIHJlYWQgc28gZmFyIGZyb20gdGhlIGdpdmVuIGJ1ZmZlci4gKilcblxuICB2YWwgdG9rZW5fY291bnQgOiBzY2FuYnVmIC0+IGludFxuICAoKiBbU2Nhbm5pbmcudG9rZW5fY291bnQgaWJdIHJldHVybnMgdGhlIG51bWJlciBvZiB0b2tlbnMgcmVhZFxuICAgICBzbyBmYXIgZnJvbSBbaWJdLiAqKVxuXG4gIHZhbCBlb2YgOiBzY2FuYnVmIC0+IGJvb2xcbiAgKCogW1NjYW5uaW5nLmVvZiBpYl0gcmV0dXJucyB0aGUgZW5kIG9mIGlucHV0IGNvbmRpdGlvblxuICAgICBvZiB0aGUgZ2l2ZW4gYnVmZmVyLiAqKVxuXG4gIHZhbCBlbmRfb2ZfaW5wdXQgOiBzY2FuYnVmIC0+IGJvb2xcbiAgKCogW1NjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYl0gdGVzdHMgdGhlIGVuZCBvZiBpbnB1dCBjb25kaXRpb25cbiAgICAgb2YgdGhlIGdpdmVuIGJ1ZmZlciAoaWYgbm8gY2hhciBoYXMgZXZlciBiZWVuIHJlYWQsIGFuIGF0dGVtcHQgdG9cbiAgICAgcmVhZCBvbmUgaXMgcGVyZm9ybWVkKS4gKilcblxuICB2YWwgYmVnaW5uaW5nX29mX2lucHV0IDogc2NhbmJ1ZiAtPiBib29sXG4gICgqIFtTY2FubmluZy5iZWdpbm5pbmdfb2ZfaW5wdXQgaWJdIHRlc3RzIHRoZSBiZWdpbm5pbmcgb2YgaW5wdXRcbiAgICAgY29uZGl0aW9uIG9mIHRoZSBnaXZlbiBidWZmZXIuICopXG5cbiAgdmFsIG5hbWVfb2ZfaW5wdXQgOiBzY2FuYnVmIC0+IHN0cmluZ1xuICAoKiBbU2Nhbm5pbmcubmFtZV9vZl9pbnB1dCBpYl0gcmV0dXJucyB0aGUgbmFtZSBvZiB0aGUgY2hhcmFjdGVyXG4gICAgIHNvdXJjZSBmb3IgaW5wdXQgYnVmZmVyIFtpYl0uICopXG5cbiAgdmFsIG9wZW5faW4gOiBmaWxlX25hbWUgLT4gaW5fY2hhbm5lbFxuICB2YWwgb3Blbl9pbl9iaW4gOiBmaWxlX25hbWUgLT4gaW5fY2hhbm5lbFxuICB2YWwgZnJvbV9maWxlIDogZmlsZV9uYW1lIC0+IGluX2NoYW5uZWxcbiAgdmFsIGZyb21fZmlsZV9iaW4gOiBmaWxlX25hbWUgLT4gaW5fY2hhbm5lbFxuICB2YWwgZnJvbV9zdHJpbmcgOiBzdHJpbmcgLT4gaW5fY2hhbm5lbFxuICB2YWwgZnJvbV9mdW5jdGlvbiA6ICh1bml0IC0+IGNoYXIpIC0+IGluX2NoYW5uZWxcbiAgdmFsIGZyb21fY2hhbm5lbCA6IFN0ZGxpYi5pbl9jaGFubmVsIC0+IGluX2NoYW5uZWxcblxuICB2YWwgY2xvc2VfaW4gOiBpbl9jaGFubmVsIC0+IHVuaXRcblxuICB2YWwgbWVtb19mcm9tX2NoYW5uZWwgOiBTdGRsaWIuaW5fY2hhbm5lbCAtPiBpbl9jaGFubmVsXG4gICgqIE9ic29sZXRlLiAqKVxuXG5lbmRcblxuXG5tb2R1bGUgU2Nhbm5pbmcgOiBTQ0FOTklORyA9IHN0cnVjdFxuXG4gICgqIFRoZSBydW4tdGltZSBsaWJyYXJ5IGZvciBzY2FuZi4gKilcblxuICB0eXBlIGZpbGVfbmFtZSA9IHN0cmluZ1xuXG4gIHR5cGUgaW5fY2hhbm5lbF9uYW1lID1cbiAgICB8IEZyb21fY2hhbm5lbCBvZiBTdGRsaWIuaW5fY2hhbm5lbFxuICAgIHwgRnJvbV9maWxlIG9mIGZpbGVfbmFtZSAqIFN0ZGxpYi5pbl9jaGFubmVsXG4gICAgfCBGcm9tX2Z1bmN0aW9uXG4gICAgfCBGcm9tX3N0cmluZ1xuXG5cbiAgdHlwZSBpbl9jaGFubmVsID0ge1xuICAgIG11dGFibGUgaWNfZW9mIDogYm9vbDtcbiAgICBtdXRhYmxlIGljX2N1cnJlbnRfY2hhciA6IGNoYXI7XG4gICAgbXV0YWJsZSBpY19jdXJyZW50X2NoYXJfaXNfdmFsaWQgOiBib29sO1xuICAgIG11dGFibGUgaWNfY2hhcl9jb3VudCA6IGludDtcbiAgICBtdXRhYmxlIGljX2xpbmVfY291bnQgOiBpbnQ7XG4gICAgbXV0YWJsZSBpY190b2tlbl9jb3VudCA6IGludDtcbiAgICBpY19nZXRfbmV4dF9jaGFyIDogdW5pdCAtPiBjaGFyO1xuICAgIGljX3Rva2VuX2J1ZmZlciA6IEJ1ZmZlci50O1xuICAgIGljX2lucHV0X25hbWUgOiBpbl9jaGFubmVsX25hbWU7XG4gIH1cblxuXG4gIHR5cGUgc2NhbmJ1ZiA9IGluX2NoYW5uZWxcblxuICBsZXQgbnVsbF9jaGFyID0gJ1xcMDAwJ1xuXG4gICgqIFJlYWRzIGEgbmV3IGNoYXJhY3RlciBmcm9tIGlucHV0IGJ1ZmZlci5cbiAgICAgTmV4dF9jaGFyIG5ldmVyIGZhaWxzLCBldmVuIGluIGNhc2Ugb2YgZW5kIG9mIGlucHV0OlxuICAgICBpdCB0aGVuIHNpbXBseSBzZXRzIHRoZSBlbmQgb2YgZmlsZSBjb25kaXRpb24uICopXG4gIGxldCBuZXh0X2NoYXIgaWIgPVxuICAgIHRyeVxuICAgICAgbGV0IGMgPSBpYi5pY19nZXRfbmV4dF9jaGFyICgpIGluXG4gICAgICBpYi5pY19jdXJyZW50X2NoYXIgPC0gYztcbiAgICAgIGliLmljX2N1cnJlbnRfY2hhcl9pc192YWxpZCA8LSB0cnVlO1xuICAgICAgaWIuaWNfY2hhcl9jb3VudCA8LSBzdWNjIGliLmljX2NoYXJfY291bnQ7XG4gICAgICBpZiBjID0gJ1xcbicgdGhlbiBpYi5pY19saW5lX2NvdW50IDwtIHN1Y2MgaWIuaWNfbGluZV9jb3VudDtcbiAgICAgIGMgd2l0aFxuICAgIHwgRW5kX29mX2ZpbGUgLT5cbiAgICAgIGxldCBjID0gbnVsbF9jaGFyIGluXG4gICAgICBpYi5pY19jdXJyZW50X2NoYXIgPC0gYztcbiAgICAgIGliLmljX2N1cnJlbnRfY2hhcl9pc192YWxpZCA8LSBmYWxzZTtcbiAgICAgIGliLmljX2VvZiA8LSB0cnVlO1xuICAgICAgY1xuXG5cbiAgbGV0IHBlZWtfY2hhciBpYiA9XG4gICAgaWYgaWIuaWNfY3VycmVudF9jaGFyX2lzX3ZhbGlkXG4gICAgdGhlbiBpYi5pY19jdXJyZW50X2NoYXJcbiAgICBlbHNlIG5leHRfY2hhciBpYlxuXG5cbiAgKCogUmV0dXJucyBhIHZhbGlkIGN1cnJlbnQgY2hhciBmb3IgdGhlIGlucHV0IGJ1ZmZlci4gSW4gcGFydGljdWxhclxuICAgICBubyBpcnJlbGV2YW50IG51bGwgY2hhcmFjdGVyIChhcyBzZXQgYnkgW25leHRfY2hhcl0gaW4gY2FzZSBvZiBlbmRcbiAgICAgb2YgaW5wdXQpIGlzIHJldHVybmVkLCBzaW5jZSBbRW5kX29mX2ZpbGVdIGlzIHJhaXNlZCB3aGVuXG4gICAgIFtuZXh0X2NoYXJdIHNldHMgdGhlIGVuZCBvZiBmaWxlIGNvbmRpdGlvbiB3aGlsZSB0cnlpbmcgdG8gcmVhZCBhXG4gICAgIG5ldyBjaGFyYWN0ZXIuICopXG4gIGxldCBjaGVja2VkX3BlZWtfY2hhciBpYiA9XG4gICAgbGV0IGMgPSBwZWVrX2NoYXIgaWIgaW5cbiAgICBpZiBpYi5pY19lb2YgdGhlbiByYWlzZSBFbmRfb2ZfZmlsZTtcbiAgICBjXG5cblxuICBsZXQgZW5kX29mX2lucHV0IGliID1cbiAgICBpZ25vcmUgKHBlZWtfY2hhciBpYik7XG4gICAgaWIuaWNfZW9mXG5cblxuICBsZXQgZW9mIGliID0gaWIuaWNfZW9mXG5cbiAgbGV0IGJlZ2lubmluZ19vZl9pbnB1dCBpYiA9IGliLmljX2NoYXJfY291bnQgPSAwXG5cbiAgbGV0IG5hbWVfb2ZfaW5wdXQgaWIgPVxuICAgIG1hdGNoIGliLmljX2lucHV0X25hbWUgd2l0aFxuICAgIHwgRnJvbV9jaGFubmVsIF9pYyAtPiBcInVubmFtZWQgU3RkbGliIGlucHV0IGNoYW5uZWxcIlxuICAgIHwgRnJvbV9maWxlIChmbmFtZSwgX2ljKSAtPiBmbmFtZVxuICAgIHwgRnJvbV9mdW5jdGlvbiAtPiBcInVubmFtZWQgZnVuY3Rpb25cIlxuICAgIHwgRnJvbV9zdHJpbmcgLT4gXCJ1bm5hbWVkIGNoYXJhY3RlciBzdHJpbmdcIlxuXG5cbiAgbGV0IGNoYXJfY291bnQgaWIgPVxuICAgIGlmIGliLmljX2N1cnJlbnRfY2hhcl9pc192YWxpZFxuICAgIHRoZW4gaWIuaWNfY2hhcl9jb3VudCAtIDFcbiAgICBlbHNlIGliLmljX2NoYXJfY291bnRcblxuXG4gIGxldCBsaW5lX2NvdW50IGliID0gaWIuaWNfbGluZV9jb3VudFxuXG4gIGxldCByZXNldF90b2tlbiBpYiA9IEJ1ZmZlci5yZXNldCBpYi5pY190b2tlbl9idWZmZXJcblxuICBsZXQgaW52YWxpZGF0ZV9jdXJyZW50X2NoYXIgaWIgPSBpYi5pY19jdXJyZW50X2NoYXJfaXNfdmFsaWQgPC0gZmFsc2VcblxuICBsZXQgdG9rZW4gaWIgPVxuICAgIGxldCB0b2tlbl9idWZmZXIgPSBpYi5pY190b2tlbl9idWZmZXIgaW5cbiAgICBsZXQgdG9rID0gQnVmZmVyLmNvbnRlbnRzIHRva2VuX2J1ZmZlciBpblxuICAgIEJ1ZmZlci5jbGVhciB0b2tlbl9idWZmZXI7XG4gICAgaWIuaWNfdG9rZW5fY291bnQgPC0gc3VjYyBpYi5pY190b2tlbl9jb3VudDtcbiAgICB0b2tcblxuXG4gIGxldCB0b2tlbl9jb3VudCBpYiA9IGliLmljX3Rva2VuX2NvdW50XG5cbiAgbGV0IHNraXBfY2hhciB3aWR0aCBpYiA9XG4gICAgaW52YWxpZGF0ZV9jdXJyZW50X2NoYXIgaWI7XG4gICAgd2lkdGhcblxuXG4gIGxldCBpZ25vcmVfY2hhciB3aWR0aCBpYiA9IHNraXBfY2hhciAod2lkdGggLSAxKSBpYlxuXG4gIGxldCBzdG9yZV9jaGFyIHdpZHRoIGliIGMgPVxuICAgIEJ1ZmZlci5hZGRfY2hhciBpYi5pY190b2tlbl9idWZmZXIgYztcbiAgICBpZ25vcmVfY2hhciB3aWR0aCBpYlxuXG5cbiAgbGV0IGRlZmF1bHRfdG9rZW5fYnVmZmVyX3NpemUgPSAxMDI0XG5cbiAgbGV0IGNyZWF0ZSBpbmFtZSBuZXh0ID0ge1xuICAgIGljX2VvZiA9IGZhbHNlO1xuICAgIGljX2N1cnJlbnRfY2hhciA9IG51bGxfY2hhcjtcbiAgICBpY19jdXJyZW50X2NoYXJfaXNfdmFsaWQgPSBmYWxzZTtcbiAgICBpY19jaGFyX2NvdW50ID0gMDtcbiAgICBpY19saW5lX2NvdW50ID0gMDtcbiAgICBpY190b2tlbl9jb3VudCA9IDA7XG4gICAgaWNfZ2V0X25leHRfY2hhciA9IG5leHQ7XG4gICAgaWNfdG9rZW5fYnVmZmVyID0gQnVmZmVyLmNyZWF0ZSBkZWZhdWx0X3Rva2VuX2J1ZmZlcl9zaXplO1xuICAgIGljX2lucHV0X25hbWUgPSBpbmFtZTtcbiAgfVxuXG5cbiAgbGV0IGZyb21fc3RyaW5nIHMgPVxuICAgIGxldCBpID0gcmVmIDAgaW5cbiAgICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gICAgbGV0IG5leHQgKCkgPVxuICAgICAgaWYgIWkgPj0gbGVuIHRoZW4gcmFpc2UgRW5kX29mX2ZpbGUgZWxzZVxuICAgICAgbGV0IGMgPSBzLlshaV0gaW5cbiAgICAgIGluY3IgaTtcbiAgICAgIGMgaW5cbiAgICBjcmVhdGUgRnJvbV9zdHJpbmcgbmV4dFxuXG5cbiAgbGV0IGZyb21fZnVuY3Rpb24gPSBjcmVhdGUgRnJvbV9mdW5jdGlvblxuXG4gICgqIFNjYW5uaW5nIGZyb20gYW4gaW5wdXQgY2hhbm5lbC4gKilcblxuICAoKiBQb3NpdGlvbiBvZiB0aGUgcHJvYmxlbTpcblxuICAgICBXZSBjYW5ub3QgcHJldmVudCB0aGUgc2Nhbm5pbmcgbWVjaGFuaXNtIHRvIHVzZSBvbmUgbG9va2FoZWFkIGNoYXJhY3RlcixcbiAgICAgaWYgbmVlZGVkIGJ5IHRoZSBzZW1hbnRpY3Mgb2YgdGhlIGZvcm1hdCBzdHJpbmcgc3BlY2lmaWNhdGlvbnMgKGUuZy4gYVxuICAgICB0cmFpbGluZyAnc2tpcCBzcGFjZScgc3BlY2lmaWNhdGlvbiBpbiB0aGUgZm9ybWF0IHN0cmluZyk7IGluIHRoaXMgY2FzZSxcbiAgICAgdGhlIG1hbmRhdG9yeSBsb29rYWhlYWQgY2hhcmFjdGVyIGlzIGluZGVlZCByZWFkIGZyb20gdGhlIGlucHV0IGFuZCBub3RcbiAgICAgdXNlZCB0byByZXR1cm4gdGhlIHRva2VuIHJlYWQuIEl0IGlzIHRodXMgbWFuZGF0b3J5IHRvIGJlIGFibGUgdG8gc3RvcmVcbiAgICAgYW4gdW51c2VkIGxvb2thaGVhZCBjaGFyYWN0ZXIgc29tZXdoZXJlIHRvIGdldCBpdCBhcyB0aGUgZmlyc3QgY2hhcmFjdGVyXG4gICAgIG9mIHRoZSBuZXh0IHNjYW4uXG5cbiAgICAgVG8gY2lyY3VtdmVudCB0aGlzIHByb2JsZW0sIGFsbCB0aGUgc2Nhbm5pbmcgZnVuY3Rpb25zIGdldCBhIGxvdyBsZXZlbFxuICAgICBpbnB1dCBidWZmZXIgYXJndW1lbnQgd2hlcmUgdGhleSBzdG9yZSB0aGUgbG9va2FoZWFkIGNoYXJhY3RlciB3aGVuXG4gICAgIG5lZWRlZDsgYWRkaXRpb25hbGx5LCB0aGUgaW5wdXQgYnVmZmVyIGlzIHRoZSBvbmx5IHNvdXJjZSBvZiBjaGFyYWN0ZXIgb2ZcbiAgICAgYSBzY2FubmVyLiBUaGUgW3NjYW5idWZdIGlucHV0IGJ1ZmZlcnMgYXJlIGRlZmluZWQgaW4gbW9kdWxlIHshU2Nhbm5pbmd9LlxuXG4gICAgIE5vdyB3ZSB1bmRlcnN0YW5kIHRoYXQgaXQgaXMgZXh0cmVtZWx5IGltcG9ydGFudCB0aGF0IHJlbGF0ZWQgYW5kXG4gICAgIHN1Y2Nlc3NpdmUgY2FsbHMgdG8gc2Nhbm5lcnMgaW5kZWVkIHJlYWQgZnJvbSB0aGUgc2FtZSBpbnB1dCBidWZmZXIuXG4gICAgIEluIGVmZmVjdCwgaWYgYSBzY2FubmVyIFtzY2FuMV0gaXMgcmVhZGluZyBmcm9tIFtpYjFdIGFuZCBzdG9yZXMgYW5cbiAgICAgdW51c2VkIGxvb2thaGVhZCBjaGFyYWN0ZXIgW2MxXSBpbnRvIGl0cyBpbnB1dCBidWZmZXIgW2liMV0sIHRoZW5cbiAgICAgYW5vdGhlciBzY2FubmVyIFtzY2FuMl0gbm90IHJlYWRpbmcgZnJvbSB0aGUgc2FtZSBidWZmZXIgW2liMV0gd2lsbCBtaXNzXG4gICAgIHRoZSBjaGFyYWN0ZXIgW2MxXSwgc2VlbWluZ2x5IHZhbmlzaGVkIGluIHRoZSBhaXIgZnJvbSB0aGUgcG9pbnQgb2Ygdmlld1xuICAgICBvZiBbc2NhbjJdLlxuXG4gICAgIFRoaXMgbWVjaGFuaXNtIHdvcmtzIHBlcmZlY3RseSB0byByZWFkIGZyb20gc3RyaW5ncywgZnJvbSBmaWxlcywgYW5kIGZyb21cbiAgICAgZnVuY3Rpb25zLCBzaW5jZSBpbiB0aG9zZSBjYXNlcywgYWxsb2NhdGluZyB0d28gYnVmZmVycyByZWFkaW5nIGZyb20gdGhlXG4gICAgIHNhbWUgc291cmNlIGlzIHVubmF0dXJhbC5cblxuICAgICBTdGlsbCwgdGhlcmUgaXMgYSBkaWZmaWN1bHR5IGluIHRoZSBjYXNlIG9mIHNjYW5uaW5nIGZyb20gYW4gaW5wdXRcbiAgICAgY2hhbm5lbC4gSW4gZWZmZWN0LCB3aGVuIHNjYW5uaW5nIGZyb20gYW4gaW5wdXQgY2hhbm5lbCBbaWNdLCB0aGlzIGNoYW5uZWxcbiAgICAgbWF5IG5vdCBoYXZlIGJlZW4gYWxsb2NhdGVkIGZyb20gd2l0aGluIHRoaXMgbGlicmFyeS4gSGVuY2UsIGl0IG1heSBiZVxuICAgICBzaGFyZWQgKHR3byBmdW5jdGlvbnMgb2YgdGhlIHVzZXIncyBwcm9ncmFtIG1heSBzdWNjZXNzaXZlbHkgcmVhZCBmcm9tXG4gICAgIFtpY10pLiBUaGlzIGlzIGhpZ2hseSBlcnJvciBwcm9uZSBzaW5jZSwgb25lIG9mIHRoZSBmdW5jdGlvbiBtYXkgc2VlayB0aGVcbiAgICAgaW5wdXQgY2hhbm5lbCwgd2hpbGUgdGhlIG90aGVyIGZ1bmN0aW9uIGhhcyBzdGlsbCBhbiB1bnVzZWQgbG9va2FoZWFkXG4gICAgIGNoYXJhY3RlciBpbiBpdHMgaW5wdXQgYnVmZmVyLiBJbiBjb25jbHVzaW9uLCB5b3Ugc2hvdWxkIG5ldmVyIG1peCBkaXJlY3RcbiAgICAgbG93IGxldmVsIHJlYWRpbmcgYW5kIGhpZ2ggbGV2ZWwgc2Nhbm5pbmcgZnJvbSB0aGUgc2FtZSBpbnB1dCBjaGFubmVsLlxuXG4gICopXG5cbiAgKCogUGVyZm9ybSBidWZmZXJpemVkIGlucHV0IHRvIGltcHJvdmUgZWZmaWNpZW5jeS4gKilcbiAgbGV0IGZpbGVfYnVmZmVyX3NpemUgPSByZWYgMTAyNFxuXG4gICgqIFRoZSBzY2FubmVyIGNsb3NlcyB0aGUgaW5wdXQgY2hhbm5lbCBhdCBlbmQgb2YgaW5wdXQuICopXG4gIGxldCBzY2FuX2Nsb3NlX2F0X2VuZCBpYyA9IFN0ZGxpYi5jbG9zZV9pbiBpYzsgcmFpc2UgRW5kX29mX2ZpbGVcblxuICAoKiBUaGUgc2Nhbm5lciBkb2VzIG5vdCBjbG9zZSB0aGUgaW5wdXQgY2hhbm5lbCBhdCBlbmQgb2YgaW5wdXQ6XG4gICAgIGl0IGp1c3QgcmFpc2VzIFtFbmRfb2ZfZmlsZV0uICopXG4gIGxldCBzY2FuX3JhaXNlX2F0X2VuZCBfaWMgPSByYWlzZSBFbmRfb2ZfZmlsZVxuXG4gIGxldCBmcm9tX2ljIHNjYW5fY2xvc2VfaWMgaW5hbWUgaWMgPVxuICAgIGxldCBsZW4gPSAhZmlsZV9idWZmZXJfc2l6ZSBpblxuICAgIGxldCBidWYgPSBCeXRlcy5jcmVhdGUgbGVuIGluXG4gICAgbGV0IGkgPSByZWYgMCBpblxuICAgIGxldCBsaW0gPSByZWYgMCBpblxuICAgIGxldCBlb2YgPSByZWYgZmFsc2UgaW5cbiAgICBsZXQgbmV4dCAoKSA9XG4gICAgICBpZiAhaSA8ICFsaW0gdGhlbiBiZWdpbiBsZXQgYyA9IEJ5dGVzLmdldCBidWYgIWkgaW4gaW5jciBpOyBjIGVuZCBlbHNlXG4gICAgICBpZiAhZW9mIHRoZW4gcmFpc2UgRW5kX29mX2ZpbGUgZWxzZSBiZWdpblxuICAgICAgICBsaW0gOj0gaW5wdXQgaWMgYnVmIDAgbGVuO1xuICAgICAgICBpZiAhbGltID0gMCB0aGVuIGJlZ2luIGVvZiA6PSB0cnVlOyBzY2FuX2Nsb3NlX2ljIGljIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgICAgaSA6PSAxO1xuICAgICAgICAgIEJ5dGVzLmdldCBidWYgMFxuICAgICAgICBlbmRcbiAgICAgIGVuZCBpblxuICAgIGNyZWF0ZSBpbmFtZSBuZXh0XG5cblxuICBsZXQgZnJvbV9pY19jbG9zZV9hdF9lbmQgPSBmcm9tX2ljIHNjYW5fY2xvc2VfYXRfZW5kXG4gIGxldCBmcm9tX2ljX3JhaXNlX2F0X2VuZCA9IGZyb21faWMgc2Nhbl9yYWlzZV9hdF9lbmRcblxuICAoKiBUaGUgc2Nhbm5pbmcgYnVmZmVyIHJlYWRpbmcgZnJvbSBbU3RkbGliLnN0ZGluXS5cbiAgICAgT25lIGNvdWxkIHRyeSB0byBkZWZpbmUgW3N0ZGliXSBhcyBhIHNjYW5uaW5nIGJ1ZmZlciByZWFkaW5nIGEgY2hhcmFjdGVyXG4gICAgIGF0IGEgdGltZSAobm8gYnVmZmVyaXphdGlvbiBhdCBhbGwpLCBidXQgdW5mb3J0dW5hdGVseSB0aGUgdG9wLWxldmVsXG4gICAgIGludGVyYWN0aW9uIHdvdWxkIGJlIHdyb25nLiBUaGlzIGlzIGR1ZSB0byBzb21lIGtpbmQgb2ZcbiAgICAgJ3JhY2UgY29uZGl0aW9uJyB3aGVuIHJlYWRpbmcgZnJvbSBbU3RkbGliLnN0ZGluXSxcbiAgICAgc2luY2UgdGhlIGludGVyYWN0aXZlIGNvbXBpbGVyIGFuZCBbU2NhbmYuc2NhbmZdIHdpbGwgc2ltdWx0YW5lb3VzbHlcbiAgICAgcmVhZCB0aGUgbWF0ZXJpYWwgdGhleSBuZWVkIGZyb20gW1N0ZGxpYi5zdGRpbl07IHRoZW4sIGNvbmZ1c2lvblxuICAgICB3aWxsIHJlc3VsdCBmcm9tIHdoYXQgc2hvdWxkIGJlIHJlYWQgYnkgdGhlIHRvcC1sZXZlbCBhbmQgd2hhdCBzaG91bGQgYmVcbiAgICAgcmVhZCBieSBbU2NhbmYuc2NhbmZdLlxuICAgICBUaGlzIGlzIGV2ZW4gbW9yZSBjb21wbGljYXRlZCBieSB0aGUgb25lIGNoYXJhY3RlciBsb29rYWhlYWQgdGhhdFxuICAgICBbU2NhbmYuc2NhbmZdIGlzIHNvbWV0aW1lcyBvYmxpZ2VkIHRvIG1haW50YWluOiB0aGUgbG9va2FoZWFkIGNoYXJhY3RlclxuICAgICB3aWxsIGJlIGF2YWlsYWJsZSBmb3IgdGhlIG5leHQgW1NjYW5mLnNjYW5mXSBlbnRyeSwgc2VlbWluZ2x5IGNvbWluZyBmcm9tXG4gICAgIG5vd2hlcmUuXG4gICAgIEFsc28gbm8gW0VuZF9vZl9maWxlXSBpcyByYWlzZWQgd2hlbiByZWFkaW5nIGZyb20gc3RkaW46IGlmIG5vdCBlbm91Z2hcbiAgICAgY2hhcmFjdGVycyBoYXZlIGJlZW4gcmVhZCwgd2Ugc2ltcGx5IGFzayB0byByZWFkIG1vcmUuICopXG4gIGxldCBzdGRpbiA9XG4gICAgZnJvbV9pYyBzY2FuX3JhaXNlX2F0X2VuZFxuICAgICAgKEZyb21fZmlsZSAoXCItXCIsIFN0ZGxpYi5zdGRpbikpIFN0ZGxpYi5zdGRpblxuXG5cbiAgbGV0IHN0ZGliID0gc3RkaW5cblxuICBsZXQgb3Blbl9pbl9maWxlIG9wZW5faW4gZm5hbWUgPVxuICAgIG1hdGNoIGZuYW1lIHdpdGhcbiAgICB8IFwiLVwiIC0+IHN0ZGluXG4gICAgfCBmbmFtZSAtPlxuICAgICAgbGV0IGljID0gb3Blbl9pbiBmbmFtZSBpblxuICAgICAgZnJvbV9pY19jbG9zZV9hdF9lbmQgKEZyb21fZmlsZSAoZm5hbWUsIGljKSkgaWNcblxuXG4gIGxldCBvcGVuX2luID0gb3Blbl9pbl9maWxlIFN0ZGxpYi5vcGVuX2luXG4gIGxldCBvcGVuX2luX2JpbiA9IG9wZW5faW5fZmlsZSBTdGRsaWIub3Blbl9pbl9iaW5cblxuICBsZXQgZnJvbV9maWxlID0gb3Blbl9pblxuICBsZXQgZnJvbV9maWxlX2JpbiA9IG9wZW5faW5fYmluXG5cbiAgbGV0IGZyb21fY2hhbm5lbCBpYyA9XG4gICAgZnJvbV9pY19yYWlzZV9hdF9lbmQgKEZyb21fY2hhbm5lbCBpYykgaWNcblxuXG4gIGxldCBjbG9zZV9pbiBpYiA9XG4gICAgbWF0Y2ggaWIuaWNfaW5wdXRfbmFtZSB3aXRoXG4gICAgfCBGcm9tX2NoYW5uZWwgaWMgLT5cbiAgICAgIFN0ZGxpYi5jbG9zZV9pbiBpY1xuICAgIHwgRnJvbV9maWxlIChfZm5hbWUsIGljKSAtPiBTdGRsaWIuY2xvc2VfaW4gaWNcbiAgICB8IEZyb21fZnVuY3Rpb24gfCBGcm9tX3N0cmluZyAtPiAoKVxuXG5cbiAgKCpcbiAgICAgT2Jzb2xldGU6IGEgbWVtbyBbZnJvbV9jaGFubmVsXSB2ZXJzaW9uIHRvIGJ1aWxkIGEgW1NjYW5uaW5nLmluX2NoYW5uZWxdXG4gICAgIHNjYW5uaW5nIGJ1ZmZlciBvdXQgb2YgYSBbU3RkbGliLmluX2NoYW5uZWxdLlxuICAgICBUaGlzIGZ1bmN0aW9uIHdhcyB1c2VkIHRvIHRyeSB0byBwcmVzZXJ2ZSB0aGUgc2Nhbm5pbmdcbiAgICAgc2VtYW50aWNzIGZvciB0aGUgKG5vdyBvYnNvbGV0ZSkgZnVuY3Rpb24gW2ZzY2FuZl0uXG4gICAgIEdpdmVuIHRoYXQgYWxsIHNjYW5uZXIgbXVzdCByZWFkIGZyb20gYSBbU2Nhbm5pbmcuaW5fY2hhbm5lbF0gc2Nhbm5pbmdcbiAgICAgYnVmZmVyLCBbZnNjYW5mXSBtdXN0IHJlYWQgZnJvbSBvbmUhXG4gICAgIE1vcmUgcHJlY2lzZWx5LCBnaXZlbiBbaWNdLCBhbGwgc3VjY2Vzc2l2ZSBjYWxscyBbZnNjYW5mIGljXSBtdXN0IHJlYWRcbiAgICAgZnJvbSB0aGUgc2FtZSBzY2FubmluZyBidWZmZXIuXG4gICAgIFRoaXMgb2JsaWdlZCB0aGlzIGxpYnJhcnkgdG8gYWxsb2NhdGVkIHNjYW5uaW5nIGJ1ZmZlcnMgdGhhdCB3ZXJlXG4gICAgIG5vdCBwcm9wZXJseSBnYXJiYWdlIGNvbGxlY3RhYmxlLCBoZW5jZSBsZWFkaW5nIHRvIG1lbW9yeSBsZWFrcy5cbiAgICAgSWYgeW91IG5lZWQgdG8gcmVhZCBmcm9tIGEgW1N0ZGxpYi5pbl9jaGFubmVsXSBpbnB1dCBjaGFubmVsXG4gICAgIFtpY10sIHNpbXBseSBkZWZpbmUgYSBbU2Nhbm5pbmcuaW5fY2hhbm5lbF0gZm9ybWF0dGVkIGlucHV0IGNoYW5uZWwgYXMgaW5cbiAgICAgW2xldCBpYiA9IFNjYW5uaW5nLmZyb21fY2hhbm5lbCBpY10sIHRoZW4gdXNlIFtTY2FuZi5ic2NhbmYgaWJdIGFzIHVzdWFsLlxuICAqKVxuICBsZXQgbWVtb19mcm9tX2ljID1cbiAgICBsZXQgbWVtbyA9IHJlZiBbXSBpblxuICAgIChmdW4gc2Nhbl9jbG9zZV9pYyBpYyAtPlxuICAgICB0cnkgTGlzdC5hc3NxIGljICFtZW1vIHdpdGhcbiAgICAgfCBOb3RfZm91bmQgLT5cbiAgICAgICBsZXQgaWIgPVxuICAgICAgICAgZnJvbV9pYyBzY2FuX2Nsb3NlX2ljIChGcm9tX2NoYW5uZWwgaWMpIGljIGluXG4gICAgICAgbWVtbyA6PSAoaWMsIGliKSA6OiAhbWVtbztcbiAgICAgICBpYilcblxuXG4gICgqIE9ic29sZXRlOiBzZWUgeyFtZW1vX2Zyb21faWN9IGFib3ZlLiAqKVxuICBsZXQgbWVtb19mcm9tX2NoYW5uZWwgPSBtZW1vX2Zyb21faWMgc2Nhbl9yYWlzZV9hdF9lbmRcblxuZW5kXG5cblxuKCogRm9ybWF0dGVkIGlucHV0IGZ1bmN0aW9ucy4gKilcblxudHlwZSAoJ2EsICdiLCAnYywgJ2QpIHNjYW5uZXIgPVxuICAgICAoJ2EsIFNjYW5uaW5nLmluX2NoYW5uZWwsICdiLCAnYywgJ2EgLT4gJ2QsICdkKSBmb3JtYXQ2IC0+ICdjXG5cblxuKCogUmVwb3J0aW5nIGVycm9ycy4gKilcbmV4Y2VwdGlvbiBTY2FuX2ZhaWx1cmUgb2Ygc3RyaW5nXG5cbmxldCBiYWRfaW5wdXQgcyA9IHJhaXNlIChTY2FuX2ZhaWx1cmUgcylcblxubGV0IGJhZF9pbnB1dF9lc2NhcGUgYyA9XG4gIGJhZF9pbnB1dCAoUHJpbnRmLnNwcmludGYgXCJpbGxlZ2FsIGVzY2FwZSBjaGFyYWN0ZXIgJUNcIiBjKVxuXG5cbmxldCBiYWRfdG9rZW5fbGVuZ3RoIG1lc3NhZ2UgPVxuICBiYWRfaW5wdXRcbiAgICAoUHJpbnRmLnNwcmludGZcbiAgICAgICBcInNjYW5uaW5nIG9mICVzIGZhaWxlZDogXFxcbiAgICAgICAgdGhlIHNwZWNpZmllZCBsZW5ndGggd2FzIHRvbyBzaG9ydCBmb3IgdG9rZW5cIlxuICAgICAgIG1lc3NhZ2UpXG5cblxubGV0IGJhZF9lbmRfb2ZfaW5wdXQgbWVzc2FnZSA9XG4gIGJhZF9pbnB1dFxuICAgIChQcmludGYuc3ByaW50ZlxuICAgICAgIFwic2Nhbm5pbmcgb2YgJXMgZmFpbGVkOiBcXFxuICAgICAgICBwcmVtYXR1cmUgZW5kIG9mIGZpbGUgb2NjdXJyZWQgYmVmb3JlIGVuZCBvZiB0b2tlblwiXG4gICAgICAgbWVzc2FnZSlcblxuXG5sZXQgYmFkX2Zsb2F0ICgpID1cbiAgYmFkX2lucHV0IFwibm8gZG90IG9yIGV4cG9uZW50IHBhcnQgZm91bmQgaW4gZmxvYXQgdG9rZW5cIlxuXG5cbmxldCBiYWRfaGV4X2Zsb2F0ICgpID1cbiAgYmFkX2lucHV0IFwibm90IGEgdmFsaWQgZmxvYXQgaW4gaGV4YWRlY2ltYWwgbm90YXRpb25cIlxuXG5cbmxldCBjaGFyYWN0ZXJfbWlzbWF0Y2hfZXJyIGMgY2kgPVxuICBQcmludGYuc3ByaW50ZiBcImxvb2tpbmcgZm9yICVDLCBmb3VuZCAlQ1wiIGMgY2lcblxuXG5sZXQgY2hhcmFjdGVyX21pc21hdGNoIGMgY2kgPVxuICBiYWRfaW5wdXQgKGNoYXJhY3Rlcl9taXNtYXRjaF9lcnIgYyBjaSlcblxuXG5sZXQgcmVjIHNraXBfd2hpdGVzIGliID1cbiAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgaWYgbm90IChTY2FubmluZy5lb2YgaWIpIHRoZW4gYmVnaW5cbiAgICBtYXRjaCBjIHdpdGhcbiAgICB8ICcgJyB8ICdcXHQnIHwgJ1xcbicgfCAnXFxyJyAtPlxuICAgICAgU2Nhbm5pbmcuaW52YWxpZGF0ZV9jdXJyZW50X2NoYXIgaWI7IHNraXBfd2hpdGVzIGliXG4gICAgfCBfIC0+ICgpXG4gIGVuZFxuXG5cbigqIENoZWNraW5nIHRoYXQgW2NdIGlzIGluZGVlZCBpbiB0aGUgaW5wdXQsIHRoZW4gc2tpcHMgaXQuXG4gICBJbiB0aGlzIGNhc2UsIHRoZSBjaGFyYWN0ZXIgW2NdIGhhcyBiZWVuIGV4cGxpY2l0bHkgc3BlY2lmaWVkIGluIHRoZVxuICAgZm9ybWF0IGFzIGJlaW5nIG1hbmRhdG9yeSBpbiB0aGUgaW5wdXQ7IGhlbmNlIHdlIHNob3VsZCBmYWlsIHdpdGhcbiAgIFtFbmRfb2ZfZmlsZV0gaW4gY2FzZSBvZiBlbmRfb2ZfaW5wdXQuXG4gICAoUmVtZW1iZXIgdGhhdCBbU2Nhbl9mYWlsdXJlXSBpcyByYWlzZWQgb25seSB3aGVuICh3ZSBjYW4gcHJvdmUgYnlcbiAgIGV2aWRlbmNlKSB0aGF0IHRoZSBpbnB1dCBkb2VzIG5vdCBtYXRjaCB0aGUgZm9ybWF0IHN0cmluZyBnaXZlbi4gV2UgbXVzdFxuICAgdGh1cyBkaWZmZXJlbnRpYXRlIFtFbmRfb2ZfZmlsZV0gYXMgYW4gZXJyb3IgZHVlIHRvIGxhY2sgb2YgaW5wdXQsIGFuZFxuICAgW1NjYW5fZmFpbHVyZV0gd2hpY2ggaXMgZHVlIHRvIHByb3ZhYmx5IHdyb25nIGlucHV0LiBJIGFtIG5vdCBzdXJlIHRoaXMgaXNcbiAgIHdvcnRoIHRoZSBidXJkZW46IGl0IGlzIGNvbXBsZXggYW5kIHNvbWVob3cgc3VibGltaW5hbDsgc2hvdWxkIGJlIGNsZWFyZXJcbiAgIHRvIGZhaWwgd2l0aCBTY2FuX2ZhaWx1cmUgXCJOb3QgZW5vdWdoIGlucHV0IHRvIGNvbXBsZXRlIHNjYW5uaW5nXCIhKVxuXG4gICBUaGF0J3Mgd2h5LCB3YWl0aW5nIGZvciBhIGJldHRlciBzb2x1dGlvbiwgd2UgdXNlIGNoZWNrZWRfcGVla19jaGFyIGhlcmUuXG4gICBXZSBhcmUgYWxzbyBjYXJlZnVsIHRvIHRyZWF0IFwiXFxyXFxuXCIgaW4gdGhlIGlucHV0IGFzIGFuIGVuZCBvZiBsaW5lIG1hcmtlcjpcbiAgIGl0IGFsd2F5cyBtYXRjaGVzIGEgJ1xcbicgc3BlY2lmaWNhdGlvbiBpbiB0aGUgaW5wdXQgZm9ybWF0IHN0cmluZy4gKilcbmxldCByZWMgY2hlY2tfY2hhciBpYiBjID1cbiAgbWF0Y2ggYyB3aXRoXG4gIHwgJyAnIC0+IHNraXBfd2hpdGVzIGliXG4gIHwgJ1xcbicgLT4gY2hlY2tfbmV3bGluZSBpYlxuICB8IGMgLT4gY2hlY2tfdGhpc19jaGFyIGliIGNcblxuYW5kIGNoZWNrX3RoaXNfY2hhciBpYiBjID1cbiAgbGV0IGNpID0gU2Nhbm5pbmcuY2hlY2tlZF9wZWVrX2NoYXIgaWIgaW5cbiAgaWYgY2kgPSBjIHRoZW4gU2Nhbm5pbmcuaW52YWxpZGF0ZV9jdXJyZW50X2NoYXIgaWIgZWxzZVxuICBjaGFyYWN0ZXJfbWlzbWF0Y2ggYyBjaVxuXG5hbmQgY2hlY2tfbmV3bGluZSBpYiA9XG4gIGxldCBjaSA9IFNjYW5uaW5nLmNoZWNrZWRfcGVla19jaGFyIGliIGluXG4gIG1hdGNoIGNpIHdpdGhcbiAgfCAnXFxuJyAtPiBTY2FubmluZy5pbnZhbGlkYXRlX2N1cnJlbnRfY2hhciBpYlxuICB8ICdcXHInIC0+IFNjYW5uaW5nLmludmFsaWRhdGVfY3VycmVudF9jaGFyIGliOyBjaGVja190aGlzX2NoYXIgaWIgJ1xcbidcbiAgfCBfIC0+IGNoYXJhY3Rlcl9taXNtYXRjaCAnXFxuJyBjaVxuXG5cbigqIEV4dHJhY3RpbmcgdG9rZW5zIGZyb20gdGhlIG91dHB1dCB0b2tlbiBidWZmZXIuICopXG5cbmxldCB0b2tlbl9jaGFyIGliID0gKFNjYW5uaW5nLnRva2VuIGliKS5bMF1cblxubGV0IHRva2VuX3N0cmluZyA9IFNjYW5uaW5nLnRva2VuXG5cbmxldCB0b2tlbl9ib29sIGliID1cbiAgbWF0Y2ggU2Nhbm5pbmcudG9rZW4gaWIgd2l0aFxuICB8IFwidHJ1ZVwiIC0+IHRydWVcbiAgfCBcImZhbHNlXCIgLT4gZmFsc2VcbiAgfCBzIC0+IGJhZF9pbnB1dCAoUHJpbnRmLnNwcmludGYgXCJpbnZhbGlkIGJvb2xlYW4gJyVzJ1wiIHMpXG5cblxuKCogVGhlIHR5cGUgb2YgaW50ZWdlciBjb252ZXJzaW9ucy4gKilcbnR5cGUgaW50ZWdlcl9jb252ZXJzaW9uID1cbiAgfCBCX2NvbnZlcnNpb24gKCogVW5zaWduZWQgYmluYXJ5IGNvbnZlcnNpb24gKilcbiAgfCBEX2NvbnZlcnNpb24gKCogU2lnbmVkIGRlY2ltYWwgY29udmVyc2lvbiAqKVxuICB8IElfY29udmVyc2lvbiAoKiBTaWduZWQgaW50ZWdlciBjb252ZXJzaW9uICopXG4gIHwgT19jb252ZXJzaW9uICgqIFVuc2lnbmVkIG9jdGFsIGNvbnZlcnNpb24gKilcbiAgfCBVX2NvbnZlcnNpb24gKCogVW5zaWduZWQgZGVjaW1hbCBjb252ZXJzaW9uICopXG4gIHwgWF9jb252ZXJzaW9uICgqIFVuc2lnbmVkIGhleGFkZWNpbWFsIGNvbnZlcnNpb24gKilcblxuXG5sZXQgaW50ZWdlcl9jb252ZXJzaW9uX29mX2NoYXIgPSBmdW5jdGlvblxuICB8ICdiJyAtPiBCX2NvbnZlcnNpb25cbiAgfCAnZCcgLT4gRF9jb252ZXJzaW9uXG4gIHwgJ2knIC0+IElfY29udmVyc2lvblxuICB8ICdvJyAtPiBPX2NvbnZlcnNpb25cbiAgfCAndScgLT4gVV9jb252ZXJzaW9uXG4gIHwgJ3gnIHwgJ1gnIC0+IFhfY29udmVyc2lvblxuICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG5cblxuKCogRXh0cmFjdCBhbiBpbnRlZ2VyIGxpdGVyYWwgdG9rZW4uXG4gICBTaW5jZSB0aGUgZnVuY3Rpb25zIFN0ZGxpYi4qaW50Kl9vZl9zdHJpbmcgZG8gbm90IGFjY2VwdCBhIGxlYWRpbmcgKyxcbiAgIHdlIHNraXAgaXQgaWYgbmVjZXNzYXJ5LiAqKVxubGV0IHRva2VuX2ludF9saXRlcmFsIGNvbnYgaWIgPVxuICBsZXQgdG9rID1cbiAgICBtYXRjaCBjb252IHdpdGhcbiAgICB8IERfY29udmVyc2lvbiB8IElfY29udmVyc2lvbiAtPiBTY2FubmluZy50b2tlbiBpYlxuICAgIHwgVV9jb252ZXJzaW9uIC0+IFwiMHVcIiBeIFNjYW5uaW5nLnRva2VuIGliXG4gICAgfCBPX2NvbnZlcnNpb24gLT4gXCIwb1wiIF4gU2Nhbm5pbmcudG9rZW4gaWJcbiAgICB8IFhfY29udmVyc2lvbiAtPiBcIjB4XCIgXiBTY2FubmluZy50b2tlbiBpYlxuICAgIHwgQl9jb252ZXJzaW9uIC0+IFwiMGJcIiBeIFNjYW5uaW5nLnRva2VuIGliIGluXG4gIGxldCBsID0gU3RyaW5nLmxlbmd0aCB0b2sgaW5cbiAgaWYgbCA9IDAgfHwgdG9rLlswXSA8PiAnKycgdGhlbiB0b2sgZWxzZSBTdHJpbmcuc3ViIHRvayAxIChsIC0gMSlcblxuXG4oKiBBbGwgdGhlIGZ1bmN0aW9ucyB0aGF0IGNvbnZlcnQgYSBzdHJpbmcgdG8gYSBudW1iZXIgcmFpc2UgdGhlIGV4Y2VwdGlvblxuICAgRmFpbHVyZSB3aGVuIHRoZSBjb252ZXJzaW9uIGlzIG5vdCBwb3NzaWJsZS5cbiAgIFRoaXMgZXhjZXB0aW9uIGlzIHRoZW4gdHJhcHBlZCBpbiBba3NjYW5mXS4gKilcbmxldCB0b2tlbl9pbnQgY29udiBpYiA9IGludF9vZl9zdHJpbmcgKHRva2VuX2ludF9saXRlcmFsIGNvbnYgaWIpXG5cbmxldCB0b2tlbl9mbG9hdCBpYiA9IGZsb2F0X29mX3N0cmluZyAoU2Nhbm5pbmcudG9rZW4gaWIpXG5cbigqIFRvIHNjYW4gbmF0aXZlIGludHMsIGludDMyIGFuZCBpbnQ2NCBpbnRlZ2Vycy5cbiAgIFdlIGNhbm5vdCBhY2Nlc3MgdG8gY29udmVyc2lvbnMgdG8vZnJvbSBzdHJpbmdzIGZvciB0aG9zZSB0eXBlcyxcbiAgIE5hdGl2ZWludC5vZl9zdHJpbmcsIEludDMyLm9mX3N0cmluZywgYW5kIEludDY0Lm9mX3N0cmluZyxcbiAgIHNpbmNlIHRob3NlIG1vZHVsZXMgYXJlIG5vdCBhdmFpbGFibGUgdG8gW1NjYW5mXS5cbiAgIEhvd2V2ZXIsIHdlIGNhbiBiaW5kIGFuZCB1c2UgdGhlIGNvcnJlc3BvbmRpbmcgcHJpbWl0aXZlcyB0aGF0IGFyZVxuICAgYXZhaWxhYmxlIGluIHRoZSBydW50aW1lLiAqKVxuZXh0ZXJuYWwgbmF0aXZlaW50X29mX3N0cmluZyA6IHN0cmluZyAtPiBuYXRpdmVpbnRcbiAgPSBcImNhbWxfbmF0aXZlaW50X29mX3N0cmluZ1wiXG5cbmV4dGVybmFsIGludDMyX29mX3N0cmluZyA6IHN0cmluZyAtPiBpbnQzMlxuICA9IFwiY2FtbF9pbnQzMl9vZl9zdHJpbmdcIlxuXG5leHRlcm5hbCBpbnQ2NF9vZl9zdHJpbmcgOiBzdHJpbmcgLT4gaW50NjRcbiAgPSBcImNhbWxfaW50NjRfb2Zfc3RyaW5nXCJcblxuXG5sZXQgdG9rZW5fbmF0aXZlaW50IGNvbnYgaWIgPSBuYXRpdmVpbnRfb2Zfc3RyaW5nICh0b2tlbl9pbnRfbGl0ZXJhbCBjb252IGliKVxubGV0IHRva2VuX2ludDMyIGNvbnYgaWIgPSBpbnQzMl9vZl9zdHJpbmcgKHRva2VuX2ludF9saXRlcmFsIGNvbnYgaWIpXG5sZXQgdG9rZW5faW50NjQgY29udiBpYiA9IGludDY0X29mX3N0cmluZyAodG9rZW5faW50X2xpdGVyYWwgY29udiBpYilcblxuKCogU2Nhbm5pbmcgbnVtYmVycy4gKilcblxuKCogRGlnaXRzIHNjYW5uaW5nIGZ1bmN0aW9ucyBzdXBwb3NlIHRoYXQgb25lIGNoYXJhY3RlciBoYXMgYmVlbiBjaGVja2VkIGFuZFxuICAgaXMgYXZhaWxhYmxlLCBzaW5jZSB0aGV5IHJldHVybiBhdCBlbmQgb2YgZmlsZSB3aXRoIHRoZSBjdXJyZW50bHkgZm91bmRcbiAgIHRva2VuIHNlbGVjdGVkLlxuXG4gICBQdXQgaXQgaW4gYW5vdGhlciB3YXksIHRoZSBkaWdpdHMgc2Nhbm5pbmcgZnVuY3Rpb25zIHNjYW4gZm9yIGEgcG9zc2libHlcbiAgIGVtcHR5IHNlcXVlbmNlIG9mIGRpZ2l0cywgKGhlbmNlLCBhIHN1Y2Nlc3NmdWwgc2Nhbm5pbmcgZnJvbSBvbmUgb2YgdGhvc2VcbiAgIGZ1bmN0aW9ucyBkb2VzIG5vdCBpbXBseSB0aGF0IHRoZSB0b2tlbiBpcyBhIHdlbGwtZm9ybWVkIG51bWJlcjogdG8gZ2V0IGFcbiAgIHRydWUgbnVtYmVyLCBpdCBpcyBtYW5kYXRvcnkgdG8gY2hlY2sgdGhhdCBhdCBsZWFzdCBvbmUgdmFsaWQgZGlnaXQgaXNcbiAgIGF2YWlsYWJsZSBiZWZvcmUgY2FsbGluZyBvbmUgb2YgdGhlIGRpZ2l0IHNjYW5uaW5nIGZ1bmN0aW9ucykuICopXG5cbigqIFRoZSBkZWNpbWFsIGNhc2UgaXMgdHJlYXRlZCBlc3BlY2lhbGx5IGZvciBvcHRpbWl6YXRpb24gcHVycG9zZXMuICopXG5sZXQgcmVjIHNjYW5fZGVjaW1hbF9kaWdpdF9zdGFyIHdpZHRoIGliID1cbiAgaWYgd2lkdGggPSAwIHRoZW4gd2lkdGggZWxzZVxuICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICBpZiBTY2FubmluZy5lb2YgaWIgdGhlbiB3aWR0aCBlbHNlXG4gIG1hdGNoIGMgd2l0aFxuICB8ICcwJyAuLiAnOScgYXMgYyAtPlxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgIHNjYW5fZGVjaW1hbF9kaWdpdF9zdGFyIHdpZHRoIGliXG4gIHwgJ18nIC0+XG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuaWdub3JlX2NoYXIgd2lkdGggaWIgaW5cbiAgICBzY2FuX2RlY2ltYWxfZGlnaXRfc3RhciB3aWR0aCBpYlxuICB8IF8gLT4gd2lkdGhcblxuXG5sZXQgc2Nhbl9kZWNpbWFsX2RpZ2l0X3BsdXMgd2lkdGggaWIgPVxuICBpZiB3aWR0aCA9IDAgdGhlbiBiYWRfdG9rZW5fbGVuZ3RoIFwiZGVjaW1hbCBkaWdpdHNcIiBlbHNlXG4gIGxldCBjID0gU2Nhbm5pbmcuY2hlY2tlZF9wZWVrX2NoYXIgaWIgaW5cbiAgbWF0Y2ggYyB3aXRoXG4gIHwgJzAnIC4uICc5JyAtPlxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgIHNjYW5fZGVjaW1hbF9kaWdpdF9zdGFyIHdpZHRoIGliXG4gIHwgYyAtPlxuICAgIGJhZF9pbnB1dCAoUHJpbnRmLnNwcmludGYgXCJjaGFyYWN0ZXIgJUMgaXMgbm90IGEgZGVjaW1hbCBkaWdpdFwiIGMpXG5cblxuKCogVG8gc2NhbiBudW1iZXJzIGZyb20gb3RoZXIgYmFzZXMsIHdlIHVzZSBhIHByZWRpY2F0ZSBhcmd1bWVudCB0b1xuICAgc2NhbiBkaWdpdHMuICopXG5sZXQgc2Nhbl9kaWdpdF9zdGFyIGRpZ2l0cCB3aWR0aCBpYiA9XG4gIGxldCByZWMgc2Nhbl9kaWdpdHMgd2lkdGggaWIgPVxuICAgIGlmIHdpZHRoID0gMCB0aGVuIHdpZHRoIGVsc2VcbiAgICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICAgIGlmIFNjYW5uaW5nLmVvZiBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgICBtYXRjaCBjIHdpdGhcbiAgICB8IGMgd2hlbiBkaWdpdHAgYyAtPlxuICAgICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgICBzY2FuX2RpZ2l0cyB3aWR0aCBpYlxuICAgIHwgJ18nIC0+XG4gICAgICBsZXQgd2lkdGggPSBTY2FubmluZy5pZ25vcmVfY2hhciB3aWR0aCBpYiBpblxuICAgICAgc2Nhbl9kaWdpdHMgd2lkdGggaWJcbiAgICB8IF8gLT4gd2lkdGggaW5cbiAgc2Nhbl9kaWdpdHMgd2lkdGggaWJcblxuXG5sZXQgc2Nhbl9kaWdpdF9wbHVzIGJhc2lzIGRpZ2l0cCB3aWR0aCBpYiA9XG4gICgqIEVuc3VyZSB3ZSBoYXZlIGdvdCBlbm91Z2ggd2lkdGggbGVmdCxcbiAgICAgYW5kIHJlYWQgYXQgbGVhc3Qgb25lIGRpZ2l0LiAqKVxuICBpZiB3aWR0aCA9IDAgdGhlbiBiYWRfdG9rZW5fbGVuZ3RoIFwiZGlnaXRzXCIgZWxzZVxuICBsZXQgYyA9IFNjYW5uaW5nLmNoZWNrZWRfcGVla19jaGFyIGliIGluXG4gIGlmIGRpZ2l0cCBjIHRoZW5cbiAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICBzY2FuX2RpZ2l0X3N0YXIgZGlnaXRwIHdpZHRoIGliXG4gIGVsc2VcbiAgICBiYWRfaW5wdXQgKFByaW50Zi5zcHJpbnRmIFwiY2hhcmFjdGVyICVDIGlzIG5vdCBhIHZhbGlkICVzIGRpZ2l0XCIgYyBiYXNpcylcblxuXG5sZXQgaXNfYmluYXJ5X2RpZ2l0ID0gZnVuY3Rpb25cbiAgfCAnMCcgLi4gJzEnIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG5cblxubGV0IHNjYW5fYmluYXJ5X2ludCA9IHNjYW5fZGlnaXRfcGx1cyBcImJpbmFyeVwiIGlzX2JpbmFyeV9kaWdpdFxuXG5sZXQgaXNfb2N0YWxfZGlnaXQgPSBmdW5jdGlvblxuICB8ICcwJyAuLiAnNycgLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2VcblxuXG5sZXQgc2Nhbl9vY3RhbF9pbnQgPSBzY2FuX2RpZ2l0X3BsdXMgXCJvY3RhbFwiIGlzX29jdGFsX2RpZ2l0XG5cbmxldCBpc19oZXhhX2RpZ2l0ID0gZnVuY3Rpb25cbiAgfCAnMCcgLi4gJzknIHwgJ2EnIC4uICdmJyB8ICdBJyAuLiAnRicgLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2VcblxuXG5sZXQgc2Nhbl9oZXhhZGVjaW1hbF9pbnQgPSBzY2FuX2RpZ2l0X3BsdXMgXCJoZXhhZGVjaW1hbFwiIGlzX2hleGFfZGlnaXRcblxuKCogU2NhbiBhIGRlY2ltYWwgaW50ZWdlci4gKilcbmxldCBzY2FuX3Vuc2lnbmVkX2RlY2ltYWxfaW50ID0gc2Nhbl9kZWNpbWFsX2RpZ2l0X3BsdXNcblxubGV0IHNjYW5fc2lnbiB3aWR0aCBpYiA9XG4gIGxldCBjID0gU2Nhbm5pbmcuY2hlY2tlZF9wZWVrX2NoYXIgaWIgaW5cbiAgbWF0Y2ggYyB3aXRoXG4gIHwgJysnIC0+IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgY1xuICB8ICctJyAtPiBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGNcbiAgfCBfIC0+IHdpZHRoXG5cblxubGV0IHNjYW5fb3B0aW9uYWxseV9zaWduZWRfZGVjaW1hbF9pbnQgd2lkdGggaWIgPVxuICBsZXQgd2lkdGggPSBzY2FuX3NpZ24gd2lkdGggaWIgaW5cbiAgc2Nhbl91bnNpZ25lZF9kZWNpbWFsX2ludCB3aWR0aCBpYlxuXG5cbigqIFNjYW4gYW4gdW5zaWduZWQgaW50ZWdlciB0aGF0IGNvdWxkIGJlIGdpdmVuIGluIGFueSAoY29tbW9uKSBiYXNpcy5cbiAgIElmIGRpZ2l0cyBhcmUgcHJlZml4ZWQgYnkgb25lIG9mIDB4LCAwWCwgMG8sIG9yIDBiLCB0aGUgbnVtYmVyIGlzXG4gICBhc3N1bWVkIHRvIGJlIHdyaXR0ZW4gcmVzcGVjdGl2ZWx5IGluIGhleGFkZWNpbWFsLCBoZXhhZGVjaW1hbCxcbiAgIG9jdGFsLCBvciBiaW5hcnkuICopXG5sZXQgc2Nhbl91bnNpZ25lZF9pbnQgd2lkdGggaWIgPVxuICBtYXRjaCBTY2FubmluZy5jaGVja2VkX3BlZWtfY2hhciBpYiB3aXRoXG4gIHwgJzAnIGFzIGMgLT5cbiAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICBpZiB3aWR0aCA9IDAgdGhlbiB3aWR0aCBlbHNlXG4gICAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgICBpZiBTY2FubmluZy5lb2YgaWIgdGhlbiB3aWR0aCBlbHNlXG4gICAgYmVnaW4gbWF0Y2ggYyB3aXRoXG4gICAgfCAneCcgfCAnWCcgLT4gc2Nhbl9oZXhhZGVjaW1hbF9pbnQgKFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYykgaWJcbiAgICB8ICdvJyAtPiBzY2FuX29jdGFsX2ludCAoU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjKSBpYlxuICAgIHwgJ2InIC0+IHNjYW5fYmluYXJ5X2ludCAoU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjKSBpYlxuICAgIHwgXyAtPiBzY2FuX2RlY2ltYWxfZGlnaXRfc3RhciB3aWR0aCBpYiBlbmRcbiAgfCBfIC0+IHNjYW5fdW5zaWduZWRfZGVjaW1hbF9pbnQgd2lkdGggaWJcblxuXG5sZXQgc2Nhbl9vcHRpb25hbGx5X3NpZ25lZF9pbnQgd2lkdGggaWIgPVxuICBsZXQgd2lkdGggPSBzY2FuX3NpZ24gd2lkdGggaWIgaW5cbiAgc2Nhbl91bnNpZ25lZF9pbnQgd2lkdGggaWJcblxuXG5sZXQgc2Nhbl9pbnRfY29udmVyc2lvbiBjb252IHdpZHRoIGliID1cbiAgbWF0Y2ggY29udiB3aXRoXG4gIHwgQl9jb252ZXJzaW9uIC0+IHNjYW5fYmluYXJ5X2ludCB3aWR0aCBpYlxuICB8IERfY29udmVyc2lvbiAtPiBzY2FuX29wdGlvbmFsbHlfc2lnbmVkX2RlY2ltYWxfaW50IHdpZHRoIGliXG4gIHwgSV9jb252ZXJzaW9uIC0+IHNjYW5fb3B0aW9uYWxseV9zaWduZWRfaW50IHdpZHRoIGliXG4gIHwgT19jb252ZXJzaW9uIC0+IHNjYW5fb2N0YWxfaW50IHdpZHRoIGliXG4gIHwgVV9jb252ZXJzaW9uIC0+IHNjYW5fdW5zaWduZWRfZGVjaW1hbF9pbnQgd2lkdGggaWJcbiAgfCBYX2NvbnZlcnNpb24gLT4gc2Nhbl9oZXhhZGVjaW1hbF9pbnQgd2lkdGggaWJcblxuXG4oKiBTY2FubmluZyBmbG9hdGluZyBwb2ludCBudW1iZXJzLiAqKVxuXG4oKiBGcmFjdGlvbmFsIHBhcnQgaXMgb3B0aW9uYWwgYW5kIGNhbiBiZSByZWR1Y2VkIHRvIDAgZGlnaXRzLiAqKVxubGV0IHNjYW5fZnJhY3Rpb25hbF9wYXJ0IHdpZHRoIGliID1cbiAgaWYgd2lkdGggPSAwIHRoZW4gd2lkdGggZWxzZVxuICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICBpZiBTY2FubmluZy5lb2YgaWIgdGhlbiB3aWR0aCBlbHNlXG4gIG1hdGNoIGMgd2l0aFxuICB8ICcwJyAuLiAnOScgYXMgYyAtPlxuICAgIHNjYW5fZGVjaW1hbF9kaWdpdF9zdGFyIChTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMpIGliXG4gIHwgXyAtPiB3aWR0aFxuXG5cbigqIEV4cCBwYXJ0IGlzIG9wdGlvbmFsIGFuZCBjYW4gYmUgcmVkdWNlZCB0byAwIGRpZ2l0cy4gKilcbmxldCBzY2FuX2V4cG9uZW50X3BhcnQgd2lkdGggaWIgPVxuICBpZiB3aWR0aCA9IDAgdGhlbiB3aWR0aCBlbHNlXG4gIGxldCBjID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gIGlmIFNjYW5uaW5nLmVvZiBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgbWF0Y2ggYyB3aXRoXG4gIHwgJ2UnIHwgJ0UnIGFzIGMgLT5cbiAgICBzY2FuX29wdGlvbmFsbHlfc2lnbmVkX2RlY2ltYWxfaW50IChTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMpIGliXG4gIHwgXyAtPiB3aWR0aFxuXG5cbigqIFNjYW4gdGhlIGludGVnZXIgcGFydCBvZiBhIGZsb2F0aW5nIHBvaW50IG51bWJlciwgKG5vdCB1c2luZyB0aGVcbiAgIE9DYW1sIGxleGljYWwgY29udmVudGlvbiBzaW5jZSB0aGUgaW50ZWdlciBwYXJ0IGNhbiBiZSBlbXB0eSk6XG4gICBhbiBvcHRpb25hbCBzaWduLCBmb2xsb3dlZCBieSBhIHBvc3NpYmx5IGVtcHR5IHNlcXVlbmNlIG9mIGRlY2ltYWxcbiAgIGRpZ2l0cyAoZS5nLiAtLjEpLiAqKVxubGV0IHNjYW5faW50ZWdlcl9wYXJ0IHdpZHRoIGliID1cbiAgbGV0IHdpZHRoID0gc2Nhbl9zaWduIHdpZHRoIGliIGluXG4gIHNjYW5fZGVjaW1hbF9kaWdpdF9zdGFyIHdpZHRoIGliXG5cblxuKCpcbiAgIEZvciB0aGUgdGltZSBiZWluZyB3ZSBoYXZlIChhcyBmb3VuZCBpbiBzY2FuZi5tbGkpOlxuICAgdGhlIGZpZWxkIHdpZHRoIGlzIGNvbXBvc2VkIG9mIGFuIG9wdGlvbmFsIGludGVnZXIgbGl0ZXJhbFxuICAgaW5kaWNhdGluZyB0aGUgbWF4aW1hbCB3aWR0aCBvZiB0aGUgdG9rZW4gdG8gcmVhZC5cbiAgIFVuZm9ydHVuYXRlbHksIHRoZSB0eXBlLWNoZWNrZXIgbGV0IHRoZSB1c2VyIHdyaXRlIGFuIG9wdGlvbmFsIHByZWNpc2lvbixcbiAgIHNpbmNlIHRoaXMgaXMgdmFsaWQgZm9yIHByaW50ZiBmb3JtYXQgc3RyaW5ncy5cblxuICAgVGh1cywgdGhlIG5leHQgc3RlcCBmb3IgU2NhbmYgaXMgdG8gc3VwcG9ydCBhIGZ1bGwgd2lkdGggYW5kIHByZWNpc2lvblxuICAgaW5kaWNhdGlvbiwgbW9yZSBvciBsZXNzIHNpbWlsYXIgdG8gdGhlIG9uZSBmb3IgcHJpbnRmLCBwb3NzaWJseSBleHRlbmRlZFxuICAgdG8gdGhlIHNwZWNpZmljYXRpb24gb2YgYSBbbWF4LCBtaW5dIHJhbmdlIGZvciB0aGUgd2lkdGggb2YgdGhlIHRva2VuIHJlYWRcbiAgIGZvciBzdHJpbmdzLiBTb21ldGhpbmcgbGlrZSB0aGUgZm9sbG93aW5nIHNwZWMgZm9yIHNjYW5mLm1saTpcblxuICAgVGhlIG9wdGlvbmFsIFt3aWR0aF0gaXMgYW4gaW50ZWdlciBpbmRpY2F0aW5nIHRoZSBtYXhpbWFsXG4gICB3aWR0aCBvZiB0aGUgdG9rZW4gcmVhZC4gRm9yIGluc3RhbmNlLCBbJTZkXSByZWFkcyBhbiBpbnRlZ2VyLFxuICAgaGF2aW5nIGF0IG1vc3QgNiBjaGFyYWN0ZXJzLlxuXG4gICBUaGUgb3B0aW9uYWwgW3ByZWNpc2lvbl0gaXMgYSBkb3QgWy5dIGZvbGxvd2VkIGJ5IGFuIGludGVnZXI6XG5cbiAgIC0gaW4gdGhlIGZsb2F0aW5nIHBvaW50IG51bWJlciBjb252ZXJzaW9ucyAoWyVmXSwgWyVlXSwgWyVnXSwgWyVGXSwgWyVFXSxcbiAgIGFuZCBbJUZdIGNvbnZlcnNpb25zLCB0aGUgW3ByZWNpc2lvbl0gaW5kaWNhdGVzIHRoZSBtYXhpbXVtIG51bWJlciBvZlxuICAgZGlnaXRzIHRoYXQgbWF5IGZvbGxvdyB0aGUgZGVjaW1hbCBwb2ludC4gRm9yIGluc3RhbmNlLCBbJS40Zl0gcmVhZHMgYVxuICAgW2Zsb2F0XSB3aXRoIGF0IG1vc3QgNCBmcmFjdGlvbmFsIGRpZ2l0cyxcblxuICAgLSBpbiB0aGUgc3RyaW5nIGNvbnZlcnNpb25zIChbJXNdLCBbJVNdLCBbJVxcWyByYW5nZSBcXF1dKSwgYW5kIGluIHRoZVxuICAgaW50ZWdlciBudW1iZXIgY29udmVyc2lvbnMgKFslaV0sIFslZF0sIFsldV0sIFsleF0sIFslb10sIGFuZCB0aGVpclxuICAgW2ludDMyXSwgW2ludDY0XSwgYW5kIFtuYXRpdmVfaW50XSBjb3JyZXNwb25kZW50KSwgdGhlIFtwcmVjaXNpb25dXG4gICBpbmRpY2F0ZXMgdGhlIHJlcXVpcmVkIG1pbmltdW0gd2lkdGggb2YgdGhlIHRva2VuIHJlYWQsXG5cbiAgIC0gb24gYWxsIG90aGVyIGNvbnZlcnNpb25zLCB0aGUgd2lkdGggYW5kIHByZWNpc2lvbiBzcGVjaWZ5IHRoZSBbbWF4LCBtaW5dXG4gICByYW5nZSBmb3IgdGhlIHdpZHRoIG9mIHRoZSB0b2tlbiByZWFkLlxuKilcbmxldCBzY2FuX2Zsb2F0IHdpZHRoIHByZWNpc2lvbiBpYiA9XG4gIGxldCB3aWR0aCA9IHNjYW5faW50ZWdlcl9wYXJ0IHdpZHRoIGliIGluXG4gIGlmIHdpZHRoID0gMCB0aGVuIHdpZHRoLCBwcmVjaXNpb24gZWxzZVxuICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICBpZiBTY2FubmluZy5lb2YgaWIgdGhlbiB3aWR0aCwgcHJlY2lzaW9uIGVsc2VcbiAgbWF0Y2ggYyB3aXRoXG4gIHwgJy4nIC0+XG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgbGV0IHByZWNpc2lvbiA9IEludC5taW4gd2lkdGggcHJlY2lzaW9uIGluXG4gICAgbGV0IHdpZHRoID0gd2lkdGggLSAocHJlY2lzaW9uIC0gc2Nhbl9mcmFjdGlvbmFsX3BhcnQgcHJlY2lzaW9uIGliKSBpblxuICAgIHNjYW5fZXhwb25lbnRfcGFydCB3aWR0aCBpYiwgcHJlY2lzaW9uXG4gIHwgXyAtPlxuICAgIHNjYW5fZXhwb25lbnRfcGFydCB3aWR0aCBpYiwgcHJlY2lzaW9uXG5cblxubGV0IGNoZWNrX2Nhc2VfaW5zZW5zaXRpdmVfc3RyaW5nIHdpZHRoIGliIGVycm9yIHN0ciA9XG4gIGxldCBsb3dlcmNhc2UgYyA9XG4gICAgbWF0Y2ggYyB3aXRoXG4gICAgfCAnQScgLi4gJ1onIC0+XG4gICAgICBjaGFyX29mX2ludCAoaW50X29mX2NoYXIgYyAtIGludF9vZl9jaGFyICdBJyArIGludF9vZl9jaGFyICdhJylcbiAgICB8IF8gLT4gYyBpblxuICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzdHIgaW5cbiAgbGV0IHdpZHRoID0gcmVmIHdpZHRoIGluXG4gIGZvciBpID0gMCB0byBsZW4gLSAxIGRvXG4gICAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgICBpZiBsb3dlcmNhc2UgYyA8PiBsb3dlcmNhc2Ugc3RyLltpXSB0aGVuIGVycm9yICgpO1xuICAgIGlmICF3aWR0aCA9IDAgdGhlbiBlcnJvciAoKTtcbiAgICB3aWR0aCA6PSBTY2FubmluZy5zdG9yZV9jaGFyICF3aWR0aCBpYiBjO1xuICBkb25lO1xuICAhd2lkdGhcblxuXG5sZXQgc2Nhbl9oZXhfZmxvYXQgd2lkdGggcHJlY2lzaW9uIGliID1cbiAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9oZXhfZmxvYXQgKCk7XG4gIGxldCB3aWR0aCA9IHNjYW5fc2lnbiB3aWR0aCBpYiBpblxuICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2hleF9mbG9hdCAoKTtcbiAgbWF0Y2ggU2Nhbm5pbmcucGVla19jaGFyIGliIHdpdGhcbiAgfCAnMCcgYXMgYyAtPiAoXG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9oZXhfZmxvYXQgKCk7XG4gICAgbGV0IHdpZHRoID0gY2hlY2tfY2FzZV9pbnNlbnNpdGl2ZV9zdHJpbmcgd2lkdGggaWIgYmFkX2hleF9mbG9hdCBcInhcIiBpblxuICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiB3aWR0aCBlbHNlXG4gICAgICBsZXQgd2lkdGggPSBtYXRjaCBTY2FubmluZy5wZWVrX2NoYXIgaWIgd2l0aFxuICAgICAgICB8ICcuJyB8ICdwJyB8ICdQJyAtPiB3aWR0aFxuICAgICAgICB8IF8gLT4gc2Nhbl9oZXhhZGVjaW1hbF9pbnQgd2lkdGggaWIgaW5cbiAgICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiB3aWR0aCBlbHNlXG4gICAgICAgIGxldCB3aWR0aCA9IG1hdGNoIFNjYW5uaW5nLnBlZWtfY2hhciBpYiB3aXRoXG4gICAgICAgICAgfCAnLicgYXMgYyAtPiAoXG4gICAgICAgICAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICAgICAgICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiB3aWR0aCBlbHNlXG4gICAgICAgICAgICAgIG1hdGNoIFNjYW5uaW5nLnBlZWtfY2hhciBpYiB3aXRoXG4gICAgICAgICAgICAgIHwgJ3AnIHwgJ1AnIC0+IHdpZHRoXG4gICAgICAgICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgICAgIGxldCBwcmVjaXNpb24gPSBJbnQubWluIHdpZHRoIHByZWNpc2lvbiBpblxuICAgICAgICAgICAgICAgIHdpZHRoIC0gKHByZWNpc2lvbiAtIHNjYW5faGV4YWRlY2ltYWxfaW50IHByZWNpc2lvbiBpYilcbiAgICAgICAgICApXG4gICAgICAgICAgfCBfIC0+IHdpZHRoIGluXG4gICAgICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiB3aWR0aCBlbHNlXG4gICAgICAgICAgbWF0Y2ggU2Nhbm5pbmcucGVla19jaGFyIGliIHdpdGhcbiAgICAgICAgICB8ICdwJyB8ICdQJyBhcyBjIC0+XG4gICAgICAgICAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICAgICAgICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfaGV4X2Zsb2F0ICgpO1xuICAgICAgICAgICAgc2Nhbl9vcHRpb25hbGx5X3NpZ25lZF9kZWNpbWFsX2ludCB3aWR0aCBpYlxuICAgICAgICAgIHwgXyAtPiB3aWR0aFxuICApXG4gIHwgJ24nIHwgJ04nIGFzIGMgLT5cbiAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2hleF9mbG9hdCAoKTtcbiAgICBjaGVja19jYXNlX2luc2Vuc2l0aXZlX3N0cmluZyB3aWR0aCBpYiBiYWRfaGV4X2Zsb2F0IFwiYW5cIlxuICB8ICdpJyB8ICdJJyBhcyBjIC0+XG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9oZXhfZmxvYXQgKCk7XG4gICAgY2hlY2tfY2FzZV9pbnNlbnNpdGl2ZV9zdHJpbmcgd2lkdGggaWIgYmFkX2hleF9mbG9hdCBcIm5maW5pdHlcIlxuICB8IF8gLT4gYmFkX2hleF9mbG9hdCAoKVxuXG5cbmxldCBzY2FuX2NhbWxfZmxvYXRfcmVzdCB3aWR0aCBwcmVjaXNpb24gaWIgPVxuICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2Zsb2F0ICgpO1xuICBsZXQgd2lkdGggPSBzY2FuX2RlY2ltYWxfZGlnaXRfc3RhciB3aWR0aCBpYiBpblxuICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2Zsb2F0ICgpO1xuICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICBtYXRjaCBjIHdpdGhcbiAgfCAnLicgLT5cbiAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICAoKiBUaGUgZWZmZWN0aXZlIHdpZHRoIGF2YWlsYWJsZSBmb3Igc2Nhbm5pbmcgdGhlIGZyYWN0aW9uYWwgcGFydCBpc1xuICAgICAgIHRoZSBtaW5pbXVtIG9mIGRlY2xhcmVkIHByZWNpc2lvbiBhbmQgd2lkdGggbGVmdC4gKilcbiAgICBsZXQgcHJlY2lzaW9uID0gSW50Lm1pbiB3aWR0aCBwcmVjaXNpb24gaW5cbiAgICAoKiBBZnRlciBzY2FubmluZyB0aGUgZnJhY3Rpb25hbCBwYXJ0IHdpdGggW3ByZWNpc2lvbl0gcHJvdmlzaW9uYWwgd2lkdGgsXG4gICAgICAgW3dpZHRoX3ByZWNpc2lvbl0gaXMgbGVmdC4gKilcbiAgICBsZXQgd2lkdGhfcHJlY2lzaW9uID0gc2Nhbl9mcmFjdGlvbmFsX3BhcnQgcHJlY2lzaW9uIGliIGluXG4gICAgKCogSGVuY2UsIHNjYW5uaW5nIHRoZSBmcmFjdGlvbmFsIHBhcnQgdG9vayBleGFjdGx5XG4gICAgICAgW3ByZWNpc2lvbiAtIHdpZHRoX3ByZWNpc2lvbl0gY2hhcnMuICopXG4gICAgbGV0IGZyYWNfd2lkdGggPSBwcmVjaXNpb24gLSB3aWR0aF9wcmVjaXNpb24gaW5cbiAgICAoKiBBbmQgbmV3IHByb3Zpc2lvbmFsIHdpZHRoIGlzIFt3aWR0aCAtIHdpZHRoX3ByZWNpc2lvbi4gKilcbiAgICBsZXQgd2lkdGggPSB3aWR0aCAtIGZyYWNfd2lkdGggaW5cbiAgICBzY2FuX2V4cG9uZW50X3BhcnQgd2lkdGggaWJcbiAgfCAnZScgfCAnRScgLT5cbiAgICBzY2FuX2V4cG9uZW50X3BhcnQgd2lkdGggaWJcbiAgfCBfIC0+IGJhZF9mbG9hdCAoKVxuXG5cbmxldCBzY2FuX2NhbWxfZmxvYXQgd2lkdGggcHJlY2lzaW9uIGliID1cbiAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9mbG9hdCAoKTtcbiAgbGV0IHdpZHRoID0gc2Nhbl9zaWduIHdpZHRoIGliIGluXG4gIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfZmxvYXQgKCk7XG4gIG1hdGNoIFNjYW5uaW5nLnBlZWtfY2hhciBpYiB3aXRoXG4gIHwgJzAnIGFzIGMgLT4gKFxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfZmxvYXQgKCk7XG4gICAgbWF0Y2ggU2Nhbm5pbmcucGVla19jaGFyIGliIHdpdGhcbiAgICB8ICd4JyB8ICdYJyBhcyBjIC0+IChcbiAgICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9mbG9hdCAoKTtcbiAgICAgIGxldCB3aWR0aCA9IHNjYW5faGV4YWRlY2ltYWxfaW50IHdpZHRoIGliIGluXG4gICAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2Zsb2F0ICgpO1xuICAgICAgbGV0IHdpZHRoID0gbWF0Y2ggU2Nhbm5pbmcucGVla19jaGFyIGliIHdpdGhcbiAgICAgICAgfCAnLicgYXMgYyAtPiAoXG4gICAgICAgICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgICAgICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgICAgICAgICAgIG1hdGNoIFNjYW5uaW5nLnBlZWtfY2hhciBpYiB3aXRoXG4gICAgICAgICAgICB8ICdwJyB8ICdQJyAtPiB3aWR0aFxuICAgICAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICAgIGxldCBwcmVjaXNpb24gPSBJbnQubWluIHdpZHRoIHByZWNpc2lvbiBpblxuICAgICAgICAgICAgICB3aWR0aCAtIChwcmVjaXNpb24gLSBzY2FuX2hleGFkZWNpbWFsX2ludCBwcmVjaXNpb24gaWIpXG4gICAgICAgIClcbiAgICAgICAgfCAncCcgfCAnUCcgLT4gd2lkdGhcbiAgICAgICAgfCBfIC0+IGJhZF9mbG9hdCAoKSBpblxuICAgICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgICAgICAgbWF0Y2ggU2Nhbm5pbmcucGVla19jaGFyIGliIHdpdGhcbiAgICAgICAgfCAncCcgfCAnUCcgYXMgYyAtPlxuICAgICAgICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgICAgICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfaGV4X2Zsb2F0ICgpO1xuICAgICAgICAgIHNjYW5fb3B0aW9uYWxseV9zaWduZWRfZGVjaW1hbF9pbnQgd2lkdGggaWJcbiAgICAgICAgfCBfIC0+IHdpZHRoXG4gICAgKVxuICAgIHwgXyAtPlxuICAgICAgc2Nhbl9jYW1sX2Zsb2F0X3Jlc3Qgd2lkdGggcHJlY2lzaW9uIGliXG4gIClcbiAgfCAnMScgLi4gJzknIGFzIGMgLT5cbiAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2Zsb2F0ICgpO1xuICAgIHNjYW5fY2FtbF9mbG9hdF9yZXN0IHdpZHRoIHByZWNpc2lvbiBpYlxuKCogU3BlY2lhbCBjYXNlIG9mIG5hbiBhbmQgaW5maW5pdHk6XG4gIHwgJ2knIC0+XG4gIHwgJ24nIC0+XG4qKVxuICB8IF8gLT4gYmFkX2Zsb2F0ICgpXG5cblxuKCogU2NhbiBhIHJlZ3VsYXIgc3RyaW5nOlxuICAgc3RvcHMgd2hlbiBlbmNvdW50ZXJpbmcgYSBzcGFjZSwgaWYgbm8gc2Nhbm5pbmcgaW5kaWNhdGlvbiBoYXMgYmVlbiBnaXZlbjtcbiAgIG90aGVyd2lzZSwgc3RvcHMgd2hlbiBlbmNvdW50ZXJpbmcgdGhlIGNoYXJhY3RlcnMgaW4gdGhlIHNjYW5uaW5nXG4gICBpbmRpY2F0aW9uIFtzdHBdLlxuICAgSXQgYWxzbyBzdG9wcyBhdCBlbmQgb2YgZmlsZSBvciB3aGVuIHRoZSBtYXhpbXVtIG51bWJlciBvZiBjaGFyYWN0ZXJzIGhhc1xuICAgYmVlbiByZWFkLiAqKVxubGV0IHNjYW5fc3RyaW5nIHN0cCB3aWR0aCBpYiA9XG4gIGxldCByZWMgbG9vcCB3aWR0aCA9XG4gICAgaWYgd2lkdGggPSAwIHRoZW4gd2lkdGggZWxzZVxuICAgIGxldCBjID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gICAgaWYgU2Nhbm5pbmcuZW9mIGliIHRoZW4gd2lkdGggZWxzZVxuICAgICAgbWF0Y2ggc3RwIHdpdGhcbiAgICAgIHwgU29tZSBjJyB3aGVuIGMgPSBjJyAtPiBTY2FubmluZy5za2lwX2NoYXIgd2lkdGggaWJcbiAgICAgIHwgU29tZSBfIC0+IGxvb3AgKFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYylcbiAgICAgIHwgTm9uZSAtPlxuICAgICAgICBtYXRjaCBjIHdpdGhcbiAgICAgICAgfCAnICcgfCAnXFx0JyB8ICdcXG4nIHwgJ1xccicgLT4gd2lkdGhcbiAgICAgICAgfCBfIC0+IGxvb3AgKFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYykgaW5cbiAgbG9vcCB3aWR0aFxuXG5cbigqIFNjYW4gYSBjaGFyOiBwZWVrIHN0cmljdGx5IG9uZSBjaGFyYWN0ZXIgaW4gdGhlIGlucHV0LCB3aGF0c29ldmVyLiAqKVxubGV0IHNjYW5fY2hhciB3aWR0aCBpYiA9XG4gICgqIFRoZSBjYXNlIHdpZHRoID0gMCBjb3VsZCBub3QgaGFwcGVuIGhlcmUsIHNpbmNlIGl0IGlzIHRlc3RlZCBiZWZvcmVcbiAgICAgY2FsbGluZyBzY2FuX2NoYXIsIGluIHRoZSBtYWluIHNjYW5uaW5nIGZ1bmN0aW9uLlxuICAgIGlmIHdpZHRoID0gMCB0aGVuIGJhZF90b2tlbl9sZW5ndGggXCJhIGNoYXJhY3RlclwiIGVsc2UgKilcbiAgU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiAoU2Nhbm5pbmcuY2hlY2tlZF9wZWVrX2NoYXIgaWIpXG5cblxubGV0IGNoYXJfZm9yX2JhY2tzbGFzaCA9IGZ1bmN0aW9uXG4gIHwgJ24nIC0+ICdcXDAxMCdcbiAgfCAncicgLT4gJ1xcMDEzJ1xuICB8ICdiJyAtPiAnXFwwMDgnXG4gIHwgJ3QnIC0+ICdcXDAwOSdcbiAgfCBjIC0+IGNcblxuXG4oKiBUaGUgaW50ZWdlciB2YWx1ZSBjb3JyZXNwb25kaW5nIHRvIHRoZSBmYWNpYWwgdmFsdWUgb2YgYSB2YWxpZFxuICAgZGVjaW1hbCBkaWdpdCBjaGFyYWN0ZXIuICopXG5sZXQgZGVjaW1hbF92YWx1ZV9vZl9jaGFyIGMgPSBpbnRfb2ZfY2hhciBjIC0gaW50X29mX2NoYXIgJzAnXG5cbmxldCBjaGFyX2Zvcl9kZWNpbWFsX2NvZGUgYzAgYzEgYzIgPVxuICBsZXQgYyA9XG4gICAgMTAwICogZGVjaW1hbF92YWx1ZV9vZl9jaGFyIGMwICtcbiAgICAgMTAgKiBkZWNpbWFsX3ZhbHVlX29mX2NoYXIgYzEgK1xuICAgICAgICAgIGRlY2ltYWxfdmFsdWVfb2ZfY2hhciBjMiBpblxuICBpZiBjIDwgMCB8fCBjID4gMjU1IHRoZW5cbiAgICBiYWRfaW5wdXRcbiAgICAgIChQcmludGYuc3ByaW50ZlxuICAgICAgICAgXCJiYWQgY2hhcmFjdGVyIGRlY2ltYWwgZW5jb2RpbmcgXFxcXCVjJWMlY1wiIGMwIGMxIGMyKSBlbHNlXG4gIGNoYXJfb2ZfaW50IGNcblxuXG4oKiBUaGUgaW50ZWdlciB2YWx1ZSBjb3JyZXNwb25kaW5nIHRvIHRoZSBmYWNpYWwgdmFsdWUgb2YgYSB2YWxpZFxuICAgaGV4YWRlY2ltYWwgZGlnaXQgY2hhcmFjdGVyLiAqKVxubGV0IGhleGFkZWNpbWFsX3ZhbHVlX29mX2NoYXIgYyA9XG4gIGxldCBkID0gaW50X29mX2NoYXIgYyBpblxuICAoKiBDb3VsZCBhbHNvIGJlOlxuICAgIGlmIGQgPD0gaW50X29mX2NoYXIgJzknIHRoZW4gZCAtIGludF9vZl9jaGFyICcwJyBlbHNlXG4gICAgaWYgZCA8PSBpbnRfb2ZfY2hhciAnRicgdGhlbiAxMCArIGQgLSBpbnRfb2ZfY2hhciAnQScgZWxzZVxuICAgIGlmIGQgPD0gaW50X29mX2NoYXIgJ2YnIHRoZW4gMTAgKyBkIC0gaW50X29mX2NoYXIgJ2EnIGVsc2UgYXNzZXJ0IGZhbHNlXG4gICopXG4gIGlmIGQgPj0gaW50X29mX2NoYXIgJ2EnIHRoZW5cbiAgICBkIC0gODcgKCogMTAgKyBpbnRfb2ZfY2hhciBjIC0gaW50X29mX2NoYXIgJ2EnICopIGVsc2VcbiAgaWYgZCA+PSBpbnRfb2ZfY2hhciAnQScgdGhlblxuICAgIGQgLSA1NSAgKCogMTAgKyBpbnRfb2ZfY2hhciBjIC0gaW50X29mX2NoYXIgJ0EnICopIGVsc2VcbiAgICBkIC0gaW50X29mX2NoYXIgJzAnXG5cblxubGV0IGNoYXJfZm9yX2hleGFkZWNpbWFsX2NvZGUgYzEgYzIgPVxuICBsZXQgYyA9XG4gICAgMTYgKiBoZXhhZGVjaW1hbF92YWx1ZV9vZl9jaGFyIGMxICtcbiAgICAgICAgIGhleGFkZWNpbWFsX3ZhbHVlX29mX2NoYXIgYzIgaW5cbiAgaWYgYyA8IDAgfHwgYyA+IDI1NSB0aGVuXG4gICAgYmFkX2lucHV0XG4gICAgICAoUHJpbnRmLnNwcmludGYgXCJiYWQgY2hhcmFjdGVyIGhleGFkZWNpbWFsIGVuY29kaW5nIFxcXFwlYyVjXCIgYzEgYzIpIGVsc2VcbiAgY2hhcl9vZl9pbnQgY1xuXG5cbigqIENhbGxlZCBpbiBwYXJ0aWN1bGFyIHdoZW4gZW5jb3VudGVyaW5nICdcXFxcJyBhcyBzdGFydGVyIG9mIGEgY2hhci5cbiAgIFN0b3BzIGJlZm9yZSB0aGUgY29ycmVzcG9uZGluZyAnXFwnJy4gKilcbmxldCBjaGVja19uZXh0X2NoYXIgbWVzc2FnZSB3aWR0aCBpYiA9XG4gIGlmIHdpZHRoID0gMCB0aGVuIGJhZF90b2tlbl9sZW5ndGggbWVzc2FnZSBlbHNlXG4gIGxldCBjID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gIGlmIFNjYW5uaW5nLmVvZiBpYiB0aGVuIGJhZF9lbmRfb2ZfaW5wdXQgbWVzc2FnZSBlbHNlXG4gIGNcblxuXG5sZXQgY2hlY2tfbmV4dF9jaGFyX2Zvcl9jaGFyID0gY2hlY2tfbmV4dF9jaGFyIFwiYSBDaGFyXCJcbmxldCBjaGVja19uZXh0X2NoYXJfZm9yX3N0cmluZyA9IGNoZWNrX25leHRfY2hhciBcImEgU3RyaW5nXCJcblxubGV0IHNjYW5fYmFja3NsYXNoX2NoYXIgd2lkdGggaWIgPVxuICBtYXRjaCBjaGVja19uZXh0X2NoYXJfZm9yX2NoYXIgd2lkdGggaWIgd2l0aFxuICB8ICdcXFxcJyB8ICdcXCcnIHwgJ1xcXCInIHwgJ24nIHwgJ3QnIHwgJ2InIHwgJ3InIGFzIGMgLT5cbiAgICBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIChjaGFyX2Zvcl9iYWNrc2xhc2ggYylcbiAgfCAnMCcgLi4gJzknIGFzIGMgLT5cbiAgICBsZXQgZ2V0X2RpZ2l0ICgpID1cbiAgICAgIGxldCBjID0gU2Nhbm5pbmcubmV4dF9jaGFyIGliIGluXG4gICAgICBtYXRjaCBjIHdpdGhcbiAgICAgIHwgJzAnIC4uICc5JyBhcyBjIC0+IGNcbiAgICAgIHwgYyAtPiBiYWRfaW5wdXRfZXNjYXBlIGMgaW5cbiAgICBsZXQgYzAgPSBjIGluXG4gICAgbGV0IGMxID0gZ2V0X2RpZ2l0ICgpIGluXG4gICAgbGV0IGMyID0gZ2V0X2RpZ2l0ICgpIGluXG4gICAgU2Nhbm5pbmcuc3RvcmVfY2hhciAod2lkdGggLSAyKSBpYiAoY2hhcl9mb3JfZGVjaW1hbF9jb2RlIGMwIGMxIGMyKVxuICB8ICd4JyAtPlxuICAgIGxldCBnZXRfZGlnaXQgKCkgPVxuICAgICAgbGV0IGMgPSBTY2FubmluZy5uZXh0X2NoYXIgaWIgaW5cbiAgICAgIG1hdGNoIGMgd2l0aFxuICAgICAgfCAnMCcgLi4gJzknIHwgJ0EnIC4uICdGJyB8ICdhJyAuLiAnZicgYXMgYyAtPiBjXG4gICAgICB8IGMgLT4gYmFkX2lucHV0X2VzY2FwZSBjIGluXG4gICAgbGV0IGMxID0gZ2V0X2RpZ2l0ICgpIGluXG4gICAgbGV0IGMyID0gZ2V0X2RpZ2l0ICgpIGluXG4gICAgU2Nhbm5pbmcuc3RvcmVfY2hhciAod2lkdGggLSAyKSBpYiAoY2hhcl9mb3JfaGV4YWRlY2ltYWxfY29kZSBjMSBjMilcbiAgfCBjIC0+XG4gICAgYmFkX2lucHV0X2VzY2FwZSBjXG5cblxuKCogU2NhbiBhIGNoYXJhY3RlciAoYW4gT0NhbWwgdG9rZW4pLiAqKVxubGV0IHNjYW5fY2FtbF9jaGFyIHdpZHRoIGliID1cblxuICBsZXQgcmVjIGZpbmRfc3RhcnQgd2lkdGggPVxuICAgIG1hdGNoIFNjYW5uaW5nLmNoZWNrZWRfcGVla19jaGFyIGliIHdpdGhcbiAgICB8ICdcXCcnIC0+IGZpbmRfY2hhciAoU2Nhbm5pbmcuaWdub3JlX2NoYXIgd2lkdGggaWIpXG4gICAgfCBjIC0+IGNoYXJhY3Rlcl9taXNtYXRjaCAnXFwnJyBjXG5cbiAgYW5kIGZpbmRfY2hhciB3aWR0aCA9XG4gICAgbWF0Y2ggY2hlY2tfbmV4dF9jaGFyX2Zvcl9jaGFyIHdpZHRoIGliIHdpdGhcbiAgICB8ICdcXFxcJyAtPlxuICAgICAgZmluZF9zdG9wIChzY2FuX2JhY2tzbGFzaF9jaGFyIChTY2FubmluZy5pZ25vcmVfY2hhciB3aWR0aCBpYikgaWIpXG4gICAgfCBjIC0+XG4gICAgICBmaW5kX3N0b3AgKFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYylcblxuICBhbmQgZmluZF9zdG9wIHdpZHRoID1cbiAgICBtYXRjaCBjaGVja19uZXh0X2NoYXJfZm9yX2NoYXIgd2lkdGggaWIgd2l0aFxuICAgIHwgJ1xcJycgLT4gU2Nhbm5pbmcuaWdub3JlX2NoYXIgd2lkdGggaWJcbiAgICB8IGMgLT4gY2hhcmFjdGVyX21pc21hdGNoICdcXCcnIGMgaW5cblxuICBmaW5kX3N0YXJ0IHdpZHRoXG5cblxuKCogU2NhbiBhIGRlbGltaXRlZCBzdHJpbmcgKGFuIE9DYW1sIHRva2VuKS4gKilcbmxldCBzY2FuX2NhbWxfc3RyaW5nIHdpZHRoIGliID1cblxuICBsZXQgcmVjIGZpbmRfc3RhcnQgd2lkdGggPVxuICAgIG1hdGNoIFNjYW5uaW5nLmNoZWNrZWRfcGVla19jaGFyIGliIHdpdGhcbiAgICB8ICdcXFwiJyAtPiBmaW5kX3N0b3AgKFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliKVxuICAgIHwgYyAtPiBjaGFyYWN0ZXJfbWlzbWF0Y2ggJ1xcXCInIGNcblxuICBhbmQgZmluZF9zdG9wIHdpZHRoID1cbiAgICBtYXRjaCBjaGVja19uZXh0X2NoYXJfZm9yX3N0cmluZyB3aWR0aCBpYiB3aXRoXG4gICAgfCAnXFxcIicgLT4gU2Nhbm5pbmcuaWdub3JlX2NoYXIgd2lkdGggaWJcbiAgICB8ICdcXFxcJyAtPiBzY2FuX2JhY2tzbGFzaCAoU2Nhbm5pbmcuaWdub3JlX2NoYXIgd2lkdGggaWIpXG4gICAgfCBjIC0+IGZpbmRfc3RvcCAoU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjKVxuXG4gIGFuZCBzY2FuX2JhY2tzbGFzaCB3aWR0aCA9XG4gICAgbWF0Y2ggY2hlY2tfbmV4dF9jaGFyX2Zvcl9zdHJpbmcgd2lkdGggaWIgd2l0aFxuICAgIHwgJ1xccicgLT4gc2tpcF9uZXdsaW5lIChTY2FubmluZy5pZ25vcmVfY2hhciB3aWR0aCBpYilcbiAgICB8ICdcXG4nIC0+IHNraXBfc3BhY2VzIChTY2FubmluZy5pZ25vcmVfY2hhciB3aWR0aCBpYilcbiAgICB8IF8gLT4gZmluZF9zdG9wIChzY2FuX2JhY2tzbGFzaF9jaGFyIHdpZHRoIGliKVxuXG4gIGFuZCBza2lwX25ld2xpbmUgd2lkdGggPVxuICAgIG1hdGNoIGNoZWNrX25leHRfY2hhcl9mb3Jfc3RyaW5nIHdpZHRoIGliIHdpdGhcbiAgICB8ICdcXG4nIC0+IHNraXBfc3BhY2VzIChTY2FubmluZy5pZ25vcmVfY2hhciB3aWR0aCBpYilcbiAgICB8IF8gLT4gZmluZF9zdG9wIChTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliICdcXHInKVxuXG4gIGFuZCBza2lwX3NwYWNlcyB3aWR0aCA9XG4gICAgbWF0Y2ggY2hlY2tfbmV4dF9jaGFyX2Zvcl9zdHJpbmcgd2lkdGggaWIgd2l0aFxuICAgIHwgJyAnIC0+IHNraXBfc3BhY2VzIChTY2FubmluZy5pZ25vcmVfY2hhciB3aWR0aCBpYilcbiAgICB8IF8gLT4gZmluZF9zdG9wIHdpZHRoIGluXG5cbiAgZmluZF9zdGFydCB3aWR0aFxuXG5cbigqIFNjYW4gYSBib29sZWFuIChhbiBPQ2FtbCB0b2tlbikuICopXG5sZXQgc2Nhbl9ib29sIGliID1cbiAgbGV0IGMgPSBTY2FubmluZy5jaGVja2VkX3BlZWtfY2hhciBpYiBpblxuICBsZXQgbSA9XG4gICAgbWF0Y2ggYyB3aXRoXG4gICAgfCAndCcgLT4gNFxuICAgIHwgJ2YnIC0+IDVcbiAgICB8IGMgLT5cbiAgICAgIGJhZF9pbnB1dFxuICAgICAgICAoUHJpbnRmLnNwcmludGYgXCJ0aGUgY2hhcmFjdGVyICVDIGNhbm5vdCBzdGFydCBhIGJvb2xlYW5cIiBjKSBpblxuICBzY2FuX3N0cmluZyBOb25lIG0gaWJcblxuXG4oKiBTY2FuIGEgc3RyaW5nIGNvbnRhaW5pbmcgZWxlbWVudHMgaW4gY2hhcl9zZXQgYW5kIHRlcm1pbmF0ZWQgYnkgc2Nhbl9pbmRpY1xuICAgaWYgcHJvdmlkZWQuICopXG5sZXQgc2Nhbl9jaGFyc19pbl9jaGFyX3NldCBjaGFyX3NldCBzY2FuX2luZGljIHdpZHRoIGliID1cbiAgbGV0IHJlYyBzY2FuX2NoYXJzIGkgc3RwID1cbiAgICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICAgIGlmIGkgPiAwICYmIG5vdCAoU2Nhbm5pbmcuZW9mIGliKSAmJlxuICAgICAgIGlzX2luX2NoYXJfc2V0IGNoYXJfc2V0IGMgJiZcbiAgICAgICBpbnRfb2ZfY2hhciBjIDw+IHN0cCB0aGVuXG4gICAgICBsZXQgXyA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgbWF4X2ludCBpYiBjIGluXG4gICAgICBzY2FuX2NoYXJzIChpIC0gMSkgc3RwIGluXG4gIG1hdGNoIHNjYW5faW5kaWMgd2l0aFxuICB8IE5vbmUgLT4gc2Nhbl9jaGFycyB3aWR0aCAoLTEpO1xuICB8IFNvbWUgYyAtPlxuICAgIHNjYW5fY2hhcnMgd2lkdGggKGludF9vZl9jaGFyIGMpO1xuICAgIGlmIG5vdCAoU2Nhbm5pbmcuZW9mIGliKSB0aGVuXG4gICAgICBsZXQgY2kgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgICAgIGlmIGMgPSBjaVxuICAgICAgdGhlbiBTY2FubmluZy5pbnZhbGlkYXRlX2N1cnJlbnRfY2hhciBpYlxuICAgICAgZWxzZSBjaGFyYWN0ZXJfbWlzbWF0Y2ggYyBjaVxuXG5cbigqIFRoZSBnbG9iYWwgZXJyb3IgcmVwb3J0IGZ1bmN0aW9uIGZvciBbU2NhbmZdLiAqKVxubGV0IHNjYW5mX2JhZF9pbnB1dCBpYiA9IGZ1bmN0aW9uXG4gIHwgU2Nhbl9mYWlsdXJlIHMgfCBGYWlsdXJlIHMgLT5cbiAgICBsZXQgaSA9IFNjYW5uaW5nLmNoYXJfY291bnQgaWIgaW5cbiAgICBiYWRfaW5wdXQgKFByaW50Zi5zcHJpbnRmIFwic2NhbmY6IGJhZCBpbnB1dCBhdCBjaGFyIG51bWJlciAlaTogJXNcIiBpIHMpXG4gIHwgeCAtPiByYWlzZSB4XG5cblxuKCogR2V0IHRoZSBjb250ZW50IG9mIGEgY291bnRlciBmcm9tIGFuIGlucHV0IGJ1ZmZlci4gKilcbmxldCBnZXRfY291bnRlciBpYiBjb3VudGVyID1cbiAgbWF0Y2ggY291bnRlciB3aXRoXG4gIHwgTGluZV9jb3VudGVyIC0+IFNjYW5uaW5nLmxpbmVfY291bnQgaWJcbiAgfCBDaGFyX2NvdW50ZXIgLT4gU2Nhbm5pbmcuY2hhcl9jb3VudCBpYlxuICB8IFRva2VuX2NvdW50ZXIgLT4gU2Nhbm5pbmcudG9rZW5fY291bnQgaWJcblxuXG4oKiBDb21wdXRlIHRoZSB3aWR0aCBvZiBhIHBhZGRpbmcgb3B0aW9uIChzZWUgXCIlNDJ7XCIgYW5kIFwiJTEyMyhcIikuICopXG5sZXQgd2lkdGhfb2ZfcGFkX29wdCBwYWRfb3B0ID0gbWF0Y2ggcGFkX29wdCB3aXRoXG4gIHwgTm9uZSAtPiBtYXhfaW50XG4gIHwgU29tZSB3aWR0aCAtPiB3aWR0aFxuXG5cbmxldCBzdG9wcGVyX29mX2Zvcm1hdHRpbmdfbGl0IGZtdGluZyA9XG4gIGlmIGZtdGluZyA9IEVzY2FwZWRfcGVyY2VudCB0aGVuICclJywgXCJcIiBlbHNlXG4gICAgbGV0IHN0ciA9IHN0cmluZ19vZl9mb3JtYXR0aW5nX2xpdCBmbXRpbmcgaW5cbiAgICBsZXQgc3RwID0gc3RyLlsxXSBpblxuICAgIGxldCBzdWJfc3RyID0gU3RyaW5nLnN1YiBzdHIgMiAoU3RyaW5nLmxlbmd0aCBzdHIgLSAyKSBpblxuICAgIHN0cCwgc3ViX3N0clxuXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBSZWFkZXIgbWFuYWdlbWVudCAqKVxuXG4oKiBBIGNhbGwgdG8gdGFrZV9mb3JtYXRfcmVhZGVycyBvbiBhIGZvcm1hdCBpcyBldmFsdWF0ZWQgaW50byBmdW5jdGlvbnNcbiAgIHRha2luZyByZWFkZXJzIGFzIGFyZ3VtZW50cyBhbmQgYWdncmVnYXRlIHRoZW0gaW50byBhbiBoZXRlcm9nZW5lb3VzIGxpc3QgKilcbigqIFdoZW4gYWxsIHJlYWRlcnMgYXJlIHRha2VuLCBmaW5hbGx5IHBhc3MgdGhlIGxpc3Qgb2YgdGhlIHJlYWRlcnMgdG8gdGhlXG4gICBjb250aW51YXRpb24gay4gKilcbmxldCByZWMgdGFrZV9mb3JtYXRfcmVhZGVycyA6IHR5cGUgYSBjIGQgZSBmIC5cbiAgICAoKGQsIGUpIGhldGVyX2xpc3QgLT4gZSkgLT4gKGEsIFNjYW5uaW5nLmluX2NoYW5uZWwsIGMsIGQsIGUsIGYpIGZtdCAtPlxuICAgIGQgPVxuZnVuIGsgZm10IC0+IG1hdGNoIGZtdCB3aXRoXG4gIHwgUmVhZGVyIGZtdF9yZXN0IC0+XG4gICAgZnVuIHJlYWRlciAtPlxuICAgICAgbGV0IG5ld19rIHJlYWRlcnNfcmVzdCA9IGsgKENvbnMgKHJlYWRlciwgcmVhZGVyc19yZXN0KSkgaW5cbiAgICAgIHRha2VfZm9ybWF0X3JlYWRlcnMgbmV3X2sgZm10X3Jlc3RcbiAgfCBDaGFyIHJlc3QgICAgICAgICAgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IENhbWxfY2hhciByZXN0ICAgICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgU3RyaW5nIChfLCByZXN0KSAgICAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBDYW1sX3N0cmluZyAoXywgcmVzdCkgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IEludCAoXywgXywgXywgcmVzdCkgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgSW50MzIgKF8sIF8sIF8sIHJlc3QpICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBOYXRpdmVpbnQgKF8sIF8sIF8sIHJlc3QpICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IEludDY0IChfLCBfLCBfLCByZXN0KSAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgRmxvYXQgKF8sIF8sIF8sIHJlc3QpICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBCb29sIChfLCByZXN0KSAgICAgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IEFscGhhIHJlc3QgICAgICAgICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgVGhldGEgcmVzdCAgICAgICAgICAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBGbHVzaCByZXN0ICAgICAgICAgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IFN0cmluZ19saXRlcmFsIChfLCByZXN0KSAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgQ2hhcl9saXRlcmFsIChfLCByZXN0KSAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBDdXN0b20gKF8sIF8sIHJlc3QpICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuXG4gIHwgU2Nhbl9jaGFyX3NldCAoXywgXywgcmVzdCkgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBTY2FuX2dldF9jb3VudGVyIChfLCByZXN0KSAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IFNjYW5fbmV4dF9jaGFyIHJlc3QgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG5cbiAgfCBGb3JtYXR0aW5nX2xpdCAoXywgcmVzdCkgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IEZvcm1hdHRpbmdfZ2VuIChPcGVuX3RhZyAoRm9ybWF0IChmbXQsIF8pKSwgcmVzdCkgLT5cbiAgICAgIHRha2VfZm9ybWF0X3JlYWRlcnMgayAoY29uY2F0X2ZtdCBmbXQgcmVzdClcbiAgfCBGb3JtYXR0aW5nX2dlbiAoT3Blbl9ib3ggKEZvcm1hdCAoZm10LCBfKSksIHJlc3QpIC0+XG4gICAgICB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgKGNvbmNhdF9mbXQgZm10IHJlc3QpXG5cbiAgfCBGb3JtYXRfYXJnIChfLCBfLCByZXN0KSAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IEZvcm1hdF9zdWJzdCAoXywgZm10dHksIHJlc3QpICAgIC0+XG4gICAgIHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayAoZXJhc2VfcmVsIChzeW1tIGZtdHR5KSkgcmVzdFxuICB8IElnbm9yZWRfcGFyYW0gKGlnbiwgcmVzdCkgICAgICAgIC0+IHRha2VfaWdub3JlZF9mb3JtYXRfcmVhZGVycyBrIGlnbiByZXN0XG5cbiAgfCBFbmRfb2ZfZm9ybWF0ICAgICAgICAgICAgICAgICAgICAtPiBrIE5pbFxuXG4oKiBUYWtlIHJlYWRlcnMgYXNzb2NpYXRlZCB0byBhbiBmbXR0eSBjb21pbmcgZnJvbSBhIEZvcm1hdF9zdWJzdCBcIiUoLi4uJSlcIi4gKilcbmFuZCB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIDogdHlwZSB4IHkgYSBjIGQgZSBmIC5cbiAgICAoKGQsIGUpIGhldGVyX2xpc3QgLT4gZSkgLT4gKGEsIFNjYW5uaW5nLmluX2NoYW5uZWwsIGMsIGQsIHgsIHkpIGZtdHR5IC0+XG4gICAgICAoeSwgU2Nhbm5pbmcuaW5fY2hhbm5lbCwgYywgeCwgZSwgZikgZm10IC0+IGQgPVxuZnVuIGsgZm10dHkgZm10IC0+IG1hdGNoIGZtdHR5IHdpdGhcbiAgfCBSZWFkZXJfdHkgZm10X3Jlc3QgLT5cbiAgICBmdW4gcmVhZGVyIC0+XG4gICAgICBsZXQgbmV3X2sgcmVhZGVyc19yZXN0ID0gayAoQ29ucyAocmVhZGVyLCByZWFkZXJzX3Jlc3QpKSBpblxuICAgICAgdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBuZXdfayBmbXRfcmVzdCBmbXRcbiAgfCBJZ25vcmVkX3JlYWRlcl90eSBmbXRfcmVzdCAtPlxuICAgIGZ1biByZWFkZXIgLT5cbiAgICAgIGxldCBuZXdfayByZWFkZXJzX3Jlc3QgPSBrIChDb25zIChyZWFkZXIsIHJlYWRlcnNfcmVzdCkpIGluXG4gICAgICB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIG5ld19rIGZtdF9yZXN0IGZtdFxuICB8IENoYXJfdHkgcmVzdCAgICAgICAgICAgICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBTdHJpbmdfdHkgcmVzdCAgICAgICAgICAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgSW50X3R5IHJlc3QgICAgICAgICAgICAgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IEludDMyX3R5IHJlc3QgICAgICAgICAgICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBOYXRpdmVpbnRfdHkgcmVzdCAgICAgICAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgSW50NjRfdHkgcmVzdCAgICAgICAgICAgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IEZsb2F0X3R5IHJlc3QgICAgICAgICAgICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBCb29sX3R5IHJlc3QgICAgICAgICAgICAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgQWxwaGFfdHkgcmVzdCAgICAgICAgICAgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IFRoZXRhX3R5IHJlc3QgICAgICAgICAgICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBBbnlfdHkgcmVzdCAgICAgICAgICAgICAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgRm9ybWF0X2FyZ190eSAoXywgcmVzdCkgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IEVuZF9vZl9mbXR0eSAgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgRm9ybWF0X3N1YnN0X3R5ICh0eTEsIHR5MiwgcmVzdCkgLT5cbiAgICBsZXQgdHkgPSB0cmFucyAoc3ltbSB0eTEpIHR5MiBpblxuICAgIHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayAoY29uY2F0X2ZtdHR5IHR5IHJlc3QpIGZtdFxuXG4oKiBUYWtlIHJlYWRlcnMgYXNzb2NpYXRlZCB0byBhbiBpZ25vcmVkIHBhcmFtZXRlci4gKilcbmFuZCB0YWtlX2lnbm9yZWRfZm9ybWF0X3JlYWRlcnMgOiB0eXBlIHggeSBhIGMgZCBlIGYgLlxuICAgICgoZCwgZSkgaGV0ZXJfbGlzdCAtPiBlKSAtPiAoYSwgU2Nhbm5pbmcuaW5fY2hhbm5lbCwgYywgZCwgeCwgeSkgaWdub3JlZCAtPlxuICAgICAgKHksIFNjYW5uaW5nLmluX2NoYW5uZWwsIGMsIHgsIGUsIGYpIGZtdCAtPiBkID1cbmZ1biBrIGlnbiBmbXQgLT4gbWF0Y2ggaWduIHdpdGhcbiAgfCBJZ25vcmVkX3JlYWRlciAtPlxuICAgIGZ1biByZWFkZXIgLT5cbiAgICAgIGxldCBuZXdfayByZWFkZXJzX3Jlc3QgPSBrIChDb25zIChyZWFkZXIsIHJlYWRlcnNfcmVzdCkpIGluXG4gICAgICB0YWtlX2Zvcm1hdF9yZWFkZXJzIG5ld19rIGZtdFxuICB8IElnbm9yZWRfY2hhciAgICAgICAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIGZtdFxuICB8IElnbm9yZWRfY2FtbF9jaGFyICAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIGZtdFxuICB8IElnbm9yZWRfc3RyaW5nIF8gICAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIGZtdFxuICB8IElnbm9yZWRfY2FtbF9zdHJpbmcgXyAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIGZtdFxuICB8IElnbm9yZWRfaW50IChfLCBfKSAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIGZtdFxuICB8IElnbm9yZWRfaW50MzIgKF8sIF8pICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIGZtdFxuICB8IElnbm9yZWRfbmF0aXZlaW50IChfLCBfKSAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIGZtdFxuICB8IElnbm9yZWRfaW50NjQgKF8sIF8pICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIGZtdFxuICB8IElnbm9yZWRfZmxvYXQgKF8sIF8pICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIGZtdFxuICB8IElnbm9yZWRfYm9vbCBfICAgICAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIGZtdFxuICB8IElnbm9yZWRfZm9ybWF0X2FyZyBfICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIGZtdFxuICB8IElnbm9yZWRfZm9ybWF0X3N1YnN0IChfLCBmbXR0eSkgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIGZtdHR5IGZtdFxuICB8IElnbm9yZWRfc2Nhbl9jaGFyX3NldCBfICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIGZtdFxuICB8IElnbm9yZWRfc2Nhbl9nZXRfY291bnRlciBfICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIGZtdFxuICB8IElnbm9yZWRfc2Nhbl9uZXh0X2NoYXIgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIGZtdFxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBHZW5lcmljIHNjYW5uaW5nICopXG5cbigqIE1ha2UgYSBnZW5lcmljIHNjYW5uaW5nIGZ1bmN0aW9uLiAqKVxuKCogU2NhbiBhIHN0cmVhbSBhY2NvcmRpbmcgdG8gYSBmb3JtYXQgYW5kIHJlYWRlcnMgb2J0YWluZWQgYnlcbiAgIHRha2VfZm9ybWF0X3JlYWRlcnMsIGFuZCBhZ2dyZWdhdGUgc2Nhbm5lZCB2YWx1ZXMgaW50byBhblxuICAgaGV0ZXJvZ2VuZW91cyBsaXN0LiAqKVxuKCogUmV0dXJuIHRoZSBoZXRlcm9nZW5lb3VzIGxpc3Qgb2Ygc2Nhbm5lZCB2YWx1ZXMuICopXG5sZXQgcmVjIG1ha2Vfc2NhbmYgOiB0eXBlIGEgYyBkIGUgZi5cbiAgICBTY2FubmluZy5pbl9jaGFubmVsIC0+IChhLCBTY2FubmluZy5pbl9jaGFubmVsLCBjLCBkLCBlLCBmKSBmbXQgLT5cbiAgICAgIChkLCBlKSBoZXRlcl9saXN0IC0+IChhLCBmKSBoZXRlcl9saXN0ID1cbmZ1biBpYiBmbXQgcmVhZGVycyAtPiBtYXRjaCBmbXQgd2l0aFxuICB8IENoYXIgcmVzdCAtPlxuICAgIGxldCBfID0gc2Nhbl9jaGFyIDAgaWIgaW5cbiAgICBsZXQgYyA9IHRva2VuX2NoYXIgaWIgaW5cbiAgICBDb25zIChjLCBtYWtlX3NjYW5mIGliIHJlc3QgcmVhZGVycylcbiAgfCBDYW1sX2NoYXIgcmVzdCAtPlxuICAgIGxldCBfID0gc2Nhbl9jYW1sX2NoYXIgMCBpYiBpblxuICAgIGxldCBjID0gdG9rZW5fY2hhciBpYiBpblxuICAgIENvbnMgKGMsIG1ha2Vfc2NhbmYgaWIgcmVzdCByZWFkZXJzKVxuXG4gIHwgU3RyaW5nIChwYWQsIEZvcm1hdHRpbmdfbGl0IChmbXRpbmdfbGl0LCByZXN0KSkgLT5cbiAgICBsZXQgc3RwLCBzdHIgPSBzdG9wcGVyX29mX2Zvcm1hdHRpbmdfbGl0IGZtdGluZ19saXQgaW5cbiAgICBsZXQgc2NhbiB3aWR0aCBfIGliID0gc2Nhbl9zdHJpbmcgKFNvbWUgc3RwKSB3aWR0aCBpYiBpblxuICAgIGxldCBzdHJfcmVzdCA9IFN0cmluZ19saXRlcmFsIChzdHIsIHJlc3QpIGluXG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgc3RyX3Jlc3QgcmVhZGVycyBwYWQgTm9fcHJlY2lzaW9uIHNjYW4gdG9rZW5fc3RyaW5nXG4gIHwgU3RyaW5nIChwYWQsIEZvcm1hdHRpbmdfZ2VuIChPcGVuX3RhZyAoRm9ybWF0IChmbXQnLCBfKSksIHJlc3QpKSAtPlxuICAgIGxldCBzY2FuIHdpZHRoIF8gaWIgPSBzY2FuX3N0cmluZyAoU29tZSAneycpIHdpZHRoIGliIGluXG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgKGNvbmNhdF9mbXQgZm10JyByZXN0KSByZWFkZXJzIHBhZCBOb19wcmVjaXNpb24gc2NhblxuICAgICAgICAgICAgICAgICAgIHRva2VuX3N0cmluZ1xuICB8IFN0cmluZyAocGFkLCBGb3JtYXR0aW5nX2dlbiAoT3Blbl9ib3ggKEZvcm1hdCAoZm10JywgXykpLCByZXN0KSkgLT5cbiAgICBsZXQgc2NhbiB3aWR0aCBfIGliID0gc2Nhbl9zdHJpbmcgKFNvbWUgJ1snKSB3aWR0aCBpYiBpblxuICAgIHBhZF9wcmVjX3NjYW5mIGliIChjb25jYXRfZm10IGZtdCcgcmVzdCkgcmVhZGVycyBwYWQgTm9fcHJlY2lzaW9uIHNjYW5cbiAgICAgICAgICAgICAgICAgICB0b2tlbl9zdHJpbmdcbiAgfCBTdHJpbmcgKHBhZCwgcmVzdCkgLT5cbiAgICBsZXQgc2NhbiB3aWR0aCBfIGliID0gc2Nhbl9zdHJpbmcgTm9uZSB3aWR0aCBpYiBpblxuICAgIHBhZF9wcmVjX3NjYW5mIGliIHJlc3QgcmVhZGVycyBwYWQgTm9fcHJlY2lzaW9uIHNjYW4gdG9rZW5fc3RyaW5nXG5cbiAgfCBDYW1sX3N0cmluZyAocGFkLCByZXN0KSAtPlxuICAgIGxldCBzY2FuIHdpZHRoIF8gaWIgPSBzY2FuX2NhbWxfc3RyaW5nIHdpZHRoIGliIGluXG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgcmVzdCByZWFkZXJzIHBhZCBOb19wcmVjaXNpb24gc2NhbiB0b2tlbl9zdHJpbmdcbiAgfCBJbnQgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbGV0IGMgPSBpbnRlZ2VyX2NvbnZlcnNpb25fb2ZfY2hhciAoY2hhcl9vZl9pY29udiBpY29udikgaW5cbiAgICBsZXQgc2NhbiB3aWR0aCBfIGliID0gc2Nhbl9pbnRfY29udmVyc2lvbiBjIHdpZHRoIGliIGluXG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgcmVzdCByZWFkZXJzIHBhZCBwcmVjIHNjYW4gKHRva2VuX2ludCBjKVxuICB8IEludDMyIChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIGxldCBjID0gaW50ZWdlcl9jb252ZXJzaW9uX29mX2NoYXIgKGNoYXJfb2ZfaWNvbnYgaWNvbnYpIGluXG4gICAgbGV0IHNjYW4gd2lkdGggXyBpYiA9IHNjYW5faW50X2NvbnZlcnNpb24gYyB3aWR0aCBpYiBpblxuICAgIHBhZF9wcmVjX3NjYW5mIGliIHJlc3QgcmVhZGVycyBwYWQgcHJlYyBzY2FuICh0b2tlbl9pbnQzMiBjKVxuICB8IE5hdGl2ZWludCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBsZXQgYyA9IGludGVnZXJfY29udmVyc2lvbl9vZl9jaGFyIChjaGFyX29mX2ljb252IGljb252KSBpblxuICAgIGxldCBzY2FuIHdpZHRoIF8gaWIgPSBzY2FuX2ludF9jb252ZXJzaW9uIGMgd2lkdGggaWIgaW5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiByZXN0IHJlYWRlcnMgcGFkIHByZWMgc2NhbiAodG9rZW5fbmF0aXZlaW50IGMpXG4gIHwgSW50NjQgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbGV0IGMgPSBpbnRlZ2VyX2NvbnZlcnNpb25fb2ZfY2hhciAoY2hhcl9vZl9pY29udiBpY29udikgaW5cbiAgICBsZXQgc2NhbiB3aWR0aCBfIGliID0gc2Nhbl9pbnRfY29udmVyc2lvbiBjIHdpZHRoIGliIGluXG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgcmVzdCByZWFkZXJzIHBhZCBwcmVjIHNjYW4gKHRva2VuX2ludDY0IGMpXG4gIHwgRmxvYXQgKChfLCAoRmxvYXRfRiB8IEZsb2F0X0NGKSksIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiByZXN0IHJlYWRlcnMgcGFkIHByZWMgc2Nhbl9jYW1sX2Zsb2F0IHRva2VuX2Zsb2F0XG4gIHwgRmxvYXQgKChfLCAoRmxvYXRfZiB8IEZsb2F0X2UgfCBGbG9hdF9FIHwgRmxvYXRfZyB8IEZsb2F0X0cpKSxcbiAgICAgICAgICAgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIHBhZF9wcmVjX3NjYW5mIGliIHJlc3QgcmVhZGVycyBwYWQgcHJlYyBzY2FuX2Zsb2F0IHRva2VuX2Zsb2F0XG4gIHwgRmxvYXQgKChfLCAoRmxvYXRfaCB8IEZsb2F0X0gpKSwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIHBhZF9wcmVjX3NjYW5mIGliIHJlc3QgcmVhZGVycyBwYWQgcHJlYyBzY2FuX2hleF9mbG9hdCB0b2tlbl9mbG9hdFxuICB8IEJvb2wgKHBhZCwgcmVzdCkgLT5cbiAgICBsZXQgc2NhbiBfIF8gaWIgPSBzY2FuX2Jvb2wgaWIgaW5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiByZXN0IHJlYWRlcnMgcGFkIE5vX3ByZWNpc2lvbiBzY2FuIHRva2VuX2Jvb2xcbiAgfCBBbHBoYSBfIC0+XG4gICAgaW52YWxpZF9hcmcgXCJzY2FuZjogYmFkIGNvbnZlcnNpb24gXFxcIiVhXFxcIlwiXG4gIHwgVGhldGEgXyAtPlxuICAgIGludmFsaWRfYXJnIFwic2NhbmY6IGJhZCBjb252ZXJzaW9uIFxcXCIldFxcXCJcIlxuICB8IEN1c3RvbSBfIC0+XG4gICAgaW52YWxpZF9hcmcgXCJzY2FuZjogYmFkIGNvbnZlcnNpb24gXFxcIiU/XFxcIiAoY3VzdG9tIGNvbnZlcnRlcilcIlxuICB8IFJlYWRlciBmbXRfcmVzdCAtPlxuICAgIGJlZ2luIG1hdGNoIHJlYWRlcnMgd2l0aFxuICAgIHwgQ29ucyAocmVhZGVyLCByZWFkZXJzX3Jlc3QpIC0+XG4gICAgICAgIGxldCB4ID0gcmVhZGVyIGliIGluXG4gICAgICAgIENvbnMgKHgsIG1ha2Vfc2NhbmYgaWIgZm10X3Jlc3QgcmVhZGVyc19yZXN0KVxuICAgIHwgTmlsIC0+XG4gICAgICAgIGludmFsaWRfYXJnIFwic2NhbmY6IG1pc3NpbmcgcmVhZGVyXCJcbiAgICBlbmRcbiAgfCBGbHVzaCByZXN0IC0+XG4gICAgaWYgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gbWFrZV9zY2FuZiBpYiByZXN0IHJlYWRlcnNcbiAgICBlbHNlIGJhZF9pbnB1dCBcImVuZCBvZiBpbnB1dCBub3QgZm91bmRcIlxuXG4gIHwgU3RyaW5nX2xpdGVyYWwgKHN0ciwgcmVzdCkgLT5cbiAgICBTdHJpbmcuaXRlciAoY2hlY2tfY2hhciBpYikgc3RyO1xuICAgIG1ha2Vfc2NhbmYgaWIgcmVzdCByZWFkZXJzXG4gIHwgQ2hhcl9saXRlcmFsIChjaHIsIHJlc3QpIC0+XG4gICAgY2hlY2tfY2hhciBpYiBjaHI7XG4gICAgbWFrZV9zY2FuZiBpYiByZXN0IHJlYWRlcnNcblxuICB8IEZvcm1hdF9hcmcgKHBhZF9vcHQsIGZtdHR5LCByZXN0KSAtPlxuICAgIGxldCBfID0gc2Nhbl9jYW1sX3N0cmluZyAod2lkdGhfb2ZfcGFkX29wdCBwYWRfb3B0KSBpYiBpblxuICAgIGxldCBzID0gdG9rZW5fc3RyaW5nIGliIGluXG4gICAgbGV0IGZtdCA9XG4gICAgICB0cnkgZm9ybWF0X29mX3N0cmluZ19mbXR0eSBzIGZtdHR5XG4gICAgICB3aXRoIEZhaWx1cmUgbXNnIC0+IGJhZF9pbnB1dCBtc2dcbiAgICBpblxuICAgIENvbnMgKGZtdCwgbWFrZV9zY2FuZiBpYiByZXN0IHJlYWRlcnMpXG4gIHwgRm9ybWF0X3N1YnN0IChwYWRfb3B0LCBmbXR0eSwgcmVzdCkgLT5cbiAgICBsZXQgXyA9IHNjYW5fY2FtbF9zdHJpbmcgKHdpZHRoX29mX3BhZF9vcHQgcGFkX29wdCkgaWIgaW5cbiAgICBsZXQgcyA9IHRva2VuX3N0cmluZyBpYiBpblxuICAgIGxldCBmbXQsIGZtdCcgPVxuICAgICAgdHJ5XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdCA9IGZtdF9lYmJfb2Zfc3RyaW5nIHMgaW5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10JyA9IGZtdF9lYmJfb2Zfc3RyaW5nIHMgaW5cbiAgICAgICAgKCogVE9ETzogZmluZCBhIHdheSB0byBhdm9pZCByZXBhcnNpbmcgdHdpY2UgKilcblxuICAgICAgICAoKiBUT0RPOiB0aGVzZSB0eXBlLWNoZWNrcyBiZWxvdyAqY2FuKiBmYWlsIGJlY2F1c2Ugb2YgdHlwZVxuICAgICAgICAgICBhbWJpZ3VpdHkgaW4gcHJlc2VuY2Ugb2YgaWdub3JlZC1yZWFkZXJzOiBcIiVfciVkXCIgYW5kIFwiJWQlX3JcIlxuICAgICAgICAgICBhcmUgdHlwZWQgaW4gdGhlIHNhbWUgd2F5LlxuXG4gICAgICAgICAgICMgU2NhbmYuc3NjYW5mIFwiXFxcIiVfciVkXFxcIjNcIiBcIiUoJWQlX3IlKVwiIGlnbm9yZVxuICAgICAgICAgICAgIChmdW4gZm10IG4gLT4gc3RyaW5nX29mX2Zvcm1hdCBmbXQsIG4pXG4gICAgICAgICAgIEV4Y2VwdGlvbjogQ2FtbGludGVybmFsRm9ybWF0LlR5cGVfbWlzbWF0Y2guXG5cbiAgICAgICAgICAgV2Ugc2hvdWxkIHByb3Blcmx5IGNhdGNoIHRoaXMgZXhjZXB0aW9uLlxuICAgICAgICAqKVxuICAgICAgICB0eXBlX2Zvcm1hdCBmbXQgKGVyYXNlX3JlbCBmbXR0eSksXG4gICAgICAgIHR5cGVfZm9ybWF0IGZtdCcgKGVyYXNlX3JlbCAoc3ltbSBmbXR0eSkpXG4gICAgICB3aXRoIEZhaWx1cmUgbXNnIC0+IGJhZF9pbnB1dCBtc2dcbiAgICBpblxuICAgIENvbnMgKEZvcm1hdCAoZm10LCBzKSxcbiAgICAgICAgICBtYWtlX3NjYW5mIGliIChjb25jYXRfZm10IGZtdCcgcmVzdCkgcmVhZGVycylcblxuICB8IFNjYW5fY2hhcl9zZXQgKHdpZHRoX29wdCwgY2hhcl9zZXQsIEZvcm1hdHRpbmdfbGl0IChmbXRpbmdfbGl0LCByZXN0KSkgLT5cbiAgICBsZXQgc3RwLCBzdHIgPSBzdG9wcGVyX29mX2Zvcm1hdHRpbmdfbGl0IGZtdGluZ19saXQgaW5cbiAgICBsZXQgd2lkdGggPSB3aWR0aF9vZl9wYWRfb3B0IHdpZHRoX29wdCBpblxuICAgIHNjYW5fY2hhcnNfaW5fY2hhcl9zZXQgY2hhcl9zZXQgKFNvbWUgc3RwKSB3aWR0aCBpYjtcbiAgICBsZXQgcyA9IHRva2VuX3N0cmluZyBpYiBpblxuICAgIGxldCBzdHJfcmVzdCA9IFN0cmluZ19saXRlcmFsIChzdHIsIHJlc3QpIGluXG4gICAgQ29ucyAocywgbWFrZV9zY2FuZiBpYiBzdHJfcmVzdCByZWFkZXJzKVxuICB8IFNjYW5fY2hhcl9zZXQgKHdpZHRoX29wdCwgY2hhcl9zZXQsIHJlc3QpIC0+XG4gICAgbGV0IHdpZHRoID0gd2lkdGhfb2ZfcGFkX29wdCB3aWR0aF9vcHQgaW5cbiAgICBzY2FuX2NoYXJzX2luX2NoYXJfc2V0IGNoYXJfc2V0IE5vbmUgd2lkdGggaWI7XG4gICAgbGV0IHMgPSB0b2tlbl9zdHJpbmcgaWIgaW5cbiAgICBDb25zIChzLCBtYWtlX3NjYW5mIGliIHJlc3QgcmVhZGVycylcbiAgfCBTY2FuX2dldF9jb3VudGVyIChjb3VudGVyLCByZXN0KSAtPlxuICAgIGxldCBjb3VudCA9IGdldF9jb3VudGVyIGliIGNvdW50ZXIgaW5cbiAgICBDb25zIChjb3VudCwgbWFrZV9zY2FuZiBpYiByZXN0IHJlYWRlcnMpXG4gIHwgU2Nhbl9uZXh0X2NoYXIgcmVzdCAtPlxuICAgIGxldCBjID0gU2Nhbm5pbmcuY2hlY2tlZF9wZWVrX2NoYXIgaWIgaW5cbiAgICBDb25zIChjLCBtYWtlX3NjYW5mIGliIHJlc3QgcmVhZGVycylcblxuICB8IEZvcm1hdHRpbmdfbGl0IChmb3JtYXR0aW5nX2xpdCwgcmVzdCkgLT5cbiAgICBTdHJpbmcuaXRlciAoY2hlY2tfY2hhciBpYikgKHN0cmluZ19vZl9mb3JtYXR0aW5nX2xpdCBmb3JtYXR0aW5nX2xpdCk7XG4gICAgbWFrZV9zY2FuZiBpYiByZXN0IHJlYWRlcnNcbiAgfCBGb3JtYXR0aW5nX2dlbiAoT3Blbl90YWcgKEZvcm1hdCAoZm10JywgXykpLCByZXN0KSAtPlxuICAgIGNoZWNrX2NoYXIgaWIgJ0AnOyBjaGVja19jaGFyIGliICd7JztcbiAgICBtYWtlX3NjYW5mIGliIChjb25jYXRfZm10IGZtdCcgcmVzdCkgcmVhZGVyc1xuICB8IEZvcm1hdHRpbmdfZ2VuIChPcGVuX2JveCAoRm9ybWF0IChmbXQnLCBfKSksIHJlc3QpIC0+XG4gICAgY2hlY2tfY2hhciBpYiAnQCc7IGNoZWNrX2NoYXIgaWIgJ1snO1xuICAgIG1ha2Vfc2NhbmYgaWIgKGNvbmNhdF9mbXQgZm10JyByZXN0KSByZWFkZXJzXG5cbiAgfCBJZ25vcmVkX3BhcmFtIChpZ24sIHJlc3QpIC0+XG4gICAgbGV0IFBhcmFtX2Zvcm1hdF9FQkIgZm10JyA9IHBhcmFtX2Zvcm1hdF9vZl9pZ25vcmVkX2Zvcm1hdCBpZ24gcmVzdCBpblxuICAgIGJlZ2luIG1hdGNoIG1ha2Vfc2NhbmYgaWIgZm10JyByZWFkZXJzIHdpdGhcbiAgICB8IENvbnMgKF8sIGFyZ19yZXN0KSAtPiBhcmdfcmVzdFxuICAgIHwgTmlsIC0+IGFzc2VydCBmYWxzZVxuICAgIGVuZFxuXG4gIHwgRW5kX29mX2Zvcm1hdCAtPlxuICAgIE5pbFxuXG4oKiBDYXNlIGFuYWx5c2lzIG9uIHBhZGRpbmcgYW5kIHByZWNpc2lvbi4gKilcbigqIFJlamVjdCBmb3JtYXRzIGNvbnRhaW5pbmcgXCIlKlwiIG9yIFwiJS4qXCIuICopXG4oKiBQYXNzIHBhZGRpbmcgYW5kIHByZWNpc2lvbiB0byB0aGUgZ2VuZXJpYyBzY2FubmVyIGBzY2FuJy4gKilcbmFuZCBwYWRfcHJlY19zY2FuZiA6IHR5cGUgYSBjIGQgZSBmIHggeSB6IHQgLlxuICAgIFNjYW5uaW5nLmluX2NoYW5uZWwgLT4gKGEsIFNjYW5uaW5nLmluX2NoYW5uZWwsIGMsIGQsIGUsIGYpIGZtdCAtPlxuICAgICAgKGQsIGUpIGhldGVyX2xpc3QgLT4gKHgsIHkpIHBhZGRpbmcgLT4gKHksIHogLT4gYSkgcHJlY2lzaW9uIC0+XG4gICAgICAoaW50IC0+IGludCAtPiBTY2FubmluZy5pbl9jaGFubmVsIC0+IHQpIC0+XG4gICAgICAoU2Nhbm5pbmcuaW5fY2hhbm5lbCAtPiB6KSAtPlxuICAgICAgKHgsIGYpIGhldGVyX2xpc3QgPVxuZnVuIGliIGZtdCByZWFkZXJzIHBhZCBwcmVjIHNjYW4gdG9rZW4gLT4gbWF0Y2ggcGFkLCBwcmVjIHdpdGhcbiAgfCBOb19wYWRkaW5nLCBOb19wcmVjaXNpb24gLT5cbiAgICBsZXQgXyA9IHNjYW4gbWF4X2ludCBtYXhfaW50IGliIGluXG4gICAgbGV0IHggPSB0b2tlbiBpYiBpblxuICAgIENvbnMgKHgsIG1ha2Vfc2NhbmYgaWIgZm10IHJlYWRlcnMpXG4gIHwgTm9fcGFkZGluZywgTGl0X3ByZWNpc2lvbiBwIC0+XG4gICAgbGV0IF8gPSBzY2FuIG1heF9pbnQgcCBpYiBpblxuICAgIGxldCB4ID0gdG9rZW4gaWIgaW5cbiAgICBDb25zICh4LCBtYWtlX3NjYW5mIGliIGZtdCByZWFkZXJzKVxuICB8IExpdF9wYWRkaW5nICgoUmlnaHQgfCBaZXJvcyksIHcpLCBOb19wcmVjaXNpb24gLT5cbiAgICBsZXQgXyA9IHNjYW4gdyBtYXhfaW50IGliIGluXG4gICAgbGV0IHggPSB0b2tlbiBpYiBpblxuICAgIENvbnMgKHgsIG1ha2Vfc2NhbmYgaWIgZm10IHJlYWRlcnMpXG4gIHwgTGl0X3BhZGRpbmcgKChSaWdodCB8IFplcm9zKSwgdyksIExpdF9wcmVjaXNpb24gcCAtPlxuICAgIGxldCBfID0gc2NhbiB3IHAgaWIgaW5cbiAgICBsZXQgeCA9IHRva2VuIGliIGluXG4gICAgQ29ucyAoeCwgbWFrZV9zY2FuZiBpYiBmbXQgcmVhZGVycylcbiAgfCBMaXRfcGFkZGluZyAoTGVmdCwgXyksIF8gLT5cbiAgICBpbnZhbGlkX2FyZyBcInNjYW5mOiBiYWQgY29udmVyc2lvbiBcXFwiJS1cXFwiXCJcbiAgfCBMaXRfcGFkZGluZyAoKFJpZ2h0IHwgWmVyb3MpLCBfKSwgQXJnX3ByZWNpc2lvbiAtPlxuICAgIGludmFsaWRfYXJnIFwic2NhbmY6IGJhZCBjb252ZXJzaW9uIFxcXCIlKlxcXCJcIlxuICB8IEFyZ19wYWRkaW5nIF8sIF8gLT5cbiAgICBpbnZhbGlkX2FyZyBcInNjYW5mOiBiYWQgY29udmVyc2lvbiBcXFwiJSpcXFwiXCJcbiAgfCBOb19wYWRkaW5nLCBBcmdfcHJlY2lzaW9uIC0+XG4gICAgaW52YWxpZF9hcmcgXCJzY2FuZjogYmFkIGNvbnZlcnNpb24gXFxcIiUqXFxcIlwiXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAoKiBEZWZpbmluZyBbc2NhbmZdIGFuZCB2YXJpb3VzIGZsYXZvcnMgb2YgW3NjYW5mXSAqKVxuXG50eXBlICdhIGtzY2FuZl9yZXN1bHQgPSBBcmdzIG9mICdhIHwgRXhjIG9mIGV4blxuXG5sZXQga3NjYW5mIGliIGVmIChGb3JtYXQgKGZtdCwgc3RyKSkgPVxuICBsZXQgcmVjIGFwcGx5IDogdHlwZSBhIGIgLiBhIC0+IChhLCBiKSBoZXRlcl9saXN0IC0+IGIgPVxuICAgIGZ1biBmIGFyZ3MgLT4gbWF0Y2ggYXJncyB3aXRoXG4gICAgfCBDb25zICh4LCByKSAtPiBhcHBseSAoZiB4KSByXG4gICAgfCBOaWwgLT4gZlxuICBpblxuICBsZXQgayByZWFkZXJzIGYgPVxuICAgIFNjYW5uaW5nLnJlc2V0X3Rva2VuIGliO1xuICAgIG1hdGNoIHRyeSBBcmdzIChtYWtlX3NjYW5mIGliIGZtdCByZWFkZXJzKSB3aXRoXG4gICAgICB8IChTY2FuX2ZhaWx1cmUgXyB8IEZhaWx1cmUgXyB8IEVuZF9vZl9maWxlKSBhcyBleGMgLT4gRXhjIGV4Y1xuICAgICAgfCBJbnZhbGlkX2FyZ3VtZW50IG1zZyAtPlxuICAgICAgICBpbnZhbGlkX2FyZyAobXNnIF4gXCIgaW4gZm9ybWF0IFxcXCJcIiBeIFN0cmluZy5lc2NhcGVkIHN0ciBeIFwiXFxcIlwiKVxuICAgIHdpdGhcbiAgICAgIHwgQXJncyBhcmdzIC0+IGFwcGx5IGYgYXJnc1xuICAgICAgfCBFeGMgZXhjIC0+IGVmIGliIGV4Y1xuICBpblxuICB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG5cbigqKiopXG5cbmxldCBrYnNjYW5mID0ga3NjYW5mXG5sZXQgYnNjYW5mIGliIGZtdCA9IGtic2NhbmYgaWIgc2NhbmZfYmFkX2lucHV0IGZtdFxuXG5sZXQga3NzY2FuZiBzIGVmIGZtdCA9IGtic2NhbmYgKFNjYW5uaW5nLmZyb21fc3RyaW5nIHMpIGVmIGZtdFxubGV0IHNzY2FuZiBzIGZtdCA9IGtic2NhbmYgKFNjYW5uaW5nLmZyb21fc3RyaW5nIHMpIHNjYW5mX2JhZF9pbnB1dCBmbXRcblxubGV0IHNjYW5mIGZtdCA9IGtzY2FuZiBTY2FubmluZy5zdGRpYiBzY2FuZl9iYWRfaW5wdXQgZm10XG5cbigqKiopXG5cbigqIFNjYW5uaW5nIGZvcm1hdCBzdHJpbmdzLiAqKVxubGV0IGJzY2FuZl9mb3JtYXQgOlxuICBTY2FubmluZy5pbl9jaGFubmVsIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2IC0+XG4gICgoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiAtPiAnZykgLT4gJ2cgPVxuICBmdW4gaWIgZm9ybWF0IGYgLT5cbiAgICBsZXQgXyA9IHNjYW5fY2FtbF9zdHJpbmcgbWF4X2ludCBpYiBpblxuICAgIGxldCBzdHIgPSB0b2tlbl9zdHJpbmcgaWIgaW5cbiAgICBsZXQgZm10JyA9XG4gICAgICB0cnkgZm9ybWF0X29mX3N0cmluZ19mb3JtYXQgc3RyIGZvcm1hdFxuICAgICAgd2l0aCBGYWlsdXJlIG1zZyAtPiBiYWRfaW5wdXQgbXNnIGluXG4gICAgZiBmbXQnXG5cblxubGV0IHNzY2FuZl9mb3JtYXQgOlxuICBzdHJpbmcgLT4gKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgLT5cbiAgKCgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2IC0+ICdnKSAtPiAnZyA9XG4gIGZ1biBzIGZvcm1hdCBmIC0+IGJzY2FuZl9mb3JtYXQgKFNjYW5uaW5nLmZyb21fc3RyaW5nIHMpIGZvcm1hdCBmXG5cblxubGV0IGZvcm1hdF9mcm9tX3N0cmluZyBzIGZtdCA9XG4gIHNzY2FuZl9mb3JtYXQgKFwiXFxcIlwiIF4gU3RyaW5nLmVzY2FwZWQgcyBeIFwiXFxcIlwiKSBmbXQgKGZ1biB4IC0+IHgpXG5cblxubGV0IHVuZXNjYXBlZCBzID1cbiAgc3NjYW5mIChcIlxcXCJcIiBeIHMgXiBcIlxcXCJcIikgXCIlUyUhXCIgKGZ1biB4IC0+IHgpXG5cblxuKCogRGVwcmVjYXRlZCAqKVxubGV0IGtmc2NhbmYgaWMgZWYgZm10ID0ga2JzY2FuZiAoU2Nhbm5pbmcubWVtb19mcm9tX2NoYW5uZWwgaWMpIGVmIGZtdFxubGV0IGZzY2FuZiBpYyBmbXQgPSBrc2NhbmYgKFNjYW5uaW5nLm1lbW9fZnJvbV9jaGFubmVsIGljKSBzY2FuZl9iYWRfaW5wdXQgZm10XG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIFJlZ2lzdGVyaW5nIE9DYW1sIHZhbHVlcyB3aXRoIHRoZSBDIHJ1bnRpbWUgZm9yIGxhdGVyIGNhbGxiYWNrcyAqKVxuXG5leHRlcm5hbCByZWdpc3Rlcl9uYW1lZF92YWx1ZSA6IHN0cmluZyAtPiBPYmoudCAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9yZWdpc3Rlcl9uYW1lZF92YWx1ZVwiXG5cbmxldCByZWdpc3RlciBuYW1lIHYgPVxuICByZWdpc3Rlcl9uYW1lZF92YWx1ZSBuYW1lIChPYmoucmVwciB2KVxuXG5sZXQgcmVnaXN0ZXJfZXhjZXB0aW9uIG5hbWUgKGV4biA6IGV4bikgPVxuICBsZXQgZXhuID0gT2JqLnJlcHIgZXhuIGluXG4gIGxldCBzbG90ID0gaWYgT2JqLnRhZyBleG4gPSBPYmoub2JqZWN0X3RhZyB0aGVuIGV4biBlbHNlIE9iai5maWVsZCBleG4gMCBpblxuICByZWdpc3Rlcl9uYW1lZF92YWx1ZSBuYW1lIHNsb3RcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgIEplcm9tZSBWb3VpbGxvbiwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMDIgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxub3BlbiBPYmpcblxuKCoqKiogT2JqZWN0IHJlcHJlc2VudGF0aW9uICoqKiopXG5cbmV4dGVybmFsIHNldF9pZDogJ2EgLT4gJ2EgPSBcImNhbWxfc2V0X29vX2lkXCIgW0BAbm9hbGxvY11cblxuKCoqKiogT2JqZWN0IGNvcHkgKioqKilcblxubGV0IGNvcHkgbyA9XG4gIGxldCBvID0gKE9iai5vYmogKE9iai5kdXAgKE9iai5yZXByIG8pKSkgaW5cbiAgc2V0X2lkIG9cblxuKCoqKiogQ29tcHJlc3Npb24gb3B0aW9ucyAqKioqKVxuKCogUGFyYW1ldGVycyAqKVxudHlwZSBwYXJhbXMgPSB7XG4gICAgbXV0YWJsZSBjb21wYWN0X3RhYmxlIDogYm9vbDtcbiAgICBtdXRhYmxlIGNvcHlfcGFyZW50IDogYm9vbDtcbiAgICBtdXRhYmxlIGNsZWFuX3doZW5fY29weWluZyA6IGJvb2w7XG4gICAgbXV0YWJsZSByZXRyeV9jb3VudCA6IGludDtcbiAgICBtdXRhYmxlIGJ1Y2tldF9zbWFsbF9zaXplIDogaW50XG4gIH1cblxubGV0IHBhcmFtcyA9IHtcbiAgY29tcGFjdF90YWJsZSA9IHRydWU7XG4gIGNvcHlfcGFyZW50ID0gdHJ1ZTtcbiAgY2xlYW5fd2hlbl9jb3B5aW5nID0gdHJ1ZTtcbiAgcmV0cnlfY291bnQgPSAzO1xuICBidWNrZXRfc21hbGxfc2l6ZSA9IDE2XG59XG5cbigqKioqIFBhcmFtZXRlcnMgKioqKilcblxubGV0IGluaXRpYWxfb2JqZWN0X3NpemUgPSAyXG5cbigqKioqIEl0ZW1zICoqKiopXG5cbnR5cGUgaXRlbSA9IER1bW15QSB8IER1bW15QiB8IER1bW15QyBvZiBpbnRcbmxldCBfID0gW0R1bW15QTsgRHVtbXlCOyBEdW1teUMgMF0gKCogdG8gYXZvaWQgd2FybmluZ3MgKilcblxubGV0IGR1bW15X2l0ZW0gPSAobWFnaWMgKCkgOiBpdGVtKVxuXG4oKioqKiBUeXBlcyAqKioqKVxuXG50eXBlIHRhZ1xudHlwZSBsYWJlbCA9IGludFxudHlwZSBjbG9zdXJlID0gaXRlbVxudHlwZSB0ID0gRHVtbXlBIHwgRHVtbXlCIHwgRHVtbXlDIG9mIGludFxubGV0IF8gPSBbRHVtbXlBOyBEdW1teUI7IER1bW15QyAwXSAoKiB0byBhdm9pZCB3YXJuaW5ncyAqKVxuXG50eXBlIG9iaiA9IHQgYXJyYXlcbmV4dGVybmFsIHJldCA6IChvYmogLT4gJ2EpIC0+IGNsb3N1cmUgPSBcIiVpZGVudGl0eVwiXG5cbigqKioqIExhYmVscyAqKioqKVxuXG5sZXQgcHVibGljX21ldGhvZF9sYWJlbCBzIDogdGFnID1cbiAgbGV0IGFjY3UgPSByZWYgMCBpblxuICBmb3IgaSA9IDAgdG8gU3RyaW5nLmxlbmd0aCBzIC0gMSBkb1xuICAgIGFjY3UgOj0gMjIzICogIWFjY3UgKyBDaGFyLmNvZGUgcy5baV1cbiAgZG9uZTtcbiAgKCogcmVkdWNlIHRvIDMxIGJpdHMgKilcbiAgYWNjdSA6PSAhYWNjdSBsYW5kICgxIGxzbCAzMSAtIDEpO1xuICAoKiBtYWtlIGl0IHNpZ25lZCBmb3IgNjQgYml0cyBhcmNoaXRlY3R1cmVzICopXG4gIGxldCB0YWcgPSBpZiAhYWNjdSA+IDB4M0ZGRkZGRkYgdGhlbiAhYWNjdSAtICgxIGxzbCAzMSkgZWxzZSAhYWNjdSBpblxuICAoKiBQcmludGYuZXByaW50ZiBcIiVzID0gJWRcXG5cIiBzIHRhZzsgZmx1c2ggc3RkZXJyOyAqKVxuICBtYWdpYyB0YWdcblxuKCoqKiogU3BhcnNlIGFycmF5ICoqKiopXG5cbm1vZHVsZSBWYXJzID1cbiAgTWFwLk1ha2Uoc3RydWN0IHR5cGUgdCA9IHN0cmluZyBsZXQgY29tcGFyZSAoeDp0KSB5ID0gY29tcGFyZSB4IHkgZW5kKVxudHlwZSB2YXJzID0gaW50IFZhcnMudFxuXG5tb2R1bGUgTWV0aHMgPVxuICBNYXAuTWFrZShzdHJ1Y3QgdHlwZSB0ID0gc3RyaW5nIGxldCBjb21wYXJlICh4OnQpIHkgPSBjb21wYXJlIHggeSBlbmQpXG50eXBlIG1ldGhzID0gbGFiZWwgTWV0aHMudFxubW9kdWxlIExhYnMgPVxuICBNYXAuTWFrZShzdHJ1Y3QgdHlwZSB0ID0gbGFiZWwgbGV0IGNvbXBhcmUgKHg6dCkgeSA9IGNvbXBhcmUgeCB5IGVuZClcbnR5cGUgbGFicyA9IGJvb2wgTGFicy50XG5cbigqIFRoZSBjb21waWxlciBhc3N1bWVzIHRoYXQgdGhlIGZpcnN0IGZpZWxkIG9mIHRoaXMgc3RydWN0dXJlIGlzIFtzaXplXS4gKilcbnR5cGUgdGFibGUgPVxuIHsgbXV0YWJsZSBzaXplOiBpbnQ7XG4gICBtdXRhYmxlIG1ldGhvZHM6IGNsb3N1cmUgYXJyYXk7XG4gICBtdXRhYmxlIG1ldGhvZHNfYnlfbmFtZTogbWV0aHM7XG4gICBtdXRhYmxlIG1ldGhvZHNfYnlfbGFiZWw6IGxhYnM7XG4gICBtdXRhYmxlIHByZXZpb3VzX3N0YXRlczpcbiAgICAgKG1ldGhzICogbGFicyAqIChsYWJlbCAqIGl0ZW0pIGxpc3QgKiB2YXJzICpcbiAgICAgIGxhYmVsIGxpc3QgKiBzdHJpbmcgbGlzdCkgbGlzdDtcbiAgIG11dGFibGUgaGlkZGVuX21ldGhzOiAobGFiZWwgKiBpdGVtKSBsaXN0O1xuICAgbXV0YWJsZSB2YXJzOiB2YXJzO1xuICAgbXV0YWJsZSBpbml0aWFsaXplcnM6IChvYmogLT4gdW5pdCkgbGlzdCB9XG5cbmxldCBkdW1teV90YWJsZSA9XG4gIHsgbWV0aG9kcyA9IFt8IGR1bW15X2l0ZW0gfF07XG4gICAgbWV0aG9kc19ieV9uYW1lID0gTWV0aHMuZW1wdHk7XG4gICAgbWV0aG9kc19ieV9sYWJlbCA9IExhYnMuZW1wdHk7XG4gICAgcHJldmlvdXNfc3RhdGVzID0gW107XG4gICAgaGlkZGVuX21ldGhzID0gW107XG4gICAgdmFycyA9IFZhcnMuZW1wdHk7XG4gICAgaW5pdGlhbGl6ZXJzID0gW107XG4gICAgc2l6ZSA9IDAgfVxuXG5sZXQgdGFibGVfY291bnQgPSByZWYgMFxuXG4oKiBkdW1teV9tZXQgc2hvdWxkIGJlIGEgcG9pbnRlciwgc28gdXNlIGFuIGF0b20gKilcbmxldCBkdW1teV9tZXQgOiBpdGVtID0gb2JqIChPYmoubmV3X2Jsb2NrIDAgMClcbigqIGlmIGRlYnVnZ2luZyBpcyBuZWVkZWQsIHRoaXMgY291bGQgYmUgYSBnb29kIGlkZWE6ICopXG4oKiBsZXQgZHVtbXlfbWV0ICgpID0gZmFpbHdpdGggXCJVbmRlZmluZWQgbWV0aG9kXCIgKilcblxubGV0IHJlYyBmaXRfc2l6ZSBuID1cbiAgaWYgbiA8PSAyIHRoZW4gbiBlbHNlXG4gIGZpdF9zaXplICgobisxKS8yKSAqIDJcblxubGV0IG5ld190YWJsZSBwdWJfbGFiZWxzID1cbiAgaW5jciB0YWJsZV9jb3VudDtcbiAgbGV0IGxlbiA9IEFycmF5Lmxlbmd0aCBwdWJfbGFiZWxzIGluXG4gIGxldCBtZXRob2RzID0gQXJyYXkubWFrZSAobGVuKjIrMikgZHVtbXlfbWV0IGluXG4gIG1ldGhvZHMuKDApIDwtIG1hZ2ljIGxlbjtcbiAgbWV0aG9kcy4oMSkgPC0gbWFnaWMgKGZpdF9zaXplIGxlbiAqIFN5cy53b3JkX3NpemUgLyA4IC0gMSk7XG4gIGZvciBpID0gMCB0byBsZW4gLSAxIGRvIG1ldGhvZHMuKGkqMiszKSA8LSBtYWdpYyBwdWJfbGFiZWxzLihpKSBkb25lO1xuICB7IG1ldGhvZHMgPSBtZXRob2RzO1xuICAgIG1ldGhvZHNfYnlfbmFtZSA9IE1ldGhzLmVtcHR5O1xuICAgIG1ldGhvZHNfYnlfbGFiZWwgPSBMYWJzLmVtcHR5O1xuICAgIHByZXZpb3VzX3N0YXRlcyA9IFtdO1xuICAgIGhpZGRlbl9tZXRocyA9IFtdO1xuICAgIHZhcnMgPSBWYXJzLmVtcHR5O1xuICAgIGluaXRpYWxpemVycyA9IFtdO1xuICAgIHNpemUgPSBpbml0aWFsX29iamVjdF9zaXplIH1cblxubGV0IHJlc2l6ZSBhcnJheSBuZXdfc2l6ZSA9XG4gIGxldCBvbGRfc2l6ZSA9IEFycmF5Lmxlbmd0aCBhcnJheS5tZXRob2RzIGluXG4gIGlmIG5ld19zaXplID4gb2xkX3NpemUgdGhlbiBiZWdpblxuICAgIGxldCBuZXdfYnVjayA9IEFycmF5Lm1ha2UgbmV3X3NpemUgZHVtbXlfbWV0IGluXG4gICAgQXJyYXkuYmxpdCBhcnJheS5tZXRob2RzIDAgbmV3X2J1Y2sgMCBvbGRfc2l6ZTtcbiAgICBhcnJheS5tZXRob2RzIDwtIG5ld19idWNrXG4gZW5kXG5cbmxldCBwdXQgYXJyYXkgbGFiZWwgZWxlbWVudCA9XG4gIHJlc2l6ZSBhcnJheSAobGFiZWwgKyAxKTtcbiAgYXJyYXkubWV0aG9kcy4obGFiZWwpIDwtIGVsZW1lbnRcblxuKCoqKiogQ2xhc3NlcyAqKioqKVxuXG5sZXQgbWV0aG9kX2NvdW50ID0gcmVmIDBcbmxldCBpbnN0X3Zhcl9jb3VudCA9IHJlZiAwXG5cbigqIHR5cGUgdCAqKVxudHlwZSBtZXRoID0gaXRlbVxuXG5sZXQgbmV3X21ldGhvZCB0YWJsZSA9XG4gIGxldCBpbmRleCA9IEFycmF5Lmxlbmd0aCB0YWJsZS5tZXRob2RzIGluXG4gIHJlc2l6ZSB0YWJsZSAoaW5kZXggKyAxKTtcbiAgaW5kZXhcblxubGV0IGdldF9tZXRob2RfbGFiZWwgdGFibGUgbmFtZSA9XG4gIHRyeVxuICAgIE1ldGhzLmZpbmQgbmFtZSB0YWJsZS5tZXRob2RzX2J5X25hbWVcbiAgd2l0aCBOb3RfZm91bmQgLT5cbiAgICBsZXQgbGFiZWwgPSBuZXdfbWV0aG9kIHRhYmxlIGluXG4gICAgdGFibGUubWV0aG9kc19ieV9uYW1lIDwtIE1ldGhzLmFkZCBuYW1lIGxhYmVsIHRhYmxlLm1ldGhvZHNfYnlfbmFtZTtcbiAgICB0YWJsZS5tZXRob2RzX2J5X2xhYmVsIDwtIExhYnMuYWRkIGxhYmVsIHRydWUgdGFibGUubWV0aG9kc19ieV9sYWJlbDtcbiAgICBsYWJlbFxuXG5sZXQgZ2V0X21ldGhvZF9sYWJlbHMgdGFibGUgbmFtZXMgPVxuICBBcnJheS5tYXAgKGdldF9tZXRob2RfbGFiZWwgdGFibGUpIG5hbWVzXG5cbmxldCBzZXRfbWV0aG9kIHRhYmxlIGxhYmVsIGVsZW1lbnQgPVxuICBpbmNyIG1ldGhvZF9jb3VudDtcbiAgaWYgTGFicy5maW5kIGxhYmVsIHRhYmxlLm1ldGhvZHNfYnlfbGFiZWwgdGhlblxuICAgIHB1dCB0YWJsZSBsYWJlbCBlbGVtZW50XG4gIGVsc2VcbiAgICB0YWJsZS5oaWRkZW5fbWV0aHMgPC0gKGxhYmVsLCBlbGVtZW50KSA6OiB0YWJsZS5oaWRkZW5fbWV0aHNcblxubGV0IGdldF9tZXRob2QgdGFibGUgbGFiZWwgPVxuICB0cnkgTGlzdC5hc3NvYyBsYWJlbCB0YWJsZS5oaWRkZW5fbWV0aHNcbiAgd2l0aCBOb3RfZm91bmQgLT4gdGFibGUubWV0aG9kcy4obGFiZWwpXG5cbmxldCB0b19saXN0IGFyciA9XG4gIGlmIGFyciA9PSBtYWdpYyAwIHRoZW4gW10gZWxzZSBBcnJheS50b19saXN0IGFyclxuXG5sZXQgbmFycm93IHRhYmxlIHZhcnMgdmlydF9tZXRocyBjb25jcl9tZXRocyA9XG4gIGxldCB2YXJzID0gdG9fbGlzdCB2YXJzXG4gIGFuZCB2aXJ0X21ldGhzID0gdG9fbGlzdCB2aXJ0X21ldGhzXG4gIGFuZCBjb25jcl9tZXRocyA9IHRvX2xpc3QgY29uY3JfbWV0aHMgaW5cbiAgbGV0IHZpcnRfbWV0aF9sYWJzID0gTGlzdC5tYXAgKGdldF9tZXRob2RfbGFiZWwgdGFibGUpIHZpcnRfbWV0aHMgaW5cbiAgbGV0IGNvbmNyX21ldGhfbGFicyA9IExpc3QubWFwIChnZXRfbWV0aG9kX2xhYmVsIHRhYmxlKSBjb25jcl9tZXRocyBpblxuICB0YWJsZS5wcmV2aW91c19zdGF0ZXMgPC1cbiAgICAgKHRhYmxlLm1ldGhvZHNfYnlfbmFtZSwgdGFibGUubWV0aG9kc19ieV9sYWJlbCwgdGFibGUuaGlkZGVuX21ldGhzLFxuICAgICAgdGFibGUudmFycywgdmlydF9tZXRoX2xhYnMsIHZhcnMpXG4gICAgIDo6IHRhYmxlLnByZXZpb3VzX3N0YXRlcztcbiAgdGFibGUudmFycyA8LVxuICAgIFZhcnMuZm9sZFxuICAgICAgKGZ1biBsYWIgaW5mbyB0dmFycyAtPlxuICAgICAgICBpZiBMaXN0Lm1lbSBsYWIgdmFycyB0aGVuIFZhcnMuYWRkIGxhYiBpbmZvIHR2YXJzIGVsc2UgdHZhcnMpXG4gICAgICB0YWJsZS52YXJzIFZhcnMuZW1wdHk7XG4gIGxldCBieV9uYW1lID0gcmVmIE1ldGhzLmVtcHR5IGluXG4gIGxldCBieV9sYWJlbCA9IHJlZiBMYWJzLmVtcHR5IGluXG4gIExpc3QuaXRlcjJcbiAgICAoZnVuIG1ldCBsYWJlbCAtPlxuICAgICAgIGJ5X25hbWUgOj0gTWV0aHMuYWRkIG1ldCBsYWJlbCAhYnlfbmFtZTtcbiAgICAgICBieV9sYWJlbCA6PVxuICAgICAgICAgIExhYnMuYWRkIGxhYmVsXG4gICAgICAgICAgICAodHJ5IExhYnMuZmluZCBsYWJlbCB0YWJsZS5tZXRob2RzX2J5X2xhYmVsIHdpdGggTm90X2ZvdW5kIC0+IHRydWUpXG4gICAgICAgICAgICAhYnlfbGFiZWwpXG4gICAgY29uY3JfbWV0aHMgY29uY3JfbWV0aF9sYWJzO1xuICBMaXN0Lml0ZXIyXG4gICAgKGZ1biBtZXQgbGFiZWwgLT5cbiAgICAgICBieV9uYW1lIDo9IE1ldGhzLmFkZCBtZXQgbGFiZWwgIWJ5X25hbWU7XG4gICAgICAgYnlfbGFiZWwgOj0gTGFicy5hZGQgbGFiZWwgZmFsc2UgIWJ5X2xhYmVsKVxuICAgIHZpcnRfbWV0aHMgdmlydF9tZXRoX2xhYnM7XG4gIHRhYmxlLm1ldGhvZHNfYnlfbmFtZSA8LSAhYnlfbmFtZTtcbiAgdGFibGUubWV0aG9kc19ieV9sYWJlbCA8LSAhYnlfbGFiZWw7XG4gIHRhYmxlLmhpZGRlbl9tZXRocyA8LVxuICAgICBMaXN0LmZvbGRfcmlnaHRcbiAgICAgICAoZnVuICgobGFiLCBfKSBhcyBtZXQpIGhtIC0+XG4gICAgICAgICAgaWYgTGlzdC5tZW0gbGFiIHZpcnRfbWV0aF9sYWJzIHRoZW4gaG0gZWxzZSBtZXQ6OmhtKVxuICAgICAgIHRhYmxlLmhpZGRlbl9tZXRoc1xuICAgICAgIFtdXG5cbmxldCB3aWRlbiB0YWJsZSA9XG4gIGxldCAoYnlfbmFtZSwgYnlfbGFiZWwsIHNhdmVkX2hpZGRlbl9tZXRocywgc2F2ZWRfdmFycywgdmlydF9tZXRocywgdmFycykgPVxuICAgIExpc3QuaGQgdGFibGUucHJldmlvdXNfc3RhdGVzXG4gIGluXG4gIHRhYmxlLnByZXZpb3VzX3N0YXRlcyA8LSBMaXN0LnRsIHRhYmxlLnByZXZpb3VzX3N0YXRlcztcbiAgdGFibGUudmFycyA8LVxuICAgICBMaXN0LmZvbGRfbGVmdFxuICAgICAgIChmdW4gcyB2IC0+IFZhcnMuYWRkIHYgKFZhcnMuZmluZCB2IHRhYmxlLnZhcnMpIHMpXG4gICAgICAgc2F2ZWRfdmFycyB2YXJzO1xuICB0YWJsZS5tZXRob2RzX2J5X25hbWUgPC0gYnlfbmFtZTtcbiAgdGFibGUubWV0aG9kc19ieV9sYWJlbCA8LSBieV9sYWJlbDtcbiAgdGFibGUuaGlkZGVuX21ldGhzIDwtXG4gICAgIExpc3QuZm9sZF9yaWdodFxuICAgICAgIChmdW4gKChsYWIsIF8pIGFzIG1ldCkgaG0gLT5cbiAgICAgICAgICBpZiBMaXN0Lm1lbSBsYWIgdmlydF9tZXRocyB0aGVuIGhtIGVsc2UgbWV0OjpobSlcbiAgICAgICB0YWJsZS5oaWRkZW5fbWV0aHNcbiAgICAgICBzYXZlZF9oaWRkZW5fbWV0aHNcblxubGV0IG5ld19zbG90IHRhYmxlID1cbiAgbGV0IGluZGV4ID0gdGFibGUuc2l6ZSBpblxuICB0YWJsZS5zaXplIDwtIGluZGV4ICsgMTtcbiAgaW5kZXhcblxubGV0IG5ld192YXJpYWJsZSB0YWJsZSBuYW1lID1cbiAgdHJ5IFZhcnMuZmluZCBuYW1lIHRhYmxlLnZhcnNcbiAgd2l0aCBOb3RfZm91bmQgLT5cbiAgICBsZXQgaW5kZXggPSBuZXdfc2xvdCB0YWJsZSBpblxuICAgIGlmIG5hbWUgPD4gXCJcIiB0aGVuIHRhYmxlLnZhcnMgPC0gVmFycy5hZGQgbmFtZSBpbmRleCB0YWJsZS52YXJzO1xuICAgIGluZGV4XG5cbmxldCB0b19hcnJheSBhcnIgPVxuICBpZiBhcnIgPSBPYmoubWFnaWMgMCB0aGVuIFt8fF0gZWxzZSBhcnJcblxubGV0IG5ld19tZXRob2RzX3ZhcmlhYmxlcyB0YWJsZSBtZXRocyB2YWxzID1cbiAgbGV0IG1ldGhzID0gdG9fYXJyYXkgbWV0aHMgaW5cbiAgbGV0IG5tZXRocyA9IEFycmF5Lmxlbmd0aCBtZXRocyBhbmQgbnZhbHMgPSBBcnJheS5sZW5ndGggdmFscyBpblxuICBsZXQgcmVzID0gQXJyYXkubWFrZSAobm1ldGhzICsgbnZhbHMpIDAgaW5cbiAgZm9yIGkgPSAwIHRvIG5tZXRocyAtIDEgZG9cbiAgICByZXMuKGkpIDwtIGdldF9tZXRob2RfbGFiZWwgdGFibGUgbWV0aHMuKGkpXG4gIGRvbmU7XG4gIGZvciBpID0gMCB0byBudmFscyAtIDEgZG9cbiAgICByZXMuKGkrbm1ldGhzKSA8LSBuZXdfdmFyaWFibGUgdGFibGUgdmFscy4oaSlcbiAgZG9uZTtcbiAgcmVzXG5cbmxldCBnZXRfdmFyaWFibGUgdGFibGUgbmFtZSA9XG4gIHRyeSBWYXJzLmZpbmQgbmFtZSB0YWJsZS52YXJzIHdpdGggTm90X2ZvdW5kIC0+IGFzc2VydCBmYWxzZVxuXG5sZXQgZ2V0X3ZhcmlhYmxlcyB0YWJsZSBuYW1lcyA9XG4gIEFycmF5Lm1hcCAoZ2V0X3ZhcmlhYmxlIHRhYmxlKSBuYW1lc1xuXG5sZXQgYWRkX2luaXRpYWxpemVyIHRhYmxlIGYgPVxuICB0YWJsZS5pbml0aWFsaXplcnMgPC0gZjo6dGFibGUuaW5pdGlhbGl6ZXJzXG5cbigqXG5tb2R1bGUgS2V5cyA9XG4gIE1hcC5NYWtlKHN0cnVjdCB0eXBlIHQgPSB0YWcgYXJyYXkgbGV0IGNvbXBhcmUgKHg6dCkgeSA9IGNvbXBhcmUgeCB5IGVuZClcbmxldCBrZXlfbWFwID0gcmVmIEtleXMuZW1wdHlcbmxldCBnZXRfa2V5IHRhZ3MgOiBpdGVtID1cbiAgdHJ5IG1hZ2ljIChLZXlzLmZpbmQgdGFncyAha2V5X21hcCA6IHRhZyBhcnJheSlcbiAgd2l0aCBOb3RfZm91bmQgLT5cbiAgICBrZXlfbWFwIDo9IEtleXMuYWRkIHRhZ3MgdGFncyAha2V5X21hcDtcbiAgICBtYWdpYyB0YWdzXG4qKVxuXG5sZXQgY3JlYXRlX3RhYmxlIHB1YmxpY19tZXRob2RzID1cbiAgaWYgcHVibGljX21ldGhvZHMgPT0gbWFnaWMgMCB0aGVuIG5ld190YWJsZSBbfHxdIGVsc2VcbiAgKCogW3B1YmxpY19tZXRob2RzXSBtdXN0IGJlIGluIGFzY2VuZGluZyBvcmRlciBmb3IgYnl0ZWNvZGUgKilcbiAgbGV0IHRhZ3MgPSBBcnJheS5tYXAgcHVibGljX21ldGhvZF9sYWJlbCBwdWJsaWNfbWV0aG9kcyBpblxuICBsZXQgdGFibGUgPSBuZXdfdGFibGUgdGFncyBpblxuICBBcnJheS5pdGVyaVxuICAgIChmdW4gaSBtZXQgLT5cbiAgICAgIGxldCBsYWIgPSBpKjIrMiBpblxuICAgICAgdGFibGUubWV0aG9kc19ieV9uYW1lICA8LSBNZXRocy5hZGQgbWV0IGxhYiB0YWJsZS5tZXRob2RzX2J5X25hbWU7XG4gICAgICB0YWJsZS5tZXRob2RzX2J5X2xhYmVsIDwtIExhYnMuYWRkIGxhYiB0cnVlIHRhYmxlLm1ldGhvZHNfYnlfbGFiZWwpXG4gICAgcHVibGljX21ldGhvZHM7XG4gIHRhYmxlXG5cbmxldCBpbml0X2NsYXNzIHRhYmxlID1cbiAgaW5zdF92YXJfY291bnQgOj0gIWluc3RfdmFyX2NvdW50ICsgdGFibGUuc2l6ZSAtIDE7XG4gIHRhYmxlLmluaXRpYWxpemVycyA8LSBMaXN0LnJldiB0YWJsZS5pbml0aWFsaXplcnM7XG4gIHJlc2l6ZSB0YWJsZSAoMyArIG1hZ2ljIHRhYmxlLm1ldGhvZHMuKDEpICogMTYgLyBTeXMud29yZF9zaXplKVxuXG5sZXQgaW5oZXJpdHMgY2xhIHZhbHMgdmlydF9tZXRocyBjb25jcl9tZXRocyAoXywgc3VwZXIsIF8sIGVudikgdG9wID1cbiAgbmFycm93IGNsYSB2YWxzIHZpcnRfbWV0aHMgY29uY3JfbWV0aHM7XG4gIGxldCBpbml0ID1cbiAgICBpZiB0b3AgdGhlbiBzdXBlciBjbGEgZW52IGVsc2UgT2JqLnJlcHIgKHN1cGVyIGNsYSkgaW5cbiAgd2lkZW4gY2xhO1xuICBBcnJheS5jb25jYXRcbiAgICBbW3wgcmVwciBpbml0IHxdO1xuICAgICBtYWdpYyAoQXJyYXkubWFwIChnZXRfdmFyaWFibGUgY2xhKSAodG9fYXJyYXkgdmFscykgOiBpbnQgYXJyYXkpO1xuICAgICBBcnJheS5tYXBcbiAgICAgICAoZnVuIG5tIC0+IHJlcHIgKGdldF9tZXRob2QgY2xhIChnZXRfbWV0aG9kX2xhYmVsIGNsYSBubSkgOiBjbG9zdXJlKSlcbiAgICAgICAodG9fYXJyYXkgY29uY3JfbWV0aHMpIF1cblxubGV0IG1ha2VfY2xhc3MgcHViX21ldGhzIGNsYXNzX2luaXQgPVxuICBsZXQgdGFibGUgPSBjcmVhdGVfdGFibGUgcHViX21ldGhzIGluXG4gIGxldCBlbnZfaW5pdCA9IGNsYXNzX2luaXQgdGFibGUgaW5cbiAgaW5pdF9jbGFzcyB0YWJsZTtcbiAgKGVudl9pbml0IChPYmoucmVwciAwKSwgY2xhc3NfaW5pdCwgZW52X2luaXQsIE9iai5yZXByIDApXG5cbnR5cGUgaW5pdF90YWJsZSA9IHsgbXV0YWJsZSBlbnZfaW5pdDogdDsgbXV0YWJsZSBjbGFzc19pbml0OiB0YWJsZSAtPiB0IH1cbltAQHdhcm5pbmcgXCItdW51c2VkLWZpZWxkXCJdXG5cbmxldCBtYWtlX2NsYXNzX3N0b3JlIHB1Yl9tZXRocyBjbGFzc19pbml0IGluaXRfdGFibGUgPVxuICBsZXQgdGFibGUgPSBjcmVhdGVfdGFibGUgcHViX21ldGhzIGluXG4gIGxldCBlbnZfaW5pdCA9IGNsYXNzX2luaXQgdGFibGUgaW5cbiAgaW5pdF9jbGFzcyB0YWJsZTtcbiAgaW5pdF90YWJsZS5jbGFzc19pbml0IDwtIGNsYXNzX2luaXQ7XG4gIGluaXRfdGFibGUuZW52X2luaXQgPC0gZW52X2luaXRcblxubGV0IGR1bW15X2NsYXNzIGxvYyA9XG4gIGxldCB1bmRlZiA9IGZ1biBfIC0+IHJhaXNlIChVbmRlZmluZWRfcmVjdXJzaXZlX21vZHVsZSBsb2MpIGluXG4gIChPYmoubWFnaWMgdW5kZWYsIHVuZGVmLCB1bmRlZiwgT2JqLnJlcHIgMClcblxuKCoqKiogT2JqZWN0cyAqKioqKVxuXG5sZXQgY3JlYXRlX29iamVjdCB0YWJsZSA9XG4gICgqIFhYWCBBcHBlbCBkZSBbb2JqX2Jsb2NrXSB8IENhbGwgdG8gW29ial9ibG9ja10gICopXG4gIGxldCBvYmogPSBPYmoubmV3X2Jsb2NrIE9iai5vYmplY3RfdGFnIHRhYmxlLnNpemUgaW5cbiAgKCogWFhYIEFwcGVsIGRlIFtjYW1sX21vZGlmeV0gfCBDYWxsIHRvIFtjYW1sX21vZGlmeV0gKilcbiAgT2JqLnNldF9maWVsZCBvYmogMCAoT2JqLnJlcHIgdGFibGUubWV0aG9kcyk7XG4gIE9iai5vYmogKHNldF9pZCBvYmopXG5cbmxldCBjcmVhdGVfb2JqZWN0X29wdCBvYmpfMCB0YWJsZSA9XG4gIGlmIChPYmoubWFnaWMgb2JqXzAgOiBib29sKSB0aGVuIG9ial8wIGVsc2UgYmVnaW5cbiAgICAoKiBYWFggQXBwZWwgZGUgW29ial9ibG9ja10gfCBDYWxsIHRvIFtvYmpfYmxvY2tdICAqKVxuICAgIGxldCBvYmogPSBPYmoubmV3X2Jsb2NrIE9iai5vYmplY3RfdGFnIHRhYmxlLnNpemUgaW5cbiAgICAoKiBYWFggQXBwZWwgZGUgW2NhbWxfbW9kaWZ5XSB8IENhbGwgdG8gW2NhbWxfbW9kaWZ5XSAqKVxuICAgIE9iai5zZXRfZmllbGQgb2JqIDAgKE9iai5yZXByIHRhYmxlLm1ldGhvZHMpO1xuICAgIE9iai5vYmogKHNldF9pZCBvYmopXG4gIGVuZFxuXG5sZXQgcmVjIGl0ZXJfZiBvYmogPVxuICBmdW5jdGlvblxuICAgIFtdICAgLT4gKClcbiAgfCBmOjpsIC0+IGYgb2JqOyBpdGVyX2Ygb2JqIGxcblxubGV0IHJ1bl9pbml0aWFsaXplcnMgb2JqIHRhYmxlID1cbiAgbGV0IGluaXRzID0gdGFibGUuaW5pdGlhbGl6ZXJzIGluXG4gIGlmIGluaXRzIDw+IFtdIHRoZW5cbiAgICBpdGVyX2Ygb2JqIGluaXRzXG5cbmxldCBydW5faW5pdGlhbGl6ZXJzX29wdCBvYmpfMCBvYmogdGFibGUgPVxuICBpZiAoT2JqLm1hZ2ljIG9ial8wIDogYm9vbCkgdGhlbiBvYmogZWxzZSBiZWdpblxuICAgIGxldCBpbml0cyA9IHRhYmxlLmluaXRpYWxpemVycyBpblxuICAgIGlmIGluaXRzIDw+IFtdIHRoZW4gaXRlcl9mIG9iaiBpbml0cztcbiAgICBvYmpcbiAgZW5kXG5cbmxldCBjcmVhdGVfb2JqZWN0X2FuZF9ydW5faW5pdGlhbGl6ZXJzIG9ial8wIHRhYmxlID1cbiAgaWYgKE9iai5tYWdpYyBvYmpfMCA6IGJvb2wpIHRoZW4gb2JqXzAgZWxzZSBiZWdpblxuICAgIGxldCBvYmogPSBjcmVhdGVfb2JqZWN0IHRhYmxlIGluXG4gICAgcnVuX2luaXRpYWxpemVycyBvYmogdGFibGU7XG4gICAgb2JqXG4gIGVuZFxuXG4oKiBFcXVpdmFsZW50IHByaW1pdGl2ZSBiZWxvd1xubGV0IHNlbmRzZWxmIG9iaiBsYWIgPVxuICAobWFnaWMgb2JqIDogKG9iaiAtPiB0KSBhcnJheSBhcnJheSkuKDApLihsYWIpIG9ialxuKilcbmV4dGVybmFsIHNlbmQgOiBvYmogLT4gdGFnIC0+ICdhID0gXCIlc2VuZFwiXG5leHRlcm5hbCBzZW5kY2FjaGUgOiBvYmogLT4gdGFnIC0+IHQgLT4gaW50IC0+ICdhID0gXCIlc2VuZGNhY2hlXCJcbmV4dGVybmFsIHNlbmRzZWxmIDogb2JqIC0+IGxhYmVsIC0+ICdhID0gXCIlc2VuZHNlbGZcIlxuZXh0ZXJuYWwgZ2V0X3B1YmxpY19tZXRob2QgOiBvYmogLT4gdGFnIC0+IGNsb3N1cmVcbiAgICA9IFwiY2FtbF9nZXRfcHVibGljX21ldGhvZFwiIFtAQG5vYWxsb2NdXG5cbigqKioqIHRhYmxlIGNvbGxlY3Rpb24gYWNjZXNzICoqKiopXG5cbnR5cGUgdGFibGVzID1cbiAgfCBFbXB0eVxuICB8IENvbnMgb2Yge2tleSA6IGNsb3N1cmU7IG11dGFibGUgZGF0YTogdGFibGVzOyBtdXRhYmxlIG5leHQ6IHRhYmxlc31cblxubGV0IHNldF9kYXRhIHRhYmxlcyB2ID0gbWF0Y2ggdGFibGVzIHdpdGhcbiAgfCBFbXB0eSAtPiBhc3NlcnQgZmFsc2VcbiAgfCBDb25zIHRhYmxlcyAtPiB0YWJsZXMuZGF0YSA8LSB2XG5sZXQgc2V0X25leHQgdGFibGVzIHYgPSBtYXRjaCB0YWJsZXMgd2l0aFxuICB8IEVtcHR5IC0+IGFzc2VydCBmYWxzZVxuICB8IENvbnMgdGFibGVzIC0+IHRhYmxlcy5uZXh0IDwtIHZcbmxldCBnZXRfa2V5ID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPiBhc3NlcnQgZmFsc2VcbiAgfCBDb25zIHRhYmxlcyAtPiB0YWJsZXMua2V5XG5sZXQgZ2V0X2RhdGEgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+IGFzc2VydCBmYWxzZVxuICB8IENvbnMgdGFibGVzIC0+IHRhYmxlcy5kYXRhXG5sZXQgZ2V0X25leHQgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+IGFzc2VydCBmYWxzZVxuICB8IENvbnMgdGFibGVzIC0+IHRhYmxlcy5uZXh0XG5cbmxldCBidWlsZF9wYXRoIG4ga2V5cyB0YWJsZXMgPVxuICBsZXQgcmVzID0gQ29ucyB7a2V5ID0gT2JqLm1hZ2ljIDA7IGRhdGEgPSBFbXB0eTsgbmV4dCA9IEVtcHR5fSBpblxuICBsZXQgciA9IHJlZiByZXMgaW5cbiAgZm9yIGkgPSAwIHRvIG4gZG9cbiAgICByIDo9IENvbnMge2tleSA9IGtleXMuKGkpOyBkYXRhID0gIXI7IG5leHQgPSBFbXB0eX1cbiAgZG9uZTtcbiAgc2V0X2RhdGEgdGFibGVzICFyO1xuICByZXNcblxubGV0IHJlYyBsb29rdXBfa2V5cyBpIGtleXMgdGFibGVzID1cbiAgaWYgaSA8IDAgdGhlbiB0YWJsZXMgZWxzZVxuICBsZXQga2V5ID0ga2V5cy4oaSkgaW5cbiAgbGV0IHJlYyBsb29rdXBfa2V5ICh0YWJsZXM6dGFibGVzKSA9XG4gICAgaWYgZ2V0X2tleSB0YWJsZXMgPT0ga2V5IHRoZW5cbiAgICAgIG1hdGNoIGdldF9kYXRhIHRhYmxlcyB3aXRoXG4gICAgICB8IEVtcHR5IC0+IGFzc2VydCBmYWxzZVxuICAgICAgfCBDb25zIF8gYXMgdGFibGVzX2RhdGEgLT5cbiAgICAgICAgICBsb29rdXBfa2V5cyAoaS0xKSBrZXlzIHRhYmxlc19kYXRhXG4gICAgZWxzZVxuICAgICAgbWF0Y2ggZ2V0X25leHQgdGFibGVzIHdpdGhcbiAgICAgIHwgQ29ucyBfIGFzIG5leHQgLT4gbG9va3VwX2tleSBuZXh0XG4gICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgbGV0IG5leHQgOiB0YWJsZXMgPSBDb25zIHtrZXk7IGRhdGEgPSBFbXB0eTsgbmV4dCA9IEVtcHR5fSBpblxuICAgICAgICAgIHNldF9uZXh0IHRhYmxlcyBuZXh0O1xuICAgICAgICAgIGJ1aWxkX3BhdGggKGktMSkga2V5cyBuZXh0XG4gIGluXG4gIGxvb2t1cF9rZXkgdGFibGVzXG5cbmxldCBsb29rdXBfdGFibGVzIHJvb3Qga2V5cyA9XG4gIG1hdGNoIGdldF9kYXRhIHJvb3Qgd2l0aFxuICB8IENvbnMgXyBhcyByb290X2RhdGEgLT5cbiAgICBsb29rdXBfa2V5cyAoQXJyYXkubGVuZ3RoIGtleXMgLSAxKSBrZXlzIHJvb3RfZGF0YVxuICB8IEVtcHR5IC0+XG4gICAgYnVpbGRfcGF0aCAoQXJyYXkubGVuZ3RoIGtleXMgLSAxKSBrZXlzIHJvb3RcblxuKCoqKiogYnVpbHRpbiBtZXRob2RzICoqKiopXG5cbmxldCBnZXRfY29uc3QgeCA9IHJldCAoZnVuIF9vYmogLT4geClcbmxldCBnZXRfdmFyIG4gICA9IHJldCAoZnVuIG9iaiAtPiBBcnJheS51bnNhZmVfZ2V0IG9iaiBuKVxubGV0IGdldF9lbnYgZSBuID1cbiAgcmV0IChmdW4gb2JqIC0+XG4gICAgQXJyYXkudW5zYWZlX2dldCAoT2JqLm1hZ2ljIChBcnJheS51bnNhZmVfZ2V0IG9iaiBlKSA6IG9iaikgbilcbmxldCBnZXRfbWV0aCBuICA9IHJldCAoZnVuIG9iaiAtPiBzZW5kc2VsZiBvYmogbilcbmxldCBzZXRfdmFyIG4gICA9IHJldCAoZnVuIG9iaiB4IC0+IEFycmF5LnVuc2FmZV9zZXQgb2JqIG4geClcbmxldCBhcHBfY29uc3QgZiB4ID0gcmV0IChmdW4gX29iaiAtPiBmIHgpXG5sZXQgYXBwX3ZhciBmIG4gICA9IHJldCAoZnVuIG9iaiAtPiBmIChBcnJheS51bnNhZmVfZ2V0IG9iaiBuKSlcbmxldCBhcHBfZW52IGYgZSBuID1cbiAgcmV0IChmdW4gb2JqIC0+XG4gICAgZiAoQXJyYXkudW5zYWZlX2dldCAoT2JqLm1hZ2ljIChBcnJheS51bnNhZmVfZ2V0IG9iaiBlKSA6IG9iaikgbikpXG5sZXQgYXBwX21ldGggZiBuICA9IHJldCAoZnVuIG9iaiAtPiBmIChzZW5kc2VsZiBvYmogbikpXG5sZXQgYXBwX2NvbnN0X2NvbnN0IGYgeCB5ID0gcmV0IChmdW4gX29iaiAtPiBmIHggeSlcbmxldCBhcHBfY29uc3RfdmFyIGYgeCBuICAgPSByZXQgKGZ1biBvYmogLT4gZiB4IChBcnJheS51bnNhZmVfZ2V0IG9iaiBuKSlcbmxldCBhcHBfY29uc3RfbWV0aCBmIHggbiA9IHJldCAoZnVuIG9iaiAtPiBmIHggKHNlbmRzZWxmIG9iaiBuKSlcbmxldCBhcHBfdmFyX2NvbnN0IGYgbiB4ID0gcmV0IChmdW4gb2JqIC0+IGYgKEFycmF5LnVuc2FmZV9nZXQgb2JqIG4pIHgpXG5sZXQgYXBwX21ldGhfY29uc3QgZiBuIHggPSByZXQgKGZ1biBvYmogLT4gZiAoc2VuZHNlbGYgb2JqIG4pIHgpXG5sZXQgYXBwX2NvbnN0X2VudiBmIHggZSBuID1cbiAgcmV0IChmdW4gb2JqIC0+XG4gICAgZiB4IChBcnJheS51bnNhZmVfZ2V0IChPYmoubWFnaWMgKEFycmF5LnVuc2FmZV9nZXQgb2JqIGUpIDogb2JqKSBuKSlcbmxldCBhcHBfZW52X2NvbnN0IGYgZSBuIHggPVxuICByZXQgKGZ1biBvYmogLT5cbiAgICBmIChBcnJheS51bnNhZmVfZ2V0IChPYmoubWFnaWMgKEFycmF5LnVuc2FmZV9nZXQgb2JqIGUpIDogb2JqKSBuKSB4KVxubGV0IG1ldGhfYXBwX2NvbnN0IG4geCA9IHJldCAoZnVuIG9iaiAtPiAoc2VuZHNlbGYgb2JqIG4gOiBfIC0+IF8pIHgpXG5sZXQgbWV0aF9hcHBfdmFyIG4gbSA9XG4gIHJldCAoZnVuIG9iaiAtPiAoc2VuZHNlbGYgb2JqIG4gOiBfIC0+IF8pIChBcnJheS51bnNhZmVfZ2V0IG9iaiBtKSlcbmxldCBtZXRoX2FwcF9lbnYgbiBlIG0gPVxuICByZXQgKGZ1biBvYmogLT4gKHNlbmRzZWxmIG9iaiBuIDogXyAtPiBfKVxuICAgICAgKEFycmF5LnVuc2FmZV9nZXQgKE9iai5tYWdpYyAoQXJyYXkudW5zYWZlX2dldCBvYmogZSkgOiBvYmopIG0pKVxubGV0IG1ldGhfYXBwX21ldGggbiBtID1cbiAgcmV0IChmdW4gb2JqIC0+IChzZW5kc2VsZiBvYmogbiA6IF8gLT4gXykgKHNlbmRzZWxmIG9iaiBtKSlcbmxldCBzZW5kX2NvbnN0IG0geCBjID1cbiAgcmV0IChmdW4gb2JqIC0+IHNlbmRjYWNoZSB4IG0gKEFycmF5LnVuc2FmZV9nZXQgb2JqIDApIGMpXG5sZXQgc2VuZF92YXIgbSBuIGMgPVxuICByZXQgKGZ1biBvYmogLT5cbiAgICBzZW5kY2FjaGUgKE9iai5tYWdpYyAoQXJyYXkudW5zYWZlX2dldCBvYmogbikgOiBvYmopIG1cbiAgICAgIChBcnJheS51bnNhZmVfZ2V0IG9iaiAwKSBjKVxubGV0IHNlbmRfZW52IG0gZSBuIGMgPVxuICByZXQgKGZ1biBvYmogLT5cbiAgICBzZW5kY2FjaGVcbiAgICAgIChPYmoubWFnaWMgKEFycmF5LnVuc2FmZV9nZXRcbiAgICAgICAgICAgICAgICAgICAgKE9iai5tYWdpYyAoQXJyYXkudW5zYWZlX2dldCBvYmogZSkgOiBvYmopIG4pIDogb2JqKVxuICAgICAgbSAoQXJyYXkudW5zYWZlX2dldCBvYmogMCkgYylcbmxldCBzZW5kX21ldGggbSBuIGMgPVxuICByZXQgKGZ1biBvYmogLT5cbiAgICBzZW5kY2FjaGUgKHNlbmRzZWxmIG9iaiBuKSBtIChBcnJheS51bnNhZmVfZ2V0IG9iaiAwKSBjKVxubGV0IG5ld19jYWNoZSB0YWJsZSA9XG4gIGxldCBuID0gbmV3X21ldGhvZCB0YWJsZSBpblxuICBsZXQgbiA9XG4gICAgaWYgbiBtb2QgMiA9IDAgfHwgbiA+IDIgKyBtYWdpYyB0YWJsZS5tZXRob2RzLigxKSAqIDE2IC8gU3lzLndvcmRfc2l6ZVxuICAgIHRoZW4gbiBlbHNlIG5ld19tZXRob2QgdGFibGVcbiAgaW5cbiAgdGFibGUubWV0aG9kcy4obikgPC0gT2JqLm1hZ2ljIDA7XG4gIG5cblxudHlwZSBpbXBsID1cbiAgICBHZXRDb25zdFxuICB8IEdldFZhclxuICB8IEdldEVudlxuICB8IEdldE1ldGhcbiAgfCBTZXRWYXJcbiAgfCBBcHBDb25zdFxuICB8IEFwcFZhclxuICB8IEFwcEVudlxuICB8IEFwcE1ldGhcbiAgfCBBcHBDb25zdENvbnN0XG4gIHwgQXBwQ29uc3RWYXJcbiAgfCBBcHBDb25zdEVudlxuICB8IEFwcENvbnN0TWV0aFxuICB8IEFwcFZhckNvbnN0XG4gIHwgQXBwRW52Q29uc3RcbiAgfCBBcHBNZXRoQ29uc3RcbiAgfCBNZXRoQXBwQ29uc3RcbiAgfCBNZXRoQXBwVmFyXG4gIHwgTWV0aEFwcEVudlxuICB8IE1ldGhBcHBNZXRoXG4gIHwgU2VuZENvbnN0XG4gIHwgU2VuZFZhclxuICB8IFNlbmRFbnZcbiAgfCBTZW5kTWV0aFxuICB8IENsb3N1cmUgb2YgY2xvc3VyZVxuXG5sZXQgbWV0aG9kX2ltcGwgdGFibGUgaSBhcnIgPVxuICBsZXQgbmV4dCAoKSA9IGluY3IgaTsgbWFnaWMgYXJyLighaSkgaW5cbiAgbWF0Y2ggbmV4dCgpIHdpdGhcbiAgICBHZXRDb25zdCAtPiBsZXQgeCA6IHQgPSBuZXh0KCkgaW4gZ2V0X2NvbnN0IHhcbiAgfCBHZXRWYXIgICAtPiBsZXQgbiA9IG5leHQoKSBpbiBnZXRfdmFyIG5cbiAgfCBHZXRFbnYgICAtPiBsZXQgZSA9IG5leHQoKSBpbiBsZXQgbiA9IG5leHQoKSBpbiBnZXRfZW52IGUgblxuICB8IEdldE1ldGggIC0+IGxldCBuID0gbmV4dCgpIGluIGdldF9tZXRoIG5cbiAgfCBTZXRWYXIgICAtPiBsZXQgbiA9IG5leHQoKSBpbiBzZXRfdmFyIG5cbiAgfCBBcHBDb25zdCAtPiBsZXQgZiA9IG5leHQoKSBpbiBsZXQgeCA9IG5leHQoKSBpbiBhcHBfY29uc3QgZiB4XG4gIHwgQXBwVmFyICAgLT4gbGV0IGYgPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0ICgpIGluIGFwcF92YXIgZiBuXG4gIHwgQXBwRW52ICAgLT5cbiAgICAgIGxldCBmID0gbmV4dCgpIGluICBsZXQgZSA9IG5leHQoKSBpbiBsZXQgbiA9IG5leHQoKSBpblxuICAgICAgYXBwX2VudiBmIGUgblxuICB8IEFwcE1ldGggIC0+IGxldCBmID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCAoKSBpbiBhcHBfbWV0aCBmIG5cbiAgfCBBcHBDb25zdENvbnN0IC0+XG4gICAgICBsZXQgZiA9IG5leHQoKSBpbiBsZXQgeCA9IG5leHQoKSBpbiBsZXQgeSA9IG5leHQoKSBpblxuICAgICAgYXBwX2NvbnN0X2NvbnN0IGYgeCB5XG4gIHwgQXBwQ29uc3RWYXIgLT5cbiAgICAgIGxldCBmID0gbmV4dCgpIGluIGxldCB4ID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCgpIGluXG4gICAgICBhcHBfY29uc3RfdmFyIGYgeCBuXG4gIHwgQXBwQ29uc3RFbnYgLT5cbiAgICAgIGxldCBmID0gbmV4dCgpIGluIGxldCB4ID0gbmV4dCgpIGluIGxldCBlID0gbmV4dCAoKSBpbiBsZXQgbiA9IG5leHQoKSBpblxuICAgICAgYXBwX2NvbnN0X2VudiBmIHggZSBuXG4gIHwgQXBwQ29uc3RNZXRoIC0+XG4gICAgICBsZXQgZiA9IG5leHQoKSBpbiBsZXQgeCA9IG5leHQoKSBpbiBsZXQgbiA9IG5leHQoKSBpblxuICAgICAgYXBwX2NvbnN0X21ldGggZiB4IG5cbiAgfCBBcHBWYXJDb25zdCAtPlxuICAgICAgbGV0IGYgPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0KCkgaW4gbGV0IHggPSBuZXh0KCkgaW5cbiAgICAgIGFwcF92YXJfY29uc3QgZiBuIHhcbiAgfCBBcHBFbnZDb25zdCAtPlxuICAgICAgbGV0IGYgPSBuZXh0KCkgaW4gbGV0IGUgPSBuZXh0ICgpIGluIGxldCBuID0gbmV4dCgpIGluIGxldCB4ID0gbmV4dCgpIGluXG4gICAgICBhcHBfZW52X2NvbnN0IGYgZSBuIHhcbiAgfCBBcHBNZXRoQ29uc3QgLT5cbiAgICAgIGxldCBmID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCgpIGluIGxldCB4ID0gbmV4dCgpIGluXG4gICAgICBhcHBfbWV0aF9jb25zdCBmIG4geFxuICB8IE1ldGhBcHBDb25zdCAtPlxuICAgICAgbGV0IG4gPSBuZXh0KCkgaW4gbGV0IHggPSBuZXh0KCkgaW4gbWV0aF9hcHBfY29uc3QgbiB4XG4gIHwgTWV0aEFwcFZhciAtPlxuICAgICAgbGV0IG4gPSBuZXh0KCkgaW4gbGV0IG0gPSBuZXh0KCkgaW4gbWV0aF9hcHBfdmFyIG4gbVxuICB8IE1ldGhBcHBFbnYgLT5cbiAgICAgIGxldCBuID0gbmV4dCgpIGluIGxldCBlID0gbmV4dCgpIGluIGxldCBtID0gbmV4dCgpIGluXG4gICAgICBtZXRoX2FwcF9lbnYgbiBlIG1cbiAgfCBNZXRoQXBwTWV0aCAtPlxuICAgICAgbGV0IG4gPSBuZXh0KCkgaW4gbGV0IG0gPSBuZXh0KCkgaW4gbWV0aF9hcHBfbWV0aCBuIG1cbiAgfCBTZW5kQ29uc3QgLT5cbiAgICAgIGxldCBtID0gbmV4dCgpIGluIGxldCB4ID0gbmV4dCgpIGluIHNlbmRfY29uc3QgbSB4IChuZXdfY2FjaGUgdGFibGUpXG4gIHwgU2VuZFZhciAtPlxuICAgICAgbGV0IG0gPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0ICgpIGluIHNlbmRfdmFyIG0gbiAobmV3X2NhY2hlIHRhYmxlKVxuICB8IFNlbmRFbnYgLT5cbiAgICAgIGxldCBtID0gbmV4dCgpIGluIGxldCBlID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCgpIGluXG4gICAgICBzZW5kX2VudiBtIGUgbiAobmV3X2NhY2hlIHRhYmxlKVxuICB8IFNlbmRNZXRoIC0+XG4gICAgICBsZXQgbSA9IG5leHQoKSBpbiBsZXQgbiA9IG5leHQgKCkgaW4gc2VuZF9tZXRoIG0gbiAobmV3X2NhY2hlIHRhYmxlKVxuICB8IENsb3N1cmUgXyBhcyBjbG8gLT4gbWFnaWMgY2xvXG5cbmxldCBzZXRfbWV0aG9kcyB0YWJsZSBtZXRob2RzID1cbiAgbGV0IGxlbiA9IEFycmF5Lmxlbmd0aCBtZXRob2RzIGluIGxldCBpID0gcmVmIDAgaW5cbiAgd2hpbGUgIWkgPCBsZW4gZG9cbiAgICBsZXQgbGFiZWwgPSBtZXRob2RzLighaSkgaW4gbGV0IGNsbyA9IG1ldGhvZF9pbXBsIHRhYmxlIGkgbWV0aG9kcyBpblxuICAgIHNldF9tZXRob2QgdGFibGUgbGFiZWwgY2xvO1xuICAgIGluY3IgaVxuICBkb25lXG5cbigqKioqIFN0YXRpc3RpY3MgKioqKilcblxudHlwZSBzdGF0cyA9XG4gIHsgY2xhc3NlczogaW50OyBtZXRob2RzOiBpbnQ7IGluc3RfdmFyczogaW50OyB9XG5cbmxldCBzdGF0cyAoKSA9XG4gIHsgY2xhc3NlcyA9ICF0YWJsZV9jb3VudDtcbiAgICBtZXRob2RzID0gIW1ldGhvZF9jb3VudDsgaW5zdF92YXJzID0gIWluc3RfdmFyX2NvdW50OyB9XG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDA0IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUgc2hhcGUgPVxuICB8IEZ1bmN0aW9uXG4gIHwgTGF6eVxuICB8IENsYXNzXG4gIHwgTW9kdWxlIG9mIHNoYXBlIGFycmF5XG4gIHwgVmFsdWUgb2YgT2JqLnRcblxubGV0IHJlYyBpbml0X21vZF9maWVsZCBtb2R1IGkgbG9jIHNoYXBlID1cbiAgbGV0IGluaXQgPVxuICAgIG1hdGNoIHNoYXBlIHdpdGhcbiAgICB8IEZ1bmN0aW9uIC0+XG4gICAgICAgbGV0IHJlYyBmbiAoeCA6ICdhKSA9XG4gICAgICAgICBsZXQgZm4nIDogJ2EgLT4gJ2IgPSBPYmoub2JqIChPYmouZmllbGQgbW9kdSBpKSBpblxuICAgICAgICAgaWYgZm4gPT0gZm4nIHRoZW5cbiAgICAgICAgICAgcmFpc2UgKFVuZGVmaW5lZF9yZWN1cnNpdmVfbW9kdWxlIGxvYylcbiAgICAgICAgIGVsc2VcbiAgICAgICAgICAgZm4nIHggaW5cbiAgICAgICBPYmoucmVwciBmblxuICAgIHwgTGF6eSAtPlxuICAgICAgIGxldCByZWMgbCA9XG4gICAgICAgICBsYXp5IChcbiAgICAgICAgICAgbGV0IGwnID0gT2JqLm9iaiAoT2JqLmZpZWxkIG1vZHUgaSkgaW5cbiAgICAgICAgICAgaWYgbCA9PSBsJyB0aGVuXG4gICAgICAgICAgICAgcmFpc2UgKFVuZGVmaW5lZF9yZWN1cnNpdmVfbW9kdWxlIGxvYylcbiAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgIExhenkuZm9yY2UgbCcpIGluXG4gICAgICAgT2JqLnJlcHIgbFxuICAgIHwgQ2xhc3MgLT5cbiAgICAgICBPYmoucmVwciAoQ2FtbGludGVybmFsT08uZHVtbXlfY2xhc3MgbG9jKVxuICAgIHwgTW9kdWxlIGNvbXBzIC0+XG4gICAgICAgT2JqLnJlcHIgKGluaXRfbW9kX2Jsb2NrIGxvYyBjb21wcylcbiAgICB8IFZhbHVlIHYgLT4gdlxuICBpblxuICBPYmouc2V0X2ZpZWxkIG1vZHUgaSBpbml0XG5cbmFuZCBpbml0X21vZF9ibG9jayBsb2MgY29tcHMgPVxuICBsZXQgbGVuZ3RoID0gQXJyYXkubGVuZ3RoIGNvbXBzIGluXG4gIGxldCBtb2R1ID0gT2JqLm5ld19ibG9jayAwIGxlbmd0aCBpblxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIC0gMSBkb1xuICAgIGluaXRfbW9kX2ZpZWxkIG1vZHUgaSBsb2MgY29tcHMuKGkpXG4gIGRvbmU7XG4gIG1vZHVcblxubGV0IGluaXRfbW9kIGxvYyBzaGFwZSA9XG4gIG1hdGNoIHNoYXBlIHdpdGhcbiAgfCBNb2R1bGUgY29tcHMgLT5cbiAgICAgT2JqLnJlcHIgKGluaXRfbW9kX2Jsb2NrIGxvYyBjb21wcylcbiAgfCBfIC0+IGZhaWx3aXRoIFwiQ2FtbGludGVybmFsTW9kLmluaXRfbW9kOiBub3QgYSBtb2R1bGVcIlxuXG5sZXQgcmVjIHVwZGF0ZV9tb2RfZmllbGQgbW9kdSBpIHNoYXBlIG4gPVxuICBtYXRjaCBzaGFwZSB3aXRoXG4gIHwgRnVuY3Rpb24gfCBMYXp5IC0+XG4gICAgIE9iai5zZXRfZmllbGQgbW9kdSBpIG5cbiAgfCBWYWx1ZSBfIC0+XG4gICAgICgpICgqIHRoZSB2YWx1ZSBpcyBhbHJlYWR5IHRoZXJlICopXG4gIHwgQ2xhc3MgLT5cbiAgICAgYXNzZXJ0IChPYmoudGFnIG4gPSAwICYmIE9iai5zaXplIG4gPSA0KTtcbiAgICAgbGV0IGNsID0gT2JqLmZpZWxkIG1vZHUgaSBpblxuICAgICBmb3IgaiA9IDAgdG8gMyBkb1xuICAgICAgIE9iai5zZXRfZmllbGQgY2wgaiAoT2JqLmZpZWxkIG4gailcbiAgICAgZG9uZVxuICB8IE1vZHVsZSBjb21wcyAtPlxuICAgICB1cGRhdGVfbW9kX2Jsb2NrIGNvbXBzIChPYmouZmllbGQgbW9kdSBpKSBuXG5cbmFuZCB1cGRhdGVfbW9kX2Jsb2NrIGNvbXBzIG8gbiA9XG4gIGFzc2VydCAoT2JqLnRhZyBuID0gMCAmJiBPYmouc2l6ZSBuID49IEFycmF5Lmxlbmd0aCBjb21wcyk7XG4gIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggY29tcHMgLSAxIGRvXG4gICAgdXBkYXRlX21vZF9maWVsZCBvIGkgY29tcHMuKGkpIChPYmouZmllbGQgbiBpKVxuICBkb25lXG5cbmxldCB1cGRhdGVfbW9kIHNoYXBlIG8gbiA9XG4gIG1hdGNoIHNoYXBlIHdpdGhcbiAgfCBNb2R1bGUgY29tcHMgLT5cbiAgICAgdXBkYXRlX21vZF9ibG9jayBjb21wcyBvIG5cbiAgfCBfIC0+IGZhaWx3aXRoIFwiQ2FtbGludGVybmFsTW9kLnVwZGF0ZV9tb2Q6IG5vdCBhIG1vZHVsZVwiXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbltAQEBvY2FtbC53YXJuaW5nIFwiLTNcIl0gKCogaWdub3JlIGRlcHJlY2F0aW9uIHdhcm5pbmcgYWJvdXQgbW9kdWxlIFN0cmVhbSAqKVxuXG50eXBlIHRva2VuID1cbiAgICBLd2Qgb2Ygc3RyaW5nXG4gIHwgSWRlbnQgb2Ygc3RyaW5nXG4gIHwgSW50IG9mIGludFxuICB8IEZsb2F0IG9mIGZsb2F0XG4gIHwgU3RyaW5nIG9mIHN0cmluZ1xuICB8IENoYXIgb2YgY2hhclxuXG4oKiBUaGUgc3RyaW5nIGJ1ZmZlcmluZyBtYWNoaW5lcnkgKilcblxubGV0IGluaXRpYWxfYnVmZmVyID0gQnl0ZXMuY3JlYXRlIDMyXG5cbmxldCBidWZmZXIgPSByZWYgaW5pdGlhbF9idWZmZXJcbmxldCBidWZwb3MgPSByZWYgMFxuXG5sZXQgcmVzZXRfYnVmZmVyICgpID0gYnVmZmVyIDo9IGluaXRpYWxfYnVmZmVyOyBidWZwb3MgOj0gMFxuXG5sZXQgc3RvcmUgYyA9XG4gIGlmICFidWZwb3MgPj0gQnl0ZXMubGVuZ3RoICFidWZmZXIgdGhlbiBiZWdpblxuICAgIGxldCBuZXdidWZmZXIgPSBCeXRlcy5jcmVhdGUgKDIgKiAhYnVmcG9zKSBpblxuICAgIEJ5dGVzLmJsaXQgIWJ1ZmZlciAwIG5ld2J1ZmZlciAwICFidWZwb3M7XG4gICAgYnVmZmVyIDo9IG5ld2J1ZmZlclxuICBlbmQ7XG4gIEJ5dGVzLnNldCAhYnVmZmVyICFidWZwb3MgYztcbiAgaW5jciBidWZwb3NcblxubGV0IGdldF9zdHJpbmcgKCkgPVxuICBsZXQgcyA9IEJ5dGVzLnN1Yl9zdHJpbmcgIWJ1ZmZlciAwICFidWZwb3MgaW4gYnVmZmVyIDo9IGluaXRpYWxfYnVmZmVyOyBzXG5cbigqIFRoZSBsZXhlciAqKVxuXG5sZXQgbWFrZV9sZXhlciBrZXl3b3JkcyA9XG4gIGxldCBrd2RfdGFibGUgPSBIYXNodGJsLmNyZWF0ZSAxNyBpblxuICBMaXN0Lml0ZXIgKGZ1biBzIC0+IEhhc2h0YmwuYWRkIGt3ZF90YWJsZSBzIChLd2QgcykpIGtleXdvcmRzO1xuICBsZXQgaWRlbnRfb3Jfa2V5d29yZCBpZCA9XG4gICAgdHJ5IEhhc2h0YmwuZmluZCBrd2RfdGFibGUgaWQgd2l0aFxuICAgICAgTm90X2ZvdW5kIC0+IElkZW50IGlkXG4gIGFuZCBrZXl3b3JkX29yX2Vycm9yIGMgPVxuICAgIGxldCBzID0gU3RyaW5nLm1ha2UgMSBjIGluXG4gICAgdHJ5IEhhc2h0YmwuZmluZCBrd2RfdGFibGUgcyB3aXRoXG4gICAgICBOb3RfZm91bmQgLT4gcmFpc2UgKFN0cmVhbS5FcnJvciAoXCJJbGxlZ2FsIGNoYXJhY3RlciBcIiBeIHMpKVxuICBpblxuICBsZXQgcmVjIG5leHRfdG9rZW4gKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZSAoJyAnIHwgJ1xcMDEwJyB8ICdcXDAxMycgfCAnXFwwMDknIHwgJ1xcMDI2JyB8ICdcXDAxMicpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXzsgbmV4dF90b2tlbiBzdHJtX19cbiAgICB8IFNvbWUgKCdBJy4uJ1onIHwgJ2EnLi4neicgfCAnXycgfCAnXFwxOTInLi4nXFwyNTUnIGFzIGMpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXztcbiAgICAgICAgbGV0IHMgPSBzdHJtX18gaW4gcmVzZXRfYnVmZmVyICgpOyBzdG9yZSBjOyBpZGVudCBzXG4gICAgfCBTb21lXG4gICAgICAgICgnIScgfCAnJScgfCAnJicgfCAnJCcgfCAnIycgfCAnKycgfCAnLycgfCAnOicgfCAnPCcgfCAnPScgfCAnPicgfFxuICAgICAgICAgJz8nIHwgJ0AnIHwgJ1xcXFwnIHwgJ34nIHwgJ14nIHwgJ3wnIHwgJyonIGFzIGMpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXztcbiAgICAgICAgbGV0IHMgPSBzdHJtX18gaW4gcmVzZXRfYnVmZmVyICgpOyBzdG9yZSBjOyBpZGVudDIgc1xuICAgIHwgU29tZSAoJzAnLi4nOScgYXMgYykgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fO1xuICAgICAgICBsZXQgcyA9IHN0cm1fXyBpbiByZXNldF9idWZmZXIgKCk7IHN0b3JlIGM7IG51bWJlciBzXG4gICAgfCBTb21lICdcXCcnIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXztcbiAgICAgICAgbGV0IGMgPVxuICAgICAgICAgIHRyeSBjaGFyIHN0cm1fXyB3aXRoXG4gICAgICAgICAgICBTdHJlYW0uRmFpbHVyZSAtPiByYWlzZSAoU3RyZWFtLkVycm9yIFwiXCIpXG4gICAgICAgIGluXG4gICAgICAgIGJlZ2luIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICAgICAgU29tZSAnXFwnJyAtPiBTdHJlYW0uanVuayBzdHJtX187IFNvbWUgKENoYXIgYylcbiAgICAgICAgfCBfIC0+IHJhaXNlIChTdHJlYW0uRXJyb3IgXCJcIilcbiAgICAgICAgZW5kXG4gICAgfCBTb21lICdcXFwiJyAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187XG4gICAgICAgIGxldCBzID0gc3RybV9fIGluIHJlc2V0X2J1ZmZlciAoKTsgU29tZSAoU3RyaW5nIChzdHJpbmcgcykpXG4gICAgfCBTb21lICctJyAtPiBTdHJlYW0uanVuayBzdHJtX187IG5lZ19udW1iZXIgc3RybV9fXG4gICAgfCBTb21lICcoJyAtPiBTdHJlYW0uanVuayBzdHJtX187IG1heWJlX2NvbW1lbnQgc3RybV9fXG4gICAgfCBTb21lIGMgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBTb21lIChrZXl3b3JkX29yX2Vycm9yIGMpXG4gICAgfCBfIC0+IE5vbmVcbiAgYW5kIGlkZW50IChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWVcbiAgICAgICAgKCdBJy4uJ1onIHwgJ2EnLi4neicgfCAnXFwxOTInLi4nXFwyNTUnIHwgJzAnLi4nOScgfCAnXycgfCAnXFwnJyBhcyBjKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187IGxldCBzID0gc3RybV9fIGluIHN0b3JlIGM7IGlkZW50IHNcbiAgICB8IF8gLT4gU29tZSAoaWRlbnRfb3Jfa2V5d29yZCAoZ2V0X3N0cmluZyAoKSkpXG4gIGFuZCBpZGVudDIgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZVxuICAgICAgICAoJyEnIHwgJyUnIHwgJyYnIHwgJyQnIHwgJyMnIHwgJysnIHwgJy0nIHwgJy8nIHwgJzonIHwgJzwnIHwgJz0nIHxcbiAgICAgICAgICc+JyB8ICc/JyB8ICdAJyB8ICdcXFxcJyB8ICd+JyB8ICdeJyB8ICd8JyB8ICcqJyBhcyBjKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187IGxldCBzID0gc3RybV9fIGluIHN0b3JlIGM7IGlkZW50MiBzXG4gICAgfCBfIC0+IFNvbWUgKGlkZW50X29yX2tleXdvcmQgKGdldF9zdHJpbmcgKCkpKVxuICBhbmQgbmVnX251bWJlciAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICgnMCcuLic5JyBhcyBjKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187XG4gICAgICAgIGxldCBzID0gc3RybV9fIGluIHJlc2V0X2J1ZmZlciAoKTsgc3RvcmUgJy0nOyBzdG9yZSBjOyBudW1iZXIgc1xuICAgIHwgXyAtPiBsZXQgcyA9IHN0cm1fXyBpbiByZXNldF9idWZmZXIgKCk7IHN0b3JlICctJzsgaWRlbnQyIHNcbiAgYW5kIG51bWJlciAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICgnMCcuLic5JyBhcyBjKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187IGxldCBzID0gc3RybV9fIGluIHN0b3JlIGM7IG51bWJlciBzXG4gICAgfCBTb21lICcuJyAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187IGxldCBzID0gc3RybV9fIGluIHN0b3JlICcuJzsgZGVjaW1hbF9wYXJ0IHNcbiAgICB8IFNvbWUgKCdlJyB8ICdFJykgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fOyBsZXQgcyA9IHN0cm1fXyBpbiBzdG9yZSAnRSc7IGV4cG9uZW50X3BhcnQgc1xuICAgIHwgXyAtPiBTb21lIChJbnQgKGludF9vZl9zdHJpbmcgKGdldF9zdHJpbmcgKCkpKSlcbiAgYW5kIGRlY2ltYWxfcGFydCAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICgnMCcuLic5JyBhcyBjKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187IGxldCBzID0gc3RybV9fIGluIHN0b3JlIGM7IGRlY2ltYWxfcGFydCBzXG4gICAgfCBTb21lICgnZScgfCAnRScpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXzsgbGV0IHMgPSBzdHJtX18gaW4gc3RvcmUgJ0UnOyBleHBvbmVudF9wYXJ0IHNcbiAgICB8IF8gLT4gU29tZSAoRmxvYXQgKGZsb2F0X29mX3N0cmluZyAoZ2V0X3N0cmluZyAoKSkpKVxuICBhbmQgZXhwb25lbnRfcGFydCAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICgnKycgfCAnLScgYXMgYykgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fOyBsZXQgcyA9IHN0cm1fXyBpbiBzdG9yZSBjOyBlbmRfZXhwb25lbnRfcGFydCBzXG4gICAgfCBfIC0+IGVuZF9leHBvbmVudF9wYXJ0IHN0cm1fX1xuICBhbmQgZW5kX2V4cG9uZW50X3BhcnQgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZSAoJzAnLi4nOScgYXMgYykgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fOyBsZXQgcyA9IHN0cm1fXyBpbiBzdG9yZSBjOyBlbmRfZXhwb25lbnRfcGFydCBzXG4gICAgfCBfIC0+IFNvbWUgKEZsb2F0IChmbG9hdF9vZl9zdHJpbmcgKGdldF9zdHJpbmcgKCkpKSlcbiAgYW5kIHN0cmluZyAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICdcXFwiJyAtPiBTdHJlYW0uanVuayBzdHJtX187IGdldF9zdHJpbmcgKClcbiAgICB8IFNvbWUgJ1xcXFwnIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXztcbiAgICAgICAgbGV0IGMgPVxuICAgICAgICAgIHRyeSBlc2NhcGUgc3RybV9fIHdpdGhcbiAgICAgICAgICAgIFN0cmVhbS5GYWlsdXJlIC0+IHJhaXNlIChTdHJlYW0uRXJyb3IgXCJcIilcbiAgICAgICAgaW5cbiAgICAgICAgbGV0IHMgPSBzdHJtX18gaW4gc3RvcmUgYzsgc3RyaW5nIHNcbiAgICB8IFNvbWUgYyAtPiBTdHJlYW0uanVuayBzdHJtX187IGxldCBzID0gc3RybV9fIGluIHN0b3JlIGM7IHN0cmluZyBzXG4gICAgfCBfIC0+IHJhaXNlIFN0cmVhbS5GYWlsdXJlXG4gIGFuZCBjaGFyIChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWUgJ1xcXFwnIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXztcbiAgICAgICAgYmVnaW4gdHJ5IGVzY2FwZSBzdHJtX18gd2l0aFxuICAgICAgICAgIFN0cmVhbS5GYWlsdXJlIC0+IHJhaXNlIChTdHJlYW0uRXJyb3IgXCJcIilcbiAgICAgICAgZW5kXG4gICAgfCBTb21lIGMgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBjXG4gICAgfCBfIC0+IHJhaXNlIFN0cmVhbS5GYWlsdXJlXG4gIGFuZCBlc2NhcGUgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZSAnbicgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyAnXFxuJ1xuICAgIHwgU29tZSAncicgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyAnXFxyJ1xuICAgIHwgU29tZSAndCcgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyAnXFx0J1xuICAgIHwgU29tZSAoJzAnLi4nOScgYXMgYzEpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXztcbiAgICAgICAgYmVnaW4gbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgICAgICBTb21lICgnMCcuLic5JyBhcyBjMikgLT5cbiAgICAgICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXztcbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICAgICAgICAgIFNvbWUgKCcwJy4uJzknIGFzIGMzKSAtPlxuICAgICAgICAgICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXztcbiAgICAgICAgICAgICAgICBDaGFyLmNoclxuICAgICAgICAgICAgICAgICAgKChDaGFyLmNvZGUgYzEgLSA0OCkgKiAxMDAgKyAoQ2hhci5jb2RlIGMyIC0gNDgpICogMTAgK1xuICAgICAgICAgICAgICAgICAgICAgKENoYXIuY29kZSBjMyAtIDQ4KSlcbiAgICAgICAgICAgIHwgXyAtPiByYWlzZSAoU3RyZWFtLkVycm9yIFwiXCIpXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgfCBfIC0+IHJhaXNlIChTdHJlYW0uRXJyb3IgXCJcIilcbiAgICAgICAgZW5kXG4gICAgfCBTb21lIGMgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBjXG4gICAgfCBfIC0+IHJhaXNlIFN0cmVhbS5GYWlsdXJlXG4gIGFuZCBtYXliZV9jb21tZW50IChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWUgJyonIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXzsgbGV0IHMgPSBzdHJtX18gaW4gY29tbWVudCBzOyBuZXh0X3Rva2VuIHNcbiAgICB8IF8gLT4gU29tZSAoa2V5d29yZF9vcl9lcnJvciAnKCcpXG4gIGFuZCBjb21tZW50IChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWUgJygnIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgbWF5YmVfbmVzdGVkX2NvbW1lbnQgc3RybV9fXG4gICAgfCBTb21lICcqJyAtPiBTdHJlYW0uanVuayBzdHJtX187IG1heWJlX2VuZF9jb21tZW50IHN0cm1fX1xuICAgIHwgU29tZSBfIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgY29tbWVudCBzdHJtX19cbiAgICB8IF8gLT4gcmFpc2UgU3RyZWFtLkZhaWx1cmVcbiAgYW5kIG1heWJlX25lc3RlZF9jb21tZW50IChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWUgJyonIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgbGV0IHMgPSBzdHJtX18gaW4gY29tbWVudCBzOyBjb21tZW50IHNcbiAgICB8IFNvbWUgXyAtPiBTdHJlYW0uanVuayBzdHJtX187IGNvbW1lbnQgc3RybV9fXG4gICAgfCBfIC0+IHJhaXNlIFN0cmVhbS5GYWlsdXJlXG4gIGFuZCBtYXliZV9lbmRfY29tbWVudCAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICcpJyAtPiBTdHJlYW0uanVuayBzdHJtX187ICgpXG4gICAgfCBTb21lICcqJyAtPiBTdHJlYW0uanVuayBzdHJtX187IG1heWJlX2VuZF9jb21tZW50IHN0cm1fX1xuICAgIHwgU29tZSBfIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgY29tbWVudCBzdHJtX19cbiAgICB8IF8gLT4gcmFpc2UgU3RyZWFtLkZhaWx1cmVcbiAgaW5cbiAgZnVuIGlucHV0IC0+IFN0cmVhbS5mcm9tIChmdW4gX2NvdW50IC0+IG5leHRfdG9rZW4gaW5wdXQpXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBEYW1pZW4gRG9saWdleiwgcHJvamV0IFBhcmEsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk3IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbltAQEBvY2FtbC53YXJuaW5nIFwiLTMyXCJdXG5cbm1vZHVsZSB0eXBlIFNlZWRlZFMgPSBzaWdcblxuICB0eXBlIGtleVxuICB0eXBlICEnYSB0XG4gIHZhbCBjcmVhdGUgOiA/cmFuZG9tICgqdGh3YXJ0IHRvb2xzL3N5bmNfc3RkbGliX2RvY3MqKSA6IGJvb2wgLT4gaW50IC0+ICdhIHRcbiAgdmFsIGNsZWFyIDogJ2EgdCAtPiB1bml0XG4gIHZhbCByZXNldCA6ICdhIHQgLT4gdW5pdFxuICB2YWwgY29weSA6ICdhIHQgLT4gJ2EgdFxuICB2YWwgYWRkIDogJ2EgdCAtPiBrZXkgLT4gJ2EgLT4gdW5pdFxuICB2YWwgcmVtb3ZlIDogJ2EgdCAtPiBrZXkgLT4gdW5pdFxuICB2YWwgZmluZCA6ICdhIHQgLT4ga2V5IC0+ICdhXG4gIHZhbCBmaW5kX29wdCA6ICdhIHQgLT4ga2V5IC0+ICdhIG9wdGlvblxuICB2YWwgZmluZF9hbGwgOiAnYSB0IC0+IGtleSAtPiAnYSBsaXN0XG4gIHZhbCByZXBsYWNlIDogJ2EgdCAtPiBrZXkgLT4gJ2EgLT4gdW5pdFxuICB2YWwgbWVtIDogJ2EgdCAtPiBrZXkgLT4gYm9vbFxuICB2YWwgaXRlciA6IChrZXkgLT4gJ2EgLT4gdW5pdCkgLT4gJ2EgdCAtPiB1bml0XG4gICAgW0BAYWxlcnQgb2xkX2VwaGVtZXJvbl9hcGkgXCJUaGlzIGZ1bmN0aW9uIHdvbid0IGJlIGF2YWlsYWJsZSBpbiA1LjBcIl1cbiAgdmFsIGZpbHRlcl9tYXBfaW5wbGFjZSA6IChrZXkgLT4gJ2EgLT4gJ2Egb3B0aW9uKSAtPiAnYSB0IC0+IHVuaXRcbiAgICBbQEBhbGVydCBvbGRfZXBoZW1lcm9uX2FwaSBcIlRoaXMgZnVuY3Rpb24gd29uJ3QgYmUgYXZhaWxhYmxlIGluIDUuMFwiXVxuICB2YWwgZm9sZCA6IChrZXkgLT4gJ2EgLT4gJ2IgLT4gJ2IpIC0+ICdhIHQgLT4gJ2IgLT4gJ2JcbiAgICBbQEBhbGVydCBvbGRfZXBoZW1lcm9uX2FwaSBcIlRoaXMgZnVuY3Rpb24gd29uJ3QgYmUgYXZhaWxhYmxlIGluIDUuMFwiXVxuICB2YWwgbGVuZ3RoIDogJ2EgdCAtPiBpbnRcbiAgdmFsIHN0YXRzIDogJ2EgdCAtPiBIYXNodGJsLnN0YXRpc3RpY3NcbiAgdmFsIHRvX3NlcSA6ICdhIHQgLT4gKGtleSAqICdhKSBTZXEudFxuICAgIFtAQGFsZXJ0IG9sZF9lcGhlbWVyb25fYXBpIFwiVGhpcyBmdW5jdGlvbiB3b24ndCBiZSBhdmFpbGFibGUgaW4gNS4wXCJdXG4gIHZhbCB0b19zZXFfa2V5cyA6IF8gdCAtPiBrZXkgU2VxLnRcbiAgICBbQEBhbGVydCBvbGRfZXBoZW1lcm9uX2FwaSBcIlRoaXMgZnVuY3Rpb24gd29uJ3QgYmUgYXZhaWxhYmxlIGluIDUuMFwiXVxuICB2YWwgdG9fc2VxX3ZhbHVlcyA6ICdhIHQgLT4gJ2EgU2VxLnRcbiAgICBbQEBhbGVydCBvbGRfZXBoZW1lcm9uX2FwaSBcIlRoaXMgZnVuY3Rpb24gd29uJ3QgYmUgYXZhaWxhYmxlIGluIDUuMFwiXVxuICB2YWwgYWRkX3NlcSA6ICdhIHQgLT4gKGtleSAqICdhKSBTZXEudCAtPiB1bml0XG4gIHZhbCByZXBsYWNlX3NlcSA6ICdhIHQgLT4gKGtleSAqICdhKSBTZXEudCAtPiB1bml0XG4gIHZhbCBvZl9zZXEgOiAoa2V5ICogJ2EpIFNlcS50IC0+ICdhIHRcbiAgdmFsIGNsZWFuOiAnYSB0IC0+IHVuaXRcbiAgdmFsIHN0YXRzX2FsaXZlOiAnYSB0IC0+IEhhc2h0Ymwuc3RhdGlzdGljc1xuICAgICgqKiBzYW1lIGFzIHshc3RhdHN9IGJ1dCBvbmx5IGNvdW50IHRoZSBhbGl2ZSBiaW5kaW5ncyAqKVxuZW5kXG5cbm1vZHVsZSB0eXBlIFMgPSBzaWdcblxuICB0eXBlIGtleVxuICB0eXBlICEnYSB0XG4gIHZhbCBjcmVhdGUgOiBpbnQgLT4gJ2EgdFxuICB2YWwgY2xlYXIgOiAnYSB0IC0+IHVuaXRcbiAgdmFsIHJlc2V0IDogJ2EgdCAtPiB1bml0XG4gIHZhbCBjb3B5IDogJ2EgdCAtPiAnYSB0XG4gIHZhbCBhZGQgOiAnYSB0IC0+IGtleSAtPiAnYSAtPiB1bml0XG4gIHZhbCByZW1vdmUgOiAnYSB0IC0+IGtleSAtPiB1bml0XG4gIHZhbCBmaW5kIDogJ2EgdCAtPiBrZXkgLT4gJ2FcbiAgdmFsIGZpbmRfb3B0IDogJ2EgdCAtPiBrZXkgLT4gJ2Egb3B0aW9uXG4gIHZhbCBmaW5kX2FsbCA6ICdhIHQgLT4ga2V5IC0+ICdhIGxpc3RcbiAgdmFsIHJlcGxhY2UgOiAnYSB0IC0+IGtleSAtPiAnYSAtPiB1bml0XG4gIHZhbCBtZW0gOiAnYSB0IC0+IGtleSAtPiBib29sXG4gIHZhbCBpdGVyIDogKGtleSAtPiAnYSAtPiB1bml0KSAtPiAnYSB0IC0+IHVuaXRcbiAgICBbQEBhbGVydCBvbGRfZXBoZW1lcm9uX2FwaSBcIlRoaXMgZnVuY3Rpb24gd29uJ3QgYmUgYXZhaWxhYmxlIGluIDUuMFwiXVxuICB2YWwgZmlsdGVyX21hcF9pbnBsYWNlIDogKGtleSAtPiAnYSAtPiAnYSBvcHRpb24pIC0+ICdhIHQgLT4gdW5pdFxuICAgIFtAQGFsZXJ0IG9sZF9lcGhlbWVyb25fYXBpIFwiVGhpcyBmdW5jdGlvbiB3b24ndCBiZSBhdmFpbGFibGUgaW4gNS4wXCJdXG4gIHZhbCBmb2xkIDogKGtleSAtPiAnYSAtPiAnYiAtPiAnYikgLT4gJ2EgdCAtPiAnYiAtPiAnYlxuICAgIFtAQGFsZXJ0IG9sZF9lcGhlbWVyb25fYXBpIFwiVGhpcyBmdW5jdGlvbiB3b24ndCBiZSBhdmFpbGFibGUgaW4gNS4wXCJdXG4gIHZhbCBsZW5ndGggOiAnYSB0IC0+IGludFxuICB2YWwgc3RhdHMgOiAnYSB0IC0+IEhhc2h0Ymwuc3RhdGlzdGljc1xuICB2YWwgdG9fc2VxIDogJ2EgdCAtPiAoa2V5ICogJ2EpIFNlcS50XG4gICAgW0BAYWxlcnQgb2xkX2VwaGVtZXJvbl9hcGkgXCJUaGlzIGZ1bmN0aW9uIHdvbid0IGJlIGF2YWlsYWJsZSBpbiA1LjBcIl1cbiAgdmFsIHRvX3NlcV9rZXlzIDogXyB0IC0+IGtleSBTZXEudFxuICAgIFtAQGFsZXJ0IG9sZF9lcGhlbWVyb25fYXBpIFwiVGhpcyBmdW5jdGlvbiB3b24ndCBiZSBhdmFpbGFibGUgaW4gNS4wXCJdXG4gIHZhbCB0b19zZXFfdmFsdWVzIDogJ2EgdCAtPiAnYSBTZXEudFxuICAgIFtAQGFsZXJ0IG9sZF9lcGhlbWVyb25fYXBpIFwiVGhpcyBmdW5jdGlvbiB3b24ndCBiZSBhdmFpbGFibGUgaW4gNS4wXCJdXG4gIHZhbCBhZGRfc2VxIDogJ2EgdCAtPiAoa2V5ICogJ2EpIFNlcS50IC0+IHVuaXRcbiAgdmFsIHJlcGxhY2Vfc2VxIDogJ2EgdCAtPiAoa2V5ICogJ2EpIFNlcS50IC0+IHVuaXRcbiAgdmFsIG9mX3NlcSA6IChrZXkgKiAnYSkgU2VxLnQgLT4gJ2EgdFxuICB2YWwgY2xlYW46ICdhIHQgLT4gdW5pdFxuICB2YWwgc3RhdHNfYWxpdmU6ICdhIHQgLT4gSGFzaHRibC5zdGF0aXN0aWNzXG4gICAgKCoqIHNhbWUgYXMgeyFzdGF0c30gYnV0IG9ubHkgY291bnQgdGhlIGFsaXZlIGJpbmRpbmdzICopXG5lbmRcblxubW9kdWxlIEdlbkhhc2hUYWJsZSA9IHN0cnVjdFxuXG4gIHR5cGUgZXF1YWwgPVxuICB8IEVUcnVlIHwgRUZhbHNlXG4gIHwgRURlYWQgKCoqIHRoZSBnYXJiYWdlIGNvbGxlY3RvciByZWNsYWltZWQgdGhlIGRhdGEgKilcblxuICBtb2R1bGUgTWFrZVNlZWRlZChIOiBzaWdcbiAgICB0eXBlIHRcbiAgICB0eXBlICdhIGNvbnRhaW5lclxuICAgIHZhbCBjcmVhdGU6IHQgLT4gJ2EgLT4gJ2EgY29udGFpbmVyXG4gICAgdmFsIGhhc2g6IGludCAtPiB0IC0+IGludFxuICAgIHZhbCBlcXVhbDogJ2EgY29udGFpbmVyIC0+IHQgLT4gZXF1YWxcbiAgICB2YWwgZ2V0X2RhdGE6ICdhIGNvbnRhaW5lciAtPiAnYSBvcHRpb25cbiAgICB2YWwgZ2V0X2tleTogJ2EgY29udGFpbmVyIC0+IHQgb3B0aW9uXG4gICAgdmFsIHNldF9rZXlfZGF0YTogJ2EgY29udGFpbmVyIC0+IHQgLT4gJ2EgLT4gdW5pdFxuICAgIHZhbCBjaGVja19rZXk6ICdhIGNvbnRhaW5lciAtPiBib29sXG4gIGVuZCkgOiBTZWVkZWRTIHdpdGggdHlwZSBrZXkgPSBILnRcbiAgPSBzdHJ1Y3RcblxuICAgIHR5cGUgJ2EgdCA9XG4gICAgICB7IG11dGFibGUgc2l6ZTogaW50OyAgICAgICAgICAgICAgICAgICgqIG51bWJlciBvZiBlbnRyaWVzICopXG4gICAgICAgIG11dGFibGUgZGF0YTogJ2EgYnVja2V0bGlzdCBhcnJheTsgICgqIHRoZSBidWNrZXRzICopXG4gICAgICAgIHNlZWQ6IGludDsgICAgICAgICAgICAgICAgICAgICAgICAgICgqIGZvciByYW5kb21pemF0aW9uICopXG4gICAgICAgIGluaXRpYWxfc2l6ZTogaW50OyAgICAgICAgICAgICAgICAgICgqIGluaXRpYWwgYXJyYXkgc2l6ZSAqKVxuICAgICAgfVxuXG4gICAgYW5kICdhIGJ1Y2tldGxpc3QgPVxuICAgIHwgRW1wdHlcbiAgICB8IENvbnMgb2YgaW50ICgqIGhhc2ggb2YgdGhlIGtleSAqKSAqICdhIEguY29udGFpbmVyICogJ2EgYnVja2V0bGlzdFxuXG4gICAgKCoqIHRoZSBoYXNoIG9mIHRoZSBrZXkgaXMga2VwdCBpbiBvcmRlciB0byB0ZXN0IHRoZSBlcXVhbGl0eSBvZiB0aGUgaGFzaFxuICAgICAgYmVmb3JlIHRoZSBrZXkuIFNhbWUgcmVhc29uIGFzIGZvciBXZWFrLk1ha2UgKilcblxuICAgIHR5cGUga2V5ID0gSC50XG5cbiAgICBsZXQgcmVjIHBvd2VyXzJfYWJvdmUgeCBuID1cbiAgICAgIGlmIHggPj0gbiB0aGVuIHhcbiAgICAgIGVsc2UgaWYgeCAqIDIgPiBTeXMubWF4X2FycmF5X2xlbmd0aCB0aGVuIHhcbiAgICAgIGVsc2UgcG93ZXJfMl9hYm92ZSAoeCAqIDIpIG5cblxuICAgIGxldCBwcm5nID0gbGF6eSAoUmFuZG9tLlN0YXRlLm1ha2Vfc2VsZl9pbml0KCkpXG5cbiAgICBsZXQgY3JlYXRlID8ocmFuZG9tID0gKEhhc2h0YmwuaXNfcmFuZG9taXplZCAoKSkpIGluaXRpYWxfc2l6ZSA9XG4gICAgICBsZXQgcyA9IHBvd2VyXzJfYWJvdmUgMTYgaW5pdGlhbF9zaXplIGluXG4gICAgICBsZXQgc2VlZCA9IGlmIHJhbmRvbSB0aGVuIFJhbmRvbS5TdGF0ZS5iaXRzIChMYXp5LmZvcmNlIHBybmcpIGVsc2UgMCBpblxuICAgICAgeyBpbml0aWFsX3NpemUgPSBzOyBzaXplID0gMDsgc2VlZCA9IHNlZWQ7IGRhdGEgPSBBcnJheS5tYWtlIHMgRW1wdHkgfVxuXG4gICAgbGV0IGNsZWFyIGggPVxuICAgICAgaC5zaXplIDwtIDA7XG4gICAgICBsZXQgbGVuID0gQXJyYXkubGVuZ3RoIGguZGF0YSBpblxuICAgICAgZm9yIGkgPSAwIHRvIGxlbiAtIDEgZG9cbiAgICAgICAgaC5kYXRhLihpKSA8LSBFbXB0eVxuICAgICAgZG9uZVxuXG4gICAgbGV0IHJlc2V0IGggPVxuICAgICAgbGV0IGxlbiA9IEFycmF5Lmxlbmd0aCBoLmRhdGEgaW5cbiAgICAgIGlmIGxlbiA9IGguaW5pdGlhbF9zaXplIHRoZW5cbiAgICAgICAgY2xlYXIgaFxuICAgICAgZWxzZSBiZWdpblxuICAgICAgICBoLnNpemUgPC0gMDtcbiAgICAgICAgaC5kYXRhIDwtIEFycmF5Lm1ha2UgaC5pbml0aWFsX3NpemUgRW1wdHlcbiAgICAgIGVuZFxuXG4gICAgbGV0IGNvcHkgaCA9IHsgaCB3aXRoIGRhdGEgPSBBcnJheS5jb3B5IGguZGF0YSB9XG5cbiAgICBsZXQga2V5X2luZGV4IGggaGtleSA9XG4gICAgICBoa2V5IGxhbmQgKEFycmF5Lmxlbmd0aCBoLmRhdGEgLSAxKVxuXG4gICAgbGV0IGNsZWFuIGggPVxuICAgICAgbGV0IHJlYyBkb19idWNrZXQgPSBmdW5jdGlvblxuICAgICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgICBFbXB0eVxuICAgICAgICB8IENvbnMoXywgYywgcmVzdCkgd2hlbiBub3QgKEguY2hlY2tfa2V5IGMpIC0+XG4gICAgICAgICAgICBoLnNpemUgPC0gaC5zaXplIC0gMTtcbiAgICAgICAgICAgIGRvX2J1Y2tldCByZXN0XG4gICAgICAgIHwgQ29ucyhoa2V5LCBjLCByZXN0KSAtPlxuICAgICAgICAgICAgQ29ucyhoa2V5LCBjLCBkb19idWNrZXQgcmVzdClcbiAgICAgIGluXG4gICAgICBsZXQgZCA9IGguZGF0YSBpblxuICAgICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCBkIC0gMSBkb1xuICAgICAgICBkLihpKSA8LSBkb19idWNrZXQgZC4oaSlcbiAgICAgIGRvbmVcblxuICAgICgqKiByZXNpemUgaXMgdGhlIG9ubHkgZnVuY3Rpb24gdG8gZG8gdGhlIGFjdHVhbCBjbGVhbmluZyBvZiBkZWFkIGtleXNcbiAgICAgICAgKHJlbW92ZSBkb2VzIGl0IGp1c3QgYmVjYXVzZSBpdCBjb3VsZCkuXG5cbiAgICAgICAgVGhlIGdvYWwgaXMgdG86XG5cbiAgICAgICAgLSBub3QgcmVzaXplIGluZmluaXRlbHkgd2hlbiB0aGUgYWN0dWFsIG51bWJlciBvZiBhbGl2ZSBrZXlzIGlzXG4gICAgICAgIGJvdW5kZWQgYnV0IGtleXMgYXJlIGNvbnRpbnVvdXNseSBhZGRlZC4gVGhhdCB3b3VsZCBoYXBwZW4gaWZcbiAgICAgICAgdGhpcyBmdW5jdGlvbiBhbHdheXMgcmVzaXplLlxuICAgICAgICAtIG5vdCBjYWxsIHRoaXMgZnVuY3Rpb24gYWZ0ZXIgZWFjaCBhZGRpdGlvbiwgdGhhdCB3b3VsZCBoYXBwZW4gaWYgdGhpc1xuICAgICAgICBmdW5jdGlvbiBkb24ndCByZXNpemUgZXZlbiB3aGVuIG9ubHkgb25lIGtleSBpcyBkZWFkLlxuXG4gICAgICAgIFNvIHRoZSBhbGdvcml0aG06XG4gICAgICAgIC0gY2xlYW4gdGhlIGtleXMgYmVmb3JlIHJlc2l6aW5nXG4gICAgICAgIC0gaWYgdGhlIG51bWJlciBvZiByZW1haW5pbmcga2V5cyBpcyBsZXNzIHRoYW4gaGFsZiB0aGUgc2l6ZSBvZiB0aGVcbiAgICAgICAgYXJyYXksIGRvbid0IHJlc2l6ZS5cbiAgICAgICAgLSBpZiBpdCBpcyBtb3JlLCByZXNpemUuXG5cbiAgICAgICAgVGhlIHNlY29uZCBwcm9ibGVtIHJlbWFpbnMgaWYgdGhlIHRhYmxlIHJlYWNoZXMgeyFTeXMubWF4X2FycmF5X2xlbmd0aH0uXG5cbiAgICAqKVxuICAgIGxldCByZXNpemUgaCA9XG4gICAgICBsZXQgb2RhdGEgPSBoLmRhdGEgaW5cbiAgICAgIGxldCBvc2l6ZSA9IEFycmF5Lmxlbmd0aCBvZGF0YSBpblxuICAgICAgbGV0IG5zaXplID0gb3NpemUgKiAyIGluXG4gICAgICBjbGVhbiBoO1xuICAgICAgaWYgbnNpemUgPCBTeXMubWF4X2FycmF5X2xlbmd0aCAmJiBoLnNpemUgPj0gb3NpemUgbHNyIDEgdGhlbiBiZWdpblxuICAgICAgICBsZXQgbmRhdGEgPSBBcnJheS5tYWtlIG5zaXplIEVtcHR5IGluXG4gICAgICAgIGguZGF0YSA8LSBuZGF0YTsgICAgICAgKCogc28gdGhhdCBrZXlfaW5kZXggc2VlcyB0aGUgbmV3IGJ1Y2tldCBjb3VudCAqKVxuICAgICAgICBsZXQgcmVjIGluc2VydF9idWNrZXQgPSBmdW5jdGlvblxuICAgICAgICAgICAgRW1wdHkgLT4gKClcbiAgICAgICAgICB8IENvbnMoaGtleSwgZGF0YSwgcmVzdCkgLT5cbiAgICAgICAgICAgICAgaW5zZXJ0X2J1Y2tldCByZXN0OyAoKiBwcmVzZXJ2ZSBvcmlnaW5hbCBvcmRlciBvZiBlbGVtZW50cyAqKVxuICAgICAgICAgICAgICBsZXQgbmlkeCA9IGtleV9pbmRleCBoIGhrZXkgaW5cbiAgICAgICAgICAgICAgbmRhdGEuKG5pZHgpIDwtIENvbnMoaGtleSwgZGF0YSwgbmRhdGEuKG5pZHgpKSBpblxuICAgICAgICBmb3IgaSA9IDAgdG8gb3NpemUgLSAxIGRvXG4gICAgICAgICAgaW5zZXJ0X2J1Y2tldCBvZGF0YS4oaSlcbiAgICAgICAgZG9uZVxuICAgICAgZW5kXG5cbiAgICBsZXQgYWRkIGgga2V5IGluZm8gPVxuICAgICAgbGV0IGhrZXkgPSBILmhhc2ggaC5zZWVkIGtleSBpblxuICAgICAgbGV0IGkgPSBrZXlfaW5kZXggaCBoa2V5IGluXG4gICAgICBsZXQgY29udGFpbmVyID0gSC5jcmVhdGUga2V5IGluZm8gaW5cbiAgICAgIGxldCBidWNrZXQgPSBDb25zKGhrZXksIGNvbnRhaW5lciwgaC5kYXRhLihpKSkgaW5cbiAgICAgIGguZGF0YS4oaSkgPC0gYnVja2V0O1xuICAgICAgaC5zaXplIDwtIGguc2l6ZSArIDE7XG4gICAgICBpZiBoLnNpemUgPiBBcnJheS5sZW5ndGggaC5kYXRhIGxzbCAxIHRoZW4gcmVzaXplIGhcblxuICAgIGxldCByZW1vdmUgaCBrZXkgPVxuICAgICAgbGV0IGhrZXkgPSBILmhhc2ggaC5zZWVkIGtleSBpblxuICAgICAgbGV0IHJlYyByZW1vdmVfYnVja2V0ID0gZnVuY3Rpb25cbiAgICAgICAgfCBFbXB0eSAtPiBFbXB0eVxuICAgICAgICB8IENvbnMoaGssIGMsIG5leHQpIHdoZW4gaGtleSA9IGhrIC0+XG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBILmVxdWFsIGMga2V5IHdpdGhcbiAgICAgICAgICAgIHwgRVRydWUgLT4gaC5zaXplIDwtIGguc2l6ZSAtIDE7IG5leHRcbiAgICAgICAgICAgIHwgRUZhbHNlIC0+IENvbnMoaGssIGMsIHJlbW92ZV9idWNrZXQgbmV4dClcbiAgICAgICAgICAgIHwgRURlYWQgLT5cbiAgICAgICAgICAgICAgICAoKiBUaGUgZGVhZCBrZXkgaXMgYXV0b21hdGljYWxseSByZW1vdmVkLiBJdCBpcyBhY2NlcHRhYmxlXG4gICAgICAgICAgICAgICAgICAgIGZvciB0aGlzIGZ1bmN0aW9uIHNpbmNlIGl0IGFscmVhZHkgcmVtb3ZlcyBhIGJpbmRpbmcgKilcbiAgICAgICAgICAgICAgICBoLnNpemUgPC0gaC5zaXplIC0gMTtcbiAgICAgICAgICAgICAgICByZW1vdmVfYnVja2V0IG5leHRcbiAgICAgICAgICAgIGVuZFxuICAgICAgICB8IENvbnMoaGssYyxuZXh0KSAtPiBDb25zKGhrLCBjLCByZW1vdmVfYnVja2V0IG5leHQpIGluXG4gICAgICBsZXQgaSA9IGtleV9pbmRleCBoIGhrZXkgaW5cbiAgICAgIGguZGF0YS4oaSkgPC0gcmVtb3ZlX2J1Y2tldCBoLmRhdGEuKGkpXG5cbiAgICAoKiogeyFmaW5kfSBkb24ndCByZW1vdmUgZGVhZCBrZXlzIGJlY2F1c2UgaXQgd291bGQgYmUgc3VycHJpc2luZyBmb3JcbiAgICAgICAgdGhlIHVzZXIgdGhhdCBhIHJlYWQtb25seSBmdW5jdGlvbiBtdXRhdGVzIHRoZSBzdGF0ZSAoZWcuIGNvbmN1cnJlbnRcbiAgICAgICAgYWNjZXNzKS4gU2FtZSBmb3IgeyFpdGVyfSwgeyFmb2xkfSwgeyFtZW19LlxuICAgICopXG4gICAgbGV0IHJlYyBmaW5kX3JlYyBrZXkgaGtleSA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IENvbnMoaGssIGMsIHJlc3QpIHdoZW4gaGtleSA9IGhrICAtPlxuICAgICAgICAgIGJlZ2luIG1hdGNoIEguZXF1YWwgYyBrZXkgd2l0aFxuICAgICAgICAgIHwgRVRydWUgLT5cbiAgICAgICAgICAgICAgYmVnaW4gbWF0Y2ggSC5nZXRfZGF0YSBjIHdpdGhcbiAgICAgICAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgICAgICAgICAoKiBUaGlzIGNhc2UgaXMgbm90IGltcG9zc2libGUgYmVjYXVzZSB0aGUgZ2MgY2FuIHJ1biBiZXR3ZWVuXG4gICAgICAgICAgICAgICAgICAgICAgSC5lcXVhbCBhbmQgSC5nZXRfZGF0YSAqKVxuICAgICAgICAgICAgICAgICAgZmluZF9yZWMga2V5IGhrZXkgcmVzdFxuICAgICAgICAgICAgICB8IFNvbWUgZCAtPiBkXG4gICAgICAgICAgICAgIGVuZFxuICAgICAgICAgIHwgRUZhbHNlIC0+IGZpbmRfcmVjIGtleSBoa2V5IHJlc3RcbiAgICAgICAgICB8IEVEZWFkIC0+XG4gICAgICAgICAgICAgIGZpbmRfcmVjIGtleSBoa2V5IHJlc3RcbiAgICAgICAgICBlbmRcbiAgICAgIHwgQ29ucyhfLCBfLCByZXN0KSAtPlxuICAgICAgICAgIGZpbmRfcmVjIGtleSBoa2V5IHJlc3RcblxuICAgIGxldCBmaW5kIGgga2V5ID1cbiAgICAgIGxldCBoa2V5ID0gSC5oYXNoIGguc2VlZCBrZXkgaW5cbiAgICAgICgqIFRPRE8gaW5saW5lIDMgaXRlcmF0aW9ucyAqKVxuICAgICAgZmluZF9yZWMga2V5IGhrZXkgKGguZGF0YS4oa2V5X2luZGV4IGggaGtleSkpXG5cbiAgICBsZXQgcmVjIGZpbmRfcmVjX29wdCBrZXkgaGtleSA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgTm9uZVxuICAgICAgfCBDb25zKGhrLCBjLCByZXN0KSB3aGVuIGhrZXkgPSBoayAgLT5cbiAgICAgICAgICBiZWdpbiBtYXRjaCBILmVxdWFsIGMga2V5IHdpdGhcbiAgICAgICAgICB8IEVUcnVlIC0+XG4gICAgICAgICAgICAgIGJlZ2luIG1hdGNoIEguZ2V0X2RhdGEgYyB3aXRoXG4gICAgICAgICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgICAgICAgICAgKCogVGhpcyBjYXNlIGlzIG5vdCBpbXBvc3NpYmxlIGJlY2F1c2UgdGhlIGdjIGNhbiBydW4gYmV0d2VlblxuICAgICAgICAgICAgICAgICAgICAgIEguZXF1YWwgYW5kIEguZ2V0X2RhdGEgKilcbiAgICAgICAgICAgICAgICAgIGZpbmRfcmVjX29wdCBrZXkgaGtleSByZXN0XG4gICAgICAgICAgICAgIHwgU29tZSBfIGFzIGQgLT4gZFxuICAgICAgICAgICAgICBlbmRcbiAgICAgICAgICB8IEVGYWxzZSAtPiBmaW5kX3JlY19vcHQga2V5IGhrZXkgcmVzdFxuICAgICAgICAgIHwgRURlYWQgLT5cbiAgICAgICAgICAgICAgZmluZF9yZWNfb3B0IGtleSBoa2V5IHJlc3RcbiAgICAgICAgICBlbmRcbiAgICAgIHwgQ29ucyhfLCBfLCByZXN0KSAtPlxuICAgICAgICAgIGZpbmRfcmVjX29wdCBrZXkgaGtleSByZXN0XG5cbiAgICBsZXQgZmluZF9vcHQgaCBrZXkgPVxuICAgICAgbGV0IGhrZXkgPSBILmhhc2ggaC5zZWVkIGtleSBpblxuICAgICAgKCogVE9ETyBpbmxpbmUgMyBpdGVyYXRpb25zICopXG4gICAgICBmaW5kX3JlY19vcHQga2V5IGhrZXkgKGguZGF0YS4oa2V5X2luZGV4IGggaGtleSkpXG5cbiAgICBsZXQgZmluZF9hbGwgaCBrZXkgPVxuICAgICAgbGV0IGhrZXkgPSBILmhhc2ggaC5zZWVkIGtleSBpblxuICAgICAgbGV0IHJlYyBmaW5kX2luX2J1Y2tldCA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+IFtdXG4gICAgICB8IENvbnMoaGssIGMsIHJlc3QpIHdoZW4gaGtleSA9IGhrICAtPlxuICAgICAgICAgIGJlZ2luIG1hdGNoIEguZXF1YWwgYyBrZXkgd2l0aFxuICAgICAgICAgIHwgRVRydWUgLT4gYmVnaW4gbWF0Y2ggSC5nZXRfZGF0YSBjIHdpdGhcbiAgICAgICAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgICAgICAgICBmaW5kX2luX2J1Y2tldCByZXN0XG4gICAgICAgICAgICAgIHwgU29tZSBkIC0+IGQ6OmZpbmRfaW5fYnVja2V0IHJlc3RcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIHwgRUZhbHNlIC0+IGZpbmRfaW5fYnVja2V0IHJlc3RcbiAgICAgICAgICB8IEVEZWFkIC0+XG4gICAgICAgICAgICAgIGZpbmRfaW5fYnVja2V0IHJlc3RcbiAgICAgICAgICBlbmRcbiAgICAgIHwgQ29ucyhfLCBfLCByZXN0KSAtPlxuICAgICAgICAgIGZpbmRfaW5fYnVja2V0IHJlc3QgaW5cbiAgICAgIGZpbmRfaW5fYnVja2V0IGguZGF0YS4oa2V5X2luZGV4IGggaGtleSlcblxuXG4gICAgbGV0IHJlcGxhY2UgaCBrZXkgaW5mbyA9XG4gICAgICBsZXQgaGtleSA9IEguaGFzaCBoLnNlZWQga2V5IGluXG4gICAgICBsZXQgcmVjIHJlcGxhY2VfYnVja2V0ID0gZnVuY3Rpb25cbiAgICAgICAgfCBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgICAgfCBDb25zKGhrLCBjLCBuZXh0KSB3aGVuIGhrZXkgPSBoayAtPlxuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggSC5lcXVhbCBjIGtleSB3aXRoXG4gICAgICAgICAgICB8IEVUcnVlIC0+IEguc2V0X2tleV9kYXRhIGMga2V5IGluZm9cbiAgICAgICAgICAgIHwgRUZhbHNlIHwgRURlYWQgLT4gcmVwbGFjZV9idWNrZXQgbmV4dFxuICAgICAgICAgICAgZW5kXG4gICAgICAgIHwgQ29ucyhfLF8sbmV4dCkgLT4gcmVwbGFjZV9idWNrZXQgbmV4dFxuICAgICAgaW5cbiAgICAgIGxldCBpID0ga2V5X2luZGV4IGggaGtleSBpblxuICAgICAgbGV0IGwgPSBoLmRhdGEuKGkpIGluXG4gICAgICB0cnlcbiAgICAgICAgcmVwbGFjZV9idWNrZXQgbFxuICAgICAgd2l0aCBOb3RfZm91bmQgLT5cbiAgICAgICAgbGV0IGNvbnRhaW5lciA9IEguY3JlYXRlIGtleSBpbmZvIGluXG4gICAgICAgIGguZGF0YS4oaSkgPC0gQ29ucyhoa2V5LCBjb250YWluZXIsIGwpO1xuICAgICAgICBoLnNpemUgPC0gaC5zaXplICsgMTtcbiAgICAgICAgaWYgaC5zaXplID4gQXJyYXkubGVuZ3RoIGguZGF0YSBsc2wgMSB0aGVuIHJlc2l6ZSBoXG5cbiAgICBsZXQgbWVtIGgga2V5ID1cbiAgICAgIGxldCBoa2V5ID0gSC5oYXNoIGguc2VlZCBrZXkgaW5cbiAgICAgIGxldCByZWMgbWVtX2luX2J1Y2tldCA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgZmFsc2VcbiAgICAgIHwgQ29ucyhoaywgYywgcmVzdCkgd2hlbiBoayA9IGhrZXkgLT5cbiAgICAgICAgICBiZWdpbiBtYXRjaCBILmVxdWFsIGMga2V5IHdpdGhcbiAgICAgICAgICB8IEVUcnVlIC0+IHRydWVcbiAgICAgICAgICB8IEVGYWxzZSB8IEVEZWFkIC0+IG1lbV9pbl9idWNrZXQgcmVzdFxuICAgICAgICAgIGVuZFxuICAgICAgfCBDb25zKF9oaywgX2MsIHJlc3QpIC0+IG1lbV9pbl9idWNrZXQgcmVzdCBpblxuICAgICAgbWVtX2luX2J1Y2tldCBoLmRhdGEuKGtleV9pbmRleCBoIGhrZXkpXG5cbiAgICBsZXQgaXRlciBmIGggPVxuICAgICAgbGV0IHJlYyBkb19idWNrZXQgPSBmdW5jdGlvblxuICAgICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgICAoKVxuICAgICAgICB8IENvbnMoXywgYywgcmVzdCkgLT5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIEguZ2V0X2tleSBjLCBILmdldF9kYXRhIGMgd2l0aFxuICAgICAgICAgICAgfCBOb25lLCBfIHwgXywgTm9uZSAtPiAoKVxuICAgICAgICAgICAgfCBTb21lIGssIFNvbWUgZCAtPiBmIGsgZFxuICAgICAgICAgICAgZW5kOyBkb19idWNrZXQgcmVzdCBpblxuICAgICAgbGV0IGQgPSBoLmRhdGEgaW5cbiAgICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggZCAtIDEgZG9cbiAgICAgICAgZG9fYnVja2V0IGQuKGkpXG4gICAgICBkb25lXG5cbiAgICBsZXQgZm9sZCBmIGggaW5pdCA9XG4gICAgICBsZXQgcmVjIGRvX2J1Y2tldCBiIGFjY3UgPVxuICAgICAgICBtYXRjaCBiIHdpdGhcbiAgICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgICAgYWNjdVxuICAgICAgICB8IENvbnMoXywgYywgcmVzdCkgLT5cbiAgICAgICAgICAgIGxldCBhY2N1ID0gYmVnaW4gbWF0Y2ggSC5nZXRfa2V5IGMsIEguZ2V0X2RhdGEgYyB3aXRoXG4gICAgICAgICAgICAgIHwgTm9uZSwgXyB8IF8sIE5vbmUgLT4gYWNjdVxuICAgICAgICAgICAgICB8IFNvbWUgaywgU29tZSBkIC0+IGYgayBkIGFjY3VcbiAgICAgICAgICAgIGVuZCBpblxuICAgICAgICAgICAgZG9fYnVja2V0IHJlc3QgYWNjdSAgaW5cbiAgICAgIGxldCBkID0gaC5kYXRhIGluXG4gICAgICBsZXQgYWNjdSA9IHJlZiBpbml0IGluXG4gICAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGQgLSAxIGRvXG4gICAgICAgIGFjY3UgOj0gZG9fYnVja2V0IGQuKGkpICFhY2N1XG4gICAgICBkb25lO1xuICAgICAgIWFjY3VcblxuICAgIGxldCBmaWx0ZXJfbWFwX2lucGxhY2UgZiBoID1cbiAgICAgIGxldCByZWMgZG9fYnVja2V0ID0gZnVuY3Rpb25cbiAgICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgICAgRW1wdHlcbiAgICAgICAgfCBDb25zKGhrLCBjLCByZXN0KSAtPlxuICAgICAgICAgICAgbWF0Y2ggSC5nZXRfa2V5IGMsIEguZ2V0X2RhdGEgYyB3aXRoXG4gICAgICAgICAgICB8IE5vbmUsIF8gfCBfLCBOb25lIC0+XG4gICAgICAgICAgICAgICAgZG9fYnVja2V0IHJlc3RcbiAgICAgICAgICAgIHwgU29tZSBrLCBTb21lIGQgLT5cbiAgICAgICAgICAgICAgICBtYXRjaCBmIGsgZCB3aXRoXG4gICAgICAgICAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgICAgICAgICAgIGRvX2J1Y2tldCByZXN0XG4gICAgICAgICAgICAgICAgfCBTb21lIG5ld19kIC0+XG4gICAgICAgICAgICAgICAgICAgIEguc2V0X2tleV9kYXRhIGMgayBuZXdfZDtcbiAgICAgICAgICAgICAgICAgICAgQ29ucyhoaywgYywgZG9fYnVja2V0IHJlc3QpXG4gICAgICBpblxuICAgICAgbGV0IGQgPSBoLmRhdGEgaW5cbiAgICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggZCAtIDEgZG9cbiAgICAgICAgZC4oaSkgPC0gZG9fYnVja2V0IGQuKGkpXG4gICAgICBkb25lXG5cbiAgICBsZXQgbGVuZ3RoIGggPSBoLnNpemVcblxuICAgIGxldCByZWMgYnVja2V0X2xlbmd0aCBhY2N1ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT4gYWNjdVxuICAgICAgfCBDb25zKF8sIF8sIHJlc3QpIC0+IGJ1Y2tldF9sZW5ndGggKGFjY3UgKyAxKSByZXN0XG5cbiAgICBsZXQgc3RhdHMgaCA9XG4gICAgICBsZXQgbWJsID1cbiAgICAgICAgQXJyYXkuZm9sZF9sZWZ0IChmdW4gbSBiIC0+IEludC5tYXggbSAoYnVja2V0X2xlbmd0aCAwIGIpKSAwIGguZGF0YSBpblxuICAgICAgbGV0IGhpc3RvID0gQXJyYXkubWFrZSAobWJsICsgMSkgMCBpblxuICAgICAgQXJyYXkuaXRlclxuICAgICAgICAoZnVuIGIgLT5cbiAgICAgICAgICAgbGV0IGwgPSBidWNrZXRfbGVuZ3RoIDAgYiBpblxuICAgICAgICAgICBoaXN0by4obCkgPC0gaGlzdG8uKGwpICsgMSlcbiAgICAgICAgaC5kYXRhO1xuICAgICAgeyBIYXNodGJsLm51bV9iaW5kaW5ncyA9IGguc2l6ZTtcbiAgICAgICAgbnVtX2J1Y2tldHMgPSBBcnJheS5sZW5ndGggaC5kYXRhO1xuICAgICAgICBtYXhfYnVja2V0X2xlbmd0aCA9IG1ibDtcbiAgICAgICAgYnVja2V0X2hpc3RvZ3JhbSA9IGhpc3RvIH1cblxuICAgIGxldCByZWMgYnVja2V0X2xlbmd0aF9hbGl2ZSBhY2N1ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT4gYWNjdVxuICAgICAgfCBDb25zKF8sIGMsIHJlc3QpIHdoZW4gSC5jaGVja19rZXkgYyAtPlxuICAgICAgICAgIGJ1Y2tldF9sZW5ndGhfYWxpdmUgKGFjY3UgKyAxKSByZXN0XG4gICAgICB8IENvbnMoXywgXywgcmVzdCkgLT4gYnVja2V0X2xlbmd0aF9hbGl2ZSBhY2N1IHJlc3RcblxuICAgIGxldCBzdGF0c19hbGl2ZSBoID1cbiAgICAgIGxldCBzaXplID0gcmVmIDAgaW5cbiAgICAgIGxldCBtYmwgPVxuICAgICAgICBBcnJheS5mb2xkX2xlZnRcbiAgICAgICAgICAoZnVuIG0gYiAtPiBJbnQubWF4IG0gKGJ1Y2tldF9sZW5ndGhfYWxpdmUgMCBiKSkgMCBoLmRhdGFcbiAgICAgIGluXG4gICAgICBsZXQgaGlzdG8gPSBBcnJheS5tYWtlIChtYmwgKyAxKSAwIGluXG4gICAgICBBcnJheS5pdGVyXG4gICAgICAgIChmdW4gYiAtPlxuICAgICAgICAgICBsZXQgbCA9IGJ1Y2tldF9sZW5ndGhfYWxpdmUgMCBiIGluXG4gICAgICAgICAgIHNpemUgOj0gIXNpemUgKyBsO1xuICAgICAgICAgICBoaXN0by4obCkgPC0gaGlzdG8uKGwpICsgMSlcbiAgICAgICAgaC5kYXRhO1xuICAgICAgeyBIYXNodGJsLm51bV9iaW5kaW5ncyA9ICFzaXplO1xuICAgICAgICBudW1fYnVja2V0cyA9IEFycmF5Lmxlbmd0aCBoLmRhdGE7XG4gICAgICAgIG1heF9idWNrZXRfbGVuZ3RoID0gbWJsO1xuICAgICAgICBidWNrZXRfaGlzdG9ncmFtID0gaGlzdG8gfVxuXG4gICAgbGV0IHRvX3NlcSB0YmwgPVxuICAgICAgKCogY2FwdHVyZSBjdXJyZW50IGFycmF5LCBzbyB0aGF0IGV2ZW4gaWYgdGhlIHRhYmxlIGlzIHJlc2l6ZWQgd2VcbiAgICAgICAgIGtlZXAgaXRlcmF0aW5nIG9uIHRoZSBzYW1lIGFycmF5ICopXG4gICAgICBsZXQgdGJsX2RhdGEgPSB0YmwuZGF0YSBpblxuICAgICAgKCogc3RhdGU6IGluZGV4ICogbmV4dCBidWNrZXQgdG8gdHJhdmVyc2UgKilcbiAgICAgIGxldCByZWMgYXV4IGkgYnVjayAoKSA9IG1hdGNoIGJ1Y2sgd2l0aFxuICAgICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgICBpZiBpID0gQXJyYXkubGVuZ3RoIHRibF9kYXRhXG4gICAgICAgICAgICB0aGVuIFNlcS5OaWxcbiAgICAgICAgICAgIGVsc2UgYXV4KGkrMSkgdGJsX2RhdGEuKGkpICgpXG4gICAgICAgIHwgQ29ucyAoXywgYywgbmV4dCkgLT5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIEguZ2V0X2tleSBjLCBILmdldF9kYXRhIGMgd2l0aFxuICAgICAgICAgICAgICB8IE5vbmUsIF8gfCBfLCBOb25lIC0+IGF1eCBpIG5leHQgKClcbiAgICAgICAgICAgICAgfCBTb21lIGtleSwgU29tZSBkYXRhIC0+XG4gICAgICAgICAgICAgICAgICBTZXEuQ29ucyAoKGtleSwgZGF0YSksIGF1eCBpIG5leHQpXG4gICAgICAgICAgICBlbmRcbiAgICAgIGluXG4gICAgICBhdXggMCBFbXB0eVxuXG4gICAgbGV0IHRvX3NlcV9rZXlzIG0gPSBTZXEubWFwIGZzdCAodG9fc2VxIG0pXG5cbiAgICBsZXQgdG9fc2VxX3ZhbHVlcyBtID0gU2VxLm1hcCBzbmQgKHRvX3NlcSBtKVxuXG4gICAgbGV0IGFkZF9zZXEgdGJsIGkgPVxuICAgICAgU2VxLml0ZXIgKGZ1biAoayx2KSAtPiBhZGQgdGJsIGsgdikgaVxuXG4gICAgbGV0IHJlcGxhY2Vfc2VxIHRibCBpID1cbiAgICAgIFNlcS5pdGVyIChmdW4gKGssdikgLT4gcmVwbGFjZSB0YmwgayB2KSBpXG5cbiAgICBsZXQgb2Zfc2VxIGkgPVxuICAgICAgbGV0IHRibCA9IGNyZWF0ZSAxNiBpblxuICAgICAgcmVwbGFjZV9zZXEgdGJsIGk7XG4gICAgICB0YmxcblxuICBlbmRcbmVuZFxuXG5tb2R1bGUgT2JqRXBoID0gT2JqLkVwaGVtZXJvblxuXG5sZXQgX29ial9vcHQgOiBPYmoudCBvcHRpb24gLT4gJ2Egb3B0aW9uID0gZnVuIHggLT5cbiAgbWF0Y2ggeCB3aXRoXG4gIHwgTm9uZSAtPiB4XG4gIHwgU29tZSB2IC0+IFNvbWUgKE9iai5vYmogdilcblxuKCoqIFRoZSBwcmV2aW91cyBmdW5jdGlvbiBpcyB0eXBlZCBzbyB0aGlzIG9uZSBpcyBhbHNvIGNvcnJlY3QgKilcbmxldCBvYmpfb3B0IDogT2JqLnQgb3B0aW9uIC0+ICdhIG9wdGlvbiA9IGZ1biB4IC0+IE9iai5tYWdpYyB4XG5cblxubW9kdWxlIEsxID0gc3RydWN0XG4gIHR5cGUgKCdrLCdkKSB0ID0gT2JqRXBoLnRcblxuICBsZXQgY3JlYXRlICgpIDogKCdrLCdkKSB0ID0gT2JqRXBoLmNyZWF0ZSAxXG5cbiAgbGV0IGdldF9rZXkgKHQ6KCdrLCdkKSB0KSA6ICdrIG9wdGlvbiA9IG9ial9vcHQgKE9iakVwaC5nZXRfa2V5IHQgMClcbiAgbGV0IGdldF9rZXlfY29weSAodDooJ2ssJ2QpIHQpIDogJ2sgb3B0aW9uID0gb2JqX29wdCAoT2JqRXBoLmdldF9rZXlfY29weSB0IDApXG4gIGxldCBzZXRfa2V5ICh0OignaywnZCkgdCkgKGs6J2spIDogdW5pdCA9IE9iakVwaC5zZXRfa2V5IHQgMCAoT2JqLnJlcHIgaylcbiAgbGV0IHVuc2V0X2tleSAodDooJ2ssJ2QpIHQpIDogdW5pdCA9IE9iakVwaC51bnNldF9rZXkgdCAwXG4gIGxldCBjaGVja19rZXkgKHQ6KCdrLCdkKSB0KSA6IGJvb2wgPSBPYmpFcGguY2hlY2tfa2V5IHQgMFxuXG4gIGxldCBibGl0X2tleSAodDE6KCdrLCdkKSB0KSAodDI6KCdrLCdkKSB0KTogdW5pdCA9XG4gICAgT2JqRXBoLmJsaXRfa2V5IHQxIDAgdDIgMCAxXG5cbiAgbGV0IGdldF9kYXRhICh0OignaywnZCkgdCkgOiAnZCBvcHRpb24gPSBvYmpfb3B0IChPYmpFcGguZ2V0X2RhdGEgdClcbiAgbGV0IGdldF9kYXRhX2NvcHkgKHQ6KCdrLCdkKSB0KSA6ICdkIG9wdGlvbiA9IG9ial9vcHQgKE9iakVwaC5nZXRfZGF0YV9jb3B5IHQpXG4gIGxldCBzZXRfZGF0YSAodDooJ2ssJ2QpIHQpIChkOidkKSA6IHVuaXQgPSBPYmpFcGguc2V0X2RhdGEgdCAoT2JqLnJlcHIgZClcbiAgbGV0IHVuc2V0X2RhdGEgKHQ6KCdrLCdkKSB0KSA6IHVuaXQgPSBPYmpFcGgudW5zZXRfZGF0YSB0XG4gIGxldCBjaGVja19kYXRhICh0OignaywnZCkgdCkgOiBib29sID0gT2JqRXBoLmNoZWNrX2RhdGEgdFxuICBsZXQgYmxpdF9kYXRhICh0MTooXywnZCkgdCkgKHQyOihfLCdkKSB0KSA6IHVuaXQgPSBPYmpFcGguYmxpdF9kYXRhIHQxIHQyXG5cbiAgbGV0IG1ha2Uga2V5IGRhdGEgPVxuICAgIGxldCBlcGggPSBjcmVhdGUgKCkgaW5cbiAgICBzZXRfZGF0YSBlcGggZGF0YTtcbiAgICBzZXRfa2V5IGVwaCBrZXk7XG4gICAgZXBoXG5cbiAgbGV0IHF1ZXJ5IGVwaCBrZXkgPVxuICAgIG1hdGNoIGdldF9rZXkgZXBoIHdpdGhcbiAgICB8IE5vbmUgLT4gTm9uZVxuICAgIHwgU29tZSBrIHdoZW4gayA9PSBrZXkgLT4gZ2V0X2RhdGEgZXBoXG4gICAgfCBTb21lIF8gLT4gTm9uZVxuXG4gIG1vZHVsZSBNYWtlU2VlZGVkIChIOkhhc2h0YmwuU2VlZGVkSGFzaGVkVHlwZSkgPVxuICAgIEdlbkhhc2hUYWJsZS5NYWtlU2VlZGVkKHN0cnVjdFxuICAgICAgdHlwZSAnYSBjb250YWluZXIgPSAoSC50LCdhKSB0XG4gICAgICB0eXBlIHQgPSBILnRcbiAgICAgIGxldCBjcmVhdGUgayBkID1cbiAgICAgICAgbGV0IGMgPSBjcmVhdGUgKCkgaW5cbiAgICAgICAgc2V0X2RhdGEgYyBkO1xuICAgICAgICBzZXRfa2V5IGMgaztcbiAgICAgICAgY1xuICAgICAgbGV0IGhhc2ggPSBILmhhc2hcbiAgICAgIGxldCBlcXVhbCBjIGsgPVxuICAgICAgICAoKiB7IWdldF9rZXlfY29weX0gaXMgbm90IHVzZWQgYmVjYXVzZSB0aGUgZXF1YWxpdHkgb2YgdGhlIHVzZXIgY2FuIGJlXG4gICAgICAgICAgICB0aGUgcGh5c2ljYWwgZXF1YWxpdHkgKilcbiAgICAgICAgbWF0Y2ggZ2V0X2tleSBjIHdpdGhcbiAgICAgICAgfCBOb25lIC0+IEdlbkhhc2hUYWJsZS5FRGVhZFxuICAgICAgICB8IFNvbWUgaycgLT5cbiAgICAgICAgICAgIGlmIEguZXF1YWwgayBrJyB0aGVuIEdlbkhhc2hUYWJsZS5FVHJ1ZSBlbHNlIEdlbkhhc2hUYWJsZS5FRmFsc2VcbiAgICAgIGxldCBnZXRfZGF0YSA9IGdldF9kYXRhXG4gICAgICBsZXQgZ2V0X2tleSA9IGdldF9rZXlcbiAgICAgIGxldCBzZXRfa2V5X2RhdGEgYyBrIGQgPVxuICAgICAgICB1bnNldF9kYXRhIGM7XG4gICAgICAgIHNldF9rZXkgYyBrO1xuICAgICAgICBzZXRfZGF0YSBjIGRcbiAgICAgIGxldCBjaGVja19rZXkgPSBjaGVja19rZXlcbiAgICBlbmQpXG5cbiAgbW9kdWxlIE1ha2UoSDogSGFzaHRibC5IYXNoZWRUeXBlKTogKFMgd2l0aCB0eXBlIGtleSA9IEgudCkgPVxuICBzdHJ1Y3RcbiAgICBpbmNsdWRlIE1ha2VTZWVkZWQoc3RydWN0XG4gICAgICAgIHR5cGUgdCA9IEgudFxuICAgICAgICBsZXQgZXF1YWwgPSBILmVxdWFsXG4gICAgICAgIGxldCBoYXNoIChfc2VlZDogaW50KSB4ID0gSC5oYXNoIHhcbiAgICAgIGVuZClcbiAgICBsZXQgY3JlYXRlIHN6ID0gY3JlYXRlIH5yYW5kb206ZmFsc2Ugc3pcbiAgICBsZXQgb2Zfc2VxIGkgPVxuICAgICAgbGV0IHRibCA9IGNyZWF0ZSAxNiBpblxuICAgICAgcmVwbGFjZV9zZXEgdGJsIGk7XG4gICAgICB0YmxcbiAgZW5kXG5cbiAgbW9kdWxlIEJ1Y2tldCA9IHN0cnVjdFxuXG4gICAgdHlwZSBub25yZWMgKCdrLCAnZCkgdCA9ICgnaywgJ2QpIHQgbGlzdCByZWZcbiAgICBsZXQgazFfbWFrZSA9IG1ha2VcbiAgICBsZXQgbWFrZSAoKSA9IHJlZiBbXVxuICAgIGxldCBhZGQgYiBrIGQgPSBiIDo9IGsxX21ha2UgayBkIDo6ICFiXG5cbiAgICBsZXQgdGVzdF9rZXkgayBlID1cbiAgICAgIG1hdGNoIGdldF9rZXkgZSB3aXRoXG4gICAgICB8IFNvbWUgeCB3aGVuIHggPT0gayAtPiB0cnVlXG4gICAgICB8IF8gLT4gZmFsc2VcblxuICAgIGxldCByZW1vdmUgYiBrID1cbiAgICAgIGxldCByZWMgbG9vcCBsIGFjYyA9XG4gICAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgICB8IFtdIC0+ICgpXG4gICAgICAgIHwgaCA6OiB0IHdoZW4gdGVzdF9rZXkgayBoIC0+IGIgOj0gTGlzdC5yZXZfYXBwZW5kIGFjYyB0XG4gICAgICAgIHwgaCA6OiB0IC0+IGxvb3AgdCAoaCA6OiBhY2MpXG4gICAgICBpblxuICAgICAgbG9vcCAhYiBbXVxuXG4gICAgbGV0IGZpbmQgYiBrID1cbiAgICAgIG1hdGNoIExpc3QuZmluZF9vcHQgKHRlc3Rfa2V5IGspICFiIHdpdGhcbiAgICAgIHwgU29tZSBlIC0+IGdldF9kYXRhIGVcbiAgICAgIHwgTm9uZSAtPiBOb25lXG5cbiAgICBsZXQgbGVuZ3RoIGIgPSBMaXN0Lmxlbmd0aCAhYlxuICAgIGxldCBjbGVhciBiID0gYiA6PSBbXVxuXG4gIGVuZFxuXG5lbmRcblxubW9kdWxlIEsyID0gc3RydWN0XG4gIHR5cGUgKCdrMSwgJ2syLCAnZCkgdCA9IE9iakVwaC50XG5cbiAgbGV0IGNyZWF0ZSAoKSA6ICgnazEsJ2syLCdkKSB0ID0gT2JqRXBoLmNyZWF0ZSAyXG5cbiAgbGV0IGdldF9rZXkxICh0OignazEsJ2syLCdkKSB0KSA6ICdrMSBvcHRpb24gPSBvYmpfb3B0IChPYmpFcGguZ2V0X2tleSB0IDApXG4gIGxldCBnZXRfa2V5MV9jb3B5ICh0OignazEsJ2syLCdkKSB0KSA6ICdrMSBvcHRpb24gPVxuICAgIG9ial9vcHQgKE9iakVwaC5nZXRfa2V5X2NvcHkgdCAwKVxuICBsZXQgc2V0X2tleTEgKHQ6KCdrMSwnazIsJ2QpIHQpIChrOidrMSkgOiB1bml0ID1cbiAgICBPYmpFcGguc2V0X2tleSB0IDAgKE9iai5yZXByIGspXG4gIGxldCB1bnNldF9rZXkxICh0OignazEsJ2syLCdkKSB0KSA6IHVuaXQgPSBPYmpFcGgudW5zZXRfa2V5IHQgMFxuICBsZXQgY2hlY2tfa2V5MSAodDooJ2sxLCdrMiwnZCkgdCkgOiBib29sID0gT2JqRXBoLmNoZWNrX2tleSB0IDBcblxuICBsZXQgZ2V0X2tleTIgKHQ6KCdrMSwnazIsJ2QpIHQpIDogJ2syIG9wdGlvbiA9IG9ial9vcHQgKE9iakVwaC5nZXRfa2V5IHQgMSlcbiAgbGV0IGdldF9rZXkyX2NvcHkgKHQ6KCdrMSwnazIsJ2QpIHQpIDogJ2syIG9wdGlvbiA9XG4gICAgb2JqX29wdCAoT2JqRXBoLmdldF9rZXlfY29weSB0IDEpXG4gIGxldCBzZXRfa2V5MiAodDooJ2sxLCdrMiwnZCkgdCkgKGs6J2syKSA6IHVuaXQgPVxuICAgIE9iakVwaC5zZXRfa2V5IHQgMSAoT2JqLnJlcHIgaylcbiAgbGV0IHVuc2V0X2tleTIgKHQ6KCdrMSwnazIsJ2QpIHQpIDogdW5pdCA9IE9iakVwaC51bnNldF9rZXkgdCAxXG4gIGxldCBjaGVja19rZXkyICh0OignazEsJ2syLCdkKSB0KSA6IGJvb2wgPSBPYmpFcGguY2hlY2tfa2V5IHQgMVxuXG5cbiAgbGV0IGJsaXRfa2V5MSAodDE6KCdrMSxfLF8pIHQpICh0MjooJ2sxLF8sXykgdCkgOiB1bml0ID1cbiAgICBPYmpFcGguYmxpdF9rZXkgdDEgMCB0MiAwIDFcbiAgbGV0IGJsaXRfa2V5MiAodDE6KF8sJ2syLF8pIHQpICh0MjooXywnazIsXykgdCkgOiB1bml0ID1cbiAgICBPYmpFcGguYmxpdF9rZXkgdDEgMSB0MiAxIDFcbiAgbGV0IGJsaXRfa2V5MTIgKHQxOignazEsJ2syLF8pIHQpICh0MjooJ2sxLCdrMixfKSB0KSA6IHVuaXQgPVxuICAgIE9iakVwaC5ibGl0X2tleSB0MSAwIHQyIDAgMlxuXG4gIGxldCBnZXRfZGF0YSAodDooJ2sxLCdrMiwnZCkgdCkgOiAnZCBvcHRpb24gPSBvYmpfb3B0IChPYmpFcGguZ2V0X2RhdGEgdClcbiAgbGV0IGdldF9kYXRhX2NvcHkgKHQ6KCdrMSwnazIsJ2QpIHQpIDogJ2Qgb3B0aW9uID1cbiAgICBvYmpfb3B0IChPYmpFcGguZ2V0X2RhdGFfY29weSB0KVxuICBsZXQgc2V0X2RhdGEgKHQ6KCdrMSwnazIsJ2QpIHQpIChkOidkKSA6IHVuaXQgPVxuICAgIE9iakVwaC5zZXRfZGF0YSB0IChPYmoucmVwciBkKVxuICBsZXQgdW5zZXRfZGF0YSAodDooJ2sxLCdrMiwnZCkgdCkgOiB1bml0ID0gT2JqRXBoLnVuc2V0X2RhdGEgdFxuICBsZXQgY2hlY2tfZGF0YSAodDooJ2sxLCdrMiwnZCkgdCkgOiBib29sID0gT2JqRXBoLmNoZWNrX2RhdGEgdFxuICBsZXQgYmxpdF9kYXRhICh0MTooXyxfLCdkKSB0KSAodDI6KF8sXywnZCkgdCkgOiB1bml0ID0gT2JqRXBoLmJsaXRfZGF0YSB0MSB0MlxuXG4gIGxldCBtYWtlIGtleTEga2V5MiBkYXRhID1cbiAgICBsZXQgZXBoID0gY3JlYXRlICgpIGluXG4gICAgc2V0X2RhdGEgZXBoIGRhdGE7XG4gICAgc2V0X2tleTEgZXBoIGtleTE7XG4gICAgc2V0X2tleTIgZXBoIGtleTI7XG4gICAgaWdub3JlIChTeXMub3BhcXVlX2lkZW50aXR5IGtleTEpO1xuICAgIGVwaFxuXG4gIGxldCBxdWVyeSBlcGgga2V5MSBrZXkyID1cbiAgICBtYXRjaCBnZXRfa2V5MSBlcGggd2l0aFxuICAgIHwgTm9uZSAtPiBOb25lXG4gICAgfCBTb21lIGsgd2hlbiBrID09IGtleTEgLT5cbiAgICAgICAgYmVnaW4gbWF0Y2ggZ2V0X2tleTIgZXBoIHdpdGhcbiAgICAgICAgfCBOb25lIC0+IE5vbmVcbiAgICAgICAgfCBTb21lIGsgd2hlbiBrID09IGtleTIgLT4gZ2V0X2RhdGEgZXBoXG4gICAgICAgIHwgU29tZSBfIC0+IE5vbmVcbiAgICAgICAgZW5kXG4gICAgfCBTb21lIF8gLT4gTm9uZVxuXG4gIG1vZHVsZSBNYWtlU2VlZGVkXG4gICAgICAoSDE6SGFzaHRibC5TZWVkZWRIYXNoZWRUeXBlKVxuICAgICAgKEgyOkhhc2h0YmwuU2VlZGVkSGFzaGVkVHlwZSkgPVxuICAgIEdlbkhhc2hUYWJsZS5NYWtlU2VlZGVkKHN0cnVjdFxuICAgICAgdHlwZSAnYSBjb250YWluZXIgPSAoSDEudCxIMi50LCdhKSB0XG4gICAgICB0eXBlIHQgPSBIMS50ICogSDIudFxuICAgICAgbGV0IGNyZWF0ZSAoazEsazIpIGQgPVxuICAgICAgICBsZXQgYyA9IGNyZWF0ZSAoKSBpblxuICAgICAgICBzZXRfZGF0YSBjIGQ7XG4gICAgICAgIHNldF9rZXkxIGMgazE7IHNldF9rZXkyIGMgazI7XG4gICAgICAgIGNcbiAgICAgIGxldCBoYXNoIHNlZWQgKGsxLGsyKSA9XG4gICAgICAgIEgxLmhhc2ggc2VlZCBrMSArIEgyLmhhc2ggc2VlZCBrMiAqIDY1NTk5XG4gICAgICBsZXQgZXF1YWwgYyAoazEsazIpID1cbiAgICAgICAgbWF0Y2ggZ2V0X2tleTEgYywgZ2V0X2tleTIgYyB3aXRoXG4gICAgICAgIHwgTm9uZSwgXyB8IF8gLCBOb25lIC0+IEdlbkhhc2hUYWJsZS5FRGVhZFxuICAgICAgICB8IFNvbWUgazEnLCBTb21lIGsyJyAtPlxuICAgICAgICAgICAgaWYgSDEuZXF1YWwgazEgazEnICYmIEgyLmVxdWFsIGsyIGsyJ1xuICAgICAgICAgICAgdGhlbiBHZW5IYXNoVGFibGUuRVRydWUgZWxzZSBHZW5IYXNoVGFibGUuRUZhbHNlXG4gICAgICBsZXQgZ2V0X2RhdGEgPSBnZXRfZGF0YVxuICAgICAgbGV0IGdldF9rZXkgYyA9XG4gICAgICAgIG1hdGNoIGdldF9rZXkxIGMsIGdldF9rZXkyIGMgd2l0aFxuICAgICAgICB8IE5vbmUsIF8gfCBfICwgTm9uZSAtPiBOb25lXG4gICAgICAgIHwgU29tZSBrMScsIFNvbWUgazInIC0+IFNvbWUgKGsxJywgazInKVxuICAgICAgbGV0IHNldF9rZXlfZGF0YSBjIChrMSxrMikgZCA9XG4gICAgICAgIHVuc2V0X2RhdGEgYztcbiAgICAgICAgc2V0X2tleTEgYyBrMTsgc2V0X2tleTIgYyBrMjtcbiAgICAgICAgc2V0X2RhdGEgYyBkXG4gICAgICBsZXQgY2hlY2tfa2V5IGMgPSBjaGVja19rZXkxIGMgJiYgY2hlY2tfa2V5MiBjXG4gICAgZW5kKVxuXG4gIG1vZHVsZSBNYWtlKEgxOiBIYXNodGJsLkhhc2hlZFR5cGUpKEgyOiBIYXNodGJsLkhhc2hlZFR5cGUpOlxuICAgIChTIHdpdGggdHlwZSBrZXkgPSBIMS50ICogSDIudCkgPVxuICBzdHJ1Y3RcbiAgICBpbmNsdWRlIE1ha2VTZWVkZWRcbiAgICAgICAgKHN0cnVjdFxuICAgICAgICAgIHR5cGUgdCA9IEgxLnRcbiAgICAgICAgICBsZXQgZXF1YWwgPSBIMS5lcXVhbFxuICAgICAgICAgIGxldCBoYXNoIChfc2VlZDogaW50KSB4ID0gSDEuaGFzaCB4XG4gICAgICAgIGVuZClcbiAgICAgICAgKHN0cnVjdFxuICAgICAgICAgIHR5cGUgdCA9IEgyLnRcbiAgICAgICAgICBsZXQgZXF1YWwgPSBIMi5lcXVhbFxuICAgICAgICAgIGxldCBoYXNoIChfc2VlZDogaW50KSB4ID0gSDIuaGFzaCB4XG4gICAgICAgIGVuZClcbiAgICBsZXQgY3JlYXRlIHN6ID0gY3JlYXRlIH5yYW5kb206ZmFsc2Ugc3pcbiAgICBsZXQgb2Zfc2VxIGkgPVxuICAgICAgbGV0IHRibCA9IGNyZWF0ZSAxNiBpblxuICAgICAgcmVwbGFjZV9zZXEgdGJsIGk7XG4gICAgICB0YmxcbiAgZW5kXG5cbiAgbW9kdWxlIEJ1Y2tldCA9IHN0cnVjdFxuXG4gICAgdHlwZSBub25yZWMgKCdrMSwgJ2syLCAnZCkgdCA9ICgnazEsICdrMiwgJ2QpIHQgbGlzdCByZWZcbiAgICBsZXQgazJfbWFrZSA9IG1ha2VcbiAgICBsZXQgbWFrZSAoKSA9IHJlZiBbXVxuICAgIGxldCBhZGQgYiBrMSBrMiBkID0gYiA6PSBrMl9tYWtlIGsxIGsyIGQgOjogIWJcblxuICAgIGxldCB0ZXN0X2tleXMgazEgazIgZSA9XG4gICAgICBtYXRjaCBnZXRfa2V5MSBlLCBnZXRfa2V5MiBlIHdpdGhcbiAgICAgIHwgU29tZSB4MSwgU29tZSB4MiB3aGVuIHgxID09IGsxICYmIHgyID09IGsyIC0+IHRydWVcbiAgICAgIHwgXyAtPiBmYWxzZVxuXG4gICAgbGV0IHJlbW92ZSBiIGsxIGsyID1cbiAgICAgIGxldCByZWMgbG9vcCBsIGFjYyA9XG4gICAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgICB8IFtdIC0+ICgpXG4gICAgICAgIHwgaCA6OiB0IHdoZW4gdGVzdF9rZXlzIGsxIGsyIGggLT4gYiA6PSBMaXN0LnJldl9hcHBlbmQgYWNjIHRcbiAgICAgICAgfCBoIDo6IHQgLT4gbG9vcCB0IChoIDo6IGFjYylcbiAgICAgIGluXG4gICAgICBsb29wICFiIFtdXG5cbiAgICBsZXQgZmluZCBiIGsxIGsyID1cbiAgICAgIG1hdGNoIExpc3QuZmluZF9vcHQgKHRlc3Rfa2V5cyBrMSBrMikgIWIgd2l0aFxuICAgICAgfCBTb21lIGUgLT4gZ2V0X2RhdGEgZVxuICAgICAgfCBOb25lIC0+IE5vbmVcblxuICAgIGxldCBsZW5ndGggYiA9IExpc3QubGVuZ3RoICFiXG4gICAgbGV0IGNsZWFyIGIgPSBiIDo9IFtdXG5cbiAgZW5kXG5cbmVuZFxuXG5tb2R1bGUgS24gPSBzdHJ1Y3RcbiAgdHlwZSAoJ2ssJ2QpIHQgPSBPYmpFcGgudFxuXG4gIGxldCBjcmVhdGUgbiA6ICgnaywnZCkgdCA9IE9iakVwaC5jcmVhdGUgblxuICBsZXQgbGVuZ3RoIChrOignaywnZCkgdCkgOiBpbnQgPSBPYmpFcGgubGVuZ3RoIGtcblxuICBsZXQgZ2V0X2tleSAodDooJ2ssJ2QpIHQpIChuOmludCkgOiAnayBvcHRpb24gPSBvYmpfb3B0IChPYmpFcGguZ2V0X2tleSB0IG4pXG4gIGxldCBnZXRfa2V5X2NvcHkgKHQ6KCdrLCdkKSB0KSAobjppbnQpIDogJ2sgb3B0aW9uID1cbiAgICBvYmpfb3B0IChPYmpFcGguZ2V0X2tleV9jb3B5IHQgbilcbiAgbGV0IHNldF9rZXkgKHQ6KCdrLCdkKSB0KSAobjppbnQpIChrOidrKSA6IHVuaXQgPVxuICAgIE9iakVwaC5zZXRfa2V5IHQgbiAoT2JqLnJlcHIgaylcbiAgbGV0IHVuc2V0X2tleSAodDooJ2ssJ2QpIHQpIChuOmludCkgOiB1bml0ID0gT2JqRXBoLnVuc2V0X2tleSB0IG5cbiAgbGV0IGNoZWNrX2tleSAodDooJ2ssJ2QpIHQpIChuOmludCkgOiBib29sID0gT2JqRXBoLmNoZWNrX2tleSB0IG5cblxuICBsZXQgYmxpdF9rZXkgKHQxOignaywnZCkgdCkgKG8xOmludCkgKHQyOignaywnZCkgdCkgKG8yOmludCkgKGw6aW50KSA6IHVuaXQgPVxuICAgIE9iakVwaC5ibGl0X2tleSB0MSBvMSB0MiBvMiBsXG5cbiAgbGV0IGdldF9kYXRhICh0OignaywnZCkgdCkgOiAnZCBvcHRpb24gPSBvYmpfb3B0IChPYmpFcGguZ2V0X2RhdGEgdClcbiAgbGV0IGdldF9kYXRhX2NvcHkgKHQ6KCdrLCdkKSB0KSA6ICdkIG9wdGlvbiA9IG9ial9vcHQgKE9iakVwaC5nZXRfZGF0YV9jb3B5IHQpXG4gIGxldCBzZXRfZGF0YSAodDooJ2ssJ2QpIHQpIChkOidkKSA6IHVuaXQgPSBPYmpFcGguc2V0X2RhdGEgdCAoT2JqLnJlcHIgZClcbiAgbGV0IHVuc2V0X2RhdGEgKHQ6KCdrLCdkKSB0KSA6IHVuaXQgPSBPYmpFcGgudW5zZXRfZGF0YSB0XG4gIGxldCBjaGVja19kYXRhICh0OignaywnZCkgdCkgOiBib29sID0gT2JqRXBoLmNoZWNrX2RhdGEgdFxuICBsZXQgYmxpdF9kYXRhICh0MTooXywnZCkgdCkgKHQyOihfLCdkKSB0KSA6IHVuaXQgPSBPYmpFcGguYmxpdF9kYXRhIHQxIHQyXG5cbiAgbGV0IG1ha2Uga2V5cyBkYXRhID1cbiAgICBsZXQgbCA9IEFycmF5Lmxlbmd0aCBrZXlzIGluXG4gICAgbGV0IGVwaCA9IGNyZWF0ZSBsIGluXG4gICAgc2V0X2RhdGEgZXBoIGRhdGE7XG4gICAgZm9yIGkgPSAwIHRvIGwgLSAxIGRvIHNldF9rZXkgZXBoIGkga2V5cy4oaSkgZG9uZTtcbiAgICBlcGhcblxuICBsZXQgcXVlcnkgZXBoIGtleXMgPVxuICAgIGxldCBsID0gbGVuZ3RoIGVwaCBpblxuICAgIHRyeVxuICAgICAgaWYgbCA8PiBBcnJheS5sZW5ndGgga2V5cyB0aGVuIHJhaXNlIEV4aXQ7XG4gICAgICBmb3IgaSA9IDAgdG8gbCAtIDEgZG9cbiAgICAgICAgbWF0Y2ggZ2V0X2tleSBlcGggaSB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiByYWlzZSBFeGl0XG4gICAgICAgIHwgU29tZSBrIHdoZW4gayA9PSBrZXlzLihpKSAtPiAoKVxuICAgICAgICB8IFNvbWUgXyAtPiByYWlzZSBFeGl0XG4gICAgICBkb25lO1xuICAgICAgZ2V0X2RhdGEgZXBoXG4gICAgd2l0aCBFeGl0IC0+IE5vbmVcblxuICBtb2R1bGUgTWFrZVNlZWRlZCAoSDpIYXNodGJsLlNlZWRlZEhhc2hlZFR5cGUpID1cbiAgICBHZW5IYXNoVGFibGUuTWFrZVNlZWRlZChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgY29udGFpbmVyID0gKEgudCwnYSkgdFxuICAgICAgdHlwZSB0ID0gSC50IGFycmF5XG4gICAgICBsZXQgY3JlYXRlIGsgZCA9XG4gICAgICAgIGxldCBjID0gY3JlYXRlIChBcnJheS5sZW5ndGggaykgaW5cbiAgICAgICAgc2V0X2RhdGEgYyBkO1xuICAgICAgICBmb3IgaT0wIHRvIEFycmF5Lmxlbmd0aCBrIC0xIGRvXG4gICAgICAgICAgc2V0X2tleSBjIGkgay4oaSk7XG4gICAgICAgIGRvbmU7XG4gICAgICAgIGNcbiAgICAgIGxldCBoYXNoIHNlZWQgayA9XG4gICAgICAgIGxldCBoID0gcmVmIDAgaW5cbiAgICAgICAgZm9yIGk9MCB0byBBcnJheS5sZW5ndGggayAtMSBkb1xuICAgICAgICAgIGggOj0gSC5oYXNoIHNlZWQgay4oaSkgKiA2NTU5OSArICFoO1xuICAgICAgICBkb25lO1xuICAgICAgICAhaFxuICAgICAgbGV0IGVxdWFsIGMgayA9XG4gICAgICAgIGxldCBsZW4gID0gQXJyYXkubGVuZ3RoIGsgaW5cbiAgICAgICAgbGV0IGxlbicgPSBsZW5ndGggYyBpblxuICAgICAgICBpZiBsZW4gIT0gbGVuJyB0aGVuIEdlbkhhc2hUYWJsZS5FRmFsc2VcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGxldCByZWMgZXF1YWxfYXJyYXkgayBjIGkgPVxuICAgICAgICAgICAgaWYgaSA8IDAgdGhlbiBHZW5IYXNoVGFibGUuRVRydWVcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgbWF0Y2ggZ2V0X2tleSBjIGkgd2l0aFxuICAgICAgICAgICAgICB8IE5vbmUgLT4gR2VuSGFzaFRhYmxlLkVEZWFkXG4gICAgICAgICAgICAgIHwgU29tZSBraSAtPlxuICAgICAgICAgICAgICAgICAgaWYgSC5lcXVhbCBrLihpKSBraVxuICAgICAgICAgICAgICAgICAgdGhlbiBlcXVhbF9hcnJheSBrIGMgKGktMSlcbiAgICAgICAgICAgICAgICAgIGVsc2UgR2VuSGFzaFRhYmxlLkVGYWxzZVxuICAgICAgICAgIGluXG4gICAgICAgICAgZXF1YWxfYXJyYXkgayBjIChsZW4tMSlcbiAgICAgIGxldCBnZXRfZGF0YSA9IGdldF9kYXRhXG4gICAgICBsZXQgZ2V0X2tleSBjID1cbiAgICAgICAgbGV0IGxlbiA9IGxlbmd0aCBjIGluXG4gICAgICAgIGlmIGxlbiA9IDAgdGhlbiBTb21lIFt8fF1cbiAgICAgICAgZWxzZVxuICAgICAgICAgIG1hdGNoIGdldF9rZXkgYyAwIHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gTm9uZVxuICAgICAgICAgIHwgU29tZSBrMCAtPlxuICAgICAgICAgICAgICBsZXQgcmVjIGZpbGwgYSBpID1cbiAgICAgICAgICAgICAgICBpZiBpIDwgMSB0aGVuIFNvbWUgYVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgIG1hdGNoIGdldF9rZXkgYyBpIHdpdGhcbiAgICAgICAgICAgICAgICAgIHwgTm9uZSAtPiBOb25lXG4gICAgICAgICAgICAgICAgICB8IFNvbWUga2kgLT5cbiAgICAgICAgICAgICAgICAgICAgICBhLihpKSA8LSBraTtcbiAgICAgICAgICAgICAgICAgICAgICBmaWxsIGEgKGktMSlcbiAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgbGV0IGEgPSBBcnJheS5tYWtlIGxlbiBrMCBpblxuICAgICAgICAgICAgICBmaWxsIGEgKGxlbi0xKVxuICAgICAgbGV0IHNldF9rZXlfZGF0YSBjIGsgZCA9XG4gICAgICAgIHVuc2V0X2RhdGEgYztcbiAgICAgICAgZm9yIGk9MCB0byBBcnJheS5sZW5ndGggayAtMSBkb1xuICAgICAgICAgIHNldF9rZXkgYyBpIGsuKGkpO1xuICAgICAgICBkb25lO1xuICAgICAgICBzZXRfZGF0YSBjIGRcbiAgICAgIGxldCBjaGVja19rZXkgYyA9XG4gICAgICAgIGxldCByZWMgY2hlY2sgYyBpID1cbiAgICAgICAgICBpIDwgMCB8fCAoY2hlY2tfa2V5IGMgaSAmJiBjaGVjayBjIChpLTEpKSBpblxuICAgICAgICBjaGVjayBjIChsZW5ndGggYyAtIDEpXG4gICAgZW5kKVxuXG4gIG1vZHVsZSBNYWtlKEg6IEhhc2h0YmwuSGFzaGVkVHlwZSk6IChTIHdpdGggdHlwZSBrZXkgPSBILnQgYXJyYXkpID1cbiAgc3RydWN0XG4gICAgaW5jbHVkZSBNYWtlU2VlZGVkKHN0cnVjdFxuICAgICAgICB0eXBlIHQgPSBILnRcbiAgICAgICAgbGV0IGVxdWFsID0gSC5lcXVhbFxuICAgICAgICBsZXQgaGFzaCAoX3NlZWQ6IGludCkgeCA9IEguaGFzaCB4XG4gICAgICBlbmQpXG4gICAgbGV0IGNyZWF0ZSBzeiA9IGNyZWF0ZSB+cmFuZG9tOmZhbHNlIHN6XG4gICAgbGV0IG9mX3NlcSBpID1cbiAgICAgIGxldCB0YmwgPSBjcmVhdGUgMTYgaW5cbiAgICAgIHJlcGxhY2Vfc2VxIHRibCBpO1xuICAgICAgdGJsXG4gIGVuZFxuXG4gIG1vZHVsZSBCdWNrZXQgPSBzdHJ1Y3RcblxuICAgIHR5cGUgbm9ucmVjICgnaywgJ2QpIHQgPSAoJ2ssICdkKSB0IGxpc3QgcmVmXG4gICAgbGV0IGtuX21ha2UgPSBtYWtlXG4gICAgbGV0IG1ha2UgKCkgPSByZWYgW11cbiAgICBsZXQgYWRkIGIgayBkID0gYiA6PSBrbl9tYWtlIGsgZCA6OiAhYlxuXG4gICAgbGV0IHRlc3Rfa2V5cyBrIGUgPVxuICAgICAgdHJ5XG4gICAgICAgIGlmIGxlbmd0aCBlIDw+IEFycmF5Lmxlbmd0aCBrIHRoZW4gcmFpc2UgRXhpdDtcbiAgICAgICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCBrIC0gMSBkb1xuICAgICAgICAgIG1hdGNoIGdldF9rZXkgZSBpIHdpdGhcbiAgICAgICAgICB8IFNvbWUgeCB3aGVuIHggPT0gay4oaSkgLT4gKClcbiAgICAgICAgICB8IF8gLT4gcmFpc2UgRXhpdFxuICAgICAgICBkb25lO1xuICAgICAgICB0cnVlXG4gICAgICB3aXRoIEV4aXQgLT4gZmFsc2VcblxuICAgIGxldCByZW1vdmUgYiBrID1cbiAgICAgIGxldCByZWMgbG9vcCBsIGFjYyA9XG4gICAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgICB8IFtdIC0+ICgpXG4gICAgICAgIHwgaCA6OiB0IHdoZW4gdGVzdF9rZXlzIGsgaCAtPiBiIDo9IExpc3QucmV2X2FwcGVuZCBhY2MgdFxuICAgICAgICB8IGggOjogdCAtPiBsb29wIHQgKGggOjogYWNjKVxuICAgICAgaW5cbiAgICAgIGxvb3AgIWIgW11cblxuICAgIGxldCBmaW5kIGIgayA9XG4gICAgICBtYXRjaCBMaXN0LmZpbmRfb3B0ICh0ZXN0X2tleXMgaykgIWIgd2l0aFxuICAgICAgfCBTb21lIGUgLT4gZ2V0X2RhdGEgZVxuICAgICAgfCBOb25lIC0+IE5vbmVcblxuICAgIGxldCBsZW5ndGggYiA9IExpc3QubGVuZ3RoICFiXG4gICAgbGV0IGNsZWFyIGIgPSBiIDo9IFtdXG5cbiAgZW5kXG5cbmVuZFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgIFhhdmllciBMZXJveSBhbmQgRGFtaWVuIERvbGlnZXosIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5sZXQgZ2VuZXJpY19xdW90ZSBxdW90ZXF1b3RlIHMgPVxuICBsZXQgbCA9IFN0cmluZy5sZW5ndGggcyBpblxuICBsZXQgYiA9IEJ1ZmZlci5jcmVhdGUgKGwgKyAyMCkgaW5cbiAgQnVmZmVyLmFkZF9jaGFyIGIgJ1xcJyc7XG4gIGZvciBpID0gMCB0byBsIC0gMSBkb1xuICAgIGlmIHMuW2ldID0gJ1xcJydcbiAgICB0aGVuIEJ1ZmZlci5hZGRfc3RyaW5nIGIgcXVvdGVxdW90ZVxuICAgIGVsc2UgQnVmZmVyLmFkZF9jaGFyIGIgIHMuW2ldXG4gIGRvbmU7XG4gIEJ1ZmZlci5hZGRfY2hhciBiICdcXCcnO1xuICBCdWZmZXIuY29udGVudHMgYlxuXG4oKiBUaGlzIGZ1bmN0aW9uIGltcGxlbWVudHMgdGhlIE9wZW4gR3JvdXAgc3BlY2lmaWNhdGlvbiBmb3VuZCBoZXJlOlxuICBbWzFdXSBodHRwOi8vcHVicy5vcGVuZ3JvdXAub3JnL29ubGluZXB1YnMvOTY5OTkxOTc5OS91dGlsaXRpZXMvYmFzZW5hbWUuaHRtbFxuICBJbiBzdGVwIDEgb2YgW1sxXV0sIHdlIGNob29zZSB0byByZXR1cm4gXCIuXCIgZm9yIGVtcHR5IGlucHV0LlxuICAgIChmb3IgY29tcGF0aWJpbGl0eSB3aXRoIHByZXZpb3VzIHZlcnNpb25zIG9mIE9DYW1sKVxuICBJbiBzdGVwIDIsIHdlIGNob29zZSB0byBwcm9jZXNzIFwiLy9cIiBub3JtYWxseS5cbiAgU3RlcCA2IGlzIG5vdCBpbXBsZW1lbnRlZDogd2UgY29uc2lkZXIgdGhhdCB0aGUgW3N1ZmZpeF0gb3BlcmFuZCBpc1xuICAgIGFsd2F5cyBhYnNlbnQuICBTdWZmaXhlcyBhcmUgaGFuZGxlZCBieSBbY2hvcF9zdWZmaXhdIGFuZCBbY2hvcF9leHRlbnNpb25dLlxuKilcbmxldCBnZW5lcmljX2Jhc2VuYW1lIGlzX2Rpcl9zZXAgY3VycmVudF9kaXJfbmFtZSBuYW1lID1cbiAgbGV0IHJlYyBmaW5kX2VuZCBuID1cbiAgICBpZiBuIDwgMCB0aGVuIFN0cmluZy5zdWIgbmFtZSAwIDFcbiAgICBlbHNlIGlmIGlzX2Rpcl9zZXAgbmFtZSBuIHRoZW4gZmluZF9lbmQgKG4gLSAxKVxuICAgIGVsc2UgZmluZF9iZWcgbiAobiArIDEpXG4gIGFuZCBmaW5kX2JlZyBuIHAgPVxuICAgIGlmIG4gPCAwIHRoZW4gU3RyaW5nLnN1YiBuYW1lIDAgcFxuICAgIGVsc2UgaWYgaXNfZGlyX3NlcCBuYW1lIG4gdGhlbiBTdHJpbmcuc3ViIG5hbWUgKG4gKyAxKSAocCAtIG4gLSAxKVxuICAgIGVsc2UgZmluZF9iZWcgKG4gLSAxKSBwXG4gIGluXG4gIGlmIG5hbWUgPSBcIlwiXG4gIHRoZW4gY3VycmVudF9kaXJfbmFtZVxuICBlbHNlIGZpbmRfZW5kIChTdHJpbmcubGVuZ3RoIG5hbWUgLSAxKVxuXG4oKiBUaGlzIGZ1bmN0aW9uIGltcGxlbWVudHMgdGhlIE9wZW4gR3JvdXAgc3BlY2lmaWNhdGlvbiBmb3VuZCBoZXJlOlxuICBbWzJdXSBodHRwOi8vcHVicy5vcGVuZ3JvdXAub3JnL29ubGluZXB1YnMvOTY5OTkxOTc5OS91dGlsaXRpZXMvZGlybmFtZS5odG1sXG4gIEluIHN0ZXAgNiBvZiBbWzJdXSwgd2UgY2hvb3NlIHRvIHByb2Nlc3MgXCIvL1wiIG5vcm1hbGx5LlxuKilcbmxldCBnZW5lcmljX2Rpcm5hbWUgaXNfZGlyX3NlcCBjdXJyZW50X2Rpcl9uYW1lIG5hbWUgPVxuICBsZXQgcmVjIHRyYWlsaW5nX3NlcCBuID1cbiAgICBpZiBuIDwgMCB0aGVuIFN0cmluZy5zdWIgbmFtZSAwIDFcbiAgICBlbHNlIGlmIGlzX2Rpcl9zZXAgbmFtZSBuIHRoZW4gdHJhaWxpbmdfc2VwIChuIC0gMSlcbiAgICBlbHNlIGJhc2UgblxuICBhbmQgYmFzZSBuID1cbiAgICBpZiBuIDwgMCB0aGVuIGN1cnJlbnRfZGlyX25hbWVcbiAgICBlbHNlIGlmIGlzX2Rpcl9zZXAgbmFtZSBuIHRoZW4gaW50ZXJtZWRpYXRlX3NlcCBuXG4gICAgZWxzZSBiYXNlIChuIC0gMSlcbiAgYW5kIGludGVybWVkaWF0ZV9zZXAgbiA9XG4gICAgaWYgbiA8IDAgdGhlbiBTdHJpbmcuc3ViIG5hbWUgMCAxXG4gICAgZWxzZSBpZiBpc19kaXJfc2VwIG5hbWUgbiB0aGVuIGludGVybWVkaWF0ZV9zZXAgKG4gLSAxKVxuICAgIGVsc2UgU3RyaW5nLnN1YiBuYW1lIDAgKG4gKyAxKVxuICBpblxuICBpZiBuYW1lID0gXCJcIlxuICB0aGVuIGN1cnJlbnRfZGlyX25hbWVcbiAgZWxzZSB0cmFpbGluZ19zZXAgKFN0cmluZy5sZW5ndGggbmFtZSAtIDEpXG5cbm1vZHVsZSB0eXBlIFNZU0RFUFMgPSBzaWdcbiAgdmFsIG51bGwgOiBzdHJpbmdcbiAgdmFsIGN1cnJlbnRfZGlyX25hbWUgOiBzdHJpbmdcbiAgdmFsIHBhcmVudF9kaXJfbmFtZSA6IHN0cmluZ1xuICB2YWwgZGlyX3NlcCA6IHN0cmluZ1xuICB2YWwgaXNfZGlyX3NlcCA6IHN0cmluZyAtPiBpbnQgLT4gYm9vbFxuICB2YWwgaXNfcmVsYXRpdmUgOiBzdHJpbmcgLT4gYm9vbFxuICB2YWwgaXNfaW1wbGljaXQgOiBzdHJpbmcgLT4gYm9vbFxuICB2YWwgY2hlY2tfc3VmZml4IDogc3RyaW5nIC0+IHN0cmluZyAtPiBib29sXG4gIHZhbCBjaG9wX3N1ZmZpeF9vcHQgOiBzdWZmaXg6c3RyaW5nIC0+IHN0cmluZyAtPiBzdHJpbmcgb3B0aW9uXG4gIHZhbCB0ZW1wX2Rpcl9uYW1lIDogc3RyaW5nXG4gIHZhbCBxdW90ZSA6IHN0cmluZyAtPiBzdHJpbmdcbiAgdmFsIHF1b3RlX2NvbW1hbmQgOlxuICAgIHN0cmluZyAtPiA/c3RkaW46IHN0cmluZyAtPiA/c3Rkb3V0OiBzdHJpbmcgLT4gP3N0ZGVycjogc3RyaW5nXG4gICAgICAgICAgIC0+IHN0cmluZyBsaXN0IC0+IHN0cmluZ1xuICB2YWwgYmFzZW5hbWUgOiBzdHJpbmcgLT4gc3RyaW5nXG4gIHZhbCBkaXJuYW1lIDogc3RyaW5nIC0+IHN0cmluZ1xuZW5kXG5cbm1vZHVsZSBVbml4IDogU1lTREVQUyA9IHN0cnVjdFxuICBsZXQgbnVsbCA9IFwiL2Rldi9udWxsXCJcbiAgbGV0IGN1cnJlbnRfZGlyX25hbWUgPSBcIi5cIlxuICBsZXQgcGFyZW50X2Rpcl9uYW1lID0gXCIuLlwiXG4gIGxldCBkaXJfc2VwID0gXCIvXCJcbiAgbGV0IGlzX2Rpcl9zZXAgcyBpID0gcy5baV0gPSAnLydcbiAgbGV0IGlzX3JlbGF0aXZlIG4gPSBTdHJpbmcubGVuZ3RoIG4gPCAxIHx8IG4uWzBdIDw+ICcvJ1xuICBsZXQgaXNfaW1wbGljaXQgbiA9XG4gICAgaXNfcmVsYXRpdmUgblxuICAgICYmIChTdHJpbmcubGVuZ3RoIG4gPCAyIHx8IFN0cmluZy5zdWIgbiAwIDIgPD4gXCIuL1wiKVxuICAgICYmIChTdHJpbmcubGVuZ3RoIG4gPCAzIHx8IFN0cmluZy5zdWIgbiAwIDMgPD4gXCIuLi9cIilcbiAgbGV0IGNoZWNrX3N1ZmZpeCBuYW1lIHN1ZmYgPVxuICAgIFN0cmluZy5lbmRzX3dpdGggfnN1ZmZpeDpzdWZmIG5hbWVcblxuICBsZXQgY2hvcF9zdWZmaXhfb3B0IH5zdWZmaXggZmlsZW5hbWUgPVxuICAgIGxldCBsZW5fcyA9IFN0cmluZy5sZW5ndGggc3VmZml4IGFuZCBsZW5fZiA9IFN0cmluZy5sZW5ndGggZmlsZW5hbWUgaW5cbiAgICBpZiBsZW5fZiA+PSBsZW5fcyB0aGVuXG4gICAgICBsZXQgciA9IFN0cmluZy5zdWIgZmlsZW5hbWUgKGxlbl9mIC0gbGVuX3MpIGxlbl9zIGluXG4gICAgICBpZiByID0gc3VmZml4IHRoZW5cbiAgICAgICAgU29tZSAoU3RyaW5nLnN1YiBmaWxlbmFtZSAwIChsZW5fZiAtIGxlbl9zKSlcbiAgICAgIGVsc2VcbiAgICAgICAgTm9uZVxuICAgIGVsc2VcbiAgICAgIE5vbmVcblxuICBsZXQgdGVtcF9kaXJfbmFtZSA9XG4gICAgdHJ5IFN5cy5nZXRlbnYgXCJUTVBESVJcIiB3aXRoIE5vdF9mb3VuZCAtPiBcIi90bXBcIlxuICBsZXQgcXVvdGUgPSBnZW5lcmljX3F1b3RlIFwiJ1xcXFwnJ1wiXG4gIGxldCBxdW90ZV9jb21tYW5kIGNtZCA/c3RkaW4gP3N0ZG91dCA/c3RkZXJyIGFyZ3MgPVxuICAgIFN0cmluZy5jb25jYXQgXCIgXCIgKExpc3QubWFwIHF1b3RlIChjbWQgOjogYXJncykpXG4gICAgXiAobWF0Y2ggc3RkaW4gIHdpdGggTm9uZSAtPiBcIlwiIHwgU29tZSBmIC0+IFwiIDxcIiBeIHF1b3RlIGYpXG4gICAgXiAobWF0Y2ggc3Rkb3V0IHdpdGggTm9uZSAtPiBcIlwiIHwgU29tZSBmIC0+IFwiID5cIiBeIHF1b3RlIGYpXG4gICAgXiAobWF0Y2ggc3RkZXJyIHdpdGggTm9uZSAtPiBcIlwiIHwgU29tZSBmIC0+IGlmIHN0ZGVyciA9IHN0ZG91dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlbiBcIiAyPiYxXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgXCIgMj5cIiBeIHF1b3RlIGYpXG4gIGxldCBiYXNlbmFtZSA9IGdlbmVyaWNfYmFzZW5hbWUgaXNfZGlyX3NlcCBjdXJyZW50X2Rpcl9uYW1lXG4gIGxldCBkaXJuYW1lID0gZ2VuZXJpY19kaXJuYW1lIGlzX2Rpcl9zZXAgY3VycmVudF9kaXJfbmFtZVxuZW5kXG5cbm1vZHVsZSBXaW4zMiA6IFNZU0RFUFMgPSBzdHJ1Y3RcbiAgbGV0IG51bGwgPSBcIk5VTFwiXG4gIGxldCBjdXJyZW50X2Rpcl9uYW1lID0gXCIuXCJcbiAgbGV0IHBhcmVudF9kaXJfbmFtZSA9IFwiLi5cIlxuICBsZXQgZGlyX3NlcCA9IFwiXFxcXFwiXG4gIGxldCBpc19kaXJfc2VwIHMgaSA9IGxldCBjID0gcy5baV0gaW4gYyA9ICcvJyB8fCBjID0gJ1xcXFwnIHx8IGMgPSAnOidcbiAgbGV0IGlzX3JlbGF0aXZlIG4gPVxuICAgIChTdHJpbmcubGVuZ3RoIG4gPCAxIHx8IG4uWzBdIDw+ICcvJylcbiAgICAmJiAoU3RyaW5nLmxlbmd0aCBuIDwgMSB8fCBuLlswXSA8PiAnXFxcXCcpXG4gICAgJiYgKFN0cmluZy5sZW5ndGggbiA8IDIgfHwgbi5bMV0gPD4gJzonKVxuICBsZXQgaXNfaW1wbGljaXQgbiA9XG4gICAgaXNfcmVsYXRpdmUgblxuICAgICYmIChTdHJpbmcubGVuZ3RoIG4gPCAyIHx8IFN0cmluZy5zdWIgbiAwIDIgPD4gXCIuL1wiKVxuICAgICYmIChTdHJpbmcubGVuZ3RoIG4gPCAyIHx8IFN0cmluZy5zdWIgbiAwIDIgPD4gXCIuXFxcXFwiKVxuICAgICYmIChTdHJpbmcubGVuZ3RoIG4gPCAzIHx8IFN0cmluZy5zdWIgbiAwIDMgPD4gXCIuLi9cIilcbiAgICAmJiAoU3RyaW5nLmxlbmd0aCBuIDwgMyB8fCBTdHJpbmcuc3ViIG4gMCAzIDw+IFwiLi5cXFxcXCIpXG4gIGxldCBjaGVja19zdWZmaXggbmFtZSBzdWZmID1cbiAgIFN0cmluZy5sZW5ndGggbmFtZSA+PSBTdHJpbmcubGVuZ3RoIHN1ZmYgJiZcbiAgIChsZXQgcyA9IFN0cmluZy5zdWIgbmFtZSAoU3RyaW5nLmxlbmd0aCBuYW1lIC0gU3RyaW5nLmxlbmd0aCBzdWZmKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChTdHJpbmcubGVuZ3RoIHN1ZmYpIGluXG4gICAgU3RyaW5nLmxvd2VyY2FzZV9hc2NpaSBzID0gU3RyaW5nLmxvd2VyY2FzZV9hc2NpaSBzdWZmKVxuXG4gIGxldCBjaG9wX3N1ZmZpeF9vcHQgfnN1ZmZpeCBmaWxlbmFtZSA9XG4gICAgbGV0IGxlbl9zID0gU3RyaW5nLmxlbmd0aCBzdWZmaXggYW5kIGxlbl9mID0gU3RyaW5nLmxlbmd0aCBmaWxlbmFtZSBpblxuICAgIGlmIGxlbl9mID49IGxlbl9zIHRoZW5cbiAgICAgIGxldCByID0gU3RyaW5nLnN1YiBmaWxlbmFtZSAobGVuX2YgLSBsZW5fcykgbGVuX3MgaW5cbiAgICAgIGlmIFN0cmluZy5sb3dlcmNhc2VfYXNjaWkgciA9IFN0cmluZy5sb3dlcmNhc2VfYXNjaWkgc3VmZml4IHRoZW5cbiAgICAgICAgU29tZSAoU3RyaW5nLnN1YiBmaWxlbmFtZSAwIChsZW5fZiAtIGxlbl9zKSlcbiAgICAgIGVsc2VcbiAgICAgICAgTm9uZVxuICAgIGVsc2VcbiAgICAgIE5vbmVcblxuXG4gIGxldCB0ZW1wX2Rpcl9uYW1lID1cbiAgICB0cnkgU3lzLmdldGVudiBcIlRFTVBcIiB3aXRoIE5vdF9mb3VuZCAtPiBcIi5cIlxuICBsZXQgcXVvdGUgcyA9XG4gICAgbGV0IGwgPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgICBsZXQgYiA9IEJ1ZmZlci5jcmVhdGUgKGwgKyAyMCkgaW5cbiAgICBCdWZmZXIuYWRkX2NoYXIgYiAnXFxcIic7XG4gICAgbGV0IHJlYyBsb29wIGkgPVxuICAgICAgaWYgaSA9IGwgdGhlbiBCdWZmZXIuYWRkX2NoYXIgYiAnXFxcIicgZWxzZVxuICAgICAgbWF0Y2ggcy5baV0gd2l0aFxuICAgICAgfCAnXFxcIicgLT4gbG9vcF9icyAwIGk7XG4gICAgICB8ICdcXFxcJyAtPiBsb29wX2JzIDAgaTtcbiAgICAgIHwgYyAgICAtPiBCdWZmZXIuYWRkX2NoYXIgYiBjOyBsb29wIChpKzEpO1xuICAgIGFuZCBsb29wX2JzIG4gaSA9XG4gICAgICBpZiBpID0gbCB0aGVuIGJlZ2luXG4gICAgICAgIEJ1ZmZlci5hZGRfY2hhciBiICdcXFwiJztcbiAgICAgICAgYWRkX2JzIG47XG4gICAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgICBtYXRjaCBzLltpXSB3aXRoXG4gICAgICAgIHwgJ1xcXCInIC0+IGFkZF9icyAoMipuKzEpOyBCdWZmZXIuYWRkX2NoYXIgYiAnXFxcIic7IGxvb3AgKGkrMSk7XG4gICAgICAgIHwgJ1xcXFwnIC0+IGxvb3BfYnMgKG4rMSkgKGkrMSk7XG4gICAgICAgIHwgXyAgICAtPiBhZGRfYnMgbjsgbG9vcCBpXG4gICAgICBlbmRcbiAgICBhbmQgYWRkX2JzIG4gPSBmb3IgX2ogPSAxIHRvIG4gZG8gQnVmZmVyLmFkZF9jaGFyIGIgJ1xcXFwnOyBkb25lXG4gICAgaW5cbiAgICBsb29wIDA7XG4gICAgQnVmZmVyLmNvbnRlbnRzIGJcbigqXG5RdW90aW5nIGNvbW1hbmRzIGZvciBleGVjdXRpb24gYnkgY21kLmV4ZSBpcyBkaWZmaWN1bHQuXG4xLSBFYWNoIGFyZ3VtZW50IGlzIGZpcnN0IHF1b3RlZCB1c2luZyB0aGUgXCJxdW90ZVwiIGZ1bmN0aW9uIGFib3ZlLCB0b1xuICAgcHJvdGVjdCBpdCBhZ2FpbnN0IHRoZSBwcm9jZXNzaW5nIHBlcmZvcm1lZCBieSB0aGUgQyBydW50aW1lIHN5c3RlbSxcbiAgIHRoZW4gY21kLmV4ZSdzIHNwZWNpYWwgY2hhcmFjdGVycyBhcmUgZXNjYXBlZCB3aXRoICdeJywgdXNpbmdcbiAgIHRoZSBcInF1b3RlX2NtZFwiIGZ1bmN0aW9uIGJlbG93LiAgRm9yIG1vcmUgZGV0YWlscywgc2VlXG4gICBodHRwczovL2Jsb2dzLm1zZG4ubWljcm9zb2Z0LmNvbS90d2lzdHlsaXR0bGVwYXNzYWdlc2FsbGFsaWtlLzIwMTEvMDQvMjNcbjItIFRoZSBjb21tYW5kIGFuZCB0aGUgcmVkaXJlY3Rpb24gZmlsZXMsIGlmIGFueSwgbXVzdCBiZSBkb3VibGUtcXVvdGVkXG4gICBpbiBjYXNlIHRoZXkgY29udGFpbiBzcGFjZXMuICBUaGlzIHF1b3RpbmcgaXMgaW50ZXJwcmV0ZWQgYnkgY21kLmV4ZSxcbiAgIG5vdCBieSB0aGUgQyBydW50aW1lIHN5c3RlbSwgaGVuY2UgdGhlIFwicXVvdGVcIiBmdW5jdGlvbiBhYm92ZVxuICAgY2Fubm90IGJlIHVzZWQuICBUaGUgdHdvIGNoYXJhY3RlcnMgd2UgZG9uJ3Qga25vdyBob3cgdG8gcXVvdGVcbiAgIGluc2lkZSBhIGRvdWJsZS1xdW90ZWQgY21kLmV4ZSBzdHJpbmcgYXJlIGRvdWJsZS1xdW90ZSBhbmQgcGVyY2VudC5cbiAgIFdlIGp1c3QgZmFpbCBpZiB0aGUgY29tbWFuZCBuYW1lIG9yIHRoZSByZWRpcmVjdGlvbiBmaWxlIG5hbWVzXG4gICBjb250YWluIGEgZG91YmxlIHF1b3RlIChub3QgYWxsb3dlZCBpbiBXaW5kb3dzIGZpbGUgbmFtZXMsIGFueXdheSlcbiAgIG9yIGEgcGVyY2VudC4gIFNlZSBmdW5jdGlvbiBcInF1b3RlX2NtZF9maWxlbmFtZVwiIGJlbG93LlxuMy0gVGhlIHdob2xlIHN0cmluZyBwYXNzZWQgdG8gU3lzLmNvbW1hbmQgaXMgdGhlbiBlbmNsb3NlZCBpbiBkb3VibGVcbiAgIHF1b3Rlcywgd2hpY2ggYXJlIGltbWVkaWF0ZWx5IHN0cmlwcGVkIGJ5IGNtZC5leGUuICBPdGhlcndpc2UsXG4gICBzb21lIG9mIHRoZSBkb3VibGUgcXVvdGVzIGZyb20gc3RlcCAyIGFib3ZlIGNhbiBiZSBtaXNwYXJzZWQuXG4gICBTZWUgZS5nLiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvOTk2NTE0MVxuKilcbiAgbGV0IHF1b3RlX2NtZCBzID1cbiAgICBsZXQgYiA9IEJ1ZmZlci5jcmVhdGUgKFN0cmluZy5sZW5ndGggcyArIDIwKSBpblxuICAgIFN0cmluZy5pdGVyXG4gICAgICAoZnVuIGMgLT5cbiAgICAgICAgbWF0Y2ggYyB3aXRoXG4gICAgICAgIHwgJygnIHwgJyknIHwgJyEnIHwgJ14nIHwgJyUnIHwgJ1xcXCInIHwgJzwnIHwgJz4nIHwgJyYnIHwgJ3wnIC0+XG4gICAgICAgICAgICBCdWZmZXIuYWRkX2NoYXIgYiAnXic7IEJ1ZmZlci5hZGRfY2hhciBiIGNcbiAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICBCdWZmZXIuYWRkX2NoYXIgYiBjKVxuICAgICAgcztcbiAgICBCdWZmZXIuY29udGVudHMgYlxuICBsZXQgcXVvdGVfY21kX2ZpbGVuYW1lIGYgPVxuICAgIGlmIFN0cmluZy5jb250YWlucyBmICdcXFwiJyB8fCBTdHJpbmcuY29udGFpbnMgZiAnJScgdGhlblxuICAgICAgZmFpbHdpdGggKFwiRmlsZW5hbWUucXVvdGVfY29tbWFuZDogYmFkIGZpbGUgbmFtZSBcIiBeIGYpXG4gICAgZWxzZSBpZiBTdHJpbmcuY29udGFpbnMgZiAnICcgdGhlblxuICAgICAgXCJcXFwiXCIgXiBmIF4gXCJcXFwiXCJcbiAgICBlbHNlXG4gICAgICBmXG4gICgqIFJlZGlyZWN0aW9ucyBpbiBjbWQuZXhlOiBzZWUgaHR0cHM6Ly9zczY0LmNvbS9udC9zeW50YXgtcmVkaXJlY3Rpb24uaHRtbFxuICAgICBhbmQgaHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vZW4tdXMvcHJldmlvdXMtdmVyc2lvbnMvd2luZG93cy9pdC1wcm8vd2luZG93cy14cC9iYjQ5MDk4Mih2PXRlY2huZXQuMTApXG4gICopXG4gIGxldCBxdW90ZV9jb21tYW5kIGNtZCA/c3RkaW4gP3N0ZG91dCA/c3RkZXJyIGFyZ3MgPVxuICAgIFN0cmluZy5jb25jYXQgXCJcIiBbXG4gICAgICBcIlxcXCJcIjtcbiAgICAgIHF1b3RlX2NtZF9maWxlbmFtZSBjbWQ7XG4gICAgICBcIiBcIjtcbiAgICAgIHF1b3RlX2NtZCAoU3RyaW5nLmNvbmNhdCBcIiBcIiAoTGlzdC5tYXAgcXVvdGUgYXJncykpO1xuICAgICAgKG1hdGNoIHN0ZGluICB3aXRoIE5vbmUgLT4gXCJcIiB8IFNvbWUgZiAtPiBcIiA8XCIgXiBxdW90ZV9jbWRfZmlsZW5hbWUgZik7XG4gICAgICAobWF0Y2ggc3Rkb3V0IHdpdGggTm9uZSAtPiBcIlwiIHwgU29tZSBmIC0+IFwiID5cIiBeIHF1b3RlX2NtZF9maWxlbmFtZSBmKTtcbiAgICAgIChtYXRjaCBzdGRlcnIgd2l0aCBOb25lIC0+IFwiXCIgfCBTb21lIGYgLT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiBzdGRlcnIgPSBzdGRvdXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGVuIFwiIDI+JjFcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgXCIgMj5cIiBeIHF1b3RlX2NtZF9maWxlbmFtZSBmKTtcbiAgICAgIFwiXFxcIlwiXG4gICAgXVxuICBsZXQgaGFzX2RyaXZlIHMgPVxuICAgIGxldCBpc19sZXR0ZXIgPSBmdW5jdGlvblxuICAgICAgfCAnQScgLi4gJ1onIHwgJ2EnIC4uICd6JyAtPiB0cnVlXG4gICAgICB8IF8gLT4gZmFsc2VcbiAgICBpblxuICAgIFN0cmluZy5sZW5ndGggcyA+PSAyICYmIGlzX2xldHRlciBzLlswXSAmJiBzLlsxXSA9ICc6J1xuICBsZXQgZHJpdmVfYW5kX3BhdGggcyA9XG4gICAgaWYgaGFzX2RyaXZlIHNcbiAgICB0aGVuIChTdHJpbmcuc3ViIHMgMCAyLCBTdHJpbmcuc3ViIHMgMiAoU3RyaW5nLmxlbmd0aCBzIC0gMikpXG4gICAgZWxzZSAoXCJcIiwgcylcbiAgbGV0IGRpcm5hbWUgcyA9XG4gICAgbGV0IChkcml2ZSwgcGF0aCkgPSBkcml2ZV9hbmRfcGF0aCBzIGluXG4gICAgbGV0IGRpciA9IGdlbmVyaWNfZGlybmFtZSBpc19kaXJfc2VwIGN1cnJlbnRfZGlyX25hbWUgcGF0aCBpblxuICAgIGRyaXZlIF4gZGlyXG4gIGxldCBiYXNlbmFtZSBzID1cbiAgICBsZXQgKF9kcml2ZSwgcGF0aCkgPSBkcml2ZV9hbmRfcGF0aCBzIGluXG4gICAgZ2VuZXJpY19iYXNlbmFtZSBpc19kaXJfc2VwIGN1cnJlbnRfZGlyX25hbWUgcGF0aFxuZW5kXG5cbm1vZHVsZSBDeWd3aW4gOiBTWVNERVBTID0gc3RydWN0XG4gIGxldCBudWxsID0gXCIvZGV2L251bGxcIlxuICBsZXQgY3VycmVudF9kaXJfbmFtZSA9IFwiLlwiXG4gIGxldCBwYXJlbnRfZGlyX25hbWUgPSBcIi4uXCJcbiAgbGV0IGRpcl9zZXAgPSBcIi9cIlxuICBsZXQgaXNfZGlyX3NlcCA9IFdpbjMyLmlzX2Rpcl9zZXBcbiAgbGV0IGlzX3JlbGF0aXZlID0gV2luMzIuaXNfcmVsYXRpdmVcbiAgbGV0IGlzX2ltcGxpY2l0ID0gV2luMzIuaXNfaW1wbGljaXRcbiAgbGV0IGNoZWNrX3N1ZmZpeCA9IFdpbjMyLmNoZWNrX3N1ZmZpeFxuICBsZXQgY2hvcF9zdWZmaXhfb3B0ID0gV2luMzIuY2hvcF9zdWZmaXhfb3B0XG4gIGxldCB0ZW1wX2Rpcl9uYW1lID0gVW5peC50ZW1wX2Rpcl9uYW1lXG4gIGxldCBxdW90ZSA9IFVuaXgucXVvdGVcbiAgbGV0IHF1b3RlX2NvbW1hbmQgPSBVbml4LnF1b3RlX2NvbW1hbmRcbiAgbGV0IGJhc2VuYW1lID0gZ2VuZXJpY19iYXNlbmFtZSBpc19kaXJfc2VwIGN1cnJlbnRfZGlyX25hbWVcbiAgbGV0IGRpcm5hbWUgPSBnZW5lcmljX2Rpcm5hbWUgaXNfZGlyX3NlcCBjdXJyZW50X2Rpcl9uYW1lXG5lbmRcblxubW9kdWxlIFN5c2RlcHMgPVxuICAodmFsIChtYXRjaCBTeXMub3NfdHlwZSB3aXRoXG4gICAgICAgfCBcIldpbjMyXCIgLT4gKG1vZHVsZSBXaW4zMjogU1lTREVQUylcbiAgICAgICB8IFwiQ3lnd2luXCIgLT4gKG1vZHVsZSBDeWd3aW46IFNZU0RFUFMpXG4gICAgICAgfCBfIC0+IChtb2R1bGUgVW5peDogU1lTREVQUykpKVxuXG5pbmNsdWRlIFN5c2RlcHNcblxubGV0IGNvbmNhdCBkaXJuYW1lIGZpbGVuYW1lID1cbiAgbGV0IGwgPSBTdHJpbmcubGVuZ3RoIGRpcm5hbWUgaW5cbiAgaWYgbCA9IDAgfHwgaXNfZGlyX3NlcCBkaXJuYW1lIChsLTEpXG4gIHRoZW4gZGlybmFtZSBeIGZpbGVuYW1lXG4gIGVsc2UgZGlybmFtZSBeIGRpcl9zZXAgXiBmaWxlbmFtZVxuXG5sZXQgY2hvcF9zdWZmaXggbmFtZSBzdWZmID1cbiAgaWYgY2hlY2tfc3VmZml4IG5hbWUgc3VmZlxuICB0aGVuIFN0cmluZy5zdWIgbmFtZSAwIChTdHJpbmcubGVuZ3RoIG5hbWUgLSBTdHJpbmcubGVuZ3RoIHN1ZmYpXG4gIGVsc2UgaW52YWxpZF9hcmcgXCJGaWxlbmFtZS5jaG9wX3N1ZmZpeFwiXG5cbmxldCBleHRlbnNpb25fbGVuIG5hbWUgPVxuICBsZXQgcmVjIGNoZWNrIGkwIGkgPVxuICAgIGlmIGkgPCAwIHx8IGlzX2Rpcl9zZXAgbmFtZSBpIHRoZW4gMFxuICAgIGVsc2UgaWYgbmFtZS5baV0gPSAnLicgdGhlbiBjaGVjayBpMCAoaSAtIDEpXG4gICAgZWxzZSBTdHJpbmcubGVuZ3RoIG5hbWUgLSBpMFxuICBpblxuICBsZXQgcmVjIHNlYXJjaF9kb3QgaSA9XG4gICAgaWYgaSA8IDAgfHwgaXNfZGlyX3NlcCBuYW1lIGkgdGhlbiAwXG4gICAgZWxzZSBpZiBuYW1lLltpXSA9ICcuJyB0aGVuIGNoZWNrIGkgKGkgLSAxKVxuICAgIGVsc2Ugc2VhcmNoX2RvdCAoaSAtIDEpXG4gIGluXG4gIHNlYXJjaF9kb3QgKFN0cmluZy5sZW5ndGggbmFtZSAtIDEpXG5cbmxldCBleHRlbnNpb24gbmFtZSA9XG4gIGxldCBsID0gZXh0ZW5zaW9uX2xlbiBuYW1lIGluXG4gIGlmIGwgPSAwIHRoZW4gXCJcIiBlbHNlIFN0cmluZy5zdWIgbmFtZSAoU3RyaW5nLmxlbmd0aCBuYW1lIC0gbCkgbFxuXG5sZXQgY2hvcF9leHRlbnNpb24gbmFtZSA9XG4gIGxldCBsID0gZXh0ZW5zaW9uX2xlbiBuYW1lIGluXG4gIGlmIGwgPSAwIHRoZW4gaW52YWxpZF9hcmcgXCJGaWxlbmFtZS5jaG9wX2V4dGVuc2lvblwiXG4gIGVsc2UgU3RyaW5nLnN1YiBuYW1lIDAgKFN0cmluZy5sZW5ndGggbmFtZSAtIGwpXG5cbmxldCByZW1vdmVfZXh0ZW5zaW9uIG5hbWUgPVxuICBsZXQgbCA9IGV4dGVuc2lvbl9sZW4gbmFtZSBpblxuICBpZiBsID0gMCB0aGVuIG5hbWUgZWxzZSBTdHJpbmcuc3ViIG5hbWUgMCAoU3RyaW5nLmxlbmd0aCBuYW1lIC0gbClcblxuZXh0ZXJuYWwgb3Blbl9kZXNjOiBzdHJpbmcgLT4gb3Blbl9mbGFnIGxpc3QgLT4gaW50IC0+IGludCA9IFwiY2FtbF9zeXNfb3BlblwiXG5leHRlcm5hbCBjbG9zZV9kZXNjOiBpbnQgLT4gdW5pdCA9IFwiY2FtbF9zeXNfY2xvc2VcIlxuXG5sZXQgcHJuZyA9IGxhenkoUmFuZG9tLlN0YXRlLm1ha2Vfc2VsZl9pbml0ICgpKVxuXG5sZXQgdGVtcF9maWxlX25hbWUgdGVtcF9kaXIgcHJlZml4IHN1ZmZpeCA9XG4gIGxldCBybmQgPSAoUmFuZG9tLlN0YXRlLmJpdHMgKExhenkuZm9yY2UgcHJuZykpIGxhbmQgMHhGRkZGRkYgaW5cbiAgY29uY2F0IHRlbXBfZGlyIChQcmludGYuc3ByaW50ZiBcIiVzJTA2eCVzXCIgcHJlZml4IHJuZCBzdWZmaXgpXG5cblxubGV0IGN1cnJlbnRfdGVtcF9kaXJfbmFtZSA9IHJlZiB0ZW1wX2Rpcl9uYW1lXG5cbmxldCBzZXRfdGVtcF9kaXJfbmFtZSBzID0gY3VycmVudF90ZW1wX2Rpcl9uYW1lIDo9IHNcbmxldCBnZXRfdGVtcF9kaXJfbmFtZSAoKSA9ICFjdXJyZW50X3RlbXBfZGlyX25hbWVcblxubGV0IHRlbXBfZmlsZSA/KHRlbXBfZGlyID0gIWN1cnJlbnRfdGVtcF9kaXJfbmFtZSkgcHJlZml4IHN1ZmZpeCA9XG4gIGxldCByZWMgdHJ5X25hbWUgY291bnRlciA9XG4gICAgbGV0IG5hbWUgPSB0ZW1wX2ZpbGVfbmFtZSB0ZW1wX2RpciBwcmVmaXggc3VmZml4IGluXG4gICAgdHJ5XG4gICAgICBjbG9zZV9kZXNjKG9wZW5fZGVzYyBuYW1lIFtPcGVuX3dyb25seTsgT3Blbl9jcmVhdDsgT3Blbl9leGNsXSAwbzYwMCk7XG4gICAgICBuYW1lXG4gICAgd2l0aCBTeXNfZXJyb3IgXyBhcyBlIC0+XG4gICAgICBpZiBjb3VudGVyID49IDEwMDAgdGhlbiByYWlzZSBlIGVsc2UgdHJ5X25hbWUgKGNvdW50ZXIgKyAxKVxuICBpbiB0cnlfbmFtZSAwXG5cbmxldCBvcGVuX3RlbXBfZmlsZSA/KG1vZGUgPSBbT3Blbl90ZXh0XSkgPyhwZXJtcyA9IDBvNjAwKVxuICAgICAgICAgICAgICAgICAgID8odGVtcF9kaXIgPSAhY3VycmVudF90ZW1wX2Rpcl9uYW1lKSBwcmVmaXggc3VmZml4ID1cbiAgbGV0IHJlYyB0cnlfbmFtZSBjb3VudGVyID1cbiAgICBsZXQgbmFtZSA9IHRlbXBfZmlsZV9uYW1lIHRlbXBfZGlyIHByZWZpeCBzdWZmaXggaW5cbiAgICB0cnlcbiAgICAgIChuYW1lLFxuICAgICAgIG9wZW5fb3V0X2dlbiAoT3Blbl93cm9ubHk6Ok9wZW5fY3JlYXQ6Ok9wZW5fZXhjbDo6bW9kZSkgcGVybXMgbmFtZSlcbiAgICB3aXRoIFN5c19lcnJvciBfIGFzIGUgLT5cbiAgICAgIGlmIGNvdW50ZXIgPj0gMTAwMCB0aGVuIHJhaXNlIGUgZWxzZSB0cnlfbmFtZSAoY291bnRlciArIDEpXG4gIGluIHRyeV9uYW1lIDBcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMDIgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogQ29tcGxleCBudW1iZXJzICopXG5cbnR5cGUgdCA9IHsgcmU6IGZsb2F0OyBpbTogZmxvYXQgfVxuXG5sZXQgemVybyA9IHsgcmUgPSAwLjA7IGltID0gMC4wIH1cbmxldCBvbmUgPSB7IHJlID0gMS4wOyBpbSA9IDAuMCB9XG5sZXQgaSA9IHsgcmUgPSAwLjA7IGltID0gMS4wIH1cblxubGV0IGFkZCB4IHkgPSB7IHJlID0geC5yZSArLiB5LnJlOyBpbSA9IHguaW0gKy4geS5pbSB9XG5cbmxldCBzdWIgeCB5ID0geyByZSA9IHgucmUgLS4geS5yZTsgaW0gPSB4LmltIC0uIHkuaW0gfVxuXG5sZXQgbmVnIHggPSB7IHJlID0gLS4geC5yZTsgaW0gPSAtLiB4LmltIH1cblxubGV0IGNvbmogeCA9IHsgcmUgPSB4LnJlOyBpbSA9IC0uIHguaW0gfVxuXG5sZXQgbXVsIHggeSA9IHsgcmUgPSB4LnJlICouIHkucmUgLS4geC5pbSAqLiB5LmltO1xuICAgICAgICAgICAgICAgIGltID0geC5yZSAqLiB5LmltICsuIHguaW0gKi4geS5yZSB9XG5cbmxldCBkaXYgeCB5ID1cbiAgaWYgYWJzX2Zsb2F0IHkucmUgPj0gYWJzX2Zsb2F0IHkuaW0gdGhlblxuICAgIGxldCByID0geS5pbSAvLiB5LnJlIGluXG4gICAgbGV0IGQgPSB5LnJlICsuIHIgKi4geS5pbSBpblxuICAgIHsgcmUgPSAoeC5yZSArLiByICouIHguaW0pIC8uIGQ7XG4gICAgICBpbSA9ICh4LmltIC0uIHIgKi4geC5yZSkgLy4gZCB9XG4gIGVsc2VcbiAgICBsZXQgciA9IHkucmUgLy4geS5pbSBpblxuICAgIGxldCBkID0geS5pbSArLiByICouIHkucmUgaW5cbiAgICB7IHJlID0gKHIgKi4geC5yZSArLiB4LmltKSAvLiBkO1xuICAgICAgaW0gPSAociAqLiB4LmltIC0uIHgucmUpIC8uIGQgfVxuXG5sZXQgaW52IHggPSBkaXYgb25lIHhcblxubGV0IG5vcm0yIHggPSB4LnJlICouIHgucmUgKy4geC5pbSAqLiB4LmltXG5cbmxldCBub3JtIHggPVxuICAoKiBXYXRjaCBvdXQgZm9yIG92ZXJmbG93IGluIGNvbXB1dGluZyByZV4yICsgaW1eMiAqKVxuICBsZXQgciA9IGFic19mbG9hdCB4LnJlIGFuZCBpID0gYWJzX2Zsb2F0IHguaW0gaW5cbiAgaWYgciA9IDAuMCB0aGVuIGlcbiAgZWxzZSBpZiBpID0gMC4wIHRoZW4gclxuICBlbHNlIGlmIHIgPj0gaSB0aGVuXG4gICAgbGV0IHEgPSBpIC8uIHIgaW4gciAqLiBzcXJ0KDEuMCArLiBxICouIHEpXG4gIGVsc2VcbiAgICBsZXQgcSA9IHIgLy4gaSBpbiBpICouIHNxcnQoMS4wICsuIHEgKi4gcSlcblxubGV0IGFyZyB4ID0gYXRhbjIgeC5pbSB4LnJlXG5cbmxldCBwb2xhciBuIGEgPSB7IHJlID0gY29zIGEgKi4gbjsgaW0gPSBzaW4gYSAqLiBuIH1cblxubGV0IHNxcnQgeCA9XG4gIGlmIHgucmUgPSAwLjAgJiYgeC5pbSA9IDAuMCB0aGVuIHsgcmUgPSAwLjA7IGltID0gMC4wIH1cbiAgZWxzZSBiZWdpblxuICAgIGxldCByID0gYWJzX2Zsb2F0IHgucmUgYW5kIGkgPSBhYnNfZmxvYXQgeC5pbSBpblxuICAgIGxldCB3ID1cbiAgICAgIGlmIHIgPj0gaSB0aGVuIGJlZ2luXG4gICAgICAgIGxldCBxID0gaSAvLiByIGluXG4gICAgICAgIHNxcnQocikgKi4gc3FydCgwLjUgKi4gKDEuMCArLiBzcXJ0KDEuMCArLiBxICouIHEpKSlcbiAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgIGxldCBxID0gciAvLiBpIGluXG4gICAgICAgIHNxcnQoaSkgKi4gc3FydCgwLjUgKi4gKHEgKy4gc3FydCgxLjAgKy4gcSAqLiBxKSkpXG4gICAgICBlbmQgaW5cbiAgICBpZiB4LnJlID49IDAuMFxuICAgIHRoZW4geyByZSA9IHc7ICBpbSA9IDAuNSAqLiB4LmltIC8uIHcgfVxuICAgIGVsc2UgeyByZSA9IDAuNSAqLiBpIC8uIHc7ICBpbSA9IGlmIHguaW0gPj0gMC4wIHRoZW4gdyBlbHNlIC0uIHcgfVxuICBlbmRcblxubGV0IGV4cCB4ID1cbiAgbGV0IGUgPSBleHAgeC5yZSBpbiB7IHJlID0gZSAqLiBjb3MgeC5pbTsgaW0gPSBlICouIHNpbiB4LmltIH1cblxubGV0IGxvZyB4ID0geyByZSA9IGxvZyAobm9ybSB4KTsgaW0gPSBhdGFuMiB4LmltIHgucmUgfVxuXG5sZXQgcG93IHggeSA9IGV4cCAobXVsIHkgKGxvZyB4KSlcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICBNYW51ZWwgU2VycmFubyBldCBYYXZpZXIgTGVyb3ksIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMDAgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogTW9kdWxlIFtCaWdhcnJheV06IGxhcmdlLCBtdWx0aS1kaW1lbnNpb25hbCwgbnVtZXJpY2FsIGFycmF5cyAqKVxuXG4oKiBUaGVzZSB0eXBlcyBpbiBtdXN0IGJlIGtlcHQgaW4gc3luYyB3aXRoIHRoZSB0YWJsZXMgaW5cbiAgIC4uL3R5cGluZy90eXBlb3B0Lm1sICopXG5cbnR5cGUgZmxvYXQzMl9lbHQgPSBGbG9hdDMyX2VsdFxudHlwZSBmbG9hdDY0X2VsdCA9IEZsb2F0NjRfZWx0XG50eXBlIGludDhfc2lnbmVkX2VsdCA9IEludDhfc2lnbmVkX2VsdFxudHlwZSBpbnQ4X3Vuc2lnbmVkX2VsdCA9IEludDhfdW5zaWduZWRfZWx0XG50eXBlIGludDE2X3NpZ25lZF9lbHQgPSBJbnQxNl9zaWduZWRfZWx0XG50eXBlIGludDE2X3Vuc2lnbmVkX2VsdCA9IEludDE2X3Vuc2lnbmVkX2VsdFxudHlwZSBpbnQzMl9lbHQgPSBJbnQzMl9lbHRcbnR5cGUgaW50NjRfZWx0ID0gSW50NjRfZWx0XG50eXBlIGludF9lbHQgPSBJbnRfZWx0XG50eXBlIG5hdGl2ZWludF9lbHQgPSBOYXRpdmVpbnRfZWx0XG50eXBlIGNvbXBsZXgzMl9lbHQgPSBDb21wbGV4MzJfZWx0XG50eXBlIGNvbXBsZXg2NF9lbHQgPSBDb21wbGV4NjRfZWx0XG5cbnR5cGUgKCdhLCAnYikga2luZCA9XG4gICAgRmxvYXQzMiA6IChmbG9hdCwgZmxvYXQzMl9lbHQpIGtpbmRcbiAgfCBGbG9hdDY0IDogKGZsb2F0LCBmbG9hdDY0X2VsdCkga2luZFxuICB8IEludDhfc2lnbmVkIDogKGludCwgaW50OF9zaWduZWRfZWx0KSBraW5kXG4gIHwgSW50OF91bnNpZ25lZCA6IChpbnQsIGludDhfdW5zaWduZWRfZWx0KSBraW5kXG4gIHwgSW50MTZfc2lnbmVkIDogKGludCwgaW50MTZfc2lnbmVkX2VsdCkga2luZFxuICB8IEludDE2X3Vuc2lnbmVkIDogKGludCwgaW50MTZfdW5zaWduZWRfZWx0KSBraW5kXG4gIHwgSW50MzIgOiAoaW50MzIsIGludDMyX2VsdCkga2luZFxuICB8IEludDY0IDogKGludDY0LCBpbnQ2NF9lbHQpIGtpbmRcbiAgfCBJbnQgOiAoaW50LCBpbnRfZWx0KSBraW5kXG4gIHwgTmF0aXZlaW50IDogKG5hdGl2ZWludCwgbmF0aXZlaW50X2VsdCkga2luZFxuICB8IENvbXBsZXgzMiA6IChDb21wbGV4LnQsIGNvbXBsZXgzMl9lbHQpIGtpbmRcbiAgfCBDb21wbGV4NjQgOiAoQ29tcGxleC50LCBjb21wbGV4NjRfZWx0KSBraW5kXG4gIHwgQ2hhciA6IChjaGFyLCBpbnQ4X3Vuc2lnbmVkX2VsdCkga2luZFxuXG50eXBlIGNfbGF5b3V0ID0gQ19sYXlvdXRfdHlwXG50eXBlIGZvcnRyYW5fbGF5b3V0ID0gRm9ydHJhbl9sYXlvdXRfdHlwICgqKilcblxudHlwZSAnYSBsYXlvdXQgPVxuICAgIENfbGF5b3V0OiBjX2xheW91dCBsYXlvdXRcbiAgfCBGb3J0cmFuX2xheW91dDogZm9ydHJhbl9sYXlvdXQgbGF5b3V0XG5cbigqIEtlZXAgdGhvc2UgY29uc3RhbnRzIGluIHN5bmMgd2l0aCB0aGUgY2FtbF9iYV9raW5kIGVudW1lcmF0aW9uXG4gICBpbiBiaWdhcnJheS5oICopXG5cbmxldCBmbG9hdDMyID0gRmxvYXQzMlxubGV0IGZsb2F0NjQgPSBGbG9hdDY0XG5sZXQgaW50OF9zaWduZWQgPSBJbnQ4X3NpZ25lZFxubGV0IGludDhfdW5zaWduZWQgPSBJbnQ4X3Vuc2lnbmVkXG5sZXQgaW50MTZfc2lnbmVkID0gSW50MTZfc2lnbmVkXG5sZXQgaW50MTZfdW5zaWduZWQgPSBJbnQxNl91bnNpZ25lZFxubGV0IGludDMyID0gSW50MzJcbmxldCBpbnQ2NCA9IEludDY0XG5sZXQgaW50ID0gSW50XG5sZXQgbmF0aXZlaW50ID0gTmF0aXZlaW50XG5sZXQgY29tcGxleDMyID0gQ29tcGxleDMyXG5sZXQgY29tcGxleDY0ID0gQ29tcGxleDY0XG5sZXQgY2hhciA9IENoYXJcblxubGV0IGtpbmRfc2l6ZV9pbl9ieXRlcyA6IHR5cGUgYSBiLiAoYSwgYikga2luZCAtPiBpbnQgPSBmdW5jdGlvblxuICB8IEZsb2F0MzIgLT4gNFxuICB8IEZsb2F0NjQgLT4gOFxuICB8IEludDhfc2lnbmVkIC0+IDFcbiAgfCBJbnQ4X3Vuc2lnbmVkIC0+IDFcbiAgfCBJbnQxNl9zaWduZWQgLT4gMlxuICB8IEludDE2X3Vuc2lnbmVkIC0+IDJcbiAgfCBJbnQzMiAtPiA0XG4gIHwgSW50NjQgLT4gOFxuICB8IEludCAtPiBTeXMud29yZF9zaXplIC8gOFxuICB8IE5hdGl2ZWludCAtPiBTeXMud29yZF9zaXplIC8gOFxuICB8IENvbXBsZXgzMiAtPiA4XG4gIHwgQ29tcGxleDY0IC0+IDE2XG4gIHwgQ2hhciAtPiAxXG5cbigqIEtlZXAgdGhvc2UgY29uc3RhbnRzIGluIHN5bmMgd2l0aCB0aGUgY2FtbF9iYV9sYXlvdXQgZW51bWVyYXRpb25cbiAgIGluIGJpZ2FycmF5LmggKilcblxubGV0IGNfbGF5b3V0ID0gQ19sYXlvdXRcbmxldCBmb3J0cmFuX2xheW91dCA9IEZvcnRyYW5fbGF5b3V0XG5cbm1vZHVsZSBHZW5hcnJheSA9IHN0cnVjdFxuICB0eXBlICghJ2EsICEnYiwgISdjKSB0XG4gIGV4dGVybmFsIGNyZWF0ZTogKCdhLCAnYikga2luZCAtPiAnYyBsYXlvdXQgLT4gaW50IGFycmF5IC0+ICgnYSwgJ2IsICdjKSB0XG4gICAgID0gXCJjYW1sX2JhX2NyZWF0ZVwiXG4gIGV4dGVybmFsIGdldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IGFycmF5IC0+ICdhXG4gICAgID0gXCJjYW1sX2JhX2dldF9nZW5lcmljXCJcbiAgZXh0ZXJuYWwgc2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgYXJyYXkgLT4gJ2EgLT4gdW5pdFxuICAgICA9IFwiY2FtbF9iYV9zZXRfZ2VuZXJpY1wiXG5cbiAgbGV0IHJlYyBjbG9vcCBhcnIgaWR4IGYgY29sIG1heCA9XG4gICAgaWYgY29sID0gQXJyYXkubGVuZ3RoIGlkeCB0aGVuIHNldCBhcnIgaWR4IChmIGlkeClcbiAgICBlbHNlIGZvciBqID0gMCB0byBwcmVkIG1heC4oY29sKSBkb1xuICAgICAgICAgICBpZHguKGNvbCkgPC0gajtcbiAgICAgICAgICAgY2xvb3AgYXJyIGlkeCBmIChzdWNjIGNvbCkgbWF4XG4gICAgICAgICBkb25lXG4gIGxldCByZWMgZmxvb3AgYXJyIGlkeCBmIGNvbCBtYXggPVxuICAgIGlmIGNvbCA8IDAgdGhlbiBzZXQgYXJyIGlkeCAoZiBpZHgpXG4gICAgZWxzZSBmb3IgaiA9IDEgdG8gbWF4Lihjb2wpIGRvXG4gICAgICAgICAgIGlkeC4oY29sKSA8LSBqO1xuICAgICAgICAgICBmbG9vcCBhcnIgaWR4IGYgKHByZWQgY29sKSBtYXhcbiAgICAgICAgIGRvbmVcbiAgbGV0IGluaXQgKHR5cGUgdCkga2luZCAobGF5b3V0IDogdCBsYXlvdXQpIGRpbXMgZiA9XG4gICAgbGV0IGFyciA9IGNyZWF0ZSBraW5kIGxheW91dCBkaW1zIGluXG4gICAgbWF0Y2ggQXJyYXkubGVuZ3RoIGRpbXMsIGxheW91dCB3aXRoXG4gICAgfCAwLCBfIC0+IGFyclxuICAgIHwgZGxlbiwgQ19sYXlvdXQgLT4gY2xvb3AgYXJyIChBcnJheS5tYWtlIGRsZW4gMCkgZiAwIGRpbXM7IGFyclxuICAgIHwgZGxlbiwgRm9ydHJhbl9sYXlvdXQgLT4gZmxvb3AgYXJyIChBcnJheS5tYWtlIGRsZW4gMSkgZiAocHJlZCBkbGVuKSBkaW1zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyXG5cbiAgZXh0ZXJuYWwgbnVtX2RpbXM6ICgnYSwgJ2IsICdjKSB0IC0+IGludCA9IFwiY2FtbF9iYV9udW1fZGltc1wiXG4gIGV4dGVybmFsIG50aF9kaW06ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiBpbnQgPSBcImNhbWxfYmFfZGltXCJcbiAgbGV0IGRpbXMgYSA9XG4gICAgbGV0IG4gPSBudW1fZGltcyBhIGluXG4gICAgbGV0IGQgPSBBcnJheS5tYWtlIG4gMCBpblxuICAgIGZvciBpID0gMCB0byBuLTEgZG8gZC4oaSkgPC0gbnRoX2RpbSBhIGkgZG9uZTtcbiAgICBkXG5cbiAgZXh0ZXJuYWwga2luZDogKCdhLCAnYiwgJ2MpIHQgLT4gKCdhLCAnYikga2luZCA9IFwiY2FtbF9iYV9raW5kXCJcbiAgZXh0ZXJuYWwgbGF5b3V0OiAoJ2EsICdiLCAnYykgdCAtPiAnYyBsYXlvdXQgPSBcImNhbWxfYmFfbGF5b3V0XCJcbiAgZXh0ZXJuYWwgY2hhbmdlX2xheW91dDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2QgbGF5b3V0IC0+ICgnYSwgJ2IsICdkKSB0XG4gICAgID0gXCJjYW1sX2JhX2NoYW5nZV9sYXlvdXRcIlxuXG4gIGxldCBzaXplX2luX2J5dGVzIGFyciA9XG4gICAgKGtpbmRfc2l6ZV9pbl9ieXRlcyAoa2luZCBhcnIpKSAqIChBcnJheS5mb2xkX2xlZnQgKCAqICkgMSAoZGltcyBhcnIpKVxuXG4gIGV4dGVybmFsIHN1Yl9sZWZ0OiAoJ2EsICdiLCBjX2xheW91dCkgdCAtPiBpbnQgLT4gaW50IC0+ICgnYSwgJ2IsIGNfbGF5b3V0KSB0XG4gICAgID0gXCJjYW1sX2JhX3N1YlwiXG4gIGV4dGVybmFsIHN1Yl9yaWdodDogKCdhLCAnYiwgZm9ydHJhbl9sYXlvdXQpIHQgLT4gaW50IC0+IGludCAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAoJ2EsICdiLCBmb3J0cmFuX2xheW91dCkgdFxuICAgICA9IFwiY2FtbF9iYV9zdWJcIlxuICBleHRlcm5hbCBzbGljZV9sZWZ0OiAoJ2EsICdiLCBjX2xheW91dCkgdCAtPiBpbnQgYXJyYXkgLT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgKCdhLCAnYiwgY19sYXlvdXQpIHRcbiAgICAgPSBcImNhbWxfYmFfc2xpY2VcIlxuICBleHRlcm5hbCBzbGljZV9yaWdodDogKCdhLCAnYiwgZm9ydHJhbl9sYXlvdXQpIHQgLT4gaW50IGFycmF5IC0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICgnYSwgJ2IsIGZvcnRyYW5fbGF5b3V0KSB0XG4gICAgID0gXCJjYW1sX2JhX3NsaWNlXCJcbiAgZXh0ZXJuYWwgYmxpdDogKCdhLCAnYiwgJ2MpIHQgLT4gKCdhLCAnYiwgJ2MpIHQgLT4gdW5pdFxuICAgICA9IFwiY2FtbF9iYV9ibGl0XCJcbiAgZXh0ZXJuYWwgZmlsbDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2EgLT4gdW5pdCA9IFwiY2FtbF9iYV9maWxsXCJcbmVuZFxuXG5tb2R1bGUgQXJyYXkwID0gc3RydWN0XG4gIHR5cGUgKCEnYSwgISdiLCAhJ2MpIHQgPSAoJ2EsICdiLCAnYykgR2VuYXJyYXkudFxuICBsZXQgY3JlYXRlIGtpbmQgbGF5b3V0ID1cbiAgICBHZW5hcnJheS5jcmVhdGUga2luZCBsYXlvdXQgW3x8XVxuICBsZXQgZ2V0IGFyciA9IEdlbmFycmF5LmdldCBhcnIgW3x8XVxuICBsZXQgc2V0IGFyciA9IEdlbmFycmF5LnNldCBhcnIgW3x8XVxuICBleHRlcm5hbCBraW5kOiAoJ2EsICdiLCAnYykgdCAtPiAoJ2EsICdiKSBraW5kID0gXCJjYW1sX2JhX2tpbmRcIlxuICBleHRlcm5hbCBsYXlvdXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICdjIGxheW91dCA9IFwiY2FtbF9iYV9sYXlvdXRcIlxuXG4gIGV4dGVybmFsIGNoYW5nZV9sYXlvdXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICdkIGxheW91dCAtPiAoJ2EsICdiLCAnZCkgdFxuICAgID0gXCJjYW1sX2JhX2NoYW5nZV9sYXlvdXRcIlxuXG4gIGxldCBzaXplX2luX2J5dGVzIGFyciA9IGtpbmRfc2l6ZV9pbl9ieXRlcyAoa2luZCBhcnIpXG5cbiAgZXh0ZXJuYWwgYmxpdDogKCdhLCAnYiwgJ2MpIHQgLT4gKCdhLCAnYiwgJ2MpIHQgLT4gdW5pdCA9IFwiY2FtbF9iYV9ibGl0XCJcbiAgZXh0ZXJuYWwgZmlsbDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2EgLT4gdW5pdCA9IFwiY2FtbF9iYV9maWxsXCJcblxuICBsZXQgb2ZfdmFsdWUga2luZCBsYXlvdXQgdiA9XG4gICAgbGV0IGEgPSBjcmVhdGUga2luZCBsYXlvdXQgaW5cbiAgICBzZXQgYSB2O1xuICAgIGFcbiAgbGV0IGluaXQgPSBvZl92YWx1ZVxuZW5kXG5cbm1vZHVsZSBBcnJheTEgPSBzdHJ1Y3RcbiAgdHlwZSAoISdhLCAhJ2IsICEnYykgdCA9ICgnYSwgJ2IsICdjKSBHZW5hcnJheS50XG4gIGxldCBjcmVhdGUga2luZCBsYXlvdXQgZGltID1cbiAgICBHZW5hcnJheS5jcmVhdGUga2luZCBsYXlvdXQgW3xkaW18XVxuICBleHRlcm5hbCBnZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiAnYSA9IFwiJWNhbWxfYmFfcmVmXzFcIlxuICBleHRlcm5hbCBzZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiAnYSAtPiB1bml0ID0gXCIlY2FtbF9iYV9zZXRfMVwiXG4gIGV4dGVybmFsIHVuc2FmZV9nZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiAnYSA9IFwiJWNhbWxfYmFfdW5zYWZlX3JlZl8xXCJcbiAgZXh0ZXJuYWwgdW5zYWZlX3NldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+ICdhIC0+IHVuaXRcbiAgICAgPSBcIiVjYW1sX2JhX3Vuc2FmZV9zZXRfMVwiXG4gIGV4dGVybmFsIGRpbTogKCdhLCAnYiwgJ2MpIHQgLT4gaW50ID0gXCIlY2FtbF9iYV9kaW1fMVwiXG4gIGV4dGVybmFsIGtpbmQ6ICgnYSwgJ2IsICdjKSB0IC0+ICgnYSwgJ2IpIGtpbmQgPSBcImNhbWxfYmFfa2luZFwiXG4gIGV4dGVybmFsIGxheW91dDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2MgbGF5b3V0ID0gXCJjYW1sX2JhX2xheW91dFwiXG5cbiAgZXh0ZXJuYWwgY2hhbmdlX2xheW91dDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2QgbGF5b3V0IC0+ICgnYSwgJ2IsICdkKSB0XG4gICAgPSBcImNhbWxfYmFfY2hhbmdlX2xheW91dFwiXG5cbiAgbGV0IHNpemVfaW5fYnl0ZXMgYXJyID1cbiAgICAoa2luZF9zaXplX2luX2J5dGVzIChraW5kIGFycikpICogKGRpbSBhcnIpXG5cbiAgZXh0ZXJuYWwgc3ViOiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gaW50IC0+ICgnYSwgJ2IsICdjKSB0ID0gXCJjYW1sX2JhX3N1YlwiXG4gIGxldCBzbGljZSAodHlwZSB0KSAoYSA6IChfLCBfLCB0KSBHZW5hcnJheS50KSBuID1cbiAgICBtYXRjaCBsYXlvdXQgYSB3aXRoXG4gICAgfCBDX2xheW91dCAtPiAoR2VuYXJyYXkuc2xpY2VfbGVmdCBhIFt8bnxdIDogKF8sIF8sIHQpIEdlbmFycmF5LnQpXG4gICAgfCBGb3J0cmFuX2xheW91dCAtPiAoR2VuYXJyYXkuc2xpY2VfcmlnaHQgYSBbfG58XTogKF8sIF8sIHQpIEdlbmFycmF5LnQpXG4gIGV4dGVybmFsIGJsaXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICgnYSwgJ2IsICdjKSB0IC0+IHVuaXQgPSBcImNhbWxfYmFfYmxpdFwiXG4gIGV4dGVybmFsIGZpbGw6ICgnYSwgJ2IsICdjKSB0IC0+ICdhIC0+IHVuaXQgPSBcImNhbWxfYmFfZmlsbFwiXG4gIGxldCBjX2luaXQgYXJyIGRpbSBmID1cbiAgICBmb3IgaSA9IDAgdG8gcHJlZCBkaW0gZG8gdW5zYWZlX3NldCBhcnIgaSAoZiBpKSBkb25lXG4gIGxldCBmb3J0cmFuX2luaXQgYXJyIGRpbSBmID1cbiAgICBmb3IgaSA9IDEgdG8gZGltIGRvIHVuc2FmZV9zZXQgYXJyIGkgKGYgaSkgZG9uZVxuICBsZXQgaW5pdCAodHlwZSB0KSBraW5kIChsYXlvdXQgOiB0IGxheW91dCkgZGltIGYgPVxuICAgIGxldCBhcnIgPSBjcmVhdGUga2luZCBsYXlvdXQgZGltIGluXG4gICAgbWF0Y2ggbGF5b3V0IHdpdGhcbiAgICB8IENfbGF5b3V0IC0+IGNfaW5pdCBhcnIgZGltIGY7IGFyclxuICAgIHwgRm9ydHJhbl9sYXlvdXQgLT4gZm9ydHJhbl9pbml0IGFyciBkaW0gZjsgYXJyXG4gIGxldCBvZl9hcnJheSAodHlwZSB0KSBraW5kIChsYXlvdXQ6IHQgbGF5b3V0KSBkYXRhID1cbiAgICBsZXQgYmEgPSBjcmVhdGUga2luZCBsYXlvdXQgKEFycmF5Lmxlbmd0aCBkYXRhKSBpblxuICAgIGxldCBvZnMgPVxuICAgICAgbWF0Y2ggbGF5b3V0IHdpdGhcbiAgICAgICAgQ19sYXlvdXQgLT4gMFxuICAgICAgfCBGb3J0cmFuX2xheW91dCAtPiAxXG4gICAgaW5cbiAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGRhdGEgLSAxIGRvIHVuc2FmZV9zZXQgYmEgKGkgKyBvZnMpIGRhdGEuKGkpIGRvbmU7XG4gICAgYmFcbmVuZFxuXG5tb2R1bGUgQXJyYXkyID0gc3RydWN0XG4gIHR5cGUgKCEnYSwgISdiLCAhJ2MpIHQgPSAoJ2EsICdiLCAnYykgR2VuYXJyYXkudFxuICBsZXQgY3JlYXRlIGtpbmQgbGF5b3V0IGRpbTEgZGltMiA9XG4gICAgR2VuYXJyYXkuY3JlYXRlIGtpbmQgbGF5b3V0IFt8ZGltMTsgZGltMnxdXG4gIGV4dGVybmFsIGdldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+IGludCAtPiAnYSA9IFwiJWNhbWxfYmFfcmVmXzJcIlxuICBleHRlcm5hbCBzZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiBpbnQgLT4gJ2EgLT4gdW5pdCA9IFwiJWNhbWxfYmFfc2V0XzJcIlxuICBleHRlcm5hbCB1bnNhZmVfZ2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gaW50IC0+ICdhXG4gICAgID0gXCIlY2FtbF9iYV91bnNhZmVfcmVmXzJcIlxuICBleHRlcm5hbCB1bnNhZmVfc2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gaW50IC0+ICdhIC0+IHVuaXRcbiAgICAgPSBcIiVjYW1sX2JhX3Vuc2FmZV9zZXRfMlwiXG4gIGV4dGVybmFsIGRpbTE6ICgnYSwgJ2IsICdjKSB0IC0+IGludCA9IFwiJWNhbWxfYmFfZGltXzFcIlxuICBleHRlcm5hbCBkaW0yOiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgPSBcIiVjYW1sX2JhX2RpbV8yXCJcbiAgZXh0ZXJuYWwga2luZDogKCdhLCAnYiwgJ2MpIHQgLT4gKCdhLCAnYikga2luZCA9IFwiY2FtbF9iYV9raW5kXCJcbiAgZXh0ZXJuYWwgbGF5b3V0OiAoJ2EsICdiLCAnYykgdCAtPiAnYyBsYXlvdXQgPSBcImNhbWxfYmFfbGF5b3V0XCJcblxuICBleHRlcm5hbCBjaGFuZ2VfbGF5b3V0OiAoJ2EsICdiLCAnYykgdCAtPiAnZCBsYXlvdXQgLT4gKCdhLCAnYiwgJ2QpIHRcbiAgICA9IFwiY2FtbF9iYV9jaGFuZ2VfbGF5b3V0XCJcblxuICBsZXQgc2l6ZV9pbl9ieXRlcyBhcnIgPVxuICAgIChraW5kX3NpemVfaW5fYnl0ZXMgKGtpbmQgYXJyKSkgKiAoZGltMSBhcnIpICogKGRpbTIgYXJyKVxuXG4gIGV4dGVybmFsIHN1Yl9sZWZ0OiAoJ2EsICdiLCBjX2xheW91dCkgdCAtPiBpbnQgLT4gaW50IC0+ICgnYSwgJ2IsIGNfbGF5b3V0KSB0XG4gICAgID0gXCJjYW1sX2JhX3N1YlwiXG4gIGV4dGVybmFsIHN1Yl9yaWdodDpcbiAgICAoJ2EsICdiLCBmb3J0cmFuX2xheW91dCkgdCAtPiBpbnQgLT4gaW50IC0+ICgnYSwgJ2IsIGZvcnRyYW5fbGF5b3V0KSB0XG4gICAgID0gXCJjYW1sX2JhX3N1YlwiXG4gIGxldCBzbGljZV9sZWZ0IGEgbiA9IEdlbmFycmF5LnNsaWNlX2xlZnQgYSBbfG58XVxuICBsZXQgc2xpY2VfcmlnaHQgYSBuID0gR2VuYXJyYXkuc2xpY2VfcmlnaHQgYSBbfG58XVxuICBleHRlcm5hbCBibGl0OiAoJ2EsICdiLCAnYykgdCAtPiAoJ2EsICdiLCAnYykgdCAtPiB1bml0ID0gXCJjYW1sX2JhX2JsaXRcIlxuICBleHRlcm5hbCBmaWxsOiAoJ2EsICdiLCAnYykgdCAtPiAnYSAtPiB1bml0ID0gXCJjYW1sX2JhX2ZpbGxcIlxuICBsZXQgY19pbml0IGFyciBkaW0xIGRpbTIgZiA9XG4gICAgZm9yIGkgPSAwIHRvIHByZWQgZGltMSBkb1xuICAgICAgZm9yIGogPSAwIHRvIHByZWQgZGltMiBkb1xuICAgICAgICB1bnNhZmVfc2V0IGFyciBpIGogKGYgaSBqKVxuICAgICAgZG9uZVxuICAgIGRvbmVcbiAgbGV0IGZvcnRyYW5faW5pdCBhcnIgZGltMSBkaW0yIGYgPVxuICAgIGZvciBqID0gMSB0byBkaW0yIGRvXG4gICAgICBmb3IgaSA9IDEgdG8gZGltMSBkb1xuICAgICAgICB1bnNhZmVfc2V0IGFyciBpIGogKGYgaSBqKVxuICAgICAgZG9uZVxuICAgIGRvbmVcbiAgbGV0IGluaXQgKHR5cGUgdCkga2luZCAobGF5b3V0IDogdCBsYXlvdXQpIGRpbTEgZGltMiBmID1cbiAgICBsZXQgYXJyID0gY3JlYXRlIGtpbmQgbGF5b3V0IGRpbTEgZGltMiBpblxuICAgIG1hdGNoIGxheW91dCB3aXRoXG4gICAgfCBDX2xheW91dCAtPiBjX2luaXQgYXJyIGRpbTEgZGltMiBmOyBhcnJcbiAgICB8IEZvcnRyYW5fbGF5b3V0IC0+IGZvcnRyYW5faW5pdCBhcnIgZGltMSBkaW0yIGY7IGFyclxuICBsZXQgb2ZfYXJyYXkgKHR5cGUgdCkga2luZCAobGF5b3V0OiB0IGxheW91dCkgZGF0YSA9XG4gICAgbGV0IGRpbTEgPSBBcnJheS5sZW5ndGggZGF0YSBpblxuICAgIGxldCBkaW0yID0gaWYgZGltMSA9IDAgdGhlbiAwIGVsc2UgQXJyYXkubGVuZ3RoIGRhdGEuKDApIGluXG4gICAgbGV0IGJhID0gY3JlYXRlIGtpbmQgbGF5b3V0IGRpbTEgZGltMiBpblxuICAgIGxldCBvZnMgPVxuICAgICAgbWF0Y2ggbGF5b3V0IHdpdGhcbiAgICAgICAgQ19sYXlvdXQgLT4gMFxuICAgICAgfCBGb3J0cmFuX2xheW91dCAtPiAxXG4gICAgaW5cbiAgICBmb3IgaSA9IDAgdG8gZGltMSAtIDEgZG9cbiAgICAgIGxldCByb3cgPSBkYXRhLihpKSBpblxuICAgICAgaWYgQXJyYXkubGVuZ3RoIHJvdyA8PiBkaW0yIHRoZW5cbiAgICAgICAgaW52YWxpZF9hcmcoXCJCaWdhcnJheS5BcnJheTIub2ZfYXJyYXk6IG5vbi1yZWN0YW5ndWxhciBkYXRhXCIpO1xuICAgICAgZm9yIGogPSAwIHRvIGRpbTIgLSAxIGRvXG4gICAgICAgIHVuc2FmZV9zZXQgYmEgKGkgKyBvZnMpIChqICsgb2ZzKSByb3cuKGopXG4gICAgICBkb25lXG4gICAgZG9uZTtcbiAgICBiYVxuZW5kXG5cbm1vZHVsZSBBcnJheTMgPSBzdHJ1Y3RcbiAgdHlwZSAoISdhLCAhJ2IsICEnYykgdCA9ICgnYSwgJ2IsICdjKSBHZW5hcnJheS50XG4gIGxldCBjcmVhdGUga2luZCBsYXlvdXQgZGltMSBkaW0yIGRpbTMgPVxuICAgIEdlbmFycmF5LmNyZWF0ZSBraW5kIGxheW91dCBbfGRpbTE7IGRpbTI7IGRpbTN8XVxuICBleHRlcm5hbCBnZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiBpbnQgLT4gaW50IC0+ICdhID0gXCIlY2FtbF9iYV9yZWZfM1wiXG4gIGV4dGVybmFsIHNldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+IGludCAtPiBpbnQgLT4gJ2EgLT4gdW5pdFxuICAgICA9IFwiJWNhbWxfYmFfc2V0XzNcIlxuICBleHRlcm5hbCB1bnNhZmVfZ2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gaW50IC0+IGludCAtPiAnYVxuICAgICA9IFwiJWNhbWxfYmFfdW5zYWZlX3JlZl8zXCJcbiAgZXh0ZXJuYWwgdW5zYWZlX3NldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+IGludCAtPiBpbnQgLT4gJ2EgLT4gdW5pdFxuICAgICA9IFwiJWNhbWxfYmFfdW5zYWZlX3NldF8zXCJcbiAgZXh0ZXJuYWwgZGltMTogKCdhLCAnYiwgJ2MpIHQgLT4gaW50ID0gXCIlY2FtbF9iYV9kaW1fMVwiXG4gIGV4dGVybmFsIGRpbTI6ICgnYSwgJ2IsICdjKSB0IC0+IGludCA9IFwiJWNhbWxfYmFfZGltXzJcIlxuICBleHRlcm5hbCBkaW0zOiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgPSBcIiVjYW1sX2JhX2RpbV8zXCJcbiAgZXh0ZXJuYWwga2luZDogKCdhLCAnYiwgJ2MpIHQgLT4gKCdhLCAnYikga2luZCA9IFwiY2FtbF9iYV9raW5kXCJcbiAgZXh0ZXJuYWwgbGF5b3V0OiAoJ2EsICdiLCAnYykgdCAtPiAnYyBsYXlvdXQgPSBcImNhbWxfYmFfbGF5b3V0XCJcblxuICBleHRlcm5hbCBjaGFuZ2VfbGF5b3V0OiAoJ2EsICdiLCAnYykgdCAtPiAnZCBsYXlvdXQgLT4gKCdhLCAnYiwgJ2QpIHRcbiAgICA9IFwiY2FtbF9iYV9jaGFuZ2VfbGF5b3V0XCJcblxuICBsZXQgc2l6ZV9pbl9ieXRlcyBhcnIgPVxuICAgIChraW5kX3NpemVfaW5fYnl0ZXMgKGtpbmQgYXJyKSkgKiAoZGltMSBhcnIpICogKGRpbTIgYXJyKSAqIChkaW0zIGFycilcblxuICBleHRlcm5hbCBzdWJfbGVmdDogKCdhLCAnYiwgY19sYXlvdXQpIHQgLT4gaW50IC0+IGludCAtPiAoJ2EsICdiLCBjX2xheW91dCkgdFxuICAgICA9IFwiY2FtbF9iYV9zdWJcIlxuICBleHRlcm5hbCBzdWJfcmlnaHQ6XG4gICAgICgnYSwgJ2IsIGZvcnRyYW5fbGF5b3V0KSB0IC0+IGludCAtPiBpbnQgLT4gKCdhLCAnYiwgZm9ydHJhbl9sYXlvdXQpIHRcbiAgICAgPSBcImNhbWxfYmFfc3ViXCJcbiAgbGV0IHNsaWNlX2xlZnRfMSBhIG4gbSA9IEdlbmFycmF5LnNsaWNlX2xlZnQgYSBbfG47IG18XVxuICBsZXQgc2xpY2VfcmlnaHRfMSBhIG4gbSA9IEdlbmFycmF5LnNsaWNlX3JpZ2h0IGEgW3xuOyBtfF1cbiAgbGV0IHNsaWNlX2xlZnRfMiBhIG4gPSBHZW5hcnJheS5zbGljZV9sZWZ0IGEgW3xufF1cbiAgbGV0IHNsaWNlX3JpZ2h0XzIgYSBuID0gR2VuYXJyYXkuc2xpY2VfcmlnaHQgYSBbfG58XVxuICBleHRlcm5hbCBibGl0OiAoJ2EsICdiLCAnYykgdCAtPiAoJ2EsICdiLCAnYykgdCAtPiB1bml0ID0gXCJjYW1sX2JhX2JsaXRcIlxuICBleHRlcm5hbCBmaWxsOiAoJ2EsICdiLCAnYykgdCAtPiAnYSAtPiB1bml0ID0gXCJjYW1sX2JhX2ZpbGxcIlxuICBsZXQgY19pbml0IGFyciBkaW0xIGRpbTIgZGltMyBmID1cbiAgICBmb3IgaSA9IDAgdG8gcHJlZCBkaW0xIGRvXG4gICAgICBmb3IgaiA9IDAgdG8gcHJlZCBkaW0yIGRvXG4gICAgICAgIGZvciBrID0gMCB0byBwcmVkIGRpbTMgZG9cbiAgICAgICAgICB1bnNhZmVfc2V0IGFyciBpIGogayAoZiBpIGogaylcbiAgICAgICAgZG9uZVxuICAgICAgZG9uZVxuICAgIGRvbmVcbiAgbGV0IGZvcnRyYW5faW5pdCBhcnIgZGltMSBkaW0yIGRpbTMgZiA9XG4gICAgZm9yIGsgPSAxIHRvIGRpbTMgZG9cbiAgICAgIGZvciBqID0gMSB0byBkaW0yIGRvXG4gICAgICAgIGZvciBpID0gMSB0byBkaW0xIGRvXG4gICAgICAgICAgdW5zYWZlX3NldCBhcnIgaSBqIGsgKGYgaSBqIGspXG4gICAgICAgIGRvbmVcbiAgICAgIGRvbmVcbiAgICBkb25lXG4gIGxldCBpbml0ICh0eXBlIHQpIGtpbmQgKGxheW91dCA6IHQgbGF5b3V0KSBkaW0xIGRpbTIgZGltMyBmID1cbiAgICBsZXQgYXJyID0gY3JlYXRlIGtpbmQgbGF5b3V0IGRpbTEgZGltMiBkaW0zIGluXG4gICAgbWF0Y2ggbGF5b3V0IHdpdGhcbiAgICB8IENfbGF5b3V0IC0+IGNfaW5pdCBhcnIgZGltMSBkaW0yIGRpbTMgZjsgYXJyXG4gICAgfCBGb3J0cmFuX2xheW91dCAtPiBmb3J0cmFuX2luaXQgYXJyIGRpbTEgZGltMiBkaW0zIGY7IGFyclxuICBsZXQgb2ZfYXJyYXkgKHR5cGUgdCkga2luZCAobGF5b3V0OiB0IGxheW91dCkgZGF0YSA9XG4gICAgbGV0IGRpbTEgPSBBcnJheS5sZW5ndGggZGF0YSBpblxuICAgIGxldCBkaW0yID0gaWYgZGltMSA9IDAgdGhlbiAwIGVsc2UgQXJyYXkubGVuZ3RoIGRhdGEuKDApIGluXG4gICAgbGV0IGRpbTMgPSBpZiBkaW0yID0gMCB0aGVuIDAgZWxzZSBBcnJheS5sZW5ndGggZGF0YS4oMCkuKDApIGluXG4gICAgbGV0IGJhID0gY3JlYXRlIGtpbmQgbGF5b3V0IGRpbTEgZGltMiBkaW0zIGluXG4gICAgbGV0IG9mcyA9XG4gICAgICBtYXRjaCBsYXlvdXQgd2l0aFxuICAgICAgICBDX2xheW91dCAtPiAwXG4gICAgICB8IEZvcnRyYW5fbGF5b3V0IC0+IDFcbiAgICBpblxuICAgIGZvciBpID0gMCB0byBkaW0xIC0gMSBkb1xuICAgICAgbGV0IHJvdyA9IGRhdGEuKGkpIGluXG4gICAgICBpZiBBcnJheS5sZW5ndGggcm93IDw+IGRpbTIgdGhlblxuICAgICAgICBpbnZhbGlkX2FyZyhcIkJpZ2FycmF5LkFycmF5My5vZl9hcnJheTogbm9uLWN1YmljIGRhdGFcIik7XG4gICAgICBmb3IgaiA9IDAgdG8gZGltMiAtIDEgZG9cbiAgICAgICAgbGV0IGNvbCA9IHJvdy4oaikgaW5cbiAgICAgICAgaWYgQXJyYXkubGVuZ3RoIGNvbCA8PiBkaW0zIHRoZW5cbiAgICAgICAgICBpbnZhbGlkX2FyZyhcIkJpZ2FycmF5LkFycmF5My5vZl9hcnJheTogbm9uLWN1YmljIGRhdGFcIik7XG4gICAgICAgIGZvciBrID0gMCB0byBkaW0zIC0gMSBkb1xuICAgICAgICAgIHVuc2FmZV9zZXQgYmEgKGkgKyBvZnMpIChqICsgb2ZzKSAoayArIG9mcykgY29sLihrKVxuICAgICAgICBkb25lXG4gICAgICBkb25lXG4gICAgZG9uZTtcbiAgICBiYVxuZW5kXG5cbmV4dGVybmFsIGdlbmFycmF5X29mX2FycmF5MDogKCdhLCAnYiwgJ2MpIEFycmF5MC50IC0+ICgnYSwgJ2IsICdjKSBHZW5hcnJheS50XG4gICA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIGdlbmFycmF5X29mX2FycmF5MTogKCdhLCAnYiwgJ2MpIEFycmF5MS50IC0+ICgnYSwgJ2IsICdjKSBHZW5hcnJheS50XG4gICA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIGdlbmFycmF5X29mX2FycmF5MjogKCdhLCAnYiwgJ2MpIEFycmF5Mi50IC0+ICgnYSwgJ2IsICdjKSBHZW5hcnJheS50XG4gICA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIGdlbmFycmF5X29mX2FycmF5MzogKCdhLCAnYiwgJ2MpIEFycmF5My50IC0+ICgnYSwgJ2IsICdjKSBHZW5hcnJheS50XG4gICA9IFwiJWlkZW50aXR5XCJcbmxldCBhcnJheTBfb2ZfZ2VuYXJyYXkgYSA9XG4gIGlmIEdlbmFycmF5Lm51bV9kaW1zIGEgPSAwIHRoZW4gYVxuICBlbHNlIGludmFsaWRfYXJnIFwiQmlnYXJyYXkuYXJyYXkwX29mX2dlbmFycmF5XCJcbmxldCBhcnJheTFfb2ZfZ2VuYXJyYXkgYSA9XG4gIGlmIEdlbmFycmF5Lm51bV9kaW1zIGEgPSAxIHRoZW4gYVxuICBlbHNlIGludmFsaWRfYXJnIFwiQmlnYXJyYXkuYXJyYXkxX29mX2dlbmFycmF5XCJcbmxldCBhcnJheTJfb2ZfZ2VuYXJyYXkgYSA9XG4gIGlmIEdlbmFycmF5Lm51bV9kaW1zIGEgPSAyIHRoZW4gYVxuICBlbHNlIGludmFsaWRfYXJnIFwiQmlnYXJyYXkuYXJyYXkyX29mX2dlbmFycmF5XCJcbmxldCBhcnJheTNfb2ZfZ2VuYXJyYXkgYSA9XG4gIGlmIEdlbmFycmF5Lm51bV9kaW1zIGEgPSAzIHRoZW4gYVxuICBlbHNlIGludmFsaWRfYXJnIFwiQmlnYXJyYXkuYXJyYXkzX29mX2dlbmFycmF5XCJcblxuZXh0ZXJuYWwgcmVzaGFwZTpcbiAgICgnYSwgJ2IsICdjKSBHZW5hcnJheS50IC0+IGludCBhcnJheSAtPiAoJ2EsICdiLCAnYykgR2VuYXJyYXkudFxuICAgPSBcImNhbWxfYmFfcmVzaGFwZVwiXG5sZXQgcmVzaGFwZV8wIGEgPSByZXNoYXBlIGEgW3x8XVxubGV0IHJlc2hhcGVfMSBhIGRpbTEgPSByZXNoYXBlIGEgW3xkaW0xfF1cbmxldCByZXNoYXBlXzIgYSBkaW0xIGRpbTIgPSByZXNoYXBlIGEgW3xkaW0xO2RpbTJ8XVxubGV0IHJlc2hhcGVfMyBhIGRpbTEgZGltMiBkaW0zID0gcmVzaGFwZSBhIFt8ZGltMTtkaW0yO2RpbTN8XVxuXG4oKiBGb3JjZSBjYW1sX2JhX2dldF97MSwyLDMsTn0gdG8gYmUgbGlua2VkIGluLCBzaW5jZSB3ZSBkb24ndCByZWZlclxuICAgdG8gdGhvc2UgcHJpbWl0aXZlcyBkaXJlY3RseSBpbiB0aGlzIGZpbGUgKilcblxubGV0IF8gPVxuICBsZXQgXyA9IEdlbmFycmF5LmdldCBpblxuICBsZXQgXyA9IEFycmF5MS5nZXQgaW5cbiAgbGV0IF8gPSBBcnJheTIuZ2V0IGluXG4gIGxldCBfID0gQXJyYXkzLmdldCBpblxuICAoKVxuXG5bQEBAb2NhbWwud2FybmluZyBcIi0zMlwiXVxuZXh0ZXJuYWwgZ2V0MTogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2JhX2dldF8xXCJcbmV4dGVybmFsIGdldDI6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9iYV9nZXRfMlwiXG5leHRlcm5hbCBnZXQzOiB1bml0IC0+IHVuaXQgPSBcImNhbWxfYmFfZ2V0XzNcIlxuZXh0ZXJuYWwgc2V0MTogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2JhX3NldF8xXCJcbmV4dGVybmFsIHNldDI6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9iYV9zZXRfMlwiXG5leHRlcm5hbCBzZXQzOiB1bml0IC0+IHVuaXQgPSBcImNhbWxfYmFfc2V0XzNcIlxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAyMSBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlIHQgPSBpbl9jaGFubmVsXG5cbnR5cGUgb3Blbl9mbGFnID0gU3RkbGliLm9wZW5fZmxhZyA9XG4gIHwgT3Blbl9yZG9ubHlcbiAgfCBPcGVuX3dyb25seVxuICB8IE9wZW5fYXBwZW5kXG4gIHwgT3Blbl9jcmVhdFxuICB8IE9wZW5fdHJ1bmNcbiAgfCBPcGVuX2V4Y2xcbiAgfCBPcGVuX2JpbmFyeVxuICB8IE9wZW5fdGV4dFxuICB8IE9wZW5fbm9uYmxvY2tcblxubGV0IHN0ZGluID0gU3RkbGliLnN0ZGluXG5sZXQgb3Blbl9iaW4gPSBTdGRsaWIub3Blbl9pbl9iaW5cbmxldCBvcGVuX3RleHQgPSBTdGRsaWIub3Blbl9pblxubGV0IG9wZW5fZ2VuID0gU3RkbGliLm9wZW5faW5fZ2VuXG5cbmxldCB3aXRoX29wZW4gb3BlbmZ1biBzIGYgPVxuICBsZXQgaWMgPSBvcGVuZnVuIHMgaW5cbiAgRnVuLnByb3RlY3QgfmZpbmFsbHk6KGZ1biAoKSAtPiBTdGRsaWIuY2xvc2VfaW5fbm9lcnIgaWMpXG4gICAgKGZ1biAoKSAtPiBmIGljKVxuXG5sZXQgd2l0aF9vcGVuX2JpbiBzIGYgPVxuICB3aXRoX29wZW4gU3RkbGliLm9wZW5faW5fYmluIHMgZlxuXG5sZXQgd2l0aF9vcGVuX3RleHQgcyBmID1cbiAgd2l0aF9vcGVuIFN0ZGxpYi5vcGVuX2luIHMgZlxuXG5sZXQgd2l0aF9vcGVuX2dlbiBmbGFncyBwZXJtIHMgZiA9XG4gIHdpdGhfb3BlbiAoU3RkbGliLm9wZW5faW5fZ2VuIGZsYWdzIHBlcm0pIHMgZlxuXG5sZXQgc2VlayA9IFN0ZGxpYi5MYXJnZUZpbGUuc2Vla19pblxubGV0IHBvcyA9IFN0ZGxpYi5MYXJnZUZpbGUucG9zX2luXG5sZXQgbGVuZ3RoID0gU3RkbGliLkxhcmdlRmlsZS5pbl9jaGFubmVsX2xlbmd0aFxubGV0IGNsb3NlID0gU3RkbGliLmNsb3NlX2luXG5sZXQgY2xvc2Vfbm9lcnIgPSBTdGRsaWIuY2xvc2VfaW5fbm9lcnJcblxubGV0IGlucHV0X2NoYXIgaWMgPVxuICBtYXRjaCBTdGRsaWIuaW5wdXRfY2hhciBpYyB3aXRoXG4gIHwgYyAtPiBTb21lIGNcbiAgfCBleGNlcHRpb24gRW5kX29mX2ZpbGUgLT4gTm9uZVxuXG5sZXQgaW5wdXRfYnl0ZSBpYyA9XG4gIG1hdGNoIFN0ZGxpYi5pbnB1dF9ieXRlIGljIHdpdGhcbiAgfCBuIC0+IFNvbWUgblxuICB8IGV4Y2VwdGlvbiBFbmRfb2ZfZmlsZSAtPiBOb25lXG5cbmxldCBpbnB1dF9saW5lIGljID1cbiAgbWF0Y2ggU3RkbGliLmlucHV0X2xpbmUgaWMgd2l0aFxuICB8IHMgLT4gU29tZSBzXG4gIHwgZXhjZXB0aW9uIEVuZF9vZl9maWxlIC0+IE5vbmVcblxubGV0IGlucHV0ID0gU3RkbGliLmlucHV0XG5cbmxldCByZWFsbHlfaW5wdXQgaWMgYnVmIHBvcyBsZW4gPVxuICBtYXRjaCBTdGRsaWIucmVhbGx5X2lucHV0IGljIGJ1ZiBwb3MgbGVuIHdpdGhcbiAgfCAoKSAtPiBTb21lICgpXG4gIHwgZXhjZXB0aW9uIEVuZF9vZl9maWxlIC0+IE5vbmVcblxubGV0IHJlYWxseV9pbnB1dF9zdHJpbmcgaWMgbGVuID1cbiAgbWF0Y2ggU3RkbGliLnJlYWxseV9pbnB1dF9zdHJpbmcgaWMgbGVuIHdpdGhcbiAgfCBzIC0+IFNvbWUgc1xuICB8IGV4Y2VwdGlvbiBFbmRfb2ZfZmlsZSAtPiBOb25lXG5cbigqIFJlYWQgdXAgdG8gW2xlbl0gYnl0ZXMgaW50byBbYnVmXSwgc3RhcnRpbmcgYXQgW29mc10uIFJldHVybiB0b3RhbCBieXRlc1xuICAgcmVhZC4gKilcbmxldCByZWFkX3VwdG8gaWMgYnVmIG9mcyBsZW4gPVxuICBsZXQgcmVjIGxvb3Agb2ZzIGxlbiA9XG4gICAgaWYgbGVuID0gMCB0aGVuIG9mc1xuICAgIGVsc2UgYmVnaW5cbiAgICAgIGxldCByID0gU3RkbGliLmlucHV0IGljIGJ1ZiBvZnMgbGVuIGluXG4gICAgICBpZiByID0gMCB0aGVuXG4gICAgICAgIG9mc1xuICAgICAgZWxzZVxuICAgICAgICBsb29wIChvZnMgKyByKSAobGVuIC0gcilcbiAgICBlbmRcbiAgaW5cbiAgbG9vcCBvZnMgbGVuIC0gb2ZzXG5cbigqIEJlc3QgZWZmb3J0IGF0dGVtcHQgdG8gcmV0dXJuIGEgYnVmZmVyIHdpdGggPj0gKG9mcyArIG4pIGJ5dGVzIG9mIHN0b3JhZ2UsXG4gICBhbmQgc3VjaCB0aGF0IGl0IGNvaW5jaWRlcyB3aXRoIFtidWZdIGF0IGluZGljZXMgPCBbb2ZzXS5cblxuICAgVGhlIHJldHVybmVkIGJ1ZmZlciBpcyBlcXVhbCB0byBbYnVmXSBpdHNlbGYgaWYgaXQgYWxyZWFkeSBoYXMgc3VmZmljaWVudFxuICAgZnJlZSBzcGFjZS5cblxuICAgVGhlIHJldHVybmVkIGJ1ZmZlciBtYXkgaGF2ZSAqZmV3ZXIqIHRoYW4gW29mcyArIG5dIGJ5dGVzIG9mIHN0b3JhZ2UgaWYgdGhpc1xuICAgbnVtYmVyIGlzID4gW1N5cy5tYXhfc3RyaW5nX2xlbmd0aF0uIEhvd2V2ZXIgdGhlIHJldHVybmVkIGJ1ZmZlciB3aWxsXG4gICAqYWx3YXlzKiBoYXZlID4gW29mc10gYnl0ZXMgb2Ygc3RvcmFnZS4gSW4gdGhlIGxpbWl0aW5nIGNhc2Ugd2hlbiBbb2ZzID0gbGVuXG4gICA9IFN5cy5tYXhfc3RyaW5nX2xlbmd0aF0gKHNvIHRoYXQgaXQgaXMgbm90IHBvc3NpYmxlIHRvIHJlc2l6ZSB0aGUgYnVmZmVyIGF0XG4gICBhbGwpLCBhbiBleGNlcHRpb24gaXMgcmFpc2VkLiAqKVxuXG5sZXQgZW5zdXJlIGJ1ZiBvZnMgbiA9XG4gIGxldCBsZW4gPSBCeXRlcy5sZW5ndGggYnVmIGluXG4gIGlmIGxlbiA+PSBvZnMgKyBuIHRoZW4gYnVmXG4gIGVsc2UgYmVnaW5cbiAgICBsZXQgbmV3X2xlbiA9IHJlZiBsZW4gaW5cbiAgICB3aGlsZSAhbmV3X2xlbiA8IG9mcyArIG4gZG9cbiAgICAgIG5ld19sZW4gOj0gMiAqICFuZXdfbGVuICsgMVxuICAgIGRvbmU7XG4gICAgbGV0IG5ld19sZW4gPSAhbmV3X2xlbiBpblxuICAgIGxldCBuZXdfbGVuID1cbiAgICAgIGlmIG5ld19sZW4gPD0gU3lzLm1heF9zdHJpbmdfbGVuZ3RoIHRoZW5cbiAgICAgICAgbmV3X2xlblxuICAgICAgZWxzZSBpZiBvZnMgPCBTeXMubWF4X3N0cmluZ19sZW5ndGggdGhlblxuICAgICAgICBTeXMubWF4X3N0cmluZ19sZW5ndGhcbiAgICAgIGVsc2VcbiAgICAgICAgZmFpbHdpdGggXCJJbl9jaGFubmVsLmlucHV0X2FsbDogY2hhbm5lbCBjb250ZW50IFxcXG4gICAgICAgICAgICAgICAgICBpcyBsYXJnZXIgdGhhbiBtYXhpbXVtIHN0cmluZyBsZW5ndGhcIlxuICAgIGluXG4gICAgbGV0IG5ld19idWYgPSBCeXRlcy5jcmVhdGUgbmV3X2xlbiBpblxuICAgIEJ5dGVzLmJsaXQgYnVmIDAgbmV3X2J1ZiAwIG9mcztcbiAgICBuZXdfYnVmXG4gIGVuZFxuXG5sZXQgaW5wdXRfYWxsIGljID1cbiAgbGV0IGNodW5rX3NpemUgPSA2NTUzNiBpbiAoKiBJT19CVUZGRVJfU0laRSAqKVxuICBsZXQgaW5pdGlhbF9zaXplID1cbiAgICB0cnlcbiAgICAgIFN0ZGxpYi5pbl9jaGFubmVsX2xlbmd0aCBpYyAtIFN0ZGxpYi5wb3NfaW4gaWNcbiAgICB3aXRoIFN5c19lcnJvciBfIC0+XG4gICAgICAtMVxuICBpblxuICBsZXQgaW5pdGlhbF9zaXplID0gaWYgaW5pdGlhbF9zaXplIDwgMCB0aGVuIGNodW5rX3NpemUgZWxzZSBpbml0aWFsX3NpemUgaW5cbiAgbGV0IGluaXRpYWxfc2l6ZSA9XG4gICAgaWYgaW5pdGlhbF9zaXplIDw9IFN5cy5tYXhfc3RyaW5nX2xlbmd0aCB0aGVuXG4gICAgICBpbml0aWFsX3NpemVcbiAgICBlbHNlXG4gICAgICBTeXMubWF4X3N0cmluZ19sZW5ndGhcbiAgaW5cbiAgbGV0IGJ1ZiA9IEJ5dGVzLmNyZWF0ZSBpbml0aWFsX3NpemUgaW5cbiAgbGV0IG5yZWFkID0gcmVhZF91cHRvIGljIGJ1ZiAwIGluaXRpYWxfc2l6ZSBpblxuICBpZiBucmVhZCA8IGluaXRpYWxfc2l6ZSB0aGVuICgqIEVPRiByZWFjaGVkLCBidWZmZXIgcGFydGlhbGx5IGZpbGxlZCAqKVxuICAgIEJ5dGVzLnN1Yl9zdHJpbmcgYnVmIDAgbnJlYWRcbiAgZWxzZSBiZWdpbiAoKiBucmVhZCA9IGluaXRpYWxfc2l6ZSwgbWF5YmUgRU9GIHJlYWNoZWQgKilcbiAgICBtYXRjaCBTdGRsaWIuaW5wdXRfY2hhciBpYyB3aXRoXG4gICAgfCBleGNlcHRpb24gRW5kX29mX2ZpbGUgLT5cbiAgICAgICAgKCogRU9GIHJlYWNoZWQsIGJ1ZmZlciBpcyBjb21wbGV0ZWx5IGZpbGxlZCAqKVxuICAgICAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIGJ1ZlxuICAgIHwgYyAtPlxuICAgICAgICAoKiBFT0Ygbm90IHJlYWNoZWQgKilcbiAgICAgICAgbGV0IHJlYyBsb29wIGJ1ZiBvZnMgPVxuICAgICAgICAgIGxldCBidWYgPSBlbnN1cmUgYnVmIG9mcyBjaHVua19zaXplIGluXG4gICAgICAgICAgbGV0IHJlbSA9IEJ5dGVzLmxlbmd0aCBidWYgLSBvZnMgaW5cbiAgICAgICAgICAoKiBbcmVtXSBjYW4gYmUgPCBbY2h1bmtfc2l6ZV0gaWYgYnVmZmVyIHNpemUgY2xvc2UgdG9cbiAgICAgICAgICAgICBbU3lzLm1heF9zdHJpbmdfbGVuZ3RoXSAqKVxuICAgICAgICAgIGxldCByID0gcmVhZF91cHRvIGljIGJ1ZiBvZnMgcmVtIGluXG4gICAgICAgICAgaWYgciA8IHJlbSB0aGVuICgqIEVPRiByZWFjaGVkICopXG4gICAgICAgICAgICBCeXRlcy5zdWJfc3RyaW5nIGJ1ZiAwIChvZnMgKyByKVxuICAgICAgICAgIGVsc2UgKCogciA9IHJlbSAqKVxuICAgICAgICAgICAgbG9vcCBidWYgKG9mcyArIHJlbSlcbiAgICAgICAgaW5cbiAgICAgICAgbGV0IGJ1ZiA9IGVuc3VyZSBidWYgbnJlYWQgKGNodW5rX3NpemUgKyAxKSBpblxuICAgICAgICBCeXRlcy5zZXQgYnVmIG5yZWFkIGM7XG4gICAgICAgIGxvb3AgYnVmIChucmVhZCArIDEpXG4gIGVuZFxuXG5sZXQgc2V0X2JpbmFyeV9tb2RlID0gU3RkbGliLnNldF9iaW5hcnlfbW9kZV9pblxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAyMSBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlIHQgPSBvdXRfY2hhbm5lbFxuXG50eXBlIG9wZW5fZmxhZyA9IFN0ZGxpYi5vcGVuX2ZsYWcgPVxuICB8IE9wZW5fcmRvbmx5XG4gIHwgT3Blbl93cm9ubHlcbiAgfCBPcGVuX2FwcGVuZFxuICB8IE9wZW5fY3JlYXRcbiAgfCBPcGVuX3RydW5jXG4gIHwgT3Blbl9leGNsXG4gIHwgT3Blbl9iaW5hcnlcbiAgfCBPcGVuX3RleHRcbiAgfCBPcGVuX25vbmJsb2NrXG5cbmxldCBzdGRvdXQgPSBTdGRsaWIuc3Rkb3V0XG5sZXQgc3RkZXJyID0gU3RkbGliLnN0ZGVyclxubGV0IG9wZW5fYmluID0gU3RkbGliLm9wZW5fb3V0X2JpblxubGV0IG9wZW5fdGV4dCA9IFN0ZGxpYi5vcGVuX291dFxubGV0IG9wZW5fZ2VuID0gU3RkbGliLm9wZW5fb3V0X2dlblxuXG5sZXQgd2l0aF9vcGVuIG9wZW5mdW4gcyBmID1cbiAgbGV0IG9jID0gb3BlbmZ1biBzIGluXG4gIEZ1bi5wcm90ZWN0IH5maW5hbGx5OihmdW4gKCkgLT4gU3RkbGliLmNsb3NlX291dF9ub2VyciBvYylcbiAgICAoZnVuICgpIC0+IGYgb2MpXG5cbmxldCB3aXRoX29wZW5fYmluIHMgZiA9XG4gIHdpdGhfb3BlbiBTdGRsaWIub3Blbl9vdXRfYmluIHMgZlxuXG5sZXQgd2l0aF9vcGVuX3RleHQgcyBmID1cbiAgd2l0aF9vcGVuIFN0ZGxpYi5vcGVuX291dCBzIGZcblxubGV0IHdpdGhfb3Blbl9nZW4gZmxhZ3MgcGVybSBzIGYgPVxuICB3aXRoX29wZW4gKFN0ZGxpYi5vcGVuX291dF9nZW4gZmxhZ3MgcGVybSkgcyBmXG5cbmxldCBzZWVrID0gU3RkbGliLkxhcmdlRmlsZS5zZWVrX291dFxubGV0IHBvcyA9IFN0ZGxpYi5MYXJnZUZpbGUucG9zX291dFxubGV0IGxlbmd0aCA9IFN0ZGxpYi5MYXJnZUZpbGUub3V0X2NoYW5uZWxfbGVuZ3RoXG5sZXQgY2xvc2UgPSBTdGRsaWIuY2xvc2Vfb3V0XG5sZXQgY2xvc2Vfbm9lcnIgPSBTdGRsaWIuY2xvc2Vfb3V0X25vZXJyXG5sZXQgZmx1c2ggPSBTdGRsaWIuZmx1c2hcbmxldCBmbHVzaF9hbGwgPSBTdGRsaWIuZmx1c2hfYWxsXG5sZXQgb3V0cHV0X2NoYXIgPSBTdGRsaWIub3V0cHV0X2NoYXJcbmxldCBvdXRwdXRfYnl0ZSA9IFN0ZGxpYi5vdXRwdXRfYnl0ZVxubGV0IG91dHB1dF9zdHJpbmcgPSBTdGRsaWIub3V0cHV0X3N0cmluZ1xubGV0IG91dHB1dF9ieXRlcyA9IFN0ZGxpYi5vdXRwdXRfYnl0ZXNcbmxldCBvdXRwdXQgPSBTdGRsaWIub3V0cHV0XG5sZXQgb3V0cHV0X3N1YnN0cmluZyA9IFN0ZGxpYi5vdXRwdXRfc3Vic3RyaW5nXG5sZXQgc2V0X2JpbmFyeV9tb2RlID0gU3RkbGliLnNldF9iaW5hcnlfbW9kZV9vdXRcblxuZXh0ZXJuYWwgc2V0X2J1ZmZlcmVkIDogdCAtPiBib29sIC0+IHVuaXQgPSBcImNhbWxfbWxfc2V0X2J1ZmZlcmVkXCJcblxuZXh0ZXJuYWwgaXNfYnVmZmVyZWQgOiB0IC0+IGJvb2wgPSBcImNhbWxfbWxfaXNfYnVmZmVyZWRcIlxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgQ29weXJpZ2h0IDIwMjIgT0NhbWxQcm8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogIEFsbCByaWdodHMgcmVzZXJ2ZWQuIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlICAqKVxuKCogIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgc3BlY2lhbCAgICAgICAqKVxuKCogIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5tb2R1bGUgVjEgPSBzdHJ1Y3RcblxuICBsZXQgdmFsaWRfY2FudmFzX3NpemUgKHdpZHRoLCBoZWlnaHQpID1cbiAgICAwIDwgd2lkdGggJiYgd2lkdGggPD0gMzI3NjcgJiYgMCA8IGhlaWdodCAmJiBoZWlnaHQgPD0gMzI3NjdcblxuICBtb2R1bGUgRXhjZXB0aW9uID0gc3RydWN0XG5cbiAgICBleGNlcHRpb24gTm90X2luaXRpYWxpemVkXG4gICAgZXhjZXB0aW9uIEZpbGVfbm90X2ZvdW5kIG9mIHN0cmluZ1xuICAgIGV4Y2VwdGlvbiBSZWFkX3BuZ19mYWlsZWQgb2Ygc3RyaW5nXG4gICAgZXhjZXB0aW9uIFdyaXRlX3BuZ19mYWlsZWQgb2Ygc3RyaW5nXG5cbiAgICBsZXQgKCkgPVxuICAgICAgQ2FsbGJhY2sucmVnaXN0ZXJfZXhjZXB0aW9uIFwiTm90X2luaXRpYWxpemVkXCIgTm90X2luaXRpYWxpemVkO1xuICAgICAgQ2FsbGJhY2sucmVnaXN0ZXJfZXhjZXB0aW9uIFwiRmlsZV9ub3RfZm91bmRcIiAoRmlsZV9ub3RfZm91bmQgXCJcIik7XG4gICAgICBDYWxsYmFjay5yZWdpc3Rlcl9leGNlcHRpb24gXCJSZWFkX3BuZ19mYWlsZWRcIiAoUmVhZF9wbmdfZmFpbGVkIFwiXCIpO1xuICAgICAgQ2FsbGJhY2sucmVnaXN0ZXJfZXhjZXB0aW9uIFwiV3JpdGVfcG5nX2ZhaWxlZFwiIChXcml0ZV9wbmdfZmFpbGVkIFwiXCIpXG5cbiAgZW5kXG5cbiAgbW9kdWxlIENvbnN0ID0gc3RydWN0XG5cbiAgICBsZXQgcGkgPSAgICAgICAzLjE0MTU5MjY1MzU4OTc5MzIzODQ2XG4gICAgbGV0IHBpXzIgPSAgICAgMS41NzA3OTYzMjY3OTQ4OTY2MTkyM1xuICAgIGxldCBwaV80ID0gICAgIDAuNzg1Mzk4MTYzMzk3NDQ4MzA5NjE2XG4gICAgbGV0IHBpXzggPSAgICAgMC4zOTI2OTkwODE2OTg3MjQxNTQ4MDhcblxuICAgIGxldCBpbnZfcGkgPSAgIDAuMzE4MzA5ODg2MTgzNzkwNjcxNTM4XG4gICAgbGV0IGludl9waV8yID0gMC42MzY2MTk3NzIzNjc1ODEzNDMwNzZcbiAgICBsZXQgaW52X3BpXzQgPSAxLjI3MzIzOTU0NDczNTE2MjY4NjE1XG4gICAgbGV0IGludl9waV84ID0gMi41NDY0NzkwODk0NzAzMjUzNzIzMFxuXG4gICAgbGV0IGUgPSAgICAgICAgMi43MTgyODE4Mjg0NTkwNDUyMzUzNlxuICAgIGxldCBpbnZfZSA9ICAgIDAuMzY3ODc5NDQxMTcxNDQyMzIxNTk2XG5cbiAgICBsZXQgbG9nMl9lID0gICAxLjQ0MjY5NTA0MDg4ODk2MzQwNzM2XG4gICAgbGV0IGxvZzEwX2UgPSAgMC40MzQyOTQ0ODE5MDMyNTE4Mjc2NTFcblxuICAgIGxldCBsbl8yID0gICAgIDAuNjkzMTQ3MTgwNTU5OTQ1MzA5NDE3XG4gICAgbGV0IGxuXzEwID0gICAgMi4zMDI1ODUwOTI5OTQwNDU2ODQwMlxuXG4gIGVuZFxuXG4gIG1vZHVsZSBWZWN0b3IgPSBzdHJ1Y3RcblxuICAgIHR5cGUgdCA9IChmbG9hdCAqIGZsb2F0KVxuXG4gICAgbGV0IHplcm8gPVxuICAgICAgKDAuMCwgMC4wKVxuXG4gICAgbGV0IHVuaXQgPVxuICAgICAgKDEuMCwgMS4wKVxuXG4gICAgbGV0IGFkZCAoeDEsIHkxKSAoeDIsIHkyKSA9XG4gICAgICB4MSArLiB4MiwgeTEgKy4geTJcblxuICAgIGxldCBzdWIgKHgxLCB5MSkgKHgyLCB5MikgPVxuICAgICAgeDEgLS4geDIsIHkxIC0uIHkyXG5cbiAgICBsZXQgbXVsICh4LCB5KSBrID1cbiAgICAgIHggKi4gaywgeSAqLiBrXG5cbiAgICBsZXQgZG90ICh4MSwgeTEpICh4MiwgeTIpID1cbiAgICAgIHgxICouIHgyICsuIHkxICouIHkyXG5cbiAgICBsZXQgbm9ybSAoeCwgeSkgPVxuICAgICAgc3FydCAoeCAqLiB4ICsuIHkgKi4geSlcblxuICBlbmRcblxuICBtb2R1bGUgVHJhbnNmb3JtID0gc3RydWN0XG5cbiAgICB0eXBlIHQgPSB7XG4gICAgICBhIDogZmxvYXQ7XG4gICAgICBiIDogZmxvYXQ7XG4gICAgICBjIDogZmxvYXQ7XG4gICAgICBkIDogZmxvYXQ7XG4gICAgICBlIDogZmxvYXQ7XG4gICAgICBmIDogZmxvYXQ7XG4gICAgfVxuXG4gICAgbGV0IGlkID0geyBhID0gMS4wOyBiID0gMC4wO1xuICAgICAgICAgICAgICAgYyA9IDAuMDsgZCA9IDEuMDtcbiAgICAgICAgICAgICAgIGUgPSAwLjA7IGYgPSAwLjAgfVxuXG4gICAgbGV0IGNyZWF0ZSAoYSwgYiwgYywgZCwgZSwgZikgPVxuICAgICAgeyBhOyBiOyBjOyBkOyBlOyBmIH1cblxuICAgIGxldCBtdWwgdDEgdDIgPVxuICAgICAgeyBhID0gdDEuYSAqLiB0Mi5hICsuIHQxLmMgKi4gdDIuYjtcbiAgICAgICAgYiA9IHQxLmIgKi4gdDIuYSArLiB0MS5kICouIHQyLmI7XG4gICAgICAgIGMgPSB0MS5hICouIHQyLmMgKy4gdDEuYyAqLiB0Mi5kO1xuICAgICAgICBkID0gdDEuYiAqLiB0Mi5jICsuIHQxLmQgKi4gdDIuZDtcbiAgICAgICAgZSA9IHQxLmUgKy4gdDEuYSAqLiB0Mi5lICsuIHQxLmMgKi4gdDIuZjtcbiAgICAgICAgZiA9IHQxLmYgKy4gdDEuYiAqLiB0Mi5lICsuIHQxLmQgKi4gdDIuZiB9XG5cbiAgICBsZXQgdHJhbnNsYXRlIHQgKHgsIHkpID1cbiAgICAgIHsgdCB3aXRoXG4gICAgICAgIGUgPSB4ICouIHQuYSArLiB5ICouIHQuYztcbiAgICAgICAgZiA9IHggKi4gdC5iICsuIHkgKi4gdC5kIH1cblxuICAgIGxldCBzY2FsZSB0ICh4LHkpID1cbiAgICAgIHsgdCB3aXRoXG4gICAgICAgIGEgPSB0LmEgKi4geDsgYiA9IHQuYiAqLiB4O1xuICAgICAgICBjID0gdC5jICouIHk7IGQgPSB0LmQgKi4geSB9XG5cbiAgICBsZXQgc2hlYXIgdCAoeCwgeSkgPVxuICAgICAgeyB0IHdpdGhcbiAgICAgICAgYSA9IHQuYSArLiB0LmMgKi4geTsgYiA9IHQuYiArLiB0LmQgKi4geTtcbiAgICAgICAgYyA9IHQuYyArLiB0LmEgKi4geDsgZCA9IHQuZCArLiB0LmIgKi4geCB9XG5cbiAgICBsZXQgcm90YXRlIHQgYSA9XG4gICAgICBsZXQgY29zX2EgPSBjb3MgKC0uIGEpIGluXG4gICAgICBsZXQgc2luX2EgPSBzaW4gKC0uIGEpIGluXG4gICAgICB7IHQgd2l0aFxuICAgICAgICBhID0gdC5hICouIGNvc19hIC0uIHQuYyAqLiBzaW5fYTtcbiAgICAgICAgYiA9IHQuYiAqLiBjb3NfYSAtLiB0LmQgKi4gc2luX2E7XG4gICAgICAgIGMgPSB0LmMgKi4gY29zX2EgKy4gdC5hICouIHNpbl9hO1xuICAgICAgICBkID0gdC5kICouIGNvc19hICsuIHQuYiAqLiBzaW5fYSB9XG5cbiAgICBsZXQgaW52ZXJzZSB0ID1cbiAgICAgIGxldCBkZXQgPSB0LmEgKi4gdC5kIC0uIHQuYiAqLiB0LmMgaW5cbiAgICAgIGlmIGRldCA9IDAuMCB0aGVuXG4gICAgICAgIGludmFsaWRfYXJnIFwiVHJhbnNmb3JtLmludmVyc2U6IHRoZSBtYXRyaXggaXMgbm90IGludmVyc2libGVcIjtcbiAgICAgIGxldCBpbnZkZXQgPSAxLjAgLy4gZGV0IGluXG4gICAgICB7IGEgPSAgICB0LmQgKi4gaW52ZGV0OyBiID0gLS4gdC5iICouIGludmRldDtcbiAgICAgICAgYyA9IC0uIHQuYyAqLiBpbnZkZXQ7IGQgPSAgICB0LmEgKi4gaW52ZGV0O1xuICAgICAgICBlID0gKHQuYyAqLiB0LmYgLS4gdC5kICouIHQuZSkgKi4gaW52ZGV0O1xuICAgICAgICBmID0gKHQuYiAqLiB0LmUgLS4gdC5hICouIHQuZikgKi4gaW52ZGV0IH1cblxuICBlbmRcblxuICBtb2R1bGUgUG9pbnQgPSBzdHJ1Y3RcblxuICAgIHR5cGUgdCA9IChmbG9hdCAqIGZsb2F0KVxuXG4gICAgbGV0IG9mX2ludHMgKHgsIHkpID1cbiAgICAgIChmbG9hdF9vZl9pbnQgeCwgZmxvYXRfb2ZfaW50IHkpXG5cbiAgICBsZXQgc3ViICh4MSwgeTEpICh4MiwgeTIpID1cbiAgICAgIHgxIC0uIHgyLCB5MSAtLiB5MlxuXG4gICAgbGV0IHRyYW5zbGF0ZSAoeCwgeSkgfmJ5OihhLCBiKSA9XG4gICAgICAoeCArLiBhLCB5ICsuIGIpXG5cbiAgICBsZXQgcm90YXRlICh4LCB5KSB+YXJvdW5kOihjeCwgY3kpIH50aGV0YSA9XG4gICAgICAoKHggLS4gY3gpICouIChjb3MgKC0uIHRoZXRhKSkgKy4gKHkgLS4gY3kpICouIChzaW4gKC0uIHRoZXRhKSkgKy4gY3gsXG4gICAgICAgKHkgLS4gY3kpICouIChjb3MgKC0uIHRoZXRhKSkgLS4gKHggLS4gY3gpICouIChzaW4gKC0uIHRoZXRhKSkgKy4gY3kpXG5cbiAgICBsZXQgdHJhbnNmb3JtICh4LCB5KSB0ID1cbiAgICAgIGxldCBvcGVuIFRyYW5zZm9ybSBpblxuICAgICAgKHggKi4gdC5hICsuIHkgKi4gdC5jICsuIHQuZSxcbiAgICAgICB4ICouIHQuYiArLiB5ICouIHQuZCArLiB0LmYpXG5cbiAgICBsZXQgYmFyeWNlbnRlciBhICh4MSwgeTEpIGIgKHgyLCB5MikgPVxuICAgICAgbGV0IHN1bV9hYiA9IGEgKy4gYiBpblxuICAgICAgaWYgc3VtX2FiID0gMC4wIHRoZW5cbiAgICAgICAgaW52YWxpZF9hcmcgXCJQb2ludC5iYXJ5Y2VudGVyOiBhICsgYiBtdXN0IGJlIG5vbi1udWxcIjtcbiAgICAgIChhICouIHgxICsuIGIgKi4geDIpIC8uIHN1bV9hYixcbiAgICAgIChhICouIHkxICsuIGIgKi4geTIpIC8uIHN1bV9hYlxuXG4gICAgbGV0IGRpc3RhbmNlICh4MSwgeTEpICh4MiwgeTIpID1cbiAgICAgIHNxcnQgKCh4MiAtLiB4MSkgKiogMi4wICsuICh5MiAtLiB5MSkgKiogMi4wKVxuXG4gIGVuZFxuXG4gIG1vZHVsZSBDb2xvciA9IHN0cnVjdFxuXG4gICAgdHlwZSB0ID0gSW50MzIudFxuXG4gICAgbGV0IGNsaXBfOCBpID1cbiAgICAgIGlmIGkgPCAwIHRoZW4gMFxuICAgICAgZWxzZSBpZiBpID4gMHhGRiB0aGVuIDB4RkZcbiAgICAgIGVsc2UgaVxuXG4gICAgbGV0IG9mX3JnYiByIGcgYiA9XG4gICAgICBJbnQzMi5hZGQgMHhGRjAwMDAwMGxcbiAgICAgICAgKEludDMyLm9mX2ludCAoY2xpcF84IHIgbHNsIDE2ICsgY2xpcF84IGcgbHNsIDggKyBjbGlwXzggYikpXG5cbiAgICBsZXQgdG9fcmdiIGMgPVxuICAgICAgSW50MzIuKHRvX2ludCAobG9nYW5kIChzaGlmdF9yaWdodF9sb2dpY2FsIGMgMTYpIDB4RkZsKSksXG4gICAgICBJbnQzMi4odG9faW50IChsb2dhbmQgKHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgYyA4KSAweEZGbCkpLFxuICAgICAgSW50MzIuKHRvX2ludCAobG9nYW5kIGMgMHhGRmwpKVxuXG4gICAgbGV0IG9mX2FyZ2IgYSByIGcgYiA9XG4gICAgICBJbnQzMi5hZGRcbiAgICAgICAgKEludDMyLnNoaWZ0X2xlZnQgKEludDMyLm9mX2ludCAoY2xpcF84IGEpKSAyNClcbiAgICAgICAgKEludDMyLm9mX2ludCAoY2xpcF84IHIgbHNsIDE2ICsgY2xpcF84IGcgbHNsIDggKyBjbGlwXzggYikpXG5cbiAgICBsZXQgdG9fYXJnYiBjID1cbiAgICAgIEludDMyLih0b19pbnQgKHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgYyAyNCkpLFxuICAgICAgSW50MzIuKHRvX2ludCAobG9nYW5kIChzaGlmdF9yaWdodF9sb2dpY2FsIGMgMTYpIDB4RkZsKSksXG4gICAgICBJbnQzMi4odG9faW50IChsb2dhbmQgKHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgYyA4KSAweEZGbCkpLFxuICAgICAgSW50MzIuKHRvX2ludCAobG9nYW5kIGMgMHhGRmwpKVxuXG4gICAgbGV0IG9mX2ludCBpID1cbiAgICAgIGlmIGkgPCAwIHRoZW4gMGxcbiAgICAgIGVsc2UgaWYgaSA+IDB4MDBGRkZGRkYgdGhlbiAweEZGRkZGRkZGbFxuICAgICAgZWxzZSBJbnQzMi5hZGQgMHhGRjAwMDAwMGwgKEludDMyLm9mX2ludCBpKVxuXG4gICAgbGV0IHRvX2ludCBjID1cbiAgICAgIEludDMyLih0b19pbnQgKGxvZ2FuZCBjIDB4MDBGRkZGRkZsKSlcblxuICAgIGxldCBvZl9pbnQzMiBpID1cbiAgICAgIGlcblxuICAgIGxldCB0b19pbnQzMiBjID1cbiAgICAgIGNcblxuICAgIG1vZHVsZSBTdHJpbmdNYXAgPSBNYXAuTWFrZShTdHJpbmcpXG4gICAgbGV0IGNvbG9ycyA9IHJlZiBTdHJpbmdNYXAuZW1wdHlcbiAgICBsZXQgZGVmaW5lX2NvbG9yIG5hbWUgYyA9XG4gICAgICBjb2xvcnMgOj0gU3RyaW5nTWFwLmFkZCAoU3RyaW5nLmxvd2VyY2FzZV9hc2NpaSBuYW1lKSBjICFjb2xvcnM7XG4gICAgICBjXG5cbiAgICBsZXQgdHJhbnNwQmxhY2sgPSBkZWZpbmVfY29sb3IgXCJ0cmFuc3BhcmVudF9ibGFja1wiIDB4MDAwMDAwMDBsXG4gICAgbGV0IHRyYW5zcFdoaXRlID0gZGVmaW5lX2NvbG9yIFwidHJhbnNwYXJlbnRfd2hpdGVcIiAweDAwRkZGRkZGbFxuICAgIGxldCBibGFjayA9IGRlZmluZV9jb2xvciBcImJsYWNrXCIgMHhGRjAwMDAwMGxcbiAgICBsZXQgd2hpdGUgPSBkZWZpbmVfY29sb3IgXCJ3aGl0ZVwiIDB4RkZGRkZGRkZsXG4gICAgbGV0IGJsdWUgPSBkZWZpbmVfY29sb3IgXCJibHVlXCIgMHhGRjAwMDBGRmxcbiAgICBsZXQgY3lhbiA9IGRlZmluZV9jb2xvciBcImN5YW5cIiAweEZGMDBGRkZGbFxuICAgIGxldCBncmVlbiA9IGRlZmluZV9jb2xvciBcImdyZWVuXCIgMHhGRjAwODAwMGxcbiAgICBsZXQgbGltZSA9IGRlZmluZV9jb2xvciBcImxpbWVcIiAweEZGMDBGRjAwbFxuICAgIGxldCBvcmFuZ2UgPSBkZWZpbmVfY29sb3IgXCJvcmFuZ2VcIiAweEZGRkZBNTAwbFxuICAgIGxldCBwaW5rID0gZGVmaW5lX2NvbG9yIFwicGlua1wiIDB4RkZGRkMwQ0JsXG4gICAgbGV0IHJlZCA9IGRlZmluZV9jb2xvciBcInJlZFwiIDB4RkZGRjAwMDBsXG5cbiAgICBsZXQgb2Zfc3RyaW5nIHMgPVxuICAgICAgaWYgU3RyaW5nLmxlbmd0aCBzIDwgMSB0aGVuXG4gICAgICAgIGJsYWNrXG4gICAgICBlbHNlIGlmIHMuWzBdID0gJyMnIHRoZW5cbiAgICAgICAgbGV0IHMgPSBcIjB4XCIgXiAoU3RyaW5nLnN1YiBzIDEgKFN0cmluZy5sZW5ndGggcyAtIDEpKSBpblxuICAgICAgICBvZl9pbnQgKGludF9vZl9zdHJpbmcgcylcbiAgICAgIGVsc2VcbiAgICAgICAgdHJ5IFN0cmluZ01hcC5maW5kIChTdHJpbmcubG93ZXJjYXNlX2FzY2lpIHMpICFjb2xvcnNcbiAgICAgICAgd2l0aCBOb3RfZm91bmQgLT4gYmxhY2tcblxuICBlbmRcblxuICBtb2R1bGUgRm9udCA9IHN0cnVjdFxuXG4gICAgdHlwZSBzaXplID0gZmxvYXRcblxuICAgIHR5cGUgc2xhbnQgPVxuICAgICAgfCBSb21hblxuICAgICAgfCBJdGFsaWNcbiAgICAgIHwgT2JsaXF1ZVxuXG4gICAgdHlwZSB3ZWlnaHQgPSBpbnRcblxuICAgIGxldCB0aGluICAgICAgID0gIDEwMFxuICAgIGxldCBleHRyYUxpZ2h0ID0gIDIwMFxuICAgIGxldCBsaWdodCAgICAgID0gIDMwMFxuICAgICgqbGV0IHNlbWlMaWdodCAgPSAgMzE1ICopXG4gICAgKCpsZXQgYm9vayAgICAgICA9ICAzNzAgKilcbiAgICBsZXQgcmVndWxhciAgICA9ICA0MDBcbiAgICBsZXQgbWVkaXVtICAgICA9ICA1MDBcbiAgICBsZXQgc2VtaUJvbGQgICA9ICA2MDBcbiAgICBsZXQgYm9sZCAgICAgICA9ICA3MDBcbiAgICBsZXQgZXh0cmFCb2xkICA9ICA4MDBcbiAgICBsZXQgYmxhY2sgICAgICA9ICA5MDBcbiAgICAoKmxldCBleHRyYUJsYWNrID0gMTAwMCAqKVxuXG4gIGVuZFxuXG4gIHR5cGUgY2FudmFzXG5cbiAgdHlwZSBpbWFnZV9kYXRhID1cbiAgICAoaW50LCBCaWdhcnJheS5pbnQ4X3Vuc2lnbmVkX2VsdCwgQmlnYXJyYXkuY19sYXlvdXQpIEJpZ2FycmF5LkFycmF5My50XG5cbiAgbW9kdWxlIFBlbmRpbmcgPSBzdHJ1Y3RcblxuICAgIHR5cGUgdCA9XG4gICAgICB8IEltYWdlRGF0YSA6XG4gICAgICAgICAgaW1hZ2VfZGF0YSBSZWFjdC5ldmVudCAqXG4gICAgICAgICAgICAoP3N0ZXA6UmVhY3Quc3RlcCAtPiBpbWFnZV9kYXRhIC0+IHVuaXQpICogaW1hZ2VfZGF0YSAtPiB0XG4gICAgICB8IENhbnZhcyA6XG4gICAgICAgICAgY2FudmFzIFJlYWN0LmV2ZW50ICpcbiAgICAgICAgICAgICg/c3RlcDpSZWFjdC5zdGVwIC0+IGNhbnZhcyAtPiB1bml0KSAqIGNhbnZhcyAtPiB0XG5cbiAgICBsZXQgbGlzdCA6IHQgbGlzdCByZWYgPSByZWYgW11cblxuICAgIGxldCBhZGRfaW1hZ2VfZGF0YSBldmVudCBzZW5kX2V2ZW50IGMgPVxuICAgICAgbGlzdCA6PSBJbWFnZURhdGEgKGV2ZW50LCBzZW5kX2V2ZW50LCBjKSA6OiAhbGlzdFxuXG4gICAgbGV0IGFkZF9jYW52YXMgZXZlbnQgc2VuZF9ldmVudCBjID1cbiAgICAgIGxpc3QgOj0gQ2FudmFzIChldmVudCwgc2VuZF9ldmVudCwgYykgOjogIWxpc3RcblxuICAgIGxldCBwcm9jZXNzICgpID1cbiAgICAgIG1hdGNoICFsaXN0IHdpdGhcbiAgICAgIHwgW10gLT4gKClcbiAgICAgIHwgbCAtPlxuICAgICAgICAgIGxpc3QgOj0gW107XG4gICAgICAgICAgTGlzdC5pdGVyIChmdW5jdGlvblxuICAgICAgICAgICAgICB8IEltYWdlRGF0YSAoZXZlbnQsIHNlbmRfZXZlbnQsIGlkKSAtPlxuICAgICAgICAgICAgICAgICAgc2VuZF9ldmVudCA/c3RlcDpOb25lIGlkO1xuICAgICAgICAgICAgICAgICAgUmVhY3QuRS5zdG9wIGV2ZW50XG4gICAgICAgICAgICAgIHwgQ2FudmFzIChldmVudCwgc2VuZF9ldmVudCwgYykgLT5cbiAgICAgICAgICAgICAgICAgIHNlbmRfZXZlbnQgP3N0ZXA6Tm9uZSBjO1xuICAgICAgICAgICAgICAgICAgUmVhY3QuRS5zdG9wIGV2ZW50XG4gICAgICAgICAgICApIChMaXN0LnJldiBsKVxuXG4gIGVuZFxuXG4gIG1vZHVsZSBJbWFnZURhdGEgPSBzdHJ1Y3RcblxuICAgIHR5cGUgdCA9IGltYWdlX2RhdGFcblxuICAgIGxldCBjcmVhdGUgKHdpZHRoLCBoZWlnaHQpID1cbiAgICAgIGlmIG5vdCAodmFsaWRfY2FudmFzX3NpemUgKHdpZHRoLCBoZWlnaHQpKSB0aGVuXG4gICAgICAgIGludmFsaWRfYXJnIFwiSW1hZ2VEYXRhLmNyZWF0ZTogaW52YWxpZCBpbWFnZSBkaW1lbnNpb25zXCI7XG4gICAgICBsZXQgYSA9IEJpZ2FycmF5LkFycmF5My5jcmVhdGUgQmlnYXJyYXkuaW50OF91bnNpZ25lZFxuICAgICAgICAgICAgICAgIEJpZ2FycmF5LmNfbGF5b3V0IGhlaWdodCB3aWR0aCA0IGluXG4gICAgICBCaWdhcnJheS5BcnJheTMuZmlsbCBhIDA7XG4gICAgICBhXG5cbiAgICBleHRlcm5hbCBjcmVhdGVGcm9tUE5HX2ludGVybmFsIDogc3RyaW5nIC0+ICh0IC0+IHVuaXQpIC0+IHVuaXRcbiAgICAgID0gXCJtbF9jYW52YXNfaW1hZ2VfZGF0YV9jcmVhdGVfZnJvbV9wbmdcIlxuXG4gICAgbGV0IGNyZWF0ZUZyb21QTkcgZmlsZW5hbWUgOiB0IFJlYWN0LmV2ZW50ID1cbiAgICAgIGxldCBldmVudCwgc2VuZF9ldmVudCA9IFJlYWN0LkUuY3JlYXRlICgpIGluXG4gICAgICBjcmVhdGVGcm9tUE5HX2ludGVybmFsIGZpbGVuYW1lXG4gICAgICAgIChmdW4gaWQgLT4gUGVuZGluZy5hZGRfaW1hZ2VfZGF0YSBldmVudCBzZW5kX2V2ZW50IGlkKTtcbiAgICAgIGV2ZW50XG5cbiAgICBleHRlcm5hbCBnZXRTaXplIDogdCAtPiAoaW50ICogaW50KVxuICAgICAgPSBcIm1sX2NhbnZhc19pbWFnZV9kYXRhX2dldF9zaXplXCJcblxuICAgIGV4dGVybmFsIGZpbGwgOiB0IC0+IENvbG9yLnQgLT4gdW5pdFxuICAgICAgPSBcIm1sX2NhbnZhc19pbWFnZV9kYXRhX2ZpbGxcIlxuXG4gICAgZXh0ZXJuYWwgc3ViIDogdCAtPiBwb3M6KGludCAqIGludCkgLT4gc2l6ZTooaW50ICogaW50KSAtPiB0XG4gICAgICA9IFwibWxfY2FudmFzX2ltYWdlX2RhdGFfc3ViXCJcblxuICAgIGV4dGVybmFsIGJsaXQgOlxuICAgICAgZHN0OnQgLT4gZHBvczooaW50ICogaW50KSAtPlxuICAgICAgc3JjOnQgLT4gc3BvczooaW50ICogaW50KSAtPiBzaXplOihpbnQgKiBpbnQpIC0+IHVuaXRcbiAgICAgID0gXCJtbF9jYW52YXNfaW1hZ2VfZGF0YV9ibGl0XCJcblxuICAgIGV4dGVybmFsIGdldFBpeGVsIDogdCAtPiAoaW50ICogaW50KSAtPiBDb2xvci50XG4gICAgICA9IFwibWxfY2FudmFzX2ltYWdlX2RhdGFfZ2V0X3BpeGVsXCJcblxuICAgIGV4dGVybmFsIHB1dFBpeGVsIDogdCAtPiAoaW50ICogaW50KSAtPiBDb2xvci50IC0+IHVuaXRcbiAgICAgID0gXCJtbF9jYW52YXNfaW1hZ2VfZGF0YV9wdXRfcGl4ZWxcIlxuXG4gICAgZXh0ZXJuYWwgaW1wb3J0UE5HX2ludGVybmFsIDpcbiAgICAgIHQgLT4gcG9zOihpbnQgKiBpbnQpIC0+IHN0cmluZyAtPiAodCAtPiB1bml0KSAtPiB1bml0XG4gICAgICA9IFwibWxfY2FudmFzX2ltYWdlX2RhdGFfaW1wb3J0X3BuZ1wiXG5cbiAgICBsZXQgaW1wb3J0UE5HIGlkIH5wb3MgZmlsZW5hbWUgOiB0IFJlYWN0LmV2ZW50ID1cbiAgICAgIGxldCBldmVudCwgc2VuZF9ldmVudCA9IFJlYWN0LkUuY3JlYXRlICgpIGluXG4gICAgICBpbXBvcnRQTkdfaW50ZXJuYWwgaWQgfnBvcyBmaWxlbmFtZVxuICAgICAgICAoZnVuIGlkIC0+IFBlbmRpbmcuYWRkX2ltYWdlX2RhdGEgZXZlbnQgc2VuZF9ldmVudCBpZCk7XG4gICAgICBldmVudFxuXG4gICAgZXh0ZXJuYWwgZXhwb3J0UE5HIDogdCAtPiBzdHJpbmcgLT4gdW5pdFxuICAgICAgPSBcIm1sX2NhbnZhc19pbWFnZV9kYXRhX2V4cG9ydF9wbmdcIlxuXG4gICAgdHlwZSB0X3JlcHIgPSBpbWFnZV9kYXRhXG5cbiAgICBsZXQgb2ZfYmlnYXJyYXkgKGJhIDogdF9yZXByKSA9XG4gICAgICBpZiBub3QgKHZhbGlkX2NhbnZhc19zaXplIChCaWdhcnJheS5BcnJheTMuZGltMiBiYSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEJpZ2FycmF5LkFycmF5My5kaW0xIGJhKSkgdGhlblxuICAgICAgICBpbnZhbGlkX2FyZyBcIkltYWdlRGF0YS5vZl9iaWdhcnJheTogaW52YWxpZCBpbWFnZSBkaW1lbnNpb25zXCI7XG5cbiAgICAgIGlmIEJpZ2FycmF5LkFycmF5My5kaW0zIGJhIDw+IDQgdGhlblxuICAgICAgICBpbnZhbGlkX2FyZyBcIkltYWdlRGF0YS5vZl9iaWdhcnJheTogdGhpcmQgZGltZW5zaW9uIG11c3QgYmUgNFwiO1xuICAgICAgYmFcblxuICAgIGV4dGVybmFsIHRvX2JpZ2FycmF5IDogdCAtPiB0X3JlcHIgPSBcIiVpZGVudGl0eVwiXG5cbiAgZW5kXG5cbiAgbW9kdWxlIEdyYWRpZW50ID0gc3RydWN0XG5cbiAgICB0eXBlIHRcblxuICAgIGV4dGVybmFsIGNyZWF0ZUxpbmVhciA6IHBvczE6UG9pbnQudCAtPiBwb3MyOlBvaW50LnQgLT4gdFxuICAgICAgPSBcIm1sX2NhbnZhc19ncmFkaWVudF9jcmVhdGVfbGluZWFyXCJcblxuICAgIGV4dGVybmFsIGNyZWF0ZVJhZGlhbCA6XG4gICAgICBjZW50ZXIxOlBvaW50LnQgLT4gcmFkMTpmbG9hdCAtPiBjZW50ZXIyOlBvaW50LnQgLT4gcmFkMjpmbG9hdCAtPiB0XG4gICAgICA9IFwibWxfY2FudmFzX2dyYWRpZW50X2NyZWF0ZV9yYWRpYWxcIlxuXG4gICAgZXh0ZXJuYWwgY3JlYXRlQ29uaWMgOiBjZW50ZXI6UG9pbnQudCAtPiBhbmdsZTpmbG9hdCAtPiB0XG4gICAgICA9IFwibWxfY2FudmFzX2dyYWRpZW50X2NyZWF0ZV9jb25pY1wiXG5cbiAgICBleHRlcm5hbCBhZGRDb2xvclN0b3AgOiB0IC0+IENvbG9yLnQgLT4gZmxvYXQgLT4gdW5pdFxuICAgICAgPSBcIm1sX2NhbnZhc19ncmFkaWVudF9hZGRfY29sb3Jfc3RvcFwiXG5cbiAgZW5kXG5cbiAgbW9kdWxlIFBhdHRlcm4gPSBzdHJ1Y3RcblxuICAgIHR5cGUgdFxuXG4gICAgdHlwZSByZXBlYXQgPVxuICAgICAgfCBOb1JlcGVhdFxuICAgICAgfCBSZXBlYXRYXG4gICAgICB8IFJlcGVhdFlcbiAgICAgIHwgUmVwZWF0WFlcblxuICAgIGV4dGVybmFsIGNyZWF0ZSA6IEltYWdlRGF0YS50IC0+IHJlcGVhdCAtPiB0XG4gICAgICA9IFwibWxfY2FudmFzX3BhdHRlcm5fY3JlYXRlXCJcblxuICBlbmRcblxuICBtb2R1bGUgUGF0aCA9IHN0cnVjdFxuXG4gICAgdHlwZSB0XG5cbiAgICBleHRlcm5hbCBjcmVhdGUgOiB1bml0IC0+IHRcbiAgICAgID0gXCJtbF9jYW52YXNfcGF0aF9jcmVhdGVcIlxuXG4gICAgZXh0ZXJuYWwgY2xvc2UgOiB0IC0+IHVuaXRcbiAgICAgID0gXCJtbF9jYW52YXNfcGF0aF9jbG9zZVwiXG5cbiAgICBleHRlcm5hbCBtb3ZlVG8gOiB0IC0+IFBvaW50LnQgLT4gdW5pdFxuICAgICAgPSBcIm1sX2NhbnZhc19wYXRoX21vdmVfdG9cIlxuXG4gICAgZXh0ZXJuYWwgbGluZVRvIDogdCAtPiBQb2ludC50IC0+IHVuaXRcbiAgICAgID0gXCJtbF9jYW52YXNfcGF0aF9saW5lX3RvXCJcblxuICAgIGV4dGVybmFsIGFyYyA6XG4gICAgICB0IC0+IGNlbnRlcjpQb2ludC50IC0+IHJhZGl1czpmbG9hdCAtPlxuICAgICAgdGhldGExOmZsb2F0IC0+IHRoZXRhMjpmbG9hdCAtPiBjY3c6Ym9vbCAtPiB1bml0XG4gICAgICA9IFwibWxfY2FudmFzX3BhdGhfYXJjXCIgXCJtbF9jYW52YXNfcGF0aF9hcmNfblwiXG5cbiAgICBleHRlcm5hbCBhcmNUbyA6IHQgLT4gcDE6UG9pbnQudCAtPiBwMjpQb2ludC50IC0+IHJhZGl1czpmbG9hdCAtPiB1bml0XG4gICAgICA9IFwibWxfY2FudmFzX3BhdGhfYXJjX3RvXCJcblxuICAgIGV4dGVybmFsIHF1YWRyYXRpY0N1cnZlVG8gOiB0IC0+IGNwOlBvaW50LnQgLT4gcDpQb2ludC50IC0+IHVuaXRcbiAgICAgID0gXCJtbF9jYW52YXNfcGF0aF9xdWFkcmF0aWNfY3VydmVfdG9cIlxuXG4gICAgZXh0ZXJuYWwgYmV6aWVyQ3VydmVUbyA6XG4gICAgICB0IC0+IGNwMTpQb2ludC50IC0+IGNwMjpQb2ludC50IC0+IHA6UG9pbnQudCAtPiB1bml0XG4gICAgICA9IFwibWxfY2FudmFzX3BhdGhfYmV6aWVyX2N1cnZlX3RvXCJcblxuICAgIGV4dGVybmFsIHJlY3QgOiB0IC0+IHBvczpQb2ludC50IC0+IHNpemU6VmVjdG9yLnQgLT4gdW5pdFxuICAgICAgPSBcIm1sX2NhbnZhc19wYXRoX3JlY3RcIlxuXG4gICAgZXh0ZXJuYWwgZWxsaXBzZSA6XG4gICAgICB0IC0+IGNlbnRlcjpQb2ludC50IC0+IHJhZGl1czpWZWN0b3IudCAtPlxuICAgICAgcm90YXRpb246ZmxvYXQgLT4gdGhldGExOmZsb2F0IC0+IHRoZXRhMjpmbG9hdCAtPiBjY3c6Ym9vbCAtPiB1bml0XG4gICAgICA9IFwibWxfY2FudmFzX3BhdGhfZWxsaXBzZVwiIFwibWxfY2FudmFzX3BhdGhfZWxsaXBzZV9uXCJcblxuICAgIGV4dGVybmFsIGFkZCA6IHQgLT4gdCAtPiB1bml0XG4gICAgICA9IFwibWxfY2FudmFzX3BhdGhfYWRkXCJcblxuICAgIGV4dGVybmFsIGFkZFRyYW5zZm9ybWVkIDogdCAtPiB0IC0+IFRyYW5zZm9ybS50IC0+IHVuaXRcbiAgICAgID0gXCJtbF9jYW52YXNfcGF0aF9hZGRfdHJhbnNmb3JtZWRcIlxuXG4gIGVuZFxuXG4gIG1vZHVsZSBKb2luID0gc3RydWN0XG5cbiAgICB0eXBlIHQgPVxuICAgICAgfCBSb3VuZFxuICAgICAgfCBNaXRlclxuICAgICAgfCBCZXZlbFxuXG4gIGVuZFxuXG4gIG1vZHVsZSBDYXAgPSBzdHJ1Y3RcblxuICAgIHR5cGUgdCA9XG4gICAgICB8IEJ1dHRcbiAgICAgIHwgU3F1YXJlXG4gICAgICB8IFJvdW5kXG5cbiAgZW5kXG5cbiAgbW9kdWxlIFN0eWxlID0gc3RydWN0XG5cbiAgICB0eXBlIHQgPVxuICAgICAgfCBDb2xvciBvZiBDb2xvci50XG4gICAgICB8IEdyYWRpZW50IG9mIEdyYWRpZW50LnRcbiAgICAgIHwgUGF0dGVybiBvZiBQYXR0ZXJuLnRcblxuICBlbmRcblxuICBtb2R1bGUgQ29tcG9zaXRlT3AgPSBzdHJ1Y3RcblxuICAgIHR5cGUgdCA9XG4gICAgICB8IFNvdXJjZU92ZXJcbiAgICAgIHwgU291cmNlSW5cbiAgICAgIHwgU291cmNlT3V0XG4gICAgICB8IFNvdXJjZUF0b3BcbiAgICAgIHwgRGVzdGluYXRpb25PdmVyXG4gICAgICB8IERlc3RpbmF0aW9uSW5cbiAgICAgIHwgRGVzdGluYXRpb25PdXRcbiAgICAgIHwgRGVzdGluYXRpb25BdG9wXG4gICAgICB8IExpZ2h0ZXJcbiAgICAgIHwgQ29weVxuICAgICAgfCBYT1JcbiAgICAgIHwgTXVsdGlwbHlcbiAgICAgIHwgU2NyZWVuXG4gICAgICB8IE92ZXJsYXlcbiAgICAgIHwgRGFya2VuXG4gICAgICB8IExpZ2h0ZW5cbiAgICAgIHwgQ29sb3JEb2RnZVxuICAgICAgfCBDb2xvckJ1cm5cbiAgICAgIHwgSGFyZExpZ2h0XG4gICAgICB8IFNvZnRMaWdodFxuICAgICAgfCBEaWZmZXJlbmNlXG4gICAgICB8IEV4Y2x1c2lvblxuICAgICAgfCBIdWVcbiAgICAgIHwgU2F0dXJhdGlvblxuICAgICAgfCBDb2xvclxuICAgICAgfCBMdW1pbm9zaXR5XG5cbiAgZW5kXG5cbiAgbW9kdWxlIENhbnZhcyA9IHN0cnVjdFxuXG4gICAgdHlwZSB0ID0gY2FudmFzXG5cbiAgICAoKiBDb21wYXJpc29uIGFuZCBoYXNoIGZ1bmN0aW9ucyAqKVxuXG4gICAgbGV0ICgpID1cbiAgICAgIENhbGxiYWNrLnJlZ2lzdGVyIFwiSGFzaHRibC5oYXNoXCIgSGFzaHRibC5oYXNoXG5cbiAgICBleHRlcm5hbCBjb21wYXJlIDogdCAtPiB0IC0+IGludFxuICAgICAgPSBcIm1sX2NhbnZhc19jb21wYXJlXCJcblxuICAgIGV4dGVybmFsIGhhc2ggOiB0IC0+IGludFxuICAgICAgPSBcIm1sX2NhbnZhc19oYXNoXCJcblxuXG4gICAgKCogQ3JlYXRpb24gKilcblxuICAgIGV4dGVybmFsIGNyZWF0ZU9uc2NyZWVuIDpcbiAgICAgID9hdXRvY29tbWl0OmJvb2wgLT4gP2RlY29yYXRlZDpib29sIC0+ID9yZXNpemVhYmxlOmJvb2wgLT5cbiAgICAgID9taW5pbWl6ZTpib29sIC0+ID9tYXhpbWl6ZTpib29sIC0+ID9jbG9zZTpib29sIC0+ID90aXRsZTpzdHJpbmcgLT5cbiAgICAgID90YXJnZXQ6c3RyaW5nIC0+ID9wb3M6KGludCAqIGludCkgLT4gc2l6ZTooaW50ICogaW50KSAtPiB1bml0IC0+IHRcbiAgICAgID0gXCJtbF9jYW52YXNfY3JlYXRlX29uc2NyZWVuXCIgXCJtbF9jYW52YXNfY3JlYXRlX29uc2NyZWVuX25cIlxuXG4gICAgZXh0ZXJuYWwgY3JlYXRlT2Zmc2NyZWVuIDogc2l6ZTooaW50ICogaW50KSAtPiB1bml0IC0+IHRcbiAgICAgID0gXCJtbF9jYW52YXNfY3JlYXRlX29mZnNjcmVlblwiXG5cbiAgICBleHRlcm5hbCBjcmVhdGVPZmZzY3JlZW5Gcm9tSW1hZ2VEYXRhIDogSW1hZ2VEYXRhLnQgLT4gdFxuICAgICAgPSBcIm1sX2NhbnZhc19jcmVhdGVfb2Zmc2NyZWVuX2Zyb21faW1hZ2VfZGF0YVwiXG5cbiAgICBleHRlcm5hbCBjcmVhdGVPZmZzY3JlZW5Gcm9tUE5HX2ludGVybmFsIDogc3RyaW5nIC0+ICh0IC0+IHVuaXQpIC0+IHVuaXRcbiAgICAgID0gXCJtbF9jYW52YXNfY3JlYXRlX29mZnNjcmVlbl9mcm9tX3BuZ1wiXG5cbiAgICBsZXQgY3JlYXRlT2Zmc2NyZWVuRnJvbVBORyBmaWxlbmFtZSA6IHQgUmVhY3QuZXZlbnQgPVxuICAgICAgbGV0IGV2ZW50LCBzZW5kX2V2ZW50ID0gUmVhY3QuRS5jcmVhdGUgKCkgaW5cbiAgICAgIGNyZWF0ZU9mZnNjcmVlbkZyb21QTkdfaW50ZXJuYWwgZmlsZW5hbWVcbiAgICAgICAgKGZ1biBjIC0+IFBlbmRpbmcuYWRkX2NhbnZhcyBldmVudCBzZW5kX2V2ZW50IGMpO1xuICAgICAgZXZlbnRcblxuICAgICgqIFZpc2liaWxpdHkgKilcblxuICAgIGV4dGVybmFsIHNob3cgOiB0IC0+IHVuaXRcbiAgICAgID0gXCJtbF9jYW52YXNfc2hvd1wiXG5cbiAgICBleHRlcm5hbCBoaWRlIDogdCAtPiB1bml0XG4gICAgICA9IFwibWxfY2FudmFzX2hpZGVcIlxuXG4gICAgZXh0ZXJuYWwgY2xvc2UgOiB0IC0+IHVuaXRcbiAgICAgID0gXCJtbF9jYW52YXNfY2xvc2VcIlxuXG4gICAgKCogUmVuZGVyaW5nICopXG5cbiAgICBleHRlcm5hbCBjb21taXQgOiB0IC0+IHVuaXRcbiAgICAgID0gXCJtbF9jYW52YXNfY29tbWl0XCJcblxuICAgICgqIENvbmZpZ3VyYXRpb24gKilcblxuICAgIGV4dGVybmFsIGdldElkIDogdCAtPiBpbnRcbiAgICAgID0gXCJtbF9jYW52YXNfZ2V0X2lkXCJcblxuICAgIGV4dGVybmFsIGdldFNpemUgOiB0IC0+IChpbnQgKiBpbnQpXG4gICAgICA9IFwibWxfY2FudmFzX2dldF9zaXplXCJcblxuICAgIGV4dGVybmFsIHNldFNpemUgOiB0IC0+IChpbnQgKiBpbnQpIC0+IHVuaXRcbiAgICAgID0gXCJtbF9jYW52YXNfc2V0X3NpemVcIlxuXG4gICAgZXh0ZXJuYWwgZ2V0UG9zaXRpb24gOiB0IC0+IChpbnQgKiBpbnQpXG4gICAgICA9IFwibWxfY2FudmFzX2dldF9wb3NpdGlvblwiXG5cbiAgICBleHRlcm5hbCBzZXRQb3NpdGlvbiA6IHQgLT4gKGludCAqIGludCkgLT4gdW5pdFxuICAgICAgPSBcIm1sX2NhbnZhc19zZXRfcG9zaXRpb25cIlxuXG4gICAgKCogU3RhdGUgKilcblxuICAgIGV4dGVybmFsIHNhdmUgOiB0IC0+IHVuaXRcbiAgICAgID0gXCJtbF9jYW52YXNfc2F2ZVwiXG5cbiAgICBleHRlcm5hbCByZXN0b3JlIDogdCAtPiB1bml0XG4gICAgICA9IFwibWxfY2FudmFzX3Jlc3RvcmVcIlxuXG4gICAgKCogVHJhbnNmb3JtYXRpb25zICopXG4gICAgZXh0ZXJuYWwgc2V0VHJhbnNmb3JtIDogdCAtPiBUcmFuc2Zvcm0udCAtPiB1bml0XG4gICAgICA9IFwibWxfY2FudmFzX3NldF90cmFuc2Zvcm1cIlxuXG4gICAgZXh0ZXJuYWwgdHJhbnNmb3JtIDogdCAtPiBUcmFuc2Zvcm0udCAtPiB1bml0XG4gICAgICA9IFwibWxfY2FudmFzX3RyYW5zZm9ybVwiXG5cbiAgICBleHRlcm5hbCB0cmFuc2xhdGUgOiB0IC0+IFZlY3Rvci50IC0+IHVuaXRcbiAgICAgID0gXCJtbF9jYW52YXNfdHJhbnNsYXRlXCJcblxuICAgIGV4dGVybmFsIHNjYWxlIDogdCAtPiBWZWN0b3IudCAtPiB1bml0XG4gICAgICA9IFwibWxfY2FudmFzX3NjYWxlXCJcblxuICAgIGV4dGVybmFsIHNoZWFyIDogdCAtPiBWZWN0b3IudCAtPiB1bml0XG4gICAgICA9IFwibWxfY2FudmFzX3NoZWFyXCJcblxuICAgIGV4dGVybmFsIHJvdGF0ZSA6IHQgLT4gZmxvYXQgLT4gdW5pdFxuICAgICAgPSBcIm1sX2NhbnZhc19yb3RhdGVcIlxuXG4gICAgKCogU3R5bGUgLyBjb25maWcgKilcblxuICAgIGV4dGVybmFsIGdldExpbmVXaWR0aCA6IHQgLT4gZmxvYXRcbiAgICAgID0gXCJtbF9jYW52YXNfZ2V0X2xpbmVfd2lkdGhcIlxuXG4gICAgZXh0ZXJuYWwgc2V0TGluZVdpZHRoIDogdCAtPiBmbG9hdCAtPiB1bml0XG4gICAgICA9IFwibWxfY2FudmFzX3NldF9saW5lX3dpZHRoXCJcblxuICAgIGV4dGVybmFsIGdldExpbmVKb2luIDogdCAtPiBKb2luLnRcbiAgICAgID0gXCJtbF9jYW52YXNfZ2V0X2xpbmVfam9pblwiXG5cbiAgICBleHRlcm5hbCBzZXRMaW5lSm9pbiA6IHQgLT4gSm9pbi50IC0+IHVuaXRcbiAgICAgID0gXCJtbF9jYW52YXNfc2V0X2xpbmVfam9pblwiXG5cbiAgICBleHRlcm5hbCBnZXRMaW5lQ2FwIDogdCAtPiBDYXAudFxuICAgICAgPSBcIm1sX2NhbnZhc19nZXRfbGluZV9jYXBcIlxuXG4gICAgZXh0ZXJuYWwgc2V0TGluZUNhcCA6IHQgLT4gQ2FwLnQgLT4gdW5pdFxuICAgICAgPSBcIm1sX2NhbnZhc19zZXRfbGluZV9jYXBcIlxuXG4gICAgZXh0ZXJuYWwgZ2V0TWl0ZXJMaW1pdCA6IHQgLT4gZmxvYXRcbiAgICAgID0gXCJtbF9jYW52YXNfZ2V0X21pdGVyX2xpbWl0XCJcblxuICAgIGV4dGVybmFsIHNldE1pdGVyTGltaXQgOiB0IC0+IGZsb2F0IC0+IHVuaXRcbiAgICAgID0gXCJtbF9jYW52YXNfc2V0X21pdGVyX2xpbWl0XCJcblxuICAgIGV4dGVybmFsIGdldExpbmVEYXNoT2Zmc2V0IDogdCAtPiBmbG9hdFxuICAgICAgPSBcIm1sX2NhbnZhc19nZXRfbGluZV9kYXNoX29mZnNldFwiXG5cbiAgICBleHRlcm5hbCBzZXRMaW5lRGFzaE9mZnNldCA6IHQgLT4gZmxvYXQgLT4gdW5pdFxuICAgICAgPSBcIm1sX2NhbnZhc19zZXRfbGluZV9kYXNoX29mZnNldFwiXG5cbiAgICBleHRlcm5hbCBnZXRMaW5lRGFzaCA6IHQgLT4gZmxvYXQgYXJyYXlcbiAgICAgID0gXCJtbF9jYW52YXNfZ2V0X2xpbmVfZGFzaFwiXG5cbiAgICBleHRlcm5hbCBzZXRMaW5lRGFzaCA6IHQgLT4gZmxvYXQgYXJyYXkgLT4gdW5pdFxuICAgICAgPSBcIm1sX2NhbnZhc19zZXRfbGluZV9kYXNoXCJcblxuICAgIGV4dGVybmFsIGdldFN0cm9rZUNvbG9yIDogdCAtPiBDb2xvci50XG4gICAgICA9IFwibWxfY2FudmFzX2dldF9zdHJva2VfY29sb3JcIlxuXG4gICAgZXh0ZXJuYWwgc2V0U3Ryb2tlQ29sb3IgOiB0IC0+IENvbG9yLnQgLT4gdW5pdFxuICAgICAgPSBcIm1sX2NhbnZhc19zZXRfc3Ryb2tlX2NvbG9yXCJcblxuICAgIGV4dGVybmFsIHNldFN0cm9rZUdyYWRpZW50IDogdCAtPiBHcmFkaWVudC50IC0+IHVuaXRcbiAgICAgID0gXCJtbF9jYW52YXNfc2V0X3N0cm9rZV9ncmFkaWVudFwiXG5cbiAgICBleHRlcm5hbCBzZXRTdHJva2VQYXR0ZXJuIDogdCAtPiBQYXR0ZXJuLnQgLT4gdW5pdFxuICAgICAgPSBcIm1sX2NhbnZhc19zZXRfc3Ryb2tlX3BhdHRlcm5cIlxuXG4gICAgZXh0ZXJuYWwgZ2V0U3Ryb2tlU3R5bGUgOiB0IC0+IFN0eWxlLnRcbiAgICAgID0gXCJtbF9jYW52YXNfZ2V0X3N0cm9rZV9zdHlsZVwiXG5cbiAgICBleHRlcm5hbCBzZXRTdHJva2VTdHlsZSA6IHQgLT4gU3R5bGUudCAtPiB1bml0XG4gICAgICA9IFwibWxfY2FudmFzX3NldF9zdHJva2Vfc3R5bGVcIlxuXG4gICAgZXh0ZXJuYWwgZ2V0RmlsbENvbG9yIDogdCAtPiBDb2xvci50XG4gICAgICA9IFwibWxfY2FudmFzX2dldF9maWxsX2NvbG9yXCJcblxuICAgIGV4dGVybmFsIHNldEZpbGxDb2xvciA6IHQgLT4gQ29sb3IudCAtPiB1bml0XG4gICAgICA9IFwibWxfY2FudmFzX3NldF9maWxsX2NvbG9yXCJcblxuICAgIGV4dGVybmFsIHNldEZpbGxHcmFkaWVudCA6IHQgLT4gR3JhZGllbnQudCAtPiB1bml0XG4gICAgICA9IFwibWxfY2FudmFzX3NldF9maWxsX2dyYWRpZW50XCJcblxuICAgIGV4dGVybmFsIHNldEZpbGxQYXR0ZXJuIDogdCAtPiBQYXR0ZXJuLnQgLT4gdW5pdFxuICAgICAgPSBcIm1sX2NhbnZhc19zZXRfZmlsbF9wYXR0ZXJuXCJcblxuICAgIGV4dGVybmFsIGdldEZpbGxTdHlsZSA6IHQgLT4gU3R5bGUudFxuICAgICAgPSBcIm1sX2NhbnZhc19nZXRfZmlsbF9zdHlsZVwiXG5cbiAgICBleHRlcm5hbCBzZXRGaWxsU3R5bGUgOiB0IC0+IFN0eWxlLnQgLT4gdW5pdFxuICAgICAgPSBcIm1sX2NhbnZhc19zZXRfZmlsbF9zdHlsZVwiXG5cbiAgICBleHRlcm5hbCBnZXRHbG9iYWxBbHBoYSA6IHQgLT4gZmxvYXRcbiAgICAgID0gXCJtbF9jYW52YXNfZ2V0X2dsb2JhbF9hbHBoYVwiXG5cbiAgICBleHRlcm5hbCBzZXRHbG9iYWxBbHBoYSA6IHQgLT4gZmxvYXQgLT4gdW5pdFxuICAgICAgPSBcIm1sX2NhbnZhc19zZXRfZ2xvYmFsX2FscGhhXCJcblxuICAgIGV4dGVybmFsIGdldEdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA6IHQgLT4gQ29tcG9zaXRlT3AudFxuICAgICAgPSBcIm1sX2NhbnZhc19nZXRfZ2xvYmFsX2NvbXBvc2l0ZV9vcGVyYXRpb25cIlxuXG4gICAgZXh0ZXJuYWwgc2V0R2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uIDogdCAtPiBDb21wb3NpdGVPcC50IC0+IHVuaXRcbiAgICAgID0gXCJtbF9jYW52YXNfc2V0X2dsb2JhbF9jb21wb3NpdGVfb3BlcmF0aW9uXCJcblxuICAgIGV4dGVybmFsIGdldFNoYWRvd0NvbG9yIDogdCAtPiBDb2xvci50XG4gICAgICA9IFwibWxfY2FudmFzX2dldF9zaGFkb3dfY29sb3JcIlxuXG4gICAgZXh0ZXJuYWwgc2V0U2hhZG93Q29sb3IgOiB0IC0+IENvbG9yLnQgLT4gdW5pdFxuICAgICAgPSBcIm1sX2NhbnZhc19zZXRfc2hhZG93X2NvbG9yXCJcblxuICAgIGV4dGVybmFsIGdldFNoYWRvd0JsdXIgOiB0IC0+IGZsb2F0XG4gICAgICA9IFwibWxfY2FudmFzX2dldF9zaGFkb3dfYmx1clwiXG5cbiAgICBleHRlcm5hbCBzZXRTaGFkb3dCbHVyIDogdCAtPiBmbG9hdCAtPiB1bml0XG4gICAgICA9IFwibWxfY2FudmFzX3NldF9zaGFkb3dfYmx1clwiXG5cbiAgICBleHRlcm5hbCBnZXRTaGFkb3dPZmZzZXQgOiB0IC0+IFZlY3Rvci50XG4gICAgICA9IFwibWxfY2FudmFzX2dldF9zaGFkb3dfb2Zmc2V0XCJcblxuICAgIGV4dGVybmFsIHNldFNoYWRvd09mZnNldCA6IHQgLT4gVmVjdG9yLnQgLT4gdW5pdFxuICAgICAgPSBcIm1sX2NhbnZhc19zZXRfc2hhZG93X29mZnNldFwiXG5cbiAgICBleHRlcm5hbCBzZXRGb250IDpcbiAgICAgIHQgLT4gc3RyaW5nIC0+IHNpemU6Rm9udC5zaXplIC0+IHNsYW50OkZvbnQuc2xhbnQgLT5cbiAgICAgIHdlaWdodDpGb250LndlaWdodCAtPiB1bml0XG4gICAgICA9IFwibWxfY2FudmFzX3NldF9mb250XCJcblxuICAgICgqIFBhdGhzICopXG5cbiAgICBleHRlcm5hbCBjbGVhclBhdGggOiB0IC0+IHVuaXRcbiAgICAgID0gXCJtbF9jYW52YXNfY2xlYXJfcGF0aFwiXG5cbiAgICBleHRlcm5hbCBjbG9zZVBhdGggOiB0IC0+IHVuaXRcbiAgICAgID0gXCJtbF9jYW52YXNfY2xvc2VfcGF0aFwiXG5cbiAgICBleHRlcm5hbCBtb3ZlVG8gOiB0IC0+IFBvaW50LnQgLT4gdW5pdFxuICAgICAgPSBcIm1sX2NhbnZhc19tb3ZlX3RvXCJcblxuICAgIGV4dGVybmFsIGxpbmVUbyA6IHQgLT4gUG9pbnQudCAtPiB1bml0XG4gICAgICA9IFwibWxfY2FudmFzX2xpbmVfdG9cIlxuXG4gICAgZXh0ZXJuYWwgYXJjIDpcbiAgICAgIHQgLT4gY2VudGVyOlBvaW50LnQgLT4gcmFkaXVzOmZsb2F0IC0+XG4gICAgICB0aGV0YTE6ZmxvYXQgLT4gdGhldGEyOmZsb2F0IC0+IGNjdzpib29sIC0+IHVuaXRcbiAgICAgID0gXCJtbF9jYW52YXNfYXJjXCIgXCJtbF9jYW52YXNfYXJjX25cIlxuXG4gICAgZXh0ZXJuYWwgYXJjVG8gOiB0IC0+IHAxOlBvaW50LnQgLT4gcDI6UG9pbnQudCAtPiByYWRpdXM6ZmxvYXQgLT4gdW5pdFxuICAgICAgPSBcIm1sX2NhbnZhc19hcmNfdG9cIlxuXG4gICAgZXh0ZXJuYWwgcXVhZHJhdGljQ3VydmVUbyA6IHQgLT4gY3A6UG9pbnQudCAtPiBwOlBvaW50LnQgLT4gdW5pdFxuICAgICAgPSBcIm1sX2NhbnZhc19xdWFkcmF0aWNfY3VydmVfdG9cIlxuXG4gICAgZXh0ZXJuYWwgYmV6aWVyQ3VydmVUbyA6XG4gICAgICB0IC0+IGNwMTpQb2ludC50IC0+IGNwMjpQb2ludC50IC0+IHA6UG9pbnQudCAtPiB1bml0XG4gICAgICA9IFwibWxfY2FudmFzX2Jlemllcl9jdXJ2ZV90b1wiXG5cbiAgICBleHRlcm5hbCByZWN0IDogdCAtPiBwb3M6UG9pbnQudCAtPiBzaXplOlZlY3Rvci50IC0+IHVuaXRcbiAgICAgID0gXCJtbF9jYW52YXNfcmVjdFwiXG5cbiAgICBleHRlcm5hbCBlbGxpcHNlIDpcbiAgICAgIHQgLT4gY2VudGVyOlBvaW50LnQgLT4gcmFkaXVzOlZlY3Rvci50IC0+XG4gICAgICByb3RhdGlvbjpmbG9hdCAtPiB0aGV0YTE6ZmxvYXQgLT4gdGhldGEyOmZsb2F0IC0+IGNjdzpib29sIC0+IHVuaXRcbiAgICAgID0gXCJtbF9jYW52YXNfZWxsaXBzZVwiIFwibWxfY2FudmFzX2VsbGlwc2VfblwiXG5cbiAgICBleHRlcm5hbCBmaWxsIDogdCAtPiBub256ZXJvOmJvb2wgLT4gdW5pdFxuICAgICAgPSBcIm1sX2NhbnZhc19maWxsXCJcblxuICAgIGV4dGVybmFsIGZpbGxQYXRoIDogdCAtPiBQYXRoLnQgLT4gbm9uemVybzpib29sIC0+IHVuaXRcbiAgICAgID0gXCJtbF9jYW52YXNfZmlsbF9wYXRoXCJcblxuICAgIGV4dGVybmFsIHN0cm9rZSA6IHQgLT4gdW5pdFxuICAgICAgPSBcIm1sX2NhbnZhc19zdHJva2VcIlxuXG4gICAgZXh0ZXJuYWwgc3Ryb2tlUGF0aCA6IHQgLT4gUGF0aC50IC0+IHVuaXRcbiAgICAgID0gXCJtbF9jYW52YXNfc3Ryb2tlX3BhdGhcIlxuXG4gICAgZXh0ZXJuYWwgY2xpcCA6IHQgLT4gbm9uemVybzpib29sIC0+IHVuaXRcbiAgICAgID0gXCJtbF9jYW52YXNfY2xpcFwiXG5cbiAgICBleHRlcm5hbCBjbGlwUGF0aCA6IHQgLT4gUGF0aC50IC0+IG5vbnplcm86Ym9vbCAtPiB1bml0XG4gICAgICA9IFwibWxfY2FudmFzX2NsaXBfcGF0aFwiXG5cbiAgICAoKiBJbW1lZGlhdGUgZHJhd2luZyAqKVxuXG4gICAgZXh0ZXJuYWwgZmlsbFJlY3QgOiB0IC0+IHBvczpQb2ludC50IC0+IHNpemU6VmVjdG9yLnQgLT4gdW5pdFxuICAgICAgPSBcIm1sX2NhbnZhc19maWxsX3JlY3RcIlxuXG4gICAgZXh0ZXJuYWwgc3Ryb2tlUmVjdCA6IHQgLT4gcG9zOlBvaW50LnQgLT4gc2l6ZTpWZWN0b3IudCAtPiB1bml0XG4gICAgICA9IFwibWxfY2FudmFzX3N0cm9rZV9yZWN0XCJcblxuICAgIGV4dGVybmFsIGZpbGxUZXh0IDogdCAtPiBzdHJpbmcgLT4gUG9pbnQudCAtPiB1bml0XG4gICAgICA9IFwibWxfY2FudmFzX2ZpbGxfdGV4dFwiXG5cbiAgICBleHRlcm5hbCBzdHJva2VUZXh0IDogdCAtPiBzdHJpbmcgLT4gUG9pbnQudCAtPiB1bml0XG4gICAgICA9IFwibWxfY2FudmFzX3N0cm9rZV90ZXh0XCJcblxuICAgIGV4dGVybmFsIGJsaXQgOlxuICAgICAgZHN0OnQgLT4gZHBvczooaW50ICogaW50KSAtPlxuICAgICAgc3JjOnQgLT4gc3BvczooaW50ICogaW50KSAtPiBzaXplOihpbnQgKiBpbnQpIC0+IHVuaXRcbiAgICAgID0gXCJtbF9jYW52YXNfYmxpdFwiXG5cbiAgICAoKiBEaXJlY3QgcGl4ZWwgYWNjZXNzICopXG5cbiAgICBleHRlcm5hbCBnZXRQaXhlbCA6IHQgLT4gKGludCAqIGludCkgLT4gQ29sb3IudFxuICAgICAgPSBcIm1sX2NhbnZhc19nZXRfcGl4ZWxcIlxuXG4gICAgZXh0ZXJuYWwgcHV0UGl4ZWwgOiB0IC0+IChpbnQgKiBpbnQpIC0+IENvbG9yLnQgLT4gdW5pdFxuICAgICAgPSBcIm1sX2NhbnZhc19wdXRfcGl4ZWxcIlxuXG4gICAgZXh0ZXJuYWwgZ2V0SW1hZ2VEYXRhIDpcbiAgICAgIHQgLT4gcG9zOihpbnQgKiBpbnQpIC0+IHNpemU6KGludCAqIGludCkgLT4gSW1hZ2VEYXRhLnRcbiAgICAgID0gXCJtbF9jYW52YXNfZ2V0X2ltYWdlX2RhdGFcIlxuXG4gICAgZXh0ZXJuYWwgcHV0SW1hZ2VEYXRhIDpcbiAgICAgIHQgLT4gZHBvczooaW50ICogaW50KSAtPiBJbWFnZURhdGEudCAtPlxuICAgICAgc3BvczooaW50ICogaW50KSAtPiBzaXplOihpbnQgKiBpbnQpIC0+IHVuaXRcbiAgICAgID0gXCJtbF9jYW52YXNfcHV0X2ltYWdlX2RhdGFcIlxuXG4gICAgZXh0ZXJuYWwgaW1wb3J0UE5HX2ludGVybmFsIDpcbiAgICAgIHQgLT4gcG9zOihpbnQgKiBpbnQpIC0+IHN0cmluZyAtPiAodCAtPiB1bml0KSAtPiB1bml0XG4gICAgICA9IFwibWxfY2FudmFzX2ltcG9ydF9wbmdcIlxuXG4gICAgbGV0IGltcG9ydFBORyAoYyA6IHQpIH5wb3MgZmlsZW5hbWUgOiB0IFJlYWN0LmV2ZW50ID1cbiAgICAgIGxldCBldmVudCwgc2VuZF9ldmVudCA9IFJlYWN0LkUuY3JlYXRlICgpIGluXG4gICAgICBpbXBvcnRQTkdfaW50ZXJuYWwgYyB+cG9zIGZpbGVuYW1lXG4gICAgICAgIChmdW4gYyAtPiBQZW5kaW5nLmFkZF9jYW52YXMgZXZlbnQgc2VuZF9ldmVudCBjKTtcbiAgICAgIGV2ZW50XG5cbiAgICBleHRlcm5hbCBleHBvcnRQTkcgOiB0IC0+IHN0cmluZyAtPiB1bml0XG4gICAgICA9IFwibWxfY2FudmFzX2V4cG9ydF9wbmdcIlxuXG4gIGVuZFxuXG4gIG1vZHVsZSBFdmVudCA9IHN0cnVjdFxuXG4gICAgdHlwZSB0aW1lc3RhbXAgPSBJbnQ2NC50XG5cbiAgICB0eXBlICdhIGNhbnZhc19ldmVudCA9IHtcbiAgICAgIGNhbnZhczogQ2FudmFzLnQ7XG4gICAgICB0aW1lc3RhbXA6IHRpbWVzdGFtcDtcbiAgICAgIGRhdGE6ICdhO1xuICAgIH1cblxuICAgIHR5cGUgcG9zaXRpb24gPSBpbnQgKiBpbnRcblxuICAgIHR5cGUgc2l6ZSA9IGludCAqIGludFxuXG4gICAgdHlwZSBrZXkgPVxuICAgICAgKCogRnVuY3Rpb24gKilcbiAgICAgIHwgS2V5RXNjYXBlXG4gICAgICB8IEtleUYxXG4gICAgICB8IEtleUYyXG4gICAgICB8IEtleUYzXG4gICAgICB8IEtleUY0XG4gICAgICB8IEtleUY1XG4gICAgICB8IEtleUY2XG4gICAgICB8IEtleUY3XG4gICAgICB8IEtleUY4XG4gICAgICB8IEtleUY5XG4gICAgICB8IEtleUYxMFxuICAgICAgfCBLZXlGMTFcbiAgICAgIHwgS2V5RjEyXG4gICAgICB8IEtleVByaW50U2NyZWVuICgqIGFic2VudCBmcm9tIE1hYyBLZXlib2FyZHMgKilcbiAgICAgIHwgS2V5U2Nyb2xsTG9jayAoKiBhYnNlbnQgZnJvbSBNYWMgS2V5Ym9hcmRzICopXG4gICAgICB8IEtleVBhdXNlICgqIGFic2VudCBmcm9tIE1hYyBLZXlib2FyZHMgKilcblxuICAgICAgKCogQWxwaGFudW1lcmljLCBmaXJzdCByb3cgKilcbiAgICAgIHwgS2V5R3JhdmVUaWxkZVxuICAgICAgfCBLZXkxRXhjbGFtYXRpb25cbiAgICAgIHwgS2V5MkF0XG4gICAgICB8IEtleTNOdW1iZXJcbiAgICAgIHwgS2V5NERvbGxhclxuICAgICAgfCBLZXk1UGVyY2VudFxuICAgICAgfCBLZXk2Q2FyZXRcbiAgICAgIHwgS2V5N0FtcGVyc2FuZFxuICAgICAgfCBLZXk4QXN0ZXJpc2tcbiAgICAgIHwgS2V5OUxQYXJlbnRoZXNpc1xuICAgICAgfCBLZXkwUlBhcmVudGhlc2lzXG4gICAgICB8IEtleU1pbnVzVW5kZXJzY2xyZVxuICAgICAgfCBLZXlFcXVhbFBsdXNcbiAgICAgIHwgS2V5QmFja3NwYWNlXG5cbiAgICAgICgqIEFscGhhbnVtZXJpYywgc2Vjb25kIHJvdyAqKVxuICAgICAgfCBLZXlUYWJcbiAgICAgIHwgS2V5UVxuICAgICAgfCBLZXlXXG4gICAgICB8IEtleUVcbiAgICAgIHwgS2V5UlxuICAgICAgfCBLZXlUXG4gICAgICB8IEtleVlcbiAgICAgIHwgS2V5VVxuICAgICAgfCBLZXlJXG4gICAgICB8IEtleU9cbiAgICAgIHwgS2V5UFxuICAgICAgfCBLZXlMQnJhY2tldEN1cmx5XG4gICAgICB8IEtleVJCcmFja2V0Q3VybHlcbiAgICAgIHwgS2V5QmFja3NsYXNoUGlwZSAoKiByZXBsYWNlZCBieSBLZXlOb25VU051bWJlclRpbGRlIG9uIElTTyBLQiAqKVxuXG4gICAgICAoKiBBbHBoYW51bWVyaWMsIHRoaXJkIHJvdyAqKVxuICAgICAgfCBLZXlDYXBzTG9ja1xuICAgICAgfCBLZXlBXG4gICAgICB8IEtleVNcbiAgICAgIHwgS2V5RFxuICAgICAgfCBLZXlGXG4gICAgICB8IEtleUdcbiAgICAgIHwgS2V5SFxuICAgICAgfCBLZXlKXG4gICAgICB8IEtleUtcbiAgICAgIHwgS2V5TFxuICAgICAgfCBLZXlTZW1pY29sb25Db2xvblxuICAgICAgfCBLZXlRdW90ZURvdWJsZXF1b3RlXG4gICAgICB8IEtleU5vblVTTnVtYmVyVGlsZGUgKCogZXh0cmEga2V5IGxlZnQgb2YgUmV0dXJuIG9uIElTTyBLQiAqKVxuICAgICAgKCogYWx0aG91Z2ggZ2VuZXJhbGx5IG1hcHBlZCB0byBLZXlCYWNrc2xhc2hQaXBlICopXG4gICAgICB8IEtleVJldHVyblxuXG4gICAgICAoKiBBbHBoYW51bWVyaWMsIGZvdXJ0aCByb3cgKilcbiAgICAgIHwgS2V5TFNoaWZ0XG4gICAgICB8IEtleU5vblVTQmFja3NsYXNoUGlwZSAoKiBleHRyYSBrZXkgcmlnaHQgb2YgTFNoaWZ0IG9uIElTTyBLQiAqKVxuICAgICAgfCBLZXlaXG4gICAgICB8IEtleVhcbiAgICAgIHwgS2V5Q1xuICAgICAgfCBLZXlWXG4gICAgICB8IEtleUJcbiAgICAgIHwgS2V5TlxuICAgICAgfCBLZXlNXG4gICAgICB8IEtleUNvbW1hTGVzc1xuICAgICAgfCBLZXlQZXJpb2RHcmVhdGVyXG4gICAgICB8IEtleVNsYXNoUXVlc3Rpb25cbiAgICAgIHwgS2V5UlNoaWZ0XG5cbiAgICAgICgqIEFscGhhbnVtZXJpYywgZmlmdGggcm93ICopXG4gICAgICB8IEtleUxDb250cm9sXG4gICAgICB8IEtleUxNZXRhICgqIGxlZnQgV2luZG93cyAvIENvbW1hbmQga2V5ICopXG4gICAgICB8IEtleUxBbHRcbiAgICAgIHwgS2V5U3BhY2ViYXJcbiAgICAgIHwgS2V5UkFsdFxuICAgICAgfCBLZXlSTWV0YSAoKiByaWdodCBXaW5kb3dzIC8gQ29tbWFuZCBrZXkgKilcbiAgICAgIHwgS2V5TWVudVxuICAgICAgfCBLZXlSQ29udHJvbFxuXG4gICAgICAoKiBDb250cm9sIHBhZCAqKVxuICAgICAgfCBLZXlJbnNlcnQgKCogcmVwbGFjZWQgYnkgYSBGbiBrZXkgb24gTWFjICh3aXRoIGEgZGlmZmVyZW50IGNvZGUpICopXG4gICAgICB8IEtleUhvbWVcbiAgICAgIHwgS2V5UGFnZVVwXG4gICAgICB8IEtleURlbGV0ZUZvcndhcmRcbiAgICAgIHwgS2V5RWVuZFxuICAgICAgfCBLZXlQYWdlRG93blxuXG4gICAgICAoKiBBcnJvdyBwYWQgKilcbiAgICAgIHwgS2V5VXBBcnJvd1xuICAgICAgfCBLZXlMZWZ0QXJyb3dcbiAgICAgIHwgS2V5RG93bkFycm93XG4gICAgICB8IEtleVJpZ2h0QXJyb3dcblxuICAgICAgKCogTnVtZXJpYyBwYWQgKilcbiAgICAgIHwgS2V5UGFkTnVtbG9ja0NsZWFyICgqIG9uIE1hYywgQ2xlYXIgcmVwbGFjZXMgTnVtTG9jayAqKVxuICAgICAgfCBLZXlQYWRFcXVhbHMgKCogb24gTWFjIGtleWJvYXJkcyBvbmx5ICopXG4gICAgICB8IEtleVBhZERpdmlkZVxuICAgICAgfCBLZXlQYWRNdWx0aXBseVxuICAgICAgfCBLZXlQYWRNaW51c1xuICAgICAgfCBLZXlQYWQ3SG9tZVxuICAgICAgfCBLZXlQYWQ4VXBBcnJvd1xuICAgICAgfCBLZXlQYWQ5UGFnZVVwXG4gICAgICB8IEtleVBhZFBsdXNcbiAgICAgIHwgS2V5UGFkNExlZnRBcnJvd1xuICAgICAgfCBLZXlQYWQ1XG4gICAgICB8IEtleVBhZDZSaWdodEFycm93XG4gICAgICB8IEtleVBhZENvbW1hICgqIHNwZWNpZmljIHRvIEJyYXppbGlhbiBrZXlib2FyZHMgKilcbiAgICAgIHwgS2V5UGFkMUVuZFxuICAgICAgfCBLZXlQYWQyRG93bkFycm93XG4gICAgICB8IEtleVBhZDNQYWdlRG93blxuICAgICAgfCBLZXlQYWQwSW5zZXJ0XG4gICAgICB8IEtleVBhZERlY2ltYWxEZWxldGVcbiAgICAgIHwgS2V5UGFkRW50ZXJcblxuICAgICAgKCogRXh0cmEgZnVuY3Rpb24ga2V5cyAqKVxuICAgICAgfCBLZXlGMTNcbiAgICAgIHwgS2V5RjE0XG4gICAgICB8IEtleUYxNVxuICAgICAgfCBLZXlGMTZcbiAgICAgIHwgS2V5RjE3XG4gICAgICB8IEtleUYxOFxuICAgICAgfCBLZXlGMTlcbiAgICAgIHwgS2V5RjIwXG4gICAgICB8IEtleUYyMVxuICAgICAgfCBLZXlGMjJcbiAgICAgIHwgS2V5RjIzXG4gICAgICB8IEtleUYyNFxuXG4gICAgICAoKiBJbnRlcm5hdGlvbmFsICYgTEFORyBrZXlzICopXG4gICAgICB8IEtleUludGVybmF0aW9uYWwxICgqIGV4dHJhIGtleSBsZWZ0IG9mIFJTaGlmdCBvbiBKSVMgYW5kIEJyYXppbGlhbiBLQiAqKVxuICAgICAgfCBLZXlJbnRlcm5hdGlvbmFsMiAoKiBLYXRha2FuYS9IaXJhZ2FuYSBrZXkgcmlnaHQgb2YgU3BhY2Ugb24gSklTIEtCICopXG4gICAgICB8IEtleUludGVybmF0aW9uYWwzICgqIGV4dHJhIGtleSBsZWZ0IG9mIEJhY2tzcGFjZSBvbiBKSVMgS0IgKilcbiAgICAgIHwgS2V5SW50ZXJuYXRpb25hbDQgKCogSGVua2FuIGtleSByaWdodCBvZiBTcGFjZSBvbiBKSVMgS0IgKilcbiAgICAgIHwgS2V5SW50ZXJuYXRpb25hbDUgKCogTXVoZW5rYW4ga2V5IGxlZnQgb2YgU3BhY2Ugb24gSklTIEtCICopXG4gICAgICB8IEtleUludGVybmF0aW9uYWw2ICgqIEthbm1hIChjb21tYSkga2V5IHJpZ2h0IG9mIEtQMCBvbiBKSVMgS0IgKilcbiAgICAgIHwgS2V5SW50ZXJuYXRpb25hbDcgKCogRG91YmxlLUJ5dGUvU2luZ2xlLUJ5dGUgdG9nZ2xlIGtleSAqKVxuICAgICAgfCBLZXlJbnRlcm5hdGlvbmFsOCAoKiBVbmRlZmluZWQgKilcbiAgICAgIHwgS2V5SW50ZXJuYXRpb25hbDkgKCogVW5kZWZpbmVkICopXG4gICAgICB8IEtleUxhbmcxICgqIEhhbmd1bC9FbmdsaXNoIHRvZ2dsZSBrZXkgKEtvcmVhbikgKilcbiAgICAgIHwgS2V5TGFuZzIgKCogSGFuamEgY29udmVyc2lvbiBrZXkgKEtvcmVhbikgKilcbiAgICAgIHwgS2V5TGFuZzMgKCogS2F0YWthbmEga2V5IChKYXBhbmVzZSkgKilcbiAgICAgIHwgS2V5TGFuZzQgKCogSGlyYWdhbmEga2V5IChKYXBhbmVzZSkgKilcbiAgICAgIHwgS2V5TGFuZDUgKCogWmVua2FrdS9IYW5rYWt1IGtleSAoSmFwYW5lc2UpICopXG5cbiAgICAgICgqIEV4dGVuc2lvbnMgKilcbiAgICAgIHwgS2V5SGVscFxuICAgICAgfCBLZXlNdXRlXG4gICAgICB8IEtleVZvbHVtZVVwXG4gICAgICB8IEtleVZvbHVtZURvd25cblxuICAgIHR5cGUgZmxhZ3MgPSB7XG4gICAgICBmbGFnX3NoaWZ0IDogYm9vbDtcbiAgICAgIGZsYWdfYWx0IDogYm9vbDtcbiAgICAgIGZsYWdfY29udHJvbCA6IGJvb2w7XG4gICAgICBmbGFnX21ldGEgOiBib29sO1xuICAgICAgZmxhZ19jYXBzbG9jayA6IGJvb2w7XG4gICAgICBmbGFnX251bWxvY2sgOiBib29sO1xuICAgICAgZmxhZ19kZWFkIDogYm9vbDtcbiAgICB9XG5cbiAgICB0eXBlIGtleV9kYXRhID0ge1xuICAgICAga2V5OiBrZXk7XG4gICAgICBjaGFyOiBVY2hhci50O1xuICAgICAgZmxhZ3M6IGZsYWdzO1xuICAgIH1cblxuICAgIHR5cGUgYnV0dG9uID1cbiAgICAgIHwgQnV0dG9uTm9uZVxuICAgICAgfCBCdXR0b25MZWZ0XG4gICAgICB8IEJ1dHRvbk1pZGRsZVxuICAgICAgfCBCdXR0b25SaWdodFxuICAgICAgfCBCdXR0b25XaGVlbFVwXG4gICAgICB8IEJ1dHRvbldoZWVsRG93blxuXG4gICAgdHlwZSBidXR0b25fZGF0YSA9IHtcbiAgICAgIHBvc2l0aW9uOiBwb3NpdGlvbjtcbiAgICAgIGJ1dHRvbjogYnV0dG9uO1xuICAgIH1cblxuICAgIHR5cGUgJ2EgZXYgPSAnYSBSZWFjdC5ldmVudCAqICg/c3RlcDpSZWFjdC5zdGVwIC0+ICdhIC0+IHVuaXQpXG5cbiAgICBsZXQgZnJhbWUsIHNlbmRfZnJhbWUgPVxuICAgICAgKFJlYWN0LkUuY3JlYXRlICgpIDogdW5pdCBjYW52YXNfZXZlbnQgZXYpXG4gICAgbGV0IGZvY3VzX2luLCBzZW5kX2ZvY3VzX2luID1cbiAgICAgIChSZWFjdC5FLmNyZWF0ZSAoKSA6IHVuaXQgY2FudmFzX2V2ZW50IGV2KVxuICAgIGxldCBmb2N1c19vdXQsIHNlbmRfZm9jdXNfb3V0ID1cbiAgICAgIChSZWFjdC5FLmNyZWF0ZSAoKSA6IHVuaXQgY2FudmFzX2V2ZW50IGV2KVxuICAgIGxldCByZXNpemUsIHNlbmRfcmVzaXplID1cbiAgICAgIChSZWFjdC5FLmNyZWF0ZSAoKSA6IHNpemUgY2FudmFzX2V2ZW50IGV2KVxuICAgIGxldCBtb3ZlLCBzZW5kX21vdmUgPVxuICAgICAgKFJlYWN0LkUuY3JlYXRlICgpIDogcG9zaXRpb24gY2FudmFzX2V2ZW50IGV2KVxuICAgIGxldCBjbG9zZSwgc2VuZF9jbG9zZSA9XG4gICAgICAoUmVhY3QuRS5jcmVhdGUgKCkgOiB1bml0IGNhbnZhc19ldmVudCBldilcbiAgICBsZXQga2V5X2Rvd24sIHNlbmRfa2V5X2Rvd24gPVxuICAgICAgKFJlYWN0LkUuY3JlYXRlICgpIDoga2V5X2RhdGEgY2FudmFzX2V2ZW50IGV2KVxuICAgIGxldCBrZXlfdXAsIHNlbmRfa2V5X3VwID1cbiAgICAgIChSZWFjdC5FLmNyZWF0ZSAoKSA6IGtleV9kYXRhIGNhbnZhc19ldmVudCBldilcbiAgICBsZXQgYnV0dG9uX2Rvd24sIHNlbmRfYnV0dG9uX2Rvd24gPVxuICAgICAgKFJlYWN0LkUuY3JlYXRlICgpIDogYnV0dG9uX2RhdGEgY2FudmFzX2V2ZW50IGV2KVxuICAgIGxldCBidXR0b25fdXAsIHNlbmRfYnV0dG9uX3VwID1cbiAgICAgIChSZWFjdC5FLmNyZWF0ZSAoKSA6IGJ1dHRvbl9kYXRhIGNhbnZhc19ldmVudCBldilcbiAgICBsZXQgbW91c2VfbW92ZSwgc2VuZF9tb3VzZV9tb3ZlID1cbiAgICAgIChSZWFjdC5FLmNyZWF0ZSAoKSA6IHBvc2l0aW9uIGNhbnZhc19ldmVudCBldilcbiAgICAoKiBsZXQgYmFja2VuZF9zdG9wLCBzZW5kX2JhY2tlbmRfc3RvcCA9XG4gICAgICAgKFJlYWN0LkUuY3JlYXRlICgpIDogYmFja2VuZF9zdG9wX2V2ZW50IGV2KSAqKVxuXG4gICAgbGV0IGV2ZW50X3RpbWVzdGFtcCwgc2V0X2V2ZW50X3RpbWVzdGFtcCA9XG4gICAgICBSZWFjdC5TLmNyZWF0ZSAwTFxuXG4gICAgZXh0ZXJuYWwgaW50X29mX2tleSA6IGtleSAtPiBpbnRcbiAgICAgID0gXCJtbF9jYW52YXNfaW50X29mX2tleVwiXG5cbiAgICBleHRlcm5hbCBrZXlfb2ZfaW50IDogaW50IC0+IGtleVxuICAgICAgPSBcIm1sX2NhbnZhc19rZXlfb2ZfaW50XCJcblxuICBlbmRcblxuICBtb2R1bGUgSW50ZXJuYWxFdmVudCA9IHN0cnVjdFxuXG4gICAgKCogV2UgZGVjbGFyZSBjb25zdHJ1Y3RvcnMgdGhhdCBhcmUgb25seSB1c2VkIGZyb20gdGhlIEMgY29kZSAqKVxuICAgIFtAQEB3YXJuaW5nIFwiLTM3XCJdXG5cbiAgICBvcGVuIEV2ZW50XG5cbiAgICB0eXBlIGZyYW1lX2N5Y2xlX2V2ZW50ID0ge1xuICAgICAgdGltZXN0YW1wOiB0aW1lc3RhbXA7XG4gICAgfVxuXG4gICAgdHlwZSBmcmFtZV9ldmVudCA9IHtcbiAgICAgIGNhbnZhczogQ2FudmFzLnQ7XG4gICAgICB0aW1lc3RhbXA6IHRpbWVzdGFtcDtcbiAgICB9XG5cbiAgICB0eXBlIGZvY3VzX2RpcmVjdGlvbiA9XG4gICAgICB8IE91dFxuICAgICAgfCBJblxuXG4gICAgdHlwZSBjYW52YXNfZm9jdXNlZF9ldmVudCA9IHtcbiAgICAgIGNhbnZhczogQ2FudmFzLnQ7XG4gICAgICB0aW1lc3RhbXA6IHRpbWVzdGFtcDtcbiAgICAgIGZvY3VzOiBmb2N1c19kaXJlY3Rpb247XG4gICAgfVxuXG4gICAgdHlwZSBjYW52YXNfcmVzaXplZF9ldmVudCA9IHtcbiAgICAgIGNhbnZhczogQ2FudmFzLnQ7XG4gICAgICB0aW1lc3RhbXA6IHRpbWVzdGFtcDtcbiAgICAgIHNpemU6IGludCAqIGludDtcbiAgICB9XG5cbiAgICB0eXBlIGNhbnZhc19tb3ZlZF9ldmVudCA9IHtcbiAgICAgIGNhbnZhczogQ2FudmFzLnQ7XG4gICAgICB0aW1lc3RhbXA6IHRpbWVzdGFtcDtcbiAgICAgIHBvc2l0aW9uOiBpbnQgKiBpbnQ7XG4gICAgfVxuXG4gICAgdHlwZSBjYW52YXNfY2xvc2VkX2V2ZW50ID0ge1xuICAgICAgY2FudmFzOiBDYW52YXMudDtcbiAgICAgIHRpbWVzdGFtcDogdGltZXN0YW1wO1xuICAgIH1cblxuICAgIHR5cGUgc3RhdGUgPVxuICAgICAgfCBVcFxuICAgICAgfCBEb3duXG5cbiAgICB0eXBlIGtleV9hY3Rpb25fZXZlbnQgPSB7XG4gICAgICBjYW52YXM6IENhbnZhcy50O1xuICAgICAgdGltZXN0YW1wOiB0aW1lc3RhbXA7XG4gICAgICBrZXk6IGtleTtcbiAgICAgIGNoYXI6IFVjaGFyLnQ7XG4gICAgICBmbGFnczogZmxhZ3M7XG4gICAgICBzdGF0ZTogc3RhdGU7XG4gICAgfVxuXG4gICAgdHlwZSBidXR0b25fYWN0aW9uX2V2ZW50ID0ge1xuICAgICAgY2FudmFzOiBDYW52YXMudDtcbiAgICAgIHRpbWVzdGFtcDogdGltZXN0YW1wO1xuICAgICAgcG9zaXRpb246IGludCAqIGludDtcbiAgICAgIGJ1dHRvbjogYnV0dG9uO1xuICAgICAgc3RhdGU6IHN0YXRlO1xuICAgIH1cblxuICAgIHR5cGUgbW91c2VfbW92ZV9ldmVudCA9IHtcbiAgICAgIGNhbnZhczogQ2FudmFzLnQ7XG4gICAgICB0aW1lc3RhbXA6IHRpbWVzdGFtcDtcbiAgICAgIHBvc2l0aW9uOiBpbnQgKiBpbnQ7XG4gICAgfVxuXG4gICAgdHlwZSB0ID1cbiAgICAgIHwgRnJhbWVDeWNsZSBvZiBmcmFtZV9jeWNsZV9ldmVudFxuICAgICAgfCBGcmFtZSBvZiBmcmFtZV9ldmVudFxuICAgICAgfCBDYW52YXNGb2N1c2VkIG9mIGNhbnZhc19mb2N1c2VkX2V2ZW50XG4gICAgICB8IENhbnZhc1Jlc2l6ZWQgb2YgY2FudmFzX3Jlc2l6ZWRfZXZlbnRcbiAgICAgIHwgQ2FudmFzTW92ZWQgb2YgY2FudmFzX21vdmVkX2V2ZW50XG4gICAgICB8IENhbnZhc0Nsb3NlZCBvZiBjYW52YXNfY2xvc2VkX2V2ZW50XG4gICAgICB8IEtleUFjdGlvbiBvZiBrZXlfYWN0aW9uX2V2ZW50XG4gICAgICB8IEJ1dHRvbkFjdGlvbiBvZiBidXR0b25fYWN0aW9uX2V2ZW50XG4gICAgICB8IE1vdXNlTW92ZSBvZiBtb3VzZV9tb3ZlX2V2ZW50XG5cbiAgZW5kXG5cbiAgbW9kdWxlIEJhY2tlbmQgPSBzdHJ1Y3RcblxuICAgIGV4dGVybmFsIGluaXQgOiB1bml0IC0+IHVuaXRcbiAgICAgID0gXCJtbF9jYW52YXNfaW5pdFwiXG5cbiAgICBleHRlcm5hbCBydW5faW50ZXJuYWwgOlxuICAgICAgKEludGVybmFsRXZlbnQudCAtPiB1bml0KSAtPiAodW5pdCAtPiAnZHVtbXkxKSAtPiAnZHVtbXkyXG4gICAgICA9IFwibWxfY2FudmFzX3J1blwiXG5cbiAgICBleHRlcm5hbCBzdG9wIDogdW5pdCAtPiB1bml0XG4gICAgICA9IFwibWxfY2FudmFzX3N0b3BcIlxuXG4gICAgZXh0ZXJuYWwgZ2V0Q3VycmVudFRpbWVzdGFtcCA6IHVuaXQgLT4gRXZlbnQudGltZXN0YW1wXG4gICAgICA9IFwibWxfY2FudmFzX2dldF9jdXJyZW50X3RpbWVzdGFtcFwiXG5cbiAgICBleHRlcm5hbCBnZXRDYW52YXMgOiBpbnQgLT4gQ2FudmFzLnRcbiAgICAgID0gXCJtbF9jYW52YXNfZ2V0X2NhbnZhc1wiXG5cbiAgICBsZXQgcnVuIGsgPVxuICAgICAgbGV0IG9wZW4gSW50ZXJuYWxFdmVudCBpblxuICAgICAgbGV0IG9wZW4gRXZlbnQgaW5cbiAgICAgIGxldCBoIGUgPVxuICAgICAgICAobWF0Y2ggZSB3aXRoXG4gICAgICAgIHwgRnJhbWVDeWNsZSB7IHRpbWVzdGFtcCB9IC0+XG4gICAgICAgICAgICAoKiBJbnRlcm5hbCB1c2FnZSAqKVxuICAgICAgICAgICAgKClcbiAgICAgICAgfCBGcmFtZSB7IGNhbnZhczsgdGltZXN0YW1wIH0gLT5cbiAgICAgICAgICAgIGxldCBlID0geyBjYW52YXM7IHRpbWVzdGFtcDsgZGF0YSA9ICgpIH0gaW5cbiAgICAgICAgICAgIHNldF9ldmVudF90aW1lc3RhbXAgZS50aW1lc3RhbXA7IHNlbmRfZnJhbWUgZVxuICAgICAgICB8IENhbnZhc0ZvY3VzZWQgeyBjYW52YXM7IHRpbWVzdGFtcDsgZm9jdXMgPSBJbiB9IC0+XG4gICAgICAgICAgICBsZXQgZSA9IHsgY2FudmFzOyB0aW1lc3RhbXA7IGRhdGEgPSAoKSB9IGluXG4gICAgICAgICAgICBzZXRfZXZlbnRfdGltZXN0YW1wIGUudGltZXN0YW1wOyBzZW5kX2ZvY3VzX2luIGVcbiAgICAgICAgfCBDYW52YXNGb2N1c2VkIHsgY2FudmFzOyB0aW1lc3RhbXA7IGZvY3VzID0gT3V0IH0gLT5cbiAgICAgICAgICAgIGxldCBlID0geyBjYW52YXM7IHRpbWVzdGFtcDsgZGF0YSA9ICgpIH0gaW5cbiAgICAgICAgICAgIHNldF9ldmVudF90aW1lc3RhbXAgZS50aW1lc3RhbXA7IHNlbmRfZm9jdXNfb3V0IGVcbiAgICAgICAgfCBDYW52YXNSZXNpemVkIHsgY2FudmFzOyB0aW1lc3RhbXA7IHNpemUgfSAtPlxuICAgICAgICAgICAgbGV0IGUgPSB7IGNhbnZhczsgdGltZXN0YW1wOyBkYXRhID0gc2l6ZSB9IGluXG4gICAgICAgICAgICBzZXRfZXZlbnRfdGltZXN0YW1wIGUudGltZXN0YW1wOyBzZW5kX3Jlc2l6ZSBlXG4gICAgICAgIHwgQ2FudmFzTW92ZWQgeyBjYW52YXM7IHRpbWVzdGFtcDsgcG9zaXRpb24gfSAtPlxuICAgICAgICAgICAgbGV0IGUgPSB7IGNhbnZhczsgdGltZXN0YW1wOyBkYXRhID0gcG9zaXRpb24gfSBpblxuICAgICAgICAgICAgc2V0X2V2ZW50X3RpbWVzdGFtcCBlLnRpbWVzdGFtcDsgc2VuZF9tb3ZlIGVcbiAgICAgICAgfCBDYW52YXNDbG9zZWQgeyBjYW52YXM7IHRpbWVzdGFtcCB9IC0+XG4gICAgICAgICAgICBsZXQgZSA9IHsgY2FudmFzOyB0aW1lc3RhbXA7IGRhdGEgPSAoKSB9IGluXG4gICAgICAgICAgICBzZXRfZXZlbnRfdGltZXN0YW1wIGUudGltZXN0YW1wOyBzZW5kX2Nsb3NlIGVcbiAgICAgICAgfCBLZXlBY3Rpb24geyBjYW52YXM7IHRpbWVzdGFtcDsga2V5OyBjaGFyOyBmbGFnczsgc3RhdGUgPSBEb3duIH0gLT5cbiAgICAgICAgICAgIGxldCBlID0geyBjYW52YXM7IHRpbWVzdGFtcDsgZGF0YSA9IHsga2V5OyBjaGFyOyBmbGFncyB9IH0gaW5cbiAgICAgICAgICAgIHNldF9ldmVudF90aW1lc3RhbXAgZS50aW1lc3RhbXA7IHNlbmRfa2V5X2Rvd24gZVxuICAgICAgICB8IEtleUFjdGlvbiB7IGNhbnZhczsgdGltZXN0YW1wOyBrZXk7IGNoYXI7IGZsYWdzOyBzdGF0ZSA9IFVwIH0gLT5cbiAgICAgICAgICAgIGxldCBlID0geyBjYW52YXM7IHRpbWVzdGFtcDsgZGF0YSA9IHsga2V5OyBjaGFyOyBmbGFncyB9IH0gaW5cbiAgICAgICAgICAgIHNldF9ldmVudF90aW1lc3RhbXAgZS50aW1lc3RhbXA7IHNlbmRfa2V5X3VwIGVcbiAgICAgICAgfCBCdXR0b25BY3Rpb24geyBjYW52YXM7IHRpbWVzdGFtcDsgcG9zaXRpb247IGJ1dHRvbjsgc3RhdGUgPSBEb3duIH0gLT5cbiAgICAgICAgICAgIGxldCBlID0geyBjYW52YXM7IHRpbWVzdGFtcDsgZGF0YSA9IHsgcG9zaXRpb247IGJ1dHRvbiB9IH0gaW5cbiAgICAgICAgICAgIHNldF9ldmVudF90aW1lc3RhbXAgZS50aW1lc3RhbXA7IHNlbmRfYnV0dG9uX2Rvd24gZVxuICAgICAgICB8IEJ1dHRvbkFjdGlvbiB7IGNhbnZhczsgdGltZXN0YW1wOyBwb3NpdGlvbjsgYnV0dG9uOyBzdGF0ZSA9IFVwIH0gLT5cbiAgICAgICAgICAgIGxldCBlID0geyBjYW52YXM7IHRpbWVzdGFtcDsgZGF0YSA9IHsgcG9zaXRpb247IGJ1dHRvbiB9IH0gaW5cbiAgICAgICAgICAgIHNldF9ldmVudF90aW1lc3RhbXAgZS50aW1lc3RhbXA7IHNlbmRfYnV0dG9uX3VwIGVcbiAgICAgICAgfCBNb3VzZU1vdmUgeyBjYW52YXM7IHRpbWVzdGFtcDsgcG9zaXRpb24gfSAtPlxuICAgICAgICAgICAgbGV0IGUgPSB7IGNhbnZhczsgdGltZXN0YW1wOyBkYXRhID0gcG9zaXRpb24gfSBpblxuICAgICAgICAgICAgc2V0X2V2ZW50X3RpbWVzdGFtcCBlLnRpbWVzdGFtcDsgc2VuZF9tb3VzZV9tb3ZlIGUpO1xuICAgICAgICBQZW5kaW5nLnByb2Nlc3MgKClcbiAgICAgIGluXG4gICAgICBydW5faW50ZXJuYWwgaCBrXG4gIGVuZFxuXG5lbmRcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgIENvcHlyaWdodCAyMDIyIE9DYW1sUHJvICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICBBbGwgcmlnaHRzIHJlc2VydmVkLiBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSAgKilcbigqICBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlIHNwZWNpYWwgICAgICAgKilcbigqICBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxub3BlbiBPY2FtbENhbnZhcy5WMVxuXG5sZXQgZXZlbnRzID0gcmVmIFtdXG5cbmxldCByZXRhaW5fZXZlbnQgZSA9XG4gIGV2ZW50cyA6PSBlIDo6ICFldmVudHNcblxubGV0IGNsZWFyX2V2ZW50cyAoKSA9XG4gIGV2ZW50cyA6PSBbXVxuXG5sZXQgKCkgPVxuXG4gIEJhY2tlbmQuaW5pdCAoKTtcblxuICBsZXQgYyA9IENhbnZhcy5jcmVhdGVPbnNjcmVlbiB+dGl0bGU6XCJQUE0gRHVtcFwiXG4gICAgICAgICAgICB+cG9zOigzMDAsIDIwMCkgfnNpemU6KDMwMCwgMjAwKSAoKSBpblxuXG4gIENhbnZhcy5zZXRGaWxsQ29sb3IgYyBDb2xvci5vcmFuZ2U7XG4gIENhbnZhcy5maWxsUmVjdCBjIH5wb3M6KDAuMCwgMC4wKSB+c2l6ZTooMzAwLjAsIDIwMC4wKTtcblxuICBDYW52YXMuc2V0U3Ryb2tlQ29sb3IgYyBDb2xvci5jeWFuO1xuICBDYW52YXMuc2V0TGluZVdpZHRoIGMgMTAuMDtcbiAgQ2FudmFzLmNsZWFyUGF0aCBjO1xuICBDYW52YXMubW92ZVRvIGMgKDUuMCwgNS4wKTtcbiAgQ2FudmFzLmxpbmVUbyBjICgyOTUuMCwgNS4wKTtcbiAgQ2FudmFzLmxpbmVUbyBjICgyOTUuMCwgMTk1LjApO1xuICBDYW52YXMubGluZVRvIGMgKDUuMCwgMTk1LjApO1xuICBDYW52YXMuY2xvc2VQYXRoIGM7XG4gIENhbnZhcy5zdHJva2UgYztcblxuICBDYW52YXMuc2V0Rm9udCBjIFwiTGliZXJhdGlvbiBTYW5zXCIgfnNpemU6MzYuMFxuICAgIH5zbGFudDpGb250LlJvbWFuIH53ZWlnaHQ6Rm9udC5ib2xkO1xuXG4gIENhbnZhcy5zZXRGaWxsQ29sb3IgYyAoQ29sb3Iub2ZfcmdiIDAgNjQgMjU1KTtcbiAgQ2FudmFzLnNldExpbmVXaWR0aCBjIDEuMDtcbiAgQ2FudmFzLnNhdmUgYztcbiAgQ2FudmFzLnRyYW5zbGF0ZSBjICgxNTAuMCwgMTAwLjApO1xuICBDYW52YXMucm90YXRlIGMgKC0uIENvbnN0LnBpXzgpO1xuICBDYW52YXMuZmlsbFRleHQgYyBcIkhlbGxvIHdvcmxkICFcIiAoLTEzMC4wLCAyMC4wKTtcbiAgQ2FudmFzLnJlc3RvcmUgYztcblxuICBDYW52YXMuc2hvdyBjO1xuXG4gIGxldCBpbWcgPSBDYW52YXMuZ2V0SW1hZ2VEYXRhIGMgfnBvczooMCwgMCkgfnNpemU6KDMwMCwgMjAwKSBpblxuICBsZXQgaW1nX2JhID0gSW1hZ2VEYXRhLnRvX2JpZ2FycmF5IGltZyBpblxuXG4gIGxldCBvYyA9IG9wZW5fb3V0IFwicGljdHVyZS5wcG1cIiBpblxuICBsZXQgZm10ID0gRm9ybWF0LmZvcm1hdHRlcl9vZl9vdXRfY2hhbm5lbCBvYyBpblxuICBGb3JtYXQuZnByaW50ZiBmbXQgXCJQM1xcbiVkICVkXFxuJWRcXG5cIiAzMDAgMjAwIDI1NTtcblxuICBmb3IgaSA9IDAgdG8gMTk5IGRvXG4gICAgZm9yIGogPSAwIHRvIDI5OSBkb1xuICAgICAgbGV0IGIgPSBCaWdhcnJheS5BcnJheTMuZ2V0IGltZ19iYSBpIGogMCBpblxuICAgICAgbGV0IGcgPSBCaWdhcnJheS5BcnJheTMuZ2V0IGltZ19iYSBpIGogMSBpblxuICAgICAgbGV0IHIgPSBCaWdhcnJheS5BcnJheTMuZ2V0IGltZ19iYSBpIGogMiBpblxuICAgICAgbGV0IF9hID0gQmlnYXJyYXkuQXJyYXkzLmdldCBpbWdfYmEgaSBqIDMgaW5cbiAgICAgIGxldCBzZXAgPSBpZiAoaiBsYW5kIDMpID0gMyB0aGVuICdcXG4nIGVsc2UgJyAnIGluXG4gICAgICBGb3JtYXQuZnByaW50ZiBmbXQgXCIlZCAlZCAlZCVjXCIgciBnIGIgc2VwXG4gICAgZG9uZVxuICBkb25lO1xuXG4gIGNsb3NlX291dCBvYztcblxuICBDYW52YXMucHV0SW1hZ2VEYXRhIGMgfmRwb3M6KDAsIDApIGltZyB+c3BvczooMCwgMCkgfnNpemU6KDMwMCwgMjAwKTtcblxuICByZXRhaW5fZXZlbnQgQEBcbiAgICBSZWFjdC5FLm1hcCAoZnVuIF8gLT5cbiAgICAgICAgQmFja2VuZC5zdG9wICgpXG4gICAgICApIEV2ZW50LmNsb3NlO1xuXG4gIHJldGFpbl9ldmVudCBAQFxuICAgIFJlYWN0LkUubWFwIChmdW4geyBFdmVudC5kYXRhID0geyBFdmVudC5rZXk7IF8gfTsgXyB9IC0+XG4gICAgICAgIGlmIGtleSA9IEtleUVzY2FwZSB0aGVuXG4gICAgICAgICAgQmFja2VuZC5zdG9wICgpXG4gICAgICApIEV2ZW50LmtleV9kb3duO1xuXG4gIHJldGFpbl9ldmVudCBAQFxuICAgIFJlYWN0LkUubWFwIChmdW4geyBFdmVudC5jYW52YXMgPSBfOyB0aW1lc3RhbXAgPSBfO1xuICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0geyBFdmVudC5wb3NpdGlvbiA9ICh4LCB5KTsgYnV0dG9uID0gXyB9IH0gLT5cbiAgICAgICAgQ2FudmFzLnNldEZpbGxDb2xvciBjIENvbG9yLnJlZDtcbiAgICAgICAgQ2FudmFzLmNsZWFyUGF0aCBjO1xuICAgICAgICBDYW52YXMuYXJjIGMgfmNlbnRlcjooZmxvYXRfb2ZfaW50IHgsIGZsb2F0X29mX2ludCB5KVxuICAgICAgICAgIH5yYWRpdXM6NS4wIH50aGV0YTE6MC4wIH50aGV0YTI6KDIuMCAqLiBDb25zdC5waSkgfmNjdzpmYWxzZTtcbiAgICAgICAgQ2FudmFzLmZpbGwgYyB+bm9uemVybzpmYWxzZTtcbiAgICAgICkgRXZlbnQuYnV0dG9uX2Rvd247XG5cbiAgQmFja2VuZC5ydW4gKGZ1biAoKSAtPlxuICAgICAgY2xlYXJfZXZlbnRzICgpO1xuICAgICAgUHJpbnRmLnByaW50ZiBcIkdvb2RieWUgIVxcblwiKVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBFbnN1cmUgdGhhdCBbYXRfZXhpdF0gZnVuY3Rpb25zIGFyZSBjYWxsZWQgYXQgdGhlIGVuZCBvZiBldmVyeSBwcm9ncmFtICopXG5cbmxldCBfID0gZG9fYXRfZXhpdCgpXG4iXX0=
