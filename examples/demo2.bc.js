//# 1 ".demo2.eobjs/jsoo/demo2.bc.runtime.js"
// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=unknown, use-js-string=true, version=5.8.2+5.8.2
//# 3 ".demo2.eobjs/jsoo/demo2.bc.runtime.js"

//# 7 ".demo2.eobjs/jsoo/demo2.bc.runtime.js"
(function
  (Object){
   typeof globalThis !== "object"
   &&
    (this
      ? get()
      : (Object.defineProperty
         (Object.prototype, "_T_", {configurable: true, get: get}),
        _T_));
   function get(){
    var global = this || self;
    global.globalThis = global;
    delete Object.prototype._T_;
   }
  }
  (Object));
(function(globalThis){
   "use strict";
   var
    joo_global_object = globalThis,
    BUTTON =
      {NONE: 0, LEFT: 1, MIDDLE: 2, RIGHT: 3, WHEEL_UP: 4, WHEEL_DOWN: 5},
    BUTTON_STATE = {UP: 0, DOWN: 1},
    BUTTON_STATE_TAG = {UP: 0, DOWN: 1},
    BUTTON_TAG =
      {NONE: 0, LEFT: 1, MIDDLE: 2, RIGHT: 3, WHEEL_UP: 4, WHEEL_DOWN: 5};
   function caml_subarray_to_jsbytes(a, i, len){
    var f = String.fromCharCode;
    if(i == 0 && len <= 4096 && len == a.length) return f.apply(null, a);
    var s = "";
    for(; 0 < len; i += 1024, len -= 1024)
     s += f.apply(null, a.slice(i, i + Math.min(len, 1024)));
    return s;
   }
   function caml_string_of_jsbytes(x){return x;}
   function caml_string_of_array(a){
    return caml_string_of_jsbytes(caml_subarray_to_jsbytes(a, 0, a.length));
   }
   function caml_ba_get_1(ba, i0){return ba.get(ba.offset(i0));}
   function BigStringReader(bs, i){this.s = bs; this.i = i;}
   BigStringReader.prototype =
    {read8u: function(){return caml_ba_get_1(this.s, this.i++);},
     read8s: function(){return caml_ba_get_1(this.s, this.i++) << 24 >> 24;},
     read16u:
     function(){
      var s = this.s, i = this.i;
      this.i = i + 2;
      return caml_ba_get_1(s, i) << 8 | caml_ba_get_1(s, i + 1);
     },
     read16s:
     function(){
      var s = this.s, i = this.i;
      this.i = i + 2;
      return caml_ba_get_1(s, i) << 24 >> 16 | caml_ba_get_1(s, i + 1);
     },
     read32u:
     function(){
      var s = this.s, i = this.i;
      this.i = i + 4;
      return (caml_ba_get_1(s, i) << 24 | caml_ba_get_1(s, i + 1) << 16
             | caml_ba_get_1(s, i + 2) << 8
             | caml_ba_get_1(s, i + 3))
             >>> 0;
     },
     read32s:
     function(){
      var s = this.s, i = this.i;
      this.i = i + 4;
      return caml_ba_get_1(s, i) << 24 | caml_ba_get_1(s, i + 1) << 16
             | caml_ba_get_1(s, i + 2) << 8
             | caml_ba_get_1(s, i + 3);
     },
     readstr:
     function(len){
      var i = this.i, arr = new Array(len);
      for(var j = 0; j < len; j++) arr[j] = caml_ba_get_1(this.s, i + j);
      this.i = i + len;
      return caml_string_of_array(arr);
     },
     readuint8array:
     function(len){
      var i = this.i, offset = this.offset(i);
      this.i = i + len;
      return this.s.data.subarray(offset, offset + len);
     }};
   var
    CAP_TYPE_TAG = {BUTT: 0, SQUARE: 1, ROUND: 2},
    COMPOP_TAG =
      {SOURCE_OVER: 0,
       SOURCE_IN: 1,
       SOURCE_OUT: 2,
       SOURCE_ATOP: 3,
       DESTINATION_OVER: 4,
       DESTINATION_IN: 5,
       DESTINATION_OUT: 6,
       DESTINATION_ATOP: 7,
       LIGHTER: 8,
       COPY: 9,
       XOR: 10,
       MULTIPLY: 11,
       SCREEN: 12,
       OVERLAY: 13,
       DARKEN: 14,
       LIGHTEN: 15,
       COLOR_DODGE: 16,
       COLOR_BURN: 17,
       HARD_LIGHT: 18,
       SOFT_LIGHT: 19,
       DIFFERENCE: 20,
       EXCLUSION: 21,
       HUE: 22,
       SATURATION: 23,
       COLOR: 24,
       LUMINOSITY: 25},
    tag_to_cap_type =
      new
       joo_global_object.Map
       ([[CAP_TYPE_TAG.BUTT, "butt"],
         [CAP_TYPE_TAG.SQUARE, "square"],
         [CAP_TYPE_TAG.ROUND, "round"]]);
   function Cap_type_val(cap){return tag_to_cap_type.get(cap);}
   var
    tag_to_compop =
      new
       joo_global_object.Map
       ([[COMPOP_TAG.SOURCE_OVER, "source-over"],
         [COMPOP_TAG.SOURCE_IN, "source-in"],
         [COMPOP_TAG.SOURCE_OUT, "source-out"],
         [COMPOP_TAG.SOURCE_ATOP, "source-atop"],
         [COMPOP_TAG.DESTINATION_OVER, "destination-over"],
         [COMPOP_TAG.DESTINATION_IN, "destination-in"],
         [COMPOP_TAG.DESTINATION_OUT, "destination-out"],
         [COMPOP_TAG.DESTINATION_ATOP, "destination-atop"],
         [COMPOP_TAG.LIGHTER, "lighter"],
         [COMPOP_TAG.COPY, "copy"],
         [COMPOP_TAG.XOR, "xor"],
         [COMPOP_TAG.MULTIPLY, "multiply"],
         [COMPOP_TAG.SCREEN, "screen"],
         [COMPOP_TAG.OVERLAY, "overlay"],
         [COMPOP_TAG.DARKEN, "darken"],
         [COMPOP_TAG.LIGHTEN, "lighten"],
         [COMPOP_TAG.COLOR_DODGE, "color-dodge"],
         [COMPOP_TAG.COLOR_BURN, "color-burn"],
         [COMPOP_TAG.HARD_LIGHT, "hard-light"],
         [COMPOP_TAG.SOFT_LIGHT, "soft-light"],
         [COMPOP_TAG.DIFFERENCE, "difference"],
         [COMPOP_TAG.EXCLUSION, "exclusion"],
         [COMPOP_TAG.HUE, "hue"],
         [COMPOP_TAG.SATURATION, "saturation"],
         [COMPOP_TAG.COLOR, "color"],
         [COMPOP_TAG.LUMINOSITY, "luminosity"]]);
   function Compop_val(cap){return tag_to_compop.get(cap);}
   var STYLE_TAG = {COLOR: 0, GRADIENT: 1, PATTERN: 2};
   function Draw_style_val(style){
    var s = [];
    s[1] = style;
    switch(typeof style){
      case "string":
       s[0] = STYLE_TAG.COLOR; break;
      case "CanvasGradient":
       s[0] = STYLE_TAG.GRADIENT; break;
      case "CanvasPattern":
       s[0] = STYLE_TAG.PATTERN; break;
    }
    return s;
   }
   var
    EVENT_TAG =
      {FRAME_CYCLE: 0,
       FRAME: 1,
       CANVAS_FOCUSED: 2,
       CANVAS_RESIZED: 3,
       CANVAS_MOVED: 4,
       CANVAS_CLOSED: 5,
       KEY_ACTION: 6,
       BUTTON_ACTION: 7,
       MOUSE_MOVE: 8},
    FOCUS = {OUT: 0, IN: 1},
    FOCUS_TAG = {OUT: 0, IN: 1},
    JOIN_TYPE_TAG = {ROUND: 0, MITER: 1, BEVEL: 2},
    tag_to_join_type =
      new
       joo_global_object.Map
       ([[JOIN_TYPE_TAG.ROUND, "round"],
         [JOIN_TYPE_TAG.MITER, "miter"],
         [JOIN_TYPE_TAG.BEVEL, "bevel"]]);
   function Join_type_val(join){return tag_to_join_type.get(join);}
   var
    KEY =
      {UNDEFINED: 0x03,
       ESCAPE: 0x29,
       F1: 0x3A,
       F2: 0x3B,
       F3: 0x3C,
       F4: 0x3D,
       F5: 0x3E,
       F6: 0x3F,
       F7: 0x40,
       F8: 0x41,
       F9: 0x42,
       F10: 0x43,
       F11: 0x44,
       F12: 0x45,
       PRINTSCREEN: 0x46,
       SCROLLLOCK: 0x47,
       PAUSE: 0x48,
       GRAVE_TILDE: 0x35,
       _1_EXCLAMATION: 0x1E,
       _2_AT: 0x1F,
       _3_NUMBER: 0x20,
       _4_DOLLAR: 0x21,
       _5_PERCENT: 0x22,
       _6_CARET: 0x23,
       _7_AMPERSAND: 0x24,
       _8_ASTERISK: 0x25,
       _9_LPARENTHESIS: 0x26,
       _0_RPARENTHESIS: 0x27,
       MINUS_UNDERSCORE: 0x2D,
       EQUAL_PLUS: 0x2E,
       BACKSPACE: 0x2A,
       TAB: 0x2B,
       Q: 0x14,
       W: 0x1A,
       E: 0x08,
       R: 0x15,
       T: 0x17,
       Y: 0x1C,
       U: 0x18,
       I: 0x0C,
       O: 0x12,
       P: 0x13,
       LBRACKET_CURLY: 0x2F,
       RBRACKET_CURLY: 0x30,
       BACKSLASH_PIPE: 0x31,
       CAPSLOCK: 0x39,
       A: 0x04,
       S: 0x16,
       D: 0x07,
       F: 0x09,
       G: 0x0A,
       H: 0x0B,
       J: 0x0D,
       K: 0x0E,
       L: 0x0F,
       SEMICOLON_COLON: 0x33,
       QUOTE_DOUBLEQUOTE: 0x34,
       NONUS_NUMBER_TILDE: 0x32,
       RETURN: 0x28,
       LSHIFT: 0xE1,
       NONUS_BACKSLASH_PIPE: 0x64,
       Z: 0x1D,
       X: 0x1B,
       C: 0x06,
       V: 0x19,
       B: 0x05,
       N: 0x11,
       M: 0x10,
       COMMA_LESS: 0x36,
       PERIOD_GREATER: 0x37,
       SLASH_QUESTION: 0x38,
       RSHIFT: 0xE5,
       LCONTROL: 0xE0,
       LMETA: 0xE3,
       LALT: 0xE2,
       SPACEBAR: 0x2C,
       RALT: 0xE6,
       RMETA: 0xE7,
       MENU: 0x76,
       RCONTROL: 0xE4,
       INSERT: 0x49,
       HOME: 0x4A,
       PAGEUP: 0x4B,
       DELETEFORWARD: 0x4C,
       END: 0x4D,
       PAGEDOWN: 0x4E,
       UPARROW: 0x52,
       LEFTARROW: 0x50,
       DOWNARROW: 0x51,
       RIGHTARROW: 0x4F,
       PAD_NUMLOCK_CLEAR: 0x53,
       PAD_EQUALS: 0x67,
       PAD_DIVIDE: 0x54,
       PAD_MULTIPLY: 0x55,
       PAD_MINUS: 0x56,
       PAD_7_HOME: 0x5F,
       PAD_8_UPARROW: 0x60,
       PAD_9_PAGEUP: 0x61,
       PAD_PLUS: 0x57,
       PAD_4_LEFTARROW: 0x5C,
       PAD_5: 0x5D,
       PAD_6_RIGHTARROW: 0x5E,
       PAD_COMMA: 0x85,
       PAD_1_END: 0x59,
       PAD_2_DOWNARROW: 0x5A,
       PAD_3_PAGEDOWN: 0x5B,
       PAD_0_INSERT: 0x62,
       PAD_DECIMAL_DELETE: 0x63,
       PAD_ENTER: 0x58,
       F13: 0x68,
       F14: 0x69,
       F15: 0x6A,
       F16: 0x6B,
       F17: 0x6C,
       F18: 0x6D,
       F19: 0x6E,
       F20: 0x6F,
       F21: 0x70,
       F22: 0x71,
       F23: 0x72,
       F24: 0x73,
       INTERNATIONAL1: 0x87,
       INTERNATIONAL2: 0x88,
       INTERNATIONAL3: 0x89,
       INTERNATIONAL4: 0x8A,
       INTERNATIONAL5: 0x8B,
       INTERNATIONAL6: 0x8C,
       INTERNATIONAL7: 0x8D,
       INTERNATIONAL8: 0x8E,
       INTERNATIONAL9: 0x8F,
       LANG1: 0x90,
       LANG2: 0x91,
       LANG3: 0x92,
       LANG4: 0x93,
       LANG5: 0x94,
       HELP: 0x75,
       MUTE: 0x7F,
       VOLUMEUP: 0x80,
       VOLUMEDOWN: 0x81},
    KEY_STATE = {UP: 0, DOWN: 1},
    KEY_STATE_TAG = {UP: 0, DOWN: 1},
    KEY_TAG =
      {ESCAPE: 0,
       F1: 1,
       F2: 2,
       F3: 3,
       F4: 4,
       F5: 5,
       F6: 6,
       F7: 7,
       F8: 8,
       F9: 9,
       F10: 10,
       F11: 11,
       F12: 12,
       PRINTSCREEN: 13,
       SCROLLLOCK: 14,
       PAUSE: 15,
       GRAVE_TILDE: 16,
       _1_EXCLAMATION: 17,
       _2_AT: 18,
       _3_NUMBER: 19,
       _4_DOLLAR: 20,
       _5_PERCENT: 21,
       _6_CARET: 22,
       _7_AMPERSAND: 23,
       _8_ASTERISK: 24,
       _9_LPARENTHESIS: 25,
       _0_RPARENTHESIS: 26,
       MINUS_UNDERSCORE: 27,
       EQUAL_PLUS: 28,
       BACKSPACE: 29,
       TAB: 30,
       Q: 31,
       W: 32,
       E: 33,
       R: 34,
       T: 35,
       Y: 36,
       U: 37,
       I: 38,
       O: 39,
       P: 40,
       LBRACKET_CURLY: 41,
       RBRACKET_CURLY: 42,
       BACKSLASH_PIPE: 43,
       CAPSLOCK: 44,
       A: 45,
       S: 46,
       D: 47,
       F: 48,
       G: 49,
       H: 50,
       J: 51,
       K: 52,
       L: 53,
       SEMICOLON_COLON: 54,
       QUOTE_DOUBLEQUOTE: 55,
       NONUS_NUMBER_TILDE: 56,
       RETURN: 57,
       LSHIFT: 58,
       NONUS_BACKSLASH_PIPE: 59,
       Z: 60,
       X: 61,
       C: 62,
       V: 63,
       B: 64,
       N: 65,
       M: 66,
       COMMA_LESS: 67,
       PERIOD_GREATER: 68,
       SLASH_QUESTION: 69,
       RSHIFT: 70,
       LCONTROL: 71,
       LMETA: 72,
       LALT: 73,
       SPACEBAR: 74,
       RALT: 75,
       RMETA: 76,
       MENU: 77,
       RCONTROL: 78,
       INSERT: 79,
       HOME: 80,
       PAGEUP: 81,
       DELETEFORWARD: 82,
       END: 83,
       PAGEDOWN: 84,
       UPARROW: 85,
       LEFTARROW: 86,
       DOWNARROW: 87,
       RIGHTARROW: 88,
       PAD_NUMLOCK_CLEAR: 89,
       PAD_EQUALS: 90,
       PAD_DIVIDE: 91,
       PAD_MULTIPLY: 92,
       PAD_MINUS: 93,
       PAD_7_HOME: 94,
       PAD_8_UPARROW: 95,
       PAD_9_PAGEUP: 96,
       PAD_PLUS: 97,
       PAD_4_LEFTARROW: 98,
       PAD_5: 99,
       PAD_6_RIGHTARROW: 100,
       PAD_COMMA: 101,
       PAD_1_END: 102,
       PAD_2_DOWNARROW: 103,
       PAD_3_PAGEDOWN: 104,
       PAD_0_INSERT: 105,
       PAD_DECIMAL_DELETE: 106,
       PAD_ENTER: 107,
       F13: 108,
       F14: 109,
       F15: 110,
       F16: 111,
       F17: 112,
       F18: 113,
       F19: 114,
       F20: 115,
       F21: 116,
       F22: 117,
       F23: 118,
       F24: 119,
       INTERNATIONAL1: 120,
       INTERNATIONAL2: 121,
       INTERNATIONAL3: 122,
       INTERNATIONAL4: 123,
       INTERNATIONAL5: 124,
       INTERNATIONAL6: 125,
       INTERNATIONAL7: 126,
       INTERNATIONAL8: 127,
       INTERNATIONAL9: 128,
       LANG1: 129,
       LANG2: 130,
       LANG3: 131,
       LANG4: 132,
       LANG5: 133,
       HELP: 134,
       MUTE: 135,
       VOLUMEUP: 136,
       VOLUMEDOWN: 137},
    tag_to_kc =
      new
       joo_global_object.Map
       ([[KEY_TAG.ESCAPE, KEY.ESCAPE],
         [KEY_TAG.F1, KEY.F1],
         [KEY_TAG.F2, KEY.F2],
         [KEY_TAG.F3, KEY.F3],
         [KEY_TAG.F4, KEY.F4],
         [KEY_TAG.F5, KEY.F5],
         [KEY_TAG.F6, KEY.F6],
         [KEY_TAG.F7, KEY.F7],
         [KEY_TAG.F8, KEY.F8],
         [KEY_TAG.F9, KEY.F9],
         [KEY_TAG.F10, KEY.F10],
         [KEY_TAG.F11, KEY.F11],
         [KEY_TAG.F12, KEY.F12],
         [KEY_TAG.PRINTSCREEN, KEY.PRINTSCREEN],
         [KEY_TAG.SCROLLLOCK, KEY.SCROLLLOCK],
         [KEY_TAG.PAUSE, KEY.PAUSE],
         [KEY_TAG.GRAVE_TILDE, KEY.GRAVE_TILDE],
         [KEY_TAG._1_EXCLAMATION, KEY._1_EXCLAMATION],
         [KEY_TAG._2_AT, KEY._2_AT],
         [KEY_TAG._3_NUMBER, KEY._3_NUMBER],
         [KEY_TAG._4_DOLLAR, KEY._4_DOLLAR],
         [KEY_TAG._5_PERCENT, KEY._5_PERCENT],
         [KEY_TAG._6_CARET, KEY._6_CARET],
         [KEY_TAG._7_AMPERSAND, KEY._7_AMPERSAND],
         [KEY_TAG._8_ASTERISK, KEY._8_ASTERISK],
         [KEY_TAG._9_LPARENTHESIS, KEY._9_LPARENTHESIS],
         [KEY_TAG._0_RPARENTHESIS, KEY._0_RPARENTHESIS],
         [KEY_TAG.MINUS_UNDERSCORE, KEY.MINUS_UNDERSCORE],
         [KEY_TAG.EQUAL_PLUS, KEY.EQUAL_PLUS],
         [KEY_TAG.BACKSPACE, KEY.BACKSPACE],
         [KEY_TAG.TAB, KEY.TAB],
         [KEY_TAG.Q, KEY.Q],
         [KEY_TAG.W, KEY.W],
         [KEY_TAG.E, KEY.E],
         [KEY_TAG.R, KEY.R],
         [KEY_TAG.T, KEY.T],
         [KEY_TAG.Y, KEY.Y],
         [KEY_TAG.U, KEY.U],
         [KEY_TAG.I, KEY.I],
         [KEY_TAG.O, KEY.O],
         [KEY_TAG.P, KEY.P],
         [KEY_TAG.LBRACKET_CURLY, KEY.LBRACKET_CURLY],
         [KEY_TAG.RBRACKET_CURLY, KEY.RBRACKET_CURLY],
         [KEY_TAG.BACKSLASH_PIPE, KEY.BACKSLASH_PIPE],
         [KEY_TAG.CAPSLOCK, KEY.CAPSLOCK],
         [KEY_TAG.A, KEY.A],
         [KEY_TAG.S, KEY.S],
         [KEY_TAG.D, KEY.D],
         [KEY_TAG.F, KEY.F],
         [KEY_TAG.G, KEY.G],
         [KEY_TAG.H, KEY.H],
         [KEY_TAG.J, KEY.J],
         [KEY_TAG.K, KEY.K],
         [KEY_TAG.L, KEY.L],
         [KEY_TAG.SEMICOLON_COLON, KEY.SEMICOLON_COLON],
         [KEY_TAG.QUOTE_DOUBLEQUOTE, KEY.QUOTE_DOUBLEQUOTE],
         [KEY_TAG.NONUS_NUMBER_TILDE, KEY.NONUS_NUMBER_TILDE],
         [KEY_TAG.RETURN, KEY.RETURN],
         [KEY_TAG.LSHIFT, KEY.LSHIFT],
         [KEY_TAG.NONUS_BACKSLASH_PIPE, KEY.NONUS_BACKSLASH_PIPE],
         [KEY_TAG.Z, KEY.Z],
         [KEY_TAG.X, KEY.X],
         [KEY_TAG.C, KEY.C],
         [KEY_TAG.V, KEY.V],
         [KEY_TAG.B, KEY.B],
         [KEY_TAG.N, KEY.N],
         [KEY_TAG.M, KEY.M],
         [KEY_TAG.COMMA_LESS, KEY.COMMA_LESS],
         [KEY_TAG.PERIOD_GREATER, KEY.PERIOD_GREATER],
         [KEY_TAG.SLASH_QUESTION, KEY.SLASH_QUESTION],
         [KEY_TAG.RSHIFT, KEY.RSHIFT],
         [KEY_TAG.LCONTROL, KEY.LCONTROL],
         [KEY_TAG.LMETA, KEY.LMETA],
         [KEY_TAG.LALT, KEY.LALT],
         [KEY_TAG.SPACEBAR, KEY.SPACEBAR],
         [KEY_TAG.RALT, KEY.RALT],
         [KEY_TAG.RMETA, KEY.RMETA],
         [KEY_TAG.MENU, KEY.MENU],
         [KEY_TAG.RCONTROL, KEY.RCONTROL],
         [KEY_TAG.INSERT, KEY.INSERT],
         [KEY_TAG.HOME, KEY.HOME],
         [KEY_TAG.PAGEUP, KEY.PAGEUP],
         [KEY_TAG.DELETEFORWARD, KEY.DELETEFORWARD],
         [KEY_TAG.END, KEY.END],
         [KEY_TAG.PAGEDOWN, KEY.PAGEDOWN],
         [KEY_TAG.UPARROW, KEY.UPARROW],
         [KEY_TAG.LEFTARROW, KEY.LEFTARROW],
         [KEY_TAG.DOWNARROW, KEY.DOWNARROW],
         [KEY_TAG.RIGHTARROW, KEY.RIGHTARROW],
         [KEY_TAG.PAD_NUMLOCK_CLEAR, KEY.PAD_NUMLOCK_CLEAR],
         [KEY_TAG.PAD_EQUALS, KEY.PAD_EQUALS],
         [KEY_TAG.PAD_DIVIDE, KEY.PAD_DIVIDE],
         [KEY_TAG.PAD_MULTIPLY, KEY.PAD_MULTIPLY],
         [KEY_TAG.PAD_MINUS, KEY.PAD_MINUS],
         [KEY_TAG.PAD_7_HOME, KEY.PAD_7_HOME],
         [KEY_TAG.PAD_8_UPARROW, KEY.PAD_8_UPARROW],
         [KEY_TAG.PAD_9_PAGEUP, KEY.PAD_9_PAGEUP],
         [KEY_TAG.PAD_PLUS, KEY.PAD_PLUS],
         [KEY_TAG.PAD_4_LEFTARROW, KEY.PAD_4_LEFTARROW],
         [KEY_TAG.PAD_5, KEY.PAD_5],
         [KEY_TAG.PAD_6_RIGHTARROW, KEY.PAD_6_RIGHTARROW],
         [KEY_TAG.PAD_COMMA, KEY.PAD_COMMA],
         [KEY_TAG.PAD_1_END, KEY.PAD_1_END],
         [KEY_TAG.PAD_2_DOWNARROW, KEY.PAD_2_DOWNARROW],
         [KEY_TAG.PAD_3_PAGEDOWN, KEY.PAD_3_PAGEDOWN],
         [KEY_TAG.PAD_0_INSERT, KEY.PAD_0_INSERT],
         [KEY_TAG.PAD_DECIMAL_DELETE, KEY.PAD_DECIMAL_DELETE],
         [KEY_TAG.PAD_ENTER, KEY.PAD_ENTER],
         [KEY_TAG.F13, KEY.F13],
         [KEY_TAG.F14, KEY.F14],
         [KEY_TAG.F15, KEY.F15],
         [KEY_TAG.F16, KEY.F16],
         [KEY_TAG.F17, KEY.F17],
         [KEY_TAG.F18, KEY.F18],
         [KEY_TAG.F19, KEY.F19],
         [KEY_TAG.F20, KEY.F20],
         [KEY_TAG.F21, KEY.F21],
         [KEY_TAG.F22, KEY.F22],
         [KEY_TAG.F23, KEY.F23],
         [KEY_TAG.F24, KEY.F24],
         [KEY_TAG.INTERNATIONAL1, KEY.INTERNATIONAL1],
         [KEY_TAG.INTERNATIONAL2, KEY.INTERNATIONAL2],
         [KEY_TAG.INTERNATIONAL3, KEY.INTERNATIONAL3],
         [KEY_TAG.INTERNATIONAL4, KEY.INTERNATIONAL4],
         [KEY_TAG.INTERNATIONAL5, KEY.INTERNATIONAL5],
         [KEY_TAG.INTERNATIONAL6, KEY.INTERNATIONAL6],
         [KEY_TAG.INTERNATIONAL7, KEY.INTERNATIONAL7],
         [KEY_TAG.INTERNATIONAL8, KEY.INTERNATIONAL8],
         [KEY_TAG.INTERNATIONAL9, KEY.INTERNATIONAL9],
         [KEY_TAG.LANG1, KEY.LANG1],
         [KEY_TAG.LANG2, KEY.LANG2],
         [KEY_TAG.LANG3, KEY.LANG3],
         [KEY_TAG.LANG4, KEY.LANG4],
         [KEY_TAG.LANG5, KEY.LANG5],
         [KEY_TAG.HELP, KEY.HELP],
         [KEY_TAG.MUTE, KEY.MUTE],
         [KEY_TAG.VOLUMEUP, KEY.VOLUMEUP],
         [KEY_TAG.VOLUMEDOWN, KEY.VOLUMEDOWN]]);
   function Key_code_val(keycode){return tag_to_kc.get(keycode);}
   function caml_str_repeat(n, s){
    if(n == 0) return "";
    if(s.repeat) return s.repeat(n);
    var r = "", l = 0;
    for(;;){
     if(n & 1) r += s;
     n >>= 1;
     if(n == 0) return r;
     s += s;
     l++;
     if(l == 9) s.slice(0, 1);
    }
   }
   function caml_convert_string_to_bytes(s){
    if(s.t == 2)
     s.c += caml_str_repeat(s.l - s.c.length, "\0");
    else
     s.c = caml_subarray_to_jsbytes(s.c, 0, s.c.length);
    s.t = 0;
   }
   function jsoo_is_ascii(s){
    if(s.length < 24){
     for(var i = 0; i < s.length; i++) if(s.charCodeAt(i) > 127) return false;
     return true;
    }
    else
     return ! /[^\x00-\x7f]/.test(s);
   }
   function caml_utf16_of_utf8(s){
    for(var b = "", t = "", c, c1, c2, v, i = 0, l = s.length; i < l; i++){
     c1 = s.charCodeAt(i);
     if(c1 < 0x80){
      for(var j = i + 1; j < l && (c1 = s.charCodeAt(j)) < 0x80; j++) ;
      if(j - i > 512){
       t.substr(0, 1);
       b += t;
       t = "";
       b += s.slice(i, j);
      }
      else
       t += s.slice(i, j);
      if(j == l) break;
      i = j;
     }
     v = 1;
     if(++i < l && ((c2 = s.charCodeAt(i)) & - 64) == 128){
      c = c2 + (c1 << 6);
      if(c1 < 0xe0){
       v = c - 0x3080;
       if(v < 0x80) v = 1;
      }
      else{
       v = 2;
       if(++i < l && ((c2 = s.charCodeAt(i)) & - 64) == 128){
        c = c2 + (c << 6);
        if(c1 < 0xf0){
         v = c - 0xe2080;
         if(v < 0x800 || v >= 0xd7ff && v < 0xe000) v = 2;
        }
        else{
         v = 3;
         if(++i < l && ((c2 = s.charCodeAt(i)) & - 64) == 128 && c1 < 0xf5){
          v = c2 - 0x3c82080 + (c << 6);
          if(v < 0x10000 || v > 0x10ffff) v = 3;
         }
        }
       }
      }
     }
     if(v < 4){
      i -= v;
      t += "\ufffd";
     }
     else if(v > 0xffff)
      t += String.fromCharCode(0xd7c0 + (v >> 10), 0xdc00 + (v & 0x3FF));
     else
      t += String.fromCharCode(v);
     if(t.length > 1024){t.substr(0, 1); b += t; t = "";}
    }
    return b + t;
   }
   function MlBytes(tag, contents, length){
    this.t = tag;
    this.c = contents;
    this.l = length;
   }
   MlBytes.prototype.toString =
    function(){
     switch(this.t){
       case 9:
        return this.c;
       default: caml_convert_string_to_bytes(this);
       case 0:
        if(jsoo_is_ascii(this.c)){this.t = 9; return this.c;} this.t = 8;
       case 8:
        return this.c;
     }
    };
   MlBytes.prototype.toUtf16 =
    function(){
     var r = this.toString();
     if(this.t == 9) return r;
     return caml_utf16_of_utf8(r);
    };
   MlBytes.prototype.slice =
    function(){
     var content = this.t == 4 ? this.c.slice() : this.c;
     return new MlBytes(this.t, content, this.l);
    };
   function caml_utf8_of_utf16(s){
    for(var b = "", t = b, c, d, i = 0, l = s.length; i < l; i++){
     c = s.charCodeAt(i);
     if(c < 0x80){
      for(var j = i + 1; j < l && (c = s.charCodeAt(j)) < 0x80; j++) ;
      if(j - i > 512){
       t.substr(0, 1);
       b += t;
       t = "";
       b += s.slice(i, j);
      }
      else
       t += s.slice(i, j);
      if(j == l) break;
      i = j;
     }
     if(c < 0x800){
      t += String.fromCharCode(0xc0 | c >> 6);
      t += String.fromCharCode(0x80 | c & 0x3f);
     }
     else if(c < 0xd800 || c >= 0xdfff)
      t +=
       String.fromCharCode
        (0xe0 | c >> 12, 0x80 | c >> 6 & 0x3f, 0x80 | c & 0x3f);
     else if
      (c >= 0xdbff || i + 1 == l || (d = s.charCodeAt(i + 1)) < 0xdc00
       || d > 0xdfff)
      t += "\xef\xbf\xbd";
     else{
      i++;
      c = (c << 10) + d - 0x35fdc00;
      t +=
       String.fromCharCode
        (0xf0 | c >> 18,
         0x80 | c >> 12 & 0x3f,
         0x80 | c >> 6 & 0x3f,
         0x80 | c & 0x3f);
     }
     if(t.length > 1024){t.substr(0, 1); b += t; t = "";}
    }
    return b + t;
   }
   function caml_string_of_jsstring(s){
    return jsoo_is_ascii(s)
            ? caml_string_of_jsbytes(s)
            : caml_string_of_jsbytes(caml_utf8_of_utf16(s));
   }
   var
    unix_error =
      ["E2BIG",
       "EACCES",
       "EAGAIN",
       "EBADF",
       "EBUSY",
       "ECHILD",
       "EDEADLK",
       "EDOM",
       "EEXIST",
       "EFAULT",
       "EFBIG",
       "EINTR",
       "EINVAL",
       "EIO",
       "EISDIR",
       "EMFILE",
       "EMLINK",
       "ENAMETOOLONG",
       "ENFILE",
       "ENODEV",
       "ENOENT",
       "ENOEXEC",
       "ENOLCK",
       "ENOMEM",
       "ENOSPC",
       "ENOSYS",
       "ENOTDIR",
       "ENOTEMPTY",
       "ENOTTY",
       "ENXIO",
       "EPERM",
       "EPIPE",
       "ERANGE",
       "EROFS",
       "ESPIPE",
       "ESRCH",
       "EXDEV",
       "EWOULDBLOCK",
       "EINPROGRESS",
       "EALREADY",
       "ENOTSOCK",
       "EDESTADDRREQ",
       "EMSGSIZE",
       "EPROTOTYPE",
       "ENOPROTOOPT",
       "EPROTONOSUPPORT",
       "ESOCKTNOSUPPORT",
       "EOPNOTSUPP",
       "EPFNOSUPPORT",
       "EAFNOSUPPORT",
       "EADDRINUSE",
       "EADDRNOTAVAIL",
       "ENETDOWN",
       "ENETUNREACH",
       "ENETRESET",
       "ECONNABORTED",
       "ECONNRESET",
       "ENOBUFS",
       "EISCONN",
       "ENOTCONN",
       "ESHUTDOWN",
       "ETOOMANYREFS",
       "ETIMEDOUT",
       "ECONNREFUSED",
       "EHOSTDOWN",
       "EHOSTUNREACH",
       "ELOOP",
       "EOVERFLOW"];
   function make_unix_err_args(code, syscall, path, errno){
    var variant = unix_error.indexOf(code);
    if(variant < 0){if(errno == null) errno = - 9999; variant = [0, errno];}
    var
     args =
       [variant,
        caml_string_of_jsstring(syscall || ""),
        caml_string_of_jsstring(path || "")];
    return args;
   }
   var caml_named_values = {};
   function caml_named_value(nm){return caml_named_values[nm];}
   function jsoo_sys_getenv(n){
    var process = globalThis.process;
    if(process && process.env && process.env[n] != undefined)
     return process.env[n];
    if(globalThis.jsoo_static_env && globalThis.jsoo_static_env[n])
     return globalThis.jsoo_static_env[n];
   }
   var caml_record_backtrace_flag = 0;
   (function(){
      var r = jsoo_sys_getenv("OCAMLRUNPARAM");
      if(r !== undefined){
       var l = r.split(",");
       for(var i = 0; i < l.length; i++)
        if(l[i] == "b"){
         caml_record_backtrace_flag = 1;
         break;
        }
        else if(l[i].startsWith("b="))
         caml_record_backtrace_flag = + l[i].slice(2);
        else
         continue;
      }
     }
     ());
   var caml_global_data = [0];
   function caml_exn_with_js_backtrace(exn, force){
    if(! exn.js_error || force || exn[0] == 248)
     exn.js_error = new globalThis.Error("Js exception containing backtrace");
    return exn;
   }
   function caml_maybe_attach_backtrace(exn, force){
    return caml_record_backtrace_flag
            ? caml_exn_with_js_backtrace(exn, force)
            : exn;
   }
   function caml_raise_with_args(tag, args){
    throw caml_maybe_attach_backtrace([0, tag].concat(args));
   }
   function caml_is_ml_bytes(s){return s instanceof MlBytes;}
   function caml_is_ml_string(s){
    return typeof s === "string" && ! /[^\x00-\xff]/.test(s);
   }
   function caml_bytes_of_array(a){
    if(! (a instanceof Uint8Array)) a = new Uint8Array(a);
    return new MlBytes(4, a, a.length);
   }
   function caml_bytes_of_jsbytes(s){return new MlBytes(0, s, s.length);}
   function caml_jsbytes_of_string(x){return x;}
   function caml_bytes_of_string(s){
    return caml_bytes_of_jsbytes(caml_jsbytes_of_string(s));
   }
   function caml_raise_with_arg(tag, arg){
    throw caml_maybe_attach_backtrace([0, tag, arg]);
   }
   function caml_raise_with_string(tag, msg){
    caml_raise_with_arg(tag, caml_string_of_jsbytes(msg));
   }
   function caml_raise_sys_error(msg){
    caml_raise_with_string(caml_global_data.Sys_error, msg);
   }
   function caml_raise_no_such_file(name){
    caml_raise_sys_error(name + ": No such file or directory");
   }
   function caml_convert_bytes_to_array(s){
    var a = new Uint8Array(s.l), b = s.c, l = b.length, i = 0;
    for(; i < l; i++) a[i] = b.charCodeAt(i);
    for(l = s.l; i < l; i++) a[i] = 0;
    s.c = a;
    s.t = 4;
    return a;
   }
   function caml_uint8_array_of_bytes(s){
    if(s.t != 4) caml_convert_bytes_to_array(s);
    return s.c;
   }
   function caml_invalid_argument(msg){
    caml_raise_with_string(caml_global_data.Invalid_argument, msg);
   }
   function caml_create_bytes(len){
    if(len < 0) caml_invalid_argument("Bytes.create");
    return new MlBytes(len ? 2 : 9, "", len);
   }
   function caml_ml_bytes_length(s){return s.l;}
   function caml_blit_bytes(s1, i1, s2, i2, len){
    if(len == 0) return 0;
    if(i2 == 0 && (len >= s2.l || s2.t == 2 && len >= s2.c.length)){
     s2.c =
      s1.t == 4
       ? caml_subarray_to_jsbytes(s1.c, i1, len)
       : i1 == 0 && s1.c.length == len ? s1.c : s1.c.substr(i1, len);
     s2.t = s2.c.length == s2.l ? 0 : 2;
    }
    else if(s2.t == 2 && i2 == s2.c.length){
     s2.c +=
      s1.t == 4
       ? caml_subarray_to_jsbytes(s1.c, i1, len)
       : i1 == 0 && s1.c.length == len ? s1.c : s1.c.substr(i1, len);
     s2.t = s2.c.length == s2.l ? 0 : 2;
    }
    else{
     if(s2.t != 4) caml_convert_bytes_to_array(s2);
     var c1 = s1.c, c2 = s2.c;
     if(s1.t == 4)
      if(i2 <= i1)
       for(var i = 0; i < len; i++) c2[i2 + i] = c1[i1 + i];
      else
       for(var i = len - 1; i >= 0; i--) c2[i2 + i] = c1[i1 + i];
     else{
      var l = Math.min(len, c1.length - i1);
      for(var i = 0; i < l; i++) c2[i2 + i] = c1.charCodeAt(i1 + i);
      for(; i < len; i++) c2[i2 + i] = 0;
     }
    }
    return 0;
   }
   function MlFile(){}
   function MlFakeFile(content){this.data = content;}
   MlFakeFile.prototype = new MlFile();
   MlFakeFile.prototype.constructor = MlFakeFile;
   MlFakeFile.prototype.truncate =
    function(len){
     var old = this.data;
     this.data = caml_create_bytes(len | 0);
     caml_blit_bytes(old, 0, this.data, 0, len);
    };
   MlFakeFile.prototype.length =
    function(){return caml_ml_bytes_length(this.data);};
   MlFakeFile.prototype.write =
    function(offset, buf, pos, len){
     var clen = this.length();
     if(offset + len >= clen){
      var new_str = caml_create_bytes(offset + len), old_data = this.data;
      this.data = new_str;
      caml_blit_bytes(old_data, 0, this.data, 0, clen);
     }
     caml_blit_bytes(caml_bytes_of_array(buf), pos, this.data, offset, len);
     return 0;
    };
   MlFakeFile.prototype.read =
    function(offset, buf, pos, len){
     var clen = this.length();
     if(offset + len >= clen) len = clen - offset;
     if(len){
      var data = caml_create_bytes(len | 0);
      caml_blit_bytes(this.data, offset, data, 0, len);
      buf.set(caml_uint8_array_of_bytes(data), pos);
     }
     return len;
    };
   function MlFakeFd(name, file, flags){
    this.file = file;
    this.name = name;
    this.flags = flags;
   }
   MlFakeFd.prototype.err_closed =
    function(){
     caml_raise_sys_error(this.name + ": file descriptor already closed");
    };
   MlFakeFd.prototype.length =
    function(){if(this.file) return this.file.length(); this.err_closed();};
   MlFakeFd.prototype.write =
    function(offset, buf, pos, len){
     if(this.file) return this.file.write(offset, buf, pos, len);
     this.err_closed();
    };
   MlFakeFd.prototype.read =
    function(offset, buf, pos, len){
     if(this.file) return this.file.read(offset, buf, pos, len);
     this.err_closed();
    };
   MlFakeFd.prototype.close = function(){this.file = undefined;};
   function MlFakeDevice(root, f){
    this.content = {};
    this.root = root;
    this.lookupFun = f;
   }
   MlFakeDevice.prototype.nm = function(name){return this.root + name;};
   MlFakeDevice.prototype.create_dir_if_needed =
    function(name){
     var comp = name.split("/"), res = "";
     for(var i = 0; i < comp.length - 1; i++){
      res += comp[i] + "/";
      if(this.content[res]) continue;
      this.content[res] = Symbol("directory");
     }
    };
   MlFakeDevice.prototype.slash =
    function(name){return /\/$/.test(name) ? name : name + "/";};
   MlFakeDevice.prototype.lookup =
    function(name){
     if(! this.content[name] && this.lookupFun){
      var
       res =
         this.lookupFun
          (caml_string_of_jsbytes(this.root), caml_string_of_jsbytes(name));
      if(res !== 0){
       this.create_dir_if_needed(name);
       this.content[name] = new MlFakeFile(caml_bytes_of_string(res[1]));
      }
     }
    };
   MlFakeDevice.prototype.exists =
    function(name){
     if(name == "") return 1;
     var name_slash = this.slash(name);
     if(this.content[name_slash]) return 1;
     this.lookup(name);
     return this.content[name] ? 1 : 0;
    };
   MlFakeDevice.prototype.isFile =
    function(name){return this.exists(name) && ! this.is_dir(name) ? 1 : 0;};
   MlFakeDevice.prototype.mkdir =
    function(name, mode, raise_unix){
     var unix_error = raise_unix && caml_named_value("Unix.Unix_error");
     if(this.exists(name))
      if(unix_error)
       caml_raise_with_args
        (unix_error, make_unix_err_args("EEXIST", "mkdir", this.nm(name)));
      else
       caml_raise_sys_error(name + ": File exists");
     var parent = /^(.*)\/[^/]+/.exec(name);
     parent = parent && parent[1] || "";
     if(! this.exists(parent))
      if(unix_error)
       caml_raise_with_args
        (unix_error, make_unix_err_args("ENOENT", "mkdir", this.nm(parent)));
      else
       caml_raise_sys_error(parent + ": No such file or directory");
     if(! this.is_dir(parent))
      if(unix_error)
       caml_raise_with_args
        (unix_error, make_unix_err_args("ENOTDIR", "mkdir", this.nm(parent)));
      else
       caml_raise_sys_error(parent + ": Not a directory");
     this.create_dir_if_needed(this.slash(name));
    };
   MlFakeDevice.prototype.rmdir =
    function(name, raise_unix){
     var
      unix_error = raise_unix && caml_named_value("Unix.Unix_error"),
      name_slash = name == "" ? "" : this.slash(name),
      r = new RegExp("^" + name_slash + "([^/]+)");
     if(! this.exists(name))
      if(unix_error)
       caml_raise_with_args
        (unix_error, make_unix_err_args("ENOENT", "rmdir", this.nm(name)));
      else
       caml_raise_sys_error(name + ": No such file or directory");
     if(! this.is_dir(name))
      if(unix_error)
       caml_raise_with_args
        (unix_error, make_unix_err_args("ENOTDIR", "rmdir", this.nm(name)));
      else
       caml_raise_sys_error(name + ": Not a directory");
     for(var n in this.content)
      if(n.match(r))
       if(unix_error)
        caml_raise_with_args
         (unix_error, make_unix_err_args("ENOTEMPTY", "rmdir", this.nm(name)));
       else
        caml_raise_sys_error(this.nm(name) + ": Directory not empty");
     delete this.content[name_slash];
    };
   MlFakeDevice.prototype.readdir =
    function(name){
     var name_slash = name == "" ? "" : this.slash(name);
     if(! this.exists(name))
      caml_raise_sys_error(name + ": No such file or directory");
     if(! this.is_dir(name)) caml_raise_sys_error(name + ": Not a directory");
     var r = new RegExp("^" + name_slash + "([^/]+)"), seen = {}, a = [];
     for(var n in this.content){
      var m = n.match(r);
      if(m && ! seen[m[1]]){seen[m[1]] = true; a.push(m[1]);}
     }
     return a;
    };
   MlFakeDevice.prototype.opendir =
    function(name, raise_unix){
     var
      unix_error = raise_unix && caml_named_value("Unix.Unix_error"),
      a = this.readdir(name),
      c = false,
      i = 0;
     return {readSync:
             function(){
              if(c)
               if(unix_error)
                caml_raise_with_args
                 (unix_error,
                  make_unix_err_args("EBADF", "closedir", this.nm(name)));
               else
                caml_raise_sys_error(name + ": closedir failed");
              if(i == a.length) return null;
              var entry = a[i];
              i++;
              return {name: entry};
             },
             closeSync:
             function(){
              if(c)
               if(unix_error)
                caml_raise_with_args
                 (unix_error,
                  make_unix_err_args("EBADF", "closedir", this.nm(name)));
               else
                caml_raise_sys_error(name + ": closedir failed");
              c = true;
              a = [];
             }};
    };
   MlFakeDevice.prototype.is_dir =
    function(name){
     if(name == "") return true;
     var name_slash = this.slash(name);
     return this.content[name_slash] ? 1 : 0;
    };
   MlFakeDevice.prototype.unlink =
    function(name){
     var ok = this.content[name] ? true : false;
     delete this.content[name];
     return ok;
    };
   MlFakeDevice.prototype.open =
    function(name, f){
     var file;
     if(f.rdonly && f.wronly)
      caml_raise_sys_error
       (this.nm(name)
        + " : flags Open_rdonly and Open_wronly are not compatible");
     if(f.text && f.binary)
      caml_raise_sys_error
       (this.nm(name)
        + " : flags Open_text and Open_binary are not compatible");
     this.lookup(name);
     if(this.content[name]){
      if(this.is_dir(name))
       caml_raise_sys_error(this.nm(name) + " : is a directory");
      if(f.create && f.excl)
       caml_raise_sys_error(this.nm(name) + " : file already exists");
      file = this.content[name];
      if(f.truncate) file.truncate();
     }
     else if(f.create){
      this.create_dir_if_needed(name);
      this.content[name] = new MlFakeFile(caml_create_bytes(0));
      file = this.content[name];
     }
     else
      caml_raise_no_such_file(this.nm(name));
     return new MlFakeFd(this.nm(name), file, f);
    };
   MlFakeDevice.prototype.open =
    function(name, f){
     var file;
     if(f.rdonly && f.wronly)
      caml_raise_sys_error
       (this.nm(name)
        + " : flags Open_rdonly and Open_wronly are not compatible");
     if(f.text && f.binary)
      caml_raise_sys_error
       (this.nm(name)
        + " : flags Open_text and Open_binary are not compatible");
     this.lookup(name);
     if(this.content[name]){
      if(this.is_dir(name))
       caml_raise_sys_error(this.nm(name) + " : is a directory");
      if(f.create && f.excl)
       caml_raise_sys_error(this.nm(name) + " : file already exists");
      file = this.content[name];
      if(f.truncate) file.truncate();
     }
     else if(f.create){
      this.create_dir_if_needed(name);
      this.content[name] = new MlFakeFile(caml_create_bytes(0));
      file = this.content[name];
     }
     else
      caml_raise_no_such_file(this.nm(name));
     return new MlFakeFd(this.nm(name), file, f);
    };
   MlFakeDevice.prototype.register =
    function(name, content){
     var file;
     if(this.content[name])
      caml_raise_sys_error(this.nm(name) + " : file already exists");
     if(caml_is_ml_bytes(content)) file = new MlFakeFile(content);
     if(caml_is_ml_string(content))
      file = new MlFakeFile(caml_bytes_of_string(content));
     else if(content instanceof Array)
      file = new MlFakeFile(caml_bytes_of_array(content));
     else if(typeof content === "string")
      file = new MlFakeFile(caml_bytes_of_jsbytes(content));
     else if(content.toString){
      var
       bytes =
         caml_bytes_of_string(caml_string_of_jsstring(content.toString()));
      file = new MlFakeFile(bytes);
     }
     if(file){
      this.create_dir_if_needed(name);
      this.content[name] = file;
     }
     else
      caml_raise_sys_error
       (this.nm(name) + " : registering file with invalid content type");
    };
   MlFakeDevice.prototype.constructor = MlFakeDevice;
   function MlFakeFd_out(fd, flags){
    MlFakeFile.call(this, caml_create_bytes(0));
    this.log = function(s){return 0;};
    if(fd == 1 && typeof console.log == "function")
     this.log = console.log;
    else if(fd == 2 && typeof console.error == "function")
     this.log = console.error;
    else if(typeof console.log == "function") this.log = console.log;
    this.flags = flags;
   }
   MlFakeFd_out.prototype.length = function(){return 0;};
   MlFakeFd_out.prototype.write =
    function(offset, buf, pos, len){
     if(this.log){
      if
       (len > 0 && pos >= 0 && pos + len <= buf.length
        && buf[pos + len - 1] == 10)
       len--;
      var src = caml_create_bytes(len);
      caml_blit_bytes(caml_bytes_of_array(buf), pos, src, 0, len);
      this.log(src.toUtf16());
      return 0;
     }
     caml_raise_sys_error(this.fd + ": file descriptor already closed");
    };
   MlFakeFd_out.prototype.read =
    function(offset, buf, pos, len){
     caml_raise_sys_error(this.fd + ": file descriptor is write only");
    };
   MlFakeFd_out.prototype.close = function(){this.log = undefined;};
   var caml_int64_offset = Math.pow(2, - 24);
   function caml_raise_constant(tag){throw tag;}
   function caml_raise_zero_divide(){
    caml_raise_constant(caml_global_data.Division_by_zero);
   }
   function MlInt64(lo, mi, hi){
    this.lo = lo & 0xffffff;
    this.mi = mi & 0xffffff;
    this.hi = hi & 0xffff;
   }
   MlInt64.prototype.caml_custom = "_j";
   MlInt64.prototype.copy =
    function(){return new MlInt64(this.lo, this.mi, this.hi);};
   MlInt64.prototype.ucompare =
    function(x){
     if(this.hi > x.hi) return 1;
     if(this.hi < x.hi) return - 1;
     if(this.mi > x.mi) return 1;
     if(this.mi < x.mi) return - 1;
     if(this.lo > x.lo) return 1;
     if(this.lo < x.lo) return - 1;
     return 0;
    };
   MlInt64.prototype.compare =
    function(x){
     var hi = this.hi << 16, xhi = x.hi << 16;
     if(hi > xhi) return 1;
     if(hi < xhi) return - 1;
     if(this.mi > x.mi) return 1;
     if(this.mi < x.mi) return - 1;
     if(this.lo > x.lo) return 1;
     if(this.lo < x.lo) return - 1;
     return 0;
    };
   MlInt64.prototype.neg =
    function(){
     var
      lo = - this.lo,
      mi = - this.mi + (lo >> 24),
      hi = - this.hi + (mi >> 24);
     return new MlInt64(lo, mi, hi);
    };
   MlInt64.prototype.add =
    function(x){
     var
      lo = this.lo + x.lo,
      mi = this.mi + x.mi + (lo >> 24),
      hi = this.hi + x.hi + (mi >> 24);
     return new MlInt64(lo, mi, hi);
    };
   MlInt64.prototype.sub =
    function(x){
     var
      lo = this.lo - x.lo,
      mi = this.mi - x.mi + (lo >> 24),
      hi = this.hi - x.hi + (mi >> 24);
     return new MlInt64(lo, mi, hi);
    };
   MlInt64.prototype.mul =
    function(x){
     var
      lo = this.lo * x.lo,
      mi = (lo * caml_int64_offset | 0) + this.mi * x.lo + this.lo * x.mi,
      hi =
        (mi * caml_int64_offset | 0) + this.hi * x.lo + this.mi * x.mi
        + this.lo * x.hi;
     return new MlInt64(lo, mi, hi);
    };
   MlInt64.prototype.isZero =
    function(){return (this.lo | this.mi | this.hi) == 0;};
   MlInt64.prototype.isNeg = function(){return this.hi << 16 < 0;};
   MlInt64.prototype.and =
    function(x){
     return new MlInt64(this.lo & x.lo, this.mi & x.mi, this.hi & x.hi);
    };
   MlInt64.prototype.or =
    function(x){
     return new MlInt64(this.lo | x.lo, this.mi | x.mi, this.hi | x.hi);
    };
   MlInt64.prototype.xor =
    function(x){
     return new MlInt64(this.lo ^ x.lo, this.mi ^ x.mi, this.hi ^ x.hi);
    };
   MlInt64.prototype.shift_left =
    function(s){
     s = s & 63;
     if(s == 0) return this;
     if(s < 24)
      return new
              MlInt64
              (this.lo << s,
               this.mi << s | this.lo >> 24 - s,
               this.hi << s | this.mi >> 24 - s);
     if(s < 48)
      return new
              MlInt64
              (0, this.lo << s - 24, this.mi << s - 24 | this.lo >> 48 - s);
     return new MlInt64(0, 0, this.lo << s - 48);
    };
   MlInt64.prototype.shift_right_unsigned =
    function(s){
     s = s & 63;
     if(s == 0) return this;
     if(s < 24)
      return new
              MlInt64
              (this.lo >> s | this.mi << 24 - s,
               this.mi >> s | this.hi << 24 - s,
               this.hi >> s);
     if(s < 48)
      return new
              MlInt64
              (this.mi >> s - 24 | this.hi << 48 - s, this.hi >> s - 24, 0);
     return new MlInt64(this.hi >> s - 48, 0, 0);
    };
   MlInt64.prototype.shift_right =
    function(s){
     s = s & 63;
     if(s == 0) return this;
     var h = this.hi << 16 >> 16;
     if(s < 24)
      return new
              MlInt64
              (this.lo >> s | this.mi << 24 - s,
               this.mi >> s | h << 24 - s,
               this.hi << 16 >> s >>> 16);
     var sign = this.hi << 16 >> 31;
     if(s < 48)
      return new
              MlInt64
              (this.mi >> s - 24 | this.hi << 48 - s,
               this.hi << 16 >> s - 24 >> 16,
               sign & 0xffff);
     return new MlInt64(this.hi << 16 >> s - 32, sign, sign);
    };
   MlInt64.prototype.lsl1 =
    function(){
     this.hi = this.hi << 1 | this.mi >> 23;
     this.mi = (this.mi << 1 | this.lo >> 23) & 0xffffff;
     this.lo = this.lo << 1 & 0xffffff;
    };
   MlInt64.prototype.lsr1 =
    function(){
     this.lo = (this.lo >>> 1 | this.mi << 23) & 0xffffff;
     this.mi = (this.mi >>> 1 | this.hi << 23) & 0xffffff;
     this.hi = this.hi >>> 1;
    };
   MlInt64.prototype.udivmod =
    function(x){
     var
      offset = 0,
      modulus = this.copy(),
      divisor = x.copy(),
      quotient = new MlInt64(0, 0, 0);
     while(modulus.ucompare(divisor) > 0){offset++; divisor.lsl1();}
     while(offset >= 0){
      offset--;
      quotient.lsl1();
      if(modulus.ucompare(divisor) >= 0){
       quotient.lo++;
       modulus = modulus.sub(divisor);
      }
      divisor.lsr1();
     }
     return {quotient: quotient, modulus: modulus};
    };
   MlInt64.prototype.div =
    function(y){
     var x = this;
     if(y.isZero()) caml_raise_zero_divide();
     var sign = x.hi ^ y.hi;
     if(x.hi & 0x8000) x = x.neg();
     if(y.hi & 0x8000) y = y.neg();
     var q = x.udivmod(y).quotient;
     if(sign & 0x8000) q = q.neg();
     return q;
    };
   MlInt64.prototype.mod =
    function(y){
     var x = this;
     if(y.isZero()) caml_raise_zero_divide();
     var sign = x.hi;
     if(x.hi & 0x8000) x = x.neg();
     if(y.hi & 0x8000) y = y.neg();
     var r = x.udivmod(y).modulus;
     if(sign & 0x8000) r = r.neg();
     return r;
    };
   MlInt64.prototype.toInt = function(){return this.lo | this.mi << 24;};
   MlInt64.prototype.toFloat =
    function(){
     return (this.hi << 16) * Math.pow(2, 32) + this.mi * Math.pow(2, 24)
            + this.lo;
    };
   MlInt64.prototype.toArray =
    function(){
     return [this.hi >> 8,
             this.hi & 0xff,
             this.mi >> 16,
             this.mi >> 8 & 0xff,
             this.mi & 0xff,
             this.lo >> 16,
             this.lo >> 8 & 0xff,
             this.lo & 0xff];
    };
   MlInt64.prototype.lo32 =
    function(){return this.lo | (this.mi & 0xff) << 24;};
   MlInt64.prototype.hi32 =
    function(){return this.mi >>> 8 & 0xffff | this.hi << 16;};
   function MlMutex(){this.locked = false;}
   function MlNat(x){
    this.data = new Int32Array(x);
    this.length = this.data.length + 2;
   }
   MlNat.prototype.caml_custom = "_nat";
   function caml_ml_string_length(s){return s.length;}
   function caml_string_unsafe_get(s, i){return s.charCodeAt(i);}
   function caml_uint8_array_of_string(s){
    var l = caml_ml_string_length(s), a = new Uint8Array(l), i = 0;
    for(; i < l; i++) a[i] = caml_string_unsafe_get(s, i);
    return a;
   }
   function caml_bytes_bound_error(){
    caml_invalid_argument("index out of bounds");
   }
   function caml_bytes_unsafe_set(s, i, c){
    c &= 0xff;
    if(s.t != 4){
     if(i == s.c.length){
      s.c += String.fromCharCode(c);
      if(i + 1 == s.l) s.t = 0;
      return 0;
     }
     caml_convert_bytes_to_array(s);
    }
    s.c[i] = c;
    return 0;
   }
   function caml_bytes_set(s, i, c){
    if(i >>> 0 >= s.l) caml_bytes_bound_error();
    return caml_bytes_unsafe_set(s, i, c);
   }
   function MlNodeFd(fd, flags){
    this.fs = require("fs");
    this.fd = fd;
    this.flags = flags;
   }
   MlNodeFd.prototype = new MlFile();
   MlNodeFd.prototype.constructor = MlNodeFd;
   MlNodeFd.prototype.truncate =
    function(len){
     try{this.fs.ftruncateSync(this.fd, len | 0);}
     catch(err){caml_raise_sys_error(err.toString());}
    };
   MlNodeFd.prototype.length =
    function(){
     try{return this.fs.fstatSync(this.fd).size;}
     catch(err){caml_raise_sys_error(err.toString());}
    };
   MlNodeFd.prototype.write =
    function(offset, buf, buf_offset, len){
     try{
      if(this.flags.isCharacterDevice)
       this.fs.writeSync(this.fd, buf, buf_offset, len);
      else
       this.fs.writeSync(this.fd, buf, buf_offset, len, offset);
     }
     catch(err){caml_raise_sys_error(err.toString());}
     return 0;
    };
   MlNodeFd.prototype.read =
    function(offset, a, buf_offset, len){
     try{
      if(this.flags.isCharacterDevice)
       var read = this.fs.readSync(this.fd, a, buf_offset, len);
      else
       var read = this.fs.readSync(this.fd, a, buf_offset, len, offset);
      return read;
     }
     catch(err){caml_raise_sys_error(err.toString());}
    };
   MlNodeFd.prototype.close =
    function(){
     try{this.fs.closeSync(this.fd); return 0;}
     catch(err){caml_raise_sys_error(err.toString());}
    };
   function MlNodeDevice(root){this.fs = require("fs"); this.root = root;}
   MlNodeDevice.prototype.nm = function(name){return this.root + name;};
   MlNodeDevice.prototype.exists =
    function(name){
     try{return this.fs.existsSync(this.nm(name)) ? 1 : 0;}
     catch(err){return 0;}
    };
   MlNodeDevice.prototype.isFile =
    function(name){
     try{return this.fs.statSync(this.nm(name)).isFile() ? 1 : 0;}
     catch(err){caml_raise_sys_error(err.toString());}
    };
   MlNodeDevice.prototype.mkdir =
    function(name, mode, raise_unix){
     try{this.fs.mkdirSync(this.nm(name), {mode: mode}); return 0;}
     catch(err){this.raise_nodejs_error(err, raise_unix);}
    };
   MlNodeDevice.prototype.rmdir =
    function(name, raise_unix){
     try{this.fs.rmdirSync(this.nm(name)); return 0;}
     catch(err){this.raise_nodejs_error(err, raise_unix);}
    };
   MlNodeDevice.prototype.readdir =
    function(name, raise_unix){
     try{return this.fs.readdirSync(this.nm(name));}
     catch(err){this.raise_nodejs_error(err, raise_unix);}
    };
   MlNodeDevice.prototype.is_dir =
    function(name){
     try{return this.fs.statSync(this.nm(name)).isDirectory() ? 1 : 0;}
     catch(err){caml_raise_sys_error(err.toString());}
    };
   MlNodeDevice.prototype.unlink =
    function(name, raise_unix){
     try{
      var b = this.fs.existsSync(this.nm(name)) ? 1 : 0;
      this.fs.unlinkSync(this.nm(name));
      return b;
     }
     catch(err){this.raise_nodejs_error(err, raise_unix);}
    };
   MlNodeDevice.prototype.open =
    function(name, f, raise_unix){
     var consts = require("constants"), res = 0;
     for(var key in f)
      switch(key){
        case "rdonly":
         res |= consts.O_RDONLY; break;
        case "wronly":
         res |= consts.O_WRONLY; break;
        case "append":
         res |= consts.O_WRONLY | consts.O_APPEND; break;
        case "create":
         res |= consts.O_CREAT; break;
        case "truncate":
         res |= consts.O_TRUNC; break;
        case "excl":
         res |= consts.O_EXCL; break;
        case "binary":
         res |= consts.O_BINARY; break;
        case "text":
         res |= consts.O_TEXT; break;
        case "nonblock":
         res |= consts.O_NONBLOCK; break;
      }
     try{
      var
       fd = this.fs.openSync(this.nm(name), res),
       isCharacterDevice =
         this.fs.lstatSync(this.nm(name)).isCharacterDevice();
      f.isCharacterDevice = isCharacterDevice;
      return new MlNodeFd(fd, f);
     }
     catch(err){this.raise_nodejs_error(err, raise_unix);}
    };
   MlNodeDevice.prototype.rename =
    function(o, n, raise_unix){
     try{this.fs.renameSync(this.nm(o), this.nm(n));}
     catch(err){this.raise_nodejs_error(err, raise_unix);}
    };
   MlNodeDevice.prototype.stat =
    function(name, raise_unix){
     try{
      var js_stats = this.fs.statSync(this.nm(name));
      return this.stats_from_js(js_stats);
     }
     catch(err){this.raise_nodejs_error(err, raise_unix);}
    };
   MlNodeDevice.prototype.lstat =
    function(name, raise_unix){
     try{
      var js_stats = this.fs.lstatSync(this.nm(name));
      return this.stats_from_js(js_stats);
     }
     catch(err){this.raise_nodejs_error(err, raise_unix);}
    };
   MlNodeDevice.prototype.symlink =
    function(to_dir, target, path, raise_unix){
     try{
      this.fs.symlinkSync
       (this.nm(target), this.nm(path), to_dir ? "dir" : "file");
      return 0;
     }
     catch(err){this.raise_nodejs_error(err, raise_unix);}
    };
   MlNodeDevice.prototype.readlink =
    function(name, raise_unix){
     try{
      var link = this.fs.readlinkSync(this.nm(name), "utf8");
      return caml_string_of_jsstring(link);
     }
     catch(err){this.raise_nodejs_error(err, raise_unix);}
    };
   MlNodeDevice.prototype.opendir =
    function(name, raise_unix){
     try{return this.fs.opendirSync(this.nm(name));}
     catch(err){this.raise_nodejs_error(err, raise_unix);}
    };
   MlNodeDevice.prototype.raise_nodejs_error =
    function(err, raise_unix){
     var unix_error = caml_named_value("Unix.Unix_error");
     if(raise_unix && unix_error){
      var
       args = make_unix_err_args(err.code, err.syscall, err.path, err.errno);
      caml_raise_with_args(unix_error, args);
     }
     else
      caml_raise_sys_error(err.toString());
    };
   MlNodeDevice.prototype.stats_from_js =
    function(js_stats){
     var file_kind;
     if(js_stats.isFile())
      file_kind = 0;
     else if(js_stats.isDirectory())
      file_kind = 1;
     else if(js_stats.isCharacterDevice())
      file_kind = 2;
     else if(js_stats.isBlockDevice())
      file_kind = 3;
     else if(js_stats.isSymbolicLink())
      file_kind = 4;
     else if(js_stats.isFIFO())
      file_kind = 5;
     else if(js_stats.isSocket()) file_kind = 6;
     return [0,
             js_stats.dev,
             js_stats.ino,
             file_kind,
             js_stats.mode,
             js_stats.nlink,
             js_stats.uid,
             js_stats.gid,
             js_stats.rdev,
             js_stats.size,
             js_stats.atimeMs,
             js_stats.mtimeMs,
             js_stats.ctimeMs];
    };
   MlNodeDevice.prototype.constructor = MlNodeDevice;
   var MlObjectTable;
   if(typeof globalThis.Map === "undefined")
    MlObjectTable =
     function(){
       function NaiveLookup(objs){this.objs = objs;}
       NaiveLookup.prototype.get =
        function(v){
         for(var i = 0; i < this.objs.length; i++)
          if(this.objs[i] === v) return i;
        };
       NaiveLookup.prototype.set = function(){};
       return function(){
        this.objs = [];
        this.lookup = new NaiveLookup(this.objs);};
      }
      ();
   else
    MlObjectTable =
     function(){this.objs = []; this.lookup = new globalThis.Map();};
   MlObjectTable.prototype.store =
    function(v){this.lookup.set(v, this.objs.length); this.objs.push(v);};
   MlObjectTable.prototype.recall =
    function(v){
     var i = this.lookup.get(v);
     return i === undefined ? undefined : this.objs.length - i;
    };
   function MlStringReader(s, i){
    this.s = caml_jsbytes_of_string(s);
    this.i = i;
   }
   MlStringReader.prototype =
    {read8u: function(){return this.s.charCodeAt(this.i++);},
     read8s: function(){return this.s.charCodeAt(this.i++) << 24 >> 24;},
     read16u:
     function(){
      var s = this.s, i = this.i;
      this.i = i + 2;
      return s.charCodeAt(i) << 8 | s.charCodeAt(i + 1);
     },
     read16s:
     function(){
      var s = this.s, i = this.i;
      this.i = i + 2;
      return s.charCodeAt(i) << 24 >> 16 | s.charCodeAt(i + 1);
     },
     read32u:
     function(){
      var s = this.s, i = this.i;
      this.i = i + 4;
      return (s.charCodeAt(i) << 24 | s.charCodeAt(i + 1) << 16
             | s.charCodeAt(i + 2) << 8
             | s.charCodeAt(i + 3))
             >>> 0;
     },
     read32s:
     function(){
      var s = this.s, i = this.i;
      this.i = i + 4;
      return s.charCodeAt(i) << 24 | s.charCodeAt(i + 1) << 16
             | s.charCodeAt(i + 2) << 8
             | s.charCodeAt(i + 3);
     },
     readstr:
     function(len){
      var i = this.i;
      this.i = i + len;
      return caml_string_of_jsbytes(this.s.substring(i, i + len));
     },
     readuint8array:
     function(len){
      var b = new Uint8Array(len), s = this.s, i = this.i;
      for(var j = 0; j < len; j++) b[j] = s.charCodeAt(i + j);
      this.i = i + len;
      return b;
     }};
   function caml_int64_create_lo_hi(lo, hi){
    return new
            MlInt64
            (lo & 0xffffff,
             lo >>> 24 & 0xff | (hi & 0xffff) << 8,
             hi >>> 16 & 0xffff);
   }
   function caml_int64_hi32(v){return v.hi32();}
   function caml_int64_lo32(v){return v.lo32();}
   function caml_array_bound_error(){
    caml_invalid_argument("index out of bounds");
   }
   var caml_ba_custom_name = "_bigarr02";
   function Ml_Bigarray(kind, layout, dims, buffer){
    this.kind = kind;
    this.layout = layout;
    this.dims = dims;
    this.data = buffer;
   }
   Ml_Bigarray.prototype.caml_custom = caml_ba_custom_name;
   Ml_Bigarray.prototype.offset =
    function(arg){
     var ofs = 0;
     if(typeof arg === "number") arg = [arg];
     if(! (arg instanceof Array))
      caml_invalid_argument("bigarray.js: invalid offset");
     if(this.dims.length != arg.length)
      caml_invalid_argument("Bigarray.get/set: bad number of dimensions");
     if(this.layout == 0)
      for(var i = 0; i < this.dims.length; i++){
       if(arg[i] < 0 || arg[i] >= this.dims[i]) caml_array_bound_error();
       ofs = ofs * this.dims[i] + arg[i];
      }
     else
      for(var i = this.dims.length - 1; i >= 0; i--){
       if(arg[i] < 1 || arg[i] > this.dims[i]) caml_array_bound_error();
       ofs = ofs * this.dims[i] + (arg[i] - 1);
      }
     return ofs;
    };
   Ml_Bigarray.prototype.get =
    function(ofs){
     switch(this.kind){
       case 7:
        var l = this.data[ofs * 2 + 0], h = this.data[ofs * 2 + 1];
        return caml_int64_create_lo_hi(l, h);
       case 10:
       case 11:
        var r = this.data[ofs * 2 + 0], i = this.data[ofs * 2 + 1];
        return [254, r, i];
       default: return this.data[ofs];
     }
    };
   Ml_Bigarray.prototype.set =
    function(ofs, v){
     switch(this.kind){
       case 7:
        this.data[ofs * 2 + 0] = caml_int64_lo32(v);
        this.data[ofs * 2 + 1] = caml_int64_hi32(v);
        break;
       case 10:
       case 11:
        this.data[ofs * 2 + 0] = v[1]; this.data[ofs * 2 + 1] = v[2]; break;
       default: this.data[ofs] = v; break;
     }
     return 0;
    };
   Ml_Bigarray.prototype.fill =
    function(v){
     switch(this.kind){
       case 7:
        var a = caml_int64_lo32(v), b = caml_int64_hi32(v);
        if(a == b)
         this.data.fill(a);
        else
         for(var i = 0; i < this.data.length; i++)
          this.data[i] = i % 2 == 0 ? a : b;
        break;
       case 10:
       case 11:
        var im = v[1], re = v[2];
        if(im == re)
         this.data.fill(im);
        else
         for(var i = 0; i < this.data.length; i++)
          this.data[i] = i % 2 == 0 ? im : re;
        break;
       default: this.data.fill(v); break;
     }
    };
   Ml_Bigarray.prototype.compare =
    function(b, total){
     if(this.layout != b.layout || this.kind != b.kind){
      var k1 = this.kind | this.layout << 8, k2 = b.kind | b.layout << 8;
      return k2 - k1;
     }
     if(this.dims.length != b.dims.length)
      return b.dims.length - this.dims.length;
     for(var i = 0; i < this.dims.length; i++)
      if(this.dims[i] != b.dims[i]) return this.dims[i] < b.dims[i] ? - 1 : 1;
     switch(this.kind){
       case 0:
       case 1:
       case 10:
       case 11:
        var x, y;
        for(var i = 0; i < this.data.length; i++){
         x = this.data[i];
         y = b.data[i];
         if(x < y) return - 1;
         if(x > y) return 1;
         if(x != y){
          if(! total) return NaN;
          if(x == x) return 1;
          if(y == y) return - 1;
         }
        }
        break;
       case 7:
        for(var i = 0; i < this.data.length; i += 2){
         if(this.data[i + 1] < b.data[i + 1]) return - 1;
         if(this.data[i + 1] > b.data[i + 1]) return 1;
         if(this.data[i] >>> 0 < b.data[i] >>> 0) return - 1;
         if(this.data[i] >>> 0 > b.data[i] >>> 0) return 1;
        }
        break;
       case 2:
       case 3:
       case 4:
       case 5:
       case 6:
       case 8:
       case 9:
       case 12:
        for(var i = 0; i < this.data.length; i++){
         if(this.data[i] < b.data[i]) return - 1;
         if(this.data[i] > b.data[i]) return 1;
        }
        break;
     }
     return 0;
    };
   function Ml_Bigarray_c_1_1(kind, layout, dims, buffer){
    this.kind = kind;
    this.layout = layout;
    this.dims = dims;
    this.data = buffer;
   }
   Ml_Bigarray_c_1_1.prototype = new Ml_Bigarray();
   Ml_Bigarray_c_1_1.prototype.offset =
    function(arg){
     if(typeof arg !== "number")
      if(arg instanceof Array && arg.length == 1)
       arg = arg[0];
      else
       caml_invalid_argument("Ml_Bigarray_c_1_1.offset");
     if(arg < 0 || arg >= this.dims[0]) caml_array_bound_error();
     return arg;
    };
   Ml_Bigarray_c_1_1.prototype.get = function(ofs){return this.data[ofs];};
   Ml_Bigarray_c_1_1.prototype.set =
    function(ofs, v){this.data[ofs] = v; return 0;};
   Ml_Bigarray_c_1_1.prototype.fill =
    function(v){this.data.fill(v); return 0;};
   function Optional_bool_val(mlOptBool, def){
    return typeof mlOptBool == "object" ? mlOptBool[1] !== 0 : def;
   }
   function Optional_val(mlOptVal, def){
    return typeof mlOptVal == "object" ? mlOptVal[1] : def;
   }
   var
    REPEAT_TAG = {NO_REPEAT: 0, REPEAT_X: 1, REPEAT_Y: 2, REPEAT_XY: 3},
    tag_to_repeat =
      new
       joo_global_object.Map
       ([[REPEAT_TAG.NO_REPEAT, "no-repeat"],
         [REPEAT_TAG.REPEAT_X, "repeat-x"],
         [REPEAT_TAG.REPEAT_Y, "repeat-y"],
         [REPEAT_TAG.REPEAT_XY, "repeat"]]);
   function Repeat_val(repeat){return tag_to_repeat.get(repeat);}
   var
    SLANT = {ROMAN: "normal", ITALIC: "italic", OBLIQUE: "oblique"},
    SLANT_TAG = {ROMAN: 0, ITALIC: 1, OBLIQUE: 2},
    tag_to_slant =
      new
       joo_global_object.Map
       ([[SLANT_TAG.ROMAN, SLANT.ROMAN],
         [SLANT_TAG.ITALIC, SLANT.ITALIC],
         [SLANT_TAG.OBLIQUE, SLANT.OBLIQUE]]);
   function Slant_val(slant){return tag_to_slant.get(slant);}
   function UInt8ArrayReader(s, i){this.s = s; this.i = i;}
   UInt8ArrayReader.prototype =
    {read8u: function(){return this.s[this.i++];},
     read8s: function(){return this.s[this.i++] << 24 >> 24;},
     read16u:
     function(){
      var s = this.s, i = this.i;
      this.i = i + 2;
      return s[i] << 8 | s[i + 1];
     },
     read16s:
     function(){
      var s = this.s, i = this.i;
      this.i = i + 2;
      return s[i] << 24 >> 16 | s[i + 1];
     },
     read32u:
     function(){
      var s = this.s, i = this.i;
      this.i = i + 4;
      return (s[i] << 24 | s[i + 1] << 16 | s[i + 2] << 8 | s[i + 3]) >>> 0;
     },
     read32s:
     function(){
      var s = this.s, i = this.i;
      this.i = i + 4;
      return s[i] << 24 | s[i + 1] << 16 | s[i + 2] << 8 | s[i + 3];
     },
     readstr:
     function(len){
      var i = this.i;
      this.i = i + len;
      return caml_string_of_array(this.s.subarray(i, i + len));
     },
     readuint8array:
     function(len){
      var i = this.i;
      this.i = i + len;
      return this.s.subarray(i, i + len);
     }};
   var
    button_to_tag =
      new
       joo_global_object.Map
       ([[BUTTON.NONE, BUTTON_TAG.NONE],
         [BUTTON.LEFT, BUTTON_TAG.LEFT],
         [BUTTON.MIDDLE, BUTTON_TAG.MIDDLE],
         [BUTTON.MIDDLE, BUTTON_TAG.RIGHT],
         [BUTTON.WHEEL_UP, BUTTON_TAG.WHEEL_UP],
         [BUTTON.WHEEL_DOWN, BUTTON_TAG.WHEEL_DOWN]]);
   function Val_button(button){return button_to_tag.get(button);}
   var
    button_state_to_tag =
      new
       joo_global_object.Map
       ([[BUTTON_STATE.UP, BUTTON_STATE_TAG.UP],
         [BUTTON_STATE.DOWN, BUTTON_STATE_TAG.DOWN]]);
   function Val_button_state(state){return button_state_to_tag.get(state);}
   var
    cap_type_to_tag =
      new
       joo_global_object.Map
       ([["butt", CAP_TYPE_TAG.BUTT],
         ["square", CAP_TYPE_TAG.SQUARE],
         ["round", CAP_TYPE_TAG.ROUND]]);
   function Val_cap_type(cap){return cap_type_to_tag.get(cap);}
   var
    compop_to_tag =
      new
       joo_global_object.Map
       ([["source-over", COMPOP_TAG.SOURCE_OVER],
         ["source-in", COMPOP_TAG.SOURCE_IN],
         ["source-out", COMPOP_TAG.SOURCE_OUT],
         ["source-atop", COMPOP_TAG.SOURCE_ATOP],
         ["destination-over", COMPOP_TAG.DESTINATION_OVER],
         ["destination-in", COMPOP_TAG.DESTINATION_IN],
         ["destination-out", COMPOP_TAG.DESTINATION_OUT],
         ["destination-atop", COMPOP_TAG.DESTINATION_ATOP],
         ["lighter", COMPOP_TAG.LIGHTER],
         ["copy", COMPOP_TAG.COPY],
         ["xor", COMPOP_TAG.XOR],
         ["multiply", COMPOP_TAG.MULTIPLY],
         ["screen", COMPOP_TAG.SCREEN],
         ["overlay", COMPOP_TAG.OVERLAY],
         ["darken", COMPOP_TAG.DARKEN],
         ["lighten", COMPOP_TAG.LIGHTEN],
         ["color-dodge", COMPOP_TAG.COLOR_DODGE],
         ["color-burn", COMPOP_TAG.COLOR_BURN],
         ["hard-light", COMPOP_TAG.HARD_LIGHT],
         ["soft-light", COMPOP_TAG.SOFT_LIGHT],
         ["difference", COMPOP_TAG.DIFFERENCE],
         ["exclusion", COMPOP_TAG.EXCLUSION],
         ["hue", COMPOP_TAG.HUE],
         ["saturation", COMPOP_TAG.SATURATION],
         ["color", COMPOP_TAG.COLOR],
         ["luminosity", COMPOP_TAG.LUMINOSITY]]);
   function Val_compop(compop){return compop_to_tag.get(compop);}
   function _color_of_int(i){
    var a = (i & 0xFF000000) >>> 24;
    if(a == 255) return "#" + (i & 0x00FFFFFF).toString(16).padStart(6, "0");
    var
     b = i & 0x000000FF,
     g = (i & 0x0000FF00) >>> 8,
     r = (i & 0x00FF0000) >>> 16;
    return "rgba(" + r + "," + g + "," + b + "," + a / 255.0 + ")";
   }
   function Val_draw_style(style){
    var s = 0;
    switch(style[0]){
      case STYLE_TAG.COLOR:
       s = _color_of_int(style[1]); break;
      case STYLE_TAG.GRADIENT:
      case STYLE_TAG.PATTERN: s = style[1]; break;
      default: break;
    }
    return s;
   }
   var
    focus_to_tag =
      new
       joo_global_object.Map
       ([[FOCUS.OUT, FOCUS_TAG.OUT], [FOCUS.IN, FOCUS_TAG.IN]]);
   function Val_focus_in_out(focus){return focus_to_tag.get(focus);}
   var
    join_type_to_tag =
      new
       joo_global_object.Map
       ([["round", JOIN_TYPE_TAG.ROUND],
         ["miter", JOIN_TYPE_TAG.MITER],
         ["bevel", JOIN_TYPE_TAG.BEVEL]]);
   function Val_join_type(join){return join_type_to_tag.get(join);}
   var
    kc_to_tag =
      new
       joo_global_object.Map
       ([[KEY.ESCAPE, KEY_TAG.ESCAPE],
         [KEY.F1, KEY_TAG.F1],
         [KEY.F2, KEY_TAG.F2],
         [KEY.F3, KEY_TAG.F3],
         [KEY.F4, KEY_TAG.F4],
         [KEY.F5, KEY_TAG.F5],
         [KEY.F6, KEY_TAG.F6],
         [KEY.F7, KEY_TAG.F7],
         [KEY.F8, KEY_TAG.F8],
         [KEY.F9, KEY_TAG.F9],
         [KEY.F10, KEY_TAG.F10],
         [KEY.F11, KEY_TAG.F11],
         [KEY.F12, KEY_TAG.F12],
         [KEY.PRINTSCREEN, KEY_TAG.PRINTSCREEN],
         [KEY.SCROLLLOCK, KEY_TAG.SCROLLLOCK],
         [KEY.PAUSE, KEY_TAG.PAUSE],
         [KEY.GRAVE_TILDE, KEY_TAG.GRAVE_TILDE],
         [KEY._1_EXCLAMATION, KEY_TAG._1_EXCLAMATION],
         [KEY._2_AT, KEY_TAG._2_AT],
         [KEY._3_NUMBER, KEY_TAG._3_NUMBER],
         [KEY._4_DOLLAR, KEY_TAG._4_DOLLAR],
         [KEY._5_PERCENT, KEY_TAG._5_PERCENT],
         [KEY._6_CARET, KEY_TAG._6_CARET],
         [KEY._7_AMPERSAND, KEY_TAG._7_AMPERSAND],
         [KEY._8_ASTERISK, KEY_TAG._8_ASTERISK],
         [KEY._9_LPARENTHESIS, KEY_TAG._9_LPARENTHESIS],
         [KEY._0_RPARENTHESIS, KEY_TAG._0_RPARENTHESIS],
         [KEY.MINUS_UNDERSCORE, KEY_TAG.MINUS_UNDERSCORE],
         [KEY.EQUAL_PLUS, KEY_TAG.EQUAL_PLUS],
         [KEY.BACKSPACE, KEY_TAG.BACKSPACE],
         [KEY.TAB, KEY_TAG.TAB],
         [KEY.Q, KEY_TAG.Q],
         [KEY.W, KEY_TAG.W],
         [KEY.E, KEY_TAG.E],
         [KEY.R, KEY_TAG.R],
         [KEY.T, KEY_TAG.T],
         [KEY.Y, KEY_TAG.Y],
         [KEY.U, KEY_TAG.U],
         [KEY.I, KEY_TAG.I],
         [KEY.O, KEY_TAG.O],
         [KEY.P, KEY_TAG.P],
         [KEY.LBRACKET_CURLY, KEY_TAG.LBRACKET_CURLY],
         [KEY.RBRACKET_CURLY, KEY_TAG.RBRACKET_CURLY],
         [KEY.BACKSLASH_PIPE, KEY_TAG.BACKSLASH_PIPE],
         [KEY.CAPSLOCK, KEY_TAG.CAPSLOCK],
         [KEY.A, KEY_TAG.A],
         [KEY.S, KEY_TAG.S],
         [KEY.D, KEY_TAG.D],
         [KEY.F, KEY_TAG.F],
         [KEY.G, KEY_TAG.G],
         [KEY.H, KEY_TAG.H],
         [KEY.J, KEY_TAG.J],
         [KEY.K, KEY_TAG.K],
         [KEY.L, KEY_TAG.L],
         [KEY.SEMICOLON_COLON, KEY_TAG.SEMICOLON_COLON],
         [KEY.QUOTE_DOUBLEQUOTE, KEY_TAG.QUOTE_DOUBLEQUOTE],
         [KEY.NONUS_NUMBER_TILDE, KEY_TAG.NONUS_NUMBER_TILDE],
         [KEY.RETURN, KEY_TAG.RETURN],
         [KEY.LSHIFT, KEY_TAG.LSHIFT],
         [KEY.NONUS_BACKSLASH_PIPE, KEY_TAG.NONUS_BACKSLASH_PIPE],
         [KEY.Z, KEY_TAG.Z],
         [KEY.X, KEY_TAG.X],
         [KEY.C, KEY_TAG.C],
         [KEY.V, KEY_TAG.V],
         [KEY.B, KEY_TAG.B],
         [KEY.N, KEY_TAG.N],
         [KEY.M, KEY_TAG.M],
         [KEY.COMMA_LESS, KEY_TAG.COMMA_LESS],
         [KEY.PERIOD_GREATER, KEY_TAG.PERIOD_GREATER],
         [KEY.SLASH_QUESTION, KEY_TAG.SLASH_QUESTION],
         [KEY.RSHIFT, KEY_TAG.RSHIFT],
         [KEY.LCONTROL, KEY_TAG.LCONTROL],
         [KEY.LMETA, KEY_TAG.LMETA],
         [KEY.LALT, KEY_TAG.LALT],
         [KEY.SPACEBAR, KEY_TAG.SPACEBAR],
         [KEY.RALT, KEY_TAG.RALT],
         [KEY.RMETA, KEY_TAG.RMETA],
         [KEY.MENU, KEY_TAG.MENU],
         [KEY.RCONTROL, KEY_TAG.RCONTROL],
         [KEY.INSERT, KEY_TAG.INSERT],
         [KEY.HOME, KEY_TAG.HOME],
         [KEY.PAGEUP, KEY_TAG.PAGEUP],
         [KEY.DELETEFORWARD, KEY_TAG.DELETEFORWARD],
         [KEY.END, KEY_TAG.END],
         [KEY.PAGEDOWN, KEY_TAG.PAGEDOWN],
         [KEY.UPARROW, KEY_TAG.UPARROW],
         [KEY.LEFTARROW, KEY_TAG.LEFTARROW],
         [KEY.DOWNARROW, KEY_TAG.DOWNARROW],
         [KEY.RIGHTARROW, KEY_TAG.RIGHTARROW],
         [KEY.PAD_NUMLOCK_CLEAR, KEY_TAG.PAD_NUMLOCK_CLEAR],
         [KEY.PAD_EQUALS, KEY_TAG.PAD_EQUALS],
         [KEY.PAD_DIVIDE, KEY_TAG.PAD_DIVIDE],
         [KEY.PAD_MULTIPLY, KEY_TAG.PAD_MULTIPLY],
         [KEY.PAD_MINUS, KEY_TAG.PAD_MINUS],
         [KEY.PAD_7_HOME, KEY_TAG.PAD_7_HOME],
         [KEY.PAD_8_UPARROW, KEY_TAG.PAD_8_UPARROW],
         [KEY.PAD_9_PAGEUP, KEY_TAG.PAD_9_PAGEUP],
         [KEY.PAD_PLUS, KEY_TAG.PAD_PLUS],
         [KEY.PAD_4_LEFTARROW, KEY_TAG.PAD_4_LEFTARROW],
         [KEY.PAD_5, KEY_TAG.PAD_5],
         [KEY.PAD_6_RIGHTARROW, KEY_TAG.PAD_6_RIGHTARROW],
         [KEY.PAD_COMMA, KEY_TAG.PAD_COMMA],
         [KEY.PAD_1_END, KEY_TAG.PAD_1_END],
         [KEY.PAD_2_DOWNARROW, KEY_TAG.PAD_2_DOWNARROW],
         [KEY.PAD_3_PAGEDOWN, KEY_TAG.PAD_3_PAGEDOWN],
         [KEY.PAD_0_INSERT, KEY_TAG.PAD_0_INSERT],
         [KEY.PAD_DECIMAL_DELETE, KEY_TAG.PAD_DECIMAL_DELETE],
         [KEY.PAD_ENTER, KEY_TAG.PAD_ENTER],
         [KEY.F13, KEY_TAG.F13],
         [KEY.F14, KEY_TAG.F14],
         [KEY.F15, KEY_TAG.F15],
         [KEY.F16, KEY_TAG.F16],
         [KEY.F17, KEY_TAG.F17],
         [KEY.F18, KEY_TAG.F18],
         [KEY.F19, KEY_TAG.F19],
         [KEY.F20, KEY_TAG.F20],
         [KEY.F21, KEY_TAG.F21],
         [KEY.F22, KEY_TAG.F22],
         [KEY.F23, KEY_TAG.F23],
         [KEY.F24, KEY_TAG.F24],
         [KEY.INTERNATIONAL1, KEY_TAG.INTERNATIONAL1],
         [KEY.INTERNATIONAL2, KEY_TAG.INTERNATIONAL2],
         [KEY.INTERNATIONAL3, KEY_TAG.INTERNATIONAL3],
         [KEY.INTERNATIONAL4, KEY_TAG.INTERNATIONAL4],
         [KEY.INTERNATIONAL5, KEY_TAG.INTERNATIONAL5],
         [KEY.INTERNATIONAL6, KEY_TAG.INTERNATIONAL6],
         [KEY.INTERNATIONAL7, KEY_TAG.INTERNATIONAL7],
         [KEY.INTERNATIONAL8, KEY_TAG.INTERNATIONAL8],
         [KEY.INTERNATIONAL9, KEY_TAG.INTERNATIONAL9],
         [KEY.LANG1, KEY_TAG.LANG1],
         [KEY.LANG2, KEY_TAG.LANG2],
         [KEY.LANG3, KEY_TAG.LANG3],
         [KEY.LANG4, KEY_TAG.LANG4],
         [KEY.LANG5, KEY_TAG.LANG5],
         [KEY.HELP, KEY_TAG.HELP],
         [KEY.MUTE, KEY_TAG.MUTE],
         [KEY.VOLUMEUP, KEY_TAG.VOLUMEUP],
         [KEY.VOLUMEDOWN, KEY_TAG.VOLUMEDOWN]]);
   function Val_key_code(keycode){return kc_to_tag.get(keycode);}
   var
    key_state_to_tag =
      new
       joo_global_object.Map
       ([[KEY_STATE.UP, KEY_STATE_TAG.UP],
         [KEY_STATE.DOWN, KEY_STATE_TAG.DOWN]]);
   function Val_key_state(state){return key_state_to_tag.get(state);}
   var
    repeat_to_tag =
      new
       joo_global_object.Map
       ([["no-repeat", REPEAT_TAG.NO_REPEAT],
         ["repeat-x", REPEAT_TAG.REPEAT_X],
         ["repeat-y", REPEAT_TAG.REPEAT_Y],
         ["repeat", REPEAT_TAG.REPEAT_XY]]);
   function Val_repeat(repeat){return repeat_to_tag.get(repeat);}
   function _event_canvas_scale(e){
    return {scaleX: e.target.canvas.width / e.target.clientWidth,
            scaleY: e.target.canvas.height / e.target.clientHeight};
   }
   var _focus = null;
   function caml_int64_of_float(x){
    if(x < 0) x = Math.ceil(x);
    return new
            MlInt64
            (x & 0xffffff,
             Math.floor(x * caml_int64_offset) & 0xffffff,
             Math.floor(x * caml_int64_offset * caml_int64_offset) & 0xffff);
   }
   var
    _ml_canvas_mlProcessEvent = null,
    _ml_canvas_mlException = null,
    _ml_canvas_initialized = false;
   function _ml_canvas_ensure_initialized(){
    if(_ml_canvas_initialized == false)
     caml_raise_constant(caml_named_value("Not_initialized"));
   }
   var _ml_canvas_mlContinuation = null;
   function ml_canvas_stop(){
    _ml_canvas_ensure_initialized();
    _ml_canvas_mlProcessEvent = null;
    if(_ml_canvas_mlException !== null){
     var exn = _ml_canvas_mlException;
     _ml_canvas_mlContinuation = null;
     _ml_canvas_mlException = null;
     throw exn;
    }
    else if(_ml_canvas_mlContinuation !== null)
     try{_ml_canvas_mlContinuation(); _ml_canvas_mlContinuation = null;}
     catch(exn){_ml_canvas_mlContinuation = null; throw exn;}
    return 0;
   }
   function _ml_canvas_process_event(mlEvent){
    if(_ml_canvas_mlProcessEvent === null) return false;
    try{_ml_canvas_mlProcessEvent(mlEvent); return true;}
    catch(exn){_ml_canvas_mlException = exn; ml_canvas_stop(); return false;}
   }
   function _frame_handler(timestamp){
    var surfaces = document.getElementsByTagName("canvas");
    for(var i = 0; i < surfaces.length; ++i){
     var
      evt =
        [EVENT_TAG.FRAME,
         [0, surfaces[i].canvas, caml_int64_of_float(timestamp * 1000.0)]];
     _ml_canvas_process_event(evt);
    }
    window.requestAnimationFrame(_frame_handler);
   }
   var _move = {moving: false, target: null, prev_x: 0, prev_y: 0};
   function ml_canvas_hide(canvas){
    if(canvas.frame !== null){
     if(_focus === canvas) _focus = null;
     canvas.frame.style.visibility = "hidden";
    }
    return 0;
   }
   function ml_canvas_close(canvas){
    if(canvas.frame !== null){
     ml_canvas_hide(canvas);
     canvas.name = null;
     if(canvas.surface != null){
      canvas.surface.canvas = null;
      if(canvas.surface.parentNode !== null)
       canvas.surface.parentNode.removeChild(canvas.surface);
     }
     if(canvas.header != null){
      canvas.header.canvas = null;
      if(canvas.header.parentNode !== null)
       canvas.header.parentNode.removeChild(canvas.header);
      canvas.header = null;
     }
     if(canvas.frame !== null){
      canvas.frame.canvas = null;
      if(canvas.frame.parentNode !== null)
       canvas.frame.parentNode.removeChild(canvas.frame);
      canvas.frame = null;
     }
    }
    return 0;
   }
   function _header_down_handler(e){
    if(e.target !== null){
     _focus = e.target.canvas;
     if
      (e.offsetX >= e.target.canvas.width - 20
       && e.offsetX <= e.target.canvas.width - 10
       && e.offsetY >= 10
       && e.offsetY <= 20){
      var
       evt =
         [EVENT_TAG.CANVAS_CLOSED,
          [0, e.target.canvas, caml_int64_of_float(e.timeStamp * 1000.0)]];
      _ml_canvas_process_event(evt);
      ml_canvas_close(e.target.canvas);
      _focus = null;
      return false;
     }
     _move.moving = true;
     _move.target = e.target.canvas.frame;
     _move.prev_x = e.pageX;
     _move.prev_y = e.pageY;
     e.target.canvas.target.insertBefore(_move.target, null);
    }
    return false;
   }
   function _int_of_color(c){
    if(c[0] == "#")
     return parseInt(c.substr(1, c.length - 1), 16);
    else{
     var
      rgba = c.replace(/^rgba?\(|\s+|\)$/g, "").split(","),
      r = parseInt(rgba[0]),
      g = parseInt(rgba[1]),
      b = parseInt(rgba[2]),
      a = parseFloat(rgba[3]) * 255;
     return b | g << 8 | r << 16 | a << 24;
    }
   }
   var
    _internal_canvas = document.createElement("canvas"),
    _internal_ctxt = _internal_canvas.getContext("2d"),
    kn_to_kc =
      new
       joo_global_object.Map
       ([["", KEY.UNDEFINED],
         ["Unidentified", KEY.UNDEFINED],
         ["Escape", KEY.ESCAPE],
         ["F1", KEY.F1],
         ["F2", KEY.F2],
         ["F3", KEY.F3],
         ["F4", KEY.F4],
         ["F5", KEY.F5],
         ["F6", KEY.F6],
         ["F7", KEY.F7],
         ["F8", KEY.F8],
         ["F9", KEY.F9],
         ["F10", KEY.F10],
         ["F11", KEY.F11],
         ["F12", KEY.F12],
         ["PrintScreen", KEY.PRINTSCREEN],
         ["ScrollLock", KEY.SCROLLLOCK],
         ["Pause", KEY.PAUSE],
         ["Backquote", KEY.GRAVE_TILDE],
         ["Digit1", KEY._1_EXCLAMATION],
         ["Digit2", KEY._2_AT],
         ["Digit3", KEY._3_NUMBER],
         ["Digit4", KEY._4_DOLLAR],
         ["Digit5", KEY._5_PERCENT],
         ["Digit6", KEY._6_CARET],
         ["Digit7", KEY._7_AMPERSAND],
         ["Digit8", KEY._8_ASTERISK],
         ["Digit9", KEY._9_LPARENTHESIS],
         ["Digit0", KEY._0_RPARENTHESIS],
         ["Minus", KEY.MINUS_UNDERSCORE],
         ["Equal", KEY.EQUAL_PLUS],
         ["IntlYen", KEY.INTERNATIONAL3],
         ["Backspace", KEY.BACKSPACE],
         ["Tab", KEY.TAB],
         ["KeyQ", KEY.Q],
         ["KeyW", KEY.W],
         ["KeyE", KEY.E],
         ["KeyR", KEY.R],
         ["KeyT", KEY.T],
         ["KeyY", KEY.Y],
         ["KeyU", KEY.U],
         ["KeyI", KEY.I],
         ["KeyO", KEY.O],
         ["KeyP", KEY.P],
         ["BracketLeft", KEY.LBRACKET_CURLY],
         ["BracketRight", KEY.RBRACKET_CURLY],
         ["Backslash", KEY.BACKSLASH_PIPE],
         ["CapsLock", KEY.CAPSLOCK],
         ["KeyA", KEY.A],
         ["KeyS", KEY.S],
         ["KeyD", KEY.D],
         ["KeyF", KEY.F],
         ["KeyG", KEY.G],
         ["KeyH", KEY.H],
         ["KeyJ", KEY.J],
         ["KeyK", KEY.K],
         ["KeyL", KEY.L],
         ["Semicolon", KEY.SEMICOLON_COLON],
         ["Quote", KEY.QUOTE_DOUBLEQUOTE],
         ["Enter", KEY.RETURN],
         ["ShiftLeft", KEY.LSHIFT],
         ["IntlBackslash", KEY.NONUS_BACKSLASH_PIPE],
         ["KeyZ", KEY.Z],
         ["KeyX", KEY.X],
         ["KeyC", KEY.C],
         ["KeyV", KEY.V],
         ["KeyB", KEY.B],
         ["KeyN", KEY.N],
         ["KeyM", KEY.M],
         ["Comma", KEY.COMMA_LESS],
         ["Period", KEY.PERIOD_GREATER],
         ["Slash", KEY.SLASH_QUESTION],
         ["IntlRo", KEY.INTERNATIONAL1],
         ["ShiftRight", KEY.RSHIFT],
         ["ControlLeft", KEY.LCONTROL],
         ["MetaLeft", KEY.LMETA],
         ["AltLeft", KEY.LALT],
         ["NonConvert", KEY.INTERNATIONAL5],
         ["Lang2", KEY.LANG2],
         ["Space", KEY.SPACEBAR],
         ["Lang1", KEY.LANG1],
         ["Convert", KEY.INTERNATIONAL4],
         ["KanaMode", KEY.INTERNATIONAL2],
         ["AltRight", KEY.RALT],
         ["MetaRight", KEY.RMETA],
         ["ContextMenu", KEY.MENU],
         ["ControlRight", KEY.RCONTROL],
         ["Help", KEY.HELP],
         ["Insert", KEY.INSERT],
         ["Home", KEY.HOME],
         ["PageUp", KEY.PAGEUP],
         ["Delete", KEY.DELETEFORWARD],
         ["End", KEY.END],
         ["PageDown", KEY.PAGEDOWN],
         ["ArrowUp", KEY.UPARROW],
         ["ArrowLeft", KEY.LEFTARROW],
         ["ArrowDown", KEY.DOWNARROW],
         ["ArrowRight", KEY.RIGHTARROW],
         ["NumpadLock", KEY.PAD_NUMLOCK_CLEAR],
         ["NumpadEqual", KEY.PAD_EQUALS],
         ["NumpadDivide", KEY.PAD_DIVIDE],
         ["NumpadMultiply", KEY.PAD_MULTIPLY],
         ["NumpadSubtract", KEY.PAD_MINUS],
         ["Numpad7", KEY.PAD_7_HOME],
         ["Numpad8", KEY.PAD_8_UPARROW],
         ["Numpad9", KEY.PAD_9_PAGEUP],
         ["NumpadAdd", KEY.PAD_PLUS],
         ["Numpad4", KEY.PAD_4_LEFTARROW],
         ["Numpad5", KEY.PAD_5],
         ["Numpad6", KEY.PAD_6_RIGHTARROW],
         ["NumpadComma", KEY.PAD_COMMA],
         ["Numpad1", KEY.PAD_1_END],
         ["Numpad2", KEY.PAD_2_DOWNARROW],
         ["Numpad3", KEY.PAD_3_PAGEDOWN],
         ["Numpad0", KEY.PAD_0_INSERT],
         ["NumpadDecimal", KEY.PAD_DECIMAL_DELETE],
         ["NumpadEnter", KEY.PAD_ENTER],
         ["F13", KEY.F13],
         ["F14", KEY.F14],
         ["F15", KEY.F15],
         ["F16", KEY.F16],
         ["F17", KEY.F17],
         ["F18", KEY.F18],
         ["F19", KEY.F19],
         ["F20", KEY.F20],
         ["F21", KEY.F21],
         ["F22", KEY.F22],
         ["F23", KEY.F23],
         ["F24", KEY.F24],
         ["Lang3", KEY.LANG3],
         ["Lang4", KEY.LANG4],
         ["Lang5", KEY.LANG5],
         ["Katakana", KEY.LANG3],
         ["Hiragana", KEY.LANG4],
         ["AudioVolumeDown", KEY.VOLUMEDOWN],
         ["AudioVolumeUp", KEY.VOLUMEUP],
         ["AudioVolumeMute", KEY.MUTE]]);
   function keyname_to_keycode(keyname){return kn_to_kc.get(keyname);}
   function _make_key_event(e, state){
    var
     char = e.key.length === 1 ? e.key.charCodeAt(0) : 0,
     flags =
       [0,
        e.shiftKey,
        e.altKey,
        e.ctrlKey,
        e.metaKey,
        e.getModifierState("CapsLock"),
        e.getModifierState("NumLock"),
        e.key === "Dead"],
     evt =
       [EVENT_TAG.KEY_ACTION,
        [0,
         _focus,
         caml_int64_of_float(e.timeStamp * 1000.0),
         Val_key_code(keyname_to_keycode(e.code)),
         char,
         flags,
         Val_key_state(state)]];
    return evt;
   }
   function _key_down_handler(e){
    if(_focus !== null){
     var evt = _make_key_event(e, KEY_STATE.DOWN);
     _ml_canvas_process_event(evt);
    }
    return false;
   }
   function _key_up_handler(e){
    if(_focus !== null){
     var evt = _make_key_event(e, KEY_STATE.UP);
     _ml_canvas_process_event(evt);
    }
    return false;
   }
   function _ml_canvas_adjust_blit_info
   (dwidth, dheight, dx, dy, swidth, sheight, sx, sy, width, height){
    if(dx < 0){sx -= dx; width += dx; dx = 0;}
    if(dy < 0){sy -= dy; height += dy; dy = 0;}
    if(sx < 0){dx -= sx; width += sx; sx = 0;}
    if(sy < 0){dy -= sy; height += sy; sy = 0;}
    if(dx + width > dwidth) width = dwidth - dx;
    if(dy + height > dheight) height = dheight - dy;
    if(sx + width > swidth) width = swidth - sx;
    if(sy + height > sheight) height = sheight - sy;
    return [dx, dy, sx, sy, width, height];
   }
   function caml_ba_get_size(dims){
    var n_dims = dims.length, size = 1;
    for(var i = 0; i < n_dims; i++){
     if(dims[i] < 0)
      caml_invalid_argument("Bigarray.create: negative dimension");
     size = size * dims[i];
    }
    return size;
   }
   function caml_ba_get_size_per_element(kind){
    switch(kind){case 7:case 10:case 11: return 2;default: return 1;
    }
   }
   function caml_ba_create_unsafe(kind, layout, dims, data){
    var size_per_element = caml_ba_get_size_per_element(kind);
    if(caml_ba_get_size(dims) * size_per_element != data.length)
     caml_invalid_argument("length doesn't match dims");
    if(layout == 0 && dims.length == 1 && size_per_element == 1)
     return new Ml_Bigarray_c_1_1(kind, layout, dims, data);
    return new Ml_Bigarray(kind, layout, dims, data);
   }
   function _ml_canvas_ba_of_img(img){
    var surface = document.createElement("canvas");
    surface.width = img.width;
    surface.height = img.height;
    var ctxt = surface.getContext("2d");
    ctxt.drawImage(img, 0, 0);
    var
     image = ctxt.getImageData(0, 0, img.width, img.height),
     sta = new window.Uint8Array(image.data.buffer),
     dta = new window.Uint8Array(sta.length);
    for(var i = 0; i < sta.length; i += 4){
     dta[i + 0] = sta[i + 2];
     dta[i + 1] = sta[i + 1];
     dta[i + 2] = sta[i + 0];
     dta[i + 3] = sta[i + 3];
    }
    return caml_ba_create_unsafe(3, 0, [img.height, img.width, 4], dta);
   }
   function caml_jsstring_of_string(s){
    if(jsoo_is_ascii(s)) return s;
    return caml_utf16_of_utf8(s);
   }
   function _ml_canvas_decorate(header, minimize, maximize, close, title){
    var width = header.width, ctxt = header.getContext("2d");
    ctxt.fillStyle = "#585858";
    ctxt.fillRect(0, 0, width, 30);
    if(title !== null){
     ctxt.fillStyle = "#F0F0F0F0";
     ctxt.font = "bold 16px Arial";
     ctxt.textAlign = "center";
     ctxt.fillText(caml_jsstring_of_string(title), width / 2, 21);
    }
    ctxt.strokeStyle = "#F0F0F0F0";
    ctxt.lineWidth = 2.0;
    if(close == true){
     ctxt.beginPath();
     ctxt.moveTo(width - 20, 10);
     ctxt.lineTo(width - 10, 20);
     ctxt.moveTo(width - 20, 20);
     ctxt.lineTo(width - 10, 10);
     ctxt.stroke();
    }
   }
   function fs_node_supported(){
    return typeof globalThis.process !== "undefined"
           && typeof globalThis.process.versions !== "undefined"
           && typeof globalThis.process.versions.node !== "undefined";
   }
   function make_path_is_absolute(){
    function posix(path){
     if(path.charAt(0) === "/") return ["", path.substring(1)];
     return;
    }
    function win32(path){
     var
      splitDeviceRe =
        /^([a-zA-Z]:|[\\/]{2}[^\\/]+[\\/]+[^\\/]+)?([\\/])?([\s\S]*?)$/,
      result = splitDeviceRe.exec(path),
      device = result[1] || "",
      isUnc = Boolean(device && device.charAt(1) !== ":");
     if(Boolean(result[2] || isUnc)){
      var root = result[1] || "", sep = result[2] || "";
      return [root, path.substring(root.length + sep.length)];
     }
     return;
    }
    return fs_node_supported() && globalThis.process
            && globalThis.process.platform
            ? globalThis.process.platform === "win32" ? win32 : posix
            : posix;
   }
   var path_is_absolute = make_path_is_absolute();
   function caml_trailing_slash(name){
    return name.slice(- 1) !== "/" ? name + "/" : name;
   }
   if(fs_node_supported() && globalThis.process && globalThis.process.cwd)
    var caml_current_dir = globalThis.process.cwd().replace(/\\/g, "/");
   else
    var caml_current_dir = "/static";
   caml_current_dir = caml_trailing_slash(caml_current_dir);
   function caml_make_path(name){
    name = caml_jsstring_of_string(name);
    if(! path_is_absolute(name)) name = caml_current_dir + name;
    var
     comp0 = path_is_absolute(name),
     comp = comp0[1].split("/"),
     ncomp = [];
    for(var i = 0; i < comp.length; i++)
     switch(comp[i]){
       case "..":
        if(ncomp.length > 1) ncomp.pop(); break;
       case ".": break;
       case "": break;
       default: ncomp.push(comp[i]); break;
     }
    ncomp.unshift(comp0[0]);
    ncomp.orig = name;
    return ncomp;
   }
   function caml_get_root(path){
    var x = path_is_absolute(path);
    if(! x) return;
    return x[0] + "/";
   }
   function caml_failwith(msg){
    if(! caml_global_data.Failure)
     caml_global_data.Failure = [248, caml_string_of_jsbytes("Failure"), - 3];
    caml_raise_with_string(caml_global_data.Failure, msg);
   }
   var
    caml_root =
      caml_get_root(caml_current_dir)
      || caml_failwith("unable to compute caml_root"),
    jsoo_mount_point = [];
   if(fs_node_supported())
    jsoo_mount_point.push
     ({path: caml_root, device: new MlNodeDevice(caml_root)});
   else
    jsoo_mount_point.push
     ({path: caml_root, device: new MlFakeDevice(caml_root)});
   jsoo_mount_point.push
    ({path: "/static/", device: new MlFakeDevice("/static/")});
   function resolve_fs_device(name){
    var
     path = caml_make_path(name),
     name = path.join("/"),
     name_slash = caml_trailing_slash(name),
     res;
    for(var i = 0; i < jsoo_mount_point.length; i++){
     var m = jsoo_mount_point[i];
     if
      (name_slash.search(m.path) == 0
       && (! res || res.path.length < m.path.length))
      res =
       {path: m.path,
        device: m.device,
        rest: name.substring(m.path.length, name.length)};
    }
    if(! res && fs_node_supported()){
     var root = caml_get_root(name);
     if(root && root.match(/^[a-zA-Z]:\/$/)){
      var m = {path: root, device: new MlNodeDevice(root)};
      jsoo_mount_point.push(m);
      res =
       {path: m.path,
        device: m.device,
        rest: name.substring(m.path.length, name.length)};
     }
    }
    if(res) return res;
    caml_raise_sys_error("no device found for " + name_slash);
   }
   function caml_read_file_content(name){
    var
     name = typeof name == "string" ? caml_string_of_jsbytes(name) : name,
     root = resolve_fs_device(name);
    if(root.device.exists(root.rest)){
     var
      file = root.device.open(root.rest, {rdonly: 1}),
      len = file.length(),
      buf = new Uint8Array(len);
     file.read(0, buf, 0, len);
     return caml_string_of_array(buf);
    }
    caml_raise_no_such_file(caml_jsbytes_of_string(name));
   }
   function _ml_canvas_image_of_png_file(filename){
    var file = caml_read_file_content(filename);
    if(file === null) return null;
    var
     fc = caml_read_file_content(filename),
     data = window.btoa(fc.c === undefined ? fc : fc.c),
     img = new window.Image();
    img.loading = "eager";
    img.decoding = "sync";
    img.src = "data:image/png;base64," + data;
    return [img.decode(), img];
   }
   function caml_ba_dim(ba, i){
    if(i < 0 || i >= ba.dims.length) caml_invalid_argument("Bigarray.dim");
    return ba.dims[i];
   }
   function caml_ba_to_typed_array(ba){return ba.data;}
   function _ml_canvas_surface_of_ba(data){
    var surface = document.createElement("canvas");
    surface.width = caml_ba_dim(data, 1);
    surface.height = caml_ba_dim(data, 0);
    var
     ctxt = surface.getContext("2d"),
     sta = new window.Uint8Array(caml_ba_to_typed_array(data).buffer),
     dta = new window.Uint8ClampedArray(sta.length);
    for(var i = 0; i < sta.length; i += 4){
     dta[i + 0] = sta[i + 2];
     dta[i + 1] = sta[i + 1];
     dta[i + 2] = sta[i + 0];
     dta[i + 3] = sta[i + 3];
    }
    if(window.ImageData === undefined){
     var image = ctxt.createImageData(surface.width, surface.height);
     image.data.set(dta);
    }
    else
     var image = new window.ImageData(dta, surface.width, surface.height);
    ctxt.putImageData(image, 0, 0);
    return surface;
   }
   function _ml_canvas_valid_canvas_size(width, height){
    return 0 < width && width <= 32767 && 0 < height && height <= 32767;
   }
   function _move_handler(e){
    if(_move.moving){
     var
      new_x = e.pageX,
      new_y = e.pageY,
      dx = new_x - _move.prev_x,
      dy = new_y - _move.prev_y;
     _move.prev_x = new_x;
     _move.prev_y = new_y;
     var canvas = _move.target.canvas;
     canvas.x += dx;
     canvas.y += dy;
     _move.target.style.left = canvas.x + "px";
     _move.target.style.top = canvas.y + "px";
    }
    else if(e.target.canvas !== undefined){
     var
      s = _event_canvas_scale(e),
      evt =
        [EVENT_TAG.MOUSE_MOVE,
         [0,
          e.target.canvas,
          caml_int64_of_float(e.timeStamp * 1000.0),
          [0, e.offsetX * s.scaleX, e.offsetY * s.scaleY]]];
     _ml_canvas_process_event(evt);
    }
    return false;
   }
   var _next_id = 0;
   function _resize_handler(entries){
    entries.forEach
     (function(e){
       var
        evt =
          [EVENT_TAG.CANVAS_RESIZED,
           [0,
            e.target.canvas,
            caml_int64_of_float(e.timeStamp * 1000.0),
            [0, e.target.clientWidth, e.target.clientHeight]]];
       _ml_canvas_process_event(evt);
      });
    return false;
   }
   var _resize = new window.ResizeObserver(_resize_handler);
   function _surface_down_handler(e){
    if(e.target !== null){
     _focus = e.target.canvas;
     e.target.canvas.target.insertBefore(e.target.canvas.frame, null);
     var
      s = _event_canvas_scale(e),
      evt =
        [EVENT_TAG.BUTTON_ACTION,
         [0,
          e.target.canvas,
          caml_int64_of_float(e.timeStamp * 1000.0),
          [0, e.offsetX * s.scaleX, e.offsetY * s.scaleY],
          e.button + 1,
          1]];
     _ml_canvas_process_event(evt);
    }
    return false;
   }
   function _up_handler(e){
    _move.moving = false;
    if(e.target.canvas !== undefined){
     var
      s = _event_canvas_scale(e),
      evt =
        [EVENT_TAG.BUTTON_ACTION,
         [0,
          e.target.canvas,
          caml_int64_of_float(e.timeStamp * 1000.0),
          [0, e.offsetX * s.scaleX, e.offsetY * s.scaleY],
          e.button + 1,
          0]];
     _ml_canvas_process_event(evt);
    }
    return false;
   }
   function incr_nat(nat, ofs, len, carry_in){
    var carry = carry_in;
    for(var i = 0; i < len; i++){
     var x = (nat.data[ofs + i] >>> 0) + carry;
     nat.data[ofs + i] = x | 0;
     if(x == x >>> 0){carry = 0; break;} else carry = 1;
    }
    return carry;
   }
   function add_nat(nat1, ofs1, len1, nat2, ofs2, len2, carry_in){
    var carry = carry_in;
    for(var i = 0; i < len2; i++){
     var
      x = (nat1.data[ofs1 + i] >>> 0) + (nat2.data[ofs2 + i] >>> 0) + carry;
     nat1.data[ofs1 + i] = x;
     if(x == x >>> 0) carry = 0; else carry = 1;
    }
    return incr_nat(nat1, ofs1 + len2, len1 - len2, carry);
   }
   function bigstring_of_array_buffer(ab){
    var ta = new Uint8Array(ab);
    return caml_ba_create_unsafe(12, 0, [ta.length], ta);
   }
   function bigstring_of_typed_array(ba){
    var
     ta =
       new
        Uint8Array
        (ba.buffer, ba.byteOffset, ba.length * ba.BYTES_PER_ELEMENT);
    return caml_ba_create_unsafe(12, 0, [ta.length], ta);
   }
   function bigstring_to_array_buffer(bs){return bs.data.buffer;}
   function bigstring_to_typed_array(bs){return bs.data;}
   function blit_nat(nat1, ofs1, nat2, ofs2, len){
    for(var i = 0; i < len; i++) nat1.data[ofs1 + i] = nat2.data[ofs2 + i];
    return 0;
   }
   var
    caml_MD5Transform =
      function(){
        function add(x, y){return x + y | 0;}
        function xx(q, a, b, x, s, t){
         a = add(add(a, q), add(x, t));
         return add(a << s | a >>> 32 - s, b);
        }
        function ff(a, b, c, d, x, s, t){
         return xx(b & c | ~ b & d, a, b, x, s, t);
        }
        function gg(a, b, c, d, x, s, t){
         return xx(b & d | c & ~ d, a, b, x, s, t);
        }
        function hh(a, b, c, d, x, s, t){return xx(b ^ c ^ d, a, b, x, s, t);}
        function ii(a, b, c, d, x, s, t){
         return xx(c ^ (b | ~ d), a, b, x, s, t);
        }
        return function(w, buffer){
         var a = w[0], b = w[1], c = w[2], d = w[3];
         a = ff(a, b, c, d, buffer[0], 7, 0xD76AA478);
         d = ff(d, a, b, c, buffer[1], 12, 0xE8C7B756);
         c = ff(c, d, a, b, buffer[2], 17, 0x242070DB);
         b = ff(b, c, d, a, buffer[3], 22, 0xC1BDCEEE);
         a = ff(a, b, c, d, buffer[4], 7, 0xF57C0FAF);
         d = ff(d, a, b, c, buffer[5], 12, 0x4787C62A);
         c = ff(c, d, a, b, buffer[6], 17, 0xA8304613);
         b = ff(b, c, d, a, buffer[7], 22, 0xFD469501);
         a = ff(a, b, c, d, buffer[8], 7, 0x698098D8);
         d = ff(d, a, b, c, buffer[9], 12, 0x8B44F7AF);
         c = ff(c, d, a, b, buffer[10], 17, 0xFFFF5BB1);
         b = ff(b, c, d, a, buffer[11], 22, 0x895CD7BE);
         a = ff(a, b, c, d, buffer[12], 7, 0x6B901122);
         d = ff(d, a, b, c, buffer[13], 12, 0xFD987193);
         c = ff(c, d, a, b, buffer[14], 17, 0xA679438E);
         b = ff(b, c, d, a, buffer[15], 22, 0x49B40821);
         a = gg(a, b, c, d, buffer[1], 5, 0xF61E2562);
         d = gg(d, a, b, c, buffer[6], 9, 0xC040B340);
         c = gg(c, d, a, b, buffer[11], 14, 0x265E5A51);
         b = gg(b, c, d, a, buffer[0], 20, 0xE9B6C7AA);
         a = gg(a, b, c, d, buffer[5], 5, 0xD62F105D);
         d = gg(d, a, b, c, buffer[10], 9, 0x02441453);
         c = gg(c, d, a, b, buffer[15], 14, 0xD8A1E681);
         b = gg(b, c, d, a, buffer[4], 20, 0xE7D3FBC8);
         a = gg(a, b, c, d, buffer[9], 5, 0x21E1CDE6);
         d = gg(d, a, b, c, buffer[14], 9, 0xC33707D6);
         c = gg(c, d, a, b, buffer[3], 14, 0xF4D50D87);
         b = gg(b, c, d, a, buffer[8], 20, 0x455A14ED);
         a = gg(a, b, c, d, buffer[13], 5, 0xA9E3E905);
         d = gg(d, a, b, c, buffer[2], 9, 0xFCEFA3F8);
         c = gg(c, d, a, b, buffer[7], 14, 0x676F02D9);
         b = gg(b, c, d, a, buffer[12], 20, 0x8D2A4C8A);
         a = hh(a, b, c, d, buffer[5], 4, 0xFFFA3942);
         d = hh(d, a, b, c, buffer[8], 11, 0x8771F681);
         c = hh(c, d, a, b, buffer[11], 16, 0x6D9D6122);
         b = hh(b, c, d, a, buffer[14], 23, 0xFDE5380C);
         a = hh(a, b, c, d, buffer[1], 4, 0xA4BEEA44);
         d = hh(d, a, b, c, buffer[4], 11, 0x4BDECFA9);
         c = hh(c, d, a, b, buffer[7], 16, 0xF6BB4B60);
         b = hh(b, c, d, a, buffer[10], 23, 0xBEBFBC70);
         a = hh(a, b, c, d, buffer[13], 4, 0x289B7EC6);
         d = hh(d, a, b, c, buffer[0], 11, 0xEAA127FA);
         c = hh(c, d, a, b, buffer[3], 16, 0xD4EF3085);
         b = hh(b, c, d, a, buffer[6], 23, 0x04881D05);
         a = hh(a, b, c, d, buffer[9], 4, 0xD9D4D039);
         d = hh(d, a, b, c, buffer[12], 11, 0xE6DB99E5);
         c = hh(c, d, a, b, buffer[15], 16, 0x1FA27CF8);
         b = hh(b, c, d, a, buffer[2], 23, 0xC4AC5665);
         a = ii(a, b, c, d, buffer[0], 6, 0xF4292244);
         d = ii(d, a, b, c, buffer[7], 10, 0x432AFF97);
         c = ii(c, d, a, b, buffer[14], 15, 0xAB9423A7);
         b = ii(b, c, d, a, buffer[5], 21, 0xFC93A039);
         a = ii(a, b, c, d, buffer[12], 6, 0x655B59C3);
         d = ii(d, a, b, c, buffer[3], 10, 0x8F0CCC92);
         c = ii(c, d, a, b, buffer[10], 15, 0xFFEFF47D);
         b = ii(b, c, d, a, buffer[1], 21, 0x85845DD1);
         a = ii(a, b, c, d, buffer[8], 6, 0x6FA87E4F);
         d = ii(d, a, b, c, buffer[15], 10, 0xFE2CE6E0);
         c = ii(c, d, a, b, buffer[6], 15, 0xA3014314);
         b = ii(b, c, d, a, buffer[13], 21, 0x4E0811A1);
         a = ii(a, b, c, d, buffer[4], 6, 0xF7537E82);
         d = ii(d, a, b, c, buffer[11], 10, 0xBD3AF235);
         c = ii(c, d, a, b, buffer[2], 15, 0x2AD7D2BB);
         b = ii(b, c, d, a, buffer[9], 21, 0xEB86D391);
         w[0] = add(a, w[0]);
         w[1] = add(b, w[1]);
         w[2] = add(c, w[2]);
         w[3] = add(d, w[3]);};
       }
       ();
   function caml_MD5Final(ctx){
    var in_buf = ctx.len & 0x3f;
    ctx.b8[in_buf] = 0x80;
    in_buf++;
    if(in_buf > 56){
     for(var j = in_buf; j < 64; j++) ctx.b8[j] = 0;
     caml_MD5Transform(ctx.w, ctx.b32);
     for(var j = 0; j < 56; j++) ctx.b8[j] = 0;
    }
    else
     for(var j = in_buf; j < 56; j++) ctx.b8[j] = 0;
    ctx.b32[14] = ctx.len << 3;
    ctx.b32[15] = ctx.len >> 29 & 0x1FFFFFFF;
    caml_MD5Transform(ctx.w, ctx.b32);
    var t = new Uint8Array(16);
    for(var i = 0; i < 4; i++)
     for(var j = 0; j < 4; j++) t[i * 4 + j] = ctx.w[i] >> 8 * j & 0xFF;
    return t;
   }
   function caml_MD5Init(){
    var
     buffer = new ArrayBuffer(64),
     b32 = new Uint32Array(buffer),
     b8 = new Uint8Array(buffer);
    return {len: 0,
            w:
            new Uint32Array([0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476]),
            b32: b32,
            b8: b8};
   }
   function caml_MD5Update(ctx, input, input_len){
    var in_buf = ctx.len & 0x3f, input_pos = 0;
    ctx.len += input_len;
    if(in_buf){
     var missing = 64 - in_buf;
     if(input_len < missing){
      ctx.b8.set(input.subarray(0, input_len), in_buf);
      return;
     }
     ctx.b8.set(input.subarray(0, missing), in_buf);
     caml_MD5Transform(ctx.w, ctx.b32);
     input_len -= missing;
     input_pos += missing;
    }
    while(input_len >= 64){
     ctx.b8.set(input.subarray(input_pos, input_pos + 64), 0);
     caml_MD5Transform(ctx.w, ctx.b32);
     input_len -= 64;
     input_pos += 64;
    }
    if(input_len)
     ctx.b8.set(input.subarray(input_pos, input_pos + input_len), 0);
   }
   function caml_acosh_float(x){return Math.acosh(x);}
   function caml_call_gen(f, args){
    var
     n = f.l >= 0 ? f.l : f.l = f.length,
     argsLen = args.length,
     d = n - argsLen;
    if(d == 0)
     return f.apply(null, args);
    else if(d < 0){
     var g = f.apply(null, args.slice(0, n));
     if(typeof g !== "function") return g;
     return caml_call_gen(g, args.slice(n));
    }
    else{
     switch(d){
       case 1:
        {
         var
          g =
            function(x){
             var nargs = new Array(argsLen + 1);
             for(var i = 0; i < argsLen; i++) nargs[i] = args[i];
             nargs[argsLen] = x;
             return f.apply(null, nargs);
            };
         break;
        }
       case 2:
        {
         var
          g =
            function(x, y){
             var nargs = new Array(argsLen + 2);
             for(var i = 0; i < argsLen; i++) nargs[i] = args[i];
             nargs[argsLen] = x;
             nargs[argsLen + 1] = y;
             return f.apply(null, nargs);
            };
         break;
        }
       default:
        var
         g =
           function(){
            var
             extra_args = arguments.length == 0 ? 1 : arguments.length,
             nargs = new Array(args.length + extra_args);
            for(var i = 0; i < args.length; i++) nargs[i] = args[i];
            for(var i = 0; i < arguments.length; i++)
             nargs[args.length + i] = arguments[i];
            return caml_call_gen(f, nargs);
           };
     }
     g.l = d;
     return g;
    }
   }
   function caml_alloc_dummy_infix(){
    return function f(x){return caml_call_gen(f.fun, [x]);};
   }
   function caml_alloc_stack(hv, hx, hf){return 0;}
   var
    caml_argv =
      function(){
        var process = globalThis.process, main = "a.out", args = [];
        if(process && process.argv && process.argv.length > 1){
         var argv = process.argv;
         main = argv[1];
         args = argv.slice(2);
        }
        var p = caml_string_of_jsstring(main), args2 = [0, p];
        for(var i = 0; i < args.length; i++)
         args2.push(caml_string_of_jsstring(args[i]));
        return args2;
       }
       ();
   function caml_array_append(a1, a2){
    var l1 = a1.length, l2 = a2.length, l = l1 + l2 - 1, a = new Array(l);
    a[0] = 0;
    var i = 1, j = 1;
    for(; i < l1; i++) a[i] = a1[i];
    for(; i < l; i++, j++) a[i] = a2[j];
    return a;
   }
   function caml_array_blit(a1, i1, a2, i2, len){
    if(i2 <= i1)
     for(var j = 1; j <= len; j++) a2[i2 + j] = a1[i1 + j];
    else
     for(var j = len; j >= 1; j--) a2[i2 + j] = a1[i1 + j];
    return 0;
   }
   function caml_array_concat(l){
    var a = [0];
    while(l !== 0){
     var b = l[1];
     for(var i = 1; i < b.length; i++) a.push(b[i]);
     l = l[2];
    }
    return a;
   }
   function caml_array_fill(array, ofs, len, v){
    for(var i = 0; i < len; i++) array[ofs + i + 1] = v;
    return 0;
   }
   function caml_array_get(array, index){
    if(index < 0 || index >= array.length - 1) caml_array_bound_error();
    return array[index + 1];
   }
   function caml_array_of_bytes(x){return caml_uint8_array_of_bytes(x);}
   function caml_array_of_string(x){return caml_uint8_array_of_string(x);}
   function caml_array_set(array, index, newval){
    if(index < 0 || index >= array.length - 1) caml_array_bound_error();
    array[index + 1] = newval;
    return 0;
   }
   function caml_array_sub(a, i, len){
    var a2 = new Array(len + 1);
    a2[0] = 0;
    for(var i2 = 1, i1 = i + 1; i2 <= len; i2++, i1++) a2[i2] = a[i1];
    return a2;
   }
   function caml_asinh_float(x){return Math.asinh(x);}
   function caml_atanh_float(x){return Math.atanh(x);}
   function caml_atomic_cas(ref, o, n){
    if(ref[1] === o){ref[1] = n; return 1;}
    return 0;
   }
   function caml_atomic_exchange(ref, v){
    var r = ref[1];
    ref[1] = v;
    return r;
   }
   function caml_atomic_fetch_add(ref, i){
    var old = ref[1];
    ref[1] += i;
    return old;
   }
   function caml_atomic_load(ref){return ref[1];}
   function caml_atomic_make_contended(a){return [0, a];}
   function caml_ba_blit(src, dst){
    if(dst.dims.length != src.dims.length)
     caml_invalid_argument("Bigarray.blit: dimension mismatch");
    for(var i = 0; i < dst.dims.length; i++)
     if(dst.dims[i] != src.dims[i])
      caml_invalid_argument("Bigarray.blit: dimension mismatch");
    dst.data.set(src.data);
    return 0;
   }
   function caml_ba_change_layout(ba, layout){
    if(ba.layout == layout) return ba;
    var new_dims = [];
    for(var i = 0; i < ba.dims.length; i++)
     new_dims[i] = ba.dims[ba.dims.length - i - 1];
    return caml_ba_create_unsafe(ba.kind, layout, new_dims, ba.data);
   }
   function caml_ba_compare(a, b, total){return a.compare(b, total);}
   function caml_ba_create_buffer(kind, size){
    var view;
    switch(kind){
      case 0:
       view = Float32Array; break;
      case 1:
       view = Float64Array; break;
      case 2:
       view = Int8Array; break;
      case 3:
       view = Uint8Array; break;
      case 4:
       view = Int16Array; break;
      case 5:
       view = Uint16Array; break;
      case 6:
       view = Int32Array; break;
      case 7:
       view = Int32Array; break;
      case 8:
       view = Int32Array; break;
      case 9:
       view = Int32Array; break;
      case 10:
       view = Float32Array; break;
      case 11:
       view = Float64Array; break;
      case 12:
       view = Uint8Array; break;
    }
    if(! view) caml_invalid_argument("Bigarray.create: unsupported kind");
    var data = new view(size * caml_ba_get_size_per_element(kind));
    return data;
   }
   function caml_js_from_array(a){return a.slice(1);}
   function caml_ba_create(kind, layout, dims_ml){
    var
     dims = caml_js_from_array(dims_ml),
     data = caml_ba_create_buffer(kind, caml_ba_get_size(dims));
    return caml_ba_create_unsafe(kind, layout, dims, data);
   }
   function caml_ba_create_from(data1, data2, jstyp, kind, layout, dims){
    if(data2 || caml_ba_get_size_per_element(kind) == 2)
     caml_invalid_argument
      ("caml_ba_create_from: use return caml_ba_create_unsafe");
    return caml_ba_create_unsafe(kind, layout, dims, data1);
   }
   function caml_int32_float_of_bits(x){
    var int32a = new Int32Array(1);
    int32a[0] = x;
    var float32a = new Float32Array(int32a.buffer);
    return float32a[0];
   }
   function caml_int64_of_bytes(a){
    return new
            MlInt64
            (a[7] << 0 | a[6] << 8 | a[5] << 16,
             a[4] << 0 | a[3] << 8 | a[2] << 16,
             a[1] << 0 | a[0] << 8);
   }
   function caml_int64_float_of_bits(x){
    var lo = x.lo, mi = x.mi, hi = x.hi, exp = (hi & 0x7fff) >> 4;
    if(exp == 2047)
     return (lo | mi | hi & 0xf) == 0
             ? hi & 0x8000 ? - Infinity : Infinity
             : NaN;
    var k = Math.pow(2, - 24), res = (lo * k + mi) * k + (hi & 0xf);
    if(exp > 0){
     res += 16;
     res *= Math.pow(2, exp - 1027);
    }
    else
     res *= Math.pow(2, - 1026);
    if(hi & 0x8000) res = - res;
    return res;
   }
   function caml_ba_deserialize(reader, sz, name){
    var num_dims = reader.read32s();
    if(num_dims < 0 || num_dims > 16)
     caml_failwith("input_value: wrong number of bigarray dimensions");
    var
     tag = reader.read32s(),
     kind = tag & 0xff,
     layout = tag >> 8 & 1,
     dims = [];
    if(name == "_bigarr02")
     for(var i = 0; i < num_dims; i++){
      var size_dim = reader.read16u();
      if(size_dim == 0xffff){
       var size_dim_hi = reader.read32u(), size_dim_lo = reader.read32u();
       if(size_dim_hi != 0)
        caml_failwith("input_value: bigarray dimension overflow in 32bit");
       size_dim = size_dim_lo;
      }
      dims.push(size_dim);
     }
    else
     for(var i = 0; i < num_dims; i++) dims.push(reader.read32u());
    var
     size = caml_ba_get_size(dims),
     data = caml_ba_create_buffer(kind, size),
     ba = caml_ba_create_unsafe(kind, layout, dims, data);
    switch(kind){
      case 2:
       for(var i = 0; i < size; i++) data[i] = reader.read8s(); break;
      case 3:
      case 12:
       for(var i = 0; i < size; i++) data[i] = reader.read8u(); break;
      case 4:
       for(var i = 0; i < size; i++) data[i] = reader.read16s(); break;
      case 5:
       for(var i = 0; i < size; i++) data[i] = reader.read16u(); break;
      case 6:
       for(var i = 0; i < size; i++) data[i] = reader.read32s(); break;
      case 8:
      case 9:
       var sixty = reader.read8u();
       if(sixty)
        caml_failwith
         ("input_value: cannot read bigarray with 64-bit OCaml ints");
       for(var i = 0; i < size; i++) data[i] = reader.read32s();
       break;
      case 7:
       var t = new Array(8);
       for(var i = 0; i < size; i++){
        for(var j = 0; j < 8; j++) t[j] = reader.read8u();
        var int64 = caml_int64_of_bytes(t);
        ba.set(i, int64);
       }
       break;
      case 1:
       var t = new Array(8);
       for(var i = 0; i < size; i++){
        for(var j = 0; j < 8; j++) t[j] = reader.read8u();
        var f = caml_int64_float_of_bits(caml_int64_of_bytes(t));
        ba.set(i, f);
       }
       break;
      case 0:
       for(var i = 0; i < size; i++){
        var f = caml_int32_float_of_bits(reader.read32s());
        ba.set(i, f);
       }
       break;
      case 10:
       for(var i = 0; i < size; i++){
        var
         re = caml_int32_float_of_bits(reader.read32s()),
         im = caml_int32_float_of_bits(reader.read32s());
        ba.set(i, [254, re, im]);
       }
       break;
      case 11:
       var t = new Array(8);
       for(var i = 0; i < size; i++){
        for(var j = 0; j < 8; j++) t[j] = reader.read8u();
        var re = caml_int64_float_of_bits(caml_int64_of_bytes(t));
        for(var j = 0; j < 8; j++) t[j] = reader.read8u();
        var im = caml_int64_float_of_bits(caml_int64_of_bytes(t));
        ba.set(i, [254, re, im]);
       }
       break;
    }
    sz[0] = (4 + num_dims) * 4;
    return caml_ba_create_unsafe(kind, layout, dims, data);
   }
   function caml_ba_dim_1(ba){return caml_ba_dim(ba, 0);}
   function caml_ba_dim_2(ba){return caml_ba_dim(ba, 1);}
   function caml_ba_dim_3(ba){return caml_ba_dim(ba, 2);}
   function caml_ba_fill(ba, v){ba.fill(v); return 0;}
   function caml_ba_kind_of_typed_array(ta){
    var kind;
    if(ta instanceof Float32Array)
     kind = 0;
    else if(ta instanceof Float64Array)
     kind = 1;
    else if(ta instanceof Int8Array)
     kind = 2;
    else if(ta instanceof Uint8Array)
     kind = 3;
    else if(ta instanceof Uint8ClampedArray)
     kind = 3;
    else if(ta instanceof Int16Array)
     kind = 4;
    else if(ta instanceof Uint16Array)
     kind = 5;
    else if(ta instanceof Int32Array)
     kind = 6;
    else if(ta instanceof Uint32Array)
     kind = 6;
    else
     caml_invalid_argument("caml_ba_kind_of_typed_array: unsupported kind");
    return kind;
   }
   function caml_ba_from_typed_array(ta){
    var
     kind = caml_ba_kind_of_typed_array(ta),
     ta =
       ta instanceof Uint32Array
        ? new Int32Array(ta.buffer, ta.byteOffset, ta.length)
        : ta;
    return caml_ba_create_unsafe(kind, 0, [ta.length], ta);
   }
   function caml_ba_get_2(ba, i0, i1){return ba.get(ba.offset([i0, i1]));}
   function caml_ba_get_3(ba, i0, i1, i2){
    return ba.get(ba.offset([i0, i1, i2]));
   }
   function caml_ba_get_generic(ba, i){
    var ofs = ba.offset(caml_js_from_array(i));
    return ba.get(ofs);
   }
   function caml_mul(a, b){return Math.imul(a, b);}
   function caml_hash_mix_int(h, d){
    d = caml_mul(d, 0xcc9e2d51 | 0);
    d = d << 15 | d >>> 32 - 15;
    d = caml_mul(d, 0x1b873593);
    h ^= d;
    h = h << 13 | h >>> 32 - 13;
    return (h + (h << 2) | 0) + (0xe6546b64 | 0) | 0;
   }
   var log2_ok = Math.log2 && Math.log2(1.1235582092889474E+307) == 1020;
   function jsoo_floor_log2(x){
    if(log2_ok) return Math.floor(Math.log2(x));
    var i = 0;
    if(x == 0) return - Infinity;
    if(x >= 1) while(x >= 2){x /= 2; i++;} else while(x < 1){x *= 2; i--;}
    return i;
   }
   function caml_int64_create_lo_mi_hi(lo, mi, hi){return new MlInt64(lo, mi, hi);
   }
   function caml_int64_bits_of_float(x){
    if(! isFinite(x)){
     if(isNaN(x)) return caml_int64_create_lo_mi_hi(1, 0, 0x7ff0);
     return x > 0
             ? caml_int64_create_lo_mi_hi(0, 0, 0x7ff0)
             : caml_int64_create_lo_mi_hi(0, 0, 0xfff0);
    }
    var sign = x == 0 && 1 / x == - Infinity ? 0x8000 : x >= 0 ? 0 : 0x8000;
    if(sign) x = - x;
    var exp = jsoo_floor_log2(x) + 1023;
    if(exp <= 0){
     exp = 0;
     x /= Math.pow(2, - 1026);
    }
    else{
     x /= Math.pow(2, exp - 1027);
     if(x < 16){x *= 2; exp -= 1;}
     if(exp == 0) x /= 2;
    }
    var k = Math.pow(2, 24), r3 = x | 0;
    x = (x - r3) * k;
    var r2 = x | 0;
    x = (x - r2) * k;
    var r1 = x | 0;
    r3 = r3 & 0xf | sign | exp << 4;
    return caml_int64_create_lo_mi_hi(r1, r2, r3);
   }
   function caml_hash_mix_int64(h, v){
    h = caml_hash_mix_int(h, caml_int64_lo32(v));
    h = caml_hash_mix_int(h, caml_int64_hi32(v));
    return h;
   }
   function caml_hash_mix_float(h, v0){
    return caml_hash_mix_int64(h, caml_int64_bits_of_float(v0));
   }
   function caml_ba_hash(ba){
    var num_elts = caml_ba_get_size(ba.dims), h = 0;
    switch(ba.kind){
      case 2:
      case 3:
      case 12:
       if(num_elts > 256) num_elts = 256;
       var w = 0, i = 0;
       for(i = 0; i + 4 <= ba.data.length; i += 4){
        w =
         ba.data[i + 0] | ba.data[i + 1] << 8 | ba.data[i + 2] << 16
         | ba.data[i + 3] << 24;
        h = caml_hash_mix_int(h, w);
       }
       w = 0;
       switch(num_elts & 3){
         case 3:
          w = ba.data[i + 2] << 16;
         case 2:
          w |= ba.data[i + 1] << 8;
         case 1:
          w |= ba.data[i + 0]; h = caml_hash_mix_int(h, w);
       }
       break;
      case 4:
      case 5:
       if(num_elts > 128) num_elts = 128;
       var w = 0, i = 0;
       for(i = 0; i + 2 <= ba.data.length; i += 2){
        w = ba.data[i + 0] | ba.data[i + 1] << 16;
        h = caml_hash_mix_int(h, w);
       }
       if((num_elts & 1) != 0) h = caml_hash_mix_int(h, ba.data[i]);
       break;
      case 6:
       if(num_elts > 64) num_elts = 64;
       for(var i = 0; i < num_elts; i++) h = caml_hash_mix_int(h, ba.data[i]);
       break;
      case 8:
      case 9:
       if(num_elts > 64) num_elts = 64;
       for(var i = 0; i < num_elts; i++) h = caml_hash_mix_int(h, ba.data[i]);
       break;
      case 7:
       if(num_elts > 32) num_elts = 32;
       num_elts *= 2;
       for(var i = 0; i < num_elts; i++) h = caml_hash_mix_int(h, ba.data[i]);
       break;
      case 10:
       num_elts *= 2;
      case 0:
       if(num_elts > 64) num_elts = 64;
       for(var i = 0; i < num_elts; i++)
        h = caml_hash_mix_float(h, ba.data[i]);
       break;
      case 11:
       num_elts *= 2;
      case 1:
       if(num_elts > 32) num_elts = 32;
       for(var i = 0; i < num_elts; i++)
        h = caml_hash_mix_float(h, ba.data[i]);
       break;
    }
    return h;
   }
   function caml_ba_init(){return 0;}
   function caml_ba_kind(ba){return ba.kind;}
   function caml_ba_layout(ba){return ba.layout;}
   function caml_ba_map_file(vfd, kind, layout, shared, dims, pos){caml_failwith("caml_ba_map_file not implemented");
   }
   function caml_ba_map_file_bytecode(argv, argn){
    return caml_ba_map_file
            (argv[0], argv[1], argv[2], argv[3], argv[4], argv[5]);
   }
   function caml_ba_num_dims(ba){return ba.dims.length;}
   function caml_ba_reshape(ba, vind){
    vind = caml_js_from_array(vind);
    var new_dim = [], num_dims = vind.length;
    if(num_dims < 0 || num_dims > 16)
     caml_invalid_argument("Bigarray.reshape: bad number of dimensions");
    var num_elts = 1;
    for(var i = 0; i < num_dims; i++){
     new_dim[i] = vind[i];
     if(new_dim[i] < 0)
      caml_invalid_argument("Bigarray.reshape: negative dimension");
     num_elts = num_elts * new_dim[i];
    }
    var size = caml_ba_get_size(ba.dims);
    if(num_elts != size)
     caml_invalid_argument("Bigarray.reshape: size mismatch");
    return caml_ba_create_unsafe(ba.kind, ba.layout, new_dim, ba.data);
   }
   function caml_int32_bits_of_float(x){
    var float32a = new Float32Array(1);
    float32a[0] = x;
    var int32a = new Int32Array(float32a.buffer);
    return int32a[0] | 0;
   }
   function caml_int64_to_bytes(x){return x.toArray();}
   function caml_ba_serialize(writer, ba, sz){
    writer.write(32, ba.dims.length);
    writer.write(32, ba.kind | ba.layout << 8);
    if(ba.caml_custom == "_bigarr02")
     for(var i = 0; i < ba.dims.length; i++)
      if(ba.dims[i] < 0xffff)
       writer.write(16, ba.dims[i]);
      else{
       writer.write(16, 0xffff);
       writer.write(32, 0);
       writer.write(32, ba.dims[i]);
      }
    else
     for(var i = 0; i < ba.dims.length; i++) writer.write(32, ba.dims[i]);
    switch(ba.kind){
      case 2:
      case 3:
      case 12:
       for(var i = 0; i < ba.data.length; i++) writer.write(8, ba.data[i]);
       break;
      case 4:
      case 5:
       for(var i = 0; i < ba.data.length; i++) writer.write(16, ba.data[i]);
       break;
      case 6:
       for(var i = 0; i < ba.data.length; i++) writer.write(32, ba.data[i]);
       break;
      case 8:
      case 9:
       writer.write(8, 0);
       for(var i = 0; i < ba.data.length; i++) writer.write(32, ba.data[i]);
       break;
      case 7:
       for(var i = 0; i < ba.data.length / 2; i++){
        var b = caml_int64_to_bytes(ba.get(i));
        for(var j = 0; j < 8; j++) writer.write(8, b[j]);
       }
       break;
      case 1:
       for(var i = 0; i < ba.data.length; i++){
        var b = caml_int64_to_bytes(caml_int64_bits_of_float(ba.get(i)));
        for(var j = 0; j < 8; j++) writer.write(8, b[j]);
       }
       break;
      case 0:
       for(var i = 0; i < ba.data.length; i++){
        var b = caml_int32_bits_of_float(ba.get(i));
        writer.write(32, b);
       }
       break;
      case 10:
       for(var i = 0; i < ba.data.length / 2; i++){
        var j = ba.get(i);
        writer.write(32, caml_int32_bits_of_float(j[1]));
        writer.write(32, caml_int32_bits_of_float(j[2]));
       }
       break;
      case 11:
       for(var i = 0; i < ba.data.length / 2; i++){
        var
         complex = ba.get(i),
         b = caml_int64_to_bytes(caml_int64_bits_of_float(complex[1]));
        for(var j = 0; j < 8; j++) writer.write(8, b[j]);
        var b = caml_int64_to_bytes(caml_int64_bits_of_float(complex[2]));
        for(var j = 0; j < 8; j++) writer.write(8, b[j]);
       }
       break;
    }
    sz[0] = (4 + ba.dims.length) * 4;
    sz[1] = (4 + ba.dims.length) * 8;
   }
   function caml_ba_set_1(ba, i0, v){ba.set(ba.offset(i0), v); return 0;}
   function caml_ba_set_2(ba, i0, i1, v){
    ba.set(ba.offset([i0, i1]), v);
    return 0;
   }
   function caml_ba_set_3(ba, i0, i1, i2, v){
    ba.set(ba.offset([i0, i1, i2]), v);
    return 0;
   }
   function caml_ba_set_generic(ba, i, v){
    ba.set(ba.offset(caml_js_from_array(i)), v);
    return 0;
   }
   function caml_ba_slice(ba, vind){
    vind = caml_js_from_array(vind);
    var num_inds = vind.length, index = [], sub_dims = [], ofs;
    if(num_inds > ba.dims.length)
     caml_invalid_argument("Bigarray.slice: too many indices");
    if(ba.layout == 0){
     for(var i = 0; i < num_inds; i++) index[i] = vind[i];
     for(; i < ba.dims.length; i++) index[i] = 0;
     sub_dims = ba.dims.slice(num_inds);
    }
    else{
     for(var i = 0; i < num_inds; i++)
      index[ba.dims.length - num_inds + i] = vind[i];
     for(var i = 0; i < ba.dims.length - num_inds; i++) index[i] = 1;
     sub_dims = ba.dims.slice(0, ba.dims.length - num_inds);
    }
    ofs = ba.offset(index);
    var
     size = caml_ba_get_size(sub_dims),
     size_per_element = caml_ba_get_size_per_element(ba.kind),
     new_data =
       ba.data.subarray
        (ofs * size_per_element, (ofs + size) * size_per_element);
    return caml_ba_create_unsafe(ba.kind, ba.layout, sub_dims, new_data);
   }
   function caml_ba_sub(ba, ofs, len){
    var changed_dim, mul = 1;
    if(ba.layout == 0){
     for(var i = 1; i < ba.dims.length; i++) mul = mul * ba.dims[i];
     changed_dim = 0;
    }
    else{
     for(var i = 0; i < ba.dims.length - 1; i++) mul = mul * ba.dims[i];
     changed_dim = ba.dims.length - 1;
     ofs = ofs - 1;
    }
    if(ofs < 0 || len < 0 || ofs + len > ba.dims[changed_dim])
     caml_invalid_argument("Bigarray.sub: bad sub-array");
    var new_dims = [];
    for(var i = 0; i < ba.dims.length; i++) new_dims[i] = ba.dims[i];
    new_dims[changed_dim] = len;
    mul *= caml_ba_get_size_per_element(ba.kind);
    var new_data = ba.data.subarray(ofs * mul, (ofs + len) * mul);
    return caml_ba_create_unsafe(ba.kind, ba.layout, new_dims, new_data);
   }
   function caml_ba_uint8_get16(ba, i0){
    var ofs = ba.offset(i0);
    if(ofs + 1 >= ba.data.length) caml_array_bound_error();
    var b1 = ba.get(ofs), b2 = ba.get(ofs + 1);
    return b1 | b2 << 8;
   }
   function caml_ba_uint8_get32(ba, i0){
    var ofs = ba.offset(i0);
    if(ofs + 3 >= ba.data.length) caml_array_bound_error();
    var
     b1 = ba.get(ofs + 0),
     b2 = ba.get(ofs + 1),
     b3 = ba.get(ofs + 2),
     b4 = ba.get(ofs + 3);
    return b1 << 0 | b2 << 8 | b3 << 16 | b4 << 24;
   }
   function caml_ba_uint8_get64(ba, i0){
    var ofs = ba.offset(i0);
    if(ofs + 7 >= ba.data.length) caml_array_bound_error();
    var
     b1 = ba.get(ofs + 0),
     b2 = ba.get(ofs + 1),
     b3 = ba.get(ofs + 2),
     b4 = ba.get(ofs + 3),
     b5 = ba.get(ofs + 4),
     b6 = ba.get(ofs + 5),
     b7 = ba.get(ofs + 6),
     b8 = ba.get(ofs + 7);
    return caml_int64_of_bytes([b8, b7, b6, b5, b4, b3, b2, b1]);
   }
   function caml_ba_uint8_set16(ba, i0, v){
    var ofs = ba.offset(i0);
    if(ofs + 1 >= ba.data.length) caml_array_bound_error();
    ba.set(ofs + 0, v & 0xff);
    ba.set(ofs + 1, v >>> 8 & 0xff);
    return 0;
   }
   function caml_ba_uint8_set32(ba, i0, v){
    var ofs = ba.offset(i0);
    if(ofs + 3 >= ba.data.length) caml_array_bound_error();
    ba.set(ofs + 0, v & 0xff);
    ba.set(ofs + 1, v >>> 8 & 0xff);
    ba.set(ofs + 2, v >>> 16 & 0xff);
    ba.set(ofs + 3, v >>> 24 & 0xff);
    return 0;
   }
   function caml_ba_uint8_set64(ba, i0, v){
    var ofs = ba.offset(i0);
    if(ofs + 7 >= ba.data.length) caml_array_bound_error();
    var v = caml_int64_to_bytes(v);
    for(var i = 0; i < 8; i++) ba.set(ofs + i, v[7 - i]);
    return 0;
   }
   function caml_backtrace_status(_unit){
    return caml_record_backtrace_flag ? 1 : 0;
   }
   function caml_bigstring_blit_ba_to_ba(ba1, pos1, ba2, pos2, len){
    if(12 != ba1.kind)
     caml_invalid_argument("caml_bigstring_blit_ba_to_ba: kind mismatch");
    if(12 != ba2.kind)
     caml_invalid_argument("caml_bigstring_blit_ba_to_ba: kind mismatch");
    if(len == 0) return 0;
    var ofs1 = ba1.offset(pos1), ofs2 = ba2.offset(pos2);
    if(ofs1 + len > ba1.data.length) caml_array_bound_error();
    if(ofs2 + len > ba2.data.length) caml_array_bound_error();
    var slice = ba1.data.subarray(ofs1, ofs1 + len);
    ba2.data.set(slice, pos2);
    return 0;
   }
   function caml_bigstring_blit_ba_to_bytes(ba1, pos1, bytes2, pos2, len){
    if(12 != ba1.kind)
     caml_invalid_argument("caml_bigstring_blit_string_to_ba: kind mismatch");
    if(len == 0) return 0;
    var ofs1 = ba1.offset(pos1);
    if(ofs1 + len > ba1.data.length) caml_array_bound_error();
    if(pos2 + len > caml_ml_bytes_length(bytes2)) caml_array_bound_error();
    var slice = ba1.data.slice(ofs1, ofs1 + len);
    caml_blit_bytes(caml_bytes_of_array(slice), 0, bytes2, pos2, len);
    return 0;
   }
   function caml_bigstring_blit_bytes_to_ba(str1, pos1, ba2, pos2, len){
    if(12 != ba2.kind)
     caml_invalid_argument("caml_bigstring_blit_string_to_ba: kind mismatch");
    if(len == 0) return 0;
    var ofs2 = ba2.offset(pos2);
    if(pos1 + len > caml_ml_bytes_length(str1)) caml_array_bound_error();
    if(ofs2 + len > ba2.data.length) caml_array_bound_error();
    var slice = caml_uint8_array_of_bytes(str1).slice(pos1, pos1 + len);
    ba2.data.set(slice, ofs2);
    return 0;
   }
   function caml_bigstring_blit_string_to_ba(str1, pos1, ba2, pos2, len){
    if(12 != ba2.kind)
     caml_invalid_argument("caml_bigstring_blit_string_to_ba: kind mismatch");
    if(len == 0) return 0;
    var ofs2 = ba2.offset(pos2);
    if(pos1 + len > caml_ml_string_length(str1)) caml_array_bound_error();
    if(ofs2 + len > ba2.data.length) caml_array_bound_error();
    var slice = caml_uint8_array_of_string(str1).slice(pos1, pos1 + len);
    ba2.data.set(slice, ofs2);
    return 0;
   }
   function caml_bigstring_memcmp(s1, pos1, s2, pos2, len){
    for(var i = 0; i < len; i++){
     var a = caml_ba_get_1(s1, pos1 + i), b = caml_ba_get_1(s2, pos2 + i);
     if(a < b) return - 1;
     if(a > b) return 1;
    }
    return 0;
   }
   function caml_blit_string(a, b, c, d, e){
    caml_blit_bytes(caml_bytes_of_string(a), b, c, d, e);
    return 0;
   }
   function caml_bswap16(x){return (x & 0x00FF) << 8 | (x & 0xFF00) >> 8;}
   function caml_build_symbols(symb){
    var r = {};
    if(symb)
     for(var i = 1; i < symb.length; i++)
      r[caml_jsstring_of_string(symb[i][1])] = symb[i][2];
    return r;
   }
   function caml_bytes_compare(s1, s2){
    s1.t & 6 && caml_convert_string_to_bytes(s1);
    s2.t & 6 && caml_convert_string_to_bytes(s2);
    return s1.c < s2.c ? - 1 : s1.c > s2.c ? 1 : 0;
   }
   function caml_bytes_equal(s1, s2){
    if(s1 === s2) return 1;
    s1.t & 6 && caml_convert_string_to_bytes(s1);
    s2.t & 6 && caml_convert_string_to_bytes(s2);
    return s1.c == s2.c ? 1 : 0;
   }
   function caml_bytes_unsafe_get(s, i){
    switch(s.t & 6){
      default: if(i >= s.c.length) return 0;
      case 0:
       return s.c.charCodeAt(i);
      case 4:
       return s.c[i];
    }
   }
   function caml_bytes_get(s, i){
    if(i >>> 0 >= s.l) caml_bytes_bound_error();
    return caml_bytes_unsafe_get(s, i);
   }
   function caml_bytes_get16(s, i){
    if(i >>> 0 >= s.l - 1) caml_bytes_bound_error();
    var
     b1 = caml_bytes_unsafe_get(s, i),
     b2 = caml_bytes_unsafe_get(s, i + 1);
    return b2 << 8 | b1;
   }
   function caml_bytes_get32(s, i){
    if(i >>> 0 >= s.l - 3) caml_bytes_bound_error();
    var
     b1 = caml_bytes_unsafe_get(s, i),
     b2 = caml_bytes_unsafe_get(s, i + 1),
     b3 = caml_bytes_unsafe_get(s, i + 2),
     b4 = caml_bytes_unsafe_get(s, i + 3);
    return b4 << 24 | b3 << 16 | b2 << 8 | b1;
   }
   function caml_bytes_get64(s, i){
    if(i >>> 0 >= s.l - 7) caml_bytes_bound_error();
    var a = new Array(8);
    for(var j = 0; j < 8; j++) a[7 - j] = caml_bytes_unsafe_get(s, i + j);
    return caml_int64_of_bytes(a);
   }
   function caml_bytes_lessequal(s1, s2){
    s1.t & 6 && caml_convert_string_to_bytes(s1);
    s2.t & 6 && caml_convert_string_to_bytes(s2);
    return s1.c <= s2.c ? 1 : 0;
   }
   function caml_bytes_greaterequal(s1, s2){return caml_bytes_lessequal(s2, s1);
   }
   function caml_bytes_lessthan(s1, s2){
    s1.t & 6 && caml_convert_string_to_bytes(s1);
    s2.t & 6 && caml_convert_string_to_bytes(s2);
    return s1.c < s2.c ? 1 : 0;
   }
   function caml_bytes_greaterthan(s1, s2){return caml_bytes_lessthan(s2, s1);
   }
   function caml_bytes_notequal(s1, s2){return 1 - caml_bytes_equal(s1, s2);}
   function caml_bytes_of_utf16_jsstring(s){
    var tag = 9;
    if(! jsoo_is_ascii(s)) tag = 8, s = caml_utf8_of_utf16(s);
    return new MlBytes(tag, s, s.length);
   }
   function caml_bytes_set16(s, i, i16){
    if(i >>> 0 >= s.l - 1) caml_bytes_bound_error();
    var b2 = 0xFF & i16 >> 8, b1 = 0xFF & i16;
    caml_bytes_unsafe_set(s, i + 0, b1);
    caml_bytes_unsafe_set(s, i + 1, b2);
    return 0;
   }
   function caml_bytes_set32(s, i, i32){
    if(i >>> 0 >= s.l - 3) caml_bytes_bound_error();
    var
     b4 = 0xFF & i32 >> 24,
     b3 = 0xFF & i32 >> 16,
     b2 = 0xFF & i32 >> 8,
     b1 = 0xFF & i32;
    caml_bytes_unsafe_set(s, i + 0, b1);
    caml_bytes_unsafe_set(s, i + 1, b2);
    caml_bytes_unsafe_set(s, i + 2, b3);
    caml_bytes_unsafe_set(s, i + 3, b4);
    return 0;
   }
   function caml_bytes_set64(s, i, i64){
    if(i >>> 0 >= s.l - 7) caml_bytes_bound_error();
    var a = caml_int64_to_bytes(i64);
    for(var j = 0; j < 8; j++) caml_bytes_unsafe_set(s, i + 7 - j, a[j]);
    return 0;
   }
   var caml_callback = caml_call_gen;
   function caml_cbrt_float(x){return Math.cbrt(x);}
   var caml_ml_channels = new Array();
   function caml_ml_channel_get(id){return caml_ml_channels[id];}
   function caml_channel_descriptor(chanid){
    var chan = caml_ml_channel_get(chanid);
    return chan.fd;
   }
   function caml_check_bound(array, index){
    if(index >>> 0 >= array.length - 1) caml_array_bound_error();
    return array;
   }
   function caml_classify_float(x){
    if(isFinite(x)){
     if(Math.abs(x) >= 2.2250738585072014e-308) return 0;
     if(x != 0) return 1;
     return 2;
    }
    return isNaN(x) ? 4 : 3;
   }
   function caml_is_continuation_tag(t){return 0;}
   function caml_int32_unmarshal(reader, size){size[0] = 4; return reader.read32s();
   }
   function caml_nativeint_unmarshal(reader, size){
    switch(reader.read8u()){
      case 1:
       size[0] = 4; return reader.read32s();
      case 2:
       caml_failwith("input_value: native integer value too large");
      default: caml_failwith("input_value: ill-formed native integer");
    }
   }
   function caml_int64_unmarshal(reader, size){
    var t = new Array(8);
    for(var j = 0; j < 8; j++) t[j] = reader.read8u();
    size[0] = 8;
    return caml_int64_of_bytes(t);
   }
   function caml_int64_marshal(writer, v, sizes){
    var b = caml_int64_to_bytes(v);
    for(var i = 0; i < 8; i++) writer.write(8, b[i]);
    sizes[0] = 8;
    sizes[1] = 8;
   }
   function caml_int64_compare(x, y, total){return x.compare(y);}
   function caml_int64_hash(v){return v.lo32() ^ v.hi32();}
   var
    caml_custom_ops =
      {"_j":
       {deserialize: caml_int64_unmarshal,
        serialize: caml_int64_marshal,
        fixed_length: 8,
        compare: caml_int64_compare,
        hash: caml_int64_hash},
       "_i": {deserialize: caml_int32_unmarshal, fixed_length: 4},
       "_n": {deserialize: caml_nativeint_unmarshal, fixed_length: 4},
       "_bigarray":
       {deserialize:
        function(reader, sz){
         return caml_ba_deserialize(reader, sz, "_bigarray");
        },
        serialize: caml_ba_serialize,
        compare: caml_ba_compare,
        hash: caml_ba_hash},
       "_bigarr02":
       {deserialize:
        function(reader, sz){
         return caml_ba_deserialize(reader, sz, "_bigarr02");
        },
        serialize: caml_ba_serialize,
        compare: caml_ba_compare,
        hash: caml_ba_hash}};
   function caml_compare_val_get_custom(a){
    return caml_custom_ops[a.caml_custom]
           && caml_custom_ops[a.caml_custom].compare;
   }
   function caml_compare_val_number_custom(num, custom, swap, total){
    var comp = caml_compare_val_get_custom(custom);
    if(comp){
     var x = swap > 0 ? comp(custom, num, total) : comp(num, custom, total);
     if(total && x != x) return swap;
     if(+ x != + x) return + x;
     if((x | 0) != 0) return x | 0;
    }
    return swap;
   }
   function caml_compare_val_tag(a){
    if(typeof a === "number")
     return 1000;
    else if(caml_is_ml_bytes(a))
     return 252;
    else if(caml_is_ml_string(a))
     return 1252;
    else if(a instanceof Array && a[0] === a[0] >>> 0 && a[0] <= 255){var tag = a[0] | 0; return tag == 254 ? 0 : tag;}
    else if(a instanceof String)
     return 12520;
    else if(typeof a == "string")
     return 12520;
    else if(a instanceof Number)
     return 1000;
    else if(a && a.caml_custom)
     return 1255;
    else if(a && a.compare)
     return 1256;
    else if(typeof a == "function")
     return 1247;
    else if(typeof a == "symbol") return 1251;
    return 1001;
   }
   function caml_int_compare(a, b){
    if(a < b) return - 1;
    if(a == b) return 0;
    return 1;
   }
   function caml_string_compare(s1, s2){
    return s1 < s2 ? - 1 : s1 > s2 ? 1 : 0;
   }
   function caml_compare_val(a, b, total){
    var stack = [];
    for(;;){
     if(! (total && a === b)){
      var tag_a = caml_compare_val_tag(a);
      if(tag_a == 250){a = a[1]; continue;}
      var tag_b = caml_compare_val_tag(b);
      if(tag_b == 250){b = b[1]; continue;}
      if(tag_a !== tag_b){
       if(tag_a == 1000){
        if(tag_b == 1255)
         return caml_compare_val_number_custom(a, b, - 1, total);
        return - 1;
       }
       if(tag_b == 1000){
        if(tag_a == 1255)
         return caml_compare_val_number_custom(b, a, 1, total);
        return 1;
       }
       return tag_a < tag_b ? - 1 : 1;
      }
      switch(tag_a){
        case 247:
         caml_invalid_argument("compare: functional value"); break;
        case 248:
         var x = caml_int_compare(a[2], b[2]); if(x != 0) return x | 0; break;
        case 249:
         caml_invalid_argument("compare: functional value"); break;
        case 250:
         caml_invalid_argument("equal: got Forward_tag, should not happen");
         break;
        case 251:
         caml_invalid_argument("equal: abstract value"); break;
        case 252:
         if(a !== b){
          var x = caml_bytes_compare(a, b);
          if(x != 0) return x | 0;
         }
         break;
        case 253:
         caml_invalid_argument("equal: got Double_tag, should not happen");
         break;
        case 254:
         caml_invalid_argument
          ("equal: got Double_array_tag, should not happen");
         break;
        case 255:
         caml_invalid_argument("equal: got Custom_tag, should not happen");
         break;
        case 1247:
         caml_invalid_argument("compare: functional value"); break;
        case 1255:
         var comp = caml_compare_val_get_custom(a);
         if(comp != caml_compare_val_get_custom(b))
          return a.caml_custom < b.caml_custom ? - 1 : 1;
         if(! comp) caml_invalid_argument("compare: abstract value");
         var x = comp(a, b, total);
         if(x != x) return total ? - 1 : x;
         if(x !== (x | 0)) return - 1;
         if(x != 0) return x | 0;
         break;
        case 1256:
         var x = a.compare(b, total);
         if(x != x) return total ? - 1 : x;
         if(x !== (x | 0)) return - 1;
         if(x != 0) return x | 0;
         break;
        case 1000:
         a = + a;
         b = + b;
         if(a < b) return - 1;
         if(a > b) return 1;
         if(a != b){
          if(! total) return NaN;
          if(a == a) return 1;
          if(b == b) return - 1;
         }
         break;
        case 1001:
         if(a < b) return - 1;
         if(a > b) return 1;
         if(a != b){
          if(! total) return NaN;
          if(a == a) return 1;
          if(b == b) return - 1;
         }
         break;
        case 1251:
         if(a !== b){if(! total) return NaN; return 1;} break;
        case 1252:
         var a = caml_jsbytes_of_string(a), b = caml_jsbytes_of_string(b);
         if(a !== b){if(a < b) return - 1; if(a > b) return 1;}
         break;
        case 12520:
         var a = a.toString(), b = b.toString();
         if(a !== b){if(a < b) return - 1; if(a > b) return 1;}
         break;
        case 246:
        case 254:
        default:
         if(caml_is_continuation_tag(tag_a)){
          caml_invalid_argument("compare: continuation value");
          break;
         }
         if(a.length != b.length) return a.length < b.length ? - 1 : 1;
         if(a.length > 1) stack.push(a, b, 1);
         break;
      }
     }
     if(stack.length == 0) return 0;
     var i = stack.pop();
     b = stack.pop();
     a = stack.pop();
     if(i + 1 < a.length) stack.push(a, b, i + 1);
     a = a[i];
     b = b[i];
    }
   }
   function caml_compare(a, b){return caml_compare_val(a, b, true);}
   function caml_continuation_use_noexc(cont){
    var stack = cont[1];
    cont[1] = 0;
    return stack;
   }
   function caml_continuation_use_and_update_handler_noexc
   (cont, hval, hexn, heff){
    var stack = caml_continuation_use_noexc(cont);
    stack[3] = [0, hval, hexn, heff];
    return stack;
   }
   function caml_convert_raw_backtrace(){return [0];}
   function caml_convert_raw_backtrace_slot(){
    caml_failwith("caml_convert_raw_backtrace_slot");
   }
   function caml_copysign_float(x, y){
    if(y == 0) y = 1 / y;
    x = Math.abs(x);
    return y < 0 ? - x : x;
   }
   function caml_cosh_float(x){return Math.cosh(x);}
   function caml_create_file(name, content){
    var root = resolve_fs_device(name);
    if(! root.device.register) caml_failwith("cannot register file");
    root.device.register(root.rest, content);
    return 0;
   }
   function caml_create_string(len){caml_invalid_argument("String.create");}
   var caml_custom_event_index = 0, caml_decompress_input = null;
   function caml_div(x, y){
    if(y == 0) caml_raise_zero_divide();
    return x / y | 0;
   }
   var caml_domain_dls = [0];
   function caml_domain_dls_get(unit){return caml_domain_dls;}
   function caml_domain_dls_set(a){caml_domain_dls = a;}
   var caml_domain_id = 0;
   function caml_ml_mutex_unlock(t){t.locked = false; return 0;}
   var caml_domain_latest_idx = 1;
   function caml_domain_spawn(f, mutex){
    var id = caml_domain_latest_idx++, old = caml_domain_id;
    caml_domain_id = id;
    var res = caml_callback(f, [0]);
    caml_domain_id = old;
    caml_ml_mutex_unlock(mutex);
    return id;
   }
   var caml_ephe_data_offset = 2, caml_ephe_key_offset = 3;
   function caml_ephe_unset_data(x){
    if(globalThis.FinalizationRegistry && globalThis.WeakRef)
     if(x[1] instanceof globalThis.FinalizationRegistry)
      for(var j = caml_ephe_key_offset; j < x.length; j++){
       var key = x[j];
       if(key instanceof globalThis.WeakRef){
        key = key.deref();
        if(key) x[1].unregister(key);
       }
      }
    x[caml_ephe_data_offset] = undefined;
    return 0;
   }
   function caml_ephe_set_data(x, data){
    if(globalThis.FinalizationRegistry && globalThis.WeakRef)
     if(! (x[1] instanceof globalThis.FinalizationRegistry)){
      x[1] =
       new
        globalThis.FinalizationRegistry
        (function(){caml_ephe_unset_data(x);});
      for(var j = caml_ephe_key_offset; j < x.length; j++){
       var key = x[j];
       if(key instanceof globalThis.WeakRef){
        key = key.deref();
        if(key) x[1].register(key, undefined, key);
       }
      }
     }
    x[caml_ephe_data_offset] = data;
    return 0;
   }
   function caml_ephe_blit_data(src, dst){
    var n = src[caml_ephe_data_offset];
    if(n === undefined)
     caml_ephe_unset_data(dst);
    else
     caml_ephe_set_data(dst, n);
    return 0;
   }
   function caml_ephe_blit_key(a1, i1, a2, i2, len){
    caml_array_blit
     (a1,
      caml_ephe_key_offset + i1 - 1,
      a2,
      caml_ephe_key_offset + i2 - 1,
      len);
    return 0;
   }
   function caml_ephe_check_data(x){
    return x[caml_ephe_data_offset] === undefined ? 0 : 1;
   }
   function caml_ephe_check_key(x, i){
    var weak = x[caml_ephe_key_offset + i];
    if(globalThis.WeakRef && weak instanceof globalThis.WeakRef)
     weak = weak.deref();
    return weak === undefined ? 0 : 1;
   }
   function caml_weak_create(n){
    if(n < 0) caml_invalid_argument("Weak.create");
    var x = [251, "caml_ephe_list_head"];
    x.length = caml_ephe_key_offset + n;
    return x;
   }
   function caml_ephe_create(n){var x = caml_weak_create(n); return x;}
   function caml_ephe_get_data(x){
    return x[caml_ephe_data_offset] === undefined
            ? 0
            : [0, x[caml_ephe_data_offset]];
   }
   function caml_obj_dup(x){
    var l = x.length, a = new Array(l);
    for(var i = 0; i < l; i++) a[i] = x[i];
    return a;
   }
   function caml_ephe_get_data_copy(x){
    return x[caml_ephe_data_offset] === undefined
            ? 0
            : [0, caml_obj_dup(x[caml_ephe_data_offset])];
   }
   function caml_ephe_get_key(x, i){
    if(i < 0 || caml_ephe_key_offset + i >= x.length)
     caml_invalid_argument("Weak.get_key");
    var weak = x[caml_ephe_key_offset + i];
    if(globalThis.WeakRef && weak instanceof globalThis.WeakRef)
     weak = weak.deref();
    return weak === undefined ? 0 : [0, weak];
   }
   function caml_ephe_get_key_copy(x, i){
    if(i < 0 || caml_ephe_key_offset + i >= x.length)
     caml_invalid_argument("Weak.get_copy");
    var y = caml_ephe_get_key(x, i);
    if(y === 0) return y;
    var z = y[1];
    if(z instanceof Array) return [0, caml_obj_dup(z)];
    return y;
   }
   function caml_ephe_set_key(x, i, v){
    if(i < 0 || caml_ephe_key_offset + i >= x.length)
     caml_invalid_argument("Weak.set");
    if(v instanceof Object && globalThis.WeakRef){
     if(x[1].register) x[1].register(v, undefined, v);
     x[caml_ephe_key_offset + i] = new globalThis.WeakRef(v);
    }
    else
     x[caml_ephe_key_offset + i] = v;
    return 0;
   }
   function caml_ephe_unset_key(x, i){
    if(i < 0 || caml_ephe_key_offset + i >= x.length)
     caml_invalid_argument("Weak.set");
    if
     (globalThis.WeakRef
      && x[caml_ephe_key_offset + i] instanceof globalThis.WeakRef
      && x[1].unregister){
     var old = x[caml_ephe_key_offset + i].deref();
     if(old !== undefined){
      var count = 0;
      for(var j = caml_ephe_key_offset; j < x.length; j++){
       var key = x[j];
       if(key instanceof globalThis.WeakRef){
        key = key.deref();
        if(key === old) count++;
       }
      }
      if(count == 1) x[1].unregister(old);
     }
    }
    x[caml_ephe_key_offset + i] = undefined;
    return 0;
   }
   function caml_equal(x, y){return + (caml_compare_val(x, y, false) == 0);}
   function caml_erf_float(x){
    var
     a1 = 0.254829592,
     a2 = - 0.284496736,
     a3 = 1.421413741,
     a4 = - 1.453152027,
     a5 = 1.061405429,
     p = 0.3275911,
     sign = 1;
    if(x < 0) sign = - 1;
    x = Math.abs(x);
    var
     t = 1.0 / (1.0 + p * x),
     y =
       1.0
       -
        ((((a5 * t + a4) * t + a3) * t + a2) * t + a1) * t
        * Math.exp(- (x * x));
    return sign * y;
   }
   function caml_erfc_float(x){return 1 - caml_erf_float(x);}
   function caml_eventlog_pause(unit){return 0;}
   function caml_eventlog_resume(unit){return 0;}
   var caml_executable_name = caml_argv[1];
   function caml_exp2_float(x){return Math.pow(2, x);}
   function caml_expm1_float(x){return Math.expm1(x);}
   function caml_is_special_exception(exn){
    switch(exn[2]){case - 8:case - 11:case - 12: return 1;default: return 0;
    }
   }
   function caml_format_exception(exn){
    var r = "";
    if(exn[0] == 0){
     r += exn[1][1];
     if
      (exn.length == 3 && exn[2][0] == 0 && caml_is_special_exception(exn[1]))
      var bucket = exn[2], start = 1;
     else
      var start = 2, bucket = exn;
     r += "(";
     for(var i = start; i < bucket.length; i++){
      if(i > start) r += ", ";
      var v = bucket[i];
      if(typeof v == "number")
       r += v.toString();
      else if(v instanceof MlBytes)
       r += '"' + v.toString() + '"';
      else if(typeof v == "string")
       r += '"' + v.toString() + '"';
      else
       r += "_";
     }
     r += ")";
    }
    else if(exn[0] == 248) r += exn[1];
    return r;
   }
   function caml_fatal_uncaught_exception(err){
    if(err instanceof Array && (err[0] == 0 || err[0] == 248)){
     var handler = caml_named_value("Printexc.handle_uncaught_exception");
     if(handler)
      caml_callback(handler, [err, false]);
     else{
      var
       msg = caml_format_exception(err),
       at_exit = caml_named_value("Pervasives.do_at_exit");
      if(at_exit) caml_callback(at_exit, [0]);
      console.error("Fatal error: exception " + msg);
      if(err.js_error) throw err.js_error;
     }
    }
    else
     throw err;
   }
   function caml_fill_bytes(s, i, l, c){
    if(l > 0)
     if(i == 0 && (l >= s.l || s.t == 2 && l >= s.c.length))
      if(c == 0){
       s.c = "";
       s.t = 2;
      }
      else{
       s.c = caml_str_repeat(l, String.fromCharCode(c));
       s.t = l == s.l ? 0 : 2;
      }
     else{
      if(s.t != 4) caml_convert_bytes_to_array(s);
      for(l += i; i < l; i++) s.c[i] = c;
     }
    return 0;
   }
   function caml_final_register(){return 0;}
   var all_finalizers = new globalThis.Set();
   function caml_final_register_called_without_value(cb, a){
    if(globalThis.FinalizationRegistry && a instanceof Object){
     var
      x =
        new
         globalThis.FinalizationRegistry
         (function(x){all_finalizers.delete(x); cb(0); return;});
     x.register(a, x);
     all_finalizers.add(x);
    }
    return 0;
   }
   function caml_final_release(){return 0;}
   function caml_finish_formatting(f, rawbuffer){
    if(f.uppercase) rawbuffer = rawbuffer.toUpperCase();
    var len = rawbuffer.length;
    if(f.signedconv && (f.sign < 0 || f.signstyle != "-")) len++;
    if(f.alternate){if(f.base == 8) len += 1; if(f.base == 16) len += 2;}
    var buffer = "";
    if(f.justify == "+" && f.filler == " ")
     for(var i = len; i < f.width; i++) buffer += " ";
    if(f.signedconv)
     if(f.sign < 0)
      buffer += "-";
     else if(f.signstyle != "-") buffer += f.signstyle;
    if(f.alternate && f.base == 8) buffer += "0";
    if(f.alternate && f.base == 16) buffer += f.uppercase ? "0X" : "0x";
    if(f.justify == "+" && f.filler == "0")
     for(var i = len; i < f.width; i++) buffer += "0";
    buffer += rawbuffer;
    if(f.justify == "-") for(var i = len; i < f.width; i++) buffer += " ";
    return caml_string_of_jsbytes(buffer);
   }
   function caml_float_compare(x, y){
    if(x === y) return 0;
    if(x < y) return - 1;
    if(x > y) return 1;
    if(x === x) return 1;
    if(y === y) return - 1;
    return 0;
   }
   function caml_float_of_bytes(a){
    return caml_int64_float_of_bits(caml_int64_of_bytes(a));
   }
   function caml_float_of_string(s){
    var res;
    s = caml_jsbytes_of_string(s);
    res = + s;
    if(s.length > 0 && res === res) return res;
    s = s.replace(/_/g, "");
    res = + s;
    if(s.length > 0 && res === res || /^[+-]?nan$/i.test(s)) return res;
    var m = /^ *([+-]?)0x([0-9a-f]+)\.?([0-9a-f]*)(p([+-]?[0-9]+))?/i.exec(s);
    if(m){
     var
      m3 = m[3].replace(/0+$/, ""),
      mantissa = parseInt(m[1] + m[2] + m3, 16),
      exponent = (m[5] | 0) - 4 * m3.length;
     res = mantissa * Math.pow(2, exponent);
     return res;
    }
    if(/^\+?inf(inity)?$/i.test(s)) return Infinity;
    if(/^-inf(inity)?$/i.test(s)) return - Infinity;
    caml_failwith("float_of_string");
   }
   function caml_floatarray_blit(a1, i1, a2, i2, len){
    if(i2 <= i1)
     for(var j = 1; j <= len; j++) a2[i2 + j] = a1[i1 + j];
    else
     for(var j = len; j >= 1; j--) a2[i2 + j] = a1[i1 + j];
    return 0;
   }
   function caml_floatarray_create(len){
    if(len < 0) caml_array_bound_error();
    var len = len + 1 | 0, b = new Array(len);
    b[0] = 254;
    for(var i = 1; i < len; i++) b[i] = 0;
    return b;
   }
   function caml_fma_float(x, y, z){
    var
     SPLIT = Math.pow(2, 27) + 1,
     MIN_VALUE = Math.pow(2, - 1022),
     EPSILON = Math.pow(2, - 52),
     C = 416,
     A = Math.pow(2, + C),
     B = Math.pow(2, - C);
    function multiply(a, b){
     var
      at = SPLIT * a,
      ahi = at - (at - a),
      alo = a - ahi,
      bt = SPLIT * b,
      bhi = bt - (bt - b),
      blo = b - bhi,
      p = a * b,
      e = ahi * bhi - p + ahi * blo + alo * bhi + alo * blo;
     return {p: p, e: e};
    }
    function add(a, b){
     var s = a + b, v = s - a, e = a - (s - v) + (b - v);
     return {s: s, e: e};
    }
    function adjust(x, y){
     return x !== 0 && y !== 0 && SPLIT * x - (SPLIT * x - x) === x
             ? x * (1 + (x < 0 ? - 1 : + 1) * (y < 0 ? - 1 : + 1) * EPSILON)
             : x;
    }
    if
     (x === 0 || x !== x || x === + (1 / 0) || x === - (1 / 0) || y === 0
      || y !== y
      || y === + (1 / 0)
      || y === - (1 / 0))
     return x * y + z;
    if(z === 0) return x * y;
    if(z !== z || z === + (1 / 0) || z === - (1 / 0)) return z;
    var scale = 1;
    while(Math.abs(x) > A){scale *= A; x *= B;}
    while(Math.abs(y) > A){scale *= A; y *= B;}
    if(scale === 1 / 0) return x * y * scale;
    while(Math.abs(x) < B){scale *= B; x *= A;}
    while(Math.abs(y) < B){scale *= B; y *= A;}
    if(scale === 0) return z;
    var xs = x, ys = y, zs = z / scale;
    if(Math.abs(zs) > Math.abs(xs * ys) * 4 / EPSILON) return z;
    if(Math.abs(zs) < Math.abs(xs * ys) * EPSILON / 4 * EPSILON / 4)
     zs = (z < 0 ? - 1 : + 1) * MIN_VALUE;
    var
     xy = multiply(xs, ys),
     s = add(xy.p, zs),
     u = add(xy.e, s.e),
     i = add(s.s, u.s),
     f = i.s + adjust(i.e, u.e);
    if(f === 0) return f;
    var fs = f * scale;
    if(Math.abs(fs) > MIN_VALUE) return fs;
    return fs + adjust(f - fs / scale, i.e) * scale;
   }
   function caml_parse_format(fmt){
    fmt = caml_jsbytes_of_string(fmt);
    var len = fmt.length;
    if(len > 31) caml_invalid_argument("format_int: format too long");
    var
     f =
       {justify: "+",
        signstyle: "-",
        filler: " ",
        alternate: false,
        base: 0,
        signedconv: false,
        width: 0,
        uppercase: false,
        sign: 1,
        prec: - 1,
        conv: "f"};
    for(var i = 0; i < len; i++){
     var c = fmt.charAt(i);
     switch(c){
       case "-":
        f.justify = "-"; break;
       case "+":
       case " ":
        f.signstyle = c; break;
       case "0":
        f.filler = "0"; break;
       case "#":
        f.alternate = true; break;
       case "1":
       case "2":
       case "3":
       case "4":
       case "5":
       case "6":
       case "7":
       case "8":
       case "9":
        f.width = 0;
        while(c = fmt.charCodeAt(i) - 48, c >= 0 && c <= 9){f.width = f.width * 10 + c; i++;}
        i--;
        break;
       case ".":
        f.prec = 0;
        i++;
        while(c = fmt.charCodeAt(i) - 48, c >= 0 && c <= 9){f.prec = f.prec * 10 + c; i++;}
        i--;
       case "d":
       case "i":
        f.signedconv = true;
       case "u":
        f.base = 10; break;
       case "x":
        f.base = 16; break;
       case "X":
        f.base = 16; f.uppercase = true; break;
       case "o":
        f.base = 8; break;
       case "e":
       case "f":
       case "g":
        f.signedconv = true; f.conv = c; break;
       case "E":
       case "F":
       case "G":
        f.signedconv = true;
        f.uppercase = true;
        f.conv = c.toLowerCase();
        break;
     }
    }
    return f;
   }
   function caml_format_float(fmt, x){
    function toFixed(x, dp){
     if(Math.abs(x) < 1.0)
      return x.toFixed(dp);
     else{
      var e = parseInt(x.toString().split("+")[1]);
      if(e > 20){
       e -= 20;
       x /= Math.pow(10, e);
       x += new Array(e + 1).join("0");
       if(dp > 0) x = x + "." + new Array(dp + 1).join("0");
       return x;
      }
      else
       return x.toFixed(dp);
     }
    }
    var s, f = caml_parse_format(fmt), prec = f.prec < 0 ? 6 : f.prec;
    if(x < 0 || x == 0 && 1 / x == - Infinity){f.sign = - 1; x = - x;}
    if(isNaN(x)){
     s = "nan";
     f.filler = " ";
    }
    else if(! isFinite(x)){
     s = "inf";
     f.filler = " ";
    }
    else
     switch(f.conv){
       case "e":
        var s = x.toExponential(prec), i = s.length;
        if(s.charAt(i - 3) == "e")
         s = s.slice(0, i - 1) + "0" + s.slice(i - 1);
        break;
       case "f":
        s = toFixed(x, prec); break;
       case "g":
        prec = prec ? prec : 1;
        s = x.toExponential(prec - 1);
        var j = s.indexOf("e"), exp = + s.slice(j + 1);
        if(exp < - 4 || x >= 1e21 || x.toFixed(0).length > prec){
         var i = j - 1;
         while(s.charAt(i) == "0") i--;
         if(s.charAt(i) == ".") i--;
         s = s.slice(0, i + 1) + s.slice(j);
         i = s.length;
         if(s.charAt(i - 3) == "e")
          s = s.slice(0, i - 1) + "0" + s.slice(i - 1);
         break;
        }
        else{
         var p = prec;
         if(exp < 0){
          p -= exp + 1;
          s = x.toFixed(p);
         }
         else
          while(s = x.toFixed(p), s.length > prec + 1) p--;
         if(p){
          var i = s.length - 1;
          while(s.charAt(i) == "0") i--;
          if(s.charAt(i) == ".") i--;
          s = s.slice(0, i + 1);
         }
        }
        break;
     }
    return caml_finish_formatting(f, s);
   }
   function caml_format_int(fmt, i){
    if(caml_jsbytes_of_string(fmt) == "%d")
     return caml_string_of_jsbytes("" + i);
    var f = caml_parse_format(fmt);
    if(i < 0) if(f.signedconv){f.sign = - 1; i = - i;} else i >>>= 0;
    var s = i.toString(f.base);
    if(f.prec >= 0){
     f.filler = " ";
     var n = f.prec - s.length;
     if(n > 0) s = caml_str_repeat(n, "0") + s;
    }
    return caml_finish_formatting(f, s);
   }
   var caml_oo_last_id = 0;
   function caml_fresh_oo_id(){return caml_oo_last_id++;}
   function caml_frexp_float(x){
    if(x == 0 || ! isFinite(x)) return [0, x, 0];
    var neg = x < 0;
    if(neg) x = - x;
    var exp = Math.max(- 1023, jsoo_floor_log2(x) + 1);
    x *= Math.pow(2, - exp);
    while(x < 0.5){x *= 2; exp--;}
    while(x >= 1){x *= 0.5; exp++;}
    if(neg) x = - x;
    return [0, x, exp];
   }
   function jsoo_create_file(name, content){
    var
     name = caml_string_of_jsbytes(name),
     content = caml_string_of_jsbytes(content);
    return caml_create_file(name, content);
   }
   function caml_fs_init(){
    var tmp = globalThis.caml_fs_tmp;
    if(tmp)
     for(var i = 0; i < tmp.length; i++)
      jsoo_create_file(tmp[i].name, tmp[i].content);
    globalThis.jsoo_create_file = jsoo_create_file;
    globalThis.caml_fs_tmp = [];
    return 0;
   }
   function caml_gc_compaction(){return 0;}
   function caml_gc_counters(){return [254, 0, 0, 0];}
   function caml_gc_full_major(unit){
    if(typeof globalThis.gc == "function") globalThis.gc();
    return 0;
   }
   function caml_gc_get(){return [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];}
   function caml_gc_huge_fallback_count(unit){return 0;}
   function caml_gc_major(unit){
    if(typeof globalThis.gc == "function") globalThis.gc();
    return 0;
   }
   function caml_gc_major_slice(work){return 0;}
   function caml_gc_minor(unit){
    if(typeof globalThis.gc == "function") globalThis.gc(true);
    return 0;
   }
   function caml_gc_minor_words(unit){return 0;}
   function caml_gc_quick_stat(){
    return [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
   }
   function caml_gc_set(_control){return 0;}
   function caml_gc_stat(){return caml_gc_quick_stat();}
   function caml_get_continuation_callstack(){return [0];}
   function caml_get_current_callstack(){return [0];}
   function caml_get_exception_backtrace(){return 0;}
   function caml_get_exception_raw_backtrace(){return [0];}
   function caml_get_global_data(){return caml_global_data;}
   function caml_get_major_bucket(n){return 0;}
   function caml_get_major_credit(n){return 0;}
   function caml_get_minor_free(unit){return 0;}
   var caml_method_cache = [];
   function caml_get_public_method(obj, tag, cacheid){
    var meths = obj[1], ofs = caml_method_cache[cacheid];
    if(ofs === undefined)
     for(var i = caml_method_cache.length; i < cacheid; i++)
      caml_method_cache[i] = 0;
    else if(meths[ofs] === tag) return meths[ofs - 1];
    var li = 3, hi = meths[1] * 2 + 1, mi;
    while(li < hi){
     mi = li + hi >> 1 | 1;
     if(tag < meths[mi + 1]) hi = mi - 2; else li = mi;
    }
    caml_method_cache[cacheid] = li + 1;
    return tag == meths[li + 1] ? meths[li] : 0;
   }
   function caml_gr_arc_aux(ctx, cx, cy, ry, rx, a1, a2){
    while(a1 > a2) a2 += 360;
    a1 /= 180;
    a2 /= 180;
    var
     rot = 0,
     xPos,
     yPos,
     xPos_prev,
     yPos_prev,
     space = 2,
     num = (a2 - a1) * Math.PI * ((rx + ry) / 2) / space | 0,
     delta = (a2 - a1) * Math.PI / num,
     i = a1 * Math.PI;
    for(var j = 0; j <= num; j++){
     xPos =
      cx - rx * Math.sin(i) * Math.sin(rot * Math.PI)
      + ry * Math.cos(i) * Math.cos(rot * Math.PI);
     xPos = xPos.toFixed(2);
     yPos =
      cy + ry * Math.cos(i) * Math.sin(rot * Math.PI)
      + rx * Math.sin(i) * Math.cos(rot * Math.PI);
     yPos = yPos.toFixed(2);
     if(j == 0)
      ctx.moveTo(xPos, yPos);
     else if(xPos_prev != xPos || yPos_prev != yPos) ctx.lineTo(xPos, yPos);
     xPos_prev = xPos;
     yPos_prev = yPos;
     i -= delta;
    }
    return 0;
   }
   var caml_gr_state;
   function caml_gr_state_get(){
    if(caml_gr_state) return caml_gr_state;
    throw caml_maybe_attach_backtrace
           ([0,
             caml_named_value("Graphics.Graphic_failure"),
             caml_string_of_jsbytes("Not initialized")]);
   }
   function caml_gr_blit_image(im, x, y){
    var
     s = caml_gr_state_get(),
     im2 =
       s.context.getImageData
        (x, s.height - im.height - y, im.width, im.height);
    for(var i = 0; i < im2.data.length; i += 4){
     im.data[i] = im2.data[i];
     im.data[i + 1] = im2.data[i + 1];
     im.data[i + 2] = im2.data[i + 2];
     im.data[i + 3] = im2.data[i + 3];
    }
    return 0;
   }
   function caml_gr_clear_graph(){
    var s = caml_gr_state_get();
    s.canvas.width = s.width;
    s.canvas.height = s.height;
    return 0;
   }
   function caml_gr_close_graph(){
    var s = caml_gr_state_get();
    s.canvas.width = 0;
    s.canvas.height = 0;
    return 0;
   }
   function caml_gr_close_subwindow(a){
    caml_failwith("caml_gr_close_subwindow not Implemented");
   }
   function caml_gr_create_image(x, y){
    var s = caml_gr_state_get();
    return s.context.createImageData(x, y);
   }
   function caml_gr_current_x(){var s = caml_gr_state_get(); return s.x;}
   function caml_gr_current_y(){var s = caml_gr_state_get(); return s.y;}
   function caml_gr_display_mode(){
    caml_failwith("caml_gr_display_mode not Implemented");
   }
   function caml_gr_doc_of_state(state){
    if(state.canvas.ownerDocument) return state.canvas.ownerDocument;
   }
   function caml_gr_draw_arc(x, y, rx, ry, a1, a2){
    var s = caml_gr_state_get();
    s.context.beginPath();
    caml_gr_arc_aux(s.context, x, s.height - y, rx, ry, a1, a2);
    s.context.stroke();
    return 0;
   }
   function caml_gr_draw_str(str){
    var s = caml_gr_state_get(), m = s.context.measureText(str), dx = m.width;
    s.context.fillText(str, s.x, s.height - s.y);
    s.x += dx | 0;
    return 0;
   }
   function caml_gr_draw_char(c){
    caml_gr_draw_str(String.fromCharCode(c));
    return 0;
   }
   function caml_gr_draw_image(im, x, y){
    var s = caml_gr_state_get();
    if(! im.image){
     var canvas = document.createElement("canvas");
     canvas.width = s.width;
     canvas.height = s.height;
     canvas.getContext("2d").putImageData(im, 0, 0);
     var image = new globalThis.Image();
     image.onload =
      function(){
       s.context.drawImage(image, x, s.height - im.height - y);
       im.image = image;
      };
     image.src = canvas.toDataURL("image/png");
    }
    else
     s.context.drawImage(im.image, x, s.height - im.height - y);
    return 0;
   }
   function caml_gr_draw_rect(x, y, w, h){
    var s = caml_gr_state_get();
    s.context.strokeRect(x, s.height - y, w, - h);
    return 0;
   }
   function caml_gr_draw_string(str){
    caml_gr_draw_str(caml_jsstring_of_string(str));
    return 0;
   }
   function caml_gr_dump_image(im){
    var data = [0];
    for(var i = 0; i < im.height; i++){
     data[i + 1] = [0];
     for(var j = 0; j < im.width; j++){
      var
       o = i * (im.width * 4) + j * 4,
       r = im.data[o + 0],
       g = im.data[o + 1],
       b = im.data[o + 2];
      data[i + 1][j + 1] = (r << 16) + (g << 8) + b;
     }
    }
    return data;
   }
   function caml_gr_fill_arc(x, y, rx, ry, a1, a2){
    var s = caml_gr_state_get();
    s.context.beginPath();
    caml_gr_arc_aux(s.context, x, s.height - y, rx, ry, a1, a2);
    s.context.fill();
    return 0;
   }
   function caml_gr_fill_poly(ar){
    var s = caml_gr_state_get();
    s.context.beginPath();
    s.context.moveTo(ar[1][1], s.height - ar[1][2]);
    for(var i = 2; i < ar.length; i++)
     s.context.lineTo(ar[i][1], s.height - ar[i][2]);
    s.context.lineTo(ar[1][1], s.height - ar[1][2]);
    s.context.fill();
    return 0;
   }
   function caml_gr_fill_rect(x, y, w, h){
    var s = caml_gr_state_get();
    s.context.fillRect(x, s.height - y, w, - h);
    return 0;
   }
   function caml_gr_lineto(x, y){
    var s = caml_gr_state_get();
    s.context.beginPath();
    s.context.moveTo(s.x, s.height - s.y);
    s.context.lineTo(x, s.height - y);
    s.context.stroke();
    s.x = x;
    s.y = y;
    return 0;
   }
   function caml_gr_make_image(arr){
    var
     s = caml_gr_state_get(),
     h = arr.length - 1,
     w = arr[1].length - 1,
     im = s.context.createImageData(w, h);
    for(var i = 0; i < h; i++)
     for(var j = 0; j < w; j++){
      var c = arr[i + 1][j + 1], o = i * (w * 4) + j * 4;
      if(c == - 1){
       im.data[o + 0] = 0;
       im.data[o + 1] = 0;
       im.data[o + 2] = 0;
       im.data[o + 3] = 0;
      }
      else{
       im.data[o + 0] = c >> 16 & 0xff;
       im.data[o + 1] = c >> 8 & 0xff;
       im.data[o + 2] = c >> 0 & 0Xff;
       im.data[o + 3] = 0xff;
      }
     }
    return im;
   }
   function caml_gr_moveto(x, y){
    var s = caml_gr_state_get();
    s.x = x;
    s.y = y;
    return 0;
   }
   function caml_gr_set_window_title(name){
    var s = caml_gr_state_get();
    s.title = name;
    var jsname = caml_jsstring_of_string(name);
    if(s.set_title) s.set_title(jsname);
    return 0;
   }
   function caml_gr_set_line_width(w){
    var s = caml_gr_state_get();
    s.line_width = w;
    s.context.lineWidth = w;
    return 0;
   }
   function caml_gr_set_text_size(size){
    var s = caml_gr_state_get();
    s.text_size = size;
    s.context.font = s.text_size + "px " + caml_jsstring_of_string(s.font);
    return 0;
   }
   function caml_gr_set_font(f){
    var s = caml_gr_state_get();
    s.font = f;
    s.context.font = s.text_size + "px " + caml_jsstring_of_string(s.font);
    return 0;
   }
   function caml_gr_set_color(color){
    var s = caml_gr_state_get();
    function convert(number){
     var str = "" + number.toString(16);
     while(str.length < 2) str = "0" + str;
     return str;
    }
    var r = color >> 16 & 0xff, g = color >> 8 & 0xff, b = color >> 0 & 0xff;
    s.color = color;
    var c_str = "#" + convert(r) + convert(g) + convert(b);
    s.context.fillStyle = c_str;
    s.context.strokeStyle = c_str;
    return 0;
   }
   function caml_gr_resize_window(w, h){
    var s = caml_gr_state_get();
    s.width = w;
    s.height = h;
    s.canvas.width = w;
    s.canvas.height = h;
    return 0;
   }
   function caml_gr_state_init(){
    caml_gr_moveto(caml_gr_state.x, caml_gr_state.y);
    caml_gr_resize_window(caml_gr_state.width, caml_gr_state.height);
    caml_gr_set_line_width(caml_gr_state.line_width);
    caml_gr_set_text_size(caml_gr_state.text_size);
    caml_gr_set_font(caml_gr_state.font);
    caml_gr_set_color(caml_gr_state.color);
    caml_gr_set_window_title(caml_gr_state.title);
    caml_gr_state.context.textBaseline = "bottom";
   }
   function caml_gr_state_set(ctx){
    caml_gr_state = ctx;
    caml_gr_state_init();
    return 0;
   }
   function caml_gr_state_create(canvas, w, h){
    var context = canvas.getContext("2d");
    return {context: context,
            canvas: canvas,
            x: 0,
            y: 0,
            width: w,
            height: h,
            line_width: 1,
            font: caml_string_of_jsbytes("fixed"),
            text_size: 26,
            color: 0x000000,
            title: caml_string_of_jsbytes("")};
   }
   function caml_gr_open_graph(info){
    var info = caml_jsstring_of_string(info);
    function get(name){
     var res = info.match("(^|,) *" + name + " *= *([a-zA-Z0-9_]+) *(,|$)");
     if(res) return res[2];
    }
    var specs = [];
    if(! (info == "")) specs.push(info);
    var target = get("target");
    if(! target) target = "";
    var status = get("status");
    if(! status) specs.push("status=1");
    var w = get("width");
    w = w ? parseInt(w) : 200;
    specs.push("width=" + w);
    var h = get("height");
    h = h ? parseInt(h) : 200;
    specs.push("height=" + h);
    var win = globalThis.open("about:blank", target, specs.join(","));
    if(! win) caml_failwith("Graphics.open_graph: cannot open the window");
    var doc = win.document, canvas = doc.createElement("canvas");
    canvas.width = w;
    canvas.height = h;
    var ctx = caml_gr_state_create(canvas, w, h);
    ctx.set_title = function(title){doc.title = title;};
    caml_gr_state_set(ctx);
    var body = doc.body;
    body.style.margin = "0px";
    body.appendChild(canvas);
    return 0;
   }
   function caml_gr_open_subwindow(a, b, c, d){
    caml_failwith("caml_gr_open_subwindow not Implemented");
   }
   function caml_gr_plot(x, y){
    var
     s = caml_gr_state_get(),
     im = s.context.createImageData(1, 1),
     d = im.data,
     color = s.color;
    d[0] = color >> 16 & 0xff;
    d[1] = color >> 8 & 0xff, d[2] = color >> 0 & 0xff;
    d[3] = 0xFF;
    s.x = x;
    s.y = y;
    s.context.putImageData(im, x, s.height - y);
    return 0;
   }
   function caml_gr_point_color(x, y){
    var
     s = caml_gr_state_get(),
     im = s.context.getImageData(x, s.height - y, 1, 1),
     d = im.data;
    return (d[0] << 16) + (d[1] << 8) + d[2];
   }
   function caml_gr_remember_mode(){
    caml_failwith("caml_gr_remember_mode not Implemented");
   }
   function caml_gr_sigio_handler(){return 0;}
   function caml_gr_sigio_signal(){return 0;}
   function caml_gr_size_x(){var s = caml_gr_state_get(); return s.width;}
   function caml_gr_size_y(){var s = caml_gr_state_get(); return s.height;}
   function caml_gr_synchronize(){
    caml_failwith("caml_gr_synchronize not Implemented");
   }
   function caml_gr_text_size(txt){
    var
     s = caml_gr_state_get(),
     w = s.context.measureText(caml_jsstring_of_string(txt)).width;
    return [0, w, s.text_size];
   }
   function caml_gr_wait_event(_evl){
    caml_failwith
     ("caml_gr_wait_event not Implemented: use Graphics_js instead");
   }
   function caml_gr_window_id(a){
    caml_failwith("caml_gr_window_id not Implemented");
   }
   function caml_greaterequal(x, y){
    return + (caml_compare_val(x, y, false) >= 0);
   }
   function caml_greaterthan(x, y){
    return + (caml_compare_val(x, y, false) > 0);
   }
   function caml_hash_mix_jsbytes(h, s){
    var len = s.length, i, w;
    for(i = 0; i + 4 <= len; i += 4){
     w =
      s.charCodeAt(i) | s.charCodeAt(i + 1) << 8 | s.charCodeAt(i + 2) << 16
      | s.charCodeAt(i + 3) << 24;
     h = caml_hash_mix_int(h, w);
    }
    w = 0;
    switch(len & 3){
      case 3:
       w = s.charCodeAt(i + 2) << 16;
      case 2:
       w |= s.charCodeAt(i + 1) << 8;
      case 1:
       w |= s.charCodeAt(i); h = caml_hash_mix_int(h, w);
    }
    h ^= len;
    return h;
   }
   function caml_hash_mix_string(h, v){
    return caml_hash_mix_jsbytes(h, caml_jsbytes_of_string(v));
   }
   function caml_hash_mix_bytes_arr(h, s){
    var len = s.length, i, w;
    for(i = 0; i + 4 <= len; i += 4){
     w = s[i] | s[i + 1] << 8 | s[i + 2] << 16 | s[i + 3] << 24;
     h = caml_hash_mix_int(h, w);
    }
    w = 0;
    switch(len & 3){
      case 3:
       w = s[i + 2] << 16;
      case 2:
       w |= s[i + 1] << 8;
      case 1:
       w |= s[i]; h = caml_hash_mix_int(h, w);
    }
    h ^= len;
    return h;
   }
   function caml_ml_bytes_content(s){
    switch(s.t & 6){
      default: caml_convert_string_to_bytes(s);
      case 0:
       return s.c;
      case 4:
       return s.c;
    }
   }
   function caml_hash_mix_bytes(h, v){
    var content = caml_ml_bytes_content(v);
    return typeof content === "string"
            ? caml_hash_mix_jsbytes(h, content)
            : caml_hash_mix_bytes_arr(h, content);
   }
   function caml_hash_mix_final(h){
    h ^= h >>> 16;
    h = caml_mul(h, 0x85ebca6b | 0);
    h ^= h >>> 13;
    h = caml_mul(h, 0xc2b2ae35 | 0);
    h ^= h >>> 16;
    return h;
   }
   function caml_hash(count, limit, seed, obj){
    var queue, rd, wr, sz, num, h, v, i, len;
    sz = limit;
    if(sz < 0 || sz > 256) sz = 256;
    num = count;
    h = seed;
    queue = [obj];
    rd = 0;
    wr = 1;
    while(rd < wr && num > 0){
     v = queue[rd++];
     if(v && v.caml_custom){
      if
       (caml_custom_ops[v.caml_custom] && caml_custom_ops[v.caml_custom].hash){
       var hh = caml_custom_ops[v.caml_custom].hash(v);
       h = caml_hash_mix_int(h, hh);
       num--;
      }
     }
     else if(v instanceof Array && v[0] === (v[0] | 0))
      switch(v[0]){
        case 248:
         h = caml_hash_mix_int(h, v[2]); num--; break;
        case 250:
         queue[--rd] = v[1]; break;
        default:
         if(caml_is_continuation_tag(v[0])) break;
         var tag = v.length - 1 << 10 | v[0];
         h = caml_hash_mix_int(h, tag);
         for(i = 1, len = v.length; i < len; i++){if(wr >= sz) break; queue[wr++] = v[i];
         }
         break;
      }
     else if(caml_is_ml_bytes(v)){
      h = caml_hash_mix_bytes(h, v);
      num--;
     }
     else if(caml_is_ml_string(v)){
      h = caml_hash_mix_string(h, v);
      num--;
     }
     else if(typeof v === "string"){
      h = caml_hash_mix_jsbytes(h, v);
      num--;
     }
     else if(v === (v | 0)){
      h = caml_hash_mix_int(h, v + v + 1);
      num--;
     }
     else if(typeof v === "number"){h = caml_hash_mix_float(h, v); num--;}
    }
    h = caml_hash_mix_final(h);
    return h & 0x3FFFFFFF;
   }
   function caml_hash_mix_bigstring(h, bs){
    return caml_hash_mix_bytes_arr(h, bs.data);
   }
   function num_digits_nat(nat, ofs, len){
    for(var i = len - 1; i >= 0; i--) if(nat.data[ofs + i] != 0) return i + 1;
    return 1;
   }
   function caml_hash_nat(x){
    var len = num_digits_nat(x, 0, x.data.length), h = 0;
    for(var i = 0; i < len; i++) h = caml_hash_mix_int(h, x.data[i]);
    return h;
   }
   function caml_hexstring_of_float(x, prec, style){
    if(! isFinite(x)){
     if(isNaN(x)) return caml_string_of_jsstring("nan");
     return caml_string_of_jsstring(x > 0 ? "infinity" : "-infinity");
    }
    var sign = x == 0 && 1 / x == - Infinity ? 1 : x >= 0 ? 0 : 1;
    if(sign) x = - x;
    var exp = 0;
    if(x == 0)
     ;
    else if(x < 1)
     while(x < 1 && exp > - 1022){x *= 2; exp--;}
    else
     while(x >= 2){x /= 2; exp++;}
    var exp_sign = exp < 0 ? "" : "+", sign_str = "";
    if(sign)
     sign_str = "-";
    else
     switch(style){
       case 43:
        sign_str = "+"; break;
       case 32:
        sign_str = " "; break;
       default: break;
     }
    if(prec >= 0 && prec < 13){
     var cst = Math.pow(2, prec * 4);
     x = Math.round(x * cst) / cst;
    }
    var x_str = x.toString(16);
    if(prec >= 0){
     var idx = x_str.indexOf(".");
     if(idx < 0)
      x_str += "." + caml_str_repeat(prec, "0");
     else{
      var size = idx + 1 + prec;
      if(x_str.length < size)
       x_str += caml_str_repeat(size - x_str.length, "0");
      else
       x_str = x_str.substr(0, size);
     }
    }
    return caml_string_of_jsstring
            (sign_str + "0x" + x_str + "p" + exp_sign + exp.toString(10));
   }
   function caml_hypot_float(x, y){return Math.hypot(x, y);}
   var caml_marshal_header_size = 20;
   function caml_refill(chan){
    if(chan.refill != null){
     var str = chan.refill(), str_a = caml_uint8_array_of_string(str);
     if(str_a.length == 0)
      chan.refill = null;
     else{
      if(chan.buffer.length < chan.buffer_max + str_a.length){
       var b = new Uint8Array(chan.buffer_max + str_a.length);
       b.set(chan.buffer);
       chan.buffer = b;
      }
      chan.buffer.set(str_a, chan.buffer_max);
      chan.offset += str_a.length;
      chan.buffer_max += str_a.length;
     }
    }
    else{
     var
      nread =
        chan.file.read
         (chan.offset,
          chan.buffer,
          chan.buffer_max,
          chan.buffer.length - chan.buffer_max);
     chan.offset += nread;
     chan.buffer_max += nread;
    }
   }
   function caml_raise_end_of_file(){
    caml_raise_constant(caml_global_data.End_of_file);
   }
   function caml_marshal_data_size(s, ofs){
    var r = new UInt8ArrayReader(caml_uint8_array_of_bytes(s), ofs);
    function readvlq(overflow){
     var c = r.read8u(), n = c & 0x7F;
     while((c & 0x80) != 0){
      c = r.read8u();
      var n7 = n << 7;
      if(n != n7 >> 7) overflow[0] = true;
      n = n7 | c & 0x7F;
     }
     return n;
    }
    switch(r.read32u()){
      case 0x8495A6BE:
       var header_len = 20, data_len = r.read32u(); break;
      case 0x8495A6BD:
       var
        header_len = r.read8u() & 0x3F,
        overflow = [false],
        data_len = readvlq(overflow);
       if(overflow[0])
        caml_failwith
         ("Marshal.data_size: object too large to be read back on this platform");
       break;
      case 0x8495A6BF:
      default: caml_failwith("Marshal.data_size: bad object"); break;
    }
    return header_len - caml_marshal_header_size + data_len;
   }
   function caml_input_value_from_reader(reader, ofs){
    function readvlq(overflow){
     var c = reader.read8u(), n = c & 0x7F;
     while((c & 0x80) != 0){
      c = reader.read8u();
      var n7 = n << 7;
      if(n != n7 >> 7) overflow[0] = true;
      n = n7 | c & 0x7F;
     }
     return n;
    }
    var magic = reader.read32u();
    switch(magic){
      case 0x8495A6BE:
       var
        header_len = 20,
        compressed = 0,
        data_len = reader.read32u(),
        uncompressed_data_len = data_len,
        num_objects = reader.read32u(),
        _size_32 = reader.read32u(),
        _size_64 = reader.read32u();
       break;
      case 0x8495A6BD:
       var
        header_len = reader.read8u() & 0x3F,
        compressed = 1,
        overflow = [false],
        data_len = readvlq(overflow),
        uncompressed_data_len = readvlq(overflow),
        num_objects = readvlq(overflow),
        _size_32 = readvlq(overflow),
        _size_64 = readvlq(overflow);
       if(overflow[0])
        caml_failwith
         ("caml_input_value_from_reader: object too large to be read back on this platform");
       break;
      case 0x8495A6BF:
       caml_failwith
        ("caml_input_value_from_reader: object too large to be read back on a 32-bit platform");
       break;
      default:
       caml_failwith("caml_input_value_from_reader: bad object"); break;
    }
    var
     stack = [],
     intern_obj_table = num_objects > 0 ? [] : null,
     obj_counter = 0;
    function intern_rec(reader){
     var code = reader.read8u();
     if(code >= 0x40)
      if(code >= 0x80){
       var tag = code & 0xF, size = code >> 4 & 0x7, v = [tag];
       if(size == 0) return v;
       if(intern_obj_table) intern_obj_table[obj_counter++] = v;
       stack.push(v, size);
       return v;
      }
      else
       return code & 0x3F;
     else if(code >= 0x20){
      var len = code & 0x1F, v = reader.readstr(len);
      if(intern_obj_table) intern_obj_table[obj_counter++] = v;
      return v;
     }
     else
      switch(code){
        case 0x00:
         return reader.read8s();
        case 0x01:
         return reader.read16s();
        case 0x02:
         return reader.read32s();
        case 0x03:
         caml_failwith("input_value: integer too large"); break;
        case 0x04:
         var offset = reader.read8u();
         if(compressed == 0) offset = obj_counter - offset;
         return intern_obj_table[offset];
        case 0x05:
         var offset = reader.read16u();
         if(compressed == 0) offset = obj_counter - offset;
         return intern_obj_table[offset];
        case 0x06:
         var offset = reader.read32u();
         if(compressed == 0) offset = obj_counter - offset;
         return intern_obj_table[offset];
        case 0x08:
         var
          header = reader.read32u(),
          tag = header & 0xFF,
          size = header >> 10,
          v = [tag];
         if(size == 0) return v;
         if(intern_obj_table) intern_obj_table[obj_counter++] = v;
         stack.push(v, size);
         return v;
        case 0x13:
         caml_failwith("input_value: data block too large"); break;
        case 0x09:
         var len = reader.read8u(), v = reader.readstr(len);
         if(intern_obj_table) intern_obj_table[obj_counter++] = v;
         return v;
        case 0x0A:
         var len = reader.read32u(), v = reader.readstr(len);
         if(intern_obj_table) intern_obj_table[obj_counter++] = v;
         return v;
        case 0x0C:
         var t = new Array(8);
         for(var i = 0; i < 8; i++) t[7 - i] = reader.read8u();
         var v = caml_float_of_bytes(t);
         if(intern_obj_table) intern_obj_table[obj_counter++] = v;
         return v;
        case 0x0B:
         var t = new Array(8);
         for(var i = 0; i < 8; i++) t[i] = reader.read8u();
         var v = caml_float_of_bytes(t);
         if(intern_obj_table) intern_obj_table[obj_counter++] = v;
         return v;
        case 0x0E:
         var len = reader.read8u(), v = new Array(len + 1);
         v[0] = 254;
         var t = new Array(8);
         if(intern_obj_table) intern_obj_table[obj_counter++] = v;
         for(var i = 1; i <= len; i++){
          for(var j = 0; j < 8; j++) t[7 - j] = reader.read8u();
          v[i] = caml_float_of_bytes(t);
         }
         return v;
        case 0x0D:
         var len = reader.read8u(), v = new Array(len + 1);
         v[0] = 254;
         var t = new Array(8);
         if(intern_obj_table) intern_obj_table[obj_counter++] = v;
         for(var i = 1; i <= len; i++){
          for(var j = 0; j < 8; j++) t[j] = reader.read8u();
          v[i] = caml_float_of_bytes(t);
         }
         return v;
        case 0x07:
         var len = reader.read32u(), v = new Array(len + 1);
         v[0] = 254;
         if(intern_obj_table) intern_obj_table[obj_counter++] = v;
         var t = new Array(8);
         for(var i = 1; i <= len; i++){
          for(var j = 0; j < 8; j++) t[7 - j] = reader.read8u();
          v[i] = caml_float_of_bytes(t);
         }
         return v;
        case 0x0F:
         var len = reader.read32u(), v = new Array(len + 1);
         v[0] = 254;
         var t = new Array(8);
         for(var i = 1; i <= len; i++){
          for(var j = 0; j < 8; j++) t[j] = reader.read8u();
          v[i] = caml_float_of_bytes(t);
         }
         return v;
        case 0x10:
        case 0x11:
         caml_failwith("input_value: code pointer"); break;
        case 0x12:
        case 0x18:
        case 0x19:
         var c, s = "";
         while((c = reader.read8u()) != 0) s += String.fromCharCode(c);
         var ops = caml_custom_ops[s], expected_size;
         if(! ops)
          caml_failwith("input_value: unknown custom block identifier");
         switch(code){
           case 0x12: break;
           case 0x19:
            if(! ops.fixed_length)
             caml_failwith("input_value: expected a fixed-size custom block");
            expected_size = ops.fixed_length;
            break;
           case 0x18:
            expected_size = reader.read32u();
            reader.read32s();
            reader.read32s();
            break;
         }
         var
          old_pos = reader.i,
          size = [0],
          v = ops.deserialize(reader, size);
         if(expected_size != undefined)
          if(expected_size != size[0])
           caml_failwith
            ("input_value: incorrect length of serialized custom block");
         if(intern_obj_table) intern_obj_table[obj_counter++] = v;
         return v;
        default: caml_failwith("input_value: ill-formed message");
      }
    }
    if(compressed)
     if(caml_decompress_input)
      var
       data = reader.readuint8array(data_len),
       res = new Uint8Array(uncompressed_data_len),
       res = caml_decompress_input(data, res),
       reader = new UInt8ArrayReader(res, 0);
     else
      caml_failwith("input_value: compressed object, cannot decompress");
    var res = intern_rec(reader);
    while(stack.length > 0){
     var size = stack.pop(), v = stack.pop(), d = v.length;
     if(d < size) stack.push(v, size);
     v[d] = intern_rec(reader);
    }
    if(typeof ofs != "number") ofs[0] = reader.i;
    return res;
   }
   function caml_string_of_bytes(s){
    s.t & 6 && caml_convert_string_to_bytes(s);
    return caml_string_of_jsbytes(s.c);
   }
   function caml_input_value_from_bytes(s, ofs){
    var
     reader =
       new
        MlStringReader
        (caml_string_of_bytes(s), typeof ofs == "number" ? ofs : ofs[0]);
    return caml_input_value_from_reader(reader, ofs);
   }
   function caml_input_value(chanid){
    var
     chan = caml_ml_channel_get(chanid),
     header = new Uint8Array(caml_marshal_header_size);
    function block(buffer, offset, n){
     var r = 0;
     while(r < n){
      if(chan.buffer_curr >= chan.buffer_max){
       chan.buffer_curr = 0;
       chan.buffer_max = 0;
       caml_refill(chan);
      }
      if(chan.buffer_curr >= chan.buffer_max) break;
      buffer[offset + r] = chan.buffer[chan.buffer_curr];
      chan.buffer_curr++;
      r++;
     }
     return r;
    }
    var r = block(header, 0, caml_marshal_header_size);
    if(r == 0)
     caml_raise_end_of_file();
    else if(r < caml_marshal_header_size)
     caml_failwith("input_value: truncated object");
    var
     len = caml_marshal_data_size(caml_bytes_of_array(header), 0),
     buf = new Uint8Array(len + caml_marshal_header_size);
    buf.set(header, 0);
    var r = block(buf, caml_marshal_header_size, len);
    if(r < len)
     caml_failwith("input_value: truncated object " + r + "  " + len);
    var
     offset = [0],
     res = caml_input_value_from_bytes(caml_bytes_of_array(buf), offset);
    chan.offset = chan.offset + offset[0];
    return res;
   }
   function caml_input_value_from_string(s, ofs){
    var reader = new MlStringReader(s, typeof ofs == "number" ? ofs : ofs[0]);
    return caml_input_value_from_reader(reader, ofs);
   }
   function caml_input_value_to_outside_heap(c){return caml_input_value(c);}
   function caml_install_signal_handler(){return 0;}
   function caml_int32_bswap(x){
    return (x & 0x000000FF) << 24 | (x & 0x0000FF00) << 8
           | (x & 0x00FF0000) >>> 8
           | (x & 0xFF000000) >>> 24;
   }
   function caml_int64_add(x, y){return x.add(y);}
   function caml_int64_and(x, y){return x.and(y);}
   function caml_int64_bswap(x){
    var y = caml_int64_to_bytes(x);
    return caml_int64_of_bytes
            ([y[7], y[6], y[5], y[4], y[3], y[2], y[1], y[0]]);
   }
   function caml_int64_div(x, y){return x.div(y);}
   function caml_int64_is_zero(x){return + x.isZero();}
   function caml_int64_of_int32(x){
    return new MlInt64(x & 0xffffff, x >> 24 & 0xffffff, x >> 31 & 0xffff);
   }
   function caml_int64_to_int32(x){return x.toInt();}
   function caml_int64_is_negative(x){return + x.isNeg();}
   function caml_int64_neg(x){return x.neg();}
   function caml_int64_format(fmt, x){
    var f = caml_parse_format(fmt);
    if(f.signedconv && caml_int64_is_negative(x)){f.sign = - 1; x = caml_int64_neg(x);}
    var
     buffer = "",
     wbase = caml_int64_of_int32(f.base),
     cvtbl = "0123456789abcdef";
    do{
     var p = x.udivmod(wbase);
     x = p.quotient;
     buffer = cvtbl.charAt(caml_int64_to_int32(p.modulus)) + buffer;
    }
    while
     (! caml_int64_is_zero(x));
    if(f.prec >= 0){
     f.filler = " ";
     var n = f.prec - buffer.length;
     if(n > 0) buffer = caml_str_repeat(n, "0") + buffer;
    }
    return caml_finish_formatting(f, buffer);
   }
   function caml_int64_mod(x, y){return x.mod(y);}
   function caml_int64_mul(x, y){return x.mul(y);}
   function caml_int64_ult(x, y){return x.ucompare(y) < 0;}
   function caml_parse_sign_and_base(s){
    var i = 0, len = caml_ml_string_length(s), base = 10, sign = 1;
    if(len > 0)
     switch(caml_string_unsafe_get(s, i)){
       case 45:
        i++; sign = - 1; break;
       case 43:
        i++; sign = 1; break;
     }
    if(i + 1 < len && caml_string_unsafe_get(s, i) == 48)
     switch(caml_string_unsafe_get(s, i + 1)){
       case 120:
       case 88:
        base = 16; i += 2; break;
       case 111:
       case 79:
        base = 8; i += 2; break;
       case 98:
       case 66:
        base = 2; i += 2; break;
       case 117:
       case 85:
        i += 2; break;
     }
    return [i, sign, base];
   }
   function caml_parse_digit(c){
    if(c >= 48 && c <= 57) return c - 48;
    if(c >= 65 && c <= 90) return c - 55;
    if(c >= 97 && c <= 122) return c - 87;
    return - 1;
   }
   function caml_int64_of_string(s){
    var
     r = caml_parse_sign_and_base(s),
     i = r[0],
     sign = r[1],
     base = r[2],
     base64 = caml_int64_of_int32(base),
     threshold =
       new MlInt64(0xffffff, 0xfffffff, 0xffff).udivmod(base64).quotient,
     c = caml_string_unsafe_get(s, i),
     d = caml_parse_digit(c);
    if(d < 0 || d >= base) caml_failwith("int_of_string");
    var res = caml_int64_of_int32(d);
    for(;;){
     i++;
     c = caml_string_unsafe_get(s, i);
     if(c == 95) continue;
     d = caml_parse_digit(c);
     if(d < 0 || d >= base) break;
     if(caml_int64_ult(threshold, res)) caml_failwith("int_of_string");
     d = caml_int64_of_int32(d);
     res = caml_int64_add(caml_int64_mul(base64, res), d);
     if(caml_int64_ult(res, d)) caml_failwith("int_of_string");
    }
    if(i != caml_ml_string_length(s)) caml_failwith("int_of_string");
    if(base == 10 && caml_int64_ult(new MlInt64(0, 0, 0x8000), res))
     caml_failwith("int_of_string");
    if(sign < 0) res = caml_int64_neg(res);
    return res;
   }
   function caml_int64_or(x, y){return x.or(y);}
   function caml_int64_shift_left(x, s){return x.shift_left(s);}
   function caml_int64_shift_right(x, s){return x.shift_right(s);}
   function caml_int64_shift_right_unsigned(x, s){return x.shift_right_unsigned(s);
   }
   function caml_int64_sub(x, y){return x.sub(y);}
   function caml_int64_to_float(x){return x.toFloat();}
   function caml_int64_xor(x, y){return x.xor(y);}
   function caml_int_of_string(s){
    var
     r = caml_parse_sign_and_base(s),
     i = r[0],
     sign = r[1],
     base = r[2],
     len = caml_ml_string_length(s),
     threshold = - 1 >>> 0,
     c = i < len ? caml_string_unsafe_get(s, i) : 0,
     d = caml_parse_digit(c);
    if(d < 0 || d >= base) caml_failwith("int_of_string");
    var res = d;
    for(i++; i < len; i++){
     c = caml_string_unsafe_get(s, i);
     if(c == 95) continue;
     d = caml_parse_digit(c);
     if(d < 0 || d >= base) break;
     res = base * res + d;
     if(res > threshold) caml_failwith("int_of_string");
    }
    if(i != len) caml_failwith("int_of_string");
    res = sign * res;
    if(base == 10 && (res | 0) != res) caml_failwith("int_of_string");
    return res | 0;
   }
   function caml_is_js(){return 1;}
   function caml_is_printable(c){return + (c > 31 && c < 127);}
   function caml_js_call(f, o, args){
    return f.apply(o, caml_js_from_array(args));
   }
   function caml_js_delete(o, f){delete o[f]; return 0;}
   function caml_js_equals(x, y){return + (x == y);}
   function caml_js_error_of_exception(exn){
    if(exn.js_error) return exn.js_error;
    return null;
   }
   function caml_js_error_option_of_exception(exn){
    if(exn.js_error) return [0, exn.js_error];
    return 0;
   }
   function caml_js_eval_string(s){return eval(caml_jsstring_of_string(s));}
   function caml_js_expr(s){
    console.error("caml_js_expr: fallback to runtime evaluation\n");
    return eval(caml_jsstring_of_string(s));
   }
   function caml_js_from_bool(x){return ! ! x;}
   function caml_js_from_float(x){return x;}
   function caml_js_from_string(s){return caml_jsstring_of_string(s);}
   function caml_js_fun_call(f, a){
    switch(a.length){
      case 1:
       return f();
      case 2:
       return f(a[1]);
      case 3:
       return f(a[1], a[2]);
      case 4:
       return f(a[1], a[2], a[3]);
      case 5:
       return f(a[1], a[2], a[3], a[4]);
      case 6:
       return f(a[1], a[2], a[3], a[4], a[5]);
      case 7:
       return f(a[1], a[2], a[3], a[4], a[5], a[6]);
      case 8:
       return f(a[1], a[2], a[3], a[4], a[5], a[6], a[7]);
    }
    return f.apply(null, caml_js_from_array(a));
   }
   function caml_js_function_arity(f){return f.l >= 0 ? f.l : f.l = f.length;}
   function caml_js_get(o, f){return o[f];}
   function caml_js_get_console(){
    var
     c = console,
     m =
       ["log",
        "debug",
        "info",
        "warn",
        "error",
        "assert",
        "dir",
        "dirxml",
        "trace",
        "group",
        "groupCollapsed",
        "groupEnd",
        "time",
        "timeEnd"];
    function f(){}
    for(var i = 0; i < m.length; i++) if(! c[m[i]]) c[m[i]] = f;
    return c;
   }
   function caml_js_html_entities(s){
    var entity = /^&#?[0-9a-zA-Z]+;$/;
    if(s.match(entity)){
     var str, temp = document.createElement("p");
     temp.innerHTML = s;
     str = temp.textContent || temp.innerText;
     temp = null;
     return str;
    }
    else
     caml_failwith("Invalid entity " + s);
   }
   var caml_js_regexps = {amp: /&/g, lt: /</g, quot: /\"/g, all: /[&<\"]/};
   function caml_js_html_escape(s){
    if(! caml_js_regexps.all.test(s)) return s;
    return s.replace(caml_js_regexps.amp, "&amp;").replace
             (caml_js_regexps.lt, "&lt;").replace
            (caml_js_regexps.quot, "&quot;");
   }
   function caml_js_instanceof(o, c){return o instanceof c ? 1 : 0;}
   function caml_js_meth_call(o, f, args){
    return o[caml_jsstring_of_string(f)].apply(o, caml_js_from_array(args));
   }
   function caml_js_new(c, a){
    switch(a.length){
      case 1:
       return new c;
      case 2:
       return new c(a[1]);
      case 3:
       return new c(a[1], a[2]);
      case 4:
       return new c(a[1], a[2], a[3]);
      case 5:
       return new c(a[1], a[2], a[3], a[4]);
      case 6:
       return new c(a[1], a[2], a[3], a[4], a[5]);
      case 7:
       return new c(a[1], a[2], a[3], a[4], a[5], a[6]);
      case 8:
       return new c(a[1], a[2], a[3], a[4], a[5], a[6], a[7]);
    }
    function F(){return c.apply(this, caml_js_from_array(a));}
    F.prototype = c.prototype;
    return new F;
   }
   function caml_js_object(a){
    var o = {};
    for(var i = 1; i < a.length; i++){
     var p = a[i];
     o[caml_jsstring_of_string(p[1])] = p[2];
    }
    return o;
   }
   function caml_js_on_ie(){
    var
     ua =
       globalThis.navigator && globalThis.navigator.userAgent
        ? globalThis.navigator.userAgent
        : "";
    return ua.indexOf("MSIE") != - 1 && ua.indexOf("Opera") != 0;
   }
   function caml_js_pure_expr(f){return caml_callback(f, [0]);}
   function caml_js_set(o, f, v){o[f] = v; return 0;}
   function caml_js_strict_equals(x, y){return + (x === y);}
   function caml_js_to_array(a){
    var len = a.length, b = new Array(len + 1);
    b[0] = 0;
    for(var i = 0; i < len; i++) b[i + 1] = a[i];
    return b;
   }
   function caml_js_to_bool(x){return + x;}
   function caml_js_to_byte_string(s){return caml_string_of_jsbytes(s);}
   function caml_js_to_float(x){return x;}
   function caml_js_to_int32(x){return x | 0;}
   function caml_js_to_string(s){return caml_string_of_jsstring(s);}
   function caml_js_typeof(o){return typeof o;}
   function caml_js_var(x){
    var x = caml_jsstring_of_string(x);
    if(! x.match(/^[a-zA-Z_$][a-zA-Z_$0-9]*(\.[a-zA-Z_$][a-zA-Z_$0-9]*)*$/))
     console.error
      ('caml_js_var: "' + x
       + '" is not a valid JavaScript variable. continuing ..');
    return eval(x);
   }
   function caml_js_wrap_callback(f){
    return function(){
     var len = arguments.length;
     if(len > 0){
      var args = new Array(len);
      for(var i = 0; i < len; i++) args[i] = arguments[i];
     }
     else
      args = [undefined];
     var res = caml_callback(f, args);
     return res instanceof Function ? caml_js_wrap_callback(res) : res;};
   }
   function caml_js_wrap_callback_arguments(f){
    return function(){
     var len = arguments.length, args = new Array(len);
     for(var i = 0; i < len; i++) args[i] = arguments[i];
     return caml_callback(f, [args]);};
   }
   function caml_js_wrap_callback_strict(arity, f){
    return function(){
     var
      n = arguments.length,
      args = new Array(arity),
      len = Math.min(arguments.length, arity);
     for(var i = 0; i < len; i++) args[i] = arguments[i];
     return caml_callback(f, args);};
   }
   function caml_js_wrap_callback_unsafe(f){
    return function(){
     var len = caml_js_function_arity(f), args = new Array(len);
     for(var i = 0; i < len; i++) args[i] = arguments[i];
     return caml_callback(f, args);};
   }
   function caml_js_wrap_meth_callback(f){
    return function(){
     var len = arguments.length, args = new Array(len + 1);
     args[0] = this;
     for(var i = 0; i < len; i++) args[i + 1] = arguments[i];
     var res = caml_callback(f, args);
     return res instanceof Function ? caml_js_wrap_callback(res) : res;};
   }
   function caml_js_wrap_meth_callback_arguments(f){
    return function(){
     var len = arguments.length, args = new Array(len);
     for(var i = 0; i < len; i++) args[i] = arguments[i];
     return caml_callback(f, [this, args]);};
   }
   function caml_js_wrap_meth_callback_strict(arity, f){
    return function(){
     var args = new Array(arity + 1), len = Math.min(arguments.length, arity);
     args[0] = this;
     for(var i = 0; i < len; i++) args[i + 1] = arguments[i];
     return caml_callback(f, args);};
   }
   function caml_js_wrap_meth_callback_unsafe(f){
    return function(){
     var len = caml_js_function_arity(f) - 1, args = new Array(len + 1);
     args[0] = this;
     for(var i = 0; i < len; i++) args[i + 1] = arguments[i];
     return caml_callback(f, args);};
   }
   function caml_jsoo_flags_effects(unit){return 0;}
   function caml_jsoo_flags_use_js_string(unit){return 1;}
   function caml_lazy_make_forward(v){return [250, v];}
   function caml_obj_tag(x){
    if(x instanceof Array && x[0] == x[0] >>> 0)
     return x[0];
    else if(caml_is_ml_bytes(x))
     return 252;
    else if(caml_is_ml_string(x))
     return 252;
    else if(x instanceof Function || typeof x == "function")
     return 247;
    else if(x && x.caml_custom) return 255; else return 1000;
   }
   function caml_lazy_read_result(o){
    return caml_obj_tag(o) == 250 ? o[1] : o;
   }
   function caml_obj_update_tag(b, o, n){
    if(b[0] == o){b[0] = n; return 1;}
    return 0;
   }
   function caml_lazy_reset_to_lazy(o){
    caml_obj_update_tag(o, 244, 246);
    return 0;
   }
   function caml_lazy_update_to_forcing(o){
    return o instanceof Array && o[0] == o[0] >>> 0
            && caml_obj_update_tag(o, 246, 244)
            ? 0
            : 1;
   }
   function caml_lazy_update_to_forward(o){
    caml_obj_update_tag(o, 244, 250);
    return 0;
   }
   function caml_ldexp_float(x, exp){
    exp |= 0;
    if(exp > 1023){
     exp -= 1023;
     x *= Math.pow(2, 1023);
     if(exp > 1023){exp -= 1023; x *= Math.pow(2, 1023);}
    }
    if(exp < - 1023){exp += 1023; x *= Math.pow(2, - 1023);}
    x *= Math.pow(2, exp);
    return x;
   }
   function caml_lessequal(x, y){
    return + (caml_compare_val(x, y, false) <= 0);
   }
   function caml_lessthan(x, y){return + (caml_compare_val(x, y, false) < 0);}
   function caml_lex_array(s){
    s = caml_jsbytes_of_string(s);
    var l = s.length / 2, a = new Array(l);
    for(var i = 0; i < l; i++)
     a[i] = (s.charCodeAt(2 * i) | s.charCodeAt(2 * i + 1) << 8) << 16 >> 16;
    return a;
   }
   function caml_lex_engine(tbl, start_state, lexbuf){
    var
     lex_buffer = 2,
     lex_buffer_len = 3,
     lex_start_pos = 5,
     lex_curr_pos = 6,
     lex_last_pos = 7,
     lex_last_action = 8,
     lex_eof_reached = 9,
     lex_base = 1,
     lex_backtrk = 2,
     lex_default = 3,
     lex_trans = 4,
     lex_check = 5;
    if(! tbl.lex_default){
     tbl.lex_base = caml_lex_array(tbl[lex_base]);
     tbl.lex_backtrk = caml_lex_array(tbl[lex_backtrk]);
     tbl.lex_check = caml_lex_array(tbl[lex_check]);
     tbl.lex_trans = caml_lex_array(tbl[lex_trans]);
     tbl.lex_default = caml_lex_array(tbl[lex_default]);
    }
    var
     c,
     state = start_state,
     buffer = caml_uint8_array_of_bytes(lexbuf[lex_buffer]);
    if(state >= 0){
     lexbuf[lex_last_pos] = lexbuf[lex_start_pos] = lexbuf[lex_curr_pos];
     lexbuf[lex_last_action] = - 1;
    }
    else
     state = - state - 1;
    for(;;){
     var base = tbl.lex_base[state];
     if(base < 0) return - base - 1;
     var backtrk = tbl.lex_backtrk[state];
     if(backtrk >= 0){
      lexbuf[lex_last_pos] = lexbuf[lex_curr_pos];
      lexbuf[lex_last_action] = backtrk;
     }
     if(lexbuf[lex_curr_pos] >= lexbuf[lex_buffer_len])
      if(lexbuf[lex_eof_reached] == 0) return - state - 1; else c = 256;
     else{c = buffer[lexbuf[lex_curr_pos]]; lexbuf[lex_curr_pos]++;}
     if(tbl.lex_check[base + c] == state)
      state = tbl.lex_trans[base + c];
     else
      state = tbl.lex_default[state];
     if(state < 0){
      lexbuf[lex_curr_pos] = lexbuf[lex_last_pos];
      if(lexbuf[lex_last_action] == - 1)
       caml_failwith("lexing: empty token");
      else
       return lexbuf[lex_last_action];
     }
     else if(c == 256) lexbuf[lex_eof_reached] = 0;
    }
   }
   function caml_list_mount_point(){
    var prev = 0;
    for(var i = 0; i < jsoo_mount_point.length; i++){
     var old = prev;
     prev = [0, caml_string_of_jsbytes(jsoo_mount_point[i].path), old];
    }
    return prev;
   }
   function caml_list_of_js_array(a){
    var l = 0;
    for(var i = a.length - 1; i >= 0; i--){var e = a[i]; l = [0, e, l];}
    return l;
   }
   function caml_list_to_js_array(l){
    var a = [];
    for(; l !== 0; l = l[2]) a.push(l[1]);
    return a;
   }
   function caml_log10_float(x){return Math.log10(x);}
   function caml_log1p_float(x){return Math.log1p(x);}
   function caml_log2_float(x){return Math.log2(x);}
   function caml_new_string(s){return caml_string_of_jsbytes(s);}
   function caml_lxm_next(v){
    function shift_l(x, k){return caml_int64_shift_left(x, k);}
    function shift_r(x, k){return caml_int64_shift_right_unsigned(x, k);}
    function or(a, b){return caml_int64_or(a, b);}
    function xor(a, b){return caml_int64_xor(a, b);}
    function add(a, b){return caml_int64_add(a, b);}
    function mul(a, b){return caml_int64_mul(a, b);}
    function rotl(x, k){return or(shift_l(x, k), shift_r(x, 64 - k));}
    function get(a, i){return caml_ba_get_1(a, i);}
    function set(a, i, x){return caml_ba_set_1(a, i, x);}
    var
     M = caml_int64_of_string(caml_new_string("0xd1342543de82ef95")),
     daba = caml_int64_of_string(caml_new_string("0xdaba0b6eb09322e3")),
     z,
     q0,
     q1,
     st = v,
     a = get(st, 0),
     s = get(st, 1),
     x0 = get(st, 2),
     x1 = get(st, 3);
    z = add(s, x0);
    z = mul(xor(z, shift_r(z, 32)), daba);
    z = mul(xor(z, shift_r(z, 32)), daba);
    z = xor(z, shift_r(z, 32));
    set(st, 1, add(mul(s, M), a));
    var q0 = x0, q1 = x1;
    q1 = xor(q1, q0);
    q0 = rotl(q0, 24);
    q0 = xor(xor(q0, q1), shift_l(q1, 16));
    q1 = rotl(q1, 37);
    set(st, 2, q0);
    set(st, 3, q1);
    return z;
   }
   function caml_make_float_vect(len){
    if(len < 0) caml_array_bound_error();
    var len = len + 1 | 0, b = new Array(len);
    b[0] = 254;
    for(var i = 1; i < len; i++) b[i] = 0;
    return b;
   }
   function caml_make_vect(len, init){
    if(len < 0) caml_array_bound_error();
    var len = len + 1 | 0, b = new Array(len);
    b[0] = 0;
    for(var i = 1; i < len; i++) b[i] = init;
    return b;
   }
   var
    caml_marshal_constants =
      {PREFIX_SMALL_BLOCK: 0x80,
       PREFIX_SMALL_INT: 0x40,
       PREFIX_SMALL_STRING: 0x20,
       CODE_INT8: 0x00,
       CODE_INT16: 0x01,
       CODE_INT32: 0x02,
       CODE_INT64: 0x03,
       CODE_SHARED8: 0x04,
       CODE_SHARED16: 0x05,
       CODE_SHARED32: 0x06,
       CODE_BLOCK32: 0x08,
       CODE_BLOCK64: 0x13,
       CODE_STRING8: 0x09,
       CODE_STRING32: 0x0A,
       CODE_DOUBLE_BIG: 0x0B,
       CODE_DOUBLE_LITTLE: 0x0C,
       CODE_DOUBLE_ARRAY8_BIG: 0x0D,
       CODE_DOUBLE_ARRAY8_LITTLE: 0x0E,
       CODE_DOUBLE_ARRAY32_BIG: 0x0F,
       CODE_DOUBLE_ARRAY32_LITTLE: 0x07,
       CODE_CODEPOINTER: 0x10,
       CODE_INFIXPOINTER: 0x11,
       CODE_CUSTOM: 0x12,
       CODE_CUSTOM_LEN: 0x18,
       CODE_CUSTOM_FIXED: 0x19};
   function caml_maybe_print_stats(unit){return 0;}
   function caml_md5_bytes(s, ofs, len){
    var ctx = caml_MD5Init(), a = caml_uint8_array_of_bytes(s);
    caml_MD5Update(ctx, a.subarray(ofs, ofs + len), len);
    return caml_string_of_array(caml_MD5Final(ctx));
   }
   function caml_ml_input_block(chanid, ba, i, l){
    var
     chan = caml_ml_channel_get(chanid),
     n = l,
     avail = chan.buffer_max - chan.buffer_curr;
    if(l <= avail){
     ba.set(chan.buffer.subarray(chan.buffer_curr, chan.buffer_curr + l), i);
     chan.buffer_curr += l;
    }
    else if(avail > 0){
     ba.set
      (chan.buffer.subarray(chan.buffer_curr, chan.buffer_curr + avail), i);
     chan.buffer_curr += avail;
     n = avail;
    }
    else{
     chan.buffer_curr = 0;
     chan.buffer_max = 0;
     caml_refill(chan);
     var avail = chan.buffer_max - chan.buffer_curr;
     if(n > avail) n = avail;
     ba.set(chan.buffer.subarray(chan.buffer_curr, chan.buffer_curr + n), i);
     chan.buffer_curr += n;
    }
    return n | 0;
   }
   function caml_md5_chan(chanid, toread){
    var ctx = caml_MD5Init(), buffer = new Uint8Array(4096);
    if(toread < 0)
     while(true){
      var read = caml_ml_input_block(chanid, buffer, 0, buffer.length);
      if(read == 0) break;
      caml_MD5Update(ctx, buffer.subarray(0, read), read);
     }
    else
     while(toread > 0){
      var
       read =
         caml_ml_input_block
          (chanid, buffer, 0, toread > buffer.length ? buffer.length : toread);
      if(read == 0) caml_raise_end_of_file();
      caml_MD5Update(ctx, buffer.subarray(0, read), read);
      toread -= read;
     }
    return caml_string_of_array(caml_MD5Final(ctx));
   }
   function caml_md5_string(s, ofs, len){
    return caml_md5_bytes(caml_bytes_of_string(s), ofs, len);
   }
   function caml_memprof_discard(t){return 0;}
   function caml_memprof_set(_control){return 0;}
   function caml_memprof_start(rate, stack_size, tracker){return 0;}
   function caml_memprof_stop(unit){return 0;}
   function caml_ml_channel_redirect(captured, into){
    var
     to_restore = caml_ml_channel_get(captured),
     new_ = caml_ml_channel_get(into);
    caml_ml_channels[captured] = new_;
    return to_restore;
   }
   function caml_ml_channel_restore(captured, to_restore){caml_ml_channels[captured] = to_restore; return 0;
   }
   function caml_ml_channel_size(chanid){
    var chan = caml_ml_channel_get(chanid);
    return chan.file.length();
   }
   function caml_ml_channel_size_64(chanid){
    var chan = caml_ml_channel_get(chanid);
    return caml_int64_of_float(chan.file.length());
   }
   var caml_sys_fds = new Array(3);
   function caml_sys_close(fd){
    var file = caml_sys_fds[fd];
    if(file) file.close();
    delete caml_sys_fds[fd];
    return 0;
   }
   function caml_ml_flush(chanid){
    var chan = caml_ml_channel_get(chanid);
    if(! chan.opened) caml_raise_sys_error("Cannot flush a closed channel");
    if(! chan.buffer || chan.buffer_curr == 0) return 0;
    if(chan.output)
     chan.output(caml_subarray_to_jsbytes(chan.buffer, 0, chan.buffer_curr));
    else
     chan.file.write(chan.offset, chan.buffer, 0, chan.buffer_curr);
    chan.offset += chan.buffer_curr;
    chan.buffer_curr = 0;
    return 0;
   }
   function caml_ml_close_channel(chanid){
    var chan = caml_ml_channel_get(chanid);
    if(chan.opened){
     chan.opened = false;
     caml_sys_close(chan.fd);
     chan.fd = - 1;
     chan.buffer = new Uint8Array(0);
     chan.buffer_curr = 0;
     chan.buffer_max = 0;
    }
    return 0;
   }
   function caml_ml_condition_broadcast(t){return 0;}
   function caml_ml_condition_new(unit){return {condition: 1};}
   function caml_ml_condition_signal(t){return 0;}
   function caml_ml_condition_wait(t, mutext){return 0;}
   function caml_ml_debug_info_status(){return 0;}
   function caml_ml_domain_cpu_relax(unit){return 0;}
   function caml_ml_domain_id(unit){return caml_domain_id;}
   function caml_ml_domain_set_name(_name){return 0;}
   var caml_ml_domain_unique_token_ = [0];
   function caml_ml_domain_unique_token(unit){return caml_ml_domain_unique_token_;
   }
   var caml_runtime_warnings = 0;
   function caml_ml_enable_runtime_warnings(bool){caml_runtime_warnings = bool; return 0;
   }
   function caml_ml_input(chanid, b, i, l){
    var ba = caml_uint8_array_of_bytes(b);
    return caml_ml_input_block(chanid, ba, i, l);
   }
   function caml_ml_input_bigarray(chanid, b, i, l){
    var ba = caml_ba_to_typed_array(b);
    return caml_ml_input_block(chanid, ba, i, l);
   }
   function caml_ml_input_char(chanid){
    var chan = caml_ml_channel_get(chanid);
    if(chan.buffer_curr >= chan.buffer_max){
     chan.buffer_curr = 0;
     chan.buffer_max = 0;
     caml_refill(chan);
    }
    if(chan.buffer_curr >= chan.buffer_max) caml_raise_end_of_file();
    var res = chan.buffer[chan.buffer_curr];
    chan.buffer_curr++;
    return res;
   }
   function caml_ml_input_int(chanid){
    var chan = caml_ml_channel_get(chanid), res = 0;
    for(var i = 0; i < 4; i++)
     res = (res << 8) + caml_ml_input_char(chanid) | 0;
    return res | 0;
   }
   function caml_ml_input_scan_line(chanid){
    var chan = caml_ml_channel_get(chanid), p = chan.buffer_curr;
    do
     if(p >= chan.buffer_max){
      if(chan.buffer_curr > 0){
       chan.buffer.set(chan.buffer.subarray(chan.buffer_curr), 0);
       p -= chan.buffer_curr;
       chan.buffer_max -= chan.buffer_curr;
       chan.buffer_curr = 0;
      }
      if(chan.buffer_max >= chan.buffer.length) return - chan.buffer_max | 0;
      var prev_max = chan.buffer_max;
      caml_refill(chan);
      if(prev_max == chan.buffer_max) return - chan.buffer_max | 0;
     }
    while
     (chan.buffer[p++] != 10);
    return p - chan.buffer_curr | 0;
   }
   function caml_ml_is_buffered(chanid){
    return caml_ml_channel_get(chanid).buffered ? 1 : 0;
   }
   function caml_ml_mutex_lock(t){
    if(t.locked)
     caml_failwith("Mutex.lock: mutex already locked. Cannot wait.");
    else
     t.locked = true;
    return 0;
   }
   function caml_ml_mutex_new(unit){return new MlMutex();}
   function caml_ml_mutex_try_lock(t){
    if(! t.locked){t.locked = true; return 1;}
    return 0;
   }
   function caml_sys_open_for_node(fd, flags){
    if(flags.name)
     try{
      var fs = require("fs"), fd2 = fs.openSync(flags.name, "rs");
      return new MlNodeFd(fd2, flags);
     }
     catch(e){}
    return new MlNodeFd(fd, flags);
   }
   function caml_sys_open_internal(file, idx){
    if(idx == undefined) idx = caml_sys_fds.length;
    caml_sys_fds[idx] = file;
    return idx | 0;
   }
   function caml_sys_open(name, flags, _perms){
    var f = {};
    while(flags){
     switch(flags[1]){
       case 0:
        f.rdonly = 1; break;
       case 1:
        f.wronly = 1; break;
       case 2:
        f.append = 1; break;
       case 3:
        f.create = 1; break;
       case 4:
        f.truncate = 1; break;
       case 5:
        f.excl = 1; break;
       case 6:
        f.binary = 1; break;
       case 7:
        f.text = 1; break;
       case 8:
        f.nonblock = 1; break;
     }
     flags = flags[2];
    }
    if(f.rdonly && f.wronly)
     caml_raise_sys_error
      (caml_jsbytes_of_string(name)
       + " : flags Open_rdonly and Open_wronly are not compatible");
    if(f.text && f.binary)
     caml_raise_sys_error
      (caml_jsbytes_of_string(name)
       + " : flags Open_text and Open_binary are not compatible");
    var root = resolve_fs_device(name), file = root.device.open(root.rest, f);
    return caml_sys_open_internal(file, undefined);
   }
   (function(){
      function file(fd, flags){
       return fs_node_supported()
               ? caml_sys_open_for_node(fd, flags)
               : new MlFakeFd_out(fd, flags);
      }
      caml_sys_open_internal
       (file(0, {rdonly: 1, altname: "/dev/stdin", isCharacterDevice: true}),
        0);
      caml_sys_open_internal
       (file(1, {buffered: 2, wronly: 1, isCharacterDevice: true}), 1);
      caml_sys_open_internal
       (file(2, {buffered: 2, wronly: 1, isCharacterDevice: true}), 2);
     }
     ());
   function caml_ml_open_descriptor_in(fd){
    var file = caml_sys_fds[fd];
    if(file.flags.wronly) caml_raise_sys_error("fd " + fd + " is writeonly");
    var
     refill = null,
     channel =
       {file: file,
        offset: file.flags.append ? file.length() : 0,
        fd: fd,
        opened: true,
        out: false,
        buffer_curr: 0,
        buffer_max: 0,
        buffer: new Uint8Array(65536),
        refill: refill};
    caml_ml_channels[channel.fd] = channel;
    return channel.fd;
   }
   function caml_ml_open_descriptor_out(fd){
    var file = caml_sys_fds[fd];
    if(file.flags.rdonly) caml_raise_sys_error("fd " + fd + " is readonly");
    var
     buffered = file.flags.buffered !== undefined ? file.flags.buffered : 1,
     channel =
       {file: file,
        offset: file.flags.append ? file.length() : 0,
        fd: fd,
        opened: true,
        out: true,
        buffer_curr: 0,
        buffer: new Uint8Array(65536),
        buffered: buffered};
    caml_ml_channels[channel.fd] = channel;
    return channel.fd;
   }
   function caml_ml_out_channels_list(){
    var l = 0;
    for(var c = 0; c < caml_ml_channels.length; c++)
     if
      (caml_ml_channels[c] && caml_ml_channels[c].opened
       && caml_ml_channels[c].out)
      l = [0, caml_ml_channels[c].fd, l];
    return l;
   }
   function caml_ml_output_ta(chanid, buffer, offset, len){
    var chan = caml_ml_channel_get(chanid);
    if(! chan.opened)
     caml_raise_sys_error("Cannot output to a closed channel");
    buffer = buffer.subarray(offset, offset + len);
    if(chan.buffer_curr + buffer.length > chan.buffer.length){
     var b = new Uint8Array(chan.buffer_curr + buffer.length);
     b.set(chan.buffer);
     chan.buffer = b;
    }
    switch(chan.buffered){
      case 0:
       chan.buffer.set(buffer, chan.buffer_curr);
       chan.buffer_curr += buffer.length;
       caml_ml_flush(chanid);
       break;
      case 1:
       chan.buffer.set(buffer, chan.buffer_curr);
       chan.buffer_curr += buffer.length;
       if(chan.buffer_curr >= chan.buffer.length) caml_ml_flush(chanid);
       break;
      case 2:
       var id = buffer.lastIndexOf(10);
       if(id < 0){
        chan.buffer.set(buffer, chan.buffer_curr);
        chan.buffer_curr += buffer.length;
        if(chan.buffer_curr >= chan.buffer.length) caml_ml_flush(chanid);
       }
       else{
        chan.buffer.set(buffer.subarray(0, id + 1), chan.buffer_curr);
        chan.buffer_curr += id + 1;
        caml_ml_flush(chanid);
        chan.buffer.set(buffer.subarray(id + 1), chan.buffer_curr);
        chan.buffer_curr += buffer.length - id - 1;
       }
       break;
    }
    return 0;
   }
   function caml_ml_output_bytes(chanid, buffer, offset, len){
    var buffer = caml_uint8_array_of_bytes(buffer);
    return caml_ml_output_ta(chanid, buffer, offset, len);
   }
   function caml_ml_output(chanid, buffer, offset, len){
    return caml_ml_output_bytes
            (chanid, caml_bytes_of_string(buffer), offset, len);
   }
   function caml_ml_output_bigarray(chanid, buffer, offset, len){
    var buffer = caml_ba_to_typed_array(buffer);
    return caml_ml_output_ta(chanid, buffer, offset, len);
   }
   function caml_ml_output_char(chanid, c){
    var s = caml_string_of_jsbytes(String.fromCharCode(c));
    caml_ml_output(chanid, s, 0, 1);
    return 0;
   }
   function caml_ml_output_int(chanid, i){
    var
     arr = [i >> 24 & 0xFF, i >> 16 & 0xFF, i >> 8 & 0xFF, i & 0xFF],
     s = caml_string_of_array(arr);
    caml_ml_output(chanid, s, 0, 4);
    return 0;
   }
   function caml_pos_in(chanid){
    var chan = caml_ml_channel_get(chanid);
    return chan.offset - (chan.buffer_max - chan.buffer_curr) | 0;
   }
   function caml_ml_pos_in(chanid){return caml_pos_in(chanid);}
   function caml_ml_pos_in_64(chanid){
    return caml_int64_of_float(caml_pos_in(chanid));
   }
   function caml_pos_out(chanid){
    var chan = caml_ml_channel_get(chanid);
    return chan.offset + chan.buffer_curr;
   }
   function caml_ml_pos_out(chanid){return caml_pos_out(chanid);}
   function caml_ml_pos_out_64(chanid){
    return caml_int64_of_float(caml_pos_out(chanid));
   }
   function caml_ml_runtime_events_pause(){return 0;}
   function caml_ml_runtime_events_resume(){return 0;}
   function caml_ml_runtime_events_start(){return 0;}
   function caml_ml_runtime_warnings_enabled(_unit){return caml_runtime_warnings;
   }
   function caml_seek_in(chanid, pos){
    var chan = caml_ml_channel_get(chanid);
    if(chan.refill != null) caml_raise_sys_error("Illegal seek");
    if
     (pos >= chan.offset - chan.buffer_max && pos <= chan.offset
      && chan.file.flags.binary)
     chan.buffer_curr = chan.buffer_max - (chan.offset - pos);
    else{chan.offset = pos; chan.buffer_curr = 0; chan.buffer_max = 0;}
    return 0;
   }
   function caml_ml_seek_in(chanid, pos){return caml_seek_in(chanid, pos);}
   function caml_ml_seek_in_64(chanid, pos){
    var pos = caml_int64_to_float(pos);
    return caml_seek_in(chanid, pos);
   }
   function caml_seek_out(chanid, pos){
    caml_ml_flush(chanid);
    var chan = caml_ml_channel_get(chanid);
    chan.offset = pos;
    return 0;
   }
   function caml_ml_seek_out(chanid, pos){return caml_seek_out(chanid, pos);}
   function caml_ml_seek_out_64(chanid, pos){
    var pos = caml_int64_to_float(pos);
    return caml_seek_out(chanid, pos);
   }
   function caml_ml_set_binary_mode(chanid, mode){
    var chan = caml_ml_channel_get(chanid);
    chan.file.flags.text = ! mode;
    chan.file.flags.binary = mode;
    return 0;
   }
   function caml_ml_set_buffered(chanid, v){
    caml_ml_channel_get(chanid).buffered = v;
    if(! v) caml_ml_flush(chanid);
    return 0;
   }
   function caml_ml_set_channel_name(chanid, name){
    var chan = caml_ml_channel_get(chanid);
    chan.name = name;
    return 0;
   }
   function caml_ml_set_channel_output(chanid, f){
    var chan = caml_ml_channel_get(chanid);
    chan.output = function(s){f(s);};
    return 0;
   }
   function caml_ml_set_channel_refill(chanid, f){
    caml_ml_channel_get(chanid).refill = f;
    return 0;
   }
   function caml_mod(x, y){if(y == 0) caml_raise_zero_divide(); return x % y;}
   function caml_modf_float(x){
    if(isFinite(x)){
     var neg = 1 / x < 0;
     x = Math.abs(x);
     var i = Math.floor(x), f = x - i;
     if(neg){i = - i; f = - f;}
     return [0, f, i];
    }
    if(isNaN(x)) return [0, NaN, NaN];
    return [0, 1 / x, x];
   }
   function caml_mount_autoload(name, f){
    var
     path = caml_make_path(name),
     name = caml_trailing_slash(path.join("/"));
    jsoo_mount_point.push({path: name, device: new MlFakeDevice(name, f)});
    return 0;
   }
   function caml_lex_run_mem(s, i, mem, curr_pos){
    for(;;){
     var dst = s.charCodeAt(i);
     i++;
     if(dst == 0xff) return;
     var src = s.charCodeAt(i);
     i++;
     if(src == 0xff)
      mem[dst + 1] = curr_pos;
     else
      mem[dst + 1] = mem[src + 1];
    }
   }
   function caml_lex_run_tag(s, i, mem){
    for(;;){
     var dst = s.charCodeAt(i);
     i++;
     if(dst == 0xff) return;
     var src = s.charCodeAt(i);
     i++;
     if(src == 0xff) mem[dst + 1] = - 1; else mem[dst + 1] = mem[src + 1];
    }
   }
   function caml_new_lex_engine(tbl, start_state, lexbuf){
    var
     lex_buffer = 2,
     lex_buffer_len = 3,
     lex_start_pos = 5,
     lex_curr_pos = 6,
     lex_last_pos = 7,
     lex_last_action = 8,
     lex_eof_reached = 9,
     lex_mem = 10,
     lex_base = 1,
     lex_backtrk = 2,
     lex_default = 3,
     lex_trans = 4,
     lex_check = 5,
     lex_base_code = 6,
     lex_backtrk_code = 7,
     lex_default_code = 8,
     lex_trans_code = 9,
     lex_check_code = 10,
     lex_code = 11;
    if(! tbl.lex_default){
     tbl.lex_base = caml_lex_array(tbl[lex_base]);
     tbl.lex_backtrk = caml_lex_array(tbl[lex_backtrk]);
     tbl.lex_check = caml_lex_array(tbl[lex_check]);
     tbl.lex_trans = caml_lex_array(tbl[lex_trans]);
     tbl.lex_default = caml_lex_array(tbl[lex_default]);
    }
    if(! tbl.lex_default_code){
     tbl.lex_base_code = caml_lex_array(tbl[lex_base_code]);
     tbl.lex_backtrk_code = caml_lex_array(tbl[lex_backtrk_code]);
     tbl.lex_check_code = caml_lex_array(tbl[lex_check_code]);
     tbl.lex_trans_code = caml_lex_array(tbl[lex_trans_code]);
     tbl.lex_default_code = caml_lex_array(tbl[lex_default_code]);
    }
    if(tbl.lex_code == null)
     tbl.lex_code = caml_jsbytes_of_string(tbl[lex_code]);
    var
     c,
     state = start_state,
     buffer = caml_uint8_array_of_bytes(lexbuf[lex_buffer]);
    if(state >= 0){
     lexbuf[lex_last_pos] = lexbuf[lex_start_pos] = lexbuf[lex_curr_pos];
     lexbuf[lex_last_action] = - 1;
    }
    else
     state = - state - 1;
    for(;;){
     var base = tbl.lex_base[state];
     if(base < 0){
      var pc_off = tbl.lex_base_code[state];
      caml_lex_run_tag(tbl.lex_code, pc_off, lexbuf[lex_mem]);
      return - base - 1;
     }
     var backtrk = tbl.lex_backtrk[state];
     if(backtrk >= 0){
      var pc_off = tbl.lex_backtrk_code[state];
      caml_lex_run_tag(tbl.lex_code, pc_off, lexbuf[lex_mem]);
      lexbuf[lex_last_pos] = lexbuf[lex_curr_pos];
      lexbuf[lex_last_action] = backtrk;
     }
     if(lexbuf[lex_curr_pos] >= lexbuf[lex_buffer_len])
      if(lexbuf[lex_eof_reached] == 0) return - state - 1; else c = 256;
     else{c = buffer[lexbuf[lex_curr_pos]]; lexbuf[lex_curr_pos]++;}
     var pstate = state;
     if(tbl.lex_check[base + c] == state)
      state = tbl.lex_trans[base + c];
     else
      state = tbl.lex_default[state];
     if(state < 0){
      lexbuf[lex_curr_pos] = lexbuf[lex_last_pos];
      if(lexbuf[lex_last_action] == - 1)
       caml_failwith("lexing: empty token");
      else
       return lexbuf[lex_last_action];
     }
     else{
      var base_code = tbl.lex_base_code[pstate], pc_off;
      if(tbl.lex_check_code[base_code + c] == pstate)
       pc_off = tbl.lex_trans_code[base_code + c];
      else
       pc_off = tbl.lex_default_code[pstate];
      if(pc_off > 0)
       caml_lex_run_mem
        (tbl.lex_code, pc_off, lexbuf[lex_mem], lexbuf[lex_curr_pos]);
      if(c == 256) lexbuf[lex_eof_reached] = 0;
     }
    }
   }
   function caml_nextafter_float(x, y){
    if(isNaN(x) || isNaN(y)) return NaN;
    if(x == y) return y;
    if(x == 0) return y < 0 ? - Math.pow(2, - 1074) : Math.pow(2, - 1074);
    var bits = caml_int64_bits_of_float(x), one = caml_int64_of_int32(1);
    if(x < y == x > 0)
     bits = caml_int64_add(bits, one);
    else
     bits = caml_int64_sub(bits, one);
    return caml_int64_float_of_bits(bits);
   }
   function caml_notequal(x, y){
    return + (caml_compare_val(x, y, false) != 0);
   }
   function caml_obj_add_offset(v, offset){
    caml_failwith("Obj.add_offset is not supported");
   }
   function caml_obj_block(tag, size){
    var o = new Array(size + 1);
    o[0] = tag;
    for(var i = 1; i <= size; i++) o[i] = 0;
    return o;
   }
   function caml_obj_compare_and_swap(x, i, old, n){
    if(x[i + 1] == old){x[i + 1] = n; return 1;}
    return 0;
   }
   function caml_obj_is_block(x){return + (x instanceof Array);}
   function caml_obj_is_shared(x){return 1;}
   function caml_obj_make_forward(b, v){b[0] = 250; b[1] = v; return 0;}
   function caml_obj_raw_field(o, i){return o[i + 1];}
   function caml_obj_reachable_words(o){return 0;}
   function caml_obj_set_raw_field(o, i, v){return o[i + 1] = v;}
   function caml_obj_set_tag(x, tag){x[0] = tag; return 0;}
   function caml_obj_truncate(x, s){
    if(s <= 0 || s + 1 > x.length) caml_invalid_argument("Obj.truncate");
    if(x.length != s + 1) x.length = s + 1;
    return 0;
   }
   function caml_obj_with_tag(tag, x){
    var l = x.length, a = new Array(l);
    a[0] = tag;
    for(var i = 1; i < l; i++) a[i] = x[i];
    return a;
   }
   function caml_ojs_new_arr(c, a){
    switch(a.length){
      case 0:
       return new c;
      case 1:
       return new c(a[0]);
      case 2:
       return new c(a[0], a[1]);
      case 3:
       return new c(a[0], a[1], a[2]);
      case 4:
       return new c(a[0], a[1], a[2], a[3]);
      case 5:
       return new c(a[0], a[1], a[2], a[3], a[4]);
      case 6:
       return new c(a[0], a[1], a[2], a[3], a[4], a[5]);
      case 7:
       return new c(a[0], a[1], a[2], a[3], a[4], a[5], a[6]);
    }
    function F(){return c.apply(this, a);}
    F.prototype = c.prototype;
    return new F;
   }
   var
    caml_output_val =
      function(){
        function Writer(){this.chunk = [];}
        Writer.prototype =
         {chunk_idx: 20,
          block_len: 0,
          obj_counter: 0,
          size_32: 0,
          size_64: 0,
          write:
          function(size, value){
           for(var i = size - 8; i >= 0; i -= 8)
            this.chunk[this.chunk_idx++] = value >> i & 0xFF;
          },
          write_at:
          function(pos, size, value){
           var pos = pos;
           for(var i = size - 8; i >= 0; i -= 8)
            this.chunk[pos++] = value >> i & 0xFF;
          },
          write_code:
          function(size, code, value){
           this.chunk[this.chunk_idx++] = code;
           for(var i = size - 8; i >= 0; i -= 8)
            this.chunk[this.chunk_idx++] = value >> i & 0xFF;
          },
          write_shared:
          function(offset){
           if(offset < 1 << 8)
            this.write_code(8, 0x04, offset);
           else if(offset < 1 << 16)
            this.write_code(16, 0x05, offset);
           else
            this.write_code(32, 0x06, offset);
          },
          pos: function(){return this.chunk_idx;},
          finalize:
          function(){
           this.block_len = this.chunk_idx - 20;
           this.chunk_idx = 0;
           this.write(32, 0x8495A6BE);
           this.write(32, this.block_len);
           this.write(32, this.obj_counter);
           this.write(32, this.size_32);
           this.write(32, this.size_64);
           return this.chunk;
          }};
        return function(v, flags){
         flags = caml_list_to_js_array(flags);
         var
          no_sharing = flags.indexOf(0) !== - 1,
          closures = flags.indexOf(1) !== - 1;
         if(closures)
          console.warn
           ("in caml_output_val: flag Marshal.Closures is not supported.");
         var
          writer = new Writer(),
          stack = [],
          intern_obj_table = no_sharing ? null : new MlObjectTable();
         function memo(v){
          if(no_sharing) return false;
          var existing_offset = intern_obj_table.recall(v);
          if(existing_offset){
           writer.write_shared(existing_offset);
           return true;
          }
          else{intern_obj_table.store(v); return false;}
         }
         function extern_rec(v){
          if(v.caml_custom){
           if(memo(v)) return;
           var
            name = v.caml_custom,
            ops = caml_custom_ops[name],
            sz_32_64 = [0, 0];
           if(! ops.serialize)
            caml_invalid_argument("output_value: abstract value (Custom)");
           if(ops.fixed_length == undefined){
            writer.write(8, 0x18);
            for(var i = 0; i < name.length; i++)
             writer.write(8, name.charCodeAt(i));
            writer.write(8, 0);
            var header_pos = writer.pos();
            for(var i = 0; i < 12; i++) writer.write(8, 0);
            ops.serialize(writer, v, sz_32_64);
            writer.write_at(header_pos, 32, sz_32_64[0]);
            writer.write_at(header_pos + 4, 32, 0);
            writer.write_at(header_pos + 8, 32, sz_32_64[1]);
           }
           else{
            writer.write(8, 0x19);
            for(var i = 0; i < name.length; i++)
             writer.write(8, name.charCodeAt(i));
            writer.write(8, 0);
            var old_pos = writer.pos();
            ops.serialize(writer, v, sz_32_64);
            if(ops.fixed_length != writer.pos() - old_pos)
             caml_failwith
              ("output_value: incorrect fixed sizes specified by " + name);
           }
           writer.size_32 += 2 + (sz_32_64[0] + 3 >> 2);
           writer.size_64 += 2 + (sz_32_64[1] + 7 >> 3);
          }
          else if(v instanceof Array && v[0] === (v[0] | 0)){
           if(v[0] == 251)
            caml_failwith("output_value: abstract value (Abstract)");
           if(caml_is_continuation_tag(v[0]))
            caml_invalid_argument("output_value: continuation value");
           if(v.length > 1 && memo(v)) return;
           if(v[0] < 16 && v.length - 1 < 8)
            writer.write(8, 0x80 + v[0] + (v.length - 1 << 4));
           else
            writer.write_code(32, 0x08, v.length - 1 << 10 | v[0]);
           writer.size_32 += v.length;
           writer.size_64 += v.length;
           if(v.length > 1) stack.push(v, 1);
          }
          else if(caml_is_ml_bytes(v)){
           if(! caml_is_ml_bytes(caml_string_of_jsbytes("")))
            caml_failwith
             ("output_value: [Bytes.t] cannot safely be marshaled with [--enable use-js-string]");
           if(memo(v)) return;
           var len = caml_ml_bytes_length(v);
           if(len < 0x20)
            writer.write(8, 0x20 + len);
           else if(len < 0x100)
            writer.write_code(8, 0x09, len);
           else
            writer.write_code(32, 0x0A, len);
           for(var i = 0; i < len; i++)
            writer.write(8, caml_bytes_unsafe_get(v, i));
           writer.size_32 += 1 + ((len + 4) / 4 | 0);
           writer.size_64 += 1 + ((len + 8) / 8 | 0);
          }
          else if(caml_is_ml_string(v)){
           if(memo(v)) return;
           var len = caml_ml_string_length(v);
           if(len < 0x20)
            writer.write(8, 0x20 + len);
           else if(len < 0x100)
            writer.write_code(8, 0x09, len);
           else
            writer.write_code(32, 0x0A, len);
           for(var i = 0; i < len; i++)
            writer.write(8, caml_string_unsafe_get(v, i));
           writer.size_32 += 1 + ((len + 4) / 4 | 0);
           writer.size_64 += 1 + ((len + 8) / 8 | 0);
          }
          else if(v != (v | 0)){
           var type_of_v = typeof v;
           if(type_of_v != "number")
            caml_failwith("output_value: abstract value (" + type_of_v + ")");
           if(memo(v)) return;
           var t = caml_int64_to_bytes(caml_int64_bits_of_float(v));
           writer.write(8, 0x0C);
           for(var i = 0; i < 8; i++) writer.write(8, t[7 - i]);
           writer.size_32 += 3;
           writer.size_64 += 2;
          }
          else if(v >= 0 && v < 0x40)
           writer.write(8, 0X40 + v);
          else if(v >= - (1 << 7) && v < 1 << 7)
           writer.write_code(8, 0x00, v);
          else if(v >= - (1 << 15) && v < 1 << 15)
           writer.write_code(16, 0x01, v);
          else
           writer.write_code(32, 0x02, v);
         }
         extern_rec(v);
         while(stack.length > 0){
          var i = stack.pop(), v = stack.pop();
          if(i + 1 < v.length) stack.push(v, i + 1);
          extern_rec(v[i]);
         }
         if(intern_obj_table)
          writer.obj_counter = intern_obj_table.objs.length;
         writer.finalize();
         return writer.chunk;};
       }
       ();
   function caml_output_value_to_string(v, flags){
    return caml_string_of_array(caml_output_val(v, flags));
   }
   function caml_output_value(chanid, v, flags){
    var s = caml_output_value_to_string(v, flags);
    caml_ml_output(chanid, s, 0, caml_ml_string_length(s));
    return 0;
   }
   function caml_output_value_to_buffer(s, ofs, len, v, flags){
    var t = caml_output_val(v, flags);
    if(t.length > len) caml_failwith("Marshal.to_buffer: buffer overflow");
    caml_blit_bytes(t, 0, s, ofs, t.length);
    return 0;
   }
   function caml_output_value_to_bytes(v, flags){
    return caml_bytes_of_array(caml_output_val(v, flags));
   }
   var caml_parser_trace = 0;
   function caml_parse_engine(tables, env, cmd, arg){
    var
     ERRCODE = 256,
     loop = 6,
     testshift = 7,
     shift = 8,
     shift_recover = 9,
     reduce = 10,
     READ_TOKEN = 0,
     RAISE_PARSE_ERROR = 1,
     GROW_STACKS_1 = 2,
     GROW_STACKS_2 = 3,
     COMPUTE_SEMANTIC_ACTION = 4,
     CALL_ERROR_FUNCTION = 5,
     env_s_stack = 1,
     env_v_stack = 2,
     env_symb_start_stack = 3,
     env_symb_end_stack = 4,
     env_stacksize = 5,
     env_stackbase = 6,
     env_curr_char = 7,
     env_lval = 8,
     env_symb_start = 9,
     env_symb_end = 10,
     env_asp = 11,
     env_rule_len = 12,
     env_rule_number = 13,
     env_sp = 14,
     env_state = 15,
     env_errflag = 16,
     tbl_transl_const = 2,
     tbl_transl_block = 3,
     tbl_lhs = 4,
     tbl_len = 5,
     tbl_defred = 6,
     tbl_dgoto = 7,
     tbl_sindex = 8,
     tbl_rindex = 9,
     tbl_gindex = 10,
     tbl_tablesize = 11,
     tbl_table = 12,
     tbl_check = 13,
     tbl_names_const = 15,
     tbl_names_block = 16;
    function log(x){
     var s = caml_string_of_jsbytes(x + "\n");
     caml_ml_output(2, s, 0, caml_ml_string_length(s));
    }
    function token_name(names, number){
     var str = caml_jsstring_of_string(names);
     if(str[0] == "\x00") return "<unknown token>";
     return str.split("\x00")[number];
    }
    function print_token(state, tok){
     var token, kind;
     if(tok instanceof Array){
      token = token_name(tables[tbl_names_block], tok[0]);
      if(typeof tok[1] == "number")
       kind = "" + tok[1];
      else if(typeof tok[1] == "string")
       kind = tok[1];
      else if(tok[1] instanceof MlBytes)
       kind = caml_jsbytes_of_string(tok[1]);
      else
       kind = "_";
      log("State " + state + ": read token " + token + "(" + kind + ")");
     }
     else{
      token = token_name(tables[tbl_names_const], tok);
      log("State " + state + ": read token " + token);
     }
    }
    if(! tables.dgoto){
     tables.defred = caml_lex_array(tables[tbl_defred]);
     tables.sindex = caml_lex_array(tables[tbl_sindex]);
     tables.check = caml_lex_array(tables[tbl_check]);
     tables.rindex = caml_lex_array(tables[tbl_rindex]);
     tables.table = caml_lex_array(tables[tbl_table]);
     tables.len = caml_lex_array(tables[tbl_len]);
     tables.lhs = caml_lex_array(tables[tbl_lhs]);
     tables.gindex = caml_lex_array(tables[tbl_gindex]);
     tables.dgoto = caml_lex_array(tables[tbl_dgoto]);
    }
    var
     res = 0,
     n,
     n1,
     n2,
     state1,
     sp = env[env_sp],
     state = env[env_state],
     errflag = env[env_errflag];
    exit:
    for(;;)
     next:
     switch(cmd){
       case 0:
        state = 0; errflag = 0;
       case 6:
        n = tables.defred[state];
        if(n != 0){cmd = reduce; break;}
        if(env[env_curr_char] >= 0){cmd = testshift; break;}
        res = READ_TOKEN;
        break exit;
       case 1:
        if(arg instanceof Array){
         env[env_curr_char] = tables[tbl_transl_block][arg[0] + 1];
         env[env_lval] = arg[1];
        }
        else{
         env[env_curr_char] = tables[tbl_transl_const][arg + 1];
         env[env_lval] = 0;
        }
        if(caml_parser_trace) print_token(state, arg);
       case 7:
        n1 = tables.sindex[state];
        n2 = n1 + env[env_curr_char];
        if
         (n1 != 0 && n2 >= 0 && n2 <= tables[tbl_tablesize]
          && tables.check[n2] == env[env_curr_char]){cmd = shift; break;}
        n1 = tables.rindex[state];
        n2 = n1 + env[env_curr_char];
        if
         (n1 != 0 && n2 >= 0 && n2 <= tables[tbl_tablesize]
          && tables.check[n2] == env[env_curr_char]){
         n = tables.table[n2];
         cmd = reduce;
         break;
        }
        if(errflag <= 0){res = CALL_ERROR_FUNCTION; break exit;}
       case 5:
        if(errflag < 3){
         errflag = 3;
         for(;;){
          state1 = env[env_s_stack][sp + 1];
          n1 = tables.sindex[state1];
          n2 = n1 + ERRCODE;
          if
           (n1 != 0 && n2 >= 0 && n2 <= tables[tbl_tablesize]
            && tables.check[n2] == ERRCODE){
           if(caml_parser_trace) log("Recovering in state " + state1);
           cmd = shift_recover;
           break next;
          }
          else{
           if(caml_parser_trace) log("Discarding state " + state1);
           if(sp <= env[env_stackbase]){
            if(caml_parser_trace) log("No more states to discard");
            return RAISE_PARSE_ERROR;
           }
           sp--;
          }
         }
        }
        else{
         if(env[env_curr_char] == 0) return RAISE_PARSE_ERROR;
         if(caml_parser_trace) log("Discarding last token read");
         env[env_curr_char] = - 1;
         cmd = loop;
         break;
        }
       case 8:
        env[env_curr_char] = - 1; if(errflag > 0) errflag--;
       case 9:
        if(caml_parser_trace)
         log("State " + state + ": shift to state " + tables.table[n2]);
        state = tables.table[n2];
        sp++;
        if(sp >= env[env_stacksize]){res = GROW_STACKS_1; break exit;}
       case 2:
        env[env_s_stack][sp + 1] = state;
        env[env_v_stack][sp + 1] = env[env_lval];
        env[env_symb_start_stack][sp + 1] = env[env_symb_start];
        env[env_symb_end_stack][sp + 1] = env[env_symb_end];
        cmd = loop;
        break;
       case 10:
        if(caml_parser_trace) log("State " + state + ": reduce by rule " + n);
        var m = tables.len[n];
        env[env_asp] = sp;
        env[env_rule_number] = n;
        env[env_rule_len] = m;
        sp = sp - m + 1;
        m = tables.lhs[n];
        state1 = env[env_s_stack][sp];
        n1 = tables.gindex[m];
        n2 = n1 + state1;
        if
         (n1 != 0 && n2 >= 0 && n2 <= tables[tbl_tablesize]
          && tables.check[n2] == state1)
         state = tables.table[n2];
        else
         state = tables.dgoto[m];
        if(sp >= env[env_stacksize]){res = GROW_STACKS_2; break exit;}
       case 3:
        res = COMPUTE_SEMANTIC_ACTION; break exit;
       case 4:
        env[env_s_stack][sp + 1] = state;
        env[env_v_stack][sp + 1] = arg;
        var asp = env[env_asp];
        env[env_symb_end_stack][sp + 1] = env[env_symb_end_stack][asp + 1];
        if(sp > asp)
         env[env_symb_start_stack][sp + 1] = env[env_symb_end_stack][asp + 1];
        cmd = loop;
        break;
       default: return RAISE_PARSE_ERROR;
     }
    env[env_sp] = sp;
    env[env_state] = state;
    env[env_errflag] = errflag;
    return res;
   }
   function caml_pure_js_expr(s){
    console.error("caml_pure_js_expr: fallback to runtime evaluation\n");
    return eval(caml_jsstring_of_string(s));
   }
   function caml_raise_not_a_dir(name){
    caml_raise_sys_error(name + ": Not a directory");
   }
   function caml_raise_not_found(){
    caml_raise_constant(caml_global_data.Not_found);
   }
   function caml_raw_backtrace_length(){return 0;}
   function caml_raw_backtrace_next_slot(){return 0;}
   function caml_raw_backtrace_slot(){
    caml_invalid_argument
     ("Printexc.get_raw_backtrace_slot: index out of bounds");
   }
   function caml_recommended_domain_count(unit){return 1;}
   function caml_record_backtrace(b){
    caml_record_backtrace_flag = b;
    return 0;
   }
   function caml_register_channel_for_spacetime(_channel){return 0;}
   function caml_register_global(n, v, name_opt){
    if(name_opt){
     var name = name_opt;
     if(globalThis.toplevelReloc)
      n = caml_callback(globalThis.toplevelReloc, [name]);
     else if(caml_global_data.symbols){
      if(! caml_global_data.symidx)
       caml_global_data.symidx = caml_build_symbols(caml_global_data.symbols);
      var nid = caml_global_data.symidx[name];
      if(nid >= 0)
       n = nid;
      else
       caml_failwith("caml_register_global: cannot locate " + name);
     }
    }
    caml_global_data[n + 1] = v;
    if(name_opt) caml_global_data[name_opt] = v;
   }
   function caml_register_named_value(nm, v){
    caml_named_values[caml_jsbytes_of_string(nm)] = v;
    return 0;
   }
   function caml_restore_raw_backtrace(exn, bt){return 0;}
   function caml_round_float(x){
    if(x >= 0){
     var y = Math.floor(x);
     return x - y >= 0.5 ? y + 1 : y;
    }
    else{var y = Math.ceil(x); return y - x >= 0.5 ? y - 1 : y;}
   }
   function caml_runtime_events_create_cursor(target){return {};}
   function caml_runtime_events_free_cursor(cursor){return 0;}
   function caml_runtime_events_read_poll(cursor, callbacks, num){return 0;}
   function caml_runtime_events_user_register
   (event_name, event_tag, event_type){
    caml_custom_event_index += 1;
    return [0, caml_custom_event_index, event_name, event_type, event_tag];
   }
   function caml_runtime_events_user_resolve(){return 0;}
   function caml_runtime_events_user_write(event, event_content){return 0;}
   function caml_runtime_parameters(_unit){return caml_string_of_jsbytes("");}
   function caml_runtime_variant(_unit){return caml_string_of_jsbytes("");}
   function caml_set_oo_id(b){b[2] = caml_oo_last_id++; return b;}
   function caml_set_parser_trace(bool){
    var oldflag = caml_parser_trace;
    caml_parser_trace = bool;
    return oldflag;
   }
   function caml_set_static_env(k, v){
    if(! globalThis.jsoo_static_env) globalThis.jsoo_static_env = {};
    globalThis.jsoo_static_env[k] = v;
    return 0;
   }
   function caml_signbit_float(x){if(x == 0) x = 1 / x; return x < 0 ? 1 : 0;}
   function caml_sinh_float(x){return Math.sinh(x);}
   function caml_spacetime_enabled(_unit){return 0;}
   function caml_spacetime_only_works_for_native_code(){
    caml_failwith("Spacetime profiling only works for native code");
   }
   function caml_str_initialize(unit){return 0;}
   function caml_string_bound_error(){
    caml_invalid_argument("index out of bounds");
   }
   function caml_string_concat(a, b){return a + b;}
   function caml_string_equal(s1, s2){if(s1 === s2) return 1; return 0;}
   function caml_string_get(s, i){
    if(i >>> 0 >= caml_ml_string_length(s)) caml_string_bound_error();
    return caml_string_unsafe_get(s, i);
   }
   function caml_string_get16(s, i){
    if(i >>> 0 >= caml_ml_string_length(s) - 1) caml_string_bound_error();
    var
     b1 = caml_string_unsafe_get(s, i),
     b2 = caml_string_unsafe_get(s, i + 1);
    return b2 << 8 | b1;
   }
   function caml_string_get32(s, i){
    if(i >>> 0 >= caml_ml_string_length(s) - 3) caml_string_bound_error();
    var
     b1 = caml_string_unsafe_get(s, i),
     b2 = caml_string_unsafe_get(s, i + 1),
     b3 = caml_string_unsafe_get(s, i + 2),
     b4 = caml_string_unsafe_get(s, i + 3);
    return b4 << 24 | b3 << 16 | b2 << 8 | b1;
   }
   function caml_string_get64(s, i){
    if(i >>> 0 >= caml_ml_string_length(s) - 7) caml_string_bound_error();
    var a = new Array(8);
    for(var j = 0; j < 8; j++) a[7 - j] = caml_string_unsafe_get(s, i + j);
    return caml_int64_of_bytes(a);
   }
   function caml_string_lessequal(s1, s2){return s1 <= s2 ? 1 : 0;}
   function caml_string_greaterequal(s1, s2){return caml_string_lessequal(s2, s1);
   }
   function caml_string_lessthan(s1, s2){return s1 < s2 ? 1 : 0;}
   function caml_string_greaterthan(s1, s2){return caml_string_lessthan(s2, s1);
   }
   function caml_string_hash(h, v){
    var h = caml_hash_mix_string(h, v), h = caml_hash_mix_final(h);
    return h & 0x3FFFFFFF;
   }
   function caml_string_notequal(s1, s2){
    return 1 - caml_string_equal(s1, s2);
   }
   function caml_string_set(s, i, c){caml_failwith("caml_string_set");}
   function caml_string_set16(s, i, i16){caml_failwith("caml_string_set16");}
   function caml_string_set32(s, i, i32){caml_failwith("caml_string_set32");}
   function caml_string_set64(s, i, i64){caml_failwith("caml_string_set64");}
   function caml_string_unsafe_set(s, i, c){
    caml_failwith("caml_string_unsafe_set");
   }
   function caml_sys_argv(a){return caml_argv;}
   function caml_sys_chdir(dir){
    var root = resolve_fs_device(dir);
    if(root.device.exists(root.rest)){
     if(root.rest)
      caml_current_dir = caml_trailing_slash(root.path + root.rest);
     else
      caml_current_dir = root.path;
     return 0;
    }
    else
     caml_raise_no_such_file(caml_jsbytes_of_string(dir));
   }
   function caml_sys_const_backend_type(){
    return [0, caml_string_of_jsbytes("js_of_ocaml")];
   }
   function caml_sys_const_big_endian(){return 0;}
   function caml_sys_const_int_size(){return 32;}
   function caml_sys_const_max_wosize(){return 0x7FFFFFFF / 4 | 0;}
   function caml_sys_const_naked_pointers_checked(_unit){return 0;}
   var
    os_type =
      globalThis.process && globalThis.process.platform
       && globalThis.process.platform == "win32"
       ? "Cygwin"
       : "Unix";
   function caml_sys_const_ostype_cygwin(){return os_type == "Cygwin" ? 1 : 0;
   }
   function caml_sys_const_ostype_unix(){return os_type == "Unix" ? 1 : 0;}
   function caml_sys_const_ostype_win32(){return os_type == "Win32" ? 1 : 0;}
   function caml_sys_const_word_size(){return 32;}
   function caml_sys_executable_name(a){return caml_executable_name;}
   function caml_sys_exit(code){
    if(globalThis.quit) globalThis.quit(code);
    if(globalThis.process && globalThis.process.exit)
     globalThis.process.exit(code);
    caml_invalid_argument("Function 'exit' not implemented");
   }
   function caml_sys_file_exists(name){
    var root = resolve_fs_device(name);
    return root.device.exists(root.rest);
   }
   function caml_sys_get_argv(a){return [0, caml_argv[1], caml_argv];}
   function caml_sys_get_config(){
    return [0, caml_string_of_jsbytes(os_type), 32, 0];
   }
   function caml_sys_getcwd(){
    return caml_string_of_jsbytes(caml_current_dir);
   }
   function caml_sys_getenv(name){
    var r = jsoo_sys_getenv(caml_jsstring_of_string(name));
    if(r === undefined) caml_raise_not_found();
    return caml_string_of_jsstring(r);
   }
   function caml_sys_is_directory(name){
    var root = resolve_fs_device(name), a = root.device.is_dir(root.rest);
    return a ? 1 : 0;
   }
   function caml_sys_is_regular_file(name){
    var root = resolve_fs_device(name);
    return root.device.isFile(root.rest);
   }
   function caml_sys_isatty(_chan){return 0;}
   function caml_sys_mkdir(name, perm){
    var root = resolve_fs_device(name);
    root.device.mkdir(root.rest, perm);
    return 0;
   }
   function caml_sys_modify_argv(arg){caml_argv = arg; return 0;}
   function caml_sys_random_seed(){
    if(globalThis.crypto)
     if(globalThis.crypto.getRandomValues){
      var a = globalThis.crypto.getRandomValues(new Int32Array(4));
      return [0, a[0], a[1], a[2], a[3]];
     }
     else if(globalThis.crypto.randomBytes){
      var a = new Int32Array(globalThis.crypto.randomBytes(16).buffer);
      return [0, a[0], a[1], a[2], a[3]];
     }
    var now = new Date().getTime(), x = now ^ 0xffffffff * Math.random();
    return [0, x];
   }
   function caml_sys_read_directory(name){
    var
     root = resolve_fs_device(name),
     a = root.device.readdir(root.rest),
     l = new Array(a.length + 1);
    l[0] = 0;
    for(var i = 0; i < a.length; i++) l[i + 1] = caml_string_of_jsbytes(a[i]);
    return l;
   }
   function caml_sys_remove(name){
    var root = resolve_fs_device(name), ok = root.device.unlink(root.rest);
    if(ok == 0) caml_raise_no_such_file(caml_jsbytes_of_string(name));
    return 0;
   }
   function caml_sys_rename(o, n){
    var o_root = resolve_fs_device(o), n_root = resolve_fs_device(n);
    if(o_root.device != n_root.device)
     caml_failwith("caml_sys_rename: cannot move file between two filesystem");
    if(! o_root.device.rename)
     caml_failwith("caml_sys_rename: no implemented");
    o_root.device.rename(o_root.rest, n_root.rest);
   }
   function caml_sys_rmdir(name){
    var root = resolve_fs_device(name);
    root.device.rmdir(root.rest);
    return 0;
   }
   function caml_sys_system_command(cmd){
    var cmd = caml_jsstring_of_string(cmd);
    if(typeof require != "undefined"){
     var child_process = require("child_process");
     if(child_process && child_process.execSync)
      try{child_process.execSync(cmd, {stdio: "inherit"}); return 0;}
      catch(e){return 1;}
    }
    else
     return 127;
   }
   var caml_initial_time = new Date().getTime() * 0.001;
   function caml_sys_time(){
    var now = new Date().getTime();
    return now * 0.001 - caml_initial_time;
   }
   function caml_sys_time_include_children(b){return caml_sys_time();}
   function caml_sys_unsafe_getenv(name){return caml_sys_getenv(name);}
   function caml_tanh_float(x){return Math.tanh(x);}
   function caml_to_js_string(s){return caml_jsstring_of_string(s);}
   function caml_trampoline(res){
    var c = 1;
    while(res && res.joo_tramp){
     res = res.joo_tramp.apply(null, res.joo_args);
     c++;
    }
    return res;
   }
   function caml_trampoline_return(f, args){return {joo_tramp: f, joo_args: args};
   }
   function caml_trunc_float(x){return Math.trunc(x);}
   function caml_unix_cleanup(){}
   function caml_unix_closedir(dir_handle){
    try{dir_handle.pointer.closeSync();}
    catch(e){
     var unix_error = caml_named_value("Unix.Unix_error");
     caml_raise_with_args
      (unix_error, make_unix_err_args("EBADF", "closedir", dir_handle.path));
    }
   }
   function caml_unix_filedescr_of_fd(x){return x;}
   function caml_unix_findclose(dir_handle){return caml_unix_closedir(dir_handle);
   }
   function caml_unix_opendir(path){
    var root = resolve_fs_device(path);
    if(! root.device.opendir)
     caml_failwith("caml_unix_opendir: not implemented");
    var dir_handle = root.device.opendir(root.rest, true);
    return {pointer: dir_handle, path: path};
   }
   function caml_unix_readdir(dir_handle){
    var entry;
    try{entry = dir_handle.pointer.readSync();}
    catch(e){
     var unix_error = caml_named_value("Unix.Unix_error");
     caml_raise_with_args
      (unix_error, make_unix_err_args("EBADF", "readdir", dir_handle.path));
    }
    if(entry === null)
     caml_raise_end_of_file();
    else
     return caml_string_of_jsstring(entry.name);
   }
   function caml_unix_findfirst(path){
    var path_js = caml_jsstring_of_string(path);
    path_js = path_js.replace(/(^|[\\\/])\*\.\*$/, "");
    path = caml_string_of_jsstring(path_js);
    var
     dir_handle = caml_unix_opendir(path),
     first_entry = caml_unix_readdir(dir_handle);
    return [0, first_entry, dir_handle];
   }
   function caml_unix_findnext(dir_handle){return caml_unix_readdir(dir_handle);
   }
   function caml_unix_getpwuid(unit){caml_raise_not_found();}
   function caml_unix_gettimeofday(){return new Date().getTime() / 1000;}
   function caml_unix_getuid(unit){
    if(globalThis.process && globalThis.process.getuid)
     return globalThis.process.getuid();
    caml_raise_not_found();
   }
   function caml_unix_gmtime(t){
    var
     d = new Date(t * 1000),
     d_num = d.getTime(),
     januaryfirst = new Date(Date.UTC(d.getUTCFullYear(), 0, 1)).getTime(),
     doy = Math.floor((d_num - januaryfirst) / 86400000);
    return [0,
            d.getUTCSeconds(),
            d.getUTCMinutes(),
            d.getUTCHours(),
            d.getUTCDate(),
            d.getUTCMonth(),
            d.getUTCFullYear() - 1900,
            d.getUTCDay(),
            doy,
            false | 0];
   }
   function caml_unix_has_symlink(unit){return fs_node_supported() ? 1 : 0;}
   function caml_unix_inet_addr_of_string(){return 0;}
   function caml_unix_isatty(fileDescriptor){
    if(fs_node_supported()){
     var tty = require("tty");
     return tty.isatty(fileDescriptor) ? 1 : 0;
    }
    else
     return 0;
   }
   function caml_unix_localtime(t){
    var
     d = new Date(t * 1000),
     d_num = d.getTime(),
     januaryfirst = new Date(d.getFullYear(), 0, 1).getTime(),
     doy = Math.floor((d_num - januaryfirst) / 86400000),
     jan = new Date(d.getFullYear(), 0, 1),
     jul = new Date(d.getFullYear(), 6, 1),
     stdTimezoneOffset =
       Math.max(jan.getTimezoneOffset(), jul.getTimezoneOffset());
    return [0,
            d.getSeconds(),
            d.getMinutes(),
            d.getHours(),
            d.getDate(),
            d.getMonth(),
            d.getFullYear() - 1900,
            d.getDay(),
            doy,
            d.getTimezoneOffset() < stdTimezoneOffset | 0];
   }
   function caml_unix_lstat(name){
    var root = resolve_fs_device(name);
    if(! root.device.lstat) caml_failwith("caml_unix_lstat: not implemented");
    return root.device.lstat(root.rest, true);
   }
   function caml_unix_lstat_64(name){
    var r = caml_unix_lstat(name);
    r[9] = caml_int64_of_int32(r[9]);
    return r;
   }
   function caml_unix_mkdir(name, perm){
    var root = resolve_fs_device(name);
    if(! root.device.mkdir) caml_failwith("caml_unix_mkdir: not implemented");
    return root.device.mkdir(root.rest, perm, true);
   }
   function caml_unix_mktime(tm){
    var
     d = new Date(tm[6] + 1900, tm[5], tm[4], tm[3], tm[2], tm[1]).getTime(),
     t = Math.floor(d / 1000),
     tm2 = caml_unix_localtime(t);
    return [0, t, tm2];
   }
   function caml_unix_readlink(name){
    var root = resolve_fs_device(name);
    if(! root.device.readlink)
     caml_failwith("caml_unix_readlink: not implemented");
    return root.device.readlink(root.rest, true);
   }
   function caml_unix_rewinddir(dir_handle){
    caml_unix_closedir(dir_handle);
    var new_dir_handle = caml_unix_opendir(dir_handle.path);
    dir_handle.pointer = new_dir_handle.pointer;
    return 0;
   }
   function caml_unix_rmdir(name){
    var root = resolve_fs_device(name);
    if(! root.device.rmdir) caml_failwith("caml_unix_rmdir: not implemented");
    return root.device.rmdir(root.rest, true);
   }
   function caml_unix_startup(){}
   function caml_unix_stat(name){
    var root = resolve_fs_device(name);
    if(! root.device.stat) caml_failwith("caml_unix_stat: not implemented");
    return root.device.stat(root.rest, true);
   }
   function caml_unix_stat_64(name){
    var r = caml_unix_stat(name);
    r[9] = caml_int64_of_int32(r[9]);
    return r;
   }
   function caml_unix_symlink(to_dir, src, dst){
    var src_root = resolve_fs_device(src), dst_root = resolve_fs_device(dst);
    if(src_root.device != dst_root.device)
     caml_failwith
      ("caml_unix_symlink: cannot symlink between two filesystems");
    if(! src_root.device.symlink)
     caml_failwith("caml_unix_symlink: not implemented");
    return src_root.device.symlink(to_dir, src_root.rest, dst_root.rest, true);
   }
   function caml_unix_time(){return Math.floor(caml_unix_gettimeofday());}
   function caml_unix_unlink(name){
    var root = resolve_fs_device(name);
    if(! root.device.unlink)
     caml_failwith("caml_unix_unlink: not implemented");
    return root.device.unlink(root.rest, true);
   }
   function caml_unmount(name){
    var
     path = caml_make_path(name),
     name = caml_trailing_slash(path.join("/")),
     idx = - 1;
    for(var i = 0; i < jsoo_mount_point.length; i++)
     if(jsoo_mount_point[i].path == name) idx = i;
    if(idx > - 1) jsoo_mount_point.splice(idx, 1);
    return 0;
   }
   function caml_update_dummy(x, y){
    if(y.fun){x.fun = y.fun; return 0;}
    if(typeof y === "function"){x.fun = y; return 0;}
    var i = y.length;
    while(i--) x[i] = y[i];
    return 0;
   }
   function caml_weak_set(x, i, v){
    if(v == 0) caml_ephe_unset_key(x, i); else caml_ephe_set_key(x, i, v[1]);
    return 0;
   }
   function caml_wrap_exception(e){
    {
     if(e instanceof Array) return e;
     var exn;
     if
      (globalThis.RangeError && e instanceof globalThis.RangeError
       && e.message
       && e.message.match(/maximum call stack/i))
      exn = caml_global_data.Stack_overflow;
     else if
      (globalThis.InternalError && e instanceof globalThis.InternalError
       && e.message
       && e.message.match(/too much recursion/i))
      exn = caml_global_data.Stack_overflow;
     else if(e instanceof globalThis.Error && caml_named_value("jsError"))
      exn = [0, caml_named_value("jsError"), e];
     else
      exn = [0, caml_global_data.Failure, caml_string_of_jsstring(String(e))];
     if(e instanceof globalThis.Error) exn.js_error = e;
     return exn;
    }
   }
   function caml_xmlhttprequest_create(unit){
    if(typeof globalThis.XMLHttpRequest !== "undefined")
     try{return new globalThis.XMLHttpRequest;}catch(e){}
    if(typeof globalThis.activeXObject !== "undefined"){
     try{return new globalThis.activeXObject("Msxml2.XMLHTTP");}catch(e){}
     try{return new globalThis.activeXObject("Msxml3.XMLHTTP");}catch(e){}
     try{return new globalThis.activeXObject("Microsoft.XMLHTTP");}catch(e){}
    }
    caml_failwith("Cannot create a XMLHttpRequest");
   }
   function compare_digits_nat(nat1, ofs1, nat2, ofs2){
    if(nat1.data[ofs1] > nat2.data[ofs2]) return 1;
    if(nat1.data[ofs1] < nat2.data[ofs2]) return - 1;
    return 0;
   }
   function compare_nat(nat1, ofs1, len1, nat2, ofs2, len2){
    var
     a = num_digits_nat(nat1, ofs1, len1),
     b = num_digits_nat(nat2, ofs2, len2);
    if(a > b) return 1;
    if(a < b) return - 1;
    for(var i = len1 - 1; i >= 0; i--){
     if(nat1.data[ofs1 + i] >>> 0 > nat2.data[ofs2 + i] >>> 0) return 1;
     if(nat1.data[ofs1 + i] >>> 0 < nat2.data[ofs2 + i] >>> 0) return - 1;
    }
    return 0;
   }
   function compare_nat_real(nat1, nat2){
    return compare_nat(nat1, 0, nat1.data.length, nat2, 0, nat2.data.length);
   }
   function complement_nat(nat, ofs, len){
    for(var i = 0; i < len; i++)
     nat.data[ofs + i] = (- 1 >>> 0) - (nat.data[ofs + i] >>> 0);
   }
   function create_nat(size){
    var arr = new MlNat(size);
    for(var i = 0; i < size; i++) arr.data[i] = - 1;
    return arr;
   }
   function decr_nat(nat, ofs, len, carry_in){
    var borrow = carry_in == 1 ? 0 : 1;
    for(var i = 0; i < len; i++){
     var x = (nat.data[ofs + i] >>> 0) - borrow;
     nat.data[ofs + i] = x;
     if(x >= 0){borrow = 0; break;} else borrow = 1;
    }
    return borrow == 1 ? 0 : 1;
   }
   function deserialize_nat(reader, sz){
    var len = reader.read32s(), nat = new MlNat(len);
    for(var i = 0; i < len; i++) nat.data[i] = reader.read32s();
    sz[0] = len * 4;
    return nat;
   }
   function div_helper(a, b, c){
    var
     x = a * 65536 + (b >>> 16),
     y = Math.floor(x / c) * 65536,
     z = x % c * 65536,
     w = z + (b & 0x0000FFFF);
    return [y + Math.floor(w / c), w % c];
   }
   function div_digit_nat(natq, ofsq, natr, ofsr, nat1, ofs1, len, nat2, ofs2){
    var rem = nat1.data[ofs1 + len - 1] >>> 0;
    for(var i = len - 2; i >= 0; i--){
     var
      x = div_helper(rem, nat1.data[ofs1 + i] >>> 0, nat2.data[ofs2] >>> 0);
     natq.data[ofsq + i] = x[0];
     rem = x[1];
    }
    natr.data[ofsr] = rem;
    return 0;
   }
   function num_leading_zero_bits_in_digit(nat, ofs){
    var a = nat.data[ofs], b = 0;
    if(a & 0xFFFF0000){b += 16; a >>>= 16;}
    if(a & 0xFF00){b += 8; a >>>= 8;}
    if(a & 0xF0){b += 4; a >>>= 4;}
    if(a & 12){b += 2; a >>>= 2;}
    if(a & 2){b += 1; a >>>= 1;}
    if(a & 1) b += 1;
    return 32 - b;
   }
   function shift_left_nat(nat1, ofs1, len1, nat2, ofs2, nbits){
    if(nbits == 0){nat2.data[ofs2] = 0; return 0;}
    var wrap = 0;
    for(var i = 0; i < len1; i++){
     var a = nat1.data[ofs1 + i] >>> 0;
     nat1.data[ofs1 + i] = a << nbits | wrap;
     wrap = a >>> 32 - nbits;
    }
    nat2.data[ofs2] = wrap;
    return 0;
   }
   function shift_right_nat(nat1, ofs1, len1, nat2, ofs2, nbits){
    if(nbits == 0){nat2.data[ofs2] = 0; return 0;}
    var wrap = 0;
    for(var i = len1 - 1; i >= 0; i--){
     var a = nat1.data[ofs1 + i] >>> 0;
     nat1.data[ofs1 + i] = a >>> nbits | wrap;
     wrap = a << 32 - nbits;
    }
    nat2.data[ofs2] = wrap;
    return 0;
   }
   function set_to_zero_nat(nat, ofs, len){
    for(var i = 0; i < len; i++) nat.data[ofs + i] = 0;
    return 0;
   }
   function nat_of_array(l){return new MlNat(l);}
   function mult_digit_nat(nat1, ofs1, len1, nat2, ofs2, len2, nat3, ofs3){
    var carry = 0, a = nat3.data[ofs3] >>> 0;
    for(var i = 0; i < len2; i++){
     var
      x1 =
        (nat1.data[ofs1 + i] >>> 0)
        + (nat2.data[ofs2 + i] >>> 0) * (a & 0x0000FFFF)
        + carry,
      x2 = (nat2.data[ofs2 + i] >>> 0) * (a >>> 16);
     carry = Math.floor(x2 / 65536);
     var x3 = x1 + x2 % 65536 * 65536;
     nat1.data[ofs1 + i] = x3;
     carry += Math.floor(x3 / 4294967296);
    }
    return len2 < len1 && carry
            ? add_nat
              (nat1, ofs1 + len2, len1 - len2, nat_of_array([carry]), 0, 1, 0)
            : carry;
   }
   function sub_nat(nat1, ofs1, len1, nat2, ofs2, len2, carry_in){
    var borrow = carry_in == 1 ? 0 : 1;
    for(var i = 0; i < len2; i++){
     var
      x = (nat1.data[ofs1 + i] >>> 0) - (nat2.data[ofs2 + i] >>> 0) - borrow;
     nat1.data[ofs1 + i] = x;
     if(x >= 0) borrow = 0; else borrow = 1;
    }
    return decr_nat(nat1, ofs1 + len2, len1 - len2, borrow == 1 ? 0 : 1);
   }
   function div_nat(nat1, ofs1, len1, nat2, ofs2, len2){
    if(len2 == 1){
     div_digit_nat(nat1, ofs1 + 1, nat1, ofs1, nat1, ofs1, len1, nat2, ofs2);
     return 0;
    }
    var s = num_leading_zero_bits_in_digit(nat2, ofs2 + len2 - 1);
    shift_left_nat(nat2, ofs2, len2, nat_of_array([0]), 0, s);
    shift_left_nat(nat1, ofs1, len1, nat_of_array([0]), 0, s);
    var d = (nat2.data[ofs2 + len2 - 1] >>> 0) + 1, a = create_nat(len2 + 1);
    for(var i = len1 - 1; i >= len2; i--){
     var
      quo =
        d == 4294967296
         ? nat1.data[ofs1 + i] >>> 0
         : div_helper
            (nat1.data[ofs1 + i] >>> 0, nat1.data[ofs1 + i - 1] >>> 0, d)
           [0];
     set_to_zero_nat(a, 0, len2 + 1);
     mult_digit_nat(a, 0, len2 + 1, nat2, ofs2, len2, nat_of_array([quo]), 0);
     sub_nat(nat1, ofs1 + i - len2, len2 + 1, a, 0, len2 + 1, 1);
     while
     (nat1.data[ofs1 + i] != 0
      || compare_nat(nat1, ofs1 + i - len2, len2, nat2, ofs2, len2) >= 0){
      quo = quo + 1;
      sub_nat(nat1, ofs1 + i - len2, len2 + 1, nat2, ofs2, len2, 1);
     }
     nat1.data[ofs1 + i] = quo;
    }
    shift_right_nat(nat1, ofs1, len2, nat_of_array([0]), 0, s);
    shift_right_nat(nat2, ofs2, len2, nat_of_array([0]), 0, s);
    return 0;
   }
   function serialize_nat(writer, nat, sz){
    var len = nat.data.length;
    writer.write(32, len);
    for(var i = 0; i < len; i++) writer.write(32, nat.data[i]);
    sz[0] = len * 4;
    sz[1] = len * 8;
   }
   function initialize_nat(){
    caml_custom_ops["_nat"] =
     {deserialize: deserialize_nat,
      serialize: serialize_nat,
      hash: caml_hash_nat};
   }
   function is_digit_int(nat, ofs){if(nat.data[ofs] >= 0) return 1; return 0;}
   function is_digit_odd(nat, ofs){if(nat.data[ofs] & 1) return 1; return 0;}
   function is_digit_zero(nat, ofs){
    if(nat.data[ofs] == 0) return 1;
    return 0;
   }
   function jsoo_create_file_extern(name, content){
    if(globalThis.jsoo_create_file)
     globalThis.jsoo_create_file(name, content);
    else{
     if(! globalThis.caml_fs_tmp) globalThis.caml_fs_tmp = [];
     globalThis.caml_fs_tmp.push({name: name, content: content});
    }
    return 0;
   }
   function jsoo_effect_not_supported(){
    caml_failwith("Effect handlers are not supported");
   }
   function land_digit_nat(nat1, ofs1, nat2, ofs2){nat1.data[ofs1] &= nat2.data[ofs2]; return 0;
   }
   function length_nat(x){return x.data.length;}
   function lor_digit_nat(nat1, ofs1, nat2, ofs2){nat1.data[ofs1] |= nat2.data[ofs2]; return 0;
   }
   function lxor_digit_nat(nat1, ofs1, nat2, ofs2){nat1.data[ofs1] ^= nat2.data[ofs2]; return 0;
   }
   function ml_canvas_arc(canvas, p, radius, theta1, theta2, ccw){
    canvas.ctxt.arc(p[1], p[2], radius, theta1, theta2, ccw);
    return 0;
   }
   function ml_canvas_arc_to(canvas, p1, p2, radius){
    canvas.ctxt.arcTo(p1[1], p1[2], p2[1], p2[2], radius);
    return 0;
   }
   function ml_canvas_bezier_curve_to(canvas, p1, p2, p3){
    canvas.ctxt.bezierCurveTo(p1[1], p1[2], p2[1], p2[2], p3[1], p3[2]);
    return 0;
   }
   function ml_canvas_blit(dst_canvas, dpos, src_canvas, spos, size){
    var width = size[1], height = size[2];
    if(! _ml_canvas_valid_canvas_size(width, height))
     caml_invalid_argument("Canvas.blit: invalid dimensions");
    dst_canvas.ctxt.drawImage
     (src_canvas.surface,
      spos[1],
      spos[2],
      width,
      height,
      dpos[1],
      dpos[2],
      width,
      height);
    return 0;
   }
   function ml_canvas_clear_path(canvas){canvas.ctxt.beginPath(); return 0;}
   function ml_canvas_clip(canvas, nonzero){
    if(nonzero) canvas.ctxt.clip("nonzero"); else canvas.ctxt.clip();
    return 0;
   }
   function ml_canvas_clip_path(canvas, path, nonzero){
    if(nonzero)
     canvas.ctxt.clip(path, "nonzero");
    else
     canvas.ctxt.clip(path);
    return 0;
   }
   function ml_canvas_close_path(canvas){canvas.ctxt.closePath(); return 0;}
   function ml_canvas_commit(canvas){return 0;}
   function ml_canvas_compare(canvas1, canvas2){
    if(canvas1.id < canvas2.id)
     return - 1;
    else if(canvas1.id > canvas2.id) return 1; else return 0;
   }
   function ml_canvas_create_offscreen(size){
    _ml_canvas_ensure_initialized();
    var width = size[1], height = size[2];
    if(! _ml_canvas_valid_canvas_size(width, height))
     caml_invalid_argument("Canvas.createOffscreen: invalid dimensions");
    var
     id = ++_next_id,
     canvas =
       {name: null,
        frame: null,
        header: null,
        surface: surface,
        ctxt: ctxt,
        x: 0,
        y: 0,
        width: width,
        height: height,
        id: id,
        autocommit: false,
        resizeable: false,
        minimize: false,
        maximize: false,
        close: false},
     surface = document.createElement("canvas");
    surface.id = "s" + id;
    surface.width = width;
    surface.height = height;
    surface.style.position = "absolute";
    surface.canvas = canvas;
    canvas.surface = surface;
    var ctxt = surface.getContext("2d");
    ctxt.globalAlpha = 1.0;
    ctxt.lineWidth = 2.0;
    ctxt.fillStyle = "white";
    ctxt.strokeStyle = "black";
    canvas.ctxt = ctxt;
    return canvas;
   }
   function ml_canvas_create_offscreen_from_image_data(data){
    _ml_canvas_ensure_initialized();
    var
     width = caml_ba_dim(data, 1),
     height = caml_ba_dim(data, 0),
     canvas = ml_canvas_create_offscreen([0, width, height]);
    if(canvas === null) return null;
    var
     sta = new window.Uint8Array(caml_ba_to_typed_array(data).buffer),
     dta = new window.Uint8ClampedArray(sta.length);
    for(var i = 0; i < sta.length; i += 4){
     dta[i + 0] = sta[i + 2];
     dta[i + 1] = sta[i + 1];
     dta[i + 2] = sta[i + 0];
     dta[i + 3] = sta[i + 3];
    }
    if(window.ImageData === undefined){
     var image = canvas.ctxt.createImageData(width, height);
     image.data.set(dta);
    }
    else
     var image = new window.ImageData(dta, width, height);
    canvas.ctxt.putImageData(image, 0, 0);
    return canvas;
   }
   function ml_canvas_create_offscreen_from_png(filename, onload){
    _ml_canvas_ensure_initialized();
    var img = _ml_canvas_image_of_png_file(filename);
    if(img === null){
     caml_raise_with_string(caml_named_value("Read_png_failed"), filename);
     return 0;
    }
    img[0].then
     (function(__img){
       var
        canvas = ml_canvas_create_offscreen([0, img[1].width, img[1].height]);
       if(canvas === null) return 0;
       canvas.ctxt.drawImage(img[1], 0, 0);
       onload(canvas);
       return 0;
      });
    return 0;
   }
   function ml_canvas_create_onscreen
   (autocommit,
    decorated,
    resizeable,
    minimize,
    maximize,
    close,
    title,
    target,
    pos,
    size){
    _ml_canvas_ensure_initialized();
    var width = size[1], height = size[2];
    if(! _ml_canvas_valid_canvas_size(width, height))
     caml_invalid_argument("Canvas.blit: invalid dimensions");
    var
     pos = Optional_val(pos, [0, 0, 0]),
     x = pos[1],
     y = pos[2],
     autocommit = Optional_bool_val(autocommit, true),
     decorated = false,
     resizeable = Optional_bool_val(resizeable, true),
     minimize = Optional_bool_val(minimize, true),
     maximize = Optional_bool_val(maximize, true),
     close = Optional_bool_val(close, true),
     title = Optional_val(title, null),
     target = Optional_val(target, null);
    target = document.getElementById(target);
    if(target == null) target = document.body;
    var
     id = ++_next_id,
     canvas =
       {name: title,
        target: target,
        frame: null,
        header: null,
        surface: null,
        ctxt: null,
        x: x,
        y: y,
        width: width,
        height: height,
        id: id,
        autocommit: autocommit,
        resizeable: resizeable,
        minimize: minimize,
        maximize: maximize,
        close: close},
     header_height = decorated == true ? 30 : 0,
     frame = document.createElement("div");
    frame.id = "f" + id;
    if(resizeable == true){
     frame.style.width = "100%";
     frame.style.height = "100%";
    }
    else{
     frame.style.width = width + "px";
     frame.style.height = height + header_height + "px";
    }
    frame.style.visibility = "hidden";
    frame.oncontextmenu = function(){return false;};
    frame.canvas = canvas;
    canvas.frame = frame;
    target.appendChild(frame);
    var header = null;
    if(decorated === true){
     frame.style.border = "1px solid black";
     header = document.createElement("canvas");
     header.id = "h" + id;
     header.width = width;
     header.height = 30;
     _ml_canvas_decorate(header, minimize, maximize, close, title);
     header.onmousedown = _header_down_handler;
     header.canvas = canvas;
     canvas.header = header;
     frame.appendChild(header);
    }
    var surface = document.createElement("canvas");
    surface.id = "s" + id;
    surface.width = width;
    surface.height = height;
    surface.onmousedown = _surface_down_handler;
    surface.canvas = canvas;
    canvas.surface = surface;
    frame.appendChild(surface);
    if(resizeable === true){
     surface.style.width = "100%";
     surface.style.height = "100%";
     _resize.observe(surface);
    }
    var ctxt = surface.getContext("2d");
    ctxt.globalAlpha = 1.0;
    ctxt.lineWidth = 1.0;
    ctxt.fillStyle = "white";
    ctxt.strokeStyle = "black";
    canvas.ctxt = ctxt;
    ctxt.fillRect(0, 0, width, height);
    return canvas;
   }
   function ml_canvas_ellipse
   (canvas, p, radius, rotation, theta1, theta2, ccw){
    canvas.ctxt.ellipse
     (p[1], p[2], radius[1], radius[2], rotation, theta1, theta2, ccw);
    return 0;
   }
   function ml_canvas_export_png(canvas, filename){
    try{
     var data = canvas.surface.toDataURL("image/png").substring(22);
     caml_create_file(filename, window.atob(data));
    }
    catch(exn){
     caml_raise_with_string(caml_named_value("Write_png_failed"), filename);
    }
    return 0;
   }
   function ml_canvas_fill(canvas, nonzero){
    if(nonzero) canvas.ctxt.fill("nonzero"); else canvas.ctxt.fill();
    return 0;
   }
   function ml_canvas_fill_path(canvas, path, nonzero){
    if(nonzero)
     canvas.ctxt.fill(path, "nonzero");
    else
     canvas.ctxt.fill(path);
    return 0;
   }
   function ml_canvas_fill_rect(canvas, pos, size){
    canvas.ctxt.fillRect(pos[1], pos[2], size[1], size[2]);
    return 0;
   }
   function ml_canvas_fill_text(canvas, text, pos){
    canvas.ctxt.fillText(caml_jsstring_of_string(text), pos[1], pos[2]);
    return 0;
   }
   function ml_canvas_get_canvas(id){
    _ml_canvas_ensure_initialized();
    var surface = document.getElementById("s" + id);
    if(surface === null){caml_raise_not_found(); return 0;}
    return surface.canvas;
   }
   function ml_canvas_get_current_timestamp(){
    _ml_canvas_ensure_initialized();
    var e = new window.Event("dummy");
    return caml_int64_of_float(e.timeStamp * 1000.0);
   }
   function ml_canvas_get_fill_color(canvas){
    return typeof canvas.ctxt.fillStyle == "string"
            ? _int_of_color(canvas.ctxt.fillStyle)
            : 0;
   }
   function ml_canvas_get_fill_style(canvas){
    return Draw_style_val(canvas.ctxt.fillStyle);
   }
   function ml_canvas_get_global_alpha(canvas){return canvas.ctxt.globalAlpha;
   }
   function ml_canvas_get_global_composite_operation(canvas){return Val_compop(canvas.ctxt.globalCompositeOperation);
   }
   function ml_canvas_get_id(canvas){return canvas.id;}
   function ml_canvas_get_image_data(canvas, pos, size){
    var width = size[1], height = size[2];
    if(! _ml_canvas_valid_canvas_size(width, height))
     caml_invalid_argument("Canvas.getImageData: invalid dimensions");
    var
     image = canvas.ctxt.getImageData(pos[1], pos[2], width, height),
     sta = new window.Uint8Array(image.data.buffer),
     dta = new window.Uint8Array(sta.length);
    for(var i = 0; i < sta.length; i += 4){
     dta[i + 0] = sta[i + 2];
     dta[i + 1] = sta[i + 1];
     dta[i + 2] = sta[i + 0];
     dta[i + 3] = sta[i + 3];
    }
    return caml_ba_create_unsafe(3, 0, [height, width, 4], dta);
   }
   function ml_canvas_get_line_cap(canvas){return Val_cap_type(canvas.lineCap);
   }
   function ml_canvas_get_line_dash(canvas){
    var arr = canvas.ctxt.getLineDash();
    arr.unshift(254);
    return arr;
   }
   function ml_canvas_get_line_dash_offset(canvas){return canvas.ctxt.lineDashOffset;
   }
   function ml_canvas_get_line_join(canvas){return Val_join_type(canvas.lineJoin);
   }
   function ml_canvas_get_line_width(canvas){return canvas.ctxt.lineWidth;}
   function ml_canvas_get_miter_limit(canvas){return canvas.ctxt.miterLimit;}
   function ml_canvas_get_pixel(canvas, pos){
    var image = canvas.ctxt.getImageData(pos[1], pos[2], 1, 1);
    return image.data[3] << 24 >>> 0 | image.data[0] << 16
           | image.data[1] << 8
           | image.data[2] << 0;
   }
   function ml_canvas_get_position(canvas){
    return canvas.frame !== null ? [0, canvas.x, canvas.y] : [0, 0, 0];
   }
   function ml_canvas_get_shadow_blur(canvas){return canvas.ctxt.shadowBlur;}
   function ml_canvas_get_shadow_color(canvas){
    return _int_of_color(canvas.ctxt.shadowColor);
   }
   function ml_canvas_get_shadow_offset(canvas, offset){
    return [0, canvas.ctxt.shadowOffsetX, canvas.ctxt.shadowOffsetY];
   }
   function ml_canvas_get_size(canvas){
    return [0, canvas.width, canvas.height];
   }
   function ml_canvas_get_stroke_color(canvas){
    return typeof canvas.ctxt.strokeStyle == "string"
            ? _int_of_color(canvas.ctxt.strokeStyle)
            : 0;
   }
   function ml_canvas_get_stroke_style(canvas){
    return Draw_style_val(canvas.ctxt.strokeStyle);
    return 0;
   }
   function ml_canvas_gradient_add_color_stop(gradient, color, pos){gradient.addColorStop(pos, _color_of_int(color)); return 0;
   }
   function ml_canvas_gradient_create_conic(center, angle){
    return _internal_ctxt.createConicGradient(angle, center[1], center[2]);
   }
   function ml_canvas_gradient_create_linear(pos1, pos2){
    return _internal_ctxt.createLinearGradient
            (pos1[1], pos1[2], pos2[1], pos2[2]);
   }
   function ml_canvas_gradient_create_radial(center1, rad1, center2, rad2){
    return _internal_ctxt.createRadialGradient
            (center1[1], center1[2], rad1, center2[1], center2[2], rad2);
   }
   function ml_canvas_hash(canvas){
    var hash = caml_named_value("Hashtbl.hash");
    return hash(canvas.id);
   }
   function ml_canvas_image_data_blit(dst_data, dpos, src_data, spos, size){
    var width = size[1], height = size[2];
    if(! _ml_canvas_valid_canvas_size(width, height))
     caml_invalid_argument("ImageData.blit: invalid dimensions");
    var
     dwidth = caml_ba_dim(dst_data, 1),
     dheight = caml_ba_dim(dst_data, 0),
     swidth = caml_ba_dim(src_data, 1),
     sheight = caml_ba_dim(src_data, 0),
     blit_info =
       _ml_canvas_adjust_blit_info
        (dwidth,
         dheight,
         dpos[1],
         dpos[2],
         swidth,
         sheight,
         spos[1],
         spos[2],
         width,
         height),
     dx = blit_info[0],
     dy = blit_info[1],
     sx = blit_info[2],
     sy = blit_info[3],
     width = blit_info[4],
     height = blit_info[5];
    if(width > 0 && height > 0){
     var
      dta = new window.Uint32Array(caml_ba_to_typed_array(dst_data).buffer),
      sta = new window.Uint32Array(caml_ba_to_typed_array(src_data).buffer);
     for(var y = 0; y < height; ++y)
      for(var x = 0; x < width; ++x)
       dta[(dy + y) * dwidth + (dx + x)] = sta[(sy + y) * swidth + (sx + x)];
    }
    return 0;
   }
   function ml_canvas_image_data_create_from_png(filename, onload){
    _ml_canvas_ensure_initialized();
    var img = _ml_canvas_image_of_png_file(filename);
    if(img === null){
     caml_raise_with_string(caml_named_value("Read_png_failed"), filename);
     return 0;
    }
    img[0].then
     (function(__img){
       var ba = _ml_canvas_ba_of_img(img[1]);
       onload(ba);
       return 0;
      });
    return 0;
   }
   function ml_canvas_image_data_export_png(data, filename){
    _ml_canvas_ensure_initialized();
    try{
     var surface = _ml_canvas_surface_of_ba(data);
     if(surface !== null){
      var data = surface.toDataURL("image/png").substring(22);
      caml_create_file(filename, window.atob(data));
     }
    }
    catch(exn){
     caml_raise_with_string(caml_named_value("Write_png_failed"), filename);
    }
    return 0;
   }
   function ml_canvas_image_data_fill(data, color){
    var ta = new window.Uint32Array(caml_ba_to_typed_array(data).buffer);
    for(var i = 0; i < ta.length; i++) ta[i] = color;
    return 0;
   }
   function ml_canvas_image_data_get_pixel(data, pos){
    var ta = new window.Uint32Array(caml_ba_to_typed_array(data).buffer);
    return ta[pos[2] * caml_ba_dim(data, 1) + pos[1]];
   }
   function ml_canvas_image_data_get_size(data){
    return [0, caml_ba_dim(data, 1), caml_ba_dim(data, 0)];
   }
   function ml_canvas_image_data_import_png(data, pos, filename, onload){
    _ml_canvas_ensure_initialized();
    var
     img = _ml_canvas_image_of_png_file(filename),
     surface = _ml_canvas_surface_of_ba(data);
    if(img === null || surface === null){
     caml_raise_with_string(caml_named_value("Read_png_failed"), filename);
     return 0;
    }
    img[0].then
     (function(__img){
       var ctxt = surface.getContext("2d");
       ctxt.drawImage(img[1], pos[1], pos[2]);
       var
        image = ctxt.getImageData(0, 0, surface.width, surface.height),
        sta = new window.Uint8Array(image.data.buffer),
        dta = caml_ba_to_typed_array(data);
       for(var i = 0; i < dta.length; i++) dta[i] = sta[i];
       onload(data);
       return 0;
      });
    return 0;
   }
   function ml_canvas_image_data_put_pixel(data, pos, color){
    var ta = new window.Uint32Array(caml_ba_to_typed_array(data).buffer);
    ta[pos[2] * caml_ba_dim(data, 1) + pos[1]] = color;
    return 0;
   }
   function ml_canvas_image_data_sub(src_data, spos, size){
    var dwidth = size[1], dheight = size[2];
    if(! _ml_canvas_valid_canvas_size(dwidth, dheight))
     caml_invalid_argument("ImageData.blit: invalid dimensions");
    var
     swidth = caml_ba_dim(src_data, 1),
     sheight = caml_ba_dim(src_data, 0),
     ta = new window.Uint8Array(dwidth * dheight * 4),
     dst_data = caml_ba_create_unsafe(3, 0, [dheight, dwidth, 4], ta),
     blit_info =
       _ml_canvas_adjust_blit_info
        (dwidth,
         dheight,
         0,
         0,
         swidth,
         sheight,
         spos[1],
         spos[2],
         dwidth,
         dheight),
     dx = blit_info[0],
     dy = blit_info[1],
     sx = blit_info[2],
     sy = blit_info[3],
     width = blit_info[4],
     height = blit_info[5];
    if(width > 0 && height > 0){
     var
      dta = new window.Uint32Array(caml_ba_to_typed_array(dst_data).buffer),
      sta = new window.Uint32Array(caml_ba_to_typed_array(src_data).buffer);
     for(var y = 0; y < height; ++y)
      for(var x = 0; x < width; ++x)
       dta[(dy + y) * dwidth + (dx + x)] = sta[(sy + y) * swidth + (sx + x)];
    }
    return dst_data;
   }
   function ml_canvas_import_png(canvas, pos, filename, onload){
    var img = _ml_canvas_image_of_png_file(filename);
    if(img === null){
     caml_raise_with_string(caml_named_value("Read_png_failed"), filename);
     return 0;
    }
    img[0].then
     (function(__img){
       canvas.ctxt.drawImage(img[1], pos[1], pos[2]);
       onload(canvas);
       return 0;
      });
    return 0;
   }
   function ml_canvas_init(){
    if(_ml_canvas_initialized === true) return 0;
    document.addEventListener("keydown", _key_down_handler, {passive: true});
    document.addEventListener("keyup", _key_up_handler, {passive: true});
    document.addEventListener("mouseup", _up_handler, {passive: true});
    document.addEventListener("mousemove", _move_handler, {passive: true});
    window.requestAnimationFrame(_frame_handler);
    _ml_canvas_initialized = true;
    return 0;
   }
   function ml_canvas_int_of_key(keycode){return Key_code_val(keycode);}
   function ml_canvas_key_of_int(keycode){
    caml_invalid_argument("key_of_int: i must be in the 0-255 range");
    return Val_key_code(keycode);
   }
   function ml_canvas_line_to(canvas, p){
    canvas.ctxt.lineTo(p[1], p[2]);
    return 0;
   }
   function ml_canvas_move_to(canvas, p){
    canvas.ctxt.moveTo(p[1], p[2]);
    return 0;
   }
   function ml_canvas_path_add(path1, path2){path1.addPath(path2); return 0;}
   function ml_canvas_path_add_transformed(path1, path2, t){
    var m = new window.DOMMatrix([[1], t[2], t[3], t[4], t[5], t[6]]);
    path1.addPath(path2, m);
    return 0;
   }
   function ml_canvas_path_arc(path, p, radius, theta1, theta2, ccw){path.arc(p[1], p[2], radius, theta1, theta2, ccw); return 0;
   }
   function ml_canvas_path_arc_to(path, p1, p2, radius){
    path.arcTo(p1[1], p1[2], p2[1], p2[2], radius);
    return 0;
   }
   function ml_canvas_path_bezier_curve_to(path, cp1, cp2, p){
    path.bezierCurveTo(cp1[1], cp1[2], cp2[1], cp2[2], p[1], p[2]);
    return 0;
   }
   function ml_canvas_path_close(path){path.closePath(); return 0;}
   function ml_canvas_path_create(){return new window.Path2D();}
   function ml_canvas_path_ellipse
   (path, p, radius, rotation, theta1, theta2, ccw){
    path.ellipse
     (p[1], p[2], radius[1], radius[2], rotation, theta1, theta2, ccw);
    return 0;
   }
   function ml_canvas_path_line_to(path, p){path.lineTo(p[1], p[2]); return 0;
   }
   function ml_canvas_path_move_to(path, p){path.moveTo(p[1], p[2]); return 0;
   }
   function ml_canvas_path_quadratic_curve_to(path, cp, p){
    path.quadraticCurveTo(cp[1], cp[2], p[1], p[2]);
    return 0;
   }
   function ml_canvas_path_rect(path, pos, size){
    path.rect(pos[1], pos[2], size[1], size[2]);
    return 0;
   }
   function ml_canvas_pattern_create(image, repeat){
    var img_canv = _ml_canvas_surface_of_ba(image);
    return _internal_ctxt.createPattern(img_canv, Repeat_val(repeat));
   }
   function ml_canvas_put_image_data(canvas, dpos, data, spos, size){
    var width = size[1], height = size[2];
    if(! _ml_canvas_valid_canvas_size(width, height))
     caml_invalid_argument("Canvas.putImageData: invalid dimensions");
    var
     sta = new window.Uint8Array(caml_ba_to_typed_array(data).buffer),
     dta = new window.Uint8ClampedArray(sta.length);
    for(var i = 0; i < sta.length; i += 4){
     dta[i + 0] = sta[i + 2];
     dta[i + 1] = sta[i + 1];
     dta[i + 2] = sta[i + 0];
     dta[i + 3] = sta[i + 3];
    }
    if(window.ImageData === undefined){
     var
      image =
        canvas.ctxt.createImageData
         (caml_ba_dim(data, 1), caml_ba_dim(data, 0));
     image.data.set(dta);
    }
    else
     var
      image =
        new window.ImageData(dta, caml_ba_dim(data, 1), caml_ba_dim(data, 0));
    canvas.ctxt.putImageData
     (image, dpos[1], dpos[2], spos[1], spos[2], width, height);
    return 0;
   }
   function ml_canvas_put_pixel(canvas, pos, color){
    var image = canvas.ctxt.createImageData(1, 1);
    image.data[3] = (color & 0xFF000000) >>> 24;
    image.data[0] = (color & 0x00FF0000) >>> 16;
    image.data[1] = (color & 0x0000FF00) >>> 8;
    image.data[2] = (color & 0x000000FF) >>> 0;
    canvas.ctxt.putImageData(image, pos[1], pos[2]);
    return 0;
   }
   function ml_canvas_quadratic_curve_to(canvas, p1, p2){
    canvas.ctxt.quadraticCurveTo(p1[1], p1[2], p2[1], p2[2]);
    return 0;
   }
   function ml_canvas_rect(canvas, pos, size){
    canvas.ctxt.rect(pos[1], pos[2], size[1], size[2]);
    return 0;
   }
   function ml_canvas_restore(canvas){canvas.ctxt.restore(); return 0;}
   function ml_canvas_rotate(canvas, theta){canvas.ctxt.rotate(theta); return 0;
   }
   function ml_canvas_run(mlProcessEvent, mlContinuation){
    _ml_canvas_ensure_initialized();
    if(_ml_canvas_mlProcessEvent !== null) return 0;
    _ml_canvas_mlProcessEvent = mlProcessEvent;
    _ml_canvas_mlContinuation = mlContinuation;
    _ml_canvas_mlException = null;
    return 0;
   }
   function ml_canvas_save(canvas){canvas.ctxt.save(); return 0;}
   function ml_canvas_scale(canvas, vec){
    canvas.ctxt.scale(vec[1], vec[2]);
    return 0;
   }
   function ml_canvas_set_fill_color(canvas, color){
    canvas.ctxt.fillStyle = _color_of_int(color);
    return 0;
   }
   function ml_canvas_set_fill_gradient(canvas, grad){canvas.ctxt.fillStyle = grad; return 0;
   }
   function ml_canvas_set_fill_pattern(canvas, pattern){canvas.ctxt.fillStyle = pattern; return 0;
   }
   function ml_canvas_set_fill_style(canvas, style){
    canvas.ctxt.fillStyle = Val_draw_style(style);
    return 0;
   }
   function ml_canvas_set_font(canvas, family, size, slant, weight){
    canvas.ctxt.font =
     Slant_val(slant) + " " + weight + " " + size + "pt "
     + caml_jsstring_of_string(family);
    return 0;
   }
   function ml_canvas_set_global_alpha(canvas, global_alpha){canvas.ctxt.globalAlpha = global_alpha; return 0;
   }
   function ml_canvas_set_global_composite_operation(canvas, op){
    canvas.ctxt.globalCompositeOperation = Compop_val(op);
    return 0;
   }
   function ml_canvas_set_line_cap(canvas, cap){
    canvas.ctxt.lineCap = Cap_type_val(cap);
    return 0;
   }
   function ml_canvas_set_line_dash(canvas, dash){
    dash.shift();
    canvas.ctxt.setLineDash(dash);
    return 0;
   }
   function ml_canvas_set_line_dash_offset(canvas, offset){canvas.ctxt.lineDashOffset = offset; return 0;
   }
   function ml_canvas_set_line_join(canvas, join){
    canvas.ctxt.lineJoin = Join_type_val(join);
    return 0;
   }
   function ml_canvas_set_line_width(canvas, width){canvas.ctxt.lineWidth = width; return 0;
   }
   function ml_canvas_set_miter_limit(canvas, limit){canvas.ctxt.miterLimit = limit; return 0;
   }
   function ml_canvas_set_position(canvas, pos){
    if(canvas.frame !== null){
     var x = pos[1], y = pos[2];
     canvas.x = x;
     canvas.y = y;
     canvas.frame.style.left = x + "px";
     canvas.frame.style.top = y + "px";
    }
    return 0;
   }
   function ml_canvas_set_shadow_blur(canvas, blur){canvas.ctxt.shadowBlur = blur; return 0;
   }
   function ml_canvas_set_shadow_color(canvas, color){
    canvas.ctxt.shadowColor = _color_of_int(color);
    return 0;
   }
   function ml_canvas_set_shadow_offset(canvas, offset){
    canvas.ctxt.shadowOffsetX = offset[1];
    canvas.ctxt.shadowOffsetY = offset[2];
    return 0;
   }
   function ml_canvas_set_size(canvas, size){
    var width = size[1], height = size[2];
    if(! _ml_canvas_valid_canvas_size(width, height))
     caml_invalid_argument("Canvas.setSize: invalid dimensions");
    var img = canvas.ctxt.getImageData(0, 0, canvas.width, canvas.height);
    if(canvas.header !== null){
     canvas.header.width = width;
     _ml_canvas_decorate
      (canvas.header,
       canvas.minimize,
       canvas.maximize,
       canvas.close,
       canvas.name);
    }
    canvas.surface.width = canvas.width = width;
    canvas.surface.height = canvas.height = height;
    canvas.ctxt.fillRect(0, 0, width, height);
    canvas.ctxt.putImageData(img, 0, 0);
    return 0;
   }
   function ml_canvas_set_stroke_color(canvas, color){
    canvas.ctxt.strokeStyle = _color_of_int(color);
    return 0;
   }
   function ml_canvas_set_stroke_gradient(canvas, grad){canvas.ctxt.strokeStyle = grad; return 0;
   }
   function ml_canvas_set_stroke_pattern(canvas, pattern){canvas.ctxt.strokeStyle = pattern; return 0;
   }
   function ml_canvas_set_stroke_style(canvas, style){
    canvas.ctxt.strokeStyle = Val_draw_style(style);
    return 0;
   }
   function ml_canvas_set_transform(canvas, t){
    canvas.ctxt.setTransform(t[1], t[2], t[3], t[4], t[5], t[6]);
    return 0;
   }
   function ml_canvas_shear(canvas, vec){
    canvas.ctxt.transform(1.0, vec[2], vec[1], 1.0, 0.0, 0.0);
    return 0;
   }
   function ml_canvas_show(canvas){
    if(canvas.frame !== null){
     _focus = canvas;
     canvas.frame.style.visibility = "visible";
    }
    return 0;
   }
   function ml_canvas_stroke(canvas){canvas.ctxt.stroke(); return 0;}
   function ml_canvas_stroke_path(canvas, path){canvas.ctxt.stroke(path); return 0;
   }
   function ml_canvas_stroke_rect(canvas, pos, size){
    canvas.ctxt.strokeRect(pos[1], pos[2], size[1], size[2]);
    return 0;
   }
   function ml_canvas_stroke_text(canvas, text, pos){
    canvas.ctxt.strokeText(caml_jsstring_of_string(text), pos[1], pos[2]);
    return 0;
   }
   function ml_canvas_transform(canvas, t){
    canvas.ctxt.transform(t[1], t[2], t[3], t[4], t[5], t[6]);
    return 0;
   }
   function ml_canvas_translate(canvas, vec){
    canvas.ctxt.translate(vec[1], vec[2]);
    return 0;
   }
   function mult_nat(nat1, ofs1, len1, nat2, ofs2, len2, nat3, ofs3, len3){
    var carry = 0;
    for(var i = 0; i < len3; i++)
     carry +=
      mult_digit_nat
       (nat1, ofs1 + i, len1 - i, nat2, ofs2, len2, nat3, ofs3 + i);
    return carry;
   }
   function nth_digit_nat(nat, ofs){return nat.data[ofs];}
   function nth_digit_nat_native(nat, ofs){return nat.data[ofs];}
   var
    re_match =
      function(){
        var
         re_word_letters =
           [0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0xFF,
            0x03,
            0xFE,
            0xFF,
            0xFF,
            0x87,
            0xFE,
            0xFF,
            0xFF,
            0x07,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0xFF,
            0xFF,
            0x7F,
            0xFF,
            0xFF,
            0xFF,
            0x7F,
            0xFF],
         opcodes =
           {CHAR: 0,
            CHARNORM: 1,
            STRING: 2,
            STRINGNORM: 3,
            CHARCLASS: 4,
            BOL: 5,
            EOL: 6,
            WORDBOUNDARY: 7,
            BEGGROUP: 8,
            ENDGROUP: 9,
            REFGROUP: 10,
            ACCEPT: 11,
            SIMPLEOPT: 12,
            SIMPLESTAR: 13,
            SIMPLEPLUS: 14,
            GOTO: 15,
            PUSHBACK: 16,
            SETMARK: 17,
            CHECKPROGRESS: 18};
        function is_word_letter(c){
         return re_word_letters[c >> 3] >> (c & 7) & 1;
        }
        function in_bitset(s, i){
         return caml_string_get(s, i >> 3) >> (i & 7) & 1;
        }
        function re_match_impl(re, s, pos, partial){
         var
          prog = caml_js_from_array(re[1]),
          cpool = caml_js_from_array(re[2]),
          normtable = caml_jsbytes_of_string(re[3]),
          numgroups = re[4] | 0,
          numregisters = re[5] | 0,
          startchars = re[6] | 0,
          s = caml_uint8_array_of_string(s),
          pc = 0,
          quit = false,
          stack = [],
          groups = new Array(numgroups),
          re_register = new Array(numregisters);
         for(var i = 0; i < groups.length; i++)
          groups[i] = {start: - 1, end: - 1};
         groups[0].start = pos;
         function backtrack(){
          while(stack.length){
           var item = stack.pop();
           if(item.undo)
            item.undo.obj[item.undo.prop] = item.undo.value;
           else if(item.pos){pc = item.pos.pc; pos = item.pos.txt; return;}
          }
          quit = true;
         }
         function push(item){stack.push(item);}
         function accept(){
          groups[0].end = pos;
          var result = new Array(1 + groups.length * 2);
          result[0] = 0;
          for(var i = 0; i < groups.length; i++){
           var g = groups[i];
           if(g.start < 0 || g.end < 0) g.start = g.end = - 1;
           result[2 * i + 1] = g.start;
           result[2 * i + 1 + 1] = g.end;
          }
          return result;
         }
         function prefix_match(){
          if(partial) return accept(); else backtrack();
         }
         while(! quit){
          var
           op = prog[pc] & 0xff,
           sarg = prog[pc] >> 8,
           uarg = sarg & 0xff,
           c = s[pos],
           group;
          pc++;
          switch(op){
            case opcodes.CHAR:
             if(pos === s.length){prefix_match(); break;}
             if(c === uarg) pos++; else backtrack();
             break;
            case opcodes.CHARNORM:
             if(pos === s.length){prefix_match(); break;}
             if(normtable.charCodeAt(c) === uarg) pos++; else backtrack();
             break;
            case opcodes.STRING:
             for
             (var arg = caml_jsbytes_of_string(cpool[uarg]), i = 0;
              i < arg.length;
              i++){
              if(pos === s.length){prefix_match(); break;}
              if(c === arg.charCodeAt(i))
               c = s[++pos];
              else{backtrack(); break;}
             }
             break;
            case opcodes.STRINGNORM:
             for
             (var arg = caml_jsbytes_of_string(cpool[uarg]), i = 0;
              i < arg.length;
              i++){
              if(pos === s.length){prefix_match(); break;}
              if(normtable.charCodeAt(c) === arg.charCodeAt(i))
               c = s[++pos];
              else{backtrack(); break;}
             }
             break;
            case opcodes.CHARCLASS:
             if(pos === s.length){prefix_match(); break;}
             if(in_bitset(cpool[uarg], c)) pos++; else backtrack();
             break;
            case opcodes.BOL:
             if(pos > 0 && s[pos - 1] != 10) backtrack(); break;
            case opcodes.EOL:
             if(pos < s.length && s[pos] != 10) backtrack(); break;
            case opcodes.WORDBOUNDARY:
             if(pos == 0){
              if(pos === s.length){prefix_match(); break;}
              if(is_word_letter(s[0])) break;
              backtrack();
             }
             else if(pos === s.length){
              if(is_word_letter(s[pos - 1])) break;
              backtrack();
             }
             else{
              if(is_word_letter(s[pos - 1]) != is_word_letter(s[pos])) break;
              backtrack();
             }
             break;
            case opcodes.BEGGROUP:
             group = groups[uarg];
             push({undo: {obj: group, prop: "start", value: group.start}});
             group.start = pos;
             break;
            case opcodes.ENDGROUP:
             group = groups[uarg];
             push({undo: {obj: group, prop: "end", value: group.end}});
             group.end = pos;
             break;
            case opcodes.REFGROUP:
             group = groups[uarg];
             if(group.start < 0 || group.end < 0){backtrack(); break;}
             for(var i = group.start; i < group.end; i++){
              if(pos === s.length){prefix_match(); break;}
              if(s[i] != s[pos]){backtrack(); break;}
              pos++;
             }
             break;
            case opcodes.SIMPLEOPT:
             if(in_bitset(cpool[uarg], c)) pos++; break;
            case opcodes.SIMPLESTAR:
             while(in_bitset(cpool[uarg], c)) c = s[++pos]; break;
            case opcodes.SIMPLEPLUS:
             if(pos === s.length){prefix_match(); break;}
             if(in_bitset(cpool[uarg], c))
              do c = s[++pos];while(in_bitset(cpool[uarg], c));
             else
              backtrack();
             break;
            case opcodes.ACCEPT: return accept();
            case opcodes.GOTO:
             pc = pc + sarg; break;
            case opcodes.PUSHBACK:
             push({pos: {pc: pc + sarg, txt: pos}}); break;
            case opcodes.SETMARK:
             push
              ({undo: {obj: re_register, prop: uarg, value: re_register[uarg]}});
             re_register[uarg] = pos;
             break;
            case opcodes.CHECKPROGRESS:
             if(re_register[uarg] === pos) backtrack(); break;
            default: throw new Error("Invalid bytecode");
          }
         }
         return 0;
        }
        return re_match_impl;
       }
       ();
   function re_partial_match(re, s, pos){
    if(pos < 0 || pos > caml_ml_string_length(s))
     caml_invalid_argument("Str.partial_match");
    var res = re_match(re, s, pos, 1);
    return res ? res : [0];
   }
   function re_replacement_text(repl, groups, orig){
    var
     repl = caml_jsbytes_of_string(repl),
     len = repl.length,
     orig = caml_jsbytes_of_string(orig),
     res = "",
     n = 0,
     cur,
     start,
     end,
     c;
    while(n < len){
     cur = repl.charAt(n++);
     if(cur != "\\")
      res += cur;
     else{
      if(n == len) caml_failwith("Str.replace: illegal backslash sequence");
      cur = repl.charAt(n++);
      switch(cur){
        case "\\":
         res += cur; break;
        case "0":
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
         c = + cur;
         if(c * 2 >= groups.length - 1)
          caml_failwith("Str.replace: reference to unmatched group");
         start = caml_array_get(groups, c * 2);
         end = caml_array_get(groups, c * 2 + 1);
         if(start == - 1)
          caml_failwith("Str.replace: reference to unmatched group");
         res += orig.slice(start, end);
         break;
        default: res += "\\" + cur;
      }
     }
    }
    return caml_string_of_jsbytes(res);
   }
   function re_search_backward(re, s, pos){
    if(pos < 0 || pos > caml_ml_string_length(s))
     caml_invalid_argument("Str.search_backward");
    while(pos >= 0){
     var res = re_match(re, s, pos, 0);
     if(res) return res;
     pos--;
    }
    return [0];
   }
   function re_search_forward(re, s, pos){
    if(pos < 0 || pos > caml_ml_string_length(s))
     caml_invalid_argument("Str.search_forward");
    while(pos <= caml_ml_string_length(s)){
     var res = re_match(re, s, pos, 0);
     if(res) return res;
     pos++;
    }
    return [0];
   }
   function re_string_match(re, s, pos){
    if(pos < 0 || pos > caml_ml_string_length(s))
     caml_invalid_argument("Str.string_match");
    var res = re_match(re, s, pos, 0);
    return res ? res : [0];
   }
   function set_digit_nat(nat, ofs, digit){nat.data[ofs] = digit; return 0;}
   function set_digit_nat_native(nat, ofs, digit){nat.data[ofs] = digit; return 0;
   }
   function square_nat(nat1, ofs1, len1, nat2, ofs2, len2){
    var carry = 0;
    carry += add_nat(nat1, ofs1, len1, nat1, ofs1, len1, 0);
    carry += mult_nat(nat1, ofs1, len1, nat2, ofs2, len2, nat2, ofs2, len2);
    return carry;
   }
   function caml_setup_uncaught_exception_handler(){
    var process = globalThis.process;
    if(process && process.on)
     process.on
      ("uncaughtException",
       function(err, origin){
        caml_fatal_uncaught_exception(err);
        process.exit(2);
       });
    else if(globalThis.addEventListener)
     globalThis.addEventListener
      ("error",
       function(event){
        if(event.error) caml_fatal_uncaught_exception(event.error);
       });
   }
   caml_setup_uncaught_exception_handler();
   globalThis.jsoo_runtime =
    {ml_canvas_get_current_timestamp: ml_canvas_get_current_timestamp,
     ml_canvas_get_canvas: ml_canvas_get_canvas,
     ml_canvas_stop: ml_canvas_stop,
     ml_canvas_run: ml_canvas_run,
     _ml_canvas_process_event: _ml_canvas_process_event,
     _ml_canvas_mlException: _ml_canvas_mlException,
     _ml_canvas_mlContinuation: _ml_canvas_mlContinuation,
     _ml_canvas_mlProcessEvent: _ml_canvas_mlProcessEvent,
     ml_canvas_init: ml_canvas_init,
     ml_canvas_key_of_int: ml_canvas_key_of_int,
     ml_canvas_int_of_key: ml_canvas_int_of_key,
     ml_canvas_export_png: ml_canvas_export_png,
     ml_canvas_import_png: ml_canvas_import_png,
     ml_canvas_put_image_data: ml_canvas_put_image_data,
     ml_canvas_get_image_data: ml_canvas_get_image_data,
     ml_canvas_put_pixel: ml_canvas_put_pixel,
     ml_canvas_get_pixel: ml_canvas_get_pixel,
     ml_canvas_blit: ml_canvas_blit,
     ml_canvas_stroke_text: ml_canvas_stroke_text,
     ml_canvas_fill_text: ml_canvas_fill_text,
     ml_canvas_stroke_rect: ml_canvas_stroke_rect,
     ml_canvas_fill_rect: ml_canvas_fill_rect,
     ml_canvas_clip_path: ml_canvas_clip_path,
     ml_canvas_clip: ml_canvas_clip,
     ml_canvas_stroke_path: ml_canvas_stroke_path,
     ml_canvas_stroke: ml_canvas_stroke,
     ml_canvas_fill_path: ml_canvas_fill_path,
     ml_canvas_fill: ml_canvas_fill,
     ml_canvas_ellipse: ml_canvas_ellipse,
     ml_canvas_rect: ml_canvas_rect,
     ml_canvas_bezier_curve_to: ml_canvas_bezier_curve_to,
     ml_canvas_quadratic_curve_to: ml_canvas_quadratic_curve_to,
     ml_canvas_arc_to: ml_canvas_arc_to,
     ml_canvas_arc: ml_canvas_arc,
     ml_canvas_line_to: ml_canvas_line_to,
     ml_canvas_move_to: ml_canvas_move_to,
     ml_canvas_close_path: ml_canvas_close_path,
     ml_canvas_clear_path: ml_canvas_clear_path,
     ml_canvas_set_font: ml_canvas_set_font,
     ml_canvas_set_shadow_offset: ml_canvas_set_shadow_offset,
     ml_canvas_get_shadow_offset: ml_canvas_get_shadow_offset,
     ml_canvas_set_shadow_blur: ml_canvas_set_shadow_blur,
     ml_canvas_get_shadow_blur: ml_canvas_get_shadow_blur,
     ml_canvas_set_shadow_color: ml_canvas_set_shadow_color,
     ml_canvas_get_shadow_color: ml_canvas_get_shadow_color,
     ml_canvas_set_global_composite_operation:
     ml_canvas_set_global_composite_operation,
     ml_canvas_get_global_composite_operation:
     ml_canvas_get_global_composite_operation,
     ml_canvas_get_fill_style: ml_canvas_get_fill_style,
     ml_canvas_set_fill_style: ml_canvas_set_fill_style,
     ml_canvas_set_fill_pattern: ml_canvas_set_fill_pattern,
     ml_canvas_set_fill_gradient: ml_canvas_set_fill_gradient,
     ml_canvas_set_global_alpha: ml_canvas_set_global_alpha,
     ml_canvas_get_global_alpha: ml_canvas_get_global_alpha,
     ml_canvas_set_fill_color: ml_canvas_set_fill_color,
     ml_canvas_get_fill_color: ml_canvas_get_fill_color,
     ml_canvas_get_stroke_style: ml_canvas_get_stroke_style,
     ml_canvas_set_stroke_style: ml_canvas_set_stroke_style,
     ml_canvas_set_stroke_pattern: ml_canvas_set_stroke_pattern,
     ml_canvas_set_stroke_gradient: ml_canvas_set_stroke_gradient,
     ml_canvas_set_stroke_color: ml_canvas_set_stroke_color,
     ml_canvas_get_stroke_color: ml_canvas_get_stroke_color,
     ml_canvas_set_miter_limit: ml_canvas_set_miter_limit,
     ml_canvas_get_miter_limit: ml_canvas_get_miter_limit,
     ml_canvas_set_line_join: ml_canvas_set_line_join,
     ml_canvas_get_line_join: ml_canvas_get_line_join,
     ml_canvas_set_line_dash: ml_canvas_set_line_dash,
     ml_canvas_get_line_dash: ml_canvas_get_line_dash,
     ml_canvas_set_line_dash_offset: ml_canvas_set_line_dash_offset,
     ml_canvas_get_line_dash_offset: ml_canvas_get_line_dash_offset,
     ml_canvas_set_line_cap: ml_canvas_set_line_cap,
     ml_canvas_get_line_cap: ml_canvas_get_line_cap,
     ml_canvas_set_line_width: ml_canvas_set_line_width,
     ml_canvas_get_line_width: ml_canvas_get_line_width,
     _int_of_color: _int_of_color,
     _color_of_int: _color_of_int,
     ml_canvas_restore: ml_canvas_restore,
     ml_canvas_save: ml_canvas_save,
     ml_canvas_rotate: ml_canvas_rotate,
     ml_canvas_shear: ml_canvas_shear,
     ml_canvas_scale: ml_canvas_scale,
     ml_canvas_translate: ml_canvas_translate,
     ml_canvas_transform: ml_canvas_transform,
     ml_canvas_set_transform: ml_canvas_set_transform,
     ml_canvas_set_position: ml_canvas_set_position,
     ml_canvas_get_position: ml_canvas_get_position,
     ml_canvas_set_size: ml_canvas_set_size,
     ml_canvas_get_size: ml_canvas_get_size,
     ml_canvas_get_id: ml_canvas_get_id,
     ml_canvas_commit: ml_canvas_commit,
     ml_canvas_close: ml_canvas_close,
     ml_canvas_hide: ml_canvas_hide,
     ml_canvas_show: ml_canvas_show,
     ml_canvas_create_offscreen_from_png: ml_canvas_create_offscreen_from_png,
     ml_canvas_create_offscreen_from_image_data:
     ml_canvas_create_offscreen_from_image_data,
     ml_canvas_create_offscreen: ml_canvas_create_offscreen,
     ml_canvas_create_onscreen: ml_canvas_create_onscreen,
     _ml_canvas_decorate: _ml_canvas_decorate,
     _next_id: _next_id,
     ml_canvas_compare: ml_canvas_compare,
     ml_canvas_hash: ml_canvas_hash,
     ml_canvas_pattern_create: ml_canvas_pattern_create,
     ml_canvas_gradient_add_color_stop: ml_canvas_gradient_add_color_stop,
     ml_canvas_gradient_create_conic: ml_canvas_gradient_create_conic,
     ml_canvas_gradient_create_radial: ml_canvas_gradient_create_radial,
     ml_canvas_gradient_create_linear: ml_canvas_gradient_create_linear,
     ml_canvas_path_add_transformed: ml_canvas_path_add_transformed,
     ml_canvas_path_add: ml_canvas_path_add,
     ml_canvas_path_ellipse: ml_canvas_path_ellipse,
     ml_canvas_path_rect: ml_canvas_path_rect,
     ml_canvas_path_bezier_curve_to: ml_canvas_path_bezier_curve_to,
     ml_canvas_path_quadratic_curve_to: ml_canvas_path_quadratic_curve_to,
     ml_canvas_path_arc_to: ml_canvas_path_arc_to,
     ml_canvas_path_arc: ml_canvas_path_arc,
     ml_canvas_path_line_to: ml_canvas_path_line_to,
     ml_canvas_path_move_to: ml_canvas_path_move_to,
     ml_canvas_path_close: ml_canvas_path_close,
     ml_canvas_path_create: ml_canvas_path_create,
     ml_canvas_image_data_export_png: ml_canvas_image_data_export_png,
     ml_canvas_image_data_import_png: ml_canvas_image_data_import_png,
     ml_canvas_image_data_put_pixel: ml_canvas_image_data_put_pixel,
     ml_canvas_image_data_get_pixel: ml_canvas_image_data_get_pixel,
     ml_canvas_image_data_blit: ml_canvas_image_data_blit,
     ml_canvas_image_data_sub: ml_canvas_image_data_sub,
     _ml_canvas_adjust_blit_info: _ml_canvas_adjust_blit_info,
     ml_canvas_image_data_fill: ml_canvas_image_data_fill,
     ml_canvas_image_data_get_size: ml_canvas_image_data_get_size,
     ml_canvas_image_data_create_from_png:
     ml_canvas_image_data_create_from_png,
     _ml_canvas_surface_of_ba: _ml_canvas_surface_of_ba,
     _ml_canvas_ba_of_img: _ml_canvas_ba_of_img,
     _ml_canvas_image_of_png_file: _ml_canvas_image_of_png_file,
     _frame_handler: _frame_handler,
     _resize_handler: _resize_handler,
     _move_handler: _move_handler,
     _up_handler: _up_handler,
     _surface_down_handler: _surface_down_handler,
     _header_down_handler: _header_down_handler,
     _key_up_handler: _key_up_handler,
     _key_down_handler: _key_down_handler,
     _make_key_event: _make_key_event,
     _event_canvas_scale: _event_canvas_scale,
     _resize: _resize,
     _move: _move,
     _focus: _focus,
     _internal_ctxt: _internal_ctxt,
     _internal_canvas: _internal_canvas,
     _ml_canvas_valid_canvas_size: _ml_canvas_valid_canvas_size,
     _ml_canvas_ensure_initialized: _ml_canvas_ensure_initialized,
     _ml_canvas_initialized: _ml_canvas_initialized,
     Compop_val: Compop_val,
     Val_compop: Val_compop,
     Cap_type_val: Cap_type_val,
     Val_cap_type: Val_cap_type,
     Join_type_val: Join_type_val,
     Val_join_type: Val_join_type,
     Slant_val: Slant_val,
     Draw_style_val: Draw_style_val,
     Val_draw_style: Val_draw_style,
     Repeat_val: Repeat_val,
     Val_repeat: Val_repeat,
     Val_button_state: Val_button_state,
     Val_button: Val_button,
     Val_key_state: Val_key_state,
     Key_code_val: Key_code_val,
     Val_key_code: Val_key_code,
     Val_focus_in_out: Val_focus_in_out,
     Optional_val: Optional_val,
     Optional_bool_val: Optional_bool_val,
     COMPOP_TAG: COMPOP_TAG,
     CAP_TYPE_TAG: CAP_TYPE_TAG,
     JOIN_TYPE_TAG: JOIN_TYPE_TAG,
     SLANT_TAG: SLANT_TAG,
     REPEAT_TAG: REPEAT_TAG,
     STYLE_TAG: STYLE_TAG,
     EVENT_TAG: EVENT_TAG,
     BUTTON_STATE_TAG: BUTTON_STATE_TAG,
     BUTTON_TAG: BUTTON_TAG,
     KEY_STATE_TAG: KEY_STATE_TAG,
     KEY_TAG: KEY_TAG,
     FOCUS_TAG: FOCUS_TAG,
     keyname_to_keycode: keyname_to_keycode,
     BUTTON_STATE: BUTTON_STATE,
     BUTTON: BUTTON,
     KEY_STATE: KEY_STATE,
     KEY: KEY,
     FOCUS: FOCUS,
     SLANT: SLANT,
     caml_runtime_events_read_poll: caml_runtime_events_read_poll,
     caml_runtime_events_free_cursor: caml_runtime_events_free_cursor,
     caml_runtime_events_create_cursor: caml_runtime_events_create_cursor,
     caml_ml_runtime_events_resume: caml_ml_runtime_events_resume,
     caml_ml_runtime_events_pause: caml_ml_runtime_events_pause,
     caml_ml_runtime_events_start: caml_ml_runtime_events_start,
     caml_runtime_events_user_resolve: caml_runtime_events_user_resolve,
     caml_runtime_events_user_write: caml_runtime_events_user_write,
     caml_runtime_events_user_register: caml_runtime_events_user_register,
     caml_custom_event_index: caml_custom_event_index,
     caml_decompress_input: caml_decompress_input,
     jsoo_effect_not_supported: jsoo_effect_not_supported,
     caml_ml_condition_signal: caml_ml_condition_signal,
     caml_ml_condition_broadcast: caml_ml_condition_broadcast,
     caml_ml_condition_wait: caml_ml_condition_wait,
     caml_ml_condition_new: caml_ml_condition_new,
     caml_get_continuation_callstack: caml_get_continuation_callstack,
     caml_continuation_use_and_update_handler_noexc:
     caml_continuation_use_and_update_handler_noexc,
     caml_continuation_use_noexc: caml_continuation_use_noexc,
     caml_alloc_stack: caml_alloc_stack,
     caml_ml_mutex_unlock: caml_ml_mutex_unlock,
     caml_ml_mutex_try_lock: caml_ml_mutex_try_lock,
     caml_ml_mutex_lock: caml_ml_mutex_lock,
     caml_ml_mutex_new: caml_ml_mutex_new,
     MlMutex: MlMutex,
     caml_lxm_next: caml_lxm_next,
     caml_ml_domain_cpu_relax: caml_ml_domain_cpu_relax,
     caml_ml_domain_id: caml_ml_domain_id,
     caml_domain_spawn: caml_domain_spawn,
     caml_domain_id: caml_domain_id,
     caml_recommended_domain_count: caml_recommended_domain_count,
     caml_ml_domain_set_name: caml_ml_domain_set_name,
     caml_ml_domain_unique_token: caml_ml_domain_unique_token,
     caml_atomic_make_contended: caml_atomic_make_contended,
     caml_atomic_exchange: caml_atomic_exchange,
     caml_atomic_fetch_add: caml_atomic_fetch_add,
     caml_atomic_cas: caml_atomic_cas,
     caml_atomic_load: caml_atomic_load,
     caml_domain_dls_get: caml_domain_dls_get,
     caml_domain_dls_set: caml_domain_dls_set,
     caml_domain_dls: caml_domain_dls,
     caml_ephe_check_data: caml_ephe_check_data,
     caml_ephe_unset_data: caml_ephe_unset_data,
     caml_ephe_set_data: caml_ephe_set_data,
     caml_ephe_get_data_copy: caml_ephe_get_data_copy,
     caml_ephe_get_data: caml_ephe_get_data,
     caml_ephe_blit_data: caml_ephe_blit_data,
     caml_ephe_blit_key: caml_ephe_blit_key,
     caml_ephe_check_key: caml_ephe_check_key,
     caml_ephe_get_key_copy: caml_ephe_get_key_copy,
     caml_ephe_get_key: caml_ephe_get_key,
     caml_weak_set: caml_weak_set,
     caml_weak_create: caml_weak_create,
     caml_ephe_create: caml_ephe_create,
     caml_ephe_unset_key: caml_ephe_unset_key,
     caml_ephe_set_key: caml_ephe_set_key,
     caml_ephe_data_offset: caml_ephe_data_offset,
     caml_ephe_key_offset: caml_ephe_key_offset,
     caml_unix_inet_addr_of_string: caml_unix_inet_addr_of_string,
     caml_unix_findclose: caml_unix_findclose,
     caml_unix_findnext: caml_unix_findnext,
     caml_unix_findfirst: caml_unix_findfirst,
     caml_unix_rewinddir: caml_unix_rewinddir,
     caml_unix_closedir: caml_unix_closedir,
     caml_unix_readdir: caml_unix_readdir,
     caml_unix_opendir: caml_unix_opendir,
     caml_unix_has_symlink: caml_unix_has_symlink,
     caml_unix_getpwuid: caml_unix_getpwuid,
     caml_unix_getuid: caml_unix_getuid,
     caml_unix_unlink: caml_unix_unlink,
     caml_unix_readlink: caml_unix_readlink,
     caml_unix_symlink: caml_unix_symlink,
     caml_unix_rmdir: caml_unix_rmdir,
     caml_unix_mkdir: caml_unix_mkdir,
     caml_unix_lstat_64: caml_unix_lstat_64,
     caml_unix_lstat: caml_unix_lstat,
     caml_unix_stat_64: caml_unix_stat_64,
     caml_unix_stat: caml_unix_stat,
     make_unix_err_args: make_unix_err_args,
     caml_unix_isatty: caml_unix_isatty,
     caml_unix_filedescr_of_fd: caml_unix_filedescr_of_fd,
     caml_unix_cleanup: caml_unix_cleanup,
     caml_unix_startup: caml_unix_startup,
     caml_unix_mktime: caml_unix_mktime,
     caml_unix_localtime: caml_unix_localtime,
     caml_unix_gmtime: caml_unix_gmtime,
     caml_unix_time: caml_unix_time,
     caml_unix_gettimeofday: caml_unix_gettimeofday,
     caml_str_initialize: caml_str_initialize,
     re_replacement_text: re_replacement_text,
     re_partial_match: re_partial_match,
     re_string_match: re_string_match,
     re_search_backward: re_search_backward,
     re_search_forward: re_search_forward,
     re_match: re_match,
     caml_sys_is_regular_file: caml_sys_is_regular_file,
     caml_spacetime_only_works_for_native_code:
     caml_spacetime_only_works_for_native_code,
     caml_register_channel_for_spacetime: caml_register_channel_for_spacetime,
     caml_sys_const_naked_pointers_checked:
     caml_sys_const_naked_pointers_checked,
     caml_spacetime_enabled: caml_spacetime_enabled,
     caml_ml_runtime_warnings_enabled: caml_ml_runtime_warnings_enabled,
     caml_ml_enable_runtime_warnings: caml_ml_enable_runtime_warnings,
     caml_runtime_warnings: caml_runtime_warnings,
     caml_install_signal_handler: caml_install_signal_handler,
     caml_runtime_parameters: caml_runtime_parameters,
     caml_runtime_variant: caml_runtime_variant,
     caml_sys_isatty: caml_sys_isatty,
     caml_sys_get_config: caml_sys_get_config,
     os_type: os_type,
     caml_sys_const_backend_type: caml_sys_const_backend_type,
     caml_sys_const_ostype_cygwin: caml_sys_const_ostype_cygwin,
     caml_sys_const_ostype_win32: caml_sys_const_ostype_win32,
     caml_sys_const_ostype_unix: caml_sys_const_ostype_unix,
     caml_sys_const_max_wosize: caml_sys_const_max_wosize,
     caml_sys_const_int_size: caml_sys_const_int_size,
     caml_sys_const_word_size: caml_sys_const_word_size,
     caml_sys_const_big_endian: caml_sys_const_big_endian,
     caml_sys_random_seed: caml_sys_random_seed,
     caml_sys_time_include_children: caml_sys_time_include_children,
     caml_sys_time: caml_sys_time,
     caml_sys_system_command: caml_sys_system_command,
     caml_sys_executable_name: caml_sys_executable_name,
     caml_sys_modify_argv: caml_sys_modify_argv,
     caml_sys_argv: caml_sys_argv,
     caml_sys_get_argv: caml_sys_get_argv,
     caml_executable_name: caml_executable_name,
     caml_argv: caml_argv,
     caml_sys_unsafe_getenv: caml_sys_unsafe_getenv,
     caml_sys_getenv: caml_sys_getenv,
     jsoo_sys_getenv: jsoo_sys_getenv,
     caml_set_static_env: caml_set_static_env,
     caml_fatal_uncaught_exception: caml_fatal_uncaught_exception,
     caml_format_exception: caml_format_exception,
     caml_is_special_exception: caml_is_special_exception,
     caml_sys_exit: caml_sys_exit,
     caml_raise_sys_error: caml_raise_sys_error,
     caml_maybe_print_stats: caml_maybe_print_stats,
     caml_is_printable: caml_is_printable,
     caml_get_global_data: caml_get_global_data,
     caml_register_global: caml_register_global,
     caml_build_symbols: caml_build_symbols,
     caml_global_data: caml_global_data,
     caml_named_value: caml_named_value,
     caml_register_named_value: caml_register_named_value,
     caml_named_values: caml_named_values,
     caml_call_gen: caml_call_gen,
     caml_set_parser_trace: caml_set_parser_trace,
     caml_parse_engine: caml_parse_engine,
     caml_parser_trace: caml_parser_trace,
     caml_is_continuation_tag: caml_is_continuation_tag,
     caml_lazy_read_result: caml_lazy_read_result,
     caml_lazy_reset_to_lazy: caml_lazy_reset_to_lazy,
     caml_lazy_update_to_forward: caml_lazy_update_to_forward,
     caml_lazy_update_to_forcing: caml_lazy_update_to_forcing,
     caml_obj_update_tag: caml_obj_update_tag,
     caml_obj_add_offset: caml_obj_add_offset,
     caml_obj_reachable_words: caml_obj_reachable_words,
     caml_obj_set_raw_field: caml_obj_set_raw_field,
     caml_obj_raw_field: caml_obj_raw_field,
     caml_fresh_oo_id: caml_fresh_oo_id,
     caml_set_oo_id: caml_set_oo_id,
     caml_oo_last_id: caml_oo_last_id,
     caml_get_public_method: caml_get_public_method,
     caml_lazy_make_forward: caml_lazy_make_forward,
     caml_obj_is_shared: caml_obj_is_shared,
     caml_obj_compare_and_swap: caml_obj_compare_and_swap,
     caml_obj_make_forward: caml_obj_make_forward,
     caml_obj_truncate: caml_obj_truncate,
     caml_obj_dup: caml_obj_dup,
     caml_obj_with_tag: caml_obj_with_tag,
     caml_obj_block: caml_obj_block,
     caml_obj_set_tag: caml_obj_set_tag,
     caml_obj_tag: caml_obj_tag,
     caml_obj_is_block: caml_obj_is_block,
     caml_alloc_dummy_infix: caml_alloc_dummy_infix,
     caml_update_dummy: caml_update_dummy,
     deserialize_nat: deserialize_nat,
     serialize_nat: serialize_nat,
     lxor_digit_nat: lxor_digit_nat,
     lor_digit_nat: lor_digit_nat,
     land_digit_nat: land_digit_nat,
     compare_nat_real: compare_nat_real,
     compare_nat: compare_nat,
     compare_digits_nat: compare_digits_nat,
     shift_right_nat: shift_right_nat,
     div_nat: div_nat,
     div_digit_nat: div_digit_nat,
     div_helper: div_helper,
     shift_left_nat: shift_left_nat,
     square_nat: square_nat,
     mult_nat: mult_nat,
     mult_digit_nat: mult_digit_nat,
     sub_nat: sub_nat,
     decr_nat: decr_nat,
     complement_nat: complement_nat,
     add_nat: add_nat,
     incr_nat: incr_nat,
     is_digit_odd: is_digit_odd,
     is_digit_zero: is_digit_zero,
     is_digit_int: is_digit_int,
     num_leading_zero_bits_in_digit: num_leading_zero_bits_in_digit,
     num_digits_nat: num_digits_nat,
     nth_digit_nat_native: nth_digit_nat_native,
     set_digit_nat_native: set_digit_nat_native,
     nth_digit_nat: nth_digit_nat,
     set_digit_nat: set_digit_nat,
     blit_nat: blit_nat,
     set_to_zero_nat: set_to_zero_nat,
     create_nat: create_nat,
     nat_of_array: nat_of_array,
     length_nat: length_nat,
     caml_hash_nat: caml_hash_nat,
     MlNat: MlNat,
     initialize_nat: initialize_nat,
     caml_array_of_bytes: caml_array_of_bytes,
     caml_array_of_string: caml_array_of_string,
     caml_js_to_string: caml_js_to_string,
     caml_to_js_string: caml_to_js_string,
     caml_js_from_string: caml_js_from_string,
     caml_new_string: caml_new_string,
     caml_js_to_byte_string: caml_js_to_byte_string,
     caml_is_ml_string: caml_is_ml_string,
     caml_ml_bytes_content: caml_ml_bytes_content,
     caml_is_ml_bytes: caml_is_ml_bytes,
     caml_bytes_of_jsbytes: caml_bytes_of_jsbytes,
     caml_string_of_jsstring: caml_string_of_jsstring,
     caml_jsstring_of_string: caml_jsstring_of_string,
     caml_jsbytes_of_string: caml_jsbytes_of_string,
     caml_string_of_jsbytes: caml_string_of_jsbytes,
     caml_bytes_of_string: caml_bytes_of_string,
     caml_string_of_bytes: caml_string_of_bytes,
     caml_string_lessthan: caml_string_lessthan,
     caml_string_lessequal: caml_string_lessequal,
     caml_string_equal: caml_string_equal,
     caml_string_compare: caml_string_compare,
     caml_ml_string_length: caml_ml_string_length,
     caml_string_unsafe_set: caml_string_unsafe_set,
     caml_string_unsafe_get: caml_string_unsafe_get,
     caml_string_concat: caml_string_concat,
     caml_ml_bytes_length: caml_ml_bytes_length,
     caml_blit_string: caml_blit_string,
     caml_blit_bytes: caml_blit_bytes,
     caml_fill_bytes: caml_fill_bytes,
     caml_bytes_greaterthan: caml_bytes_greaterthan,
     caml_string_greaterthan: caml_string_greaterthan,
     caml_bytes_greaterequal: caml_bytes_greaterequal,
     caml_string_greaterequal: caml_string_greaterequal,
     caml_bytes_lessthan: caml_bytes_lessthan,
     caml_bytes_lessequal: caml_bytes_lessequal,
     caml_bytes_notequal: caml_bytes_notequal,
     caml_string_notequal: caml_string_notequal,
     caml_bytes_equal: caml_bytes_equal,
     caml_bytes_compare: caml_bytes_compare,
     caml_bytes_of_array: caml_bytes_of_array,
     caml_string_of_array: caml_string_of_array,
     caml_create_bytes: caml_create_bytes,
     caml_create_string: caml_create_string,
     caml_uint8_array_of_string: caml_uint8_array_of_string,
     caml_uint8_array_of_bytes: caml_uint8_array_of_bytes,
     caml_convert_bytes_to_array: caml_convert_bytes_to_array,
     caml_convert_string_to_bytes: caml_convert_string_to_bytes,
     MlBytes: MlBytes,
     caml_bytes_of_utf16_jsstring: caml_bytes_of_utf16_jsstring,
     caml_bytes_set: caml_bytes_set,
     caml_string_set64: caml_string_set64,
     caml_bytes_set64: caml_bytes_set64,
     caml_string_set32: caml_string_set32,
     caml_bytes_set32: caml_bytes_set32,
     caml_string_set16: caml_string_set16,
     caml_bytes_set16: caml_bytes_set16,
     caml_string_set: caml_string_set,
     caml_bytes_get: caml_bytes_get,
     caml_bytes_get64: caml_bytes_get64,
     caml_string_get64: caml_string_get64,
     caml_bytes_get32: caml_bytes_get32,
     caml_string_get32: caml_string_get32,
     caml_bytes_get16: caml_bytes_get16,
     caml_string_get16: caml_string_get16,
     caml_string_get: caml_string_get,
     caml_bytes_bound_error: caml_bytes_bound_error,
     caml_string_bound_error: caml_string_bound_error,
     caml_bytes_unsafe_set: caml_bytes_unsafe_set,
     caml_bytes_unsafe_get: caml_bytes_unsafe_get,
     jsoo_is_ascii: jsoo_is_ascii,
     caml_utf16_of_utf8: caml_utf16_of_utf8,
     caml_utf8_of_utf16: caml_utf8_of_utf16,
     caml_subarray_to_jsbytes: caml_subarray_to_jsbytes,
     caml_str_repeat: caml_str_repeat,
     caml_md5_bytes: caml_md5_bytes,
     caml_MD5Final: caml_MD5Final,
     caml_MD5Update: caml_MD5Update,
     caml_MD5Init: caml_MD5Init,
     caml_MD5Transform: caml_MD5Transform,
     caml_md5_string: caml_md5_string,
     caml_md5_chan: caml_md5_chan,
     caml_output_value_to_buffer: caml_output_value_to_buffer,
     caml_output_value_to_bytes: caml_output_value_to_bytes,
     caml_output_value_to_string: caml_output_value_to_string,
     caml_output_val: caml_output_val,
     MlObjectTable: MlObjectTable,
     caml_marshal_data_size: caml_marshal_data_size,
     caml_marshal_header_size: caml_marshal_header_size,
     caml_input_value_from_reader: caml_input_value_from_reader,
     caml_custom_ops: caml_custom_ops,
     caml_nativeint_unmarshal: caml_nativeint_unmarshal,
     caml_int32_unmarshal: caml_int32_unmarshal,
     caml_int64_marshal: caml_int64_marshal,
     caml_int64_unmarshal: caml_int64_unmarshal,
     caml_input_value_from_bytes: caml_input_value_from_bytes,
     caml_input_value_from_string: caml_input_value_from_string,
     caml_float_of_bytes: caml_float_of_bytes,
     BigStringReader: BigStringReader,
     MlStringReader: MlStringReader,
     UInt8ArrayReader: UInt8ArrayReader,
     caml_marshal_constants: caml_marshal_constants,
     caml_new_lex_engine: caml_new_lex_engine,
     caml_lex_engine: caml_lex_engine,
     caml_lex_array: caml_lex_array,
     caml_js_error_of_exception: caml_js_error_of_exception,
     caml_xmlhttprequest_create: caml_xmlhttprequest_create,
     caml_js_get_console: caml_js_get_console,
     caml_js_html_entities: caml_js_html_entities,
     caml_js_html_escape: caml_js_html_escape,
     caml_js_on_ie: caml_js_on_ie,
     caml_js_object: caml_js_object,
     caml_pure_js_expr: caml_pure_js_expr,
     caml_js_expr: caml_js_expr,
     caml_js_eval_string: caml_js_eval_string,
     caml_js_strict_equals: caml_js_strict_equals,
     caml_js_equals: caml_js_equals,
     caml_js_function_arity: caml_js_function_arity,
     caml_js_wrap_meth_callback_unsafe: caml_js_wrap_meth_callback_unsafe,
     caml_js_wrap_meth_callback_strict: caml_js_wrap_meth_callback_strict,
     caml_js_wrap_meth_callback_arguments:
     caml_js_wrap_meth_callback_arguments,
     caml_js_wrap_meth_callback: caml_js_wrap_meth_callback,
     caml_js_wrap_callback_unsafe: caml_js_wrap_callback_unsafe,
     caml_js_wrap_callback_strict: caml_js_wrap_callback_strict,
     caml_js_wrap_callback_arguments: caml_js_wrap_callback_arguments,
     caml_js_wrap_callback: caml_js_wrap_callback,
     caml_ojs_new_arr: caml_ojs_new_arr,
     caml_js_new: caml_js_new,
     caml_js_meth_call: caml_js_meth_call,
     caml_js_fun_call: caml_js_fun_call,
     caml_js_call: caml_js_call,
     caml_js_var: caml_js_var,
     caml_list_to_js_array: caml_list_to_js_array,
     caml_list_of_js_array: caml_list_of_js_array,
     caml_js_to_array: caml_js_to_array,
     caml_js_from_array: caml_js_from_array,
     caml_js_to_int32: caml_js_to_int32,
     caml_js_to_float: caml_js_to_float,
     caml_js_from_float: caml_js_from_float,
     caml_js_to_bool: caml_js_to_bool,
     caml_js_from_bool: caml_js_from_bool,
     caml_js_error_option_of_exception: caml_js_error_option_of_exception,
     caml_exn_with_js_backtrace: caml_exn_with_js_backtrace,
     caml_maybe_attach_backtrace: caml_maybe_attach_backtrace,
     caml_wrap_exception: caml_wrap_exception,
     caml_jsoo_flags_effects: caml_jsoo_flags_effects,
     caml_jsoo_flags_use_js_string: caml_jsoo_flags_use_js_string,
     caml_is_js: caml_is_js,
     caml_callback: caml_callback,
     caml_trampoline_return: caml_trampoline_return,
     caml_trampoline: caml_trampoline,
     caml_js_typeof: caml_js_typeof,
     caml_js_instanceof: caml_js_instanceof,
     caml_js_delete: caml_js_delete,
     caml_js_get: caml_js_get,
     caml_js_set: caml_js_set,
     caml_js_pure_expr: caml_js_pure_expr,
     caml_ml_set_buffered: caml_ml_set_buffered,
     caml_ml_is_buffered: caml_ml_is_buffered,
     caml_ml_output_int: caml_ml_output_int,
     caml_ml_pos_out_64: caml_ml_pos_out_64,
     caml_ml_pos_out: caml_ml_pos_out,
     caml_pos_out: caml_pos_out,
     caml_ml_seek_out_64: caml_ml_seek_out_64,
     caml_ml_seek_out: caml_ml_seek_out,
     caml_seek_out: caml_seek_out,
     caml_output_value: caml_output_value,
     caml_ml_output_char: caml_ml_output_char,
     caml_ml_output: caml_ml_output,
     caml_ml_output_bigarray: caml_ml_output_bigarray,
     caml_ml_output_bytes: caml_ml_output_bytes,
     caml_ml_output_ta: caml_ml_output_ta,
     caml_ml_flush: caml_ml_flush,
     caml_ml_input_scan_line: caml_ml_input_scan_line,
     caml_ml_pos_in_64: caml_ml_pos_in_64,
     caml_ml_pos_in: caml_ml_pos_in,
     caml_pos_in: caml_pos_in,
     caml_ml_seek_in_64: caml_ml_seek_in_64,
     caml_ml_seek_in: caml_ml_seek_in,
     caml_seek_in: caml_seek_in,
     caml_ml_input_int: caml_ml_input_int,
     caml_ml_input_char: caml_ml_input_char,
     caml_input_value_to_outside_heap: caml_input_value_to_outside_heap,
     caml_input_value: caml_input_value,
     caml_ml_input_block: caml_ml_input_block,
     caml_ml_input_bigarray: caml_ml_input_bigarray,
     caml_ml_input: caml_ml_input,
     caml_refill: caml_refill,
     caml_ml_set_channel_refill: caml_ml_set_channel_refill,
     caml_ml_set_channel_output: caml_ml_set_channel_output,
     caml_ml_channel_size_64: caml_ml_channel_size_64,
     caml_ml_channel_size: caml_ml_channel_size,
     caml_ml_close_channel: caml_ml_close_channel,
     caml_ml_set_binary_mode: caml_ml_set_binary_mode,
     caml_channel_descriptor: caml_channel_descriptor,
     caml_ml_open_descriptor_in: caml_ml_open_descriptor_in,
     caml_ml_open_descriptor_out: caml_ml_open_descriptor_out,
     caml_ml_out_channels_list: caml_ml_out_channels_list,
     caml_ml_channel_get: caml_ml_channel_get,
     caml_ml_channel_restore: caml_ml_channel_restore,
     caml_ml_channel_redirect: caml_ml_channel_redirect,
     caml_ml_channels: caml_ml_channels,
     caml_ml_set_channel_name: caml_ml_set_channel_name,
     caml_sys_open: caml_sys_open,
     caml_sys_close: caml_sys_close,
     caml_sys_fds: caml_sys_fds,
     caml_int64_bswap: caml_int64_bswap,
     caml_int32_bswap: caml_int32_bswap,
     caml_bswap16: caml_bswap16,
     caml_mod: caml_mod,
     caml_div: caml_div,
     caml_mul: caml_mul,
     caml_int_of_string: caml_int_of_string,
     caml_parse_digit: caml_parse_digit,
     caml_parse_sign_and_base: caml_parse_sign_and_base,
     caml_format_int: caml_format_int,
     caml_int64_hash: caml_int64_hash,
     caml_int64_to_bytes: caml_int64_to_bytes,
     caml_int64_of_bytes: caml_int64_of_bytes,
     caml_int64_hi32: caml_int64_hi32,
     caml_int64_lo32: caml_int64_lo32,
     caml_int64_create_lo_hi: caml_int64_create_lo_hi,
     caml_int64_create_lo_mi_hi: caml_int64_create_lo_mi_hi,
     caml_int64_of_string: caml_int64_of_string,
     caml_int64_format: caml_int64_format,
     caml_int64_of_float: caml_int64_of_float,
     caml_int64_to_float: caml_int64_to_float,
     caml_int64_to_int32: caml_int64_to_int32,
     caml_int64_of_int32: caml_int64_of_int32,
     caml_int64_mod: caml_int64_mod,
     caml_int64_div: caml_int64_div,
     caml_int64_shift_right: caml_int64_shift_right,
     caml_int64_shift_right_unsigned: caml_int64_shift_right_unsigned,
     caml_int64_shift_left: caml_int64_shift_left,
     caml_int64_xor: caml_int64_xor,
     caml_int64_or: caml_int64_or,
     caml_int64_and: caml_int64_and,
     caml_int64_is_negative: caml_int64_is_negative,
     caml_int64_is_zero: caml_int64_is_zero,
     caml_int64_mul: caml_int64_mul,
     caml_int64_sub: caml_int64_sub,
     caml_int64_add: caml_int64_add,
     caml_int64_neg: caml_int64_neg,
     caml_int64_compare: caml_int64_compare,
     caml_int64_ult: caml_int64_ult,
     MlInt64: MlInt64,
     caml_int64_offset: caml_int64_offset,
     caml_float_of_string: caml_float_of_string,
     caml_format_float: caml_format_float,
     caml_fma_float: caml_fma_float,
     caml_erfc_float: caml_erfc_float,
     caml_erf_float: caml_erf_float,
     caml_cbrt_float: caml_cbrt_float,
     caml_round_float: caml_round_float,
     caml_atanh_float: caml_atanh_float,
     caml_tanh_float: caml_tanh_float,
     caml_asinh_float: caml_asinh_float,
     caml_sinh_float: caml_sinh_float,
     caml_acosh_float: caml_acosh_float,
     caml_cosh_float: caml_cosh_float,
     caml_log10_float: caml_log10_float,
     caml_hypot_float: caml_hypot_float,
     caml_log2_float: caml_log2_float,
     caml_log1p_float: caml_log1p_float,
     caml_exp2_float: caml_exp2_float,
     caml_expm1_float: caml_expm1_float,
     caml_signbit_float: caml_signbit_float,
     caml_copysign_float: caml_copysign_float,
     caml_float_compare: caml_float_compare,
     caml_frexp_float: caml_frexp_float,
     caml_ldexp_float: caml_ldexp_float,
     caml_modf_float: caml_modf_float,
     caml_classify_float: caml_classify_float,
     caml_int32_float_of_bits: caml_int32_float_of_bits,
     caml_trunc_float: caml_trunc_float,
     caml_nextafter_float: caml_nextafter_float,
     caml_int64_float_of_bits: caml_int64_float_of_bits,
     caml_hexstring_of_float: caml_hexstring_of_float,
     caml_int32_bits_of_float: caml_int32_bits_of_float,
     caml_int64_bits_of_float: caml_int64_bits_of_float,
     jsoo_floor_log2: jsoo_floor_log2,
     caml_string_hash: caml_string_hash,
     caml_hash: caml_hash,
     caml_hash_mix_string: caml_hash_mix_string,
     caml_hash_mix_bytes: caml_hash_mix_bytes,
     caml_hash_mix_bytes_arr: caml_hash_mix_bytes_arr,
     caml_hash_mix_jsbytes: caml_hash_mix_jsbytes,
     caml_hash_mix_int64: caml_hash_mix_int64,
     caml_hash_mix_float: caml_hash_mix_float,
     caml_hash_mix_final: caml_hash_mix_final,
     caml_hash_mix_int: caml_hash_mix_int,
     caml_gr_close_subwindow: caml_gr_close_subwindow,
     caml_gr_open_subwindow: caml_gr_open_subwindow,
     caml_gr_window_id: caml_gr_window_id,
     caml_gr_display_mode: caml_gr_display_mode,
     caml_gr_remember_mode: caml_gr_remember_mode,
     caml_gr_synchronize: caml_gr_synchronize,
     caml_gr_wait_event: caml_gr_wait_event,
     caml_gr_sigio_signal: caml_gr_sigio_signal,
     caml_gr_sigio_handler: caml_gr_sigio_handler,
     caml_gr_blit_image: caml_gr_blit_image,
     caml_gr_create_image: caml_gr_create_image,
     caml_gr_draw_image: caml_gr_draw_image,
     caml_gr_dump_image: caml_gr_dump_image,
     caml_gr_make_image: caml_gr_make_image,
     caml_gr_text_size: caml_gr_text_size,
     caml_gr_set_text_size: caml_gr_set_text_size,
     caml_gr_set_font: caml_gr_set_font,
     caml_gr_draw_string: caml_gr_draw_string,
     caml_gr_draw_char: caml_gr_draw_char,
     caml_gr_draw_str: caml_gr_draw_str,
     caml_gr_fill_arc: caml_gr_fill_arc,
     caml_gr_fill_poly: caml_gr_fill_poly,
     caml_gr_fill_rect: caml_gr_fill_rect,
     caml_gr_set_line_width: caml_gr_set_line_width,
     caml_gr_draw_arc: caml_gr_draw_arc,
     caml_gr_arc_aux: caml_gr_arc_aux,
     caml_gr_draw_rect: caml_gr_draw_rect,
     caml_gr_lineto: caml_gr_lineto,
     caml_gr_current_y: caml_gr_current_y,
     caml_gr_current_x: caml_gr_current_x,
     caml_gr_moveto: caml_gr_moveto,
     caml_gr_point_color: caml_gr_point_color,
     caml_gr_plot: caml_gr_plot,
     caml_gr_set_color: caml_gr_set_color,
     caml_gr_size_y: caml_gr_size_y,
     caml_gr_size_x: caml_gr_size_x,
     caml_gr_clear_graph: caml_gr_clear_graph,
     caml_gr_resize_window: caml_gr_resize_window,
     caml_gr_set_window_title: caml_gr_set_window_title,
     caml_gr_close_graph: caml_gr_close_graph,
     caml_gr_doc_of_state: caml_gr_doc_of_state,
     caml_gr_state_create: caml_gr_state_create,
     caml_gr_state_init: caml_gr_state_init,
     caml_gr_open_graph: caml_gr_open_graph,
     caml_gr_state_set: caml_gr_state_set,
     caml_gr_state_get: caml_gr_state_get,
     caml_gr_state: caml_gr_state,
     caml_get_major_credit: caml_get_major_credit,
     caml_get_major_bucket: caml_get_major_bucket,
     caml_get_minor_free: caml_get_minor_free,
     caml_gc_minor_words: caml_gc_minor_words,
     caml_gc_major_slice: caml_gc_major_slice,
     caml_gc_huge_fallback_count: caml_gc_huge_fallback_count,
     caml_eventlog_pause: caml_eventlog_pause,
     caml_eventlog_resume: caml_eventlog_resume,
     caml_memprof_discard: caml_memprof_discard,
     caml_memprof_stop: caml_memprof_stop,
     caml_memprof_start: caml_memprof_start,
     caml_final_release: caml_final_release,
     caml_final_register_called_without_value:
     caml_final_register_called_without_value,
     caml_final_register: caml_final_register,
     caml_memprof_set: caml_memprof_set,
     caml_gc_get: caml_gc_get,
     caml_gc_set: caml_gc_set,
     caml_gc_stat: caml_gc_stat,
     caml_gc_quick_stat: caml_gc_quick_stat,
     caml_gc_counters: caml_gc_counters,
     caml_gc_compaction: caml_gc_compaction,
     caml_gc_full_major: caml_gc_full_major,
     caml_gc_major: caml_gc_major,
     caml_gc_minor: caml_gc_minor,
     caml_sys_open_for_node: caml_sys_open_for_node,
     MlNodeFd: MlNodeFd,
     MlNodeDevice: MlNodeDevice,
     fs_node_supported: fs_node_supported,
     MlFakeFd: MlFakeFd,
     MlFakeFd_out: MlFakeFd_out,
     MlFakeFile: MlFakeFile,
     MlFakeDevice: MlFakeDevice,
     caml_read_file_content: caml_read_file_content,
     jsoo_create_file: jsoo_create_file,
     caml_create_file: caml_create_file,
     caml_fs_init: caml_fs_init,
     jsoo_create_file_extern: jsoo_create_file_extern,
     caml_ba_map_file_bytecode: caml_ba_map_file_bytecode,
     caml_ba_map_file: caml_ba_map_file,
     caml_sys_rmdir: caml_sys_rmdir,
     caml_sys_mkdir: caml_sys_mkdir,
     caml_sys_rename: caml_sys_rename,
     caml_sys_is_directory: caml_sys_is_directory,
     caml_sys_remove: caml_sys_remove,
     caml_sys_read_directory: caml_sys_read_directory,
     caml_sys_file_exists: caml_sys_file_exists,
     caml_raise_not_a_dir: caml_raise_not_a_dir,
     caml_raise_no_such_file: caml_raise_no_such_file,
     caml_sys_chdir: caml_sys_chdir,
     caml_sys_getcwd: caml_sys_getcwd,
     caml_unmount: caml_unmount,
     caml_mount_autoload: caml_mount_autoload,
     resolve_fs_device: resolve_fs_device,
     caml_list_mount_point: caml_list_mount_point,
     jsoo_mount_point: jsoo_mount_point,
     caml_make_path: caml_make_path,
     path_is_absolute: path_is_absolute,
     MlFile: MlFile,
     caml_root: caml_root,
     caml_get_root: caml_get_root,
     caml_current_dir: caml_current_dir,
     caml_trailing_slash: caml_trailing_slash,
     caml_finish_formatting: caml_finish_formatting,
     caml_parse_format: caml_parse_format,
     caml_array_bound_error: caml_array_bound_error,
     caml_raise_not_found: caml_raise_not_found,
     caml_raise_zero_divide: caml_raise_zero_divide,
     caml_raise_end_of_file: caml_raise_end_of_file,
     caml_invalid_argument: caml_invalid_argument,
     caml_failwith: caml_failwith,
     caml_raise_with_string: caml_raise_with_string,
     caml_raise_with_args: caml_raise_with_args,
     caml_raise_with_arg: caml_raise_with_arg,
     caml_raise_constant: caml_raise_constant,
     caml_lessthan: caml_lessthan,
     caml_lessequal: caml_lessequal,
     caml_greaterthan: caml_greaterthan,
     caml_greaterequal: caml_greaterequal,
     caml_notequal: caml_notequal,
     caml_equal: caml_equal,
     caml_int_compare: caml_int_compare,
     caml_compare: caml_compare,
     caml_compare_val: caml_compare_val,
     caml_compare_val_number_custom: caml_compare_val_number_custom,
     caml_compare_val_get_custom: caml_compare_val_get_custom,
     caml_compare_val_tag: caml_compare_val_tag,
     caml_bigstring_blit_ba_to_bytes: caml_bigstring_blit_ba_to_bytes,
     caml_bigstring_blit_bytes_to_ba: caml_bigstring_blit_bytes_to_ba,
     caml_bigstring_blit_string_to_ba: caml_bigstring_blit_string_to_ba,
     caml_bigstring_blit_ba_to_ba: caml_bigstring_blit_ba_to_ba,
     caml_bigstring_memcmp: caml_bigstring_memcmp,
     bigstring_of_typed_array: bigstring_of_typed_array,
     bigstring_of_array_buffer: bigstring_of_array_buffer,
     bigstring_to_typed_array: bigstring_to_typed_array,
     bigstring_to_array_buffer: bigstring_to_array_buffer,
     caml_hash_mix_bigstring: caml_hash_mix_bigstring,
     caml_ba_from_typed_array: caml_ba_from_typed_array,
     caml_ba_kind_of_typed_array: caml_ba_kind_of_typed_array,
     caml_ba_to_typed_array: caml_ba_to_typed_array,
     caml_ba_hash: caml_ba_hash,
     caml_ba_create_from: caml_ba_create_from,
     caml_ba_deserialize: caml_ba_deserialize,
     caml_ba_serialize: caml_ba_serialize,
     caml_ba_reshape: caml_ba_reshape,
     caml_ba_slice: caml_ba_slice,
     caml_ba_sub: caml_ba_sub,
     caml_ba_blit: caml_ba_blit,
     caml_ba_fill: caml_ba_fill,
     caml_ba_set_3: caml_ba_set_3,
     caml_ba_set_2: caml_ba_set_2,
     caml_ba_set_1: caml_ba_set_1,
     caml_ba_uint8_set64: caml_ba_uint8_set64,
     caml_ba_uint8_set32: caml_ba_uint8_set32,
     caml_ba_uint8_set16: caml_ba_uint8_set16,
     caml_ba_set_generic: caml_ba_set_generic,
     caml_ba_get_3: caml_ba_get_3,
     caml_ba_get_2: caml_ba_get_2,
     caml_ba_get_1: caml_ba_get_1,
     caml_ba_uint8_get64: caml_ba_uint8_get64,
     caml_ba_uint8_get32: caml_ba_uint8_get32,
     caml_ba_uint8_get16: caml_ba_uint8_get16,
     caml_ba_get_generic: caml_ba_get_generic,
     caml_ba_dim_3: caml_ba_dim_3,
     caml_ba_dim_2: caml_ba_dim_2,
     caml_ba_dim_1: caml_ba_dim_1,
     caml_ba_dim: caml_ba_dim,
     caml_ba_num_dims: caml_ba_num_dims,
     caml_ba_layout: caml_ba_layout,
     caml_ba_kind: caml_ba_kind,
     caml_ba_change_layout: caml_ba_change_layout,
     caml_ba_create: caml_ba_create,
     caml_ba_create_unsafe: caml_ba_create_unsafe,
     caml_ba_compare: caml_ba_compare,
     Ml_Bigarray_c_1_1: Ml_Bigarray_c_1_1,
     Ml_Bigarray: Ml_Bigarray,
     caml_ba_custom_name: caml_ba_custom_name,
     caml_ba_create_buffer: caml_ba_create_buffer,
     caml_ba_get_size_per_element: caml_ba_get_size_per_element,
     caml_ba_get_size: caml_ba_get_size,
     caml_ba_init: caml_ba_init,
     caml_convert_raw_backtrace_slot: caml_convert_raw_backtrace_slot,
     caml_get_current_callstack: caml_get_current_callstack,
     caml_restore_raw_backtrace: caml_restore_raw_backtrace,
     caml_raw_backtrace_slot: caml_raw_backtrace_slot,
     caml_raw_backtrace_next_slot: caml_raw_backtrace_next_slot,
     caml_raw_backtrace_length: caml_raw_backtrace_length,
     caml_convert_raw_backtrace: caml_convert_raw_backtrace,
     caml_record_backtrace: caml_record_backtrace,
     caml_get_exception_raw_backtrace: caml_get_exception_raw_backtrace,
     caml_get_exception_backtrace: caml_get_exception_backtrace,
     caml_backtrace_status: caml_backtrace_status,
     caml_ml_debug_info_status: caml_ml_debug_info_status,
     caml_record_backtrace_flag: caml_record_backtrace_flag,
     caml_floatarray_create: caml_floatarray_create,
     caml_make_float_vect: caml_make_float_vect,
     caml_make_vect: caml_make_vect,
     caml_check_bound: caml_check_bound,
     caml_array_fill: caml_array_fill,
     caml_array_get: caml_array_get,
     caml_array_set: caml_array_set,
     caml_floatarray_blit: caml_floatarray_blit,
     caml_array_blit: caml_array_blit,
     caml_array_concat: caml_array_concat,
     caml_array_append: caml_array_append,
     caml_array_sub: caml_array_sub};
   var
    cst_Assert_failure = "Assert_failure",
    cst_Division_by_zero = "Division_by_zero",
    cst_End_of_file = "End_of_file",
    cst_Failure = "Failure",
    cst_Invalid_argument = "Invalid_argument",
    cst_Match_failure = "Match_failure",
    cst_Not_found = "Not_found",
    cst_Out_of_memory = "Out_of_memory",
    cst_Stack_overflow = "Stack_overflow",
    cst_Sys_blocked_io = "Sys_blocked_io",
    cst_Sys_error = "Sys_error",
    cst_Undefined_recursive_module = "Undefined_recursive_module";
   caml_fs_init();
   caml_register_global(0, [248, cst_Out_of_memory, -1], cst_Out_of_memory);
   caml_register_global(1, [248, cst_Sys_error, -2], cst_Sys_error);
   caml_register_global(2, [248, cst_Failure, -3], cst_Failure);
   caml_register_global
    (3, [248, cst_Invalid_argument, -4], cst_Invalid_argument);
   caml_register_global(4, [248, cst_End_of_file, -5], cst_End_of_file);
   caml_register_global
    (5, [248, cst_Division_by_zero, -6], cst_Division_by_zero);
   caml_register_global(6, [248, cst_Not_found, -7], cst_Not_found);
   caml_register_global(7, [248, cst_Match_failure, -8], cst_Match_failure);
   caml_register_global(8, [248, cst_Stack_overflow, -9], cst_Stack_overflow);
   caml_register_global(9, [248, cst_Sys_blocked_io, -10], cst_Sys_blocked_io);
   caml_register_global
    (10, [248, cst_Assert_failure, -11], cst_Assert_failure);
   caml_register_global
    (11,
     [248, cst_Undefined_recursive_module, -12],
     cst_Undefined_recursive_module);
   return;
  }
  (globalThis));


(function(a){"use strict";var
s="Sys_error",ao="Stdlib__Obj",ap="Stdlib__Unit",ay="Stdlib__Nativeint",l="Stdlib__Gc",ax="Stdlib__Stack",r="CamlinternalFormat",R="Stdlib__Genlex",av="Stdlib__Random",q="Stdlib__Pervasives",A="Stack_overflow",ab="Stdlib__ArrayLabels",ae="Stdlib__Either",aj="Stdlib__Printexc",w="Stdlib__Map",z="Stdlib__Arg",Q="Undefined_recursive_module",au="Stdlib__Array",F="Assert_failure",P="CamlinternalFormatBasics",k="Stdlib__Lazy",O="Stdlib__Queue",v="Stdlib__Format",V="Stdlib__In_channel",f="Stdlib__Bool",E="Stdlib__BytesLabels",aF="Stdlib__Bytes",ah="Division_by_zero",ai="Unix",u="End_of_file",N="CamlinternalMod",D="Stdlib__Marshal",aa="React",aE="Out_of_memory",M="Stdlib__Parsing",ag="Stdlib__Weak",ad="Not_found",aD="Failure",e="Stdlib__Int",p="Stdlib__StdLabels",d="Stdlib__Oo",K="Stdlib__Bigarray",L="Stdlib__List",$="Stdlib__Ephemeron",at="Stdlib__String",aC="Stdlib__Printf",U="Stdlib",as="Bigarray",an="Stdlib__Callback",T="Stdlib__Filename",am="Stdlib__Hashtbl",j="Invalid_argument",_="Stdlib__Fun",t="Stdlib__Option",y="Stdlib__Lexing",aB="Stdlib__ListLabels",al="CamlinternalAtomic",aw="Stdlib__Atomic",ak="Stdlib__MoreLabels",Z="Stdlib__Result",i="Std_exit",J="Stdlib__Set",X="OcamlCanvas",Y="Stdlib__Buffer",af="Dune__exe__Demo2",aA="Match_failure",h="Stdlib__StringLabels",ar="Stdlib__Complex",S="Stdlib__Int64",W="Stdlib__Out_channel",o="Stdlib__Seq",I="UnixLabels",aq="Stdlib__Sys",ac="CamlinternalLazy",H="Sys_blocked_io",x="Stdlib__Float",G="Stdlib__Uchar",g="Stdlib__Scanf",n="CamlinternalOO",az="Stdlib__Digest",m="Stdlib__Stream",C="Stdlib__Char",B="Stdlib__Int32",c=a.jsoo_runtime,b=c.caml_get_global_data();b.prim_count=902;b.symbols=[0,[0,I,77],[0,ai,76],[0,Q,11],[0,s,10],[0,H,9],[0,ag,56],[0,ap,31],[0,G,26],[0,aq,17],[0,h,70],[0,at,30],[0,m,44],[0,p,72],[0,ax,42],[0,J,40],[0,o,21],[0,g,58],[0,Z,23],[0,av,54],[0,O,43],[0,aC,47],[0,aj,50],[0,q,15],[0,M,39],[0,W,75],[0,t,22],[0,d,61],[0,ao,18],[0,ay,37],[0,ak,71],[0,D,32],[0,w,41],[0,aB,68],[0,L,27],[0,y,38],[0,k,20],[0,S,36],[0,B,35],[0,e,28],[0,V,74],[0,am,55],[0,R,63],[0,l,52],[0,_,51],[0,v,57],[0,x,34],[0,T,65],[0,$,64],[0,ae,16],[0,az,53],[0,ar,66],[0,C,25],[0,an,59],[0,E,69],[0,aF,29],[0,Y,45],[0,f,24],[0,K,73],[0,aw,49],[0,ab,67],[0,au,33],[0,z,48],[0,U,14],[0,i,82],[0,A,8],[0,aa,79],[0,aE,7],[0,X,80],[0,ad,6],[0,aA,5],[0,j,4],[0,aD,3],[0,u,2],[0,af,81],[0,ah,1],[0,n,60],[0,N,62],[0,ac,19],[0,P,12],[0,r,46],[0,al,13],[0,as,78],[0,F,0]];b.sections=[0,[0,83,[0,[0,[0,[0,[0,0,[2,F],0,[0,0,[2,as],78,0,1],2],[2,al],13,[0,0,[2,r],46,0,1],3],[2,P],12,[0,[0,0,[2,ac],19,[0,[0,0,[2,N],62,0,1],[2,n],60,0,2],3],[2,ah],1,[0,[0,0,[2,af],81,0,1],[2,u],2,0,2],4],5],[2,aD],3,[0,[0,[0,[0,0,[2,j],4,0,1],[2,aA],5,[0,0,[2,ad],6,[0,0,[2,X],80,0,1],2],3],[2,aE],7,[0,[0,0,[2,aa],79,0,1],[2,A],8,[0,0,[2,i],82,0,1],2],4],[2,U],14,[0,[0,[0,0,[2,z],48,0,1],[2,au],33,[0,[0,0,[2,ab],67,0,1],[2,aw],49,[0,0,[2,K],73,0,1],2],3],[2,f],24,[0,[0,[0,0,[2,Y],45,0,1],[2,aF],29,[0,[0,0,[2,E],69,0,1],[2,an],59,0,2],3],[2,C],25,[0,[0,0,[2,ar],66,0,1],[2,az],53,0,2],4],5],6],7],[2,ae],16,[0,[0,[0,[0,[0,[0,0,[2,$],64,[0,0,[2,T],65,0,1],2],[2,x],34,[0,0,[2,v],57,0,1],3],[2,_],51,[0,0,[2,l],52,[0,[0,0,[2,R],63,0,1],[2,am],55,[0,0,[2,V],74,0,1],2],3],4],[2,e],28,[0,0,[2,B],35,[0,0,[2,S],36,0,1],2],5],[2,k],20,[0,[0,[0,0,[2,y],38,0,1],[2,L],27,[0,[0,[0,0,[2,aB],68,0,1],[2,w],41,0,2],[2,D],32,[0,[0,0,[2,ak],71,0,1],[2,ay],37,0,2],3],4],[2,ao],18,[0,[0,0,[2,d],61,0,1],[2,t],22,[0,[0,0,[2,W],75,0,1],[2,M],39,0,2],3],5],6],[2,q],15,[0,[0,[0,[0,[0,0,[2,aj],50,0,1],[2,aC],47,0,2],[2,O],43,[0,[0,0,[2,av],54,0,1],[2,Z],23,[0,0,[2,g],58,0,1],2],3],[2,o],21,[0,[0,0,[2,J],40,0,1],[2,ax],42,[0,[0,[0,0,[2,p],72,0,1],[2,m],44,0,2],[2,at],30,[0,0,[2,h],70,0,1],3],4],5],[2,aq],17,[0,[0,0,[2,G],26,[0,0,[2,ap],31,[0,0,[2,ag],56,0,1],2],3],[2,H],9,[0,[0,0,[2,s],10,0,1],[2,Q],11,[0,0,[2,ai],76,[0,0,[2,I],77,0,1],2],3],4],6],7],8]],0,c.caml_list_of_js_array(["BUTTON","BUTTON_STATE","BUTTON_STATE_TAG","BUTTON_TAG","BigStringReader","CAP_TYPE_TAG","COMPOP_TAG","Cap_type_val","Compop_val","Draw_style_val","EVENT_TAG","FOCUS","FOCUS_TAG","JOIN_TYPE_TAG","Join_type_val","KEY","KEY_STATE","KEY_STATE_TAG","KEY_TAG","Key_code_val","MlBytes","MlFakeDevice","MlFakeFd","MlFakeFd_out","MlFakeFile","MlFile","MlInt64","MlMutex","MlNat","MlNodeDevice","MlNodeFd","MlObjectTable","MlStringReader","Ml_Bigarray","Ml_Bigarray_c_1_1","Optional_bool_val","Optional_val","REPEAT_TAG","Repeat_val","SLANT","SLANT_TAG","STYLE_TAG","Slant_val","UInt8ArrayReader","Val_button","Val_button_state","Val_cap_type","Val_compop","Val_draw_style","Val_focus_in_out","Val_join_type","Val_key_code","Val_key_state","Val_repeat","_color_of_int","_event_canvas_scale","_focus","_frame_handler","_header_down_handler","_int_of_color","_internal_canvas","_internal_ctxt","_key_down_handler","_key_up_handler","_make_key_event","_ml_canvas_adjust_blit_info","_ml_canvas_ba_of_img","_ml_canvas_decorate","_ml_canvas_ensure_initialized","_ml_canvas_image_of_png_file","_ml_canvas_initialized","_ml_canvas_mlContinuation","_ml_canvas_mlException","_ml_canvas_mlProcessEvent","_ml_canvas_process_event","_ml_canvas_surface_of_ba","_ml_canvas_valid_canvas_size","_move","_move_handler","_next_id","_resize","_resize_handler","_surface_down_handler","_up_handler","add_nat","bigstring_of_array_buffer","bigstring_of_typed_array","bigstring_to_array_buffer","bigstring_to_typed_array","blit_nat","caml_MD5Final","caml_MD5Init","caml_MD5Transform","caml_MD5Update","caml_acosh_float","caml_alloc_dummy_infix","caml_alloc_stack","caml_argv","caml_array_append","caml_array_blit","caml_array_bound_error","caml_array_concat","caml_array_fill","caml_array_get","caml_array_of_bytes","caml_array_of_string","caml_array_set","caml_array_sub","caml_asinh_float","caml_atanh_float","caml_atomic_cas","caml_atomic_exchange","caml_atomic_fetch_add","caml_atomic_load","caml_atomic_make_contended","caml_ba_blit","caml_ba_change_layout","caml_ba_compare","caml_ba_create","caml_ba_create_buffer","caml_ba_create_from","caml_ba_create_unsafe","caml_ba_custom_name","caml_ba_deserialize","caml_ba_dim","caml_ba_dim_1","caml_ba_dim_2","caml_ba_dim_3","caml_ba_fill","caml_ba_from_typed_array","caml_ba_get_1","caml_ba_get_2","caml_ba_get_3","caml_ba_get_generic","caml_ba_get_size","caml_ba_get_size_per_element","caml_ba_hash","caml_ba_init","caml_ba_kind","caml_ba_kind_of_typed_array","caml_ba_layout","caml_ba_map_file","caml_ba_map_file_bytecode","caml_ba_num_dims","caml_ba_reshape","caml_ba_serialize","caml_ba_set_1","caml_ba_set_2","caml_ba_set_3","caml_ba_set_generic","caml_ba_slice","caml_ba_sub","caml_ba_to_typed_array","caml_ba_uint8_get16","caml_ba_uint8_get32","caml_ba_uint8_get64","caml_ba_uint8_set16","caml_ba_uint8_set32","caml_ba_uint8_set64","caml_backtrace_status","caml_bigstring_blit_ba_to_ba","caml_bigstring_blit_ba_to_bytes","caml_bigstring_blit_bytes_to_ba","caml_bigstring_blit_string_to_ba","caml_bigstring_memcmp","caml_blit_bytes","caml_blit_string","caml_bswap16","caml_build_symbols","caml_bytes_bound_error","caml_bytes_compare","caml_bytes_equal","caml_bytes_get","caml_bytes_get16","caml_bytes_get32","caml_bytes_get64","caml_bytes_greaterequal","caml_bytes_greaterthan","caml_bytes_lessequal","caml_bytes_lessthan","caml_bytes_notequal","caml_bytes_of_array","caml_bytes_of_jsbytes","caml_bytes_of_string","caml_bytes_of_utf16_jsstring","caml_bytes_set","caml_bytes_set16","caml_bytes_set32","caml_bytes_set64","caml_bytes_unsafe_get","caml_bytes_unsafe_set","caml_call_gen","caml_callback","caml_cbrt_float","caml_channel_descriptor","caml_check_bound","caml_classify_float","caml_compare","caml_compare_val","caml_compare_val_get_custom","caml_compare_val_number_custom","caml_compare_val_tag","caml_continuation_use_and_update_handler_noexc","caml_continuation_use_noexc","caml_convert_bytes_to_array","caml_convert_raw_backtrace","caml_convert_raw_backtrace_slot","caml_convert_string_to_bytes","caml_copysign_float","caml_cosh_float","caml_create_bytes","caml_create_file","caml_create_string","caml_current_dir","caml_custom_event_index","caml_custom_ops","caml_decompress_input","caml_div","caml_domain_dls","caml_domain_dls_get","caml_domain_dls_set","caml_domain_id","caml_domain_spawn","caml_ephe_blit_data","caml_ephe_blit_key","caml_ephe_check_data","caml_ephe_check_key","caml_ephe_create","caml_ephe_data_offset","caml_ephe_get_data","caml_ephe_get_data_copy","caml_ephe_get_key","caml_ephe_get_key_copy","caml_ephe_key_offset","caml_ephe_set_data","caml_ephe_set_key","caml_ephe_unset_data","caml_ephe_unset_key","caml_equal","caml_erf_float","caml_erfc_float","caml_eventlog_pause","caml_eventlog_resume","caml_executable_name","caml_exn_with_js_backtrace","caml_exp2_float","caml_expm1_float","caml_failwith","caml_fatal_uncaught_exception","caml_fill_bytes","caml_final_register","caml_final_register_called_without_value","caml_final_release","caml_finish_formatting","caml_float_compare","caml_float_of_bytes","caml_float_of_string","caml_floatarray_blit","caml_floatarray_create","caml_fma_float","caml_format_exception","caml_format_float","caml_format_int","caml_fresh_oo_id","caml_frexp_float","caml_fs_init","caml_gc_compaction","caml_gc_counters","caml_gc_full_major","caml_gc_get","caml_gc_huge_fallback_count","caml_gc_major","caml_gc_major_slice","caml_gc_minor","caml_gc_minor_words","caml_gc_quick_stat","caml_gc_set","caml_gc_stat","caml_get_continuation_callstack","caml_get_current_callstack","caml_get_exception_backtrace","caml_get_exception_raw_backtrace","caml_get_global_data","caml_get_major_bucket","caml_get_major_credit","caml_get_minor_free","caml_get_public_method","caml_get_root","caml_global_data","caml_gr_arc_aux","caml_gr_blit_image","caml_gr_clear_graph","caml_gr_close_graph","caml_gr_close_subwindow","caml_gr_create_image","caml_gr_current_x","caml_gr_current_y","caml_gr_display_mode","caml_gr_doc_of_state","caml_gr_draw_arc","caml_gr_draw_char","caml_gr_draw_image","caml_gr_draw_rect","caml_gr_draw_str","caml_gr_draw_string","caml_gr_dump_image","caml_gr_fill_arc","caml_gr_fill_poly","caml_gr_fill_rect","caml_gr_lineto","caml_gr_make_image","caml_gr_moveto","caml_gr_open_graph","caml_gr_open_subwindow","caml_gr_plot","caml_gr_point_color","caml_gr_remember_mode","caml_gr_resize_window","caml_gr_set_color","caml_gr_set_font","caml_gr_set_line_width","caml_gr_set_text_size","caml_gr_set_window_title","caml_gr_sigio_handler","caml_gr_sigio_signal","caml_gr_size_x","caml_gr_size_y","caml_gr_state","caml_gr_state_create","caml_gr_state_get","caml_gr_state_init","caml_gr_state_set","caml_gr_synchronize","caml_gr_text_size","caml_gr_wait_event","caml_gr_window_id","caml_greaterequal","caml_greaterthan","caml_hash","caml_hash_mix_bigstring","caml_hash_mix_bytes","caml_hash_mix_bytes_arr","caml_hash_mix_final","caml_hash_mix_float","caml_hash_mix_int","caml_hash_mix_int64","caml_hash_mix_jsbytes","caml_hash_mix_string","caml_hash_nat","caml_hexstring_of_float","caml_hypot_float","caml_input_value","caml_input_value_from_bytes","caml_input_value_from_reader","caml_input_value_from_string","caml_input_value_to_outside_heap","caml_install_signal_handler","caml_int32_bits_of_float","caml_int32_bswap","caml_int32_float_of_bits","caml_int32_unmarshal","caml_int64_add","caml_int64_and","caml_int64_bits_of_float","caml_int64_bswap","caml_int64_compare","caml_int64_create_lo_hi","caml_int64_create_lo_mi_hi","caml_int64_div","caml_int64_float_of_bits","caml_int64_format","caml_int64_hash","caml_int64_hi32","caml_int64_is_negative","caml_int64_is_zero","caml_int64_lo32","caml_int64_marshal","caml_int64_mod","caml_int64_mul","caml_int64_neg","caml_int64_of_bytes","caml_int64_of_float","caml_int64_of_int32","caml_int64_of_string","caml_int64_offset","caml_int64_or","caml_int64_shift_left","caml_int64_shift_right","caml_int64_shift_right_unsigned","caml_int64_sub","caml_int64_to_bytes","caml_int64_to_float","caml_int64_to_int32","caml_int64_ult","caml_int64_unmarshal","caml_int64_xor","caml_int_compare","caml_int_of_string","caml_invalid_argument","caml_is_continuation_tag","caml_is_js","caml_is_ml_bytes","caml_is_ml_string","caml_is_printable","caml_is_special_exception","caml_js_call","caml_js_delete","caml_js_equals","caml_js_error_of_exception","caml_js_error_option_of_exception","caml_js_eval_string","caml_js_expr","caml_js_from_array","caml_js_from_bool","caml_js_from_float","caml_js_from_string","caml_js_fun_call","caml_js_function_arity","caml_js_get","caml_js_get_console","caml_js_html_entities","caml_js_html_escape","caml_js_instanceof","caml_js_meth_call","caml_js_new","caml_js_object","caml_js_on_ie","caml_js_pure_expr","caml_js_set","caml_js_strict_equals","caml_js_to_array","caml_js_to_bool","caml_js_to_byte_string","caml_js_to_float","caml_js_to_int32","caml_js_to_string","caml_js_typeof","caml_js_var","caml_js_wrap_callback","caml_js_wrap_callback_arguments","caml_js_wrap_callback_strict","caml_js_wrap_callback_unsafe","caml_js_wrap_meth_callback","caml_js_wrap_meth_callback_arguments","caml_js_wrap_meth_callback_strict","caml_js_wrap_meth_callback_unsafe","caml_jsbytes_of_string","caml_jsoo_flags_effects","caml_jsoo_flags_use_js_string","caml_jsstring_of_string","caml_lazy_make_forward","caml_lazy_read_result","caml_lazy_reset_to_lazy","caml_lazy_update_to_forcing","caml_lazy_update_to_forward","caml_ldexp_float","caml_lessequal","caml_lessthan","caml_lex_array","caml_lex_engine","caml_list_mount_point","caml_list_of_js_array","caml_list_to_js_array","caml_log10_float","caml_log1p_float","caml_log2_float","caml_lxm_next","caml_make_float_vect","caml_make_path","caml_make_vect","caml_marshal_constants","caml_marshal_data_size","caml_marshal_header_size","caml_maybe_attach_backtrace","caml_maybe_print_stats","caml_md5_bytes","caml_md5_chan","caml_md5_string","caml_memprof_discard","caml_memprof_set","caml_memprof_start","caml_memprof_stop","caml_ml_bytes_content","caml_ml_bytes_length","caml_ml_channel_get","caml_ml_channel_redirect","caml_ml_channel_restore","caml_ml_channel_size","caml_ml_channel_size_64","caml_ml_channels","caml_ml_close_channel","caml_ml_condition_broadcast","caml_ml_condition_new","caml_ml_condition_signal","caml_ml_condition_wait","caml_ml_debug_info_status","caml_ml_domain_cpu_relax","caml_ml_domain_id","caml_ml_domain_set_name","caml_ml_domain_unique_token","caml_ml_enable_runtime_warnings","caml_ml_flush","caml_ml_input","caml_ml_input_bigarray","caml_ml_input_block","caml_ml_input_char","caml_ml_input_int","caml_ml_input_scan_line","caml_ml_is_buffered","caml_ml_mutex_lock","caml_ml_mutex_new","caml_ml_mutex_try_lock","caml_ml_mutex_unlock","caml_ml_open_descriptor_in","caml_ml_open_descriptor_out","caml_ml_out_channels_list","caml_ml_output","caml_ml_output_bigarray","caml_ml_output_bytes","caml_ml_output_char","caml_ml_output_int","caml_ml_output_ta","caml_ml_pos_in","caml_ml_pos_in_64","caml_ml_pos_out","caml_ml_pos_out_64","caml_ml_runtime_events_pause","caml_ml_runtime_events_resume","caml_ml_runtime_events_start","caml_ml_runtime_warnings_enabled","caml_ml_seek_in","caml_ml_seek_in_64","caml_ml_seek_out","caml_ml_seek_out_64","caml_ml_set_binary_mode","caml_ml_set_buffered","caml_ml_set_channel_name","caml_ml_set_channel_output","caml_ml_set_channel_refill","caml_ml_string_length","caml_mod","caml_modf_float","caml_mount_autoload","caml_mul","caml_named_value","caml_named_values","caml_nativeint_unmarshal","caml_new_lex_engine","caml_new_string","caml_nextafter_float","caml_notequal","caml_obj_add_offset","caml_obj_block","caml_obj_compare_and_swap","caml_obj_dup","caml_obj_is_block","caml_obj_is_shared","caml_obj_make_forward","caml_obj_raw_field","caml_obj_reachable_words","caml_obj_set_raw_field","caml_obj_set_tag","caml_obj_tag","caml_obj_truncate","caml_obj_update_tag","caml_obj_with_tag","caml_ojs_new_arr","caml_oo_last_id","caml_output_val","caml_output_value","caml_output_value_to_buffer","caml_output_value_to_bytes","caml_output_value_to_string","caml_parse_digit","caml_parse_engine","caml_parse_format","caml_parse_sign_and_base","caml_parser_trace","caml_pos_in","caml_pos_out","caml_pure_js_expr","caml_raise_constant","caml_raise_end_of_file","caml_raise_no_such_file","caml_raise_not_a_dir","caml_raise_not_found","caml_raise_sys_error","caml_raise_with_arg","caml_raise_with_args","caml_raise_with_string","caml_raise_zero_divide","caml_raw_backtrace_length","caml_raw_backtrace_next_slot","caml_raw_backtrace_slot","caml_read_file_content","caml_recommended_domain_count","caml_record_backtrace","caml_record_backtrace_flag","caml_refill","caml_register_channel_for_spacetime","caml_register_global","caml_register_named_value","caml_restore_raw_backtrace","caml_root","caml_round_float","caml_runtime_events_create_cursor","caml_runtime_events_free_cursor","caml_runtime_events_read_poll","caml_runtime_events_user_register","caml_runtime_events_user_resolve","caml_runtime_events_user_write","caml_runtime_parameters","caml_runtime_variant","caml_runtime_warnings","caml_seek_in","caml_seek_out","caml_set_oo_id","caml_set_parser_trace","caml_set_static_env","caml_signbit_float","caml_sinh_float","caml_spacetime_enabled","caml_spacetime_only_works_for_native_code","caml_str_initialize","caml_str_repeat","caml_string_bound_error","caml_string_compare","caml_string_concat","caml_string_equal","caml_string_get","caml_string_get16","caml_string_get32","caml_string_get64","caml_string_greaterequal","caml_string_greaterthan","caml_string_hash","caml_string_lessequal","caml_string_lessthan","caml_string_notequal","caml_string_of_array","caml_string_of_bytes","caml_string_of_jsbytes","caml_string_of_jsstring","caml_string_set","caml_string_set16","caml_string_set32","caml_string_set64","caml_string_unsafe_get","caml_string_unsafe_set","caml_subarray_to_jsbytes","caml_sys_argv","caml_sys_chdir","caml_sys_close","caml_sys_const_backend_type","caml_sys_const_big_endian","caml_sys_const_int_size","caml_sys_const_max_wosize","caml_sys_const_naked_pointers_checked","caml_sys_const_ostype_cygwin","caml_sys_const_ostype_unix","caml_sys_const_ostype_win32","caml_sys_const_word_size","caml_sys_executable_name","caml_sys_exit","caml_sys_fds","caml_sys_file_exists","caml_sys_get_argv","caml_sys_get_config","caml_sys_getcwd","caml_sys_getenv","caml_sys_is_directory","caml_sys_is_regular_file","caml_sys_isatty","caml_sys_mkdir","caml_sys_modify_argv","caml_sys_open","caml_sys_open_for_node","caml_sys_random_seed","caml_sys_read_directory","caml_sys_remove","caml_sys_rename","caml_sys_rmdir","caml_sys_system_command","caml_sys_time","caml_sys_time_include_children","caml_sys_unsafe_getenv","caml_tanh_float","caml_to_js_string","caml_trailing_slash","caml_trampoline","caml_trampoline_return","caml_trunc_float","caml_uint8_array_of_bytes","caml_uint8_array_of_string","caml_unix_cleanup","caml_unix_closedir","caml_unix_filedescr_of_fd","caml_unix_findclose","caml_unix_findfirst","caml_unix_findnext","caml_unix_getpwuid","caml_unix_gettimeofday","caml_unix_getuid","caml_unix_gmtime","caml_unix_has_symlink","caml_unix_inet_addr_of_string","caml_unix_isatty","caml_unix_localtime","caml_unix_lstat","caml_unix_lstat_64","caml_unix_mkdir","caml_unix_mktime","caml_unix_opendir","caml_unix_readdir","caml_unix_readlink","caml_unix_rewinddir","caml_unix_rmdir","caml_unix_startup","caml_unix_stat","caml_unix_stat_64","caml_unix_symlink","caml_unix_time","caml_unix_unlink","caml_unmount","caml_update_dummy","caml_utf16_of_utf8","caml_utf8_of_utf16","caml_weak_create","caml_weak_set","caml_wrap_exception","caml_xmlhttprequest_create","compare_digits_nat","compare_nat","compare_nat_real","complement_nat","create_nat","decr_nat","deserialize_nat","div_digit_nat","div_helper","div_nat","fs_node_supported","incr_nat","initialize_nat","is_digit_int","is_digit_odd","is_digit_zero","jsoo_create_file","jsoo_create_file_extern","jsoo_effect_not_supported","jsoo_floor_log2","jsoo_is_ascii","jsoo_mount_point","jsoo_sys_getenv","keyname_to_keycode","land_digit_nat","length_nat","lor_digit_nat","lxor_digit_nat","make_unix_err_args","ml_canvas_arc","ml_canvas_arc_to","ml_canvas_bezier_curve_to","ml_canvas_blit","ml_canvas_clear_path","ml_canvas_clip","ml_canvas_clip_path","ml_canvas_close","ml_canvas_close_path","ml_canvas_commit","ml_canvas_compare","ml_canvas_create_offscreen","ml_canvas_create_offscreen_from_image_data","ml_canvas_create_offscreen_from_png","ml_canvas_create_onscreen","ml_canvas_ellipse","ml_canvas_export_png","ml_canvas_fill","ml_canvas_fill_path","ml_canvas_fill_rect","ml_canvas_fill_text","ml_canvas_get_canvas","ml_canvas_get_current_timestamp","ml_canvas_get_fill_color","ml_canvas_get_fill_style","ml_canvas_get_global_alpha","ml_canvas_get_global_composite_operation","ml_canvas_get_id","ml_canvas_get_image_data","ml_canvas_get_line_cap","ml_canvas_get_line_dash","ml_canvas_get_line_dash_offset","ml_canvas_get_line_join","ml_canvas_get_line_width","ml_canvas_get_miter_limit","ml_canvas_get_pixel","ml_canvas_get_position","ml_canvas_get_shadow_blur","ml_canvas_get_shadow_color","ml_canvas_get_shadow_offset","ml_canvas_get_size","ml_canvas_get_stroke_color","ml_canvas_get_stroke_style","ml_canvas_gradient_add_color_stop","ml_canvas_gradient_create_conic","ml_canvas_gradient_create_linear","ml_canvas_gradient_create_radial","ml_canvas_hash","ml_canvas_hide","ml_canvas_image_data_blit","ml_canvas_image_data_create_from_png","ml_canvas_image_data_export_png","ml_canvas_image_data_fill","ml_canvas_image_data_get_pixel","ml_canvas_image_data_get_size","ml_canvas_image_data_import_png","ml_canvas_image_data_put_pixel","ml_canvas_image_data_sub","ml_canvas_import_png","ml_canvas_init","ml_canvas_int_of_key","ml_canvas_key_of_int","ml_canvas_line_to","ml_canvas_move_to","ml_canvas_path_add","ml_canvas_path_add_transformed","ml_canvas_path_arc","ml_canvas_path_arc_to","ml_canvas_path_bezier_curve_to","ml_canvas_path_close","ml_canvas_path_create","ml_canvas_path_ellipse","ml_canvas_path_line_to","ml_canvas_path_move_to","ml_canvas_path_quadratic_curve_to","ml_canvas_path_rect","ml_canvas_pattern_create","ml_canvas_put_image_data","ml_canvas_put_pixel","ml_canvas_quadratic_curve_to","ml_canvas_rect","ml_canvas_restore","ml_canvas_rotate","ml_canvas_run","ml_canvas_save","ml_canvas_scale","ml_canvas_set_fill_color","ml_canvas_set_fill_gradient","ml_canvas_set_fill_pattern","ml_canvas_set_fill_style","ml_canvas_set_font","ml_canvas_set_global_alpha","ml_canvas_set_global_composite_operation","ml_canvas_set_line_cap","ml_canvas_set_line_dash","ml_canvas_set_line_dash_offset","ml_canvas_set_line_join","ml_canvas_set_line_width","ml_canvas_set_miter_limit","ml_canvas_set_position","ml_canvas_set_shadow_blur","ml_canvas_set_shadow_color","ml_canvas_set_shadow_offset","ml_canvas_set_size","ml_canvas_set_stroke_color","ml_canvas_set_stroke_gradient","ml_canvas_set_stroke_pattern","ml_canvas_set_stroke_style","ml_canvas_set_transform","ml_canvas_shear","ml_canvas_show","ml_canvas_stop","ml_canvas_stroke","ml_canvas_stroke_path","ml_canvas_stroke_rect","ml_canvas_stroke_text","ml_canvas_transform","ml_canvas_translate","mult_digit_nat","mult_nat","nat_of_array","nth_digit_nat","nth_digit_nat_native","num_digits_nat","num_leading_zero_bits_in_digit","os_type","path_is_absolute","re_match","re_partial_match","re_replacement_text","re_search_backward","re_search_forward","re_string_match","resolve_fs_device","serialize_nat","set_digit_nat","set_digit_nat_native","set_to_zero_nat","shift_left_nat","shift_right_nat","square_nat","sub_nat"]),0];return}(globalThis));
//# 1 "../.js/default/stdlib/stdlib.cma.js"
// Generated by js_of_ocaml
//# 3 "../.js/default/stdlib/stdlib.cma.js"

//# 5 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function erase_rel(param){
    if(typeof param === "number") return 0;
    switch(param[0]){
      case 0:
       var rest = param[1]; return [0, erase_rel(rest)];
      case 1:
       var rest$0 = param[1]; return [1, erase_rel(rest$0)];
      case 2:
       var rest$1 = param[1]; return [2, erase_rel(rest$1)];
      case 3:
       var rest$2 = param[1]; return [3, erase_rel(rest$2)];
      case 4:
       var rest$3 = param[1]; return [4, erase_rel(rest$3)];
      case 5:
       var rest$4 = param[1]; return [5, erase_rel(rest$4)];
      case 6:
       var rest$5 = param[1]; return [6, erase_rel(rest$5)];
      case 7:
       var rest$6 = param[1]; return [7, erase_rel(rest$6)];
      case 8:
       var rest$7 = param[2], ty = param[1];
       return [8, ty, erase_rel(rest$7)];
      case 9:
       var rest$8 = param[3], ty1 = param[1];
       return [9, ty1, ty1, erase_rel(rest$8)];
      case 10:
       var rest$9 = param[1]; return [10, erase_rel(rest$9)];
      case 11:
       var rest$10 = param[1]; return [11, erase_rel(rest$10)];
      case 12:
       var rest$11 = param[1]; return [12, erase_rel(rest$11)];
      case 13:
       var rest$12 = param[1]; return [13, erase_rel(rest$12)];
      default: var rest$13 = param[1]; return [14, erase_rel(rest$13)];
    }
   }
   function concat_fmtty(fmtty1, fmtty2){
    if(typeof fmtty1 === "number") return fmtty2;
    switch(fmtty1[0]){
      case 0:
       var rest = fmtty1[1]; return [0, concat_fmtty(rest, fmtty2)];
      case 1:
       var rest$0 = fmtty1[1]; return [1, concat_fmtty(rest$0, fmtty2)];
      case 2:
       var rest$1 = fmtty1[1]; return [2, concat_fmtty(rest$1, fmtty2)];
      case 3:
       var rest$2 = fmtty1[1]; return [3, concat_fmtty(rest$2, fmtty2)];
      case 4:
       var rest$3 = fmtty1[1]; return [4, concat_fmtty(rest$3, fmtty2)];
      case 5:
       var rest$4 = fmtty1[1]; return [5, concat_fmtty(rest$4, fmtty2)];
      case 6:
       var rest$5 = fmtty1[1]; return [6, concat_fmtty(rest$5, fmtty2)];
      case 7:
       var rest$6 = fmtty1[1]; return [7, concat_fmtty(rest$6, fmtty2)];
      case 8:
       var rest$7 = fmtty1[2], ty = fmtty1[1];
       return [8, ty, concat_fmtty(rest$7, fmtty2)];
      case 9:
       var rest$8 = fmtty1[3], ty2 = fmtty1[2], ty1 = fmtty1[1];
       return [9, ty1, ty2, concat_fmtty(rest$8, fmtty2)];
      case 10:
       var rest$9 = fmtty1[1]; return [10, concat_fmtty(rest$9, fmtty2)];
      case 11:
       var rest$10 = fmtty1[1]; return [11, concat_fmtty(rest$10, fmtty2)];
      case 12:
       var rest$11 = fmtty1[1]; return [12, concat_fmtty(rest$11, fmtty2)];
      case 13:
       var rest$12 = fmtty1[1]; return [13, concat_fmtty(rest$12, fmtty2)];
      default:
       var rest$13 = fmtty1[1]; return [14, concat_fmtty(rest$13, fmtty2)];
    }
   }
   function concat_fmt(fmt1, fmt2){
    if(typeof fmt1 === "number") return fmt2;
    switch(fmt1[0]){
      case 0:
       var rest = fmt1[1]; return [0, concat_fmt(rest, fmt2)];
      case 1:
       var rest$0 = fmt1[1]; return [1, concat_fmt(rest$0, fmt2)];
      case 2:
       var rest$1 = fmt1[2], pad = fmt1[1];
       return [2, pad, concat_fmt(rest$1, fmt2)];
      case 3:
       var rest$2 = fmt1[2], pad$0 = fmt1[1];
       return [3, pad$0, concat_fmt(rest$2, fmt2)];
      case 4:
       var rest$3 = fmt1[4], prec = fmt1[3], pad$1 = fmt1[2], iconv = fmt1[1];
       return [4, iconv, pad$1, prec, concat_fmt(rest$3, fmt2)];
      case 5:
       var
        rest$4 = fmt1[4],
        prec$0 = fmt1[3],
        pad$2 = fmt1[2],
        iconv$0 = fmt1[1];
       return [5, iconv$0, pad$2, prec$0, concat_fmt(rest$4, fmt2)];
      case 6:
       var
        rest$5 = fmt1[4],
        prec$1 = fmt1[3],
        pad$3 = fmt1[2],
        iconv$1 = fmt1[1];
       return [6, iconv$1, pad$3, prec$1, concat_fmt(rest$5, fmt2)];
      case 7:
       var
        rest$6 = fmt1[4],
        prec$2 = fmt1[3],
        pad$4 = fmt1[2],
        iconv$2 = fmt1[1];
       return [7, iconv$2, pad$4, prec$2, concat_fmt(rest$6, fmt2)];
      case 8:
       var
        rest$7 = fmt1[4],
        prec$3 = fmt1[3],
        pad$5 = fmt1[2],
        fconv = fmt1[1];
       return [8, fconv, pad$5, prec$3, concat_fmt(rest$7, fmt2)];
      case 9:
       var rest$8 = fmt1[2], pad$6 = fmt1[1];
       return [9, pad$6, concat_fmt(rest$8, fmt2)];
      case 10:
       var rest$9 = fmt1[1]; return [10, concat_fmt(rest$9, fmt2)];
      case 11:
       var rest$10 = fmt1[2], str = fmt1[1];
       return [11, str, concat_fmt(rest$10, fmt2)];
      case 12:
       var rest$11 = fmt1[2], chr = fmt1[1];
       return [12, chr, concat_fmt(rest$11, fmt2)];
      case 13:
       var rest$12 = fmt1[3], fmtty = fmt1[2], pad$7 = fmt1[1];
       return [13, pad$7, fmtty, concat_fmt(rest$12, fmt2)];
      case 14:
       var rest$13 = fmt1[3], fmtty$0 = fmt1[2], pad$8 = fmt1[1];
       return [14, pad$8, fmtty$0, concat_fmt(rest$13, fmt2)];
      case 15:
       var rest$14 = fmt1[1]; return [15, concat_fmt(rest$14, fmt2)];
      case 16:
       var rest$15 = fmt1[1]; return [16, concat_fmt(rest$15, fmt2)];
      case 17:
       var rest$16 = fmt1[2], fmting_lit = fmt1[1];
       return [17, fmting_lit, concat_fmt(rest$16, fmt2)];
      case 18:
       var rest$17 = fmt1[2], fmting_gen = fmt1[1];
       return [18, fmting_gen, concat_fmt(rest$17, fmt2)];
      case 19:
       var rest$18 = fmt1[1]; return [19, concat_fmt(rest$18, fmt2)];
      case 20:
       var rest$19 = fmt1[3], char_set = fmt1[2], width_opt = fmt1[1];
       return [20, width_opt, char_set, concat_fmt(rest$19, fmt2)];
      case 21:
       var rest$20 = fmt1[2], counter = fmt1[1];
       return [21, counter, concat_fmt(rest$20, fmt2)];
      case 22:
       var rest$21 = fmt1[1]; return [22, concat_fmt(rest$21, fmt2)];
      case 23:
       var rest$22 = fmt1[2], ign = fmt1[1];
       return [23, ign, concat_fmt(rest$22, fmt2)];
      default:
       var rest$23 = fmt1[3], f = fmt1[2], arity = fmt1[1];
       return [24, arity, f, concat_fmt(rest$23, fmt2)];
    }
   }
   var CamlinternalFormatBasics = [0, concat_fmtty, erase_rel, concat_fmt];
   runtime.caml_register_global
    (0, CamlinternalFormatBasics, "CamlinternalFormatBasics");
   return;
  }
  (globalThis));

//# 179 "../.js/default/stdlib/stdlib.cma.js"
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function make(v){return [0, v];}
   function get(r){return r[1];}
   function set(r, v){r[1] = v; return 0;}
   function exchange(r, v){var cur = r[1]; r[1] = v; return cur;}
   function compare_and_set(r, seen, v){
    var cur = r[1];
    return cur === seen ? (r[1] = v, 1) : 0;
   }
   function fetch_and_add(r, n){
    var cur = r[1];
    r[1] = cur + n | 0;
    return cur;
   }
   function incr(r){fetch_and_add(r, 1); return 0;}
   function decr(r){fetch_and_add(r, -1); return 0;}
   var
    CamlinternalAtomic =
      [0,
       make,
       get,
       set,
       exchange,
       compare_and_set,
       fetch_and_add,
       incr,
       decr];
   runtime.caml_register_global(0, CamlinternalAtomic, "CamlinternalAtomic");
   return;
  }
  (globalThis));

//# 215 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_false$0 = "false",
    cst_true$0 = "true",
    caml_create_bytes = runtime.caml_create_bytes,
    caml_float_of_string = runtime.caml_float_of_string,
    caml_int64_float_of_bits = runtime.caml_int64_float_of_bits,
    caml_int_of_string = runtime.caml_int_of_string,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_bytes_length = runtime.caml_ml_bytes_length,
    caml_ml_channel_size = runtime.caml_ml_channel_size,
    caml_ml_channel_size_64 = runtime.caml_ml_channel_size_64,
    caml_ml_close_channel = runtime.caml_ml_close_channel,
    caml_ml_flush = runtime.caml_ml_flush,
    caml_ml_input = runtime.caml_ml_input,
    caml_ml_input_char = runtime.caml_ml_input_char,
    caml_ml_open_descriptor_in = runtime.caml_ml_open_descriptor_in,
    caml_ml_open_descriptor_out = runtime.caml_ml_open_descriptor_out,
    caml_ml_output = runtime.caml_ml_output,
    caml_ml_output_bytes = runtime.caml_ml_output_bytes,
    caml_ml_output_char = runtime.caml_ml_output_char,
    caml_ml_set_binary_mode = runtime.caml_ml_set_binary_mode,
    caml_ml_set_channel_name = runtime.caml_ml_set_channel_name,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_concat = runtime.caml_string_concat,
    caml_string_of_bytes = runtime.caml_string_of_bytes,
    caml_sys_open = runtime.caml_sys_open,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    CamlinternalAtomic = global_data.CamlinternalAtomic,
    CamlinternalFormatBasics = global_data.CamlinternalFormatBasics,
    Invalid_argument = global_data.Invalid_argument,
    Failure = global_data.Failure,
    Match_failure = global_data.Match_failure,
    Assert_failure = global_data.Assert_failure,
    Not_found = global_data.Not_found,
    Out_of_memory = global_data.Out_of_memory,
    Stack_overflow = global_data.Stack_overflow,
    Sys_error = global_data.Sys_error,
    End_of_file = global_data.End_of_file,
    Division_by_zero = global_data.Division_by_zero,
    Sys_blocked_io = global_data.Sys_blocked_io,
    Undefined_recursive_module = global_data.Undefined_recursive_module;
   function failwith(s){
    throw caml_maybe_attach_backtrace([0, Failure, s], 1);
   }
   function invalid_arg(s){
    throw caml_maybe_attach_backtrace([0, Invalid_argument, s], 1);
   }
   var Exit = [248, "Stdlib.Exit", runtime.caml_fresh_oo_id(0)];
   function min(x, y){return runtime.caml_lessequal(x, y) ? x : y;}
   function max(x, y){return runtime.caml_greaterequal(x, y) ? x : y;}
   function abs(x){return 0 <= x ? x : - x | 0;}
   function lnot(x){return x ^ -1;}
   var
    infinity =
      caml_int64_float_of_bits
       (runtime.caml_int64_create_lo_mi_hi(0, 0, 32752)),
    neg_infinity =
      caml_int64_float_of_bits
       (runtime.caml_int64_create_lo_mi_hi(0, 0, 65520)),
    nan =
      caml_int64_float_of_bits
       (runtime.caml_int64_create_lo_mi_hi(1, 0, 32752)),
    max_float =
      caml_int64_float_of_bits
       (runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 32751)),
    min_float =
      caml_int64_float_of_bits(runtime.caml_int64_create_lo_mi_hi(0, 0, 16)),
    epsilon_float =
      caml_int64_float_of_bits
       (runtime.caml_int64_create_lo_mi_hi(0, 0, 15536)),
    symbol_concat = caml_string_concat,
    cst_char_of_int = "char_of_int",
    cst_true = cst_true$0,
    cst_false = cst_false$0,
    cst_bool_of_string = "bool_of_string",
    _a_ = [0, 1],
    _b_ = [0, 0];
   function char_of_int(n){
    if(0 <= n && 255 >= n) return n;
    return invalid_arg(cst_char_of_int);
   }
   function string_of_bool(b){return b ? cst_true : cst_false;}
   function bool_of_string(param){
    return param !== cst_false$0
            ? param !== cst_true$0 ? invalid_arg(cst_bool_of_string) : 1
            : 0;
   }
   function bool_of_string_opt(param){
    return param !== cst_false$0 ? param !== cst_true$0 ? 0 : _a_ : _b_;
   }
   function string_of_int(n){return "" + n;}
   function int_of_string_opt(s){
    try{var _u_ = [0, caml_int_of_string(s)]; return _u_;}
    catch(_v_){
     var _t_ = caml_wrap_exception(_v_);
     if(_t_[1] === Failure) return 0;
     throw caml_maybe_attach_backtrace(_t_, 0);
    }
   }
   function valid_float_lexem(s1){
    var l = caml_ml_string_length(s1), i = 0;
    for(;;){
     if(l <= i) return s1 + ".";
     var match = runtime.caml_string_get(s1, i);
     a:
     {
      if(48 <= match){if(58 > match) break a;} else if(45 === match) break a;
      return s1;
     }
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function string_of_float(f){
    return valid_float_lexem(runtime.caml_format_float("%.12g", f));
   }
   function float_of_string_opt(s){
    try{var _r_ = [0, caml_float_of_string(s)]; return _r_;}
    catch(_s_){
     var _q_ = caml_wrap_exception(_s_);
     if(_q_[1] === Failure) return 0;
     throw caml_maybe_attach_backtrace(_q_, 0);
    }
   }
   function symbol(l1, l2){
    if(! l1) return l2;
    var tl = l1[2], hd = l1[1];
    return [0, hd, symbol(tl, l2)];
   }
   var
    stdin = caml_ml_open_descriptor_in(0),
    stdout = caml_ml_open_descriptor_out(1),
    stderr = caml_ml_open_descriptor_out(2),
    _c_ = [0, 1, [0, 3, [0, 4, [0, 7, 0]]]],
    _d_ = [0, 1, [0, 3, [0, 4, [0, 6, 0]]]],
    cst_output = "output",
    cst_output_substring = "output_substring",
    _e_ = [0, 0, [0, 7, 0]],
    _f_ = [0, 0, [0, 6, 0]],
    cst_input = "input",
    cst_really_input = "really_input";
   function open_out_gen(mode, perm, name){
    var c = caml_ml_open_descriptor_out(caml_sys_open(name, mode, perm));
    caml_ml_set_channel_name(c, name);
    return c;
   }
   function open_out(name){return open_out_gen(_c_, 438, name);}
   function open_out_bin(name){return open_out_gen(_d_, 438, name);}
   function flush_all(param){
    var param$0 = runtime.caml_ml_out_channels_list(0);
    for(;;){
     if(! param$0) return 0;
     var l = param$0[2], a = param$0[1];
     try{caml_ml_flush(a);}
     catch(_p_){
      var _o_ = caml_wrap_exception(_p_);
      if(_o_[1] !== Sys_error) throw caml_maybe_attach_backtrace(_o_, 0);
     }
     param$0 = l;
    }
   }
   function output_bytes(oc, s){
    return caml_ml_output_bytes(oc, s, 0, caml_ml_bytes_length(s));
   }
   function output_string(oc, s){
    return caml_ml_output(oc, s, 0, caml_ml_string_length(s));
   }
   function output(oc, s, ofs, len){
    if(0 <= ofs && 0 <= len && (caml_ml_bytes_length(s) - len | 0) >= ofs)
     return caml_ml_output_bytes(oc, s, ofs, len);
    return invalid_arg(cst_output);
   }
   function output_substring(oc, s, ofs, len){
    if(0 <= ofs && 0 <= len && (caml_ml_string_length(s) - len | 0) >= ofs)
     return caml_ml_output(oc, s, ofs, len);
    return invalid_arg(cst_output_substring);
   }
   function output_value(chan, v){
    return runtime.caml_output_value(chan, v, 0);
   }
   function close_out(oc){
    caml_ml_flush(oc);
    return caml_ml_close_channel(oc);
   }
   function close_out_noerr(oc){
    try{caml_ml_flush(oc);}catch(_n_){}
    try{var _l_ = caml_ml_close_channel(oc); return _l_;}catch(_m_){return 0;}
   }
   function open_in_gen(mode, perm, name){
    var c = caml_ml_open_descriptor_in(caml_sys_open(name, mode, perm));
    caml_ml_set_channel_name(c, name);
    return c;
   }
   function open_in(name){return open_in_gen(_e_, 0, name);}
   function open_in_bin(name){return open_in_gen(_f_, 0, name);}
   function input(ic, s, ofs, len){
    if(0 <= ofs && 0 <= len && (caml_ml_bytes_length(s) - len | 0) >= ofs)
     return caml_ml_input(ic, s, ofs, len);
    return invalid_arg(cst_input);
   }
   function unsafe_really_input(ic, s, ofs, len){
    var ofs$0 = ofs, len$0 = len;
    for(;;){
     if(0 >= len$0) return 0;
     var r = caml_ml_input(ic, s, ofs$0, len$0);
     if(0 === r) throw caml_maybe_attach_backtrace(End_of_file, 1);
     var len$1 = len$0 - r | 0, ofs$1 = ofs$0 + r | 0;
     ofs$0 = ofs$1;
     len$0 = len$1;
    }
   }
   function really_input(ic, s, ofs, len){
    if(0 <= ofs && 0 <= len && (caml_ml_bytes_length(s) - len | 0) >= ofs)
     return unsafe_really_input(ic, s, ofs, len);
    return invalid_arg(cst_really_input);
   }
   function really_input_string(ic, len){
    var s = caml_create_bytes(len);
    really_input(ic, s, 0, len);
    return caml_string_of_bytes(s);
   }
   function input_line(chan){
    function build_result(buf, pos, param){
     var pos$0 = pos, param$0 = param;
     for(;;){
      if(! param$0) return buf;
      var tl = param$0[2], hd = param$0[1], len = caml_ml_bytes_length(hd);
      runtime.caml_blit_bytes(hd, 0, buf, pos$0 - len | 0, len);
      var pos$1 = pos$0 - len | 0;
      pos$0 = pos$1;
      param$0 = tl;
     }
    }
    var accu = 0, len = 0;
    for(;;){
     var n = runtime.caml_ml_input_scan_line(chan);
     if(0 === n){
      if(! accu) throw caml_maybe_attach_backtrace(End_of_file, 1);
      var _k_ = build_result(caml_create_bytes(len), len, accu);
     }
     else{
      if(0 >= n){
       var beg = caml_create_bytes(- n | 0);
       caml_ml_input(chan, beg, 0, - n | 0);
       var len$1 = len - n | 0, accu$0 = [0, beg, accu];
       accu = accu$0;
       len = len$1;
       continue;
      }
      var res = caml_create_bytes(n - 1 | 0);
      caml_ml_input(chan, res, 0, n - 1 | 0);
      caml_ml_input_char(chan);
      if(accu)
       var
        len$0 = (len + n | 0) - 1 | 0,
        _k_ = build_result(caml_create_bytes(len$0), len$0, [0, res, accu]);
      else
       var _k_ = res;
     }
     return caml_string_of_bytes(_k_);
    }
   }
   function close_in_noerr(ic){
    try{var _i_ = caml_ml_close_channel(ic); return _i_;}catch(_j_){return 0;}
   }
   function print_char(c){return caml_ml_output_char(stdout, c);}
   function print_string(s){return output_string(stdout, s);}
   function print_bytes(s){return output_bytes(stdout, s);}
   function print_int(i){return output_string(stdout, "" + i);}
   function print_float(f){return output_string(stdout, string_of_float(f));}
   function print_endline(s){
    output_string(stdout, s);
    caml_ml_output_char(stdout, 10);
    return caml_ml_flush(stdout);
   }
   function print_newline(param){
    caml_ml_output_char(stdout, 10);
    return caml_ml_flush(stdout);
   }
   function prerr_char(c){return caml_ml_output_char(stderr, c);}
   function prerr_string(s){return output_string(stderr, s);}
   function prerr_bytes(s){return output_bytes(stderr, s);}
   function prerr_int(i){return output_string(stderr, "" + i);}
   function prerr_float(f){return output_string(stderr, string_of_float(f));}
   function prerr_endline(s){
    output_string(stderr, s);
    caml_ml_output_char(stderr, 10);
    return caml_ml_flush(stderr);
   }
   function prerr_newline(param){
    caml_ml_output_char(stderr, 10);
    return caml_ml_flush(stderr);
   }
   function read_line(param){caml_ml_flush(stdout); return input_line(stdin);}
   function read_int(param){return caml_int_of_string(read_line(0));}
   function read_int_opt(param){return int_of_string_opt(read_line(0));}
   function read_float(param){return caml_float_of_string(read_line(0));}
   function read_float_opt(param){return float_of_string_opt(read_line(0));}
   function string_of_format(param){var str = param[2]; return str;}
   function symbol$0(param, _h_){
    var
     str2 = _h_[2],
     fmt2 = _h_[1],
     str1 = param[2],
     fmt1 = param[1],
     s2 = "%," + str2;
    return [0, caml_call2(CamlinternalFormatBasics[3], fmt1, fmt2), str1 + s2];
   }
   var exit_function = caml_call1(CamlinternalAtomic[1], flush_all);
   function at_exit(f){
    for(;;){
     var
      f_yet_to_run = caml_call1(CamlinternalAtomic[1], 1),
      old_exit = caml_call1(CamlinternalAtomic[2], exit_function);
     let f_yet_to_run$0 = f_yet_to_run, old_exit$0 = old_exit;
     var
      new_exit =
        function(param){
         if(caml_call3(CamlinternalAtomic[5], f_yet_to_run$0, 1, 0))
          caml_call1(f, 0);
         return caml_call1(old_exit$0, 0);
        },
      success =
        caml_call3(CamlinternalAtomic[5], exit_function, old_exit, new_exit),
      _g_ = 1 - success;
     if(! _g_) return _g_;
    }
   }
   function do_at_exit(param){
    return caml_call1(caml_call1(CamlinternalAtomic[2], exit_function), 0);
   }
   function exit(retcode){
    do_at_exit(0);
    return runtime.caml_sys_exit(retcode);
   }
   runtime.caml_register_named_value("Pervasives.do_at_exit", do_at_exit);
   var
    Stdlib =
      [0,
       invalid_arg,
       failwith,
       Exit,
       Match_failure,
       Assert_failure,
       Invalid_argument,
       Failure,
       Not_found,
       Out_of_memory,
       Stack_overflow,
       Sys_error,
       End_of_file,
       Division_by_zero,
       Sys_blocked_io,
       Undefined_recursive_module,
       min,
       max,
       abs,
       2147483647,
       -2147483648,
       lnot,
       infinity,
       neg_infinity,
       nan,
       max_float,
       min_float,
       epsilon_float,
       symbol_concat,
       char_of_int,
       string_of_bool,
       bool_of_string_opt,
       bool_of_string,
       string_of_int,
       int_of_string_opt,
       string_of_float,
       float_of_string_opt,
       symbol,
       stdin,
       stdout,
       stderr,
       print_char,
       print_string,
       print_bytes,
       print_int,
       print_float,
       print_endline,
       print_newline,
       prerr_char,
       prerr_string,
       prerr_bytes,
       prerr_int,
       prerr_float,
       prerr_endline,
       prerr_newline,
       read_line,
       read_int_opt,
       read_int,
       read_float_opt,
       read_float,
       open_out,
       open_out_bin,
       open_out_gen,
       caml_ml_flush,
       flush_all,
       caml_ml_output_char,
       output_string,
       output_bytes,
       output,
       output_substring,
       caml_ml_output_char,
       runtime.caml_ml_output_int,
       output_value,
       runtime.caml_ml_seek_out,
       runtime.caml_ml_pos_out,
       caml_ml_channel_size,
       close_out,
       close_out_noerr,
       caml_ml_set_binary_mode,
       open_in,
       open_in_bin,
       open_in_gen,
       caml_ml_input_char,
       input_line,
       input,
       really_input,
       really_input_string,
       caml_ml_input_char,
       runtime.caml_ml_input_int,
       runtime.caml_input_value,
       runtime.caml_ml_seek_in,
       runtime.caml_ml_pos_in,
       caml_ml_channel_size,
       caml_ml_close_channel,
       close_in_noerr,
       caml_ml_set_binary_mode,
       [0,
        runtime.caml_ml_seek_out_64,
        runtime.caml_ml_pos_out_64,
        caml_ml_channel_size_64,
        runtime.caml_ml_seek_in_64,
        runtime.caml_ml_pos_in_64,
        caml_ml_channel_size_64],
       string_of_format,
       symbol$0,
       exit,
       at_exit,
       valid_float_lexem,
       unsafe_really_input,
       do_at_exit];
   runtime.caml_register_global(46, Stdlib, "Stdlib");
   return;
  }
  (globalThis));

//# 978 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception,
    global_data = runtime.caml_get_global_data(),
    ocaml_version = "4.14.0",
    ocaml_release = [0, 4, 14, 0, 0],
    Stdlib = global_data.Stdlib,
    executable_name = runtime.caml_sys_executable_name(0),
    os_type = runtime.caml_sys_get_config(0)[1],
    backend_type = [0, "js_of_ocaml"],
    unix = runtime.caml_sys_const_ostype_unix(0),
    win32 = runtime.caml_sys_const_ostype_win32(0),
    cygwin = runtime.caml_sys_const_ostype_cygwin(0),
    max_array_length = runtime.caml_sys_const_max_wosize(0),
    max_floatarray_length = max_array_length / 2 | 0,
    max_string_length = (4 * max_array_length | 0) - 1 | 0;
   function getenv_opt(s){
    try{var _d_ = [0, runtime.caml_sys_getenv(s)]; return _d_;}
    catch(_e_){
     var _c_ = caml_wrap_exception(_e_);
     if(_c_ === Stdlib[8]) return 0;
     throw caml_maybe_attach_backtrace(_c_, 0);
    }
   }
   var interactive = [0, 0];
   function set_signal(sig_num, sig_beh){return 0;}
   var Break = [248, "Stdlib.Sys.Break", runtime.caml_fresh_oo_id(0)];
   function catch_break(on){return on ? 0 : 0;}
   function Make(_b_, _a_){return [0, 1];}
   var
    Immediate64 = [0, Make],
    Stdlib_Sys =
      [0,
       executable_name,
       getenv_opt,
       interactive,
       os_type,
       backend_type,
       unix,
       win32,
       cygwin,
       32,
       32,
       0,
       max_string_length,
       max_array_length,
       max_floatarray_length,
       set_signal,
       -1,
       -2,
       -3,
       -4,
       -5,
       -6,
       -7,
       -8,
       -9,
       -10,
       -11,
       -12,
       -13,
       -14,
       -15,
       -16,
       -17,
       -18,
       -19,
       -20,
       -21,
       -22,
       -23,
       -24,
       -25,
       -26,
       -27,
       -28,
       Break,
       catch_break,
       ocaml_version,
       0,
       ocaml_release,
       runtime.caml_ml_enable_runtime_warnings,
       runtime.caml_ml_runtime_warnings_enabled,
       Immediate64];
   runtime.caml_register_global(4, Stdlib_Sys, "Stdlib__Sys");
   return;
  }
  (globalThis));

//# 1073 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Obj_extension_constructor$1 = "Obj.extension_constructor",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_obj_tag = runtime.caml_obj_tag;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Sys = global_data.Stdlib__Sys;
   function is_block(a){return 1 - (typeof a === "number" ? 1 : 0);}
   var
    double_field = runtime.caml_array_get,
    set_double_field = runtime.caml_array_set,
    custom_tag = 255,
    _a_ = [0, "obj.ml", 95, 4],
    cst_Obj_extension_constructor = cst_Obj_extension_constructor$1,
    cst_Obj_extension_constructor$0 = cst_Obj_extension_constructor$1;
   function info(obj){
    if(caml_obj_tag(obj) !== 247)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
    var
     info = runtime.caml_obj_raw_field(obj, 1),
     arity = 64 === Stdlib_Sys[9] ? info >> 56 : info >> 24,
     start_env = info << 8 >>> 9 | 0;
    return [0, arity, start_env];
   }
   function of_val(x){
    a:
    {
     if(is_block(x) && caml_obj_tag(x) !== 248 && 1 <= x.length - 1){var slot = x[1]; break a;}
     var slot = x;
    }
    a:
    {
     if(is_block(slot) && caml_obj_tag(slot) === 248){var name = slot[1]; break a;}
     var name = caml_call1(Stdlib[1], cst_Obj_extension_constructor$0);
    }
    return caml_obj_tag(name) === 252
            ? slot
            : caml_call1(Stdlib[1], cst_Obj_extension_constructor);
   }
   function name(slot){return slot[1];}
   function id(slot){return slot[2];}
   var
    Extension_constructor = [0, of_val, name, id],
    extension_constructor = Extension_constructor[1],
    extension_name = Extension_constructor[2],
    extension_id = Extension_constructor[3],
    max_ephe_length = Stdlib_Sys[13] - 2 | 0,
    cst_Obj_Ephemeron_create = "Obj.Ephemeron.create",
    cst_Obj_Ephemeron_get_key = "Obj.Ephemeron.get_key",
    cst_Obj_Ephemeron_get_key_copy = "Obj.Ephemeron.get_key_copy",
    cst_Obj_Ephemeron_set_key = "Obj.Ephemeron.set_key",
    cst_Obj_Ephemeron_unset_key = "Obj.Ephemeron.unset_key",
    cst_Obj_Ephemeron_check_key = "Obj.Ephemeron.check_key",
    cst_Obj_Ephemeron_blit_key = "Obj.Ephemeron.blit_key";
   function create(l){
    var _g_ = 0 <= l ? 1 : 0, _h_ = _g_ ? l <= max_ephe_length ? 1 : 0 : _g_;
    if(1 - _h_) caml_call1(Stdlib[1], cst_Obj_Ephemeron_create);
    return runtime.caml_ephe_create(l);
   }
   function length(x){return x.length - 3 | 0;}
   function raise_if_invalid_offset(e, o, msg){
    var
     _d_ = 0 <= o ? 1 : 0,
     _e_ = _d_ ? o < length(e) ? 1 : 0 : _d_,
     _f_ = 1 - _e_;
    return _f_ ? caml_call1(Stdlib[1], msg) : _f_;
   }
   function get_key(e, o){
    raise_if_invalid_offset(e, o, cst_Obj_Ephemeron_get_key);
    return runtime.caml_ephe_get_key(e, o);
   }
   function get_key_copy(e, o){
    raise_if_invalid_offset(e, o, cst_Obj_Ephemeron_get_key_copy);
    return runtime.caml_ephe_get_key_copy(e, o);
   }
   function set_key(e, o, x){
    raise_if_invalid_offset(e, o, cst_Obj_Ephemeron_set_key);
    return runtime.caml_ephe_set_key(e, o, x);
   }
   function unset_key(e, o){
    raise_if_invalid_offset(e, o, cst_Obj_Ephemeron_unset_key);
    return runtime.caml_ephe_unset_key(e, o);
   }
   function check_key(e, o){
    raise_if_invalid_offset(e, o, cst_Obj_Ephemeron_check_key);
    return runtime.caml_ephe_check_key(e, o);
   }
   function blit_key(e1, o1, e2, o2, l){
    if
     (0 <= l
      &&
       0 <= o1
       && (length(e1) - l | 0) >= o1 && 0 <= o2 && (length(e2) - l | 0) >= o2){
     var
      _b_ = 0 !== l ? 1 : 0,
      _c_ = _b_ ? runtime.caml_ephe_blit_key(e1, o1, e2, o2, l) : _b_;
     return _c_;
    }
    return caml_call1(Stdlib[1], cst_Obj_Ephemeron_blit_key);
   }
   var
    Stdlib_Obj =
      [0,
       is_block,
       double_field,
       set_double_field,
       0,
       245,
       246,
       247,
       248,
       249,
       250,
       251,
       251,
       252,
       253,
       254,
       custom_tag,
       custom_tag,
       1000,
       1001,
       1002,
       [0, info],
       Extension_constructor,
       extension_constructor,
       extension_name,
       extension_id,
       [0,
        create,
        length,
        get_key,
        get_key_copy,
        set_key,
        unset_key,
        check_key,
        blit_key,
        runtime.caml_ephe_get_data,
        runtime.caml_ephe_get_data_copy,
        runtime.caml_ephe_set_data,
        runtime.caml_ephe_unset_data,
        runtime.caml_ephe_check_data,
        runtime.caml_ephe_blit_data,
        max_ephe_length]];
   runtime.caml_register_global(13, Stdlib_Obj, "Stdlib__Obj");
   return;
  }
  (globalThis));

//# 1235 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_obj_make_forward = runtime.caml_obj_make_forward,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Obj = global_data.Stdlib__Obj,
    Undefined =
      [248, "CamlinternalLazy.Undefined", runtime.caml_fresh_oo_id(0)];
   function raise_undefined(param){
    throw caml_maybe_attach_backtrace(Undefined, 1);
   }
   function force_lazy_block(blk){
    var closure = blk[1];
    blk[1] = raise_undefined;
    try{
     var result = caml_call1(closure, 0);
     caml_obj_make_forward(blk, result);
     return result;
    }
    catch(e$0){
     var e = caml_wrap_exception(e$0);
     blk[1] = function(param){throw caml_maybe_attach_backtrace(e, 0);};
     throw caml_maybe_attach_backtrace(e, 0);
    }
   }
   function force_val_lazy_block(blk){
    var closure = blk[1];
    blk[1] = raise_undefined;
    var result = caml_call1(closure, 0);
    caml_obj_make_forward(blk, result);
    return result;
   }
   function force(lzv){
    var t = caml_obj_tag(lzv);
    return t === Stdlib_Obj[10]
            ? lzv[1]
            : t !== Stdlib_Obj[6] ? lzv : force_lazy_block(lzv);
   }
   function force_val(lzv){
    var t = caml_obj_tag(lzv);
    return t === Stdlib_Obj[10]
            ? lzv[1]
            : t !== Stdlib_Obj[6] ? lzv : force_val_lazy_block(lzv);
   }
   var
    CamlinternalLazy =
      [0, Undefined, force_lazy_block, force_val_lazy_block, force, force_val];
   runtime.caml_register_global(2, CamlinternalLazy, "CamlinternalLazy");
   return;
  }
  (globalThis));

//# 1300 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, caml_obj_tag = runtime.caml_obj_tag;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    CamlinternalLazy = global_data.CamlinternalLazy,
    Stdlib_Obj = global_data.Stdlib__Obj,
    Undefined = CamlinternalLazy[1],
    force_val = CamlinternalLazy[5];
   function from_fun(f){
    var x = runtime.caml_obj_block(Stdlib_Obj[6], 1);
    x[1] = f;
    return x;
   }
   function from_val(v){
    var t = caml_obj_tag(v);
    if(t !== Stdlib_Obj[10] && t !== Stdlib_Obj[6] && t !== Stdlib_Obj[14])
     return v;
    return runtime.caml_lazy_make_forward(v);
   }
   function is_val(l){
    var _i_ = Stdlib_Obj[6];
    return caml_obj_tag(l) !== _i_ ? 1 : 0;
   }
   function map(f, x){
    return [246,
            function(_f_){
             var
              _g_ = caml_obj_tag(x),
              _h_ =
                250 === _g_
                 ? x[1]
                 : 246 === _g_ ? caml_call1(CamlinternalLazy[2], x) : x;
             return caml_call1(f, _h_);
            }];
   }
   function map_val(f, x){
    if(! is_val(x))
     return [246,
             function(_c_){
              var
               _d_ = caml_obj_tag(x),
               _e_ =
                 250 === _d_
                  ? x[1]
                  : 246 === _d_ ? caml_call1(CamlinternalLazy[2], x) : x;
              return caml_call1(f, _e_);
             }];
    var
     _a_ = caml_obj_tag(x),
     _b_ =
       250 === _a_
        ? x[1]
        : 246 === _a_ ? caml_call1(CamlinternalLazy[2], x) : x;
    return from_val(caml_call1(f, _b_));
   }
   var
    Stdlib_Lazy =
      [0,
       Undefined,
       map,
       is_val,
       from_val,
       map_val,
       from_fun,
       force_val,
       from_fun,
       from_val,
       is_val];
   runtime.caml_register_global(2, Stdlib_Lazy, "Stdlib__Lazy");
   return;
  }
  (globalThis));

//# 1382 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Assert_failure = global_data.Assert_failure,
    CamlinternalAtomic = global_data.CamlinternalAtomic,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Stdlib = global_data.Stdlib,
    Stdlib_Lazy = global_data.Stdlib__Lazy,
    cst_Seq_init = "Seq.init",
    cst_Seq_take = "Seq.take",
    cst_Seq_drop = "Seq.drop";
   function empty(param){return 0;}
   function return$0(x, param){return [0, x, empty];}
   function cons(x, next, param){return [0, x, next];}
   function append(seq1, seq2, param){
    var match = caml_call1(seq1, 0);
    if(! match) return caml_call1(seq2, 0);
    var next = match[2], x = match[1];
    return [0, x, function(_av_){return append(next, seq2, _av_);}];
   }
   function map(f, seq, param){
    var match = caml_call1(seq, 0);
    if(! match) return 0;
    var next = match[2], x = match[1];
    return [0, caml_call1(f, x), function(_au_){return map(f, next, _au_);}];
   }
   function filter_map(f, seq, param){
    var seq$0 = seq;
    for(;;){
     var match = caml_call1(seq$0, 0);
     if(! match) return 0;
     var next = match[2], x = match[1], match$0 = caml_call1(f, x);
     if(match$0){
      var y = match$0[1];
      return [0, y, function(_at_){return filter_map(f, next, _at_);}];
     }
     seq$0 = next;
    }
   }
   function filter(f, seq, param){
    var seq$0 = seq;
    for(;;){
     var match = caml_call1(seq$0, 0);
     if(! match) return 0;
     var next = match[2], x = match[1];
     if(caml_call1(f, x))
      return [0, x, function(_as_){return filter(f, next, _as_);}];
     seq$0 = next;
    }
   }
   function concat(seq, param){
    var match = caml_call1(seq, 0);
    if(! match) return 0;
    var next = match[2], x = match[1];
    return append(x, function(_ar_){return concat(next, _ar_);}, 0);
   }
   function flat_map(f, seq, param){
    var match = caml_call1(seq, 0);
    if(! match) return 0;
    var next = match[2], x = match[1];
    return append
            (caml_call1(f, x),
             function(_aq_){return flat_map(f, next, _aq_);},
             0);
   }
   function fold_left(f, acc, seq){
    var acc$0 = acc, seq$0 = seq;
    for(;;){
     var match = caml_call1(seq$0, 0);
     if(! match) return acc$0;
     var next = match[2], x = match[1], acc$1 = caml_call2(f, acc$0, x);
     acc$0 = acc$1;
     seq$0 = next;
    }
   }
   function iter(f, seq){
    var seq$0 = seq;
    for(;;){
     var match = caml_call1(seq$0, 0);
     if(! match) return 0;
     var next = match[2], x = match[1];
     caml_call1(f, x);
     seq$0 = next;
    }
   }
   function unfold(f, u, param){
    var match = caml_call1(f, u);
    if(! match) return 0;
    var match$0 = match[1], u$0 = match$0[2], x = match$0[1];
    return [0, x, function(_ap_){return unfold(f, u$0, _ap_);}];
   }
   function is_empty(xs){return caml_call1(xs, 0) ? 0 : 1;}
   function uncons(xs){
    var match = caml_call1(xs, 0);
    if(! match) return 0;
    var xs$0 = match[2], x = match[1];
    return [0, [0, x, xs$0]];
   }
   function length(xs$1){
    var accu = 0, xs = xs$1;
    for(;;){
     var match = caml_call1(xs, 0);
     if(! match) return accu;
     var xs$0 = match[2], accu$0 = accu + 1 | 0;
     accu = accu$0;
     xs = xs$0;
    }
   }
   function iteri(f, xs$1){
    var i = 0, xs = xs$1;
    for(;;){
     var match = caml_call1(xs, 0);
     if(! match) return 0;
     var xs$0 = match[2], x = match[1];
     caml_call2(f, i, x);
     var i$0 = i + 1 | 0;
     i = i$0;
     xs = xs$0;
    }
   }
   function fold_lefti(f, accu$1, xs$1){
    var accu = accu$1, i = 0, xs = xs$1;
    for(;;){
     var match = caml_call1(xs, 0);
     if(! match) return accu;
     var
      xs$0 = match[2],
      x = match[1],
      accu$0 = caml_call3(f, accu, i, x),
      i$0 = i + 1 | 0;
     accu = accu$0;
     i = i$0;
     xs = xs$0;
    }
   }
   function for_all(p, xs){
    var xs$0 = xs;
    for(;;){
     var match = caml_call1(xs$0, 0);
     if(! match) return 1;
     var xs$1 = match[2], x = match[1], _ao_ = caml_call1(p, x);
     if(! _ao_) return _ao_;
     xs$0 = xs$1;
    }
   }
   function exists(p, xs){
    var xs$0 = xs;
    for(;;){
     var match = caml_call1(xs$0, 0);
     if(! match) return 0;
     var xs$1 = match[2], x = match[1], _an_ = caml_call1(p, x);
     if(_an_) return _an_;
     xs$0 = xs$1;
    }
   }
   function find(p, xs){
    var xs$0 = xs;
    for(;;){
     var match = caml_call1(xs$0, 0);
     if(! match) return 0;
     var xs$1 = match[2], x = match[1];
     if(caml_call1(p, x)) return [0, x];
     xs$0 = xs$1;
    }
   }
   function find_map(f, xs){
    var xs$0 = xs;
    for(;;){
     var match = caml_call1(xs$0, 0);
     if(! match) return 0;
     var xs$1 = match[2], x = match[1], result = caml_call1(f, x);
     if(result) return result;
     xs$0 = xs$1;
    }
   }
   function iter2(f, xs, ys){
    var xs$0 = xs, ys$0 = ys;
    for(;;){
     var match = caml_call1(xs$0, 0);
     if(! match) return 0;
     var xs$1 = match[2], x = match[1], match$0 = caml_call1(ys$0, 0);
     if(! match$0) return 0;
     var ys$1 = match$0[2], y = match$0[1];
     caml_call2(f, x, y);
     xs$0 = xs$1;
     ys$0 = ys$1;
    }
   }
   function fold_left2(f, accu, xs, ys){
    var accu$0 = accu, xs$0 = xs, ys$0 = ys;
    for(;;){
     var match = caml_call1(xs$0, 0);
     if(! match) return accu$0;
     var xs$1 = match[2], x = match[1], match$0 = caml_call1(ys$0, 0);
     if(! match$0) return accu$0;
     var
      ys$1 = match$0[2],
      y = match$0[1],
      accu$1 = caml_call3(f, accu$0, x, y);
     accu$0 = accu$1;
     xs$0 = xs$1;
     ys$0 = ys$1;
    }
   }
   function for_all2(f, xs, ys){
    var xs$0 = xs, ys$0 = ys;
    for(;;){
     var match = caml_call1(xs$0, 0);
     if(! match) return 1;
     var xs$1 = match[2], x = match[1], match$0 = caml_call1(ys$0, 0);
     if(! match$0) return 1;
     var ys$1 = match$0[2], y = match$0[1], _am_ = caml_call2(f, x, y);
     if(! _am_) return _am_;
     xs$0 = xs$1;
     ys$0 = ys$1;
    }
   }
   function exists2(f, xs, ys){
    var xs$0 = xs, ys$0 = ys;
    for(;;){
     var match = caml_call1(xs$0, 0);
     if(! match) return 0;
     var xs$1 = match[2], x = match[1], match$0 = caml_call1(ys$0, 0);
     if(! match$0) return 0;
     var ys$1 = match$0[2], y = match$0[1], _al_ = caml_call2(f, x, y);
     if(_al_) return _al_;
     xs$0 = xs$1;
     ys$0 = ys$1;
    }
   }
   function equal(eq, xs, ys){
    var xs$0 = xs, ys$0 = ys;
    for(;;){
     var match = caml_call1(xs$0, 0), match$0 = caml_call1(ys$0, 0);
     if(match){
      if(match$0){
       var
        ys$1 = match$0[2],
        y = match$0[1],
        xs$1 = match[2],
        x = match[1],
        _ak_ = caml_call2(eq, x, y);
       if(! _ak_) return _ak_;
       xs$0 = xs$1;
       ys$0 = ys$1;
       continue;
      }
     }
     else if(! match$0) return 1;
     return 0;
    }
   }
   function compare(cmp, xs, ys){
    var xs$0 = xs, ys$0 = ys;
    for(;;){
     var match = caml_call1(xs$0, 0), match$0 = caml_call1(ys$0, 0);
     if(! match) return match$0 ? -1 : 0;
     var xs$1 = match[2], x = match[1];
     if(! match$0) return 1;
     var ys$1 = match$0[2], y = match$0[1], c = caml_call2(cmp, x, y);
     if(0 !== c) return c;
     xs$0 = xs$1;
     ys$0 = ys$1;
    }
   }
   function init_aux(f, i, j, param){
    if(i >= j) return 0;
    var _ai_ = i + 1 | 0;
    return [0,
            caml_call1(f, i),
            function(_aj_){return init_aux(f, _ai_, j, _aj_);}];
   }
   function init(n, f){
    if(0 > n) return caml_call1(Stdlib[1], cst_Seq_init);
    var _ag_ = 0;
    return function(_ah_){return init_aux(f, _ag_, n, _ah_);};
   }
   function repeat(x, param){
    return [0, x, function(_af_){return repeat(x, _af_);}];
   }
   function forever(f, param){
    return [0, caml_call1(f, 0), function(_ae_){return forever(f, _ae_);}];
   }
   function cycle_nonempty(xs, param){
    return append(xs, function(_ad_){return cycle_nonempty(xs, _ad_);}, 0);
   }
   function cycle(xs, param){
    var match = caml_call1(xs, 0);
    if(! match) return 0;
    var xs$0 = match[2], x = match[1];
    function _aa_(_ac_){return cycle_nonempty(xs, _ac_);}
    return [0, x, function(_ab_){return append(xs$0, _aa_, _ab_);}];
   }
   function iterate1(f, x, param){
    var y = caml_call1(f, x);
    return [0, y, function(_$_){return iterate1(f, y, _$_);}];
   }
   function iterate(f, x){
    function next(___){return iterate1(f, x, ___);}
    return function(_Z_){return [0, x, next];};
   }
   function mapi_aux(f, i, xs, param){
    var match = caml_call1(xs, 0);
    if(! match) return 0;
    var xs$0 = match[2], x = match[1], _X_ = i + 1 | 0;
    return [0,
            caml_call2(f, i, x),
            function(_Y_){return mapi_aux(f, _X_, xs$0, _Y_);}];
   }
   function mapi(f, xs){
    var _V_ = 0;
    return function(_W_){return mapi_aux(f, _V_, xs, _W_);};
   }
   function tail_scan(f, s, xs, param){
    var match = caml_call1(xs, 0);
    if(! match) return 0;
    var xs$0 = match[2], x = match[1], s$0 = caml_call2(f, s, x);
    return [0, s$0, function(_U_){return tail_scan(f, s$0, xs$0, _U_);}];
   }
   function scan(f, s, xs){
    function next(_T_){return tail_scan(f, s, xs, _T_);}
    return function(_S_){return [0, s, next];};
   }
   function take_aux(n, xs){
    return 0 === n
            ? empty
            : function
             (param){
              var match = caml_call1(xs, 0);
              if(! match) return 0;
              var xs$0 = match[2], x = match[1];
              return [0, x, take_aux(n - 1 | 0, xs$0)];
             };
   }
   function take(n, xs){
    if(n < 0) caml_call1(Stdlib[1], cst_Seq_take);
    return take_aux(n, xs);
   }
   function drop(n, xs){
    return 0 <= n
            ? 0
              === n
              ? xs
              : function
               (param){
                var n$0 = n, xs$0 = xs;
                for(;;){
                 var match = caml_call1(xs$0, 0);
                 if(! match) return 0;
                 var xs$1 = match[2], n$1 = n$0 - 1 | 0;
                 if(0 === n$1) return caml_call1(xs$1, 0);
                 n$0 = n$1;
                 xs$0 = xs$1;
                }
               }
            : caml_call1(Stdlib[1], cst_Seq_drop);
   }
   function take_while(p, xs, param){
    var match = caml_call1(xs, 0);
    if(! match) return 0;
    var xs$0 = match[2], x = match[1];
    return caml_call1(p, x)
            ? [0, x, function(_R_){return take_while(p, xs$0, _R_);}]
            : 0;
   }
   function drop_while(p, xs, param){
    var xs$0 = xs;
    for(;;){
     var node = caml_call1(xs$0, 0);
     if(! node) return 0;
     var xs$1 = node[2], x = node[1];
     if(! caml_call1(p, x)) return node;
     xs$0 = xs$1;
    }
   }
   function group(eq, xs, param){
    var match = caml_call1(xs, 0);
    if(! match) return 0;
    var xs$0 = match[2], x = match[1], _K_ = caml_call1(eq, x);
    function _L_(_Q_){return drop_while(_K_, xs$0, _Q_);}
    var _M_ = caml_call1(eq, x);
    function next(_P_){return take_while(_M_, xs$0, _P_);}
    return [0,
            function(_O_){return [0, x, next];},
            function(_N_){return group(eq, _L_, _N_);}];
   }
   var
    Forced_twice =
      [248, "Stdlib.Seq.Forced_twice", runtime.caml_fresh_oo_id(0)],
    to_lazy = Stdlib_Lazy[6],
    _a_ = [0, "seq.ml", 596, 4];
   function failure(param){
    throw caml_maybe_attach_backtrace(Forced_twice, 1);
   }
   function memoize(xs){
    function s$0(param){
     var match = caml_call1(xs, 0);
     if(! match) return 0;
     var xs$0 = match[2], x = match[1];
     return [0, x, memoize(xs$0)];
    }
    var s = caml_call1(to_lazy, s$0);
    return function(_J_){
     var _I_ = runtime.caml_obj_tag(s);
     return 250 === _I_
             ? s[1]
             : 246 === _I_ ? caml_call1(CamlinternalLazy[2], s) : s;};
   }
   function once(xs){
    function f(param){
     var match = caml_call1(xs, 0);
     if(! match) return 0;
     var xs$0 = match[2], x = match[1];
     return [0, x, once(xs$0)];
    }
    var action = caml_call1(CamlinternalAtomic[1], f);
    return function(param){
     var f = caml_call2(CamlinternalAtomic[4], action, failure);
     return caml_call1(f, 0);};
   }
   function zip(xs, ys, param){
    var match = caml_call1(xs, 0);
    if(! match) return 0;
    var xs$0 = match[2], x = match[1], match$0 = caml_call1(ys, 0);
    if(! match$0) return 0;
    var ys$0 = match$0[2], y = match$0[1];
    return [0, [0, x, y], function(_H_){return zip(xs$0, ys$0, _H_);}];
   }
   function map2(f, xs, ys, param){
    var match = caml_call1(xs, 0);
    if(! match) return 0;
    var xs$0 = match[2], x = match[1], match$0 = caml_call1(ys, 0);
    if(! match$0) return 0;
    var ys$0 = match$0[2], y = match$0[1];
    return [0,
            caml_call2(f, x, y),
            function(_G_){return map2(f, xs$0, ys$0, _G_);}];
   }
   function interleave(xs, ys, param){
    var match = caml_call1(xs, 0);
    if(! match) return caml_call1(ys, 0);
    var xs$0 = match[2], x = match[1];
    return [0, x, function(_F_){return interleave(ys, xs$0, _F_);}];
   }
   function sorted_merge1(cmp, x, xs, y, ys){
    return 0 < caml_call2(cmp, x, y)
            ? [0,
              y,
              function(_D_){
               var match = caml_call1(ys, 0);
               if(! match) return [0, x, xs];
               var ys$0 = match[2], y = match[1];
               return sorted_merge1(cmp, x, xs, y, ys$0);
              }]
            : [0,
              x,
              function(_E_){
               var match = caml_call1(xs, 0);
               if(! match) return [0, y, ys];
               var xs$0 = match[2], x = match[1];
               return sorted_merge1(cmp, x, xs$0, y, ys);
              }];
   }
   function sorted_merge(cmp, xs, ys, param){
    var match = caml_call1(xs, 0), match$0 = caml_call1(ys, 0);
    if(match){
     if(match$0){
      var ys$0 = match$0[2], y = match$0[1], xs$0 = match[2], x = match[1];
      return sorted_merge1(cmp, x, xs$0, y, ys$0);
     }
     var c = match;
    }
    else{if(! match$0) return 0; var c = match$0;}
    return c;
   }
   function map_fst(xys, param){
    var match = caml_call1(xys, 0);
    if(! match) return 0;
    var xys$0 = match[2], x = match[1][1];
    return [0, x, function(_C_){return map_fst(xys$0, _C_);}];
   }
   function map_snd(xys, param){
    var match = caml_call1(xys, 0);
    if(! match) return 0;
    var xys$0 = match[2], y = match[1][2];
    return [0, y, function(_B_){return map_snd(xys$0, _B_);}];
   }
   function unzip(xys){
    return [0,
            function(_A_){return map_fst(xys, _A_);},
            function(_z_){return map_snd(xys, _z_);}];
   }
   function filter_map_find_left_map(f, xs, param){
    var xs$0 = xs;
    for(;;){
     var match = caml_call1(xs$0, 0);
     if(! match) return 0;
     var xs$1 = match[2], x = match[1], match$0 = caml_call1(f, x);
     if(0 === match$0[0]){
      var y = match$0[1];
      return [0,
              y,
              function(_y_){return filter_map_find_left_map(f, xs$1, _y_);}];
     }
     xs$0 = xs$1;
    }
   }
   function filter_map_find_right_map(f, xs, param){
    var xs$0 = xs;
    for(;;){
     var match = caml_call1(xs$0, 0);
     if(! match) return 0;
     var xs$1 = match[2], x = match[1], match$0 = caml_call1(f, x);
     if(0 !== match$0[0]){
      var z = match$0[1];
      return [0,
              z,
              function(_x_){return filter_map_find_right_map(f, xs$1, _x_);}];
     }
     xs$0 = xs$1;
    }
   }
   function partition_map(f, xs){
    return [0,
            function(_w_){return filter_map_find_left_map(f, xs, _w_);},
            function(_v_){return filter_map_find_right_map(f, xs, _v_);}];
   }
   function partition(p, xs){
    function _s_(x){return 1 - caml_call1(p, x);}
    return [0,
            function(_u_){return filter(p, xs, _u_);},
            function(_t_){return filter(_s_, xs, _t_);}];
   }
   function peel(xss){
    return unzip(function(_r_){return filter_map(uncons, xss, _r_);});
   }
   function transpose(xss, param){
    var match = peel(xss), tails = match[2], heads = match[1];
    if(! is_empty(heads))
     return [0, heads, function(_q_){return transpose(tails, _q_);}];
    if(is_empty(tails)) return 0;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
   }
   function _b_(remainders, xss, param){
    var match = caml_call1(xss, 0);
    if(! match) return transpose(remainders, 0);
    var xss$0 = match[2], xs = match[1], match$0 = caml_call1(xs, 0);
    if(match$0){
     var
      xs$0 = match$0[2],
      x = match$0[1],
      match$1 = peel(remainders),
      tails = match$1[2],
      heads = match$1[1],
      _l_ = function(_p_){return [0, xs$0, tails];};
     return [0,
             function(_o_){return [0, x, heads];},
             function(_n_){return _b_(_l_, xss$0, _n_);}];
    }
    var
     match$2 = peel(remainders),
     tails$0 = match$2[2],
     heads$0 = match$2[1];
    return [0, heads$0, function(_m_){return _b_(tails$0, xss$0, _m_);}];
   }
   function map_product(f, xs, ys){
    function _f_(x){
     function _j_(y){return caml_call2(f, x, y);}
     return function(_k_){return map(_j_, ys, _k_);};
    }
    function xss(_i_){return map(_f_, xs, _i_);}
    function _e_(_h_){return _b_(empty, xss, _h_);}
    return function(_g_){return concat(_e_, _g_);};
   }
   function product(xs, ys){
    return map_product(function(x, y){return [0, x, y];}, xs, ys);
   }
   function of_dispenser(it){
    function c(param){
     var match = caml_call1(it, 0);
     if(! match) return 0;
     var x = match[1];
     return [0, x, c];
    }
    return c;
   }
   function to_dispenser(xs){
    var s = [0, xs];
    return function(param){
     var match = caml_call1(s[1], 0);
     if(! match) return 0;
     var xs = match[2], x = match[1];
     s[1] = xs;
     return [0, x];};
   }
   function ints(i, param){
    var _c_ = i + 1 | 0;
    return [0, i, function(_d_){return ints(_c_, _d_);}];
   }
   var
    Stdlib_Seq =
      [0,
       is_empty,
       uncons,
       length,
       iter,
       fold_left,
       iteri,
       fold_lefti,
       for_all,
       exists,
       find,
       find_map,
       iter2,
       fold_left2,
       for_all2,
       exists2,
       equal,
       compare,
       empty,
       return$0,
       cons,
       init,
       unfold,
       repeat,
       forever,
       cycle,
       iterate,
       map,
       mapi,
       filter,
       filter_map,
       scan,
       take,
       drop,
       take_while,
       drop_while,
       group,
       memoize,
       Forced_twice,
       once,
       transpose,
       append,
       concat,
       flat_map,
       flat_map,
       zip,
       map2,
       interleave,
       sorted_merge,
       product,
       map_product,
       unzip,
       unzip,
       partition_map,
       partition,
       of_dispenser,
       to_dispenser,
       ints];
   runtime.caml_register_global(10, Stdlib_Seq, "Stdlib__Seq");
   return;
  }
  (globalThis));

//# 2338 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_bytes_unsafe_set = runtime.caml_bytes_unsafe_set,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_string_of_bytes = runtime.caml_string_of_bytes;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "\\\\",
    cst$0 = "\\'",
    Stdlib = global_data.Stdlib,
    cst_Char_chr = "Char.chr",
    cst_b = "\\b",
    cst_t = "\\t",
    cst_n = "\\n",
    cst_r = "\\r";
   function chr(n){
    if(0 <= n && 255 >= n) return n;
    return caml_call1(Stdlib[1], cst_Char_chr);
   }
   function escaped(c){
    a:
    {
     if(40 <= c){
      if(92 === c) return cst;
      if(127 > c) break a;
     }
     else{
      if(32 <= c){if(39 <= c) return cst$0; break a;}
      if(14 > c)
       switch(c){
         case 8:
          return cst_b;
         case 9:
          return cst_t;
         case 10:
          return cst_n;
         case 13:
          return cst_r;
       }
     }
     var s = caml_create_bytes(4);
     caml_bytes_unsafe_set(s, 0, 92);
     caml_bytes_unsafe_set(s, 1, 48 + (c / 100 | 0) | 0);
     caml_bytes_unsafe_set(s, 2, 48 + ((c / 10 | 0) % 10 | 0) | 0);
     caml_bytes_unsafe_set(s, 3, 48 + (c % 10 | 0) | 0);
     return caml_string_of_bytes(s);
    }
    var s$0 = caml_create_bytes(1);
    caml_bytes_unsafe_set(s$0, 0, c);
    return caml_string_of_bytes(s$0);
   }
   function lowercase(c){
    var _b_ = c - 192 | 0;
    a:
    {
     if(30 < _b_ >>> 0){
      if(25 < _b_ + 127 >>> 0) break a;
     }
     else if(23 === _b_) break a;
     return c + 32 | 0;
    }
    return c;
   }
   function uppercase(c){
    var _a_ = c - 224 | 0;
    a:
    {
     if(30 < _a_ >>> 0){
      if(25 < _a_ + 127 >>> 0) break a;
     }
     else if(23 === _a_) break a;
     return c - 32 | 0;
    }
    return c;
   }
   function lowercase_ascii(c){return 25 < c - 65 >>> 0 ? c : c + 32 | 0;}
   function uppercase_ascii(c){return 25 < c - 97 >>> 0 ? c : c - 32 | 0;}
   function compare(c1, c2){return c1 - c2 | 0;}
   function equal(c1, c2){return 0 === (c1 - c2 | 0) ? 1 : 0;}
   var
    Stdlib_Char =
      [0,
       chr,
       escaped,
       lowercase,
       uppercase,
       lowercase_ascii,
       uppercase_ascii,
       compare,
       equal];
   runtime.caml_register_global(8, Stdlib_Char, "Stdlib__Char");
   return;
  }
  (globalThis));

//# 2443 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_uchar_ml = "uchar.ml",
    caml_format_int = runtime.caml_format_int,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    err_no_pred = "U+0000 has no predecessor",
    err_no_succ = "U+10FFFF has no successor",
    Assert_failure = global_data.Assert_failure,
    Stdlib = global_data.Stdlib,
    cst_is_not_an_Unicode_scalar_v = " is not an Unicode scalar value",
    cst_is_not_a_latin1_character = " is not a latin1 character",
    cst_U = "U+",
    lo_bound = 55295,
    hi_bound = 57344;
   function succ(u){
    return u === 55295
            ? hi_bound
            : u === 1114111 ? caml_call1(Stdlib[1], err_no_succ) : u + 1 | 0;
   }
   function pred(u){
    return u === 57344
            ? lo_bound
            : u === 0 ? caml_call1(Stdlib[1], err_no_pred) : u - 1 | 0;
   }
   function is_valid(i){
    var _n_ = 0 <= i ? 1 : 0, _o_ = _n_ ? i <= 55295 ? 1 : 0 : _n_;
    if(_o_)
     var _p_ = _o_;
    else
     var _q_ = 57344 <= i ? 1 : 0, _p_ = _q_ ? i <= 1114111 ? 1 : 0 : _q_;
    return _p_;
   }
   function of_int(i){
    if(is_valid(i)) return i;
    var
     _m_ =
       caml_call2
        (Stdlib[28], caml_format_int("%X", i), cst_is_not_an_Unicode_scalar_v);
    return caml_call1(Stdlib[1], _m_);
   }
   function is_char(u){return u < 256 ? 1 : 0;}
   function of_char(c){return c;}
   function to_char(u){
    if(255 >= u) return u;
    var
     _k_ =
       caml_call2
        (Stdlib[28],
         caml_format_int("%04X", u),
         cst_is_not_a_latin1_character),
     _l_ = caml_call2(Stdlib[28], cst_U, _k_);
    return caml_call1(Stdlib[1], _l_);
   }
   function unsafe_to_char(_j_){return _j_;}
   function equal(_i_, _h_){return _i_ === _h_ ? 1 : 0;}
   var
    compare = runtime.caml_int_compare,
    _a_ = [0, cst_uchar_ml, 85, 7],
    _b_ = [0, cst_uchar_ml, 80, 18],
    _c_ = [0, cst_uchar_ml, 91, 7],
    _d_ = [0, cst_uchar_ml, 88, 18];
   function hash(_g_){return _g_;}
   function utf_decode_is_valid(d){return 1 === (d >>> 27 | 0) ? 1 : 0;}
   function utf_decode_length(d){return (d >>> 24 | 0) & 7;}
   function utf_decode_uchar(d){return d & 16777215;}
   function utf_decode(n, u){return (8 | n) << 24 | u;}
   function utf_decode_invalid(n){return n << 24 | 65533;}
   function utf_8_byte_length(u){
    if(0 > u) throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
    if(127 >= u) return 1;
    if(2047 >= u) return 2;
    if(65535 >= u) return 3;
    if(1114111 < u)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
    return 4;
   }
   function utf_16_byte_length(u){
    if(0 > u) throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
    if(65535 >= u) return 2;
    if(1114111 < u)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
    return 4;
   }
   var
    Stdlib_Uchar =
      [0,
       0,
       1114111,
       65279,
       65533,
       succ,
       pred,
       is_valid,
       of_int,
       function(_f_){return _f_;},
       function(_e_){return _e_;},
       is_char,
       of_char,
       to_char,
       unsafe_to_char,
       equal,
       compare,
       hash,
       utf_decode_is_valid,
       utf_decode_uchar,
       utf_decode_length,
       utf_decode,
       utf_decode_invalid,
       utf_8_byte_length,
       utf_16_byte_length];
   runtime.caml_register_global(13, Stdlib_Uchar, "Stdlib__Uchar");
   return;
  }
  (globalThis));

//# 2575 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_List_nth$1 = "List.nth",
    caml_compare = runtime.caml_compare,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Stdlib_Seq = global_data.Stdlib__Seq,
    Stdlib_Sys = global_data.Stdlib__Sys,
    cst_hd = "hd",
    cst_tl = "tl",
    cst_nth = "nth",
    cst_List_nth = cst_List_nth$1,
    cst_List_nth$0 = cst_List_nth$1;
   function length(l$0){
    var len = 0, param = l$0;
    for(;;){
     if(! param) return len;
     var l = param[2], len$0 = len + 1 | 0;
     len = len$0;
     param = l;
    }
   }
   function cons(a, l){return [0, a, l];}
   function hd(param){
    if(! param) return caml_call1(Stdlib[2], cst_hd);
    var a = param[1];
    return a;
   }
   function tl(param){
    if(! param) return caml_call1(Stdlib[2], cst_tl);
    var l = param[2];
    return l;
   }
   function nth(l, n){
    if(0 > n) return caml_call1(Stdlib[1], cst_List_nth);
    var l$0 = l, n$0 = n;
    for(;;){
     if(! l$0) return caml_call1(Stdlib[2], cst_nth);
     var l$1 = l$0[2], a = l$0[1];
     if(0 === n$0) return a;
     var n$1 = n$0 - 1 | 0;
     l$0 = l$1;
     n$0 = n$1;
    }
   }
   function nth_opt(l, n){
    if(0 > n) return caml_call1(Stdlib[1], cst_List_nth$0);
    var l$0 = l, n$0 = n;
    for(;;){
     if(! l$0) return 0;
     var l$1 = l$0[2], a = l$0[1];
     if(0 === n$0) return [0, a];
     var n$1 = n$0 - 1 | 0;
     l$0 = l$1;
     n$0 = n$1;
    }
   }
   var append = Stdlib[37];
   function rev_append(l1, l2){
    var l1$0 = l1, l2$0 = l2;
    for(;;){
     if(! l1$0) return l2$0;
     var l1$1 = l1$0[2], a = l1$0[1], l2$1 = [0, a, l2$0];
     l1$0 = l1$1;
     l2$0 = l2$1;
    }
   }
   function rev(l){return rev_append(l, 0);}
   function init_aux(i, n, f){
    if(n <= i) return 0;
    var r = caml_call1(f, i);
    return [0, r, init_aux(i + 1 | 0, n, f)];
   }
   var
    cst_List_map2 = "List.map2",
    cst_List_iter2 = "List.iter2",
    cst_List_fold_left2 = "List.fold_left2",
    cst_List_fold_right2 = "List.fold_right2",
    cst_List_for_all2 = "List.for_all2",
    cst_List_exists2 = "List.exists2",
    _b_ = [0, 0, 0],
    cst_List_combine = "List.combine",
    cst_List_rev_map2 = "List.rev_map2",
    cst_List_init = "List.init",
    rev_init_threshold = typeof Stdlib_Sys[5] === "number" ? 10000 : 50;
   function init(len, f){
    if(0 > len) return caml_call1(Stdlib[1], cst_List_init);
    if(rev_init_threshold >= len) return init_aux(0, len, f);
    var acc = 0, i = 0;
    for(;;){
     if(len <= i) return rev(acc);
     var i$0 = i + 1 | 0, acc$0 = [0, caml_call1(f, i), acc];
     acc = acc$0;
     i = i$0;
    }
   }
   function flatten(param){
    if(! param) return 0;
    var r = param[2], l = param[1], _H_ = flatten(r);
    return caml_call2(Stdlib[37], l, _H_);
   }
   function map(f, param){
    if(! param) return 0;
    var l = param[2], a = param[1], r = caml_call1(f, a);
    return [0, r, map(f, l)];
   }
   function _a_(i, f, param){
    if(! param) return 0;
    var l = param[2], a = param[1], r = caml_call2(f, i, a);
    return [0, r, _a_(i + 1 | 0, f, l)];
   }
   function mapi(f, l){return _a_(0, f, l);}
   function rev_map(f, l){
    var accu = 0, param = l;
    for(;;){
     if(! param) return accu;
     var l$0 = param[2], a = param[1], accu$0 = [0, caml_call1(f, a), accu];
     accu = accu$0;
     param = l$0;
    }
   }
   function iter(f, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var l = param$0[2], a = param$0[1];
     caml_call1(f, a);
     param$0 = l;
    }
   }
   function iteri(f, l$0){
    var i = 0, param = l$0;
    for(;;){
     if(! param) return 0;
     var l = param[2], a = param[1];
     caml_call2(f, i, a);
     var i$0 = i + 1 | 0;
     i = i$0;
     param = l;
    }
   }
   function fold_left(f, accu, l){
    var accu$0 = accu, l$0 = l;
    for(;;){
     if(! l$0) return accu$0;
     var l$1 = l$0[2], a = l$0[1], accu$1 = caml_call2(f, accu$0, a);
     accu$0 = accu$1;
     l$0 = l$1;
    }
   }
   function fold_right(f, l, accu){
    if(! l) return accu;
    var l$0 = l[2], a = l[1];
    return caml_call2(f, a, fold_right(f, l$0, accu));
   }
   function map2(f, l1, l2){
    if(l1){
     if(l2){
      var
       l2$0 = l2[2],
       a2 = l2[1],
       l1$0 = l1[2],
       a1 = l1[1],
       r = caml_call2(f, a1, a2);
      return [0, r, map2(f, l1$0, l2$0)];
     }
    }
    else if(! l2) return 0;
    return caml_call1(Stdlib[1], cst_List_map2);
   }
   function rev_map2(f, l1, l2){
    var accu = 0, l1$0 = l1, l2$0 = l2;
    for(;;){
     if(l1$0){
      if(l2$0){
       var
        l2$1 = l2$0[2],
        a2 = l2$0[1],
        l1$1 = l1$0[2],
        a1 = l1$0[1],
        accu$0 = [0, caml_call2(f, a1, a2), accu];
       accu = accu$0;
       l1$0 = l1$1;
       l2$0 = l2$1;
       continue;
      }
     }
     else if(! l2$0) return accu;
     return caml_call1(Stdlib[1], cst_List_rev_map2);
    }
   }
   function iter2(f, l1, l2){
    var l1$0 = l1, l2$0 = l2;
    for(;;){
     if(l1$0){
      if(l2$0){
       var l2$1 = l2$0[2], a2 = l2$0[1], l1$1 = l1$0[2], a1 = l1$0[1];
       caml_call2(f, a1, a2);
       l1$0 = l1$1;
       l2$0 = l2$1;
       continue;
      }
     }
     else if(! l2$0) return 0;
     return caml_call1(Stdlib[1], cst_List_iter2);
    }
   }
   function fold_left2(f, accu, l1, l2){
    var accu$0 = accu, l1$0 = l1, l2$0 = l2;
    for(;;){
     if(l1$0){
      if(l2$0){
       var
        l2$1 = l2$0[2],
        a2 = l2$0[1],
        l1$1 = l1$0[2],
        a1 = l1$0[1],
        accu$1 = caml_call3(f, accu$0, a1, a2);
       accu$0 = accu$1;
       l1$0 = l1$1;
       l2$0 = l2$1;
       continue;
      }
     }
     else if(! l2$0) return accu$0;
     return caml_call1(Stdlib[1], cst_List_fold_left2);
    }
   }
   function fold_right2(f, l1, l2, accu){
    if(l1){
     if(l2){
      var l2$0 = l2[2], a2 = l2[1], l1$0 = l1[2], a1 = l1[1];
      return caml_call3(f, a1, a2, fold_right2(f, l1$0, l2$0, accu));
     }
    }
    else if(! l2) return accu;
    return caml_call1(Stdlib[1], cst_List_fold_right2);
   }
   function for_all(p, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 1;
     var l = param$0[2], a = param$0[1], _G_ = caml_call1(p, a);
     if(! _G_) return _G_;
     param$0 = l;
    }
   }
   function exists(p, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var l = param$0[2], a = param$0[1], _F_ = caml_call1(p, a);
     if(_F_) return _F_;
     param$0 = l;
    }
   }
   function for_all2(p, l1, l2){
    var l1$0 = l1, l2$0 = l2;
    for(;;){
     if(l1$0){
      if(l2$0){
       var
        l2$1 = l2$0[2],
        a2 = l2$0[1],
        l1$1 = l1$0[2],
        a1 = l1$0[1],
        _E_ = caml_call2(p, a1, a2);
       if(! _E_) return _E_;
       l1$0 = l1$1;
       l2$0 = l2$1;
       continue;
      }
     }
     else if(! l2$0) return 1;
     return caml_call1(Stdlib[1], cst_List_for_all2);
    }
   }
   function exists2(p, l1, l2){
    var l1$0 = l1, l2$0 = l2;
    for(;;){
     if(l1$0){
      if(l2$0){
       var
        l2$1 = l2$0[2],
        a2 = l2$0[1],
        l1$1 = l1$0[2],
        a1 = l1$0[1],
        _D_ = caml_call2(p, a1, a2);
       if(_D_) return _D_;
       l1$0 = l1$1;
       l2$0 = l2$1;
       continue;
      }
     }
     else if(! l2$0) return 0;
     return caml_call1(Stdlib[1], cst_List_exists2);
    }
   }
   function mem(x, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var
      l = param$0[2],
      a = param$0[1],
      _C_ = 0 === caml_compare(a, x) ? 1 : 0;
     if(_C_) return _C_;
     param$0 = l;
    }
   }
   function memq(x, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var l = param$0[2], a = param$0[1], _B_ = a === x ? 1 : 0;
     if(_B_) return _B_;
     param$0 = l;
    }
   }
   function assoc(x, param){
    var param$0 = param;
    for(;;){
     if(! param$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     var l = param$0[2], match = param$0[1], b = match[2], a = match[1];
     if(0 === caml_compare(a, x)) return b;
     param$0 = l;
    }
   }
   function assoc_opt(x, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var l = param$0[2], match = param$0[1], b = match[2], a = match[1];
     if(0 === caml_compare(a, x)) return [0, b];
     param$0 = l;
    }
   }
   function assq(x, param){
    var param$0 = param;
    for(;;){
     if(! param$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     var l = param$0[2], match = param$0[1], b = match[2], a = match[1];
     if(a === x) return b;
     param$0 = l;
    }
   }
   function assq_opt(x, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var l = param$0[2], match = param$0[1], b = match[2], a = match[1];
     if(a === x) return [0, b];
     param$0 = l;
    }
   }
   function mem_assoc(x, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var
      l = param$0[2],
      a = param$0[1][1],
      _A_ = 0 === caml_compare(a, x) ? 1 : 0;
     if(_A_) return _A_;
     param$0 = l;
    }
   }
   function mem_assq(x, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var l = param$0[2], a = param$0[1][1], _z_ = a === x ? 1 : 0;
     if(_z_) return _z_;
     param$0 = l;
    }
   }
   function remove_assoc(x, param){
    if(! param) return 0;
    var l = param[2], pair = param[1], a = pair[1];
    return 0 === caml_compare(a, x) ? l : [0, pair, remove_assoc(x, l)];
   }
   function remove_assq(x, param){
    if(! param) return 0;
    var l = param[2], pair = param[1], a = pair[1];
    return a === x ? l : [0, pair, remove_assq(x, l)];
   }
   function find(p, param){
    var param$0 = param;
    for(;;){
     if(! param$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     var l = param$0[2], x = param$0[1];
     if(caml_call1(p, x)) return x;
     param$0 = l;
    }
   }
   function find_opt(p, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var l = param$0[2], x = param$0[1];
     if(caml_call1(p, x)) return [0, x];
     param$0 = l;
    }
   }
   function find_map(f, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var l = param$0[2], x = param$0[1], result = caml_call1(f, x);
     if(result) return result;
     param$0 = l;
    }
   }
   function find_all(p){
    var accu = 0;
    return function(param$0){
     var accu$0 = accu, param = param$0;
     for(;;){
      if(! param) return rev(accu$0);
      var l = param[2], x = param[1];
      if(caml_call1(p, x)){
       var accu$1 = [0, x, accu$0];
       accu$0 = accu$1;
       param = l;
      }
      else
       param = l;
     }};
   }
   function filteri(p, l){
    var i = 0, acc = 0, param = l;
    for(;;){
     if(! param) return rev(acc);
     var
      l$0 = param[2],
      x = param[1],
      acc$0 = caml_call2(p, i, x) ? [0, x, acc] : acc,
      i$0 = i + 1 | 0;
     i = i$0;
     acc = acc$0;
     param = l$0;
    }
   }
   function filter_map(f){
    var accu = 0;
    return function(param$0){
     var accu$0 = accu, param = param$0;
     for(;;){
      if(! param) return rev(accu$0);
      var l = param[2], x = param[1], match = caml_call1(f, x);
      if(match){
       var v = match[1], accu$1 = [0, v, accu$0];
       accu$0 = accu$1;
       param = l;
      }
      else
       param = l;
     }};
   }
   function concat_map(f, l){
    var acc = 0, param = l;
    for(;;){
     if(! param) return rev(acc);
     var
      l$0 = param[2],
      x = param[1],
      xs = caml_call1(f, x),
      acc$0 = rev_append(xs, acc);
     acc = acc$0;
     param = l$0;
    }
   }
   function fold_left_map(f, accu, l){
    var accu$0 = accu, l_accu = 0, param = l;
    for(;;){
     if(! param) return [0, accu$0, rev(l_accu)];
     var
      l$0 = param[2],
      x = param[1],
      match = caml_call2(f, accu$0, x),
      x$0 = match[2],
      accu$1 = match[1],
      l_accu$0 = [0, x$0, l_accu];
     accu$0 = accu$1;
     l_accu = l_accu$0;
     param = l$0;
    }
   }
   function partition(p, l){
    var yes = 0, no = 0, param = l;
    for(;;){
     if(! param){var _y_ = rev(no); return [0, rev(yes), _y_];}
     var l$0 = param[2], x = param[1];
     if(caml_call1(p, x)){
      var yes$0 = [0, x, yes];
      yes = yes$0;
      param = l$0;
     }
     else{var no$0 = [0, x, no]; no = no$0; param = l$0;}
    }
   }
   function partition_map(p, l){
    var left = 0, right = 0, param = l;
    for(;;){
     if(! param){var _x_ = rev(right); return [0, rev(left), _x_];}
     var l$0 = param[2], x = param[1], match = caml_call1(p, x);
     if(0 === match[0]){
      var v = match[1], left$0 = [0, v, left];
      left = left$0;
      param = l$0;
     }
     else{
      var v$0 = match[1], right$0 = [0, v$0, right];
      right = right$0;
      param = l$0;
     }
    }
   }
   function split(param){
    if(! param) return _b_;
    var
     l = param[2],
     match = param[1],
     y = match[2],
     x = match[1],
     match$0 = split(l),
     ry = match$0[2],
     rx = match$0[1];
    return [0, [0, x, rx], [0, y, ry]];
   }
   function combine(l1, l2){
    if(l1){
     if(l2){
      var l2$0 = l2[2], a2 = l2[1], l1$0 = l1[2], a1 = l1[1];
      return [0, [0, a1, a2], combine(l1$0, l2$0)];
     }
    }
    else if(! l2) return 0;
    return caml_call1(Stdlib[1], cst_List_combine);
   }
   function merge(cmp, l1, l2){
    if(! l1) return l2;
    if(! l2) return l1;
    var t2 = l2[2], h2 = l2[1], t1 = l1[2], h1 = l1[1];
    return 0 < caml_call2(cmp, h1, h2)
            ? [0, h2, merge(cmp, l1, t2)]
            : [0, h1, merge(cmp, t1, l2)];
   }
   function stable_sort(cmp, l){
    function sort(n, l){
     if(2 === n){
      if(l){
       var match = l[2];
       if(match){
        var
         tl = match[2],
         x2 = match[1],
         x1 = l[1],
         s =
           0 < caml_call2(cmp, x1, x2)
            ? [0, x2, [0, x1, 0]]
            : [0, x1, [0, x2, 0]];
        return [0, s, tl];
       }
      }
     }
     else if(3 === n && l){
      var _w_ = l[2];
      if(_w_){
       var match$2 = _w_[2];
       if(match$2){
        var
         tl$1 = match$2[2],
         x3 = match$2[1],
         x2$0 = _w_[1],
         x1$0 = l[1],
         s$0 =
           0 < caml_call2(cmp, x1$0, x2$0)
            ? 0
              < caml_call2(cmp, x1$0, x3)
              ? 0
                < caml_call2(cmp, x2$0, x3)
                ? [0, x3, [0, x2$0, [0, x1$0, 0]]]
                : [0, x2$0, [0, x3, [0, x1$0, 0]]]
              : [0, x2$0, [0, x1$0, [0, x3, 0]]]
            : 0
              < caml_call2(cmp, x2$0, x3)
              ? 0
                < caml_call2(cmp, x1$0, x3)
                ? [0, x3, [0, x1$0, [0, x2$0, 0]]]
                : [0, x1$0, [0, x3, [0, x2$0, 0]]]
              : [0, x1$0, [0, x2$0, [0, x3, 0]]];
        return [0, s$0, tl$1];
       }
      }
     }
     var
      n1 = n >> 1,
      n2 = n - n1 | 0,
      match$0 = rev_sort(n1, l),
      l2$0 = match$0[2],
      s1 = match$0[1],
      match$1 = rev_sort(n2, l2$0),
      tl$0 = match$1[2],
      s2 = match$1[1],
      l1 = s1,
      l2 = s2,
      accu = 0;
     for(;;){
      if(l1){
       if(l2){
        var t2 = l2[2], h2 = l2[1], t1 = l1[2], h1 = l1[1];
        if(0 < caml_call2(cmp, h1, h2)){
         var accu$0 = [0, h1, accu];
         l1 = t1;
         accu = accu$0;
         continue;
        }
        var accu$1 = [0, h2, accu];
        l2 = t2;
        accu = accu$1;
        continue;
       }
       var _v_ = rev_append(l1, accu);
      }
      else
       var _v_ = rev_append(l2, accu);
      return [0, _v_, tl$0];
     }
    }
    function rev_sort(n, l){
     if(2 === n){
      if(l){
       var match = l[2];
       if(match){
        var
         tl = match[2],
         x2 = match[1],
         x1 = l[1],
         s =
           0 < caml_call2(cmp, x1, x2)
            ? [0, x1, [0, x2, 0]]
            : [0, x2, [0, x1, 0]];
        return [0, s, tl];
       }
      }
     }
     else if(3 === n && l){
      var _u_ = l[2];
      if(_u_){
       var match$2 = _u_[2];
       if(match$2){
        var
         tl$1 = match$2[2],
         x3 = match$2[1],
         x2$0 = _u_[1],
         x1$0 = l[1],
         s$0 =
           0 < caml_call2(cmp, x1$0, x2$0)
            ? 0
              < caml_call2(cmp, x2$0, x3)
              ? [0, x1$0, [0, x2$0, [0, x3, 0]]]
              : 0
                < caml_call2(cmp, x1$0, x3)
                ? [0, x1$0, [0, x3, [0, x2$0, 0]]]
                : [0, x3, [0, x1$0, [0, x2$0, 0]]]
            : 0
              < caml_call2(cmp, x1$0, x3)
              ? [0, x2$0, [0, x1$0, [0, x3, 0]]]
              : 0
                < caml_call2(cmp, x2$0, x3)
                ? [0, x2$0, [0, x3, [0, x1$0, 0]]]
                : [0, x3, [0, x2$0, [0, x1$0, 0]]];
        return [0, s$0, tl$1];
       }
      }
     }
     var
      n1 = n >> 1,
      n2 = n - n1 | 0,
      match$0 = sort(n1, l),
      l2$0 = match$0[2],
      s1 = match$0[1],
      match$1 = sort(n2, l2$0),
      tl$0 = match$1[2],
      s2 = match$1[1],
      l1 = s1,
      l2 = s2,
      accu = 0;
     for(;;){
      if(l1){
       if(l2){
        var t2 = l2[2], h2 = l2[1], t1 = l1[2], h1 = l1[1];
        if(0 < caml_call2(cmp, h1, h2)){
         var accu$0 = [0, h2, accu];
         l2 = t2;
         accu = accu$0;
         continue;
        }
        var accu$1 = [0, h1, accu];
        l1 = t1;
        accu = accu$1;
        continue;
       }
       var _t_ = rev_append(l1, accu);
      }
      else
       var _t_ = rev_append(l2, accu);
      return [0, _t_, tl$0];
     }
    }
    var len = length(l);
    return 2 <= len ? sort(len, l)[1] : l;
   }
   function sort_uniq(cmp, l){
    function sort(n, l){
     if(2 === n){
      if(l){
       var match = l[2];
       if(match){
        var
         tl = match[2],
         x2 = match[1],
         x1 = l[1],
         c$0 = caml_call2(cmp, x1, x2),
         s =
           0 === c$0
            ? [0, x1, 0]
            : 0 <= c$0 ? [0, x2, [0, x1, 0]] : [0, x1, [0, x2, 0]];
        return [0, s, tl];
       }
      }
     }
     else if(3 === n && l){
      var _n_ = l[2];
      if(_n_){
       var match$2 = _n_[2];
       if(match$2){
        var
         tl$1 = match$2[2],
         x3 = match$2[1],
         x2$0 = _n_[1],
         x1$0 = l[1],
         c$1 = caml_call2(cmp, x1$0, x2$0);
        if(0 === c$1)
         var
          c$2 = caml_call2(cmp, x2$0, x3),
          _o_ =
            0 === c$2
             ? [0, x2$0, 0]
             : 0 <= c$2 ? [0, x3, [0, x2$0, 0]] : [0, x2$0, [0, x3, 0]],
          s$0 = _o_;
        else if(0 <= c$1){
         var c$3 = caml_call2(cmp, x1$0, x3);
         if(0 === c$3)
          var _p_ = [0, x2$0, [0, x1$0, 0]];
         else if(0 <= c$3)
          var
           c$4 = caml_call2(cmp, x2$0, x3),
           _q_ =
             0 === c$4
              ? [0, x2$0, [0, x1$0, 0]]
              : 0
                <= c$4
                ? [0, x3, [0, x2$0, [0, x1$0, 0]]]
                : [0, x2$0, [0, x3, [0, x1$0, 0]]],
           _p_ = _q_;
         else
          var _p_ = [0, x2$0, [0, x1$0, [0, x3, 0]]];
         var s$0 = _p_;
        }
        else{
         var c$5 = caml_call2(cmp, x2$0, x3);
         if(0 === c$5)
          var _r_ = [0, x1$0, [0, x2$0, 0]];
         else if(0 <= c$5)
          var
           c$6 = caml_call2(cmp, x1$0, x3),
           _s_ =
             0 === c$6
              ? [0, x1$0, [0, x2$0, 0]]
              : 0
                <= c$6
                ? [0, x3, [0, x1$0, [0, x2$0, 0]]]
                : [0, x1$0, [0, x3, [0, x2$0, 0]]],
           _r_ = _s_;
         else
          var _r_ = [0, x1$0, [0, x2$0, [0, x3, 0]]];
         var s$0 = _r_;
        }
        return [0, s$0, tl$1];
       }
      }
     }
     var
      n1 = n >> 1,
      n2 = n - n1 | 0,
      match$0 = rev_sort(n1, l),
      l2$0 = match$0[2],
      s1 = match$0[1],
      match$1 = rev_sort(n2, l2$0),
      tl$0 = match$1[2],
      s2 = match$1[1],
      l1 = s1,
      l2 = s2,
      accu = 0;
     for(;;){
      if(l1){
       if(l2){
        var
         t2 = l2[2],
         h2 = l2[1],
         t1 = l1[2],
         h1 = l1[1],
         c = caml_call2(cmp, h1, h2);
        if(0 === c){
         var accu$0 = [0, h1, accu];
         l1 = t1;
         l2 = t2;
         accu = accu$0;
         continue;
        }
        if(0 < c){
         var accu$1 = [0, h1, accu];
         l1 = t1;
         accu = accu$1;
         continue;
        }
        var accu$2 = [0, h2, accu];
        l2 = t2;
        accu = accu$2;
        continue;
       }
       var _m_ = rev_append(l1, accu);
      }
      else
       var _m_ = rev_append(l2, accu);
      return [0, _m_, tl$0];
     }
    }
    function rev_sort(n, l){
     if(2 === n){
      if(l){
       var match = l[2];
       if(match){
        var
         tl = match[2],
         x2 = match[1],
         x1 = l[1],
         c$0 = caml_call2(cmp, x1, x2),
         s =
           0 === c$0
            ? [0, x1, 0]
            : 0 < c$0 ? [0, x1, [0, x2, 0]] : [0, x2, [0, x1, 0]];
        return [0, s, tl];
       }
      }
     }
     else if(3 === n && l){
      var _g_ = l[2];
      if(_g_){
       var match$2 = _g_[2];
       if(match$2){
        var
         tl$1 = match$2[2],
         x3 = match$2[1],
         x2$0 = _g_[1],
         x1$0 = l[1],
         c$1 = caml_call2(cmp, x1$0, x2$0);
        if(0 === c$1)
         var
          c$2 = caml_call2(cmp, x2$0, x3),
          _h_ =
            0 === c$2
             ? [0, x2$0, 0]
             : 0 < c$2 ? [0, x2$0, [0, x3, 0]] : [0, x3, [0, x2$0, 0]],
          s$0 = _h_;
        else if(0 < c$1){
         var c$3 = caml_call2(cmp, x2$0, x3);
         if(0 === c$3)
          var _i_ = [0, x1$0, [0, x2$0, 0]];
         else if(0 < c$3)
          var _i_ = [0, x1$0, [0, x2$0, [0, x3, 0]]];
         else
          var
           c$4 = caml_call2(cmp, x1$0, x3),
           _j_ =
             0 === c$4
              ? [0, x1$0, [0, x2$0, 0]]
              : 0
                < c$4
                ? [0, x1$0, [0, x3, [0, x2$0, 0]]]
                : [0, x3, [0, x1$0, [0, x2$0, 0]]],
           _i_ = _j_;
         var s$0 = _i_;
        }
        else{
         var c$5 = caml_call2(cmp, x1$0, x3);
         if(0 === c$5)
          var _k_ = [0, x2$0, [0, x1$0, 0]];
         else if(0 < c$5)
          var _k_ = [0, x2$0, [0, x1$0, [0, x3, 0]]];
         else
          var
           c$6 = caml_call2(cmp, x2$0, x3),
           _l_ =
             0 === c$6
              ? [0, x2$0, [0, x1$0, 0]]
              : 0
                < c$6
                ? [0, x2$0, [0, x3, [0, x1$0, 0]]]
                : [0, x3, [0, x2$0, [0, x1$0, 0]]],
           _k_ = _l_;
         var s$0 = _k_;
        }
        return [0, s$0, tl$1];
       }
      }
     }
     var
      n1 = n >> 1,
      n2 = n - n1 | 0,
      match$0 = sort(n1, l),
      l2$0 = match$0[2],
      s1 = match$0[1],
      match$1 = sort(n2, l2$0),
      tl$0 = match$1[2],
      s2 = match$1[1],
      l1 = s1,
      l2 = s2,
      accu = 0;
     for(;;){
      if(l1){
       if(l2){
        var
         t2 = l2[2],
         h2 = l2[1],
         t1 = l1[2],
         h1 = l1[1],
         c = caml_call2(cmp, h1, h2);
        if(0 === c){
         var accu$0 = [0, h1, accu];
         l1 = t1;
         l2 = t2;
         accu = accu$0;
         continue;
        }
        if(0 <= c){
         var accu$1 = [0, h2, accu];
         l2 = t2;
         accu = accu$1;
         continue;
        }
        var accu$2 = [0, h1, accu];
        l1 = t1;
        accu = accu$2;
        continue;
       }
       var _f_ = rev_append(l1, accu);
      }
      else
       var _f_ = rev_append(l2, accu);
      return [0, _f_, tl$0];
     }
    }
    var len = length(l);
    return 2 <= len ? sort(len, l)[1] : l;
   }
   function compare_lengths(l1, l2){
    var l1$0 = l1, l2$0 = l2;
    for(;;){
     if(! l1$0) return l2$0 ? -1 : 0;
     if(! l2$0) return 1;
     var l2$1 = l2$0[2], l1$1 = l1$0[2];
     l1$0 = l1$1;
     l2$0 = l2$1;
    }
   }
   function compare_length_with(l, n){
    var l$0 = l, n$0 = n;
    for(;;){
     if(! l$0) return 0 === n$0 ? 0 : 0 < n$0 ? -1 : 1;
     var l$1 = l$0[2];
     if(0 >= n$0) return 1;
     var n$1 = n$0 - 1 | 0;
     l$0 = l$1;
     n$0 = n$1;
    }
   }
   function equal(eq, l1, l2){
    var l1$0 = l1, l2$0 = l2;
    for(;;){
     if(l1$0){
      if(l2$0){
       var
        l2$1 = l2$0[2],
        a2 = l2$0[1],
        l1$1 = l1$0[2],
        a1 = l1$0[1],
        _e_ = caml_call2(eq, a1, a2);
       if(! _e_) return _e_;
       l1$0 = l1$1;
       l2$0 = l2$1;
       continue;
      }
     }
     else if(! l2$0) return 1;
     return 0;
    }
   }
   function compare(cmp, l1, l2){
    var l1$0 = l1, l2$0 = l2;
    for(;;){
     if(! l1$0) return l2$0 ? -1 : 0;
     var l1$1 = l1$0[2], a1 = l1$0[1];
     if(! l2$0) return 1;
     var l2$1 = l2$0[2], a2 = l2$0[1], c = caml_call2(cmp, a1, a2);
     if(0 !== c) return c;
     l1$0 = l1$1;
     l2$0 = l2$1;
    }
   }
   function to_seq(l){
    function aux(l, param){
     if(! l) return 0;
     var tail = l[2], x = l[1];
     return [0, x, function(_d_){return aux(tail, _d_);}];
    }
    return function(_c_){return aux(l, _c_);};
   }
   function of_seq(seq){
    function direct(depth, seq){
     if(0 === depth)
      return rev
              (caml_call3
                (Stdlib_Seq[5], function(acc, x){return [0, x, acc];}, 0, seq));
     var match = caml_call1(seq, 0);
     if(! match) return 0;
     var next = match[2], x = match[1];
     return [0, x, direct(depth - 1 | 0, next)];
    }
    return direct(500, seq);
   }
   var
    Stdlib_List =
      [0,
       length,
       compare_lengths,
       compare_length_with,
       cons,
       hd,
       tl,
       nth,
       nth_opt,
       rev,
       init,
       append,
       rev_append,
       flatten,
       flatten,
       equal,
       compare,
       iter,
       iteri,
       map,
       mapi,
       rev_map,
       filter_map,
       concat_map,
       fold_left_map,
       fold_left,
       fold_right,
       iter2,
       map2,
       rev_map2,
       fold_left2,
       fold_right2,
       for_all,
       exists,
       for_all2,
       exists2,
       mem,
       memq,
       find,
       find_opt,
       find_map,
       find_all,
       find_all,
       filteri,
       partition,
       partition_map,
       assoc,
       assoc_opt,
       assq,
       assq_opt,
       mem_assoc,
       mem_assq,
       remove_assoc,
       remove_assq,
       split,
       combine,
       stable_sort,
       stable_sort,
       stable_sort,
       sort_uniq,
       merge,
       to_seq,
       of_seq];
   runtime.caml_register_global(18, Stdlib_List, "Stdlib__List");
   return;
  }
  (globalThis));

//# 3709 "../.js/default/stdlib/stdlib.cma.js"
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function abs(x){return 0 <= x ? x : - x | 0;}
   function lognot(x){return x ^ -1;}
   function equal(_b_, _a_){return _b_ === _a_ ? 1 : 0;}
   var compare = runtime.caml_int_compare;
   function min(x, y){return x <= y ? x : y;}
   function max(x, y){return y <= x ? x : y;}
   function to_string(x){return "" + x;}
   var
    Stdlib_Int =
      [0,
       0,
       1,
       -1,
       abs,
       2147483647,
       -2147483648,
       lognot,
       equal,
       compare,
       min,
       max,
       to_string];
   runtime.caml_register_global(1, Stdlib_Int, "Stdlib__Int");
   return;
  }
  (globalThis));

//# 3741 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_bytes_ml = "bytes.ml",
    cst_index_out_of_bounds$3 = "index out of bounds",
    caml_blit_bytes = runtime.caml_blit_bytes,
    caml_bswap16 = runtime.caml_bswap16,
    caml_bytes_get = runtime.caml_bytes_get,
    caml_bytes_get16 = runtime.caml_bytes_get16,
    caml_bytes_get32 = runtime.caml_bytes_get32,
    caml_bytes_get64 = runtime.caml_bytes_get64,
    caml_bytes_of_string = runtime.caml_bytes_of_string,
    caml_bytes_set = runtime.caml_bytes_set,
    caml_bytes_set16 = runtime.caml_bytes_set16,
    caml_bytes_set32 = runtime.caml_bytes_set32,
    caml_bytes_set64 = runtime.caml_bytes_set64,
    caml_bytes_unsafe_get = runtime.caml_bytes_unsafe_get,
    caml_bytes_unsafe_set = runtime.caml_bytes_unsafe_set,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_fill_bytes = runtime.caml_fill_bytes,
    caml_int32_bswap = runtime.caml_int32_bswap,
    caml_int64_bswap = runtime.caml_int64_bswap,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_bytes_length = runtime.caml_ml_bytes_length,
    caml_string_of_bytes = runtime.caml_string_of_bytes,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Stdlib_Uchar = global_data.Stdlib__Uchar,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Sys = global_data.Stdlib__Sys,
    Stdlib_Int = global_data.Stdlib__Int,
    Stdlib_Seq = global_data.Stdlib__Seq,
    Stdlib_Char = global_data.Stdlib__Char;
   function make(n, c){
    var s = caml_create_bytes(n);
    caml_fill_bytes(s, 0, n, c);
    return s;
   }
   function init(n, f){
    var s = caml_create_bytes(n), _ap_ = n - 1 | 0, _ao_ = 0;
    if(_ap_ >= 0){
     var i = _ao_;
     for(;;){
      caml_bytes_unsafe_set(s, i, caml_call1(f, i));
      var _aq_ = i + 1 | 0;
      if(_ap_ === i) break;
      i = _aq_;
     }
    }
    return s;
   }
   var
    empty = caml_create_bytes(0),
    cst_String_sub_Bytes_sub = "String.sub / Bytes.sub",
    cst_Bytes_extend = "Bytes.extend",
    cst_String_fill_Bytes_fill = "String.fill / Bytes.fill",
    cst_Bytes_blit = "Bytes.blit",
    cst_String_blit_Bytes_blit_str = "String.blit / Bytes.blit_string",
    cst_Bytes_concat = "Bytes.concat",
    cst_String_index_from_Bytes_in = "String.index_from / Bytes.index_from",
    cst_String_index_from_opt_Byte =
      "String.index_from_opt / Bytes.index_from_opt",
    cst_String_rindex_from_Bytes_r = "String.rindex_from / Bytes.rindex_from",
    cst_String_rindex_from_opt_Byt =
      "String.rindex_from_opt / Bytes.rindex_from_opt",
    cst_String_contains_from_Bytes =
      "String.contains_from / Bytes.contains_from",
    cst_String_rcontains_from_Byte =
      "String.rcontains_from / Bytes.rcontains_from";
   function copy(s){
    var len = caml_ml_bytes_length(s), r = caml_create_bytes(len);
    caml_blit_bytes(s, 0, r, 0, len);
    return r;
   }
   function to_string(b){return caml_string_of_bytes(copy(b));}
   function of_string(s){return copy(caml_bytes_of_string(s));}
   function sub(s, ofs, len){
    if(0 <= ofs && 0 <= len && (caml_ml_bytes_length(s) - len | 0) >= ofs){
     var r = caml_create_bytes(len);
     caml_blit_bytes(s, ofs, r, 0, len);
     return r;
    }
    return caml_call1(Stdlib[1], cst_String_sub_Bytes_sub);
   }
   function sub_string(b, ofs, len){
    return caml_string_of_bytes(sub(b, ofs, len));
   }
   function symbol(a, b){
    var c = a + b | 0, _an_ = b < 0 ? 1 : 0, match = c < 0 ? 1 : 0;
    a:
    {
     if(a < 0){if(_an_ && ! match) break a;} else if(! _an_ && match) break a;
     return c;
    }
    return caml_call1(Stdlib[1], cst_Bytes_extend);
   }
   function extend(s, left, right){
    var
     len = symbol(symbol(caml_ml_bytes_length(s), left), right),
     r = caml_create_bytes(len);
    if(0 <= left)
     var dstoff = left, srcoff = 0;
    else
     var dstoff = 0, srcoff = - left | 0;
    var
     cpylen =
       caml_call2
        (Stdlib_Int[10],
         caml_ml_bytes_length(s) - srcoff | 0,
         len - dstoff | 0);
    if(0 < cpylen) caml_blit_bytes(s, srcoff, r, dstoff, cpylen);
    return r;
   }
   function fill(s, ofs, len, c){
    if(0 <= ofs && 0 <= len && (caml_ml_bytes_length(s) - len | 0) >= ofs)
     return caml_fill_bytes(s, ofs, len, c);
    return caml_call1(Stdlib[1], cst_String_fill_Bytes_fill);
   }
   function blit(s1, ofs1, s2, ofs2, len){
    if
     (0 <= len
      &&
       0 <= ofs1
       &&
        (caml_ml_bytes_length(s1) - len | 0) >= ofs1
        && 0 <= ofs2 && (caml_ml_bytes_length(s2) - len | 0) >= ofs2)
     return caml_blit_bytes(s1, ofs1, s2, ofs2, len);
    return caml_call1(Stdlib[1], cst_Bytes_blit);
   }
   function blit_string(s1, ofs1, s2, ofs2, len){
    if
     (0 <= len
      &&
       0 <= ofs1
       &&
        (runtime.caml_ml_string_length(s1) - len | 0) >= ofs1
        && 0 <= ofs2 && (caml_ml_bytes_length(s2) - len | 0) >= ofs2)
     return runtime.caml_blit_string(s1, ofs1, s2, ofs2, len);
    return caml_call1(Stdlib[1], cst_String_blit_Bytes_blit_str);
   }
   function iter(f, a){
    var _al_ = caml_ml_bytes_length(a) - 1 | 0, _ak_ = 0;
    if(_al_ >= 0){
     var i = _ak_;
     for(;;){
      caml_call1(f, caml_bytes_unsafe_get(a, i));
      var _am_ = i + 1 | 0;
      if(_al_ === i) break;
      i = _am_;
     }
    }
    return 0;
   }
   function iteri(f, a){
    var _ai_ = caml_ml_bytes_length(a) - 1 | 0, _ah_ = 0;
    if(_ai_ >= 0){
     var i = _ah_;
     for(;;){
      caml_call2(f, i, caml_bytes_unsafe_get(a, i));
      var _aj_ = i + 1 | 0;
      if(_ai_ === i) break;
      i = _aj_;
     }
    }
    return 0;
   }
   function concat(sep, l){
    if(! l) return empty;
    var seplen = caml_ml_bytes_length(sep);
    a:
    {
     b:
     {
      var acc = 0, param = l, pos$1 = 0;
      for(;;){
       if(! param) break;
       var hd = param[1];
       if(! param[2]) break b;
       var
        tl = param[2],
        x = (caml_ml_bytes_length(hd) + seplen | 0) + acc | 0,
        acc$0 = acc <= x ? x : caml_call1(Stdlib[1], cst_Bytes_concat);
       acc = acc$0;
       param = tl;
      }
      var _ag_ = acc;
      break a;
     }
     var _ag_ = caml_ml_bytes_length(hd) + acc | 0;
    }
    var dst = caml_create_bytes(_ag_), pos = pos$1, param$0 = l;
    for(;;){
     if(! param$0) return dst;
     var hd$0 = param$0[1];
     if(! param$0[2]){
      caml_blit_bytes(hd$0, 0, dst, pos, caml_ml_bytes_length(hd$0));
      return dst;
     }
     var tl$0 = param$0[2];
     caml_blit_bytes(hd$0, 0, dst, pos, caml_ml_bytes_length(hd$0));
     caml_blit_bytes
      (sep, 0, dst, pos + caml_ml_bytes_length(hd$0) | 0, seplen);
     var pos$0 = (pos + caml_ml_bytes_length(hd$0) | 0) + seplen | 0;
     pos = pos$0;
     param$0 = tl$0;
    }
   }
   function cat(s1, s2){
    var
     l1 = caml_ml_bytes_length(s1),
     l2 = caml_ml_bytes_length(s2),
     r = caml_create_bytes(l1 + l2 | 0);
    caml_blit_bytes(s1, 0, r, 0, l1);
    caml_blit_bytes(s2, 0, r, l1, l2);
    return r;
   }
   function is_space(param){
    var _af_ = param - 9 | 0;
    a:
    {
     if(4 < _af_ >>> 0){if(23 !== _af_) break a;} else if(2 === _af_) break a;
     return 1;
    }
    return 0;
   }
   function trim(s){
    var len = caml_ml_bytes_length(s), i = [0, 0];
    for(;;){
     if(i[1] >= len) break;
     if(! is_space(caml_bytes_unsafe_get(s, i[1]))) break;
     i[1]++;
    }
    var j = [0, len - 1 | 0];
    for(;;){
     if(i[1] <= j[1] && is_space(caml_bytes_unsafe_get(s, j[1]))){j[1]--; continue;}
     return i[1] <= j[1] ? sub(s, i[1], (j[1] - i[1] | 0) + 1 | 0) : empty;
    }
   }
   function escaped(s){
    var n = [0, 0], ___ = caml_ml_bytes_length(s) - 1 | 0, _Z_ = 0;
    if(___ >= 0){
     var i$0 = _Z_;
     for(;;){
      var match = caml_bytes_unsafe_get(s, i$0);
      a:
      {
       b:
       {
        c:
        {
         if(32 <= match){
          var _ac_ = match - 34 | 0;
          if(58 < _ac_ >>> 0){
           if(93 <= _ac_) break c;
          }
          else if(56 < _ac_ - 1 >>> 0) break b;
          var _ad_ = 1;
          break a;
         }
         if(11 <= match){
          if(13 === match) break b;
         }
         else if(8 <= match) break b;
        }
        var _ad_ = 4;
        break a;
       }
       var _ad_ = 2;
      }
      n[1] = n[1] + _ad_ | 0;
      var _ae_ = i$0 + 1 | 0;
      if(___ === i$0) break;
      i$0 = _ae_;
     }
    }
    if(n[1] === caml_ml_bytes_length(s)) return copy(s);
    var s$0 = caml_create_bytes(n[1]);
    n[1] = 0;
    var _aa_ = caml_ml_bytes_length(s) - 1 | 0, _$_ = 0;
    if(_aa_ >= 0){
     var i = _$_;
     for(;;){
      var c = caml_bytes_unsafe_get(s, i);
      a:
      {
       b:
       {
        c:
        {
         if(35 <= c){
          if(92 !== c){if(127 <= c) break c; break b;}
         }
         else{
          if(32 > c){
           if(14 <= c) break c;
           switch(c){
             case 8:
              caml_bytes_unsafe_set(s$0, n[1], 92);
              n[1]++;
              caml_bytes_unsafe_set(s$0, n[1], 98);
              break a;
             case 9:
              caml_bytes_unsafe_set(s$0, n[1], 92);
              n[1]++;
              caml_bytes_unsafe_set(s$0, n[1], 116);
              break a;
             case 10:
              caml_bytes_unsafe_set(s$0, n[1], 92);
              n[1]++;
              caml_bytes_unsafe_set(s$0, n[1], 110);
              break a;
             case 13:
              caml_bytes_unsafe_set(s$0, n[1], 92);
              n[1]++;
              caml_bytes_unsafe_set(s$0, n[1], 114);
              break a;
             default: break c;
           }
          }
          if(34 > c) break b;
         }
         caml_bytes_unsafe_set(s$0, n[1], 92);
         n[1]++;
         caml_bytes_unsafe_set(s$0, n[1], c);
         break a;
        }
        caml_bytes_unsafe_set(s$0, n[1], 92);
        n[1]++;
        caml_bytes_unsafe_set(s$0, n[1], 48 + (c / 100 | 0) | 0);
        n[1]++;
        caml_bytes_unsafe_set(s$0, n[1], 48 + ((c / 10 | 0) % 10 | 0) | 0);
        n[1]++;
        caml_bytes_unsafe_set(s$0, n[1], 48 + (c % 10 | 0) | 0);
        break a;
       }
       caml_bytes_unsafe_set(s$0, n[1], c);
      }
      n[1]++;
      var _ab_ = i + 1 | 0;
      if(_aa_ === i) break;
      i = _ab_;
     }
    }
    return s$0;
   }
   function map(f, s){
    var l = caml_ml_bytes_length(s);
    if(0 === l) return s;
    var r = caml_create_bytes(l), _X_ = l - 1 | 0, _W_ = 0;
    if(_X_ >= 0){
     var i = _W_;
     for(;;){
      caml_bytes_unsafe_set(r, i, caml_call1(f, caml_bytes_unsafe_get(s, i)));
      var _Y_ = i + 1 | 0;
      if(_X_ === i) break;
      i = _Y_;
     }
    }
    return r;
   }
   function mapi(f, s){
    var l = caml_ml_bytes_length(s);
    if(0 === l) return s;
    var r = caml_create_bytes(l), _U_ = l - 1 | 0, _T_ = 0;
    if(_U_ >= 0){
     var i = _T_;
     for(;;){
      caml_bytes_unsafe_set
       (r, i, caml_call2(f, i, caml_bytes_unsafe_get(s, i)));
      var _V_ = i + 1 | 0;
      if(_U_ === i) break;
      i = _V_;
     }
    }
    return r;
   }
   function fold_left(f, x, a){
    var r = [0, x], _R_ = caml_ml_bytes_length(a) - 1 | 0, _Q_ = 0;
    if(_R_ >= 0){
     var i = _Q_;
     for(;;){
      r[1] = caml_call2(f, r[1], caml_bytes_unsafe_get(a, i));
      var _S_ = i + 1 | 0;
      if(_R_ === i) break;
      i = _S_;
     }
    }
    return r[1];
   }
   function fold_right(f, a, x){
    var r = [0, x], _O_ = caml_ml_bytes_length(a) - 1 | 0;
    if(_O_ >= 0){
     var i = _O_;
     for(;;){
      r[1] = caml_call2(f, caml_bytes_unsafe_get(a, i), r[1]);
      var _P_ = i - 1 | 0;
      if(0 === i) break;
      i = _P_;
     }
    }
    return r[1];
   }
   function exists(p, s){
    var n = caml_ml_bytes_length(s), i = 0;
    for(;;){
     if(i === n) return 0;
     if(caml_call1(p, caml_bytes_unsafe_get(s, i))) return 1;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function for_all(p, s){
    var n = caml_ml_bytes_length(s), i = 0;
    for(;;){
     if(i === n) return 1;
     if(! caml_call1(p, caml_bytes_unsafe_get(s, i))) return 0;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function uppercase_ascii(s){return map(Stdlib_Char[6], s);}
   function lowercase_ascii(s){return map(Stdlib_Char[5], s);}
   function apply1(f, s){
    if(0 === caml_ml_bytes_length(s)) return s;
    var r = copy(s);
    caml_bytes_unsafe_set(r, 0, caml_call1(f, caml_bytes_unsafe_get(s, 0)));
    return r;
   }
   function capitalize_ascii(s){return apply1(Stdlib_Char[6], s);}
   function uncapitalize_ascii(s){return apply1(Stdlib_Char[5], s);}
   function starts_with(prefix, s){
    var
     len_s = caml_ml_bytes_length(s),
     len_pre = caml_ml_bytes_length(prefix),
     _N_ = len_pre <= len_s ? 1 : 0;
    if(! _N_) return _N_;
    var i = 0;
    for(;;){
     if(i === len_pre) return 1;
     if(caml_bytes_unsafe_get(s, i) !== caml_bytes_unsafe_get(prefix, i))
      return 0;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function ends_with(suffix, s){
    var
     len_s = caml_ml_bytes_length(s),
     len_suf = caml_ml_bytes_length(suffix),
     diff = len_s - len_suf | 0,
     _M_ = 0 <= diff ? 1 : 0;
    if(! _M_) return _M_;
    var i = 0;
    for(;;){
     if(i === len_suf) return 1;
     if
      (caml_bytes_unsafe_get(s, diff + i | 0)
       !== caml_bytes_unsafe_get(suffix, i))
      return 0;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function index_rec(s, lim, i, c){
    var i$0 = i;
    for(;;){
     if(lim <= i$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     if(caml_bytes_unsafe_get(s, i$0) === c) return i$0;
     var i$1 = i$0 + 1 | 0;
     i$0 = i$1;
    }
   }
   function index(s, c){return index_rec(s, caml_ml_bytes_length(s), 0, c);}
   function index_rec_opt(s, lim, i, c){
    var i$0 = i;
    for(;;){
     if(lim <= i$0) return 0;
     if(caml_bytes_unsafe_get(s, i$0) === c) return [0, i$0];
     var i$1 = i$0 + 1 | 0;
     i$0 = i$1;
    }
   }
   function index_opt(s, c){
    return index_rec_opt(s, caml_ml_bytes_length(s), 0, c);
   }
   function index_from(s, i, c){
    var l = caml_ml_bytes_length(s);
    if(0 <= i && l >= i) return index_rec(s, l, i, c);
    return caml_call1(Stdlib[1], cst_String_index_from_Bytes_in);
   }
   function index_from_opt(s, i, c){
    var l = caml_ml_bytes_length(s);
    if(0 <= i && l >= i) return index_rec_opt(s, l, i, c);
    return caml_call1(Stdlib[1], cst_String_index_from_opt_Byte);
   }
   function rindex_rec(s, i, c){
    var i$0 = i;
    for(;;){
     if(0 > i$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     if(caml_bytes_unsafe_get(s, i$0) === c) return i$0;
     var i$1 = i$0 - 1 | 0;
     i$0 = i$1;
    }
   }
   function rindex(s, c){
    return rindex_rec(s, caml_ml_bytes_length(s) - 1 | 0, c);
   }
   function rindex_from(s, i, c){
    if(-1 <= i && caml_ml_bytes_length(s) > i) return rindex_rec(s, i, c);
    return caml_call1(Stdlib[1], cst_String_rindex_from_Bytes_r);
   }
   function rindex_rec_opt(s, i, c){
    var i$0 = i;
    for(;;){
     if(0 > i$0) return 0;
     if(caml_bytes_unsafe_get(s, i$0) === c) return [0, i$0];
     var i$1 = i$0 - 1 | 0;
     i$0 = i$1;
    }
   }
   function rindex_opt(s, c){
    return rindex_rec_opt(s, caml_ml_bytes_length(s) - 1 | 0, c);
   }
   function rindex_from_opt(s, i, c){
    if(-1 <= i && caml_ml_bytes_length(s) > i) return rindex_rec_opt(s, i, c);
    return caml_call1(Stdlib[1], cst_String_rindex_from_opt_Byt);
   }
   function contains_from(s, i, c){
    var l = caml_ml_bytes_length(s);
    if(0 <= i && l >= i)
     try{index_rec(s, l, i, c); var _K_ = 1; return _K_;}
     catch(_L_){
      var _J_ = caml_wrap_exception(_L_);
      if(_J_ === Stdlib[8]) return 0;
      throw caml_maybe_attach_backtrace(_J_, 0);
     }
    return caml_call1(Stdlib[1], cst_String_contains_from_Bytes);
   }
   function contains(s, c){return contains_from(s, 0, c);}
   function rcontains_from(s, i, c){
    if(0 <= i && caml_ml_bytes_length(s) > i)
     try{rindex_rec(s, i, c); var _H_ = 1; return _H_;}
     catch(_I_){
      var _G_ = caml_wrap_exception(_I_);
      if(_G_ === Stdlib[8]) return 0;
      throw caml_maybe_attach_backtrace(_G_, 0);
     }
    return caml_call1(Stdlib[1], cst_String_rcontains_from_Byte);
   }
   var
    compare = runtime.caml_bytes_compare,
    cst_Bytes_of_seq_cannot_grow_b = "Bytes.of_seq: cannot grow bytes";
   function split_on_char(sep, s){
    var
     r = [0, 0],
     j = [0, caml_ml_bytes_length(s)],
     _C_ = caml_ml_bytes_length(s) - 1 | 0;
    if(_C_ >= 0){
     var i = _C_;
     for(;;){
      if(caml_bytes_unsafe_get(s, i) === sep){
       var _E_ = r[1];
       r[1] = [0, sub(s, i + 1 | 0, (j[1] - i | 0) - 1 | 0), _E_];
       j[1] = i;
      }
      var _F_ = i - 1 | 0;
      if(0 === i) break;
      i = _F_;
     }
    }
    var _D_ = r[1];
    return [0, sub(s, 0, j[1]), _D_];
   }
   function uppercase(s){return map(Stdlib_Char[4], s);}
   function lowercase(s){return map(Stdlib_Char[3], s);}
   function capitalize(s){return apply1(Stdlib_Char[4], s);}
   function uncapitalize(s){return apply1(Stdlib_Char[3], s);}
   function to_seq(s){
    function aux(i, param){
     if(i === caml_ml_bytes_length(s)) return 0;
     var x = caml_bytes_get(s, i), _A_ = i + 1 | 0;
     return [0, x, function(_B_){return aux(_A_, _B_);}];
    }
    var _y_ = 0;
    return function(_z_){return aux(_y_, _z_);};
   }
   function to_seqi(s){
    function aux(i, param){
     if(i === caml_ml_bytes_length(s)) return 0;
     var x = caml_bytes_get(s, i), _w_ = i + 1 | 0;
     return [0, [0, i, x], function(_x_){return aux(_w_, _x_);}];
    }
    var _u_ = 0;
    return function(_v_){return aux(_u_, _v_);};
   }
   function of_seq(i){
    var n = [0, 0], buf = [0, make(256, 0)];
    caml_call2
     (Stdlib_Seq[4],
      function(c){
       if(n[1] === caml_ml_bytes_length(buf[1])){
        var
         new_len =
           caml_call2
            (Stdlib_Int[10],
             2 * caml_ml_bytes_length(buf[1]) | 0,
             Stdlib_Sys[12]);
        if(caml_ml_bytes_length(buf[1]) === new_len)
         caml_call1(Stdlib[2], cst_Bytes_of_seq_cannot_grow_b);
        var new_buf = make(new_len, 0);
        blit(buf[1], 0, new_buf, 0, n[1]);
        buf[1] = new_buf;
       }
       caml_bytes_set(buf[1], n[1], c);
       n[1]++;
       return 0;
      },
      i);
    return sub(buf[1], 0, n[1]);
   }
   function unsafe_get_uint16_le(b, i){
    return Stdlib_Sys[11]
            ? caml_bswap16(caml_bytes_get16(b, i))
            : caml_bytes_get16(b, i);
   }
   function unsafe_get_uint16_be(b, i){
    return Stdlib_Sys[11]
            ? caml_bytes_get16(b, i)
            : caml_bswap16(caml_bytes_get16(b, i));
   }
   function get_int8(b, i){
    var _s_ = Stdlib_Sys[10] - 8 | 0, _t_ = Stdlib_Sys[10] - 8 | 0;
    return caml_bytes_get(b, i) << _t_ >> _s_;
   }
   function get_uint16_le(b, i){
    return Stdlib_Sys[11]
            ? caml_bswap16(caml_bytes_get16(b, i))
            : caml_bytes_get16(b, i);
   }
   function get_uint16_be(b, i){
    return Stdlib_Sys[11]
            ? caml_bytes_get16(b, i)
            : caml_bswap16(caml_bytes_get16(b, i));
   }
   function get_int16_ne(b, i){
    var _q_ = Stdlib_Sys[10] - 16 | 0, _r_ = Stdlib_Sys[10] - 16 | 0;
    return caml_bytes_get16(b, i) << _r_ >> _q_;
   }
   function get_int16_le(b, i){
    var _o_ = Stdlib_Sys[10] - 16 | 0, _p_ = Stdlib_Sys[10] - 16 | 0;
    return get_uint16_le(b, i) << _p_ >> _o_;
   }
   function get_int16_be(b, i){
    var _m_ = Stdlib_Sys[10] - 16 | 0, _n_ = Stdlib_Sys[10] - 16 | 0;
    return get_uint16_be(b, i) << _n_ >> _m_;
   }
   function get_int32_le(b, i){
    return Stdlib_Sys[11]
            ? caml_int32_bswap(caml_bytes_get32(b, i))
            : caml_bytes_get32(b, i);
   }
   function get_int32_be(b, i){
    return Stdlib_Sys[11]
            ? caml_bytes_get32(b, i)
            : caml_int32_bswap(caml_bytes_get32(b, i));
   }
   function get_int64_le(b, i){
    return Stdlib_Sys[11]
            ? caml_int64_bswap(caml_bytes_get64(b, i))
            : caml_bytes_get64(b, i);
   }
   function get_int64_be(b, i){
    return Stdlib_Sys[11]
            ? caml_bytes_get64(b, i)
            : caml_int64_bswap(caml_bytes_get64(b, i));
   }
   function unsafe_set_uint16_le(b, i, x){
    if(Stdlib_Sys[11]){caml_bytes_set16(b, i, caml_bswap16(x)); return;}
    caml_bytes_set16(b, i, x);
    return;
   }
   function unsafe_set_uint16_be(b, i, x){
    if(Stdlib_Sys[11]){caml_bytes_set16(b, i, x); return;}
    caml_bytes_set16(b, i, caml_bswap16(x));
    return;
   }
   function set_int16_le(b, i, x){
    return Stdlib_Sys[11]
            ? caml_bytes_set16(b, i, caml_bswap16(x))
            : caml_bytes_set16(b, i, x);
   }
   function set_int16_be(b, i, x){
    return Stdlib_Sys[11]
            ? caml_bytes_set16(b, i, x)
            : caml_bytes_set16(b, i, caml_bswap16(x));
   }
   function set_int32_le(b, i, x){
    return Stdlib_Sys[11]
            ? caml_bytes_set32(b, i, caml_int32_bswap(x))
            : caml_bytes_set32(b, i, x);
   }
   function set_int32_be(b, i, x){
    return Stdlib_Sys[11]
            ? caml_bytes_set32(b, i, x)
            : caml_bytes_set32(b, i, caml_int32_bswap(x));
   }
   function set_int64_le(b, i, x){
    return Stdlib_Sys[11]
            ? caml_bytes_set64(b, i, caml_int64_bswap(x))
            : caml_bytes_set64(b, i, x);
   }
   function set_int64_be(b, i, x){
    return Stdlib_Sys[11]
            ? caml_bytes_set64(b, i, x)
            : caml_bytes_set64(b, i, caml_int64_bswap(x));
   }
   var
    set_uint8 = caml_bytes_set,
    set_uint16_ne = caml_bytes_set16,
    dec_invalid = Stdlib_Uchar[22],
    _a_ = [0, cst_bytes_ml, 667, 9],
    _b_ = [0, cst_bytes_ml, 642, 20],
    cst_index_out_of_bounds = cst_index_out_of_bounds$3,
    cst_index_out_of_bounds$0 = cst_index_out_of_bounds$3,
    _c_ = [0, cst_bytes_ml, 765, 9],
    _d_ = [0, cst_bytes_ml, 754, 20],
    cst_index_out_of_bounds$1 = cst_index_out_of_bounds$3,
    cst_index_out_of_bounds$2 = cst_index_out_of_bounds$3,
    _e_ = [0, cst_bytes_ml, 819, 9],
    _f_ = [0, cst_bytes_ml, 808, 20];
   function dec_ret(n, u){
    var _l_ = caml_call1(Stdlib_Uchar[9], u);
    return caml_call2(Stdlib_Uchar[21], n, _l_);
   }
   function not_in_x80_to_xBF(b){return 2 !== (b >>> 6 | 0) ? 1 : 0;}
   function not_in_xA0_to_xBF(b){return 5 !== (b >>> 5 | 0) ? 1 : 0;}
   function not_in_x80_to_x9F(b){return 4 !== (b >>> 5 | 0) ? 1 : 0;}
   function not_in_x90_to_xBF(b){
    var _j_ = b < 144 ? 1 : 0, _k_ = _j_ || (191 < b ? 1 : 0);
    return _k_;
   }
   function not_in_x80_to_x8F(b){return 8 !== (b >>> 4 | 0) ? 1 : 0;}
   function utf_8_uchar_3(b0, b1, b2){
    return (b0 & 15) << 12 | (b1 & 63) << 6 | b2 & 63;
   }
   function utf_8_uchar_4(b0, b1, b2, b3){
    return (b0 & 7) << 18 | (b1 & 63) << 12 | (b2 & 63) << 6 | b3 & 63;
   }
   function get_utf_8_uchar(b, i){
    var b0 = caml_bytes_get(b, i), max = caml_ml_bytes_length(b) - 1 | 0;
    a:
    {
     if(224 <= b0){
      if(237 <= b0){
       if(245 <= b0) break a;
       switch(b0 - 237 | 0){
         case 0:
          var i$0 = i + 1 | 0;
          if(max < i$0) return caml_call1(dec_invalid, 1);
          var b1$4 = caml_bytes_unsafe_get(b, i$0);
          if(not_in_x80_to_x9F(b1$4)) return caml_call1(dec_invalid, 1);
          var i$1 = i$0 + 1 | 0;
          if(max < i$1) return caml_call1(dec_invalid, 2);
          var b2$3 = caml_bytes_unsafe_get(b, i$1);
          return not_in_x80_to_xBF(b2$3)
                  ? caml_call1(dec_invalid, 2)
                  : dec_ret(3, utf_8_uchar_3(b0, b1$4, b2$3));
         case 3:
          var i$4 = i + 1 | 0;
          if(max < i$4) return caml_call1(dec_invalid, 1);
          var b1$2 = caml_bytes_unsafe_get(b, i$4);
          if(not_in_x90_to_xBF(b1$2)) return caml_call1(dec_invalid, 1);
          var i$5 = i$4 + 1 | 0;
          if(max < i$5) return caml_call1(dec_invalid, 2);
          var b2$1 = caml_bytes_unsafe_get(b, i$5);
          if(not_in_x80_to_xBF(b2$1)) return caml_call1(dec_invalid, 2);
          var i$6 = i$5 + 1 | 0;
          if(max < i$6) return caml_call1(dec_invalid, 3);
          var b3$1 = caml_bytes_unsafe_get(b, i$6);
          return not_in_x80_to_xBF(b3$1)
                  ? caml_call1(dec_invalid, 3)
                  : dec_ret(4, utf_8_uchar_4(b0, b1$2, b2$1, b3$1));
         case 7:
          var i$10 = i + 1 | 0;
          if(max < i$10) return caml_call1(dec_invalid, 1);
          var b1$0 = caml_bytes_unsafe_get(b, i$10);
          if(not_in_x80_to_x8F(b1$0)) return caml_call1(dec_invalid, 1);
          var i$11 = i$10 + 1 | 0;
          if(max < i$11) return caml_call1(dec_invalid, 2);
          var b2 = caml_bytes_unsafe_get(b, i$11);
          if(not_in_x80_to_xBF(b2)) return caml_call1(dec_invalid, 2);
          var i$12 = i$11 + 1 | 0;
          if(max < i$12) return caml_call1(dec_invalid, 3);
          var b3 = caml_bytes_unsafe_get(b, i$12);
          return not_in_x80_to_xBF(b3)
                  ? caml_call1(dec_invalid, 3)
                  : dec_ret(4, utf_8_uchar_4(b0, b1$0, b2, b3));
         case 1:
         case 2: break;
         default:
          var i$7 = i + 1 | 0;
          if(max < i$7) return caml_call1(dec_invalid, 1);
          var b1$1 = caml_bytes_unsafe_get(b, i$7);
          if(not_in_x80_to_xBF(b1$1)) return caml_call1(dec_invalid, 1);
          var i$8 = i$7 + 1 | 0;
          if(max < i$8) return caml_call1(dec_invalid, 2);
          var b2$0 = caml_bytes_unsafe_get(b, i$8);
          if(not_in_x80_to_xBF(b2$0)) return caml_call1(dec_invalid, 2);
          var i$9 = i$8 + 1 | 0;
          if(max < i$9) return caml_call1(dec_invalid, 3);
          var b3$0 = caml_bytes_unsafe_get(b, i$9);
          return not_in_x80_to_xBF(b3$0)
                  ? caml_call1(dec_invalid, 3)
                  : dec_ret(4, utf_8_uchar_4(b0, b1$1, b2$0, b3$0));
       }
      }
      else if(225 > b0){
       var i$13 = i + 1 | 0;
       if(max < i$13) return caml_call1(dec_invalid, 1);
       var b1$5 = caml_bytes_unsafe_get(b, i$13);
       if(not_in_xA0_to_xBF(b1$5)) return caml_call1(dec_invalid, 1);
       var i$14 = i$13 + 1 | 0;
       if(max < i$14) return caml_call1(dec_invalid, 2);
       var b2$4 = caml_bytes_unsafe_get(b, i$14);
       return not_in_x80_to_xBF(b2$4)
               ? caml_call1(dec_invalid, 2)
               : dec_ret(3, utf_8_uchar_3(b0, b1$5, b2$4));
      }
      var i$2 = i + 1 | 0;
      if(max < i$2) return caml_call1(dec_invalid, 1);
      var b1$3 = caml_bytes_unsafe_get(b, i$2);
      if(not_in_x80_to_xBF(b1$3)) return caml_call1(dec_invalid, 1);
      var i$3 = i$2 + 1 | 0;
      if(max < i$3) return caml_call1(dec_invalid, 2);
      var b2$2 = caml_bytes_unsafe_get(b, i$3);
      return not_in_x80_to_xBF(b2$2)
              ? caml_call1(dec_invalid, 2)
              : dec_ret(3, utf_8_uchar_3(b0, b1$3, b2$2));
     }
     if(128 > b0) return dec_ret(1, b0);
     if(194 <= b0){
      var i$15 = i + 1 | 0;
      if(max < i$15) return caml_call1(dec_invalid, 1);
      var b1 = caml_bytes_unsafe_get(b, i$15);
      return not_in_x80_to_xBF(b1)
              ? caml_call1(dec_invalid, 1)
              : dec_ret(2, (b0 & 31) << 6 | b1 & 63);
     }
    }
    return caml_call1(dec_invalid, 1);
   }
   function set_utf_8_uchar(b, i, u){
    function set(_i_, _h_, _g_){caml_bytes_unsafe_set(_i_, _h_, _g_); return;}
    var
     max = caml_ml_bytes_length(b) - 1 | 0,
     u$0 = caml_call1(Stdlib_Uchar[10], u);
    if(0 > u$0)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
    if(127 >= u$0){caml_bytes_set(b, i, u$0); return 1;}
    if(2047 >= u$0){
     var last$1 = i + 1 | 0;
     return max < last$1
             ? 0
             : (caml_bytes_set
                (b, i, 192 | u$0 >>> 6 | 0),
               set(b, last$1, 128 | u$0 & 63),
               2);
    }
    if(65535 >= u$0){
     var last$0 = i + 2 | 0;
     return max < last$0
             ? 0
             : (caml_bytes_set
                (b, i, 224 | u$0 >>> 12 | 0),
               set(b, i + 1 | 0, 128 | (u$0 >>> 6 | 0) & 63),
               set(b, last$0, 128 | u$0 & 63),
               3);
    }
    if(1114111 < u$0)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
    var last = i + 3 | 0;
    return max < last
            ? 0
            : (caml_bytes_set
               (b, i, 240 | u$0 >>> 18 | 0),
              set(b, i + 1 | 0, 128 | (u$0 >>> 12 | 0) & 63),
              set(b, i + 2 | 0, 128 | (u$0 >>> 6 | 0) & 63),
              set(b, last, 128 | u$0 & 63),
              4);
   }
   function is_valid_utf_8(b){
    var max = caml_ml_bytes_length(b) - 1 | 0, i = 0;
    for(;;){
     if(max < i) return 1;
     var match = caml_bytes_unsafe_get(b, i);
     a:
     {
      if(224 <= match){
       if(237 <= match){
        if(245 <= match) break a;
        switch(match - 237 | 0){
          case 0:
           var last = i + 2 | 0;
           if
            (max >= last
             &&
              !
              not_in_x80_to_x9F(caml_bytes_unsafe_get(b, i + 1 | 0))
              && ! not_in_x80_to_xBF(caml_bytes_unsafe_get(b, last))){var i$0 = last + 1 | 0; i = i$0; continue;}
           return 0;
          case 3:
           var last$1 = i + 3 | 0;
           if
            (max >= last$1
             &&
              !
              not_in_x90_to_xBF(caml_bytes_unsafe_get(b, i + 1 | 0))
              &&
               !
               not_in_x80_to_xBF(caml_bytes_unsafe_get(b, i + 2 | 0))
               && ! not_in_x80_to_xBF(caml_bytes_unsafe_get(b, last$1))){var i$2 = last$1 + 1 | 0; i = i$2; continue;}
           return 0;
          case 7:
           var last$3 = i + 3 | 0;
           if
            (max >= last$3
             &&
              !
              not_in_x80_to_x8F(caml_bytes_unsafe_get(b, i + 1 | 0))
              &&
               !
               not_in_x80_to_xBF(caml_bytes_unsafe_get(b, i + 2 | 0))
               && ! not_in_x80_to_xBF(caml_bytes_unsafe_get(b, last$3))){var i$4 = last$3 + 1 | 0; i = i$4; continue;}
           return 0;
          case 1:
          case 2: break;
          default:
           var last$2 = i + 3 | 0;
           if
            (max >= last$2
             &&
              !
              not_in_x80_to_xBF(caml_bytes_unsafe_get(b, i + 1 | 0))
              &&
               !
               not_in_x80_to_xBF(caml_bytes_unsafe_get(b, i + 2 | 0))
               && ! not_in_x80_to_xBF(caml_bytes_unsafe_get(b, last$2))){var i$3 = last$2 + 1 | 0; i = i$3; continue;}
           return 0;
        }
       }
       else if(225 > match){
        var last$4 = i + 2 | 0;
        if
         (max >= last$4
          &&
           !
           not_in_xA0_to_xBF(caml_bytes_unsafe_get(b, i + 1 | 0))
           && ! not_in_x80_to_xBF(caml_bytes_unsafe_get(b, last$4))){var i$5 = last$4 + 1 | 0; i = i$5; continue;}
        return 0;
       }
       var last$0 = i + 2 | 0;
       if
        (max >= last$0
         &&
          !
          not_in_x80_to_xBF(caml_bytes_unsafe_get(b, i + 1 | 0))
          && ! not_in_x80_to_xBF(caml_bytes_unsafe_get(b, last$0))){var i$1 = last$0 + 1 | 0; i = i$1; continue;}
       return 0;
      }
      if(128 > match){var i$7 = i + 1 | 0; i = i$7; continue;}
      if(194 <= match){
       var last$5 = i + 1 | 0;
       if
        (max >= last$5
         && ! not_in_x80_to_xBF(caml_bytes_unsafe_get(b, last$5))){var i$6 = last$5 + 1 | 0; i = i$6; continue;}
       return 0;
      }
     }
     return 0;
    }
   }
   function get_utf_16be_uchar(b, i){
    var max = caml_ml_bytes_length(b) - 1 | 0;
    if(0 <= i && max >= i){
     if(i === max) return caml_call1(dec_invalid, 1);
     var hi = unsafe_get_uint16_be(b, i);
     if(55296 <= hi && 57343 >= hi){
      if(56319 < hi) return caml_call1(dec_invalid, 2);
      var last = i + 3 | 0;
      if(max < last) return caml_call1(dec_invalid, (max - i | 0) + 1 | 0);
      var lo = unsafe_get_uint16_be(b, i + 2 | 0);
      if(56320 <= lo && 57343 >= lo){
       var u = ((hi & 1023) << 10 | lo & 1023) + 65536 | 0;
       return dec_ret(4, u);
      }
      return caml_call1(dec_invalid, 2);
     }
     return dec_ret(2, hi);
    }
    return caml_call1(Stdlib[1], cst_index_out_of_bounds);
   }
   function set_utf_16be_uchar(b, i, u){
    var max = caml_ml_bytes_length(b) - 1 | 0;
    if(0 <= i && max >= i){
     var u$0 = caml_call1(Stdlib_Uchar[10], u);
     if(0 > u$0)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
     if(65535 >= u$0){
      var last$0 = i + 1 | 0;
      return max < last$0 ? 0 : (unsafe_set_uint16_be(b, i, u$0), 2);
     }
     if(1114111 < u$0)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
     var last = i + 3 | 0;
     if(max < last) return 0;
     var
      u$1 = u$0 - 65536 | 0,
      hi = 55296 | u$1 >>> 10 | 0,
      lo = 56320 | u$1 & 1023;
     unsafe_set_uint16_be(b, i, hi);
     unsafe_set_uint16_be(b, i + 2 | 0, lo);
     return 4;
    }
    return caml_call1(Stdlib[1], cst_index_out_of_bounds$0);
   }
   function is_valid_utf_16be(b){
    var max = caml_ml_bytes_length(b) - 1 | 0, i = 0;
    for(;;){
     if(max < i) return 1;
     if(i === max) return 0;
     var u = unsafe_get_uint16_be(b, i);
     if(55296 <= u && 57343 >= u){
      if(56319 < u) return 0;
      var last = i + 3 | 0;
      if(max < last) return 0;
      var u$0 = unsafe_get_uint16_be(b, i + 2 | 0);
      if(56320 <= u$0 && 57343 >= u$0){
       var i$1 = i + 4 | 0;
       i = i$1;
       continue;
      }
      return 0;
     }
     var i$0 = i + 2 | 0;
     i = i$0;
    }
   }
   function get_utf_16le_uchar(b, i){
    var max = caml_ml_bytes_length(b) - 1 | 0;
    if(0 <= i && max >= i){
     if(i === max) return caml_call1(dec_invalid, 1);
     var hi = unsafe_get_uint16_le(b, i);
     if(55296 <= hi && 57343 >= hi){
      if(56319 < hi) return caml_call1(dec_invalid, 2);
      var last = i + 3 | 0;
      if(max < last) return caml_call1(dec_invalid, (max - i | 0) + 1 | 0);
      var lo = unsafe_get_uint16_le(b, i + 2 | 0);
      if(56320 <= lo && 57343 >= lo){
       var u = ((hi & 1023) << 10 | lo & 1023) + 65536 | 0;
       return dec_ret(4, u);
      }
      return caml_call1(dec_invalid, 2);
     }
     return dec_ret(2, hi);
    }
    return caml_call1(Stdlib[1], cst_index_out_of_bounds$1);
   }
   function set_utf_16le_uchar(b, i, u){
    var max = caml_ml_bytes_length(b) - 1 | 0;
    if(0 <= i && max >= i){
     var u$0 = caml_call1(Stdlib_Uchar[10], u);
     if(0 > u$0)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
     if(65535 >= u$0){
      var last$0 = i + 1 | 0;
      return max < last$0 ? 0 : (unsafe_set_uint16_le(b, i, u$0), 2);
     }
     if(1114111 < u$0)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
     var last = i + 3 | 0;
     if(max < last) return 0;
     var
      u$1 = u$0 - 65536 | 0,
      hi = 55296 | u$1 >>> 10 | 0,
      lo = 56320 | u$1 & 1023;
     unsafe_set_uint16_le(b, i, hi);
     unsafe_set_uint16_le(b, i + 2 | 0, lo);
     return 4;
    }
    return caml_call1(Stdlib[1], cst_index_out_of_bounds$2);
   }
   function is_valid_utf_16le(b){
    var max = caml_ml_bytes_length(b) - 1 | 0, i = 0;
    for(;;){
     if(max < i) return 1;
     if(i === max) return 0;
     var u = unsafe_get_uint16_le(b, i);
     if(55296 <= u && 57343 >= u){
      if(56319 < u) return 0;
      var last = i + 3 | 0;
      if(max < last) return 0;
      var u$0 = unsafe_get_uint16_le(b, i + 2 | 0);
      if(56320 <= u$0 && 57343 >= u$0){
       var i$1 = i + 4 | 0;
       i = i$1;
       continue;
      }
      return 0;
     }
     var i$0 = i + 2 | 0;
     i = i$0;
    }
   }
   var
    Stdlib_Bytes =
      [0,
       make,
       init,
       empty,
       copy,
       of_string,
       to_string,
       sub,
       sub_string,
       extend,
       fill,
       blit,
       blit_string,
       concat,
       cat,
       iter,
       iteri,
       map,
       mapi,
       fold_left,
       fold_right,
       for_all,
       exists,
       trim,
       escaped,
       index,
       index_opt,
       rindex,
       rindex_opt,
       index_from,
       index_from_opt,
       rindex_from,
       rindex_from_opt,
       contains,
       contains_from,
       rcontains_from,
       uppercase,
       lowercase,
       capitalize,
       uncapitalize,
       uppercase_ascii,
       lowercase_ascii,
       capitalize_ascii,
       uncapitalize_ascii,
       compare,
       runtime.caml_bytes_equal,
       starts_with,
       ends_with,
       caml_string_of_bytes,
       caml_bytes_of_string,
       split_on_char,
       to_seq,
       to_seqi,
       of_seq,
       get_utf_8_uchar,
       set_utf_8_uchar,
       is_valid_utf_8,
       get_utf_16be_uchar,
       set_utf_16be_uchar,
       is_valid_utf_16be,
       get_utf_16le_uchar,
       set_utf_16le_uchar,
       is_valid_utf_16le,
       caml_bytes_get,
       get_int8,
       caml_bytes_get16,
       get_uint16_be,
       get_uint16_le,
       get_int16_ne,
       get_int16_be,
       get_int16_le,
       caml_bytes_get32,
       get_int32_be,
       get_int32_le,
       caml_bytes_get64,
       get_int64_be,
       get_int64_le,
       set_uint8,
       caml_bytes_set,
       set_uint16_ne,
       set_int16_be,
       set_int16_le,
       caml_bytes_set16,
       set_int16_be,
       set_int16_le,
       caml_bytes_set32,
       set_int32_be,
       set_int32_le,
       caml_bytes_set64,
       set_int64_be,
       set_int64_le];
   runtime.caml_register_global(30, Stdlib_Bytes, "Stdlib__Bytes");
   return;
  }
  (globalThis));

//# 4969 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$0 = "",
    caml_blit_string = runtime.caml_blit_string,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_equal = runtime.caml_string_equal,
    caml_string_unsafe_get = runtime.caml_string_unsafe_get,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = cst$0,
    empty = cst$0,
    Stdlib = global_data.Stdlib,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    bts = Stdlib_Bytes[48],
    bos = Stdlib_Bytes[49];
   function make(n, c){
    return caml_call1(bts, caml_call2(Stdlib_Bytes[1], n, c));
   }
   function init(n, f){
    return caml_call1(bts, caml_call2(Stdlib_Bytes[2], n, f));
   }
   function copy(s){
    var _ac_ = caml_call1(bos, s);
    return caml_call1(bts, caml_call1(Stdlib_Bytes[4], _ac_));
   }
   var of_bytes = Stdlib_Bytes[6], to_bytes = Stdlib_Bytes[5];
   function sub(s, ofs, len){
    var _ab_ = caml_call1(bos, s);
    return caml_call1(bts, caml_call3(Stdlib_Bytes[7], _ab_, ofs, len));
   }
   var
    fill = Stdlib_Bytes[10],
    blit = Stdlib_Bytes[12],
    cst_String_concat = "String.concat";
   function concat(sep, l){
    if(! l) return cst;
    var seplen = caml_ml_string_length(sep);
    a:
    {
     b:
     {
      var acc = 0, param = l, pos$1 = 0;
      for(;;){
       if(! param) break;
       var hd = param[1];
       if(! param[2]) break b;
       var
        tl = param[2],
        x = (caml_ml_string_length(hd) + seplen | 0) + acc | 0,
        acc$0 = acc <= x ? x : caml_call1(Stdlib[1], cst_String_concat);
       acc = acc$0;
       param = tl;
      }
      var _aa_ = acc;
      break a;
     }
     var _aa_ = caml_ml_string_length(hd) + acc | 0;
    }
    var dst = runtime.caml_create_bytes(_aa_), pos = pos$1, param$0 = l;
    for(;;){
     if(param$0){
      var hd$0 = param$0[1];
      if(param$0[2]){
       var tl$0 = param$0[2];
       caml_blit_string(hd$0, 0, dst, pos, caml_ml_string_length(hd$0));
       caml_blit_string
        (sep, 0, dst, pos + caml_ml_string_length(hd$0) | 0, seplen);
       var pos$0 = (pos + caml_ml_string_length(hd$0) | 0) + seplen | 0;
       pos = pos$0;
       param$0 = tl$0;
       continue;
      }
      caml_blit_string(hd$0, 0, dst, pos, caml_ml_string_length(hd$0));
     }
     return caml_call1(bts, dst);
    }
   }
   var
    cat = Stdlib[28],
    cst_String_index_from_Bytes_in = "String.index_from / Bytes.index_from",
    cst_String_index_from_opt_Byte =
      "String.index_from_opt / Bytes.index_from_opt",
    cst_String_rindex_from_Bytes_r = "String.rindex_from / Bytes.rindex_from",
    cst_String_rindex_from_opt_Byt =
      "String.rindex_from_opt / Bytes.rindex_from_opt",
    cst_String_contains_from_Bytes =
      "String.contains_from / Bytes.contains_from",
    cst_String_rcontains_from_Byte =
      "String.rcontains_from / Bytes.rcontains_from";
   function iter(f, s){
    var ___ = caml_ml_string_length(s) - 1 | 0, _Z_ = 0;
    if(___ >= 0){
     var i = _Z_;
     for(;;){
      caml_call1(f, caml_string_unsafe_get(s, i));
      var _$_ = i + 1 | 0;
      if(___ === i) break;
      i = _$_;
     }
    }
    return 0;
   }
   function iteri(f, s){
    var _X_ = caml_ml_string_length(s) - 1 | 0, _W_ = 0;
    if(_X_ >= 0){
     var i = _W_;
     for(;;){
      caml_call2(f, i, caml_string_unsafe_get(s, i));
      var _Y_ = i + 1 | 0;
      if(_X_ === i) break;
      i = _Y_;
     }
    }
    return 0;
   }
   function map(f, s){
    var _V_ = caml_call1(bos, s);
    return caml_call1(bts, caml_call2(Stdlib_Bytes[17], f, _V_));
   }
   function mapi(f, s){
    var _U_ = caml_call1(bos, s);
    return caml_call1(bts, caml_call2(Stdlib_Bytes[18], f, _U_));
   }
   function fold_right(f, x, a){
    var _T_ = caml_call1(bos, x);
    return caml_call3(Stdlib_Bytes[20], f, _T_, a);
   }
   function fold_left(f, a, x){
    var _S_ = caml_call1(bos, x);
    return caml_call3(Stdlib_Bytes[19], f, a, _S_);
   }
   function exists(f, s){
    var _R_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[22], f, _R_);
   }
   function for_all(f, s){
    var _Q_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[21], f, _Q_);
   }
   function is_space(param){
    var _P_ = param - 9 | 0;
    a:
    {
     if(4 < _P_ >>> 0){if(23 !== _P_) break a;} else if(2 === _P_) break a;
     return 1;
    }
    return 0;
   }
   function trim(s){
    if(s == cst$0) return s;
    if
     (!
      is_space(caml_string_unsafe_get(s, 0))
      &&
       !
       is_space(caml_string_unsafe_get(s, caml_ml_string_length(s) - 1 | 0)))
     return s;
    var _O_ = caml_call1(bos, s);
    return caml_call1(bts, caml_call1(Stdlib_Bytes[23], _O_));
   }
   function escaped(s){
    var n = caml_ml_string_length(s), i = 0;
    for(;;){
     if(n <= i) return s;
     var _M_ = caml_string_unsafe_get(s, i) - 32 | 0;
     a:
     {
      if(59 < _M_ >>> 0){
       if(33 < _M_ - 61 >>> 0) break a;
      }
      else if(2 === _M_) break a;
      var i$0 = i + 1 | 0;
      i = i$0;
      continue;
     }
     var _N_ = caml_call1(bos, s);
     return caml_call1(bts, caml_call1(Stdlib_Bytes[24], _N_));
    }
   }
   function index_rec(s, lim, i, c){
    var i$0 = i;
    for(;;){
     if(lim <= i$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     if(caml_string_unsafe_get(s, i$0) === c) return i$0;
     var i$1 = i$0 + 1 | 0;
     i$0 = i$1;
    }
   }
   function index(s, c){return index_rec(s, caml_ml_string_length(s), 0, c);}
   function index_rec_opt(s, lim, i, c){
    var i$0 = i;
    for(;;){
     if(lim <= i$0) return 0;
     if(caml_string_unsafe_get(s, i$0) === c) return [0, i$0];
     var i$1 = i$0 + 1 | 0;
     i$0 = i$1;
    }
   }
   function index_opt(s, c){
    return index_rec_opt(s, caml_ml_string_length(s), 0, c);
   }
   function index_from(s, i, c){
    var l = caml_ml_string_length(s);
    if(0 <= i && l >= i) return index_rec(s, l, i, c);
    return caml_call1(Stdlib[1], cst_String_index_from_Bytes_in);
   }
   function index_from_opt(s, i, c){
    var l = caml_ml_string_length(s);
    if(0 <= i && l >= i) return index_rec_opt(s, l, i, c);
    return caml_call1(Stdlib[1], cst_String_index_from_opt_Byte);
   }
   function rindex_rec(s, i, c){
    var i$0 = i;
    for(;;){
     if(0 > i$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     if(caml_string_unsafe_get(s, i$0) === c) return i$0;
     var i$1 = i$0 - 1 | 0;
     i$0 = i$1;
    }
   }
   function rindex(s, c){
    return rindex_rec(s, caml_ml_string_length(s) - 1 | 0, c);
   }
   function rindex_from(s, i, c){
    if(-1 <= i && caml_ml_string_length(s) > i) return rindex_rec(s, i, c);
    return caml_call1(Stdlib[1], cst_String_rindex_from_Bytes_r);
   }
   function rindex_rec_opt(s, i, c){
    var i$0 = i;
    for(;;){
     if(0 > i$0) return 0;
     if(caml_string_unsafe_get(s, i$0) === c) return [0, i$0];
     var i$1 = i$0 - 1 | 0;
     i$0 = i$1;
    }
   }
   function rindex_opt(s, c){
    return rindex_rec_opt(s, caml_ml_string_length(s) - 1 | 0, c);
   }
   function rindex_from_opt(s, i, c){
    if(-1 <= i && caml_ml_string_length(s) > i)
     return rindex_rec_opt(s, i, c);
    return caml_call1(Stdlib[1], cst_String_rindex_from_opt_Byt);
   }
   function contains_from(s, i, c){
    var l = caml_ml_string_length(s);
    if(0 <= i && l >= i)
     try{index_rec(s, l, i, c); var _K_ = 1; return _K_;}
     catch(_L_){
      var _J_ = caml_wrap_exception(_L_);
      if(_J_ === Stdlib[8]) return 0;
      throw caml_maybe_attach_backtrace(_J_, 0);
     }
    return caml_call1(Stdlib[1], cst_String_contains_from_Bytes);
   }
   function contains(s, c){return contains_from(s, 0, c);}
   function rcontains_from(s, i, c){
    if(0 <= i && caml_ml_string_length(s) > i)
     try{rindex_rec(s, i, c); var _H_ = 1; return _H_;}
     catch(_I_){
      var _G_ = caml_wrap_exception(_I_);
      if(_G_ === Stdlib[8]) return 0;
      throw caml_maybe_attach_backtrace(_G_, 0);
     }
    return caml_call1(Stdlib[1], cst_String_rcontains_from_Byte);
   }
   function uppercase_ascii(s){
    var _F_ = caml_call1(bos, s);
    return caml_call1(bts, caml_call1(Stdlib_Bytes[40], _F_));
   }
   function lowercase_ascii(s){
    var _E_ = caml_call1(bos, s);
    return caml_call1(bts, caml_call1(Stdlib_Bytes[41], _E_));
   }
   function capitalize_ascii(s){
    var _D_ = caml_call1(bos, s);
    return caml_call1(bts, caml_call1(Stdlib_Bytes[42], _D_));
   }
   function uncapitalize_ascii(s){
    var _C_ = caml_call1(bos, s);
    return caml_call1(bts, caml_call1(Stdlib_Bytes[43], _C_));
   }
   function starts_with(prefix, s){
    var
     len_s = caml_ml_string_length(s),
     len_pre = caml_ml_string_length(prefix),
     _B_ = len_pre <= len_s ? 1 : 0;
    if(! _B_) return _B_;
    var i = 0;
    for(;;){
     if(i === len_pre) return 1;
     if(caml_string_unsafe_get(s, i) !== caml_string_unsafe_get(prefix, i))
      return 0;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function ends_with(suffix, s){
    var
     len_s = caml_ml_string_length(s),
     len_suf = caml_ml_string_length(suffix),
     diff = len_s - len_suf | 0,
     _A_ = 0 <= diff ? 1 : 0;
    if(! _A_) return _A_;
    var i = 0;
    for(;;){
     if(i === len_suf) return 1;
     if
      (caml_string_unsafe_get(s, diff + i | 0)
       !== caml_string_unsafe_get(suffix, i))
      return 0;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function split_on_char(sep, s){
    var
     r = [0, 0],
     j = [0, caml_ml_string_length(s)],
     _w_ = caml_ml_string_length(s) - 1 | 0;
    if(_w_ >= 0){
     var i = _w_;
     for(;;){
      if(caml_string_unsafe_get(s, i) === sep){
       var _y_ = r[1];
       r[1] = [0, sub(s, i + 1 | 0, (j[1] - i | 0) - 1 | 0), _y_];
       j[1] = i;
      }
      var _z_ = i - 1 | 0;
      if(0 === i) break;
      i = _z_;
     }
    }
    var _x_ = r[1];
    return [0, sub(s, 0, j[1]), _x_];
   }
   function uppercase(s){
    var _v_ = caml_call1(bos, s);
    return caml_call1(bts, caml_call1(Stdlib_Bytes[36], _v_));
   }
   function lowercase(s){
    var _u_ = caml_call1(bos, s);
    return caml_call1(bts, caml_call1(Stdlib_Bytes[37], _u_));
   }
   function capitalize(s){
    var _t_ = caml_call1(bos, s);
    return caml_call1(bts, caml_call1(Stdlib_Bytes[38], _t_));
   }
   function uncapitalize(s){
    var _s_ = caml_call1(bos, s);
    return caml_call1(bts, caml_call1(Stdlib_Bytes[39], _s_));
   }
   var compare = runtime.caml_string_compare;
   function to_seq(s){
    var _r_ = caml_call1(bos, s);
    return caml_call1(Stdlib_Bytes[51], _r_);
   }
   function to_seqi(s){
    var _q_ = caml_call1(bos, s);
    return caml_call1(Stdlib_Bytes[52], _q_);
   }
   function of_seq(g){
    return caml_call1(bts, caml_call1(Stdlib_Bytes[53], g));
   }
   function get_utf_8_uchar(s, i){
    var _p_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[54], _p_, i);
   }
   function is_valid_utf_8(s){
    var _o_ = caml_call1(bos, s);
    return caml_call1(Stdlib_Bytes[56], _o_);
   }
   function get_utf_16be_uchar(s, i){
    var _n_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[57], _n_, i);
   }
   function is_valid_utf_16be(s){
    var _m_ = caml_call1(bos, s);
    return caml_call1(Stdlib_Bytes[59], _m_);
   }
   function get_utf_16le_uchar(s, i){
    var _l_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[60], _l_, i);
   }
   function is_valid_utf_16le(s){
    var _k_ = caml_call1(bos, s);
    return caml_call1(Stdlib_Bytes[62], _k_);
   }
   function get_int8(s, i){
    var _j_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[64], _j_, i);
   }
   function get_uint16_le(s, i){
    var _i_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[67], _i_, i);
   }
   function get_uint16_be(s, i){
    var _h_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[66], _h_, i);
   }
   function get_int16_ne(s, i){
    var _g_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[68], _g_, i);
   }
   function get_int16_le(s, i){
    var _f_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[70], _f_, i);
   }
   function get_int16_be(s, i){
    var _e_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[69], _e_, i);
   }
   function get_int32_le(s, i){
    var _d_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[73], _d_, i);
   }
   function get_int32_be(s, i){
    var _c_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[72], _c_, i);
   }
   function get_int64_le(s, i){
    var _b_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[76], _b_, i);
   }
   function get_int64_be(s, i){
    var _a_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[75], _a_, i);
   }
   var
    Stdlib_String =
      [0,
       make,
       init,
       empty,
       of_bytes,
       to_bytes,
       concat,
       cat,
       caml_string_equal,
       compare,
       starts_with,
       ends_with,
       contains_from,
       rcontains_from,
       contains,
       sub,
       split_on_char,
       map,
       mapi,
       fold_left,
       fold_right,
       for_all,
       exists,
       trim,
       escaped,
       uppercase_ascii,
       lowercase_ascii,
       capitalize_ascii,
       uncapitalize_ascii,
       iter,
       iteri,
       index_from,
       index_from_opt,
       rindex_from,
       rindex_from_opt,
       index,
       index_opt,
       rindex,
       rindex_opt,
       to_seq,
       to_seqi,
       of_seq,
       get_utf_8_uchar,
       is_valid_utf_8,
       get_utf_16be_uchar,
       is_valid_utf_16be,
       get_utf_16le_uchar,
       is_valid_utf_16le,
       blit,
       copy,
       fill,
       uppercase,
       lowercase,
       capitalize,
       uncapitalize,
       runtime.caml_string_get,
       get_int8,
       runtime.caml_string_get16,
       get_uint16_be,
       get_uint16_le,
       get_int16_ne,
       get_int16_be,
       get_int16_le,
       runtime.caml_string_get32,
       get_int32_be,
       get_int32_le,
       runtime.caml_string_get64,
       get_int64_be,
       get_int64_le];
   runtime.caml_register_global(12, Stdlib_String, "Stdlib__String");
   return;
  }
  (globalThis));

//# 5572 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_array_sub = runtime.caml_array_sub,
    caml_check_bound = runtime.caml_check_bound,
    caml_make_vect = runtime.caml_make_vect,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Seq = global_data.Stdlib__Seq,
    Assert_failure = global_data.Assert_failure,
    Stdlib = global_data.Stdlib,
    make_float = runtime.caml_make_float_vect,
    Floatarray = [0],
    cst_Array_init = "Array.init",
    cst_Array_sub = "Array.sub",
    cst_Array_fill = "Array.fill",
    cst_Array_blit = "Array.blit",
    cst_Array_iter2_arrays_must_ha =
      "Array.iter2: arrays must have the same length",
    cst_Array_map2_arrays_must_hav =
      "Array.map2: arrays must have the same length",
    cst_Array_for_all2 = "Array.for_all2",
    cst_Array_exists2 = "Array.exists2",
    cst_Array_combine = "Array.combine";
   function init(l, f){
    if(0 === l) return [0];
    if(0 > l) return caml_call1(Stdlib[1], cst_Array_init);
    var res = caml_make_vect(l, caml_call1(f, 0)), _aq_ = l - 1 | 0, _ap_ = 1;
    if(_aq_ >= 1){
     var i = _ap_;
     for(;;){
      res[1 + i] = caml_call1(f, i);
      var _ar_ = i + 1 | 0;
      if(_aq_ === i) break;
      i = _ar_;
     }
    }
    return res;
   }
   function make_matrix(sx, sy, init){
    var res = caml_make_vect(sx, [0]), _an_ = sx - 1 | 0, _am_ = 0;
    if(_an_ >= 0){
     var x = _am_;
     for(;;){
      res[1 + x] = caml_make_vect(sy, init);
      var _ao_ = x + 1 | 0;
      if(_an_ === x) break;
      x = _ao_;
     }
    }
    return res;
   }
   function copy(a){
    var l = a.length - 1;
    return 0 === l ? [0] : caml_array_sub(a, 0, l);
   }
   function append(a1, a2){
    var l1 = a1.length - 1;
    return 0 === l1
            ? copy(a2)
            : 0
              === a2.length - 1
              ? caml_array_sub(a1, 0, l1)
              : runtime.caml_array_append(a1, a2);
   }
   function sub(a, ofs, len){
    if(0 <= ofs && 0 <= len && (a.length - 1 - len | 0) >= ofs)
     return caml_array_sub(a, ofs, len);
    return caml_call1(Stdlib[1], cst_Array_sub);
   }
   function fill(a, ofs, len, v){
    if(0 <= ofs && 0 <= len && (a.length - 1 - len | 0) >= ofs)
     return runtime.caml_array_fill(a, ofs, len, v);
    return caml_call1(Stdlib[1], cst_Array_fill);
   }
   function blit(a1, ofs1, a2, ofs2, len){
    if
     (0 <= len
      &&
       0 <= ofs1
       &&
        (a1.length - 1 - len | 0) >= ofs1
        && 0 <= ofs2 && (a2.length - 1 - len | 0) >= ofs2)
     return runtime.caml_array_blit(a1, ofs1, a2, ofs2, len);
    return caml_call1(Stdlib[1], cst_Array_blit);
   }
   function iter(f, a){
    var _ak_ = a.length - 2 | 0, _aj_ = 0;
    if(_ak_ >= 0){
     var i = _aj_;
     for(;;){
      caml_call1(f, a[1 + i]);
      var _al_ = i + 1 | 0;
      if(_ak_ === i) break;
      i = _al_;
     }
    }
    return 0;
   }
   function iter2(f, a, b){
    if(a.length - 1 !== b.length - 1)
     return caml_call1(Stdlib[1], cst_Array_iter2_arrays_must_ha);
    var _ah_ = a.length - 2 | 0, _ag_ = 0;
    if(_ah_ >= 0){
     var i = _ag_;
     for(;;){
      caml_call2(f, a[1 + i], b[1 + i]);
      var _ai_ = i + 1 | 0;
      if(_ah_ === i) break;
      i = _ai_;
     }
    }
    return 0;
   }
   function map(f, a){
    var l = a.length - 1;
    if(0 === l) return [0];
    var
     r = caml_make_vect(l, caml_call1(f, a[1])),
     _ae_ = l - 1 | 0,
     _ad_ = 1;
    if(_ae_ >= 1){
     var i = _ad_;
     for(;;){
      r[1 + i] = caml_call1(f, a[1 + i]);
      var _af_ = i + 1 | 0;
      if(_ae_ === i) break;
      i = _af_;
     }
    }
    return r;
   }
   function map2(f, a, b){
    var la = a.length - 1, lb = b.length - 1;
    if(la !== lb)
     return caml_call1(Stdlib[1], cst_Array_map2_arrays_must_hav);
    if(0 === la) return [0];
    var
     r = caml_make_vect(la, caml_call2(f, a[1], b[1])),
     _ab_ = la - 1 | 0,
     _aa_ = 1;
    if(_ab_ >= 1){
     var i = _aa_;
     for(;;){
      r[1 + i] = caml_call2(f, a[1 + i], b[1 + i]);
      var _ac_ = i + 1 | 0;
      if(_ab_ === i) break;
      i = _ac_;
     }
    }
    return r;
   }
   function iteri(f, a){
    var ___ = a.length - 2 | 0, _Z_ = 0;
    if(___ >= 0){
     var i = _Z_;
     for(;;){
      caml_call2(f, i, a[1 + i]);
      var _$_ = i + 1 | 0;
      if(___ === i) break;
      i = _$_;
     }
    }
    return 0;
   }
   function mapi(f, a){
    var l = a.length - 1;
    if(0 === l) return [0];
    var
     r = caml_make_vect(l, caml_call2(f, 0, a[1])),
     _X_ = l - 1 | 0,
     _W_ = 1;
    if(_X_ >= 1){
     var i = _W_;
     for(;;){
      r[1 + i] = caml_call2(f, i, a[1 + i]);
      var _Y_ = i + 1 | 0;
      if(_X_ === i) break;
      i = _Y_;
     }
    }
    return r;
   }
   function to_list(a){
    var i$1 = a.length - 2 | 0, i = i$1, res = 0;
    for(;;){
     if(0 > i) return res;
     var res$0 = [0, a[1 + i], res], i$0 = i - 1 | 0;
     i = i$0;
     res = res$0;
    }
   }
   function list_length(accu, param){
    var accu$0 = accu, param$0 = param;
    for(;;){
     if(! param$0) return accu$0;
     var t = param$0[2], accu$1 = accu$0 + 1 | 0;
     accu$0 = accu$1;
     param$0 = t;
    }
   }
   function of_list(l){
    if(! l) return [0];
    var
     tl = l[2],
     hd = l[1],
     a = caml_make_vect(list_length(0, l), hd),
     i = 1,
     param = tl;
    for(;;){
     if(! param) return a;
     var tl$0 = param[2], hd$0 = param[1];
     a[1 + i] = hd$0;
     var i$0 = i + 1 | 0;
     i = i$0;
     param = tl$0;
    }
   }
   function fold_left(f, x, a){
    var r = [0, x], _U_ = a.length - 2 | 0, _T_ = 0;
    if(_U_ >= 0){
     var i = _T_;
     for(;;){
      r[1] = caml_call2(f, r[1], a[1 + i]);
      var _V_ = i + 1 | 0;
      if(_U_ === i) break;
      i = _V_;
     }
    }
    return r[1];
   }
   function fold_left_map(f, acc, input_array){
    var len = input_array.length - 1;
    if(0 === len) return [0, acc, [0]];
    var
     match = caml_call2(f, acc, input_array[1]),
     elt = match[2],
     acc$0 = match[1],
     output_array = caml_make_vect(len, elt),
     acc$1 = [0, acc$0],
     _R_ = len - 1 | 0,
     _Q_ = 1;
    if(_R_ >= 1){
     var i = _Q_;
     for(;;){
      var
       match$0 = caml_call2(f, acc$1[1], input_array[1 + i]),
       elt$0 = match$0[2],
       acc$2 = match$0[1];
      acc$1[1] = acc$2;
      output_array[1 + i] = elt$0;
      var _S_ = i + 1 | 0;
      if(_R_ === i) break;
      i = _S_;
     }
    }
    return [0, acc$1[1], output_array];
   }
   function fold_right(f, a, x){
    var r = [0, x], _O_ = a.length - 2 | 0;
    if(_O_ >= 0){
     var i = _O_;
     for(;;){
      r[1] = caml_call2(f, a[1 + i], r[1]);
      var _P_ = i - 1 | 0;
      if(0 === i) break;
      i = _P_;
     }
    }
    return r[1];
   }
   function exists(p, a){
    var n = a.length - 1, i = 0;
    for(;;){
     if(i === n) return 0;
     if(caml_call1(p, a[1 + i])) return 1;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function for_all(p, a){
    var n = a.length - 1, i = 0;
    for(;;){
     if(i === n) return 1;
     if(! caml_call1(p, a[1 + i])) return 0;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function for_all2(p, l1, l2){
    var n1 = l1.length - 1, n2 = l2.length - 1;
    if(n1 !== n2) return caml_call1(Stdlib[1], cst_Array_for_all2);
    var i = 0;
    for(;;){
     if(i === n1) return 1;
     if(! caml_call2(p, l1[1 + i], l2[1 + i])) return 0;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function exists2(p, l1, l2){
    var n1 = l1.length - 1, n2 = l2.length - 1;
    if(n1 !== n2) return caml_call1(Stdlib[1], cst_Array_exists2);
    var i = 0;
    for(;;){
     if(i === n1) return 0;
     if(caml_call2(p, l1[1 + i], l2[1 + i])) return 1;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function mem(x, a){
    var n = a.length - 1, i = 0;
    for(;;){
     if(i === n) return 0;
     if(0 === runtime.caml_compare(a[1 + i], x)) return 1;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function memq(x, a){
    var n = a.length - 1, i = 0;
    for(;;){
     if(i === n) return 0;
     if(x === a[1 + i]) return 1;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function find_opt(p, a){
    var n = a.length - 1, i = 0;
    for(;;){
     if(i === n) return 0;
     var x = a[1 + i];
     if(caml_call1(p, x)) return [0, x];
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function find_map(f, a){
    var n = a.length - 1, i = 0;
    for(;;){
     if(i === n) return 0;
     var r = caml_call1(f, a[1 + i]);
     if(r) return r;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function split(x){
    if(runtime.caml_equal(x, [0])) return [0, [0], [0]];
    var
     match = x[1],
     b0 = match[2],
     a0 = match[1],
     n = x.length - 1,
     a = caml_make_vect(n, a0),
     b = caml_make_vect(n, b0),
     _M_ = n - 1 | 0,
     _L_ = 1;
    if(_M_ >= 1){
     var i = _L_;
     for(;;){
      var match$0 = x[1 + i], bi = match$0[2], ai = match$0[1];
      a[1 + i] = ai;
      b[1 + i] = bi;
      var _N_ = i + 1 | 0;
      if(_M_ === i) break;
      i = _N_;
     }
    }
    return [0, a, b];
   }
   function combine(a, b){
    var na = a.length - 1, nb = b.length - 1;
    if(na !== nb) caml_call1(Stdlib[1], cst_Array_combine);
    if(0 === na) return [0];
    var x = caml_make_vect(na, [0, a[1], b[1]]), _J_ = na - 1 | 0, _I_ = 1;
    if(_J_ >= 1){
     var i = _I_;
     for(;;){
      x[1 + i] = [0, a[1 + i], b[1 + i]];
      var _K_ = i + 1 | 0;
      if(_J_ === i) break;
      i = _K_;
     }
    }
    return x;
   }
   var
    Bottom = [248, "Stdlib.Array.Bottom", runtime.caml_fresh_oo_id(0)],
    _a_ = [0, "array.ml", 322, 4];
   function sort(cmp, a){
    function maxson(l, i){
     var i31 = ((i + i | 0) + i | 0) + 1 | 0, x = [0, i31];
     if((i31 + 2 | 0) < l){
      var _B_ = i31 + 1 | 0, _C_ = caml_check_bound(a, _B_)[1 + _B_];
      if(caml_call2(cmp, caml_check_bound(a, i31)[1 + i31], _C_) < 0)
       x[1] = i31 + 1 | 0;
      var
       _D_ = i31 + 2 | 0,
       _E_ = caml_check_bound(a, _D_)[1 + _D_],
       _F_ = x[1];
      if(caml_call2(cmp, caml_check_bound(a, _F_)[1 + _F_], _E_) < 0)
       x[1] = i31 + 2 | 0;
      return x[1];
     }
     if((i31 + 1 | 0) < l){
      var _G_ = i31 + 1 | 0, _H_ = caml_check_bound(a, _G_)[1 + _G_];
      if(0 > caml_call2(cmp, caml_check_bound(a, i31)[1 + i31], _H_))
       return i31 + 1 | 0;
     }
     if(i31 < l) return i31;
     throw caml_maybe_attach_backtrace([0, Bottom, i], 1);
    }
    var l = a.length - 1, _v_ = ((l + 1 | 0) / 3 | 0) - 1 | 0;
    if(_v_ >= 0){
     var i$6 = _v_;
     for(;;){
      var e$1 = caml_check_bound(a, i$6)[1 + i$6];
      try{
       var i = i$6;
       for(;;){
        var j = maxson(l, i);
        if(0 >= caml_call2(cmp, caml_check_bound(a, j)[1 + j], e$1)) break;
        var _s_ = caml_check_bound(a, j)[1 + j];
        caml_check_bound(a, i)[1 + i] = _s_;
        i = j;
       }
       caml_check_bound(a, i)[1 + i] = e$1;
      }
      catch(exn$0){
       var exn = caml_wrap_exception(exn$0);
       if(exn[1] !== Bottom) throw caml_maybe_attach_backtrace(exn, 0);
       var i$0 = exn[2];
       caml_check_bound(a, i$0)[1 + i$0] = e$1;
      }
      var _A_ = i$6 - 1 | 0;
      if(0 === i$6) break;
      i$6 = _A_;
     }
    }
    var _w_ = l - 1 | 0;
    if(_w_ >= 2){
     var i$4 = _w_;
     for(;;){
      var e$0 = caml_check_bound(a, i$4)[1 + i$4];
      a[1 + i$4] = caml_check_bound(a, 0)[1];
      var i$5 = 0;
      try{
       var i$1 = i$5;
       for(;;){
        var j$0 = maxson(i$4, i$1), _t_ = caml_check_bound(a, j$0)[1 + j$0];
        caml_check_bound(a, i$1)[1 + i$1] = _t_;
        i$1 = j$0;
       }
      }
      catch(exn){
       var exn$0 = caml_wrap_exception(exn);
       if(exn$0[1] !== Bottom) throw caml_maybe_attach_backtrace(exn$0, 0);
       var i$2 = exn$0[2];
       a:
       {
        b:
        {
         var i$3 = i$2;
         for(;;){
          var father = (i$3 - 1 | 0) / 3 | 0;
          if(i$3 === father)
           throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
          if
           (0 <= caml_call2(cmp, caml_check_bound(a, father)[1 + father], e$0))
           break;
          var _u_ = caml_check_bound(a, father)[1 + father];
          caml_check_bound(a, i$3)[1 + i$3] = _u_;
          if(0 >= father) break b;
          i$3 = father;
         }
         caml_check_bound(a, i$3)[1 + i$3] = e$0;
         break a;
        }
        caml_check_bound(a, 0)[1] = e$0;
       }
       var _z_ = i$4 - 1 | 0;
       if(2 === i$4) break;
       i$4 = _z_;
      }
     }
    }
    var _x_ = 1 < l ? 1 : 0;
    if(_x_){
     var e = caml_check_bound(a, 1)[2];
     a[2] = caml_check_bound(a, 0)[1];
     a[1] = e;
     var _y_ = 0;
    }
    else
     var _y_ = _x_;
    return _y_;
   }
   function stable_sort(cmp, a){
    function merge(src1ofs, src1len, src2, src2ofs, src2len, dst, dstofs){
     var
      src1r = src1ofs + src1len | 0,
      src2r = src2ofs + src2len | 0,
      s2$1 = caml_check_bound(src2, src2ofs)[1 + src2ofs],
      s1$1 = caml_check_bound(a, src1ofs)[1 + src1ofs],
      i1 = src1ofs,
      s1 = s1$1,
      i2 = src2ofs,
      s2 = s2$1,
      d = dstofs;
     for(;;)
      if(0 < caml_call2(cmp, s1, s2)){
       caml_check_bound(dst, d)[1 + d] = s2;
       var i2$0 = i2 + 1 | 0;
       if(i2$0 >= src2r) return blit(a, i1, dst, d + 1 | 0, src1r - i1 | 0);
       var d$0 = d + 1 | 0, s2$0 = caml_check_bound(src2, i2$0)[1 + i2$0];
       i2 = i2$0;
       s2 = s2$0;
       d = d$0;
      }
      else{
       caml_check_bound(dst, d)[1 + d] = s1;
       var i1$0 = i1 + 1 | 0;
       if(i1$0 >= src1r)
        return blit(src2, i2, dst, d + 1 | 0, src2r - i2 | 0);
       var d$1 = d + 1 | 0, s1$0 = caml_check_bound(a, i1$0)[1 + i1$0];
       i1 = i1$0;
       s1 = s1$0;
       d = d$1;
      }
    }
    function isortto(srcofs, dst, dstofs, len){
     var _k_ = len - 1 | 0, _j_ = 0;
     if(_k_ >= 0){
      var i = _j_;
      for(;;){
       var
        _l_ = srcofs + i | 0,
        e = caml_check_bound(a, _l_)[1 + _l_],
        j = [0, (dstofs + i | 0) - 1 | 0];
       for(;;){
        if(dstofs > j[1]) break;
        var _m_ = j[1];
        if(0 >= caml_call2(cmp, caml_check_bound(dst, _m_)[1 + _m_], e))
         break;
        var
         _n_ = j[1],
         _o_ = caml_check_bound(dst, _n_)[1 + _n_],
         _p_ = j[1] + 1 | 0;
        caml_check_bound(dst, _p_)[1 + _p_] = _o_;
        j[1]--;
       }
       var _q_ = j[1] + 1 | 0;
       caml_check_bound(dst, _q_)[1 + _q_] = e;
       var _r_ = i + 1 | 0;
       if(_k_ === i) break;
       i = _r_;
      }
     }
     return 0;
    }
    function sortto(srcofs, dst, dstofs, len){
     if(len <= 5) return isortto(srcofs, dst, dstofs, len);
     var l1 = len / 2 | 0, l2 = len - l1 | 0;
     sortto(srcofs + l1 | 0, dst, dstofs + l1 | 0, l2);
     sortto(srcofs, a, srcofs + l2 | 0, l1);
     return merge(srcofs + l2 | 0, l1, dst, dstofs + l1 | 0, l2, dst, dstofs);
    }
    var l = a.length - 1;
    if(l <= 5) return isortto(0, a, 0, l);
    var
     l1 = l / 2 | 0,
     l2 = l - l1 | 0,
     t = caml_make_vect(l2, caml_check_bound(a, 0)[1]);
    sortto(l1, t, 0, l2);
    sortto(0, a, l2, l1);
    return merge(l2, l1, t, 0, l2, a, 0);
   }
   function to_seq(a){
    function aux(i, param){
     if(i >= a.length - 1) return 0;
     var x = a[1 + i], _h_ = i + 1 | 0;
     return [0, x, function(_i_){return aux(_h_, _i_);}];
    }
    var _f_ = 0;
    return function(_g_){return aux(_f_, _g_);};
   }
   function to_seqi(a){
    function aux(i, param){
     if(i >= a.length - 1) return 0;
     var x = a[1 + i], _d_ = i + 1 | 0;
     return [0, [0, i, x], function(_e_){return aux(_d_, _e_);}];
    }
    var _b_ = 0;
    return function(_c_){return aux(_b_, _c_);};
   }
   function of_seq(i$2){
    var
     l =
       caml_call3
        (Stdlib_Seq[5], function(acc, x){return [0, x, acc];}, 0, i$2);
    if(! l) return [0];
    var
     tl = l[2],
     hd = l[1],
     len = list_length(0, l),
     a = caml_make_vect(len, hd),
     i$1 = len - 2 | 0,
     i = i$1,
     param = tl;
    for(;;){
     if(! param) return a;
     var tl$0 = param[2], hd$0 = param[1];
     a[1 + i] = hd$0;
     var i$0 = i - 1 | 0;
     i = i$0;
     param = tl$0;
    }
   }
   var
    Stdlib_Array =
      [0,
       make_float,
       init,
       make_matrix,
       make_matrix,
       append,
       runtime.caml_array_concat,
       sub,
       copy,
       fill,
       blit,
       to_list,
       of_list,
       iter,
       iteri,
       map,
       mapi,
       fold_left,
       fold_left_map,
       fold_right,
       iter2,
       map2,
       for_all,
       exists,
       for_all2,
       exists2,
       mem,
       memq,
       find_opt,
       find_map,
       split,
       combine,
       sort,
       stable_sort,
       stable_sort,
       to_seq,
       to_seqi,
       of_seq,
       Floatarray];
   runtime.caml_register_global(14, Stdlib_Array, "Stdlib__Array");
   return;
  }
  (globalThis));

//# 7011 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_greaterequal = runtime.caml_greaterequal,
    caml_int_compare = runtime.caml_int_compare,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_mul = runtime.caml_mul,
    caml_wrap_exception = runtime.caml_wrap_exception,
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Stdlib_Sys = global_data.Stdlib__Sys,
    Assert_failure = global_data.Assert_failure,
    zero = 0,
    one = 1;
   function succ(n){return n + 1 | 0;}
   function pred(n){return n - 1 | 0;}
   function abs(n){return caml_greaterequal(n, 0) ? n : - n | 0;}
   function lognot(n){return n ^ -1;}
   var
    _a_ = Stdlib_Sys[9],
    _b_ = [0, "int32.ml", 69, 6],
    minus_one = -1,
    min_int = -2147483648,
    max_int = 2147483647;
   if(32 === _a_)
    var
     max_int$0 = Stdlib[19],
     unsigned_to_int =
       function(n){
        if(0 >= caml_int_compare(0, n) && 0 >= caml_int_compare(n, max_int$0))
         return [0, n];
        return 0;
       };
   else{
    if(64 !== _a_)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
    var unsigned_to_int = function(n){return [0, n & -1];};
   }
   function to_string(n){return runtime.caml_format_int("%d", n);}
   function of_string_opt(s){
    try{var _d_ = [0, runtime.caml_int_of_string(s)]; return _d_;}
    catch(_e_){
     var _c_ = caml_wrap_exception(_e_);
     if(_c_[1] === Stdlib[7]) return 0;
     throw caml_maybe_attach_backtrace(_c_, 0);
    }
   }
   var compare = caml_int_compare;
   function equal(x, y){return 0 === caml_int_compare(x, y) ? 1 : 0;}
   function unsigned_compare(n, m){
    var y = m + 2147483648 | 0, x = n + 2147483648 | 0;
    return caml_int_compare(x, y);
   }
   function min(x, y){return runtime.caml_lessequal(x, y) ? x : y;}
   function max(x, y){return caml_greaterequal(x, y) ? x : y;}
   function unsigned_div(n, d){
    if(runtime.caml_lessthan(d, 0))
     return 0 <= unsigned_compare(n, d) ? one : zero;
    var q = runtime.caml_div(n >>> 1 | 0, d) << 1, r = n - caml_mul(q, d) | 0;
    return 0 <= unsigned_compare(r, d) ? q + 1 | 0 : q;
   }
   function unsigned_rem(n, d){
    return n - caml_mul(unsigned_div(n, d), d) | 0;
   }
   var
    Stdlib_Int32 =
      [0,
       zero,
       one,
       minus_one,
       unsigned_div,
       unsigned_rem,
       succ,
       pred,
       abs,
       max_int,
       min_int,
       lognot,
       unsigned_to_int,
       of_string_opt,
       to_string,
       compare,
       unsigned_compare,
       equal,
       min,
       max];
   runtime.caml_register_global(14, Stdlib_Int32, "Stdlib__Int32");
   return;
  }
  (globalThis));

//# 7106 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_greaterequal = runtime.caml_greaterequal,
    caml_int64_add = runtime.caml_int64_add,
    caml_int64_compare = runtime.caml_int64_compare,
    caml_int64_mul = runtime.caml_int64_mul,
    caml_int64_sub = runtime.caml_int64_sub,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception,
    global_data = runtime.caml_get_global_data(),
    _a_ = runtime.caml_int64_create_lo_mi_hi(1, 0, 0),
    zero = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    one = runtime.caml_int64_create_lo_mi_hi(1, 0, 0),
    minus_one = runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 65535),
    min_int = runtime.caml_int64_create_lo_mi_hi(0, 0, 32768),
    max_int = runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 32767),
    Stdlib = global_data.Stdlib,
    _b_ = runtime.caml_int64_create_lo_mi_hi(1, 0, 0),
    _c_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    _d_ = runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 65535);
   function succ(n){return caml_int64_add(n, _a_);}
   function pred(n){return caml_int64_sub(n, _b_);}
   function abs(n){
    return caml_greaterequal(n, _c_) ? n : runtime.caml_int64_neg(n);
   }
   function lognot(n){return runtime.caml_int64_xor(n, _d_);}
   var max_int$0 = runtime.caml_int64_of_int32(Stdlib[19]);
   function unsigned_to_int(n){
    if
     (0 >= caml_int64_compare(zero, n)
      && 0 >= caml_int64_compare(n, max_int$0))
     return [0, runtime.caml_int64_to_int32(n)];
    return 0;
   }
   function to_string(n){return runtime.caml_int64_format("%d", n);}
   function of_string_opt(s){
    try{var _f_ = [0, runtime.caml_int64_of_string(s)]; return _f_;}
    catch(_g_){
     var _e_ = caml_wrap_exception(_g_);
     if(_e_[1] === Stdlib[7]) return 0;
     throw caml_maybe_attach_backtrace(_e_, 0);
    }
   }
   function compare(x, y){return caml_int64_compare(x, y);}
   function equal(x, y){return 0 === caml_int64_compare(x, y) ? 1 : 0;}
   function unsigned_compare(n, m){
    var y = caml_int64_sub(m, min_int), x = caml_int64_sub(n, min_int);
    return caml_int64_compare(x, y);
   }
   function min(x, y){return runtime.caml_lessequal(x, y) ? x : y;}
   function max(x, y){return caml_greaterequal(x, y) ? x : y;}
   function unsigned_div(n, d){
    if(runtime.caml_lessthan(d, zero))
     return 0 <= unsigned_compare(n, d) ? one : zero;
    var
     q =
       runtime.caml_int64_shift_left
        (runtime.caml_int64_div
          (runtime.caml_int64_shift_right_unsigned(n, 1), d),
         1),
     r = caml_int64_sub(n, caml_int64_mul(q, d));
    return 0 <= unsigned_compare(r, d) ? caml_int64_add(q, _a_) : q;
   }
   function unsigned_rem(n, d){
    return caml_int64_sub(n, caml_int64_mul(unsigned_div(n, d), d));
   }
   var
    Stdlib_Int64 =
      [0,
       zero,
       one,
       minus_one,
       unsigned_div,
       unsigned_rem,
       succ,
       pred,
       abs,
       max_int,
       min_int,
       lognot,
       unsigned_to_int,
       of_string_opt,
       to_string,
       compare,
       unsigned_compare,
       equal,
       min,
       max];
   runtime.caml_register_global(11, Stdlib_Int64, "Stdlib__Int64");
   return;
  }
  (globalThis));

//# 7204 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_greaterequal = runtime.caml_greaterequal,
    caml_int_compare = runtime.caml_int_compare,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_mul = runtime.caml_mul,
    caml_wrap_exception = runtime.caml_wrap_exception,
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Stdlib_Sys = global_data.Stdlib__Sys,
    zero = 0,
    one = 1;
   function succ(n){return n + 1 | 0;}
   function pred(n){return n - 1 | 0;}
   function abs(n){return caml_greaterequal(n, 0) ? n : - n | 0;}
   var
    size = Stdlib_Sys[9],
    min_int = 1 << (size - 1 | 0),
    max_int = min_int - 1 | 0;
   function lognot(n){return n ^ -1;}
   var max_int$0 = Stdlib[19];
   function unsigned_to_int(n){
    if(0 >= caml_int_compare(0, n) && 0 >= caml_int_compare(n, max_int$0))
     return [0, n];
    return 0;
   }
   function to_string(n){return runtime.caml_format_int("%d", n);}
   function of_string_opt(s){
    try{var _b_ = [0, runtime.caml_int_of_string(s)]; return _b_;}
    catch(_c_){
     var _a_ = caml_wrap_exception(_c_);
     if(_a_[1] === Stdlib[7]) return 0;
     throw caml_maybe_attach_backtrace(_a_, 0);
    }
   }
   var compare = caml_int_compare;
   function equal(x, y){return 0 === caml_int_compare(x, y) ? 1 : 0;}
   function unsigned_compare(n, m){
    var y = m - min_int | 0, x = n - min_int | 0;
    return caml_int_compare(x, y);
   }
   function min(x, y){return runtime.caml_lessequal(x, y) ? x : y;}
   function max(x, y){return caml_greaterequal(x, y) ? x : y;}
   function unsigned_div(n, d){
    if(runtime.caml_lessthan(d, 0))
     return 0 <= unsigned_compare(n, d) ? one : zero;
    var q = runtime.caml_div(n >>> 1 | 0, d) << 1, r = n - caml_mul(q, d) | 0;
    return 0 <= unsigned_compare(r, d) ? q + 1 | 0 : q;
   }
   function unsigned_rem(n, d){
    return n - caml_mul(unsigned_div(n, d), d) | 0;
   }
   var
    Stdlib_Nativeint =
      [0,
       zero,
       one,
       -1,
       unsigned_div,
       unsigned_rem,
       succ,
       pred,
       abs,
       size,
       max_int,
       min_int,
       lognot,
       unsigned_to_int,
       of_string_opt,
       to_string,
       compare,
       unsigned_compare,
       equal,
       min,
       max];
   runtime.caml_register_global(12, Stdlib_Nativeint, "Stdlib__Nativeint");
   return;
  }
  (globalThis));

//# 8582 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Map_bal$3 = "Map.bal",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Seq = global_data.Stdlib__Seq,
    cst_Map_bal = cst_Map_bal$3,
    cst_Map_bal$0 = cst_Map_bal$3,
    cst_Map_bal$1 = cst_Map_bal$3,
    cst_Map_bal$2 = cst_Map_bal$3,
    cst_Map_remove_min_elt = "Map.remove_min_elt",
    _a_ = [0, 0, 0, 0],
    _b_ = [0, "map.ml", 400, 10],
    _c_ = [0, 0, 0],
    Stdlib_Map =
      [0,
       function(Ord){
        function height(param){
         if(! param) return 0;
         var h = param[5];
         return h;
        }
        function create(l, x, d, r){
         var
          hl = height(l),
          hr = height(r),
          _K_ = hr <= hl ? hl + 1 | 0 : hr + 1 | 0;
         return [0, l, x, d, r, _K_];
        }
        function singleton(x, d){return [0, 0, x, d, 0, 1];}
        function bal(l, x, d, r){
         if(l) var h = l[5], hl = h; else var hl = 0;
         if(r) var h$0 = r[5], hr = h$0; else var hr = 0;
         if((hr + 2 | 0) < hl){
          if(! l) return caml_call1(Stdlib[1], cst_Map_bal$0);
          var lr = l[4], ld = l[3], lv = l[2], ll = l[1], _F_ = height(lr);
          if(_F_ <= height(ll))
           return create(ll, lv, ld, create(lr, x, d, r));
          if(! lr) return caml_call1(Stdlib[1], cst_Map_bal);
          var
           lrr = lr[4],
           lrd = lr[3],
           lrv = lr[2],
           lrl = lr[1],
           _G_ = create(lrr, x, d, r);
          return create(create(ll, lv, ld, lrl), lrv, lrd, _G_);
         }
         if((hl + 2 | 0) >= hr){
          var _J_ = hr <= hl ? hl + 1 | 0 : hr + 1 | 0;
          return [0, l, x, d, r, _J_];
         }
         if(! r) return caml_call1(Stdlib[1], cst_Map_bal$2);
         var rr = r[4], rd = r[3], rv = r[2], rl = r[1], _H_ = height(rl);
         if(_H_ <= height(rr)) return create(create(l, x, d, rl), rv, rd, rr);
         if(! rl) return caml_call1(Stdlib[1], cst_Map_bal$1);
         var
          rlr = rl[4],
          rld = rl[3],
          rlv = rl[2],
          rll = rl[1],
          _I_ = create(rlr, rv, rd, rr);
         return create(create(l, x, d, rll), rlv, rld, _I_);
        }
        var empty = 0;
        function is_empty(param){return param ? 0 : 1;}
        function add(x, data, m){
         if(! m) return [0, 0, x, data, 0, 1];
         var
          h = m[5],
          r = m[4],
          d = m[3],
          v = m[2],
          l = m[1],
          c = caml_call2(Ord[1], x, v);
         if(0 === c) return d === data ? m : [0, l, x, data, r, h];
         if(0 <= c){
          var rr = add(x, data, r);
          return r === rr ? m : bal(l, v, d, rr);
         }
         var ll = add(x, data, l);
         return l === ll ? m : bal(ll, v, d, r);
        }
        function find(x, param){
         var param$0 = param;
         for(;;){
          if(! param$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
          var
           r = param$0[4],
           d = param$0[3],
           v = param$0[2],
           l = param$0[1],
           c = caml_call2(Ord[1], x, v);
          if(0 === c) return d;
          var r$0 = 0 <= c ? r : l;
          param$0 = r$0;
         }
        }
        function find_first(f, param$0){
         var param$1 = param$0;
         for(;;){
          if(! param$1) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
          var
           r$0 = param$1[4],
           d0$1 = param$1[3],
           v0$1 = param$1[2],
           l$0 = param$1[1];
          if(caml_call1(f, v0$1)){
           var v0 = v0$1, d0 = d0$1, param = l$0;
           for(;;){
            if(! param) return [0, v0, d0];
            var r = param[4], d0$0 = param[3], v0$0 = param[2], l = param[1];
            if(caml_call1(f, v0$0)){
             v0 = v0$0;
             d0 = d0$0;
             param = l;
            }
            else
             param = r;
           }
          }
          else
           param$1 = r$0;
         }
        }
        function find_first_opt(f, param$0){
         var param$1 = param$0;
         for(;;){
          if(! param$1) return 0;
          var
           r$0 = param$1[4],
           d0$1 = param$1[3],
           v0$1 = param$1[2],
           l$0 = param$1[1];
          if(caml_call1(f, v0$1)){
           var v0 = v0$1, d0 = d0$1, param = l$0;
           for(;;){
            if(! param) return [0, [0, v0, d0]];
            var r = param[4], d0$0 = param[3], v0$0 = param[2], l = param[1];
            if(caml_call1(f, v0$0)){
             v0 = v0$0;
             d0 = d0$0;
             param = l;
            }
            else
             param = r;
           }
          }
          else
           param$1 = r$0;
         }
        }
        function find_last(f, param$0){
         var param$1 = param$0;
         for(;;){
          if(! param$1) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
          var
           r$0 = param$1[4],
           d0$1 = param$1[3],
           v0$1 = param$1[2],
           l$0 = param$1[1];
          if(caml_call1(f, v0$1)){
           var v0 = v0$1, d0 = d0$1, param = r$0;
           for(;;){
            if(! param) return [0, v0, d0];
            var r = param[4], d0$0 = param[3], v0$0 = param[2], l = param[1];
            if(caml_call1(f, v0$0)){
             v0 = v0$0;
             d0 = d0$0;
             param = r;
            }
            else
             param = l;
           }
          }
          else
           param$1 = l$0;
         }
        }
        function find_last_opt(f, param$0){
         var param$1 = param$0;
         for(;;){
          if(! param$1) return 0;
          var
           r$0 = param$1[4],
           d0$1 = param$1[3],
           v0$1 = param$1[2],
           l$0 = param$1[1];
          if(caml_call1(f, v0$1)){
           var v0 = v0$1, d0 = d0$1, param = r$0;
           for(;;){
            if(! param) return [0, [0, v0, d0]];
            var r = param[4], d0$0 = param[3], v0$0 = param[2], l = param[1];
            if(caml_call1(f, v0$0)){
             v0 = v0$0;
             d0 = d0$0;
             param = r;
            }
            else
             param = l;
           }
          }
          else
           param$1 = l$0;
         }
        }
        function find_opt(x, param){
         var param$0 = param;
         for(;;){
          if(! param$0) return 0;
          var
           r = param$0[4],
           d = param$0[3],
           v = param$0[2],
           l = param$0[1],
           c = caml_call2(Ord[1], x, v);
          if(0 === c) return [0, d];
          var r$0 = 0 <= c ? r : l;
          param$0 = r$0;
         }
        }
        function mem(x, param){
         var param$0 = param;
         for(;;){
          if(! param$0) return 0;
          var
           r = param$0[4],
           v = param$0[2],
           l = param$0[1],
           c = caml_call2(Ord[1], x, v),
           _E_ = 0 === c ? 1 : 0;
          if(_E_) return _E_;
          var r$0 = 0 <= c ? r : l;
          param$0 = r$0;
         }
        }
        function min_binding(param){
         var param$0 = param;
         for(;;){
          if(! param$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
          var l = param$0[1];
          if(! l){var d = param$0[3], v = param$0[2]; return [0, v, d];}
          param$0 = l;
         }
        }
        function min_binding_opt(param){
         var param$0 = param;
         for(;;){
          if(! param$0) return 0;
          var l = param$0[1];
          if(! l){var d = param$0[3], v = param$0[2]; return [0, [0, v, d]];}
          param$0 = l;
         }
        }
        function max_binding(param){
         var param$0 = param;
         for(;;){
          if(! param$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
          if(! param$0[4]){
           var d = param$0[3], v = param$0[2];
           return [0, v, d];
          }
          var r = param$0[4];
          param$0 = r;
         }
        }
        function max_binding_opt(param){
         var param$0 = param;
         for(;;){
          if(! param$0) return 0;
          if(! param$0[4]){
           var d = param$0[3], v = param$0[2];
           return [0, [0, v, d]];
          }
          var r = param$0[4];
          param$0 = r;
         }
        }
        function remove_min_binding(param){
         if(! param) return caml_call1(Stdlib[1], cst_Map_remove_min_elt);
         var l = param[1];
         if(l){
          var r = param[4], d = param[3], v = param[2];
          return bal(remove_min_binding(l), v, d, r);
         }
         var r$0 = param[4];
         return r$0;
        }
        function _d_(t1, t2){
         if(! t1) return t2;
         if(! t2) return t1;
         var match = min_binding(t2), d = match[2], x = match[1];
         return bal(t1, x, d, remove_min_binding(t2));
        }
        function remove(x, m){
         if(! m) return 0;
         var
          r = m[4],
          d = m[3],
          v = m[2],
          l = m[1],
          c = caml_call2(Ord[1], x, v);
         if(0 === c) return _d_(l, r);
         if(0 <= c){
          var rr = remove(x, r);
          return r === rr ? m : bal(l, v, d, rr);
         }
         var ll = remove(x, l);
         return l === ll ? m : bal(ll, v, d, r);
        }
        function update(x, f, m){
         if(! m){
          var match$0 = caml_call1(f, 0);
          if(! match$0) return 0;
          var data$0 = match$0[1];
          return [0, 0, x, data$0, 0, 1];
         }
         var
          h = m[5],
          r = m[4],
          d = m[3],
          v = m[2],
          l = m[1],
          c = caml_call2(Ord[1], x, v);
         if(0 === c){
          var match = caml_call1(f, [0, d]);
          if(! match) return _d_(l, r);
          var data = match[1];
          return d === data ? m : [0, l, x, data, r, h];
         }
         if(0 <= c){
          var rr = update(x, f, r);
          return r === rr ? m : bal(l, v, d, rr);
         }
         var ll = update(x, f, l);
         return l === ll ? m : bal(ll, v, d, r);
        }
        function iter(f, param){
         var param$0 = param;
         for(;;){
          if(! param$0) return 0;
          var r = param$0[4], d = param$0[3], v = param$0[2], l = param$0[1];
          iter(f, l);
          caml_call2(f, v, d);
          param$0 = r;
         }
        }
        function map(f, param){
         if(! param) return 0;
         var
          h = param[5],
          r = param[4],
          d = param[3],
          v = param[2],
          l = param[1],
          l$0 = map(f, l),
          d$0 = caml_call1(f, d),
          r$0 = map(f, r);
         return [0, l$0, v, d$0, r$0, h];
        }
        function mapi(f, param){
         if(! param) return 0;
         var
          h = param[5],
          r = param[4],
          d = param[3],
          v = param[2],
          l = param[1],
          l$0 = mapi(f, l),
          d$0 = caml_call2(f, v, d),
          r$0 = mapi(f, r);
         return [0, l$0, v, d$0, r$0, h];
        }
        function fold(f, m, accu){
         var m$0 = m, accu$0 = accu;
         for(;;){
          if(! m$0) return accu$0;
          var
           r = m$0[4],
           d = m$0[3],
           v = m$0[2],
           l = m$0[1],
           accu$1 = caml_call3(f, v, d, fold(f, l, accu$0));
          m$0 = r;
          accu$0 = accu$1;
         }
        }
        function for_all(p, param){
         var param$0 = param;
         for(;;){
          if(! param$0) return 1;
          var
           r = param$0[4],
           d = param$0[3],
           v = param$0[2],
           l = param$0[1],
           _B_ = caml_call2(p, v, d);
          if(_B_){
           var _C_ = for_all(p, l);
           if(_C_){param$0 = r; continue;}
           var _D_ = _C_;
          }
          else
           var _D_ = _B_;
          return _D_;
         }
        }
        function exists(p, param){
         var param$0 = param;
         for(;;){
          if(! param$0) return 0;
          var
           r = param$0[4],
           d = param$0[3],
           v = param$0[2],
           l = param$0[1],
           _y_ = caml_call2(p, v, d);
          if(_y_)
           var _z_ = _y_;
          else{
           var _A_ = exists(p, l);
           if(! _A_){param$0 = r; continue;}
           var _z_ = _A_;
          }
          return _z_;
         }
        }
        function add_min_binding(k, x, param){
         if(! param) return singleton(k, x);
         var r = param[4], d = param[3], v = param[2], l = param[1];
         return bal(add_min_binding(k, x, l), v, d, r);
        }
        function add_max_binding(k, x, param){
         if(! param) return singleton(k, x);
         var r = param[4], d = param[3], v = param[2], l = param[1];
         return bal(l, v, d, add_max_binding(k, x, r));
        }
        function join(l, v, d, r){
         if(! l) return add_min_binding(v, d, r);
         if(! r) return add_max_binding(v, d, l);
         var
          rh = r[5],
          rr = r[4],
          rd = r[3],
          rv = r[2],
          rl = r[1],
          lh = l[5],
          lr = l[4],
          ld = l[3],
          lv = l[2],
          ll = l[1];
         return (rh + 2 | 0) < lh
                 ? bal(ll, lv, ld, join(lr, v, d, r))
                 : (lh
                   + 2
                   | 0)
                   < rh
                   ? bal(join(l, v, d, rl), rv, rd, rr)
                   : create(l, v, d, r);
        }
        function concat(t1, t2){
         if(! t1) return t2;
         if(! t2) return t1;
         var match = min_binding(t2), d = match[2], x = match[1];
         return join(t1, x, d, remove_min_binding(t2));
        }
        function concat_or_join(t1, v, d, t2){
         if(! d) return concat(t1, t2);
         var d$0 = d[1];
         return join(t1, v, d$0, t2);
        }
        function split(x, param){
         if(! param) return _a_;
         var
          r = param[4],
          d = param[3],
          v = param[2],
          l = param[1],
          c = caml_call2(Ord[1], x, v);
         if(0 === c) return [0, l, [0, d], r];
         if(0 <= c){
          var
           match = split(x, r),
           rr = match[3],
           pres = match[2],
           lr = match[1];
          return [0, join(l, v, d, lr), pres, rr];
         }
         var
          match$0 = split(x, l),
          rl = match$0[3],
          pres$0 = match$0[2],
          ll = match$0[1];
         return [0, ll, pres$0, join(rl, v, d, r)];
        }
        function merge(f, s1, s2){
         if(s1){
          var h1 = s1[5], r1 = s1[4], d1 = s1[3], v1 = s1[2], l1 = s1[1];
          if(height(s2) <= h1){
           var
            match = split(v1, s2),
            r2 = match[3],
            d2 = match[2],
            l2 = match[1],
            _u_ = merge(f, r1, r2),
            _v_ = caml_call3(f, v1, [0, d1], d2);
           return concat_or_join(merge(f, l1, l2), v1, _v_, _u_);
          }
         }
         else if(! s2) return 0;
         if(! s2)
          throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
         var
          r2$0 = s2[4],
          d2$0 = s2[3],
          v2 = s2[2],
          l2$0 = s2[1],
          match$0 = split(v2, s1),
          r1$0 = match$0[3],
          d1$0 = match$0[2],
          l1$0 = match$0[1],
          _w_ = merge(f, r1$0, r2$0),
          _x_ = caml_call3(f, v2, d1$0, [0, d2$0]);
         return concat_or_join(merge(f, l1$0, l2$0), v2, _x_, _w_);
        }
        function union(f, s1, s2){
         if(s1){
          if(s2){
           var
            h2 = s2[5],
            r2 = s2[4],
            d2 = s2[3],
            v2 = s2[2],
            l2 = s2[1],
            h1 = s1[5],
            r1 = s1[4],
            d1 = s1[3],
            v1 = s1[2],
            l1 = s1[1];
           if(h2 <= h1){
            var
             match = split(v1, s2),
             r2$0 = match[3],
             d2$0 = match[2],
             l2$0 = match[1],
             l = union(f, l1, l2$0),
             r = union(f, r1, r2$0);
            if(! d2$0) return join(l, v1, d1, r);
            var d2$1 = d2$0[1];
            return concat_or_join(l, v1, caml_call3(f, v1, d1, d2$1), r);
           }
           var
            match$0 = split(v2, s1),
            r1$0 = match$0[3],
            d1$0 = match$0[2],
            l1$0 = match$0[1],
            l$0 = union(f, l1$0, l2),
            r$0 = union(f, r1$0, r2);
           if(! d1$0) return join(l$0, v2, d2, r$0);
           var d1$1 = d1$0[1];
           return concat_or_join(l$0, v2, caml_call3(f, v2, d1$1, d2), r$0);
          }
          var s = s1;
         }
         else
          var s = s2;
         return s;
        }
        function filter(p, m){
         if(! m) return 0;
         var
          r = m[4],
          d = m[3],
          v = m[2],
          l = m[1],
          l$0 = filter(p, l),
          pvd = caml_call2(p, v, d),
          r$0 = filter(p, r);
         if(! pvd) return concat(l$0, r$0);
         if(l === l$0 && r === r$0) return m;
         return join(l$0, v, d, r$0);
        }
        function filter_map(f, param){
         if(! param) return 0;
         var
          r = param[4],
          d = param[3],
          v = param[2],
          l = param[1],
          l$0 = filter_map(f, l),
          fvd = caml_call2(f, v, d),
          r$0 = filter_map(f, r);
         if(! fvd) return concat(l$0, r$0);
         var d$0 = fvd[1];
         return join(l$0, v, d$0, r$0);
        }
        function partition(p, param){
         if(! param) return _c_;
         var
          r = param[4],
          d = param[3],
          v = param[2],
          l = param[1],
          match = partition(p, l),
          lf = match[2],
          lt = match[1],
          pvd = caml_call2(p, v, d),
          match$0 = partition(p, r),
          rf = match$0[2],
          rt = match$0[1];
         if(pvd){
          var _s_ = concat(lf, rf);
          return [0, join(lt, v, d, rt), _s_];
         }
         var _t_ = join(lf, v, d, rf);
         return [0, concat(lt, rt), _t_];
        }
        function cons_enum(m, e){
         var m$0 = m, e$0 = e;
         for(;;){
          if(! m$0) return e$0;
          var
           r = m$0[4],
           d = m$0[3],
           v = m$0[2],
           l = m$0[1],
           e$1 = [0, v, d, r, e$0];
          m$0 = l;
          e$0 = e$1;
         }
        }
        function compare(cmp, m1, m2){
         var
          e2$2 = cons_enum(m2, 0),
          e1$2 = cons_enum(m1, 0),
          e1 = e1$2,
          e2 = e2$2;
         for(;;){
          if(! e1) return e2 ? -1 : 0;
          if(! e2) return 1;
          var
           e2$0 = e2[4],
           r2 = e2[3],
           d2 = e2[2],
           v2 = e2[1],
           e1$0 = e1[4],
           r1 = e1[3],
           d1 = e1[2],
           v1 = e1[1],
           c = caml_call2(Ord[1], v1, v2);
          if(0 !== c) return c;
          var c$0 = caml_call2(cmp, d1, d2);
          if(0 !== c$0) return c$0;
          var e2$1 = cons_enum(r2, e2$0), e1$1 = cons_enum(r1, e1$0);
          e1 = e1$1;
          e2 = e2$1;
         }
        }
        function equal(cmp, m1, m2){
         var
          e2$2 = cons_enum(m2, 0),
          e1$2 = cons_enum(m1, 0),
          e1 = e1$2,
          e2 = e2$2;
         for(;;){
          if(! e1) return e2 ? 0 : 1;
          if(! e2) return 0;
          var
           e2$0 = e2[4],
           r2 = e2[3],
           d2 = e2[2],
           v2 = e2[1],
           e1$0 = e1[4],
           r1 = e1[3],
           d1 = e1[2],
           v1 = e1[1],
           _p_ = 0 === caml_call2(Ord[1], v1, v2) ? 1 : 0;
          if(_p_){
           var _q_ = caml_call2(cmp, d1, d2);
           if(_q_){
            var e2$1 = cons_enum(r2, e2$0), e1$1 = cons_enum(r1, e1$0);
            e1 = e1$1;
            e2 = e2$1;
            continue;
           }
           var _r_ = _q_;
          }
          else
           var _r_ = _p_;
          return _r_;
         }
        }
        function cardinal(param){
         if(! param) return 0;
         var r = param[4], l = param[1], _o_ = cardinal(r);
         return (cardinal(l) + 1 | 0) + _o_ | 0;
        }
        function bindings_aux(accu, param){
         var accu$0 = accu, param$0 = param;
         for(;;){
          if(! param$0) return accu$0;
          var
           r = param$0[4],
           d = param$0[3],
           v = param$0[2],
           l = param$0[1],
           accu$1 = [0, [0, v, d], bindings_aux(accu$0, r)];
          accu$0 = accu$1;
          param$0 = l;
         }
        }
        function bindings(s){return bindings_aux(0, s);}
        function add_seq(i, m){
         return caml_call3
                 (Stdlib_Seq[5],
                  function(m, param){
                   var v = param[2], k = param[1];
                   return add(k, v, m);
                  },
                  m,
                  i);
        }
        function of_seq(i){return add_seq(i, empty);}
        function seq_of_enum(c, param){
         if(! c) return 0;
         var
          rest = c[4],
          t = c[3],
          v = c[2],
          k = c[1],
          _m_ = cons_enum(t, rest);
         return [0, [0, k, v], function(_n_){return seq_of_enum(_m_, _n_);}];
        }
        function to_seq(m){
         var _k_ = cons_enum(m, 0);
         return function(_l_){return seq_of_enum(_k_, _l_);};
        }
        function snoc_enum(s, e){
         var s$0 = s, e$0 = e;
         for(;;){
          if(! s$0) return e$0;
          var
           r = s$0[4],
           d = s$0[3],
           v = s$0[2],
           l = s$0[1],
           e$1 = [0, v, d, l, e$0];
          s$0 = r;
          e$0 = e$1;
         }
        }
        function rev_seq_of_enum(c, param){
         if(! c) return 0;
         var
          rest = c[4],
          t = c[3],
          v = c[2],
          k = c[1],
          _i_ = snoc_enum(t, rest);
         return [0,
                 [0, k, v],
                 function(_j_){return rev_seq_of_enum(_i_, _j_);}];
        }
        function to_rev_seq(c){
         var _g_ = snoc_enum(c, 0);
         return function(_h_){return rev_seq_of_enum(_g_, _h_);};
        }
        function to_seq_from(low, m){
         a:
         {
          b:
          {
           var m$0 = m, c = 0;
           for(;;){
            if(! m$0) break;
            var
             r = m$0[4],
             d = m$0[3],
             v = m$0[2],
             l = m$0[1],
             n = caml_call2(Ord[1], v, low);
            if(0 === n) break b;
            if(0 <= n){
             var c$0 = [0, v, d, r, c];
             m$0 = l;
             c = c$0;
            }
            else
             m$0 = r;
           }
           var _e_ = c;
           break a;
          }
          var _e_ = [0, v, d, r, c];
         }
         return function(_f_){return seq_of_enum(_e_, _f_);};
        }
        return [0,
                empty,
                is_empty,
                mem,
                add,
                update,
                singleton,
                remove,
                merge,
                union,
                compare,
                equal,
                iter,
                fold,
                for_all,
                exists,
                filter,
                filter_map,
                partition,
                cardinal,
                bindings,
                min_binding,
                min_binding_opt,
                max_binding,
                max_binding_opt,
                min_binding,
                min_binding_opt,
                split,
                find,
                find_opt,
                find_first,
                find_first_opt,
                find_last,
                find_last_opt,
                map,
                mapi,
                to_seq,
                to_rev_seq,
                to_seq_from,
                add_seq,
                of_seq];
       }];
   runtime.caml_register_global(11, Stdlib_Map, "Stdlib__Map");
   return;
  }
  (globalThis));

//# 10064 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_buffer_ml = "buffer.ml",
    caml_blit_string = runtime.caml_blit_string,
    caml_bswap16 = runtime.caml_bswap16,
    caml_bytes_unsafe_get = runtime.caml_bytes_unsafe_get,
    caml_bytes_unsafe_set = runtime.caml_bytes_unsafe_set,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_int32_bswap = runtime.caml_int32_bswap,
    caml_int64_bswap = runtime.caml_int64_bswap,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_bytes_length = runtime.caml_ml_bytes_length,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_get = runtime.caml_string_get;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Stdlib_Sys = global_data.Stdlib__Sys,
    Stdlib_Seq = global_data.Stdlib__Seq,
    Stdlib = global_data.Stdlib,
    Stdlib_String = global_data.Stdlib__String,
    Assert_failure = global_data.Assert_failure,
    cst_Buffer_sub = "Buffer.sub",
    cst_Buffer_blit = "Buffer.blit",
    cst_Buffer_nth = "Buffer.nth",
    _a_ = [0, cst_buffer_ml, 94, 2],
    _b_ = [0, cst_buffer_ml, 93, 2],
    cst_Buffer_add_cannot_grow_buf = "Buffer.add: cannot grow buffer";
   function create(n){
    var
     n$0 = 1 <= n ? n : 1,
     n$1 = Stdlib_Sys[12] < n$0 ? Stdlib_Sys[12] : n$0,
     s = caml_create_bytes(n$1);
    return [0, s, 0, n$1, s];
   }
   function contents(b){return caml_call3(Stdlib_Bytes[8], b[1], 0, b[2]);}
   function to_bytes(b){return caml_call3(Stdlib_Bytes[7], b[1], 0, b[2]);}
   function sub(b, ofs, len){
    if(0 <= ofs && 0 <= len && (b[2] - len | 0) >= ofs)
     return caml_call3(Stdlib_Bytes[8], b[1], ofs, len);
    return caml_call1(Stdlib[1], cst_Buffer_sub);
   }
   function blit(src, srcoff, dst, dstoff, len){
    if
     (0 <= len
      &&
       0 <= srcoff
       &&
        (src[2] - len | 0) >= srcoff
        && 0 <= dstoff && (caml_ml_bytes_length(dst) - len | 0) >= dstoff)
     return runtime.caml_blit_bytes(src[1], srcoff, dst, dstoff, len);
    return caml_call1(Stdlib[1], cst_Buffer_blit);
   }
   function nth(b, ofs){
    if(0 <= ofs && b[2] > ofs) return caml_bytes_unsafe_get(b[1], ofs);
    return caml_call1(Stdlib[1], cst_Buffer_nth);
   }
   function length(b){return b[2];}
   function clear(b){b[2] = 0; return 0;}
   function reset(b){
    b[2] = 0;
    b[1] = b[4];
    b[3] = caml_ml_bytes_length(b[1]);
    return 0;
   }
   function resize(b, more){
    var old_pos = b[2], old_len = b[3], new_len = [0, old_len];
    for(;;){
     if(new_len[1] >= (old_pos + more | 0)) break;
     new_len[1] = 2 * new_len[1] | 0;
    }
    if(Stdlib_Sys[12] < new_len[1])
     if((old_pos + more | 0) <= Stdlib_Sys[12])
      new_len[1] = Stdlib_Sys[12];
     else
      caml_call1(Stdlib[2], cst_Buffer_add_cannot_grow_buf);
    var new_buffer = caml_create_bytes(new_len[1]);
    caml_call5(Stdlib_Bytes[11], b[1], 0, new_buffer, 0, b[2]);
    b[1] = new_buffer;
    b[3] = new_len[1];
    if((b[2] + more | 0) > b[3])
     throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
    if((old_pos + more | 0) <= b[3]) return;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
   }
   function add_char(b, c){
    var pos = b[2];
    if(b[3] <= pos) resize(b, 1);
    caml_bytes_unsafe_set(b[1], pos, c);
    b[2] = pos + 1 | 0;
    return 0;
   }
   var
    uchar_utf_8_byte_length_max = 4,
    uchar_utf_16_byte_length_max = 4,
    cst_Buffer_add_substring_add_s = "Buffer.add_substring/add_subbytes",
    _c_ = [0, cst_buffer_ml, 212, 2],
    cst_Buffer_add_channel = "Buffer.add_channel",
    _d_ = [0, cst_buffer_ml, 231, 9],
    cst_Buffer_truncate = "Buffer.truncate";
   function add_utf_8_uchar(b, u){
    for(;;){
     var pos = b[2];
     if(b[3] <= pos) resize(b, uchar_utf_8_byte_length_max);
     var n = caml_call3(Stdlib_Bytes[55], b[1], pos, u);
     if(0 !== n){b[2] = pos + n | 0; return 0;}
     resize(b, uchar_utf_8_byte_length_max);
    }
   }
   function add_utf_16be_uchar(b, u){
    for(;;){
     var pos = b[2];
     if(b[3] <= pos) resize(b, uchar_utf_16_byte_length_max);
     var n = caml_call3(Stdlib_Bytes[58], b[1], pos, u);
     if(0 !== n){b[2] = pos + n | 0; return 0;}
     resize(b, uchar_utf_16_byte_length_max);
    }
   }
   function add_utf_16le_uchar(b, u){
    for(;;){
     var pos = b[2];
     if(b[3] <= pos) resize(b, uchar_utf_16_byte_length_max);
     var n = caml_call3(Stdlib_Bytes[61], b[1], pos, u);
     if(0 !== n){b[2] = pos + n | 0; return 0;}
     resize(b, uchar_utf_16_byte_length_max);
    }
   }
   function add_substring(b, s, offset, len){
    var _t_ = offset < 0 ? 1 : 0;
    if(_t_)
     var _u_ = _t_;
    else
     var
      _v_ = len < 0 ? 1 : 0,
      _u_ = _v_ || ((caml_ml_string_length(s) - len | 0) < offset ? 1 : 0);
    if(_u_) caml_call1(Stdlib[1], cst_Buffer_add_substring_add_s);
    var new_position = b[2] + len | 0;
    if(b[3] < new_position) resize(b, len);
    caml_blit_string(s, offset, b[1], b[2], len);
    b[2] = new_position;
    return 0;
   }
   function add_subbytes(b, s, offset, len){
    return add_substring(b, caml_call1(Stdlib_Bytes[48], s), offset, len);
   }
   function add_string(b, s){
    var len = caml_ml_string_length(s), new_position = b[2] + len | 0;
    if(b[3] < new_position) resize(b, len);
    caml_blit_string(s, 0, b[1], b[2], len);
    b[2] = new_position;
    return 0;
   }
   function add_bytes(b, s){
    return add_string(b, caml_call1(Stdlib_Bytes[48], s));
   }
   function add_buffer(b, bs){return add_subbytes(b, bs[1], 0, bs[2]);}
   function add_channel(b, ic, to_read$1){
    var
     _r_ = to_read$1 < 0 ? 1 : 0,
     _s_ = _r_ || (Stdlib_Sys[12] < to_read$1 ? 1 : 0);
    if(_s_) caml_call1(Stdlib[1], cst_Buffer_add_channel);
    if(b[3] < (b[2] + to_read$1 | 0)) resize(b, to_read$1);
    var
     ofs$1 = b[2],
     buf = b[1],
     already_read = 0,
     ofs = ofs$1,
     to_read = to_read$1;
    for(;;){
     if(0 !== to_read){
      var r = caml_call4(Stdlib[84], ic, buf, ofs, to_read);
      if(0 !== r){
       var
        already_read$0 = already_read + r | 0,
        ofs$0 = ofs + r | 0,
        to_read$0 = to_read - r | 0;
       already_read = already_read$0;
       ofs = ofs$0;
       to_read = to_read$0;
       continue;
      }
     }
     if((b[2] + already_read | 0) > b[3])
      throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
     b[2] = b[2] + already_read | 0;
     if(already_read < to_read$1)
      throw caml_maybe_attach_backtrace(Stdlib[12], 1);
     return 0;
    }
   }
   function output_buffer(oc, b){
    return caml_call4(Stdlib[68], oc, b[1], 0, b[2]);
   }
   function add_substitute(b, f, s){
    var lim$1 = caml_ml_string_length(s), previous = 32, i$4 = 0;
    for(;;){
     if(i$4 >= lim$1){
      var _q_ = 92 === previous ? 1 : 0;
      return _q_ ? add_char(b, previous) : _q_;
     }
     var previous$0 = caml_string_get(s, i$4);
     if(36 === previous$0)
      if(92 === previous){
       add_char(b, previous$0);
       var i$5 = i$4 + 1 | 0;
       previous = 32;
       i$4 = i$5;
      }
      else{
       var start$0 = i$4 + 1 | 0;
       if(lim$1 <= start$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
       var opening = caml_string_get(s, start$0);
       a:
       {
        if(40 !== opening && 123 !== opening){
         var start = start$0 + 1 | 0, lim$0 = caml_ml_string_length(s);
         b:
         {
          c:
          {
           d:
           {
            var i$2 = start;
            for(;;){
             if(lim$0 <= i$2) break c;
             var match = caml_string_get(s, i$2);
             if(91 <= match){
              if(97 <= match){
               if(123 <= match) break d;
              }
              else if(95 !== match) break d;
             }
             else
              if(58 <= match){
               if(65 > match) break;
              }
              else if(48 > match) break d;
             var i$3 = i$2 + 1 | 0;
             i$2 = i$3;
            }
           }
           var stop$0 = i$2;
           break b;
          }
          var stop$0 = lim$0;
         }
         var
          match$0 =
            [0,
             caml_call3(Stdlib_String[15], s, start$0, stop$0 - start$0 | 0),
             stop$0];
         break a;
        }
        var new_start = start$0 + 1 | 0, k$2 = 0;
        if(40 === opening)
         var closing = 41;
        else{
         if(123 !== opening)
          throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
         var closing = 125;
        }
        var lim = caml_ml_string_length(s), k = k$2, stop = new_start;
        for(;;){
         if(lim <= stop) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
         if(caml_string_get(s, stop) === opening){
          var i = stop + 1 | 0, k$0 = k + 1 | 0;
          k = k$0;
          stop = i;
         }
         else if(caml_string_get(s, stop) === closing){
          if(0 === k) break;
          var i$0 = stop + 1 | 0, k$1 = k - 1 | 0;
          k = k$1;
          stop = i$0;
         }
         else{var i$1 = stop + 1 | 0; stop = i$1;}
        }
        var
         match$0 =
           [0,
            caml_call3
             (Stdlib_String[15], s, new_start, (stop - start$0 | 0) - 1 | 0),
            stop + 1 | 0];
       }
       var next_i = match$0[2], ident = match$0[1];
       add_string(b, caml_call1(f, ident));
       previous = 32;
       i$4 = next_i;
      }
     else if(92 === previous){
      add_char(b, 92);
      add_char(b, previous$0);
      var i$6 = i$4 + 1 | 0;
      previous = 32;
      i$4 = i$6;
     }
     else if(92 === previous$0){
      var i$7 = i$4 + 1 | 0;
      previous = previous$0;
      i$4 = i$7;
     }
     else{
      add_char(b, previous$0);
      var i$8 = i$4 + 1 | 0;
      previous = previous$0;
      i$4 = i$8;
     }
    }
   }
   function truncate(b, len){
    if(0 <= len && b[2] >= len){b[2] = len; return 0;}
    return caml_call1(Stdlib[1], cst_Buffer_truncate);
   }
   function to_seq(b){
    function aux(i, param){
     if(b[2] <= i) return 0;
     var x = caml_bytes_unsafe_get(b[1], i), _o_ = i + 1 | 0;
     return [0, x, function(_p_){return aux(_o_, _p_);}];
    }
    var _m_ = 0;
    return function(_n_){return aux(_m_, _n_);};
   }
   function to_seqi(b){
    function aux(i, param){
     if(b[2] <= i) return 0;
     var x = caml_bytes_unsafe_get(b[1], i), _k_ = i + 1 | 0;
     return [0, [0, i, x], function(_l_){return aux(_k_, _l_);}];
    }
    var _i_ = 0;
    return function(_j_){return aux(_i_, _j_);};
   }
   function add_seq(b, seq){
    return caml_call2
            (Stdlib_Seq[4], function(_h_){return add_char(b, _h_);}, seq);
   }
   function of_seq(i){var b = create(32); add_seq(b, i); return b;}
   function add_int8(b, x){
    var new_position = b[2] + 1 | 0;
    if(b[3] < new_position) resize(b, 1);
    caml_bytes_unsafe_set(b[1], b[2], x);
    b[2] = new_position;
    return 0;
   }
   function add_int16_ne(b, x){
    var new_position = b[2] + 2 | 0;
    if(b[3] < new_position) resize(b, 2);
    runtime.caml_bytes_set16(b[1], b[2], x);
    b[2] = new_position;
    return 0;
   }
   function add_int32_ne(b, x){
    var new_position = b[2] + 4 | 0;
    if(b[3] < new_position) resize(b, 4);
    runtime.caml_bytes_set32(b[1], b[2], x);
    b[2] = new_position;
    return 0;
   }
   function add_int64_ne(b, x){
    var new_position = b[2] + 8 | 0;
    if(b[3] < new_position) resize(b, 8);
    runtime.caml_bytes_set64(b[1], b[2], x);
    b[2] = new_position;
    return 0;
   }
   function add_int16_le(b, x){
    var _g_ = Stdlib_Sys[11] ? caml_bswap16(x) : x;
    return add_int16_ne(b, _g_);
   }
   function add_int16_be(b, x){
    var x$0 = Stdlib_Sys[11] ? x : caml_bswap16(x);
    return add_int16_ne(b, x$0);
   }
   function add_int32_le(b, x){
    var _f_ = Stdlib_Sys[11] ? caml_int32_bswap(x) : x;
    return add_int32_ne(b, _f_);
   }
   function add_int32_be(b, x){
    var x$0 = Stdlib_Sys[11] ? x : caml_int32_bswap(x);
    return add_int32_ne(b, x$0);
   }
   function add_int64_le(b, x){
    var _e_ = Stdlib_Sys[11] ? caml_int64_bswap(x) : x;
    return add_int64_ne(b, _e_);
   }
   function add_int64_be(b, x){
    var x$0 = Stdlib_Sys[11] ? x : caml_int64_bswap(x);
    return add_int64_ne(b, x$0);
   }
   var
    Stdlib_Buffer =
      [0,
       create,
       contents,
       to_bytes,
       sub,
       blit,
       nth,
       length,
       clear,
       reset,
       output_buffer,
       truncate,
       add_char,
       add_utf_8_uchar,
       add_utf_16le_uchar,
       add_utf_16be_uchar,
       add_string,
       add_bytes,
       add_substring,
       add_subbytes,
       add_substitute,
       add_buffer,
       add_channel,
       to_seq,
       to_seqi,
       add_seq,
       of_seq,
       add_int8,
       add_int8,
       add_int16_ne,
       add_int16_be,
       add_int16_le,
       add_int16_ne,
       add_int16_be,
       add_int16_le,
       add_int32_ne,
       add_int32_be,
       add_int32_le,
       add_int64_ne,
       add_int64_be,
       add_int64_le];
   runtime.caml_register_global(17, Stdlib_Buffer, "Stdlib__Buffer");
   return;
  }
  (globalThis));

//# 10531 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$43 = "",
    cst_and = " and ",
    cst_Li$3 = "%Li",
    cst_i$3 = "%i",
    cst_li$3 = "%li",
    cst_ni$3 = "%ni",
    cst_u$0 = "%u",
    cst$42 = "' '",
    cst$41 = "'#'",
    cst$39 = "'*'",
    cst$40 = "'+'",
    cst$44 = ", ",
    cst_0$3 = "0",
    cst_at_character_number = ": at character number ",
    cst$38 = "@[",
    cst$37 = "@{",
    cst_bad_input_format_type_mism =
      "bad input: format type mismatch between ",
    cst_bad_input_format_type_mism$0 =
      "bad input: format type mismatch between %S and %S",
    cst_camlinternalFormat_ml = "camlinternalFormat.ml",
    cst_invalid_format = "invalid format ",
    cst_precision$3 = "precision",
    caml_blit_string = runtime.caml_blit_string,
    caml_bytes_set = runtime.caml_bytes_set,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_format_float = runtime.caml_format_float,
    caml_format_int = runtime.caml_format_int,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_notequal = runtime.caml_notequal,
    caml_string_get = runtime.caml_string_get,
    caml_string_unsafe_get = runtime.caml_string_unsafe_get,
    caml_trampoline = runtime.caml_trampoline,
    caml_trampoline_return = runtime.caml_trampoline_return,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    cst$9 = "%{",
    cst$10 = "%}",
    cst$11 = "%(",
    cst$12 = "%)",
    cst$13 = "%?",
    cst$18 = cst$37,
    cst$19 = cst$38,
    cst$20 = cst$37,
    cst$21 = cst$38,
    cst$22 = cst$37,
    cst$23 = cst$38,
    cst$26 = cst$39,
    cst$24 = "'-'",
    cst$25 = cst$39,
    cst$27 = cst$40,
    cst$28 = cst$41,
    cst$29 = cst$42,
    cst$30 = cst$40,
    cst$31 = "'_'",
    sub_format = [0, 0, cst$43],
    formatting_lit = [0, "@;", 1, 0],
    cst$35 = cst$41,
    cst$32 = cst$40,
    cst$33 = cst$40,
    cst$34 = cst$42,
    cst$36 = cst$40,
    cst_unexpected_end_of_format = "unexpected end of format",
    cst$17 = ".",
    cst$14 = "%!",
    cst$15 = cst$37,
    cst$16 = cst$38,
    cst$8 = "%%",
    cst$0 = "@]",
    cst$1 = "@}",
    cst$2 = "@?",
    cst$3 = "@\n",
    cst$4 = "@.",
    cst$5 = "@@",
    cst$6 = "@%",
    cst$7 = "@",
    cst = ".*",
    Assert_failure = global_data.Assert_failure,
    CamlinternalFormatBasics = global_data.CamlinternalFormatBasics,
    Stdlib = global_data.Stdlib,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib_Sys = global_data.Stdlib__Sys,
    Stdlib_Char = global_data.Stdlib__Char,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Stdlib_Int = global_data.Stdlib__Int,
    _a_ = [0, 0, 0],
    cst_c = "%c",
    cst_s = "%s",
    cst_i = cst_i$3,
    cst_li = cst_li$3,
    cst_ni = cst_ni$3,
    cst_Li = cst_Li$3,
    cst_f = "%f",
    cst_B = "%B",
    cst_a = "%a",
    cst_t = "%t",
    cst_r = "%r",
    cst_r$0 = "%_r",
    cst_0c = "0c",
    _b_ = [0, cst_camlinternalFormat_ml, 850, 23],
    _c_ = [0, cst_camlinternalFormat_ml, 837, 26],
    _d_ = [0, cst_camlinternalFormat_ml, 847, 28],
    _e_ = [0, cst_camlinternalFormat_ml, 815, 21],
    _f_ = [0, cst_camlinternalFormat_ml, 819, 21],
    _g_ = [0, cst_camlinternalFormat_ml, 823, 19],
    _h_ = [0, cst_camlinternalFormat_ml, 827, 22],
    _i_ = [0, cst_camlinternalFormat_ml, 832, 30],
    _j_ = [0, cst_camlinternalFormat_ml, 851, 23],
    _k_ = [0, cst_camlinternalFormat_ml, 836, 26],
    _l_ = [0, cst_camlinternalFormat_ml, 846, 28],
    _m_ = [0, cst_camlinternalFormat_ml, 814, 21],
    _n_ = [0, cst_camlinternalFormat_ml, 818, 21],
    _o_ = [0, cst_camlinternalFormat_ml, 822, 19],
    _p_ = [0, cst_camlinternalFormat_ml, 826, 22],
    _q_ = [0, cst_camlinternalFormat_ml, 831, 30];
   function create_char_set(param){return caml_call2(Stdlib_Bytes[1], 32, 0);}
   function add_in_char_set(char_set, c){
    var
     str_ind = c >>> 3 | 0,
     mask = 1 << (c & 7),
     _cU_ = runtime.caml_bytes_get(char_set, str_ind) | mask;
    return caml_bytes_set(char_set, str_ind, caml_call1(Stdlib[29], _cU_));
   }
   function freeze_char_set(char_set){
    return caml_call1(Stdlib_Bytes[6], char_set);
   }
   function rev_char_set(char_set){
    var char_set$0 = create_char_set(0), i = 0;
    for(;;){
     var _cS_ = caml_string_get(char_set, i) ^ 255;
     caml_bytes_set(char_set$0, i, caml_call1(Stdlib[29], _cS_));
     var _cT_ = i + 1 | 0;
     if(31 === i) return caml_call1(Stdlib_Bytes[48], char_set$0);
     i = _cT_;
    }
   }
   function is_in_char_set(char_set, c){
    var str_ind = c >>> 3 | 0, mask = 1 << (c & 7);
    return 0 !== (caml_string_get(char_set, str_ind) & mask) ? 1 : 0;
   }
   function pad_of_pad_opt(pad_opt){
    if(! pad_opt) return 0;
    var width = pad_opt[1];
    return [0, 1, width];
   }
   function param_format_of_ignored_format(ign, fmt){
    if(typeof ign === "number")
     switch(ign){
       case 0:
        return [0, [0, fmt]];
       case 1:
        return [0, [1, fmt]];
       case 2:
        return [0, [19, fmt]];
       default: return [0, [22, fmt]];
     }
    switch(ign[0]){
      case 0:
       var pad_opt = ign[1]; return [0, [2, pad_of_pad_opt(pad_opt), fmt]];
      case 1:
       var pad_opt$0 = ign[1];
       return [0, [3, pad_of_pad_opt(pad_opt$0), fmt]];
      case 2:
       var pad_opt$1 = ign[2], iconv = ign[1];
       return [0, [4, iconv, pad_of_pad_opt(pad_opt$1), 0, fmt]];
      case 3:
       var pad_opt$2 = ign[2], iconv$0 = ign[1];
       return [0, [5, iconv$0, pad_of_pad_opt(pad_opt$2), 0, fmt]];
      case 4:
       var pad_opt$3 = ign[2], iconv$1 = ign[1];
       return [0, [6, iconv$1, pad_of_pad_opt(pad_opt$3), 0, fmt]];
      case 5:
       var pad_opt$4 = ign[2], iconv$2 = ign[1];
       return [0, [7, iconv$2, pad_of_pad_opt(pad_opt$4), 0, fmt]];
      case 6:
       var prec_opt = ign[2], pad_opt$5 = ign[1];
       if(prec_opt)
        var ndec = prec_opt[1], _cR_ = [0, ndec];
       else
        var _cR_ = 0;
       return [0, [8, _a_, pad_of_pad_opt(pad_opt$5), _cR_, fmt]];
      case 7:
       var pad_opt$6 = ign[1];
       return [0, [9, pad_of_pad_opt(pad_opt$6), fmt]];
      case 8:
       var fmtty = ign[2], pad_opt$7 = ign[1];
       return [0, [13, pad_opt$7, fmtty, fmt]];
      case 9:
       var fmtty$0 = ign[2], pad_opt$8 = ign[1];
       return [0, [14, pad_opt$8, fmtty$0, fmt]];
      case 10:
       var char_set = ign[2], width_opt = ign[1];
       return [0, [20, width_opt, char_set, fmt]];
      default: var counter = ign[1]; return [0, [21, counter, fmt]];
    }
   }
   function default_float_precision(fconv){return 5 === fconv[2] ? 12 : -6;}
   function buffer_create(init_size){
    return [0, 0, caml_create_bytes(init_size)];
   }
   function buffer_check_size(buf, overhead){
    var
     len = runtime.caml_ml_bytes_length(buf[2]),
     min_len = buf[1] + overhead | 0;
    if(len < min_len){
     var
      new_len = caml_call2(Stdlib_Int[11], len * 2 | 0, min_len),
      new_str = caml_create_bytes(new_len);
     caml_call5(Stdlib_Bytes[11], buf[2], 0, new_str, 0, len);
     buf[2] = new_str;
    }
    return;
   }
   function buffer_add_char(buf, c){
    buffer_check_size(buf, 1);
    caml_bytes_set(buf[2], buf[1], c);
    buf[1] = buf[1] + 1 | 0;
    return;
   }
   function buffer_add_string(buf, s){
    var str_len = caml_ml_string_length(s);
    buffer_check_size(buf, str_len);
    caml_call5(Stdlib_String[48], s, 0, buf[2], buf[1], str_len);
    buf[1] = buf[1] + str_len | 0;
    return;
   }
   function buffer_contents(buf){
    return caml_call3(Stdlib_Bytes[8], buf[2], 0, buf[1]);
   }
   function char_of_iconv(iconv){
    switch(iconv){
      case 6:
      case 7:
       return 120;
      case 8:
      case 9:
       return 88;
      case 10:
      case 11:
       return 111;
      case 12:
      case 15:
       return 117;
      case 0:
      case 1:
      case 2:
      case 13:
       return 100;
      default: return 105;
    }
   }
   function char_of_fconv(opt, fconv){
    if(opt) var sth = opt[1], cF = sth; else var cF = 70;
    switch(fconv[2]){
      case 0:
       return 102;
      case 1:
       return 101;
      case 2:
       return 69;
      case 3:
       return 103;
      case 4:
       return 71;
      case 5:
       return cF;
      case 6:
       return 104;
      case 7:
       return 72;
      default: return 70;
    }
   }
   function bprint_padty(buf, padty){
    switch(padty){
      case 0:
       return buffer_add_char(buf, 45);
      case 1:
       return;
      default: return buffer_add_char(buf, 48);
    }
   }
   function bprint_ignored_flag(buf, ign_flag){
    return ign_flag ? buffer_add_char(buf, 95) : ign_flag;
   }
   function bprint_pad_opt(buf, pad_opt){
    if(! pad_opt) return;
    var width = pad_opt[1];
    return buffer_add_string(buf, caml_call1(Stdlib_Int[12], width));
   }
   function bprint_padding(buf, pad){
    if(typeof pad === "number") return;
    if(0 === pad[0]){
     var n = pad[2], padty = pad[1];
     bprint_padty(buf, padty);
     return buffer_add_string(buf, caml_call1(Stdlib_Int[12], n));
    }
    var padty$0 = pad[1];
    bprint_padty(buf, padty$0);
    return buffer_add_char(buf, 42);
   }
   function bprint_precision(buf, prec){
    if(typeof prec !== "number"){
     var n = prec[1];
     buffer_add_char(buf, 46);
     return buffer_add_string(buf, caml_call1(Stdlib_Int[12], n));
    }
    if(prec) return buffer_add_string(buf, cst);
    return;
   }
   function bprint_iconv_flag(buf, iconv){
    switch(iconv){
      case 1:
      case 4:
       return buffer_add_char(buf, 43);
      case 2:
      case 5:
       return buffer_add_char(buf, 32);
      case 7:
      case 9:
      case 11:
      case 13:
      case 14:
      case 15:
       return buffer_add_char(buf, 35);
      default: return;
    }
   }
   function bprint_altint_fmt(buf, ign_flag, iconv, pad, prec, c){
    buffer_add_char(buf, 37);
    bprint_ignored_flag(buf, ign_flag);
    bprint_iconv_flag(buf, iconv);
    bprint_padding(buf, pad);
    bprint_precision(buf, prec);
    buffer_add_char(buf, c);
    return buffer_add_char(buf, char_of_iconv(iconv));
   }
   function bprint_fconv_flag(buf, fconv){
    switch(fconv[1]){
      case 0: break;
      case 1:
       buffer_add_char(buf, 43); break;
      default: buffer_add_char(buf, 32);
    }
    if(8 <= fconv[2]) return buffer_add_char(buf, 35);
    return;
   }
   function string_of_formatting_lit(formatting_lit){
    if(typeof formatting_lit === "number")
     switch(formatting_lit){
       case 0:
        return cst$0;
       case 1:
        return cst$1;
       case 2:
        return cst$2;
       case 3:
        return cst$3;
       case 4:
        return cst$4;
       case 5:
        return cst$5;
       default: return cst$6;
     }
    switch(formatting_lit[0]){
      case 0:
       var str = formatting_lit[1]; return str;
      case 1:
       var str$0 = formatting_lit[1]; return str$0;
      default:
       var c = formatting_lit[1], _cQ_ = caml_call2(Stdlib_String[1], 1, c);
       return caml_call2(Stdlib[28], cst$7, _cQ_);
    }
   }
   function bprint_char_literal(buf, chr){
    return 37 === chr
            ? buffer_add_string(buf, cst$8)
            : buffer_add_char(buf, chr);
   }
   function bprint_string_literal(buf, str){
    var _cO_ = caml_ml_string_length(str) - 1 | 0, _cN_ = 0;
    if(_cO_ >= 0){
     var i = _cN_;
     for(;;){
      bprint_char_literal(buf, caml_string_get(str, i));
      var _cP_ = i + 1 | 0;
      if(_cO_ === i) break;
      i = _cP_;
     }
    }
    return;
   }
   function bprint_fmtty(buf, fmtty){
    var fmtty$0 = fmtty;
    for(;;){
     if(typeof fmtty$0 === "number") return;
     switch(fmtty$0[0]){
       case 0:
        var fmtty$1 = fmtty$0[1];
        buffer_add_string(buf, cst_c);
        fmtty$0 = fmtty$1;
        break;
       case 1:
        var fmtty$2 = fmtty$0[1];
        buffer_add_string(buf, cst_s);
        fmtty$0 = fmtty$2;
        break;
       case 2:
        var fmtty$3 = fmtty$0[1];
        buffer_add_string(buf, cst_i);
        fmtty$0 = fmtty$3;
        break;
       case 3:
        var fmtty$4 = fmtty$0[1];
        buffer_add_string(buf, cst_li);
        fmtty$0 = fmtty$4;
        break;
       case 4:
        var fmtty$5 = fmtty$0[1];
        buffer_add_string(buf, cst_ni);
        fmtty$0 = fmtty$5;
        break;
       case 5:
        var fmtty$6 = fmtty$0[1];
        buffer_add_string(buf, cst_Li);
        fmtty$0 = fmtty$6;
        break;
       case 6:
        var fmtty$7 = fmtty$0[1];
        buffer_add_string(buf, cst_f);
        fmtty$0 = fmtty$7;
        break;
       case 7:
        var fmtty$8 = fmtty$0[1];
        buffer_add_string(buf, cst_B);
        fmtty$0 = fmtty$8;
        break;
       case 8:
        var fmtty$9 = fmtty$0[2], sub_fmtty = fmtty$0[1];
        buffer_add_string(buf, cst$9);
        bprint_fmtty(buf, sub_fmtty);
        buffer_add_string(buf, cst$10);
        fmtty$0 = fmtty$9;
        break;
       case 9:
        var fmtty$10 = fmtty$0[3], sub_fmtty$0 = fmtty$0[1];
        buffer_add_string(buf, cst$11);
        bprint_fmtty(buf, sub_fmtty$0);
        buffer_add_string(buf, cst$12);
        fmtty$0 = fmtty$10;
        break;
       case 10:
        var fmtty$11 = fmtty$0[1];
        buffer_add_string(buf, cst_a);
        fmtty$0 = fmtty$11;
        break;
       case 11:
        var fmtty$12 = fmtty$0[1];
        buffer_add_string(buf, cst_t);
        fmtty$0 = fmtty$12;
        break;
       case 12:
        var fmtty$13 = fmtty$0[1];
        buffer_add_string(buf, cst$13);
        fmtty$0 = fmtty$13;
        break;
       case 13:
        var fmtty$14 = fmtty$0[1];
        buffer_add_string(buf, cst_r);
        fmtty$0 = fmtty$14;
        break;
       default:
        var fmtty$15 = fmtty$0[1];
        buffer_add_string(buf, cst_r$0);
        fmtty$0 = fmtty$15;
     }
    }
   }
   function int_of_custom_arity(param){
    if(! param) return 0;
    var x = param[1];
    return 1 + int_of_custom_arity(x) | 0;
   }
   function string_of_fmt(fmt){
    var buf = buffer_create(16);
    function fmtiter(fmt, ign_flag){
     var fmt$0 = fmt, ign_flag$0 = ign_flag;
     for(;;){
      if(typeof fmt$0 === "number") return;
      switch(fmt$0[0]){
        case 0:
         var rest = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         buffer_add_char(buf, 99);
         fmt$0 = rest;
         ign_flag$0 = 0;
         break;
        case 1:
         var rest$0 = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         buffer_add_char(buf, 67);
         fmt$0 = rest$0;
         ign_flag$0 = 0;
         break;
        case 2:
         var rest$1 = fmt$0[2], pad = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         bprint_padding(buf, pad);
         buffer_add_char(buf, 115);
         fmt$0 = rest$1;
         ign_flag$0 = 0;
         break;
        case 3:
         var rest$2 = fmt$0[2], pad$0 = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         bprint_padding(buf, pad$0);
         buffer_add_char(buf, 83);
         fmt$0 = rest$2;
         ign_flag$0 = 0;
         break;
        case 4:
         var
          rest$3 = fmt$0[4],
          prec = fmt$0[3],
          pad$1 = fmt$0[2],
          iconv = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         bprint_iconv_flag(buf, iconv);
         bprint_padding(buf, pad$1);
         bprint_precision(buf, prec);
         buffer_add_char(buf, char_of_iconv(iconv));
         fmt$0 = rest$3;
         ign_flag$0 = 0;
         break;
        case 5:
         var
          rest$4 = fmt$0[4],
          prec$0 = fmt$0[3],
          pad$2 = fmt$0[2],
          iconv$0 = fmt$0[1];
         bprint_altint_fmt(buf, ign_flag$0, iconv$0, pad$2, prec$0, 108);
         fmt$0 = rest$4;
         ign_flag$0 = 0;
         break;
        case 6:
         var
          rest$5 = fmt$0[4],
          prec$1 = fmt$0[3],
          pad$3 = fmt$0[2],
          iconv$1 = fmt$0[1];
         bprint_altint_fmt(buf, ign_flag$0, iconv$1, pad$3, prec$1, 110);
         fmt$0 = rest$5;
         ign_flag$0 = 0;
         break;
        case 7:
         var
          rest$6 = fmt$0[4],
          prec$2 = fmt$0[3],
          pad$4 = fmt$0[2],
          iconv$2 = fmt$0[1];
         bprint_altint_fmt(buf, ign_flag$0, iconv$2, pad$4, prec$2, 76);
         fmt$0 = rest$6;
         ign_flag$0 = 0;
         break;
        case 8:
         var
          rest$7 = fmt$0[4],
          prec$3 = fmt$0[3],
          pad$5 = fmt$0[2],
          fconv = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         bprint_fconv_flag(buf, fconv);
         bprint_padding(buf, pad$5);
         bprint_precision(buf, prec$3);
         buffer_add_char(buf, char_of_fconv(0, fconv));
         fmt$0 = rest$7;
         ign_flag$0 = 0;
         break;
        case 9:
         var rest$8 = fmt$0[2], pad$6 = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         bprint_padding(buf, pad$6);
         buffer_add_char(buf, 66);
         fmt$0 = rest$8;
         ign_flag$0 = 0;
         break;
        case 10:
         var rest$9 = fmt$0[1];
         buffer_add_string(buf, cst$14);
         fmt$0 = rest$9;
         break;
        case 11:
         var rest$10 = fmt$0[2], str = fmt$0[1];
         bprint_string_literal(buf, str);
         fmt$0 = rest$10;
         break;
        case 12:
         var rest$11 = fmt$0[2], chr = fmt$0[1];
         bprint_char_literal(buf, chr);
         fmt$0 = rest$11;
         break;
        case 13:
         var rest$12 = fmt$0[3], fmtty = fmt$0[2], pad_opt = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         bprint_pad_opt(buf, pad_opt);
         buffer_add_char(buf, 123);
         bprint_fmtty(buf, fmtty);
         buffer_add_char(buf, 37);
         buffer_add_char(buf, 125);
         fmt$0 = rest$12;
         ign_flag$0 = 0;
         break;
        case 14:
         var rest$13 = fmt$0[3], fmtty$0 = fmt$0[2], pad_opt$0 = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         bprint_pad_opt(buf, pad_opt$0);
         buffer_add_char(buf, 40);
         bprint_fmtty(buf, fmtty$0);
         buffer_add_char(buf, 37);
         buffer_add_char(buf, 41);
         fmt$0 = rest$13;
         ign_flag$0 = 0;
         break;
        case 15:
         var rest$14 = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         buffer_add_char(buf, 97);
         fmt$0 = rest$14;
         ign_flag$0 = 0;
         break;
        case 16:
         var rest$15 = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         buffer_add_char(buf, 116);
         fmt$0 = rest$15;
         ign_flag$0 = 0;
         break;
        case 17:
         var rest$16 = fmt$0[2], fmting_lit = fmt$0[1];
         bprint_string_literal(buf, string_of_formatting_lit(fmting_lit));
         fmt$0 = rest$16;
         break;
        case 18:
         var rest$17 = fmt$0[2], fmting_gen = fmt$0[1];
         if(0 === fmting_gen[0]){
          var str$0 = fmting_gen[1][2];
          buffer_add_string(buf, cst$15);
          buffer_add_string(buf, str$0);
         }
         else{
          var str$1 = fmting_gen[1][2];
          buffer_add_string(buf, cst$16);
          buffer_add_string(buf, str$1);
         }
         fmt$0 = rest$17;
         break;
        case 19:
         var rest$18 = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         buffer_add_char(buf, 114);
         fmt$0 = rest$18;
         ign_flag$0 = 0;
         break;
        case 20:
         var rest$19 = fmt$0[3], char_set = fmt$0[2], width_opt = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         bprint_pad_opt(buf, width_opt);
         var
          print_char =
            function(buf, i){
             var c = caml_call1(Stdlib[29], i);
             return 37 === c
                     ? (buffer_add_char(buf, 37), buffer_add_char(buf, 37))
                     : 64
                       === c
                       ? (buffer_add_char(buf, 37), buffer_add_char(buf, 64))
                       : buffer_add_char(buf, c);
            };
         buffer_add_char(buf, 91);
         var
          set =
            is_in_char_set(char_set, 0)
             ? (buffer_add_char(buf, 94), rev_char_set(char_set))
             : char_set;
         let set$0 = set;
         var
          is_alone =
            function(c){
             var
              after = caml_call1(Stdlib_Char[1], c + 1 | 0),
              before = caml_call1(Stdlib_Char[1], c - 1 | 0),
              _cJ_ = is_in_char_set(set$0, c);
             if(_cJ_)
              var
               _cK_ = is_in_char_set(set$0, before),
               _cL_ = _cK_ ? is_in_char_set(set$0, after) : _cK_,
               _cM_ = 1 - _cL_;
             else
              var _cM_ = _cJ_;
             return _cM_;
            };
         if(is_alone(93)) buffer_add_char(buf, 93);
         a:
         b:
         {
          c:
          {
           d:
           {
            var i = 1;
            for(;;){
             if(i >= 256) break;
             if(is_in_char_set(set, caml_call1(Stdlib[29], i))){
              var switcher = caml_call1(Stdlib[29], i) - 45 | 0;
              if(48 < switcher >>> 0){
               if(210 <= switcher) break d;
              }
              else if(46 < switcher - 1 >>> 0){
               var i$2 = i + 1 | 0;
               i = i$2;
               continue;
              }
              var i$1 = i + 1 | 0;
              if(is_in_char_set(set, caml_call1(Stdlib[29], i$1))){
               var switcher$0 = caml_call1(Stdlib[29], i$1) - 45 | 0;
               if(48 < switcher$0 >>> 0){
                if(210 <= switcher$0) break c;
               }
               else if
                (46 < switcher$0 - 1 >>> 0
                 && ! is_in_char_set(set, caml_call1(Stdlib[29], i$1 + 1 | 0))){
                print_char(buf, i$1 - 1 | 0);
                var i$5 = i$1 + 1 | 0;
                i = i$5;
                continue;
               }
               if(is_in_char_set(set, caml_call1(Stdlib[29], i$1 + 1 | 0))){
                var j = i$1 + 2 | 0, i$3 = i$1 - 1 | 0, j$0 = j;
                for(;;){
                 if(256 === j$0) break;
                 if(! is_in_char_set(set, caml_call1(Stdlib[29], j$0))) break;
                 var j$1 = j$0 + 1 | 0;
                 j$0 = j$1;
                }
                print_char(buf, i$3);
                print_char(buf, 45);
                print_char(buf, j$0 - 1 | 0);
                if(j$0 >= 256) break b;
                var i$7 = j$0 + 1 | 0;
                i = i$7;
               }
               else{
                print_char(buf, i$1 - 1 | 0);
                print_char(buf, i$1);
                var i$4 = i$1 + 2 | 0;
                i = i$4;
               }
              }
              else{
               print_char(buf, i$1 - 1 | 0);
               var i$6 = i$1 + 1 | 0;
               i = i$6;
              }
             }
             else{var i$0 = i + 1 | 0; i = i$0;}
            }
            break a;
           }
           print_char(buf, 255);
           break a;
          }
          print_char(buf, 254);
          print_char(buf, 255);
          break a;
         }
         if(is_alone(45)) buffer_add_char(buf, 45);
         buffer_add_char(buf, 93);
         fmt$0 = rest$19;
         ign_flag$0 = 0;
         break;
        case 21:
         var rest$20 = fmt$0[2], counter = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         switch(counter){
           case 0:
            var _cF_ = 108; break;
           case 1:
            var _cF_ = 110; break;
           default: var _cF_ = 78;
         }
         buffer_add_char(buf, _cF_);
         fmt$0 = rest$20;
         ign_flag$0 = 0;
         break;
        case 22:
         var rest$21 = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         bprint_string_literal(buf, cst_0c);
         fmt$0 = rest$21;
         ign_flag$0 = 0;
         break;
        case 23:
         var
          rest$22 = fmt$0[2],
          ign = fmt$0[1],
          fmt$1 = param_format_of_ignored_format(ign, rest$22)[1];
         fmt$0 = fmt$1;
         ign_flag$0 = 1;
         break;
        default:
         var
          rest$23 = fmt$0[3],
          arity = fmt$0[1],
          _cH_ = int_of_custom_arity(arity),
          _cG_ = 1;
         if(_cH_ >= 1){
          var i$8 = _cG_;
          for(;;){
           buffer_add_char(buf, 37);
           bprint_ignored_flag(buf, ign_flag$0);
           buffer_add_char(buf, 63);
           var _cI_ = i$8 + 1 | 0;
           if(_cH_ === i$8) break;
           i$8 = _cI_;
          }
         }
         fmt$0 = rest$23;
         ign_flag$0 = 0;
      }
     }
    }
    fmtiter(fmt, 0);
    return buffer_contents(buf);
   }
   function symm(param){
    if(typeof param === "number") return 0;
    switch(param[0]){
      case 0:
       var rest = param[1]; return [0, symm(rest)];
      case 1:
       var rest$0 = param[1]; return [1, symm(rest$0)];
      case 2:
       var rest$1 = param[1]; return [2, symm(rest$1)];
      case 3:
       var rest$2 = param[1]; return [3, symm(rest$2)];
      case 4:
       var rest$3 = param[1]; return [4, symm(rest$3)];
      case 5:
       var rest$4 = param[1]; return [5, symm(rest$4)];
      case 6:
       var rest$5 = param[1]; return [6, symm(rest$5)];
      case 7:
       var rest$6 = param[1]; return [7, symm(rest$6)];
      case 8:
       var rest$7 = param[2], ty = param[1]; return [8, ty, symm(rest$7)];
      case 9:
       var rest$8 = param[3], ty2 = param[2], ty1 = param[1];
       return [9, ty2, ty1, symm(rest$8)];
      case 10:
       var rest$9 = param[1]; return [10, symm(rest$9)];
      case 11:
       var rest$10 = param[1]; return [11, symm(rest$10)];
      case 12:
       var rest$11 = param[1]; return [12, symm(rest$11)];
      case 13:
       var rest$12 = param[1]; return [13, symm(rest$12)];
      default: var rest$13 = param[1]; return [14, symm(rest$13)];
    }
   }
   function fmtty_rel_det(param){
    if(typeof param === "number")
     return [0,
             function(param){return;},
             function(param){return;},
             function(param){return;},
             function(param){return;}];
    switch(param[0]){
      case 0:
       var
        rest = param[1],
        match = fmtty_rel_det(rest),
        de = match[4],
        ed = match[3],
        af = match[2],
        fa = match[1];
       return [0,
               function(param){fa(0); return;},
               function(param){af(0); return;},
               ed,
               de];
      case 1:
       var
        rest$0 = param[1],
        match$0 = fmtty_rel_det(rest$0),
        de$0 = match$0[4],
        ed$0 = match$0[3],
        af$0 = match$0[2],
        fa$0 = match$0[1];
       return [0,
               function(param){fa$0(0); return;},
               function(param){af$0(0); return;},
               ed$0,
               de$0];
      case 2:
       var
        rest$1 = param[1],
        match$1 = fmtty_rel_det(rest$1),
        de$1 = match$1[4],
        ed$1 = match$1[3],
        af$1 = match$1[2],
        fa$1 = match$1[1];
       return [0,
               function(param){fa$1(0); return;},
               function(param){af$1(0); return;},
               ed$1,
               de$1];
      case 3:
       var
        rest$2 = param[1],
        match$2 = fmtty_rel_det(rest$2),
        de$2 = match$2[4],
        ed$2 = match$2[3],
        af$2 = match$2[2],
        fa$2 = match$2[1];
       return [0,
               function(param){fa$2(0); return;},
               function(param){af$2(0); return;},
               ed$2,
               de$2];
      case 4:
       var
        rest$3 = param[1],
        match$3 = fmtty_rel_det(rest$3),
        de$3 = match$3[4],
        ed$3 = match$3[3],
        af$3 = match$3[2],
        fa$3 = match$3[1];
       return [0,
               function(param){fa$3(0); return;},
               function(param){af$3(0); return;},
               ed$3,
               de$3];
      case 5:
       var
        rest$4 = param[1],
        match$4 = fmtty_rel_det(rest$4),
        de$4 = match$4[4],
        ed$4 = match$4[3],
        af$4 = match$4[2],
        fa$4 = match$4[1];
       return [0,
               function(param){fa$4(0); return;},
               function(param){af$4(0); return;},
               ed$4,
               de$4];
      case 6:
       var
        rest$5 = param[1],
        match$5 = fmtty_rel_det(rest$5),
        de$5 = match$5[4],
        ed$5 = match$5[3],
        af$5 = match$5[2],
        fa$5 = match$5[1];
       return [0,
               function(param){fa$5(0); return;},
               function(param){af$5(0); return;},
               ed$5,
               de$5];
      case 7:
       var
        rest$6 = param[1],
        match$6 = fmtty_rel_det(rest$6),
        de$6 = match$6[4],
        ed$6 = match$6[3],
        af$6 = match$6[2],
        fa$6 = match$6[1];
       return [0,
               function(param){fa$6(0); return;},
               function(param){af$6(0); return;},
               ed$6,
               de$6];
      case 8:
       var
        rest$7 = param[2],
        match$7 = fmtty_rel_det(rest$7),
        de$7 = match$7[4],
        ed$7 = match$7[3],
        af$7 = match$7[2],
        fa$7 = match$7[1];
       return [0,
               function(param){fa$7(0); return;},
               function(param){af$7(0); return;},
               ed$7,
               de$7];
      case 9:
       var
        rest$8 = param[3],
        ty2 = param[2],
        ty1 = param[1],
        match$8 = fmtty_rel_det(rest$8),
        de$8 = match$8[4],
        ed$8 = match$8[3],
        af$8 = match$8[2],
        fa$8 = match$8[1],
        ty = trans(symm(ty1), ty2),
        match$9 = fmtty_rel_det(ty),
        jd = match$9[4],
        dj = match$9[3],
        ga = match$9[2],
        ag = match$9[1];
       return [0,
               function(param){fa$8(0); ag(0); return;},
               function(param){ga(0); af$8(0); return;},
               function(param){ed$8(0); dj(0); return;},
               function(param){jd(0); de$8(0); return;}];
      case 10:
       var
        rest$9 = param[1],
        match$10 = fmtty_rel_det(rest$9),
        de$9 = match$10[4],
        ed$9 = match$10[3],
        af$9 = match$10[2],
        fa$9 = match$10[1];
       return [0,
               function(param){fa$9(0); return;},
               function(param){af$9(0); return;},
               ed$9,
               de$9];
      case 11:
       var
        rest$10 = param[1],
        match$11 = fmtty_rel_det(rest$10),
        de$10 = match$11[4],
        ed$10 = match$11[3],
        af$10 = match$11[2],
        fa$10 = match$11[1];
       return [0,
               function(param){fa$10(0); return;},
               function(param){af$10(0); return;},
               ed$10,
               de$10];
      case 12:
       var
        rest$11 = param[1],
        match$12 = fmtty_rel_det(rest$11),
        de$11 = match$12[4],
        ed$11 = match$12[3],
        af$11 = match$12[2],
        fa$11 = match$12[1];
       return [0,
               function(param){fa$11(0); return;},
               function(param){af$11(0); return;},
               ed$11,
               de$11];
      case 13:
       var
        rest$12 = param[1],
        match$13 = fmtty_rel_det(rest$12),
        de$12 = match$13[4],
        ed$12 = match$13[3],
        af$12 = match$13[2],
        fa$12 = match$13[1];
       return [0,
               function(param){fa$12(0); return;},
               function(param){af$12(0); return;},
               function(param){ed$12(0); return;},
               function(param){de$12(0); return;}];
      default:
       var
        rest$13 = param[1],
        match$14 = fmtty_rel_det(rest$13),
        de$13 = match$14[4],
        ed$13 = match$14[3],
        af$13 = match$14[2],
        fa$13 = match$14[1];
       return [0,
               function(param){fa$13(0); return;},
               function(param){af$13(0); return;},
               function(param){ed$13(0); return;},
               function(param){de$13(0); return;}];
    }
   }
   function trans(ty1, ty2){
    a:
    {
     b:
     {
      c:
      {
       d:
       {
        e:
        {
         f:
         {
          g:
          {
           if(typeof ty1 !== "number"){
            switch(ty1[0]){
              case 0:
               var rest1 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 0:
                   var rest2 = ty2[1]; return [0, trans(rest1, rest2)];
                  case 8:
                   break f;
                  case 9:
                   break g;
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   break e;
                }
               break;
              case 1:
               var rest1$0 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 1:
                   var rest2$0 = ty2[1]; return [1, trans(rest1$0, rest2$0)];
                  case 8:
                   break f;
                  case 9:
                   break g;
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   break e;
                }
               break;
              case 2:
               var rest1$1 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 2:
                   var rest2$1 = ty2[1]; return [2, trans(rest1$1, rest2$1)];
                  case 8:
                   break f;
                  case 9:
                   break g;
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   break e;
                }
               break;
              case 3:
               var rest1$2 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 3:
                   var rest2$2 = ty2[1]; return [3, trans(rest1$2, rest2$2)];
                  case 8:
                   break f;
                  case 9:
                   break g;
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   break e;
                }
               break;
              case 4:
               var rest1$3 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 4:
                   var rest2$3 = ty2[1]; return [4, trans(rest1$3, rest2$3)];
                  case 8:
                   break f;
                  case 9:
                   break g;
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   break e;
                }
               break;
              case 5:
               var rest1$4 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 5:
                   var rest2$4 = ty2[1]; return [5, trans(rest1$4, rest2$4)];
                  case 8:
                   break f;
                  case 9:
                   break g;
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   break e;
                }
               break;
              case 6:
               var rest1$5 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 6:
                   var rest2$5 = ty2[1]; return [6, trans(rest1$5, rest2$5)];
                  case 8:
                   break f;
                  case 9:
                   break g;
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   break e;
                }
               break;
              case 7:
               var rest1$6 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 7:
                   var rest2$6 = ty2[1]; return [7, trans(rest1$6, rest2$6)];
                  case 8:
                   break f;
                  case 9:
                   break g;
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   break e;
                }
               break;
              case 8:
               var rest1$7 = ty1[2], ty1$0 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 8:
                   var
                    rest2$7 = ty2[2],
                    ty2$0 = ty2[1],
                    _cE_ = trans(rest1$7, rest2$7);
                   return [8, trans(ty1$0, ty2$0), _cE_];
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   break e;
                }
               throw caml_maybe_attach_backtrace([0, Assert_failure, _k_], 1);
              case 9:
               var rest1$8 = ty1[3], ty12 = ty1[2], ty11 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 8:
                   break f;
                  case 9:
                   var
                    rest2$8 = ty2[3],
                    ty22 = ty2[2],
                    ty21 = ty2[1],
                    ty = trans(symm(ty12), ty21),
                    match = fmtty_rel_det(ty),
                    f4 = match[4],
                    f2 = match[2];
                   f2(0);
                   f4(0);
                   return [9, ty11, ty22, trans(rest1$8, rest2$8)];
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   break e;
                }
               throw caml_maybe_attach_backtrace([0, Assert_failure, _l_], 1);
              case 10:
               var rest1$9 = ty1[1];
               if(typeof ty2 !== "number" && 10 === ty2[0]){
                var rest2$9 = ty2[1];
                return [10, trans(rest1$9, rest2$9)];
               }
               throw caml_maybe_attach_backtrace([0, Assert_failure, _m_], 1);
              case 11:
               var rest1$10 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 10:
                   break a;
                  case 11:
                   var rest2$10 = ty2[1];
                   return [11, trans(rest1$10, rest2$10)];
                }
               throw caml_maybe_attach_backtrace([0, Assert_failure, _n_], 1);
              case 12:
               var rest1$11 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   var rest2$11 = ty2[1];
                   return [12, trans(rest1$11, rest2$11)];
                }
               throw caml_maybe_attach_backtrace([0, Assert_failure, _o_], 1);
              case 13:
               var rest1$12 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   var rest2$12 = ty2[1];
                   return [13, trans(rest1$12, rest2$12)];
                }
               throw caml_maybe_attach_backtrace([0, Assert_failure, _p_], 1);
              default:
               var rest1$13 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   var rest2$13 = ty2[1];
                   return [14, trans(rest1$13, rest2$13)];
                }
               throw caml_maybe_attach_backtrace([0, Assert_failure, _q_], 1);
            }
            throw caml_maybe_attach_backtrace([0, Assert_failure, _j_], 1);
           }
           if(typeof ty2 === "number") return 0;
           switch(ty2[0]){
             case 10:
              break a;
             case 11:
              break b;
             case 12:
              break c;
             case 13:
              break d;
             case 14:
              break e;
             case 8:
              break f;
             case 9: break;
             default:
              throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
           }
          }
          throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
         }
         throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
        }
        throw caml_maybe_attach_backtrace([0, Assert_failure, _i_], 1);
       }
       throw caml_maybe_attach_backtrace([0, Assert_failure, _h_], 1);
      }
      throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
     }
     throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
    }
    throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
   }
   function fmtty_of_fmt(fmtty){
    var fmtty$0 = fmtty;
    for(;;){
     if(typeof fmtty$0 === "number") return 0;
     switch(fmtty$0[0]){
       case 0:
        var rest = fmtty$0[1]; return [0, fmtty_of_fmt(rest)];
       case 1:
        var rest$0 = fmtty$0[1]; return [0, fmtty_of_fmt(rest$0)];
       case 2:
        var rest$1 = fmtty$0[2], pad = fmtty$0[1];
        return fmtty_of_padding_fmtty(pad, [1, fmtty_of_fmt(rest$1)]);
       case 3:
        var rest$2 = fmtty$0[2], pad$0 = fmtty$0[1];
        return fmtty_of_padding_fmtty(pad$0, [1, fmtty_of_fmt(rest$2)]);
       case 4:
        var
         rest$3 = fmtty$0[4],
         prec = fmtty$0[3],
         pad$1 = fmtty$0[2],
         ty_rest = fmtty_of_fmt(rest$3),
         prec_ty = fmtty_of_precision_fmtty(prec, [2, ty_rest]);
        return fmtty_of_padding_fmtty(pad$1, prec_ty);
       case 5:
        var
         rest$4 = fmtty$0[4],
         prec$0 = fmtty$0[3],
         pad$2 = fmtty$0[2],
         ty_rest$0 = fmtty_of_fmt(rest$4),
         prec_ty$0 = fmtty_of_precision_fmtty(prec$0, [3, ty_rest$0]);
        return fmtty_of_padding_fmtty(pad$2, prec_ty$0);
       case 6:
        var
         rest$5 = fmtty$0[4],
         prec$1 = fmtty$0[3],
         pad$3 = fmtty$0[2],
         ty_rest$1 = fmtty_of_fmt(rest$5),
         prec_ty$1 = fmtty_of_precision_fmtty(prec$1, [4, ty_rest$1]);
        return fmtty_of_padding_fmtty(pad$3, prec_ty$1);
       case 7:
        var
         rest$6 = fmtty$0[4],
         prec$2 = fmtty$0[3],
         pad$4 = fmtty$0[2],
         ty_rest$2 = fmtty_of_fmt(rest$6),
         prec_ty$2 = fmtty_of_precision_fmtty(prec$2, [5, ty_rest$2]);
        return fmtty_of_padding_fmtty(pad$4, prec_ty$2);
       case 8:
        var
         rest$7 = fmtty$0[4],
         prec$3 = fmtty$0[3],
         pad$5 = fmtty$0[2],
         ty_rest$3 = fmtty_of_fmt(rest$7),
         prec_ty$3 = fmtty_of_precision_fmtty(prec$3, [6, ty_rest$3]);
        return fmtty_of_padding_fmtty(pad$5, prec_ty$3);
       case 9:
        var rest$8 = fmtty$0[2], pad$6 = fmtty$0[1];
        return fmtty_of_padding_fmtty(pad$6, [7, fmtty_of_fmt(rest$8)]);
       case 10:
        var fmtty$1 = fmtty$0[1]; fmtty$0 = fmtty$1; break;
       case 11:
        var fmtty$2 = fmtty$0[2]; fmtty$0 = fmtty$2; break;
       case 12:
        var fmtty$3 = fmtty$0[2]; fmtty$0 = fmtty$3; break;
       case 13:
        var rest$9 = fmtty$0[3], ty = fmtty$0[2];
        return [8, ty, fmtty_of_fmt(rest$9)];
       case 14:
        var rest$10 = fmtty$0[3], ty$0 = fmtty$0[2];
        return [9, ty$0, ty$0, fmtty_of_fmt(rest$10)];
       case 15:
        var rest$11 = fmtty$0[1]; return [10, fmtty_of_fmt(rest$11)];
       case 16:
        var rest$12 = fmtty$0[1]; return [11, fmtty_of_fmt(rest$12)];
       case 17:
        var fmtty$4 = fmtty$0[2]; fmtty$0 = fmtty$4; break;
       case 18:
        var
         rest$13 = fmtty$0[2],
         formatting_gen = fmtty$0[1],
         _cB_ = fmtty_of_fmt(rest$13);
        if(0 === formatting_gen[0])
         var fmt = formatting_gen[1][1], _cC_ = fmtty_of_fmt(fmt);
        else
         var fmt$0 = formatting_gen[1][1], _cC_ = fmtty_of_fmt(fmt$0);
        return caml_call2(CamlinternalFormatBasics[1], _cC_, _cB_);
       case 19:
        var rest$14 = fmtty$0[1]; return [13, fmtty_of_fmt(rest$14)];
       case 20:
        var rest$15 = fmtty$0[3]; return [1, fmtty_of_fmt(rest$15)];
       case 21:
        var rest$16 = fmtty$0[2]; return [2, fmtty_of_fmt(rest$16)];
       case 22:
        var rest$17 = fmtty$0[1]; return [0, fmtty_of_fmt(rest$17)];
       case 23:
        var fmtty$5 = fmtty$0[2], ign = fmtty$0[1];
        if(typeof ign === "number")
         switch(ign){
           case 0:
            fmtty$0 = fmtty$5; break;
           case 1:
            fmtty$0 = fmtty$5; break;
           case 2:
            return [14, fmtty_of_fmt(fmtty$5)];
           default: fmtty$0 = fmtty$5;
         }
        else
         switch(ign[0]){
           case 0:
            fmtty$0 = fmtty$5; break;
           case 1:
            fmtty$0 = fmtty$5; break;
           case 2:
            fmtty$0 = fmtty$5; break;
           case 3:
            fmtty$0 = fmtty$5; break;
           case 4:
            fmtty$0 = fmtty$5; break;
           case 5:
            fmtty$0 = fmtty$5; break;
           case 6:
            fmtty$0 = fmtty$5; break;
           case 7:
            fmtty$0 = fmtty$5; break;
           case 8:
            fmtty$0 = fmtty$5; break;
           case 9:
            var fmtty$6 = ign[2], _cD_ = fmtty_of_fmt(fmtty$5);
            return caml_call2(CamlinternalFormatBasics[1], fmtty$6, _cD_);
           case 10:
            fmtty$0 = fmtty$5; break;
           default: fmtty$0 = fmtty$5;
         }
        break;
       default:
        var rest$18 = fmtty$0[3], arity = fmtty$0[1];
        return fmtty_of_custom(arity, fmtty_of_fmt(rest$18));
     }
    }
   }
   function fmtty_of_custom(arity, fmtty){
    if(! arity) return fmtty;
    var arity$0 = arity[1];
    return [12, fmtty_of_custom(arity$0, fmtty)];
   }
   function fmtty_of_padding_fmtty(pad, fmtty){
    return typeof pad === "number" ? fmtty : 0 === pad[0] ? fmtty : [2, fmtty];
   }
   function fmtty_of_precision_fmtty(prec, fmtty){
    return typeof prec === "number" ? prec ? [2, fmtty] : fmtty : fmtty;
   }
   var
    Type_mismatch =
      [248, "CamlinternalFormat.Type_mismatch", runtime.caml_fresh_oo_id(0)],
    cst_d = "%d",
    cst_d$0 = "%+d",
    cst_d$1 = "% d",
    cst_i$0 = cst_i$3,
    cst_i$1 = "%+i",
    cst_i$2 = "% i",
    cst_x = "%x",
    cst_x$0 = "%#x",
    cst_X = "%X",
    cst_X$0 = "%#X",
    cst_o = "%o",
    cst_o$0 = "%#o",
    cst_u = cst_u$0,
    cst_Ld = "%Ld",
    cst_Ld$0 = "%+Ld",
    cst_Ld$1 = "% Ld",
    cst_Li$0 = cst_Li$3,
    cst_Li$1 = "%+Li",
    cst_Li$2 = "% Li",
    cst_Lx = "%Lx",
    cst_Lx$0 = "%#Lx",
    cst_LX = "%LX",
    cst_LX$0 = "%#LX",
    cst_Lo = "%Lo",
    cst_Lo$0 = "%#Lo",
    cst_Lu = "%Lu",
    cst_ld = "%ld",
    cst_ld$0 = "%+ld",
    cst_ld$1 = "% ld",
    cst_li$0 = cst_li$3,
    cst_li$1 = "%+li",
    cst_li$2 = "% li",
    cst_lx = "%lx",
    cst_lx$0 = "%#lx",
    cst_lX = "%lX",
    cst_lX$0 = "%#lX",
    cst_lo = "%lo",
    cst_lo$0 = "%#lo",
    cst_lu = "%lu",
    cst_nd = "%nd",
    cst_nd$0 = "%+nd",
    cst_nd$1 = "% nd",
    cst_ni$0 = cst_ni$3,
    cst_ni$1 = "%+ni",
    cst_ni$2 = "% ni",
    cst_nx = "%nx",
    cst_nx$0 = "%#nx",
    cst_nX = "%nX",
    cst_nX$0 = "%#nX",
    cst_no = "%no",
    cst_no$0 = "%#no",
    cst_nu = "%nu",
    _r_ = [0, 103],
    cst_neg_infinity = "neg_infinity",
    cst_infinity = "infinity",
    cst_nan = "nan",
    _s_ = [0, cst_camlinternalFormat_ml, 1558, 4],
    cst_Printf_bad_conversion = "Printf: bad conversion %[",
    _t_ = [0, cst_camlinternalFormat_ml, 1626, 39],
    _u_ = [0, cst_camlinternalFormat_ml, 1649, 31],
    _v_ = [0, cst_camlinternalFormat_ml, 1650, 31],
    cst_Printf_bad_conversion$0 = "Printf: bad conversion %_",
    _w_ = [0, cst_camlinternalFormat_ml, 1830, 8],
    _x_ = [0, 0, 4],
    _y_ =
      [0,
       [11, "invalid box description ", [3, 0, 0]],
       "invalid box description %S"],
    _z_ =
      [0,
       [11,
        cst_invalid_format,
        [3,
         0,
         [11, cst_at_character_number, [4, 0, 0, 0, [11, cst$44, [2, 0, 0]]]]]],
       "invalid format %S: at character number %d, %s"],
    cst_non_zero_widths_are_unsupp =
      "non-zero widths are unsupported for %c conversions",
    _A_ =
      [0,
       [11,
        cst_invalid_format,
        [3,
         0,
         [11,
          cst_at_character_number,
          [4, 0, 0, 0, [11, ", '", [0, [11, "' without ", [2, 0, 0]]]]]]]],
       "invalid format %S: at character number %d, '%c' without %s"],
    _B_ =
      [0,
       [11,
        cst_invalid_format,
        [3,
         0,
         [11,
          cst_at_character_number,
          [4, 0, 0, 0, [11, cst$44, [2, 0, [11, " expected, read ", [1, 0]]]]]]]],
       "invalid format %S: at character number %d, %s expected, read %C"],
    _C_ =
      [0,
       [11,
        cst_invalid_format,
        [3,
         0,
         [11,
          cst_at_character_number,
          [4, 0, 0, 0, [11, ", duplicate flag ", [1, 0]]]]]],
       "invalid format %S: at character number %d, duplicate flag %C"],
    cst_padding = "padding",
    _D_ = [0, 1, 0],
    cst_0 = cst_0$3,
    _E_ = [0, 0],
    cst_precision = cst_precision$3,
    _F_ = [1, 0],
    _G_ = [1, 1],
    cst_precision$0 = cst_precision$3,
    _H_ = [1, 1],
    cst_precision$1 = cst_precision$3,
    cst_0$0 = cst_0$3,
    _I_ = [1, 1],
    cst_0$1 = cst_0$3,
    cst_0$2 = "'0'",
    _J_ =
      [0,
       [11,
        cst_invalid_format,
        [3,
         0,
         [11,
          cst_at_character_number,
          [4,
           0,
           0,
           0,
           [11, ', invalid conversion "', [12, 37, [0, [12, 34, 0]]]]]]]],
       'invalid format %S: at character number %d, invalid conversion "%%%c"'],
    _K_ = [0, 0],
    cst_padding$0 = "`padding'",
    _L_ = [0, 0],
    cst_precision$2 = "`precision'",
    _M_ =
      [0,
       [11,
        cst_invalid_format,
        [3,
         0,
         [11,
          cst_at_character_number,
          [4,
           0,
           0,
           0,
           [11,
            ", flag ",
            [1,
             [11,
              " is only allowed after the '",
              [12, 37, [11, "', before padding and precision", 0]]]]]]]]],
       "invalid format %S: at character number %d, flag %C is only allowed after the '%%', before padding and precision"],
    _N_ = [0, [12, 64, 0]],
    _O_ = [0, "@ ", 1, 0],
    _P_ = [0, "@,", 0, 0],
    _Q_ = [2, 60],
    _R_ =
      [0,
       [11,
        cst_invalid_format,
        [3,
         0,
         [11,
          ": '",
          [12,
           37,
           [11,
            "' alone is not accepted in character sets, use ",
            [12,
             37,
             [12,
              37,
              [11, " instead at position ", [4, 0, 0, 0, [12, 46, 0]]]]]]]]]],
       "invalid format %S: '%%' alone is not accepted in character sets, use %%%% instead at position %d."],
    _S_ =
      [0,
       [11,
        cst_invalid_format,
        [3,
         0,
         [11,
          ": integer ",
          [4, 0, 0, 0, [11, " is greater than the limit ", [4, 0, 0, 0, 0]]]]]],
       "invalid format %S: integer %d is greater than the limit %d"],
    _T_ = [0, cst_camlinternalFormat_ml, 2837, 11],
    cst_digit = "digit",
    _U_ =
      [0,
       [11,
        cst_invalid_format,
        [3,
         0,
         [11,
          ': unclosed sub-format, expected "',
          [12, 37, [0, [11, '" at character number ', [4, 0, 0, 0, 0]]]]]]],
       'invalid format %S: unclosed sub-format, expected "%%%c" at character number %d'],
    cst_character = "character ')'",
    cst_character$0 = "character '}'",
    _V_ = [0, cst_camlinternalFormat_ml, 2899, 34],
    _W_ = [0, cst_camlinternalFormat_ml, 2935, 28],
    _X_ = [0, cst_camlinternalFormat_ml, 2957, 11],
    _Y_ =
      [0,
       [11,
        cst_invalid_format,
        [3,
         0,
         [11,
          cst_at_character_number,
          [4,
           0,
           0,
           0,
           [11,
            cst$44,
            [2,
             0,
             [11,
              " is incompatible with '",
              [0, [11, "' in sub-format ", [3, 0, 0]]]]]]]]]],
       "invalid format %S: at character number %d, %s is incompatible with '%c' in sub-format %S"],
    _Z_ =
      [0,
       [11, cst_bad_input_format_type_mism, [3, 0, [11, cst_and, [3, 0, 0]]]],
       cst_bad_input_format_type_mism$0],
    ___ =
      [0,
       [11, cst_bad_input_format_type_mism, [3, 0, [11, cst_and, [3, 0, 0]]]],
       cst_bad_input_format_type_mism$0];
   function type_padding(pad, fmtty){
    if(typeof pad === "number") return [0, 0, fmtty];
    if(0 === pad[0]){
     var w = pad[2], padty = pad[1];
     return [0, [0, padty, w], fmtty];
    }
    if(typeof fmtty !== "number" && 2 === fmtty[0]){
     var rest = fmtty[1], padty$0 = pad[1];
     return [0, [1, padty$0], rest];
    }
    throw caml_maybe_attach_backtrace(Type_mismatch, 1);
   }
   function type_padprec(pad, prec, fmtty){
    var match = type_padding(pad, fmtty);
    if(typeof prec !== "number"){
     var rest$1 = match[2], pad$2 = match[1], p = prec[1];
     return [0, pad$2, [0, p], rest$1];
    }
    if(! prec){
     var rest$0 = match[2], pad$1 = match[1];
     return [0, pad$1, 0, rest$0];
    }
    var match$0 = match[2];
    if(typeof match$0 !== "number" && 2 === match$0[0]){
     var rest = match$0[1], pad$0 = match[1];
     return [0, pad$0, 1, rest];
    }
    throw caml_maybe_attach_backtrace(Type_mismatch, 1);
   }
   function type_format(fmt, fmtty){
    var _cA_ = type_format_gen(fmt, fmtty);
    if(typeof _cA_[2] !== "number")
     throw caml_maybe_attach_backtrace(Type_mismatch, 1);
    var fmt$0 = _cA_[1];
    return fmt$0;
   }
   function type_format_gen(fmt, fmtty0){
    if(typeof fmt === "number") return [0, 0, fmtty0];
    switch(fmt[0]){
      case 0:
       if(typeof fmtty0 !== "number" && 0 === fmtty0[0]){
        var
         fmtty_rest = fmtty0[1],
         fmt_rest = fmt[1],
         match = type_format_gen(fmt_rest, fmtty_rest),
         fmtty = match[2],
         fmt$0 = match[1];
        return [0, [0, fmt$0], fmtty];
       }
       break;
      case 1:
       if(typeof fmtty0 !== "number" && 0 === fmtty0[0]){
        var
         fmtty_rest$0 = fmtty0[1],
         fmt_rest$0 = fmt[1],
         match$0 = type_format_gen(fmt_rest$0, fmtty_rest$0),
         fmtty$0 = match$0[2],
         fmt$1 = match$0[1];
        return [0, [1, fmt$1], fmtty$0];
       }
       break;
      case 2:
       var
        fmt_rest$1 = fmt[2],
        pad = fmt[1],
        match$1 = type_padding(pad, fmtty0),
        pad$0 = match$1[1],
        match$2 = match$1[2];
       if(typeof match$2 !== "number" && 1 === match$2[0]){
        var
         fmtty_rest$1 = match$2[1],
         match$3 = type_format_gen(fmt_rest$1, fmtty_rest$1),
         fmtty$1 = match$3[2],
         fmt$2 = match$3[1];
        return [0, [2, pad$0, fmt$2], fmtty$1];
       }
       throw caml_maybe_attach_backtrace(Type_mismatch, 1);
      case 3:
       var
        fmt_rest$2 = fmt[2],
        pad$1 = fmt[1],
        match$4 = type_padding(pad$1, fmtty0),
        pad$2 = match$4[1],
        match$5 = match$4[2];
       if(typeof match$5 !== "number" && 1 === match$5[0]){
        var
         fmtty_rest$2 = match$5[1],
         match$6 = type_format_gen(fmt_rest$2, fmtty_rest$2),
         fmtty$2 = match$6[2],
         fmt$3 = match$6[1];
        return [0, [3, pad$2, fmt$3], fmtty$2];
       }
       throw caml_maybe_attach_backtrace(Type_mismatch, 1);
      case 4:
       var
        fmt_rest$3 = fmt[4],
        prec = fmt[3],
        pad$3 = fmt[2],
        iconv = fmt[1],
        match$7 = type_padprec(pad$3, prec, fmtty0),
        pad$4 = match$7[1],
        match$8 = match$7[3];
       if(typeof match$8 !== "number" && 2 === match$8[0]){
        var
         fmtty_rest$3 = match$8[1],
         prec$0 = match$7[2],
         match$9 = type_format_gen(fmt_rest$3, fmtty_rest$3),
         fmtty$3 = match$9[2],
         fmt$4 = match$9[1];
        return [0, [4, iconv, pad$4, prec$0, fmt$4], fmtty$3];
       }
       throw caml_maybe_attach_backtrace(Type_mismatch, 1);
      case 5:
       var
        fmt_rest$4 = fmt[4],
        prec$1 = fmt[3],
        pad$5 = fmt[2],
        iconv$0 = fmt[1],
        match$10 = type_padprec(pad$5, prec$1, fmtty0),
        pad$6 = match$10[1],
        match$11 = match$10[3];
       if(typeof match$11 !== "number" && 3 === match$11[0]){
        var
         fmtty_rest$4 = match$11[1],
         prec$2 = match$10[2],
         match$12 = type_format_gen(fmt_rest$4, fmtty_rest$4),
         fmtty$4 = match$12[2],
         fmt$5 = match$12[1];
        return [0, [5, iconv$0, pad$6, prec$2, fmt$5], fmtty$4];
       }
       throw caml_maybe_attach_backtrace(Type_mismatch, 1);
      case 6:
       var
        fmt_rest$5 = fmt[4],
        prec$3 = fmt[3],
        pad$7 = fmt[2],
        iconv$1 = fmt[1],
        match$13 = type_padprec(pad$7, prec$3, fmtty0),
        pad$8 = match$13[1],
        match$14 = match$13[3];
       if(typeof match$14 !== "number" && 4 === match$14[0]){
        var
         fmtty_rest$5 = match$14[1],
         prec$4 = match$13[2],
         match$15 = type_format_gen(fmt_rest$5, fmtty_rest$5),
         fmtty$5 = match$15[2],
         fmt$6 = match$15[1];
        return [0, [6, iconv$1, pad$8, prec$4, fmt$6], fmtty$5];
       }
       throw caml_maybe_attach_backtrace(Type_mismatch, 1);
      case 7:
       var
        fmt_rest$6 = fmt[4],
        prec$5 = fmt[3],
        pad$9 = fmt[2],
        iconv$2 = fmt[1],
        match$16 = type_padprec(pad$9, prec$5, fmtty0),
        pad$10 = match$16[1],
        match$17 = match$16[3];
       if(typeof match$17 !== "number" && 5 === match$17[0]){
        var
         fmtty_rest$6 = match$17[1],
         prec$6 = match$16[2],
         match$18 = type_format_gen(fmt_rest$6, fmtty_rest$6),
         fmtty$6 = match$18[2],
         fmt$7 = match$18[1];
        return [0, [7, iconv$2, pad$10, prec$6, fmt$7], fmtty$6];
       }
       throw caml_maybe_attach_backtrace(Type_mismatch, 1);
      case 8:
       var
        fmt_rest$7 = fmt[4],
        prec$7 = fmt[3],
        pad$11 = fmt[2],
        fconv = fmt[1],
        match$19 = type_padprec(pad$11, prec$7, fmtty0),
        pad$12 = match$19[1],
        match$20 = match$19[3];
       if(typeof match$20 !== "number" && 6 === match$20[0]){
        var
         fmtty_rest$7 = match$20[1],
         prec$8 = match$19[2],
         match$21 = type_format_gen(fmt_rest$7, fmtty_rest$7),
         fmtty$7 = match$21[2],
         fmt$8 = match$21[1];
        return [0, [8, fconv, pad$12, prec$8, fmt$8], fmtty$7];
       }
       throw caml_maybe_attach_backtrace(Type_mismatch, 1);
      case 9:
       var
        fmt_rest$8 = fmt[2],
        pad$13 = fmt[1],
        match$22 = type_padding(pad$13, fmtty0),
        pad$14 = match$22[1],
        match$23 = match$22[2];
       if(typeof match$23 !== "number" && 7 === match$23[0]){
        var
         fmtty_rest$8 = match$23[1],
         match$24 = type_format_gen(fmt_rest$8, fmtty_rest$8),
         fmtty$8 = match$24[2],
         fmt$9 = match$24[1];
        return [0, [9, pad$14, fmt$9], fmtty$8];
       }
       throw caml_maybe_attach_backtrace(Type_mismatch, 1);
      case 10:
       var
        fmt_rest$9 = fmt[1],
        match$25 = type_format_gen(fmt_rest$9, fmtty0),
        fmtty$9 = match$25[2],
        fmt$10 = match$25[1];
       return [0, [10, fmt$10], fmtty$9];
      case 11:
       var
        fmt_rest$10 = fmt[2],
        str = fmt[1],
        match$26 = type_format_gen(fmt_rest$10, fmtty0),
        fmtty$10 = match$26[2],
        fmt$11 = match$26[1];
       return [0, [11, str, fmt$11], fmtty$10];
      case 12:
       var
        fmt_rest$11 = fmt[2],
        chr = fmt[1],
        match$27 = type_format_gen(fmt_rest$11, fmtty0),
        fmtty$11 = match$27[2],
        fmt$12 = match$27[1];
       return [0, [12, chr, fmt$12], fmtty$11];
      case 13:
       if(typeof fmtty0 !== "number" && 8 === fmtty0[0]){
        var
         fmtty_rest$9 = fmtty0[2],
         sub_fmtty = fmtty0[1],
         fmt_rest$12 = fmt[3],
         sub_fmtty$0 = fmt[2],
         pad_opt = fmt[1];
        if(caml_notequal([0, sub_fmtty$0], [0, sub_fmtty]))
         throw caml_maybe_attach_backtrace(Type_mismatch, 1);
        var
         match$28 = type_format_gen(fmt_rest$12, fmtty_rest$9),
         fmtty$12 = match$28[2],
         fmt$13 = match$28[1];
        return [0, [13, pad_opt, sub_fmtty, fmt$13], fmtty$12];
       }
       break;
      case 14:
       if(typeof fmtty0 !== "number" && 9 === fmtty0[0]){
        var
         fmtty_rest$10 = fmtty0[3],
         sub_fmtty1 = fmtty0[1],
         fmt_rest$13 = fmt[3],
         sub_fmtty$1 = fmt[2],
         pad_opt$0 = fmt[1],
         _cy_ = [0, caml_call1(CamlinternalFormatBasics[2], sub_fmtty1)];
        if
         (caml_notequal
           ([0, caml_call1(CamlinternalFormatBasics[2], sub_fmtty$1)], _cy_))
         throw caml_maybe_attach_backtrace(Type_mismatch, 1);
        var
         match$29 =
           type_format_gen
            (fmt_rest$13,
             caml_call1(CamlinternalFormatBasics[2], fmtty_rest$10)),
         fmtty$13 = match$29[2],
         fmt$14 = match$29[1];
        return [0, [14, pad_opt$0, sub_fmtty1, fmt$14], fmtty$13];
       }
       break;
      case 15:
       if(typeof fmtty0 !== "number" && 10 === fmtty0[0]){
        var
         fmtty_rest$11 = fmtty0[1],
         fmt_rest$14 = fmt[1],
         match$30 = type_format_gen(fmt_rest$14, fmtty_rest$11),
         fmtty$14 = match$30[2],
         fmt$15 = match$30[1];
        return [0, [15, fmt$15], fmtty$14];
       }
       break;
      case 16:
       if(typeof fmtty0 !== "number" && 11 === fmtty0[0]){
        var
         fmtty_rest$12 = fmtty0[1],
         fmt_rest$15 = fmt[1],
         match$31 = type_format_gen(fmt_rest$15, fmtty_rest$12),
         fmtty$15 = match$31[2],
         fmt$16 = match$31[1];
        return [0, [16, fmt$16], fmtty$15];
       }
       break;
      case 17:
       var
        fmt_rest$16 = fmt[2],
        formatting_lit = fmt[1],
        match$32 = type_format_gen(fmt_rest$16, fmtty0),
        fmtty$16 = match$32[2],
        fmt$17 = match$32[1];
       return [0, [17, formatting_lit, fmt$17], fmtty$16];
      case 18:
       var fmt_rest$17 = fmt[2], formatting_gen = fmt[1];
       if(0 === formatting_gen[0]){
        var
         match$36 = formatting_gen[1],
         str$0 = match$36[2],
         fmt1 = match$36[1],
         match$37 = type_format_gen(fmt1, fmtty0),
         fmtty2 = match$37[2],
         fmt2 = match$37[1],
         match$38 = type_format_gen(fmt_rest$17, fmtty2),
         fmtty3 = match$38[2],
         fmt3 = match$38[1];
        return [0, [18, [0, [0, fmt2, str$0]], fmt3], fmtty3];
       }
       var
        match$39 = formatting_gen[1],
        str$1 = match$39[2],
        fmt1$0 = match$39[1],
        match$40 = type_format_gen(fmt1$0, fmtty0),
        fmtty2$0 = match$40[2],
        fmt2$0 = match$40[1],
        match$41 = type_format_gen(fmt_rest$17, fmtty2$0),
        fmtty3$0 = match$41[2],
        fmt3$0 = match$41[1];
       return [0, [18, [1, [0, fmt2$0, str$1]], fmt3$0], fmtty3$0];
      case 19:
       if(typeof fmtty0 !== "number" && 13 === fmtty0[0]){
        var
         fmtty_rest$13 = fmtty0[1],
         fmt_rest$18 = fmt[1],
         match$33 = type_format_gen(fmt_rest$18, fmtty_rest$13),
         fmtty$17 = match$33[2],
         fmt$18 = match$33[1];
        return [0, [19, fmt$18], fmtty$17];
       }
       break;
      case 20:
       if(typeof fmtty0 !== "number" && 1 === fmtty0[0]){
        var
         fmtty_rest$14 = fmtty0[1],
         fmt_rest$19 = fmt[3],
         char_set = fmt[2],
         width_opt = fmt[1],
         match$34 = type_format_gen(fmt_rest$19, fmtty_rest$14),
         fmtty$18 = match$34[2],
         fmt$19 = match$34[1];
        return [0, [20, width_opt, char_set, fmt$19], fmtty$18];
       }
       break;
      case 21:
       if(typeof fmtty0 !== "number" && 2 === fmtty0[0]){
        var
         fmtty_rest$15 = fmtty0[1],
         fmt_rest$20 = fmt[2],
         counter = fmt[1],
         match$35 = type_format_gen(fmt_rest$20, fmtty_rest$15),
         fmtty$19 = match$35[2],
         fmt$20 = match$35[1];
        return [0, [21, counter, fmt$20], fmtty$19];
       }
       break;
      case 23:
       var rest = fmt[2], ign = fmt[1];
       if(typeof ign !== "number")
        switch(ign[0]){
          case 0:
           return type_ignored_param_one(ign, rest, fmtty0);
          case 1:
           return type_ignored_param_one(ign, rest, fmtty0);
          case 2:
           return type_ignored_param_one(ign, rest, fmtty0);
          case 3:
           return type_ignored_param_one(ign, rest, fmtty0);
          case 4:
           return type_ignored_param_one(ign, rest, fmtty0);
          case 5:
           return type_ignored_param_one(ign, rest, fmtty0);
          case 6:
           return type_ignored_param_one(ign, rest, fmtty0);
          case 7:
           return type_ignored_param_one(ign, rest, fmtty0);
          case 8:
           var sub_fmtty$2 = ign[2], pad_opt$1 = ign[1];
           return type_ignored_param_one
                   ([8, pad_opt$1, sub_fmtty$2], rest, fmtty0);
          case 9:
           var
            sub_fmtty$3 = ign[2],
            pad_opt$2 = ign[1],
            _cz_ = type_ignored_format_substituti(sub_fmtty$3, rest, fmtty0),
            match$43 = _cz_[2],
            fmtty$21 = match$43[2],
            fmt$22 = match$43[1],
            sub_fmtty$4 = _cz_[1];
           return [0, [23, [9, pad_opt$2, sub_fmtty$4], fmt$22], fmtty$21];
          case 10:
           return type_ignored_param_one(ign, rest, fmtty0);
          default: return type_ignored_param_one(ign, rest, fmtty0);
        }
       switch(ign){
         case 0:
          return type_ignored_param_one(ign, rest, fmtty0);
         case 1:
          return type_ignored_param_one(ign, rest, fmtty0);
         case 2:
          if(typeof fmtty0 !== "number" && 14 === fmtty0[0]){
           var
            fmtty_rest$16 = fmtty0[1],
            match$42 = type_format_gen(rest, fmtty_rest$16),
            fmtty$20 = match$42[2],
            fmt$21 = match$42[1];
           return [0, [23, 2, fmt$21], fmtty$20];
          }
          throw caml_maybe_attach_backtrace(Type_mismatch, 1);
         default: return type_ignored_param_one(ign, rest, fmtty0);
       }
    }
    throw caml_maybe_attach_backtrace(Type_mismatch, 1);
   }
   function type_ignored_param_one(ign, fmt, fmtty){
    var
     match = type_format_gen(fmt, fmtty),
     fmtty$0 = match[2],
     fmt$0 = match[1];
    return [0, [23, ign, fmt$0], fmtty$0];
   }
   function type_ignored_format_substituti(sub_fmtty, fmt, fmtty){
    if(typeof sub_fmtty === "number")
     return [0, 0, type_format_gen(fmt, fmtty)];
    switch(sub_fmtty[0]){
      case 0:
       if(typeof fmtty !== "number" && 0 === fmtty[0]){
        var
         fmtty_rest = fmtty[1],
         sub_fmtty_rest = sub_fmtty[1],
         match =
           type_ignored_format_substituti(sub_fmtty_rest, fmt, fmtty_rest),
         fmt$0 = match[2],
         sub_fmtty_rest$0 = match[1];
        return [0, [0, sub_fmtty_rest$0], fmt$0];
       }
       break;
      case 1:
       if(typeof fmtty !== "number" && 1 === fmtty[0]){
        var
         fmtty_rest$0 = fmtty[1],
         sub_fmtty_rest$1 = sub_fmtty[1],
         match$0 =
           type_ignored_format_substituti(sub_fmtty_rest$1, fmt, fmtty_rest$0),
         fmt$1 = match$0[2],
         sub_fmtty_rest$2 = match$0[1];
        return [0, [1, sub_fmtty_rest$2], fmt$1];
       }
       break;
      case 2:
       if(typeof fmtty !== "number" && 2 === fmtty[0]){
        var
         fmtty_rest$1 = fmtty[1],
         sub_fmtty_rest$3 = sub_fmtty[1],
         match$1 =
           type_ignored_format_substituti(sub_fmtty_rest$3, fmt, fmtty_rest$1),
         fmt$2 = match$1[2],
         sub_fmtty_rest$4 = match$1[1];
        return [0, [2, sub_fmtty_rest$4], fmt$2];
       }
       break;
      case 3:
       if(typeof fmtty !== "number" && 3 === fmtty[0]){
        var
         fmtty_rest$2 = fmtty[1],
         sub_fmtty_rest$5 = sub_fmtty[1],
         match$2 =
           type_ignored_format_substituti(sub_fmtty_rest$5, fmt, fmtty_rest$2),
         fmt$3 = match$2[2],
         sub_fmtty_rest$6 = match$2[1];
        return [0, [3, sub_fmtty_rest$6], fmt$3];
       }
       break;
      case 4:
       if(typeof fmtty !== "number" && 4 === fmtty[0]){
        var
         fmtty_rest$3 = fmtty[1],
         sub_fmtty_rest$7 = sub_fmtty[1],
         match$3 =
           type_ignored_format_substituti(sub_fmtty_rest$7, fmt, fmtty_rest$3),
         fmt$4 = match$3[2],
         sub_fmtty_rest$8 = match$3[1];
        return [0, [4, sub_fmtty_rest$8], fmt$4];
       }
       break;
      case 5:
       if(typeof fmtty !== "number" && 5 === fmtty[0]){
        var
         fmtty_rest$4 = fmtty[1],
         sub_fmtty_rest$9 = sub_fmtty[1],
         match$4 =
           type_ignored_format_substituti(sub_fmtty_rest$9, fmt, fmtty_rest$4),
         fmt$5 = match$4[2],
         sub_fmtty_rest$10 = match$4[1];
        return [0, [5, sub_fmtty_rest$10], fmt$5];
       }
       break;
      case 6:
       if(typeof fmtty !== "number" && 6 === fmtty[0]){
        var
         fmtty_rest$5 = fmtty[1],
         sub_fmtty_rest$11 = sub_fmtty[1],
         match$5 =
           type_ignored_format_substituti
            (sub_fmtty_rest$11, fmt, fmtty_rest$5),
         fmt$6 = match$5[2],
         sub_fmtty_rest$12 = match$5[1];
        return [0, [6, sub_fmtty_rest$12], fmt$6];
       }
       break;
      case 7:
       if(typeof fmtty !== "number" && 7 === fmtty[0]){
        var
         fmtty_rest$6 = fmtty[1],
         sub_fmtty_rest$13 = sub_fmtty[1],
         match$6 =
           type_ignored_format_substituti
            (sub_fmtty_rest$13, fmt, fmtty_rest$6),
         fmt$7 = match$6[2],
         sub_fmtty_rest$14 = match$6[1];
        return [0, [7, sub_fmtty_rest$14], fmt$7];
       }
       break;
      case 8:
       if(typeof fmtty !== "number" && 8 === fmtty[0]){
        var
         fmtty_rest$7 = fmtty[2],
         sub2_fmtty = fmtty[1],
         sub_fmtty_rest$15 = sub_fmtty[2],
         sub2_fmtty$0 = sub_fmtty[1];
        if(caml_notequal([0, sub2_fmtty$0], [0, sub2_fmtty]))
         throw caml_maybe_attach_backtrace(Type_mismatch, 1);
        var
         match$7 =
           type_ignored_format_substituti
            (sub_fmtty_rest$15, fmt, fmtty_rest$7),
         fmt$8 = match$7[2],
         sub_fmtty_rest$16 = match$7[1];
        return [0, [8, sub2_fmtty, sub_fmtty_rest$16], fmt$8];
       }
       break;
      case 9:
       if(typeof fmtty !== "number" && 9 === fmtty[0]){
        var
         fmtty_rest$8 = fmtty[3],
         sub2_fmtty$1 = fmtty[2],
         sub1_fmtty = fmtty[1],
         sub_fmtty_rest$17 = sub_fmtty[3],
         sub2_fmtty$2 = sub_fmtty[2],
         sub1_fmtty$0 = sub_fmtty[1],
         _cw_ = [0, caml_call1(CamlinternalFormatBasics[2], sub1_fmtty)];
        if
         (caml_notequal
           ([0, caml_call1(CamlinternalFormatBasics[2], sub1_fmtty$0)], _cw_))
         throw caml_maybe_attach_backtrace(Type_mismatch, 1);
        var _cx_ = [0, caml_call1(CamlinternalFormatBasics[2], sub2_fmtty$1)];
        if
         (caml_notequal
           ([0, caml_call1(CamlinternalFormatBasics[2], sub2_fmtty$2)], _cx_))
         throw caml_maybe_attach_backtrace(Type_mismatch, 1);
        var
         sub_fmtty$0 = trans(symm(sub1_fmtty), sub2_fmtty$1),
         match$8 = fmtty_rel_det(sub_fmtty$0),
         f4 = match$8[4],
         f2 = match$8[2];
        f2(0);
        f4(0);
        var
         match$9 =
           type_ignored_format_substituti
            (caml_call1(CamlinternalFormatBasics[2], sub_fmtty_rest$17),
             fmt,
             fmtty_rest$8),
         fmt$9 = match$9[2],
         sub_fmtty_rest$18 = match$9[1];
        return [0,
                [9, sub1_fmtty, sub2_fmtty$1, symm(sub_fmtty_rest$18)],
                fmt$9];
       }
       break;
      case 10:
       if(typeof fmtty !== "number" && 10 === fmtty[0]){
        var
         fmtty_rest$9 = fmtty[1],
         sub_fmtty_rest$19 = sub_fmtty[1],
         match$10 =
           type_ignored_format_substituti
            (sub_fmtty_rest$19, fmt, fmtty_rest$9),
         fmt$10 = match$10[2],
         sub_fmtty_rest$20 = match$10[1];
        return [0, [10, sub_fmtty_rest$20], fmt$10];
       }
       break;
      case 11:
       if(typeof fmtty !== "number" && 11 === fmtty[0]){
        var
         fmtty_rest$10 = fmtty[1],
         sub_fmtty_rest$21 = sub_fmtty[1],
         match$11 =
           type_ignored_format_substituti
            (sub_fmtty_rest$21, fmt, fmtty_rest$10),
         fmt$11 = match$11[2],
         sub_fmtty_rest$22 = match$11[1];
        return [0, [11, sub_fmtty_rest$22], fmt$11];
       }
       break;
      case 13:
       if(typeof fmtty !== "number" && 13 === fmtty[0]){
        var
         fmtty_rest$11 = fmtty[1],
         sub_fmtty_rest$23 = sub_fmtty[1],
         match$12 =
           type_ignored_format_substituti
            (sub_fmtty_rest$23, fmt, fmtty_rest$11),
         fmt$12 = match$12[2],
         sub_fmtty_rest$24 = match$12[1];
        return [0, [13, sub_fmtty_rest$24], fmt$12];
       }
       break;
      case 14:
       if(typeof fmtty !== "number" && 14 === fmtty[0]){
        var
         fmtty_rest$12 = fmtty[1],
         sub_fmtty_rest$25 = sub_fmtty[1],
         match$13 =
           type_ignored_format_substituti
            (sub_fmtty_rest$25, fmt, fmtty_rest$12),
         fmt$13 = match$13[2],
         sub_fmtty_rest$26 = match$13[1];
        return [0, [14, sub_fmtty_rest$26], fmt$13];
       }
       break;
    }
    throw caml_maybe_attach_backtrace(Type_mismatch, 1);
   }
   function recast(fmt, fmtty){
    var _cv_ = symm(fmtty);
    return type_format(fmt, caml_call1(CamlinternalFormatBasics[2], _cv_));
   }
   function fix_padding(padty, width, str){
    var
     len = caml_ml_string_length(str),
     padty$0 = 0 <= width ? padty : 0,
     width$0 = caml_call1(Stdlib[18], width);
    if(width$0 <= len) return str;
    var
     _cu_ = 2 === padty$0 ? 48 : 32,
     res = caml_call2(Stdlib_Bytes[1], width$0, _cu_);
    switch(padty$0){
      case 0:
       caml_call5(Stdlib_String[48], str, 0, res, 0, len); break;
      case 1:
       caml_call5(Stdlib_String[48], str, 0, res, width$0 - len | 0, len);
       break;
      default:
       a:
       if(0 < len){
        if
         (43 !== caml_string_get(str, 0)
          && 45 !== caml_string_get(str, 0) && 32 !== caml_string_get(str, 0))
         break a;
        caml_bytes_set(res, 0, caml_string_get(str, 0));
        caml_call5
         (Stdlib_String[48],
          str,
          1,
          res,
          (width$0 - len | 0) + 1 | 0,
          len - 1 | 0);
        break;
       }
       a:
       if(1 < len && 48 === caml_string_get(str, 0)){
        if(120 !== caml_string_get(str, 1) && 88 !== caml_string_get(str, 1))
         break a;
        caml_bytes_set(res, 1, caml_string_get(str, 1));
        caml_call5
         (Stdlib_String[48],
          str,
          2,
          res,
          (width$0 - len | 0) + 2 | 0,
          len - 2 | 0);
        break;
       }
       caml_call5(Stdlib_String[48], str, 0, res, width$0 - len | 0, len);
    }
    return caml_call1(Stdlib_Bytes[48], res);
   }
   function fix_int_precision(prec, str){
    var
     prec$0 = caml_call1(Stdlib[18], prec),
     len = caml_ml_string_length(str),
     c = caml_string_get(str, 0);
    a:
    {
     b:
     {
      if(58 > c){
       if(32 !== c){
        if(43 > c) break a;
        switch(c - 43 | 0){
          case 5:
           c:
           if(len < (prec$0 + 2 | 0) && 1 < len){
            if
             (120 !== caml_string_get(str, 1)
              && 88 !== caml_string_get(str, 1))
             break c;
            var res$1 = caml_call2(Stdlib_Bytes[1], prec$0 + 2 | 0, 48);
            caml_bytes_set(res$1, 1, caml_string_get(str, 1));
            caml_call5
             (Stdlib_String[48],
              str,
              2,
              res$1,
              (prec$0 - len | 0) + 4 | 0,
              len - 2 | 0);
            return caml_call1(Stdlib_Bytes[48], res$1);
           }
           break b;
          case 0:
          case 2: break;
          case 1:
          case 3:
          case 4:
           break a;
          default: break b;
        }
       }
       if(len >= (prec$0 + 1 | 0)) break a;
       var res$0 = caml_call2(Stdlib_Bytes[1], prec$0 + 1 | 0, 48);
       caml_bytes_set(res$0, 0, c);
       caml_call5
        (Stdlib_String[48],
         str,
         1,
         res$0,
         (prec$0 - len | 0) + 2 | 0,
         len - 1 | 0);
       return caml_call1(Stdlib_Bytes[48], res$0);
      }
      if(71 <= c){if(5 < c - 97 >>> 0) break a;} else if(65 > c) break a;
     }
     if(len < prec$0){
      var res = caml_call2(Stdlib_Bytes[1], prec$0, 48);
      caml_call5(Stdlib_String[48], str, 0, res, prec$0 - len | 0, len);
      return caml_call1(Stdlib_Bytes[48], res);
     }
    }
    return str;
   }
   function string_to_caml_string(str){
    var
     str$0 = caml_call1(Stdlib_String[24], str),
     l = caml_ml_string_length(str$0),
     res = caml_call2(Stdlib_Bytes[1], l + 2 | 0, 34);
    caml_blit_string(str$0, 0, res, 1, l);
    return caml_call1(Stdlib_Bytes[48], res);
   }
   function format_of_fconv(fconv, prec){
    var
     prec$0 = caml_call1(Stdlib[18], prec),
     symb = char_of_fconv(_r_, fconv),
     buf = buffer_create(16);
    buffer_add_char(buf, 37);
    bprint_fconv_flag(buf, fconv);
    buffer_add_char(buf, 46);
    buffer_add_string(buf, caml_call1(Stdlib_Int[12], prec$0));
    buffer_add_char(buf, symb);
    return buffer_contents(buf);
   }
   function transform_int_alt(iconv, s){
    if(13 > iconv) return s;
    var n = [0, 0], _cp_ = caml_ml_string_length(s) - 1 | 0, _co_ = 0;
    if(_cp_ >= 0){
     var i$0 = _co_;
     for(;;){
      if(9 >= caml_string_unsafe_get(s, i$0) - 48 >>> 0) n[1]++;
      var _ct_ = i$0 + 1 | 0;
      if(_cp_ === i$0) break;
      i$0 = _ct_;
     }
    }
    var
     digits = n[1],
     buf =
       caml_create_bytes
        (caml_ml_string_length(s) + ((digits - 1 | 0) / 3 | 0) | 0),
     pos = [0, 0];
    function put(c){caml_bytes_set(buf, pos[1], c); pos[1]++; return;}
    var
     left = [0, ((digits - 1 | 0) % 3 | 0) + 1 | 0],
     _cr_ = caml_ml_string_length(s) - 1 | 0,
     _cq_ = 0;
    if(_cr_ >= 0){
     var i = _cq_;
     for(;;){
      var c = caml_string_unsafe_get(s, i);
      if(9 < c - 48 >>> 0)
       put(c);
      else{if(0 === left[1]){put(95); left[1] = 3;} left[1]--; put(c);}
      var _cs_ = i + 1 | 0;
      if(_cr_ === i) break;
      i = _cs_;
     }
    }
    return caml_call1(Stdlib_Bytes[48], buf);
   }
   function convert_int(iconv, n){
    switch(iconv){
      case 1:
       var _cn_ = cst_d$0; break;
      case 2:
       var _cn_ = cst_d$1; break;
      case 4:
       var _cn_ = cst_i$1; break;
      case 5:
       var _cn_ = cst_i$2; break;
      case 6:
       var _cn_ = cst_x; break;
      case 7:
       var _cn_ = cst_x$0; break;
      case 8:
       var _cn_ = cst_X; break;
      case 9:
       var _cn_ = cst_X$0; break;
      case 10:
       var _cn_ = cst_o; break;
      case 11:
       var _cn_ = cst_o$0; break;
      case 0:
      case 13:
       var _cn_ = cst_d; break;
      case 3:
      case 14:
       var _cn_ = cst_i$0; break;
      default: var _cn_ = cst_u;
    }
    return transform_int_alt(iconv, caml_format_int(_cn_, n));
   }
   function convert_int32(iconv, n){
    switch(iconv){
      case 1:
       var _cm_ = cst_ld$0; break;
      case 2:
       var _cm_ = cst_ld$1; break;
      case 4:
       var _cm_ = cst_li$1; break;
      case 5:
       var _cm_ = cst_li$2; break;
      case 6:
       var _cm_ = cst_lx; break;
      case 7:
       var _cm_ = cst_lx$0; break;
      case 8:
       var _cm_ = cst_lX; break;
      case 9:
       var _cm_ = cst_lX$0; break;
      case 10:
       var _cm_ = cst_lo; break;
      case 11:
       var _cm_ = cst_lo$0; break;
      case 0:
      case 13:
       var _cm_ = cst_ld; break;
      case 3:
      case 14:
       var _cm_ = cst_li$0; break;
      default: var _cm_ = cst_lu;
    }
    return transform_int_alt(iconv, caml_format_int(_cm_, n));
   }
   function convert_nativeint(iconv, n){
    switch(iconv){
      case 1:
       var _cl_ = cst_nd$0; break;
      case 2:
       var _cl_ = cst_nd$1; break;
      case 4:
       var _cl_ = cst_ni$1; break;
      case 5:
       var _cl_ = cst_ni$2; break;
      case 6:
       var _cl_ = cst_nx; break;
      case 7:
       var _cl_ = cst_nx$0; break;
      case 8:
       var _cl_ = cst_nX; break;
      case 9:
       var _cl_ = cst_nX$0; break;
      case 10:
       var _cl_ = cst_no; break;
      case 11:
       var _cl_ = cst_no$0; break;
      case 0:
      case 13:
       var _cl_ = cst_nd; break;
      case 3:
      case 14:
       var _cl_ = cst_ni$0; break;
      default: var _cl_ = cst_nu;
    }
    return transform_int_alt(iconv, caml_format_int(_cl_, n));
   }
   function convert_int64(iconv, n){
    switch(iconv){
      case 1:
       var _ck_ = cst_Ld$0; break;
      case 2:
       var _ck_ = cst_Ld$1; break;
      case 4:
       var _ck_ = cst_Li$1; break;
      case 5:
       var _ck_ = cst_Li$2; break;
      case 6:
       var _ck_ = cst_Lx; break;
      case 7:
       var _ck_ = cst_Lx$0; break;
      case 8:
       var _ck_ = cst_LX; break;
      case 9:
       var _ck_ = cst_LX$0; break;
      case 10:
       var _ck_ = cst_Lo; break;
      case 11:
       var _ck_ = cst_Lo$0; break;
      case 0:
      case 13:
       var _ck_ = cst_Ld; break;
      case 3:
      case 14:
       var _ck_ = cst_Li$0; break;
      default: var _ck_ = cst_Lu;
    }
    return transform_int_alt(iconv, runtime.caml_int64_format(_ck_, n));
   }
   function convert_float(fconv, prec, x){
    function hex(param){
     switch(fconv[1]){
       case 0:
        var sign = 45; break;
       case 1:
        var sign = 43; break;
       default: var sign = 32;
     }
     return runtime.caml_hexstring_of_float(x, prec, sign);
    }
    function caml_special_val(str){
     var match = runtime.caml_classify_float(x);
     return 3 === match
             ? x < 0. ? cst_neg_infinity : cst_infinity
             : 4 <= match ? cst_nan : str;
    }
    switch(fconv[2]){
      case 5:
       var
        str = caml_format_float(format_of_fconv(fconv, prec), x),
        len = caml_ml_string_length(str),
        i = 0;
       for(;;){
        if(i === len)
         var _ch_ = 0;
        else{
         var _cg_ = caml_string_get(str, i) - 46 | 0;
         a:
         {
          if(23 < _cg_ >>> 0){
           if(55 === _cg_) break a;
          }
          else if(21 < _cg_ - 1 >>> 0) break a;
          var i$0 = i + 1 | 0;
          i = i$0;
          continue;
         }
         var _ch_ = 1;
        }
        var _ci_ = _ch_ ? str : caml_call2(Stdlib[28], str, cst$17);
        return caml_special_val(_ci_);
       }
      case 6:
       return hex(0);
      case 7:
       var _cj_ = hex(0); return caml_call1(Stdlib_String[25], _cj_);
      case 8:
       return caml_special_val(hex(0));
      default: return caml_format_float(format_of_fconv(fconv, prec), x);
    }
   }
   function string_of_fmtty(fmtty){
    var buf = buffer_create(16);
    bprint_fmtty(buf, fmtty);
    return buffer_contents(buf);
   }
   function make_printf$0(counter, k, acc, fmt){
    var k$0 = k, acc$0 = acc, fmt$0 = fmt;
    for(;;){
     if(typeof fmt$0 === "number") return caml_call1(k$0, acc$0);
     switch(fmt$0[0]){
       case 0:
        var rest = fmt$0[1];
        return function(c){
         var new_acc = [5, acc$0, c];
         return make_printf(k$0, new_acc, rest);};
       case 1:
        var rest$0 = fmt$0[1];
        return function(c){
         var
          str = caml_call1(Stdlib_Char[2], c),
          l = caml_ml_string_length(str),
          res = caml_call2(Stdlib_Bytes[1], l + 2 | 0, 39);
         caml_blit_string(str, 0, res, 1, l);
         var new_acc = [4, acc$0, caml_call1(Stdlib_Bytes[48], res)];
         return make_printf(k$0, new_acc, rest$0);};
       case 2:
        var rest$1 = fmt$0[2], pad = fmt$0[1];
        return make_padding
                (k$0, acc$0, rest$1, pad, function(str){return str;});
       case 3:
        var rest$2 = fmt$0[2], pad$0 = fmt$0[1];
        return make_padding(k$0, acc$0, rest$2, pad$0, string_to_caml_string);
       case 4:
        var
         rest$3 = fmt$0[4],
         prec = fmt$0[3],
         pad$1 = fmt$0[2],
         iconv = fmt$0[1];
        return make_int_padding_precision
                (k$0, acc$0, rest$3, pad$1, prec, convert_int, iconv);
       case 5:
        var
         rest$4 = fmt$0[4],
         prec$0 = fmt$0[3],
         pad$2 = fmt$0[2],
         iconv$0 = fmt$0[1];
        return make_int_padding_precision
                (k$0, acc$0, rest$4, pad$2, prec$0, convert_int32, iconv$0);
       case 6:
        var
         rest$5 = fmt$0[4],
         prec$1 = fmt$0[3],
         pad$3 = fmt$0[2],
         iconv$1 = fmt$0[1];
        return make_int_padding_precision
                (k$0,
                 acc$0,
                 rest$5,
                 pad$3,
                 prec$1,
                 convert_nativeint,
                 iconv$1);
       case 7:
        var
         rest$6 = fmt$0[4],
         prec$2 = fmt$0[3],
         pad$4 = fmt$0[2],
         iconv$2 = fmt$0[1];
        return make_int_padding_precision
                (k$0, acc$0, rest$6, pad$4, prec$2, convert_int64, iconv$2);
       case 8:
        var
         rest$7 = fmt$0[4],
         prec$3 = fmt$0[3],
         pad$5 = fmt$0[2],
         fconv = fmt$0[1];
        if(typeof pad$5 === "number"){
         if(typeof prec$3 === "number")
          return prec$3
                  ? function
                   (p, x){
                    var str = convert_float(fconv, p, x);
                    return make_printf(k$0, [4, acc$0, str], rest$7);
                   }
                  : function
                   (x){
                    var
                     str =
                       convert_float(fconv, default_float_precision(fconv), x);
                    return make_printf(k$0, [4, acc$0, str], rest$7);
                   };
         var p = prec$3[1];
         return function(x){
          var str = convert_float(fconv, p, x);
          return make_printf(k$0, [4, acc$0, str], rest$7);};
        }
        if(0 === pad$5[0]){
         var w = pad$5[2], padty = pad$5[1];
         if(typeof prec$3 === "number")
          return prec$3
                  ? function
                   (p, x){
                    var str = fix_padding(padty, w, convert_float(fconv, p, x));
                    return make_printf(k$0, [4, acc$0, str], rest$7);
                   }
                  : function
                   (x){
                    var
                     str =
                       convert_float(fconv, default_float_precision(fconv), x),
                     str$0 = fix_padding(padty, w, str);
                    return make_printf(k$0, [4, acc$0, str$0], rest$7);
                   };
         var p$0 = prec$3[1];
         return function(x){
          var str = fix_padding(padty, w, convert_float(fconv, p$0, x));
          return make_printf(k$0, [4, acc$0, str], rest$7);};
        }
        var padty$0 = pad$5[1];
        if(typeof prec$3 === "number")
         return prec$3
                 ? function
                  (w, p, x){
                   var
                    str = fix_padding(padty$0, w, convert_float(fconv, p, x));
                   return make_printf(k$0, [4, acc$0, str], rest$7);
                  }
                 : function
                  (w, x){
                   var
                    str =
                      convert_float(fconv, default_float_precision(fconv), x),
                    str$0 = fix_padding(padty$0, w, str);
                   return make_printf(k$0, [4, acc$0, str$0], rest$7);
                  };
        var p$1 = prec$3[1];
        return function(w, x){
         var str = fix_padding(padty$0, w, convert_float(fconv, p$1, x));
         return make_printf(k$0, [4, acc$0, str], rest$7);};
       case 9:
        var rest$8 = fmt$0[2], pad$6 = fmt$0[1];
        return make_padding(k$0, acc$0, rest$8, pad$6, Stdlib[30]);
       case 10:
        var rest$9 = fmt$0[1], acc$1 = [7, acc$0];
        acc$0 = acc$1;
        fmt$0 = rest$9;
        break;
       case 11:
        var rest$10 = fmt$0[2], str = fmt$0[1], acc$2 = [2, acc$0, str];
        acc$0 = acc$2;
        fmt$0 = rest$10;
        break;
       case 12:
        var rest$11 = fmt$0[2], chr = fmt$0[1], acc$3 = [3, acc$0, chr];
        acc$0 = acc$3;
        fmt$0 = rest$11;
        break;
       case 13:
        var
         rest$12 = fmt$0[3],
         sub_fmtty = fmt$0[2],
         ty = string_of_fmtty(sub_fmtty);
        return function(str){
         return make_printf(k$0, [4, acc$0, ty], rest$12);};
       case 14:
        var rest$13 = fmt$0[3], fmtty = fmt$0[2];
        return function(param){
         var fmt = param[1], _cf_ = recast(fmt, fmtty);
         return make_printf
                 (k$0,
                  acc$0,
                  caml_call2(CamlinternalFormatBasics[3], _cf_, rest$13));};
       case 15:
        var rest$14 = fmt$0[1];
        return function(f, x){
         return make_printf
                 (k$0,
                  [6, acc$0, function(o){return caml_call2(f, o, x);}],
                  rest$14);};
       case 16:
        var rest$15 = fmt$0[1];
        return function(f){return make_printf(k$0, [6, acc$0, f], rest$15);};
       case 17:
        var
         rest$16 = fmt$0[2],
         fmting_lit = fmt$0[1],
         acc$4 = [0, acc$0, fmting_lit];
        acc$0 = acc$4;
        fmt$0 = rest$16;
        break;
       case 18:
        var _cd_ = fmt$0[1];
        if(0 === _cd_[0]){
         var rest$17 = fmt$0[2], fmt$1 = _cd_[1][1];
         let acc = acc$0, k = k$0, rest = rest$17;
         var
          k$1 =
            function(kacc){return make_printf(k, [1, acc, [0, kacc]], rest);};
         k$0 = k$1;
         acc$0 = 0;
         fmt$0 = fmt$1;
        }
        else{
         var rest$18 = fmt$0[2], fmt$2 = _cd_[1][1];
         let acc = acc$0, k = k$0, rest = rest$18;
         var
          k$2 =
            function(kacc){return make_printf(k, [1, acc, [1, kacc]], rest);};
         k$0 = k$2;
         acc$0 = 0;
         fmt$0 = fmt$2;
        }
        break;
       case 19:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _s_], 1);
       case 20:
        var
         rest$19 = fmt$0[3],
         new_acc = [8, acc$0, cst_Printf_bad_conversion];
        return function(param){return make_printf(k$0, new_acc, rest$19);};
       case 21:
        var rest$20 = fmt$0[2];
        return function(n){
         var new_acc = [4, acc$0, caml_format_int(cst_u$0, n)];
         return make_printf(k$0, new_acc, rest$20);};
       case 22:
        var rest$21 = fmt$0[1];
        return function(c){
         var new_acc = [5, acc$0, c];
         return make_printf(k$0, new_acc, rest$21);};
       case 23:
        var rest$22 = fmt$0[2], ign = fmt$0[1];
        if(counter >= 50)
         return caml_trampoline_return
                 (make_ignored_param$0, [0, k$0, acc$0, ign, rest$22]);
        var counter$1 = counter + 1 | 0;
        return make_ignored_param$0(counter$1, k$0, acc$0, ign, rest$22);
       default:
        var
         rest$23 = fmt$0[3],
         f = fmt$0[2],
         arity = fmt$0[1],
         _ce_ = caml_call1(f, 0);
        if(counter >= 50)
         return caml_trampoline_return
                 (make_custom$0, [0, k$0, acc$0, rest$23, arity, _ce_]);
        var counter$0 = counter + 1 | 0;
        return make_custom$0(counter$0, k$0, acc$0, rest$23, arity, _ce_);
     }
    }
   }
   function make_printf(k, acc, fmt){
    return caml_trampoline(make_printf$0(0, k, acc, fmt));
   }
   function make_ignored_param$0(counter, k, acc, ign, fmt){
    if(typeof ign === "number")
     switch(ign){
       case 0:
        if(counter >= 50)
         return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
        var counter$0 = counter + 1 | 0;
        return make_invalid_arg(counter$0, k, acc, fmt);
       case 1:
        if(counter >= 50)
         return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
        var counter$1 = counter + 1 | 0;
        return make_invalid_arg(counter$1, k, acc, fmt);
       case 2:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _t_], 1);
       default:
        if(counter >= 50)
         return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
        var counter$2 = counter + 1 | 0;
        return make_invalid_arg(counter$2, k, acc, fmt);
     }
    switch(ign[0]){
      case 0:
       if(counter >= 50)
        return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
       var counter$3 = counter + 1 | 0;
       return make_invalid_arg(counter$3, k, acc, fmt);
      case 1:
       if(counter >= 50)
        return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
       var counter$4 = counter + 1 | 0;
       return make_invalid_arg(counter$4, k, acc, fmt);
      case 2:
       if(counter >= 50)
        return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
       var counter$5 = counter + 1 | 0;
       return make_invalid_arg(counter$5, k, acc, fmt);
      case 3:
       if(counter >= 50)
        return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
       var counter$6 = counter + 1 | 0;
       return make_invalid_arg(counter$6, k, acc, fmt);
      case 4:
       if(counter >= 50)
        return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
       var counter$7 = counter + 1 | 0;
       return make_invalid_arg(counter$7, k, acc, fmt);
      case 5:
       if(counter >= 50)
        return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
       var counter$8 = counter + 1 | 0;
       return make_invalid_arg(counter$8, k, acc, fmt);
      case 6:
       if(counter >= 50)
        return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
       var counter$9 = counter + 1 | 0;
       return make_invalid_arg(counter$9, k, acc, fmt);
      case 7:
       if(counter >= 50)
        return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
       var counter$10 = counter + 1 | 0;
       return make_invalid_arg(counter$10, k, acc, fmt);
      case 8:
       if(counter >= 50)
        return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
       var counter$11 = counter + 1 | 0;
       return make_invalid_arg(counter$11, k, acc, fmt);
      case 9:
       var fmtty = ign[2];
       if(counter >= 50)
        return caml_trampoline_return
                (make_from_fmtty$0, [0, k, acc, fmtty, fmt]);
       var counter$14 = counter + 1 | 0;
       return make_from_fmtty$0(counter$14, k, acc, fmtty, fmt);
      case 10:
       if(counter >= 50)
        return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
       var counter$12 = counter + 1 | 0;
       return make_invalid_arg(counter$12, k, acc, fmt);
      default:
       if(counter >= 50)
        return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
       var counter$13 = counter + 1 | 0;
       return make_invalid_arg(counter$13, k, acc, fmt);
    }
   }
   function make_ignored_param(k, acc, ign, fmt){
    return caml_trampoline(make_ignored_param$0(0, k, acc, ign, fmt));
   }
   function make_from_fmtty$0(counter, k, acc, fmtty, fmt){
    if(typeof fmtty !== "number")
     switch(fmtty[0]){
       case 0:
        var rest = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest, fmt);};
       case 1:
        var rest$0 = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest$0, fmt);};
       case 2:
        var rest$1 = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest$1, fmt);};
       case 3:
        var rest$2 = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest$2, fmt);};
       case 4:
        var rest$3 = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest$3, fmt);};
       case 5:
        var rest$4 = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest$4, fmt);};
       case 6:
        var rest$5 = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest$5, fmt);};
       case 7:
        var rest$6 = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest$6, fmt);};
       case 8:
        var rest$7 = fmtty[2];
        return function(param){return make_from_fmtty(k, acc, rest$7, fmt);};
       case 9:
        var
         rest$8 = fmtty[3],
         ty2 = fmtty[2],
         ty1 = fmtty[1],
         ty = trans(symm(ty1), ty2);
        return function(param){
         return make_from_fmtty
                 (k,
                  acc,
                  caml_call2(CamlinternalFormatBasics[1], ty, rest$8),
                  fmt);};
       case 10:
        var rest$9 = fmtty[1];
        return function(param, _cc_){
         return make_from_fmtty(k, acc, rest$9, fmt);};
       case 11:
        var rest$10 = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest$10, fmt);};
       case 12:
        var rest$11 = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest$11, fmt);};
       case 13:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _u_], 1);
       default:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _v_], 1);
     }
    if(counter >= 50)
     return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
    var counter$0 = counter + 1 | 0;
    return make_invalid_arg(counter$0, k, acc, fmt);
   }
   function make_from_fmtty(k, acc, fmtty, fmt){
    return caml_trampoline(make_from_fmtty$0(0, k, acc, fmtty, fmt));
   }
   function make_invalid_arg(counter, k, acc, fmt){
    var _cb_ = [8, acc, cst_Printf_bad_conversion$0];
    if(counter >= 50)
     return caml_trampoline_return(make_printf$0, [0, k, _cb_, fmt]);
    var counter$0 = counter + 1 | 0;
    return make_printf$0(counter$0, k, _cb_, fmt);
   }
   function make_padding(k, acc, fmt, pad, trans){
    if(typeof pad === "number")
     return function(x){
      var new_acc = [4, acc, caml_call1(trans, x)];
      return make_printf(k, new_acc, fmt);};
    if(0 === pad[0]){
     var width = pad[2], padty = pad[1];
     return function(x){
      var new_acc = [4, acc, fix_padding(padty, width, caml_call1(trans, x))];
      return make_printf(k, new_acc, fmt);};
    }
    var padty$0 = pad[1];
    return function(w, x){
     var new_acc = [4, acc, fix_padding(padty$0, w, caml_call1(trans, x))];
     return make_printf(k, new_acc, fmt);};
   }
   function make_int_padding_precision(k, acc, fmt, pad, prec, trans, iconv){
    if(typeof pad === "number"){
     if(typeof prec === "number")
      return prec
              ? function
               (p, x){
                var str = fix_int_precision(p, caml_call2(trans, iconv, x));
                return make_printf(k, [4, acc, str], fmt);
               }
              : function
               (x){
                var str = caml_call2(trans, iconv, x);
                return make_printf(k, [4, acc, str], fmt);
               };
     var p = prec[1];
     return function(x){
      var str = fix_int_precision(p, caml_call2(trans, iconv, x));
      return make_printf(k, [4, acc, str], fmt);};
    }
    if(0 === pad[0]){
     var w = pad[2], padty = pad[1];
     if(typeof prec === "number")
      return prec
              ? function
               (p, x){
                var
                 str =
                   fix_padding
                    (padty,
                     w,
                     fix_int_precision(p, caml_call2(trans, iconv, x)));
                return make_printf(k, [4, acc, str], fmt);
               }
              : function
               (x){
                var str = fix_padding(padty, w, caml_call2(trans, iconv, x));
                return make_printf(k, [4, acc, str], fmt);
               };
     var p$0 = prec[1];
     return function(x){
      var
       str =
         fix_padding
          (padty, w, fix_int_precision(p$0, caml_call2(trans, iconv, x)));
      return make_printf(k, [4, acc, str], fmt);};
    }
    var padty$0 = pad[1];
    if(typeof prec === "number")
     return prec
             ? function
              (w, p, x){
               var
                str =
                  fix_padding
                   (padty$0,
                    w,
                    fix_int_precision(p, caml_call2(trans, iconv, x)));
               return make_printf(k, [4, acc, str], fmt);
              }
             : function
              (w, x){
               var str = fix_padding(padty$0, w, caml_call2(trans, iconv, x));
               return make_printf(k, [4, acc, str], fmt);
              };
    var p$1 = prec[1];
    return function(w, x){
     var
      str =
        fix_padding
         (padty$0, w, fix_int_precision(p$1, caml_call2(trans, iconv, x)));
     return make_printf(k, [4, acc, str], fmt);};
   }
   function make_custom$0(counter, k, acc, rest, arity, f){
    if(arity){
     var arity$0 = arity[1];
     return function(x){
      return make_custom(k, acc, rest, arity$0, caml_call1(f, x));};
    }
    var _ca_ = [4, acc, f];
    if(counter >= 50)
     return caml_trampoline_return(make_printf$0, [0, k, _ca_, rest]);
    var counter$0 = counter + 1 | 0;
    return make_printf$0(counter$0, k, _ca_, rest);
   }
   function make_custom(k, acc, rest, arity, f){
    return caml_trampoline(make_custom$0(0, k, acc, rest, arity, f));
   }
   function make_iprintf$0(counter, k, o, fmt){
    var k$0 = k, fmt$0 = fmt;
    for(;;){
     if(typeof fmt$0 === "number") return caml_call1(k$0, o);
     switch(fmt$0[0]){
       case 0:
        var rest = fmt$0[1], x = make_iprintf(k$0, o, rest);
        return function(_b$_){return x;};
       case 1:
        var rest$0 = fmt$0[1], x$0 = make_iprintf(k$0, o, rest$0);
        return function(_b__){return x$0;};
       case 2:
        var _bM_ = fmt$0[1];
        if(typeof _bM_ === "number"){
         var rest$1 = fmt$0[2], x$1 = make_iprintf(k$0, o, rest$1);
         return function(_b9_){return x$1;};
        }
        if(0 === _bM_[0]){
         var rest$2 = fmt$0[2], x$2 = make_iprintf(k$0, o, rest$2);
         return function(_b8_){return x$2;};
        }
        var
         rest$3 = fmt$0[2],
         x$3 = make_iprintf(k$0, o, rest$3),
         x$4 = function(_b7_){return x$3;};
        return function(_b6_){return x$4;};
       case 3:
        var _bN_ = fmt$0[1];
        if(typeof _bN_ === "number"){
         var rest$4 = fmt$0[2], x$5 = make_iprintf(k$0, o, rest$4);
         return function(_b5_){return x$5;};
        }
        if(0 === _bN_[0]){
         var rest$5 = fmt$0[2], x$6 = make_iprintf(k$0, o, rest$5);
         return function(_b4_){return x$6;};
        }
        var
         rest$6 = fmt$0[2],
         x$7 = make_iprintf(k$0, o, rest$6),
         x$8 = function(_b3_){return x$7;};
        return function(_b2_){return x$8;};
       case 4:
        var rest$7 = fmt$0[4], prec = fmt$0[3], pad = fmt$0[2];
        return fn_of_padding_precision(k$0, o, rest$7, pad, prec);
       case 5:
        var rest$8 = fmt$0[4], prec$0 = fmt$0[3], pad$0 = fmt$0[2];
        return fn_of_padding_precision(k$0, o, rest$8, pad$0, prec$0);
       case 6:
        var rest$9 = fmt$0[4], prec$1 = fmt$0[3], pad$1 = fmt$0[2];
        return fn_of_padding_precision(k$0, o, rest$9, pad$1, prec$1);
       case 7:
        var rest$10 = fmt$0[4], prec$2 = fmt$0[3], pad$2 = fmt$0[2];
        return fn_of_padding_precision(k$0, o, rest$10, pad$2, prec$2);
       case 8:
        var rest$11 = fmt$0[4], prec$3 = fmt$0[3], pad$3 = fmt$0[2];
        return fn_of_padding_precision(k$0, o, rest$11, pad$3, prec$3);
       case 9:
        var _bO_ = fmt$0[1];
        if(typeof _bO_ === "number"){
         var rest$12 = fmt$0[2], x$9 = make_iprintf(k$0, o, rest$12);
         return function(_b1_){return x$9;};
        }
        if(0 === _bO_[0]){
         var rest$13 = fmt$0[2], x$10 = make_iprintf(k$0, o, rest$13);
         return function(_b0_){return x$10;};
        }
        var
         rest$14 = fmt$0[2],
         x$11 = make_iprintf(k$0, o, rest$14),
         x$12 = function(_bZ_){return x$11;};
        return function(_bY_){return x$12;};
       case 10:
        var rest$15 = fmt$0[1]; fmt$0 = rest$15; break;
       case 11:
        var rest$16 = fmt$0[2]; fmt$0 = rest$16; break;
       case 12:
        var rest$17 = fmt$0[2]; fmt$0 = rest$17; break;
       case 13:
        var rest$18 = fmt$0[3], x$13 = make_iprintf(k$0, o, rest$18);
        return function(_bX_){return x$13;};
       case 14:
        var rest$19 = fmt$0[3], fmtty = fmt$0[2];
        return function(param){
         var fmt = param[1], _bW_ = recast(fmt, fmtty);
         return make_iprintf
                 (k$0,
                  o,
                  caml_call2(CamlinternalFormatBasics[3], _bW_, rest$19));};
       case 15:
        var
         rest$20 = fmt$0[1],
         x$14 = make_iprintf(k$0, o, rest$20),
         x$15 = function(_bV_){return x$14;};
        return function(_bU_){return x$15;};
       case 16:
        var rest$21 = fmt$0[1], x$16 = make_iprintf(k$0, o, rest$21);
        return function(_bT_){return x$16;};
       case 17:
        var rest$22 = fmt$0[2]; fmt$0 = rest$22; break;
       case 18:
        var _bP_ = fmt$0[1];
        if(0 === _bP_[0]){
         var rest$23 = fmt$0[2], fmt$1 = _bP_[1][1];
         let k = k$0, rest = rest$23;
         var k$1 = function(koc){return make_iprintf(k, koc, rest);};
         k$0 = k$1;
         fmt$0 = fmt$1;
        }
        else{
         var rest$24 = fmt$0[2], fmt$2 = _bP_[1][1];
         let k = k$0, rest = rest$24;
         var k$2 = function(koc){return make_iprintf(k, koc, rest);};
         k$0 = k$2;
         fmt$0 = fmt$2;
        }
        break;
       case 19:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _w_], 1);
       case 20:
        var rest$25 = fmt$0[3], x$17 = make_iprintf(k$0, o, rest$25);
        return function(_bS_){return x$17;};
       case 21:
        var rest$26 = fmt$0[2], x$18 = make_iprintf(k$0, o, rest$26);
        return function(_bR_){return x$18;};
       case 22:
        var rest$27 = fmt$0[1], x$19 = make_iprintf(k$0, o, rest$27);
        return function(_bQ_){return x$19;};
       case 23:
        var rest$28 = fmt$0[2], ign = fmt$0[1];
        return make_ignored_param
                (function(param){return caml_call1(k$0, o);}, 0, ign, rest$28);
       default:
        var rest$29 = fmt$0[3], arity = fmt$0[1];
        if(counter >= 50)
         return caml_trampoline_return
                 (fn_of_custom_arity$0, [0, k$0, o, rest$29, arity]);
        var counter$0 = counter + 1 | 0;
        return fn_of_custom_arity$0(counter$0, k$0, o, rest$29, arity);
     }
    }
   }
   function make_iprintf(k, o, fmt){
    return caml_trampoline(make_iprintf$0(0, k, o, fmt));
   }
   function fn_of_padding_precision(k, o, fmt, pad, prec){
    if(typeof pad === "number"){
     if(typeof prec !== "number"){
      var x$2 = make_iprintf(k, o, fmt);
      return function(_bL_){return x$2;};
     }
     if(prec){
      var x = make_iprintf(k, o, fmt), x$0 = function(_bK_){return x;};
      return function(_bJ_){return x$0;};
     }
     var x$1 = make_iprintf(k, o, fmt);
     return function(_bI_){return x$1;};
    }
    if(0 === pad[0]){
     if(typeof prec !== "number"){
      var x$6 = make_iprintf(k, o, fmt);
      return function(_bH_){return x$6;};
     }
     if(prec){
      var x$3 = make_iprintf(k, o, fmt), x$4 = function(_bG_){return x$3;};
      return function(_bF_){return x$4;};
     }
     var x$5 = make_iprintf(k, o, fmt);
     return function(_bE_){return x$5;};
    }
    if(typeof prec !== "number"){
     var x$12 = make_iprintf(k, o, fmt), x$13 = function(_bD_){return x$12;};
     return function(_bC_){return x$13;};
    }
    if(prec){
     var
      x$7 = make_iprintf(k, o, fmt),
      x$8 = function(_bB_){return x$7;},
      x$9 = function(_bA_){return x$8;};
     return function(_bz_){return x$9;};
    }
    var x$10 = make_iprintf(k, o, fmt);
    function x$11(_by_){return x$10;}
    return function(_bx_){return x$11;};
   }
   function fn_of_custom_arity$0(counter, k, o, fmt, param){
    if(param){
     var arity = param[1], x = fn_of_custom_arity(k, o, fmt, arity);
     return function(_bw_){return x;};
    }
    if(counter >= 50)
     return caml_trampoline_return(make_iprintf$0, [0, k, o, fmt]);
    var counter$0 = counter + 1 | 0;
    return make_iprintf$0(counter$0, k, o, fmt);
   }
   function fn_of_custom_arity(k, o, fmt, param){
    return caml_trampoline(fn_of_custom_arity$0(0, k, o, fmt, param));
   }
   function output_acc(o, acc){
    var acc$0 = acc;
    for(;;){
     if(typeof acc$0 === "number") return 0;
     switch(acc$0[0]){
       case 0:
        var
         fmting_lit = acc$0[2],
         p = acc$0[1],
         s = string_of_formatting_lit(fmting_lit);
        output_acc(o, p);
        return caml_call2(Stdlib[66], o, s);
       case 1:
        var match = acc$0[2], p$0 = acc$0[1];
        if(0 === match[0]){
         var acc$1 = match[1];
         output_acc(o, p$0);
         caml_call2(Stdlib[66], o, cst$18);
         acc$0 = acc$1;
        }
        else{
         var acc$2 = match[1];
         output_acc(o, p$0);
         caml_call2(Stdlib[66], o, cst$19);
         acc$0 = acc$2;
        }
        break;
       case 6:
        var f = acc$0[2], p$3 = acc$0[1];
        output_acc(o, p$3);
        return caml_call1(f, o);
       case 7:
        var p$4 = acc$0[1];
        output_acc(o, p$4);
        return caml_call1(Stdlib[63], o);
       case 8:
        var msg = acc$0[2], p$5 = acc$0[1];
        output_acc(o, p$5);
        return caml_call1(Stdlib[1], msg);
       case 2:
       case 4:
        var s$0 = acc$0[2], p$1 = acc$0[1];
        output_acc(o, p$1);
        return caml_call2(Stdlib[66], o, s$0);
       default:
        var c = acc$0[2], p$2 = acc$0[1];
        output_acc(o, p$2);
        return caml_call2(Stdlib[65], o, c);
     }
    }
   }
   function bufput_acc(b, acc){
    var acc$0 = acc;
    for(;;){
     if(typeof acc$0 === "number") return 0;
     switch(acc$0[0]){
       case 0:
        var
         fmting_lit = acc$0[2],
         p = acc$0[1],
         s = string_of_formatting_lit(fmting_lit);
        bufput_acc(b, p);
        return caml_call2(Stdlib_Buffer[16], b, s);
       case 1:
        var match = acc$0[2], p$0 = acc$0[1];
        if(0 === match[0]){
         var acc$1 = match[1];
         bufput_acc(b, p$0);
         caml_call2(Stdlib_Buffer[16], b, cst$20);
         acc$0 = acc$1;
        }
        else{
         var acc$2 = match[1];
         bufput_acc(b, p$0);
         caml_call2(Stdlib_Buffer[16], b, cst$21);
         acc$0 = acc$2;
        }
        break;
       case 6:
        var f = acc$0[2], p$3 = acc$0[1];
        bufput_acc(b, p$3);
        return caml_call1(f, b);
       case 7:
        var acc$3 = acc$0[1]; acc$0 = acc$3; break;
       case 8:
        var msg = acc$0[2], p$4 = acc$0[1];
        bufput_acc(b, p$4);
        return caml_call1(Stdlib[1], msg);
       case 2:
       case 4:
        var s$0 = acc$0[2], p$1 = acc$0[1];
        bufput_acc(b, p$1);
        return caml_call2(Stdlib_Buffer[16], b, s$0);
       default:
        var c = acc$0[2], p$2 = acc$0[1];
        bufput_acc(b, p$2);
        return caml_call2(Stdlib_Buffer[12], b, c);
     }
    }
   }
   function strput_acc(b, acc){
    var acc$0 = acc;
    for(;;){
     if(typeof acc$0 === "number") return 0;
     switch(acc$0[0]){
       case 0:
        var
         fmting_lit = acc$0[2],
         p = acc$0[1],
         s = string_of_formatting_lit(fmting_lit);
        strput_acc(b, p);
        return caml_call2(Stdlib_Buffer[16], b, s);
       case 1:
        var match = acc$0[2], p$0 = acc$0[1];
        if(0 === match[0]){
         var acc$1 = match[1];
         strput_acc(b, p$0);
         caml_call2(Stdlib_Buffer[16], b, cst$22);
         acc$0 = acc$1;
        }
        else{
         var acc$2 = match[1];
         strput_acc(b, p$0);
         caml_call2(Stdlib_Buffer[16], b, cst$23);
         acc$0 = acc$2;
        }
        break;
       case 6:
        var f = acc$0[2], p$3 = acc$0[1];
        strput_acc(b, p$3);
        var _bv_ = caml_call1(f, 0);
        return caml_call2(Stdlib_Buffer[16], b, _bv_);
       case 7:
        var acc$3 = acc$0[1]; acc$0 = acc$3; break;
       case 8:
        var msg = acc$0[2], p$4 = acc$0[1];
        strput_acc(b, p$4);
        return caml_call1(Stdlib[1], msg);
       case 2:
       case 4:
        var s$0 = acc$0[2], p$1 = acc$0[1];
        strput_acc(b, p$1);
        return caml_call2(Stdlib_Buffer[16], b, s$0);
       default:
        var c = acc$0[2], p$2 = acc$0[1];
        strput_acc(b, p$2);
        return caml_call2(Stdlib_Buffer[12], b, c);
     }
    }
   }
   function failwith_message(param){
    var fmt = param[1], buf = caml_call1(Stdlib_Buffer[1], 256);
    function k(acc){
     strput_acc(buf, acc);
     var _bu_ = caml_call1(Stdlib_Buffer[2], buf);
     return caml_call1(Stdlib[2], _bu_);
    }
    return make_printf(k, 0, fmt);
   }
   function open_box_of_string(str){
    if(str == cst$43) return _x_;
    var len = caml_ml_string_length(str);
    function invalid_box(param){
     return caml_call1(failwith_message(_y_), str);
    }
    function parse_spaces(i){
     var i$0 = i;
     for(;;){
      if(i$0 === len) return i$0;
      var match = caml_string_get(str, i$0);
      if(9 !== match && 32 !== match) return i$0;
      var i$1 = i$0 + 1 | 0;
      i$0 = i$1;
     }
    }
    var wstart = parse_spaces(0);
    a:
    b:
    {
     var wend = wstart;
     for(;;){
      if(wend === len) break b;
      if(25 < caml_string_get(str, wend) - 97 >>> 0) break;
      var j = wend + 1 | 0;
      wend = j;
     }
     break a;
    }
    var
     box_name = caml_call3(Stdlib_String[15], str, wstart, wend - wstart | 0),
     nstart = parse_spaces(wend);
    a:
    b:
    {
     var nend = nstart;
     for(;;){
      if(nend === len) break b;
      var match = caml_string_get(str, nend);
      if(48 <= match){if(58 <= match) break;} else if(45 !== match) break;
      var j$0 = nend + 1 | 0;
      nend = j$0;
     }
     break a;
    }
    if(nstart === nend)
     var indent = 0;
    else
     try{
      var
       _bs_ =
         runtime.caml_int_of_string
          (caml_call3(Stdlib_String[15], str, nstart, nend - nstart | 0)),
       indent = _bs_;
     }
     catch(_bt_){
      var _br_ = caml_wrap_exception(_bt_);
      if(_br_[1] !== Stdlib[7]) throw caml_maybe_attach_backtrace(_br_, 0);
      var indent = invalid_box(0);
     }
    var exp_end = parse_spaces(nend);
    if(exp_end !== len) invalid_box(0);
    a:
    {
     if(box_name !== cst$43 && box_name !== "b"){
      if(box_name === "h"){var box_type = 0; break a;}
      if(box_name === "hov"){var box_type = 3; break a;}
      if(box_name === "hv"){var box_type = 2; break a;}
      if(box_name !== "v"){var box_type = invalid_box(0); break a;}
      var box_type = 1;
      break a;
     }
     var box_type = 4;
    }
    return [0, indent, box_type];
   }
   function make_padding_fmt_ebb(pad, fmt){
    if(typeof pad === "number") return [0, 0, fmt];
    if(0 === pad[0]){var w = pad[2], s = pad[1]; return [0, [0, s, w], fmt];}
    var s$0 = pad[1];
    return [0, [1, s$0], fmt];
   }
   function make_padprec_fmt_ebb(pad, prec, fmt){
    if(typeof prec === "number")
     var match = prec ? [0, 1] : [0, 0];
    else
     var p = prec[1], match = [0, [0, p]];
    var prec$0 = match[1];
    if(typeof pad === "number") return [0, 0, prec$0, fmt];
    if(0 === pad[0]){
     var w = pad[2], s = pad[1];
     return [0, [0, s, w], prec$0, fmt];
    }
    var s$0 = pad[1];
    return [0, [1, s$0], prec$0, fmt];
   }
   function fmt_ebb_of_string(legacy_behavior, str){
    if(legacy_behavior)
     var flag = legacy_behavior[1], legacy_behavior$0 = flag;
    else
     var legacy_behavior$0 = 1;
    function invalid_format_message(str_ind, msg){
     return caml_call3(failwith_message(_z_), str, str_ind, msg);
    }
    function invalid_format_without(str_ind, c, s){
     return caml_call4(failwith_message(_A_), str, str_ind, c, s);
    }
    function expected_character(str_ind, expected, read){
     return caml_call4(failwith_message(_B_), str, str_ind, expected, read);
    }
    function parse(lit_start, end_ind){
     a:
     {
      var str_ind = lit_start;
      for(;;){
       if(str_ind === end_ind) return add_literal(lit_start, str_ind, 0);
       var match = caml_string_get(str, str_ind);
       if(37 === match) break;
       if(64 === match) break a;
       var str_ind$1 = str_ind + 1 | 0;
       str_ind = str_ind$1;
      }
      var str_ind$2 = str_ind + 1 | 0;
      if(str_ind$2 === end_ind)
       invalid_format_message(end_ind, cst_unexpected_end_of_format);
      var
       match$1 =
         95 === caml_string_get(str, str_ind$2)
          ? parse_flags(str_ind, str_ind$2 + 1 | 0, end_ind, 1)
          : parse_flags(str_ind, str_ind$2, end_ind, 0),
       fmt_rest = match$1[1];
      return add_literal(lit_start, str_ind, fmt_rest);
     }
     var str_ind$0 = str_ind + 1 | 0;
     a:
     if(str_ind$0 === end_ind)
      var match$0 = _N_;
     else{
      var c = caml_string_get(str, str_ind$0);
      if(65 <= c){
       if(94 <= c){
        var switcher = c - 123 | 0;
        if(2 >= switcher >>> 0)
         switch(switcher){
           case 0:
            var match$0 = parse_tag(1, str_ind$0 + 1 | 0, end_ind); break a;
           case 1: break;
           default:
            var
             fmt_rest$2 = parse(str_ind$0 + 1 | 0, end_ind)[1],
             match$0 = [0, [17, 1, fmt_rest$2]];
            break a;
         }
       }
       else if(91 <= c)
        switch(c - 91 | 0){
          case 0:
           var match$0 = parse_tag(0, str_ind$0 + 1 | 0, end_ind); break a;
          case 1: break;
          default:
           var
            fmt_rest$3 = parse(str_ind$0 + 1 | 0, end_ind)[1],
            match$0 = [0, [17, 0, fmt_rest$3]];
           break a;
        }
      }
      else{
       if(10 === c){
        var
         fmt_rest$4 = parse(str_ind$0 + 1 | 0, end_ind)[1],
         match$0 = [0, [17, 3, fmt_rest$4]];
        break a;
       }
       if(32 <= c)
        switch(c - 32 | 0){
          case 0:
           var
            fmt_rest$5 = parse(str_ind$0 + 1 | 0, end_ind)[1],
            match$0 = [0, [17, _O_, fmt_rest$5]];
           break a;
          case 5:
           if
            ((str_ind$0 + 1 | 0) < end_ind
             && 37 === caml_string_get(str, str_ind$0 + 1 | 0)){
            var
             fmt_rest$6 = parse(str_ind$0 + 2 | 0, end_ind)[1],
             match$0 = [0, [17, 6, fmt_rest$6]];
            break a;
           }
           var
            fmt_rest$7 = parse(str_ind$0, end_ind)[1],
            match$0 = [0, [12, 64, fmt_rest$7]];
           break a;
          case 12:
           var
            fmt_rest$8 = parse(str_ind$0 + 1 | 0, end_ind)[1],
            match$0 = [0, [17, _P_, fmt_rest$8]];
           break a;
          case 14:
           var
            fmt_rest$9 = parse(str_ind$0 + 1 | 0, end_ind)[1],
            match$0 = [0, [17, 4, fmt_rest$9]];
           break a;
          case 27:
           var str_ind$3 = str_ind$0 + 1 | 0;
           b:
           try{
            var
             _bg_ = str_ind$3 === end_ind ? 1 : 0,
             _bh_ = _bg_ || (60 !== caml_string_get(str, str_ind$3) ? 1 : 0);
            if(_bh_) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
            var
             str_ind_1 = parse_spaces(str_ind$3 + 1 | 0, end_ind),
             match$2 = caml_string_get(str, str_ind_1);
            c:
            {
             if(48 <= match$2){
              if(58 > match$2) break c;
             }
             else if(45 === match$2) break c;
             throw caml_maybe_attach_backtrace(Stdlib[8], 1);
            }
            var
             match$3 = parse_integer(str_ind_1, end_ind),
             width = match$3[2],
             str_ind_2 = match$3[1],
             str_ind_3 = parse_spaces(str_ind_2, end_ind),
             switcher$0 = caml_string_get(str, str_ind_3) - 45 | 0;
            if(12 < switcher$0 >>> 0){
             if(17 === switcher$0){
              var
               s =
                 caml_call3
                  (Stdlib_String[15],
                   str,
                   str_ind$3 - 2 | 0,
                   (str_ind_3 - str_ind$3 | 0) + 3 | 0),
               _bi_ = [0, s, width, 0],
               _bj_ = str_ind_3 + 1 | 0,
               formatting_lit$0 = _bi_,
               next_ind = _bj_;
              break b;
             }
            }
            else if(1 < switcher$0 - 1 >>> 0){
             var
              match$4 = parse_integer(str_ind_3, end_ind),
              offset = match$4[2],
              str_ind_4 = match$4[1],
              str_ind_5 = parse_spaces(str_ind_4, end_ind);
             if(62 !== caml_string_get(str, str_ind_5))
              throw caml_maybe_attach_backtrace(Stdlib[8], 1);
             var
              s$0 =
                caml_call3
                 (Stdlib_String[15],
                  str,
                  str_ind$3 - 2 | 0,
                  (str_ind_5 - str_ind$3 | 0) + 3 | 0),
              _bk_ = [0, s$0, width, offset],
              _bl_ = str_ind_5 + 1 | 0,
              formatting_lit$0 = _bk_,
              next_ind = _bl_;
             break b;
            }
            throw caml_maybe_attach_backtrace(Stdlib[8], 1);
           }
           catch(_bq_){
            var _bf_ = caml_wrap_exception(_bq_);
            if(_bf_ !== Stdlib[8] && _bf_[1] !== Stdlib[7])
             throw caml_maybe_attach_backtrace(_bf_, 0);
            var formatting_lit$0 = formatting_lit, next_ind = str_ind$3;
           }
           var
            fmt_rest$12 = parse(next_ind, end_ind)[1],
            match$0 = [0, [17, formatting_lit$0, fmt_rest$12]];
           break a;
          case 28:
           var str_ind$4 = str_ind$0 + 1 | 0;
           try{
            var
             str_ind_1$0 = parse_spaces(str_ind$4, end_ind),
             match$6 = caml_string_get(str, str_ind_1$0);
            b:
            {
             c:
             {
              if(48 <= match$6){
               if(58 > match$6) break c;
              }
              else if(45 === match$6) break c;
              var _bo_ = 0;
              break b;
             }
             var
              match$7 = parse_integer(str_ind_1$0, end_ind),
              size = match$7[2],
              str_ind_2$0 = match$7[1],
              str_ind_3$0 = parse_spaces(str_ind_2$0, end_ind);
             if(62 !== caml_string_get(str, str_ind_3$0))
              throw caml_maybe_attach_backtrace(Stdlib[8], 1);
             var
              s$1 =
                caml_call3
                 (Stdlib_String[15],
                  str,
                  str_ind$4 - 2 | 0,
                  (str_ind_3$0 - str_ind$4 | 0) + 3 | 0),
              _bo_ = [0, [0, str_ind_3$0 + 1 | 0, [1, s$1, size]]];
            }
            var _bn_ = _bo_;
           }
           catch(_bp_){
            var _bm_ = caml_wrap_exception(_bp_);
            if(_bm_ !== Stdlib[8] && _bm_[1] !== Stdlib[7])
             throw caml_maybe_attach_backtrace(_bm_, 0);
            var _bn_ = 0;
           }
           if(_bn_)
            var
             match$5 = _bn_[1],
             formatting_lit$1 = match$5[2],
             next_ind$0 = match$5[1],
             fmt_rest$13 = parse(next_ind$0, end_ind)[1],
             _be_ = [0, [17, formatting_lit$1, fmt_rest$13]];
           else
            var
             fmt_rest$14 = parse(str_ind$4, end_ind)[1],
             _be_ = [0, [17, _Q_, fmt_rest$14]];
           var match$0 = _be_;
           break a;
          case 31:
           var
            fmt_rest$10 = parse(str_ind$0 + 1 | 0, end_ind)[1],
            match$0 = [0, [17, 2, fmt_rest$10]];
           break a;
          case 32:
           var
            fmt_rest$11 = parse(str_ind$0 + 1 | 0, end_ind)[1],
            match$0 = [0, [17, 5, fmt_rest$11]];
           break a;
        }
      }
      var
       fmt_rest$1 = parse(str_ind$0 + 1 | 0, end_ind)[1],
       match$0 = [0, [17, [2, c], fmt_rest$1]];
     }
     var fmt_rest$0 = match$0[1];
     return add_literal(lit_start, str_ind, fmt_rest$0);
    }
    function parse_flags(pct_ind, str_ind, end_ind, ign){
     var
      zero = [0, 0],
      minus = [0, 0],
      plus = [0, 0],
      space = [0, 0],
      hash = [0, 0];
     function set_flag(str_ind, flag){
      var _bb_ = flag[1], _bc_ = _bb_ ? 1 - legacy_behavior$0 : _bb_;
      if(_bc_){
       var _bd_ = caml_string_get(str, str_ind);
       caml_call3(failwith_message(_C_), str, str_ind, _bd_);
      }
      flag[1] = 1;
      return;
     }
     a:
     b:
     {
      var str_ind$0 = str_ind;
      c:
      for(;;){
       if(str_ind$0 === end_ind)
        invalid_format_message(end_ind, cst_unexpected_end_of_format);
       var switcher = caml_string_get(str, str_ind$0) - 32 | 0;
       if(16 < switcher >>> 0) break b;
       switch(switcher){
         case 0:
          set_flag(str_ind$0, space);
          var str_ind$1 = str_ind$0 + 1 | 0;
          str_ind$0 = str_ind$1;
          break;
         case 3:
          set_flag(str_ind$0, hash);
          var str_ind$2 = str_ind$0 + 1 | 0;
          str_ind$0 = str_ind$2;
          break;
         case 11:
          set_flag(str_ind$0, plus);
          var str_ind$3 = str_ind$0 + 1 | 0;
          str_ind$0 = str_ind$3;
          break;
         case 13:
          set_flag(str_ind$0, minus);
          var str_ind$4 = str_ind$0 + 1 | 0;
          str_ind$0 = str_ind$4;
          break;
         case 16:
          set_flag(str_ind$0, zero);
          var str_ind$5 = str_ind$0 + 1 | 0;
          str_ind$0 = str_ind$5;
          break;
         default: break c;
       }
      }
      break a;
     }
     var
      space$0 = space[1],
      hash$0 = hash[1],
      plus$0 = plus[1],
      minus$0 = minus[1],
      zero$0 = zero[1];
     if(str_ind$0 === end_ind)
      invalid_format_message(end_ind, cst_unexpected_end_of_format);
     var
      padty =
        zero$0
         ? minus$0
           ? legacy_behavior$0
             ? 0
             : incompatible_flag(pct_ind, str_ind$0, 45, cst_0)
           : 2
         : minus$0 ? 0 : 1,
      match = caml_string_get(str, str_ind$0);
     if(48 <= match){
      if(58 > match){
       var
        match$0 = parse_positive(str_ind$0, end_ind, 0),
        width = match$0[2],
        new_ind = match$0[1];
       return parse_after_padding
               (pct_ind,
                new_ind,
                end_ind,
                minus$0,
                plus$0,
                hash$0,
                space$0,
                ign,
                [0, padty, width]);
      }
     }
     else if(42 === match)
      return parse_after_padding
              (pct_ind,
               str_ind$0 + 1 | 0,
               end_ind,
               minus$0,
               plus$0,
               hash$0,
               space$0,
               ign,
               [1, padty]);
     switch(padty){
       case 0:
        if(1 - legacy_behavior$0)
         invalid_format_without(str_ind$0 - 1 | 0, 45, cst_padding);
        return parse_after_padding
                (pct_ind,
                 str_ind$0,
                 end_ind,
                 minus$0,
                 plus$0,
                 hash$0,
                 space$0,
                 ign,
                 0);
       case 1:
        return parse_after_padding
                (pct_ind,
                 str_ind$0,
                 end_ind,
                 minus$0,
                 plus$0,
                 hash$0,
                 space$0,
                 ign,
                 0);
       default:
        return parse_after_padding
                (pct_ind,
                 str_ind$0,
                 end_ind,
                 minus$0,
                 plus$0,
                 hash$0,
                 space$0,
                 ign,
                 _D_);
     }
    }
    function parse_after_padding
    (pct_ind, str_ind, end_ind, minus, plus, hash, space, ign, pad){
     if(str_ind === end_ind)
      invalid_format_message(end_ind, cst_unexpected_end_of_format);
     var symb = caml_string_get(str, str_ind);
     if(46 !== symb)
      return parse_conversion
              (pct_ind,
               str_ind + 1 | 0,
               end_ind,
               plus,
               hash,
               space,
               ign,
               pad,
               0,
               pad,
               symb);
     var str_ind$0 = str_ind + 1 | 0;
     if(str_ind$0 === end_ind)
      invalid_format_message(end_ind, cst_unexpected_end_of_format);
     function parse_literal(minus, str_ind){
      var
       match = parse_positive(str_ind, end_ind, 0),
       prec = match[2],
       new_ind = match[1];
      return parse_after_precision
              (pct_ind,
               new_ind,
               end_ind,
               minus,
               plus,
               hash,
               space,
               ign,
               pad,
               [0, prec]);
     }
     var symb$0 = caml_string_get(str, str_ind$0);
     if(48 <= symb$0){
      if(58 > symb$0) return parse_literal(minus, str_ind$0);
     }
     else if(42 <= symb$0)
      switch(symb$0 - 42 | 0){
        case 0:
         return parse_after_precision
                 (pct_ind,
                  str_ind$0 + 1 | 0,
                  end_ind,
                  minus,
                  plus,
                  hash,
                  space,
                  ign,
                  pad,
                  1);
        case 1:
        case 3:
         if(legacy_behavior$0){
          var
           _ba_ = str_ind$0 + 1 | 0,
           minus$0 = minus || (45 === symb$0 ? 1 : 0);
          return parse_literal(minus$0, _ba_);
         }
         break;
      }
     return legacy_behavior$0
             ? parse_after_precision
               (pct_ind,
                str_ind$0,
                end_ind,
                minus,
                plus,
                hash,
                space,
                ign,
                pad,
                _E_)
             : invalid_format_without(str_ind$0 - 1 | 0, 46, cst_precision);
    }
    function parse_after_precision
    (pct_ind, str_ind, end_ind, minus, plus, hash, space, ign, pad, prec){
     if(str_ind === end_ind)
      invalid_format_message(end_ind, cst_unexpected_end_of_format);
     function parse_conv(padprec){
      return parse_conversion
              (pct_ind,
               str_ind + 1 | 0,
               end_ind,
               plus,
               hash,
               space,
               ign,
               pad,
               prec,
               padprec,
               caml_string_get(str, str_ind));
     }
     if(typeof pad !== "number") return parse_conv(pad);
     if(typeof prec === "number" && ! prec) return parse_conv(0);
     if(minus){
      if(typeof prec === "number") return parse_conv(_F_);
      var n = prec[1];
      return parse_conv([0, 0, n]);
     }
     if(typeof prec === "number") return parse_conv(_G_);
     var n$0 = prec[1];
     return parse_conv([0, 1, n$0]);
    }
    function parse_conversion
    (pct_ind,
     str_ind,
     end_ind,
     plus,
     hash,
     space,
     ign,
     pad,
     prec,
     padprec,
     symb){
     var
      plus_used = [0, 0],
      hash_used = [0, 0],
      space_used = [0, 0],
      ign_used = [0, 0],
      pad_used = [0, 0],
      prec_used = [0, 0];
     function get_plus(param){plus_used[1] = 1; return plus;}
     function get_hash(param){hash_used[1] = 1; return hash;}
     function get_space(param){space_used[1] = 1; return space;}
     function get_ign(param){ign_used[1] = 1; return ign;}
     function get_pad(param){pad_used[1] = 1; return pad;}
     function get_prec(param){prec_used[1] = 1; return prec;}
     function get_padprec(param){pad_used[1] = 1; return padprec;}
     function get_int_pad(param){
      var pad = get_pad(0), match = get_prec(0);
      if(typeof match === "number" && ! match) return pad;
      if(typeof pad === "number") return 0;
      if(0 !== pad[0])
       return 2 <= pad[1]
               ? legacy_behavior$0
                 ? _H_
                 : incompatible_flag(pct_ind, str_ind, 48, cst_precision$1)
               : pad;
      if(2 > pad[1]) return pad;
      var n = pad[2];
      return legacy_behavior$0
              ? [0, 1, n]
              : incompatible_flag(pct_ind, str_ind, 48, cst_precision$0);
     }
     function check_no_0(symb, pad){
      if(typeof pad === "number") return pad;
      if(0 !== pad[0])
       return 2 <= pad[1]
               ? legacy_behavior$0
                 ? _I_
                 : incompatible_flag(pct_ind, str_ind, symb, cst_0$1)
               : pad;
      if(2 > pad[1]) return pad;
      var width = pad[2];
      return legacy_behavior$0
              ? [0, 1, width]
              : incompatible_flag(pct_ind, str_ind, symb, cst_0$0);
     }
     function opt_of_pad(c, pad){
      if(typeof pad === "number") return 0;
      if(0 === pad[0])
       switch(pad[1]){
         case 0:
          var width = pad[2];
          return legacy_behavior$0
                  ? [0, width]
                  : incompatible_flag(pct_ind, str_ind, c, cst$24);
         case 1:
          var width$0 = pad[2]; return [0, width$0];
         default:
          var width$1 = pad[2];
          return legacy_behavior$0
                  ? [0, width$1]
                  : incompatible_flag(pct_ind, str_ind, c, cst_0$2);
       }
      return incompatible_flag(pct_ind, str_ind, c, cst$25);
     }
     function get_pad_opt(c){return opt_of_pad(c, get_pad(0));}
     function get_padprec_opt(c){return opt_of_pad(c, get_padprec(0));}
     a:
     {
      if(124 > symb)
       switch(symb){
         case 33:
          var
           fmt_rest$5 = parse(str_ind, end_ind)[1],
           fmt_result = [0, [10, fmt_rest$5]];
          break a;
         case 40:
          var
           sub_end = search_subformat_end(str_ind, end_ind, 41),
           fmt_rest$7 = parse(sub_end + 2 | 0, end_ind)[1],
           sub_fmt = parse(str_ind, sub_end)[1],
           sub_fmtty = fmtty_of_fmt(sub_fmt);
          if(get_ign(0))
           var
            ignored$2 = [9, get_pad_opt(95), sub_fmtty],
            _aJ_ = [0, [23, ignored$2, fmt_rest$7]];
          else
           var _aJ_ = [0, [14, get_pad_opt(40), sub_fmtty, fmt_rest$7]];
          var fmt_result = _aJ_;
          break a;
         case 44:
          var fmt_result = parse(str_ind, end_ind); break a;
         case 67:
          var
           fmt_rest$10 = parse(str_ind, end_ind)[1],
           _aL_ =
             get_ign(0) ? [0, [23, 1, fmt_rest$10]] : [0, [1, fmt_rest$10]],
           fmt_result = _aL_;
          break a;
         case 78:
          var fmt_rest$14 = parse(str_ind, end_ind)[1], counter$0 = 2;
          if(get_ign(0))
           var
            ignored$6 = [11, counter$0],
            _aR_ = [0, [23, ignored$6, fmt_rest$14]];
          else
           var _aR_ = [0, [21, counter$0, fmt_rest$14]];
          var fmt_result = _aR_;
          break a;
         case 83:
          var
           pad$6 = check_no_0(symb, get_padprec(0)),
           fmt_rest$15 = parse(str_ind, end_ind)[1];
          if(get_ign(0))
           var
            ignored$7 = [1, get_padprec_opt(95)],
            _aS_ = [0, [23, ignored$7, fmt_rest$15]];
          else
           var
            match$5 = make_padding_fmt_ebb(pad$6, fmt_rest$15),
            fmt_rest$16 = match$5[2],
            pad$7 = match$5[1],
            _aS_ = [0, [3, pad$7, fmt_rest$16]];
          var fmt_result = _aS_;
          break a;
         case 91:
          if(str_ind === end_ind)
           invalid_format_message(end_ind, cst_unexpected_end_of_format);
          var
           char_set = create_char_set(0),
           add_range =
             function(c$0, c){
              if(c >= c$0){
               var i = c$0;
               for(;;){
                add_in_char_set(char_set, caml_call1(Stdlib[29], i));
                var _a$_ = i + 1 | 0;
                if(c === i) break;
                i = _a$_;
               }
              }
              return;
             },
           fail_single_percent =
             function(str_ind){
              return caml_call2(failwith_message(_R_), str, str_ind);
             },
           parse_char_set_content =
             function(counter, str_ind, end_ind){
              var str_ind$0 = str_ind;
              for(;;){
               if(str_ind$0 === end_ind)
                invalid_format_message(end_ind, cst_unexpected_end_of_format);
               var c = caml_string_get(str, str_ind$0);
               if(45 !== c){
                if(93 === c) return str_ind$0 + 1 | 0;
                var _a__ = str_ind$0 + 1 | 0;
                if(counter >= 50)
                 return caml_trampoline_return
                         (parse_char_set_after_char$0, [0, _a__, end_ind, c]);
                var counter$0 = counter + 1 | 0;
                return parse_char_set_after_char$0
                        (counter$0, _a__, end_ind, c);
               }
               add_in_char_set(char_set, 45);
               var str_ind$1 = str_ind$0 + 1 | 0;
               str_ind$0 = str_ind$1;
              }
             },
           parse_char_set_after_char$0 =
             function(counter, str_ind, end_ind, c){
              var str_ind$0 = str_ind, c$0 = c;
              for(;;){
               if(str_ind$0 === end_ind)
                invalid_format_message(end_ind, cst_unexpected_end_of_format);
               var c$1 = caml_string_get(str, str_ind$0);
               a:
               {
                if(46 <= c$1){
                 if(64 !== c$1){
                  if(93 !== c$1) break a;
                  add_in_char_set(char_set, c$0);
                  return str_ind$0 + 1 | 0;
                 }
                }
                else if(37 !== c$1){
                 if(45 > c$1) break a;
                 var str_ind$2 = str_ind$0 + 1 | 0;
                 if(str_ind$2 === end_ind)
                  invalid_format_message
                   (end_ind, cst_unexpected_end_of_format);
                 var c$2 = caml_string_get(str, str_ind$2);
                 if(37 === c$2){
                  if((str_ind$2 + 1 | 0) === end_ind)
                   invalid_format_message
                    (end_ind, cst_unexpected_end_of_format);
                  var c$3 = caml_string_get(str, str_ind$2 + 1 | 0);
                  if(37 !== c$3 && 64 !== c$3)
                   return fail_single_percent(str_ind$2);
                  add_range(c$0, c$3);
                  var _a8_ = str_ind$2 + 2 | 0;
                  if(counter >= 50)
                   return caml_trampoline_return
                           (parse_char_set_content, [0, _a8_, end_ind]);
                  var counter$1 = counter + 1 | 0;
                  return parse_char_set_content(counter$1, _a8_, end_ind);
                 }
                 if(93 === c$2){
                  add_in_char_set(char_set, c$0);
                  add_in_char_set(char_set, 45);
                  return str_ind$2 + 1 | 0;
                 }
                 add_range(c$0, c$2);
                 var _a9_ = str_ind$2 + 1 | 0;
                 if(counter >= 50)
                  return caml_trampoline_return
                          (parse_char_set_content, [0, _a9_, end_ind]);
                 var counter$0 = counter + 1 | 0;
                 return parse_char_set_content(counter$0, _a9_, end_ind);
                }
                if(37 === c$0){
                 add_in_char_set(char_set, c$1);
                 var _a7_ = str_ind$0 + 1 | 0;
                 if(counter >= 50)
                  return caml_trampoline_return
                          (parse_char_set_content, [0, _a7_, end_ind]);
                 var counter$2 = counter + 1 | 0;
                 return parse_char_set_content(counter$2, _a7_, end_ind);
                }
               }
               if(37 === c$0) fail_single_percent(str_ind$0);
               add_in_char_set(char_set, c$0);
               var str_ind$1 = str_ind$0 + 1 | 0;
               str_ind$0 = str_ind$1;
               c$0 = c$1;
              }
             },
           parse_char_set_after_char =
             function(str_ind, end_ind, c){
              return caml_trampoline
                      (parse_char_set_after_char$0(0, str_ind, end_ind, c));
             };
          if(str_ind === end_ind)
           invalid_format_message(end_ind, cst_unexpected_end_of_format);
          if(94 === caml_string_get(str, str_ind))
           var
            str_ind$0 = str_ind + 1 | 0,
            reverse = 1,
            str_ind$1 = str_ind$0;
          else
           var reverse = 0, str_ind$1 = str_ind;
          if(str_ind$1 === end_ind)
           invalid_format_message(end_ind, cst_unexpected_end_of_format);
          var
           c = caml_string_get(str, str_ind$1),
           next_ind = parse_char_set_after_char(str_ind$1 + 1 | 0, end_ind, c),
           char_set$0 = freeze_char_set(char_set),
           char_set$1 = reverse ? rev_char_set(char_set$0) : char_set$0,
           fmt_rest$19 = parse(next_ind, end_ind)[1];
          if(get_ign(0))
           var
            ignored$9 = [10, get_pad_opt(95), char_set$1],
            _aX_ = [0, [23, ignored$9, fmt_rest$19]];
          else
           var _aX_ = [0, [20, get_pad_opt(91), char_set$1, fmt_rest$19]];
          var fmt_result = _aX_;
          break a;
         case 97:
          var
           fmt_rest$20 = parse(str_ind, end_ind)[1],
           fmt_result = [0, [15, fmt_rest$20]];
          break a;
         case 99:
          var
           char_format =
             function(fmt_rest){
              return get_ign(0) ? [0, [23, 0, fmt_rest]] : [0, [0, fmt_rest]];
             },
           fmt_rest$21 = parse(str_ind, end_ind)[1],
           match$7 = get_pad_opt(99);
          if(match$7){
           if(0 === match$7[1])
            var
             _aY_ =
               get_ign(0) ? [0, [23, 3, fmt_rest$21]] : [0, [22, fmt_rest$21]],
             _aZ_ = _aY_;
           else
            var
             _aZ_ =
               legacy_behavior$0
                ? char_format(fmt_rest$21)
                : invalid_format_message
                  (str_ind, cst_non_zero_widths_are_unsupp);
           var _a0_ = _aZ_;
          }
          else
           var _a0_ = char_format(fmt_rest$21);
          var fmt_result = _a0_;
          break a;
         case 114:
          var
           fmt_rest$22 = parse(str_ind, end_ind)[1],
           _a1_ =
             get_ign(0) ? [0, [23, 2, fmt_rest$22]] : [0, [19, fmt_rest$22]],
           fmt_result = _a1_;
          break a;
         case 115:
          var
           pad$9 = check_no_0(symb, get_padprec(0)),
           fmt_rest$23 = parse(str_ind, end_ind)[1];
          if(get_ign(0))
           var
            ignored$10 = [0, get_padprec_opt(95)],
            _a2_ = [0, [23, ignored$10, fmt_rest$23]];
          else
           var
            match$8 = make_padding_fmt_ebb(pad$9, fmt_rest$23),
            fmt_rest$24 = match$8[2],
            pad$10 = match$8[1],
            _a2_ = [0, [2, pad$10, fmt_rest$24]];
          var fmt_result = _a2_;
          break a;
         case 116:
          var
           fmt_rest$25 = parse(str_ind, end_ind)[1],
           fmt_result = [0, [16, fmt_rest$25]];
          break a;
         case 123:
          var
           sub_end$0 = search_subformat_end(str_ind, end_ind, 125),
           sub_fmt$0 = parse(str_ind, sub_end$0)[1],
           fmt_rest$26 = parse(sub_end$0 + 2 | 0, end_ind)[1],
           sub_fmtty$0 = fmtty_of_fmt(sub_fmt$0);
          if(get_ign(0))
           var
            ignored$11 = [8, get_pad_opt(95), sub_fmtty$0],
            _a3_ = [0, [23, ignored$11, fmt_rest$26]];
          else
           var _a3_ = [0, [13, get_pad_opt(123), sub_fmtty$0, fmt_rest$26]];
          var fmt_result = _a3_;
          break a;
         case 66:
         case 98:
          var
           pad$3 = check_no_0(symb, get_padprec(0)),
           fmt_rest$8 = parse(str_ind, end_ind)[1];
          if(get_ign(0))
           var
            ignored$3 = [7, get_padprec_opt(95)],
            _aK_ = [0, [23, ignored$3, fmt_rest$8]];
          else
           var
            match$3 = make_padding_fmt_ebb(pad$3, fmt_rest$8),
            fmt_rest$9 = match$3[2],
            pad$4 = match$3[1],
            _aK_ = [0, [9, pad$4, fmt_rest$9]];
          var fmt_result = _aK_;
          break a;
         case 37:
         case 64:
          var
           fmt_rest$6 = parse(str_ind, end_ind)[1],
           fmt_result = [0, [12, symb, fmt_rest$6]];
          break a;
         case 76:
         case 108:
         case 110:
          if(str_ind !== end_ind){
           var symb$0 = caml_string_get(str, str_ind), _a4_ = symb$0 - 88 | 0;
           b:
           {
            if(32 >= _a4_ >>> 0)
             switch(_a4_){
               case 0:
               case 12:
               case 17:
               case 23:
               case 29:
               case 32:
                var _aQ_ = 1; break b;
             }
            var _aQ_ = 0;
           }
           if(_aQ_) break;
          }
          var fmt_rest$13 = parse(str_ind, end_ind)[1];
          b:
          {
           if(108 <= symb){
            if(111 > symb)
             switch(symb - 108 | 0){
               case 0:
                var counter = 0; break b;
               case 1: break;
               default: var counter = 1; break b;
             }
           }
           else if(76 === symb){var counter = 2; break b;}
           throw caml_maybe_attach_backtrace([0, Assert_failure, _V_], 1);
          }
          if(get_ign(0))
           var
            ignored$5 = [11, counter],
            _aP_ = [0, [23, ignored$5, fmt_rest$13]];
          else
           var _aP_ = [0, [21, counter, fmt_rest$13]];
          var fmt_result = _aP_;
          break a;
         case 32:
         case 35:
         case 43:
         case 45:
         case 95:
          var
           fmt_result = caml_call3(failwith_message(_M_), str, pct_ind, symb);
          break a;
         case 88:
         case 100:
         case 105:
         case 111:
         case 117:
         case 120:
          var
           _aT_ = get_space(0),
           _aU_ = get_hash(0),
           iconv$2 =
             compute_int_conv(pct_ind, str_ind, get_plus(0), _aU_, _aT_, symb),
           fmt_rest$17 = parse(str_ind, end_ind)[1];
          if(get_ign(0))
           var
            ignored$8 = [2, iconv$2, get_pad_opt(95)],
            _aV_ = [0, [23, ignored$8, fmt_rest$17]];
          else
           var
            _aW_ = get_prec(0),
            match$6 = make_padprec_fmt_ebb(get_int_pad(0), _aW_, fmt_rest$17),
            fmt_rest$18 = match$6[3],
            prec$4 = match$6[2],
            pad$8 = match$6[1],
            _aV_ = [0, [4, iconv$2, pad$8, prec$4, fmt_rest$18]];
          var fmt_result = _aV_;
          break a;
         case 69:
         case 70:
         case 71:
         case 72:
         case 101:
         case 102:
         case 103:
         case 104:
          var
           space$1 = get_space(0),
           hash$1 = get_hash(0),
           plus$2 = get_plus(0),
           flag =
             plus$2
              ? space$1
                ? legacy_behavior$0
                  ? 1
                  : incompatible_flag(pct_ind, str_ind, 32, cst$36)
                : 1
              : space$1 ? 2 : 0;
          b:
          {
           c:
           if(73 <= symb){
            var switcher = symb - 101 | 0;
            if(3 >= switcher >>> 0){
             switch(switcher){
               case 0:
                var _a5_ = 1; break;
               case 1:
                var _a5_ = 0; break;
               case 2:
                var _a5_ = 3; break;
               default: var _a5_ = 6;
             }
             var kind = _a5_;
             break b;
            }
           }
           else if(69 <= symb){
            switch(symb - 69 | 0){
              case 0:
               var _a6_ = 2; break;
              case 1:
               break c;
              case 2:
               var _a6_ = 4; break;
              default: var _a6_ = 7;
            }
            var kind = _a6_;
            break b;
           }
           if(hash$1){
            if(70 === symb){var kind = 8; break b;}
           }
           else if(70 === symb){var kind = 5; break b;}
           throw caml_maybe_attach_backtrace([0, Assert_failure, _X_], 1);
          }
          var
           fconv = [0, flag, kind],
           fmt_rest$11 = parse(str_ind, end_ind)[1];
          if(get_ign(0)){
           var match = get_prec(0);
           if(typeof match === "number")
            var
             _aM_ =
               match ? incompatible_flag(pct_ind, str_ind, 95, cst$26) : 0;
           else
            var ndec = match[1], _aM_ = [0, ndec];
           var
            ignored$4 = [6, get_pad_opt(95), _aM_],
            _aN_ = [0, [23, ignored$4, fmt_rest$11]];
          }
          else
           var
            _aO_ = get_prec(0),
            match$4 = make_padprec_fmt_ebb(get_pad(0), _aO_, fmt_rest$11),
            fmt_rest$12 = match$4[3],
            prec$3 = match$4[2],
            pad$5 = match$4[1],
            _aN_ = [0, [8, fconv, pad$5, prec$3, fmt_rest$12]];
          var fmt_result = _aN_;
          break a;
       }
      b:
      if(108 <= symb){
       if(111 > symb){
        switch(symb - 108 | 0){
          case 0:
           var
            _at_ = caml_string_get(str, str_ind),
            _au_ = get_space(0),
            _av_ = get_hash(0),
            iconv =
              compute_int_conv
               (pct_ind, str_ind + 1 | 0, get_plus(0), _av_, _au_, _at_),
            fmt_rest = parse(str_ind + 1 | 0, end_ind)[1];
           if(get_ign(0))
            var
             ignored = [3, iconv, get_pad_opt(95)],
             _aw_ = [0, [23, ignored, fmt_rest]];
           else
            var
             _ay_ = get_prec(0),
             match$0 = make_padprec_fmt_ebb(get_int_pad(0), _ay_, fmt_rest),
             fmt_rest$0 = match$0[3],
             prec$0 = match$0[2],
             pad$0 = match$0[1],
             _aw_ = [0, [5, iconv, pad$0, prec$0, fmt_rest$0]];
           var _ax_ = _aw_;
           break;
          case 1:
           break b;
          default:
           var
            _az_ = caml_string_get(str, str_ind),
            _aA_ = get_space(0),
            _aB_ = get_hash(0),
            iconv$0 =
              compute_int_conv
               (pct_ind, str_ind + 1 | 0, get_plus(0), _aB_, _aA_, _az_),
            fmt_rest$1 = parse(str_ind + 1 | 0, end_ind)[1];
           if(get_ign(0))
            var
             ignored$0 = [4, iconv$0, get_pad_opt(95)],
             _aC_ = [0, [23, ignored$0, fmt_rest$1]];
           else
            var
             _aD_ = get_prec(0),
             match$1 = make_padprec_fmt_ebb(get_int_pad(0), _aD_, fmt_rest$1),
             fmt_rest$2 = match$1[3],
             prec$1 = match$1[2],
             pad$1 = match$1[1],
             _aC_ = [0, [6, iconv$0, pad$1, prec$1, fmt_rest$2]];
           var _ax_ = _aC_;
        }
        var fmt_result = _ax_;
        break a;
       }
      }
      else if(76 === symb){
       var
        _aE_ = caml_string_get(str, str_ind),
        _aF_ = get_space(0),
        _aG_ = get_hash(0),
        iconv$1 =
          compute_int_conv
           (pct_ind, str_ind + 1 | 0, get_plus(0), _aG_, _aF_, _aE_),
        fmt_rest$3 = parse(str_ind + 1 | 0, end_ind)[1];
       if(get_ign(0))
        var
         ignored$1 = [5, iconv$1, get_pad_opt(95)],
         _aH_ = [0, [23, ignored$1, fmt_rest$3]];
       else
        var
         _aI_ = get_prec(0),
         match$2 = make_padprec_fmt_ebb(get_int_pad(0), _aI_, fmt_rest$3),
         fmt_rest$4 = match$2[3],
         prec$2 = match$2[2],
         pad$2 = match$2[1],
         _aH_ = [0, [7, iconv$1, pad$2, prec$2, fmt_rest$4]];
       var fmt_result = _aH_;
       break a;
      }
      var
       fmt_result =
         caml_call3(failwith_message(_J_), str, str_ind - 1 | 0, symb);
     }
     if(1 - legacy_behavior$0){
      var _ak_ = 1 - plus_used[1], plus$0 = _ak_ ? plus : _ak_;
      if(plus$0) incompatible_flag(pct_ind, str_ind, symb, cst$27);
      var _al_ = 1 - hash_used[1], hash$0 = _al_ ? hash : _al_;
      if(hash$0) incompatible_flag(pct_ind, str_ind, symb, cst$28);
      var _am_ = 1 - space_used[1], space$0 = _am_ ? space : _am_;
      if(space$0) incompatible_flag(pct_ind, str_ind, symb, cst$29);
      var
       _an_ = 1 - pad_used[1],
       _ao_ = _an_ ? caml_notequal([0, pad], _K_) : _an_;
      if(_ao_) incompatible_flag(pct_ind, str_ind, symb, cst_padding$0);
      var
       _ap_ = 1 - prec_used[1],
       _aq_ = _ap_ ? caml_notequal([0, prec], _L_) : _ap_;
      if(_aq_){
       var _ar_ = ign ? 95 : symb;
       incompatible_flag(pct_ind, str_ind, _ar_, cst_precision$2);
      }
      var plus$1 = ign ? plus : ign;
      if(plus$1) incompatible_flag(pct_ind, str_ind, 95, cst$30);
     }
     var _as_ = 1 - ign_used[1], ign$0 = _as_ ? ign : _as_;
     a:
     if(ign$0){
      b:
      {
       if(38 <= symb){
        if(44 !== symb && 64 !== symb) break b;
       }
       else if(33 !== symb && 37 > symb) break b;
       if(legacy_behavior$0) break a;
      }
      incompatible_flag(pct_ind, str_ind, symb, cst$31);
     }
     return fmt_result;
    }
    function parse_tag(is_open_tag, str_ind, end_ind){
     try{
      if(str_ind === end_ind) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
      if(60 !== caml_string_get(str, str_ind))
       throw caml_maybe_attach_backtrace(Stdlib[8], 1);
      var ind = caml_call3(Stdlib_String[31], str, str_ind + 1 | 0, 62);
      if(end_ind <= ind) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
      var
       sub_str =
         caml_call3
          (Stdlib_String[15], str, str_ind, (ind - str_ind | 0) + 1 | 0),
       fmt_rest$0 = parse(ind + 1 | 0, end_ind)[1],
       sub_fmt = parse(str_ind, ind + 1 | 0)[1],
       sub_format$0 = [0, sub_fmt, sub_str],
       formatting$0 = is_open_tag ? [0, sub_format$0] : [1, sub_format$0],
       _ai_ = [0, [18, formatting$0, fmt_rest$0]];
      return _ai_;
     }
     catch(_aj_){
      var _ah_ = caml_wrap_exception(_aj_);
      if(_ah_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_ah_, 0);
      var
       fmt_rest = parse(str_ind, end_ind)[1],
       formatting = is_open_tag ? [0, sub_format] : [1, sub_format];
      return [0, [18, formatting, fmt_rest]];
     }
    }
    function parse_spaces(str_ind, end_ind){
     var str_ind$0 = str_ind;
     for(;;){
      if(str_ind$0 === end_ind)
       invalid_format_message(end_ind, cst_unexpected_end_of_format);
      if(32 !== caml_string_get(str, str_ind$0)) return str_ind$0;
      var str_ind$1 = str_ind$0 + 1 | 0;
      str_ind$0 = str_ind$1;
     }
    }
    function parse_positive(str_ind, end_ind, acc){
     var str_ind$0 = str_ind, acc$0 = acc;
     for(;;){
      if(str_ind$0 === end_ind)
       invalid_format_message(end_ind, cst_unexpected_end_of_format);
      var c = caml_string_get(str, str_ind$0);
      if(9 < c - 48 >>> 0) return [0, str_ind$0, acc$0];
      var new_acc = (acc$0 * 10 | 0) + (c - 48 | 0) | 0;
      if(Stdlib_Sys[12] < new_acc){
       var _ag_ = Stdlib_Sys[12];
       return caml_call3(failwith_message(_S_), str, new_acc, _ag_);
      }
      var str_ind$1 = str_ind$0 + 1 | 0;
      str_ind$0 = str_ind$1;
      acc$0 = new_acc;
     }
    }
    function parse_integer(str_ind, end_ind){
     if(str_ind === end_ind)
      invalid_format_message(end_ind, cst_unexpected_end_of_format);
     var match = caml_string_get(str, str_ind);
     if(48 <= match){
      if(58 > match) return parse_positive(str_ind, end_ind, 0);
     }
     else if(45 === match){
      if((str_ind + 1 | 0) === end_ind)
       invalid_format_message(end_ind, cst_unexpected_end_of_format);
      var c = caml_string_get(str, str_ind + 1 | 0);
      if(9 < c - 48 >>> 0)
       return expected_character(str_ind + 1 | 0, cst_digit, c);
      var
       match$0 = parse_positive(str_ind + 1 | 0, end_ind, 0),
       n = match$0[2],
       next_ind = match$0[1];
      return [0, next_ind, - n | 0];
     }
     throw caml_maybe_attach_backtrace([0, Assert_failure, _T_], 1);
    }
    function add_literal(lit_start, str_ind, fmt){
     var size = str_ind - lit_start | 0;
     return 0 === size
             ? [0, fmt]
             : 1
               === size
               ? [0, [12, caml_string_get(str, lit_start), fmt]]
               : [0,
                 [11,
                  caml_call3(Stdlib_String[15], str, lit_start, size),
                  fmt]];
    }
    function search_subformat_end(str_ind, end_ind, c){
     var str_ind$0 = str_ind;
     for(;;){
      if(str_ind$0 === end_ind)
       caml_call3(failwith_message(_U_), str, c, end_ind);
      if(37 === caml_string_get(str, str_ind$0)){
       if((str_ind$0 + 1 | 0) === end_ind)
        invalid_format_message(end_ind, cst_unexpected_end_of_format);
       if(caml_string_get(str, str_ind$0 + 1 | 0) === c) return str_ind$0;
       var match = caml_string_get(str, str_ind$0 + 1 | 0);
       if(95 <= match){
        if(123 <= match){
         if(126 > match)
          switch(match - 123 | 0){
            case 0:
             var
              sub_end = search_subformat_end(str_ind$0 + 2 | 0, end_ind, 125),
              str_ind$2 = sub_end + 2 | 0;
             str_ind$0 = str_ind$2;
             continue;
            case 1: break;
            default:
             return expected_character(str_ind$0 + 1 | 0, cst_character, 125);
          }
        }
        else if(96 > match){
         if((str_ind$0 + 2 | 0) === end_ind)
          invalid_format_message(end_ind, cst_unexpected_end_of_format);
         var match$0 = caml_string_get(str, str_ind$0 + 2 | 0);
         if(40 === match$0){
          var
           sub_end$0 = search_subformat_end(str_ind$0 + 3 | 0, end_ind, 41),
           str_ind$3 = sub_end$0 + 2 | 0;
          str_ind$0 = str_ind$3;
          continue;
         }
         if(123 === match$0){
          var
           sub_end$1 = search_subformat_end(str_ind$0 + 3 | 0, end_ind, 125),
           str_ind$4 = sub_end$1 + 2 | 0;
          str_ind$0 = str_ind$4;
          continue;
         }
         var str_ind$5 = str_ind$0 + 3 | 0;
         str_ind$0 = str_ind$5;
         continue;
        }
       }
       else{
        if(40 === match){
         var
          sub_end$2 = search_subformat_end(str_ind$0 + 2 | 0, end_ind, 41),
          str_ind$6 = sub_end$2 + 2 | 0;
         str_ind$0 = str_ind$6;
         continue;
        }
        if(41 === match)
         return expected_character(str_ind$0 + 1 | 0, cst_character$0, 41);
       }
       var str_ind$1 = str_ind$0 + 2 | 0;
       str_ind$0 = str_ind$1;
      }
      else{var str_ind$7 = str_ind$0 + 1 | 0; str_ind$0 = str_ind$7;}
     }
    }
    function compute_int_conv(pct_ind, str_ind, plus, hash, space, symb){
     var plus$0 = plus, hash$0 = hash, space$0 = space;
     for(;;){
      a:
      {
       if(plus$0){
        if(! hash$0){
         if(space$0) break a;
         if(100 === symb) return 1;
         if(105 === symb) return 4;
         break a;
        }
       }
       else{
        if(! hash$0){
         if(space$0){
          if(100 === symb) return 2;
          if(105 === symb) return 5;
          break a;
         }
         var switcher$1 = symb - 88 | 0;
         if(32 < switcher$1 >>> 0) break a;
         switch(switcher$1){
           case 0:
            return 8;
           case 12:
            return 0;
           case 17:
            return 3;
           case 23:
            return 10;
           case 29:
            return 12;
           case 32:
            return 6;
           default: break a;
         }
        }
        if(! space$0){
         var switcher$0 = symb - 88 | 0;
         if(32 >= switcher$0 >>> 0)
          switch(switcher$0){
            case 0:
             return 9;
            case 12:
             return 13;
            case 17:
             return 14;
            case 23:
             return 11;
            case 29:
             return 15;
            case 32:
             return 7;
          }
        }
       }
       var switcher = symb - 88 | 0;
       if(32 >= switcher >>> 0)
        switch(switcher){
          case 0:
           if(legacy_behavior$0) return 9; break;
          case 23:
           if(legacy_behavior$0) return 11; break;
          case 32:
           if(legacy_behavior$0) return 7; break;
          case 12:
          case 17:
          case 29:
           if(! legacy_behavior$0)
            return incompatible_flag(pct_ind, str_ind, symb, cst$35);
           hash$0 = 0;
           continue;
        }
      }
      if(plus$0)
       if(space$0){
        if(! legacy_behavior$0)
         return incompatible_flag(pct_ind, str_ind, 32, cst$32);
        space$0 = 0;
       }
       else{
        if(! legacy_behavior$0)
         return incompatible_flag(pct_ind, str_ind, symb, cst$33);
        plus$0 = 0;
       }
      else{
       if(! space$0)
        throw caml_maybe_attach_backtrace([0, Assert_failure, _W_], 1);
       if(! legacy_behavior$0)
        return incompatible_flag(pct_ind, str_ind, symb, cst$34);
       space$0 = 0;
      }
     }
    }
    function incompatible_flag(pct_ind, str_ind, symb, option){
     var
      subfmt =
        caml_call3(Stdlib_String[15], str, pct_ind, str_ind - pct_ind | 0);
     return caml_call5
             (failwith_message(_Y_), str, pct_ind, option, symb, subfmt);
    }
    return parse(0, caml_ml_string_length(str));
   }
   function format_of_string_fmtty(str, fmtty){
    var fmt = fmt_ebb_of_string(0, str)[1];
    try{var _ae_ = [0, type_format(fmt, fmtty), str]; return _ae_;}
    catch(_af_){
     var _ac_ = caml_wrap_exception(_af_);
     if(_ac_ !== Type_mismatch) throw caml_maybe_attach_backtrace(_ac_, 0);
     var _ad_ = string_of_fmtty(fmtty);
     return caml_call2(failwith_message(_Z_), str, _ad_);
    }
   }
   function format_of_string_format(str, param){
    var
     str$0 = param[2],
     fmt = param[1],
     fmt$0 = fmt_ebb_of_string(0, str)[1];
    try{
     var _aa_ = [0, type_format(fmt$0, fmtty_of_fmt(fmt)), str];
     return _aa_;
    }
    catch(_ab_){
     var _$_ = caml_wrap_exception(_ab_);
     if(_$_ === Type_mismatch)
      return caml_call2(failwith_message(___), str, str$0);
     throw caml_maybe_attach_backtrace(_$_, 0);
    }
   }
   var
    CamlinternalFormat =
      [0,
       is_in_char_set,
       rev_char_set,
       create_char_set,
       add_in_char_set,
       freeze_char_set,
       param_format_of_ignored_format,
       make_printf,
       make_iprintf,
       output_acc,
       bufput_acc,
       strput_acc,
       type_format,
       fmt_ebb_of_string,
       format_of_string_fmtty,
       format_of_string_format,
       char_of_iconv,
       string_of_formatting_lit,
       string_of_fmtty,
       string_of_fmt,
       open_box_of_string,
       symm,
       trans,
       recast];
   runtime.caml_register_global(197, CamlinternalFormat, "CamlinternalFormat");
   return;
  }
  (globalThis));

//# 15834 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    CamlinternalFormat = global_data.CamlinternalFormat,
    Stdlib = global_data.Stdlib;
   function kfprintf(k, o, param){
    var fmt = param[1];
    return caml_call3
            (CamlinternalFormat[7],
             function(acc){
              caml_call2(CamlinternalFormat[9], o, acc);
              return caml_call1(k, o);
             },
             0,
             fmt);
   }
   function kbprintf(k, b, param){
    var fmt = param[1];
    return caml_call3
            (CamlinternalFormat[7],
             function(acc){
              caml_call2(CamlinternalFormat[10], b, acc);
              return caml_call1(k, b);
             },
             0,
             fmt);
   }
   function ikfprintf(k, oc, param){
    var fmt = param[1];
    return caml_call3(CamlinternalFormat[8], k, oc, fmt);
   }
   function fprintf(oc, fmt){
    return kfprintf(function(_d_){return 0;}, oc, fmt);
   }
   function bprintf(b, fmt){
    return kbprintf(function(_c_){return 0;}, b, fmt);
   }
   function ifprintf(oc, fmt){
    return ikfprintf(function(_b_){return 0;}, oc, fmt);
   }
   function ibprintf(b, fmt){
    return ikfprintf(function(_a_){return 0;}, b, fmt);
   }
   function printf(fmt){return fprintf(Stdlib[39], fmt);}
   function eprintf(fmt){return fprintf(Stdlib[40], fmt);}
   function ksprintf(k, param){
    var fmt = param[1];
    function k$0(acc){
     var buf = caml_call1(Stdlib_Buffer[1], 64);
     caml_call2(CamlinternalFormat[11], buf, acc);
     return caml_call1(k, caml_call1(Stdlib_Buffer[2], buf));
    }
    return caml_call3(CamlinternalFormat[7], k$0, 0, fmt);
   }
   function sprintf(fmt){return ksprintf(function(s){return s;}, fmt);}
   var
    Stdlib_Printf =
      [0,
       fprintf,
       printf,
       eprintf,
       sprintf,
       bprintf,
       ifprintf,
       ibprintf,
       kfprintf,
       ikfprintf,
       ksprintf,
       kbprintf,
       ikfprintf,
       ksprintf];
   runtime.caml_register_global(3, Stdlib_Printf, "Stdlib__Printf");
   return;
  }
  (globalThis));

//# 16644 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    CamlinternalAtomic = global_data.CamlinternalAtomic,
    make = CamlinternalAtomic[1],
    get = CamlinternalAtomic[2],
    set = CamlinternalAtomic[3],
    exchange = CamlinternalAtomic[4],
    compare_and_set = CamlinternalAtomic[5],
    fetch_and_add = CamlinternalAtomic[6],
    incr = CamlinternalAtomic[7],
    decr = CamlinternalAtomic[8],
    Stdlib_Atomic =
      [0,
       make,
       get,
       set,
       exchange,
       compare_and_set,
       fetch_and_add,
       incr,
       decr];
   runtime.caml_register_global(1, Stdlib_Atomic, "Stdlib__Atomic");
   return;
  }
  (globalThis));

//# 16676 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$4 = "",
    cst_s = "%s\n",
    cst_Program_not_linked_with_g_$0 =
      "(Program not linked with -g, cannot print stack backtrace)\n",
    cst_characters = ", characters ",
    cst_Fatal_error_exception = "Fatal error: exception ",
    cst_Fatal_error_exception_s = "Fatal error: exception %s\n",
    cst_Uncaught_exception = "Uncaught exception: ",
    cst_Uncaught_exception_s = "Uncaught exception: %s\n",
    caml_check_bound = runtime.caml_check_bound,
    caml_get_exception_raw_backtra = runtime.caml_get_exception_raw_backtrace,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$0 = cst$4,
    cst$3 = cst$4,
    partial = [4, 0, 0, 0, [12, 45, [4, 0, 0, 0, 0]]],
    cst$1 = cst$4,
    cst$2 = cst$4,
    cst = "_",
    locfmt =
      [0,
       [11,
        'File "',
        [2,
         0,
         [11,
          '", line ',
          [4,
           0,
           0,
           0,
           [11,
            cst_characters,
            [4, 0, 0, 0, [12, 45, [4, 0, 0, 0, [11, ": ", [2, 0, 0]]]]]]]]]],
       'File "%s", line %d, characters %d-%d: %s'],
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib_Atomic = global_data.Stdlib__Atomic,
    Stdlib = global_data.Stdlib,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Stdlib_Obj = global_data.Stdlib__Obj,
    printers = caml_call1(Stdlib_Atomic[1], 0),
    _a_ = [0, [3, 0, 0], "%S"],
    _b_ = [0, [4, 0, 0, 0, 0], "%d"],
    _c_ = [0, [11, ", ", [2, 0, [2, 0, 0]]], ", %s%s"],
    _d_ = [0, [12, 40, [2, 0, [2, 0, [12, 41, 0]]]], "(%s%s)"],
    _e_ = [0, [12, 40, [2, 0, [12, 41, 0]]], "(%s)"],
    cst_Out_of_memory = "Out of memory",
    cst_Stack_overflow = "Stack overflow",
    cst_Pattern_matching_failed = "Pattern matching failed",
    cst_Assertion_failed = "Assertion failed",
    cst_Undefined_recursive_module = "Undefined recursive module",
    _f_ =
      [0,
       [11, cst_Uncaught_exception, [2, 0, [12, 10, 0]]],
       cst_Uncaught_exception_s],
    _g_ =
      [0,
       [11, cst_Uncaught_exception, [2, 0, [12, 10, 0]]],
       cst_Uncaught_exception_s],
    cst_Raised_at = "Raised at",
    cst_Re_raised_at = "Re-raised at",
    cst_Raised_by_primitive_operat = "Raised by primitive operation at",
    cst_Called_from = "Called from",
    cst_inlined = " (inlined)",
    _h_ =
      [0,
       [2,
        0,
        [12,
         32,
         [2,
          0,
          [11,
           ' in file "',
           [2,
            0,
            [12,
             34,
             [2,
              0,
              [11, ", line ", [4, 0, 0, 0, [11, cst_characters, partial]]]]]]]]]],
       '%s %s in file "%s"%s, line %d, characters %d-%d'],
    _i_ = [0, [2, 0, [11, " unknown location", 0]], "%s unknown location"],
    _j_ = [0, [2, 0, [12, 10, 0]], cst_s],
    _k_ =
      [0,
       [11, cst_Program_not_linked_with_g_$0, 0],
       cst_Program_not_linked_with_g_$0],
    _l_ = [0, [2, 0, [12, 10, 0]], cst_s],
    cst_Program_not_linked_with_g_ = cst_Program_not_linked_with_g_$0;
   function field(x, i){
    var f = x[1 + i];
    if(! caml_call1(Stdlib_Obj[1], f))
     return caml_call2(Stdlib_Printf[4], _b_, f);
    var _ag_ = Stdlib_Obj[13];
    if(caml_obj_tag(f) === _ag_) return caml_call2(Stdlib_Printf[4], _a_, f);
    var _ah_ = Stdlib_Obj[14];
    return caml_obj_tag(f) === _ah_ ? caml_call1(Stdlib[35], f) : cst;
   }
   function other_fields(x, i){
    if(x.length - 1 <= i) return cst$0;
    var _ae_ = other_fields(x, i + 1 | 0), _af_ = field(x, i);
    return caml_call3(Stdlib_Printf[4], _c_, _af_, _ae_);
   }
   function use_printers(x){
    var param = caml_call1(Stdlib_Atomic[2], printers);
    for(;;){
     if(! param) return 0;
     var tl = param[2], hd = param[1];
     a:
     {
      try{var val = caml_call1(hd, x);}catch(_ad_){break a;}
      if(val){var s = val[1]; return [0, s];}
     }
     param = tl;
    }
   }
   function to_string_default(x){
    if(x === Stdlib[9]) return cst_Out_of_memory;
    if(x === Stdlib[10]) return cst_Stack_overflow;
    if(x[1] === Stdlib[4]){
     var
      match$0 = x[2],
      char$0 = match$0[3],
      line = match$0[2],
      file = match$0[1];
     return caml_call6
             (Stdlib_Printf[4],
              locfmt,
              file,
              line,
              char$0,
              char$0 + 5 | 0,
              cst_Pattern_matching_failed);
    }
    if(x[1] === Stdlib[5]){
     var
      match$1 = x[2],
      char$1 = match$1[3],
      line$0 = match$1[2],
      file$0 = match$1[1];
     return caml_call6
             (Stdlib_Printf[4],
              locfmt,
              file$0,
              line$0,
              char$1,
              char$1 + 6 | 0,
              cst_Assertion_failed);
    }
    if(x[1] === Stdlib[15]){
     var
      match$2 = x[2],
      char$2 = match$2[3],
      line$1 = match$2[2],
      file$1 = match$2[1];
     return caml_call6
             (Stdlib_Printf[4],
              locfmt,
              file$1,
              line$1,
              char$2,
              char$2 + 6 | 0,
              cst_Undefined_recursive_module);
    }
    if(0 !== caml_obj_tag(x)) return x[1];
    var constructor = x[1][1], match = x.length - 1;
    if(2 < match >>> 0)
     var
      _$_ = other_fields(x, 2),
      _aa_ = field(x, 1),
      _ac_ = caml_call3(Stdlib_Printf[4], _d_, _aa_, _$_);
    else
     switch(match){
       case 0:
        var _ac_ = cst$1; break;
       case 1:
        var _ac_ = cst$2; break;
       default:
        var
         _ab_ = field(x, 1),
         _ac_ = caml_call2(Stdlib_Printf[4], _e_, _ab_);
     }
    return caml_call2(Stdlib[28], constructor, _ac_);
   }
   function to_string(e){
    var match = use_printers(e);
    if(! match) return to_string_default(e);
    var s = match[1];
    return s;
   }
   function print(fct, arg){
    try{var ___ = caml_call1(fct, arg); return ___;}
    catch(x$0){
     var x = caml_wrap_exception(x$0), _Z_ = to_string(x);
     caml_call2(Stdlib_Printf[3], _f_, _Z_);
     caml_call1(Stdlib[63], Stdlib[40]);
     throw caml_maybe_attach_backtrace(x, 0);
    }
   }
   function catch$0(fct, arg){
    try{var _Y_ = caml_call1(fct, arg); return _Y_;}
    catch(x$0){
     var x = caml_wrap_exception(x$0);
     caml_call1(Stdlib[63], Stdlib[39]);
     var _X_ = to_string(x);
     caml_call2(Stdlib_Printf[3], _g_, _X_);
     return caml_call1(Stdlib[99], 2);
    }
   }
   function raw_backtrace_entries(bt){return bt;}
   function convert_raw_backtrace(bt){
    return [0, runtime.caml_convert_raw_backtrace(bt)];
   }
   function format_backtrace_slot(pos, slot){
    function info(is_raise){
     return is_raise
             ? 0 === pos ? cst_Raised_at : cst_Re_raised_at
             : 0 === pos ? cst_Raised_by_primitive_operat : cst_Called_from;
    }
    if(0 === slot[0]){
     var
      _P_ = slot[5],
      _Q_ = slot[4],
      _R_ = slot[3],
      _S_ = slot[6] ? cst_inlined : cst$3,
      _T_ = slot[2],
      _U_ = slot[7],
      _V_ = info(slot[1]);
     return [0,
             caml_call8
              (Stdlib_Printf[4], _h_, _V_, _U_, _T_, _S_, _R_, _Q_, _P_)];
    }
    if(slot[1]) return 0;
    var _W_ = info(0);
    return [0, caml_call2(Stdlib_Printf[4], _i_, _W_)];
   }
   function print_raw_backtrace(outchan, raw_backtrace){
    var backtrace = convert_raw_backtrace(raw_backtrace);
    if(! backtrace) return caml_call2(Stdlib_Printf[1], outchan, _k_);
    var a = backtrace[1], _N_ = a.length - 2 | 0, _M_ = 0;
    if(_N_ >= 0){
     var i = _M_;
     for(;;){
      var match = format_backtrace_slot(i, caml_check_bound(a, i)[1 + i]);
      if(match){
       var str = match[1];
       caml_call3(Stdlib_Printf[1], outchan, _j_, str);
      }
      var _O_ = i + 1 | 0;
      if(_N_ === i) break;
      i = _O_;
     }
    }
    return 0;
   }
   function print_backtrace(outchan){
    return print_raw_backtrace(outchan, caml_get_exception_raw_backtra(0));
   }
   function raw_backtrace_to_string(raw_backtrace){
    var backtrace = convert_raw_backtrace(raw_backtrace);
    if(! backtrace) return cst_Program_not_linked_with_g_;
    var
     a = backtrace[1],
     b = caml_call1(Stdlib_Buffer[1], 1024),
     _K_ = a.length - 2 | 0,
     _J_ = 0;
    if(_K_ >= 0){
     var i = _J_;
     for(;;){
      var match = format_backtrace_slot(i, caml_check_bound(a, i)[1 + i]);
      if(match){
       var str = match[1];
       caml_call3(Stdlib_Printf[5], b, _l_, str);
      }
      var _L_ = i + 1 | 0;
      if(_K_ === i) break;
      i = _L_;
     }
    }
    return caml_call1(Stdlib_Buffer[2], b);
   }
   function backtrace_slot_is_raise(param){
    return 0 === param[0] ? param[1] : param[1];
   }
   function backtrace_slot_is_inline(param){return 0 === param[0] ? param[6] : 0;
   }
   function backtrace_slot_location(param){
    return 0 === param[0]
            ? [0, [0, param[2], param[3], param[4], param[5]]]
            : 0;
   }
   function backtrace_slot_defname(param){
    if(0 === param[0] && param[7] !== cst$4) return [0, param[7]];
    return 0;
   }
   function backtrace_slots(raw_backtrace){
    var match = convert_raw_backtrace(raw_backtrace);
    if(! match) return 0;
    var backtrace = match[1], i$1 = backtrace.length - 2 | 0, i = i$1;
    for(;;){
     if(-1 === i)
      var _I_ = 0;
     else{
      var _H_ = 0 === caml_check_bound(backtrace, i)[1 + i][0] ? 1 : 0;
      if(! _H_){var i$0 = i - 1 | 0; i = i$0; continue;}
      var _I_ = _H_;
     }
     return _I_ ? [0, backtrace] : 0;
    }
   }
   function backtrace_slots_of_raw_entry(entry){return backtrace_slots([0, entry]);
   }
   function raw_backtrace_length(bt){return bt.length - 1;}
   function get_backtrace(param){
    return raw_backtrace_to_string(caml_get_exception_raw_backtra(0));
   }
   function register_printer(fn){
    for(;;){
     var
      old_printers = caml_call1(Stdlib_Atomic[2], printers),
      new_printers = [0, fn, old_printers],
      success =
        caml_call3(Stdlib_Atomic[5], printers, old_printers, new_printers),
      _G_ = 1 - success;
     if(! _G_) return _G_;
    }
   }
   function exn_slot(x){return 0 === caml_obj_tag(x) ? x[1] : x;}
   function exn_slot_id(x){var slot = exn_slot(x); return slot[2];}
   function exn_slot_name(x){var slot = exn_slot(x); return slot[1];}
   var
    errors =
      [0,
        cst$4,
        "(Cannot print locations:\n bytecode executable program file not found)",
        "(Cannot print locations:\n bytecode executable program file appears to be corrupt)",
        "(Cannot print locations:\n bytecode executable program file has wrong magic number)",
        "(Cannot print locations:\n bytecode executable program file cannot be opened;\n -- too many open files. Try running with OCAMLRUNPARAM=b=2)"].slice
       (),
    _m_ =
      [0,
       [11, cst_Fatal_error_exception, [2, 0, [12, 10, 0]]],
       cst_Fatal_error_exception_s];
   function default_uncaught_exception_han(exn, raw_backtrace){
    var _D_ = to_string(exn);
    caml_call2(Stdlib_Printf[3], _m_, _D_);
    print_raw_backtrace(Stdlib[40], raw_backtrace);
    var status = runtime.caml_ml_debug_info_status(0);
    if(status < 0){
     var
      _E_ = caml_call1(Stdlib[18], status),
      _F_ = caml_check_bound(errors, _E_)[1 + _E_];
     caml_call1(Stdlib[53], _F_);
    }
    return caml_call1(Stdlib[63], Stdlib[40]);
   }
   var uncaught_exception_handler = [0, default_uncaught_exception_han];
   function set_uncaught_exception_handler(fn){
    uncaught_exception_handler[1] = fn;
    return 0;
   }
   var
    empty_backtrace = [0],
    cst_Fatal_error_out_of_memory_ =
      "Fatal error: out of memory in uncaught exception handler",
    _n_ =
      [0,
       [11, cst_Fatal_error_exception, [2, 0, [12, 10, 0]]],
       cst_Fatal_error_exception_s],
    _o_ =
      [0,
       [11,
        "Fatal error in uncaught exception handler: exception ",
        [2, 0, [12, 10, 0]]],
       "Fatal error in uncaught exception handler: exception %s\n"];
   function handle_uncaught_exception(exn$0, debugger_in_use){
    try{
     try{
      var
       raw_backtrace =
         debugger_in_use ? empty_backtrace : caml_get_exception_raw_backtra(0);
      try{caml_call1(Stdlib[103], 0);}catch(_C_){}
      try{
       var
        _y_ = caml_call2(uncaught_exception_handler[1], exn$0, raw_backtrace),
        _x_ = _y_;
      }
      catch(exn$1){
       var
        exn = caml_wrap_exception(exn$1),
        raw_backtrace$0 = caml_get_exception_raw_backtra(0),
        _v_ = to_string(exn$0);
       caml_call2(Stdlib_Printf[3], _n_, _v_);
       print_raw_backtrace(Stdlib[40], raw_backtrace);
       var _w_ = to_string(exn);
       caml_call2(Stdlib_Printf[3], _o_, _w_);
       print_raw_backtrace(Stdlib[40], raw_backtrace$0);
       var _x_ = caml_call1(Stdlib[63], Stdlib[40]);
      }
      var _z_ = _x_;
     }
     catch(_B_){
      var _u_ = caml_wrap_exception(_B_);
      if(_u_ !== Stdlib[9]) throw caml_maybe_attach_backtrace(_u_, 0);
      var _z_ = caml_call1(Stdlib[53], cst_Fatal_error_out_of_memory_);
     }
     return _z_;
    }
    catch(_A_){return 0;}
   }
   runtime.caml_register_named_value
    ("Printexc.handle_uncaught_exception", handle_uncaught_exception);
   var
    Stdlib_Printexc =
      [0,
       to_string,
       to_string_default,
       print,
       catch$0,
       print_backtrace,
       get_backtrace,
       runtime.caml_record_backtrace,
       runtime.caml_backtrace_status,
       register_printer,
       use_printers,
       raw_backtrace_entries,
       function(_t_){return caml_get_exception_raw_backtra(_t_);},
       print_raw_backtrace,
       raw_backtrace_to_string,
       default_uncaught_exception_han,
       set_uncaught_exception_handler,
       backtrace_slots,
       backtrace_slots_of_raw_entry,
       [0,
        backtrace_slot_is_raise,
        backtrace_slot_is_inline,
        backtrace_slot_location,
        backtrace_slot_defname,
        format_backtrace_slot],
       raw_backtrace_length,
       function(_s_, _r_){return runtime.caml_raw_backtrace_slot(_s_, _r_);},
       function(_q_){return runtime.caml_convert_raw_backtrace_slot(_q_);},
       function(_p_){return runtime.caml_raw_backtrace_next_slot(_p_);},
       exn_slot_id,
       exn_slot_name];
   runtime.caml_register_global(42, Stdlib_Printexc, "Stdlib__Printexc");
   return;
  }
  (globalThis));

//# 17162 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_restore_raw_backtrace = runtime.caml_restore_raw_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Stdlib_Printexc = global_data.Stdlib__Printexc,
    Stdlib = global_data.Stdlib;
   function const$0(c, param){return c;}
   function flip(f, x, y){return caml_call2(f, y, x);}
   function negate(p, v){return 1 - caml_call1(p, v);}
   var
    Finally_raised =
      [248, "Stdlib.Fun.Finally_raised", runtime.caml_fresh_oo_id(0)],
    cst_Fun_Finally_raised = "Fun.Finally_raised: ";
   caml_call1
    (Stdlib_Printexc[9],
     function(param){
      if(param[1] !== Finally_raised) return 0;
      var exn = param[2], _a_ = caml_call1(Stdlib_Printexc[1], exn);
      return [0, caml_call2(Stdlib[28], cst_Fun_Finally_raised, _a_)];
     });
   function protect(finally$0, work){
    function finally_no_exn(param){
     try{caml_call1(finally$0, 0); return;}
     catch(e$0){
      var
       e = caml_wrap_exception(e$0),
       bt = caml_call1(Stdlib_Printexc[12], 0),
       exn = [0, Finally_raised, e];
      caml_restore_raw_backtrace(exn, bt);
      throw caml_maybe_attach_backtrace(exn, 0);
     }
    }
    try{var result = caml_call1(work, 0);}
    catch(work_exn$0){
     var
      work_exn = caml_wrap_exception(work_exn$0),
      work_bt = caml_call1(Stdlib_Printexc[12], 0);
     finally_no_exn(0);
     caml_restore_raw_backtrace(work_exn, work_bt);
     throw caml_maybe_attach_backtrace(work_exn, 0);
    }
    finally_no_exn(0);
    return result;
   }
   var Stdlib_Fun = [0, const$0, flip, negate, protect, Finally_raised];
   runtime.caml_register_global(4, Stdlib_Fun, "Stdlib__Fun");
   return;
  }
  (globalThis));

//# 17394 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Digest_from_hex$1 = "Digest.from_hex",
    caml_bytes_unsafe_set = runtime.caml_bytes_unsafe_set,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_md5_string = runtime.caml_md5_string,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_get = runtime.caml_string_get,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Stdlib_Char = global_data.Stdlib__Char,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Stdlib_String = global_data.Stdlib__String,
    compare = Stdlib_String[9],
    equal = Stdlib_String[8],
    cst_Digest_substring = "Digest.substring",
    cst_Digest_to_hex = "Digest.to_hex",
    cst_Digest_from_hex = cst_Digest_from_hex$1,
    cst_Digest_from_hex$0 = cst_Digest_from_hex$1;
   function string(str){
    return caml_md5_string(str, 0, caml_ml_string_length(str));
   }
   function bytes(b){return string(caml_call1(Stdlib_Bytes[48], b));}
   function substring(str, ofs, len){
    if(0 <= ofs && 0 <= len && (caml_ml_string_length(str) - len | 0) >= ofs)
     return caml_md5_string(str, ofs, len);
    return caml_call1(Stdlib[1], cst_Digest_substring);
   }
   function subbytes(b, ofs, len){
    return substring(caml_call1(Stdlib_Bytes[48], b), ofs, len);
   }
   function file(filename){
    var ic = caml_call1(Stdlib[80], filename);
    try{var d = runtime.caml_md5_chan(ic, -1);}
    catch(e$0){
     var e = caml_wrap_exception(e$0);
     caml_call1(Stdlib[93], ic);
     throw caml_maybe_attach_backtrace(e, 0);
    }
    caml_call1(Stdlib[93], ic);
    return d;
   }
   function output(chan, digest){return caml_call2(Stdlib[66], chan, digest);}
   function input(chan){return caml_call2(Stdlib[86], chan, 16);}
   function char_hex(n){var _e_ = 10 <= n ? 87 : 48; return n + _e_ | 0;}
   function to_hex(d){
    if(16 !== caml_ml_string_length(d))
     caml_call1(Stdlib[1], cst_Digest_to_hex);
    var result = caml_create_bytes(32), i = 0;
    for(;;){
     var x = caml_string_get(d, i);
     caml_bytes_unsafe_set(result, i * 2 | 0, char_hex(x >>> 4 | 0));
     caml_bytes_unsafe_set(result, (i * 2 | 0) + 1 | 0, char_hex(x & 15));
     var _d_ = i + 1 | 0;
     if(15 === i) return caml_call1(Stdlib_Bytes[48], result);
     i = _d_;
    }
   }
   function from_hex(s){
    if(32 !== caml_ml_string_length(s))
     caml_call1(Stdlib[1], cst_Digest_from_hex);
    function digit(c){
     if(65 <= c){
      if(97 <= c){
       if(103 > c) return (c - 97 | 0) + 10 | 0;
      }
      else if(71 > c) return (c - 65 | 0) + 10 | 0;
     }
     else if(9 >= c - 48 >>> 0) return c - 48 | 0;
     throw caml_maybe_attach_backtrace
            ([0, Stdlib[6], cst_Digest_from_hex$0], 1);
    }
    var result = caml_create_bytes(16), i = 0;
    for(;;){
     var
      i$0 = 2 * i | 0,
      _a_ = digit(caml_string_get(s, i$0 + 1 | 0)),
      _b_ = (digit(caml_string_get(s, i$0)) << 4) + _a_ | 0;
     runtime.caml_bytes_set(result, i, caml_call1(Stdlib_Char[1], _b_));
     var _c_ = i + 1 | 0;
     if(15 === i) return caml_call1(Stdlib_Bytes[48], result);
     i = _c_;
    }
   }
   var
    Stdlib_Digest =
      [0,
       compare,
       equal,
       string,
       bytes,
       substring,
       subbytes,
       file,
       output,
       input,
       to_hex,
       from_hex];
   runtime.caml_register_global(8, Stdlib_Digest, "Stdlib__Digest");
   return;
  }
  (globalThis));

//# 17515 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_check_bound = runtime.caml_check_bound,
    caml_greaterthan = runtime.caml_greaterthan,
    caml_int64_of_int32 = runtime.caml_int64_of_int32,
    caml_int64_or = runtime.caml_int64_or,
    caml_int64_shift_left = runtime.caml_int64_shift_left,
    caml_int64_shift_right_unsigne = runtime.caml_int64_shift_right_unsigned,
    caml_int64_sub = runtime.caml_int64_sub,
    caml_int64_to_int32 = runtime.caml_int64_to_int32,
    caml_lessequal = runtime.caml_lessequal,
    caml_mod = runtime.caml_mod,
    caml_string_get = runtime.caml_string_get,
    caml_sys_random_seed = runtime.caml_sys_random_seed;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Stdlib_Int32 = global_data.Stdlib__Int32,
    Stdlib_Int64 = global_data.Stdlib__Int64,
    Stdlib_Int = global_data.Stdlib__Int,
    Stdlib_Digest = global_data.Stdlib__Digest,
    Stdlib_Array = global_data.Stdlib__Array,
    Stdlib_Nativeint = global_data.Stdlib__Nativeint,
    cst_x = "x",
    cst_Random_int = "Random.int",
    cst_Random_full_int = "Random.full_int",
    cst_Random_int32 = "Random.int32",
    _a_ = runtime.caml_int64_create_lo_mi_hi(1, 0, 0),
    _b_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    cst_Random_int64 = "Random.int64";
   function new_state(param){return [0, runtime.caml_make_vect(55, 0), 0];}
   function assign(st1, st2){
    caml_call5(Stdlib_Array[10], st2[1], 0, st1[1], 0, 55);
    st1[2] = st2[2];
    return 0;
   }
   function full_init(s, seed){
    var
     seed$0 = 0 === seed.length - 1 ? [0, 0] : seed,
     l = seed$0.length - 1,
     i$0 = 0;
    for(;;){
     caml_check_bound(s[1], i$0)[1 + i$0] = i$0;
     var _q_ = i$0 + 1 | 0;
     if(54 === i$0) break;
     i$0 = _q_;
    }
    var
     accu = [0, cst_x],
     _n_ = 54 + caml_call2(Stdlib_Int[11], 55, l) | 0,
     _m_ = 0;
    if(_n_ >= 0){
     var i = _m_;
     for(;;){
      var
       j = i % 55 | 0,
       k = caml_mod(i, l),
       x = caml_check_bound(seed$0, k)[1 + k],
       accu$0 = accu[1],
       _g_ = caml_call1(Stdlib_Int[12], x),
       _h_ = caml_call2(Stdlib[28], accu$0, _g_);
      accu[1] = caml_call1(Stdlib_Digest[3], _h_);
      var
       d = accu[1],
       _i_ = caml_string_get(d, 3) << 24,
       _j_ = caml_string_get(d, 2) << 16,
       _k_ = caml_string_get(d, 1) << 8,
       _l_ = ((caml_string_get(d, 0) + _k_ | 0) + _j_ | 0) + _i_ | 0,
       _o_ = (caml_check_bound(s[1], j)[1 + j] ^ _l_) & 1073741823;
      caml_check_bound(s[1], j)[1 + j] = _o_;
      var _p_ = i + 1 | 0;
      if(_n_ === i) break;
      i = _p_;
     }
    }
    s[2] = 0;
    return 0;
   }
   function make(seed){
    var result = new_state(0);
    full_init(result, seed);
    return result;
   }
   function make_self_init(param){return make(caml_sys_random_seed(0));}
   function copy(s){
    var result = new_state(0);
    assign(result, s);
    return result;
   }
   function bits(s){
    s[2] = (s[2] + 1 | 0) % 55 | 0;
    var
     _d_ = s[2],
     curval = caml_check_bound(s[1], _d_)[1 + _d_],
     _e_ = (s[2] + 24 | 0) % 55 | 0,
     newval =
       caml_check_bound(s[1], _e_)[1 + _e_]
       + (curval ^ (curval >>> 25 | 0) & 31)
       | 0,
     newval30 = newval & 1073741823,
     _f_ = s[2];
    caml_check_bound(s[1], _f_)[1 + _f_] = newval30;
    return newval30;
   }
   function intaux(s, n){
    for(;;){
     var r = bits(s), v = caml_mod(r, n);
     if(((1073741823 - n | 0) + 1 | 0) >= (r - v | 0)) return v;
    }
   }
   function int$0(s, bound){
    if(1073741823 >= bound && 0 < bound) return intaux(s, bound);
    return caml_call1(Stdlib[1], cst_Random_int);
   }
   function full_int(s, bound){
    if(0 >= bound) return caml_call1(Stdlib[1], cst_Random_full_int);
    if(1073741823 >= bound) return intaux(s, bound);
    for(;;){
     var b1 = bits(s), b2 = bits(s), max_int_32 = 2147483647;
     if(bound <= 2147483647)
      var
       bpos = (b2 & 1073725440) << 1 | b1 >>> 15 | 0,
       max_int = max_int_32,
       r = bpos;
     else
      var
       b3 = bits(s),
       r$0 = ((b3 & 1073741312) << 12 | b2 >>> 9 | 0) << 20 | b1 >>> 10 | 0,
       max_int$0 = Stdlib[19],
       max_int = max_int$0,
       r = r$0;
     var v = caml_mod(r, bound);
     if(((max_int - bound | 0) + 1 | 0) >= (r - v | 0)) return v;
    }
   }
   function int32(s, bound){
    if(caml_lessequal(bound, 0))
     return caml_call1(Stdlib[1], cst_Random_int32);
    for(;;){
     var
      b1 = bits(s),
      b2 = (bits(s) & 1) << 30,
      r = b1 | b2,
      v = caml_mod(r, bound);
     if(! caml_greaterthan(r - v | 0, (Stdlib_Int32[9] - bound | 0) + 1 | 0))
      return v;
    }
   }
   function int64(s, bound){
    if(caml_lessequal(bound, _b_))
     return caml_call1(Stdlib[1], cst_Random_int64);
    for(;;){
     var
      b1 = caml_int64_of_int32(bits(s)),
      b2 = caml_int64_shift_left(caml_int64_of_int32(bits(s)), 30),
      b3 = caml_int64_shift_left(caml_int64_of_int32(bits(s) & 7), 60),
      r = caml_int64_or(b1, caml_int64_or(b2, b3)),
      v = runtime.caml_int64_mod(r, bound);
     if
      (!
       caml_greaterthan
        (caml_int64_sub(r, v),
         runtime.caml_int64_add(caml_int64_sub(Stdlib_Int64[9], bound), _a_)))
      return v;
    }
   }
   var
    _c_ =
      [0,
       987910699,
       495797812,
       364182224,
       414272206,
       318284740,
       990407751,
       383018966,
       270373319,
       840823159,
       24560019,
       536292337,
       512266505,
       189156120,
       730249596,
       143776328,
       51606627,
       140166561,
       366354223,
       1003410265,
       700563762,
       981890670,
       913149062,
       526082594,
       1021425055,
       784300257,
       667753350,
       630144451,
       949649812,
       48546892,
       415514493,
       258888527,
       511570777,
       89983870,
       283659902,
       308386020,
       242688715,
       482270760,
       865188196,
       1027664170,
       207196989,
       193777847,
       619708188,
       671350186,
       149669678,
       257044018,
       87658204,
       558145612,
       183450813,
       28133145,
       901332182,
       710253903,
       510646120,
       652377910,
       409934019,
       801085050],
    nativeint =
      32 === Stdlib_Nativeint[9]
       ? function(s, bound){return int32(s, bound);}
       : function
        (s, bound){
         return caml_int64_to_int32(int64(s, caml_int64_of_int32(bound)));
        };
   function float$0(s, bound){
    var r1 = bits(s), r2 = bits(s);
    return (r1 / 1073741824. + r2) / 1073741824. * bound;
   }
   function bool(s){return 0 === (bits(s) & 1) ? 1 : 0;}
   function bits32(s){
    var b1 = bits(s) >>> 14 | 0, b2 = bits(s) >>> 14 | 0;
    return b1 | b2 << 16;
   }
   function bits64(s){
    var
     b1 = caml_int64_shift_right_unsigne(caml_int64_of_int32(bits(s)), 9),
     b2 = caml_int64_shift_right_unsigne(caml_int64_of_int32(bits(s)), 9),
     b3 = caml_int64_shift_right_unsigne(caml_int64_of_int32(bits(s)), 8);
    return caml_int64_or
            (b1,
             caml_int64_or
              (caml_int64_shift_left(b2, 21), caml_int64_shift_left(b3, 42)));
   }
   var
    nativebits =
      32 === Stdlib_Nativeint[9]
       ? function(s){return bits32(s);}
       : function(s){return caml_int64_to_int32(bits64(s));},
    default$0 = [0, _c_.slice(), 0];
   function bits$0(param){return bits(default$0);}
   function int$1(bound){return int$0(default$0, bound);}
   function full_int$0(bound){return full_int(default$0, bound);}
   function int32$0(bound){return int32(default$0, bound);}
   function nativeint$0(bound){return nativeint(default$0, bound);}
   function int64$0(bound){return int64(default$0, bound);}
   function float$1(scale){return float$0(default$0, scale);}
   function bool$0(param){return bool(default$0);}
   function bits32$0(param){return bits32(default$0);}
   function bits64$0(param){return bits64(default$0);}
   function nativebits$0(param){return nativebits(default$0);}
   function full_init$0(seed){return full_init(default$0, seed);}
   function init(seed){return full_init(default$0, [0, seed]);}
   function self_init(param){
    var seed = caml_sys_random_seed(0);
    return full_init(default$0, seed);
   }
   function get_state(param){return copy(default$0);}
   function set_state(s){return assign(default$0, s);}
   var
    Stdlib_Random =
      [0,
       init,
       full_init$0,
       self_init,
       bits$0,
       int$1,
       full_int$0,
       int32$0,
       nativeint$0,
       int64$0,
       float$1,
       bool$0,
       bits32$0,
       bits64$0,
       nativebits$0,
       [0,
        make,
        make_self_init,
        copy,
        bits,
        int$0,
        full_int,
        int32,
        nativeint,
        int64,
        float$0,
        bool,
        bits32,
        bits64,
        nativebits],
       get_state,
       set_state];
   runtime.caml_register_global(18, Stdlib_Random, "Stdlib__Random");
   return;
  }
  (globalThis));

//# 17849 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_check_bound = runtime.caml_check_bound,
    caml_compare = runtime.caml_compare,
    caml_hash = runtime.caml_hash,
    caml_make_vect = runtime.caml_make_vect,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_sys_getenv = runtime.caml_sys_getenv,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    _d_ = [0, 0],
    cst = "",
    Stdlib_Sys = global_data.Stdlib__Sys,
    Stdlib = global_data.Stdlib,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Stdlib_Random = global_data.Stdlib__Random,
    Stdlib_Seq = global_data.Stdlib__Seq,
    Stdlib_Int = global_data.Stdlib__Int,
    Stdlib_Array = global_data.Stdlib__Array;
   global_data.Assert_failure;
   var Stdlib_String = global_data.Stdlib__String;
   function ongoing_traversal(h){
    var _aq_ = h.length - 1 < 4 ? 1 : 0, _ar_ = _aq_ || (h[4] < 0 ? 1 : 0);
    return _ar_;
   }
   function flip_ongoing_traversal(h){h[4] = - h[4] | 0; return 0;}
   var
    cst_Hashtbl_unsupported_hash_t = "Hashtbl: unsupported hash table format";
   try{var _f_ = caml_sys_getenv("OCAMLRUNPARAM"), params = _f_;}
   catch(_ao_){
    var _a_ = caml_wrap_exception(_ao_);
    if(_a_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_a_, 0);
    try{var _e_ = caml_sys_getenv("CAMLRUNPARAM"), _c_ = _e_;}
    catch(_ap_){
     var _b_ = caml_wrap_exception(_ap_);
     if(_b_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_b_, 0);
     var _c_ = cst;
    }
    var params = _c_;
   }
   var
    randomized_default = caml_call2(Stdlib_String[14], params, 82),
    randomized = [0, randomized_default];
   function randomize(param){randomized[1] = 1; return 0;}
   function is_randomized(param){return randomized[1];}
   var
    prng = [246, function(_an_){return caml_call1(Stdlib_Random[15][2], 0);}];
   function power_2_above(x, n){
    var x$0 = x;
    for(;;){
     if(n <= x$0) return x$0;
     if(Stdlib_Sys[13] < (x$0 * 2 | 0)) return x$0;
     var x$1 = x$0 * 2 | 0;
     x$0 = x$1;
    }
   }
   function create(opt, initial_size){
    if(opt) var sth = opt[1], random = sth; else var random = randomized[1];
    var s = power_2_above(16, initial_size);
    if(random)
     var
      _al_ = caml_obj_tag(prng),
      _am_ =
        250 === _al_
         ? prng[1]
         : 246 === _al_ ? caml_call1(CamlinternalLazy[2], prng) : prng,
      seed = caml_call1(Stdlib_Random[15][4], _am_);
    else
     var seed = 0;
    return [0, 0, caml_make_vect(s, 0), seed, s];
   }
   function clear(h){
    var _ak_ = 0 < h[1] ? 1 : 0;
    return _ak_
            ? (h
               [1]
              = 0,
              caml_call4(Stdlib_Array[9], h[2], 0, h[2].length - 1, 0))
            : _ak_;
   }
   function reset(h){
    var len = h[2].length - 1;
    if(4 <= h.length - 1 && len !== caml_call1(Stdlib[18], h[4])){
     h[1] = 0;
     h[2] = caml_make_vect(caml_call1(Stdlib[18], h[4]), 0);
     return 0;
    }
    return clear(h);
   }
   function copy_bucketlist(param){
    if(! param) return 0;
    var
     key = param[1],
     data = param[2],
     next = param[3],
     prec$1 = [0, key, data, next],
     prec = prec$1,
     param$0 = next;
    for(;;){
     if(! param$0) return prec$1;
     var
      key$0 = param$0[1],
      data$0 = param$0[2],
      next$0 = param$0[3],
      prec$0 = [0, key$0, data$0, next$0];
     prec[3] = prec$0;
     prec = prec$0;
     param$0 = next$0;
    }
   }
   function copy(h){
    var
     _ah_ = h[4],
     _ai_ = h[3],
     _aj_ = caml_call2(Stdlib_Array[15], copy_bucketlist, h[2]);
    return [0, h[1], _aj_, _ai_, _ah_];
   }
   function length(h){return h[1];}
   function insert_all_buckets(indexfun, inplace, odata, ndata){
    var
     nsize = ndata.length - 1,
     ndata_tail = caml_make_vect(nsize, 0),
     _ab_ = odata.length - 2 | 0,
     _aa_ = 0;
    if(_ab_ >= 0){
     var i$0 = _aa_;
     for(;;){
      var cell$1 = caml_check_bound(odata, i$0)[1 + i$0], cell = cell$1;
      for(;;){
       if(! cell) break;
       var
        key = cell[1],
        data = cell[2],
        next = cell[3],
        cell$0 = inplace ? cell : [0, key, data, 0],
        nidx = caml_call1(indexfun, key),
        match = caml_check_bound(ndata_tail, nidx)[1 + nidx];
       if(match)
        match[3] = cell$0;
       else
        caml_check_bound(ndata, nidx)[1 + nidx] = cell$0;
       caml_check_bound(ndata_tail, nidx)[1 + nidx] = cell$0;
       cell = next;
      }
      var _ag_ = i$0 + 1 | 0;
      if(_ab_ === i$0) break;
      i$0 = _ag_;
     }
    }
    if(inplace){
     var _ad_ = nsize - 1 | 0, _ac_ = 0;
     if(_ad_ >= 0){
      var i = _ac_;
      for(;;){
       var match$0 = caml_check_bound(ndata_tail, i)[1 + i];
       if(match$0) match$0[3] = 0;
       var _af_ = i + 1 | 0;
       if(_ad_ === i) break;
       i = _af_;
      }
     }
     var _ae_ = 0;
    }
    else
     var _ae_ = inplace;
    return _ae_;
   }
   function resize(indexfun, h){
    var
     odata = h[2],
     osize = odata.length - 1,
     nsize = osize * 2 | 0,
     _$_ = nsize < Stdlib_Sys[13] ? 1 : 0;
    if(! _$_) return _$_;
    var ndata = caml_make_vect(nsize, 0), inplace = 1 - ongoing_traversal(h);
    h[2] = ndata;
    return insert_all_buckets(caml_call1(indexfun, h), inplace, odata, ndata);
   }
   function iter(f, h){
    var old_trav = ongoing_traversal(h);
    if(1 - old_trav) flip_ongoing_traversal(h);
    try{
     var d = h[2], _X_ = d.length - 2 | 0, _W_ = 0;
     if(_X_ >= 0){
      var i = _W_;
      for(;;){
       var param = caml_check_bound(d, i)[1 + i];
       for(;;){
        if(! param) break;
        var key = param[1], data = param[2], next = param[3];
        caml_call2(f, key, data);
        param = next;
       }
       var ___ = i + 1 | 0;
       if(_X_ === i) break;
       i = ___;
      }
     }
     var _Y_ = 1 - old_trav, _Z_ = _Y_ ? flip_ongoing_traversal(h) : _Y_;
     return _Z_;
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(old_trav) throw caml_maybe_attach_backtrace(exn, 0);
     flip_ongoing_traversal(h);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function filter_map_inplace(f, h){
    var d = h[2], old_trav = ongoing_traversal(h);
    if(1 - old_trav) flip_ongoing_traversal(h);
    try{
     var _S_ = d.length - 2 | 0, _R_ = 0;
     if(_S_ >= 0){
      var i = _R_;
      for(;;){
       var slot$0 = caml_check_bound(h[2], i)[1 + i], prec = 0, slot = slot$0;
       for(;;){
        if(! slot) break;
        var
         key = slot[1],
         data = slot[2],
         next = slot[3],
         match = caml_call2(f, key, data);
        if(match){
         var data$0 = match[1];
         if(prec)
          prec[3] = slot;
         else
          caml_check_bound(h[2], i)[1 + i] = slot;
         slot[2] = data$0;
         prec = slot;
         slot = next;
        }
        else{h[1] = h[1] - 1 | 0; slot = next;}
       }
       if(prec) prec[3] = 0; else caml_check_bound(h[2], i)[1 + i] = 0;
       var _V_ = i + 1 | 0;
       if(_S_ === i) break;
       i = _V_;
      }
     }
     var _T_ = 1 - old_trav, _U_ = _T_ ? flip_ongoing_traversal(h) : _T_;
     return _U_;
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(old_trav) throw caml_maybe_attach_backtrace(exn, 0);
     flip_ongoing_traversal(h);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function fold(f, h, init){
    var old_trav = ongoing_traversal(h);
    if(1 - old_trav) flip_ongoing_traversal(h);
    try{
     var d = h[2], accu$1 = [0, init], _O_ = d.length - 2 | 0, _N_ = 0;
     if(_O_ >= 0){
      var i = _N_;
      for(;;){
       var
        accu$2 = accu$1[1],
        b$0 = caml_check_bound(d, i)[1 + i],
        b = b$0,
        accu = accu$2;
       for(;;){
        if(! b) break;
        var
         key = b[1],
         data = b[2],
         next = b[3],
         accu$0 = caml_call3(f, key, data, accu);
        b = next;
        accu = accu$0;
       }
       accu$1[1] = accu;
       var _Q_ = i + 1 | 0;
       if(_O_ === i) break;
       i = _Q_;
      }
     }
     if(1 - old_trav) flip_ongoing_traversal(h);
     var _P_ = accu$1[1];
     return _P_;
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(old_trav) throw caml_maybe_attach_backtrace(exn, 0);
     flip_ongoing_traversal(h);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function bucket_length(accu, param){
    var accu$0 = accu, param$0 = param;
    for(;;){
     if(! param$0) return accu$0;
     var next = param$0[3], accu$1 = accu$0 + 1 | 0;
     accu$0 = accu$1;
     param$0 = next;
    }
   }
   function stats(h){
    var
     mbl =
       caml_call3
        (Stdlib_Array[17],
         function(m, b){
          var _M_ = bucket_length(0, b);
          return caml_call2(Stdlib_Int[11], m, _M_);
         },
         0,
         h[2]),
     histo = caml_make_vect(mbl + 1 | 0, 0);
    caml_call2
     (Stdlib_Array[13],
      function(b){
       var l = bucket_length(0, b);
       histo[1 + l] = caml_check_bound(histo, l)[1 + l] + 1 | 0;
       return 0;
      },
      h[2]);
    return [0, h[1], h[2].length - 1, mbl, histo];
   }
   function to_seq(tbl){
    var tbl_data = tbl[2];
    function aux(i, buck, param){
     var i$0 = i, buck$0 = buck;
     for(;;){
      if(buck$0){
       var key = buck$0[1], data = buck$0[2], next = buck$0[3];
       return [0, [0, key, data], function(_L_){return aux(i$0, next, _L_);}];
      }
      if(i$0 === tbl_data.length - 1) return 0;
      var
       buck$1 = caml_check_bound(tbl_data, i$0)[1 + i$0],
       i$1 = i$0 + 1 | 0;
      i$0 = i$1;
      buck$0 = buck$1;
     }
    }
    var _I_ = 0, _J_ = 0;
    return function(_K_){return aux(_J_, _I_, _K_);};
   }
   function to_seq_keys(m){
    var _G_ = to_seq(m);
    return caml_call2(Stdlib_Seq[27], function(_H_){return _H_[1];}, _G_);
   }
   function to_seq_values(m){
    var _E_ = to_seq(m);
    return caml_call2(Stdlib_Seq[27], function(_F_){return _F_[2];}, _E_);
   }
   function MakeSeeded(H){
    function key_index(h, key){
     var _D_ = h[2].length - 2 | 0;
     return caml_call2(H[2], h[3], key) & _D_;
    }
    function add(h, key, data){
     var
      i = key_index(h, key),
      bucket = [0, key, data, caml_check_bound(h[2], i)[1 + i]];
     caml_check_bound(h[2], i)[1 + i] = bucket;
     h[1] = h[1] + 1 | 0;
     var _C_ = h[2].length - 1 << 1 < h[1] ? 1 : 0;
     return _C_ ? resize(key_index, h) : _C_;
    }
    function remove(h, key){
     var
      i = key_index(h, key),
      c = caml_check_bound(h[2], i)[1 + i],
      prec$0 = 0,
      prec = c;
     for(;;){
      if(! prec) return 0;
      var k = prec[1], next = prec[3];
      if(caml_call2(H[1], k, key)){
       h[1] = h[1] - 1 | 0;
       return prec$0
               ? (prec$0[3] = next, 0)
               : (caml_check_bound(h[2], i)[1 + i] = next, 0);
      }
      prec$0 = prec;
      prec = next;
     }
    }
    function find(h, key){
     var
      _B_ = key_index(h, key),
      match = caml_check_bound(h[2], _B_)[1 + _B_];
     if(! match) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     var k1 = match[1], d1 = match[2], next1 = match[3];
     if(caml_call2(H[1], key, k1)) return d1;
     if(! next1) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     var k2 = next1[1], d2 = next1[2], next2 = next1[3];
     if(caml_call2(H[1], key, k2)) return d2;
     if(! next2) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     var k3 = next2[1], d3 = next2[2], next3 = next2[3];
     if(caml_call2(H[1], key, k3)) return d3;
     var param = next3;
     for(;;){
      if(! param) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
      var k = param[1], data = param[2], next = param[3];
      if(caml_call2(H[1], key, k)) return data;
      param = next;
     }
    }
    function find_opt(h, key){
     var
      _A_ = key_index(h, key),
      match = caml_check_bound(h[2], _A_)[1 + _A_];
     if(! match) return 0;
     var k1 = match[1], d1 = match[2], next1 = match[3];
     if(caml_call2(H[1], key, k1)) return [0, d1];
     if(! next1) return 0;
     var k2 = next1[1], d2 = next1[2], next2 = next1[3];
     if(caml_call2(H[1], key, k2)) return [0, d2];
     if(! next2) return 0;
     var k3 = next2[1], d3 = next2[2], next3 = next2[3];
     if(caml_call2(H[1], key, k3)) return [0, d3];
     var param = next3;
     for(;;){
      if(! param) return 0;
      var k = param[1], data = param[2], next = param[3];
      if(caml_call2(H[1], key, k)) return [0, data];
      param = next;
     }
    }
    function find_all(h, key){
     function find_in_bucket(param){
      var param$0 = param;
      for(;;){
       if(! param$0) return 0;
       var k = param$0[1], d = param$0[2], next = param$0[3];
       if(caml_call2(H[1], k, key)) return [0, d, find_in_bucket(next)];
       param$0 = next;
      }
     }
     var _z_ = key_index(h, key);
     return find_in_bucket(caml_check_bound(h[2], _z_)[1 + _z_]);
    }
    function replace(h, key, data){
     var
      i = key_index(h, key),
      l = caml_check_bound(h[2], i)[1 + i],
      slot = l;
     for(;;){
      if(slot){
       var k = slot[1], next = slot[3];
       if(! caml_call2(H[1], k, key)){slot = next; continue;}
       slot[1] = key;
       slot[2] = data;
       var _w_ = 0;
      }
      else
       var _w_ = 1;
      if(_w_){
       caml_check_bound(h[2], i)[1 + i] = [0, key, data, l];
       h[1] = h[1] + 1 | 0;
       var _x_ = h[2].length - 1 << 1 < h[1] ? 1 : 0;
       if(_x_) return resize(key_index, h);
       var _y_ = _x_;
      }
      else
       var _y_ = _w_;
      return _y_;
     }
    }
    function mem(h, key){
     var
      _v_ = key_index(h, key),
      param = caml_check_bound(h[2], _v_)[1 + _v_];
     for(;;){
      if(! param) return 0;
      var k = param[1], next = param[3], _u_ = caml_call2(H[1], k, key);
      if(_u_) return _u_;
      param = next;
     }
    }
    function add_seq(tbl, i){
     return caml_call2
             (Stdlib_Seq[4],
              function(param){
               var v = param[2], k = param[1];
               return add(tbl, k, v);
              },
              i);
    }
    function replace_seq(tbl, i){
     return caml_call2
             (Stdlib_Seq[4],
              function(param){
               var v = param[2], k = param[1];
               return replace(tbl, k, v);
              },
              i);
    }
    function of_seq(i){
     var tbl = create(0, 16);
     replace_seq(tbl, i);
     return tbl;
    }
    return [0,
            create,
            clear,
            reset,
            copy,
            add,
            remove,
            find,
            find_opt,
            find_all,
            replace,
            mem,
            iter,
            filter_map_inplace,
            fold,
            length,
            stats,
            to_seq,
            to_seq_keys,
            to_seq_values,
            add_seq,
            replace_seq,
            of_seq];
   }
   function Make(H){
    var equal = H[1];
    function hash(seed, x){return caml_call1(H[2], x);}
    var
     include = MakeSeeded([0, equal, hash]),
     _t_ = include[1],
     clear = include[2],
     reset = include[3],
     copy = include[4],
     add = include[5],
     remove = include[6],
     find = include[7],
     find_opt = include[8],
     find_all = include[9],
     replace = include[10],
     mem = include[11],
     iter = include[12],
     filter_map_inplace = include[13],
     fold = include[14],
     length = include[15],
     stats = include[16],
     to_seq = include[17],
     to_seq_keys = include[18],
     to_seq_values = include[19],
     add_seq = include[20],
     replace_seq = include[21];
    function create(sz){return caml_call2(_t_, _d_, sz);}
    function of_seq(i){
     var tbl = caml_call2(_t_, _d_, 16);
     caml_call2(replace_seq, tbl, i);
     return tbl;
    }
    return [0,
            create,
            clear,
            reset,
            copy,
            add,
            remove,
            find,
            find_opt,
            find_all,
            replace,
            mem,
            iter,
            filter_map_inplace,
            fold,
            length,
            stats,
            to_seq,
            to_seq_keys,
            to_seq_values,
            add_seq,
            replace_seq,
            of_seq];
   }
   function hash(x){return caml_hash(10, 100, 0, x);}
   function hash_param(n1, n2, x){return caml_hash(n1, n2, 0, x);}
   function seeded_hash(seed, x){return caml_hash(10, 100, seed, x);}
   function key_index(h, key){
    return 4 <= h.length - 1
            ? caml_hash(10, 100, h[3], key) & (h[2].length - 2 | 0)
            : caml_call1(Stdlib[1], cst_Hashtbl_unsupported_hash_t);
   }
   function add(h, key, data){
    var
     i = key_index(h, key),
     bucket = [0, key, data, caml_check_bound(h[2], i)[1 + i]];
    caml_check_bound(h[2], i)[1 + i] = bucket;
    h[1] = h[1] + 1 | 0;
    var _s_ = h[2].length - 1 << 1 < h[1] ? 1 : 0;
    return _s_ ? resize(key_index, h) : _s_;
   }
   function remove(h, key){
    var
     i = key_index(h, key),
     c = caml_check_bound(h[2], i)[1 + i],
     prec$0 = 0,
     prec = c;
    for(;;){
     if(! prec) return 0;
     var k = prec[1], next = prec[3];
     if(0 === caml_compare(k, key)){
      h[1] = h[1] - 1 | 0;
      return prec$0
              ? (prec$0[3] = next, 0)
              : (caml_check_bound(h[2], i)[1 + i] = next, 0);
     }
     prec$0 = prec;
     prec = next;
    }
   }
   function find(h, key){
    var _r_ = key_index(h, key), match = caml_check_bound(h[2], _r_)[1 + _r_];
    if(! match) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
    var k1 = match[1], d1 = match[2], next1 = match[3];
    if(0 === caml_compare(key, k1)) return d1;
    if(! next1) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
    var k2 = next1[1], d2 = next1[2], next2 = next1[3];
    if(0 === caml_compare(key, k2)) return d2;
    if(! next2) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
    var k3 = next2[1], d3 = next2[2], next3 = next2[3];
    if(0 === caml_compare(key, k3)) return d3;
    var param = next3;
    for(;;){
     if(! param) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     var k = param[1], data = param[2], next = param[3];
     if(0 === caml_compare(key, k)) return data;
     param = next;
    }
   }
   function find_opt(h, key){
    var _q_ = key_index(h, key), match = caml_check_bound(h[2], _q_)[1 + _q_];
    if(! match) return 0;
    var k1 = match[1], d1 = match[2], next1 = match[3];
    if(0 === caml_compare(key, k1)) return [0, d1];
    if(! next1) return 0;
    var k2 = next1[1], d2 = next1[2], next2 = next1[3];
    if(0 === caml_compare(key, k2)) return [0, d2];
    if(! next2) return 0;
    var k3 = next2[1], d3 = next2[2], next3 = next2[3];
    if(0 === caml_compare(key, k3)) return [0, d3];
    var param = next3;
    for(;;){
     if(! param) return 0;
     var k = param[1], data = param[2], next = param[3];
     if(0 === caml_compare(key, k)) return [0, data];
     param = next;
    }
   }
   function find_all(h, key){
    function find_in_bucket(param){
     var param$0 = param;
     for(;;){
      if(! param$0) return 0;
      var k = param$0[1], data = param$0[2], next = param$0[3];
      if(0 === caml_compare(k, key)) return [0, data, find_in_bucket(next)];
      param$0 = next;
     }
    }
    var _p_ = key_index(h, key);
    return find_in_bucket(caml_check_bound(h[2], _p_)[1 + _p_]);
   }
   function replace(h, key, data){
    var i = key_index(h, key), l = caml_check_bound(h[2], i)[1 + i], slot = l;
    for(;;){
     if(slot){
      var k = slot[1], next = slot[3];
      if(0 !== caml_compare(k, key)){slot = next; continue;}
      slot[1] = key;
      slot[2] = data;
      var _m_ = 0;
     }
     else
      var _m_ = 1;
     if(_m_){
      caml_check_bound(h[2], i)[1 + i] = [0, key, data, l];
      h[1] = h[1] + 1 | 0;
      var _n_ = h[2].length - 1 << 1 < h[1] ? 1 : 0;
      if(_n_) return resize(key_index, h);
      var _o_ = _n_;
     }
     else
      var _o_ = _m_;
     return _o_;
    }
   }
   function mem(h, key){
    var _l_ = key_index(h, key), param = caml_check_bound(h[2], _l_)[1 + _l_];
    for(;;){
     if(! param) return 0;
     var
      k = param[1],
      next = param[3],
      _k_ = 0 === caml_compare(k, key) ? 1 : 0;
     if(_k_) return _k_;
     param = next;
    }
   }
   function add_seq(tbl, i){
    return caml_call2
            (Stdlib_Seq[4],
             function(param){
              var v = param[2], k = param[1];
              return add(tbl, k, v);
             },
             i);
   }
   function replace_seq(tbl, i){
    return caml_call2
            (Stdlib_Seq[4],
             function(param){
              var v = param[2], k = param[1];
              return replace(tbl, k, v);
             },
             i);
   }
   function of_seq(i){
    var tbl = create(0, 16);
    replace_seq(tbl, i);
    return tbl;
   }
   function rebuild(opt, h){
    if(opt) var sth = opt[1], random = sth; else var random = randomized[1];
    var s = power_2_above(16, h[2].length - 1);
    if(random)
     var
      _g_ = caml_obj_tag(prng),
      _h_ =
        250 === _g_
         ? prng[1]
         : 246 === _g_ ? caml_call1(CamlinternalLazy[2], prng) : prng,
      seed = caml_call1(Stdlib_Random[15][4], _h_);
    else
     var seed = 4 <= h.length - 1 ? h[3] : 0;
    var
     _i_ = 4 <= h.length - 1 ? h[4] : s,
     h$0 = [0, h[1], caml_make_vect(s, 0), seed, _i_];
    insert_all_buckets
     (function(_j_){return key_index(h$0, _j_);}, 0, h[2], h$0[2]);
    return h$0;
   }
   var
    Stdlib_Hashtbl =
      [0,
       create,
       clear,
       reset,
       copy,
       add,
       find,
       find_opt,
       find_all,
       mem,
       remove,
       replace,
       iter,
       filter_map_inplace,
       fold,
       length,
       randomize,
       is_randomized,
       rebuild,
       stats,
       to_seq,
       to_seq_keys,
       to_seq_values,
       add_seq,
       replace_seq,
       of_seq,
       Make,
       MakeSeeded,
       hash,
       seeded_hash,
       hash_param,
       caml_hash];
   runtime.caml_register_global(15, Stdlib_Hashtbl, "Stdlib__Hashtbl");
   return;
  }
  (globalThis));

//# 18661 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_check_bound = runtime.caml_check_bound,
    caml_make_vect = runtime.caml_make_vect,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_mod = runtime.caml_mod;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Stdlib_Sys = global_data.Stdlib__Sys,
    Stdlib_Int = global_data.Stdlib__Int,
    Stdlib_Array = global_data.Stdlib__Array,
    Stdlib_Obj = global_data.Stdlib__Obj,
    cst_Weak_create = "Weak.create",
    cst_Weak_set = "Weak.set",
    cst_Weak_get = "Weak.get",
    cst_Weak_get_copy = "Weak.get_copy",
    cst_Weak_check = "Weak.check",
    cst_Weak_blit = "Weak.blit",
    cst_Weak_fill = "Weak.fill",
    cst_Weak_Make_hash_bucket_cann = "Weak.Make: hash bucket cannot grow more";
   function create(l){
    var
     _J_ = 0 <= l ? 1 : 0,
     _K_ = _J_ ? l <= Stdlib_Obj[26][15] ? 1 : 0 : _J_;
    if(1 - _K_) caml_call1(Stdlib[1], cst_Weak_create);
    return runtime.caml_weak_create(l);
   }
   function length(x){return x.length - 3 | 0;}
   function raise_if_invalid_offset(e, o, msg){
    var
     _G_ = 0 <= o ? 1 : 0,
     _H_ = _G_ ? o < length(e) ? 1 : 0 : _G_,
     _I_ = 1 - _H_;
    return _I_ ? caml_call1(Stdlib[1], msg) : _I_;
   }
   function set(e, o, x){
    raise_if_invalid_offset(e, o, cst_Weak_set);
    if(! x) return runtime.caml_ephe_unset_key(e, o);
    var x$0 = x[1];
    return runtime.caml_ephe_set_key(e, o, x$0);
   }
   function get(e, o){
    raise_if_invalid_offset(e, o, cst_Weak_get);
    return runtime.caml_ephe_get_key(e, o);
   }
   function get_copy(e, o){
    raise_if_invalid_offset(e, o, cst_Weak_get_copy);
    return runtime.caml_ephe_get_key_copy(e, o);
   }
   function check(e, o){
    raise_if_invalid_offset(e, o, cst_Weak_check);
    return runtime.caml_ephe_check_key(e, o);
   }
   function blit(e1, o1, e2, o2, l){
    if
     (0 <= l
      &&
       0 <= o1
       && (length(e1) - l | 0) >= o1 && 0 <= o2 && (length(e2) - l | 0) >= o2){
     var
      _E_ = 0 !== l ? 1 : 0,
      _F_ = _E_ ? runtime.caml_ephe_blit_key(e1, o1, e2, o2, l) : _E_;
     return _F_;
    }
    return caml_call1(Stdlib[1], cst_Weak_blit);
   }
   function fill(ar, ofs, len, x){
    if(0 <= ofs && 0 <= len && (length(ar) - len | 0) >= ofs){
     var _C_ = (ofs + len | 0) - 1 | 0;
     if(_C_ >= ofs){
      var i = ofs;
      for(;;){
       set(ar, i, x);
       var _D_ = i + 1 | 0;
       if(_C_ === i) break;
       i = _D_;
      }
     }
     return 0;
    }
    throw caml_maybe_attach_backtrace([0, Stdlib[6], cst_Weak_fill], 1);
   }
   function Make(H){
    var emptybucket = create(0);
    function get_index(t, h){
     return caml_mod(h & Stdlib[19], t[1].length - 1);
    }
    var limit = 7;
    function create$0(sz){
     var
      sz$0 = 7 <= sz ? sz : 7,
      sz$1 = Stdlib_Sys[13] < sz$0 ? Stdlib_Sys[13] : sz$0;
     return [0,
             caml_make_vect(sz$1, emptybucket),
             caml_make_vect(sz$1, [0]),
             limit,
             0,
             0];
    }
    function clear(t){
     var _A_ = t[1].length - 2 | 0, _z_ = 0;
     if(_A_ >= 0){
      var i = _z_;
      for(;;){
       caml_check_bound(t[1], i)[1 + i] = emptybucket;
       caml_check_bound(t[2], i)[1 + i] = [0];
       var _B_ = i + 1 | 0;
       if(_A_ === i) break;
       i = _B_;
      }
     }
     t[3] = limit;
     t[4] = 0;
     return 0;
    }
    function fold(f, t, init){
     var i = 0;
     return caml_call3
             (Stdlib_Array[19],
              function(b, accu$1){
               var i$0 = i, accu = accu$1;
               for(;;){
                if(length(b) <= i$0) return accu;
                var match = get(b, i$0);
                if(match){
                 var
                  v = match[1],
                  accu$0 = caml_call2(f, v, accu),
                  i$1 = i$0 + 1 | 0;
                 i$0 = i$1;
                 accu = accu$0;
                }
                else{var i$2 = i$0 + 1 | 0; i$0 = i$2;}
               }
              },
              t[1],
              init);
    }
    function iter(f, t){
     var i = 0;
     return caml_call2
             (Stdlib_Array[13],
              function(b){
               var i$0 = i;
               for(;;){
                if(length(b) <= i$0) return 0;
                var match = get(b, i$0);
                if(match){
                 var v = match[1];
                 caml_call1(f, v);
                 var i$1 = i$0 + 1 | 0;
                 i$0 = i$1;
                }
                else{var i$2 = i$0 + 1 | 0; i$0 = i$2;}
               }
              },
              t[1]);
    }
    function count_bucket(i, b, accu){
     var i$0 = i, accu$0 = accu;
     for(;;){
      if(length(b) <= i$0) return accu$0;
      var
       _y_ = check(b, i$0) ? 1 : 0,
       accu$1 = accu$0 + _y_ | 0,
       i$1 = i$0 + 1 | 0;
      i$0 = i$1;
      accu$0 = accu$1;
     }
    }
    function count(t){
     var _v_ = 0;
     return caml_call3
             (Stdlib_Array[19],
              function(_w_, _x_){return count_bucket(_v_, _w_, _x_);},
              t[1],
              0);
    }
    function add_aux(t, setter, d, h, index){
     var
      bucket$0 = caml_check_bound(t[1], index)[1 + index],
      hashes = caml_check_bound(t[2], index)[1 + index],
      sz = length(bucket$0),
      i$3 = 0;
     for(;;){
      if(sz <= i$3) break;
      if(! check(bucket$0, i$3)){
       caml_call3(setter, bucket$0, i$3, d);
       caml_check_bound(hashes, i$3)[1 + i$3] = h;
       return 0;
      }
      var i$5 = i$3 + 1 | 0;
      i$3 = i$5;
     }
     var
      newsz =
        caml_call2
         (Stdlib_Int[10],
          ((3 * sz | 0) / 2 | 0) + 3 | 0,
          Stdlib_Sys[13] - 2 | 0);
     if(newsz <= sz) caml_call1(Stdlib[2], cst_Weak_Make_hash_bucket_cann);
     var newbucket$0 = create(newsz), newhashes = caml_make_vect(newsz, 0);
     blit(bucket$0, 0, newbucket$0, 0, sz);
     caml_call5(Stdlib_Array[10], hashes, 0, newhashes, 0, sz);
     caml_call3(setter, newbucket$0, sz, d);
     caml_check_bound(newhashes, sz)[1 + sz] = h;
     caml_check_bound(t[1], index)[1 + index] = newbucket$0;
     caml_check_bound(t[2], index)[1 + index] = newhashes;
     var _r_ = sz <= t[3] ? 1 : 0, _s_ = _r_ ? t[3] < newsz ? 1 : 0 : _r_;
     if(_s_){
      t[4] = t[4] + 1 | 0;
      var i$4 = 0;
      for(;;){
       var
        _h_ = t[5],
        bucket = caml_check_bound(t[1], _h_)[1 + _h_],
        _i_ = t[5],
        hbucket = caml_check_bound(t[2], _i_)[1 + _i_],
        len = length(bucket),
        prev_len = (((len - 3 | 0) * 2 | 0) + 2 | 0) / 3 | 0,
        live = count_bucket(0, bucket, 0);
       if(live <= prev_len){
        var j$2 = length(bucket) - 1 | 0, i$0 = 0, j = j$2;
        for(;;){
         if(prev_len > j) break;
         if(check(bucket, i$0)){
          var i$1 = i$0 + 1 | 0;
          i$0 = i$1;
         }
         else if(check(bucket, j)){
          blit(bucket, j, bucket, i$0, 1);
          var _j_ = caml_check_bound(hbucket, j)[1 + j];
          caml_check_bound(hbucket, i$0)[1 + i$0] = _j_;
          var j$0 = j - 1 | 0, i$2 = i$0 + 1 | 0;
          i$0 = i$2;
          j = j$0;
         }
         else{var j$1 = j - 1 | 0; j = j$1;}
        }
        if(0 === prev_len){
         var _k_ = t[5];
         caml_check_bound(t[1], _k_)[1 + _k_] = emptybucket;
         var _l_ = t[5];
         caml_check_bound(t[2], _l_)[1 + _l_] = [0];
        }
        else{
         var newbucket = create(prev_len);
         blit(bucket, 0, newbucket, 0, prev_len);
         var _o_ = t[5];
         caml_check_bound(t[1], _o_)[1 + _o_] = newbucket;
         var
          _p_ = caml_call3(Stdlib_Array[7], hbucket, 0, prev_len),
          _q_ = t[5];
         caml_check_bound(t[2], _q_)[1 + _q_] = _p_;
        }
        var
         _m_ = t[3] < len ? 1 : 0,
         _n_ = _m_ ? prev_len <= t[3] ? 1 : 0 : _m_;
        if(_n_) t[4] = t[4] - 1 | 0;
       }
       t[5] = caml_mod(t[5] + 1 | 0, t[1].length - 1);
       var _u_ = i$4 + 1 | 0;
       if(2 === i$4) break;
       i$4 = _u_;
      }
     }
     var _t_ = ((t[1].length - 1) / 2 | 0) < t[4] ? 1 : 0;
     if(! _t_) return _t_;
     var
      oldlen = t[1].length - 1,
      newlen =
        caml_call2
         (Stdlib_Int[10], ((3 * oldlen | 0) / 2 | 0) + 3 | 0, Stdlib_Sys[13]);
     if(oldlen < newlen){
      var newt = create$0(newlen), i = 0;
      caml_call2
       (Stdlib_Array[14],
        function(j, ob){
         var oi = i;
         for(;;){
          if(length(ob) <= oi) return 0;
          if(check(ob, oi)){
           var oh = caml_check_bound(t[2], j)[1 + j];
           let oi$0 = oi;
           var
            setter =
              function(nb, ni, param){return blit(ob, oi$0, nb, ni, 1);},
            h = caml_check_bound(oh, oi)[1 + oi];
           add_aux(newt, setter, 0, h, get_index(newt, h));
           var i$0 = oi + 1 | 0;
           oi = i$0;
          }
          else{var i$1 = oi + 1 | 0; oi = i$1;}
         }
        },
        t[1]);
      t[1] = newt[1];
      t[2] = newt[2];
      t[3] = newt[3];
      t[4] = newt[4];
      t[5] = caml_mod(t[5], newt[1].length - 1);
      return 0;
     }
     t[3] = Stdlib[19];
     t[4] = 0;
     return 0;
    }
    function add(t, d){
     var h = caml_call1(H[2], d);
     return add_aux(t, set, [0, d], h, get_index(t, h));
    }
    function find_or(t, d, ifnotfound){
     var
      h = caml_call1(H[2], d),
      index = get_index(t, h),
      bucket = caml_check_bound(t[1], index)[1 + index],
      hashes = caml_check_bound(t[2], index)[1 + index],
      sz = length(bucket),
      i = 0;
     for(;;){
      if(sz <= i) return caml_call2(ifnotfound, h, index);
      if(h === caml_check_bound(hashes, i)[1 + i]){
       var match = get_copy(bucket, i);
       if(match){
        var v = match[1];
        if(caml_call2(H[1], v, d)){
         var match$0 = get(bucket, i);
         if(match$0){var v$0 = match$0[1]; return v$0;}
         var i$0 = i + 1 | 0;
         i = i$0;
         continue;
        }
       }
       var i$1 = i + 1 | 0;
       i = i$1;
      }
      else{var i$2 = i + 1 | 0; i = i$2;}
     }
    }
    function merge(t, d){
     return find_or
             (t,
              d,
              function(h, index){add_aux(t, set, [0, d], h, index); return d;});
    }
    function find(t, d){
     return find_or
             (t,
              d,
              function(h, index){
               throw caml_maybe_attach_backtrace(Stdlib[8], 1);
              });
    }
    function find_opt(t, d){
     var
      h = caml_call1(H[2], d),
      index = get_index(t, h),
      bucket = caml_check_bound(t[1], index)[1 + index],
      hashes = caml_check_bound(t[2], index)[1 + index],
      sz = length(bucket),
      i = 0;
     for(;;){
      if(sz <= i) return 0;
      if(h === caml_check_bound(hashes, i)[1 + i]){
       var match = get_copy(bucket, i);
       if(match){
        var v = match[1];
        if(caml_call2(H[1], v, d)){
         var v$0 = get(bucket, i);
         if(v$0) return v$0;
         var i$0 = i + 1 | 0;
         i = i$0;
         continue;
        }
       }
       var i$1 = i + 1 | 0;
       i = i$1;
      }
      else{var i$2 = i + 1 | 0; i = i$2;}
     }
    }
    function find_shadow(t, d, iffound, ifnotfound){
     var
      h = caml_call1(H[2], d),
      index = get_index(t, h),
      bucket = caml_check_bound(t[1], index)[1 + index],
      hashes = caml_check_bound(t[2], index)[1 + index],
      sz = length(bucket),
      i = 0;
     for(;;){
      if(sz <= i) return ifnotfound;
      if(h === caml_check_bound(hashes, i)[1 + i]){
       var match = get_copy(bucket, i);
       if(match){
        var v = match[1];
        if(caml_call2(H[1], v, d)) return caml_call2(iffound, bucket, i);
       }
       var i$0 = i + 1 | 0;
       i = i$0;
      }
      else{var i$1 = i + 1 | 0; i = i$1;}
     }
    }
    function remove(t, d){
     return find_shadow(t, d, function(w, i){return set(w, i, 0);}, 0);
    }
    function mem(t, d){
     return find_shadow(t, d, function(w, i){return 1;}, 0);
    }
    function find_all(t, d){
     var
      h = caml_call1(H[2], d),
      index = get_index(t, h),
      bucket = caml_check_bound(t[1], index)[1 + index],
      hashes = caml_check_bound(t[2], index)[1 + index],
      sz = length(bucket),
      i = 0,
      accu = 0;
     for(;;){
      if(sz <= i) return accu;
      if(h === caml_check_bound(hashes, i)[1 + i]){
       var match = get_copy(bucket, i);
       if(match){
        var v = match[1];
        if(caml_call2(H[1], v, d)){
         var match$0 = get(bucket, i);
         if(match$0){
          var v$0 = match$0[1], accu$0 = [0, v$0, accu], i$0 = i + 1 | 0;
          i = i$0;
          accu = accu$0;
          continue;
         }
         var i$1 = i + 1 | 0;
         i = i$1;
         continue;
        }
       }
       var i$2 = i + 1 | 0;
       i = i$2;
      }
      else{var i$3 = i + 1 | 0; i = i$3;}
     }
    }
    function stats(t){
     var
      len = t[1].length - 1,
      lens = caml_call2(Stdlib_Array[15], length, t[1]);
     caml_call2(Stdlib_Array[32], runtime.caml_int_compare, lens);
     var
      totlen =
        caml_call3
         (Stdlib_Array[17],
          function(_g_, _f_){return _g_ + _f_ | 0;},
          0,
          lens),
      _a_ = len - 1 | 0,
      _c_ = len / 2 | 0,
      _b_ = caml_check_bound(lens, _a_)[1 + _a_],
      _d_ = caml_check_bound(lens, _c_)[1 + _c_],
      _e_ = caml_check_bound(lens, 0)[1];
     return [0, len, count(t), totlen, _e_, _d_, _b_];
    }
    return [0,
            create$0,
            clear,
            merge,
            add,
            remove,
            find,
            find_opt,
            find_all,
            mem,
            iter,
            fold,
            count,
            stats];
   }
   var
    Stdlib_Weak =
      [0, create, length, set, get, get_copy, check, fill, blit, Make];
   runtime.caml_register_global(13, Stdlib_Weak, "Stdlib__Weak");
   return;
  }
  (globalThis));

//# 22408 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_register_named_value = runtime.caml_register_named_value,
    global_data = runtime.caml_get_global_data(),
    Stdlib_Obj = global_data.Stdlib__Obj,
    register = caml_register_named_value;
   function register_exception(name, exn){
    var
     _a_ = Stdlib_Obj[8],
     slot = runtime.caml_obj_tag(exn) === _a_ ? exn : exn[1];
    return caml_register_named_value(name, slot);
   }
   var Stdlib_Callback = [0, register, register_exception];
   runtime.caml_register_global(1, Stdlib_Callback, "Stdlib__Callback");
   return;
  }
  (globalThis));

//# 26624 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Bigarray_Array3_of_array_n$1 =
      "Bigarray.Array3.of_array: non-cubic data",
    caml_ba_change_layout = runtime.caml_ba_change_layout,
    caml_ba_create = runtime.caml_ba_create,
    caml_ba_dim_1 = runtime.caml_ba_dim_1,
    caml_ba_dim_2 = runtime.caml_ba_dim_2,
    caml_ba_kind = runtime.caml_ba_kind,
    caml_ba_num_dims = runtime.caml_ba_num_dims,
    caml_ba_reshape = runtime.caml_ba_reshape,
    caml_ba_set_1 = runtime.caml_ba_set_1,
    caml_ba_set_2 = runtime.caml_ba_set_2,
    caml_ba_set_3 = runtime.caml_ba_set_3,
    caml_ba_set_generic = runtime.caml_ba_set_generic,
    caml_ba_slice = runtime.caml_ba_slice,
    caml_check_bound = runtime.caml_check_bound,
    caml_make_vect = runtime.caml_make_vect,
    caml_mul = runtime.caml_mul;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Stdlib_Array = global_data.Stdlib__Array,
    Stdlib_Sys = global_data.Stdlib__Sys;
   function kind_size_in_bytes(param){
    switch(param){
      case 0:
       return 4;
      case 1:
       return 8;
      case 2:
       return 1;
      case 3:
       return 1;
      case 4:
       return 2;
      case 5:
       return 2;
      case 6:
       return 4;
      case 7:
       return 8;
      case 8:
       return Stdlib_Sys[9] / 8 | 0;
      case 9:
       return Stdlib_Sys[9] / 8 | 0;
      case 10:
       return 8;
      case 11:
       return 16;
      default: return 1;
    }
   }
   var
    cst_Bigarray_Array2_of_array_n =
      "Bigarray.Array2.of_array: non-rectangular data",
    cst_Bigarray_Array3_of_array_n = cst_Bigarray_Array3_of_array_n$1,
    cst_Bigarray_Array3_of_array_n$0 = cst_Bigarray_Array3_of_array_n$1,
    cst_Bigarray_array0_of_genarra = "Bigarray.array0_of_genarray",
    cst_Bigarray_array1_of_genarra = "Bigarray.array1_of_genarray",
    cst_Bigarray_array2_of_genarra = "Bigarray.array2_of_genarray",
    cst_Bigarray_array3_of_genarra = "Bigarray.array3_of_genarray";
   function cloop(arr, idx, f, col, max){
    if(col === idx.length - 1){
     caml_ba_set_generic(arr, idx, caml_call1(f, idx));
     return;
    }
    var _am_ = caml_check_bound(max, col)[1 + col] - 1 | 0, _al_ = 0;
    if(_am_ >= 0){
     var j = _al_;
     for(;;){
      caml_check_bound(idx, col)[1 + col] = j;
      cloop(arr, idx, f, col + 1 | 0, max);
      var _an_ = j + 1 | 0;
      if(_am_ === j) break;
      j = _an_;
     }
    }
    return;
   }
   function floop(arr, idx, f, col, max){
    if(0 > col){caml_ba_set_generic(arr, idx, caml_call1(f, idx)); return;}
    var _aj_ = caml_check_bound(max, col)[1 + col], _ai_ = 1;
    if(_aj_ >= 1){
     var j = _ai_;
     for(;;){
      caml_check_bound(idx, col)[1 + col] = j;
      floop(arr, idx, f, col - 1 | 0, max);
      var _ak_ = j + 1 | 0;
      if(_aj_ === j) break;
      j = _ak_;
     }
    }
    return;
   }
   function init(kind, layout, dims, f){
    var arr = caml_ba_create(kind, layout, dims), match = dims.length - 1;
    return 0 === match
            ? arr
            : layout
              ? (floop
                 (arr, caml_make_vect(match, 1), f, match - 1 | 0, dims),
                arr)
              : (cloop(arr, caml_make_vect(match, 0), f, 0, dims), arr);
   }
   function dims(a){
    var
     n = caml_ba_num_dims(a),
     d = caml_make_vect(n, 0),
     _af_ = n - 1 | 0,
     _ae_ = 0;
    if(_af_ >= 0){
     var i = _ae_;
     for(;;){
      var _ag_ = runtime.caml_ba_dim(a, i);
      caml_check_bound(d, i)[1 + i] = _ag_;
      var _ah_ = i + 1 | 0;
      if(_af_ === i) break;
      i = _ah_;
     }
    }
    return d;
   }
   function size_in_bytes(arr){
    var
     _ac_ = dims(arr),
     _ad_ = caml_call3(Stdlib_Array[17], caml_mul, 1, _ac_);
    return caml_mul(kind_size_in_bytes(caml_ba_kind(arr)), _ad_);
   }
   function create(kind, layout){return caml_ba_create(kind, layout, [0]);}
   function get(arr){return runtime.caml_ba_get_generic(arr, [0]);}
   function set(arr){
    var _aa_ = [0];
    return function(_ab_){return caml_ba_set_generic(arr, _aa_, _ab_);};
   }
   function size_in_bytes$0(arr){
    return kind_size_in_bytes(caml_ba_kind(arr));
   }
   function of_value(kind, layout, v){
    var a = create(kind, layout);
    set(a)(v);
    return a;
   }
   function create$0(kind, layout, dim){
    return caml_ba_create(kind, layout, [0, dim]);
   }
   function size_in_bytes$1(arr){
    var _$_ = caml_ba_dim_1(arr);
    return caml_mul(kind_size_in_bytes(caml_ba_kind(arr)), _$_);
   }
   function slice(a, n){
    return runtime.caml_ba_layout(a)
            ? caml_ba_slice(a, [0, n])
            : caml_ba_slice(a, [0, n]);
   }
   function init$0(kind, layout, dim, f){
    var arr = create$0(kind, layout, dim);
    if(layout){
     var _Z_ = 1;
     if(dim >= 1){
      var i$0 = _Z_;
      for(;;){
       caml_ba_set_1(arr, i$0, caml_call1(f, i$0));
       var ___ = i$0 + 1 | 0;
       if(dim === i$0) break;
       i$0 = ___;
      }
     }
     return arr;
    }
    var _X_ = dim - 1 | 0, _W_ = 0;
    if(_X_ >= 0){
     var i = _W_;
     for(;;){
      caml_ba_set_1(arr, i, caml_call1(f, i));
      var _Y_ = i + 1 | 0;
      if(_X_ === i) break;
      i = _Y_;
     }
    }
    return arr;
   }
   function of_array(kind, layout, data){
    var
     ba = create$0(kind, layout, data.length - 1),
     ofs = layout ? 1 : 0,
     _U_ = data.length - 2 | 0,
     _T_ = 0;
    if(_U_ >= 0){
     var i = _T_;
     for(;;){
      caml_ba_set_1(ba, i + ofs | 0, caml_check_bound(data, i)[1 + i]);
      var _V_ = i + 1 | 0;
      if(_U_ === i) break;
      i = _V_;
     }
    }
    return ba;
   }
   function create$1(kind, layout, dim1, dim2){
    return caml_ba_create(kind, layout, [0, dim1, dim2]);
   }
   function size_in_bytes$2(arr){
    var _R_ = caml_ba_dim_2(arr), _S_ = caml_ba_dim_1(arr);
    return caml_mul(caml_mul(kind_size_in_bytes(caml_ba_kind(arr)), _S_), _R_);
   }
   function slice_left(a, n){return caml_ba_slice(a, [0, n]);}
   function slice_right(a, n){return caml_ba_slice(a, [0, n]);}
   function init$1(kind, layout, dim1, dim2, f){
    var arr = create$1(kind, layout, dim1, dim2);
    if(layout){
     var _N_ = 1;
     if(dim2 >= 1){
      var j$0 = _N_;
      for(;;){
       var _O_ = 1;
       if(dim1 >= 1){
        var i$0 = _O_;
        for(;;){
         caml_ba_set_2(arr, i$0, j$0, caml_call2(f, i$0, j$0));
         var _Q_ = i$0 + 1 | 0;
         if(dim1 === i$0) break;
         i$0 = _Q_;
        }
       }
       var _P_ = j$0 + 1 | 0;
       if(dim2 === j$0) break;
       j$0 = _P_;
      }
     }
     return arr;
    }
    var _I_ = dim1 - 1 | 0, _H_ = 0;
    if(_I_ >= 0){
     var i = _H_;
     for(;;){
      var _K_ = dim2 - 1 | 0, _J_ = 0;
      if(_K_ >= 0){
       var j = _J_;
       for(;;){
        caml_ba_set_2(arr, i, j, caml_call2(f, i, j));
        var _M_ = j + 1 | 0;
        if(_K_ === j) break;
        j = _M_;
       }
      }
      var _L_ = i + 1 | 0;
      if(_I_ === i) break;
      i = _L_;
     }
    }
    return arr;
   }
   function of_array$0(kind, layout, data){
    var
     dim1 = data.length - 1,
     dim2 = 0 === dim1 ? 0 : caml_check_bound(data, 0)[1].length - 1,
     ba = create$1(kind, layout, dim1, dim2),
     ofs = layout ? 1 : 0,
     _C_ = dim1 - 1 | 0,
     _B_ = 0;
    if(_C_ >= 0){
     var i = _B_;
     for(;;){
      var row = caml_check_bound(data, i)[1 + i];
      if(row.length - 1 !== dim2)
       caml_call1(Stdlib[1], cst_Bigarray_Array2_of_array_n);
      var _E_ = dim2 - 1 | 0, _D_ = 0;
      if(_E_ >= 0){
       var j = _D_;
       for(;;){
        caml_ba_set_2
         (ba, i + ofs | 0, j + ofs | 0, caml_check_bound(row, j)[1 + j]);
        var _G_ = j + 1 | 0;
        if(_E_ === j) break;
        j = _G_;
       }
      }
      var _F_ = i + 1 | 0;
      if(_C_ === i) break;
      i = _F_;
     }
    }
    return ba;
   }
   function create$2(kind, layout, dim1, dim2, dim3){
    return caml_ba_create(kind, layout, [0, dim1, dim2, dim3]);
   }
   function size_in_bytes$3(arr){
    var
     _y_ = runtime.caml_ba_dim_3(arr),
     _z_ = caml_ba_dim_2(arr),
     _A_ = caml_ba_dim_1(arr);
    return caml_mul
            (caml_mul
              (caml_mul(kind_size_in_bytes(caml_ba_kind(arr)), _A_), _z_),
             _y_);
   }
   function slice_left_1(a, n, m){return caml_ba_slice(a, [0, n, m]);}
   function slice_right_1(a, n, m){return caml_ba_slice(a, [0, n, m]);}
   function slice_left_2(a, n){return caml_ba_slice(a, [0, n]);}
   function slice_right_2(a, n){return caml_ba_slice(a, [0, n]);}
   function init$2(kind, layout, dim1, dim2, dim3, f){
    var arr = create$2(kind, layout, dim1, dim2, dim3);
    if(layout){
     var _s_ = 1;
     if(dim3 >= 1){
      var k$0 = _s_;
      for(;;){
       var _t_ = 1;
       if(dim2 >= 1){
        var j$0 = _t_;
        for(;;){
         var _v_ = 1;
         if(dim1 >= 1){
          var i$0 = _v_;
          for(;;){
           caml_ba_set_3(arr, i$0, j$0, k$0, caml_call3(f, i$0, j$0, k$0));
           var _x_ = i$0 + 1 | 0;
           if(dim1 === i$0) break;
           i$0 = _x_;
          }
         }
         var _w_ = j$0 + 1 | 0;
         if(dim2 === j$0) break;
         j$0 = _w_;
        }
       }
       var _u_ = k$0 + 1 | 0;
       if(dim3 === k$0) break;
       k$0 = _u_;
      }
     }
     return arr;
    }
    var _k_ = dim1 - 1 | 0, _j_ = 0;
    if(_k_ >= 0){
     var i = _j_;
     for(;;){
      var _m_ = dim2 - 1 | 0, _l_ = 0;
      if(_m_ >= 0){
       var j = _l_;
       for(;;){
        var _p_ = dim3 - 1 | 0, _o_ = 0;
        if(_p_ >= 0){
         var k = _o_;
         for(;;){
          caml_ba_set_3(arr, i, j, k, caml_call3(f, i, j, k));
          var _r_ = k + 1 | 0;
          if(_p_ === k) break;
          k = _r_;
         }
        }
        var _q_ = j + 1 | 0;
        if(_m_ === j) break;
        j = _q_;
       }
      }
      var _n_ = i + 1 | 0;
      if(_k_ === i) break;
      i = _n_;
     }
    }
    return arr;
   }
   function of_array$1(kind, layout, data){
    var
     dim1 = data.length - 1,
     dim2 = 0 === dim1 ? 0 : caml_check_bound(data, 0)[1].length - 1,
     dim3 =
       0 === dim2
        ? 0
        : caml_check_bound(caml_check_bound(data, 0)[1], 0)[1].length - 1,
     ba = create$2(kind, layout, dim1, dim2, dim3),
     ofs = layout ? 1 : 0,
     _b_ = dim1 - 1 | 0,
     _a_ = 0;
    if(_b_ >= 0){
     var i = _a_;
     for(;;){
      var row = caml_check_bound(data, i)[1 + i];
      if(row.length - 1 !== dim2)
       caml_call1(Stdlib[1], cst_Bigarray_Array3_of_array_n);
      var _d_ = dim2 - 1 | 0, _c_ = 0;
      if(_d_ >= 0){
       var j = _c_;
       for(;;){
        var col = caml_check_bound(row, j)[1 + j];
        if(col.length - 1 !== dim3)
         caml_call1(Stdlib[1], cst_Bigarray_Array3_of_array_n$0);
        var _g_ = dim3 - 1 | 0, _f_ = 0;
        if(_g_ >= 0){
         var k = _f_;
         for(;;){
          caml_ba_set_3
           (ba,
            i + ofs | 0,
            j + ofs | 0,
            k + ofs | 0,
            caml_check_bound(col, k)[1 + k]);
          var _i_ = k + 1 | 0;
          if(_g_ === k) break;
          k = _i_;
         }
        }
        var _h_ = j + 1 | 0;
        if(_d_ === j) break;
        j = _h_;
       }
      }
      var _e_ = i + 1 | 0;
      if(_b_ === i) break;
      i = _e_;
     }
    }
    return ba;
   }
   function array0_of_genarray(a){
    return 0 === caml_ba_num_dims(a)
            ? a
            : caml_call1(Stdlib[1], cst_Bigarray_array0_of_genarra);
   }
   function array1_of_genarray(a){
    return 1 === caml_ba_num_dims(a)
            ? a
            : caml_call1(Stdlib[1], cst_Bigarray_array1_of_genarra);
   }
   function array2_of_genarray(a){
    return 2 === caml_ba_num_dims(a)
            ? a
            : caml_call1(Stdlib[1], cst_Bigarray_array2_of_genarra);
   }
   function array3_of_genarray(a){
    return 3 === caml_ba_num_dims(a)
            ? a
            : caml_call1(Stdlib[1], cst_Bigarray_array3_of_genarra);
   }
   function reshape_0(a){return caml_ba_reshape(a, [0]);}
   function reshape_1(a, dim1){return caml_ba_reshape(a, [0, dim1]);}
   function reshape_2(a, dim1, dim2){
    return caml_ba_reshape(a, [0, dim1, dim2]);
   }
   function reshape_3(a, dim1, dim2, dim3){
    return caml_ba_reshape(a, [0, dim1, dim2, dim3]);
   }
   var
    Stdlib_Bigarray =
      [0,
       0,
       1,
       10,
       11,
       2,
       3,
       4,
       5,
       8,
       6,
       7,
       9,
       12,
       kind_size_in_bytes,
       0,
       1,
       [0, init, dims, size_in_bytes],
       [0,
        create,
        of_value,
        caml_ba_change_layout,
        size_in_bytes$0,
        get,
        set,
        of_value],
       [0,
        create$0,
        init$0,
        caml_ba_change_layout,
        size_in_bytes$1,
        slice,
        of_array],
       [0,
        create$1,
        init$1,
        caml_ba_change_layout,
        size_in_bytes$2,
        slice_left,
        slice_right,
        of_array$0],
       [0,
        create$2,
        init$2,
        caml_ba_change_layout,
        size_in_bytes$3,
        slice_left_1,
        slice_right_1,
        slice_left_2,
        slice_right_2,
        of_array$1],
       array0_of_genarray,
       array1_of_genarray,
       array2_of_genarray,
       array3_of_genarray,
       caml_ba_reshape,
       reshape_0,
       reshape_1,
       reshape_2,
       reshape_3];
   runtime.caml_register_global(10, Stdlib_Bigarray, "Stdlib__Bigarray");
   return;
  }
  (globalThis));


//# 1 "../.js/default/unix/unix.cma.js"
// Generated by js_of_ocaml
//# 3 "../.js/default/unix/unix.cma.js"

//# 7 "../.js/default/unix/unix.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$6 = "",
    cst$7 = ", ",
    cst_c$1 = "-c",
    cst_bin_sh = "/bin/sh",
    cst_0_0_0_0$0 = "0.0.0.0",
    cst_127_0_0_1$0 = "127.0.0.1",
    cst_Unix_Unix_error = "Unix.Unix_error",
    cst_tcp$2 = "tcp",
    cst_udp$2 = "udp",
    caml_channel_descriptor = runtime.caml_channel_descriptor,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_bytes_length = runtime.caml_ml_bytes_length,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_unix_inet_addr_of_string = runtime.caml_unix_inet_addr_of_string,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$5 = cst$6,
    cst$4 = cst$6,
    cst$1 = ': "',
    cst$2 = '"',
    cst$3 = ": ",
    shell = cst_bin_sh,
    cst = cst$6,
    cst$0 = cst$6,
    Stdlib = global_data.Stdlib,
    Stdlib_Hashtbl = global_data.Stdlib__Hashtbl,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Fun = global_data.Stdlib__Fun,
    Stdlib_Int = global_data.Stdlib__Int;
   global_data.Stdlib__Array;
   var
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib_Callback = global_data.Stdlib__Callback,
    Stdlib_Printexc = global_data.Stdlib__Printexc,
    Unix_error = [248, cst_Unix_Unix_error, runtime.caml_fresh_oo_id(0)];
   caml_call2
    (Stdlib_Callback[2], cst_Unix_Unix_error, [0, Unix_error, 0, cst$0, cst]);
   var
    cst_E2BIG = "E2BIG",
    _a_ =
      [0,
       [11,
        "Unix.Unix_error(Unix.",
        [2, 0, [11, cst$7, [3, 0, [11, cst$7, [3, 0, [12, 41, 0]]]]]]],
       "Unix.Unix_error(Unix.%s, %S, %S)"],
    cst_EACCES = "EACCES",
    cst_EAGAIN = "EAGAIN",
    cst_EBADF = "EBADF",
    cst_EBUSY = "EBUSY",
    cst_ECHILD = "ECHILD",
    cst_EDEADLK = "EDEADLK",
    cst_EDOM = "EDOM",
    cst_EEXIST = "EEXIST",
    cst_EFAULT = "EFAULT",
    cst_EFBIG = "EFBIG",
    cst_EINTR = "EINTR",
    cst_EINVAL = "EINVAL",
    cst_EIO = "EIO",
    cst_EISDIR = "EISDIR",
    cst_EMFILE = "EMFILE",
    cst_EMLINK = "EMLINK",
    cst_ENAMETOOLONG = "ENAMETOOLONG",
    cst_ENFILE = "ENFILE",
    cst_ENODEV = "ENODEV",
    cst_ENOENT = "ENOENT",
    cst_ENOEXEC = "ENOEXEC",
    cst_ENOLCK = "ENOLCK",
    cst_ENOMEM = "ENOMEM",
    cst_ENOSPC = "ENOSPC",
    cst_ENOSYS = "ENOSYS",
    cst_ENOTDIR = "ENOTDIR",
    cst_ENOTEMPTY = "ENOTEMPTY",
    cst_ENOTTY = "ENOTTY",
    cst_ENXIO = "ENXIO",
    cst_EPERM = "EPERM",
    cst_EPIPE = "EPIPE",
    cst_ERANGE = "ERANGE",
    cst_EROFS = "EROFS",
    cst_ESPIPE = "ESPIPE",
    cst_ESRCH = "ESRCH",
    cst_EXDEV = "EXDEV",
    cst_EWOULDBLOCK = "EWOULDBLOCK",
    cst_EINPROGRESS = "EINPROGRESS",
    cst_EALREADY = "EALREADY",
    cst_ENOTSOCK = "ENOTSOCK",
    cst_EDESTADDRREQ = "EDESTADDRREQ",
    cst_EMSGSIZE = "EMSGSIZE",
    cst_EPROTOTYPE = "EPROTOTYPE",
    cst_ENOPROTOOPT = "ENOPROTOOPT",
    cst_EPROTONOSUPPORT = "EPROTONOSUPPORT",
    cst_ESOCKTNOSUPPORT = "ESOCKTNOSUPPORT",
    cst_EOPNOTSUPP = "EOPNOTSUPP",
    cst_EPFNOSUPPORT = "EPFNOSUPPORT",
    cst_EAFNOSUPPORT = "EAFNOSUPPORT",
    cst_EADDRINUSE = "EADDRINUSE",
    cst_EADDRNOTAVAIL = "EADDRNOTAVAIL",
    cst_ENETDOWN = "ENETDOWN",
    cst_ENETUNREACH = "ENETUNREACH",
    cst_ENETRESET = "ENETRESET",
    cst_ECONNABORTED = "ECONNABORTED",
    cst_ECONNRESET = "ECONNRESET",
    cst_ENOBUFS = "ENOBUFS",
    cst_EISCONN = "EISCONN",
    cst_ENOTCONN = "ENOTCONN",
    cst_ESHUTDOWN = "ESHUTDOWN",
    cst_ETOOMANYREFS = "ETOOMANYREFS",
    cst_ETIMEDOUT = "ETIMEDOUT",
    cst_ECONNREFUSED = "ECONNREFUSED",
    cst_EHOSTDOWN = "EHOSTDOWN",
    cst_EHOSTUNREACH = "EHOSTUNREACH",
    cst_ELOOP = "ELOOP",
    cst_EOVERFLOW = "EOVERFLOW",
    _b_ = [0, [11, "EUNKNOWNERR ", [4, 0, 0, 0, 0]], "EUNKNOWNERR %d"];
   caml_call1
    (Stdlib_Printexc[9],
     function(param){
      if(param[1] !== Unix_error) return 0;
      var s = param[4], s$0 = param[3], e = param[2];
      if(typeof e === "number"){
       var _cS_ = e;
       if(34 <= _cS_)
        switch(_cS_){
          case 34:
           var msg = cst_ESPIPE; break;
          case 35:
           var msg = cst_ESRCH; break;
          case 36:
           var msg = cst_EXDEV; break;
          case 37:
           var msg = cst_EWOULDBLOCK; break;
          case 38:
           var msg = cst_EINPROGRESS; break;
          case 39:
           var msg = cst_EALREADY; break;
          case 40:
           var msg = cst_ENOTSOCK; break;
          case 41:
           var msg = cst_EDESTADDRREQ; break;
          case 42:
           var msg = cst_EMSGSIZE; break;
          case 43:
           var msg = cst_EPROTOTYPE; break;
          case 44:
           var msg = cst_ENOPROTOOPT; break;
          case 45:
           var msg = cst_EPROTONOSUPPORT; break;
          case 46:
           var msg = cst_ESOCKTNOSUPPORT; break;
          case 47:
           var msg = cst_EOPNOTSUPP; break;
          case 48:
           var msg = cst_EPFNOSUPPORT; break;
          case 49:
           var msg = cst_EAFNOSUPPORT; break;
          case 50:
           var msg = cst_EADDRINUSE; break;
          case 51:
           var msg = cst_EADDRNOTAVAIL; break;
          case 52:
           var msg = cst_ENETDOWN; break;
          case 53:
           var msg = cst_ENETUNREACH; break;
          case 54:
           var msg = cst_ENETRESET; break;
          case 55:
           var msg = cst_ECONNABORTED; break;
          case 56:
           var msg = cst_ECONNRESET; break;
          case 57:
           var msg = cst_ENOBUFS; break;
          case 58:
           var msg = cst_EISCONN; break;
          case 59:
           var msg = cst_ENOTCONN; break;
          case 60:
           var msg = cst_ESHUTDOWN; break;
          case 61:
           var msg = cst_ETOOMANYREFS; break;
          case 62:
           var msg = cst_ETIMEDOUT; break;
          case 63:
           var msg = cst_ECONNREFUSED; break;
          case 64:
           var msg = cst_EHOSTDOWN; break;
          case 65:
           var msg = cst_EHOSTUNREACH; break;
          case 66:
           var msg = cst_ELOOP; break;
          default: var msg = cst_EOVERFLOW;
        }
       else
        switch(_cS_){
          case 0:
           var msg = cst_E2BIG; break;
          case 1:
           var msg = cst_EACCES; break;
          case 2:
           var msg = cst_EAGAIN; break;
          case 3:
           var msg = cst_EBADF; break;
          case 4:
           var msg = cst_EBUSY; break;
          case 5:
           var msg = cst_ECHILD; break;
          case 6:
           var msg = cst_EDEADLK; break;
          case 7:
           var msg = cst_EDOM; break;
          case 8:
           var msg = cst_EEXIST; break;
          case 9:
           var msg = cst_EFAULT; break;
          case 10:
           var msg = cst_EFBIG; break;
          case 11:
           var msg = cst_EINTR; break;
          case 12:
           var msg = cst_EINVAL; break;
          case 13:
           var msg = cst_EIO; break;
          case 14:
           var msg = cst_EISDIR; break;
          case 15:
           var msg = cst_EMFILE; break;
          case 16:
           var msg = cst_EMLINK; break;
          case 17:
           var msg = cst_ENAMETOOLONG; break;
          case 18:
           var msg = cst_ENFILE; break;
          case 19:
           var msg = cst_ENODEV; break;
          case 20:
           var msg = cst_ENOENT; break;
          case 21:
           var msg = cst_ENOEXEC; break;
          case 22:
           var msg = cst_ENOLCK; break;
          case 23:
           var msg = cst_ENOMEM; break;
          case 24:
           var msg = cst_ENOSPC; break;
          case 25:
           var msg = cst_ENOSYS; break;
          case 26:
           var msg = cst_ENOTDIR; break;
          case 27:
           var msg = cst_ENOTEMPTY; break;
          case 28:
           var msg = cst_ENOTTY; break;
          case 29:
           var msg = cst_ENXIO; break;
          case 30:
           var msg = cst_EPERM; break;
          case 31:
           var msg = cst_EPIPE; break;
          case 32:
           var msg = cst_ERANGE; break;
          default: var msg = cst_EROFS;
        }
      }
      else
       var x = e[1], msg = caml_call2(Stdlib_Printf[4], _b_, x);
      return [0, caml_call4(Stdlib_Printf[4], _a_, msg, s$0, s)];
     });
   var cst_failed = '" failed', cst_on = ' on "';
   function handle_unix_error(f, arg){
    try{var _cR_ = caml_call1(f, arg); return _cR_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn[1] !== Unix_error) throw caml_maybe_attach_backtrace(exn, 0);
     var
      arg$0 = exn[4],
      fun_name = exn[3],
      err = exn[2],
      _cP_ = runtime.caml_check_bound(runtime.caml_sys_argv(0), 0)[1];
     caml_call1(Stdlib[49], _cP_);
     caml_call1(Stdlib[49], cst$1);
     caml_call1(Stdlib[49], fun_name);
     caml_call1(Stdlib[49], cst_failed);
     if(0 < caml_ml_string_length(arg$0)){
      caml_call1(Stdlib[49], cst_on);
      caml_call1(Stdlib[49], arg$0);
      caml_call1(Stdlib[49], cst$2);
     }
     caml_call1(Stdlib[49], cst$3);
     var _cQ_ = runtime.unix_error_message(err);
     caml_call1(Stdlib[53], _cQ_);
     return caml_call1(Stdlib[99], 2);
    }
   }
   var
    stdin = 0,
    stdout = 1,
    stderr = 2,
    cst_Unix_read = "Unix.read",
    cst_Unix_write = "Unix.write",
    cst_Unix_single_write = "Unix.single_write",
    _c_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0);
   function read(fd, buf, ofs, len){
    if(0 <= ofs && 0 <= len && (caml_ml_bytes_length(buf) - len | 0) >= ofs)
     return runtime.unix_read(fd, buf, ofs, len);
    return caml_call1(Stdlib[1], cst_Unix_read);
   }
   function write(fd, buf, ofs, len){
    if(0 <= ofs && 0 <= len && (caml_ml_bytes_length(buf) - len | 0) >= ofs)
     return runtime.unix_write(fd, buf, ofs, len);
    return caml_call1(Stdlib[1], cst_Unix_write);
   }
   function single_write(fd, buf, ofs, len){
    if(0 <= ofs && 0 <= len && (caml_ml_bytes_length(buf) - len | 0) >= ofs)
     return runtime.unix_single_write(fd, buf, ofs, len);
    return caml_call1(Stdlib[1], cst_Unix_single_write);
   }
   function write_substring(fd, buf, ofs, len){
    return write(fd, caml_call1(Stdlib_Bytes[49], buf), ofs, len);
   }
   function single_write_substring(fd, buf, ofs, len){
    return single_write(fd, caml_call1(Stdlib_Bytes[49], buf), ofs, len);
   }
   function map_file(fd, opt, kind, layout, shared, dims){
    if(opt) var sth = opt[1], pos = sth; else var pos = _c_;
    return runtime.caml_unix_map_file_bytecode
            (fd, kind, layout, shared, dims, pos);
   }
   function pause(param){
    var sigs = runtime.unix_sigprocmask(1, 0);
    return runtime.unix_sigsuspend(sigs);
   }
   function sleep(duration){return runtime.unix_sleep(duration);}
   function is_inet6_addr(s){return 16 === caml_ml_string_length(s) ? 1 : 0;}
   var
    inet_addr_any = caml_unix_inet_addr_of_string(cst_0_0_0_0$0),
    inet_addr_loopback = caml_unix_inet_addr_of_string(cst_127_0_0_1$0),
    inet6_addr_any = caml_unix_inet_addr_of_string("::"),
    inet6_addr_loopback = caml_unix_inet_addr_of_string("::1"),
    cst_Unix_recv = "Unix.recv",
    cst_Unix_recvfrom = "Unix.recvfrom",
    cst_Unix_send = "Unix.send",
    cst_Unix_sendto = "Unix.sendto",
    cst_udp = cst_udp$2,
    cst_0_0_0_0 = cst_0_0_0_0$0,
    cst_127_0_0_1 = cst_127_0_0_1$0,
    cst_tcp = cst_tcp$2,
    cst_udp$0 = cst_udp$2,
    cst_tcp$0 = cst_tcp$2,
    cst_udp$1 = cst_udp$2,
    cst_tcp$1 = cst_tcp$2,
    cst_c = cst_c$1,
    _d_ = [0, 1];
   function domain_of_sockaddr(param){
    if(0 === param[0]) return 0;
    var a = param[1];
    return is_inet6_addr(a) ? 2 : 1;
   }
   function recv(fd, buf, ofs, len, flags){
    if(0 <= ofs && 0 <= len && (caml_ml_bytes_length(buf) - len | 0) >= ofs)
     return runtime.unix_recv(fd, buf, ofs, len, flags);
    return caml_call1(Stdlib[1], cst_Unix_recv);
   }
   function recvfrom(fd, buf, ofs, len, flags){
    if(0 <= ofs && 0 <= len && (caml_ml_bytes_length(buf) - len | 0) >= ofs)
     return runtime.unix_recvfrom(fd, buf, ofs, len, flags);
    return caml_call1(Stdlib[1], cst_Unix_recvfrom);
   }
   function send(fd, buf, ofs, len, flags){
    if(0 <= ofs && 0 <= len && (caml_ml_bytes_length(buf) - len | 0) >= ofs)
     return runtime.unix_send(fd, buf, ofs, len, flags);
    return caml_call1(Stdlib[1], cst_Unix_send);
   }
   function sendto(fd, buf, ofs, len, flags, addr){
    if(0 <= ofs && 0 <= len && (caml_ml_bytes_length(buf) - len | 0) >= ofs)
     return runtime.unix_sendto(fd, buf, ofs, len, flags, addr);
    return caml_call1(Stdlib[1], cst_Unix_sendto);
   }
   function send_substring(fd, buf, ofs, len, flags){
    return send(fd, caml_call1(Stdlib_Bytes[49], buf), ofs, len, flags);
   }
   function sendto_substring(fd, buf, ofs, len, flags, addr){
    return sendto
            (fd, caml_call1(Stdlib_Bytes[49], buf), ofs, len, flags, addr);
   }
   function getsockopt(fd, opt){return runtime.unix_getsockopt(0, fd, opt);}
   function setsockopt(fd, opt, v){
    return runtime.unix_setsockopt(0, fd, opt, v);
   }
   function getsockopt_int(fd, opt){
    return runtime.unix_getsockopt(1, fd, opt);
   }
   function setsockopt_int(fd, opt, v){
    return runtime.unix_setsockopt(1, fd, opt, v);
   }
   function getsockopt_optint(fd, opt){
    return runtime.unix_getsockopt(2, fd, opt);
   }
   function setsockopt_optint(fd, opt, v){
    return runtime.unix_setsockopt(2, fd, opt, v);
   }
   function getsockopt_float(fd, opt){
    return runtime.unix_getsockopt(3, fd, opt);
   }
   function setsockopt_float(fd, opt, v){
    return runtime.unix_setsockopt(3, fd, opt, v);
   }
   function getsockopt_error(fd){return runtime.unix_getsockopt(4, fd, 0);}
   function getaddrinfo(node, service, opts){
    try{
     var
      _cG_ = runtime.unix_getaddrinfo(node, service, opts),
      _cH_ = caml_call1(Stdlib_List[9], _cG_);
     return _cH_;
    }
    catch(_cI_){
     var _cF_ = caml_wrap_exception(_cI_);
     if(_cF_[1] !== Stdlib[6]) throw caml_maybe_attach_backtrace(_cF_, 0);
     var opt_socktype = [0, 0], opt_protocol = [0, 0];
     caml_call2
      (Stdlib_List[17],
       function(param){
        if(typeof param === "number"){if(2 === param) return 0;}
        else
         switch(param[0]){
           case 1:
            var s = param[1]; opt_socktype[1] = [0, s]; return 0;
           case 2:
            var p = param[1]; opt_protocol[1] = p; return 0;
         }
        return 0;
       },
       opts);
     var
      get_port =
        function(ty, kind){
         if(service == cst$6) return [0, [0, ty, 0], 0];
         try{
          var _cM_ = [0, [0, ty, runtime.caml_int_of_string(service)], 0];
          return _cM_;
         }
         catch(_cN_){
          var _cJ_ = caml_wrap_exception(_cN_);
          if(_cJ_[1] !== Stdlib[7])
           throw caml_maybe_attach_backtrace(_cJ_, 0);
          try{
           var
            _cL_ =
              [0, [0, ty, runtime.unix_getservbyname(service, kind)[3]], 0];
           return _cL_;
          }
          catch(_cO_){
           var _cK_ = caml_wrap_exception(_cO_);
           if(_cK_ === Stdlib[8]) return 0;
           throw caml_maybe_attach_backtrace(_cK_, 0);
          }
         }
        },
      _cA_ = opt_socktype[1];
     if(_cA_)
      var
       ty = _cA_[1],
       _cB_ =
         1 === ty
          ? get_port(1, cst_udp)
          : ty
            ? service == cst$6 ? [0, [0, ty, 0], 0] : 0
            : get_port(0, cst_tcp),
       ports = _cB_;
     else
      var
       _cD_ = get_port(1, cst_udp$0),
       _cE_ = get_port(0, cst_tcp$0),
       ports = caml_call2(Stdlib[37], _cE_, _cD_);
     var
      addresses =
        node == cst$6
         ? caml_call2
            (Stdlib_List[36], 2, opts)
           ? [0, [0, inet_addr_any, cst_0_0_0_0], 0]
           : [0, [0, inet_addr_loopback, cst_127_0_0_1], 0]
         : [0, [0, caml_unix_inet_addr_of_string(node), node], 0],
      _cC_ =
        caml_call2
         (Stdlib_List[19],
          function(param){
           var port = param[2], ty = param[1];
           return caml_call2
                   (Stdlib_List[19],
                    function(param){
                     var name = param[2], addr = param[1];
                     return [0, 1, ty, opt_protocol[1], [1, addr, port], name];
                    },
                    addresses);
          },
          ports);
     return caml_call1(Stdlib_List[14], _cC_);
    }
   }
   function getnameinfo(addr, opts){
    try{var _cw_ = runtime.unix_getnameinfo(addr, opts); return _cw_;}
    catch(_cx_){
     var _cv_ = caml_wrap_exception(_cx_);
     if(_cv_[1] !== Stdlib[6]) throw caml_maybe_attach_backtrace(_cv_, 0);
     if(0 === addr[0]){var f = addr[1]; return [0, cst$4, f];}
     var p = addr[2], a = addr[1];
     try{
      if(caml_call2(Stdlib_List[36], 1, opts))
       throw caml_maybe_attach_backtrace(Stdlib[8], 1);
      var _cu_ = runtime.unix_gethostbyaddr(a)[1], hostname = _cu_;
     }
     catch(_cz_){
      var _cr_ = caml_wrap_exception(_cz_);
      if(_cr_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_cr_, 0);
      if(caml_call2(Stdlib_List[36], 2, opts))
       throw caml_maybe_attach_backtrace(Stdlib[8], 1);
      var hostname = runtime.unix_string_of_inet_addr(a);
     }
     try{
      if(caml_call2(Stdlib_List[36], 3, opts))
       throw caml_maybe_attach_backtrace(Stdlib[8], 1);
      var
       kind = caml_call2(Stdlib_List[36], 4, opts) ? cst_udp$1 : cst_tcp$1,
       _ct_ = runtime.unix_getservbyport(p, kind)[1],
       service = _ct_;
     }
     catch(_cy_){
      var _cs_ = caml_wrap_exception(_cy_);
      if(_cs_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_cs_, 0);
      var service = caml_call1(Stdlib_Int[12], p);
     }
     return [0, hostname, service];
    }
   }
   function waitpid_non_intr(pid){
    for(;;)
     try{var _cp_ = runtime.unix_waitpid(0, pid); return _cp_;}
     catch(_cq_){
      var _cn_ = caml_wrap_exception(_cq_);
      if(_cn_[1] === Unix_error){
       var _co_ = _cn_[2];
       if(typeof _co_ === "number" && 11 === _co_) continue;
      }
      throw caml_maybe_attach_backtrace(_cn_, 0);
     }
   }
   function system(cmd){
    var
     pid =
       runtime.unix_spawn
        (cst_bin_sh, [0, shell, cst_c, cmd], 0, 0, [0, 0, 1, 2]);
    return waitpid_non_intr(pid)[2];
   }
   function create_process_gen
   (cmd, args, optenv, new_stdin, new_stdout, new_stderr){
    var toclose = [0, 0];
    function close_after(param){
     return caml_call2
             (Stdlib_List[17],
              function(fd){
               try{var _cl_ = runtime.unix_close(fd); return _cl_;}
               catch(_cm_){
                var _ck_ = caml_wrap_exception(_cm_);
                if(_ck_[1] === Unix_error) return 0;
                throw caml_maybe_attach_backtrace(_ck_, 0);
               }
              },
              toclose[1]);
    }
    function file_descr_not_standard(fd){
     var fd$0 = fd;
     for(;;){
      if(3 <= fd$0) return fd$0;
      var fd$1 = runtime.unix_dup(_d_, fd$0);
      toclose[1] = [0, fd$1, toclose[1]];
      fd$0 = fd$1;
     }
    }
    var
     _ch_ = 2 === new_stderr ? 2 : file_descr_not_standard(new_stderr),
     _ci_ = 1 === new_stdout ? 1 : file_descr_not_standard(new_stdout),
     _cj_ = 0 === new_stdin ? 0 : file_descr_not_standard(new_stdin),
     redirections = [0, _cj_, _ci_, _ch_];
    return caml_call2
            (Stdlib_Fun[4],
             close_after,
             function(param){
              return runtime.unix_spawn(cmd, args, optenv, 1, redirections);
             });
   }
   function create_process(cmd, args, new_stdin, new_stdout, new_stderr){
    return create_process_gen(cmd, args, 0, new_stdin, new_stdout, new_stderr);
   }
   function create_process_env
   (cmd, args, env, new_stdin, new_stdout, new_stderr){
    return create_process_gen
            (cmd, args, [0, env], new_stdin, new_stdout, new_stderr);
   }
   var
    popen_processes = caml_call2(Stdlib_Hashtbl[1], 0, 7),
    _e_ = [0, 1],
    _f_ = [0, 1],
    _g_ = [0, 1],
    _h_ = [0, 1],
    _i_ = [0, 1],
    _j_ = [0, 1],
    _k_ = [0, 1],
    cst_c$0 = cst_c$1,
    cst_process_in_pid = "process_in_pid",
    cst_process_out_pid = "process_out_pid",
    cst_process_pid = "process_pid",
    cst_process_full_pid = "process_full_pid",
    cst_close_process_in = "close_process_in",
    cst_close_process_out = "close_process_out",
    cst_close_process = "close_process",
    cst_close_process_full = "close_process_full",
    _l_ = [0, 1],
    _m_ = [0, 1],
    _n_ = [0, 1];
   function open_proc(prog, args, envopt, proc, input, output, error){
    var pid = create_process_gen(prog, args, envopt, input, output, error);
    return caml_call3(Stdlib_Hashtbl[5], popen_processes, proc, pid);
   }
   function open_process_args_in(prog, args){
    var
     match = runtime.unix_pipe(_e_, 0),
     in_write = match[2],
     in_read = match[1],
     inchan = runtime.unix_inchannel_of_filedescr(in_read);
    try{open_proc(prog, args, 0, [1, inchan], stdin, in_write, stderr);}
    catch(e$0){
     var e = caml_wrap_exception(e$0);
     caml_call1(Stdlib[93], inchan);
     runtime.unix_close(in_write);
     throw caml_maybe_attach_backtrace(e, 0);
    }
    runtime.unix_close(in_write);
    return inchan;
   }
   function open_process_args_out(prog, args){
    var
     match = runtime.unix_pipe(_f_, 0),
     out_write = match[2],
     out_read = match[1],
     outchan = runtime.unix_outchannel_of_filedescr(out_write);
    try{open_proc(prog, args, 0, [2, outchan], out_read, stdout, stderr);}
    catch(e$0){
     var e = caml_wrap_exception(e$0);
     caml_call1(Stdlib[76], outchan);
     runtime.unix_close(out_read);
     throw caml_maybe_attach_backtrace(e, 0);
    }
    runtime.unix_close(out_read);
    return outchan;
   }
   function open_process_args(prog, args){
    var
     match = runtime.unix_pipe(_g_, 0),
     in_write = match[2],
     in_read = match[1];
    try{var match$0 = runtime.unix_pipe(_h_, 0);}
    catch(e$0){
     var e = caml_wrap_exception(e$0);
     runtime.unix_close(in_read);
     runtime.unix_close(in_write);
     throw caml_maybe_attach_backtrace(e, 0);
    }
    var
     out_write = match$0[2],
     out_read = match$0[1],
     inchan = runtime.unix_inchannel_of_filedescr(in_read),
     outchan = runtime.unix_outchannel_of_filedescr(out_write);
    try{
     open_proc
      (prog, args, 0, [0, inchan, outchan], out_read, in_write, stderr);
    }
    catch(e){
     var e$0 = caml_wrap_exception(e);
     runtime.unix_close(out_read);
     runtime.unix_close(out_write);
     runtime.unix_close(in_read);
     runtime.unix_close(in_write);
     throw caml_maybe_attach_backtrace(e$0, 0);
    }
    runtime.unix_close(out_read);
    runtime.unix_close(in_write);
    return [0, inchan, outchan];
   }
   function open_process_args_full(prog, args, env){
    var
     match = runtime.unix_pipe(_i_, 0),
     in_write = match[2],
     in_read = match[1];
    try{var match$0 = runtime.unix_pipe(_j_, 0);}
    catch(e$0){
     var e = caml_wrap_exception(e$0);
     runtime.unix_close(in_read);
     runtime.unix_close(in_write);
     throw caml_maybe_attach_backtrace(e, 0);
    }
    var out_write = match$0[2], out_read = match$0[1];
    try{var match$1 = runtime.unix_pipe(_k_, 0);}
    catch(e){
     var e$0 = caml_wrap_exception(e);
     runtime.unix_close(in_read);
     runtime.unix_close(in_write);
     runtime.unix_close(out_read);
     runtime.unix_close(out_write);
     throw caml_maybe_attach_backtrace(e$0, 0);
    }
    var
     err_write = match$1[2],
     err_read = match$1[1],
     inchan = runtime.unix_inchannel_of_filedescr(in_read),
     outchan = runtime.unix_outchannel_of_filedescr(out_write),
     errchan = runtime.unix_inchannel_of_filedescr(err_read);
    try{
     open_proc
      (prog,
       args,
       [0, env],
       [3, inchan, outchan, errchan],
       out_read,
       in_write,
       err_write);
    }
    catch(e){
     var e$1 = caml_wrap_exception(e);
     runtime.unix_close(out_read);
     runtime.unix_close(out_write);
     runtime.unix_close(in_read);
     runtime.unix_close(in_write);
     runtime.unix_close(err_read);
     runtime.unix_close(err_write);
     throw caml_maybe_attach_backtrace(e$1, 0);
    }
    runtime.unix_close(out_read);
    runtime.unix_close(in_write);
    runtime.unix_close(err_write);
    return [0, inchan, outchan, errchan];
   }
   function open_process_shell(fn, cmd){
    return caml_call2(fn, shell, [0, shell, cst_c$0, cmd]);
   }
   function open_process_in(cmd){
    return open_process_shell(open_process_args_in, cmd);
   }
   function open_process_out(cmd){
    return open_process_shell(open_process_args_out, cmd);
   }
   function open_process(cmd){
    return open_process_shell(open_process_args, cmd);
   }
   function open_process_full(cmd){
    return open_process_shell(open_process_args_full, cmd);
   }
   function find_proc_id(fun_name, proc){
    try{
     var _cf_ = caml_call2(Stdlib_Hashtbl[6], popen_processes, proc);
     return _cf_;
    }
    catch(_cg_){
     var _ce_ = caml_wrap_exception(_cg_);
     if(_ce_ === Stdlib[8])
      throw caml_maybe_attach_backtrace
             ([0, Unix_error, 3, fun_name, cst$5], 1);
     throw caml_maybe_attach_backtrace(_ce_, 0);
    }
   }
   function remove_proc_id(proc){
    return caml_call2(Stdlib_Hashtbl[10], popen_processes, proc);
   }
   function process_in_pid(inchan){
    return find_proc_id(cst_process_in_pid, [1, inchan]);
   }
   function process_out_pid(outchan){
    return find_proc_id(cst_process_out_pid, [2, outchan]);
   }
   function process_pid(param){
    var outchan = param[2], inchan = param[1];
    return find_proc_id(cst_process_pid, [0, inchan, outchan]);
   }
   function process_full_pid(param){
    var errchan = param[3], outchan = param[2], inchan = param[1];
    return find_proc_id(cst_process_full_pid, [3, inchan, outchan, errchan]);
   }
   function close_process_in(inchan){
    var proc = [1, inchan], pid = find_proc_id(cst_close_process_in, proc);
    remove_proc_id(proc);
    caml_call1(Stdlib[93], inchan);
    return waitpid_non_intr(pid)[2];
   }
   function close_process_out(outchan){
    var proc = [2, outchan], pid = find_proc_id(cst_close_process_out, proc);
    remove_proc_id(proc);
    try{caml_call1(Stdlib[76], outchan);}
    catch(_cd_){
     var _cc_ = caml_wrap_exception(_cd_);
     if(_cc_[1] !== Stdlib[11]) throw caml_maybe_attach_backtrace(_cc_, 0);
    }
    return waitpid_non_intr(pid)[2];
   }
   function close_process(param){
    var
     outchan = param[2],
     inchan = param[1],
     proc = [0, inchan, outchan],
     pid = find_proc_id(cst_close_process, proc);
    remove_proc_id(proc);
    caml_call1(Stdlib[93], inchan);
    try{caml_call1(Stdlib[76], outchan);}
    catch(_cb_){
     var _ca_ = caml_wrap_exception(_cb_);
     if(_ca_[1] !== Stdlib[11]) throw caml_maybe_attach_backtrace(_ca_, 0);
    }
    return waitpid_non_intr(pid)[2];
   }
   function close_process_full(param){
    var
     errchan = param[3],
     outchan = param[2],
     inchan = param[1],
     proc = [3, inchan, outchan, errchan],
     pid = find_proc_id(cst_close_process_full, proc);
    remove_proc_id(proc);
    caml_call1(Stdlib[93], inchan);
    try{caml_call1(Stdlib[76], outchan);}
    catch(_b$_){
     var _b__ = caml_wrap_exception(_b$_);
     if(_b__[1] !== Stdlib[11]) throw caml_maybe_attach_backtrace(_b__, 0);
    }
    caml_call1(Stdlib[93], errchan);
    return waitpid_non_intr(pid)[2];
   }
   function open_connection(sockaddr){
    var sock = runtime.unix_socket(_l_, domain_of_sockaddr(sockaddr), 0, 0);
    try{
     runtime.unix_connect(sock, sockaddr);
     var
      _b8_ = runtime.unix_outchannel_of_filedescr(sock),
      _b9_ = [0, runtime.unix_inchannel_of_filedescr(sock), _b8_];
     return _b9_;
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     runtime.unix_close(sock);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function shutdown_connection(inchan){
    return runtime.unix_shutdown(caml_channel_descriptor(inchan), 1);
   }
   function establish_server(server_fun, sockaddr){
    var sock = runtime.unix_socket(_n_, domain_of_sockaddr(sockaddr), 0, 0);
    runtime.unix_setsockopt(0, sock, 2, 1);
    runtime.unix_bind(sock, sockaddr);
    runtime.unix_listen(sock, 5);
    for(;;){
     for(;;)
      try{var match = runtime.unix_accept(_m_, sock); break;}
      catch(_b7_){
       var _b5_ = caml_wrap_exception(_b7_);
       if(_b5_[1] === Unix_error){
        var _b6_ = _b5_[2];
        if(typeof _b6_ === "number" && 11 === _b6_) continue;
       }
       throw caml_maybe_attach_backtrace(_b5_, 0);
      }
     var s = match[1], id = runtime.unix_fork(0);
     if(0 === id){
      if(0 !== runtime.unix_fork(0)) runtime.unix_exit(0);
      runtime.unix_close(sock);
      var
       inchan = runtime.unix_inchannel_of_filedescr(s),
       outchan = runtime.unix_outchannel_of_filedescr(s);
      caml_call2(server_fun, inchan, outchan);
      caml_call1(Stdlib[99], 0);
     }
     else{runtime.unix_close(s); waitpid_non_intr(id);}
    }
   }
   var
    Unix =
      [0,
       Unix_error,
       function(_b4_){return runtime.unix_error_message(_b4_);},
       handle_unix_error,
       function(_b3_){return runtime.unix_environment(_b3_);},
       function(_b2_){return runtime.unix_environment_unsafe(_b2_);},
       runtime.caml_sys_getenv,
       runtime.caml_sys_unsafe_getenv,
       function(_b1_, _b0_){return runtime.unix_putenv(_b1_, _b0_);},
       function(_bZ_, _bY_){return runtime.unix_execv(_bZ_, _bY_);},
       function(_bX_, _bW_, _bV_){
        return runtime.unix_execve(_bX_, _bW_, _bV_);
       },
       function(_bU_, _bT_){return runtime.unix_execvp(_bU_, _bT_);},
       function(_bS_, _bR_, _bQ_){
        return runtime.unix_execvpe(_bS_, _bR_, _bQ_);
       },
       function(_bP_){return runtime.unix_fork(_bP_);},
       function(_bO_){return runtime.unix_wait(_bO_);},
       function(_bN_, _bM_){return runtime.unix_waitpid(_bN_, _bM_);},
       system,
       function(_bL_){return runtime.unix_exit(_bL_);},
       function(_bK_){return runtime.unix_getpid(_bK_);},
       function(_bJ_){return runtime.unix_getppid(_bJ_);},
       function(_bI_){return runtime.unix_nice(_bI_);},
       stdin,
       stdout,
       stderr,
       function(_bH_, _bG_, _bF_){return runtime.unix_open(_bH_, _bG_, _bF_);},
       function(_bE_){return runtime.unix_close(_bE_);},
       function(_bD_){return runtime.unix_fsync(_bD_);},
       read,
       write,
       single_write,
       write_substring,
       single_write_substring,
       function(_bC_){return runtime.unix_inchannel_of_filedescr(_bC_);},
       function(_bB_){return runtime.unix_outchannel_of_filedescr(_bB_);},
       caml_channel_descriptor,
       caml_channel_descriptor,
       function(_bA_, _bz_, _by_){
        return runtime.unix_lseek(_bA_, _bz_, _by_);
       },
       function(_bx_, _bw_){return runtime.unix_truncate(_bx_, _bw_);},
       function(_bv_, _bu_){return runtime.unix_ftruncate(_bv_, _bu_);},
       runtime.caml_unix_stat,
       runtime.caml_unix_lstat,
       function(_bt_){return runtime.unix_fstat(_bt_);},
       runtime.caml_unix_isatty,
       [0,
        function(_bs_, _br_, _bq_){
         return runtime.unix_lseek_64(_bs_, _br_, _bq_);
        },
        function(_bp_, _bo_){return runtime.unix_truncate_64(_bp_, _bo_);},
        function(_bn_, _bm_){return runtime.unix_ftruncate_64(_bn_, _bm_);},
        runtime.caml_unix_stat_64,
        runtime.caml_unix_lstat_64,
        function(_bl_){return runtime.unix_fstat_64(_bl_);}],
       map_file,
       runtime.caml_unix_unlink,
       function(_bk_, _bj_){return runtime.unix_rename(_bk_, _bj_);},
       function(_bi_, _bh_, _bg_){return runtime.unix_link(_bi_, _bh_, _bg_);},
       function(_bf_){return runtime.unix_realpath(_bf_);},
       function(_be_, _bd_){return runtime.unix_chmod(_be_, _bd_);},
       function(_bc_, _bb_){return runtime.unix_fchmod(_bc_, _bb_);},
       function(_ba_, _a$_, _a__){
        return runtime.unix_chown(_ba_, _a$_, _a__);
       },
       function(_a9_, _a8_, _a7_){
        return runtime.unix_fchown(_a9_, _a8_, _a7_);
       },
       function(_a6_){return runtime.unix_umask(_a6_);},
       function(_a5_, _a4_){return runtime.unix_access(_a5_, _a4_);},
       function(_a3_, _a2_){return runtime.unix_dup(_a3_, _a2_);},
       function(_a1_, _a0_, _aZ_){return runtime.unix_dup2(_a1_, _a0_, _aZ_);},
       function(_aY_){return runtime.unix_set_nonblock(_aY_);},
       function(_aX_){return runtime.unix_clear_nonblock(_aX_);},
       function(_aW_){return runtime.unix_set_close_on_exec(_aW_);},
       function(_aV_){return runtime.unix_clear_close_on_exec(_aV_);},
       runtime.caml_unix_mkdir,
       runtime.caml_unix_rmdir,
       function(_aU_){return runtime.unix_chdir(_aU_);},
       function(_aT_){return runtime.unix_getcwd(_aT_);},
       function(_aS_){return runtime.unix_chroot(_aS_);},
       runtime.caml_unix_opendir,
       runtime.caml_unix_readdir,
       runtime.caml_unix_rewinddir,
       runtime.caml_unix_closedir,
       function(_aR_, _aQ_){return runtime.unix_pipe(_aR_, _aQ_);},
       function(_aP_, _aO_){return runtime.unix_mkfifo(_aP_, _aO_);},
       create_process,
       create_process_env,
       open_process_in,
       open_process_out,
       open_process,
       open_process_full,
       open_process_args_in,
       open_process_args_out,
       open_process_args,
       open_process_args_full,
       process_in_pid,
       process_out_pid,
       process_pid,
       process_full_pid,
       close_process_in,
       close_process_out,
       close_process,
       close_process_full,
       runtime.caml_unix_symlink,
       runtime.caml_unix_has_symlink,
       runtime.caml_unix_readlink,
       function(_aN_, _aM_, _aL_, _aK_){
        return runtime.unix_select(_aN_, _aM_, _aL_, _aK_);
       },
       function(_aJ_, _aI_, _aH_){
        return runtime.unix_lockf(_aJ_, _aI_, _aH_);
       },
       function(_aG_, _aF_){return runtime.unix_kill(_aG_, _aF_);},
       function(_aE_, _aD_){return runtime.unix_sigprocmask(_aE_, _aD_);},
       function(_aC_){return runtime.unix_sigpending(_aC_);},
       function(_aB_){return runtime.unix_sigsuspend(_aB_);},
       pause,
       function(_aA_){return runtime.caml_unix_time(_aA_);},
       function(_az_){return runtime.caml_unix_gettimeofday(_az_);},
       runtime.caml_unix_gmtime,
       runtime.caml_unix_localtime,
       runtime.caml_unix_mktime,
       function(_ay_){return runtime.unix_alarm(_ay_);},
       sleep,
       function(_ax_){return runtime.unix_sleep(_ax_);},
       function(_aw_){return runtime.unix_times(_aw_);},
       function(_av_, _au_, _at_){
        return runtime.unix_utimes(_av_, _au_, _at_);
       },
       function(_as_){return runtime.unix_getitimer(_as_);},
       function(_ar_, _aq_){return runtime.unix_setitimer(_ar_, _aq_);},
       runtime.caml_unix_getuid,
       function(_ap_){return runtime.unix_geteuid(_ap_);},
       function(_ao_){return runtime.unix_setuid(_ao_);},
       function(_an_){return runtime.unix_getgid(_an_);},
       function(_am_){return runtime.unix_getegid(_am_);},
       function(_al_){return runtime.unix_setgid(_al_);},
       function(_ak_){return runtime.unix_getgroups(_ak_);},
       function(_aj_){return runtime.unix_setgroups(_aj_);},
       function(_ai_, _ah_){return runtime.unix_initgroups(_ai_, _ah_);},
       function(_ag_){return runtime.unix_getlogin(_ag_);},
       function(_af_){return runtime.unix_getpwnam(_af_);},
       function(_ae_){return runtime.unix_getgrnam(_ae_);},
       runtime.caml_unix_getpwuid,
       function(_ad_){return runtime.unix_getgrgid(_ad_);},
       function(_ac_){return caml_unix_inet_addr_of_string(_ac_);},
       function(_ab_){return runtime.unix_string_of_inet_addr(_ab_);},
       inet_addr_any,
       inet_addr_loopback,
       inet6_addr_any,
       inet6_addr_loopback,
       is_inet6_addr,
       function(_aa_, _$_, ___, _Z_){
        return runtime.unix_socket(_aa_, _$_, ___, _Z_);
       },
       domain_of_sockaddr,
       function(_Y_, _X_, _W_, _V_){
        return runtime.unix_socketpair(_Y_, _X_, _W_, _V_);
       },
       function(_U_, _T_){return runtime.unix_accept(_U_, _T_);},
       function(_S_, _R_){return runtime.unix_bind(_S_, _R_);},
       function(_Q_, _P_){return runtime.unix_connect(_Q_, _P_);},
       function(_O_, _N_){return runtime.unix_listen(_O_, _N_);},
       function(_M_, _L_){return runtime.unix_shutdown(_M_, _L_);},
       function(_K_){return runtime.unix_getsockname(_K_);},
       function(_J_){return runtime.unix_getpeername(_J_);},
       recv,
       recvfrom,
       send,
       send_substring,
       sendto,
       sendto_substring,
       getsockopt,
       setsockopt,
       getsockopt_int,
       setsockopt_int,
       getsockopt_optint,
       setsockopt_optint,
       getsockopt_float,
       setsockopt_float,
       getsockopt_error,
       open_connection,
       shutdown_connection,
       establish_server,
       function(_I_){return runtime.unix_gethostname(_I_);},
       function(_H_){return runtime.unix_gethostbyname(_H_);},
       function(_G_){return runtime.unix_gethostbyaddr(_G_);},
       function(_F_){return runtime.unix_getprotobyname(_F_);},
       function(_E_){return runtime.unix_getprotobynumber(_E_);},
       function(_D_, _C_){return runtime.unix_getservbyname(_D_, _C_);},
       function(_B_, _A_){return runtime.unix_getservbyport(_B_, _A_);},
       getaddrinfo,
       getnameinfo,
       function(_z_){return runtime.unix_tcgetattr(_z_);},
       function(_y_, _x_, _w_){return runtime.unix_tcsetattr(_y_, _x_, _w_);},
       function(_v_, _u_){return runtime.unix_tcsendbreak(_v_, _u_);},
       function(_t_){return runtime.unix_tcdrain(_t_);},
       function(_s_, _r_){return runtime.unix_tcflush(_s_, _r_);},
       function(_q_, _p_){return runtime.unix_tcflow(_q_, _p_);},
       function(_o_){return runtime.unix_setsid(_o_);}];
   runtime.caml_register_global(136, Unix, "Unix");
   return;
  }
  (globalThis));

//# 1127 "../.js/default/unix/unix.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Unix = global_data.Unix,
    Unix_error = Unix[1],
    error_message = Unix[2],
    handle_unix_error = Unix[3],
    environment = Unix[4],
    unsafe_environment = Unix[5],
    getenv = Unix[6],
    unsafe_getenv = Unix[7],
    putenv = Unix[8],
    execv = Unix[9],
    execve = Unix[10],
    execvp = Unix[11],
    execvpe = Unix[12],
    fork = Unix[13],
    wait = Unix[14],
    waitpid = Unix[15],
    system = Unix[16],
    exit = Unix[17],
    getpid = Unix[18],
    getppid = Unix[19],
    nice = Unix[20],
    stdin = Unix[21],
    stdout = Unix[22],
    stderr = Unix[23],
    openfile = Unix[24],
    close = Unix[25],
    fsync = Unix[26],
    read = Unix[27],
    write = Unix[28],
    single_write = Unix[29],
    write_substring = Unix[30],
    single_write_substring = Unix[31],
    in_channel_of_descr = Unix[32],
    out_channel_of_descr = Unix[33],
    descr_of_in_channel = Unix[34],
    descr_of_out_channel = Unix[35],
    lseek = Unix[36],
    truncate = Unix[37],
    ftruncate = Unix[38],
    stat = Unix[39],
    lstat = Unix[40],
    fstat = Unix[41],
    isatty = Unix[42],
    LargeFile = Unix[43],
    map_file = Unix[44],
    unlink = Unix[45],
    rename = Unix[46],
    link = Unix[47],
    realpath = Unix[48],
    chmod = Unix[49],
    fchmod = Unix[50],
    chown = Unix[51],
    fchown = Unix[52],
    umask = Unix[53],
    access = Unix[54],
    dup = Unix[55],
    dup2 = Unix[56],
    set_nonblock = Unix[57],
    clear_nonblock = Unix[58],
    set_close_on_exec = Unix[59],
    clear_close_on_exec = Unix[60],
    mkdir = Unix[61],
    rmdir = Unix[62],
    chdir = Unix[63],
    getcwd = Unix[64],
    chroot = Unix[65],
    opendir = Unix[66],
    readdir = Unix[67],
    rewinddir = Unix[68],
    closedir = Unix[69],
    pipe = Unix[70],
    mkfifo = Unix[71],
    create_process = Unix[72],
    create_process_env = Unix[73],
    open_process_in = Unix[74],
    open_process_out = Unix[75],
    open_process = Unix[76],
    open_process_full = Unix[77],
    open_process_args_in = Unix[78],
    open_process_args_out = Unix[79],
    open_process_args = Unix[80],
    open_process_args_full = Unix[81],
    process_in_pid = Unix[82],
    process_out_pid = Unix[83],
    process_pid = Unix[84],
    process_full_pid = Unix[85],
    close_process_in = Unix[86],
    close_process_out = Unix[87],
    close_process = Unix[88],
    close_process_full = Unix[89],
    symlink = Unix[90],
    has_symlink = Unix[91],
    readlink = Unix[92],
    select = Unix[93],
    lockf = Unix[94],
    kill = Unix[95],
    sigprocmask = Unix[96],
    sigpending = Unix[97],
    sigsuspend = Unix[98],
    pause = Unix[99],
    time = Unix[100],
    gettimeofday = Unix[101],
    gmtime = Unix[102],
    localtime = Unix[103],
    mktime = Unix[104],
    alarm = Unix[105],
    sleep = Unix[106],
    sleepf = Unix[107],
    times = Unix[108],
    utimes = Unix[109],
    getitimer = Unix[110],
    setitimer = Unix[111],
    getuid = Unix[112],
    geteuid = Unix[113],
    setuid = Unix[114],
    getgid = Unix[115],
    getegid = Unix[116],
    setgid = Unix[117],
    getgroups = Unix[118],
    setgroups = Unix[119],
    initgroups = Unix[120],
    getlogin = Unix[121],
    getpwnam = Unix[122],
    getgrnam = Unix[123],
    getpwuid = Unix[124],
    getgrgid = Unix[125],
    inet_addr_of_string = Unix[126],
    string_of_inet_addr = Unix[127],
    inet_addr_any = Unix[128],
    inet_addr_loopback = Unix[129],
    inet6_addr_any = Unix[130],
    inet6_addr_loopback = Unix[131],
    is_inet6_addr = Unix[132],
    socket = Unix[133],
    domain_of_sockaddr = Unix[134],
    socketpair = Unix[135],
    accept = Unix[136],
    bind = Unix[137],
    connect = Unix[138],
    listen = Unix[139],
    shutdown = Unix[140],
    getsockname = Unix[141],
    getpeername = Unix[142],
    recv = Unix[143],
    recvfrom = Unix[144],
    send = Unix[145],
    send_substring = Unix[146],
    sendto = Unix[147],
    sendto_substring = Unix[148],
    getsockopt = Unix[149],
    setsockopt = Unix[150],
    getsockopt_int = Unix[151],
    setsockopt_int = Unix[152],
    getsockopt_optint = Unix[153],
    setsockopt_optint = Unix[154],
    getsockopt_float = Unix[155],
    setsockopt_float = Unix[156],
    getsockopt_error = Unix[157],
    open_connection = Unix[158],
    shutdown_connection = Unix[159],
    establish_server = Unix[160],
    gethostname = Unix[161],
    gethostbyname = Unix[162],
    gethostbyaddr = Unix[163],
    getprotobyname = Unix[164],
    getprotobynumber = Unix[165],
    getservbyname = Unix[166],
    getservbyport = Unix[167],
    getaddrinfo = Unix[168],
    getnameinfo = Unix[169],
    tcgetattr = Unix[170],
    tcsetattr = Unix[171],
    tcsendbreak = Unix[172],
    tcdrain = Unix[173],
    tcflush = Unix[174],
    tcflow = Unix[175],
    setsid = Unix[176],
    UnixLabels =
      [0,
       Unix_error,
       error_message,
       handle_unix_error,
       environment,
       unsafe_environment,
       getenv,
       unsafe_getenv,
       putenv,
       execv,
       execve,
       execvp,
       execvpe,
       fork,
       wait,
       waitpid,
       system,
       exit,
       getpid,
       getppid,
       nice,
       stdin,
       stdout,
       stderr,
       openfile,
       close,
       fsync,
       read,
       write,
       single_write,
       write_substring,
       single_write_substring,
       in_channel_of_descr,
       out_channel_of_descr,
       descr_of_in_channel,
       descr_of_out_channel,
       lseek,
       truncate,
       ftruncate,
       stat,
       lstat,
       fstat,
       isatty,
       LargeFile,
       map_file,
       unlink,
       rename,
       link,
       realpath,
       chmod,
       fchmod,
       chown,
       fchown,
       umask,
       access,
       dup,
       dup2,
       set_nonblock,
       clear_nonblock,
       set_close_on_exec,
       clear_close_on_exec,
       mkdir,
       rmdir,
       chdir,
       getcwd,
       chroot,
       opendir,
       readdir,
       rewinddir,
       closedir,
       pipe,
       mkfifo,
       create_process,
       create_process_env,
       open_process_in,
       open_process_out,
       open_process,
       open_process_full,
       open_process_args_in,
       open_process_args_out,
       open_process_args,
       open_process_args_full,
       process_in_pid,
       process_out_pid,
       process_pid,
       process_full_pid,
       close_process_in,
       close_process_out,
       close_process,
       close_process_full,
       symlink,
       has_symlink,
       readlink,
       select,
       lockf,
       kill,
       sigprocmask,
       sigpending,
       sigsuspend,
       pause,
       time,
       gettimeofday,
       gmtime,
       localtime,
       mktime,
       alarm,
       sleep,
       sleepf,
       times,
       utimes,
       getitimer,
       setitimer,
       getuid,
       geteuid,
       setuid,
       getgid,
       getegid,
       setgid,
       getgroups,
       setgroups,
       initgroups,
       getlogin,
       getpwnam,
       getgrnam,
       getpwuid,
       getgrgid,
       inet_addr_of_string,
       string_of_inet_addr,
       inet_addr_any,
       inet_addr_loopback,
       inet6_addr_any,
       inet6_addr_loopback,
       is_inet6_addr,
       socket,
       domain_of_sockaddr,
       socketpair,
       accept,
       bind,
       connect,
       listen,
       shutdown,
       getsockname,
       getpeername,
       recv,
       recvfrom,
       send,
       send_substring,
       sendto,
       sendto_substring,
       getsockopt,
       setsockopt,
       getsockopt_int,
       setsockopt_int,
       getsockopt_optint,
       setsockopt_optint,
       getsockopt_float,
       setsockopt_float,
       getsockopt_error,
       open_connection,
       shutdown_connection,
       establish_server,
       gethostname,
       gethostbyname,
       gethostbyaddr,
       getprotobyname,
       getprotobynumber,
       getservbyname,
       getservbyport,
       getaddrinfo,
       getnameinfo,
       tcgetattr,
       tcsetattr,
       tcsendbreak,
       tcdrain,
       tcflush,
       tcflow,
       setsid];
   runtime.caml_register_global(1, UnixLabels, "UnixLabels");
   return;
  }
  (globalThis));


//# 1 "../.js/default/bigarray/bigarray.cma.js"
// Generated by js_of_ocaml
//# 3 "../.js/default/bigarray/bigarray.cma.js"

//# 7 "../.js/default/bigarray/bigarray.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Stdlib_Bigarray = global_data.Stdlib__Bigarray,
    float32 = Stdlib_Bigarray[1],
    float64 = Stdlib_Bigarray[2],
    complex32 = Stdlib_Bigarray[3],
    complex64 = Stdlib_Bigarray[4],
    int8_signed = Stdlib_Bigarray[5],
    int8_unsigned = Stdlib_Bigarray[6],
    int16_signed = Stdlib_Bigarray[7],
    int16_unsigned = Stdlib_Bigarray[8],
    int$0 = Stdlib_Bigarray[9],
    int32 = Stdlib_Bigarray[10],
    int64 = Stdlib_Bigarray[11],
    nativeint = Stdlib_Bigarray[12],
    char$0 = Stdlib_Bigarray[13],
    kind_size_in_bytes = Stdlib_Bigarray[14],
    c_layout = Stdlib_Bigarray[15],
    fortran_layout = Stdlib_Bigarray[16],
    array0_of_genarray = Stdlib_Bigarray[22],
    array1_of_genarray = Stdlib_Bigarray[23],
    array2_of_genarray = Stdlib_Bigarray[24],
    array3_of_genarray = Stdlib_Bigarray[25],
    reshape = Stdlib_Bigarray[26],
    reshape_0 = Stdlib_Bigarray[27],
    reshape_1 = Stdlib_Bigarray[28],
    reshape_2 = Stdlib_Bigarray[29],
    reshape_3 = Stdlib_Bigarray[30],
    Bigarray =
      [0,
       float32,
       float64,
       complex32,
       complex64,
       int8_signed,
       int8_unsigned,
       int16_signed,
       int16_unsigned,
       int$0,
       int32,
       int64,
       nativeint,
       char$0,
       kind_size_in_bytes,
       c_layout,
       fortran_layout,
       array0_of_genarray,
       array1_of_genarray,
       array2_of_genarray,
       array3_of_genarray,
       reshape,
       reshape_0,
       reshape_1,
       reshape_2,
       reshape_3];
   runtime.caml_register_global(1, Bigarray, "Bigarray");
   return;
  }
  (globalThis));


//# 1 "../.js/default/react/react.cma.js"
// Generated by js_of_ocaml
//# 3 "../.js/default/react/react.cma.js"

//# 6 "../.js/default/react/react.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_src_react_ml = "src/react.ml",
    caml_equal = runtime.caml_equal,
    caml_int_compare = runtime.caml_int_compare,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    err_max_rank = "maximal rank exceeded",
    err_sig_undef = "signal value undefined yet",
    err_fix = "trying to fix a delayed value",
    err_retain_never = "E.never cannot retain a closure",
    err_retain_cst_sig = "constant signals cannot retain a closure",
    err_step_executed = "step already executed",
    err_event_scheduled = "event already scheduled on a step",
    err_signal_scheduled = "signal already scheduled on a step",
    one = [0, 1],
    zero = [0, 0],
    zero$0 = [0, 0],
    one$0 = [0, 1],
    minus_one = [0, -1],
    zero$1 = [0, 0.],
    one$1 = [0, 1.],
    minus_one$0 = [0, -1.],
    none = [0, 0],
    Assert_failure = global_data.Assert_failure,
    Stdlib = global_data.Stdlib,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Weak = global_data.Stdlib__Weak;
   function create(size){return [0, caml_call1(Stdlib_Weak[1], size), 0];}
   function clear(a){
    a[1] = caml_call1(Stdlib_Weak[1], 0);
    a[2] = 0;
    return 0;
   }
   function get(a, i){return caml_call2(Stdlib_Weak[4], a[1], i);}
   function swap(a, i$0, i){
    var v = caml_call2(Stdlib_Weak[4], a[1], i);
    caml_call5(Stdlib_Weak[8], a[1], i$0, a[1], i, 1);
    return caml_call3(Stdlib_Weak[3], a[1], i$0, v);
   }
   function add(a, v){
    var _cy_ = caml_call1(Stdlib_Weak[2], a[1]);
    if(a[2] === _cy_){
     var arr = caml_call1(Stdlib_Weak[1], 2 * (a[2] + 1 | 0) | 0);
     caml_call5(Stdlib_Weak[8], a[1], 0, arr, 0, a[2]);
     a[1] = arr;
    }
    caml_call3(Stdlib_Weak[3], a[1], a[2], [0, v]);
    a[2] = a[2] + 1 | 0;
    return 0;
   }
   function rem_last(a){
    var l = a[2] - 1 | 0;
    a[2] = l;
    return caml_call3(Stdlib_Weak[3], a[1], l, 0);
   }
   function fold(f, acc, a){
    var acc$0 = [0, acc], _cw_ = a[2] - 1 | 0, _cv_ = 0;
    if(_cw_ >= 0){
     var i = _cv_;
     for(;;){
      var match = caml_call2(Stdlib_Weak[4], a[1], i);
      if(match){var v = match[1]; acc$0[1] = caml_call2(f, acc$0[1], v);}
      var _cx_ = i + 1 | 0;
      if(_cw_ === i) break;
      i = _cx_;
     }
    }
    return acc$0[1];
   }
   function compare_down(h, i$0, i){
    var match = get(h, i$0), match$0 = get(h, i);
    if(! match) return match$0 ? -1 : 0;
    var n = match[1];
    if(! match$0) return 1;
    var n$0 = match$0[1];
    return caml_int_compare(n[1], n$0[1]);
   }
   function down(h, i){
    var i$0 = i;
    for(;;){
     var
      last = h[2] - 1 | 0,
      start = 2 * i$0 | 0,
      l = start + 1 | 0,
      r = start + 2 | 0;
     if(last < l) return 0;
     var
      child = last < r ? l : 0 <= compare_down(h, l, r) ? r : l,
      _cu_ = 0 < compare_down(h, i$0, child) ? 1 : 0;
     if(! _cu_) return _cu_;
     swap(h, i$0, child);
     i$0 = child;
    }
   }
   var delayed_rank = Stdlib[19], nil = [0, 1, create(0), 0, 0];
   function create$0(param){var h = create(11); return [0, 0, h, 0, 0];}
   function add$0(c, n$1){
    if(n$1[2] === c) return 0;
    n$1[2] = c;
    var h = c[2];
    add(h, n$1);
    var i$0 = h[2] - 1 | 0, i = i$0, last_none = 0;
    for(;;){
     if(0 === i) return last_none ? down(h, 0) : last_none;
     var p = (i - 1 | 0) / 2 | 0, match = get(h, i), match$0 = get(h, p);
     if(! match) return 0;
     var n = match[1];
     if(match$0){
      var n$0 = match$0[1];
      if(0 <= caml_int_compare(n[1], n$0[1]))
       return last_none ? down(h, i) : last_none;
      swap(h, i, p);
      i = p;
      last_none = 0;
     }
     else{swap(h, i, p); i = p; last_none = 1;}
    }
   }
   function add_deps(c, n){
    var a = n[6], _cs_ = a[2] - 1 | 0, _cr_ = 0;
    if(_cs_ >= 0){
     var i = _cr_;
     for(;;){
      var match = caml_call2(Stdlib_Weak[4], a[1], i);
      if(match){var v = match[1]; add$0(c, v);}
      var _ct_ = i + 1 | 0;
      if(_cs_ === i) break;
      i = _ct_;
     }
    }
    return 0;
   }
   function add_eop(c, op){c[3] = [0, op, c[3]]; return 0;}
   function allow_reschedule(n){n[2] = nil; return;}
   function rebuild(c){
    var h = c[2], _cp_ = (h[2] - 2 | 0) / 2 | 0;
    if(_cp_ >= 0){
     var i = _cp_;
     for(;;){down(h, i); var _cq_ = i - 1 | 0; if(0 === i) break; i = _cq_;}
    }
    return 0;
   }
   function execute(c$1){
    if(c$1[1]) return caml_call1(Stdlib[1], err_step_executed);
    var c = c$1;
    for(;;){
     var
      eops =
        function(c){
         caml_call2
          (Stdlib_List[17], function(op){return caml_call1(op, 0);}, c[3]);
         c[3] = 0;
         return;
        },
      cops =
        function(c){
         caml_call2
          (Stdlib_List[17], function(op){return caml_call1(op, 0);}, c[4]);
         c[4] = 0;
         return;
        },
      finish = function(c){c[1] = 1; c[2] = create(0); return 0;};
     for(;;){
      var a = c[2];
      a:
      {
       b:
       {
        for(;;){
         var s = a[2];
         if(0 === s) break b;
         var v = get(a, 0);
         if(1 < s){
          var _cn_ = get(a, s - 1 | 0);
          caml_call1(caml_call2(Stdlib_Weak[3], a[1], 0), _cn_);
          rem_last(a);
          down(a, 0);
         }
         else
          rem_last(a);
         if(v) break;
        }
        var match = v;
        break a;
       }
       var match = 0;
      }
      if(! match){eops(c); cops(c); return finish(c);}
      var n = match[1];
      if(n[1] === delayed_rank) break;
      caml_call1(n[5], c);
     }
     var c$0 = create$0(0);
     eops(c);
     var h = c[2];
     let c$1 = c$0;
     var _co_ = [0, n, fold(function(acc, e){return [0, e, acc];}, 0, h)];
     caml_call2
      (Stdlib_List[17], function(n){return caml_call1(n[5], c$1);}, _co_);
     cops(c);
     finish(c);
     c = c$0;
    }
   }
   function find_unfinished(nl){
    var next = 0, param = [0, nl, 0];
    for(;;)
     if(param){
      var nl$0 = param[1];
      if(nl$0){
       var todo = param[2], next$0 = next, param$0 = nl$0;
       for(;;){
        if(! param$0) break;
        var nl$1 = param$0[2], n = param$0[1];
        if(! n[2][1]) return n[2];
        var next$1 = [0, caml_call1(n[4], 0), next$0];
        next$0 = next$1;
        param$0 = nl$1;
       }
       next = next$0;
       param = todo;
      }
      else{var todo$0 = param[2]; param = todo$0;}
     }
     else{if(0 === next) return nil; param = next; next = 0;}
   }
   var min_rank = Stdlib[20], max_rank = delayed_rank - 1 | 0;
   function nop(param){return 0;}
   function no_producers(param){return 0;}
   function create$1(r){
    return [0, r, nil, nop, no_producers, nop, create(0)];
   }
   function rem_dep(n$0, n){
    var a = n$0[6];
    try{
     var _ck_ = a[2] - 1 | 0, _cj_ = 0;
     if(_ck_ >= 0){
      var i = _cj_;
      for(;;){
       var match = caml_call2(Stdlib_Weak[4], a[1], i);
       if(match){
        var v = match[1];
        if(n === v){
         caml_call3(Stdlib_Weak[3], a[1], i, 0);
         throw caml_maybe_attach_backtrace(Stdlib[3], 1);
        }
       }
       var _cl_ = i + 1 | 0;
       if(_ck_ === i) break;
       i = _cl_;
      }
     }
     return;
    }
    catch(_cm_){
     var _ci_ = caml_wrap_exception(_cm_);
     if(_ci_ === Stdlib[3]) return;
     throw caml_maybe_attach_backtrace(_ci_, 0);
    }
   }
   function add_dep(n$0, n){
    var a = n$0[6];
    try{
     var _ce_ = a[2] - 1 | 0, _cd_ = 0;
     if(_ce_ >= 0){
      var i = _cd_;
      for(;;){
       if(! caml_call2(Stdlib_Weak[4], a[1], i)){
        caml_call3(Stdlib_Weak[3], a[1], i, [0, n]);
        throw caml_maybe_attach_backtrace(Stdlib[3], 1);
       }
       var _cg_ = i + 1 | 0;
       if(_ce_ === i) break;
       i = _cg_;
      }
     }
     var _cf_ = add(a, n);
     return _cf_;
    }
    catch(_ch_){
     var _cc_ = caml_wrap_exception(_ch_);
     if(_cc_ === Stdlib[3]) return 0;
     throw caml_maybe_attach_backtrace(_cc_, 0);
    }
   }
   function deps(n){
    return fold(function(acc, d){return [0, d, acc];}, 0, n[6]);
   }
   function bind(n, p, u){n[4] = p; n[5] = u; return 0;}
   function stop(opt, to_rem){
    if(opt) var sth = opt[1], strong = sth; else var strong = 0;
    if(! strong){
     to_rem[4] = no_producers;
     to_rem[5] = nop;
     return clear(to_rem[6]);
    }
    var producers = caml_call1(to_rem[4], 0);
    to_rem[4] = no_producers;
    to_rem[5] = nop;
    clear(to_rem[6]);
    var next = 0, to_rem$0 = to_rem, param = producers;
    for(;;)
     if(param){
      var todo = param[2], n = param[1];
      rem_dep(n, to_rem$0);
      if(n[1] !== min_rank){
       var a = n[6];
       try{
        var _b9_ = a[2] - 1 | 0, _b8_ = 0;
        if(_b9_ >= 0){
         var i = _b8_;
         for(;;){
          if(caml_call2(Stdlib_Weak[6], a[1], i))
           throw caml_maybe_attach_backtrace(Stdlib[3], 1);
          var _b$_ = i + 1 | 0;
          if(_b9_ === i) break;
          i = _b$_;
         }
        }
        var _b__ = 1, _ca_ = _b__;
       }
       catch(_cb_){
        var _b7_ = caml_wrap_exception(_cb_);
        if(_b7_ !== Stdlib[3]) throw caml_maybe_attach_backtrace(_b7_, 0);
        var _ca_ = 0;
       }
       if(! (1 - _ca_)){
        var prods = caml_call1(n[4], 0);
        n[4] = no_producers;
        n[5] = nop;
        clear(n[6]);
        var next$0 = [0, [0, n, prods], next];
        next = next$0;
        param = todo;
        continue;
       }
      }
      param = todo;
     }
     else{
      if(! next) return 0;
      var
       next$1 = next[2],
       match = next[1],
       prods$0 = match[2],
       to_rem$1 = match[1];
      next = next$1;
      to_rem$0 = to_rem$1;
      param = prods$0;
     }
   }
   var
    rmin = create$1(min_rank),
    _a_ = [0, cst_src_react_ml, 410, 54],
    _b_ = [0, cst_src_react_ml, 421, 51];
   function rmax(n$0, n){return n[1] < n$0[1] ? n$0 : n;}
   function rsucc(n){
    return n[1] === delayed_rank
            ? min_rank
            : n
               [1]
              < max_rank
              ? n[1] + 1 | 0
              : caml_call1(Stdlib[1], err_max_rank);
   }
   function rsucc2(n$0, n){
    var r = rsucc(n$0), r$0 = rsucc(n);
    return r$0 < r ? r : r$0;
   }
   function update_rank(n, r){
    if(n[1] >= r) return 0;
    n[1] = r;
    var param = [0, n, 0];
    for(;;){
     if(! param) return 1;
     var todo = param[2], n$0 = param[1];
     let n = n$0;
     var
      update =
        function(todo, d){
         if(n[1] >= d[1] && n[1] !== delayed_rank){d[1] = rsucc(n); return [0, d, todo];}
         return todo;
        };
     param = fold(update, todo, n$0[6]);
    }
   }
   function eval$0(m){
    var match = m[1][1];
    if(! match)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
    var v = match[1];
    return v;
   }
   function emut(rank){return [0, [0, 0], create$1(rank)];}
   function event(m, p, u){bind(m[2], p, u); return [0, m];}
   function eupdate(v, m, c){
    m[1][1] = [0, v];
    var v$0 = m[1];
    function op(_b6_){v$0[1] = 0; return 0;}
    c[4] = [0, op, c[4]];
    return add_deps(c, m[2]);
   }
   function sval(m){
    var match = m[1];
    if(! match)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
    var v = match[1];
    return v;
   }
   function smut(rank, eq){return [0, 0, eq, create$1(rank)];}
   function signal(i, m, p, u){
    bind(m[3], p, u);
    if(i) m[1] = i;
    var c = find_unfinished(caml_call1(m[3][4], 0));
    if(c === nil) caml_call1(m[3][5], nil); else add$0(c, m[3]);
    return [1, m];
   }
   function supdate(v, m, c){
    var match = m[1];
    if(! match){m[1] = [0, v]; return 0;}
    var v$0 = match[1];
    if(caml_call2(m[2], v, v$0)) return 0;
    m[1] = [0, v];
    var _b5_ = c !== nil ? 1 : 0;
    return _b5_ ? add_deps(c, m[3]) : _b5_;
   }
   function add_dep$0(m, n){
    add_dep(m[2], n);
    var _b4_ = 0 !== m[1][1] ? 1 : 0;
    return _b4_ ? add$0(m[2][2], n) : _b4_;
   }
   var
    _c_ = [0, 1],
    _d_ = [0, cst_src_react_ml, 701, 19],
    _e_ = [0, cst_src_react_ml, 731, 53],
    _f_ = [0, cst_src_react_ml, 760, 45];
   function create$2(param){
    var m = emut(min_rank);
    return [0,
            [0, m],
            function(step, v){
             if(! step){
              var c$0 = create$0(0);
              m[2][2] = c$0;
              eupdate(v, m, c$0);
              return execute(c$0);
             }
             var c = step[1];
             if(c[1])
              caml_call1(Stdlib[1], err_step_executed);
             else if(m[2][2][1])
              m[2][2] = c;
             else
              caml_call1(Stdlib[1], err_event_scheduled);
             return eupdate(v, m, c);
            }];
   }
   function retain(e, c){
    if(! e) return caml_call1(Stdlib[1], err_retain_never);
    var m = e[1], c$0 = m[2][3];
    m[2][3] = c;
    return [0, 82, c$0];
   }
   function stop$0(strong, param){
    if(! param) return 0;
    var m = param[1];
    return stop(strong, m[2]);
   }
   function equal(e$0, e){
    if(e$0){
     if(e){var m = e[1], m$0 = e$0[1]; return m$0 === m ? 1 : 0;}
    }
    else if(! e) return 1;
    return 0;
   }
   function trace(opt, t, e){
    if(opt) var sth = opt[1], iff = sth; else var iff = _c_;
    if(0 === iff[0]){
     if(! iff[1]) return e;
     if(! e) return e;
     var
      m = e[1],
      m$0 = emut(rsucc(m[2])),
      p = function(param){return [0, m[2], 0];},
      u =
        function(c){
         var v = eval$0(m);
         caml_call1(t, v);
         return eupdate(v, m$0, c);
        };
     add_dep$0(m, m$0[2]);
     return event(m$0, p, u);
    }
    var mc = iff[1];
    if(! e) return 0;
    var m$1 = e[1], m$2 = emut(rsucc2(mc[3], m$1[2]));
    function p$0(param){return [0, mc[3], [0, m$1[2], 0]];}
    function u$0(c){
     var match = m$1[1][1];
     if(! match) return 0;
     var v = match[1];
     if(sval(mc)) caml_call1(t, v);
     return eupdate(v, m$2, c);
    }
    add_dep(mc[3], m$2[2]);
    add_dep$0(m$1, m$2[2]);
    return event(m$2, p$0, u$0);
   }
   function once(param){
    if(! param) return 0;
    var m = param[1], m$0 = emut(rsucc(m[2]));
    function p(param){return [0, m[2], 0];}
    function u(c){
     rem_dep(m[2], m$0[2]);
     eupdate(eval$0(m), m$0, c);
     return stop(0, m$0[2]);
    }
    add_dep$0(m, m$0[2]);
    return event(m$0, p, u);
   }
   function drop_once(param){
    if(! param) return 0;
    var m = param[1], m$0 = emut(rsucc(m[2]));
    function p(param){return [0, m[2], 0];}
    function u(c){
     function u(c){return eupdate(eval$0(m), m$0, c);}
     return bind(m$0[2], p, u);
    }
    add_dep$0(m, m$0[2]);
    return event(m$0, p, u);
   }
   function app(ef, param){
    if(! param) return 0;
    var m = param[1];
    if(! ef) return 0;
    var mf = ef[1], m$0 = emut(rsucc2(m[2], mf[2]));
    function p(param){return [0, m[2], [0, mf[2], 0]];}
    function u(c){
     var _b3_ = mf[1][1], match = m[1][1];
     if(_b3_ && match){
      var v = match[1], f = _b3_[1];
      return eupdate(caml_call1(f, v), m$0, c);
     }
     return 0;
    }
    add_dep$0(m, m$0[2]);
    add_dep$0(mf, m$0[2]);
    return event(m$0, p, u);
   }
   function map(f, param){
    if(! param) return 0;
    var m = param[1], m$0 = emut(rsucc(m[2]));
    function p(param){return [0, m[2], 0];}
    function u(c){return eupdate(caml_call1(f, eval$0(m)), m$0, c);}
    add_dep$0(m, m$0[2]);
    return event(m$0, p, u);
   }
   function stamp(e, v){
    if(! e) return 0;
    var m = e[1], m$0 = emut(rsucc(m[2]));
    function p(param){return [0, m[2], 0];}
    function u(c){return eupdate(v, m$0, c);}
    add_dep$0(m, m$0[2]);
    return event(m$0, p, u);
   }
   function filter(pred, param){
    if(! param) return 0;
    var m = param[1], m$0 = emut(rsucc(m[2]));
    function p(param){return [0, m[2], 0];}
    function u(c){
     var v = eval$0(m);
     return caml_call1(pred, v) ? eupdate(v, m$0, c) : 0;
    }
    add_dep$0(m, m$0[2]);
    return event(m$0, p, u);
   }
   function fmap(fm, param){
    if(! param) return 0;
    var m = param[1], m$0 = emut(rsucc(m[2]));
    function p(param){return [0, m[2], 0];}
    function u(c){
     var match = caml_call1(fm, eval$0(m));
     if(! match) return 0;
     var v = match[1];
     return eupdate(v, m$0, c);
    }
    add_dep$0(m, m$0[2]);
    return event(m$0, p, u);
   }
   function diff(d, param){
    if(! param) return 0;
    var m = param[1], m$0 = emut(rsucc(m[2])), last = [0, 0];
    function p(param){return [0, m[2], 0];}
    function u(c){
     var v = eval$0(m), match = last[1];
     if(match){
      var v$0 = match[1];
      last[1] = [0, v];
      return eupdate(caml_call2(d, v, v$0), m$0, c);
     }
     last[1] = [0, v];
     return 0;
    }
    add_dep$0(m, m$0[2]);
    return event(m$0, p, u);
   }
   function changes(opt, param){
    if(opt) var sth = opt[1], eq = sth; else var eq = caml_equal;
    if(! param) return 0;
    var m = param[1], m$0 = emut(rsucc(m[2])), last = [0, 0];
    function p(param){return [0, m[2], 0];}
    function u(c){
     var v = eval$0(m), match = last[1];
     if(match){
      var v$0 = match[1];
      last[1] = [0, v];
      return caml_call2(eq, v, v$0) ? 0 : eupdate(v, m$0, c);
     }
     last[1] = [0, v];
     return eupdate(v, m$0, c);
    }
    add_dep$0(m, m$0[2]);
    return event(m$0, p, u);
   }
   function on(c, e){
    if(! e) return 0;
    var m = e[1];
    if(0 === c[0]) return c[1] ? e : 0;
    var mc = c[1], m$0 = emut(rsucc2(m[2], mc[3]));
    function p(param){return [0, m[2], [0, mc[3], 0]];}
    function u(c){
     return m[1][1] ? sval(mc) ? eupdate(eval$0(m), m$0, c) : 0 : 0;
    }
    add_dep$0(m, m$0[2]);
    add_dep(mc[3], m$0[2]);
    return event(m$0, p, u);
   }
   function dismiss(c, e){
    if(! e) return 0;
    var m = e[1];
    if(! c) return e;
    var mc = c[1], m$0 = emut(rsucc2(mc[2], m[2]));
    function p(param){return [0, mc[2], [0, m[2], 0]];}
    function u(c){return mc[1][1] ? 0 : eupdate(eval$0(m), m$0, c);}
    add_dep$0(mc, m$0[2]);
    add_dep$0(m, m$0[2]);
    return event(m$0, p, u);
   }
   function until(c, e){
    if(! e) return 0;
    var m = e[1];
    if(! c) return e;
    var mc = c[1], m$0 = emut(rsucc2(m[2], mc[2]));
    function p(param){return [0, m[2], [0, mc[2], 0]];}
    function u(c){
     return mc[1][1]
             ? (rem_dep
                (m[2], m$0[2]),
               rem_dep(mc[2], m$0[2]),
               stop(0, m$0[2]))
             : eupdate(eval$0(m), m$0, c);
    }
    add_dep$0(m, m$0[2]);
    add_dep$0(mc, m$0[2]);
    return event(m$0, p, u);
   }
   function accum(ef, i){
    if(! ef) return 0;
    var m = ef[1], m$0 = emut(rsucc(m[2])), acc = [0, i];
    function p(param){return [0, m[2], 0];}
    function u(c){
     var _b2_ = acc[1];
     acc[1] = caml_call1(eval$0(m), _b2_);
     return eupdate(acc[1], m$0, c);
    }
    add_dep$0(m, m$0[2]);
    return event(m$0, p, u);
   }
   function fold$0(f, i, param){
    if(! param) return 0;
    var m = param[1], m$0 = emut(rsucc(m[2])), acc = [0, i];
    function p(param){return [0, m[2], 0];}
    function u(c){
     var _b1_ = eval$0(m);
     acc[1] = caml_call2(f, acc[1], _b1_);
     return eupdate(acc[1], m$0, c);
    }
    add_dep$0(m, m$0[2]);
    return event(m$0, p, u);
   }
   function occurs(m){return 0 !== m[1][1] ? 1 : 0;}
   function find_muts_and_next_rank(el){
    var acc = 0, max = rmin, param = el;
    for(;;){
     if(! param){
      var _b0_ = rsucc(max);
      return [0, caml_call1(Stdlib_List[9], acc), _b0_];
     }
     var match = param[1];
     if(match){
      var
       l = param[2],
       m = match[1],
       max$0 = rmax(max, m[2]),
       acc$0 = [0, m, acc];
      acc = acc$0;
      max = max$0;
      param = l;
     }
     else{var l$0 = param[2]; param = l$0;}
    }
   }
   function select(el){
    var
     match = find_muts_and_next_rank(el),
     r = match[2],
     emuts = match[1],
     m = emut(r);
    function p(param){
     return caml_call2(Stdlib_List[21], function(m){return m[2];}, emuts);
    }
    function u(c){
     try{
      var
       _bY_ =
         eupdate(eval$0(caml_call2(Stdlib_List[38], occurs, emuts)), m, c);
      return _bY_;
     }
     catch(_bZ_){
      var _bX_ = caml_wrap_exception(_bZ_);
      if(_bX_ === Stdlib[8])
       throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
      throw caml_maybe_attach_backtrace(_bX_, 0);
     }
    }
    caml_call2
     (Stdlib_List[17], function(m$0){return add_dep$0(m$0, m[2]);}, emuts);
    return event(m, p, u);
   }
   function merge(f, acc, el){
    var
     match = find_muts_and_next_rank(el),
     r = match[2],
     emuts = match[1],
     m = emut(r);
    function p(param){
     return caml_call2(Stdlib_List[21], function(m){return m[2];}, emuts);
    }
    function u(c){
     var acc$0 = acc, param = emuts;
     for(;;){
      if(! param) return eupdate(acc$0, m, c);
      var m$0 = param[1], l = param[2];
      if(occurs(m$0)){
       var acc$1 = caml_call2(f, acc$0, eval$0(m$0));
       acc$0 = acc$1;
       param = l;
      }
      else{var l$0 = param[2]; param = l$0;}
     }
    }
    caml_call2
     (Stdlib_List[17], function(m$0){return add_dep$0(m$0, m[2]);}, emuts);
    return event(m, p, u);
   }
   function switch$0(e, param){
    if(! param) return e;
    var ms = param[1];
    if(e) var m = e[1], r = rsucc2(m[2], ms[2]); else var r = rsucc(ms[2]);
    var m$0 = emut(r), src = [0, e];
    function p(param){
     var match = src[1];
     if(! match) return [0, ms[2], 0];
     var m = match[1];
     return [0, m[2], [0, ms[2], 0]];
    }
    function u(c){
     var match = ms[1][1];
     if(! match){
      var match$2 = src[1];
      if(! match$2)
       throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
      var m$2 = match$2[1];
      return eupdate(eval$0(m$2), m$0, c);
     }
     var e = match[1], match$0 = src[1];
     if(match$0){var m = match$0[1]; rem_dep(m[2], m$0[2]);}
     src[1] = e;
     if(! e){var _bW_ = rsucc(ms[2]); update_rank(m$0[2], _bW_); return 0;}
     var m$1 = e[1];
     add_dep(m$1[2], m$0[2]);
     var _bV_ = rsucc2(m$1[2], ms[2]);
     if(update_rank(m$0[2], _bV_)){
      allow_reschedule(m$0[2]);
      return rebuild(c);
     }
     var match$1 = m$1[1][1];
     if(! match$1) return 0;
     var v = match$1[1];
     return eupdate(v, m$0, c);
    }
    if(e){var m$1 = e[1]; add_dep$0(m$1, m$0[2]);}
    add_dep$0(ms, m$0[2]);
    return event(m$0, p, u);
   }
   function fix(f){
    var
     m = emut(delayed_rank),
     e =
       event
        (m,
         function(param){return 0;},
         function(param){
          throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
         }),
     _bS_ = caml_call1(f, e),
     match = _bS_[1];
    if(! match){var r$0 = _bS_[2]; return r$0;}
    var r = _bS_[2], m$0 = match[1];
    if(m$0[2][1] === delayed_rank) caml_call1(Stdlib[1], err_fix);
    function p(param){return 0;}
    function u(c){
     var _bT_ = [0, eval$0(m$0)];
     m[1][1] = _bT_;
     var v = m[1];
     add_eop(c, function(_bU_){v[1] = 0; return 0;});
     return add_deps(c, m[2]);
    }
    bind(m[2], p, u);
    add_dep$0(m$0, m[2]);
    return r;
   }
   function l2(f, e0, e1){
    if(! e0) return 0;
    if(! e1) return 0;
    var m1 = e1[1], m0 = e0[1], r = rsucc2(m0[2], m1[2]), m = emut(r);
    function p(param){return [0, m0[2], [0, m1[2], 0]];}
    function u(c){
     var _bR_ = m0[1][1], match = m1[1][1];
     if(_bR_ && match){
      var v1 = match[1], v0 = _bR_[1];
      return eupdate(caml_call2(f, v0, v1), m, c);
     }
     return 0;
    }
    add_dep$0(m0, m[2]);
    add_dep$0(m1, m[2]);
    return event(m, p, u);
   }
   function l3(f, e0, e1, e2){
    if(! e0) return 0;
    if(! e1) return 0;
    if(! e2) return 0;
    var
     m2 = e2[1],
     m1 = e1[1],
     m0 = e0[1],
     _bO_ = m2[2],
     r = rsucc(rmax(rmax(m0[2], m1[2]), _bO_)),
     m = emut(r);
    function p(param){return [0, m0[2], [0, m1[2], [0, m2[2], 0]]];}
    function u(c){
     var _bP_ = m0[1][1], _bQ_ = m1[1][1], match = m2[1][1];
     if(_bP_ && _bQ_ && match){
      var v2 = match[1], v1 = _bQ_[1], v0 = _bP_[1];
      return eupdate(caml_call3(f, v0, v1, v2), m, c);
     }
     return 0;
    }
    add_dep$0(m0, m[2]);
    add_dep$0(m1, m[2]);
    add_dep$0(m2, m[2]);
    return event(m, p, u);
   }
   function l4(f, e0, e1, e2, e3){
    if(! e0) return 0;
    if(! e1) return 0;
    if(! e2) return 0;
    if(! e3) return 0;
    var
     m3 = e3[1],
     m2 = e2[1],
     m1 = e1[1],
     m0 = e0[1],
     _bK_ = rmax(m2[2], m3[2]),
     r = rsucc(rmax(rmax(m0[2], m1[2]), _bK_)),
     m = emut(r);
    function p(param){
     return [0, m0[2], [0, m1[2], [0, m2[2], [0, m3[2], 0]]]];
    }
    function u(c){
     var _bL_ = m0[1][1], _bM_ = m1[1][1], _bN_ = m2[1][1], match = m3[1][1];
     if(_bL_ && _bM_ && _bN_ && match){
      var v3 = match[1], v2 = _bN_[1], v1 = _bM_[1], v0 = _bL_[1];
      return eupdate(caml_call4(f, v0, v1, v2, v3), m, c);
     }
     return 0;
    }
    add_dep$0(m0, m[2]);
    add_dep$0(m1, m[2]);
    add_dep$0(m2, m[2]);
    add_dep$0(m3, m[2]);
    return event(m, p, u);
   }
   function l5(f, e0, e1, e2, e3, e4){
    if(! e0) return 0;
    if(! e1) return 0;
    if(! e2) return 0;
    if(! e3) return 0;
    if(! e4) return 0;
    var
     m4 = e4[1],
     m3 = e3[1],
     m2 = e2[1],
     m1 = e1[1],
     m0 = e0[1],
     _bE_ = m4[2],
     _bF_ = rmax(m2[2], m3[2]),
     r = rsucc(rmax(rmax(rmax(m0[2], m1[2]), _bF_), _bE_)),
     m = emut(r);
    function p(param){
     return [0, m0[2], [0, m1[2], [0, m2[2], [0, m3[2], [0, m4[2], 0]]]]];
    }
    function u(c){
     var
      _bG_ = m0[1][1],
      _bH_ = m1[1][1],
      _bI_ = m2[1][1],
      _bJ_ = m3[1][1],
      match = m4[1][1];
     if(_bG_ && _bH_ && _bI_ && _bJ_ && match){
      var
       v4 = match[1],
       v3 = _bJ_[1],
       v2 = _bI_[1],
       v1 = _bH_[1],
       v0 = _bG_[1];
      return eupdate(caml_call5(f, v0, v1, v2, v3, v4), m, c);
     }
     return 0;
    }
    add_dep$0(m0, m[2]);
    add_dep$0(m1, m[2]);
    add_dep$0(m2, m[2]);
    add_dep$0(m3, m[2]);
    add_dep$0(m4, m[2]);
    return event(m, p, u);
   }
   function l6(f, e0, e1, e2, e3, e4, e5){
    if(! e0) return 0;
    if(! e1) return 0;
    if(! e2) return 0;
    if(! e3) return 0;
    if(! e4) return 0;
    if(! e5) return 0;
    var
     m5 = e5[1],
     m4 = e4[1],
     m3 = e3[1],
     m2 = e2[1],
     m1 = e1[1],
     m0 = e0[1],
     _bx_ = rmax(m4[2], m5[2]),
     _by_ = rmax(m2[2], m3[2]),
     r = rsucc(rmax(rmax(rmax(m0[2], m1[2]), _by_), _bx_)),
     m = emut(r);
    function p(param){
     return [0,
             m0[2],
             [0, m1[2], [0, m2[2], [0, m3[2], [0, m4[2], [0, m5[2], 0]]]]]];
    }
    function u(c){
     var
      _bz_ = m0[1][1],
      _bA_ = m1[1][1],
      _bB_ = m2[1][1],
      _bC_ = m3[1][1],
      _bD_ = m4[1][1],
      match = m5[1][1];
     if(_bz_ && _bA_ && _bB_ && _bC_ && _bD_ && match){
      var
       v5 = match[1],
       v4 = _bD_[1],
       v3 = _bC_[1],
       v2 = _bB_[1],
       v1 = _bA_[1],
       v0 = _bz_[1];
      return eupdate(caml_call6(f, v0, v1, v2, v3, v4, v5), m, c);
     }
     return 0;
    }
    add_dep$0(m0, m[2]);
    add_dep$0(m1, m[2]);
    add_dep$0(m2, m[2]);
    add_dep$0(m3, m[2]);
    add_dep$0(m4, m[2]);
    add_dep$0(m5, m[2]);
    return event(m, p, u);
   }
   function some(e){return map(function(v){return [0, v];}, e);}
   function value(default$0, e){
    if(! default$0) return fmap(function(v){return v;}, e);
    var match = default$0[1];
    if(0 === match[0]){
     var dv = match[1];
     return map
             (function(param){
               if(! param) return dv;
               var v = param[1];
               return v;
              },
              e);
    }
    var ms = match[1];
    if(! e) return 0;
    var m = e[1], m$0 = emut(rsucc2(m[2], ms[3]));
    function p(param){return [0, m[2], [0, ms[3], 0]];}
    function u(c){
     var _bw_ = m[1][1];
     if(! _bw_) return 0;
     var match = _bw_[1];
     if(! match) return eupdate(sval(ms), m$0, c);
     var v = match[1];
     return eupdate(v, m$0, c);
    }
    add_dep$0(m, m$0[2]);
    add_dep(ms[3], m$0[2]);
    return event(m$0, p, u);
   }
   var
    Option = [0, some, value],
    _g_ = [0, cst_src_react_ml, 994, 36],
    _h_ = [0, cst_src_react_ml, 1112, 18];
   function end_of_step_add_dep(opt, stop_if_stopped, m$0, m){
    if(opt)
     var sth = opt[1], post_add_op = sth;
    else
     var post_add_op = function(param){return 0;};
    var c = find_unfinished(caml_call1(m$0[3][4], 0));
    if(c === nil){add_dep(m$0[3], m[2]); return caml_call1(post_add_op, 0);}
    function add_dep$0(param){
     if(m$0[3][5] === nop)
      return stop_if_stopped ? stop(0, m[2]) : stop_if_stopped;
     var _bv_ = rsucc(m$0[3]);
     update_rank(m[2], _bv_);
     add_dep(m$0[3], m[2]);
     return caml_call1(post_add_op, 0);
    }
    return add_eop(c, add_dep$0);
   }
   function const$0(v){return [0, v];}
   function create$3(opt, v){
    if(opt) var sth = opt[1], eq = sth; else var eq = caml_equal;
    var m = smut(min_rank, eq);
    m[1] = [0, v];
    return [0,
            [1, m],
            function(step, v){
             var _bu_ = sval(m);
             if(caml_call2(m[2], _bu_, v)) return 0;
             if(! step){
              var c$0 = create$0(0);
              m[3][2] = c$0;
              m[1] = [0, v];
              add_deps(c$0, m[3]);
              return execute(c$0);
             }
             var c = step[1];
             if(c[1])
              caml_call1(Stdlib[1], err_step_executed);
             else if(m[3][2][1])
              m[3][2] = c;
             else
              caml_call1(Stdlib[1], err_signal_scheduled);
             m[1] = [0, v];
             return add_deps(c, m[3]);
            }];
   }
   function retain$0(s, c){
    if(0 === s[0]) return caml_call1(Stdlib[1], err_retain_cst_sig);
    var m = s[1], c$0 = m[3][3];
    m[3][3] = c;
    return [0, 82, c$0];
   }
   function eq_fun(param){
    if(0 === param[0]) return 0;
    var m = param[1];
    return [0, m[2]];
   }
   function value$0(param){
    if(0 === param[0])
     var v = param[1];
    else{
     var _bt_ = param[1][1];
     if(! _bt_) return caml_call1(Stdlib[2], err_sig_undef);
     var v = _bt_[1];
    }
    return v;
   }
   function stop$1(strong, param){
    if(0 === param[0]) return 0;
    var m = param[1];
    if(m[1]) return stop(strong, m[3]);
    var c = find_unfinished(caml_call1(m[3][4], 0));
    if(c === nil)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
    function stop$0(param){return stop(strong, m[3]);}
    return add_eop(c, stop$0);
   }
   function equal$0(opt, s$0, s){
    if(opt) var sth = opt[1], eq = sth; else var eq = caml_equal;
    if(0 === s$0[0]){
     var v = s$0[1];
     if(0 === s[0]){var v$0 = s[1]; return caml_call2(eq, v, v$0);}
    }
    else{
     var m = s$0[1];
     if(0 !== s[0]){var m$0 = s[1]; return m === m$0 ? 1 : 0;}
    }
    return 0;
   }
   function trace$0(opt, t, s){
    if(opt) var sth = opt[1], iff = sth; else var iff = [0, 1];
    if(0 === iff[0]){
     if(! iff[1]) return s;
     if(0 === s[0]){var v = s[1]; caml_call1(t, v); return s;}
     var
      m = s[1],
      _br_ = m[2],
      m$0 = smut(rsucc(m[3]), _br_),
      p = function(param){return [0, m[3], 0];},
      u =
        function(c){
         var v = sval(m);
         caml_call1(t, v);
         return supdate(v, m$0, c);
        };
     add_dep(m[3], m$0[3]);
     return signal(0, m$0, p, u);
    }
    var mc = iff[1];
    if(0 === s[0]){
     var
      v$0 = s[1],
      m$1 = smut(rsucc(mc[3]), caml_equal),
      p$0 = function(param){return [0, mc[3], 0];},
      u$0 =
        function(c){
         if(sval(mc)) caml_call1(t, v$0);
         rem_dep(mc[3], m$1[3]);
         return stop(0, m$1[3]);
        };
     add_dep(mc[3], m$1[3]);
     return signal([0, v$0], m$1, p$0, u$0);
    }
    var m$2 = s[1], _bs_ = m$2[2], m$3 = smut(rsucc2(mc[3], m$2[3]), _bs_);
    function p$1(param){return [0, mc[3], [0, m$2[3], 0]];}
    function u$1(c){
     var v = sval(m$2), match = m$3[1];
     if(match){var v$0 = match[1]; if(caml_call2(m$3[2], v, v$0)) return 0;}
     if(sval(mc)) caml_call1(t, v);
     return supdate(v, m$3, c);
    }
    add_dep(mc[3], m$3[3]);
    add_dep(m$2[3], m$3[3]);
    return signal(0, m$3, p$1, u$1);
   }
   function hold(opt, i, param){
    if(opt) var sth = opt[1], eq = sth; else var eq = caml_equal;
    if(! param) return [0, i];
    var m = param[1], m$0 = smut(rsucc(m[2]), eq);
    function p(param){return [0, m[2], 0];}
    function u(c){
     var match = m[1][1];
     if(! match) return 0;
     var v = match[1];
     return supdate(v, m$0, c);
    }
    add_dep$0(m, m$0[3]);
    return signal([0, i], m$0, p, u);
   }
   function map$0(opt, f, param){
    if(opt) var sth = opt[1], eq = sth; else var eq = caml_equal;
    if(0 === param[0]){var v = param[1]; return [0, caml_call1(f, v)];}
    var m = param[1], m$0 = smut(rsucc(m[3]), eq);
    function p(param){return [0, m[3], 0];}
    function u(c){return supdate(caml_call1(f, sval(m)), m$0, c);}
    add_dep(m[3], m$0[3]);
    return signal(0, m$0, p, u);
   }
   function app$0(opt, sf, sv){
    if(opt) var sth = opt[1], eq = sth; else var eq = caml_equal;
    if(0 === sf[0]){
     var f = sf[1];
     if(0 !== sv[0]) return map$0([0, eq], f, sv);
     var v = sv[1];
     return [0, caml_call1(f, v)];
    }
    var mf = sf[1];
    if(0 === sv[0]){
     var
      v$0 = sv[1],
      m = smut(rsucc(mf[3]), eq),
      p = function(param){return [0, mf[3], 0];},
      u = function(c){return supdate(caml_call1(sval(mf), v$0), m, c);};
     add_dep(mf[3], m[3]);
     return signal(0, m, p, u);
    }
    var mv = sv[1], m$0 = smut(rsucc2(mf[3], mv[3]), eq);
    function p$0(param){return [0, mf[3], [0, mv[3], 0]];}
    function u$0(c){
     var _bq_ = sval(mv);
     return supdate(caml_call1(sval(mf), _bq_), m$0, c);
    }
    add_dep(mf[3], m$0[3]);
    add_dep(mv[3], m$0[3]);
    return signal(0, m$0, p$0, u$0);
   }
   function filter$0(opt, pred, i, s){
    if(opt) var sth = opt[1], eq = sth; else var eq = caml_equal;
    if(0 === s[0]){var v = s[1]; return caml_call1(pred, v) ? s : [0, i];}
    var m = s[1], m$0 = smut(rsucc(m[3]), eq);
    function p(param){return [0, m[3], 0];}
    function u(c){
     var v = sval(m);
     return caml_call1(pred, v) ? supdate(v, m$0, c) : 0;
    }
    add_dep(m[3], m$0[3]);
    return signal([0, i], m$0, p, u);
   }
   function fmap$0(opt, fm, i, param){
    if(opt) var sth = opt[1], eq = sth; else var eq = caml_equal;
    if(0 !== param[0]){
     var
      m = param[1],
      m$0 = smut(rsucc(m[3]), eq),
      p = function(param){return [0, m[3], 0];},
      u =
        function(c){
         var match = caml_call1(fm, sval(m));
         if(! match) return 0;
         var v = match[1];
         return supdate(v, m$0, c);
        };
     add_dep(m[3], m$0[3]);
     return signal([0, i], m$0, p, u);
    }
    var v = param[1], match = caml_call1(fm, v);
    if(! match) return [0, i];
    var v$0 = match[1];
    return [0, v$0];
   }
   function diff$0(d, param){
    if(0 === param[0]) return 0;
    var m = param[1], m$0 = emut(rsucc(m[3])), last = [0, 0];
    function p(param){return [0, m[3], 0];}
    function u(c){
     var v = sval(m), match = last[1];
     if(! match)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _h_], 1);
     var v$0 = match[1];
     last[1] = [0, v];
     return eupdate(caml_call2(d, v, v$0), m$0, c);
    }
    function post_add_op(param){last[1] = [0, sval(m)]; return 0;}
    end_of_step_add_dep([0, post_add_op], 1, m, m$0);
    return event(m$0, p, u);
   }
   function changes$0(param){
    if(0 === param[0]) return 0;
    var m = param[1], m$0 = emut(rsucc(m[3]));
    function p(param){return [0, m[3], 0];}
    function u(c){return eupdate(sval(m), m$0, c);}
    end_of_step_add_dep(0, 1, m, m$0);
    return event(m$0, p, u);
   }
   function sample(f, e, param){
    if(0 === param[0]){
     var v = param[1];
     return map(function(ev){return caml_call2(f, ev, v);}, e);
    }
    var ms = param[1];
    if(! e) return 0;
    var me = e[1], m = emut(rsucc2(me[2], ms[3]));
    function p(param){return [0, me[2], [0, ms[3], 0]];}
    function u(c){
     var match = me[1][1];
     if(! match) return 0;
     var v = match[1];
     return eupdate(caml_call2(f, v, sval(ms)), m, c);
    }
    add_dep$0(me, m[2]);
    add_dep(ms[3], m[2]);
    return event(m, p, u);
   }
   function on$0(opt, c, i, s){
    if(opt) var sth = opt[1], eq = sth; else var eq = caml_equal;
    if(0 === c[0]) return c[1] ? s : [0, i];
    var mc = c[1];
    if(0 === s[0]){
     var
      v = s[1],
      m = smut(rsucc(mc[3]), eq),
      p = function(param){return [0, mc[3], 0];},
      u = function(c){return sval(mc) ? supdate(v, m, c) : 0;};
     add_dep(mc[3], m[3]);
     return signal([0, i], m, p, u);
    }
    var ms = s[1], m$0 = smut(rsucc2(mc[3], ms[3]), eq);
    function p$0(param){return [0, mc[3], [0, ms[3], 0]];}
    function u$0(c){return sval(mc) ? supdate(sval(ms), m$0, c) : 0;}
    add_dep(mc[3], m$0[3]);
    add_dep(ms[3], m$0[3]);
    return signal([0, i], m$0, p$0, u$0);
   }
   function dismiss$0(opt, c, i, s){
    if(opt) var sth = opt[1], eq = sth; else var eq = caml_equal;
    if(! c) return s;
    var mc = c[1];
    if(0 === s[0]){
     var
      v = s[1],
      m = smut(rsucc(mc[2]), eq),
      p = function(param){return [0, mc[2], 0];},
      u = function(c){return mc[1][1] ? 0 : supdate(v, m, c);};
     add_dep(mc[2], m[3]);
     return signal([0, i], m, p, u);
    }
    var ms = s[1], m$0 = smut(rsucc2(mc[2], ms[3]), eq);
    function p$0(param){return [0, mc[2], [0, ms[3], 0]];}
    function u$0(c){return mc[1][1] ? 0 : supdate(sval(ms), m$0, c);}
    add_dep(mc[2], m$0[3]);
    add_dep(ms[3], m$0[3]);
    return signal([0, i], m$0, p$0, u$0);
   }
   function accum$0(opt, ef, i){
    if(opt) var sth = opt[1], eq = sth; else var eq = caml_equal;
    if(! ef) return [0, i];
    var m = ef[1], m$0 = smut(rsucc(m[2]), eq);
    function p(param){return [0, m[2], 0];}
    function u(c){
     var match = m[1][1];
     if(! match) return 0;
     var v = match[1];
     return supdate(caml_call1(v, sval(m$0)), m$0, c);
    }
    add_dep$0(m, m$0[3]);
    return signal([0, i], m$0, p, u);
   }
   function fold$1(opt, f, i, param){
    if(opt) var sth = opt[1], eq = sth; else var eq = caml_equal;
    if(! param) return [0, i];
    var m = param[1], m$0 = smut(rsucc(m[2]), eq);
    function p(param){return [0, m[2], 0];}
    function u(c){
     var match = m[1][1];
     if(! match) return 0;
     var v = match[1];
     return supdate(caml_call2(f, sval(m$0), v), m$0, c);
    }
    add_dep$0(m, m$0[3]);
    return signal([0, i], m$0, p, u);
   }
   function merge$0(opt, f, a, sl){
    if(opt) var sth = opt[1], eq = sth; else var eq = caml_equal;
    function rmax$0(acc, param){
     if(0 === param[0]) return acc;
     var m = param[1];
     return rmax(acc, m[3]);
    }
    function nodes(acc, param){
     if(0 === param[0]) return acc;
     var m = param[1];
     return [0, m[3], acc];
    }
    var m = smut(rsucc(caml_call3(Stdlib_List[25], rmax$0, rmin, sl)), eq);
    function p(param){return caml_call3(Stdlib_List[25], nodes, 0, sl);}
    function u(c){
     return supdate
             (caml_call3
               (Stdlib_List[25],
                function(a, param){
                 if(0 === param[0]){
                  var v = param[1];
                  return caml_call2(f, a, v);
                 }
                 var m = param[1];
                 return caml_call2(f, a, sval(m));
                },
                a,
                sl),
              m,
              c);
    }
    function dep(param){
     if(0 === param[0]) return 0;
     var m$0 = param[1];
     return add_dep(m$0[3], m[3]);
    }
    caml_call2(Stdlib_List[17], dep, sl);
    return signal(0, m, p, u);
   }
   function switch$1(opt, param){
    if(opt) var sth = opt[1], eq = sth; else var eq = caml_equal;
    if(0 === param[0]){var s = param[1]; return s;}
    var
     mss = param[1],
     dummy = smut(min_rank, eq),
     src = [0, [1, dummy]],
     m = smut(rsucc(mss[3]), eq);
    function p(param){
     var match = src[1];
     if(0 === match[0]) return [0, mss[3], 0];
     var m = match[1];
     return [0, mss[3], [0, m[3], 0]];
    }
    function u(c){
     var _bm_ = src[1];
     if(sval(mss) === _bm_){
      var match = src[1];
      if(0 === match[0]) return 0;
      var m$0 = match[1];
      return supdate(sval(m$0), m, c);
     }
     var match$0 = src[1];
     if(0 !== match$0[0]){var m$2 = match$0[1]; rem_dep(m$2[3], m[3]);}
     var new_src = sval(mss);
     src[1] = new_src;
     if(0 === new_src[0]){
      var v = new_src[1], _bn_ = rsucc(mss[3]);
      update_rank(m[3], _bn_);
      return supdate(v, m, c);
     }
     var m$1 = new_src[1];
     add_dep(m$1[3], m[3]);
     if(c === nil){
      var _bo_ = rsucc2(m$1[3], mss[3]);
      update_rank(m[3], _bo_);
      var c$0 = find_unfinished([0, m$1[3], 0]);
      return c$0 === nil ? supdate(sval(m$1), m, c$0) : add$0(c$0, m[3]);
     }
     var _bp_ = rsucc2(m$1[3], mss[3]);
     return update_rank(m[3], _bp_)
             ? (allow_reschedule(m[3]), rebuild(c), add$0(c, m[3]))
             : supdate(sval(m$1), m, c);
    }
    add_dep(mss[3], m[3]);
    add_dep(dummy[3], m[3]);
    return signal(0, m, p, u);
   }
   function bind$0(eq, s, sf){
    return switch$1
            (eq,
             map$0
              ([0, function(_bl_, _bk_){return _bl_ === _bk_ ? 1 : 0;}],
               sf,
               s));
   }
   function fix$0(opt, i, f){
    if(opt) var sth = opt[1], eq = sth; else var eq = caml_equal;
    function update_delayed(n, p, u, nl){
     bind(n, p, u);
     var c = find_unfinished(nl);
     if(c !== nil) return add$0(c, n);
     var c$0 = create$0(0);
     caml_call1(n[5], c$0);
     return execute(c$0);
    }
    var
     m = smut(delayed_rank, eq),
     s =
       signal
        ([0, i], m, function(param){return 0;}, function(param){return 0;}),
     _bh_ = caml_call1(f, s),
     match = _bh_[1];
    if(0 === match[0]){
     var
      r = _bh_[2],
      v = match[1],
      p = function(param){return 0;},
      u = function(c){return supdate(v, m, c);},
      _bi_ = deps(m[3]);
     update_delayed(m[3], p, u, _bi_);
     return r;
    }
    var r$0 = _bh_[2], m$0 = match[1];
    if(m$0[3][1] === delayed_rank) caml_call1(Stdlib[1], err_fix);
    function p$0(param){return 0;}
    function u$0(c){return supdate(sval(m$0), m, c);}
    add_dep(m$0[3], m[3]);
    var _bj_ = deps(m[3]);
    update_delayed(m[3], p$0, u$0, [0, m$0[3], _bj_]);
    return r$0;
   }
   function l2$0(opt, f, s$0, s){
    if(opt) var sth = opt[1], eq = sth; else var eq = caml_equal;
    if(0 === s$0[0]){
     var v = s$0[1];
     if(0 === s[0]){var v$0 = s[1]; return [0, caml_call2(f, v, v$0)];}
     var
      m = s[1],
      m$0 = smut(rsucc(m[3]), eq),
      p = function(param){return [0, m[3], 0];},
      u = function(c){return supdate(caml_call2(f, v, sval(m)), m$0, c);};
     add_dep(m[3], m$0[3]);
     return signal(0, m$0, p, u);
    }
    var m0 = s$0[1];
    if(0 === s[0]){
     var
      v$1 = s[1],
      m$1 = smut(rsucc(m0[3]), eq),
      p$0 = function(param){return [0, m0[3], 0];},
      u$0 = function(c){return supdate(caml_call2(f, sval(m0), v$1), m$1, c);};
     add_dep(m0[3], m$1[3]);
     return signal(0, m$1, p$0, u$0);
    }
    var m1 = s[1], m$2 = smut(rsucc2(m0[3], m1[3]), eq);
    function p$1(param){return [0, m0[3], [0, m1[3], 0]];}
    function u$1(c){
     var _bg_ = sval(m1);
     return supdate(caml_call2(f, sval(m0), _bg_), m$2, c);
    }
    add_dep(m0[3], m$2[3]);
    add_dep(m1[3], m$2[3]);
    return signal(0, m$2, p$1, u$1);
   }
   function l3$0(opt, f, s0, s1, s2){
    if(opt) var sth = opt[1], eq = sth; else var eq = caml_equal;
    if(0 === s0[0]){
     var v0 = s0[1];
     if(0 === s1[0]){
      var v1 = s1[1];
      if(0 === s2[0]){var v2 = s2[1]; return [0, caml_call3(f, v0, v1, v2)];}
     }
    }
    else{
     var m0 = s0[1];
     if(0 !== s1[0]){
      var m1 = s1[1];
      if(0 !== s2[0]){
       var
        m2 = s2[1],
        _bb_ = m2[3],
        r = rsucc(rmax(rmax(m0[3], m1[3]), _bb_)),
        m = smut(r, eq),
        p = function(param){return [0, m0[3], [0, m1[3], [0, m2[3], 0]]];},
        u =
          function(c){
           var _be_ = sval(m2), _bf_ = sval(m1);
           return supdate(caml_call3(f, sval(m0), _bf_, _be_), m, c);
          };
       add_dep(m0[3], m[3]);
       add_dep(m1[3], m[3]);
       add_dep(m2[3], m[3]);
       return signal(0, m, p, u);
      }
     }
    }
    return app$0
            ([0, eq],
             l2$0
              ([0, function(_bd_, _bc_){return _bd_ === _bc_ ? 1 : 0;}],
               f,
               s0,
               s1),
             s2);
   }
   function l4$0(opt, f, s0, s1, s2, s3){
    if(opt) var sth = opt[1], eq = sth; else var eq = caml_equal;
    if(0 === s0[0]){
     var v0 = s0[1];
     if(0 === s1[0]){
      var v1 = s1[1];
      if(0 === s2[0]){
       var v2 = s2[1];
       if(0 === s3[0]){
        var v3 = s3[1];
        return [0, caml_call4(f, v0, v1, v2, v3)];
       }
      }
     }
    }
    else{
     var m0 = s0[1];
     if(0 !== s1[0]){
      var m1 = s1[1];
      if(0 !== s2[0]){
       var m2 = s2[1];
       if(0 !== s3[0]){
        var
         m3 = s3[1],
         _a7_ = rmax(m2[3], m3[3]),
         r = rsucc(rmax(rmax(m0[3], m1[3]), _a7_)),
         m = smut(r, eq),
         p =
           function(param){
            return [0, m0[3], [0, m1[3], [0, m2[3], [0, m3[3], 0]]]];
           },
         u =
           function(c){
            var _a__ = sval(m3), _a$_ = sval(m2), _ba_ = sval(m1);
            return supdate(caml_call4(f, sval(m0), _ba_, _a$_, _a__), m, c);
           };
        add_dep(m0[3], m[3]);
        add_dep(m1[3], m[3]);
        add_dep(m2[3], m[3]);
        add_dep(m3[3], m[3]);
        return signal(0, m, p, u);
       }
      }
     }
    }
    return app$0
            ([0, eq],
             l3$0
              ([0, function(_a9_, _a8_){return _a9_ === _a8_ ? 1 : 0;}],
               f,
               s0,
               s1,
               s2),
             s3);
   }
   function l5$0(opt, f, s0, s1, s2, s3, s4){
    if(opt) var sth = opt[1], eq = sth; else var eq = caml_equal;
    if(0 === s0[0]){
     var v0 = s0[1];
     if(0 === s1[0]){
      var v1 = s1[1];
      if(0 === s2[0]){
       var v2 = s2[1];
       if(0 === s3[0]){
        var v3 = s3[1];
        if(0 === s4[0]){
         var v4 = s4[1];
         return [0, caml_call5(f, v0, v1, v2, v3, v4)];
        }
       }
      }
     }
    }
    else{
     var m0 = s0[1];
     if(0 !== s1[0]){
      var m1 = s1[1];
      if(0 !== s2[0]){
       var m2 = s2[1];
       if(0 !== s3[0]){
        var m3 = s3[1];
        if(0 !== s4[0]){
         var
          m4 = s4[1],
          _aZ_ = rmax(m3[3], m4[3]),
          _a0_ = rmax(m2[3], _aZ_),
          r = rsucc(rmax(rmax(m0[3], m1[3]), _a0_)),
          m = smut(r, eq),
          p =
            function(param){
             return [0,
                     m0[3],
                     [0, m1[3], [0, m2[3], [0, m3[3], [0, m4[3], 0]]]]];
            },
          u =
            function(c){
             var
              _a3_ = sval(m4),
              _a4_ = sval(m3),
              _a5_ = sval(m2),
              _a6_ = sval(m1),
              v = caml_call5(f, sval(m0), _a6_, _a5_, _a4_, _a3_);
             return supdate(v, m, c);
            };
         add_dep(m0[3], m[3]);
         add_dep(m1[3], m[3]);
         add_dep(m2[3], m[3]);
         add_dep(m3[3], m[3]);
         add_dep(m4[3], m[3]);
         return signal(0, m, p, u);
        }
       }
      }
     }
    }
    return app$0
            ([0, eq],
             l4$0
              ([0, function(_a2_, _a1_){return _a2_ === _a1_ ? 1 : 0;}],
               f,
               s0,
               s1,
               s2,
               s3),
             s4);
   }
   function l6$0(opt, f, s0, s1, s2, s3, s4, s5){
    if(opt) var sth = opt[1], eq = sth; else var eq = caml_equal;
    if(0 === s0[0]){
     var v0 = s0[1];
     if(0 === s1[0]){
      var v1 = s1[1];
      if(0 === s2[0]){
       var v2 = s2[1];
       if(0 === s3[0]){
        var v3 = s3[1];
        if(0 === s4[0]){
         var v4 = s4[1];
         if(0 === s5[0]){
          var v5 = s5[1];
          return [0, caml_call6(f, v0, v1, v2, v3, v4, v5)];
         }
        }
       }
      }
     }
    }
    else{
     var m0 = s0[1];
     if(0 !== s1[0]){
      var m1 = s1[1];
      if(0 !== s2[0]){
       var m2 = s2[1];
       if(0 !== s3[0]){
        var m3 = s3[1];
        if(0 !== s4[0]){
         var m4 = s4[1];
         if(0 !== s5[0]){
          var
           m5 = s5[1],
           _aP_ = rmax(m4[3], m5[3]),
           _aQ_ = rmax(m3[3], _aP_),
           _aR_ = rmax(m1[3], m2[3]),
           m = rmax(rmax(m0[3], _aR_), _aQ_),
           m$0 = smut(rsucc(m), eq),
           p =
             function(param){
              return [0,
                      m0[3],
                      [0,
                       m1[3],
                       [0, m2[3], [0, m3[3], [0, m4[3], [0, m5[3], 0]]]]]];
             },
           u =
             function(c){
              var
               _aU_ = sval(m5),
               _aV_ = sval(m4),
               _aW_ = sval(m3),
               _aX_ = sval(m2),
               _aY_ = sval(m1),
               v = caml_call6(f, sval(m0), _aY_, _aX_, _aW_, _aV_, _aU_);
              return supdate(v, m$0, c);
             };
          add_dep(m0[3], m$0[3]);
          add_dep(m1[3], m$0[3]);
          add_dep(m2[3], m$0[3]);
          add_dep(m3[3], m$0[3]);
          add_dep(m4[3], m$0[3]);
          add_dep(m5[3], m$0[3]);
          return signal(0, m$0, p, u);
         }
        }
       }
      }
     }
    }
    return app$0
            ([0, eq],
             l5$0
              ([0, function(_aT_, _aS_){return _aT_ === _aS_ ? 1 : 0;}],
               f,
               s0,
               s1,
               s2,
               s3,
               s4),
             s5);
   }
   function stdlib_not(_aO_){return 1 - _aO_;}
   function equal$1(_aN_, _aM_){return _aN_ === _aM_ ? 1 : 0;}
   function not(s){return map$0([0, equal$1], stdlib_not, s);}
   function symbol(s$0, s){
    return l2$0
            ([0, equal$1],
             function(_aK_, _aJ_){var _aL_ = _aK_ ? _aJ_ : _aK_; return _aL_;},
             s$0,
             s);
   }
   function symbol$0(s$0, s){
    return l2$0
            ([0, equal$1],
             function(_aH_, _aG_){var _aI_ = _aH_ || _aG_; return _aI_;},
             s$0,
             s);
   }
   function edge(s){return changes$0(s);}
   function edge_detect(edge, param){
    if(0 === param[0]) return 0;
    var m = param[1], m$0 = emut(rsucc(m[3]));
    function p(param){return [0, m[3], 0];}
    function u(c){
     var _aF_ = caml_equal(sval(m), edge);
     return _aF_ ? eupdate(0, m$0, c) : _aF_;
    }
    end_of_step_add_dep(0, 1, m, m$0);
    return event(m$0, p, u);
   }
   function rise(s){return edge_detect(1, s);}
   function fall(s){return edge_detect(0, s);}
   function flip(b, param){
    if(! param) return [0, b];
    var
     m = param[1],
     m$0 =
       smut(rsucc(m[2]), function(_aE_, _aD_){return _aE_ === _aD_ ? 1 : 0;});
    function p(param){return [0, m[2], 0];}
    function u(c){return m[1][1] ? supdate(1 - sval(m$0), m$0, c) : 0;}
    add_dep$0(m, m$0[3]);
    return signal([0, b], m$0, p, u);
   }
   function equal$2(_aC_, _aB_){return _aC_ === _aB_ ? 1 : 0;}
   function symbol$1(s){
    return map$0([0, equal$2], function(_aA_){return - _aA_ | 0;}, s);
   }
   function succ(s){
    return map$0([0, equal$2], function(_az_){return _az_ + 1 | 0;}, s);
   }
   function pred(s){
    return map$0([0, equal$2], function(_ay_){return _ay_ - 1 | 0;}, s);
   }
   function symbol$2(s$0, s){
    return l2$0
            ([0, equal$2],
             function(_ax_, _aw_){return _ax_ + _aw_ | 0;},
             s$0,
             s);
   }
   function symbol$3(s$0, s){
    return l2$0
            ([0, equal$2],
             function(_av_, _au_){return _av_ - _au_ | 0;},
             s$0,
             s);
   }
   function symbol$4(s$0, s){
    return l2$0([0, equal$2], runtime.caml_mul, s$0, s);
   }
   function mod(s$0, s){return l2$0([0, equal$2], runtime.caml_mod, s$0, s);}
   function abs(s){return map$0([0, equal$2], Stdlib[18], s);}
   var v = Stdlib[19], max_int = [0, v], v$0 = Stdlib[20], min_int = [0, v$0];
   function land(s$0, s){
    return l2$0
            ([0, equal$2], function(_at_, _as_){return _at_ & _as_;}, s$0, s);
   }
   function lor(s$0, s){
    return l2$0
            ([0, equal$2], function(_ar_, _aq_){return _ar_ | _aq_;}, s$0, s);
   }
   function lxor(s$0, s){
    return l2$0
            ([0, equal$2], function(_ap_, _ao_){return _ap_ ^ _ao_;}, s$0, s);
   }
   function lnot(s){return map$0([0, equal$2], Stdlib[21], s);}
   function lsl(s$0, s){
    return l2$0
            ([0, equal$2], function(_an_, _am_){return _an_ << _am_;}, s$0, s);
   }
   function lsr(s$0, s){
    return l2$0
            ([0, equal$2],
             function(_al_, _ak_){return _al_ >>> _ak_ | 0;},
             s$0,
             s);
   }
   function asr(s$0, s){
    return l2$0
            ([0, equal$2], function(_aj_, _ai_){return _aj_ >> _ai_;}, s$0, s);
   }
   function equal$3(_ah_, _ag_){return _ah_ == _ag_ ? 1 : 0;}
   function symbol$5(s){
    return map$0([0, equal$3], function(_af_){return - _af_;}, s);
   }
   function symbol$6(s$0, s){
    return l2$0
            ([0, equal$3], function(_ae_, _ad_){return _ae_ + _ad_;}, s$0, s);
   }
   function symbol$7(s$0, s){
    return l2$0
            ([0, equal$3], function(_ac_, _ab_){return _ac_ - _ab_;}, s$0, s);
   }
   function symbol$8(s$0, s){
    return l2$0([0, equal$3], function(_aa_, _$_){return _aa_ * _$_;}, s$0, s);
   }
   function symbol$9(s$0, s){
    return l2$0([0, equal$3], function(___, _Z_){return ___ / _Z_;}, s$0, s);
   }
   function symbol$10(s$0, s){
    return l2$0
            ([0, equal$3],
             function(_Y_, _X_){return Math.pow(_Y_, _X_);},
             s$0,
             s);
   }
   function sqrt(s){
    return map$0([0, equal$3], function(_W_){return Math.sqrt(_W_);}, s);
   }
   function exp(s){
    return map$0([0, equal$3], function(_V_){return Math.exp(_V_);}, s);
   }
   function log(s){
    return map$0([0, equal$3], function(_U_){return Math.log(_U_);}, s);
   }
   function log10(s){return map$0([0, equal$3], runtime.caml_log10_float, s);}
   function cos(s){
    return map$0([0, equal$3], function(_T_){return Math.cos(_T_);}, s);
   }
   function sin(s){
    return map$0([0, equal$3], function(_S_){return Math.sin(_S_);}, s);
   }
   function tan(s){
    return map$0([0, equal$3], function(_R_){return Math.tan(_R_);}, s);
   }
   function acos(s){
    return map$0([0, equal$3], function(_Q_){return Math.acos(_Q_);}, s);
   }
   function asin(s){
    return map$0([0, equal$3], function(_P_){return Math.asin(_P_);}, s);
   }
   function atan(s){
    return map$0([0, equal$3], function(_O_){return Math.atan(_O_);}, s);
   }
   function atan2(s$0, s){
    return l2$0
            ([0, equal$3],
             function(_N_, _M_){return Math.atan2(_N_, _M_);},
             s$0,
             s);
   }
   function cosh(s){return map$0([0, equal$3], runtime.caml_cosh_float, s);}
   function sinh(s){return map$0([0, equal$3], runtime.caml_sinh_float, s);}
   function tanh(s){return map$0([0, equal$3], runtime.caml_tanh_float, s);}
   function ceil(s){
    return map$0([0, equal$3], function(_L_){return Math.ceil(_L_);}, s);
   }
   function floor(s){
    return map$0([0, equal$3], function(_K_){return Math.floor(_K_);}, s);
   }
   function abs_float(s){
    return map$0([0, equal$3], function(_J_){return Math.abs(_J_);}, s);
   }
   function mod_float(s$0, s){
    return l2$0([0, equal$3], function(_I_, _H_){return _I_ % _H_;}, s$0, s);
   }
   function frexp(s){
    return map$0([0, caml_equal], runtime.caml_frexp_float, s);
   }
   function ldexp(s$0, s){
    return l2$0([0, equal$3], runtime.caml_ldexp_float, s$0, s);
   }
   function modf(s){
    return map$0([0, caml_equal], runtime.caml_modf_float, s);
   }
   function float$0(s){
    return map$0([0, equal$3], function(_G_){return _G_;}, s);
   }
   function float_of_int(s){
    return map$0([0, equal$3], function(_F_){return _F_;}, s);
   }
   function truncate(s){
    return map$0([0, equal$2], function(_E_){return _E_ | 0;}, s);
   }
   function int_of_float(s){
    return map$0([0, equal$2], function(_D_){return _D_ | 0;}, s);
   }
   var
    v$1 = Stdlib[22],
    infinity = [0, v$1],
    v$2 = Stdlib[23],
    neg_infinity = [0, v$2],
    v$3 = Stdlib[24],
    nan = [0, v$3],
    v$4 = Stdlib[25],
    max_float = [0, v$4],
    v$5 = Stdlib[26],
    min_float = [0, v$5],
    v$6 = Stdlib[27],
    epsilon_float = [0, v$6];
   function classify_float(s){
    return map$0
            ([0, function(_C_, _B_){return _C_ === _B_ ? 1 : 0;}],
             runtime.caml_classify_float,
             s);
   }
   function pair(eq, s$0, s){
    return l2$0(eq, function(x, y){return [0, x, y];}, s$0, s);
   }
   function fst(eq, s){return map$0(eq, function(_A_){return _A_[1];}, s);}
   function snd(eq, s){return map$0(eq, function(_z_){return _z_[2];}, s);}
   var Pair = [0, pair, fst, snd], _i_ = [0, cst_src_react_ml, 1526, 17];
   function some$0(s){
    var match = eq_fun(s);
    if(match)
     var
      eq = match[1],
      eq$0 =
        function(v$0, v){
         if(v$0 && v){
          var v$1 = v[1], v$2 = v$0[1];
          return caml_call2(eq, v$2, v$1);
         }
         throw caml_maybe_attach_backtrace([0, Assert_failure, _i_], 1);
        },
      eq$1 = [0, eq$0];
    else
     var eq$1 = 0;
    return map$0(eq$1, function(v){return [0, v];}, s);
   }
   function value$1(opt, default$0, s){
    if(opt) var sth = opt[1], eq = sth; else var eq = caml_equal;
    if(0 === s[0]){
     var match = s[1];
     if(match){var v = match[1]; return [0, v];}
     if(815032112 > default$0[1]){var d$1 = default$0[2]; return d$1;}
     var d = default$0[2];
     if(0 === d[0]){var d$0 = d[1]; return [0, d$0];}
     var md = d[1], c = find_unfinished([0, md[3], 0]);
     if(c === nil) return [0, sval(md)];
     var
      m = smut(rsucc(md[3]), eq),
      p = function(param){return [0, md[3], 0];},
      u =
        function(c){
         rem_dep(md[3], m[3]);
         supdate(sval(md), m, c);
         return stop(0, m[3]);
        };
     add_dep(md[3], m[3]);
     return signal(0, m, p, u);
    }
    var m$0 = s[1];
    if(815032112 <= default$0[1]){
     var match$0 = default$0[2];
     if(0 === match$0[0]){
      var d$2 = match$0[1];
      return fmap$0([0, eq], function(v){return v;}, d$2, s);
     }
     var md$0 = match$0[1], c$0 = find_unfinished([0, md$0[3], 0]);
     if(c$0 === nil){
      var
       m$1 = smut(rsucc(m$0[3]), eq),
       p$0 = function(param){return [0, m$0[3], 0];},
       u$0 =
         function(c){
          var match = sval(m$0);
          if(! match) return 0;
          var v = match[1];
          return supdate(v, m$1, c);
         };
      add_dep(m$0[3], m$1[3]);
      return signal([0, sval(md$0)], m$1, p$0, u$0);
     }
     var
      m$2 = smut(rsucc2(m$0[3], md$0[3]), eq),
      p$1 = function(param){return [0, m$0[3], 0];},
      u$1 =
        function(c){
         var match = sval(m$0);
         if(! match) return 0;
         var v = match[1];
         return supdate(v, m$2, c);
        },
      p_first = function(param){return [0, m$0[3], [0, md$0[3], 0]];},
      u_first =
        function(c){
         rem_dep(md$0[3], m$2[3]);
         var match = sval(m$0);
         if(match){
          var v = match[1];
          supdate(v, m$2, c);
         }
         else
          supdate(sval(md$0), m$2, c);
         return bind(m$2[3], p$1, u$1);
        };
     add_dep(m$0[3], m$2[3]);
     add_dep(md$0[3], m$2[3]);
     return signal(0, m$2, p_first, u_first);
    }
    var match$1 = default$0[2];
    if(0 === match$1[0]){
     var d$3 = match$1[1];
     return map$0
             ([0, eq],
              function(param){
               if(! param) return d$3;
               var v = param[1];
               return v;
              },
              s);
    }
    var md$1 = match$1[1], m$3 = smut(rsucc2(m$0[3], md$1[3]), eq);
    function p$2(param){return [0, m$0[3], [0, md$1[3], 0]];}
    function u$2(c){
     var match = sval(m$0);
     if(! match) return supdate(sval(md$1), m$3, c);
     var v = match[1];
     return supdate(v, m$3, c);
    }
    add_dep(m$0[3], m$3[3]);
    add_dep(md$1[3], m$3[3]);
    return signal(0, m$3, p$2, u$2);
   }
   var Option$0 = [0, none, some$0, value$1];
   function symbol$11(s$0, s){return l2$0([0, equal$1], caml_equal, s$0, s);}
   function symbol$12(s$0, s){
    return l2$0([0, equal$1], runtime.caml_notequal, s$0, s);
   }
   function symbol$13(s$0, s){
    return l2$0([0, equal$1], runtime.caml_lessthan, s$0, s);
   }
   function symbol$14(s$0, s){
    return l2$0([0, equal$1], runtime.caml_greaterthan, s$0, s);
   }
   function symbol$15(s$0, s){
    return l2$0([0, equal$1], runtime.caml_lessequal, s$0, s);
   }
   function symbol$16(s$0, s){
    return l2$0([0, equal$1], runtime.caml_greaterequal, s$0, s);
   }
   function compare(s$0, s){
    return l2$0([0, equal$2], runtime.caml_compare, s$0, s);
   }
   function symbol$17(s$0, s){
    return l2$0
            ([0, equal$1],
             function(_y_, _x_){return _y_ === _x_ ? 1 : 0;},
             s$0,
             s);
   }
   function symbol$18(s$0, s){
    return l2$0
            ([0, equal$1],
             function(_w_, _v_){return _w_ !== _v_ ? 1 : 0;},
             s$0,
             s);
   }
   function Make(Eq){
    var eq = Eq[1];
    function create(v){return create$3([0, eq], v);}
    function equal(s$0, s){return equal$0([0, eq], s$0, s);}
    function hold$0(v, e){return hold([0, eq], v, e);}
    function app(sf, sv){return app$0([0, eq], sf, sv);}
    function map(f, s){return map$0([0, eq], f, s);}
    function filter(pred, i){
     var _t_ = [0, eq];
     return function(_u_){return filter$0(_t_, pred, i, _u_);};
    }
    function fmap(fm, i){
     var _r_ = [0, eq];
     return function(_s_){return fmap$0(_r_, fm, i, _s_);};
    }
    function when(c, i, s){return on$0([0, eq], c, i, s);}
    function dismiss(c, s){
     var _p_ = [0, eq];
     return function(_q_){return dismiss$0(_p_, c, s, _q_);};
    }
    function accum(ef, i){return accum$0([0, eq], ef, i);}
    function fold(f, i){
     var _n_ = [0, eq];
     return function(_o_){return fold$1(_n_, f, i, _o_);};
    }
    function merge(f, a, sl){return merge$0([0, eq], f, a, sl);}
    function switch$0(s){return switch$1([0, eq], s);}
    function bind(s, sf){return bind$0([0, eq], s, sf);}
    function fix(f){
     var _l_ = [0, eq];
     return function(_m_){return fix$0(_l_, f, _m_);};
    }
    function l2(f, s$0, s){return l2$0([0, eq], f, s$0, s);}
    function l3(f, s0, s1, s2){return l3$0([0, eq], f, s0, s1, s2);}
    function l4(f, s0, s1, s2, s3){return l4$0([0, eq], f, s0, s1, s2, s3);}
    function l5(f, s0, s1, s2, s3, s4){
     return l5$0([0, eq], f, s0, s1, s2, s3, s4);
    }
    function l6(f, s0, s1, s2, s3, s4, s5){
     return l6$0([0, eq], f, s0, s1, s2, s3, s4, s5);
    }
    return [0,
            ,
            create,
            equal,
            hold$0,
            app,
            map,
            filter,
            fmap,
            when,
            dismiss,
            accum,
            fold,
            merge,
            switch$0,
            bind,
            fix,
            map,
            l2,
            l3,
            l4,
            l5,
            l6];
   }
   var
    Sb = Make([0, equal$1]),
    Si = Make([0, equal$2]),
    Sf = Make([0, equal$3]),
    React =
      [0,
       [0,
        0,
        create$2,
        retain,
        stop$0,
        equal,
        trace,
        once,
        drop_once,
        app,
        map,
        stamp,
        filter,
        fmap,
        diff,
        changes,
        on,
        on,
        dismiss,
        until,
        accum,
        fold$0,
        select,
        merge,
        switch$0,
        fix,
        map,
        l2,
        l3,
        l4,
        l5,
        l6,
        Option],
       [0,
        const$0,
        create$3,
        value$0,
        retain$0,
        eq_fun,
        stop$1,
        equal$0,
        trace$0,
        hold,
        app$0,
        map$0,
        filter$0,
        fmap$0,
        diff$0,
        changes$0,
        sample,
        on$0,
        on$0,
        dismiss$0,
        accum$0,
        fold$1,
        merge$0,
        switch$1,
        bind$0,
        fix$0,
        map$0,
        l2$0,
        l3$0,
        l4$0,
        l5$0,
        l6$0,
        [0, zero, one, not, symbol, symbol$0, edge, rise, fall, flip],
        [0,
         zero$0,
         one$0,
         minus_one,
         symbol$1,
         succ,
         pred,
         symbol$2,
         symbol$3,
         symbol$4,
         mod,
         abs,
         max_int,
         min_int,
         land,
         lor,
         lxor,
         lnot,
         lsl,
         lsr,
         asr],
        [0,
         zero$1,
         one$1,
         minus_one$0,
         symbol$5,
         symbol$6,
         symbol$7,
         symbol$8,
         symbol$9,
         symbol$10,
         sqrt,
         exp,
         log,
         log10,
         cos,
         sin,
         tan,
         acos,
         asin,
         atan,
         atan2,
         cosh,
         sinh,
         tanh,
         ceil,
         floor,
         abs_float,
         mod_float,
         frexp,
         ldexp,
         modf,
         float$0,
         float_of_int,
         truncate,
         int_of_float,
         infinity,
         neg_infinity,
         nan,
         max_float,
         min_float,
         epsilon_float,
         classify_float],
        Pair,
        Option$0,
        [0,
         symbol$11,
         symbol$12,
         symbol$13,
         symbol$14,
         symbol$15,
         symbol$16,
         compare,
         symbol$17,
         symbol$18],
        function(_j_){
         var _k_ = Make(_j_);
         return [0,
                 _k_[2],
                 _k_[3],
                 _k_[4],
                 _k_[5],
                 _k_[6],
                 _k_[7],
                 _k_[8],
                 _k_[9],
                 _k_[10],
                 _k_[11],
                 _k_[12],
                 _k_[13],
                 _k_[14],
                 _k_[15],
                 _k_[16],
                 _k_[17],
                 _k_[18],
                 _k_[19],
                 _k_[20],
                 _k_[21],
                 _k_[22]];
        },
        [0,
         [0,
          Sb[2],
          Sb[3],
          Sb[4],
          Sb[5],
          Sb[6],
          Sb[7],
          Sb[8],
          Sb[9],
          Sb[10],
          Sb[11],
          Sb[12],
          Sb[13],
          Sb[14],
          Sb[15],
          Sb[16],
          Sb[17],
          Sb[18],
          Sb[19],
          Sb[20],
          Sb[21],
          Sb[22]],
         [0,
          Si[2],
          Si[3],
          Si[4],
          Si[5],
          Si[6],
          Si[7],
          Si[8],
          Si[9],
          Si[10],
          Si[11],
          Si[12],
          Si[13],
          Si[14],
          Si[15],
          Si[16],
          Si[17],
          Si[18],
          Si[19],
          Si[20],
          Si[21],
          Si[22]],
         [0,
          Sf[2],
          Sf[3],
          Sf[4],
          Sf[5],
          Sf[6],
          Sf[7],
          Sf[8],
          Sf[9],
          Sf[10],
          Sf[11],
          Sf[12],
          Sf[13],
          Sf[14],
          Sf[15],
          Sf[16],
          Sf[17],
          Sf[18],
          Sf[19],
          Sf[20],
          Sf[21],
          Sf[22]]]],
       [0, create$0, execute]];
   runtime.caml_register_global(30, React, "React");
   return;
  }
  (globalThis));


//# 1 "../src/.ocaml_canvas.objs/jsoo/default/ocaml_canvas.cma.js"
// Generated by js_of_ocaml
//# 3 "../src/.ocaml_canvas.objs/jsoo/default/ocaml_canvas.cma.js"

//# 6 "../src/.ocaml_canvas.objs/jsoo/default/ocaml_canvas.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$2 = "",
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = cst$2,
    cst$0 = cst$2,
    cst$1 = cst$2,
    zero = [0, 0., 0.],
    unit = [0, 1., 1.],
    id = [254, 1., 0., 0., 1., 0., 0.],
    React = global_data.React,
    Stdlib = global_data.Stdlib,
    Stdlib_Bigarray = global_data.Stdlib__Bigarray,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib_Callback = global_data.Stdlib__Callback,
    Stdlib_Map = global_data.Stdlib__Map,
    Stdlib_Hashtbl = global_data.Stdlib__Hashtbl;
   function valid_canvas_size(param){
    var height = param[2], width = param[1], _dI_ = 0 < width ? 1 : 0;
    if(_dI_){
     var _dJ_ = width <= 32767 ? 1 : 0;
     if(_dJ_)
      var
       _dK_ = 0 < height ? 1 : 0,
       _dL_ = _dK_ ? height <= 32767 ? 1 : 0 : _dK_;
     else
      var _dL_ = _dJ_;
    }
    else
     var _dL_ = _dI_;
    return _dL_;
   }
   var
    Not_initialized =
      [248, "OcamlCanvas.V1.Exception.Not_initialized", caml_fresh_oo_id(0)],
    File_not_found =
      [248, "OcamlCanvas.V1.Exception.File_not_found", caml_fresh_oo_id(0)],
    Read_png_failed =
      [248, "OcamlCanvas.V1.Exception.Read_png_failed", caml_fresh_oo_id(0)],
    Write_png_failed =
      [248, "OcamlCanvas.V1.Exception.Write_png_failed", caml_fresh_oo_id(0)];
   caml_call2(Stdlib_Callback[2], "Not_initialized", Not_initialized);
   caml_call2(Stdlib_Callback[2], "File_not_found", [0, File_not_found, cst]);
   caml_call2
    (Stdlib_Callback[2], "Read_png_failed", [0, Read_png_failed, cst$0]);
   caml_call2
    (Stdlib_Callback[2], "Write_png_failed", [0, Write_png_failed, cst$1]);
   var
    Exception =
      [0, Not_initialized, File_not_found, Read_png_failed, Write_png_failed],
    Const =
      [0,
       3.141592653589793,
       1.5707963267948966,
       0.7853981633974483,
       0.39269908169872414,
       0.3183098861837907,
       0.6366197723675814,
       1.2732395447351628,
       2.5464790894703255,
       2.718281828459045,
       0.36787944117144233,
       1.4426950408889634,
       0.4342944819032518,
       0.6931471805599453,
       2.302585092994046];
   function add(param, _dH_){
    var y2 = _dH_[2], x2 = _dH_[1], y1 = param[2], x1 = param[1];
    return [0, x1 + x2, y1 + y2];
   }
   function sub(param, _dG_){
    var y2 = _dG_[2], x2 = _dG_[1], y1 = param[2], x1 = param[1];
    return [0, x1 - x2, y1 - y2];
   }
   function mul(param, k){
    var y = param[2], x = param[1];
    return [0, x * k, y * k];
   }
   function dot(param, _dF_){
    var y2 = _dF_[2], x2 = _dF_[1], y1 = param[2], x1 = param[1];
    return x1 * x2 + y1 * y2;
   }
   function norm(param){
    var y = param[2], x = param[1];
    return Math.sqrt(x * x + y * y);
   }
   var
    Vector = [0, zero, unit, add, sub, mul, dot, norm],
    cst_Transform_inverse_the_matr =
      "Transform.inverse: the matrix is not inversible";
   function create(param){
    var
     f = param[6],
     e = param[5],
     d = param[4],
     c = param[3],
     b = param[2],
     a = param[1];
    return [254, a, b, c, d, e, f];
   }
   function mul$0(t1, t2){
    return [254,
            t1[1] * t2[1] + t1[3] * t2[2],
            t1[2] * t2[1] + t1[4] * t2[2],
            t1[1] * t2[3] + t1[3] * t2[4],
            t1[2] * t2[3] + t1[4] * t2[4],
            t1[5] + t1[1] * t2[5] + t1[3] * t2[6],
            t1[6] + t1[2] * t2[5] + t1[4] * t2[6]];
   }
   function translate(t, param){
    var y = param[2], x = param[1];
    return [254,
            t[1],
            t[2],
            t[3],
            t[4],
            x * t[1] + y * t[3],
            x * t[2] + y * t[4]];
   }
   function scale(t, param){
    var y = param[2], x = param[1];
    return [254, t[1] * x, t[2] * x, t[3] * y, t[4] * y, t[5], t[6]];
   }
   function shear(t, param){
    var y = param[2], x = param[1];
    return [254,
            t[1] + t[3] * y,
            t[2] + t[4] * y,
            t[3] + t[1] * x,
            t[4] + t[2] * x,
            t[5],
            t[6]];
   }
   function rotate(t, a){
    var cos_a = Math.cos(- a), sin_a = Math.sin(- a);
    return [254,
            t[1] * cos_a - t[3] * sin_a,
            t[2] * cos_a - t[4] * sin_a,
            t[3] * cos_a + t[1] * sin_a,
            t[4] * cos_a + t[2] * sin_a,
            t[5],
            t[6]];
   }
   function inverse(t){
    var det = t[1] * t[4] - t[2] * t[3];
    if(det == 0.) caml_call1(Stdlib[1], cst_Transform_inverse_the_matr);
    var invdet = 1. / det;
    return [254,
            t[4] * invdet,
            - t[2] * invdet,
            - t[3] * invdet,
            t[1] * invdet,
            (t[3] * t[6] - t[4] * t[5]) * invdet,
            (t[2] * t[5] - t[1] * t[6]) * invdet];
   }
   var
    Transform =
      [0, id, create, mul$0, translate, scale, shear, rotate, inverse],
    cst_Point_barycenter_a_b_must_ = "Point.barycenter: a + b must be non-nul";
   function of_ints(param){var y = param[2], x = param[1]; return [0, x, y];}
   function sub$0(param, _dE_){
    var y2 = _dE_[2], x2 = _dE_[1], y1 = param[2], x1 = param[1];
    return [0, x1 - x2, y1 - y2];
   }
   function translate$0(param, _dD_){
    var b = _dD_[2], a = _dD_[1], y = param[2], x = param[1];
    return [0, x + a, y + b];
   }
   function rotate$0(param, _dC_, theta){
    var cy = _dC_[2], cx = _dC_[1], y = param[2], x = param[1];
    return [0,
            (x - cx) * Math.cos(- theta) + (y - cy) * Math.sin(- theta) + cx,
            (y - cy) * Math.cos(- theta) - (x - cx) * Math.sin(- theta) + cy];
   }
   function transform(param, t){
    var y = param[2], x = param[1];
    return [0, x * t[1] + y * t[3] + t[5], x * t[2] + y * t[4] + t[6]];
   }
   function barycenter(a, param, b, _dB_){
    var
     y2 = _dB_[2],
     x2 = _dB_[1],
     y1 = param[2],
     x1 = param[1],
     sum_ab = a + b;
    if(sum_ab == 0.) caml_call1(Stdlib[1], cst_Point_barycenter_a_b_must_);
    return [0, (a * x1 + b * x2) / sum_ab, (a * y1 + b * y2) / sum_ab];
   }
   function distance(param, _dA_){
    var y2 = _dA_[2], x2 = _dA_[1], y1 = param[2], x1 = param[1];
    return Math.sqrt(Math.pow(x2 - x1, 2.) + Math.pow(y2 - y1, 2.));
   }
   var
    Point =
      [0,
       of_ints,
       sub$0,
       translate$0,
       rotate$0,
       transform,
       barycenter,
       distance];
   function clip_8(i){return 0 <= i ? 255 < i ? 255 : i : 0;}
   function of_rgb(r, g, b){
    var _dy_ = clip_8(b), _dz_ = clip_8(g) << 8;
    return (((clip_8(r) << 16) + _dz_ | 0) + _dy_ | 0) - 16777216 | 0;
   }
   function to_rgb(c){
    return [0, (c >>> 16 | 0) & 255, (c >>> 8 | 0) & 255, c & 255];
   }
   function of_argb(a, r, g, b){
    var
     _dv_ = clip_8(b),
     _dw_ = clip_8(g) << 8,
     _dx_ = ((clip_8(r) << 16) + _dw_ | 0) + _dv_ | 0;
    return (clip_8(a) << 24) + _dx_ | 0;
   }
   function to_argb(c){
    return [0,
            c >>> 24 | 0,
            (c >>> 16 | 0) & 255,
            (c >>> 8 | 0) & 255,
            c & 255];
   }
   function of_int(i){
    return 0 <= i ? 16777215 < i ? -1 : i - 16777216 | 0 : 0;
   }
   function to_int(c){return c & 16777215;}
   function of_int32(i){return i;}
   function to_int32(c){return c;}
   var
    StringMap = caml_call1(Stdlib_Map[1], [0, Stdlib_String[9]]),
    colors = [0, StringMap[1]];
   function define_color(name, c){
    var _dt_ = colors[1], _du_ = caml_call1(Stdlib_String[26], name);
    colors[1] = caml_call3(StringMap[4], _du_, c, _dt_);
    return c;
   }
   var
    transpBlack = define_color("transparent_black", 0),
    transpWhite = define_color("transparent_white", 16777215),
    black = define_color("black", -16777216),
    white = define_color("white", -1),
    blue = define_color("blue", -16776961),
    cyan = define_color("cyan", -16711681),
    green = define_color("green", -16744448),
    lime = define_color("lime", -16711936),
    orange = define_color("orange", -23296),
    pink = define_color("pink", -16181),
    red = define_color("red", -65536),
    cst_0x = "0x";
   function of_string(s){
    if(1 > caml_ml_string_length(s)) return black;
    if(35 === runtime.caml_string_get(s, 0)){
     var
      _dn_ =
        caml_call3(Stdlib_String[15], s, 1, caml_ml_string_length(s) - 1 | 0),
      s$0 = caml_call2(Stdlib[28], cst_0x, _dn_);
     return of_int(runtime.caml_int_of_string(s$0));
    }
    try{
     var
      _dp_ = colors[1],
      _dq_ = caml_call1(Stdlib_String[26], s),
      _dr_ = caml_call2(StringMap[28], _dq_, _dp_);
     return _dr_;
    }
    catch(_ds_){
     var _do_ = caml_wrap_exception(_ds_);
     if(_do_ === Stdlib[8]) return black;
     throw caml_maybe_attach_backtrace(_do_, 0);
    }
   }
   var
    Font = [0, 100, 200, 300, 400, 500, 600, 700, 800, 900],
    list = [0, 0],
    cst_ImageData_create_invalid_i =
      "ImageData.create: invalid image dimensions",
    cst_ImageData_of_bigarray_inva =
      "ImageData.of_bigarray: invalid image dimensions",
    cst_ImageData_of_bigarray_thir =
      "ImageData.of_bigarray: third dimension must be 4";
   function add_image_data(event, send_event, c){
    list[1] = [0, [0, event, send_event, c], list[1]];
    return 0;
   }
   function add_canvas(event, send_event, c){
    list[1] = [0, [1, event, send_event, c], list[1]];
    return 0;
   }
   function create$0(param){
    var height = param[2], width = param[1];
    if(1 - valid_canvas_size([0, width, height]))
     caml_call1(Stdlib[1], cst_ImageData_create_invalid_i);
    var
     a =
       caml_call5
        (Stdlib_Bigarray[21][1],
         Stdlib_Bigarray[6],
         Stdlib_Bigarray[15],
         height,
         width,
         4);
    runtime.caml_ba_fill(a, 0);
    return a;
   }
   function createFromPNG(filename){
    var
     match = caml_call1(React[1][2], 0),
     send_event = match[2],
     event = match[1];
    runtime.ml_canvas_image_data_create_from_png
     (filename, function(id){return add_image_data(event, send_event, id);});
    return event;
   }
   function importPNG(id, pos, filename){
    var
     match = caml_call1(React[1][2], 0),
     send_event = match[2],
     event = match[1];
    runtime.ml_canvas_image_data_import_png
     (id,
      pos,
      filename,
      function(id){return add_image_data(event, send_event, id);});
    return event;
   }
   function of_bigarray(ba){
    var _dm_ = runtime.caml_ba_dim_1(ba);
    if(1 - valid_canvas_size([0, runtime.caml_ba_dim_2(ba), _dm_]))
     caml_call1(Stdlib[1], cst_ImageData_of_bigarray_inva);
    if(4 !== runtime.caml_ba_dim_3(ba))
     caml_call1(Stdlib[1], cst_ImageData_of_bigarray_thir);
    return ba;
   }
   var Join = [0], Cap = [0], Style = [0], CompositeOp = [0];
   caml_call2(Stdlib_Callback[1], "Hashtbl.hash", Stdlib_Hashtbl[28]);
   function createOffscreenFromPNG(filename){
    var
     match = caml_call1(React[1][2], 0),
     send_event = match[2],
     event = match[1];
    runtime.ml_canvas_create_offscreen_from_png
     (filename, function(c){return add_canvas(event, send_event, c);});
    return event;
   }
   function importPNG$0(c, pos, filename){
    var
     match = caml_call1(React[1][2], 0),
     send_event = match[2],
     event = match[1];
    runtime.ml_canvas_import_png
     (c, pos, filename, function(c){return add_canvas(event, send_event, c);});
    return event;
   }
   var
    match = caml_call1(React[1][2], 0),
    send_frame = match[2],
    frame = match[1],
    match$0 = caml_call1(React[1][2], 0),
    send_focus_in = match$0[2],
    focus_in = match$0[1],
    match$1 = caml_call1(React[1][2], 0),
    send_focus_out = match$1[2],
    focus_out = match$1[1],
    match$2 = caml_call1(React[1][2], 0),
    send_resize = match$2[2],
    resize = match$2[1],
    match$3 = caml_call1(React[1][2], 0),
    send_move = match$3[2],
    move = match$3[1],
    match$4 = caml_call1(React[1][2], 0),
    send_close = match$4[2],
    close = match$4[1],
    match$5 = caml_call1(React[1][2], 0),
    send_key_down = match$5[2],
    key_down = match$5[1],
    match$6 = caml_call1(React[1][2], 0),
    send_key_up = match$6[2],
    key_up = match$6[1],
    match$7 = caml_call1(React[1][2], 0),
    send_button_down = match$7[2],
    button_down = match$7[1],
    match$8 = caml_call1(React[1][2], 0),
    send_button_up = match$8[2],
    button_up = match$8[1],
    match$9 = caml_call1(React[1][2], 0),
    send_mouse_move = match$9[2],
    mouse_move = match$9[1],
    match$10 =
      caml_call2(React[2][2], 0, runtime.caml_int64_create_lo_mi_hi(0, 0, 0)),
    set_event_timestamp = match$10[2],
    event_timestamp = match$10[1];
   function run(k){
    function h(e){
     switch(e[0]){
       case 0: break;
       case 1:
        var
         match = e[1],
         timestamp = match[2],
         canvas = match[1],
         e$0 = [0, canvas, timestamp, 0];
        caml_call2(set_event_timestamp, 0, e$0[2]);
        caml_call2(send_frame, 0, e$0);
        break;
       case 2:
        var _dj_ = e[1], timestamp$0 = _dj_[2], canvas$0 = _dj_[1];
        if(_dj_[3]){
         var e$1 = [0, canvas$0, timestamp$0, 0];
         caml_call2(set_event_timestamp, 0, e$1[2]);
         caml_call2(send_focus_in, 0, e$1);
        }
        else{
         var e$2 = [0, canvas$0, timestamp$0, 0];
         caml_call2(set_event_timestamp, 0, e$2[2]);
         caml_call2(send_focus_out, 0, e$2);
        }
        break;
       case 3:
        var
         match$0 = e[1],
         size = match$0[3],
         timestamp$1 = match$0[2],
         canvas$1 = match$0[1],
         e$3 = [0, canvas$1, timestamp$1, size];
        caml_call2(set_event_timestamp, 0, e$3[2]);
        caml_call2(send_resize, 0, e$3);
        break;
       case 4:
        var
         match$1 = e[1],
         position = match$1[3],
         timestamp$2 = match$1[2],
         canvas$2 = match$1[1],
         e$4 = [0, canvas$2, timestamp$2, position];
        caml_call2(set_event_timestamp, 0, e$4[2]);
        caml_call2(send_move, 0, e$4);
        break;
       case 5:
        var
         match$2 = e[1],
         timestamp$3 = match$2[2],
         canvas$3 = match$2[1],
         e$5 = [0, canvas$3, timestamp$3, 0];
        caml_call2(set_event_timestamp, 0, e$5[2]);
        caml_call2(send_close, 0, e$5);
        break;
       case 6:
        var
         _dk_ = e[1],
         flags = _dk_[5],
         char$0 = _dk_[4],
         key = _dk_[3],
         timestamp$4 = _dk_[2],
         canvas$4 = _dk_[1];
        if(_dk_[6]){
         var e$6 = [0, canvas$4, timestamp$4, [0, key, char$0, flags]];
         caml_call2(set_event_timestamp, 0, e$6[2]);
         caml_call2(send_key_down, 0, e$6);
        }
        else{
         var e$7 = [0, canvas$4, timestamp$4, [0, key, char$0, flags]];
         caml_call2(set_event_timestamp, 0, e$7[2]);
         caml_call2(send_key_up, 0, e$7);
        }
        break;
       case 7:
        var
         _dl_ = e[1],
         button = _dl_[4],
         position$0 = _dl_[3],
         timestamp$5 = _dl_[2],
         canvas$5 = _dl_[1];
        if(_dl_[5]){
         var e$8 = [0, canvas$5, timestamp$5, [0, position$0, button]];
         caml_call2(set_event_timestamp, 0, e$8[2]);
         caml_call2(send_button_down, 0, e$8);
        }
        else{
         var e$9 = [0, canvas$5, timestamp$5, [0, position$0, button]];
         caml_call2(set_event_timestamp, 0, e$9[2]);
         caml_call2(send_button_up, 0, e$9);
        }
        break;
       default:
        var
         match$3 = e[1],
         position$1 = match$3[3],
         timestamp$6 = match$3[2],
         canvas$6 = match$3[1],
         e$10 = [0, canvas$6, timestamp$6, position$1];
        caml_call2(set_event_timestamp, 0, e$10[2]);
        caml_call2(send_mouse_move, 0, e$10);
     }
     var l = list[1];
     if(! l) return 0;
     list[1] = 0;
     var _di_ = caml_call1(Stdlib_List[9], l);
     return caml_call2
             (Stdlib_List[17],
              function(param){
               if(0 === param[0]){
                var id = param[3], send_event = param[2], event = param[1];
                caml_call2(send_event, 0, id);
                return caml_call2(React[1][4], 0, event);
               }
               var c = param[3], send_event$0 = param[2], event$0 = param[1];
               caml_call2(send_event$0, 0, c);
               return caml_call2(React[1][4], 0, event$0);
              },
              _di_);
    }
    return runtime.ml_canvas_run(h, k);
   }
   var
    OcamlCanvas =
      [0,
       [0,
        Exception,
        Const,
        Vector,
        Transform,
        Point,
        [0,
         of_rgb,
         to_rgb,
         of_argb,
         to_argb,
         of_int,
         to_int,
         of_int32,
         to_int32,
         transpBlack,
         transpWhite,
         black,
         white,
         blue,
         cyan,
         green,
         lime,
         orange,
         pink,
         red,
         of_string,
         define_color],
        Font,
        [0,
         create$0,
         createFromPNG,
         function(_dh_){return runtime.ml_canvas_image_data_get_size(_dh_);},
         function(_dg_, _df_){
          return runtime.ml_canvas_image_data_fill(_dg_, _df_);
         },
         function(_de_, _dd_, _dc_){
          return runtime.ml_canvas_image_data_sub(_de_, _dd_, _dc_);
         },
         function(_db_, _da_, _c$_, _c__, _c9_){
          return runtime.ml_canvas_image_data_blit
                  (_db_, _da_, _c$_, _c__, _c9_);
         },
         function(_c8_, _c7_){
          return runtime.ml_canvas_image_data_get_pixel(_c8_, _c7_);
         },
         function(_c6_, _c5_, _c4_){
          return runtime.ml_canvas_image_data_put_pixel(_c6_, _c5_, _c4_);
         },
         importPNG,
         function(_c3_, _c2_){
          return runtime.ml_canvas_image_data_export_png(_c3_, _c2_);
         },
         of_bigarray,
         function(_c1_){return _c1_;}],
        [0,
         function(_c0_, _cZ_){
          return runtime.ml_canvas_gradient_create_linear(_c0_, _cZ_);
         },
         function(_cY_, _cX_, _cW_, _cV_){
          return runtime.ml_canvas_gradient_create_radial
                  (_cY_, _cX_, _cW_, _cV_);
         },
         function(_cU_, _cT_){
          return runtime.ml_canvas_gradient_create_conic(_cU_, _cT_);
         },
         function(_cS_, _cR_, _cQ_){
          return runtime.ml_canvas_gradient_add_color_stop(_cS_, _cR_, _cQ_);
         }],
        [0,
         function(_cP_, _cO_){
          return runtime.ml_canvas_pattern_create(_cP_, _cO_);
         }],
        [0,
         function(_cN_){return runtime.ml_canvas_path_create(_cN_);},
         function(_cM_, _cL_){
          return runtime.ml_canvas_path_move_to(_cM_, _cL_);
         },
         function(_cK_){return runtime.ml_canvas_path_close(_cK_);},
         function(_cJ_, _cI_){
          return runtime.ml_canvas_path_line_to(_cJ_, _cI_);
         },
         function(_cH_, _cG_, _cF_, _cE_, _cD_, _cC_){
          return runtime.ml_canvas_path_arc
                  (_cH_, _cG_, _cF_, _cE_, _cD_, _cC_);
         },
         function(_cB_, _cA_, _cz_, _cy_){
          return runtime.ml_canvas_path_arc_to(_cB_, _cA_, _cz_, _cy_);
         },
         function(_cx_, _cw_, _cv_){
          return runtime.ml_canvas_path_quadratic_curve_to(_cx_, _cw_, _cv_);
         },
         function(_cu_, _ct_, _cs_, _cr_){
          return runtime.ml_canvas_path_bezier_curve_to
                  (_cu_, _ct_, _cs_, _cr_);
         },
         function(_cq_, _cp_, _co_){
          return runtime.ml_canvas_path_rect(_cq_, _cp_, _co_);
         },
         function(_cn_, _cm_, _cl_, _ck_, _cj_, _ci_, _ch_){
          return runtime.ml_canvas_path_ellipse
                  (_cn_, _cm_, _cl_, _ck_, _cj_, _ci_, _ch_);
         },
         function(_cg_, _cf_){return runtime.ml_canvas_path_add(_cg_, _cf_);},
         function(_ce_, _cd_, _cc_){
          return runtime.ml_canvas_path_add_transformed(_ce_, _cd_, _cc_);
         }],
        Join,
        Cap,
        Style,
        CompositeOp,
        [0,
         function(_cb_, _ca_){return runtime.ml_canvas_compare(_cb_, _ca_);},
         function(_b$_){return runtime.ml_canvas_hash(_b$_);},
         function
         (_b__, _b9_, _b8_, _b7_, _b6_, _b5_, _b4_, _b3_, _b2_, _b1_, _b0_){
          return runtime.ml_canvas_create_onscreen
                  (_b__,
                   _b9_,
                   _b8_,
                   _b7_,
                   _b6_,
                   _b5_,
                   _b4_,
                   _b3_,
                   _b2_,
                   _b1_,
                   _b0_);
         },
         function(_bZ_, _bY_){
          return runtime.ml_canvas_create_offscreen(_bZ_, _bY_);
         },
         function(_bX_){
          return runtime.ml_canvas_create_offscreen_from_image_data(_bX_);
         },
         createOffscreenFromPNG,
         function(_bW_){return runtime.ml_canvas_show(_bW_);},
         function(_bV_){return runtime.ml_canvas_hide(_bV_);},
         function(_bU_){return runtime.ml_canvas_close(_bU_);},
         function(_bT_){return runtime.ml_canvas_commit(_bT_);},
         function(_bS_){return runtime.ml_canvas_get_id(_bS_);},
         function(_bR_){return runtime.ml_canvas_get_size(_bR_);},
         function(_bQ_, _bP_){return runtime.ml_canvas_set_size(_bQ_, _bP_);},
         function(_bO_){return runtime.ml_canvas_get_position(_bO_);},
         function(_bN_, _bM_){
          return runtime.ml_canvas_set_position(_bN_, _bM_);
         },
         function(_bL_){return runtime.ml_canvas_save(_bL_);},
         function(_bK_){return runtime.ml_canvas_restore(_bK_);},
         function(_bJ_, _bI_){
          return runtime.ml_canvas_set_transform(_bJ_, _bI_);
         },
         function(_bH_, _bG_){return runtime.ml_canvas_transform(_bH_, _bG_);},
         function(_bF_, _bE_){return runtime.ml_canvas_translate(_bF_, _bE_);},
         function(_bD_, _bC_){return runtime.ml_canvas_scale(_bD_, _bC_);},
         function(_bB_, _bA_){return runtime.ml_canvas_shear(_bB_, _bA_);},
         function(_bz_, _by_){return runtime.ml_canvas_rotate(_bz_, _by_);},
         function(_bx_){return runtime.ml_canvas_get_line_width(_bx_);},
         function(_bw_, _bv_){
          return runtime.ml_canvas_set_line_width(_bw_, _bv_);
         },
         function(_bu_){return runtime.ml_canvas_get_line_join(_bu_);},
         function(_bt_, _bs_){
          return runtime.ml_canvas_set_line_join(_bt_, _bs_);
         },
         function(_br_){return runtime.ml_canvas_get_line_cap(_br_);},
         function(_bq_, _bp_){
          return runtime.ml_canvas_set_line_cap(_bq_, _bp_);
         },
         function(_bo_){return runtime.ml_canvas_get_miter_limit(_bo_);},
         function(_bn_, _bm_){
          return runtime.ml_canvas_set_miter_limit(_bn_, _bm_);
         },
         function(_bl_){return runtime.ml_canvas_get_line_dash_offset(_bl_);},
         function(_bk_, _bj_){
          return runtime.ml_canvas_set_line_dash_offset(_bk_, _bj_);
         },
         function(_bi_){return runtime.ml_canvas_get_line_dash(_bi_);},
         function(_bh_, _bg_){
          return runtime.ml_canvas_set_line_dash(_bh_, _bg_);
         },
         function(_bf_){return runtime.ml_canvas_get_stroke_color(_bf_);},
         function(_be_, _bd_){
          return runtime.ml_canvas_set_stroke_color(_be_, _bd_);
         },
         function(_bc_, _bb_){
          return runtime.ml_canvas_set_stroke_gradient(_bc_, _bb_);
         },
         function(_ba_, _a$_){
          return runtime.ml_canvas_set_stroke_pattern(_ba_, _a$_);
         },
         function(_a__){return runtime.ml_canvas_get_stroke_style(_a__);},
         function(_a9_, _a8_){
          return runtime.ml_canvas_set_stroke_style(_a9_, _a8_);
         },
         function(_a7_){return runtime.ml_canvas_get_fill_color(_a7_);},
         function(_a6_, _a5_){
          return runtime.ml_canvas_set_fill_color(_a6_, _a5_);
         },
         function(_a4_, _a3_){
          return runtime.ml_canvas_set_fill_gradient(_a4_, _a3_);
         },
         function(_a2_, _a1_){
          return runtime.ml_canvas_set_fill_pattern(_a2_, _a1_);
         },
         function(_a0_){return runtime.ml_canvas_get_fill_style(_a0_);},
         function(_aZ_, _aY_){
          return runtime.ml_canvas_set_fill_style(_aZ_, _aY_);
         },
         function(_aX_){return runtime.ml_canvas_get_global_alpha(_aX_);},
         function(_aW_, _aV_){
          return runtime.ml_canvas_set_global_alpha(_aW_, _aV_);
         },
         function(_aU_){
          return runtime.ml_canvas_get_global_composite_operation(_aU_);
         },
         function(_aT_, _aS_){
          return runtime.ml_canvas_set_global_composite_operation(_aT_, _aS_);
         },
         function(_aR_){return runtime.ml_canvas_get_shadow_color(_aR_);},
         function(_aQ_, _aP_){
          return runtime.ml_canvas_set_shadow_color(_aQ_, _aP_);
         },
         function(_aO_){return runtime.ml_canvas_get_shadow_blur(_aO_);},
         function(_aN_, _aM_){
          return runtime.ml_canvas_set_shadow_blur(_aN_, _aM_);
         },
         function(_aL_){return runtime.ml_canvas_get_shadow_offset(_aL_);},
         function(_aK_, _aJ_){
          return runtime.ml_canvas_set_shadow_offset(_aK_, _aJ_);
         },
         function(_aI_, _aH_, _aG_, _aF_, _aE_){
          return runtime.ml_canvas_set_font(_aI_, _aH_, _aG_, _aF_, _aE_);
         },
         function(_aD_){return runtime.ml_canvas_clear_path(_aD_);},
         function(_aC_){return runtime.ml_canvas_close_path(_aC_);},
         function(_aB_, _aA_){return runtime.ml_canvas_move_to(_aB_, _aA_);},
         function(_az_, _ay_){return runtime.ml_canvas_line_to(_az_, _ay_);},
         function(_ax_, _aw_, _av_, _au_, _at_, _as_){
          return runtime.ml_canvas_arc(_ax_, _aw_, _av_, _au_, _at_, _as_);
         },
         function(_ar_, _aq_, _ap_, _ao_){
          return runtime.ml_canvas_arc_to(_ar_, _aq_, _ap_, _ao_);
         },
         function(_an_, _am_, _al_){
          return runtime.ml_canvas_quadratic_curve_to(_an_, _am_, _al_);
         },
         function(_ak_, _aj_, _ai_, _ah_){
          return runtime.ml_canvas_bezier_curve_to(_ak_, _aj_, _ai_, _ah_);
         },
         function(_ag_, _af_, _ae_){
          return runtime.ml_canvas_rect(_ag_, _af_, _ae_);
         },
         function(_ad_, _ac_, _ab_, _aa_, _$_, ___, _Z_){
          return runtime.ml_canvas_ellipse
                  (_ad_, _ac_, _ab_, _aa_, _$_, ___, _Z_);
         },
         function(_Y_, _X_){return runtime.ml_canvas_fill(_Y_, _X_);},
         function(_W_, _V_, _U_){
          return runtime.ml_canvas_fill_path(_W_, _V_, _U_);
         },
         function(_T_){return runtime.ml_canvas_stroke(_T_);},
         function(_S_, _R_){return runtime.ml_canvas_stroke_path(_S_, _R_);},
         function(_Q_, _P_){return runtime.ml_canvas_clip(_Q_, _P_);},
         function(_O_, _N_, _M_){
          return runtime.ml_canvas_clip_path(_O_, _N_, _M_);
         },
         function(_L_, _K_, _J_){
          return runtime.ml_canvas_fill_rect(_L_, _K_, _J_);
         },
         function(_I_, _H_, _G_){
          return runtime.ml_canvas_stroke_rect(_I_, _H_, _G_);
         },
         function(_F_, _E_, _D_){
          return runtime.ml_canvas_fill_text(_F_, _E_, _D_);
         },
         function(_C_, _B_, _A_){
          return runtime.ml_canvas_stroke_text(_C_, _B_, _A_);
         },
         function(_z_, _y_, _x_, _w_, _v_){
          return runtime.ml_canvas_blit(_z_, _y_, _x_, _w_, _v_);
         },
         function(_u_, _t_){return runtime.ml_canvas_get_pixel(_u_, _t_);},
         function(_s_, _r_, _q_){
          return runtime.ml_canvas_put_pixel(_s_, _r_, _q_);
         },
         function(_p_, _o_, _n_){
          return runtime.ml_canvas_get_image_data(_p_, _o_, _n_);
         },
         function(_m_, _l_, _k_, _j_, _i_){
          return runtime.ml_canvas_put_image_data(_m_, _l_, _k_, _j_, _i_);
         },
         importPNG$0,
         function(_h_, _g_){return runtime.ml_canvas_export_png(_h_, _g_);}],
        [0,
         frame,
         focus_in,
         focus_out,
         resize,
         move,
         close,
         key_down,
         key_up,
         button_down,
         button_up,
         mouse_move,
         event_timestamp,
         function(_f_){return runtime.ml_canvas_int_of_key(_f_);},
         function(_e_){return runtime.ml_canvas_key_of_int(_e_);}],
        [0,
         function(_d_){return runtime.ml_canvas_init(_d_);},
         run,
         function(_c_){return runtime.ml_canvas_stop(_c_);},
         function(_b_){return runtime.ml_canvas_get_canvas(_b_);},
         function(_a_){return runtime.ml_canvas_get_current_timestamp(_a_);}]]];
   runtime.caml_register_global(82, OcamlCanvas, "OcamlCanvas");
   return;
  }
  (globalThis));


//# 1 ".demo2.eobjs/jsoo/dune__exe__Demo2.cmo.js"
// Generated by js_of_ocaml
//# 3 ".demo2.eobjs/jsoo/dune__exe__Demo2.cmo.js"

//# 6 ".demo2.eobjs/jsoo/dune__exe__Demo2.cmo.js"
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call11(f, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10){
    return (f.l >= 0 ? f.l : f.l = f.length) == 11
            ? f(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10)
            : runtime.caml_call_gen
              (f, [a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    OcamlCanvas = global_data.OcamlCanvas,
    React = global_data.React;
   caml_call1(OcamlCanvas[1][18][1], 0);
   var
    c =
      caml_call11
       (OcamlCanvas[1][16][3],
        0,
        0,
        0,
        0,
        0,
        0,
        [0, "Hello world"],
        0,
        [0, [0, 300, 200]],
        [0, 800, 500],
        0);
   caml_call2(OcamlCanvas[1][16][43], c, OcamlCanvas[1][6][17]);
   caml_call3(OcamlCanvas[1][16][75], c, [0, 0., 0.], [0, 800., 500.]);
   caml_call2(OcamlCanvas[1][16][37], c, OcamlCanvas[1][6][13]);
   caml_call2(OcamlCanvas[1][16][25], c, 10.);
   caml_call2(OcamlCanvas[1][16][61], c, [0, 50., 50.]);
   caml_call2(OcamlCanvas[1][16][62], c, [0, 750., 50.]);
   caml_call2(OcamlCanvas[1][16][62], c, [0, 750., 450.]);
   caml_call2(OcamlCanvas[1][16][62], c, [0, 50., 450.]);
   caml_call1(OcamlCanvas[1][16][60], c);
   caml_call1(OcamlCanvas[1][16][71], c);
   caml_call1(OcamlCanvas[1][16][59], c);
   caml_call2(OcamlCanvas[1][16][61], c, [0, 150., 350.]);
   caml_call4
    (OcamlCanvas[1][16][66],
     c,
     [0, 350., -100.],
     [0, 450., 600.],
     [0, 650., 150.]);
   caml_call1(OcamlCanvas[1][16][71], c);
   caml_call1(OcamlCanvas[1][16][7], c);
   caml_call2
    (React[1][10],
     function(param){return caml_call1(OcamlCanvas[1][18][3], 0);},
     OcamlCanvas[1][17][6]);
   caml_call2
    (React[1][10],
     function(param){
      var key = param[3][1], _a_ = 0 === key ? 1 : 0;
      return _a_ ? caml_call1(OcamlCanvas[1][18][3], 0) : _a_;
     },
     OcamlCanvas[1][17][7]);
   caml_call1(OcamlCanvas[1][18][2], function(param){return 0;});
   var Dune_exe_Demo2 = [0];
   runtime.caml_register_global(16, Dune_exe_Demo2, "Dune__exe__Demo2");
   return;
  }
  (globalThis));


//# 1 "../.js/default/stdlib/std_exit.cmo.js"
// Generated by js_of_ocaml
//# 3 "../.js/default/stdlib/std_exit.cmo.js"

//# 6 "../.js/default/stdlib/std_exit.cmo.js"
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib;
   caml_call1(Stdlib[103], 0);
   var Std_exit = [0];
   runtime.caml_register_global(1, Std_exit, "Std_exit");
   return;
  }
  (globalThis));


//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJkZW1vMi5iYy5qcyIsInNvdXJjZVJvb3QiOiIiLCJuYW1lcyI6WyJCVVRUT04iLCJCVVRUT05fU1RBVEUiLCJCVVRUT05fU1RBVEVfVEFHIiwiQlVUVE9OX1RBRyIsImNhbWxfc3ViYXJyYXlfdG9fanNieXRlcyIsImEiLCJpIiwibGVuIiwiZiIsIlN0cmluZyIsIm51bGwiLCJzIiwiTWF0aCIsImNhbWxfc3RyaW5nX29mX2pzYnl0ZXMiLCJ4IiwiY2FtbF9zdHJpbmdfb2ZfYXJyYXkiLCJjYW1sX2JhX2dldF8xIiwiYmEiLCJpMCIsIkJpZ1N0cmluZ1JlYWRlciIsImJzIiwidGhpcyIsImFyciIsIkFycmF5IiwiaiIsIm9mZnNldCIsIkNBUF9UWVBFX1RBRyIsIkNPTVBPUF9UQUciLCJ0YWdfdG9fY2FwX3R5cGUiLCJqb29fZ2xvYmFsX29iamVjdCIsIkNhcF90eXBlX3ZhbCIsImNhcCIsInRhZ190b19jb21wb3AiLCJDb21wb3BfdmFsIiwiU1RZTEVfVEFHIiwiRHJhd19zdHlsZV92YWwiLCJzdHlsZSIsIkVWRU5UX1RBRyIsIkZPQ1VTIiwiRk9DVVNfVEFHIiwiSk9JTl9UWVBFX1RBRyIsInRhZ190b19qb2luX3R5cGUiLCJKb2luX3R5cGVfdmFsIiwiam9pbiIsIktFWSIsIktFWV9TVEFURSIsIktFWV9TVEFURV9UQUciLCJLRVlfVEFHIiwidGFnX3RvX2tjIiwiS2V5X2NvZGVfdmFsIiwia2V5Y29kZSIsImNhbWxfc3RyX3JlcGVhdCIsIm4iLCJyIiwibCIsImNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMiLCJqc29vX2lzX2FzY2lpIiwiY2FtbF91dGYxNl9vZl91dGY4IiwiYiIsInQiLCJjIiwiYzEiLCJjMiIsInYiLCJNbEJ5dGVzIiwidGFnIiwiY29udGVudHMiLCJsZW5ndGgiLCJjb250ZW50IiwiY2FtbF91dGY4X29mX3V0ZjE2IiwiZCIsImNhbWxfc3RyaW5nX29mX2pzc3RyaW5nIiwidW5peF9lcnJvciIsIm1ha2VfdW5peF9lcnJfYXJncyIsImNvZGUiLCJzeXNjYWxsIiwicGF0aCIsImVycm5vIiwidmFyaWFudCIsImFyZ3MiLCJjYW1sX25hbWVkX3ZhbHVlcyIsImNhbWxfbmFtZWRfdmFsdWUiLCJubSIsImpzb29fc3lzX2dldGVudiIsInByb2Nlc3MiLCJnbG9iYWxUaGlzIiwidW5kZWZpbmVkIiwiY2FtbF9yZWNvcmRfYmFja3RyYWNlX2ZsYWciLCJjYW1sX2dsb2JhbF9kYXRhIiwiY2FtbF9leG5fd2l0aF9qc19iYWNrdHJhY2UiLCJleG4iLCJmb3JjZSIsImNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZSIsImNhbWxfcmFpc2Vfd2l0aF9hcmdzIiwiY2FtbF9pc19tbF9ieXRlcyIsImNhbWxfaXNfbWxfc3RyaW5nIiwiY2FtbF9ieXRlc19vZl9hcnJheSIsIlVpbnQ4QXJyYXkiLCJjYW1sX2J5dGVzX29mX2pzYnl0ZXMiLCJjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nIiwiY2FtbF9ieXRlc19vZl9zdHJpbmciLCJjYW1sX3JhaXNlX3dpdGhfYXJnIiwiYXJnIiwiY2FtbF9yYWlzZV93aXRoX3N0cmluZyIsIm1zZyIsImNhbWxfcmFpc2Vfc3lzX2Vycm9yIiwiY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUiLCJuYW1lIiwiY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5IiwiY2FtbF91aW50OF9hcnJheV9vZl9ieXRlcyIsImNhbWxfaW52YWxpZF9hcmd1bWVudCIsImNhbWxfY3JlYXRlX2J5dGVzIiwiY2FtbF9tbF9ieXRlc19sZW5ndGgiLCJjYW1sX2JsaXRfYnl0ZXMiLCJzMSIsImkxIiwiczIiLCJpMiIsIk1sRmlsZSIsIk1sRmFrZUZpbGUiLCJvbGQiLCJidWYiLCJwb3MiLCJjbGVuIiwibmV3X3N0ciIsIm9sZF9kYXRhIiwiZGF0YSIsIk1sRmFrZUZkIiwiZmlsZSIsImZsYWdzIiwiTWxGYWtlRGV2aWNlIiwicm9vdCIsImNvbXAiLCJyZXMiLCJTeW1ib2wiLCJuYW1lX3NsYXNoIiwibW9kZSIsInJhaXNlX3VuaXgiLCJwYXJlbnQiLCJSZWdFeHAiLCJzZWVuIiwibSIsImVudHJ5Iiwib2siLCJieXRlcyIsIk1sRmFrZUZkX291dCIsImZkIiwiY29uc29sZSIsInNyYyIsImNhbWxfaW50NjRfb2Zmc2V0IiwiY2FtbF9yYWlzZV9jb25zdGFudCIsImNhbWxfcmFpc2VfemVyb19kaXZpZGUiLCJNbEludDY0IiwibG8iLCJtaSIsImhpIiwieGhpIiwiaCIsInNpZ24iLCJtb2R1bHVzIiwiZGl2aXNvciIsInF1b3RpZW50IiwieSIsInEiLCJNbE11dGV4IiwiTWxOYXQiLCJJbnQzMkFycmF5IiwiY2FtbF9tbF9zdHJpbmdfbGVuZ3RoIiwiY2FtbF9zdHJpbmdfdW5zYWZlX2dldCIsImNhbWxfdWludDhfYXJyYXlfb2Zfc3RyaW5nIiwiY2FtbF9ieXRlc19ib3VuZF9lcnJvciIsImNhbWxfYnl0ZXNfdW5zYWZlX3NldCIsImNhbWxfYnl0ZXNfc2V0IiwiTWxOb2RlRmQiLCJyZXF1aXJlIiwiZXJyIiwiYnVmX29mZnNldCIsInJlYWQiLCJNbE5vZGVEZXZpY2UiLCJjb25zdHMiLCJrZXkiLCJpc0NoYXJhY3RlckRldmljZSIsIm8iLCJqc19zdGF0cyIsInRvX2RpciIsInRhcmdldCIsImxpbmsiLCJmaWxlX2tpbmQiLCJNbE9iamVjdFRhYmxlIiwiTmFpdmVMb29rdXAiLCJvYmpzIiwiTWxTdHJpbmdSZWFkZXIiLCJjYW1sX2ludDY0X2NyZWF0ZV9sb19oaSIsImNhbWxfaW50NjRfaGkzMiIsImNhbWxfaW50NjRfbG8zMiIsImNhbWxfYXJyYXlfYm91bmRfZXJyb3IiLCJjYW1sX2JhX2N1c3RvbV9uYW1lIiwiTWxfQmlnYXJyYXkiLCJraW5kIiwibGF5b3V0IiwiZGltcyIsImJ1ZmZlciIsIm9mcyIsImltIiwicmUiLCJ0b3RhbCIsImsxIiwiazIiLCJOYU4iLCJNbF9CaWdhcnJheV9jXzFfMSIsIk9wdGlvbmFsX2Jvb2xfdmFsIiwibWxPcHRCb29sIiwiZGVmIiwiT3B0aW9uYWxfdmFsIiwibWxPcHRWYWwiLCJSRVBFQVRfVEFHIiwidGFnX3RvX3JlcGVhdCIsIlJlcGVhdF92YWwiLCJyZXBlYXQiLCJTTEFOVCIsIlNMQU5UX1RBRyIsInRhZ190b19zbGFudCIsIlNsYW50X3ZhbCIsInNsYW50IiwiVUludDhBcnJheVJlYWRlciIsImJ1dHRvbl90b190YWciLCJWYWxfYnV0dG9uIiwiYnV0dG9uIiwiYnV0dG9uX3N0YXRlX3RvX3RhZyIsIlZhbF9idXR0b25fc3RhdGUiLCJzdGF0ZSIsImNhcF90eXBlX3RvX3RhZyIsIlZhbF9jYXBfdHlwZSIsImNvbXBvcF90b190YWciLCJWYWxfY29tcG9wIiwiY29tcG9wIiwiX2NvbG9yX29mX2ludCIsImciLCJWYWxfZHJhd19zdHlsZSIsImZvY3VzX3RvX3RhZyIsIlZhbF9mb2N1c19pbl9vdXQiLCJmb2N1cyIsImpvaW5fdHlwZV90b190YWciLCJWYWxfam9pbl90eXBlIiwia2NfdG9fdGFnIiwiVmFsX2tleV9jb2RlIiwia2V5X3N0YXRlX3RvX3RhZyIsIlZhbF9rZXlfc3RhdGUiLCJyZXBlYXRfdG9fdGFnIiwiVmFsX3JlcGVhdCIsIl9ldmVudF9jYW52YXNfc2NhbGUiLCJlIiwiX2ZvY3VzIiwiY2FtbF9pbnQ2NF9vZl9mbG9hdCIsIl9tbF9jYW52YXNfbWxQcm9jZXNzRXZlbnQiLCJfbWxfY2FudmFzX21sRXhjZXB0aW9uIiwiX21sX2NhbnZhc19pbml0aWFsaXplZCIsIl9tbF9jYW52YXNfZW5zdXJlX2luaXRpYWxpemVkIiwiX21sX2NhbnZhc19tbENvbnRpbnVhdGlvbiIsIm1sX2NhbnZhc19zdG9wIiwiX21sX2NhbnZhc19wcm9jZXNzX2V2ZW50IiwibWxFdmVudCIsIl9mcmFtZV9oYW5kbGVyIiwidGltZXN0YW1wIiwic3VyZmFjZXMiLCJkb2N1bWVudCIsImV2dCIsIndpbmRvdyIsIl9tb3ZlIiwibWxfY2FudmFzX2hpZGUiLCJjYW52YXMiLCJtbF9jYW52YXNfY2xvc2UiLCJfaGVhZGVyX2Rvd25faGFuZGxlciIsIl9pbnRfb2ZfY29sb3IiLCJwYXJzZUludCIsInJnYmEiLCJwYXJzZUZsb2F0IiwiX2ludGVybmFsX2NhbnZhcyIsIl9pbnRlcm5hbF9jdHh0Iiwia25fdG9fa2MiLCJrZXluYW1lX3RvX2tleWNvZGUiLCJrZXluYW1lIiwiX21ha2Vfa2V5X2V2ZW50IiwiY2hhciIsIl9rZXlfZG93bl9oYW5kbGVyIiwiX2tleV91cF9oYW5kbGVyIiwiX21sX2NhbnZhc19hZGp1c3RfYmxpdF9pbmZvIiwiZHdpZHRoIiwiZGhlaWdodCIsImR4IiwiZHkiLCJzd2lkdGgiLCJzaGVpZ2h0Iiwic3giLCJzeSIsIndpZHRoIiwiaGVpZ2h0IiwiY2FtbF9iYV9nZXRfc2l6ZSIsIm5fZGltcyIsInNpemUiLCJjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50IiwiY2FtbF9iYV9jcmVhdGVfdW5zYWZlIiwic2l6ZV9wZXJfZWxlbWVudCIsIl9tbF9jYW52YXNfYmFfb2ZfaW1nIiwiaW1nIiwic3VyZmFjZSIsImN0eHQiLCJpbWFnZSIsInN0YSIsImR0YSIsImNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nIiwiX21sX2NhbnZhc19kZWNvcmF0ZSIsImhlYWRlciIsIm1pbmltaXplIiwibWF4aW1pemUiLCJjbG9zZSIsInRpdGxlIiwiZnNfbm9kZV9zdXBwb3J0ZWQiLCJtYWtlX3BhdGhfaXNfYWJzb2x1dGUiLCJwb3NpeCIsIndpbjMyIiwic3BsaXREZXZpY2VSZSIsInJlc3VsdCIsImRldmljZSIsImlzVW5jIiwiQm9vbGVhbiIsInNlcCIsInBhdGhfaXNfYWJzb2x1dGUiLCJjYW1sX3RyYWlsaW5nX3NsYXNoIiwiY2FtbF9jdXJyZW50X2RpciIsImNhbWxfbWFrZV9wYXRoIiwiY29tcDAiLCJuY29tcCIsImNhbWxfZ2V0X3Jvb3QiLCJjYW1sX2ZhaWx3aXRoIiwiY2FtbF9yb290IiwianNvb19tb3VudF9wb2ludCIsInJlc29sdmVfZnNfZGV2aWNlIiwiY2FtbF9yZWFkX2ZpbGVfY29udGVudCIsIl9tbF9jYW52YXNfaW1hZ2Vfb2ZfcG5nX2ZpbGUiLCJmaWxlbmFtZSIsImZjIiwiY2FtbF9iYV9kaW0iLCJjYW1sX2JhX3RvX3R5cGVkX2FycmF5IiwiX21sX2NhbnZhc19zdXJmYWNlX29mX2JhIiwiX21sX2NhbnZhc192YWxpZF9jYW52YXNfc2l6ZSIsIl9tb3ZlX2hhbmRsZXIiLCJuZXdfeCIsIm5ld195IiwiX25leHRfaWQiLCJfcmVzaXplX2hhbmRsZXIiLCJlbnRyaWVzIiwiX3Jlc2l6ZSIsIl9zdXJmYWNlX2Rvd25faGFuZGxlciIsIl91cF9oYW5kbGVyIiwiaW5jcl9uYXQiLCJuYXQiLCJjYXJyeV9pbiIsImNhcnJ5IiwiYWRkX25hdCIsIm5hdDEiLCJvZnMxIiwibGVuMSIsIm5hdDIiLCJvZnMyIiwibGVuMiIsImJpZ3N0cmluZ19vZl9hcnJheV9idWZmZXIiLCJhYiIsInRhIiwiYmlnc3RyaW5nX29mX3R5cGVkX2FycmF5IiwiYmlnc3RyaW5nX3RvX2FycmF5X2J1ZmZlciIsImJpZ3N0cmluZ190b190eXBlZF9hcnJheSIsImJsaXRfbmF0IiwiY2FtbF9NRDVUcmFuc2Zvcm0iLCJhZGQiLCJ4eCIsImZmIiwiZ2ciLCJoaCIsImlpIiwidyIsImNhbWxfTUQ1RmluYWwiLCJjdHgiLCJpbl9idWYiLCJjYW1sX01ENUluaXQiLCJBcnJheUJ1ZmZlciIsImIzMiIsIlVpbnQzMkFycmF5IiwiYjgiLCJjYW1sX01ENVVwZGF0ZSIsImlucHV0IiwiaW5wdXRfbGVuIiwiaW5wdXRfcG9zIiwibWlzc2luZyIsImNhbWxfYWNvc2hfZmxvYXQiLCJjYW1sX2NhbGxfZ2VuIiwiYXJnc0xlbiIsIm5hcmdzIiwiZXh0cmFfYXJncyIsImFyZ3VtZW50cyIsImNhbWxfYWxsb2NfZHVtbXlfaW5maXgiLCJjYW1sX2FsbG9jX3N0YWNrIiwiaHYiLCJoeCIsImhmIiwiY2FtbF9hcmd2IiwibWFpbiIsImFyZ3YiLCJwIiwiYXJnczIiLCJjYW1sX2FycmF5X2FwcGVuZCIsImExIiwiYTIiLCJsMSIsImwyIiwiY2FtbF9hcnJheV9ibGl0IiwiY2FtbF9hcnJheV9jb25jYXQiLCJjYW1sX2FycmF5X2ZpbGwiLCJhcnJheSIsImNhbWxfYXJyYXlfZ2V0IiwiaW5kZXgiLCJjYW1sX2FycmF5X29mX2J5dGVzIiwiY2FtbF9hcnJheV9vZl9zdHJpbmciLCJjYW1sX2FycmF5X3NldCIsIm5ld3ZhbCIsImNhbWxfYXJyYXlfc3ViIiwiY2FtbF9hc2luaF9mbG9hdCIsImNhbWxfYXRhbmhfZmxvYXQiLCJjYW1sX2F0b21pY19jYXMiLCJyZWYiLCJjYW1sX2F0b21pY19leGNoYW5nZSIsImNhbWxfYXRvbWljX2ZldGNoX2FkZCIsImNhbWxfYXRvbWljX2xvYWQiLCJjYW1sX2F0b21pY19tYWtlX2NvbnRlbmRlZCIsImNhbWxfYmFfYmxpdCIsImRzdCIsImNhbWxfYmFfY2hhbmdlX2xheW91dCIsIm5ld19kaW1zIiwiY2FtbF9iYV9jb21wYXJlIiwiY2FtbF9iYV9jcmVhdGVfYnVmZmVyIiwidmlldyIsIkZsb2F0MzJBcnJheSIsIkZsb2F0NjRBcnJheSIsIkludDhBcnJheSIsIkludDE2QXJyYXkiLCJVaW50MTZBcnJheSIsImNhbWxfanNfZnJvbV9hcnJheSIsImNhbWxfYmFfY3JlYXRlIiwiZGltc19tbCIsImNhbWxfYmFfY3JlYXRlX2Zyb20iLCJkYXRhMSIsImRhdGEyIiwianN0eXAiLCJjYW1sX2ludDMyX2Zsb2F0X29mX2JpdHMiLCJpbnQzMmEiLCJmbG9hdDMyYSIsImNhbWxfaW50NjRfb2ZfYnl0ZXMiLCJjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMiLCJleHAiLCJJbmZpbml0eSIsImsiLCJjYW1sX2JhX2Rlc2VyaWFsaXplIiwicmVhZGVyIiwic3oiLCJudW1fZGltcyIsInNpemVfZGltIiwic2l6ZV9kaW1faGkiLCJzaXplX2RpbV9sbyIsInNpeHR5IiwiaW50NjQiLCJjYW1sX2JhX2RpbV8xIiwiY2FtbF9iYV9kaW1fMiIsImNhbWxfYmFfZGltXzMiLCJjYW1sX2JhX2ZpbGwiLCJjYW1sX2JhX2tpbmRfb2ZfdHlwZWRfYXJyYXkiLCJVaW50OENsYW1wZWRBcnJheSIsImNhbWxfYmFfZnJvbV90eXBlZF9hcnJheSIsImNhbWxfYmFfZ2V0XzIiLCJjYW1sX2JhX2dldF8zIiwiY2FtbF9iYV9nZXRfZ2VuZXJpYyIsImNhbWxfbXVsIiwiY2FtbF9oYXNoX21peF9pbnQiLCJsb2cyX29rIiwianNvb19mbG9vcl9sb2cyIiwiY2FtbF9pbnQ2NF9jcmVhdGVfbG9fbWlfaGkiLCJjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQiLCJpc0Zpbml0ZSIsImlzTmFOIiwicjMiLCJyMiIsInIxIiwiY2FtbF9oYXNoX21peF9pbnQ2NCIsImNhbWxfaGFzaF9taXhfZmxvYXQiLCJ2MCIsImNhbWxfYmFfaGFzaCIsIm51bV9lbHRzIiwiY2FtbF9iYV9pbml0IiwiY2FtbF9iYV9raW5kIiwiY2FtbF9iYV9sYXlvdXQiLCJjYW1sX2JhX21hcF9maWxlIiwidmZkIiwic2hhcmVkIiwiY2FtbF9iYV9tYXBfZmlsZV9ieXRlY29kZSIsImFyZ24iLCJjYW1sX2JhX251bV9kaW1zIiwiY2FtbF9iYV9yZXNoYXBlIiwidmluZCIsIm5ld19kaW0iLCJjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXQiLCJjYW1sX2ludDY0X3RvX2J5dGVzIiwiY2FtbF9iYV9zZXJpYWxpemUiLCJ3cml0ZXIiLCJjb21wbGV4IiwiY2FtbF9iYV9zZXRfMSIsImNhbWxfYmFfc2V0XzIiLCJjYW1sX2JhX3NldF8zIiwiY2FtbF9iYV9zZXRfZ2VuZXJpYyIsImNhbWxfYmFfc2xpY2UiLCJudW1faW5kcyIsInN1Yl9kaW1zIiwibmV3X2RhdGEiLCJjYW1sX2JhX3N1YiIsImNoYW5nZWRfZGltIiwibXVsIiwiY2FtbF9iYV91aW50OF9nZXQxNiIsImIxIiwiYjIiLCJjYW1sX2JhX3VpbnQ4X2dldDMyIiwiYjMiLCJiNCIsImNhbWxfYmFfdWludDhfZ2V0NjQiLCJiNSIsImI2IiwiYjciLCJjYW1sX2JhX3VpbnQ4X3NldDE2IiwiY2FtbF9iYV91aW50OF9zZXQzMiIsImNhbWxfYmFfdWludDhfc2V0NjQiLCJjYW1sX2JhY2t0cmFjZV9zdGF0dXMiLCJfdW5pdCIsImNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYmEiLCJiYTEiLCJwb3MxIiwiYmEyIiwicG9zMiIsInNsaWNlIiwiY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19ieXRlcyIsImJ5dGVzMiIsImNhbWxfYmlnc3RyaW5nX2JsaXRfYnl0ZXNfdG9fYmEiLCJzdHIxIiwiY2FtbF9iaWdzdHJpbmdfYmxpdF9zdHJpbmdfdG9fYmEiLCJjYW1sX2JpZ3N0cmluZ19tZW1jbXAiLCJjYW1sX2JsaXRfc3RyaW5nIiwiY2FtbF9ic3dhcDE2IiwiY2FtbF9idWlsZF9zeW1ib2xzIiwic3ltYiIsImNhbWxfYnl0ZXNfY29tcGFyZSIsImNhbWxfYnl0ZXNfZXF1YWwiLCJjYW1sX2J5dGVzX3Vuc2FmZV9nZXQiLCJjYW1sX2J5dGVzX2dldCIsImNhbWxfYnl0ZXNfZ2V0MTYiLCJjYW1sX2J5dGVzX2dldDMyIiwiY2FtbF9ieXRlc19nZXQ2NCIsImNhbWxfYnl0ZXNfbGVzc2VxdWFsIiwiY2FtbF9ieXRlc19ncmVhdGVyZXF1YWwiLCJjYW1sX2J5dGVzX2xlc3N0aGFuIiwiY2FtbF9ieXRlc19ncmVhdGVydGhhbiIsImNhbWxfYnl0ZXNfbm90ZXF1YWwiLCJjYW1sX2J5dGVzX29mX3V0ZjE2X2pzc3RyaW5nIiwiY2FtbF9ieXRlc19zZXQxNiIsImkxNiIsImNhbWxfYnl0ZXNfc2V0MzIiLCJpMzIiLCJjYW1sX2J5dGVzX3NldDY0IiwiaTY0IiwiY2FtbF9jYWxsYmFjayIsImNhbWxfY2JydF9mbG9hdCIsImNhbWxfbWxfY2hhbm5lbHMiLCJjYW1sX21sX2NoYW5uZWxfZ2V0IiwiaWQiLCJjYW1sX2NoYW5uZWxfZGVzY3JpcHRvciIsImNoYW5pZCIsImNoYW4iLCJjYW1sX2NoZWNrX2JvdW5kIiwiY2FtbF9jbGFzc2lmeV9mbG9hdCIsImNhbWxfaXNfY29udGludWF0aW9uX3RhZyIsImNhbWxfaW50MzJfdW5tYXJzaGFsIiwiY2FtbF9uYXRpdmVpbnRfdW5tYXJzaGFsIiwiY2FtbF9pbnQ2NF91bm1hcnNoYWwiLCJjYW1sX2ludDY0X21hcnNoYWwiLCJzaXplcyIsImNhbWxfaW50NjRfY29tcGFyZSIsImNhbWxfaW50NjRfaGFzaCIsImNhbWxfY3VzdG9tX29wcyIsImNhbWxfY29tcGFyZV92YWxfZ2V0X2N1c3RvbSIsImNhbWxfY29tcGFyZV92YWxfbnVtYmVyX2N1c3RvbSIsIm51bSIsImN1c3RvbSIsInN3YXAiLCJjYW1sX2NvbXBhcmVfdmFsX3RhZyIsIk51bWJlciIsImNhbWxfaW50X2NvbXBhcmUiLCJjYW1sX3N0cmluZ19jb21wYXJlIiwiY2FtbF9jb21wYXJlX3ZhbCIsInN0YWNrIiwidGFnX2EiLCJ0YWdfYiIsImNhbWxfY29tcGFyZSIsImNhbWxfY29udGludWF0aW9uX3VzZV9ub2V4YyIsImNvbnQiLCJjYW1sX2NvbnRpbnVhdGlvbl91c2VfYW5kX3VwZGF0ZV9oYW5kbGVyX25vZXhjIiwiaHZhbCIsImhleG4iLCJoZWZmIiwiY2FtbF9jb252ZXJ0X3Jhd19iYWNrdHJhY2UiLCJjYW1sX2NvbnZlcnRfcmF3X2JhY2t0cmFjZV9zbG90IiwiY2FtbF9jb3B5c2lnbl9mbG9hdCIsImNhbWxfY29zaF9mbG9hdCIsImNhbWxfY3JlYXRlX2ZpbGUiLCJjYW1sX2NyZWF0ZV9zdHJpbmciLCJjYW1sX2N1c3RvbV9ldmVudF9pbmRleCIsImNhbWxfZGVjb21wcmVzc19pbnB1dCIsImNhbWxfZGl2IiwiY2FtbF9kb21haW5fZGxzIiwiY2FtbF9kb21haW5fZGxzX2dldCIsInVuaXQiLCJjYW1sX2RvbWFpbl9kbHNfc2V0IiwiY2FtbF9kb21haW5faWQiLCJjYW1sX21sX211dGV4X3VubG9jayIsImNhbWxfZG9tYWluX2xhdGVzdF9pZHgiLCJjYW1sX2RvbWFpbl9zcGF3biIsIm11dGV4IiwiY2FtbF9lcGhlX2RhdGFfb2Zmc2V0IiwiY2FtbF9lcGhlX2tleV9vZmZzZXQiLCJjYW1sX2VwaGVfdW5zZXRfZGF0YSIsImNhbWxfZXBoZV9zZXRfZGF0YSIsImNhbWxfZXBoZV9ibGl0X2RhdGEiLCJjYW1sX2VwaGVfYmxpdF9rZXkiLCJjYW1sX2VwaGVfY2hlY2tfZGF0YSIsImNhbWxfZXBoZV9jaGVja19rZXkiLCJ3ZWFrIiwiY2FtbF93ZWFrX2NyZWF0ZSIsImNhbWxfZXBoZV9jcmVhdGUiLCJjYW1sX2VwaGVfZ2V0X2RhdGEiLCJjYW1sX29ial9kdXAiLCJjYW1sX2VwaGVfZ2V0X2RhdGFfY29weSIsImNhbWxfZXBoZV9nZXRfa2V5IiwiY2FtbF9lcGhlX2dldF9rZXlfY29weSIsInoiLCJjYW1sX2VwaGVfc2V0X2tleSIsIk9iamVjdCIsImNhbWxfZXBoZV91bnNldF9rZXkiLCJjb3VudCIsImNhbWxfZXF1YWwiLCJjYW1sX2VyZl9mbG9hdCIsImEzIiwiYTQiLCJhNSIsImNhbWxfZXJmY19mbG9hdCIsImNhbWxfZXZlbnRsb2dfcGF1c2UiLCJjYW1sX2V2ZW50bG9nX3Jlc3VtZSIsImNhbWxfZXhlY3V0YWJsZV9uYW1lIiwiY2FtbF9leHAyX2Zsb2F0IiwiY2FtbF9leHBtMV9mbG9hdCIsImNhbWxfaXNfc3BlY2lhbF9leGNlcHRpb24iLCJjYW1sX2Zvcm1hdF9leGNlcHRpb24iLCJidWNrZXQiLCJzdGFydCIsImNhbWxfZmF0YWxfdW5jYXVnaHRfZXhjZXB0aW9uIiwiaGFuZGxlciIsImF0X2V4aXQiLCJjYW1sX2ZpbGxfYnl0ZXMiLCJjYW1sX2ZpbmFsX3JlZ2lzdGVyIiwiYWxsX2ZpbmFsaXplcnMiLCJjYW1sX2ZpbmFsX3JlZ2lzdGVyX2NhbGxlZF93aXRob3V0X3ZhbHVlIiwiY2IiLCJjYW1sX2ZpbmFsX3JlbGVhc2UiLCJjYW1sX2ZpbmlzaF9mb3JtYXR0aW5nIiwicmF3YnVmZmVyIiwiY2FtbF9mbG9hdF9jb21wYXJlIiwiY2FtbF9mbG9hdF9vZl9ieXRlcyIsImNhbWxfZmxvYXRfb2Zfc3RyaW5nIiwibTMiLCJtYW50aXNzYSIsImV4cG9uZW50IiwiY2FtbF9mbG9hdGFycmF5X2JsaXQiLCJjYW1sX2Zsb2F0YXJyYXlfY3JlYXRlIiwiY2FtbF9mbWFfZmxvYXQiLCJTUExJVCIsIk1JTl9WQUxVRSIsIkVQU0lMT04iLCJDIiwiQSIsIkIiLCJtdWx0aXBseSIsImF0IiwiYWhpIiwiYWxvIiwiYnQiLCJiaGkiLCJibG8iLCJhZGp1c3QiLCJzY2FsZSIsInhzIiwieXMiLCJ6cyIsInh5IiwidSIsImZzIiwiY2FtbF9wYXJzZV9mb3JtYXQiLCJmbXQiLCJjYW1sX2Zvcm1hdF9mbG9hdCIsInRvRml4ZWQiLCJkcCIsInByZWMiLCJjYW1sX2Zvcm1hdF9pbnQiLCJjYW1sX29vX2xhc3RfaWQiLCJjYW1sX2ZyZXNoX29vX2lkIiwiY2FtbF9mcmV4cF9mbG9hdCIsIm5lZyIsImpzb29fY3JlYXRlX2ZpbGUiLCJjYW1sX2ZzX2luaXQiLCJ0bXAiLCJjYW1sX2djX2NvbXBhY3Rpb24iLCJjYW1sX2djX2NvdW50ZXJzIiwiY2FtbF9nY19mdWxsX21ham9yIiwiY2FtbF9nY19nZXQiLCJjYW1sX2djX2h1Z2VfZmFsbGJhY2tfY291bnQiLCJjYW1sX2djX21ham9yIiwiY2FtbF9nY19tYWpvcl9zbGljZSIsIndvcmsiLCJjYW1sX2djX21pbm9yIiwiY2FtbF9nY19taW5vcl93b3JkcyIsImNhbWxfZ2NfcXVpY2tfc3RhdCIsImNhbWxfZ2Nfc2V0IiwiX2NvbnRyb2wiLCJjYW1sX2djX3N0YXQiLCJjYW1sX2dldF9jb250aW51YXRpb25fY2FsbHN0YWNrIiwiY2FtbF9nZXRfY3VycmVudF9jYWxsc3RhY2siLCJjYW1sX2dldF9leGNlcHRpb25fYmFja3RyYWNlIiwiY2FtbF9nZXRfZXhjZXB0aW9uX3Jhd19iYWNrdHJhY2UiLCJjYW1sX2dldF9nbG9iYWxfZGF0YSIsImNhbWxfZ2V0X21ham9yX2J1Y2tldCIsImNhbWxfZ2V0X21ham9yX2NyZWRpdCIsImNhbWxfZ2V0X21pbm9yX2ZyZWUiLCJjYW1sX21ldGhvZF9jYWNoZSIsImNhbWxfZ2V0X3B1YmxpY19tZXRob2QiLCJvYmoiLCJjYWNoZWlkIiwibWV0aHMiLCJsaSIsImNhbWxfZ3JfYXJjX2F1eCIsImN4IiwiY3kiLCJyeSIsInJ4Iiwicm90IiwieFBvcyIsInlQb3MiLCJ4UG9zX3ByZXYiLCJ5UG9zX3ByZXYiLCJzcGFjZSIsImRlbHRhIiwiY2FtbF9ncl9zdGF0ZSIsImNhbWxfZ3Jfc3RhdGVfZ2V0IiwiY2FtbF9ncl9ibGl0X2ltYWdlIiwiaW0yIiwiY2FtbF9ncl9jbGVhcl9ncmFwaCIsImNhbWxfZ3JfY2xvc2VfZ3JhcGgiLCJjYW1sX2dyX2Nsb3NlX3N1YndpbmRvdyIsImNhbWxfZ3JfY3JlYXRlX2ltYWdlIiwiY2FtbF9ncl9jdXJyZW50X3giLCJjYW1sX2dyX2N1cnJlbnRfeSIsImNhbWxfZ3JfZGlzcGxheV9tb2RlIiwiY2FtbF9ncl9kb2Nfb2Zfc3RhdGUiLCJjYW1sX2dyX2RyYXdfYXJjIiwiY2FtbF9ncl9kcmF3X3N0ciIsInN0ciIsImNhbWxfZ3JfZHJhd19jaGFyIiwiY2FtbF9ncl9kcmF3X2ltYWdlIiwiY2FtbF9ncl9kcmF3X3JlY3QiLCJjYW1sX2dyX2RyYXdfc3RyaW5nIiwiY2FtbF9ncl9kdW1wX2ltYWdlIiwiY2FtbF9ncl9maWxsX2FyYyIsImNhbWxfZ3JfZmlsbF9wb2x5IiwiYXIiLCJjYW1sX2dyX2ZpbGxfcmVjdCIsImNhbWxfZ3JfbGluZXRvIiwiY2FtbF9ncl9tYWtlX2ltYWdlIiwiY2FtbF9ncl9tb3ZldG8iLCJjYW1sX2dyX3NldF93aW5kb3dfdGl0bGUiLCJqc25hbWUiLCJjYW1sX2dyX3NldF9saW5lX3dpZHRoIiwiY2FtbF9ncl9zZXRfdGV4dF9zaXplIiwiY2FtbF9ncl9zZXRfZm9udCIsImNhbWxfZ3Jfc2V0X2NvbG9yIiwiY29sb3IiLCJjb252ZXJ0IiwibnVtYmVyIiwiY19zdHIiLCJjYW1sX2dyX3Jlc2l6ZV93aW5kb3ciLCJjYW1sX2dyX3N0YXRlX2luaXQiLCJjYW1sX2dyX3N0YXRlX3NldCIsImNhbWxfZ3Jfc3RhdGVfY3JlYXRlIiwiY29udGV4dCIsImNhbWxfZ3Jfb3Blbl9ncmFwaCIsImluZm8iLCJnZXQiLCJzcGVjcyIsInN0YXR1cyIsIndpbiIsImRvYyIsImJvZHkiLCJjYW1sX2dyX29wZW5fc3Vid2luZG93IiwiY2FtbF9ncl9wbG90IiwiY2FtbF9ncl9wb2ludF9jb2xvciIsImNhbWxfZ3JfcmVtZW1iZXJfbW9kZSIsImNhbWxfZ3Jfc2lnaW9faGFuZGxlciIsImNhbWxfZ3Jfc2lnaW9fc2lnbmFsIiwiY2FtbF9ncl9zaXplX3giLCJjYW1sX2dyX3NpemVfeSIsImNhbWxfZ3Jfc3luY2hyb25pemUiLCJjYW1sX2dyX3RleHRfc2l6ZSIsInR4dCIsImNhbWxfZ3Jfd2FpdF9ldmVudCIsIl9ldmwiLCJjYW1sX2dyX3dpbmRvd19pZCIsImNhbWxfZ3JlYXRlcmVxdWFsIiwiY2FtbF9ncmVhdGVydGhhbiIsImNhbWxfaGFzaF9taXhfanNieXRlcyIsImNhbWxfaGFzaF9taXhfc3RyaW5nIiwiY2FtbF9oYXNoX21peF9ieXRlc19hcnIiLCJjYW1sX21sX2J5dGVzX2NvbnRlbnQiLCJjYW1sX2hhc2hfbWl4X2J5dGVzIiwiY2FtbF9oYXNoX21peF9maW5hbCIsImNhbWxfaGFzaCIsImxpbWl0Iiwic2VlZCIsInF1ZXVlIiwicmQiLCJ3ciIsImNhbWxfaGFzaF9taXhfYmlnc3RyaW5nIiwibnVtX2RpZ2l0c19uYXQiLCJjYW1sX2hhc2hfbmF0IiwiY2FtbF9oZXhzdHJpbmdfb2ZfZmxvYXQiLCJleHBfc2lnbiIsInNpZ25fc3RyIiwiY3N0IiwieF9zdHIiLCJpZHgiLCJjYW1sX2h5cG90X2Zsb2F0IiwiY2FtbF9tYXJzaGFsX2hlYWRlcl9zaXplIiwiY2FtbF9yZWZpbGwiLCJzdHJfYSIsIm5yZWFkIiwiY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZSIsImNhbWxfbWFyc2hhbF9kYXRhX3NpemUiLCJyZWFkdmxxIiwib3ZlcmZsb3ciLCJuNyIsImhlYWRlcl9sZW4iLCJkYXRhX2xlbiIsImNhbWxfaW5wdXRfdmFsdWVfZnJvbV9yZWFkZXIiLCJtYWdpYyIsImNvbXByZXNzZWQiLCJ1bmNvbXByZXNzZWRfZGF0YV9sZW4iLCJudW1fb2JqZWN0cyIsIl9zaXplXzMyIiwiX3NpemVfNjQiLCJpbnRlcm5fb2JqX3RhYmxlIiwib2JqX2NvdW50ZXIiLCJpbnRlcm5fcmVjIiwib3BzIiwiZXhwZWN0ZWRfc2l6ZSIsIm9sZF9wb3MiLCJjYW1sX3N0cmluZ19vZl9ieXRlcyIsImNhbWxfaW5wdXRfdmFsdWVfZnJvbV9ieXRlcyIsImNhbWxfaW5wdXRfdmFsdWUiLCJibG9jayIsImNhbWxfaW5wdXRfdmFsdWVfZnJvbV9zdHJpbmciLCJjYW1sX2lucHV0X3ZhbHVlX3RvX291dHNpZGVfaGVhcCIsImNhbWxfaW5zdGFsbF9zaWduYWxfaGFuZGxlciIsImNhbWxfaW50MzJfYnN3YXAiLCJjYW1sX2ludDY0X2FkZCIsImNhbWxfaW50NjRfYW5kIiwiY2FtbF9pbnQ2NF9ic3dhcCIsImNhbWxfaW50NjRfZGl2IiwiY2FtbF9pbnQ2NF9pc196ZXJvIiwiY2FtbF9pbnQ2NF9vZl9pbnQzMiIsImNhbWxfaW50NjRfdG9faW50MzIiLCJjYW1sX2ludDY0X2lzX25lZ2F0aXZlIiwiY2FtbF9pbnQ2NF9uZWciLCJjYW1sX2ludDY0X2Zvcm1hdCIsIndiYXNlIiwiY3Z0YmwiLCJjYW1sX2ludDY0X21vZCIsImNhbWxfaW50NjRfbXVsIiwiY2FtbF9pbnQ2NF91bHQiLCJjYW1sX3BhcnNlX3NpZ25fYW5kX2Jhc2UiLCJiYXNlIiwiY2FtbF9wYXJzZV9kaWdpdCIsImNhbWxfaW50NjRfb2Zfc3RyaW5nIiwiYmFzZTY0IiwidGhyZXNob2xkIiwiY2FtbF9pbnQ2NF9vciIsImNhbWxfaW50NjRfc2hpZnRfbGVmdCIsImNhbWxfaW50NjRfc2hpZnRfcmlnaHQiLCJjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0X3Vuc2lnbmVkIiwiY2FtbF9pbnQ2NF9zdWIiLCJjYW1sX2ludDY0X3RvX2Zsb2F0IiwiY2FtbF9pbnQ2NF94b3IiLCJjYW1sX2ludF9vZl9zdHJpbmciLCJjYW1sX2lzX2pzIiwiY2FtbF9pc19wcmludGFibGUiLCJjYW1sX2pzX2NhbGwiLCJjYW1sX2pzX2RlbGV0ZSIsImNhbWxfanNfZXF1YWxzIiwiY2FtbF9qc19lcnJvcl9vZl9leGNlcHRpb24iLCJjYW1sX2pzX2Vycm9yX29wdGlvbl9vZl9leGNlcHRpb24iLCJjYW1sX2pzX2V2YWxfc3RyaW5nIiwiZXZhbCIsImNhbWxfanNfZXhwciIsImNhbWxfanNfZnJvbV9ib29sIiwiY2FtbF9qc19mcm9tX2Zsb2F0IiwiY2FtbF9qc19mcm9tX3N0cmluZyIsImNhbWxfanNfZnVuX2NhbGwiLCJjYW1sX2pzX2Z1bmN0aW9uX2FyaXR5IiwiY2FtbF9qc19nZXQiLCJjYW1sX2pzX2dldF9jb25zb2xlIiwiY2FtbF9qc19odG1sX2VudGl0aWVzIiwiZW50aXR5IiwidGVtcCIsImNhbWxfanNfcmVnZXhwcyIsImNhbWxfanNfaHRtbF9lc2NhcGUiLCJjYW1sX2pzX2luc3RhbmNlb2YiLCJjYW1sX2pzX21ldGhfY2FsbCIsImNhbWxfanNfbmV3IiwiRiIsImNhbWxfanNfb2JqZWN0IiwiY2FtbF9qc19vbl9pZSIsInVhIiwiY2FtbF9qc19wdXJlX2V4cHIiLCJjYW1sX2pzX3NldCIsImNhbWxfanNfc3RyaWN0X2VxdWFscyIsImNhbWxfanNfdG9fYXJyYXkiLCJjYW1sX2pzX3RvX2Jvb2wiLCJjYW1sX2pzX3RvX2J5dGVfc3RyaW5nIiwiY2FtbF9qc190b19mbG9hdCIsImNhbWxfanNfdG9faW50MzIiLCJjYW1sX2pzX3RvX3N0cmluZyIsImNhbWxfanNfdHlwZW9mIiwiY2FtbF9qc192YXIiLCJjYW1sX2pzX3dyYXBfY2FsbGJhY2siLCJGdW5jdGlvbiIsImNhbWxfanNfd3JhcF9jYWxsYmFja19hcmd1bWVudHMiLCJjYW1sX2pzX3dyYXBfY2FsbGJhY2tfc3RyaWN0IiwiYXJpdHkiLCJjYW1sX2pzX3dyYXBfY2FsbGJhY2tfdW5zYWZlIiwiY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2siLCJjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja19hcmd1bWVudHMiLCJjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja19zdHJpY3QiLCJjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja191bnNhZmUiLCJjYW1sX2pzb29fZmxhZ3NfZWZmZWN0cyIsImNhbWxfanNvb19mbGFnc191c2VfanNfc3RyaW5nIiwiY2FtbF9sYXp5X21ha2VfZm9yd2FyZCIsImNhbWxfb2JqX3RhZyIsImNhbWxfbGF6eV9yZWFkX3Jlc3VsdCIsImNhbWxfb2JqX3VwZGF0ZV90YWciLCJjYW1sX2xhenlfcmVzZXRfdG9fbGF6eSIsImNhbWxfbGF6eV91cGRhdGVfdG9fZm9yY2luZyIsImNhbWxfbGF6eV91cGRhdGVfdG9fZm9yd2FyZCIsImNhbWxfbGRleHBfZmxvYXQiLCJjYW1sX2xlc3NlcXVhbCIsImNhbWxfbGVzc3RoYW4iLCJjYW1sX2xleF9hcnJheSIsImNhbWxfbGV4X2VuZ2luZSIsInRibCIsInN0YXJ0X3N0YXRlIiwibGV4YnVmIiwibGV4X2J1ZmZlciIsImxleF9idWZmZXJfbGVuIiwibGV4X3N0YXJ0X3BvcyIsImxleF9jdXJyX3BvcyIsImxleF9sYXN0X3BvcyIsImxleF9sYXN0X2FjdGlvbiIsImxleF9lb2ZfcmVhY2hlZCIsImxleF9iYXNlIiwibGV4X2JhY2t0cmsiLCJsZXhfZGVmYXVsdCIsImxleF90cmFucyIsImxleF9jaGVjayIsImJhY2t0cmsiLCJjYW1sX2xpc3RfbW91bnRfcG9pbnQiLCJwcmV2IiwiY2FtbF9saXN0X29mX2pzX2FycmF5IiwiY2FtbF9saXN0X3RvX2pzX2FycmF5IiwiY2FtbF9sb2cxMF9mbG9hdCIsImNhbWxfbG9nMXBfZmxvYXQiLCJjYW1sX2xvZzJfZmxvYXQiLCJjYW1sX25ld19zdHJpbmciLCJjYW1sX2x4bV9uZXh0Iiwic2hpZnRfbCIsInNoaWZ0X3IiLCJvciIsInhvciIsInJvdGwiLCJzZXQiLCJNIiwiZGFiYSIsInEwIiwicTEiLCJzdCIsIngwIiwieDEiLCJjYW1sX21ha2VfZmxvYXRfdmVjdCIsImNhbWxfbWFrZV92ZWN0IiwiaW5pdCIsImNhbWxfbWFyc2hhbF9jb25zdGFudHMiLCJjYW1sX21heWJlX3ByaW50X3N0YXRzIiwiY2FtbF9tZDVfYnl0ZXMiLCJjYW1sX21sX2lucHV0X2Jsb2NrIiwiYXZhaWwiLCJjYW1sX21kNV9jaGFuIiwidG9yZWFkIiwiY2FtbF9tZDVfc3RyaW5nIiwiY2FtbF9tZW1wcm9mX2Rpc2NhcmQiLCJjYW1sX21lbXByb2Zfc2V0IiwiY2FtbF9tZW1wcm9mX3N0YXJ0IiwicmF0ZSIsInN0YWNrX3NpemUiLCJ0cmFja2VyIiwiY2FtbF9tZW1wcm9mX3N0b3AiLCJjYW1sX21sX2NoYW5uZWxfcmVkaXJlY3QiLCJjYXB0dXJlZCIsImludG8iLCJ0b19yZXN0b3JlIiwibmV3XyIsImNhbWxfbWxfY2hhbm5lbF9yZXN0b3JlIiwiY2FtbF9tbF9jaGFubmVsX3NpemUiLCJjYW1sX21sX2NoYW5uZWxfc2l6ZV82NCIsImNhbWxfc3lzX2ZkcyIsImNhbWxfc3lzX2Nsb3NlIiwiY2FtbF9tbF9mbHVzaCIsImNhbWxfbWxfY2xvc2VfY2hhbm5lbCIsImNhbWxfbWxfY29uZGl0aW9uX2Jyb2FkY2FzdCIsImNhbWxfbWxfY29uZGl0aW9uX25ldyIsImNhbWxfbWxfY29uZGl0aW9uX3NpZ25hbCIsImNhbWxfbWxfY29uZGl0aW9uX3dhaXQiLCJtdXRleHQiLCJjYW1sX21sX2RlYnVnX2luZm9fc3RhdHVzIiwiY2FtbF9tbF9kb21haW5fY3B1X3JlbGF4IiwiY2FtbF9tbF9kb21haW5faWQiLCJjYW1sX21sX2RvbWFpbl9zZXRfbmFtZSIsIl9uYW1lIiwiY2FtbF9tbF9kb21haW5fdW5pcXVlX3Rva2VuXyIsImNhbWxfbWxfZG9tYWluX3VuaXF1ZV90b2tlbiIsImNhbWxfcnVudGltZV93YXJuaW5ncyIsImNhbWxfbWxfZW5hYmxlX3J1bnRpbWVfd2FybmluZ3MiLCJib29sIiwiY2FtbF9tbF9pbnB1dCIsImNhbWxfbWxfaW5wdXRfYmlnYXJyYXkiLCJjYW1sX21sX2lucHV0X2NoYXIiLCJjYW1sX21sX2lucHV0X2ludCIsImNhbWxfbWxfaW5wdXRfc2Nhbl9saW5lIiwicHJldl9tYXgiLCJjYW1sX21sX2lzX2J1ZmZlcmVkIiwiY2FtbF9tbF9tdXRleF9sb2NrIiwiY2FtbF9tbF9tdXRleF9uZXciLCJjYW1sX21sX211dGV4X3RyeV9sb2NrIiwiY2FtbF9zeXNfb3Blbl9mb3Jfbm9kZSIsImZkMiIsImNhbWxfc3lzX29wZW5faW50ZXJuYWwiLCJjYW1sX3N5c19vcGVuIiwiX3Blcm1zIiwiY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3JfaW4iLCJyZWZpbGwiLCJjaGFubmVsIiwiY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3Jfb3V0IiwiYnVmZmVyZWQiLCJjYW1sX21sX291dF9jaGFubmVsc19saXN0IiwiY2FtbF9tbF9vdXRwdXRfdGEiLCJjYW1sX21sX291dHB1dF9ieXRlcyIsImNhbWxfbWxfb3V0cHV0IiwiY2FtbF9tbF9vdXRwdXRfYmlnYXJyYXkiLCJjYW1sX21sX291dHB1dF9jaGFyIiwiY2FtbF9tbF9vdXRwdXRfaW50IiwiY2FtbF9wb3NfaW4iLCJjYW1sX21sX3Bvc19pbiIsImNhbWxfbWxfcG9zX2luXzY0IiwiY2FtbF9wb3Nfb3V0IiwiY2FtbF9tbF9wb3Nfb3V0IiwiY2FtbF9tbF9wb3Nfb3V0XzY0IiwiY2FtbF9tbF9ydW50aW1lX2V2ZW50c19wYXVzZSIsImNhbWxfbWxfcnVudGltZV9ldmVudHNfcmVzdW1lIiwiY2FtbF9tbF9ydW50aW1lX2V2ZW50c19zdGFydCIsImNhbWxfbWxfcnVudGltZV93YXJuaW5nc19lbmFibGVkIiwiY2FtbF9zZWVrX2luIiwiY2FtbF9tbF9zZWVrX2luIiwiY2FtbF9tbF9zZWVrX2luXzY0IiwiY2FtbF9zZWVrX291dCIsImNhbWxfbWxfc2Vla19vdXQiLCJjYW1sX21sX3NlZWtfb3V0XzY0IiwiY2FtbF9tbF9zZXRfYmluYXJ5X21vZGUiLCJjYW1sX21sX3NldF9idWZmZXJlZCIsImNhbWxfbWxfc2V0X2NoYW5uZWxfbmFtZSIsImNhbWxfbWxfc2V0X2NoYW5uZWxfb3V0cHV0IiwiY2FtbF9tbF9zZXRfY2hhbm5lbF9yZWZpbGwiLCJjYW1sX21vZCIsImNhbWxfbW9kZl9mbG9hdCIsImNhbWxfbW91bnRfYXV0b2xvYWQiLCJjYW1sX2xleF9ydW5fbWVtIiwibWVtIiwiY3Vycl9wb3MiLCJjYW1sX2xleF9ydW5fdGFnIiwiY2FtbF9uZXdfbGV4X2VuZ2luZSIsImxleF9tZW0iLCJsZXhfYmFzZV9jb2RlIiwibGV4X2JhY2t0cmtfY29kZSIsImxleF9kZWZhdWx0X2NvZGUiLCJsZXhfdHJhbnNfY29kZSIsImxleF9jaGVja19jb2RlIiwibGV4X2NvZGUiLCJwY19vZmYiLCJwc3RhdGUiLCJiYXNlX2NvZGUiLCJjYW1sX25leHRhZnRlcl9mbG9hdCIsImJpdHMiLCJvbmUiLCJjYW1sX25vdGVxdWFsIiwiY2FtbF9vYmpfYWRkX29mZnNldCIsImNhbWxfb2JqX2Jsb2NrIiwiY2FtbF9vYmpfY29tcGFyZV9hbmRfc3dhcCIsImNhbWxfb2JqX2lzX2Jsb2NrIiwiY2FtbF9vYmpfaXNfc2hhcmVkIiwiY2FtbF9vYmpfbWFrZV9mb3J3YXJkIiwiY2FtbF9vYmpfcmF3X2ZpZWxkIiwiY2FtbF9vYmpfcmVhY2hhYmxlX3dvcmRzIiwiY2FtbF9vYmpfc2V0X3Jhd19maWVsZCIsImNhbWxfb2JqX3NldF90YWciLCJjYW1sX29ial90cnVuY2F0ZSIsImNhbWxfb2JqX3dpdGhfdGFnIiwiY2FtbF9vanNfbmV3X2FyciIsImNhbWxfb3V0cHV0X3ZhbCIsIldyaXRlciIsInZhbHVlIiwibm9fc2hhcmluZyIsImNsb3N1cmVzIiwibWVtbyIsImV4aXN0aW5nX29mZnNldCIsImV4dGVybl9yZWMiLCJzel8zMl82NCIsImhlYWRlcl9wb3MiLCJ0eXBlX29mX3YiLCJjYW1sX291dHB1dF92YWx1ZV90b19zdHJpbmciLCJjYW1sX291dHB1dF92YWx1ZSIsImNhbWxfb3V0cHV0X3ZhbHVlX3RvX2J1ZmZlciIsImNhbWxfb3V0cHV0X3ZhbHVlX3RvX2J5dGVzIiwiY2FtbF9wYXJzZXJfdHJhY2UiLCJjYW1sX3BhcnNlX2VuZ2luZSIsInRhYmxlcyIsImVudiIsImNtZCIsIkVSUkNPREUiLCJsb29wIiwidGVzdHNoaWZ0Iiwic2hpZnQiLCJzaGlmdF9yZWNvdmVyIiwicmVkdWNlIiwiUkVBRF9UT0tFTiIsIlJBSVNFX1BBUlNFX0VSUk9SIiwiR1JPV19TVEFDS1NfMSIsIkdST1dfU1RBQ0tTXzIiLCJDT01QVVRFX1NFTUFOVElDX0FDVElPTiIsIkNBTExfRVJST1JfRlVOQ1RJT04iLCJlbnZfc19zdGFjayIsImVudl92X3N0YWNrIiwiZW52X3N5bWJfc3RhcnRfc3RhY2siLCJlbnZfc3ltYl9lbmRfc3RhY2siLCJlbnZfc3RhY2tzaXplIiwiZW52X3N0YWNrYmFzZSIsImVudl9jdXJyX2NoYXIiLCJlbnZfbHZhbCIsImVudl9zeW1iX3N0YXJ0IiwiZW52X3N5bWJfZW5kIiwiZW52X2FzcCIsImVudl9ydWxlX2xlbiIsImVudl9ydWxlX251bWJlciIsImVudl9zcCIsImVudl9zdGF0ZSIsImVudl9lcnJmbGFnIiwidGJsX3RyYW5zbF9jb25zdCIsInRibF90cmFuc2xfYmxvY2siLCJ0YmxfbGhzIiwidGJsX2xlbiIsInRibF9kZWZyZWQiLCJ0YmxfZGdvdG8iLCJ0Ymxfc2luZGV4IiwidGJsX3JpbmRleCIsInRibF9naW5kZXgiLCJ0YmxfdGFibGVzaXplIiwidGJsX3RhYmxlIiwidGJsX2NoZWNrIiwidGJsX25hbWVzX2NvbnN0IiwidGJsX25hbWVzX2Jsb2NrIiwibG9nIiwidG9rZW5fbmFtZSIsIm5hbWVzIiwicHJpbnRfdG9rZW4iLCJ0b2siLCJ0b2tlbiIsIm4xIiwibjIiLCJzdGF0ZTEiLCJzcCIsImVycmZsYWciLCJhc3AiLCJjYW1sX3B1cmVfanNfZXhwciIsImNhbWxfcmFpc2Vfbm90X2FfZGlyIiwiY2FtbF9yYWlzZV9ub3RfZm91bmQiLCJjYW1sX3Jhd19iYWNrdHJhY2VfbGVuZ3RoIiwiY2FtbF9yYXdfYmFja3RyYWNlX25leHRfc2xvdCIsImNhbWxfcmF3X2JhY2t0cmFjZV9zbG90IiwiY2FtbF9yZWNvbW1lbmRlZF9kb21haW5fY291bnQiLCJjYW1sX3JlY29yZF9iYWNrdHJhY2UiLCJjYW1sX3JlZ2lzdGVyX2NoYW5uZWxfZm9yX3NwYWNldGltZSIsIl9jaGFubmVsIiwiY2FtbF9yZWdpc3Rlcl9nbG9iYWwiLCJuYW1lX29wdCIsIm5pZCIsImNhbWxfcmVnaXN0ZXJfbmFtZWRfdmFsdWUiLCJjYW1sX3Jlc3RvcmVfcmF3X2JhY2t0cmFjZSIsImNhbWxfcm91bmRfZmxvYXQiLCJjYW1sX3J1bnRpbWVfZXZlbnRzX2NyZWF0ZV9jdXJzb3IiLCJjYW1sX3J1bnRpbWVfZXZlbnRzX2ZyZWVfY3Vyc29yIiwiY3Vyc29yIiwiY2FtbF9ydW50aW1lX2V2ZW50c19yZWFkX3BvbGwiLCJjYWxsYmFja3MiLCJjYW1sX3J1bnRpbWVfZXZlbnRzX3VzZXJfcmVnaXN0ZXIiLCJldmVudF9uYW1lIiwiZXZlbnRfdGFnIiwiZXZlbnRfdHlwZSIsImNhbWxfcnVudGltZV9ldmVudHNfdXNlcl9yZXNvbHZlIiwiY2FtbF9ydW50aW1lX2V2ZW50c191c2VyX3dyaXRlIiwiZXZlbnQiLCJldmVudF9jb250ZW50IiwiY2FtbF9ydW50aW1lX3BhcmFtZXRlcnMiLCJjYW1sX3J1bnRpbWVfdmFyaWFudCIsImNhbWxfc2V0X29vX2lkIiwiY2FtbF9zZXRfcGFyc2VyX3RyYWNlIiwib2xkZmxhZyIsImNhbWxfc2V0X3N0YXRpY19lbnYiLCJjYW1sX3NpZ25iaXRfZmxvYXQiLCJjYW1sX3NpbmhfZmxvYXQiLCJjYW1sX3NwYWNldGltZV9lbmFibGVkIiwiY2FtbF9zcGFjZXRpbWVfb25seV93b3Jrc19mb3JfbmF0aXZlX2NvZGUiLCJjYW1sX3N0cl9pbml0aWFsaXplIiwiY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IiLCJjYW1sX3N0cmluZ19jb25jYXQiLCJjYW1sX3N0cmluZ19lcXVhbCIsImNhbWxfc3RyaW5nX2dldCIsImNhbWxfc3RyaW5nX2dldDE2IiwiY2FtbF9zdHJpbmdfZ2V0MzIiLCJjYW1sX3N0cmluZ19nZXQ2NCIsImNhbWxfc3RyaW5nX2xlc3NlcXVhbCIsImNhbWxfc3RyaW5nX2dyZWF0ZXJlcXVhbCIsImNhbWxfc3RyaW5nX2xlc3N0aGFuIiwiY2FtbF9zdHJpbmdfZ3JlYXRlcnRoYW4iLCJjYW1sX3N0cmluZ19oYXNoIiwiY2FtbF9zdHJpbmdfbm90ZXF1YWwiLCJjYW1sX3N0cmluZ19zZXQiLCJjYW1sX3N0cmluZ19zZXQxNiIsImNhbWxfc3RyaW5nX3NldDMyIiwiY2FtbF9zdHJpbmdfc2V0NjQiLCJjYW1sX3N0cmluZ191bnNhZmVfc2V0IiwiY2FtbF9zeXNfYXJndiIsImNhbWxfc3lzX2NoZGlyIiwiZGlyIiwiY2FtbF9zeXNfY29uc3RfYmFja2VuZF90eXBlIiwiY2FtbF9zeXNfY29uc3RfYmlnX2VuZGlhbiIsImNhbWxfc3lzX2NvbnN0X2ludF9zaXplIiwiY2FtbF9zeXNfY29uc3RfbWF4X3dvc2l6ZSIsImNhbWxfc3lzX2NvbnN0X25ha2VkX3BvaW50ZXJzX2NoZWNrZWQiLCJvc190eXBlIiwiY2FtbF9zeXNfY29uc3Rfb3N0eXBlX2N5Z3dpbiIsImNhbWxfc3lzX2NvbnN0X29zdHlwZV91bml4IiwiY2FtbF9zeXNfY29uc3Rfb3N0eXBlX3dpbjMyIiwiY2FtbF9zeXNfY29uc3Rfd29yZF9zaXplIiwiY2FtbF9zeXNfZXhlY3V0YWJsZV9uYW1lIiwiY2FtbF9zeXNfZXhpdCIsImNhbWxfc3lzX2ZpbGVfZXhpc3RzIiwiY2FtbF9zeXNfZ2V0X2FyZ3YiLCJjYW1sX3N5c19nZXRfY29uZmlnIiwiY2FtbF9zeXNfZ2V0Y3dkIiwiY2FtbF9zeXNfZ2V0ZW52IiwiY2FtbF9zeXNfaXNfZGlyZWN0b3J5IiwiY2FtbF9zeXNfaXNfcmVndWxhcl9maWxlIiwiY2FtbF9zeXNfaXNhdHR5IiwiX2NoYW4iLCJjYW1sX3N5c19ta2RpciIsInBlcm0iLCJjYW1sX3N5c19tb2RpZnlfYXJndiIsImNhbWxfc3lzX3JhbmRvbV9zZWVkIiwibm93IiwiRGF0ZSIsImNhbWxfc3lzX3JlYWRfZGlyZWN0b3J5IiwiY2FtbF9zeXNfcmVtb3ZlIiwiY2FtbF9zeXNfcmVuYW1lIiwib19yb290Iiwibl9yb290IiwiY2FtbF9zeXNfcm1kaXIiLCJjYW1sX3N5c19zeXN0ZW1fY29tbWFuZCIsImNoaWxkX3Byb2Nlc3MiLCJjYW1sX2luaXRpYWxfdGltZSIsImNhbWxfc3lzX3RpbWUiLCJjYW1sX3N5c190aW1lX2luY2x1ZGVfY2hpbGRyZW4iLCJjYW1sX3N5c191bnNhZmVfZ2V0ZW52IiwiY2FtbF90YW5oX2Zsb2F0IiwiY2FtbF90b19qc19zdHJpbmciLCJjYW1sX3RyYW1wb2xpbmUiLCJjYW1sX3RyYW1wb2xpbmVfcmV0dXJuIiwiY2FtbF90cnVuY19mbG9hdCIsImNhbWxfdW5peF9jbGVhbnVwIiwiY2FtbF91bml4X2Nsb3NlZGlyIiwiZGlyX2hhbmRsZSIsImNhbWxfdW5peF9maWxlZGVzY3Jfb2ZfZmQiLCJjYW1sX3VuaXhfZmluZGNsb3NlIiwiY2FtbF91bml4X29wZW5kaXIiLCJjYW1sX3VuaXhfcmVhZGRpciIsImNhbWxfdW5peF9maW5kZmlyc3QiLCJwYXRoX2pzIiwiZmlyc3RfZW50cnkiLCJjYW1sX3VuaXhfZmluZG5leHQiLCJjYW1sX3VuaXhfZ2V0cHd1aWQiLCJjYW1sX3VuaXhfZ2V0dGltZW9mZGF5IiwiY2FtbF91bml4X2dldHVpZCIsImNhbWxfdW5peF9nbXRpbWUiLCJkX251bSIsImphbnVhcnlmaXJzdCIsImRveSIsImNhbWxfdW5peF9oYXNfc3ltbGluayIsImNhbWxfdW5peF9pbmV0X2FkZHJfb2Zfc3RyaW5nIiwiY2FtbF91bml4X2lzYXR0eSIsImZpbGVEZXNjcmlwdG9yIiwidHR5IiwiY2FtbF91bml4X2xvY2FsdGltZSIsImphbiIsImp1bCIsInN0ZFRpbWV6b25lT2Zmc2V0IiwiY2FtbF91bml4X2xzdGF0IiwiY2FtbF91bml4X2xzdGF0XzY0IiwiY2FtbF91bml4X21rZGlyIiwiY2FtbF91bml4X21rdGltZSIsInRtIiwidG0yIiwiY2FtbF91bml4X3JlYWRsaW5rIiwiY2FtbF91bml4X3Jld2luZGRpciIsIm5ld19kaXJfaGFuZGxlIiwiY2FtbF91bml4X3JtZGlyIiwiY2FtbF91bml4X3N0YXJ0dXAiLCJjYW1sX3VuaXhfc3RhdCIsImNhbWxfdW5peF9zdGF0XzY0IiwiY2FtbF91bml4X3N5bWxpbmsiLCJzcmNfcm9vdCIsImRzdF9yb290IiwiY2FtbF91bml4X3RpbWUiLCJjYW1sX3VuaXhfdW5saW5rIiwiY2FtbF91bm1vdW50IiwiY2FtbF91cGRhdGVfZHVtbXkiLCJjYW1sX3dlYWtfc2V0IiwiY2FtbF93cmFwX2V4Y2VwdGlvbiIsImNhbWxfeG1saHR0cHJlcXVlc3RfY3JlYXRlIiwiY29tcGFyZV9kaWdpdHNfbmF0IiwiY29tcGFyZV9uYXQiLCJjb21wYXJlX25hdF9yZWFsIiwiY29tcGxlbWVudF9uYXQiLCJjcmVhdGVfbmF0IiwiZGVjcl9uYXQiLCJib3Jyb3ciLCJkZXNlcmlhbGl6ZV9uYXQiLCJkaXZfaGVscGVyIiwiZGl2X2RpZ2l0X25hdCIsIm5hdHEiLCJvZnNxIiwibmF0ciIsIm9mc3IiLCJyZW0iLCJudW1fbGVhZGluZ196ZXJvX2JpdHNfaW5fZGlnaXQiLCJzaGlmdF9sZWZ0X25hdCIsIm5iaXRzIiwid3JhcCIsInNoaWZ0X3JpZ2h0X25hdCIsInNldF90b196ZXJvX25hdCIsIm5hdF9vZl9hcnJheSIsIm11bHRfZGlnaXRfbmF0IiwibmF0MyIsIm9mczMiLCJ4MiIsIngzIiwic3ViX25hdCIsImRpdl9uYXQiLCJxdW8iLCJzZXJpYWxpemVfbmF0IiwiaW5pdGlhbGl6ZV9uYXQiLCJpc19kaWdpdF9pbnQiLCJpc19kaWdpdF9vZGQiLCJpc19kaWdpdF96ZXJvIiwianNvb19jcmVhdGVfZmlsZV9leHRlcm4iLCJqc29vX2VmZmVjdF9ub3Rfc3VwcG9ydGVkIiwibGFuZF9kaWdpdF9uYXQiLCJsZW5ndGhfbmF0IiwibG9yX2RpZ2l0X25hdCIsImx4b3JfZGlnaXRfbmF0IiwibWxfY2FudmFzX2FyYyIsInJhZGl1cyIsInRoZXRhMSIsInRoZXRhMiIsImNjdyIsIm1sX2NhbnZhc19hcmNfdG8iLCJwMSIsInAyIiwibWxfY2FudmFzX2Jlemllcl9jdXJ2ZV90byIsInAzIiwibWxfY2FudmFzX2JsaXQiLCJkc3RfY2FudmFzIiwiZHBvcyIsInNyY19jYW52YXMiLCJzcG9zIiwibWxfY2FudmFzX2NsZWFyX3BhdGgiLCJtbF9jYW52YXNfY2xpcCIsIm5vbnplcm8iLCJtbF9jYW52YXNfY2xpcF9wYXRoIiwibWxfY2FudmFzX2Nsb3NlX3BhdGgiLCJtbF9jYW52YXNfY29tbWl0IiwibWxfY2FudmFzX2NvbXBhcmUiLCJjYW52YXMxIiwiY2FudmFzMiIsIm1sX2NhbnZhc19jcmVhdGVfb2Zmc2NyZWVuIiwibWxfY2FudmFzX2NyZWF0ZV9vZmZzY3JlZW5fZnJvbV9pbWFnZV9kYXRhIiwibWxfY2FudmFzX2NyZWF0ZV9vZmZzY3JlZW5fZnJvbV9wbmciLCJvbmxvYWQiLCJfX2ltZyIsIm1sX2NhbnZhc19jcmVhdGVfb25zY3JlZW4iLCJhdXRvY29tbWl0IiwiZGVjb3JhdGVkIiwicmVzaXplYWJsZSIsImhlYWRlcl9oZWlnaHQiLCJmcmFtZSIsIm1sX2NhbnZhc19lbGxpcHNlIiwicm90YXRpb24iLCJtbF9jYW52YXNfZXhwb3J0X3BuZyIsIm1sX2NhbnZhc19maWxsIiwibWxfY2FudmFzX2ZpbGxfcGF0aCIsIm1sX2NhbnZhc19maWxsX3JlY3QiLCJtbF9jYW52YXNfZmlsbF90ZXh0IiwidGV4dCIsIm1sX2NhbnZhc19nZXRfY2FudmFzIiwibWxfY2FudmFzX2dldF9jdXJyZW50X3RpbWVzdGFtcCIsIm1sX2NhbnZhc19nZXRfZmlsbF9jb2xvciIsIm1sX2NhbnZhc19nZXRfZmlsbF9zdHlsZSIsIm1sX2NhbnZhc19nZXRfZ2xvYmFsX2FscGhhIiwibWxfY2FudmFzX2dldF9nbG9iYWxfY29tcG9zaXRlX29wZXJhdGlvbiIsIm1sX2NhbnZhc19nZXRfaWQiLCJtbF9jYW52YXNfZ2V0X2ltYWdlX2RhdGEiLCJtbF9jYW52YXNfZ2V0X2xpbmVfY2FwIiwibWxfY2FudmFzX2dldF9saW5lX2Rhc2giLCJtbF9jYW52YXNfZ2V0X2xpbmVfZGFzaF9vZmZzZXQiLCJtbF9jYW52YXNfZ2V0X2xpbmVfam9pbiIsIm1sX2NhbnZhc19nZXRfbGluZV93aWR0aCIsIm1sX2NhbnZhc19nZXRfbWl0ZXJfbGltaXQiLCJtbF9jYW52YXNfZ2V0X3BpeGVsIiwibWxfY2FudmFzX2dldF9wb3NpdGlvbiIsIm1sX2NhbnZhc19nZXRfc2hhZG93X2JsdXIiLCJtbF9jYW52YXNfZ2V0X3NoYWRvd19jb2xvciIsIm1sX2NhbnZhc19nZXRfc2hhZG93X29mZnNldCIsIm1sX2NhbnZhc19nZXRfc2l6ZSIsIm1sX2NhbnZhc19nZXRfc3Ryb2tlX2NvbG9yIiwibWxfY2FudmFzX2dldF9zdHJva2Vfc3R5bGUiLCJtbF9jYW52YXNfZ3JhZGllbnRfYWRkX2NvbG9yX3N0b3AiLCJncmFkaWVudCIsIm1sX2NhbnZhc19ncmFkaWVudF9jcmVhdGVfY29uaWMiLCJjZW50ZXIiLCJhbmdsZSIsIm1sX2NhbnZhc19ncmFkaWVudF9jcmVhdGVfbGluZWFyIiwibWxfY2FudmFzX2dyYWRpZW50X2NyZWF0ZV9yYWRpYWwiLCJjZW50ZXIxIiwicmFkMSIsImNlbnRlcjIiLCJyYWQyIiwibWxfY2FudmFzX2hhc2giLCJoYXNoIiwibWxfY2FudmFzX2ltYWdlX2RhdGFfYmxpdCIsImRzdF9kYXRhIiwic3JjX2RhdGEiLCJibGl0X2luZm8iLCJtbF9jYW52YXNfaW1hZ2VfZGF0YV9jcmVhdGVfZnJvbV9wbmciLCJtbF9jYW52YXNfaW1hZ2VfZGF0YV9leHBvcnRfcG5nIiwibWxfY2FudmFzX2ltYWdlX2RhdGFfZmlsbCIsIm1sX2NhbnZhc19pbWFnZV9kYXRhX2dldF9waXhlbCIsIm1sX2NhbnZhc19pbWFnZV9kYXRhX2dldF9zaXplIiwibWxfY2FudmFzX2ltYWdlX2RhdGFfaW1wb3J0X3BuZyIsIm1sX2NhbnZhc19pbWFnZV9kYXRhX3B1dF9waXhlbCIsIm1sX2NhbnZhc19pbWFnZV9kYXRhX3N1YiIsIm1sX2NhbnZhc19pbXBvcnRfcG5nIiwibWxfY2FudmFzX2luaXQiLCJtbF9jYW52YXNfaW50X29mX2tleSIsIm1sX2NhbnZhc19rZXlfb2ZfaW50IiwibWxfY2FudmFzX2xpbmVfdG8iLCJtbF9jYW52YXNfbW92ZV90byIsIm1sX2NhbnZhc19wYXRoX2FkZCIsInBhdGgxIiwicGF0aDIiLCJtbF9jYW52YXNfcGF0aF9hZGRfdHJhbnNmb3JtZWQiLCJtbF9jYW52YXNfcGF0aF9hcmMiLCJtbF9jYW52YXNfcGF0aF9hcmNfdG8iLCJtbF9jYW52YXNfcGF0aF9iZXppZXJfY3VydmVfdG8iLCJjcDEiLCJjcDIiLCJtbF9jYW52YXNfcGF0aF9jbG9zZSIsIm1sX2NhbnZhc19wYXRoX2NyZWF0ZSIsIm1sX2NhbnZhc19wYXRoX2VsbGlwc2UiLCJtbF9jYW52YXNfcGF0aF9saW5lX3RvIiwibWxfY2FudmFzX3BhdGhfbW92ZV90byIsIm1sX2NhbnZhc19wYXRoX3F1YWRyYXRpY19jdXJ2ZV90byIsImNwIiwibWxfY2FudmFzX3BhdGhfcmVjdCIsIm1sX2NhbnZhc19wYXR0ZXJuX2NyZWF0ZSIsImltZ19jYW52IiwibWxfY2FudmFzX3B1dF9pbWFnZV9kYXRhIiwibWxfY2FudmFzX3B1dF9waXhlbCIsIm1sX2NhbnZhc19xdWFkcmF0aWNfY3VydmVfdG8iLCJtbF9jYW52YXNfcmVjdCIsIm1sX2NhbnZhc19yZXN0b3JlIiwibWxfY2FudmFzX3JvdGF0ZSIsInRoZXRhIiwibWxfY2FudmFzX3J1biIsIm1sUHJvY2Vzc0V2ZW50IiwibWxDb250aW51YXRpb24iLCJtbF9jYW52YXNfc2F2ZSIsIm1sX2NhbnZhc19zY2FsZSIsInZlYyIsIm1sX2NhbnZhc19zZXRfZmlsbF9jb2xvciIsIm1sX2NhbnZhc19zZXRfZmlsbF9ncmFkaWVudCIsImdyYWQiLCJtbF9jYW52YXNfc2V0X2ZpbGxfcGF0dGVybiIsInBhdHRlcm4iLCJtbF9jYW52YXNfc2V0X2ZpbGxfc3R5bGUiLCJtbF9jYW52YXNfc2V0X2ZvbnQiLCJmYW1pbHkiLCJ3ZWlnaHQiLCJtbF9jYW52YXNfc2V0X2dsb2JhbF9hbHBoYSIsImdsb2JhbF9hbHBoYSIsIm1sX2NhbnZhc19zZXRfZ2xvYmFsX2NvbXBvc2l0ZV9vcGVyYXRpb24iLCJvcCIsIm1sX2NhbnZhc19zZXRfbGluZV9jYXAiLCJtbF9jYW52YXNfc2V0X2xpbmVfZGFzaCIsImRhc2giLCJtbF9jYW52YXNfc2V0X2xpbmVfZGFzaF9vZmZzZXQiLCJtbF9jYW52YXNfc2V0X2xpbmVfam9pbiIsIm1sX2NhbnZhc19zZXRfbGluZV93aWR0aCIsIm1sX2NhbnZhc19zZXRfbWl0ZXJfbGltaXQiLCJtbF9jYW52YXNfc2V0X3Bvc2l0aW9uIiwibWxfY2FudmFzX3NldF9zaGFkb3dfYmx1ciIsImJsdXIiLCJtbF9jYW52YXNfc2V0X3NoYWRvd19jb2xvciIsIm1sX2NhbnZhc19zZXRfc2hhZG93X29mZnNldCIsIm1sX2NhbnZhc19zZXRfc2l6ZSIsIm1sX2NhbnZhc19zZXRfc3Ryb2tlX2NvbG9yIiwibWxfY2FudmFzX3NldF9zdHJva2VfZ3JhZGllbnQiLCJtbF9jYW52YXNfc2V0X3N0cm9rZV9wYXR0ZXJuIiwibWxfY2FudmFzX3NldF9zdHJva2Vfc3R5bGUiLCJtbF9jYW52YXNfc2V0X3RyYW5zZm9ybSIsIm1sX2NhbnZhc19zaGVhciIsIm1sX2NhbnZhc19zaG93IiwibWxfY2FudmFzX3N0cm9rZSIsIm1sX2NhbnZhc19zdHJva2VfcGF0aCIsIm1sX2NhbnZhc19zdHJva2VfcmVjdCIsIm1sX2NhbnZhc19zdHJva2VfdGV4dCIsIm1sX2NhbnZhc190cmFuc2Zvcm0iLCJtbF9jYW52YXNfdHJhbnNsYXRlIiwibXVsdF9uYXQiLCJsZW4zIiwibnRoX2RpZ2l0X25hdCIsIm50aF9kaWdpdF9uYXRfbmF0aXZlIiwicmVfbWF0Y2giLCJyZV93b3JkX2xldHRlcnMiLCJvcGNvZGVzIiwiaXNfd29yZF9sZXR0ZXIiLCJpbl9iaXRzZXQiLCJyZV9tYXRjaF9pbXBsIiwicGFydGlhbCIsInByb2ciLCJjcG9vbCIsIm5vcm10YWJsZSIsIm51bWdyb3VwcyIsIm51bXJlZ2lzdGVycyIsInN0YXJ0Y2hhcnMiLCJwYyIsInF1aXQiLCJncm91cHMiLCJyZV9yZWdpc3RlciIsImJhY2t0cmFjayIsIml0ZW0iLCJwdXNoIiwiYWNjZXB0IiwicHJlZml4X21hdGNoIiwic2FyZyIsInVhcmciLCJncm91cCIsIkVycm9yIiwicmVfcGFydGlhbF9tYXRjaCIsInJlX3JlcGxhY2VtZW50X3RleHQiLCJyZXBsIiwib3JpZyIsImN1ciIsImVuZCIsInJlX3NlYXJjaF9iYWNrd2FyZCIsInJlX3NlYXJjaF9mb3J3YXJkIiwicmVfc3RyaW5nX21hdGNoIiwic2V0X2RpZ2l0X25hdCIsImRpZ2l0Iiwic2V0X2RpZ2l0X25hdF9uYXRpdmUiLCJzcXVhcmVfbmF0IiwiY2FtbF9zZXR1cF91bmNhdWdodF9leGNlcHRpb25faGFuZGxlciIsIm9yaWdpbiIsImVyYXNlX3JlbCIsInJlc3QiLCJyZXN0JDAiLCJyZXN0JDEiLCJyZXN0JDIiLCJyZXN0JDMiLCJyZXN0JDQiLCJyZXN0JDUiLCJyZXN0JDYiLCJyZXN0JDciLCJ0eSIsInJlc3QkOCIsInR5MSIsInJlc3QkOSIsInJlc3QkMTAiLCJyZXN0JDExIiwicmVzdCQxMiIsInJlc3QkMTMiLCJjb25jYXRfZm10dHkiLCJmbXR0eTEiLCJmbXR0eTIiLCJ0eTIiLCJjb25jYXRfZm10IiwiZm10MSIsImZtdDIiLCJwYWQiLCJwYWQkMCIsInByZWMiLCJwYWQkMSIsImljb252IiwicHJlYyQwIiwicGFkJDIiLCJpY29udiQwIiwicHJlYyQxIiwicGFkJDMiLCJpY29udiQxIiwicHJlYyQyIiwicGFkJDQiLCJpY29udiQyIiwicHJlYyQzIiwicGFkJDUiLCJmY29udiIsInBhZCQ2Iiwic3RyIiwiY2hyIiwiZm10dHkiLCJwYWQkNyIsImZtdHR5JDAiLCJwYWQkOCIsInJlc3QkMTQiLCJyZXN0JDE1IiwicmVzdCQxNiIsImZtdGluZ19saXQiLCJyZXN0JDE3IiwiZm10aW5nX2dlbiIsInJlc3QkMTgiLCJyZXN0JDE5IiwiY2hhcl9zZXQiLCJ3aWR0aF9vcHQiLCJyZXN0JDIwIiwiY291bnRlciIsInJlc3QkMjEiLCJyZXN0JDIyIiwiaWduIiwicmVzdCQyMyIsImYiLCJhcml0eSIsIm1ha2UiLCJ2IiwiZ2V0IiwiciIsInNldCIsImV4Y2hhbmdlIiwiY3VyIiwiY29tcGFyZV9hbmRfc2V0Iiwic2VlbiIsImZldGNoX2FuZF9hZGQiLCJuIiwiaW5jciIsImRlY3IiLCJmYWlsd2l0aCIsInMiLCJpbnZhbGlkX2FyZyIsIm1pbiIsIngiLCJ5IiwibWF4IiwiYWJzIiwibG5vdCIsImluZmluaXR5IiwibmVnX2luZmluaXR5IiwibmFuIiwibWF4X2Zsb2F0IiwibWluX2Zsb2F0IiwiZXBzaWxvbl9mbG9hdCIsInN5bWJvbF9jb25jYXQiLCJjaGFyX29mX2ludCIsInN0cmluZ19vZl9ib29sIiwiYiIsImJvb2xfb2Zfc3RyaW5nIiwiYm9vbF9vZl9zdHJpbmdfb3B0Iiwic3RyaW5nX29mX2ludCIsImludF9vZl9zdHJpbmdfb3B0IiwidmFsaWRfZmxvYXRfbGV4ZW0iLCJzMSIsImwiLCJpIiwiaSQwIiwic3RyaW5nX29mX2Zsb2F0IiwiZmxvYXRfb2Zfc3RyaW5nX29wdCIsInN5bWJvbCIsImwxIiwibDIiLCJ0bCIsImhkIiwic3RkaW4iLCJzdGRvdXQiLCJzdGRlcnIiLCJvcGVuX291dF9nZW4iLCJtb2RlIiwicGVybSIsIm5hbWUiLCJjIiwib3Blbl9vdXQiLCJvcGVuX291dF9iaW4iLCJmbHVzaF9hbGwiLCJhIiwib3V0cHV0X2J5dGVzIiwib2MiLCJvdXRwdXRfc3RyaW5nIiwib3V0cHV0Iiwib2ZzIiwibGVuIiwib3V0cHV0X3N1YnN0cmluZyIsIm91dHB1dF92YWx1ZSIsImNoYW4iLCJjbG9zZV9vdXQiLCJjbG9zZV9vdXRfbm9lcnIiLCJvcGVuX2luX2dlbiIsIm9wZW5faW4iLCJvcGVuX2luX2JpbiIsImlucHV0IiwiaWMiLCJ1bnNhZmVfcmVhbGx5X2lucHV0Iiwib2ZzJDAiLCJsZW4kMCIsImxlbiQxIiwib2ZzJDEiLCJyZWFsbHlfaW5wdXQiLCJyZWFsbHlfaW5wdXRfc3RyaW5nIiwiaW5wdXRfbGluZSIsImJ1aWxkX3Jlc3VsdCIsImJ1ZiIsInBvcyQwIiwiYWNjdSIsImJlZyIsImFjY3UkMCIsInJlcyIsImNsb3NlX2luX25vZXJyIiwicHJpbnRfY2hhciIsInByaW50X3N0cmluZyIsInByaW50X2J5dGVzIiwicHJpbnRfaW50IiwicHJpbnRfZmxvYXQiLCJwcmludF9lbmRsaW5lIiwicHJpbnRfbmV3bGluZSIsInByZXJyX2NoYXIiLCJwcmVycl9zdHJpbmciLCJwcmVycl9ieXRlcyIsInByZXJyX2ludCIsInByZXJyX2Zsb2F0IiwicHJlcnJfZW5kbGluZSIsInByZXJyX25ld2xpbmUiLCJyZWFkX2xpbmUiLCJyZWFkX2ludCIsInJlYWRfaW50X29wdCIsInJlYWRfZmxvYXQiLCJyZWFkX2Zsb2F0X29wdCIsInN0cmluZ19vZl9mb3JtYXQiLCJzeW1ib2wkMCIsInN0cjIiLCJzdHIxIiwiczIiLCJleGl0X2Z1bmN0aW9uIiwiYXRfZXhpdCIsImZfeWV0X3RvX3J1biIsIm9sZF9leGl0IiwiZl95ZXRfdG9fcnVuJDAiLCJvbGRfZXhpdCQwIiwibmV3X2V4aXQiLCJzdWNjZXNzIiwiZG9fYXRfZXhpdCIsImV4aXQiLCJyZXRjb2RlIiwibWF4X2ludCIsIm1pbl9pbnQiLCJmbHVzaCIsIm91dHB1dF9jaGFyIiwib3V0cHV0X2J5dGUiLCJvdXRwdXRfYmluYXJ5X2ludCIsInNlZWtfb3V0IiwicG9zX291dCIsIm91dF9jaGFubmVsX2xlbmd0aCIsInNldF9iaW5hcnlfbW9kZV9vdXQiLCJpbnB1dF9jaGFyIiwiaW5wdXRfYnl0ZSIsImlucHV0X2JpbmFyeV9pbnQiLCJpbnB1dF92YWx1ZSIsInNlZWtfaW4iLCJwb3NfaW4iLCJpbl9jaGFubmVsX2xlbmd0aCIsImNsb3NlX2luIiwic2V0X2JpbmFyeV9tb2RlX2luIiwibGVmdCIsInJpZ2h0IiwiaXNfbGVmdCIsImlzX3JpZ2h0IiwiZmluZF9sZWZ0IiwiZmluZF9yaWdodCIsIm1hcF9sZWZ0IiwiZSIsIm1hcF9yaWdodCIsIm1hcCIsInYkMCIsImZvbGQiLCJlcXVhbCIsImUxIiwiZTIiLCJ2MSIsInYyIiwidjEkMCIsInYyJDAiLCJjb21wYXJlIiwiaXNfYmxvY2siLCJkb3VibGVfZmllbGQiLCJzZXRfZG91YmxlX2ZpZWxkIiwiY3VzdG9tX3RhZyIsImluZm8iLCJvYmoiLCJzdGFydF9lbnYiLCJvZl92YWwiLCJzbG90IiwiaWQiLCJleHRlbnNpb25fY29uc3RydWN0b3IiLCJleHRlbnNpb25fbmFtZSIsImV4dGVuc2lvbl9pZCIsIm1heF9lcGhlX2xlbmd0aCIsImNyZWF0ZSIsImxlbmd0aCIsInJhaXNlX2lmX2ludmFsaWRfb2Zmc2V0IiwibyIsIm1zZyIsImdldF9rZXkiLCJnZXRfa2V5X2NvcHkiLCJzZXRfa2V5IiwidW5zZXRfa2V5IiwiY2hlY2tfa2V5IiwiYmxpdF9rZXkiLCJvMSIsIm8yIiwicmFpc2VfdW5kZWZpbmVkIiwiZm9yY2VfbGF6eV9ibG9jayIsImJsayIsImNsb3N1cmUiLCJyZXN1bHQiLCJlJDAiLCJmb3JjZV92YWxfbGF6eV9ibG9jayIsImZvcmNlIiwibHp2IiwidCIsImZvcmNlX3ZhbCIsImZyb21fZnVuIiwiZnJvbV92YWwiLCJpc192YWwiLCJtYXBfdmFsIiwiZW1wdHkiLCJyZXR1cm4kMCIsImNvbnMiLCJuZXh0IiwiYXBwZW5kIiwic2VxMSIsInNlcTIiLCJzZXEiLCJmaWx0ZXJfbWFwIiwic2VxJDAiLCJmaWx0ZXIiLCJjb25jYXQiLCJmbGF0X21hcCIsImZvbGRfbGVmdCIsImFjYyIsImFjYyQwIiwiYWNjJDEiLCJpdGVyIiwidW5mb2xkIiwidSIsInUkMCIsImlzX2VtcHR5IiwieHMiLCJ1bmNvbnMiLCJ4cyQwIiwieHMkMSIsIml0ZXJpIiwiZm9sZF9sZWZ0aSIsImFjY3UkMSIsImZvcl9hbGwiLCJwIiwiZXhpc3RzIiwiZmluZCIsImZpbmRfbWFwIiwiaXRlcjIiLCJ5cyIsInlzJDAiLCJ5cyQxIiwiZm9sZF9sZWZ0MiIsImZvcl9hbGwyIiwiZXhpc3RzMiIsImVxIiwiY21wIiwiaW5pdF9hdXgiLCJqIiwiaW5pdCIsInJlcGVhdCIsImZvcmV2ZXIiLCJjeWNsZV9ub25lbXB0eSIsImN5Y2xlIiwiaXRlcmF0ZTEiLCJpdGVyYXRlIiwibWFwaV9hdXgiLCJtYXBpIiwidGFpbF9zY2FuIiwicyQwIiwic2NhbiIsInRha2VfYXV4IiwidGFrZSIsImRyb3AiLCJuJDAiLCJuJDEiLCJ0YWtlX3doaWxlIiwiZHJvcF93aGlsZSIsIm5vZGUiLCJncm91cCIsInRvX2xhenkiLCJmYWlsdXJlIiwibWVtb2l6ZSIsIm9uY2UiLCJhY3Rpb24iLCJ6aXAiLCJtYXAyIiwiaW50ZXJsZWF2ZSIsInNvcnRlZF9tZXJnZTEiLCJzb3J0ZWRfbWVyZ2UiLCJtYXBfZnN0IiwieHlzIiwieHlzJDAiLCJtYXBfc25kIiwidW56aXAiLCJmaWx0ZXJfbWFwX2ZpbmRfbGVmdF9tYXAiLCJmaWx0ZXJfbWFwX2ZpbmRfcmlnaHRfbWFwIiwieiIsInBhcnRpdGlvbl9tYXAiLCJwYXJ0aXRpb24iLCJwZWVsIiwieHNzIiwidHJhbnNwb3NlIiwidGFpbHMiLCJoZWFkcyIsInJlbWFpbmRlcnMiLCJ4c3MkMCIsInRhaWxzJDAiLCJoZWFkcyQwIiwibWFwX3Byb2R1Y3QiLCJwcm9kdWN0Iiwib2ZfZGlzcGVuc2VyIiwiaXQiLCJ0b19kaXNwZW5zZXIiLCJpbnRzIiwic29tZSIsInZhbHVlIiwiZGVmYXVsdCQwIiwiYmluZCIsImpvaW4iLCJub25lIiwiaXNfbm9uZSIsImlzX3NvbWUiLCJvMCIsInYwIiwidG9fcmVzdWx0IiwidG9fbGlzdCIsInRvX3NlcSIsIm9rIiwiZXJyb3IiLCJnZXRfb2siLCJnZXRfZXJyb3IiLCJtYXBfZXJyb3IiLCJpdGVyX2Vycm9yIiwiaXNfb2siLCJpc19lcnJvciIsInIwIiwicjEiLCJlMCIsInRvX29wdGlvbiIsInRvX2Zsb2F0IiwidG9fc3RyaW5nIiwiZXNjYXBlZCIsImxvd2VyY2FzZSIsInVwcGVyY2FzZSIsImxvd2VyY2FzZV9hc2NpaSIsInVwcGVyY2FzZV9hc2NpaSIsImMxIiwiYzIiLCJlcnJfbm9fcHJlZCIsImVycl9ub19zdWNjIiwibG9fYm91bmQiLCJoaV9ib3VuZCIsInN1Y2MiLCJwcmVkIiwiaXNfdmFsaWQiLCJvZl9pbnQiLCJpc19jaGFyIiwib2ZfY2hhciIsInRvX2NoYXIiLCJ1bnNhZmVfdG9fY2hhciIsImhhc2giLCJ1dGZfZGVjb2RlX2lzX3ZhbGlkIiwiZCIsInV0Zl9kZWNvZGVfbGVuZ3RoIiwidXRmX2RlY29kZV91Y2hhciIsInV0Zl9kZWNvZGUiLCJ1dGZfZGVjb2RlX2ludmFsaWQiLCJ1dGZfOF9ieXRlX2xlbmd0aCIsInV0Zl8xNl9ieXRlX2xlbmd0aCIsImwkMCIsIm50aCIsImwkMSIsIm50aF9vcHQiLCJyZXZfYXBwZW5kIiwibDEkMCIsImwyJDAiLCJsMSQxIiwibDIkMSIsInJldiIsInJldl9pbml0X3RocmVzaG9sZCIsImZsYXR0ZW4iLCJyZXZfbWFwIiwiZm9sZF9yaWdodCIsImEyIiwiYTEiLCJyZXZfbWFwMiIsImZvbGRfcmlnaHQyIiwibWVtIiwibWVtcSIsImFzc29jIiwiYXNzb2Nfb3B0IiwiYXNzcSIsImFzc3Ffb3B0IiwibWVtX2Fzc29jIiwibWVtX2Fzc3EiLCJyZW1vdmVfYXNzb2MiLCJwYWlyIiwicmVtb3ZlX2Fzc3EiLCJmaW5kX29wdCIsImZpbmRfYWxsIiwiZmlsdGVyaSIsImNvbmNhdF9tYXAiLCJmb2xkX2xlZnRfbWFwIiwibF9hY2N1IiwieCQwIiwieWVzIiwibm8iLCJzcGxpdCIsInJ5IiwicngiLCJjb21iaW5lIiwibWVyZ2UiLCJ0MiIsImgyIiwidDEiLCJoMSIsInN0YWJsZV9zb3J0Iiwic29ydCIsIngyIiwieDEiLCJ0bCQxIiwieDMiLCJ4MiQwIiwieDEkMCIsIm4xIiwibjIiLCJyZXZfc29ydCIsInRsJDAiLCJzb3J0X3VuaXEiLCJjJDAiLCJjJDEiLCJjJDIiLCJjJDMiLCJjJDQiLCJjJDUiLCJjJDYiLCJhY2N1JDIiLCJjb21wYXJlX2xlbmd0aHMiLCJjb21wYXJlX2xlbmd0aF93aXRoIiwiYXV4IiwidGFpbCIsIm9mX3NlcSIsImRpcmVjdCIsImRlcHRoIiwibG9nbm90IiwiY29weSIsIm9mX3N0cmluZyIsInN1YiIsInN1Yl9zdHJpbmciLCJleHRlbmQiLCJkc3RvZmYiLCJzcmNvZmYiLCJjcHlsZW4iLCJmaWxsIiwiYmxpdCIsIm9mczEiLCJvZnMyIiwiYmxpdF9zdHJpbmciLCJzZXAiLCJzZXBsZW4iLCJkc3QiLCJwb3MiLCJoZCQwIiwiY2F0IiwiaXNfc3BhY2UiLCJ0cmltIiwiYXBwbHkxIiwiY2FwaXRhbGl6ZV9hc2NpaSIsInVuY2FwaXRhbGl6ZV9hc2NpaSIsInN0YXJ0c193aXRoIiwicHJlZml4IiwibGVuX3MiLCJsZW5fcHJlIiwiZW5kc193aXRoIiwic3VmZml4IiwibGVuX3N1ZiIsImRpZmYiLCJpbmRleF9yZWMiLCJsaW0iLCJpJDEiLCJpbmRleCIsImluZGV4X3JlY19vcHQiLCJpbmRleF9vcHQiLCJpbmRleF9mcm9tIiwiaW5kZXhfZnJvbV9vcHQiLCJyaW5kZXhfcmVjIiwicmluZGV4IiwicmluZGV4X2Zyb20iLCJyaW5kZXhfcmVjX29wdCIsInJpbmRleF9vcHQiLCJyaW5kZXhfZnJvbV9vcHQiLCJjb250YWluc19mcm9tIiwiY29udGFpbnMiLCJyY29udGFpbnNfZnJvbSIsInNwbGl0X29uX2NoYXIiLCJjYXBpdGFsaXplIiwidW5jYXBpdGFsaXplIiwidG9fc2VxaSIsIm5ld19sZW4iLCJuZXdfYnVmIiwidW5zYWZlX2dldF91aW50MTZfbGUiLCJ1bnNhZmVfZ2V0X3VpbnQxNl9iZSIsImdldF9pbnQ4IiwiZ2V0X3VpbnQxNl9sZSIsImdldF91aW50MTZfYmUiLCJnZXRfaW50MTZfbmUiLCJnZXRfaW50MTZfbGUiLCJnZXRfaW50MTZfYmUiLCJnZXRfaW50MzJfbGUiLCJnZXRfaW50MzJfYmUiLCJnZXRfaW50NjRfbGUiLCJnZXRfaW50NjRfYmUiLCJ1bnNhZmVfc2V0X3VpbnQxNl9sZSIsInVuc2FmZV9zZXRfdWludDE2X2JlIiwic2V0X2ludDE2X2xlIiwic2V0X2ludDE2X2JlIiwic2V0X2ludDMyX2xlIiwic2V0X2ludDMyX2JlIiwic2V0X2ludDY0X2xlIiwic2V0X2ludDY0X2JlIiwic2V0X3VpbnQ4Iiwic2V0X3VpbnQxNl9uZSIsImRlY19pbnZhbGlkIiwiZGVjX3JldCIsIm5vdF9pbl94ODBfdG9feEJGIiwibm90X2luX3hBMF90b194QkYiLCJub3RfaW5feDgwX3RvX3g5RiIsIm5vdF9pbl94OTBfdG9feEJGIiwibm90X2luX3g4MF90b194OEYiLCJ1dGZfOF91Y2hhcl8zIiwiYjAiLCJiMSIsImIyIiwidXRmXzhfdWNoYXJfNCIsImIzIiwiZ2V0X3V0Zl84X3VjaGFyIiwiYjEkNCIsImIyJDMiLCJpJDQiLCJiMSQyIiwiaSQ1IiwiYjIkMSIsImkkNiIsImIzJDEiLCJpJDEwIiwiYjEkMCIsImkkMTEiLCJpJDEyIiwiaSQ3IiwiYjEkMSIsImkkOCIsImIyJDAiLCJpJDkiLCJiMyQwIiwiaSQxMyIsImIxJDUiLCJpJDE0IiwiYjIkNCIsImkkMiIsImIxJDMiLCJpJDMiLCJiMiQyIiwiaSQxNSIsInNldF91dGZfOF91Y2hhciIsImxhc3QkMSIsImxhc3QkMCIsImxhc3QiLCJpc192YWxpZF91dGZfOCIsImxhc3QkMyIsImxhc3QkMiIsImxhc3QkNCIsImxhc3QkNSIsImdldF91dGZfMTZiZV91Y2hhciIsImhpIiwibG8iLCJzZXRfdXRmXzE2YmVfdWNoYXIiLCJ1JDEiLCJpc192YWxpZF91dGZfMTZiZSIsImdldF91dGZfMTZsZV91Y2hhciIsInNldF91dGZfMTZsZV91Y2hhciIsImlzX3ZhbGlkX3V0Zl8xNmxlIiwiYnRzIiwiYm9zIiwib2ZfYnl0ZXMiLCJ0b19ieXRlcyIsImciLCJ0b19idWZmZXIiLCJidWZmIiwiZmxhZ3MiLCJkYXRhX3NpemUiLCJ0b3RhbF9zaXplIiwiZnJvbV9ieXRlcyIsImZyb21fc3RyaW5nIiwibWFrZV9mbG9hdCIsIm1ha2VfbWF0cml4Iiwic3giLCJzeSIsImxhIiwibGIiLCJyZXMkMCIsImxpc3RfbGVuZ3RoIiwib2ZfbGlzdCIsImlucHV0X2FycmF5IiwiZWx0Iiwib3V0cHV0X2FycmF5IiwiZWx0JDAiLCJhY2MkMiIsImEwIiwiYmkiLCJhaSIsIm5hIiwibmIiLCJtYXhzb24iLCJpMzEiLCJlJDEiLCJqJDAiLCJmYXRoZXIiLCJzcmMxb2ZzIiwic3JjMWxlbiIsInNyYzIiLCJzcmMyb2ZzIiwic3JjMmxlbiIsImRzdG9mcyIsInNyYzFyIiwic3JjMnIiLCJzMiQxIiwiczEkMSIsImkxIiwiaTIiLCJpMiQwIiwiZCQwIiwiczIkMCIsImkxJDAiLCJkJDEiLCJzMSQwIiwiaXNvcnR0byIsInNyY29mcyIsInNvcnR0byIsImlzX2Zpbml0ZSIsImlzX2luZmluaXRlIiwiaXNfbmFuIiwiZXBzaWxvbiIsIm9mX3N0cmluZ19vcHQiLCJpc19pbnRlZ2VyIiwibWluX21heCIsIm1pbl9udW0iLCJtYXhfbnVtIiwibWluX21heF9udW0iLCJ1bnNhZmVfZmlsbCIsImNoZWNrIiwiaGxlbiIsInNyYyIsInNvZnMiLCJkb2ZzIiwiaCIsIm1lbV9pZWVlIiwibWFwX3RvX2FycmF5IiwibWFwX2Zyb21fYXJyYXkiLCJ6ZXJvIiwib25lIiwibWludXNfb25lIiwibWF4X2ludCQwIiwidW5zaWduZWRfdG9faW50IiwidW5zaWduZWRfY29tcGFyZSIsIm0iLCJ1bnNpZ25lZF9kaXYiLCJxIiwidW5zaWduZWRfcmVtIiwic2l6ZSIsImR1bW15X3BvcyIsInplcm9fcG9zIiwiZW5naW5lIiwidGJsIiwic3RhdGUiLCJuZXdfZW5naW5lIiwiZnJvbV9mdW5jdGlvbiIsIm9wdCIsInJlYWRfZnVuIiwic3RoIiwid2l0aF9wb3NpdGlvbnMiLCJhdXhfYnVmZmVyIiwibGV4YnVmIiwicmVhZCIsIm5ld2xlbiIsIm5ld2J1ZiIsImZyb21fY2hhbm5lbCIsInNldF9wb3NpdGlvbiIsInBvc2l0aW9uIiwic2V0X2ZpbGVuYW1lIiwiZm5hbWUiLCJsZXhlbWUiLCJzdWJfbGV4ZW1lIiwic3ViX2xleGVtZV9vcHQiLCJzdWJfbGV4ZW1lX2NoYXIiLCJzdWJfbGV4ZW1lX2NoYXJfb3B0IiwibGV4ZW1lX2NoYXIiLCJsZXhlbWVfc3RhcnQiLCJsZXhlbWVfZW5kIiwibGV4ZW1lX3N0YXJ0X3AiLCJsZXhlbWVfZW5kX3AiLCJuZXdfbGluZSIsImxjcCIsImZsdXNoX2lucHV0IiwiZW52IiwiZ3Jvd19zdGFja3MiLCJvbGRzaXplIiwibmV3c2l6ZSIsIm5ld19zIiwibmV3X3YiLCJuZXdfc3RhcnQiLCJuZXdfZW5kIiwiY2xlYXJfcGFyc2VyIiwiY3VycmVudF9sb29rYWhlYWRfZnVuIiwieXlwYXJzZSIsInRhYmxlcyIsInN0YXJ0IiwibGV4ZXIiLCJpbml0X2FzcCIsImluaXRfc3AiLCJpbml0X3N0YWNrYmFzZSIsImluaXRfc3RhdGUiLCJpbml0X2N1cnJfY2hhciIsImluaXRfbHZhbCIsImluaXRfZXJyZmxhZyIsImNtZCIsImFyZyIsImFyZyQwIiwiZXhuJDAiLCJleG4iLCJjdXJyX2NoYXIiLCJ0b2siLCJwZWVrX3ZhbCIsInN5bWJvbF9zdGFydF9wb3MiLCJzdCIsImVuIiwic3ltYm9sX2VuZF9wb3MiLCJyaHNfc3RhcnRfcG9zIiwicmhzX2VuZF9wb3MiLCJzeW1ib2xfc3RhcnQiLCJzeW1ib2xfZW5kIiwicmhzX3N0YXJ0IiwicmhzX2VuZCIsImlzX2N1cnJlbnRfbG9va2FoZWFkIiwicGFyc2VfZXJyb3IiLCJoZWlnaHQiLCJobCIsImgkMCIsImhyIiwiYmFsIiwibHIiLCJsdiIsImxsIiwibHJyIiwibHJ2IiwibHJsIiwicnIiLCJydiIsInJsIiwicmxyIiwicmx2IiwicmxsIiwiYWRkIiwic2luZ2xldG9uIiwiYWRkX21pbl9lbGVtZW50IiwiYWRkX21heF9lbGVtZW50IiwicmgiLCJsaCIsIm1pbl9lbHQiLCJtaW5fZWx0X29wdCIsIm1heF9lbHQiLCJtYXhfZWx0X29wdCIsInJlbW92ZV9taW5fZWx0IiwiciQwIiwicHJlcyIsInByZXMkMCIsInJlbW92ZSIsInVuaW9uIiwicjIiLCJyMiQwIiwicjEkMCIsImludGVyIiwic3BsaXRfYmlzIiwiZGlzam9pbnQiLCJjb25zX2VudW0iLCJlMiQyIiwiZTEkMiIsImUyJDAiLCJlMSQwIiwiZTIkMSIsImUxJDEiLCJzdWJzZXQiLCJwdiIsImxmIiwibHQiLCJyZiIsInJ0IiwiY2FyZGluYWwiLCJlbGVtZW50c19hdXgiLCJlbGVtZW50cyIsImZpbmRfZmlyc3QiLCJ2MCQxIiwidjAkMCIsImZpbmRfZmlyc3Rfb3B0IiwiZmluZF9sYXN0IiwiZmluZF9sYXN0X29wdCIsInRyeV9qb2luIiwidiQxIiwieDAiLCJsJDMiLCJsJDQiLCJ4MCQwIiwibCQ1IiwieDAkMSIsIm5sIiwibWlkIiwibCQyIiwieDQiLCJhZGRfc2VxIiwic2VxX29mX2VudW0iLCJzbm9jX2VudW0iLCJyZXZfc2VxX29mX2VudW0iLCJ0b19yZXZfc2VxIiwidG9fc2VxX2Zyb20iLCJsb3ciLCJsZCIsImxyZCIsInJkIiwicmxkIiwiZGF0YSIsImQwJDEiLCJkMCIsImQwJDAiLCJtaW5fYmluZGluZyIsIm1pbl9iaW5kaW5nX29wdCIsIm1heF9iaW5kaW5nIiwibWF4X2JpbmRpbmdfb3B0IiwicmVtb3ZlX21pbl9iaW5kaW5nIiwidXBkYXRlIiwiZGF0YSQwIiwibSQwIiwiYWRkX21pbl9iaW5kaW5nIiwiayIsImFkZF9tYXhfYmluZGluZyIsImNvbmNhdF9vcl9qb2luIiwiZDEiLCJkMiIsImQyJDAiLCJkMSQwIiwiZDIkMSIsImQxJDEiLCJwdmQiLCJmdmQiLCJtMSIsIm0yIiwiYmluZGluZ3NfYXV4IiwiYmluZGluZ3MiLCJjbGVhciIsInB1c2giLCJwb3AiLCJwb3Bfb3B0IiwidG9wIiwidG9wX29wdCIsImNlbGwiLCJtYXRjaCIsInBlZWsiLCJjb250ZW50IiwicGVla19vcHQiLCJ0YWtlX29wdCIsImNlbGwkMCIsInFfcmVzIiwicHJldiIsInByZXYkMCIsInRyYW5zZmVyIiwicTEiLCJxMiIsImNvdW50IiwiZmlsbF9idWZmIiwiZ2V0X2RhdGEiLCJkMTEiLCJhJDAiLCJhJDEiLCJwZWVrX2RhdGEiLCJqdW5rX2RhdGEiLCJqdW5rIiwibmdldF9kYXRhIiwiYWwiLCJucGVlayIsInN0cm0iLCJmcm9tIiwib2ZfY2hhbm5lbCIsImlhcHAiLCJpY29ucyIsImlzaW5nIiwibGFwcCIsImxjb25zIiwibHNpbmciLCJzbGF6eSIsImR1bXAiLCJkdW1wX2RhdGEiLCJjb250ZW50cyIsInJlc2V0IiwicmVzaXplIiwibW9yZSIsIm9sZF9wb3MiLCJvbGRfbGVuIiwibmV3X2J1ZmZlciIsImFkZF9jaGFyIiwidWNoYXJfdXRmXzhfYnl0ZV9sZW5ndGhfbWF4IiwidWNoYXJfdXRmXzE2X2J5dGVfbGVuZ3RoX21heCIsImFkZF91dGZfOF91Y2hhciIsImFkZF91dGZfMTZiZV91Y2hhciIsImFkZF91dGZfMTZsZV91Y2hhciIsImFkZF9zdWJzdHJpbmciLCJvZmZzZXQiLCJuZXdfcG9zaXRpb24iLCJhZGRfc3ViYnl0ZXMiLCJhZGRfc3RyaW5nIiwiYWRkX2J5dGVzIiwiYWRkX2J1ZmZlciIsImJzIiwiYWRkX2NoYW5uZWwiLCJ0b19yZWFkJDEiLCJhbHJlYWR5X3JlYWQiLCJ0b19yZWFkIiwiYWxyZWFkeV9yZWFkJDAiLCJ0b19yZWFkJDAiLCJvdXRwdXRfYnVmZmVyIiwiYWRkX3N1YnN0aXR1dGUiLCJsaW0kMSIsInByZXZpb3VzIiwicHJldmlvdXMkMCIsInN0YXJ0JDAiLCJvcGVuaW5nIiwibGltJDAiLCJzdG9wJDAiLCJrJDIiLCJjbG9zaW5nIiwic3RvcCIsImskMCIsImskMSIsIm5leHRfaSIsImlkZW50IiwidHJ1bmNhdGUiLCJhZGRfaW50OCIsImFkZF9pbnQxNl9uZSIsImFkZF9pbnQzMl9uZSIsImFkZF9pbnQ2NF9uZSIsImFkZF9pbnQxNl9sZSIsImFkZF9pbnQxNl9iZSIsImFkZF9pbnQzMl9sZSIsImFkZF9pbnQzMl9iZSIsImFkZF9pbnQ2NF9sZSIsImFkZF9pbnQ2NF9iZSIsInN1Yl9mb3JtYXQiLCJmb3JtYXR0aW5nX2xpdCIsImNyZWF0ZV9jaGFyX3NldCIsImFkZF9pbl9jaGFyX3NldCIsInN0cl9pbmQiLCJtYXNrIiwiZnJlZXplX2NoYXJfc2V0IiwicmV2X2NoYXJfc2V0IiwiY2hhcl9zZXQkMCIsImlzX2luX2NoYXJfc2V0IiwicGFkX29mX3BhZF9vcHQiLCJwYWRfb3B0Iiwid2lkdGgiLCJwYXJhbV9mb3JtYXRfb2ZfaWdub3JlZF9mb3JtYXQiLCJmbXQiLCJwYWRfb3B0JDAiLCJwYWRfb3B0JDEiLCJwYWRfb3B0JDIiLCJwYWRfb3B0JDMiLCJwYWRfb3B0JDQiLCJwcmVjX29wdCIsInBhZF9vcHQkNSIsIm5kZWMiLCJwYWRfb3B0JDYiLCJwYWRfb3B0JDciLCJwYWRfb3B0JDgiLCJkZWZhdWx0X2Zsb2F0X3ByZWNpc2lvbiIsImJ1ZmZlcl9jcmVhdGUiLCJpbml0X3NpemUiLCJidWZmZXJfY2hlY2tfc2l6ZSIsIm92ZXJoZWFkIiwibWluX2xlbiIsIm5ld19zdHIiLCJidWZmZXJfYWRkX2NoYXIiLCJidWZmZXJfYWRkX3N0cmluZyIsInN0cl9sZW4iLCJidWZmZXJfY29udGVudHMiLCJjaGFyX29mX2ljb252IiwiY2hhcl9vZl9mY29udiIsImNGIiwiYnByaW50X3BhZHR5IiwicGFkdHkiLCJicHJpbnRfaWdub3JlZF9mbGFnIiwiaWduX2ZsYWciLCJicHJpbnRfcGFkX29wdCIsImJwcmludF9wYWRkaW5nIiwicGFkdHkkMCIsImJwcmludF9wcmVjaXNpb24iLCJicHJpbnRfaWNvbnZfZmxhZyIsImJwcmludF9hbHRpbnRfZm10IiwiYnByaW50X2Zjb252X2ZsYWciLCJzdHJpbmdfb2ZfZm9ybWF0dGluZ19saXQiLCJzdHIkMCIsImJwcmludF9jaGFyX2xpdGVyYWwiLCJicHJpbnRfc3RyaW5nX2xpdGVyYWwiLCJicHJpbnRfZm10dHkiLCJmbXR0eSQxIiwiZm10dHkkMiIsImZtdHR5JDMiLCJmbXR0eSQ0IiwiZm10dHkkNSIsImZtdHR5JDYiLCJmbXR0eSQ3IiwiZm10dHkkOCIsImZtdHR5JDkiLCJzdWJfZm10dHkiLCJmbXR0eSQxMCIsInN1Yl9mbXR0eSQwIiwiZm10dHkkMTEiLCJmbXR0eSQxMiIsImZtdHR5JDEzIiwiZm10dHkkMTQiLCJmbXR0eSQxNSIsImludF9vZl9jdXN0b21fYXJpdHkiLCJzdHJpbmdfb2ZfZm10IiwiZm10aXRlciIsImZtdCQwIiwiaWduX2ZsYWckMCIsInN0ciQxIiwic2V0JDAiLCJpc19hbG9uZSIsImFmdGVyIiwiYmVmb3JlIiwiaiQxIiwiZm10JDEiLCJzeW1tIiwiZm10dHlfcmVsX2RldCIsImRlIiwiZWQiLCJhZiIsImZhIiwiZGUkMCIsImVkJDAiLCJhZiQwIiwiZmEkMCIsImRlJDEiLCJlZCQxIiwiYWYkMSIsImZhJDEiLCJkZSQyIiwiZWQkMiIsImFmJDIiLCJmYSQyIiwiZGUkMyIsImVkJDMiLCJhZiQzIiwiZmEkMyIsImRlJDQiLCJlZCQ0IiwiYWYkNCIsImZhJDQiLCJkZSQ1IiwiZWQkNSIsImFmJDUiLCJmYSQ1IiwiZGUkNiIsImVkJDYiLCJhZiQ2IiwiZmEkNiIsImRlJDciLCJlZCQ3IiwiYWYkNyIsImZhJDciLCJkZSQ4IiwiZWQkOCIsImFmJDgiLCJmYSQ4IiwidHJhbnMiLCJqZCIsImRqIiwiZ2EiLCJhZyIsImRlJDkiLCJlZCQ5IiwiYWYkOSIsImZhJDkiLCJkZSQxMCIsImVkJDEwIiwiYWYkMTAiLCJmYSQxMCIsImRlJDExIiwiZWQkMTEiLCJhZiQxMSIsImZhJDExIiwiZGUkMTIiLCJlZCQxMiIsImFmJDEyIiwiZmEkMTIiLCJkZSQxMyIsImVkJDEzIiwiYWYkMTMiLCJmYSQxMyIsInJlc3QxIiwicmVzdDIiLCJyZXN0MSQwIiwicmVzdDIkMCIsInJlc3QxJDEiLCJyZXN0MiQxIiwicmVzdDEkMiIsInJlc3QyJDIiLCJyZXN0MSQzIiwicmVzdDIkMyIsInJlc3QxJDQiLCJyZXN0MiQ0IiwicmVzdDEkNSIsInJlc3QyJDUiLCJyZXN0MSQ2IiwicmVzdDIkNiIsInJlc3QxJDciLCJ0eTEkMCIsInJlc3QyJDciLCJ0eTIkMCIsInJlc3QxJDgiLCJ0eTEyIiwidHkxMSIsInJlc3QyJDgiLCJ0eTIyIiwidHkyMSIsImY0IiwiZjIiLCJyZXN0MSQ5IiwicmVzdDIkOSIsInJlc3QxJDEwIiwicmVzdDIkMTAiLCJyZXN0MSQxMSIsInJlc3QyJDExIiwicmVzdDEkMTIiLCJyZXN0MiQxMiIsInJlc3QxJDEzIiwicmVzdDIkMTMiLCJmbXR0eV9vZl9mbXQiLCJmbXR0eV9vZl9wYWRkaW5nX2ZtdHR5IiwidHlfcmVzdCIsInByZWNfdHkiLCJmbXR0eV9vZl9wcmVjaXNpb25fZm10dHkiLCJ0eV9yZXN0JDAiLCJwcmVjX3R5JDAiLCJ0eV9yZXN0JDEiLCJwcmVjX3R5JDEiLCJ0eV9yZXN0JDIiLCJwcmVjX3R5JDIiLCJ0eV9yZXN0JDMiLCJwcmVjX3R5JDMiLCJ0eSQwIiwiZm9ybWF0dGluZ19nZW4iLCJmbXR0eV9vZl9jdXN0b20iLCJhcml0eSQwIiwidHlwZV9wYWRkaW5nIiwidyIsInR5cGVfcGFkcHJlYyIsInR5cGVfZm9ybWF0IiwidHlwZV9mb3JtYXRfZ2VuIiwiZm10dHkwIiwiZm10dHlfcmVzdCIsImZtdF9yZXN0IiwiZm10dHlfcmVzdCQwIiwiZm10X3Jlc3QkMCIsImZtdF9yZXN0JDEiLCJmbXR0eV9yZXN0JDEiLCJmbXQkMiIsImZtdF9yZXN0JDIiLCJmbXR0eV9yZXN0JDIiLCJmbXQkMyIsImZtdF9yZXN0JDMiLCJmbXR0eV9yZXN0JDMiLCJmbXQkNCIsImZtdF9yZXN0JDQiLCJmbXR0eV9yZXN0JDQiLCJmbXQkNSIsImZtdF9yZXN0JDUiLCJmbXR0eV9yZXN0JDUiLCJwcmVjJDQiLCJmbXQkNiIsImZtdF9yZXN0JDYiLCJwcmVjJDUiLCJwYWQkOSIsInBhZCQxMCIsImZtdHR5X3Jlc3QkNiIsInByZWMkNiIsImZtdCQ3IiwiZm10X3Jlc3QkNyIsInByZWMkNyIsInBhZCQxMSIsInBhZCQxMiIsImZtdHR5X3Jlc3QkNyIsInByZWMkOCIsImZtdCQ4IiwiZm10X3Jlc3QkOCIsInBhZCQxMyIsInBhZCQxNCIsImZtdHR5X3Jlc3QkOCIsImZtdCQ5IiwiZm10X3Jlc3QkOSIsImZtdCQxMCIsImZtdF9yZXN0JDEwIiwiZm10JDExIiwiZm10X3Jlc3QkMTEiLCJmbXQkMTIiLCJmbXR0eV9yZXN0JDkiLCJmbXRfcmVzdCQxMiIsImZtdCQxMyIsImZtdHR5X3Jlc3QkMTAiLCJzdWJfZm10dHkxIiwiZm10X3Jlc3QkMTMiLCJzdWJfZm10dHkkMSIsImZtdCQxNCIsImZtdHR5X3Jlc3QkMTEiLCJmbXRfcmVzdCQxNCIsImZtdCQxNSIsImZtdHR5X3Jlc3QkMTIiLCJmbXRfcmVzdCQxNSIsImZtdCQxNiIsImZtdF9yZXN0JDE2IiwiZm10dHkkMTYiLCJmbXQkMTciLCJmbXRfcmVzdCQxNyIsImZtdHR5MyIsImZtdDMiLCJmbXQxJDAiLCJmbXR0eTIkMCIsImZtdDIkMCIsImZtdHR5MyQwIiwiZm10MyQwIiwiZm10dHlfcmVzdCQxMyIsImZtdF9yZXN0JDE4IiwiZm10dHkkMTciLCJmbXQkMTgiLCJmbXR0eV9yZXN0JDE0IiwiZm10X3Jlc3QkMTkiLCJmbXR0eSQxOCIsImZtdCQxOSIsImZtdHR5X3Jlc3QkMTUiLCJmbXRfcmVzdCQyMCIsImZtdHR5JDE5IiwiZm10JDIwIiwidHlwZV9pZ25vcmVkX3BhcmFtX29uZSIsInN1Yl9mbXR0eSQyIiwic3ViX2ZtdHR5JDMiLCJ0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGkiLCJmbXR0eSQyMSIsImZtdCQyMiIsInN1Yl9mbXR0eSQ0IiwiZm10dHlfcmVzdCQxNiIsImZtdHR5JDIwIiwiZm10JDIxIiwic3ViX2ZtdHR5X3Jlc3QiLCJzdWJfZm10dHlfcmVzdCQwIiwic3ViX2ZtdHR5X3Jlc3QkMSIsInN1Yl9mbXR0eV9yZXN0JDIiLCJzdWJfZm10dHlfcmVzdCQzIiwic3ViX2ZtdHR5X3Jlc3QkNCIsInN1Yl9mbXR0eV9yZXN0JDUiLCJzdWJfZm10dHlfcmVzdCQ2Iiwic3ViX2ZtdHR5X3Jlc3QkNyIsInN1Yl9mbXR0eV9yZXN0JDgiLCJzdWJfZm10dHlfcmVzdCQ5Iiwic3ViX2ZtdHR5X3Jlc3QkMTAiLCJzdWJfZm10dHlfcmVzdCQxMSIsInN1Yl9mbXR0eV9yZXN0JDEyIiwic3ViX2ZtdHR5X3Jlc3QkMTMiLCJzdWJfZm10dHlfcmVzdCQxNCIsInN1YjJfZm10dHkiLCJzdWJfZm10dHlfcmVzdCQxNSIsInN1YjJfZm10dHkkMCIsInN1Yl9mbXR0eV9yZXN0JDE2Iiwic3ViMl9mbXR0eSQxIiwic3ViMV9mbXR0eSIsInN1Yl9mbXR0eV9yZXN0JDE3Iiwic3ViMl9mbXR0eSQyIiwic3ViMV9mbXR0eSQwIiwic3ViX2ZtdHR5X3Jlc3QkMTgiLCJzdWJfZm10dHlfcmVzdCQxOSIsInN1Yl9mbXR0eV9yZXN0JDIwIiwic3ViX2ZtdHR5X3Jlc3QkMjEiLCJzdWJfZm10dHlfcmVzdCQyMiIsInN1Yl9mbXR0eV9yZXN0JDIzIiwic3ViX2ZtdHR5X3Jlc3QkMjQiLCJzdWJfZm10dHlfcmVzdCQyNSIsInN1Yl9mbXR0eV9yZXN0JDI2IiwicmVjYXN0IiwiZml4X3BhZGRpbmciLCJ3aWR0aCQwIiwiZml4X2ludF9wcmVjaXNpb24iLCJyZXMkMSIsInN0cmluZ190b19jYW1sX3N0cmluZyIsImZvcm1hdF9vZl9mY29udiIsInN5bWIiLCJ0cmFuc2Zvcm1faW50X2FsdCIsImRpZ2l0cyIsInB1dCIsImNvbnZlcnRfaW50IiwiY29udmVydF9pbnQzMiIsImNvbnZlcnRfbmF0aXZlaW50IiwiY29udmVydF9pbnQ2NCIsImNvbnZlcnRfZmxvYXQiLCJoZXgiLCJzaWduIiwiY2FtbF9zcGVjaWFsX3ZhbCIsInN0cmluZ19vZl9mbXR0eSIsIm1ha2VfcHJpbnRmJDAiLCJuZXdfYWNjIiwibWFrZV9wcmludGYiLCJtYWtlX3BhZGRpbmciLCJtYWtlX2ludF9wYWRkaW5nX3ByZWNpc2lvbiIsInAkMCIsInAkMSIsImFjYyQzIiwiYWNjJDQiLCJrYWNjIiwibWFrZV9pZ25vcmVkX3BhcmFtJDAiLCJtYWtlX2N1c3RvbSQwIiwibWFrZV9pbnZhbGlkX2FyZyIsIm1ha2VfZnJvbV9mbXR0eSQwIiwibWFrZV9pZ25vcmVkX3BhcmFtIiwibWFrZV9mcm9tX2ZtdHR5IiwibWFrZV9jdXN0b20iLCJtYWtlX2lwcmludGYkMCIsIm1ha2VfaXByaW50ZiIsIngkMSIsIngkMiIsIngkMyIsIngkNCIsIngkNSIsIngkNiIsIngkNyIsIngkOCIsImZuX29mX3BhZGRpbmdfcHJlY2lzaW9uIiwieCQ5IiwieCQxMCIsIngkMTEiLCJ4JDEyIiwieCQxMyIsIngkMTQiLCJ4JDE1IiwieCQxNiIsImtvYyIsInJlc3QkMjQiLCJyZXN0JDI1IiwieCQxNyIsInJlc3QkMjYiLCJ4JDE4IiwicmVzdCQyNyIsIngkMTkiLCJyZXN0JDI4IiwicmVzdCQyOSIsImZuX29mX2N1c3RvbV9hcml0eSQwIiwiZm5fb2ZfY3VzdG9tX2FyaXR5Iiwib3V0cHV0X2FjYyIsInAkMyIsInAkNCIsInAkNSIsInAkMiIsImJ1ZnB1dF9hY2MiLCJzdHJwdXRfYWNjIiwiZmFpbHdpdGhfbWVzc2FnZSIsIm9wZW5fYm94X29mX3N0cmluZyIsImludmFsaWRfYm94IiwicGFyc2Vfc3BhY2VzIiwid3N0YXJ0Iiwid2VuZCIsImJveF9uYW1lIiwibnN0YXJ0IiwibmVuZCIsImluZGVudCIsImV4cF9lbmQiLCJib3hfdHlwZSIsIm1ha2VfcGFkZGluZ19mbXRfZWJiIiwibWFrZV9wYWRwcmVjX2ZtdF9lYmIiLCJmbXRfZWJiX29mX3N0cmluZyIsImxlZ2FjeV9iZWhhdmlvciIsImZsYWciLCJsZWdhY3lfYmVoYXZpb3IkMCIsImludmFsaWRfZm9ybWF0X21lc3NhZ2UiLCJpbnZhbGlkX2Zvcm1hdF93aXRob3V0IiwiZXhwZWN0ZWRfY2hhcmFjdGVyIiwiZXhwZWN0ZWQiLCJwYXJzZSIsImxpdF9zdGFydCIsImVuZF9pbmQiLCJhZGRfbGl0ZXJhbCIsInN0cl9pbmQkMSIsInN0cl9pbmQkMiIsInBhcnNlX2ZsYWdzIiwic3RyX2luZCQwIiwicGFyc2VfdGFnIiwic3RyX2luZCQzIiwic3RyX2luZF8xIiwicGFyc2VfaW50ZWdlciIsInN0cl9pbmRfMiIsInN0cl9pbmRfMyIsImZvcm1hdHRpbmdfbGl0JDAiLCJuZXh0X2luZCIsInN0cl9pbmRfNCIsInN0cl9pbmRfNSIsInN0cl9pbmQkNCIsInN0cl9pbmRfMSQwIiwic3RyX2luZF8yJDAiLCJzdHJfaW5kXzMkMCIsInMkMSIsImZvcm1hdHRpbmdfbGl0JDEiLCJuZXh0X2luZCQwIiwicGN0X2luZCIsIm1pbnVzIiwicGx1cyIsInNwYWNlIiwic2V0X2ZsYWciLCJzdHJfaW5kJDUiLCJzcGFjZSQwIiwiaGFzaCQwIiwicGx1cyQwIiwibWludXMkMCIsInplcm8kMCIsImluY29tcGF0aWJsZV9mbGFnIiwicGFyc2VfcG9zaXRpdmUiLCJuZXdfaW5kIiwicGFyc2VfYWZ0ZXJfcGFkZGluZyIsInBhcnNlX2NvbnZlcnNpb24iLCJwYXJzZV9saXRlcmFsIiwicGFyc2VfYWZ0ZXJfcHJlY2lzaW9uIiwic3ltYiQwIiwicGFyc2VfY29udiIsInBhZHByZWMiLCJwbHVzX3VzZWQiLCJoYXNoX3VzZWQiLCJzcGFjZV91c2VkIiwiaWduX3VzZWQiLCJwYWRfdXNlZCIsInByZWNfdXNlZCIsImdldF9wbHVzIiwiZ2V0X2hhc2giLCJnZXRfc3BhY2UiLCJnZXRfaWduIiwiZ2V0X3BhZCIsImdldF9wcmVjIiwiZ2V0X3BhZHByZWMiLCJnZXRfaW50X3BhZCIsImNoZWNrX25vXzAiLCJvcHRfb2ZfcGFkIiwid2lkdGgkMSIsImdldF9wYWRfb3B0IiwiZ2V0X3BhZHByZWNfb3B0IiwiZm10X3Jlc3VsdCIsInN1Yl9lbmQiLCJzZWFyY2hfc3ViZm9ybWF0X2VuZCIsInN1Yl9mbXQiLCJpZ25vcmVkJDIiLCJjb3VudGVyJDAiLCJpZ25vcmVkJDYiLCJpZ25vcmVkJDciLCJhZGRfcmFuZ2UiLCJmYWlsX3NpbmdsZV9wZXJjZW50IiwicGFyc2VfY2hhcl9zZXRfY29udGVudCIsInBhcnNlX2NoYXJfc2V0X2FmdGVyX2NoYXIkMCIsInBhcnNlX2NoYXJfc2V0X2FmdGVyX2NoYXIiLCJyZXZlcnNlIiwiY2hhcl9zZXQkMSIsImlnbm9yZWQkOSIsImNoYXJfZm9ybWF0IiwiZm10X3Jlc3QkMjEiLCJmbXRfcmVzdCQyMiIsImZtdF9yZXN0JDIzIiwiaWdub3JlZCQxMCIsImZtdF9yZXN0JDI0IiwiZm10X3Jlc3QkMjUiLCJzdWJfZW5kJDAiLCJzdWJfZm10JDAiLCJmbXRfcmVzdCQyNiIsImlnbm9yZWQkMTEiLCJpZ25vcmVkJDMiLCJpZ25vcmVkJDUiLCJjb21wdXRlX2ludF9jb252IiwiaWdub3JlZCQ4Iiwic3BhY2UkMSIsImhhc2gkMSIsInBsdXMkMiIsImtpbmQiLCJpZ25vcmVkJDQiLCJpZ25vcmVkIiwiaWdub3JlZCQwIiwiaWdub3JlZCQxIiwicGx1cyQxIiwiaWduJDAiLCJpc19vcGVuX3RhZyIsImluZCIsInN1Yl9zdHIiLCJzdWJfZm9ybWF0JDAiLCJmb3JtYXR0aW5nJDAiLCJmb3JtYXR0aW5nIiwic3ViX2VuZCQxIiwic3ViX2VuZCQyIiwic3RyX2luZCQ2Iiwic3RyX2luZCQ3Iiwib3B0aW9uIiwic3ViZm10IiwiZm9ybWF0X29mX3N0cmluZ19mbXR0eSIsImZvcm1hdF9vZl9zdHJpbmdfZm9ybWF0Iiwia2ZwcmludGYiLCJrYnByaW50ZiIsImlrZnByaW50ZiIsImZwcmludGYiLCJicHJpbnRmIiwiaWZwcmludGYiLCJpYnByaW50ZiIsInByaW50ZiIsImVwcmludGYiLCJrc3ByaW50ZiIsInNwcmludGYiLCJhc3NvYzMiLCJ5MiIsInkxIiwibWFrZV9zeW1saXN0IiwiaGVscF9hY3Rpb24iLCJhZGRfaGVscCIsInNwZWNsaXN0IiwiYWRkMSIsImFkZDIiLCJ1c2FnZV9iIiwiZXJybXNnIiwiZG9jIiwic3BlYyIsImtleSIsInVzYWdlX3N0cmluZyIsInVzYWdlIiwiY3VycmVudCIsInBhcnNlX2FuZF9leHBhbmRfYXJndl9keW5hbWljXyIsImFsbG93X2V4cGFuZCIsImFyZ3YiLCJhbm9uZnVuIiwiaW5pdHBvcyIsImNvbnZlcnRfZXJyb3IiLCJwcm9nbmFtZSIsImZvbGxvdyQwIiwia2V5d29yZCIsImZvbGxvdyQyIiwibm9fYXJnIiwiZ2V0X2FyZyIsImNvbnN1bWVfYXJnIiwidHJlYXRfYWN0aW9uIiwibm9fYXJnJDAiLCJmJDAiLCJnZXRfYXJnJDAiLCJjb25zdW1lX2FyZyQwIiwiZiQxIiwiciQxIiwiZiQyIiwiYXJnJDEiLCJyJDIiLCJhcmckMiIsImYkMyIsImFyZyQzIiwiciQzIiwiYXJnJDQiLCJzcGVjcyIsInRyZWF0X2FjdGlvbiQwIiwiZiQ0IiwiYXJnJDUiLCJmJDUiLCJmJDYiLCJmJDciLCJhcmckNiIsIm5ld2FyZyIsInBhcnNlX2FuZF9leHBhbmRfYXJndl9keW5hbWljIiwicGFyc2VfYXJndl9keW5hbWljIiwiY3VycmVudCQwIiwicGFyc2VfYXJndiIsIm1zZyQwIiwibXNnJDEiLCJwYXJzZV9keW5hbWljIiwicGFyc2VfZXhwYW5kIiwic2Vjb25kX3dvcmQiLCJsb29wIiwibWF4X2FyZ19sZW4iLCJrd2QiLCJyZXBsYWNlX2xlYWRpbmdfdGFiIiwiYWxpZ24iLCJsaW1pdCIsImNvbXBsZXRlZCIsImtzZCIsImN1dGNvbCQwIiwic3BhY2VzJDAiLCJzcGVjJDAiLCJjdXRjb2wiLCJrd2RfbGVuIiwic3BhY2VzIiwicmVhZF9hdXgiLCJmaWxlIiwid29yZHMiLCJzdGFzaCIsIndvcmQiLCJ3b3JkJDAiLCJyZWFkX2FyZyIsInJlYWRfYXJnMCIsIndyaXRlX2F1eCIsImFyZ3MiLCJ3cml0ZV9hcmciLCJ3cml0ZV9hcmcwIiwibG9jZm10IiwicHJpbnRlcnMiLCJmaWVsZCIsIm90aGVyX2ZpZWxkcyIsInVzZV9wcmludGVycyIsInRvX3N0cmluZ19kZWZhdWx0IiwiY2hhciQwIiwibGluZSIsImNoYXIkMSIsImxpbmUkMCIsImZpbGUkMCIsImNoYXIkMiIsImxpbmUkMSIsImZpbGUkMSIsImNvbnN0cnVjdG9yIiwicHJpbnQiLCJmY3QiLCJjYXRjaCQwIiwicmF3X2JhY2t0cmFjZV9lbnRyaWVzIiwiYnQiLCJjb252ZXJ0X3Jhd19iYWNrdHJhY2UiLCJmb3JtYXRfYmFja3RyYWNlX3Nsb3QiLCJpc19yYWlzZSIsInByaW50X3Jhd19iYWNrdHJhY2UiLCJvdXRjaGFuIiwicmF3X2JhY2t0cmFjZSIsImJhY2t0cmFjZSIsInByaW50X2JhY2t0cmFjZSIsInJhd19iYWNrdHJhY2VfdG9fc3RyaW5nIiwiYmFja3RyYWNlX3Nsb3RfaXNfcmFpc2UiLCJwYXJhbSIsImJhY2t0cmFjZV9zbG90X2lzX2lubGluZSIsImJhY2t0cmFjZV9zbG90X2xvY2F0aW9uIiwiYmFja3RyYWNlX3Nsb3RfZGVmbmFtZSIsImJhY2t0cmFjZV9zbG90cyIsImJhY2t0cmFjZV9zbG90c19vZl9yYXdfZW50cnkiLCJlbnRyeSIsInJhd19iYWNrdHJhY2VfbGVuZ3RoIiwiZ2V0X2JhY2t0cmFjZSIsInJlZ2lzdGVyX3ByaW50ZXIiLCJmbiIsIm9sZF9wcmludGVycyIsIm5ld19wcmludGVycyIsImV4bl9zbG90IiwiZXhuX3Nsb3RfaWQiLCJleG5fc2xvdF9uYW1lIiwiZXJyb3JzIiwiZGVmYXVsdF91bmNhdWdodF9leGNlcHRpb25faGFuIiwic3RhdHVzIiwidW5jYXVnaHRfZXhjZXB0aW9uX2hhbmRsZXIiLCJzZXRfdW5jYXVnaHRfZXhjZXB0aW9uX2hhbmRsZXIiLCJlbXB0eV9iYWNrdHJhY2UiLCJoYW5kbGVfdW5jYXVnaHRfZXhjZXB0aW9uIiwiZGVidWdnZXJfaW5fdXNlIiwiZXhuJDEiLCJyYXdfYmFja3RyYWNlJDAiLCJjb25zdCQwIiwiZmxpcCIsIm5lZ2F0ZSIsInByb3RlY3QiLCJmaW5hbGx5JDAiLCJ3b3JrIiwiZmluYWxseV9ub19leG4iLCJ3b3JrX2V4biQwIiwid29ya19leG4iLCJ3b3JrX2J0IiwicHJpbnRfc3RhdCIsImFsbG9jYXRlZF9ieXRlcyIsIm1hIiwicHJvIiwibWkiLCJjcmVhdGVfYWxhcm0iLCJkZWxldGVfYWxhcm0iLCJudWxsX3RyYWNrZXIiLCJzYW1wbGluZ19yYXRlIiwidHJhY2tlciIsImNhbGxzdGFja19zaXplIiwic3RyaW5nIiwiYnl0ZXMiLCJzdWJzdHJpbmciLCJzdWJieXRlcyIsImZpbGVuYW1lIiwiZGlnZXN0IiwiY2hhcl9oZXgiLCJ0b19oZXgiLCJmcm9tX2hleCIsImRpZ2l0IiwibmV3X3N0YXRlIiwiYXNzaWduIiwic3QxIiwic3QyIiwiZnVsbF9pbml0Iiwic2VlZCIsInNlZWQkMCIsIm1ha2Vfc2VsZl9pbml0IiwiYml0cyIsImN1cnZhbCIsIm5ld3ZhbCIsIm5ld3ZhbDMwIiwiaW50YXV4IiwiaW50JDAiLCJib3VuZCIsImZ1bGxfaW50IiwibWF4X2ludF8zMiIsImJwb3MiLCJpbnQzMiIsImludDY0IiwibmF0aXZlaW50IiwiZmxvYXQkMCIsImJvb2wiLCJiaXRzMzIiLCJiaXRzNjQiLCJuYXRpdmViaXRzIiwiYml0cyQwIiwiaW50JDEiLCJmdWxsX2ludCQwIiwiaW50MzIkMCIsIm5hdGl2ZWludCQwIiwiaW50NjQkMCIsImZsb2F0JDEiLCJzY2FsZSIsImJvb2wkMCIsImJpdHMzMiQwIiwiYml0czY0JDAiLCJuYXRpdmViaXRzJDAiLCJmdWxsX2luaXQkMCIsInNlbGZfaW5pdCIsImdldF9zdGF0ZSIsInNldF9zdGF0ZSIsIm9uZ29pbmdfdHJhdmVyc2FsIiwiZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCIsInBhcmFtcyIsInJhbmRvbWl6ZWRfZGVmYXVsdCIsInJhbmRvbWl6ZWQiLCJyYW5kb21pemUiLCJpc19yYW5kb21pemVkIiwicHJuZyIsInBvd2VyXzJfYWJvdmUiLCJpbml0aWFsX3NpemUiLCJyYW5kb20iLCJjb3B5X2J1Y2tldGxpc3QiLCJrZXkkMCIsIm5leHQkMCIsImluc2VydF9hbGxfYnVja2V0cyIsImluZGV4ZnVuIiwiaW5wbGFjZSIsIm9kYXRhIiwibmRhdGEiLCJuc2l6ZSIsIm5kYXRhX3RhaWwiLCJuaWR4IiwibWF0Y2gkMCIsIm9zaXplIiwib2xkX3RyYXYiLCJmaWx0ZXJfbWFwX2lucGxhY2UiLCJiJDAiLCJidWNrZXRfbGVuZ3RoIiwic3RhdHMiLCJtYmwiLCJoaXN0byIsInRibF9kYXRhIiwiYnVjayIsImJ1Y2skMCIsImJ1Y2skMSIsInRvX3NlcV9rZXlzIiwidG9fc2VxX3ZhbHVlcyIsImtleV9pbmRleCIsImJ1Y2tldCIsImsxIiwibmV4dDEiLCJrMiIsIm5leHQyIiwiazMiLCJkMyIsIm5leHQzIiwiZmluZF9pbl9idWNrZXQiLCJyZXBsYWNlIiwicmVwbGFjZV9zZXEiLCJzeiIsImhhc2hfcGFyYW0iLCJzZWVkZWRfaGFzaCIsInJlYnVpbGQiLCJnZXRfY29weSIsImFyIiwiZW1wdHlidWNrZXQiLCJnZXRfaW5kZXgiLCJjcmVhdGUkMCIsInN6JDAiLCJzeiQxIiwiY291bnRfYnVja2V0IiwiYWRkX2F1eCIsInNldHRlciIsImJ1Y2tldCQwIiwiaGFzaGVzIiwibmV3c3oiLCJuZXdidWNrZXQkMCIsIm5ld2hhc2hlcyIsImhidWNrZXQiLCJwcmV2X2xlbiIsImxpdmUiLCJqJDIiLCJuZXdidWNrZXQiLCJvbGRsZW4iLCJuZXd0Iiwib2IiLCJvaSIsIm9oIiwib2kkMCIsIm5pIiwiZmluZF9vciIsImlmbm90Zm91bmQiLCJmaW5kX3NoYWRvdyIsImlmZm91bmQiLCJsZW5zIiwidG90bGVuIiwidW5rbm93biIsInBwX2VucXVldWUiLCJ0b2tlbiIsInBwX2luZmluaXR5IiwicHBfb3V0cHV0X3N0cmluZyIsInBwX291dHB1dF9uZXdsaW5lIiwiZm9ybWF0X3BwX3RleHQiLCJ0ZXh0IiwiZm9ybWF0X3N0cmluZyIsImJyZWFrX25ld19saW5lIiwicmVhbF9pbmRlbnQiLCJicmVha19zYW1lX2xpbmUiLCJmb3JtYXRfcHBfdG9rZW4iLCJzaXplJDAiLCJ0YWJzIiwiYWRkX3RhYiIsImxzIiwidGFnX25hbWUiLCJtYXJrZXIiLCJicmVha3MiLCJmaXRzIiwib2ZmIiwiYm94X3R5cGUkMCIsIm9mZiQwIiwiaW5zZXJ0aW9uX3BvaW50IiwidGFicyQwIiwiZmlyc3QiLCJoZWFkIiwidGFiIiwib2ZmJDEiLCJpbnNlcnRpb25fcG9pbnQkMCIsIndpZHRoJDIiLCJib3hfdHlwZSQxIiwidGJveCIsInRhZ19uYW1lJDAiLCJtYXJrZXIkMCIsImFkdmFuY2VfbGVmdCIsInBlbmRpbmdfY291bnQiLCJlbnF1ZXVlX2FkdmFuY2UiLCJlbnF1ZXVlX3N0cmluZ19hcyIsImluaXRpYWxpemVfc2Nhbl9zdGFjayIsInN0YWNrIiwicXVldWVfZWxlbSIsInNldF9zaXplIiwibGVmdF90b3RhbCIsInNjYW5fcHVzaCIsImVsZW0iLCJwcF9vcGVuX2JveF9nZW4iLCJicl90eSIsInBwX2Nsb3NlX2JveCIsInBwX29wZW5fc3RhZyIsInBwX2Nsb3NlX3N0YWciLCJwcF9vcGVuX3RhZyIsInBwX2Nsb3NlX3RhZyIsInBwX3NldF9wcmludF90YWdzIiwicHBfc2V0X21hcmtfdGFncyIsInBwX2dldF9wcmludF90YWdzIiwicHBfZ2V0X21hcmtfdGFncyIsInBwX3NldF90YWdzIiwicHBfZ2V0X2Zvcm1hdHRlcl9zdGFnX2Z1bmN0aW9uIiwicHBfc2V0X2Zvcm1hdHRlcl9zdGFnX2Z1bmN0aW9uIiwicGN0IiwicG90IiwibWN0IiwibW90IiwicHBfcmluaXQiLCJwcF9mbHVzaF9xdWV1ZSIsInBwX3ByaW50X2FzX3NpemUiLCJwcF9wcmludF9hcyIsImlzaXplIiwicHBfcHJpbnRfc3RyaW5nIiwicHBfcHJpbnRfYnl0ZXMiLCJwcF9wcmludF9pbnQiLCJwcF9wcmludF9mbG9hdCIsInBwX3ByaW50X2Jvb2wiLCJwcF9wcmludF9jaGFyIiwicHBfb3Blbl9oYm94IiwicHBfb3Blbl92Ym94IiwicHBfb3Blbl9odmJveCIsInBwX29wZW5faG92Ym94IiwicHBfb3Blbl9ib3giLCJwcF9wcmludF9uZXdsaW5lIiwicHBfcHJpbnRfZmx1c2giLCJwcF9mb3JjZV9uZXdsaW5lIiwicHBfcHJpbnRfaWZfbmV3bGluZSIsInBwX3ByaW50X2N1c3RvbV9icmVhayIsInBwX3ByaW50X2JyZWFrIiwicHBfcHJpbnRfc3BhY2UiLCJwcF9wcmludF9jdXQiLCJwcF9vcGVuX3Rib3giLCJwcF9jbG9zZV90Ym94IiwicHBfcHJpbnRfdGJyZWFrIiwicHBfcHJpbnRfdGFiIiwicHBfc2V0X3RhYiIsInBwX3NldF9tYXhfYm94ZXMiLCJwcF9nZXRfbWF4X2JveGVzIiwicHBfb3Zlcl9tYXhfYm94ZXMiLCJwcF9zZXRfZWxsaXBzaXNfdGV4dCIsInBwX2dldF9lbGxpcHNpc190ZXh0IiwicHBfbGltaXQiLCJwcF9zZXRfbWF4X2luZGVudCIsInBwX2dldF9tYXhfaW5kZW50IiwicHBfc2V0X21hcmdpbiIsIm5ld19tYXhfaW5kZW50IiwidmFsaWRhdGVfZ2VvbWV0cnkiLCJtYXJnaW4iLCJtYXhfaW5kZW50IiwiY2hlY2tfZ2VvbWV0cnkiLCJnZW9tZXRyeSIsInBwX2dldF9tYXJnaW4iLCJwcF9zZXRfZnVsbF9nZW9tZXRyeSIsInBwX3NldF9nZW9tZXRyeSIsInBwX3NhZmVfc2V0X2dlb21ldHJ5IiwicHBfZ2V0X2dlb21ldHJ5IiwicHBfdXBkYXRlX2dlb21ldHJ5IiwicHBfc2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zIiwicHBfZ2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zIiwicHBfc2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3RpIiwicHBfZ2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3RpIiwiZGlzcGxheV9uZXdsaW5lIiwiYmxhbmtfbGluZSIsImRpc3BsYXlfYmxhbmtzIiwicHBfc2V0X2Zvcm1hdHRlcl9vdXRfY2hhbm5lbCIsImRlZmF1bHRfcHBfbWFya19vcGVuX3RhZyIsImRlZmF1bHRfcHBfbWFya19jbG9zZV90YWciLCJkZWZhdWx0X3BwX3ByaW50X29wZW5fdGFnIiwiZGVmYXVsdF9wcF9wcmludF9jbG9zZV90YWciLCJwcF9tYWtlX2Zvcm1hdHRlciIsInBwX3F1ZXVlIiwic3lzX3RvayIsInNjYW5fc3RhY2siLCJwcF9tYXJnaW4iLCJmb3JtYXR0ZXJfb2Zfb3V0X2Z1bmN0aW9ucyIsIm91dF9mdW5zIiwibWFrZV9mb3JtYXR0ZXIiLCJwcGYiLCJmb3JtYXR0ZXJfb2Zfb3V0X2NoYW5uZWwiLCJmb3JtYXR0ZXJfb2ZfYnVmZmVyIiwicHBfYnVmZmVyX3NpemUiLCJwcF9tYWtlX2J1ZmZlciIsInN0ZGJ1ZiIsInN0ZF9mb3JtYXR0ZXIiLCJlcnJfZm9ybWF0dGVyIiwic3RyX2Zvcm1hdHRlciIsImZsdXNoX2J1ZmZlcl9mb3JtYXR0ZXIiLCJmbHVzaF9zdHJfZm9ybWF0dGVyIiwibWFrZV9zeW1ib2xpY19vdXRwdXRfYnVmZmVyIiwiY2xlYXJfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciIsInNvYiIsImdldF9zeW1ib2xpY19vdXRwdXRfYnVmZmVyIiwiZmx1c2hfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciIsIml0ZW1zIiwiYWRkX3N5bWJvbGljX291dHB1dF9pdGVtIiwiaXRlbSIsImZvcm1hdHRlcl9vZl9zeW1ib2xpY19vdXRwdXRfYiIsIm9wZW5faGJveCIsIm9wZW5fdmJveCIsIm9wZW5faHZib3giLCJvcGVuX2hvdmJveCIsIm9wZW5fYm94IiwiY2xvc2VfYm94Iiwib3Blbl90YWciLCJjbG9zZV90YWciLCJvcGVuX3N0YWciLCJjbG9zZV9zdGFnIiwicHJpbnRfYXMiLCJwcmludF9ib29sIiwicHJpbnRfYnJlYWsiLCJwcmludF9jdXQiLCJwcmludF9zcGFjZSIsImZvcmNlX25ld2xpbmUiLCJwcmludF9mbHVzaCIsInByaW50X2lmX25ld2xpbmUiLCJvcGVuX3Rib3giLCJjbG9zZV90Ym94IiwicHJpbnRfdGJyZWFrIiwic2V0X3RhYiIsInByaW50X3RhYiIsInNldF9tYXJnaW4iLCJnZXRfbWFyZ2luIiwic2V0X21heF9pbmRlbnQiLCJnZXRfbWF4X2luZGVudCIsInNldF9nZW9tZXRyeSIsInNhZmVfc2V0X2dlb21ldHJ5IiwiZ2V0X2dlb21ldHJ5IiwidXBkYXRlX2dlb21ldHJ5Iiwic2V0X21heF9ib3hlcyIsImdldF9tYXhfYm94ZXMiLCJvdmVyX21heF9ib3hlcyIsInNldF9lbGxpcHNpc190ZXh0IiwiZ2V0X2VsbGlwc2lzX3RleHQiLCJzZXRfZm9ybWF0dGVyX291dF9jaGFubmVsIiwic2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zIiwiZ2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zIiwic2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIiwiZ2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIiwic2V0X2Zvcm1hdHRlcl9zdGFnX2Z1bmN0aW9ucyIsImdldF9mb3JtYXR0ZXJfc3RhZ19mdW5jdGlvbnMiLCJzZXRfcHJpbnRfdGFncyIsImdldF9wcmludF90YWdzIiwic2V0X21hcmtfdGFncyIsImdldF9tYXJrX3RhZ3MiLCJzZXRfdGFncyIsInBwX3ByaW50X2xpc3QiLCJwcF92Iiwib3B0JDAiLCJwcF9zZXAiLCJvcHQkMSIsInBwX3ByaW50X3NlcSIsInNlcSQxIiwic2VxJDIiLCJwcF9wcmludF90ZXh0IiwicHBfcHJpbnRfb3B0aW9uIiwicHBfcHJpbnRfcmVzdWx0IiwicHBfcHJpbnRfZWl0aGVyIiwiY29tcHV0ZV90YWciLCJ0YWdfYWNjIiwib3V0cHV0X2Zvcm1hdHRpbmdfbGl0IiwiYnR5IiwicCQ2IiwicCQ3Iiwic2l6ZSQxIiwicCQ4Iiwia2RwcmludGYiLCJkcHJpbnRmIiwia2FzcHJpbnRmIiwiYXNwcmludGYiLCJmbHVzaF9zdGFuZGFyZF9mb3JtYXR0ZXJzIiwicHBfc2V0X2FsbF9mb3JtYXR0ZXJfb3V0cHV0X2Z1IiwicHBfZ2V0X2FsbF9mb3JtYXR0ZXJfb3V0cHV0X2Z1Iiwic2V0X2FsbF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0IiwiZ2V0X2FsbF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0IiwicHBfc2V0X2Zvcm1hdHRlcl90YWdfZnVuY3Rpb25zIiwic3RyaW5naWZ5IiwicHBfZ2V0X2Zvcm1hdHRlcl90YWdfZnVuY3Rpb25zIiwiZnVucyIsIm1hcmtfb3Blbl90YWciLCJtYXJrX2Nsb3NlX3RhZyIsInByaW50X29wZW5fdGFnIiwicHJpbnRfY2xvc2VfdGFnIiwic2V0X2Zvcm1hdHRlcl90YWdfZnVuY3Rpb25zIiwiZ2V0X2Zvcm1hdHRlcl90YWdfZnVuY3Rpb25zIiwibnVsbF9jaGFyIiwibmV4dF9jaGFyIiwiaWIiLCJwZWVrX2NoYXIiLCJjaGVja2VkX3BlZWtfY2hhciIsImVuZF9vZl9pbnB1dCIsImJlZ2lubmluZ19vZl9pbnB1dCIsIm5hbWVfb2ZfaW5wdXQiLCJjaGFyX2NvdW50IiwiaW52YWxpZGF0ZV9jdXJyZW50X2NoYXIiLCJ0b2tlbl9zdHJpbmciLCJ0b2tlbl9idWZmZXIiLCJpZ25vcmVfY2hhciIsInN0b3JlX2NoYXIiLCJkZWZhdWx0X3Rva2VuX2J1ZmZlcl9zaXplIiwiaW5hbWUiLCJzY2FuX2Nsb3NlX2F0X2VuZCIsInNjYW5fcmFpc2VfYXRfZW5kIiwiZnJvbV9pYyIsInNjYW5fY2xvc2VfaWMiLCJlb2YiLCJvcGVuX2luX2ZpbGUiLCJpYyQwIiwibWVtbyIsIm1lbW9fZnJvbV9jaGFubmVsIiwiYmFkX2lucHV0IiwiYmFkX2lucHV0X2VzY2FwZSIsImJhZF90b2tlbl9sZW5ndGgiLCJtZXNzYWdlIiwiYmFkX2hleF9mbG9hdCIsImNoYXJhY3Rlcl9taXNtYXRjaCIsImNpIiwiY2hlY2tfY2hhciIsImNoZWNrX3RoaXNfY2hhciIsInRva2VuX2NoYXIiLCJ0b2tlbl9ib29sIiwiaW50ZWdlcl9jb252ZXJzaW9uX29mX2NoYXIiLCJ0b2tlbl9pbnRfbGl0ZXJhbCIsImNvbnYiLCJ0b2tlbl9mbG9hdCIsInNjYW5fZGVjaW1hbF9kaWdpdF9zdGFyIiwic2Nhbl9kZWNpbWFsX2RpZ2l0X3BsdXMiLCJzY2FuX2RpZ2l0X3BsdXMiLCJiYXNpcyIsImRpZ2l0cCIsIndpZHRoJDMiLCJpc19iaW5hcnlfZGlnaXQiLCJpc19vY3RhbF9kaWdpdCIsImlzX2hleGFfZGlnaXQiLCJzY2FuX3NpZ24iLCJzY2FuX29wdGlvbmFsbHlfc2lnbmVkX2RlY2ltYWwiLCJzY2FuX2ludF9jb252ZXJzaW9uIiwic2Nhbl9mcmFjdGlvbmFsX3BhcnQiLCJzY2FuX2V4cG9uZW50X3BhcnQiLCJzY2FuX2Zsb2F0IiwicHJlY2lzaW9uIiwicHJlY2lzaW9uJDAiLCJjaGVja19jYXNlX2luc2Vuc2l0aXZlX3N0cmluZyIsInNjYW5faGV4X2Zsb2F0Iiwid2lkdGgkNCIsIndpZHRoJDUiLCJ3aWR0aCQ2Iiwid2lkdGgkMTAiLCJ3aWR0aCQ3Iiwid2lkdGgkOCIsIndpZHRoJDkiLCJzY2FuX2NhbWxfZmxvYXRfcmVzdCIsIndpZHRoX3ByZWNpc2lvbiIsImZyYWNfd2lkdGgiLCJzY2FuX2NhbWxfZmxvYXQiLCJzY2FuX3N0cmluZyIsInN0cCIsImhleGFkZWNpbWFsX3ZhbHVlX29mX2NoYXIiLCJjaGVja19uZXh0X2NoYXIiLCJzY2FuX2JhY2tzbGFzaF9jaGFyIiwiYzAiLCJnZXRfZGlnaXQkMCIsImMxJDAiLCJjMiQwIiwiZ2V0X2RpZ2l0Iiwic2Nhbl9jYW1sX3N0cmluZyIsImZpbmRfc3RvcCQwIiwic2tpcF9zcGFjZXMiLCJmaW5kX3N0b3AiLCJzY2FuX2NoYXJzX2luX2NoYXJfc2V0Iiwic2Nhbl9pbmRpYyIsInNjYW5fY2hhcnMiLCJzY2FuZl9iYWRfaW5wdXQiLCJ3aWR0aF9vZl9wYWRfb3B0Iiwic3RvcHBlcl9vZl9mb3JtYXR0aW5nX2xpdCIsImZtdGluZyIsInRha2VfZm9ybWF0X3JlYWRlcnMkMCIsInRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMkMCIsInJlYWRlciIsIm5ld19rIiwicmVhZGVyc19yZXN0IiwidGFrZV9mb3JtYXRfcmVhZGVycyIsInRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMiLCJtYWtlX3NjYW5mIiwicmVhZGVycyIsInNjYW4kMCIsInN0cl9yZXN0IiwicGFkX3ByZWNfc2NhbmYiLCJzY2FuJDEiLCJzY2FuJDIiLCJzY2FuJDMiLCJzY2FuJDQiLCJjb252JDAiLCJzY2FuJDUiLCJjb252JDEiLCJzY2FuJDYiLCJjb252JDIiLCJzY2FuJDciLCJzY2FuJDgiLCJmbXRpbmdfbGl0JDAiLCJzdHAkMCIsInMkMiIsInN0cl9yZXN0JDAiLCJhcmdfcmVzdCIsImtzY2FuZiIsImVmIiwiZXhjJDAiLCJleGMiLCJhcmdzJDEiLCJhcmdzJDAiLCJic2NhbmYiLCJrc3NjYW5mIiwic3NjYW5mIiwic2NhbmYiLCJic2NhbmZfZm9ybWF0IiwiZm9ybWF0Iiwic3NjYW5mX2Zvcm1hdCIsImZvcm1hdF9mcm9tX3N0cmluZyIsInVuZXNjYXBlZCIsImtmc2NhbmYiLCJmc2NhbmYiLCJyZWdpc3RlciIsInJlZ2lzdGVyX2V4Y2VwdGlvbiIsIm8kMCIsInB1YmxpY19tZXRob2RfbGFiZWwiLCJ0YWciLCJjb21wYXJlJDAiLCJjb21wYXJlJDEiLCJkdW1teV90YWJsZSIsInRhYmxlX2NvdW50IiwiZHVtbXlfbWV0IiwiaW5pdGlhbF9vYmplY3Rfc2l6ZSIsImZpdF9zaXplIiwibmV3X3RhYmxlIiwicHViX2xhYmVscyIsIm1ldGhvZHMiLCJhcnJheSIsIm5ld19zaXplIiwib2xkX3NpemUiLCJuZXdfYnVjayIsIm1ldGhvZF9jb3VudCIsImluc3RfdmFyX2NvdW50IiwibmV3X21ldGhvZCIsInRhYmxlIiwiZ2V0X21ldGhvZF9sYWJlbCIsImxhYmVsIiwiZ2V0X21ldGhvZF9sYWJlbHMiLCJuYW1lcyIsInNldF9tZXRob2QiLCJlbGVtZW50IiwiZ2V0X21ldGhvZCIsImFyciIsIm5hcnJvdyIsInZhcnMiLCJ2aXJ0X21ldGhzIiwiY29uY3JfbWV0aHMiLCJ2YXJzJDAiLCJ2aXJ0X21ldGhzJDAiLCJjb25jcl9tZXRocyQwIiwidmlydF9tZXRoX2xhYnMiLCJjb25jcl9tZXRoX2xhYnMiLCJsYWIiLCJ0dmFycyIsImJ5X25hbWUiLCJieV9sYWJlbCIsIm1ldCIsImhtIiwid2lkZW4iLCJzYXZlZF92YXJzIiwic2F2ZWRfaGlkZGVuX21ldGhzIiwibmV3X3ZhcmlhYmxlIiwidG9fYXJyYXkiLCJuZXdfbWV0aG9kc192YXJpYWJsZXMiLCJtZXRocyIsInZhbHMiLCJtZXRocyQwIiwibm1ldGhzIiwibnZhbHMiLCJnZXRfdmFyaWFibGUiLCJnZXRfdmFyaWFibGVzIiwiYWRkX2luaXRpYWxpemVyIiwiY3JlYXRlX3RhYmxlIiwicHVibGljX21ldGhvZHMiLCJ0YWdzIiwiaW5pdF9jbGFzcyIsImluaGVyaXRzIiwiY2xhIiwic3VwZXIkMCIsIm5tIiwibWFrZV9jbGFzcyIsInB1Yl9tZXRocyIsImNsYXNzX2luaXQiLCJlbnZfaW5pdCIsIm1ha2VfY2xhc3Nfc3RvcmUiLCJpbml0X3RhYmxlIiwiZHVtbXlfY2xhc3MiLCJsb2MiLCJ1bmRlZiIsImNyZWF0ZV9vYmplY3QiLCJjcmVhdGVfb2JqZWN0X29wdCIsIm9ial8wIiwiaXRlcl9mIiwicnVuX2luaXRpYWxpemVycyIsImluaXRzIiwicnVuX2luaXRpYWxpemVyc19vcHQiLCJjcmVhdGVfb2JqZWN0X2FuZF9ydW5faW5pdGlhbGkiLCJidWlsZF9wYXRoIiwia2V5cyIsImxvb2t1cF90YWJsZXMiLCJyb290Iiwicm9vdF9kYXRhIiwidGFibGVzJDAiLCJ0YWJsZXMkMSIsInRhYmxlc19kYXRhIiwibmV3X2NhY2hlIiwic2V0X21ldGhvZHMiLCJjbG8iLCJ4JDIwIiwiY2xvJDAiLCJuJDM4IiwiZSQxMCIsIm4kMzciLCJuJDM2IiwibiQyIiwibiQzNSIsImYkMjAiLCJuJDMiLCJmJDE5IiwibiQzNCIsIm4kNCIsImYkMTgiLCJlJDkiLCJuJDMzIiwibiQ1IiwiZiQxNyIsIm4kMzIiLCJmJDE2IiwieSQwIiwibiQ2IiwiZiQxNSIsIm4kMzEiLCJuJDciLCJmJDE0IiwiZSQ4IiwibiQzMCIsIm4kOCIsImYkMTMiLCJuJDI5IiwibiQ5IiwiZiQxMiIsIm4kMjgiLCJmJDgiLCJlJDIiLCJuJDEwIiwiZiQxMSIsImUkNyIsIm4kMjciLCJmJDkiLCJuJDExIiwiZiQxMCIsIm4kMjYiLCJuJDEyIiwibiQyNSIsIm4kMTMiLCJuJDI0IiwibSQxMiIsIm4kMTQiLCJlJDMiLCJuJDIzIiwiZSQ2IiwibSQxMSIsIm4kMTUiLCJtJDEiLCJuJDIyIiwibSQxMCIsIm0kMiIsIm0kOSIsIm0kMyIsIm4kMTYiLCJtJDgiLCJuJDIxIiwibSQ0IiwiZSQ0IiwibiQxNyIsIm0kNyIsImUkNSIsIm4kMjAiLCJtJDUiLCJuJDE4IiwibSQ2IiwibiQxOSIsImluaXRfbW9kX2Jsb2NrIiwiY29tcHMkMCIsIm1vZHUiLCJzaGFwZSIsImZuJDAiLCJjb21wcyIsImluaXRfbW9kIiwidXBkYXRlX21vZF9ibG9jayIsImNsIiwidXBkYXRlX21vZCIsImluaXRpYWxfYnVmZmVyIiwiYnVmZmVyIiwiYnVmcG9zIiwicmVzZXRfYnVmZmVyIiwic3RvcmUiLCJuZXdidWZmZXIiLCJnZXRfc3RyaW5nIiwibWFrZV9sZXhlciIsImtleXdvcmRzIiwia3dkX3RhYmxlIiwiaWRlbnRfb3Jfa2V5d29yZCIsImtleXdvcmRfb3JfZXJyb3IiLCJuZXh0X3Rva2VuIiwiZXNjYXBlIiwiY29tbWVudCIsIm51bWJlciIsImlkZW50MiIsImV4cG9uZW50X3BhcnQiLCJlbmRfZXhwb25lbnRfcGFydCIsImMzIiwiaGtleSIsImNsZWFuIiwiZG9fYnVja2V0IiwiaW5zZXJ0X2J1Y2tldCIsImNvbnRhaW5lciIsInJlbW92ZV9idWNrZXQiLCJoayIsIm5ld19kIiwiYnVja2V0X2xlbmd0aF9hbGl2ZSIsInN0YXRzX2FsaXZlIiwiZ2V0X2RhdGFfY29weSIsInNldF9kYXRhIiwidW5zZXRfZGF0YSIsImNoZWNrX2RhdGEiLCJibGl0X2RhdGEiLCJlcGgiLCJxdWVyeSIsInNldF9rZXlfZGF0YSIsIm1ha2UkMCIsInRlc3Rfa2V5IiwidCQwIiwiZ2V0X2tleTEiLCJnZXRfa2V5MV9jb3B5Iiwic2V0X2tleTEiLCJ1bnNldF9rZXkxIiwiY2hlY2tfa2V5MSIsImdldF9rZXkyIiwiZ2V0X2tleTJfY29weSIsInNldF9rZXkyIiwidW5zZXRfa2V5MiIsImNoZWNrX2tleTIiLCJibGl0X2tleTEiLCJibGl0X2tleTIiLCJibGl0X2tleTEyIiwiZ2V0X2RhdGEkMCIsImdldF9kYXRhX2NvcHkkMCIsInNldF9kYXRhJDAiLCJ1bnNldF9kYXRhJDAiLCJjaGVja19kYXRhJDAiLCJibGl0X2RhdGEkMCIsIm1ha2UkMSIsImtleTEiLCJrZXkyIiwicXVlcnkkMCIsImsyJDAiLCJrMSQwIiwiZXF1YWwkMCIsIm1ha2UkMiIsImFkZCQwIiwidGVzdF9rZXlzIiwicmVtb3ZlJDAiLCJmaW5kJDAiLCJsZW5ndGgkMCIsImNsZWFyJDAiLCJjcmVhdGUkMSIsImxlbmd0aCQxIiwiZ2V0X2tleSQwIiwiZ2V0X2tleV9jb3B5JDAiLCJzZXRfa2V5JDAiLCJ1bnNldF9rZXkkMCIsImNoZWNrX2tleSQwIiwiYmxpdF9rZXkkMCIsImdldF9kYXRhJDEiLCJnZXRfZGF0YV9jb3B5JDEiLCJzZXRfZGF0YSQxIiwidW5zZXRfZGF0YSQxIiwiY2hlY2tfZGF0YSQxIiwiYmxpdF9kYXRhJDEiLCJtYWtlJDMiLCJxdWVyeSQxIiwia2kiLCJrMCIsIm1ha2UkNCIsImFkZCQxIiwidGVzdF9rZXlzJDAiLCJyZW1vdmUkMSIsImZpbmQkMSIsImxlbmd0aCQyIiwiY2xlYXIkMSIsIm51bGwkMCIsImN1cnJlbnRfZGlyX25hbWUiLCJwYXJlbnRfZGlyX25hbWUiLCJkaXJfc2VwIiwicXVvdGVxdW90ZSIsIm51bGwkMSIsImN1cnJlbnRfZGlyX25hbWUkMCIsInBhcmVudF9kaXJfbmFtZSQwIiwiZGlyX3NlcCQwIiwibnVsbCQyIiwiY3VycmVudF9kaXJfbmFtZSQxIiwicGFyZW50X2Rpcl9uYW1lJDEiLCJkaXJfc2VwJDEiLCJnZW5lcmljX2Jhc2VuYW1lIiwiaXNfZGlyX3NlcCIsImdlbmVyaWNfZGlybmFtZSIsImlzX3JlbGF0aXZlIiwiaXNfaW1wbGljaXQiLCJjaGVja19zdWZmaXgiLCJzdWZmIiwiY2hvcF9zdWZmaXhfb3B0IiwibGVuX2YiLCJ0ZW1wX2Rpcl9uYW1lIiwicXVvdGUiLCJxdW90ZV9jb21tYW5kIiwiYmFzZW5hbWUiLCJkaXJuYW1lIiwiaXNfZGlyX3NlcCQwIiwiaXNfcmVsYXRpdmUkMCIsImlzX2ltcGxpY2l0JDAiLCJjaGVja19zdWZmaXgkMCIsImNob3Bfc3VmZml4X29wdCQwIiwidGVtcF9kaXJfbmFtZSQwIiwicXVvdGUkMCIsImxvb3AkMCIsImxvb3BfYnMiLCJhZGRfYnMiLCJxdW90ZV9jbWRfZmlsZW5hbWUiLCJxdW90ZV9jb21tYW5kJDAiLCJkcml2ZV9hbmRfcGF0aCIsImRpcm5hbWUkMCIsInBhdGgiLCJkcml2ZSIsImRpciIsImJhc2VuYW1lJDAiLCJiYXNlbmFtZSQxIiwiZGlybmFtZSQxIiwibnVsbCQzIiwiY3VycmVudF9kaXJfbmFtZSQyIiwicGFyZW50X2Rpcl9uYW1lJDIiLCJkaXJfc2VwJDIiLCJpc19kaXJfc2VwJDEiLCJpc19yZWxhdGl2ZSQxIiwiaXNfaW1wbGljaXQkMSIsImNoZWNrX3N1ZmZpeCQxIiwiY2hvcF9zdWZmaXhfb3B0JDEiLCJ0ZW1wX2Rpcl9uYW1lJDEiLCJxdW90ZSQxIiwicXVvdGVfY29tbWFuZCQxIiwiYmFzZW5hbWUkMiIsImRpcm5hbWUkMiIsImNob3Bfc3VmZml4IiwiZXh0ZW5zaW9uX2xlbiIsImkwIiwiZXh0ZW5zaW9uIiwiY2hvcF9leHRlbnNpb24iLCJyZW1vdmVfZXh0ZW5zaW9uIiwidGVtcF9maWxlX25hbWUiLCJ0ZW1wX2RpciIsInJuZCIsImN1cnJlbnRfdGVtcF9kaXJfbmFtZSIsInNldF90ZW1wX2Rpcl9uYW1lIiwiZ2V0X3RlbXBfZGlyX25hbWUiLCJ0ZW1wX2ZpbGUiLCJvcGVuX3RlbXBfZmlsZSIsInN0aCQwIiwicGVybXMiLCJzdGgkMSIsIm5lZyIsImNvbmoiLCJtdWwiLCJkaXYiLCJpbnYiLCJub3JtMiIsIm5vcm0iLCJxJDAiLCJwb2xhciIsInNxcnQiLCJ3JDAiLCJleHAiLCJsb2ciLCJwb3ciLCJraW5kX3NpemVfaW5fYnl0ZXMiLCJjbG9vcCIsImlkeCIsImNvbCIsImZsb29wIiwibGF5b3V0IiwiZGltcyIsInNpemVfaW5fYnl0ZXMiLCJzaXplX2luX2J5dGVzJDAiLCJvZl92YWx1ZSIsImRpbSIsInNpemVfaW5fYnl0ZXMkMSIsInNsaWNlIiwiaW5pdCQwIiwib2ZfYXJyYXkiLCJiYSIsImRpbTEiLCJkaW0yIiwic2l6ZV9pbl9ieXRlcyQyIiwic2xpY2VfbGVmdCIsInNsaWNlX3JpZ2h0IiwiaW5pdCQxIiwib2ZfYXJyYXkkMCIsInJvdyIsImNyZWF0ZSQyIiwiZGltMyIsInNpemVfaW5fYnl0ZXMkMyIsInNsaWNlX2xlZnRfMSIsInNsaWNlX3JpZ2h0XzEiLCJzbGljZV9sZWZ0XzIiLCJzbGljZV9yaWdodF8yIiwiaW5pdCQyIiwib2ZfYXJyYXkkMSIsImFycmF5MF9vZl9nZW5hcnJheSIsImFycmF5MV9vZl9nZW5hcnJheSIsImFycmF5Ml9vZl9nZW5hcnJheSIsImFycmF5M19vZl9nZW5hcnJheSIsInJlc2hhcGVfMCIsInJlc2hhcGVfMSIsInJlc2hhcGVfMiIsInJlc2hhcGVfMyIsIm9wZW5fYmluIiwib3Blbl90ZXh0Iiwib3Blbl9nZW4iLCJ3aXRoX29wZW4iLCJvcGVuZnVuIiwid2l0aF9vcGVuX2JpbiIsIndpdGhfb3Blbl90ZXh0Iiwid2l0aF9vcGVuX2dlbiIsInNlZWsiLCJjbG9zZSIsImNsb3NlX25vZXJyIiwicmVhZF91cHRvIiwiZW5zdXJlIiwibmV3X2xlbiQwIiwibmV3X2xlbiQxIiwiaW5wdXRfYWxsIiwiY2h1bmtfc2l6ZSIsImluaXRpYWxfc2l6ZSQwIiwiaW5pdGlhbF9zaXplJDEiLCJucmVhZCIsImJ1ZiQyIiwiYnVmJDAiLCJidWYkMSIsInJlbSIsInNldF9iaW5hcnlfbW9kZSIsInplcm8iLCJ1bml0IiwiaWQiLCJ2YWxpZF9jYW52YXNfc2l6ZSIsImhlaWdodCIsIndpZHRoIiwiYWRkIiwieTIiLCJ4MiIsInkxIiwieDEiLCJzdWIiLCJtdWwiLCJrIiwieSIsIngiLCJkb3QiLCJub3JtIiwiY3JlYXRlIiwiZiIsImUiLCJkIiwiYyIsImIiLCJhIiwibXVsJDAiLCJ0MSIsInQyIiwidHJhbnNsYXRlIiwidCIsInNjYWxlIiwic2hlYXIiLCJyb3RhdGUiLCJjb3NfYSIsInNpbl9hIiwiaW52ZXJzZSIsImRldCIsImludmRldCIsIm9mX2ludHMiLCJzdWIkMCIsInRyYW5zbGF0ZSQwIiwicm90YXRlJDAiLCJ0aGV0YSIsImN5IiwiY3giLCJ0cmFuc2Zvcm0iLCJiYXJ5Y2VudGVyIiwic3VtX2FiIiwiZGlzdGFuY2UiLCJjbGlwXzgiLCJpIiwib2ZfcmdiIiwiciIsImciLCJ0b19yZ2IiLCJvZl9hcmdiIiwidG9fYXJnYiIsIm9mX2ludCIsInRvX2ludCIsIm9mX2ludDMyIiwidG9faW50MzIiLCJjb2xvcnMiLCJkZWZpbmVfY29sb3IiLCJuYW1lIiwidHJhbnNwQmxhY2siLCJ0cmFuc3BXaGl0ZSIsImJsYWNrIiwid2hpdGUiLCJibHVlIiwiY3lhbiIsImdyZWVuIiwibGltZSIsIm9yYW5nZSIsInBpbmsiLCJyZWQiLCJvZl9zdHJpbmciLCJzIiwicyQwIiwibGlzdCIsImFkZF9pbWFnZV9kYXRhIiwiZXZlbnQiLCJzZW5kX2V2ZW50IiwiYWRkX2NhbnZhcyIsImNyZWF0ZSQwIiwiY3JlYXRlRnJvbVBORyIsImZpbGVuYW1lIiwiaW1wb3J0UE5HIiwicG9zIiwib2ZfYmlnYXJyYXkiLCJiYSIsImNyZWF0ZU9mZnNjcmVlbkZyb21QTkciLCJpbXBvcnRQTkckMCIsInNlbmRfZnJhbWUiLCJmcmFtZSIsInNlbmRfZm9jdXNfaW4iLCJmb2N1c19pbiIsInNlbmRfZm9jdXNfb3V0IiwiZm9jdXNfb3V0Iiwic2VuZF9yZXNpemUiLCJyZXNpemUiLCJzZW5kX21vdmUiLCJtb3ZlIiwic2VuZF9jbG9zZSIsImNsb3NlIiwic2VuZF9rZXlfZG93biIsImtleV9kb3duIiwic2VuZF9rZXlfdXAiLCJrZXlfdXAiLCJzZW5kX2J1dHRvbl9kb3duIiwiYnV0dG9uX2Rvd24iLCJzZW5kX2J1dHRvbl91cCIsImJ1dHRvbl91cCIsInNlbmRfbW91c2VfbW92ZSIsIm1vdXNlX21vdmUiLCJzZXRfZXZlbnRfdGltZXN0YW1wIiwiZXZlbnRfdGltZXN0YW1wIiwicnVuIiwiaCIsInRpbWVzdGFtcCIsImNhbnZhcyIsImUkMCIsInRpbWVzdGFtcCQwIiwiY2FudmFzJDAiLCJlJDEiLCJlJDIiLCJzaXplIiwidGltZXN0YW1wJDEiLCJjYW52YXMkMSIsImUkMyIsInBvc2l0aW9uIiwidGltZXN0YW1wJDIiLCJjYW52YXMkMiIsImUkNCIsInRpbWVzdGFtcCQzIiwiY2FudmFzJDMiLCJlJDUiLCJmbGFncyIsImNoYXIkMCIsImtleSIsInRpbWVzdGFtcCQ0IiwiY2FudmFzJDQiLCJlJDYiLCJlJDciLCJidXR0b24iLCJwb3NpdGlvbiQwIiwidGltZXN0YW1wJDUiLCJjYW52YXMkNSIsImUkOCIsImUkOSIsInBvc2l0aW9uJDEiLCJ0aW1lc3RhbXAkNiIsImNhbnZhcyQ2IiwiZSQxMCIsImwiLCJzZW5kX2V2ZW50JDAiLCJldmVudCQwIiwiYyIsImtleSJdLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWNhbnZhcy9vY2FtbC1jYW52YXMvX2J1aWxkL2RlZmF1bHQvc3JjL2ltcGxlbS9ldmVudC5qcyIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWNhbnZhcy9vY2FtbC1jYW52YXMvX2J1aWxkL2RlZmF1bHQvc3JjL3N0dWJzL21sX3RhZ3MuanMiLCIvYnVpbHRpbi8rbWxCeXRlcy5qcyIsIi9idWlsdGluLytiaWdhcnJheS5qcyIsIi9idWlsdGluLyttYXJzaGFsLmpzIiwiL2hvbWUvcnVubmVyL3dvcmsvb2NhbWwtY2FudmFzL29jYW1sLWNhbnZhcy9fYnVpbGQvZGVmYXVsdC9zcmMvc3R1YnMvbWxfY29udmVydC5qcyIsIi9idWlsdGluLyt1bml4LmpzIiwiL2J1aWx0aW4vK3N0ZGxpYi5qcyIsIi9idWlsdGluLytzeXMuanMiLCIvYnVpbHRpbi8rYmFja3RyYWNlLmpzIiwiL2J1aWx0aW4vK2pzbGliLmpzIiwiL2J1aWx0aW4vK2ZhaWwuanMiLCIvYnVpbHRpbi8rZnMuanMiLCIvYnVpbHRpbi8rZnNfZmFrZS5qcyIsIi9idWlsdGluLytpbnQ2NC5qcyIsIi9idWlsdGluLytzeW5jLmpzIiwiL2J1aWx0aW4vK25hdC5qcyIsIi9idWlsdGluLytmc19ub2RlLmpzIiwiL2hvbWUvcnVubmVyL3dvcmsvb2NhbWwtY2FudmFzL29jYW1sLWNhbnZhcy9fYnVpbGQvZGVmYXVsdC9zcmMvc3R1YnMvbWxfY2FudmFzLmpzIiwiL2hvbWUvcnVubmVyL3dvcmsvb2NhbWwtY2FudmFzL29jYW1sLWNhbnZhcy9fYnVpbGQvZGVmYXVsdC9zcmMvaW1wbGVtL3RyYW5zbGF0ZS5qcyIsIi9idWlsdGluLytiaWdzdHJpbmcuanMiLCIvYnVpbHRpbi8rbWQ1LmpzIiwiL2J1aWx0aW4vK2llZWVfNzU0LmpzIiwiL2J1aWx0aW4vK29iai5qcyIsIi9idWlsdGluLytlZmZlY3QuanMiLCIvYnVpbHRpbi8rYXJyYXkuanMiLCIvYnVpbHRpbi8rZG9tYWluLmpzIiwiL2J1aWx0aW4vK2ludHMuanMiLCIvYnVpbHRpbi8raGFzaC5qcyIsIi9idWlsdGluLytpby5qcyIsIi9idWlsdGluLytjb21wYXJlLmpzIiwiL2J1aWx0aW4vK3J1bnRpbWVfZXZlbnRzLmpzIiwiL2J1aWx0aW4vK3pzdGQuanMiLCIvYnVpbHRpbi8rd2Vhay5qcyIsIi9idWlsdGluLytnYy5qcyIsIi9idWlsdGluLytmb3JtYXQuanMiLCIvYnVpbHRpbi8rZ3JhcGhpY3MuanMiLCIvYnVpbHRpbi8ranNsaWJfanNfb2Zfb2NhbWwuanMiLCIvYnVpbHRpbi8rbGV4aW5nLmpzIiwiL2J1aWx0aW4vK3BybmcuanMiLCIvYnVpbHRpbi8rcGFyc2luZy5qcyIsIi9idWlsdGluLytzdHIuanMiLCIvaG9tZS9ydW5uZXIvd29yay9vY2FtbC1jYW52YXMvb2NhbWwtY2FudmFzL19vcGFtL2xpYi9vY2FtbC9jYW1saW50ZXJuYWxGb3JtYXRCYXNpY3MubWwiLCIvaG9tZS9ydW5uZXIvd29yay9vY2FtbC1jYW52YXMvb2NhbWwtY2FudmFzL19vcGFtL2xpYi9vY2FtbC9jYW1saW50ZXJuYWxBdG9taWMubWwiLCIvaG9tZS9ydW5uZXIvd29yay9vY2FtbC1jYW52YXMvb2NhbWwtY2FudmFzL19vcGFtL2xpYi9vY2FtbC9zdGRsaWIubWwiLCIvaG9tZS9ydW5uZXIvd29yay9vY2FtbC1jYW52YXMvb2NhbWwtY2FudmFzL19vcGFtL2xpYi9vY2FtbC9wZXJ2YXNpdmVzLm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvb2NhbWwtY2FudmFzL29jYW1sLWNhbnZhcy9fb3BhbS9saWIvb2NhbWwvZWl0aGVyLm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvb2NhbWwtY2FudmFzL29jYW1sLWNhbnZhcy9fb3BhbS9saWIvb2NhbWwvb2JqLm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvb2NhbWwtY2FudmFzL29jYW1sLWNhbnZhcy9fb3BhbS9saWIvb2NhbWwvY2FtbGludGVybmFsTGF6eS5tbCIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWNhbnZhcy9vY2FtbC1jYW52YXMvX29wYW0vbGliL29jYW1sL2xhenkubWwiLCIvaG9tZS9ydW5uZXIvd29yay9vY2FtbC1jYW52YXMvb2NhbWwtY2FudmFzL19vcGFtL2xpYi9vY2FtbC9zZXEubWwiLCIvaG9tZS9ydW5uZXIvd29yay9vY2FtbC1jYW52YXMvb2NhbWwtY2FudmFzL19vcGFtL2xpYi9vY2FtbC9vcHRpb24ubWwiLCIvaG9tZS9ydW5uZXIvd29yay9vY2FtbC1jYW52YXMvb2NhbWwtY2FudmFzL19vcGFtL2xpYi9vY2FtbC9yZXN1bHQubWwiLCIvaG9tZS9ydW5uZXIvd29yay9vY2FtbC1jYW52YXMvb2NhbWwtY2FudmFzL19vcGFtL2xpYi9vY2FtbC9ib29sLm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvb2NhbWwtY2FudmFzL29jYW1sLWNhbnZhcy9fb3BhbS9saWIvb2NhbWwvY2hhci5tbCIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWNhbnZhcy9vY2FtbC1jYW52YXMvX29wYW0vbGliL29jYW1sL3VjaGFyLm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvb2NhbWwtY2FudmFzL29jYW1sLWNhbnZhcy9fb3BhbS9saWIvb2NhbWwvbGlzdC5tbCIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWNhbnZhcy9vY2FtbC1jYW52YXMvX29wYW0vbGliL29jYW1sL2ludC5tbCIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWNhbnZhcy9vY2FtbC1jYW52YXMvX29wYW0vbGliL29jYW1sL2J5dGVzLm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvb2NhbWwtY2FudmFzL29jYW1sLWNhbnZhcy9fb3BhbS9saWIvb2NhbWwvc3RyaW5nLm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvb2NhbWwtY2FudmFzL29jYW1sLWNhbnZhcy9fb3BhbS9saWIvb2NhbWwvdW5pdC5tbCIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWNhbnZhcy9vY2FtbC1jYW52YXMvX29wYW0vbGliL29jYW1sL21hcnNoYWwubWwiLCIvaG9tZS9ydW5uZXIvd29yay9vY2FtbC1jYW52YXMvb2NhbWwtY2FudmFzL19vcGFtL2xpYi9vY2FtbC9hcnJheS5tbCIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWNhbnZhcy9vY2FtbC1jYW52YXMvX29wYW0vbGliL29jYW1sL2Zsb2F0Lm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvb2NhbWwtY2FudmFzL29jYW1sLWNhbnZhcy9fb3BhbS9saWIvb2NhbWwvaW50MzIubWwiLCIvaG9tZS9ydW5uZXIvd29yay9vY2FtbC1jYW52YXMvb2NhbWwtY2FudmFzL19vcGFtL2xpYi9vY2FtbC9pbnQ2NC5tbCIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWNhbnZhcy9vY2FtbC1jYW52YXMvX29wYW0vbGliL29jYW1sL25hdGl2ZWludC5tbCIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWNhbnZhcy9vY2FtbC1jYW52YXMvX29wYW0vbGliL29jYW1sL2xleGluZy5tbCIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWNhbnZhcy9vY2FtbC1jYW52YXMvX29wYW0vbGliL29jYW1sL3BhcnNpbmcubWwiLCIvaG9tZS9ydW5uZXIvd29yay9vY2FtbC1jYW52YXMvb2NhbWwtY2FudmFzL19vcGFtL2xpYi9vY2FtbC9zZXQubWwiLCIvaG9tZS9ydW5uZXIvd29yay9vY2FtbC1jYW52YXMvb2NhbWwtY2FudmFzL19vcGFtL2xpYi9vY2FtbC9tYXAubWwiLCIvaG9tZS9ydW5uZXIvd29yay9vY2FtbC1jYW52YXMvb2NhbWwtY2FudmFzL19vcGFtL2xpYi9vY2FtbC9zdGFjay5tbCIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWNhbnZhcy9vY2FtbC1jYW52YXMvX29wYW0vbGliL29jYW1sL3F1ZXVlLm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvb2NhbWwtY2FudmFzL29jYW1sLWNhbnZhcy9fb3BhbS9saWIvb2NhbWwvc3RyZWFtLm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvb2NhbWwtY2FudmFzL29jYW1sLWNhbnZhcy9fb3BhbS9saWIvb2NhbWwvYnVmZmVyLm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvb2NhbWwtY2FudmFzL29jYW1sLWNhbnZhcy9fb3BhbS9saWIvb2NhbWwvY2FtbGludGVybmFsRm9ybWF0Lm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvb2NhbWwtY2FudmFzL29jYW1sLWNhbnZhcy9fb3BhbS9saWIvb2NhbWwvcHJpbnRmLm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvb2NhbWwtY2FudmFzL29jYW1sLWNhbnZhcy9fb3BhbS9saWIvb2NhbWwvYXJnLm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvb2NhbWwtY2FudmFzL29jYW1sLWNhbnZhcy9fb3BhbS9saWIvb2NhbWwvcHJpbnRleGMubWwiLCIvaG9tZS9ydW5uZXIvd29yay9vY2FtbC1jYW52YXMvb2NhbWwtY2FudmFzL19vcGFtL2xpYi9vY2FtbC9mdW4ubWwiLCIvaG9tZS9ydW5uZXIvd29yay9vY2FtbC1jYW52YXMvb2NhbWwtY2FudmFzL19vcGFtL2xpYi9vY2FtbC9nYy5tbCIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWNhbnZhcy9vY2FtbC1jYW52YXMvX29wYW0vbGliL29jYW1sL2RpZ2VzdC5tbCIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWNhbnZhcy9vY2FtbC1jYW52YXMvX29wYW0vbGliL29jYW1sL3JhbmRvbS5tbCIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWNhbnZhcy9vY2FtbC1jYW52YXMvX29wYW0vbGliL29jYW1sL2hhc2h0YmwubWwiLCIvaG9tZS9ydW5uZXIvd29yay9vY2FtbC1jYW52YXMvb2NhbWwtY2FudmFzL19vcGFtL2xpYi9vY2FtbC93ZWFrLm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvb2NhbWwtY2FudmFzL29jYW1sLWNhbnZhcy9fb3BhbS9saWIvb2NhbWwvZm9ybWF0Lm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvb2NhbWwtY2FudmFzL29jYW1sLWNhbnZhcy9fb3BhbS9saWIvb2NhbWwvc2NhbmYubWwiLCIvaG9tZS9ydW5uZXIvd29yay9vY2FtbC1jYW52YXMvb2NhbWwtY2FudmFzL19vcGFtL2xpYi9vY2FtbC9jYWxsYmFjay5tbCIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWNhbnZhcy9vY2FtbC1jYW52YXMvX29wYW0vbGliL29jYW1sL2NhbWxpbnRlcm5hbE9PLm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvb2NhbWwtY2FudmFzL29jYW1sLWNhbnZhcy9fb3BhbS9saWIvb2NhbWwvY2FtbGludGVybmFsTW9kLm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvb2NhbWwtY2FudmFzL29jYW1sLWNhbnZhcy9fb3BhbS9saWIvb2NhbWwvZ2VubGV4Lm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvb2NhbWwtY2FudmFzL29jYW1sLWNhbnZhcy9fb3BhbS9saWIvb2NhbWwvZXBoZW1lcm9uLm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvb2NhbWwtY2FudmFzL29jYW1sLWNhbnZhcy9fb3BhbS9saWIvb2NhbWwvZmlsZW5hbWUubWwiLCIvaG9tZS9ydW5uZXIvd29yay9vY2FtbC1jYW52YXMvb2NhbWwtY2FudmFzL19vcGFtL2xpYi9vY2FtbC9jb21wbGV4Lm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvb2NhbWwtY2FudmFzL29jYW1sLWNhbnZhcy9fb3BhbS9saWIvb2NhbWwvYmlnYXJyYXkubWwiLCIvaG9tZS9ydW5uZXIvd29yay9vY2FtbC1jYW52YXMvb2NhbWwtY2FudmFzL19vcGFtL2xpYi9vY2FtbC9pbl9jaGFubmVsLm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvb2NhbWwtY2FudmFzL29jYW1sLWNhbnZhcy9fb3BhbS9saWIvb2NhbWwvb3V0X2NoYW5uZWwubWwiLCIvaG9tZS9ydW5uZXIvd29yay9vY2FtbC1jYW52YXMvb2NhbWwtY2FudmFzL19idWlsZC9kZWZhdWx0L3NyYy9vY2FtbENhbnZhcy5tbCIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWNhbnZhcy9vY2FtbC1jYW52YXMvX2J1aWxkL2RlZmF1bHQvZXhhbXBsZXMvZGVtbzIubWwiLCIvaG9tZS9ydW5uZXIvd29yay9vY2FtbC1jYW52YXMvb2NhbWwtY2FudmFzL19vcGFtL2xpYi9vY2FtbC9zdGRfZXhpdC5tbCJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0EsQzs7Rzs7O1E7Uzs7O0c7STtJO0k7RztFOzs7O0dBdU1BOztJQUFJQTs7SUFVQUM7SUNsQ0FDO0lBVkFDOztHQzdGSixTQUFTQyx5QkFBMEJDLEdBQUdDLEdBQUdDO0lBQ2pDLElBQUZDLElBQUlDO0lBQ1IsR0FBSUgsVUFBVUMsZUFBZUEsT0FBT0YsVUFBVSxPQUFPRyxRQUFTRSxNQUFNTDtJQUM5RCxJQUFGTTtJQUNKLFVBQVdKLEtBQUtELFdBQVVDO0tBQ3hCSSxLQUFLSCxRQUFTRSxNQUFNTCxRQUFRQyxHQUFFQSxJQUFJTSxTQUFTTDtJQUM3QyxPQUFPSTtHQUNUO0dBbW9CQSxTQUFTRSx1QkFBdUJDLEdBQUssT0FBT0EsRUFBRTtHQXpOOUMsU0FBU0MscUJBQXNCVjtJQUM3QixPQUFPUSx1QkFBdUJULHlCQUF5QkMsTUFBSUE7R0FDN0Q7R0NsRkEsU0FBU1csY0FBY0MsSUFBSUMsSUFDekIsT0FBT0QsT0FBT0EsVUFBVUMsS0FDMUI7R0NsU0EsU0FBU0MsZ0JBQWlCQyxJQUFJZCxHQUFLZSxTQUFTRCxJQUFJQyxTQUFTZixFQUFHO0dBQzVEYTt3QkFDdUIsT0FBT0gsY0FBY0ssUUFBT0EsVUFBMUM7d0JBQ2MsT0FBT0wsY0FBY0ssUUFBT0Esc0JBQTFDOzs7TUFFTCxJQUFJVixJQUFJVSxRQUFRZixJQUFJZTtNQUNwQkEsU0FBU2Y7TUFDVCxPQUFRVSxjQUFjTCxHQUFFTCxVQUFXVSxjQUFjTCxHQUFFTDtLQUg3Qzs7O01BTU4sSUFBSUssSUFBSVUsUUFBUWYsSUFBSWU7TUFDcEJBLFNBQVNmO01BQ1QsT0FBUVUsY0FBY0wsR0FBRUwsaUJBQWtCVSxjQUFjTCxHQUFFTDtLQUhwRDs7O01BTU4sSUFBSUssSUFBSVUsUUFBUWYsSUFBSWU7TUFDcEJBLFNBQVNmO01BQ1QsUUFBU1UsY0FBY0wsR0FBRUwsV0FBZVUsY0FBY0wsR0FBRUw7ZUFDL0NVLGNBQWNMLEdBQUVMO2VBQWNVLGNBQWNMLEdBQUVMOztLQUpqRDs7O01BT04sSUFBSUssSUFBSVUsUUFBUWYsSUFBSWU7TUFDcEJBLFNBQVNmO01BQ1QsT0FBUVUsY0FBY0wsR0FBRUwsV0FBZVUsY0FBY0wsR0FBRUw7ZUFDcERVLGNBQWNMLEdBQUVMO2VBQWNVLGNBQWNMLEdBQUVMO0tBSjNDOztjQU1VQztNQUNoQixJQUFJRCxJQUFJZSxRQUNKQyxVQUFVQyxNQUFNaEI7TUFDcEIsSUFBVSxJQUFGaUIsT0FBT0EsSUFBSWpCLEtBQUtpQixLQUN0QkYsSUFBSUUsS0FBS1IsY0FBY0ssUUFBUWYsSUFBRWtCO01BRW5DSCxTQUFTZixJQUFJQztNQUNiLE9BQU9RLHFCQUFxQk87S0FQdEI7O2NBU2lCZjtNQUN2QixJQUFJRCxJQUFJZSxRQUNKSSxTQUFTSixZQUFZZjtNQUN6QmUsU0FBU2YsSUFBSUM7TUFDYixPQUFPYyxxQkFBcUJJLFFBQVFBLFNBQVNsQjtLQUpoQztHSG1EakI7SUFBSW1CO0lBT0FDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUlrUUFDOztPQUFzQkM7VUFDdkJIO1VBQ0FBO1VBQ0FBO0dBR0gsU0FBU0ksYUFBYUMsS0FDcEIsT0FBT0gsb0JBQW9CRyxLQUM3QjtHQXlDa0I7SUFBZEM7O09BQW9CSDtVQUNyQkY7VUFDQUE7VUFDQUE7VUFDQUE7VUFDQUE7VUFDQUE7VUFDQUE7VUFDQUE7VUFDQUE7VUFDQUE7VUFDQUE7VUFDQUE7VUFDQUE7VUFDQUE7VUFDQUE7VUFDQUE7VUFDQUE7VUFDQUE7VUFDQUE7VUFDQUE7VUFDQUE7VUFDQUE7VUFDQUE7VUFDQUE7VUFDQUE7VUFDQUE7R0FHSCxTQUFTTSxXQUFXRixLQUNsQixPQUFPQyxrQkFBa0JELEtBQzNCO0dKdFhjLElBQVZHO0dJOE5KLFNBQVNDLGVBQWVDO0lBQ2hCLElBQUZ6QjtJQUNKQSxPQUFPeUI7SUFDUCxjQUFlQTs7T0FFWHpCLE9BQU91QixpQkFDUDs7T0FFQXZCLE9BQU91QixvQkFDUDs7T0FFQXZCLE9BQU91QixtQkFDUDs7SUFFSixPQUFPdkI7R0FDVDtHSjFQQTtJQUFJMEI7Ozs7Ozs7Ozs7SURuS0FDO0lDUEFDO0lBNk1BQztJSXNQQUM7O09BQXVCWjtVQUN4Qlc7VUFDQUE7VUFDQUE7R0FHSCxTQUFTRSxjQUFjQyxNQUNyQixPQUFPRixxQkFBcUJFLE1BQzlCO0dMOWJBO0lBQUlDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQXlLQUM7SUNsQ0FDO0lBOUlBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJSXNLQUM7O09BQWdCbkI7VUFDakJrQixnQkFBOEJIO1VBQzlCRyxZQUE4Qkg7VUFDOUJHLFlBQThCSDtVQUM5QkcsWUFBOEJIO1VBQzlCRyxZQUE4Qkg7VUFDOUJHLFlBQThCSDtVQUM5QkcsWUFBOEJIO1VBQzlCRyxZQUE4Qkg7VUFDOUJHLFlBQThCSDtVQUM5QkcsWUFBOEJIO1VBQzlCRyxhQUE4Qkg7VUFDOUJHLGFBQThCSDtVQUM5QkcsYUFBOEJIO1VBQzlCRyxxQkFBOEJIO1VBQzlCRyxvQkFBOEJIO1VBQzlCRyxlQUE4Qkg7VUFDOUJHLHFCQUE4Qkg7VUFDOUJHLHdCQUE4Qkg7VUFDOUJHLGVBQThCSDtVQUM5QkcsbUJBQThCSDtVQUM5QkcsbUJBQThCSDtVQUM5Qkcsb0JBQThCSDtVQUM5Qkcsa0JBQThCSDtVQUM5Qkcsc0JBQThCSDtVQUM5QkcscUJBQThCSDtVQUM5QkcseUJBQThCSDtVQUM5QkcseUJBQThCSDtVQUM5QkcsMEJBQThCSDtVQUM5Qkcsb0JBQThCSDtVQUM5QkcsbUJBQThCSDtVQUM5QkcsYUFBOEJIO1VBQzlCRyxXQUE4Qkg7VUFDOUJHLFdBQThCSDtVQUM5QkcsV0FBOEJIO1VBQzlCRyxXQUE4Qkg7VUFDOUJHLFdBQThCSDtVQUM5QkcsV0FBOEJIO1VBQzlCRyxXQUE4Qkg7VUFDOUJHLFdBQThCSDtVQUM5QkcsV0FBOEJIO1VBQzlCRyxXQUE4Qkg7VUFDOUJHLHdCQUE4Qkg7VUFDOUJHLHdCQUE4Qkg7VUFDOUJHLHdCQUE4Qkg7VUFDOUJHLGtCQUE4Qkg7VUFDOUJHLFdBQThCSDtVQUM5QkcsV0FBOEJIO1VBQzlCRyxXQUE4Qkg7VUFDOUJHLFdBQThCSDtVQUM5QkcsV0FBOEJIO1VBQzlCRyxXQUE4Qkg7VUFDOUJHLFdBQThCSDtVQUM5QkcsV0FBOEJIO1VBQzlCRyxXQUE4Qkg7VUFDOUJHLHlCQUE4Qkg7VUFDOUJHLDJCQUE4Qkg7VUFDOUJHLDRCQUE4Qkg7VUFDOUJHLGdCQUE4Qkg7VUFDOUJHLGdCQUE4Qkg7VUFDOUJHLDhCQUE4Qkg7VUFDOUJHLFdBQThCSDtVQUM5QkcsV0FBOEJIO1VBQzlCRyxXQUE4Qkg7VUFDOUJHLFdBQThCSDtVQUM5QkcsV0FBOEJIO1VBQzlCRyxXQUE4Qkg7VUFDOUJHLFdBQThCSDtVQUM5Qkcsb0JBQThCSDtVQUM5Qkcsd0JBQThCSDtVQUM5Qkcsd0JBQThCSDtVQUM5QkcsZ0JBQThCSDtVQUM5Qkcsa0JBQThCSDtVQUM5QkcsZUFBOEJIO1VBQzlCRyxjQUE4Qkg7VUFDOUJHLGtCQUE4Qkg7VUFDOUJHLGNBQThCSDtVQUM5QkcsZUFBOEJIO1VBQzlCRyxjQUE4Qkg7VUFDOUJHLGtCQUE4Qkg7VUFDOUJHLGdCQUE4Qkg7VUFDOUJHLGNBQThCSDtVQUM5QkcsZ0JBQThCSDtVQUM5QkcsdUJBQThCSDtVQUM5QkcsYUFBOEJIO1VBQzlCRyxrQkFBOEJIO1VBQzlCRyxpQkFBOEJIO1VBQzlCRyxtQkFBOEJIO1VBQzlCRyxtQkFBOEJIO1VBQzlCRyxvQkFBOEJIO1VBQzlCRywyQkFBOEJIO1VBQzlCRyxvQkFBOEJIO1VBQzlCRyxvQkFBOEJIO1VBQzlCRyxzQkFBOEJIO1VBQzlCRyxtQkFBOEJIO1VBQzlCRyxvQkFBOEJIO1VBQzlCRyx1QkFBOEJIO1VBQzlCRyxzQkFBOEJIO1VBQzlCRyxrQkFBOEJIO1VBQzlCRyx5QkFBOEJIO1VBQzlCRyxlQUE4Qkg7VUFDOUJHLDBCQUE4Qkg7VUFDOUJHLG1CQUE4Qkg7VUFDOUJHLG1CQUE4Qkg7VUFDOUJHLHlCQUE4Qkg7VUFDOUJHLHdCQUE4Qkg7VUFDOUJHLHNCQUE4Qkg7VUFDOUJHLDRCQUE4Qkg7VUFDOUJHLG1CQUE4Qkg7VUFDOUJHLGFBQThCSDtVQUM5QkcsYUFBOEJIO1VBQzlCRyxhQUE4Qkg7VUFDOUJHLGFBQThCSDtVQUM5QkcsYUFBOEJIO1VBQzlCRyxhQUE4Qkg7VUFDOUJHLGFBQThCSDtVQUM5QkcsYUFBOEJIO1VBQzlCRyxhQUE4Qkg7VUFDOUJHLGFBQThCSDtVQUM5QkcsYUFBOEJIO1VBQzlCRyxhQUE4Qkg7VUFDOUJHLHdCQUE4Qkg7VUFDOUJHLHdCQUE4Qkg7VUFDOUJHLHdCQUE4Qkg7VUFDOUJHLHdCQUE4Qkg7VUFDOUJHLHdCQUE4Qkg7VUFDOUJHLHdCQUE4Qkg7VUFDOUJHLHdCQUE4Qkg7VUFDOUJHLHdCQUE4Qkg7VUFDOUJHLHdCQUE4Qkg7VUFDOUJHLGVBQThCSDtVQUM5QkcsZUFBOEJIO1VBQzlCRyxlQUE4Qkg7VUFDOUJHLGVBQThCSDtVQUM5QkcsZUFBOEJIO1VBQzlCRyxjQUE4Qkg7VUFDOUJHLGNBQThCSDtVQUM5Qkcsa0JBQThCSDtVQUM5Qkcsb0JBQThCSDtHQUdqQyxTQUFTSyxhQUFhQyxTQUNwQixPQUFPRixjQUFjRSxTQUN2QjtHSHJSQSxTQUFTQyxnQkFBZ0JDLEdBQUd6QztJQUMxQixHQUFHeUMsUUFBUTtJQUNYLEdBQUl6QyxVQUFVLE9BQVFBLFNBQVN5QztJQUMvQixJQUFJQyxRQUFRQztJQUNaLE9BQVE7S0FDTixHQUFJRixPQUFPQyxLQUFLMUM7S0FDaEJ5QztLQUNBLEdBQUlBLFFBQVEsT0FBT0M7S0FDbkIxQyxLQUFLQTtLQUNMMkM7S0FDQSxHQUFJQSxRQUNGM0M7O0dBS047R0F5WEEsU0FBUzRDLDZCQUE4QjVDO0lBRXJDLEdBQUlBO0tBQ0ZBLE9BQU93QyxnQkFBZ0J4QyxNQUFNQTs7S0FFN0JBLE1BQU1QLHlCQUEwQk8sUUFBUUE7SUFDMUNBO0dBQ0Y7R0E3UkEsU0FBUzZDLGNBQWU3QztJQUV0QixHQUFJQSxjQUFlO0tBRWpCLElBQVcsSUFBRkwsT0FBT0EsSUFBSUssVUFBVUwsS0FBSyxHQUFJSyxhQUFhTCxVQUFVO0tBQzlEOzs7S0FFQSxTQUFRLG9CQUFvQks7R0FDaEM7R0F2REEsU0FBUzhDLG1CQUFtQjlDO0lBQzFCLFFBQVMrQyxRQUFRQyxRQUFRQyxHQUFHQyxJQUFJQyxJQUFJQyxHQUFHekQsT0FBT2dELElBQUkzQyxVQUFVTCxJQUFJZ0QsR0FBR2hELElBQUs7S0FDdEV1RCxLQUFLbEQsYUFBYUw7S0FDbEIsR0FBSXVELFVBQVc7TUFDYixJQUFXLElBQUZyQyxJQUFJbEIsT0FBUWtCLElBQUk4QixNQUFPTyxLQUFLbEQsYUFBYWEsWUFBWUEsS0FBSTtNQUNsRSxHQUFJQSxJQUFJbEIsUUFBUztPQUFFcUQ7T0FBZ0JELEtBQUtDO09BQUdBO09BQVFELEtBQUsvQyxRQUFRTCxHQUFHa0I7OztPQUM5RG1DLEtBQUtoRCxRQUFRTCxHQUFHa0I7TUFDckIsR0FBSUEsS0FBSzhCLEdBQUc7TUFDWmhELElBQUlrQjs7S0FFTnVDO0tBQ0EsS0FBT3pELElBQUlnRCxPQUFTUSxLQUFLbkQsYUFBYUwsbUJBQW9CO01BQ3hEc0QsSUFBSUUsTUFBTUQ7TUFDVixHQUFJQSxVQUFXO09BQ2JFLElBQUlIO09BQ0osR0FBSUcsVUFBVUE7O1VBQ1Q7T0FDTEE7T0FDQSxLQUFPekQsSUFBSWdELE9BQVNRLEtBQUtuRCxhQUFhTCxtQkFBb0I7UUFDeERzRCxJQUFJRSxNQUFNRjtRQUNWLEdBQUlDLFVBQVc7U0FDYkUsSUFBSUg7U0FDSixHQUFLRyxhQUFnQkEsZUFBaUJBLFlBQWNBOztZQUMvQztTQUNMQTtTQUNBLEtBQU96RCxJQUFJZ0QsT0FBU1EsS0FBS25ELGFBQWFMLHNCQUNqQ3VELFVBQVk7VUFDZkUsSUFBSUQsa0JBQWtCRjtVQUN0QixHQUFJRyxlQUFlQSxjQUFjQTs7Ozs7O0tBTTNDLEdBQUlBLE1BQU87TUFDVHpELEtBQUt5RDtNQUNMSjs7YUFDU0k7TUFDVEosS0FBS2xELDhCQUE4QnNELG9CQUFvQkE7O01BRXZESixLQUFLbEQsb0JBQW9Cc0Q7S0FDM0IsR0FBSUosZ0JBQWlCLENBQUNBLGdCQUFnQkQsS0FBS0MsR0FBR0E7O0lBRWhELE9BQU9ELElBQUVDO0dBQ1g7R0EwUEEsU0FBU0ssUUFBU0MsS0FBS0MsVUFBVUM7SUFDL0I5QyxTQUFPNEM7SUFBSzVDLFNBQU82QztJQUFVN0MsU0FBTzhDO0dBQ3RDO0dBQ0FIOztLQUNFLE9BQVEzQzs7UUFFTixPQUFPQTtnQkFFUGtDLDZCQUE2QmxDOztRQUU3QixHQUFJbUMsY0FBY25DLFFBQVMsQ0FDekJBLFlBQ0EsT0FBT0EsU0FFVEE7O1FBRUEsT0FBT0E7O0lBYmtCO0dBZ0I3QjJDOztLQUNRLElBQUZYLElBQUloQztLQUNSLEdBQUdBLGFBQWEsT0FBT2dDO0tBQ3ZCLE9BQU9JLG1CQUFtQko7SUFIQTtHQUs1Qlc7O0tBQ2MsSUFBUkksVUFBVS9DLGNBQWNBLGlCQUFpQkE7S0FDN0MsV0FBVzJDLFFBQVEzQyxRQUFPK0MsU0FBUS9DO0lBRlY7R0FqVzFCLFNBQVNnRCxtQkFBbUIxRDtJQUMxQixRQUFTK0MsUUFBUUMsSUFBSUQsR0FBR0UsR0FBR1UsR0FBR2hFLE9BQU9nRCxJQUFJM0MsVUFBVUwsSUFBSWdELEdBQUdoRCxJQUFLO0tBQzdEc0QsSUFBSWpELGFBQWFMO0tBQ2pCLEdBQUlzRCxTQUFVO01BQ1osSUFBVyxJQUFGcEMsSUFBSWxCLE9BQVFrQixJQUFJOEIsTUFBT00sSUFBSWpELGFBQWFhLFlBQVlBLEtBQUk7TUFDakUsR0FBSUEsSUFBSWxCLFFBQVM7T0FBRXFEO09BQWdCRCxLQUFLQztPQUFHQTtPQUFRRCxLQUFLL0MsUUFBUUwsR0FBR2tCOzs7T0FDOURtQyxLQUFLaEQsUUFBUUwsR0FBR2tCO01BQ3JCLEdBQUlBLEtBQUs4QixHQUFHO01BQ1poRCxJQUFJa0I7O0tBRU4sR0FBSW9DLFVBQVc7TUFDYkQsS0FBS2xELDJCQUE0Qm1EO01BQ2pDRCxLQUFLbEQsMkJBQTRCbUQ7O2FBQ3hCQSxjQUFjQTtNQUN2QkQ7T0FBS2xEO2dCQUE0Qm1ELGdCQUNDQSxzQkFDREE7O09BQ3hCQSxlQUFldEQsU0FBU2dELE1BQ3ZCZ0IsSUFBSTNELGFBQWFMO1VBQW9CZ0U7TUFFL0NYO1NBQ0s7TUFDTHJEO01BQ0FzRCxLQUFLQSxXQUFXVTtNQUNoQlg7T0FBS2xEO2dCQUE0Qm1EO2dCQUNDQTtnQkFDQUE7Z0JBQ0RBOztLQUVuQyxHQUFJRCxnQkFBaUIsQ0FBQ0EsZ0JBQWdCRCxLQUFLQyxHQUFHQTs7SUFFaEQsT0FBT0QsSUFBRUM7R0FDWDtHQWluQkEsU0FBU1ksd0JBQXlCNUQ7SUFDaEMsT0FBSTZDLGNBQWM3QztjQUNURSx1QkFBdUJGO2NBQ3BCRSx1QkFBdUJ3RCxtQkFBbUIxRDtHQUN4RDtHSWxwQmU7SUFBWDZEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FpQkosU0FBU0MsbUJBQW1CQyxNQUFNQyxTQUFTQyxNQUFNQztJQUNuQyxJQUFSQyxVQUFVTixtQkFBbUJFO0lBQ2pDLEdBQUlJLFlBQWEsQ0FFZixHQUFJRCxTQUFTbkUsTUFDWG1FLGdCQUdGQyxjQUFtQkQ7SUFFWjtLQUFMRTtRQUNGRDtRQUNBUCx3QkFBd0JJO1FBQ3hCSix3QkFBd0JLO0lBRTFCLE9BQU9HO0dBQ1Q7R0NVc0IsSUFBbEJDO0dBV0osU0FBU0MsaUJBQWlCQyxJQUN4QixPQUFPRixrQkFBa0JFLElBQzNCO0dDL0JBLFNBQVNDLGdCQUFnQi9CO0lBQ1gsSUFBUmdDLFVBQVVDO0lBRWQsR0FBR0QsV0FDR0EsZUFDQUEsWUFBWWhDLE1BQU1rQztLQUN0QixPQUFPRixZQUFZaEM7SUFDckIsR0FBR2lDLDhCQUNHQSwyQkFBMkJqQztLQUMvQixPQUFPaUMsMkJBQTJCakM7R0FDdEM7R0NwRytCLElBQTNCbUM7R0FFSixDQUFBO01BQ1EsSUFBRmxDLElBQUk4QjtNQUNSLEdBQUc5QixNQUFNaUMsVUFBVTtPQUNYLElBQUZoQyxJQUFJRDtPQUNSLElBQVUsSUFBRi9DLE9BQU9BLElBQUlnRCxVQUFVaEQ7UUFBSSxHQUM1QmdELEVBQUVoRCxVQUFXO1NBQUVpRjtTQUFnQzs7Z0JBQ3pDakMsRUFBRWhEO1NBQ1RpRiwrQkFBK0JqQyxFQUFFaEQ7O1NBQzlCOztLQVJWOztHRjBIb0IsSUFBakJrRjtHRzZCSixTQUFTQywyQkFBMkJDLEtBQUtDO0lBRXZDLEtBQUlELGdCQUFnQkMsU0FBU0Q7S0FBZUEsbUJBQW1CTDtJQUMvRCxPQUFPSztHQUNUO0dBYkEsU0FBU0UsNEJBQTRCRixLQUFLQztJQUN4QyxPQUFHSjtjQUNNRSwyQkFBMkJDLEtBQUtDO2NBQzdCRDtHQUNkO0dDNUlBLFNBQVNHLHFCQUFzQjVCLEtBQUtjO0lBQVEsTUFBTWEsNEJBQTRCLElBQUkzQixZQUFZYztHQUFRO0dUd3lCdEcsU0FBU2UsaUJBQWlCbkYsR0FDeEIsT0FBUUEsYUFBYXFELFFBQ3ZCO0dBa0JBLFNBQVMrQixrQkFBa0JwRjtJQUN6QixjQUFlQSxvQkFBbUIsb0JBQW9CQTtHQUN4RDtHQTNWQSxTQUFTcUYsb0JBQXFCM0Y7SUFDNUIsTUFBTUEsYUFBYTRGLGFBQ2pCNUYsUUFBUTRGLFdBQVc1RjtJQUVyQixXQUFXMkQsV0FBVTNELEdBQUVBO0dBQ3pCO0dBdU9BLFNBQVM2RixzQkFBc0J2RixHQUFLLFdBQVdxRCxXQUFVckQsR0FBRUEsVUFBVztHQXJCdEUsU0FBU3dGLHVCQUF1QnJGLEdBQUssT0FBT0EsRUFBRTtHQVY5QyxTQUFTc0YscUJBQXFCekY7SUFDNUIsT0FBT3VGLHNCQUFzQkMsdUJBQXVCeEY7R0FDdEQ7R1N0ckJBLFNBQVMwRixvQkFBcUJwQyxLQUFLcUM7SUFBTyxNQUFNVixnQ0FBZ0MzQixLQUFLcUM7R0FBTztHQVE1RixTQUFTQyx1QkFBd0J0QyxLQUFLdUM7SUFDcENILG9CQUFxQnBDLEtBQUtwRCx1QkFBdUIyRjtHQUNuRDtHSGJBLFNBQVNDLHFCQUFzQkQ7SUFDN0JELHVCQUF1QmYsNEJBQTRCZ0I7R0FDckQ7R0l3S0EsU0FBU0Usd0JBQXdCQztJQUMvQkYscUJBQXNCRTtHQUN4QjtHVm1RQSxTQUFTQyw0QkFBNkJqRztJQUVwQyxJQUFJTixRQUFRNEYsV0FBV3RGLE1BQ25CK0MsSUFBSS9DLEtBQUsyQyxJQUFJSSxVQUFVcEQ7SUFDM0IsTUFBT0EsSUFBSWdELEdBQUdoRCxLQUFLRCxFQUFFQyxLQUFLb0QsYUFBYXBEO0lBQ3ZDLElBQUtnRCxJQUFJM0MsS0FBS0wsSUFBSWdELEdBQUdoRCxLQUFLRCxFQUFFQztJQUM1QkssTUFBTU47SUFDTk07SUFDQSxPQUFPTjtHQUNUO0dBSUEsU0FBU3dHLDBCQUEyQmxHO0lBQ2xDLEdBQUlBLFVBQXNCaUcsNEJBQTRCakc7SUFDdEQsT0FBT0E7R0FDVDtHU3JhQSxTQUFTbUcsc0JBQXVCTjtJQUM5QkQsdUJBQXVCZixtQ0FBbUNnQjtHQUM1RDtHVGljQSxTQUFTTyxrQkFBa0J4RztJQUN6QixHQUFJQSxTQUFTdUc7SUFDYixXQUFXOUMsUUFBUXpELGlCQUFXQTtHQUNoQztHQWdKQSxTQUFTeUcscUJBQXFCckcsR0FBSyxPQUFPQSxJQUFJO0dBdkM5QyxTQUFTc0csZ0JBQWdCQyxJQUFJQyxJQUFJQyxJQUFJQyxJQUFJOUc7SUFDdkMsR0FBSUEsVUFBVTtJQUNkLEdBQUs4RyxZQUNBOUcsT0FBTzZHLFFBQVNBLGFBQTJCN0csT0FBTzZHLGFBQWU7S0FDcEVBO01BQVFGO1NBQ045Ryx5QkFBeUI4RyxNQUFNQyxJQUFJNUc7U0FDbEM0RyxXQUFXRCxlQUFlM0csTUFBSzJHLE9BQUtBLFlBQVlDLElBQUk1RztLQUN2RDZHLE9BQVFBLGVBQWVBOztZQUNkQSxhQUEyQkMsTUFBTUQsWUFBYTtLQUN2REE7TUFBU0Y7U0FDUDlHLHlCQUF5QjhHLE1BQU1DLElBQUk1RztTQUNsQzRHLFdBQVdELGVBQWUzRyxNQUFLMkcsT0FBS0EsWUFBWUMsSUFBSTVHO0tBQ3ZENkcsT0FBUUEsZUFBZUE7O1FBQ2xCO0tBQ0wsR0FBSUEsV0FBdUJSLDRCQUE0QlE7S0FDdkQsSUFBSXZELEtBQUtxRCxNQUFNcEQsS0FBS3NEO0tBQ3BCLEdBQUlGO01BQXVCLEdBQ3JCRyxNQUFNRjtPQUFJLElBQ0QsSUFBRjdHLE9BQU9BLElBQUlDLEtBQUtELEtBQUt3RCxHQUFJdUQsS0FBSy9HLEtBQUt1RCxHQUFJc0QsS0FBSzdHOztPQUNoRCxJQUNNLElBQUZBLElBQUlDLFNBQVNELFFBQVFBLEtBQUt3RCxHQUFJdUQsS0FBSy9HLEtBQUt1RCxHQUFJc0QsS0FBSzdHO1NBRXZEO01BQ0MsSUFBRmdELElBQUkxQyxTQUFVTCxLQUFLc0QsWUFBWXNEO01BQ25DLElBQVcsSUFBRjdHLE9BQU9BLElBQUlnRCxHQUFHaEQsS0FBS3dELEdBQUl1RCxLQUFLL0csS0FBS3VELGNBQWNzRCxLQUFLN0c7TUFDN0QsTUFBT0EsSUFBSUMsS0FBS0QsS0FBS3dELEdBQUl1RCxLQUFLL0c7OztJQUdsQztHQUNGO0dVNWtCQSxTQUFTZ0gsU0FBVztHQzZOcEIsU0FBU0MsV0FBV25ELFNBQ2xCL0MsWUFBWStDLFFBQ2Q7R0FDQW1ELDJCQUEyQkQ7R0FDM0JDLG1DQUFtQ0E7R0FDbkNBO2FBQXlDaEg7S0FDL0IsSUFBSmlILE1BQU1uRztLQUNWQSxZQUFZMEYsa0JBQWtCeEc7S0FDOUIwRyxnQkFBZ0JPLFFBQVFuRyxjQUFjZDtJQUhSO0dBS2hDZ0g7ZUFDRSxPQUFPUCxxQkFBcUIzRixXQURBO0dBRzlCa0c7YUFBc0M5RixRQUFPZ0csS0FBSUMsS0FBSW5IO0tBQzFDLElBQUxvSCxPQUFPdEc7S0FDWCxHQUFHSSxTQUFTbEIsT0FBT29ILEtBQU07TUFDdkIsSUFBSUMsVUFBVWIsa0JBQWtCdEYsU0FBU2xCLE1BQ3JDc0gsV0FBV3hHO01BQ2ZBLFlBQVl1RztNQUNaWCxnQkFBZ0JZLGFBQWF4RyxjQUFjc0c7O0tBRTdDVixnQkFBZ0JqQixvQkFBb0J5QixNQUFNQyxLQUFLckcsV0FBV0ksUUFBUWxCO0tBQ2xFO0lBVDJCO0dBVzdCZ0g7YUFBcUM5RixRQUFPZ0csS0FBSUMsS0FBSW5IO0tBQ3pDLElBQUxvSCxPQUFPdEc7S0FDWCxHQUFHSSxTQUFTbEIsT0FBT29ILE1BQ2pCcEgsTUFBTW9ILE9BQU9sRztLQUVmLEdBQUdsQixJQUFLO01BQ0csSUFBTHVILE9BQU9mLGtCQUFrQnhHO01BQzdCMEcsZ0JBQWdCNUYsV0FBV0ksUUFBUXFHLFNBQVN2SDtNQUM1Q2tILFFBQVFaLDBCQUEwQmlCLE9BQU9KOztLQUUzQyxPQUFPbkg7SUFWbUI7R0F3RDVCLFNBQVN3SCxTQUFTcEIsTUFBTXFCLE1BQUtDO0lBQzNCNUcsWUFBWTJHO0lBQ1ozRyxZQUFZc0Y7SUFDWnRGLGFBQWE0RztHQUNmO0dBRUFGOztLQUNFdEIscUJBQXFCcEY7SUFEUztHQUdoQzBHO2VBQ0UsR0FBRzFHLFdBQVcsT0FBT0Esb0JBQ3JCQSxrQkFGMEI7R0FJNUIwRzthQUFxQ3RHLFFBQU9nRyxLQUFJQyxLQUFJbkg7S0FDbEQsR0FBR2MsV0FBVyxPQUFPQSxnQkFBZ0JJLFFBQU9nRyxLQUFJQyxLQUFJbkg7S0FDcERjO0lBRnlCO0dBSTNCMEc7YUFBb0N0RyxRQUFRZ0csS0FBS0MsS0FBS25IO0tBQ3BELEdBQUdjLFdBQVcsT0FBT0EsZUFBZUksUUFBUWdHLEtBQUtDLEtBQUtuSDtLQUN0RGM7SUFGd0I7R0FJMUIwRyxzQ0FDRTFHLFlBQVlpRSxVQURhO0dBdFYzQixTQUFTNEMsYUFBY0MsTUFBTTNIO0lBQzNCYTtJQUNBQSxZQUFZOEc7SUFDWjlHLGlCQUFpQmI7R0FDbkI7R0FDQTBILHFDQUFxQ3ZCLE1BQ25DLE9BQVF0RixZQUFZc0YsS0FETTtHQUc1QnVCO2FBQXVEdkI7S0FDckQsSUFBSXlCLE9BQU96QixpQkFDUDBCO0tBQ0osSUFBVSxJQUFGL0gsT0FBT0EsSUFBSThILGlCQUFpQjlILElBQUk7TUFDdEMrSCxPQUFPRCxLQUFLOUg7TUFDWixHQUFHZSxhQUFhZ0gsTUFBTTtNQUN0QmhILGFBQWFnSCxPQUFPQzs7SUFOc0I7R0FTOUNKO2FBQXdDdkIsTUFDdEMsT0FBTyxXQUFXQSxRQUFNQSxPQUFNQSxXQUREO0dBRy9CdUI7YUFBeUN2QjtLQUN2QyxLQUFJdEYsYUFBYXNGLFNBQVN0RixlQUFnQjtNQUNoQztPQUFKZ0g7U0FBTWhIO1dBQWVSLHVCQUF1QlEsWUFBWVIsdUJBQXVCOEY7TUFDbkYsR0FBRzBCLFVBQVc7T0FDWmhILDBCQUEwQnNGO09BQzFCdEYsYUFBYXNGLFlBQVVZLFdBQVduQixxQkFBcUJpQzs7O0lBTDdCO0dBU2hDSDthQUF5Q3ZCO0tBRXZDLEdBQUdBLFlBQVk7S0FFQSxJQUFYNEIsYUFBYWxILFdBQVdzRjtLQUM1QixHQUFHdEYsYUFBYWtILGFBQWE7S0FFN0JsSCxZQUFZc0Y7S0FDWixPQUFPdEYsYUFBYXNGO0lBUlU7R0FVaEN1QjthQUF5Q3ZCLE1BQ3ZDLE9BQUd0RixZQUFZc0YsV0FBVXRGLFlBQVlzRixjQURQO0dBUWhDdUI7YUFBd0N2QixNQUFLNkIsTUFBTUM7S0FDbEMsSUFBWGpFLGFBQWFpRSxjQUFjeEQ7S0FDL0IsR0FBRzVELFlBQVlzRjtNQUFPLEdBQ2hCbkM7T0FDRnFCO1NBQXFCckIsWUFBWUMsc0NBQXNDcEQsUUFBUXNGOztPQUcvRUYscUJBQXFCRTtLQUdkLElBQVArQixTQUFTLG9CQUFvQi9CO0tBQ2pDK0IsU0FBVUEsVUFBVUE7S0FDcEIsS0FBSXJILFlBQVlxSDtNQUFRLEdBQ2xCbEU7T0FDRnFCO1NBQXFCckIsWUFBWUMsc0NBQXNDcEQsUUFBUXFIOztPQUcvRWpDLHFCQUFxQmlDO0tBR3pCLEtBQUlySCxZQUFZcUg7TUFBUSxHQUNsQmxFO09BQ0ZxQjtTQUFxQnJCLFlBQVlDLHVDQUF1Q3BELFFBQVFxSDs7T0FHaEZqQyxxQkFBcUJpQztLQUd6QnJILDBCQUEwQkEsV0FBV3NGO0lBNUJSO0dBOEIvQnVCO2FBQXdDdkIsTUFBTThCO0tBQzVDO01BQUlqRSxhQUFhaUUsY0FBY3hEO01BQzNCc0QsYUFBYzVCLGtCQUFnQnRGLFdBQVdzRjtNQUN6Q3RELFFBQVFzRixhQUFhSjtLQUN6QixLQUFJbEgsWUFBWXNGO01BQU8sR0FDakJuQztPQUNGcUI7U0FBcUJyQixZQUFZQyxzQ0FBc0NwRCxRQUFRc0Y7O09BRy9FRixxQkFBcUJFO0tBR3pCLEtBQUl0RixZQUFZc0Y7TUFBTyxHQUNqQm5DO09BQ0ZxQjtTQUFxQnJCLFlBQVlDLHVDQUF1Q3BELFFBQVFzRjs7T0FHaEZGLHFCQUFxQkU7S0FHekIsUUFBUXZELEtBQUsvQjtNQUFjLEdBQ3RCK0IsUUFBUUM7T0FBSSxHQUNUbUI7UUFDRnFCO1VBQXFCckIsWUFBWUMseUNBQXlDcEQsUUFBUXNGOztRQUVsRkYscUJBQXFCcEYsUUFBUXNGO0tBSW5DLE9BQU90RixhQUFha0g7SUE3QlM7R0ErQi9CTDthQUEwQ3ZCO0tBQ3pCLElBQVg0QixhQUFjNUIsa0JBQWdCdEYsV0FBV3NGO0tBQzdDLEtBQUl0RixZQUFZc0Y7TUFDZEYscUJBQXFCRTtLQUV2QixLQUFJdEYsWUFBWXNGLE9BQ2RGLHFCQUFxQkU7S0FFdkIsSUFBSXRELFFBQVFzRixhQUFhSix5QkFDckJLLFdBQ0F2STtLQUNKLFFBQVErQyxLQUFLL0IsYUFBYztNQUNuQixJQUFGd0gsSUFBSXpGLFFBQVFDO01BQ2hCLEdBQUd3RixPQUFNRCxLQUFLQyxNQUFPLENBQUNELEtBQUtDLGNBQWN4SSxPQUFPd0k7O0tBRWxELE9BQU94STtJQWZ3QjtHQWlCakM2SDthQUEwQ3ZCLE1BQU04QjtLQUM5QztNQUFJakUsYUFBYWlFLGNBQWN4RDtNQUUzQjVFLElBQUlnQixhQUFhc0Y7TUFDakIvQztNQUNBdEQ7S0FDSjs7Y0FDRSxHQUFJc0Q7ZUFBRyxHQUNEWTtnQkFDRnFCO2tCQUFxQnJCO2tCQUFZQyx3Q0FBd0NwRCxRQUFRc0Y7O2dCQUdqRkYscUJBQXFCRTtjQUd6QixHQUFHckcsS0FBS0QsVUFBVSxPQUFPSztjQUNmLElBQU5vSSxRQUFRekksRUFBRUM7Y0FDZEE7Y0FDQSxjQUFld0k7YUFaSTs7O2NBZWpCLEdBQUlsRjtlQUFHLEdBQ0RZO2dCQUNGcUI7a0JBQXFCckI7a0JBQVlDLHdDQUF3Q3BELFFBQVFzRjs7Z0JBR2pGRixxQkFBcUJFO2NBR3pCL0M7Y0FDQXZEO2FBVlk7SUFwQmU7R0FrQ2pDNkg7YUFBeUN2QjtLQUN2QyxHQUFHQSxZQUFhO0tBQ0QsSUFBWDRCLGFBQWFsSCxXQUFXc0Y7S0FDNUIsT0FBT3RGLGFBQWFrSDtJQUhVO0dBS2hDTDthQUF5Q3ZCO0tBQ2hDLElBQUhvQyxLQUFLMUgsYUFBYXNGO0tBQ3RCLE9BQU90RixhQUFhc0Y7S0FDcEIsT0FBT29DO0lBSHVCO0dBS2hDYjthQUF1Q3ZCLE1BQU1uRztLQUMzQyxJQUFJd0g7S0FDSixHQUFHeEgsWUFBWUE7TUFDYmlHO1FBQXFCcEYsUUFBUXNGOztLQUMvQixHQUFHbkcsVUFBVUE7TUFDWGlHO1FBQXFCcEYsUUFBUXNGOztLQUMvQnRGLFlBQVlzRjtLQUNaLEdBQUl0RixhQUFhc0YsTUFBTztNQUN0QixHQUFJdEYsWUFBWXNGO09BQU9GLHFCQUFxQnBGLFFBQVFzRjtNQUNwRCxHQUFJbkcsWUFBWUE7T0FBUWlHLHFCQUFxQnBGLFFBQVFzRjtNQUNyRHFCLE9BQU8zRyxhQUFhc0Y7TUFDcEIsR0FBR25HLFlBQVl3SDs7YUFDTnhILFNBQVU7TUFDbkJhLDBCQUEwQnNGO01BQzFCdEYsYUFBYXNGLFlBQVlZLFdBQVdSO01BQ3BDaUIsT0FBTzNHLGFBQWFzRjs7O01BRXBCRCx3QkFBeUJyRixRQUFRc0Y7S0FFbkMsV0FBV29CLFNBQVMxRyxRQUFRc0YsT0FBT3FCLE1BQU14SDtJQW5CYjtHQXNCOUIwSDthQUF1Q3ZCLE1BQU1uRztLQUMzQyxJQUFJd0g7S0FDSixHQUFHeEgsWUFBWUE7TUFDYmlHO1FBQXFCcEYsUUFBUXNGOztLQUMvQixHQUFHbkcsVUFBVUE7TUFDWGlHO1FBQXFCcEYsUUFBUXNGOztLQUMvQnRGLFlBQVlzRjtLQUNaLEdBQUl0RixhQUFhc0YsTUFBTztNQUN0QixHQUFJdEYsWUFBWXNGO09BQU9GLHFCQUFxQnBGLFFBQVFzRjtNQUNwRCxHQUFJbkcsWUFBWUE7T0FBUWlHLHFCQUFxQnBGLFFBQVFzRjtNQUNyRHFCLE9BQU8zRyxhQUFhc0Y7TUFDcEIsR0FBR25HLFlBQVl3SDs7YUFDTnhILFNBQVU7TUFDbkJhLDBCQUEwQnNGO01BQzFCdEYsYUFBYXNGLFlBQVlZLFdBQVdSO01BQ3BDaUIsT0FBTzNHLGFBQWFzRjs7O01BRXBCRCx3QkFBeUJyRixRQUFRc0Y7S0FFbkMsV0FBV29CLFNBQVMxRyxRQUFRc0YsT0FBT3FCLE1BQU14SDtJQW5CYjtHQXNCOUIwSDthQUEyQ3ZCLE1BQUt2QztLQUM5QyxJQUFJNEQ7S0FDSixHQUFHM0csYUFBYXNGO01BQU9GLHFCQUFxQnBGLFFBQVFzRjtLQUNwRCxHQUFHYixpQkFBaUIxQixVQUNsQjRELFdBQVdULFdBQVduRDtLQUN4QixHQUFHMkIsa0JBQWtCM0I7TUFDbkI0RCxXQUFXVCxXQUFXbkIscUJBQXFCaEM7YUFDckNBLG1CQUFtQjdDO01BQ3pCeUcsV0FBV1QsV0FBV3ZCLG9CQUFvQjVCO29CQUM3QkE7TUFDYjRELFdBQVdULFdBQVdyQixzQkFBc0I5QjthQUN0Q0EsaUJBQWtCO01BQ2Q7T0FBTjRFO1NBQVE1QyxxQkFBcUI3Qix3QkFBd0JIO01BQ3pENEQsV0FBV1QsV0FBV3lCOztLQUV4QixHQUFHaEIsS0FBSztNQUNOM0csMEJBQTBCc0Y7TUFDMUJ0RixhQUFhc0YsUUFBUXFCOzs7TUFFbEJ2QjtRQUFxQnBGLFFBQVFzRjtJQW5CSDtHQXNCakN1QixxQ0FBcUNBO0dBK0NyQyxTQUFTZSxhQUFhQyxJQUFHakI7SUFDdkJWLGdCQUFnQmxHLE1BQU0wRjtJQUN0QjFGLG9CQUFzQlYsR0FBSyxTQUFmO0lBQ1osR0FBR3VJLGtCQUFrQkM7S0FDbkI5SCxXQUFXOEg7WUFDTEQsa0JBQWtCQztLQUN4QjlILFdBQVc4SDttQkFDRUEsMkJBQ2I5SCxXQUFXOEg7SUFDYjlILGFBQWE0RztHQUNmO0dBQ0FnQiwyQ0FBNkMsU0FBYjtHQUNoQ0E7YUFBeUN4SCxRQUFPZ0csS0FBSUMsS0FBSW5IO0tBQ3RELEdBQUdjLFNBQVU7TUFDWDtRQUFHZCxXQUNHbUgsWUFDQUEsTUFBSW5ILE9BQU9rSDtXQUNYQSxJQUFJQyxNQUFJbkg7T0FDWkE7TUFHTSxJQUFKNkksTUFBTXJDLGtCQUFrQnhHO01BQzVCMEcsZ0JBQWdCakIsb0JBQW9CeUIsTUFBTUMsS0FBSzBCLFFBQVE3STtNQUN2RGMsU0FBUytIO01BQ1Q7O0tBRUYzQyxxQkFBcUJwRjtJQWRRO0dBZ0IvQjRIO2FBQXdDeEgsUUFBUWdHLEtBQUtDLEtBQUtuSDtLQUN4RGtHLHFCQUFxQnBGO0lBRE87R0FHOUI0SCwwQ0FDRTVILFdBQVdpRSxVQURrQjtHQ2hVVCxJQUFsQitELG9CQUFvQnpJO0dIQXhCLFNBQVMwSSxvQkFBcUJyRixLQUFPLE1BQU1BLElBQUs7R0F1Q2hELFNBQVNzRjtJQUNQRCxvQkFBb0I5RDtHQUN0QjtHR3JDQSxTQUFTZ0UsUUFBU0MsSUFBR0MsSUFBR0M7SUFDdEJ0SSxVQUFVb0k7SUFDVnBJLFVBQVVxSTtJQUNWckksVUFBVXNJO0dBQ1o7R0FDQUg7R0FDQUE7ZUFDRSxXQUFXQSxRQUFRbkksU0FBUUEsU0FBUUEsU0FEWjtHQUl6Qm1JO2FBQXVDMUk7S0FDckMsR0FBSU8sVUFBVVAsTUFBTTtLQUNwQixHQUFJTyxVQUFVUCxNQUFNO0tBQ3BCLEdBQUlPLFVBQVVQLE1BQU07S0FDcEIsR0FBSU8sVUFBVVAsTUFBTTtLQUNwQixHQUFJTyxVQUFVUCxNQUFNO0tBQ3BCLEdBQUlPLFVBQVVQLE1BQU07S0FDcEI7SUFQMkI7R0FTN0IwSTthQUFzQzFJO0tBQ3BDLElBQUk2SSxLQUFLdEksZUFDTHVJLE1BQU05STtLQUNWLEdBQUk2SSxLQUFLQyxLQUFLO0tBQ2QsR0FBSUQsS0FBS0MsS0FBSztLQUNkLEdBQUl2SSxVQUFVUCxNQUFNO0tBQ3BCLEdBQUlPLFVBQVVQLE1BQU07S0FDcEIsR0FBSU8sVUFBVVAsTUFBTTtLQUNwQixHQUFJTyxVQUFVUCxNQUFNO0tBQ3BCO0lBVDBCO0dBVzVCMEk7O0tBQ0U7TUFBSUMsT0FBT3BJO01BQ1BxSSxPQUFPckksV0FBV29JO01BQ2xCRSxPQUFPdEksV0FBV3FJO0tBQ3RCLFdBQVdGLFFBQVFDLElBQUlDLElBQUlDO0lBSkw7R0FNeEJIO2FBQWtDMUk7S0FDaEM7TUFBSTJJLEtBQUtwSSxVQUFVUDtNQUNmNEksS0FBS3JJLFVBQVVQLFFBQVEySTtNQUN2QkUsS0FBS3RJLFVBQVVQLFFBQVE0STtLQUMzQixXQUFXRixRQUFRQyxJQUFJQyxJQUFJQztJQUpMO0dBTXhCSDthQUFrQzFJO0tBQ2hDO01BQUkySSxLQUFLcEksVUFBVVA7TUFDZjRJLEtBQUtySSxVQUFVUCxRQUFRMkk7TUFDdkJFLEtBQUt0SSxVQUFVUCxRQUFRNEk7S0FDM0IsV0FBV0YsUUFBUUMsSUFBSUMsSUFBSUM7SUFKTDtHQU14Qkg7YUFBa0MxSTtLQUNoQztNQUFJMkksS0FBS3BJLFVBQVVQO01BQ2Y0SSxNQUFPRCxLQUFLSix5QkFBMEJoSSxVQUFVUCxPQUFPTyxVQUFVUDtNQUNqRTZJO1NBQU9ELEtBQUtMLHlCQUEwQmhJLFVBQVVQLE9BQU9PLFVBQVVQO1VBQU9PLFVBQVVQO0tBQ3RGLFdBQVcwSSxRQUFRQyxJQUFJQyxJQUFJQztJQUpMO0dBTXhCSDtlQUNFLFFBQVFuSSxVQUFRQSxVQUFRQSxjQURDO0dBRzNCbUkscUNBQ0UsT0FBUW5JLGtCQURnQjtHQUcxQm1JO2FBQWtDMUk7S0FDaEMsV0FBVzBJLFFBQVFuSSxVQUFVUCxNQUFNTyxVQUFVUCxNQUFNTyxVQUFVUDtJQUR2QztHQUd4QjBJO2FBQWlDMUk7S0FDL0IsV0FBVzBJLFFBQVFuSSxVQUFRUCxNQUFNTyxVQUFRUCxNQUFNTyxVQUFRUDtJQURsQztHQUd2QjBJO2FBQWtDMUk7S0FDaEMsV0FBVzBJLFFBQVFuSSxVQUFRUCxNQUFNTyxVQUFRUCxNQUFNTyxVQUFRUDtJQURqQztHQUd4QjBJO2FBQXlDN0k7S0FDdkNBLElBQUlBO0tBQ0osR0FBSUEsUUFBUSxPQUFPVTtLQUNuQixHQUFJVjtNQUFRO2NBQ0M2STtlQUFTbkksV0FBV1Y7ZUFDVlUsV0FBV1YsSUFBTVUsZ0JBQWlCVjtlQUNsQ1UsV0FBV1YsSUFBTVUsZ0JBQWlCVjtLQUV6RCxHQUFJQTtNQUNGO2NBQVc2STtrQkFDU25JLFdBQVlWLFFBQ1hVLFdBQVlWLFNBQVlVLGdCQUFpQlY7S0FDaEUsV0FBVzZJLGNBQWNuSSxXQUFZVjtJQVpSO0dBYy9CNkk7YUFBbUQ3STtLQUNqREEsSUFBSUE7S0FDSixHQUFJQSxRQUFRLE9BQU9VO0tBQ25CLEdBQUlWO01BQ0Y7Y0FBVzZJO2VBQ1JuSSxXQUFXVixJQUFNVSxnQkFBaUJWO2VBQ2xDVSxXQUFXVixJQUFNVSxnQkFBaUJWO2VBQ2xDVSxXQUFXVjtLQUNoQixHQUFJQTtNQUNGO2NBQVc2STtlQUNSbkksV0FBWVYsU0FBWVUsZ0JBQWlCVixHQUN6Q1UsV0FBWVY7S0FFakIsV0FBVzZJLFFBQVNuSSxXQUFZVjtJQWJPO0dBZXpDNkk7YUFBMEM3STtLQUN4Q0EsSUFBSUE7S0FDSixHQUFJQSxRQUFRLE9BQU9VO0tBQ2IsSUFBRndJLElBQUt4STtLQUNULEdBQUlWO01BQ0Y7Y0FBVzZJO2VBQ1JuSSxXQUFXVixJQUFNVSxnQkFBaUJWO2VBQ2xDVSxXQUFXVixJQUFNa0osVUFBV2xKO2VBQzNCVSxpQkFBa0JWO0tBQ2YsSUFBTG1KLE9BQVF6STtLQUNaLEdBQUlWO01BQ0Y7Y0FBVzZJO2VBQ1JuSSxXQUFZVixTQUFZVSxnQkFBaUJWO2VBQ3pDVSxpQkFBbUJWO2VBQ3BCbUo7S0FDSixXQUFXTixRQUFVbkksaUJBQW1CVixRQUFTbUosTUFBTUE7SUFmekI7R0FpQmhDTjs7S0FDRW5JLFVBQVdBLGVBQWlCQTtLQUM1QkEsV0FBWUEsZUFBaUJBO0tBQzdCQSxVQUFXQTtJQUhZO0dBS3pCbUk7O0tBQ0VuSSxXQUFZQSxnQkFBa0JBO0tBQzlCQSxXQUFZQSxnQkFBa0JBO0tBQzlCQSxVQUFVQTtJQUhhO0dBS3pCbUk7YUFBc0MxSTtLQUNwQztNQUFJVztNQUNBc0ksVUFBVTFJO01BQ1YySSxVQUFVbEo7TUFDVm1KLGVBQWVUO0tBQ25CLE1BQU9PLGlCQUFpQkMsYUFBYyxDQUNwQ3ZJLFVBQ0F1STtLQUVGLE1BQU92SSxZQUFhO01BQ2xCQTtNQUNBd0k7TUFDQSxHQUFJRixpQkFBaUJDLGNBQWU7T0FDbENDO09BQ0FGLFVBQVVBLFlBQVlDOztNQUV4QkE7O0tBRUYsa0JBQW9CQyxtQkFBb0JGO0lBbEJkO0dBb0I1QlA7YUFBa0NVO0tBRTFCLElBQUZwSixJQUFJTztLQUNSLEdBQUk2SSxZQUFZWDtLQUNQLElBQUxPLE9BQU9oSixPQUFPb0o7S0FDbEIsR0FBSXBKLGVBQWVBLElBQUlBO0tBQ3ZCLEdBQUlvSixlQUFlQSxJQUFJQTtLQUNqQixJQUFGQyxJQUFJckosVUFBVW9KO0tBQ2xCLEdBQUlKLGVBQWVLLElBQUlBO0tBQ3ZCLE9BQU9BO0lBVGU7R0FXeEJYO2FBQWtDVTtLQUUxQixJQUFGcEosSUFBSU87S0FDUixHQUFJNkksWUFBWVg7S0FDUCxJQUFMTyxPQUFPaEo7S0FDWCxHQUFJQSxlQUFlQSxJQUFJQTtLQUN2QixHQUFJb0osZUFBZUEsSUFBSUE7S0FDakIsSUFBRjdHLElBQUl2QyxVQUFVb0o7S0FDbEIsR0FBSUosZUFBZXpHLElBQUlBO0tBQ3ZCLE9BQU9BO0lBVGU7R0FXeEJtRyxxQ0FDRSxPQUFPbkksVUFBV0EsY0FETTtHQUcxQm1JOztLQUNFLFFBQVNuSSxpQkFBaUJULGtCQUFrQlMsVUFBVVQ7Y0FBbUJTO0lBRC9DO0dBRzVCbUk7O0tBQ0UsUUFBUW5JO2FBQ0FBO2FBQ0FBO2FBQ0NBO2FBQ0RBO2FBQ0FBO2FBQ0NBO2FBQ0RBO0lBUmtCO0dBVTVCbUk7ZUFDRSxPQUFPbkksV0FBWUEsc0JBREk7R0FHekJtSTtlQUNFLE9BQVNuSSx5QkFBNEJBLGNBRGQ7R0NoTnpCLFNBQVMrSSxVQUNQL0ksb0JBQ0Y7R0NRQSxTQUFTZ0osTUFBTXZKO0lBQ2JPLGdCQUFnQmlKLFdBQVd4SjtJQU8zQk8sY0FBY0E7R0FDaEI7R0FFQWdKO0dkNm9CQSxTQUFTRSxzQkFBc0I1SixHQUM3QixPQUFPQSxTQUNUO0dBZkEsU0FBUzZKLHVCQUF3QjdKLEdBQUdMLEdBQ2xDLE9BQU9LLGFBQWFMLEdBQ3RCO0dBaE1BLFNBQVNtSywyQkFBNEI5SjtJQUNuQyxJQUFJMkMsSUFBSWlILHNCQUFzQjVKLElBQzFCTixRQUFRNEYsV0FBVzNDLElBQ25CaEQ7SUFDSixNQUFPQSxJQUFJZ0QsR0FBR2hELEtBQUtELEVBQUVDLEtBQUtrSyx1QkFBdUI3SixHQUFFTDtJQUNuRCxPQUFPRDtHQUNUO0dBNVFBLFNBQVNxSztJQUNQNUQ7R0FDRjtHQXpCQSxTQUFTNkQsc0JBQXVCaEssR0FBR0wsR0FBR3NEO0lBRXBDQTtJQUNBLEdBQUlqRCxTQUFzQjtLQUN4QixHQUFJTCxLQUFLSyxXQUFZO01BQ25CQSxPQUFPRixvQkFBcUJtRDtNQUM1QixHQUFJdEQsU0FBU0ssS0FBS0E7TUFDbEI7O0tBRUZpRyw0QkFBNkJqRzs7SUFFL0JBLElBQUlMLEtBQUtzRDtJQUNUO0dBQ0Y7R0FpTUEsU0FBU2dILGVBQWdCakssR0FBR0wsR0FBR3NEO0lBQzdCLEdBQUl0RCxXQUFXSyxLQUFLK0o7SUFDcEIsT0FBT0Msc0JBQXVCaEssR0FBR0wsR0FBR3NEO0dBQ3RDO0dlckpBLFNBQVNpSCxTQUFTM0IsSUFBSWpCO0lBQ3BCNUcsVUFBVXlKO0lBQ1Z6SixVQUFVNkg7SUFDVjdILGFBQWE0RztHQUNmO0dBQ0E0Qyx5QkFBeUJ2RDtHQUN6QnVELGlDQUFpQ0E7R0FFakNBO2FBQXVDdEs7S0FDckMsSUFDRWMsc0JBQXNCQSxTQUFRZDtXQUN2QndLLEtBQ1B0RSxxQkFBcUJzRTtJQUpLO0dBTzlCRjs7S0FDRSxJQUNFLE9BQU94SixrQkFBa0JBO1dBQ2xCMEosS0FDUHRFLHFCQUFxQnNFO0lBSkc7R0FPNUJGO2FBQW9DcEosUUFBT2dHLEtBQUl1RCxZQUFXeks7S0FDeEQ7TUFDRSxHQUFHYztPQUNEQSxrQkFBa0JBLFNBQVNvRyxLQUFLdUQsWUFBWXpLOztPQUU1Q2Msa0JBQWtCQSxTQUFTb0csS0FBS3VELFlBQVl6SyxLQUFLa0I7O1dBQzVDc0osS0FDUHRFLHFCQUFxQnNFO0tBRXZCO0lBVHlCO0dBVzNCRjthQUFtQ3BKLFFBQU9wQixHQUFFMkssWUFBV3pLO0tBQ3JEO01BQ0UsR0FBR2M7T0FDUSxJQUFMNEosT0FBTzVKLGlCQUFpQkEsU0FBU2hCLEdBQUcySyxZQUFZeks7O09BRTNDLElBQUwwSyxPQUFPNUosaUJBQWlCQSxTQUFTaEIsR0FBRzJLLFlBQVl6SyxLQUFLa0I7TUFDM0QsT0FBT3dKOztXQUNBRixLQUNQdEUscUJBQXFCc0U7SUFSQztHQVcxQkY7O0tBQ0UsSUFDRXhKLGtCQUFrQkEsVUFDbEI7V0FDTzBKLEtBQ1B0RSxxQkFBcUJzRTtJQUxFO0dBaFEzQixTQUFTRyxhQUFhL0MsTUFDcEI5RyxVQUFVeUosZUFDVnpKLFlBQVk4RyxLQUNkO0dBQ0ErQyxxQ0FBcUN2RSxNQUNuQyxPQUFRdEYsWUFBWXNGLEtBRE07R0FHNUJ1RTthQUF5Q3ZFO0tBQ3ZDLElBQ0UsT0FBT3RGLG1CQUFtQkEsUUFBUXNGO1dBQzNCb0UsS0FDUDtJQUo0QjtHQU9oQ0c7YUFBeUN2RTtLQUN2QyxJQUNFLE9BQU90RixpQkFBaUJBLFFBQVFzRjtXQUN6Qm9FLEtBQ1B0RSxxQkFBcUJzRTtJQUpPO0dBT2hDRzthQUF3Q3ZFLE1BQU02QixNQUFNQztLQUNsRCxJQUNFcEgsa0JBQWtCQSxRQUFRc0YsY0FBWTZCLFFBQ3RDO1dBQ091QyxLQUNQMUosd0JBQXdCMEosS0FBS3RDO0lBTEY7R0FRL0J5QzthQUF3Q3ZFLE1BQU04QjtLQUM1QyxJQUNFcEgsa0JBQWtCQSxRQUFRc0YsUUFDMUI7V0FDT29FLEtBQ1AxSix3QkFBd0IwSixLQUFLdEM7SUFMRjtHQVEvQnlDO2FBQTBDdkUsTUFBTThCO0tBQzlDLElBQ0UsT0FBT3BILG9CQUFvQkEsUUFBUXNGO1dBQzVCb0UsS0FDUDFKLHdCQUF3QjBKLEtBQUt0QztJQUpBO0dBT2pDeUM7YUFBeUN2RTtLQUN2QyxJQUNFLE9BQU90RixpQkFBaUJBLFFBQVFzRjtXQUN6Qm9FLEtBQ1B0RSxxQkFBcUJzRTtJQUpPO0dBT2hDRzthQUF5Q3ZFLE1BQU04QjtLQUM3QztNQUNRLElBQUYvRSxJQUFJckMsbUJBQW1CQSxRQUFRc0Y7TUFDbkN0RixtQkFBbUJBLFFBQVFzRjtNQUMzQixPQUFPakQ7O1dBQ0FxSCxLQUNQMUosd0JBQXdCMEosS0FBS3RDO0lBTkQ7R0FTaEN5QzthQUF1Q3ZFLE1BQU1uRyxHQUFHaUk7S0FDOUMsSUFBSTBDLFNBQVNMLHNCQUNUekM7S0FDSixRQUFRK0MsT0FBTzVLO01BQUUsT0FDUjRLOztTQUNVL0MsT0FBTzhDLGlCQUFpQjs7U0FDeEI5QyxPQUFPOEMsaUJBQWlCOztTQUV2QzlDLE9BQU84QyxrQkFBa0JBLGlCQUN6Qjs7U0FDZ0I5QyxPQUFPOEMsZ0JBQW1COztTQUMxQjlDLE9BQU84QyxnQkFBbUI7O1NBQzFCOUMsT0FBTzhDLGVBQW1COztTQUMxQjlDLE9BQU84QyxpQkFBbUI7O1NBQzFCOUMsT0FBTzhDLGVBQW1COztTQUMxQjlDLE9BQU84QyxtQkFBbUI7O0tBRzlDO01BQ0U7T0FBSWpDLEtBQUs3SCxpQkFBaUJBLFFBQVFzRixPQUFPMEI7T0FDckNnRDtTQUFvQmhLLGtCQUFrQkEsUUFBUXNGO01BQ2xEbkcsc0JBQXNCNks7TUFDdEIsV0FBV1IsU0FBUzNCLElBQUkxSTs7V0FDakJ1SyxLQUNQMUosd0JBQXdCMEosS0FBS3RDO0lBeEJIO0dBNEI5QnlDO2FBQXlDSSxHQUFHbEksR0FBR3FGO0tBQzdDLElBQ0VwSCxtQkFBbUJBLFFBQVFpSyxJQUFJakssUUFBUStCO1dBQ2hDMkgsS0FDUDFKLHdCQUF3QjBKLEtBQUt0QztJQUpEO0dBT2hDeUM7YUFBdUN2RSxNQUFNOEI7S0FDM0M7TUFDZSxJQUFUOEMsV0FBV2xLLGlCQUFpQkEsUUFBUXNGO01BQ3hDLE9BQU90RixtQkFBbUJrSzs7V0FDbkJSLEtBQ1AxSix3QkFBd0IwSixLQUFLdEM7SUFMSDtHQVE5QnlDO2FBQXdDdkUsTUFBTThCO0tBQzVDO01BQ2UsSUFBVDhDLFdBQVdsSyxrQkFBa0JBLFFBQVFzRjtNQUN6QyxPQUFPdEYsbUJBQW1Ca0s7O1dBQ25CUixLQUNQMUosd0JBQXdCMEosS0FBS3RDO0lBTEY7R0FRL0J5QzthQUEwQ00sUUFBUUMsUUFBUTdHLE1BQU02RDtLQUM5RDtNQUNFcEg7UUFBb0JBLFFBQVFvSyxTQUFTcEssUUFBUXVELE9BQU80RztNQUNwRDs7V0FDT1QsS0FDUDFKLHdCQUF3QjBKLEtBQUt0QztJQUxBO0dBUWpDeUM7YUFBMkN2RSxNQUFNOEI7S0FDL0M7TUFDVyxJQUFMaUQsT0FBT3JLLHFCQUFxQkEsUUFBUXNGO01BQ3hDLE9BQU9wQyx3QkFBd0JtSDs7V0FDeEJYLEtBQ1AxSix3QkFBd0IwSixLQUFLdEM7SUFMQztHQVFsQ3lDO2FBQTBDdkUsTUFBTThCO0tBQzlDLElBQ0UsT0FBT3BILG9CQUFvQkEsUUFBUXNGO1dBQzVCb0UsS0FDUDFKLHdCQUF3QjBKLEtBQUt0QztJQUpBO0dBT2pDeUM7YUFBcURILEtBQUt0QztLQUN6QyxJQUFYakUsYUFBYVM7S0FDakIsR0FBSXdELGNBQWNqRSxXQUFZO01BQ25CO09BQUxPLE9BQU9OLG1CQUFtQnNHLFVBQVVBLGFBQWFBLFVBQVVBO01BQy9EbEYscUJBQXFCckIsWUFBWU87OztNQUVqQzBCLHFCQUFxQnNFO0lBTm1CO0dBUzVDRzthQUFnREs7S0FXOUMsSUFBSUk7S0FDSixHQUFJSjtNQUNGSTthQUNTSjtNQUNUSTthQUNTSjtNQUNUSTthQUNTSjtNQUNUSTthQUNTSjtNQUNUSTthQUNTSjtNQUNUSTthQUNTSixxQkFDVEk7S0FrQkY7YUFFRUo7YUFDQUE7YUFDQUk7YUFDQUo7YUFDQUE7YUFDQUE7YUFDQUE7YUFDQUE7YUFDQUE7YUFDQUE7YUFDQUE7YUFDQUE7SUF4RG1DO0dBNER2Q0wscUNBQXFDQTtHYjhUckMsSUFBSVU7R0FDSixVQUFXdkc7SUFDVHVHO0tBQWdCO09BRWQsU0FBU0MsWUFBWUMsTUFBUXpLLFlBQVl5SyxLQUFNO09BQy9DRDtpQkFBcUM5SDtTQUNuQyxJQUFXLElBQUZ6RCxPQUFPQSxJQUFJZSxrQkFBa0JmO1VBQUssR0FDckNlLFVBQVVmLE9BQU95RCxHQUFHLE9BQU96RDtRQUZQO09BSzVCdUwsdUNBQTRCO09BSTVCO1FBQ0V4SztRQUFnQkEsa0JBQWtCd0ssWUFBWXhLLFdBRHpDO01BWk87OztJQWtCaEJ1SztnQkFDRXZLLGdCQUFnQkEsa0JBQWtCZ0UsaUJBRHBCO0dBS2xCdUc7YUFBeUM3SCxHQUN2QzFDLGdCQUFnQjBDLEdBQUcxQyxtQkFDbkJBLGVBQWUwQyxHQUZlO0dBS2hDNkg7YUFBMEM3SDtLQUNsQyxJQUFGekQsSUFBSWUsZ0JBQWdCMEM7S0FDeEIsT0FBUXpELE1BQU1nRixZQUNWQSxZQUFZakUsbUJBQW1CZjtJQUhKO0dBL2VqQyxTQUFTeUwsZUFBZ0JwTCxHQUFHTDtJQUFLZSxTQUFTOEUsdUJBQXVCeEY7SUFBSVUsU0FBU2Y7R0FBRztHQUNqRnlMO3dCQUN1QixPQUFPMUssa0JBQWtCQSxVQUF2Qzt3QkFDYyxPQUFPQSxrQkFBa0JBLHNCQUF2Qzs7O01BRUwsSUFBSVYsSUFBSVUsUUFBUWYsSUFBSWU7TUFDcEJBLFNBQVNmO01BQ1QsT0FBUUssYUFBYUwsVUFBV0ssYUFBYUw7S0FIdkM7OztNQU1OLElBQUlLLElBQUlVLFFBQVFmLElBQUllO01BQ3BCQSxTQUFTZjtNQUNULE9BQVFLLGFBQWFMLGlCQUFrQkssYUFBYUw7S0FIOUM7OztNQU1OLElBQUlLLElBQUlVLFFBQVFmLElBQUllO01BQ3BCQSxTQUFTZjtNQUNULFFBQVNLLGFBQWFMLFdBQWFLLGFBQWFMO2VBQ3ZDSyxhQUFhTDtlQUFhSyxhQUFhTDs7S0FKMUM7OztNQU9OLElBQUlLLElBQUlVLFFBQVFmLElBQUllO01BQ3BCQSxTQUFTZjtNQUNULE9BQVFLLGFBQWFMLFdBQWFLLGFBQWFMO2VBQzVDSyxhQUFhTDtlQUFhSyxhQUFhTDtLQUpwQzs7Y0FNVUM7TUFDVixJQUFGRCxJQUFJZTtNQUNSQSxTQUFTZixJQUFJQztNQUNiLE9BQU9NLHVCQUF1QlEsaUJBQWlCZixHQUFHQSxJQUFJQztLQUhoRDs7Y0FLaUJBO01BQ3ZCLElBQUltRCxRQUFRdUMsV0FBVzFGLE1BQ25CSSxJQUFJVSxRQUNKZixJQUFJZTtNQUNSLElBQVUsSUFBRkcsT0FBT0EsSUFBSWpCLEtBQUtpQixLQUN0QmtDLEVBQUVsQyxLQUFLYixhQUFhTCxJQUFJa0I7TUFFMUJILFNBQVNmLElBQUlDO01BQ2IsT0FBT21EO0tBUk07R1VzT2pCLFNBQVNzSSx3QkFBd0J2QyxJQUFJRTtJQUNuQztZQUFXSDthQUNUQzthQUNFQSxvQkFBdUJFO2FBQ3hCQTtHQUNMO0dBS0EsU0FBU3NDLGdCQUFnQmxJLEdBQUksT0FBT0EsU0FBUztHQUg3QyxTQUFTbUksZ0JBQWdCbkksR0FBSSxPQUFPQSxTQUFTO0dIalM3QyxTQUFTb0k7SUFDUHJGO0dBQ0Y7R1JVd0IsSUFBcEJzRjtHQUtKLFNBQVNDLFlBQWFDLE1BQU1DLFFBQVFDLE1BQU1DO0lBRXhDcEwsWUFBY2lMO0lBQ2RqTCxjQUFja0w7SUFDZGxMLFlBQWNtTDtJQUNkbkwsWUFBWW9MO0dBQ2Q7R0FFQUosb0NBQW9DRDtHQUVwQ0M7YUFBeUMvRjtLQUMvQixJQUFKb0c7S0FDSixVQUFVcEcsa0JBQWtCQSxPQUFPQTtLQUNuQyxNQUFPQSxlQUFlL0U7TUFBUXVGO0tBQzlCLEdBQUl6RixvQkFBb0JpRjtNQUN0QlE7S0FDRixHQUFHekY7TUFBaUMsSUFDdkIsSUFBRmYsT0FBT0EsSUFBSWUsa0JBQWtCZixJQUFLO09BQ3pDLEdBQUlnRyxJQUFJaEcsVUFBVWdHLElBQUloRyxNQUFNZSxVQUFVZixJQUNwQzZMO09BQ0ZPLE1BQU9BLE1BQU1yTCxVQUFVZixLQUFNZ0csSUFBSWhHOzs7TUFFOUIsSUFDTSxJQUFGQSxJQUFJZSxzQkFBc0JmLFFBQVFBLElBQUs7T0FDOUMsR0FBSWdHLElBQUloRyxVQUFVZ0csSUFBSWhHLEtBQUtlLFVBQVVmLElBQ25DNkw7T0FFRk8sTUFBT0EsTUFBTXJMLFVBQVVmLE1BQU9nRyxJQUFJaEc7O0tBR3RDLE9BQU9vTTtJQXBCc0I7R0F1Qi9CTDthQUFzQ0s7S0FDcEMsT0FBT3JMOztRQUdMLElBQUlpQyxJQUFJakMsVUFBVXFMLGNBQ2Q3QyxJQUFJeEksVUFBVXFMO1FBQ2xCLE9BQU9WLHdCQUF3QjFJLEdBQUV1Rzs7O1FBR2pDLElBQUl4RyxJQUFJaEMsVUFBVXFMLGNBQ2RwTSxJQUFJZSxVQUFVcUw7UUFDbEIsYUFBYXJKLEdBQUcvQztnQkFFaEIsT0FBT2UsVUFBVXFMOztJQWJPO0dBaUI1Qkw7YUFBc0NLLEtBQUkzSTtLQUN4QyxPQUFPMUM7O1FBR0xBLFVBQVVxTCxlQUFlUixnQkFBZ0JuSTtRQUN6QzFDLFVBQVVxTCxlQUFlVCxnQkFBZ0JsSTtRQUN6Qzs7O1FBR0ExQyxVQUFVcUwsZUFBZTNJLE1BQ3pCMUMsVUFBVXFMLGVBQWUzSSxNQUN6QjtnQkFFQTFDLFVBQVVxTCxPQUFPM0ksR0FDakI7O0tBRUY7SUFoQjBCO0dBb0I1QnNJO2FBQXVDdEk7S0FDckMsT0FBTzFDOztRQUdMLElBQUloQixJQUFJNkwsZ0JBQWdCbkksSUFDcEJMLElBQUl1SSxnQkFBZ0JsSTtRQUN4QixHQUFHMUQsS0FBS3FEO1NBQ05yQyxlQUFlaEI7O1NBRVosSUFDTyxJQUFGQyxPQUFPQSxJQUFFZSxrQkFBa0JmO1VBQ2pDZSxVQUFVZixLQUFNQSxhQUFZRCxJQUFJcUQ7UUFHcEM7OztRQUdBLElBQUlpSixLQUFLNUksTUFDTDZJLEtBQUs3STtRQUNULEdBQUc0SSxNQUFNQztTQUNQdkwsZUFBZXNMOztTQUVaLElBQ08sSUFBRnJNLE9BQU9BLElBQUVlLGtCQUFrQmY7VUFDakNlLFVBQVVmLEtBQU1BLGFBQVlxTSxLQUFLQztRQUdyQztnQkFFQXZMLGVBQWUwQyxJQUNmOztJQTlCeUI7R0FtQzdCc0k7YUFBMEMzSSxHQUFHbUo7S0FDM0MsR0FBSXhMLGVBQWVxQyxZQUFZckMsYUFBYXFDLE9BQVE7TUFDbEQsSUFBSW9KLEtBQUt6TCxZQUFhQSxrQkFDbEIwTCxLQUFRckosU0FBVUE7TUFDdEIsT0FBT3FKLEtBQUtEOztLQUVkLEdBQUl6TCxvQkFBb0JxQztNQUFlLE9BQzlCQSxnQkFBZ0JyQztLQUV6QixJQUFXLElBQUZmLE9BQU9BLElBQUllLGtCQUFrQmY7TUFDcEMsR0FBSWUsVUFBVWYsTUFBTW9ELE9BQU9wRCxJQUN6QixPQUFRZSxVQUFVZixLQUFLb0QsT0FBT3BEO0tBQ2xDLE9BQVFlOzs7OztRQU1OLElBQUlQLEdBQUdvSjtRQUNQLElBQVcsSUFBRjVKLE9BQU9BLElBQUllLGtCQUFrQmYsSUFBSztTQUN6Q1EsSUFBSU8sVUFBVWY7U0FDZDRKLElBQUl4RyxPQUFPcEQ7U0FDWCxHQUFJUSxJQUFJb0osR0FDTjtTQUNGLEdBQUlwSixJQUFJb0osR0FDTjtTQUNGLEdBQUlwSixLQUFLb0osRUFBRztVQUNWLEtBQUsyQyxPQUFPLE9BQU9HO1VBQ25CLEdBQUlsTSxLQUFLQSxHQUFHO1VBQ1osR0FBSW9KLEtBQUtBLEdBQUc7OztRQUdoQjs7UUFHQSxJQUFXLElBQUY1SixPQUFPQSxJQUFJZSxrQkFBa0JmLE9BQU07U0FFMUMsR0FBSWUsVUFBVWYsU0FBT29ELE9BQU9wRCxRQUMxQjtTQUNGLEdBQUllLFVBQVVmLFNBQU9vRCxPQUFPcEQsUUFDMUI7U0FDRixHQUFLZSxVQUFVZixXQUFhb0QsT0FBT3BELFVBQ2pDO1NBQ0YsR0FBS2UsVUFBVWYsV0FBYW9ELE9BQU9wRCxVQUNqQzs7UUFFSjs7Ozs7Ozs7O1FBU0EsSUFBVyxJQUFGQSxPQUFPQSxJQUFJZSxrQkFBa0JmLElBQUs7U0FDekMsR0FBSWUsVUFBVWYsS0FBS29ELE9BQU9wRCxJQUN4QjtTQUNGLEdBQUllLFVBQVVmLEtBQUtvRCxPQUFPcEQsSUFDeEI7O1FBRUo7O0tBRUY7SUEvRDhCO0dBb0VoQyxTQUFTMk0sa0JBQWtCWCxNQUFNQyxRQUFRQyxNQUFNQztJQUM3Q3BMLFlBQWNpTDtJQUNkakwsY0FBY2tMO0lBQ2RsTCxZQUFjbUw7SUFDZG5MLFlBQWNvTDtHQUNoQjtHQUVBUSxrQ0FBa0NaO0dBQ2xDWTthQUErQzNHO0tBQzdDLFVBQVVBO01BQWlCLEdBQ3JCQSxlQUFlL0UsU0FBVStFO09BQzNCQSxNQUFNQTs7T0FDSFE7S0FFUCxHQUFJUixXQUFXQSxPQUFPakYsY0FDcEI4SztLQUNGLE9BQU83RjtJQVI0QjtHQVdyQzJHLDJDQUE0Q1AsS0FDMUMsT0FBT3JMLFVBQVVxTCxLQURlO0dBSWxDTzthQUE0Q1AsS0FBSTNJLEdBQzlDMUMsVUFBVXFMLE9BQU8zSSxHQUNqQixTQUZnQztHQUtsQ2tKO2FBQTZDbEosR0FDM0MxQyxlQUFlMEMsSUFDZixTQUZpQztHRXRSbkMsU0FBU21KLGtCQUFrQkMsV0FBV0M7SUFDcEMsY0FBZUQsd0JBQTJCQSxxQkFBc0JDO0dBQ2xFO0dBR0EsU0FBU0MsYUFBYUMsVUFBVUY7SUFDOUIsY0FBZUUsdUJBQXlCQSxjQUFjRjtHQUN4RDtHSnVMQTtJQUFJRztJSXdMQUM7O09BQW9CM0w7VUFDckIwTDtVQUNBQTtVQUNBQTtVQUNBQTtHQUdILFNBQVNFLFdBQVdDLFFBQ2xCLE9BQU9GLGtCQUFrQkUsUUFDM0I7R0wvWEE7SUFBSUM7SUNzTUFDO0lJbU9BQzs7T0FBbUJoTTtVQUNwQitMLGlCQUFtQkQ7VUFDbkJDLGtCQUFtQkQ7VUFDbkJDLG1CQUFtQkQ7R0FHdEIsU0FBU0csVUFBVUMsT0FDakIsT0FBT0YsaUJBQWlCRSxPQUMxQjtHRHpZQSxTQUFTQyxpQkFBa0JyTixHQUFHTCxHQUFLZSxTQUFTVixHQUFHVSxTQUFTZixFQUFHO0dBQzNEME47d0JBQ3VCLE9BQU8zTSxPQUFPQSxVQUE1Qjt3QkFDYyxPQUFPQSxPQUFPQSxzQkFBNUI7OztNQUVMLElBQUlWLElBQUlVLFFBQVFmLElBQUllO01BQ3BCQSxTQUFTZjtNQUNULE9BQVFLLEVBQUVMLFVBQVdLLEVBQUVMO0tBSGpCOzs7TUFNTixJQUFJSyxJQUFJVSxRQUFRZixJQUFJZTtNQUNwQkEsU0FBU2Y7TUFDVCxPQUFRSyxFQUFFTCxpQkFBa0JLLEVBQUVMO0tBSHhCOzs7TUFNTixJQUFJSyxJQUFJVSxRQUFRZixJQUFJZTtNQUNwQkEsU0FBU2Y7TUFDVCxRQUFTSyxFQUFFTCxXQUFhSyxFQUFFTCxlQUNqQkssRUFBRUwsY0FBYUssRUFBRUw7S0FKcEI7OztNQU9OLElBQUlLLElBQUlVLFFBQVFmLElBQUllO01BQ3BCQSxTQUFTZjtNQUNULE9BQVFLLEVBQUVMLFdBQWFLLEVBQUVMLGVBQ3RCSyxFQUFFTCxjQUFhSyxFQUFFTDtLQUpkOztjQU1VQztNQUNWLElBQUZELElBQUllO01BQ1JBLFNBQVNmLElBQUlDO01BQ2IsT0FBT1EscUJBQXFCTSxnQkFBZ0JmLEdBQUdBLElBQUlDO0tBSDdDOztjQUtpQkE7TUFDakIsSUFBRkQsSUFBSWU7TUFDUkEsU0FBU2YsSUFBSUM7TUFDYixPQUFPYyxnQkFBZ0JmLEdBQUdBLElBQUlDO0tBSGpCO0dDcVFDO0lBQWQwTjs7T0FBb0JwTTtVQUNyQjdCLGFBQW1CRztVQUNuQkgsYUFBbUJHO1VBQ25CSCxlQUFtQkc7VUFDbkJILGVBQW1CRztVQUNuQkgsaUJBQW1CRztVQUNuQkgsbUJBQW1CRztHQUd0QixTQUFTK04sV0FBV0MsUUFDbEIsT0FBT0Ysa0JBQWtCRSxRQUMzQjtHQUt3QjtJQUFwQkM7O09BQTBCdk07VUFDM0I1QixpQkFBbUJDO1VBQ25CRCxtQkFBbUJDO0dBR3RCLFNBQVNtTyxpQkFBaUJDLE9BQ3hCLE9BQU9GLHdCQUF3QkUsT0FDakM7R0E2R29CO0lBQWhCQzs7T0FBc0IxTTtrQkFDYkg7b0JBQ0FBO21CQUNBQTtHQUdiLFNBQVM4TSxhQUFhek0sS0FDcEIsT0FBT3dNLG9CQUFvQnhNLEtBQzdCO0dBa0JrQjtJQUFkME07O09BQW9CNU07eUJBQ0RGO3VCQUNBQTt3QkFDQUE7eUJBQ0FBOzhCQUNBQTs0QkFDQUE7NkJBQ0FBOzhCQUNBQTtxQkFDQUE7a0JBQ0FBO2lCQUNBQTtzQkFDQUE7b0JBQ0FBO3FCQUNBQTtvQkFDQUE7cUJBQ0FBO3lCQUNBQTt3QkFDQUE7d0JBQ0FBO3dCQUNBQTt3QkFDQUE7dUJBQ0FBO2lCQUNBQTt3QkFDQUE7bUJBQ0FBO3dCQUNBQTtHQUd2QixTQUFTK00sV0FBV0MsUUFDbEIsT0FBT0Ysa0JBQWtCRSxRQUMzQjtHYXlmQSxTQUFTQyxjQUFjdE87SUFDZixJQUFGRCxLQUFNQztJQUNWLEdBQUlELFVBQVUsYUFDQyxDQUFDQztJQUVoQjtLQUFJb0QsSUFBSXBEO0tBQ0p1TyxLQUFLdk87S0FDTCtDLEtBQUsvQztJQUNULGlCQUFpQitDLFVBQVV3TCxVQUFVbkwsVUFBVXJEO0dBQ2pEO0dieG9CQSxTQUFTeU8sZUFBZTFNO0lBQ2hCLElBQUZ6QjtJQUNKLE9BQVF5QjtXQUNERjtPQUNIdkIsSUFBSWlPLGNBQWN4TSxXQUNsQjtXQUNHRjtXQUNBQSxtQkFDSHZCLElBQUl5QixVQUNKO2VBRUE7O0lBRUosT0FBT3pCO0dBQ1Q7R0FyWWlCO0lBQWJvTzs7T0FBbUJsTjtVQUNwQlMsV0FBV0MsaUJBQ1hELFVBQVdDO0dBR2QsU0FBU3lNLGlCQUFpQkMsT0FDeEIsT0FBT0YsaUJBQWlCRSxPQUMxQjtHQW1hcUI7SUFBakJDOztPQUF1QnJOO21CQUNmVzttQkFDQUE7bUJBQ0FBO0dBR1osU0FBUzJNLGNBQWN4TSxNQUNyQixPQUFPdU0scUJBQXFCdk0sTUFDOUI7R0F0YWM7SUFBVnlNOztPQUFnQnZOO1VBQ2pCZSxZQUEwQkc7VUFDMUJILFFBQTBCRztVQUMxQkgsUUFBMEJHO1VBQzFCSCxRQUEwQkc7VUFDMUJILFFBQTBCRztVQUMxQkgsUUFBMEJHO1VBQzFCSCxRQUEwQkc7VUFDMUJILFFBQTBCRztVQUMxQkgsUUFBMEJHO1VBQzFCSCxRQUEwQkc7VUFDMUJILFNBQTBCRztVQUMxQkgsU0FBMEJHO1VBQzFCSCxTQUEwQkc7VUFDMUJILGlCQUEwQkc7VUFDMUJILGdCQUEwQkc7VUFDMUJILFdBQTBCRztVQUMxQkgsaUJBQTBCRztVQUMxQkgsb0JBQTBCRztVQUMxQkgsV0FBMEJHO1VBQzFCSCxlQUEwQkc7VUFDMUJILGVBQTBCRztVQUMxQkgsZ0JBQTBCRztVQUMxQkgsY0FBMEJHO1VBQzFCSCxrQkFBMEJHO1VBQzFCSCxpQkFBMEJHO1VBQzFCSCxxQkFBMEJHO1VBQzFCSCxxQkFBMEJHO1VBQzFCSCxzQkFBMEJHO1VBQzFCSCxnQkFBMEJHO1VBQzFCSCxlQUEwQkc7VUFDMUJILFNBQTBCRztVQUMxQkgsT0FBMEJHO1VBQzFCSCxPQUEwQkc7VUFDMUJILE9BQTBCRztVQUMxQkgsT0FBMEJHO1VBQzFCSCxPQUEwQkc7VUFDMUJILE9BQTBCRztVQUMxQkgsT0FBMEJHO1VBQzFCSCxPQUEwQkc7VUFDMUJILE9BQTBCRztVQUMxQkgsT0FBMEJHO1VBQzFCSCxvQkFBMEJHO1VBQzFCSCxvQkFBMEJHO1VBQzFCSCxvQkFBMEJHO1VBQzFCSCxjQUEwQkc7VUFDMUJILE9BQTBCRztVQUMxQkgsT0FBMEJHO1VBQzFCSCxPQUEwQkc7VUFDMUJILE9BQTBCRztVQUMxQkgsT0FBMEJHO1VBQzFCSCxPQUEwQkc7VUFDMUJILE9BQTBCRztVQUMxQkgsT0FBMEJHO1VBQzFCSCxPQUEwQkc7VUFDMUJILHFCQUEwQkc7VUFDMUJILHVCQUEwQkc7VUFDMUJILHdCQUEwQkc7VUFDMUJILFlBQTBCRztVQUMxQkgsWUFBMEJHO1VBQzFCSCwwQkFBMEJHO1VBQzFCSCxPQUEwQkc7VUFDMUJILE9BQTBCRztVQUMxQkgsT0FBMEJHO1VBQzFCSCxPQUEwQkc7VUFDMUJILE9BQTBCRztVQUMxQkgsT0FBMEJHO1VBQzFCSCxPQUEwQkc7VUFDMUJILGdCQUEwQkc7VUFDMUJILG9CQUEwQkc7VUFDMUJILG9CQUEwQkc7VUFDMUJILFlBQTBCRztVQUMxQkgsY0FBMEJHO1VBQzFCSCxXQUEwQkc7VUFDMUJILFVBQTBCRztVQUMxQkgsY0FBMEJHO1VBQzFCSCxVQUEwQkc7VUFDMUJILFdBQTBCRztVQUMxQkgsVUFBMEJHO1VBQzFCSCxjQUEwQkc7VUFDMUJILFlBQTBCRztVQUMxQkgsVUFBMEJHO1VBQzFCSCxZQUEwQkc7VUFDMUJILG1CQUEwQkc7VUFDMUJILFNBQTBCRztVQUMxQkgsY0FBMEJHO1VBQzFCSCxhQUEwQkc7VUFDMUJILGVBQTBCRztVQUMxQkgsZUFBMEJHO1VBQzFCSCxnQkFBMEJHO1VBQzFCSCx1QkFBMEJHO1VBQzFCSCxnQkFBMEJHO1VBQzFCSCxnQkFBMEJHO1VBQzFCSCxrQkFBMEJHO1VBQzFCSCxlQUEwQkc7VUFDMUJILGdCQUEwQkc7VUFDMUJILG1CQUEwQkc7VUFDMUJILGtCQUEwQkc7VUFDMUJILGNBQTBCRztVQUMxQkgscUJBQTBCRztVQUMxQkgsV0FBMEJHO1VBQzFCSCxzQkFBMEJHO1VBQzFCSCxlQUEwQkc7VUFDMUJILGVBQTBCRztVQUMxQkgscUJBQTBCRztVQUMxQkgsb0JBQTBCRztVQUMxQkgsa0JBQTBCRztVQUMxQkgsd0JBQTBCRztVQUMxQkgsZUFBMEJHO1VBQzFCSCxTQUEwQkc7VUFDMUJILFNBQTBCRztVQUMxQkgsU0FBMEJHO1VBQzFCSCxTQUEwQkc7VUFDMUJILFNBQTBCRztVQUMxQkgsU0FBMEJHO1VBQzFCSCxTQUEwQkc7VUFDMUJILFNBQTBCRztVQUMxQkgsU0FBMEJHO1VBQzFCSCxTQUEwQkc7VUFDMUJILFNBQTBCRztVQUMxQkgsU0FBMEJHO1VBQzFCSCxvQkFBMEJHO1VBQzFCSCxvQkFBMEJHO1VBQzFCSCxvQkFBMEJHO1VBQzFCSCxvQkFBMEJHO1VBQzFCSCxvQkFBMEJHO1VBQzFCSCxvQkFBMEJHO1VBQzFCSCxvQkFBMEJHO1VBQzFCSCxvQkFBMEJHO1VBQzFCSCxvQkFBMEJHO1VBQzFCSCxXQUEwQkc7VUFDMUJILFdBQTBCRztVQUMxQkgsV0FBMEJHO1VBQzFCSCxXQUEwQkc7VUFDMUJILFdBQTBCRztVQUMxQkgsVUFBMEJHO1VBQzFCSCxVQUEwQkc7VUFDMUJILGNBQTBCRztVQUMxQkgsZ0JBQTBCRztHQUc3QixTQUFTc00sYUFBYW5NLFNBQ3BCLE9BQU9rTSxjQUFjbE0sU0FDdkI7R0F5SnFCO0lBQWpCb007O09BQXVCek47VUFDeEJnQixjQUFnQkM7VUFDaEJELGdCQUFnQkM7R0FHbkIsU0FBU3lNLGNBQWNqQixPQUNyQixPQUFPZ0IscUJBQXFCaEIsT0FDOUI7R0FpQ2tCO0lBQWRrQjs7T0FBb0IzTjt1QkFDUjBMO3NCQUNBQTtzQkFDQUE7b0JBQ0FBO0dBR2hCLFNBQVNrQyxXQUFXL0IsUUFDbEIsT0FBTzhCLGtCQUFrQjlCLFFBQzNCO0dhbFVBLFNBQVNnQyxvQkFBb0JDO0lBQ3pCLGdCQUFrQkEsd0JBQXdCQTtvQkFDeEJBLHlCQUF5QkE7R0FFL0M7R0FuQlcsSUFBUEMsU0FBU2xQO0dKME9iLFNBQVNtUCxvQkFBcUIvTztJQUM1QixHQUFJQSxPQUFPQSxJQUFJRixVQUFVRTtJQUN6QjtZQUFXMEk7YUFDVDFJO2FBQ0FGLFdBQVdFLElBQUl1STthQUNmekksV0FBV0UsSUFBSXVJLG9CQUFvQkE7R0FDdkM7R0l1eUNBO0lBQUl5Ryw0QkFBNEJwUDtJQU01QnFQLHlCQUF5QnJQO0lBempEekJzUDtHQUtKLFNBQVNDO0lBQ1AsR0FBSUQ7S0FDRjFHLG9CQUFvQnJFO0dBRXhCO0dBNmlEOEIsSUFBMUJpTCw0QkFBNEJ4UDtHQW9DaEMsU0FBU3lQO0lBQ1BGO0lBQ0FILDRCQUE0QnBQO0lBQzVCLEdBQUlxUCwyQkFBMkJyUCxLQUFNO0tBQzNCLElBQUpnRixNQUFNcUs7S0FDVkcsNEJBQTRCeFA7S0FDNUJxUCx5QkFBeUJyUDtLQUN6QixNQUFPZ0Y7O1lBQ0V3Syw4QkFBOEJ4UDtLQUFNLElBRTNDd1AsNkJBQ0FBLDRCQUE0QnhQO1dBQ3JCZ0YsS0FDUHdLLDRCQUE0QnhQLE1BQzVCLE1BQU9nRjtJQUdYO0dBQ0Y7R0EvQ0EsU0FBUzBLLHlCQUF5QkM7SUFDaEMsR0FBSVAsOEJBQThCcFAsTUFBTTtJQUd4QyxJQUNFb1AsMEJBQTBCTyxVQUMxQjtVQUNPM0ssS0FDUHFLLHlCQUF5QnJLLEtBQ3pCeUssa0JBQ0E7R0FFSjtHQTc0Q0EsU0FBU0csZUFBZUM7SUFDVCxJQUFUQyxXQUFXQztJQUNmLElBQVcsSUFBRm5RLE9BQU9BLElBQUlrUSxtQkFBbUJsUSxFQUFHO0tBQ2hDO01BQUpvUTtTQUFPck87YUFDSW1PLFNBQVNsUSxXQUNadVAsb0JBQW9CVTtLQUNoQ0gseUJBQXlCTTs7SUFFM0JDLDZCQUE2Qkw7R0FDL0I7R0F0S1UsSUFBTk0sZ0NBRU1sUTtHQXF6QlYsU0FBU21RLGVBQWVDO0lBQ3RCLEdBQUlBLGlCQUFpQnBRLEtBQU07S0FDekIsR0FBSWtQLFdBQVdrQixRQUNibEIsU0FBU2xQO0tBRVhvUTs7SUFFRjtHQUNGO0dBSUEsU0FBU0MsZ0JBQWdCRDtJQUN2QixHQUFJQSxpQkFBaUJwUSxLQUFNO0tBQ3pCbVEsZUFBZUM7S0FDZkEsY0FBY3BRO0tBQ2QsR0FBSW9RLGtCQUFrQnBRLEtBQU07TUFDMUJvUSx3QkFBd0JwUTtNQUN4QixHQUFJb1EsOEJBQThCcFE7T0FDaENvUSxzQ0FBc0NBOztLQUcxQyxHQUFJQSxpQkFBaUJwUSxLQUFNO01BQ3pCb1EsdUJBQXVCcFE7TUFDdkIsR0FBSW9RLDZCQUE2QnBRO09BQy9Cb1EscUNBQXFDQTtNQUV2Q0EsZ0JBQWdCcFE7O0tBRWxCLEdBQUlvUSxpQkFBaUJwUSxLQUFNO01BQ3pCb1Esc0JBQXNCcFE7TUFDdEIsR0FBSW9RLDRCQUE0QnBRO09BQzlCb1Esb0NBQW9DQTtNQUV0Q0EsZUFBZXBROzs7SUFHbkI7R0FDRjtHQXB5QkEsU0FBU3NRLHFCQUFxQnJCO0lBQzVCLEdBQUlBLGFBQWFqUCxLQUFNO0tBQ3JCa1AsU0FBU0Q7S0FDVDtPQUFLQSxhQUFhQTtVQUNiQSxhQUFhQTtVQUNiQTtVQUFxQkEsZ0JBQWtCO01BQ2xDO09BQUplO1VBQU9yTztjQUNJc04saUJBQ0hFLG9CQUFvQkY7TUFDaENTLHlCQUF5Qk07TUFDekJLLGdCQUFnQnBCO01BQ2hCQyxTQUFTbFA7TUFDVDs7S0FFRmtRO0tBQ0FBLGVBQWVqQjtLQUNmaUIsZUFBZWpCO0tBQ2ZpQixlQUFlakI7S0FDZkEsb0NBQW9DaUIsY0FBY2xROztJQUVwRDtHQUNGO0dBNjVCQSxTQUFTdVEsY0FBY3JOO0lBQ3JCLEdBQUlBO0tBQWEsT0FDUnNOLFNBQVN0TixZQUFZQTtRQUN2QjtLQUNMO01BQUl1TixPQUFPdk47TUFDUFAsSUFBSTZOLFNBQVNDO01BQ2J0QyxJQUFJcUMsU0FBU0M7TUFDYnpOLElBQUl3TixTQUFTQztNQUNiOVEsSUFBSStRLFdBQVdEO0tBQ25CLE9BQU96TixJQUFLbUwsU0FBV3hMLFVBQVloRDs7R0FFdkM7R0FwZ0NBO0lBQUlnUixtQkFBbUJaO0lBSW5CYSxpQkFBaUJEO0lDeEJqQkU7O09BQWUxUDtjQUNHZTswQkFDQUE7b0JBRUFBO2dCQUNBQTtnQkFDQUE7Z0JBQ0FBO2dCQUNBQTtnQkFDQUE7Z0JBQ0FBO2dCQUNBQTtnQkFDQUE7Z0JBQ0FBO2lCQUNBQTtpQkFDQUE7aUJBQ0FBO3lCQUVBQTt3QkFDQUE7bUJBQ0FBO3VCQUVBQTtvQkFDQUE7b0JBQ0FBO29CQUNBQTtvQkFDQUE7b0JBQ0FBO29CQUNBQTtvQkFDQUE7b0JBQ0FBO29CQUNBQTtvQkFDQUE7bUJBQ0FBO21CQUNBQTtxQkFDQUE7dUJBQ0FBO2lCQUVBQTtrQkFDQUE7a0JBQ0FBO2tCQUNBQTtrQkFDQUE7a0JBQ0FBO2tCQUNBQTtrQkFDQUE7a0JBQ0FBO2tCQUNBQTtrQkFDQUE7eUJBQ0FBOzBCQUNBQTt1QkFDQUE7c0JBRUFBO2tCQUNBQTtrQkFDQUE7a0JBQ0FBO2tCQUNBQTtrQkFDQUE7a0JBQ0FBO2tCQUNBQTtrQkFDQUE7a0JBQ0FBO3VCQUNBQTttQkFDQUE7bUJBRUFBO3VCQUVBQTsyQkFDQUE7a0JBQ0FBO2tCQUNBQTtrQkFDQUE7a0JBQ0FBO2tCQUNBQTtrQkFDQUE7a0JBQ0FBO21CQUNBQTtvQkFDQUE7bUJBQ0FBO29CQUNBQTt3QkFDQUE7eUJBRUFBO3NCQUNBQTtxQkFDQUE7d0JBQ0FBO21CQUNBQTttQkFDQUE7bUJBQ0FBO3FCQUNBQTtzQkFDQUE7c0JBQ0FBO3VCQUNBQTt5QkFDQUE7MEJBQ0FBO2tCQUVBQTtvQkFDQUE7a0JBQ0FBO29CQUNBQTtvQkFDQUE7aUJBQ0FBO3NCQUNBQTtxQkFFQUE7dUJBQ0FBO3VCQUNBQTt3QkFDQUE7d0JBRUFBO3lCQUNBQTswQkFDQUE7NEJBQ0FBOzRCQUNBQTtxQkFDQUE7cUJBQ0FBO3FCQUNBQTt1QkFDQUE7cUJBQ0FBO3FCQUNBQTtxQkFDQUE7eUJBQ0FBO3FCQUNBQTtxQkFDQUE7cUJBQ0FBO3FCQUNBQTsyQkFDQUE7eUJBRUFBO2lCQUVBQTtpQkFDQUE7aUJBQ0FBO2lCQUNBQTtpQkFDQUE7aUJBQ0FBO2lCQUNBQTtpQkFDQUE7aUJBQ0FBO2lCQUNBQTtpQkFDQUE7aUJBQ0FBO21CQUVBQTttQkFDQUE7bUJBQ0FBO3NCQUVBQTtzQkFDQUE7NkJBRUFBOzJCQUNBQTs2QkFDQUE7R0FRdEIsU0FBUzRPLG1CQUFtQkMsU0FDMUIsT0FBT0YsYUFBYUUsU0FDdEI7R0Q1R0EsU0FBU0MsZ0JBQWdCL0IsR0FBR3JCO0lBQzFCO0tBQUlxRCxPQUFRaEMscUJBQXNCQTtLQUM5QjFIOztRQUFZMEg7UUFBWUE7UUFBVUE7UUFBV0E7UUFDakNBO1FBQ0FBO1FBQ0NBO0tBQ2JlO1FBQU9yTzs7U0FDSXVOO1NBQVFDLG9CQUFvQkY7U0FDL0JOLGFBQWFtQyxtQkFBbUI3QjtTQUNoQ2dDO1NBQU0xSjtTQUFPc0gsY0FBY2pCO0lBQ3ZDLE9BQU9vQztHQUNUO0dBSUEsU0FBU2tCLGtCQUFrQmpDO0lBQ3pCLEdBQUlDLFdBQVdsUCxLQUFNO0tBQ1gsSUFBSmdRLE1BQU1nQixnQkFBZ0IvQixHQUFHOU07S0FDN0J1Tix5QkFBeUJNOztJQUUzQjtHQUNGO0dBSUEsU0FBU21CLGdCQUFnQmxDO0lBQ3ZCLEdBQUlDLFdBQVdsUCxLQUFNO0tBQ1gsSUFBSmdRLE1BQU1nQixnQkFBZ0IvQixHQUFHOU07S0FDN0J1Tix5QkFBeUJNOztJQUUzQjtHQUNGO0dBNE5BLFNBQVNvQjtJQUE0QkMsUUFBUUMsU0FBU0MsSUFBSUMsSUFDckJDLFFBQVFDLFNBQVNDLElBQUlDLElBQUlDLE9BQU9DO0lBQ25FLEdBQUlQLE9BQVEsQ0FBRUksTUFBTUosSUFBSU0sU0FBVU4sSUFBSUE7SUFDdEMsR0FBSUMsT0FBUSxDQUFFSSxNQUFNSixJQUFJTSxVQUFVTixJQUFJQTtJQUN0QyxHQUFJRyxPQUFRLENBQUVKLE1BQU1JLElBQUlFLFNBQVVGLElBQUlBO0lBQ3RDLEdBQUlDLE9BQVEsQ0FBRUosTUFBTUksSUFBSUUsVUFBVUYsSUFBSUE7SUFDdEMsR0FBSUwsS0FBS00sUUFBU1IsUUFBV1EsUUFBU1IsU0FBVUU7SUFDaEQsR0FBSUMsS0FBS00sU0FBU1IsU0FBV1EsU0FBU1IsVUFBVUU7SUFDaEQsR0FBSUcsS0FBS0UsUUFBU0osUUFBV0ksUUFBU0osU0FBVUU7SUFDaEQsR0FBSUMsS0FBS0UsU0FBU0osU0FBV0ksU0FBU0osVUFBVUU7SUFDaEQsUUFBUUwsSUFBSUMsSUFBSUcsSUFBSUMsSUFBSUMsT0FBT0M7R0FDakM7R2Z4U0EsU0FBU0MsaUJBQWlCakc7SUFDeEIsSUFBSWtHLFNBQVNsRyxhQUNUbUc7SUFDSixJQUFXLElBQUZyUyxPQUFPQSxJQUFJb1MsUUFBUXBTLElBQUs7S0FDL0IsR0FBSWtNLEtBQUtsTTtNQUNQd0c7S0FDRjZMLE9BQU9BLE9BQU9uRyxLQUFLbE07O0lBRXJCLE9BQU9xUztHQUNUO0dBR0EsU0FBU0MsNkJBQTZCdEc7SUFDcEMsT0FBT0EsOEJBQ21CLGtCQUNqQjs7R0FFWDtHQTRQQSxTQUFTdUcsc0JBQXNCdkcsTUFBTUMsUUFBUUMsTUFBTTFFO0lBQzVCLElBQWpCZ0wsbUJBQW1CRiw2QkFBNkJ0RztJQUNwRCxHQUFHbUcsaUJBQWlCakcsUUFBUXNHLG9CQUFvQmhMO0tBQzlDaEI7SUFFRixHQUFHeUYsZUFDQUMsb0JBQ0FzRztLQUNELFdBQVc3RixrQkFBa0JYLE1BQU1DLFFBQVFDLE1BQU0xRTtJQUNuRCxXQUFXdUUsWUFBWUMsTUFBTUMsUUFBUUMsTUFBTTFFO0dBRTdDO0dlNUVBLFNBQVNpTCxxQkFBcUJDO0lBQ2hCLElBQVJDLFVBQVV4QztJQUNkd0MsZ0JBQWdCRDtJQUNoQkMsaUJBQWlCRDtJQUNSLElBQUxFLE9BQU9EO0lBQ1hDLGVBQWVGO0lBQ2Y7S0FBSUcsUUFBUUQsd0JBQXdCRixXQUFXQTtLQUMzQ0ksVUFBVXpDLGtCQUFrQndDO0tBQzVCRSxVQUFVMUMsa0JBQWtCeUM7SUFFaEMsSUFBVyxJQUFGOVMsT0FBT0EsSUFBSThTLFlBQVk5UyxPQUFRO0tBQ3RDK1MsSUFBSS9TLFNBQU84UyxJQUFJOVM7S0FDZitTLElBQUkvUyxTQUFPOFMsSUFBSTlTO0tBQ2YrUyxJQUFJL1MsU0FBTzhTLElBQUk5UztLQUNmK1MsSUFBSS9TLFNBQU84UyxJQUFJOVM7O0lBRWpCLE9BQU91Uyw2QkFDdUJHLFlBQVlBLGVBQWVLO0dBQzNEO0doQjRkQSxTQUFTQyx3QkFBd0IzUztJQUMvQixHQUFHNkMsY0FBYzdDLElBQ2YsT0FBT0E7SUFDVCxPQUFPOEMsbUJBQW1COUM7R0FBSTtHZ0J2SGhDLFNBQVM0UyxvQkFBb0JDLFFBQVFDLFVBQ1JDLFVBQVVDLE9BQU9DO0lBQzVDLElBQUlyQixRQUFRaUIsY0FDUk4sT0FBT007SUFDWE47SUFDQUEsb0JBQW9CWDtJQUNwQixHQUFJcUIsVUFBVWxULEtBQU07S0FDbEJ3UztLQUNBQTtLQUNBQTtLQUNBQSxjQUFjSSx3QkFBd0JNLFFBQVFyQjs7SUFFaERXO0lBQ0FBO0lBQ0EsR0FBSVMsY0FBZTtLQUNqQlQ7S0FDQUEsWUFBWVg7S0FDWlcsWUFBWVg7S0FDWlcsWUFBWVg7S0FDWlcsWUFBWVg7S0FDWlc7O0dBRUo7R0R6bUJBLFNBQVNXO0lBQ1AsY0FDU3hPO3FCQUNLQTtxQkFDQUE7R0FDaEI7R0wwQkEsU0FBU3lPO0lBQ1AsU0FBU0MsTUFBTW5QO0tBQ2IsR0FBSUEsd0JBQXdCLFlBQVlBO0tBQ3hDO0lBQ0Y7SUFFQSxTQUFTb1AsTUFBTXBQO0tBRWI7TUFBSXFQOztNQUNBQyxTQUFTRCxtQkFBbUJyUDtNQUM1QnVQLFNBQVNEO01BQ1RFLFFBQVFDLFFBQVFGLFVBQVVBO0tBRzlCLEdBQUlFLFFBQVFILGFBQWFFLE9BQVE7TUFDL0IsSUFBSWpNLE9BQVErTCxpQkFDUkksTUFBT0o7TUFDWCxRQUFRL0wsTUFBTXZELGVBQWV1RCxjQUFjbU07O0tBRTdDO0lBQ0Y7SUFDQSxPQUFHVCx1QkFBd0J4TztlQUFzQkE7Y0FDeENBLDBDQUEwQzJPLFFBQVFEO2NBRS9DQTtHQUNkO0dBQ3FCLElBQWpCUSxtQkFBbUJUO0dBdkR2QixTQUFTVSxvQkFBb0I3TjtJQUMzQixPQUFRQSwwQkFBMkJBLGFBQWNBO0dBQ25EO0dBSUEsR0FBR2tOLHVCQUF3QnhPLHNCQUFzQkE7SUFDMUIsSUFBakJvUCxtQkFBbUJwUDs7SUFFRixJQUFqQm9QO0dBQ05BLG1CQUFtQkQsb0JBQW9CQztHQWtEdkMsU0FBU0MsZUFBZ0IvTjtJQUN2QkEsT0FBSzJNLHdCQUF3QjNNO0lBQzdCLEtBQUs0TixpQkFBaUI1TixPQUNwQkEsT0FBTzhOLG1CQUFtQjlOO0lBQzVCO0tBQUlnTyxRQUFRSixpQkFBaUI1TjtLQUN6QnlCLE9BQU91TTtLQUNQQztJQUNKLElBQVUsSUFBRnRVLE9BQU9BLElBQUU4SCxhQUFhOUg7S0FBSSxPQUN6QjhILEtBQUs5SDs7UUFDRCxHQUFHc1Usa0JBQWdCQSxhQUFhO2lCQUNqQztnQkFDRDtnQkFDQUEsV0FBV3hNLEtBQUs5SCxLQUFJOztJQUcvQnNVLGNBQWNEO0lBQ2RDLGFBQWFqTztJQUNiLE9BQU9pTztHQUNUO0dBaEVBLFNBQVNDLGNBQWNqUTtJQUNmLElBQUY5RCxJQUFJeVQsaUJBQWlCM1A7SUFDekIsS0FBSzlELEdBQUc7SUFDUixPQUFPQTtHQUFVO0dERG5CLFNBQVNnVSxjQUFldE87SUFDdEIsS0FBSWhCO0tBQ0ZBLGlDQUE4QjNFO0lBQ2hDMEYsdUJBQXVCZiwwQkFBMEJnQjtHQUNuRDtHQ0NBO0lBQUl1TztNQUFZRixjQUFjSjtTQUFxQks7SUE2RC9DRTtHQUNKLEdBQUluQjtJQUNGbUI7YUFBNEJELHVCQUFxQjdKLGFBQWE2Sjs7SUFFOURDO2FBQTRCRCx1QkFBcUI3TSxhQUFhNk07R0FFaEVDO29DQUFtRDlNO0dBZW5ELFNBQVMrTSxrQkFBa0J0TztJQUN6QjtLQUFJL0IsT0FBTzhQLGVBQWUvTjtLQUN0QkEsT0FBTy9CO0tBQ1AyRCxhQUFhaU0sb0JBQW9CN047S0FDakMwQjtJQUNKLElBQVUsSUFBRi9ILE9BQU9BLElBQUkwVSx5QkFBeUIxVSxJQUFLO0tBQ3pDLElBQUZ1SSxJQUFJbU0saUJBQWlCMVU7S0FDekI7T0FBR2lJLGtCQUFrQk07YUFDYlIsT0FBT0Esa0JBQWtCUTtNQUMvQlI7Y0FBWVE7Z0JBQWNBO2NBQWNsQyxlQUFla0MsZUFBY2xDOztJQUV6RSxLQUFLMEIsT0FBT3dMLG9CQUFxQjtLQUN0QixJQUFMMUwsT0FBTzBNLGNBQWNsTztLQUN6QixHQUFJd0IsUUFBUUEsNEJBQTRCO01BQ2hDLElBQUZVLFdBQVVWLGtCQUFnQitDLGFBQWEvQztNQUMzQzZNLHNCQUFzQm5NO01BQ3RCUjtjQUFZUTtnQkFBY0E7Y0FBY2xDLGVBQWVrQyxlQUFjbEM7OztJQUd6RSxHQUFJMEIsS0FBTSxPQUFPQTtJQUNqQjVCLDhDQUE4QzhCO0dBQ2hEO0dBb0xBLFNBQVMyTSx1QkFBd0J2TztJQUMvQjtLQUFJQSxjQUFlQSxtQkFBa0I5Rix1QkFBdUI4RixRQUFNQTtLQUM5RHdCLE9BQU84TSxrQkFBa0J0TztJQUM3QixHQUFHd0IsbUJBQW1CQSxXQUFZO0tBQ2hDO01BQUlILE9BQU9HLGlCQUFpQkE7TUFDeEI1SCxNQUFPeUg7TUFDUFAsVUFBVXhCLFdBQVcxRjtLQUN6QnlILGFBQVlQLFFBQU1sSDtLQUNsQixPQUFPUSxxQkFBcUIwRzs7SUFFOUJmLHdCQUF3QlAsdUJBQXVCUTtHQUNqRDtHTXJIQSxTQUFTd08sNkJBQTZCQztJQUMzQixJQUFMcE4sT0FBT2tOLHVCQUF1QkU7SUFDbEMsR0FBSXBOLFNBQVN0SCxNQUFNLE9BQ1ZBO0lBRVQ7S0FBSTJVLEtBQUtILHVCQUF1QkU7S0FFNUJ0TixPQUFPNkksWUFBWTBFLFNBQVMvUCxZQUFZK1AsS0FBS0E7S0FDN0NyQyxVQUFVckM7SUFDZHFDO0lBQ0FBO0lBQ0FBLHFDQUFxQ2xMO0lBQ3JDLFFBQVFrTCxjQUFjQTtHQUN4QjtHZnVIQSxTQUFTc0MsWUFBWXJVLElBQUlYO0lBQ3ZCLEdBQUlBLFNBQVNBLEtBQUtXLGdCQUNoQjZGO0lBQ0YsT0FBTzdGLFFBQVFYO0dBQ2pCO0dBbWdCQSxTQUFTaVYsdUJBQXVCdFUsSUFDOUIsT0FBT0EsUUFDVDtHZXRtQkEsU0FBU3VVLHlCQUF5QjFOO0lBQ3BCLElBQVJtTCxVQUFVeEM7SUFDZHdDLGdCQUFnQnFDLFlBQVl4TjtJQUM1Qm1MLGlCQUFpQnFDLFlBQVl4TjtJQUM3QjtLQUFJb0wsT0FBT0Q7S0FDUEcsVUFBVXpDLGtCQUFrQjRFLHVCQUF1QnpOO0tBQ25EdUwsVUFBVTFDLHlCQUF5QnlDO0lBRXZDLElBQVcsSUFBRjlTLE9BQU9BLElBQUk4UyxZQUFZOVMsT0FBUTtLQUN0QytTLElBQUkvUyxTQUFPOFMsSUFBSTlTO0tBQ2YrUyxJQUFJL1MsU0FBTzhTLElBQUk5UztLQUNmK1MsSUFBSS9TLFNBQU84UyxJQUFJOVM7S0FDZitTLElBQUkvUyxTQUFPOFMsSUFBSTlTOztJQUVqQixHQUFJcVEscUJBQXFCckwsVUFBVztLQUN4QixJQUFONk4sUUFBUUQscUJBQXFCRCxlQUFlQTtLQUNoREUsZUFBZUU7OztLQUVMLElBQU5GLFlBQVl4QyxpQkFBaUIwQyxLQUFLSixlQUFlQTtJQUV2REMsa0JBQWtCQztJQUNsQixPQUFPRjtHQUNUO0dBOVBBLFNBQVN3Qyw2QkFBNkJsRCxPQUFPQztJQUMzQyxXQUFXRCxTQUFTQSxzQkFBc0JDLFVBQVVBO0dBQ3REO0dBcUlBLFNBQVNrRCxjQUFjL0Y7SUFDckIsR0FBSWlCLGFBQWM7S0FDaEI7TUFBSStFLFFBQVFoRztNQUNSaUcsUUFBUWpHO01BQ1JzQyxLQUFLMEQsUUFBUS9FO01BQ2JzQixLQUFLMEQsUUFBUWhGO0tBQ2pCQSxlQUFlK0U7S0FDZi9FLGVBQWVnRjtLQUNKLElBQVA5RSxTQUFTRjtLQUNiRSxZQUFZbUI7S0FDWm5CLFlBQVlvQjtLQUNadEIsMEJBQTBCRTtLQUMxQkYseUJBQXlCRTs7WUFDaEJuQixvQkFBb0JySyxVQUFXO0tBQ3hDO01BQUkzRSxJQUFJK08sb0JBQW9CQztNQUN4QmU7U0FBT3JPOztVQUNJc047VUFDSEUsb0JBQW9CRjtjQUNoQkEsWUFBVWhQLFVBQVVnUCxZQUFVaFA7S0FDOUN5UCx5QkFBeUJNOztJQUUzQjtHQUNGO0dBMmFhLElBQVRtRjtHQXRhSixTQUFTQyxnQkFBZ0JDO0lBQ3ZCQTtlQUEwQnBHO09BQ2hCO1FBQUplO1dBQU9yTzs7WUFDSXNOO1lBQ0hFLG9CQUFvQkY7Z0JBQ2hCQSxzQkFBc0JBO09BQ3RDUyx5QkFBeUJNO01BTFg7SUFPaEI7R0FDRjtHQS9JWSxJQUFSc0YsY0FBY3JGLHNCQUFzQm1GO0dBMEV4QyxTQUFTRyxzQkFBc0J0RztJQUM3QixHQUFJQSxhQUFhalAsS0FBTTtLQUNyQmtQLFNBQVNEO0tBQ1RBLG9DQUFvQ0EsdUJBQXVCalA7S0FDM0Q7TUFBSUMsSUFBSStPLG9CQUFvQkM7TUFDeEJlO1NBQU9yTzs7VUFDSXNOO1VBQ0hFLG9CQUFvQkY7Y0FDaEJBLFlBQVVoUCxVQUFVZ1AsWUFBVWhQO1VBQVdnUDs7S0FDekRTLHlCQUF5Qk07O0lBRTNCO0dBQ0Y7R0FLQSxTQUFTd0YsWUFBWXZHO0lBQ25CaUI7SUFDQSxHQUFJakIsb0JBQW9CckssVUFBVztLQUNqQztNQUFJM0UsSUFBSStPLG9CQUFvQkM7TUFDeEJlO1NBQU9yTzs7VUFDSXNOO1VBQ0hFLG9CQUFvQkY7Y0FDaEJBLFlBQVVoUCxVQUFVZ1AsWUFBVWhQO1VBQVdnUDs7S0FDekRTLHlCQUF5Qk07O0lBRTNCO0dBQ0Y7R0Z0QkEsU0FBU3lGLFNBQVNDLEtBQUsxSixLQUFLbk0sS0FBSzhWO0lBQ3JCLElBQU5DLFFBQVFEO0lBQ1osSUFBVSxJQUFGL1YsT0FBT0EsSUFBSUMsS0FBS0QsSUFBSztLQUNyQixJQUFGUSxLQUFLc1YsU0FBUzFKLE1BQUlwTSxZQUFZZ1c7S0FDbENGLFNBQVMxSixNQUFJcE0sS0FBTVE7S0FDbkIsR0FBR0EsS0FBTUEsUUFBVSxDQUNqQndWLFdBQ0EsYUFFQUE7O0lBR0osT0FBT0E7R0FDVDtHQUtBLFNBQVNDLFFBQVFDLE1BQU1DLE1BQU1DLE1BQU1DLE1BQU1DLE1BQU1DLE1BQU1SO0lBQ3pDLElBQU5DLFFBQVFEO0lBQ1osSUFBVSxJQUFGL1YsT0FBT0EsSUFBSXVXLE1BQU12VyxJQUFLO0tBQ3RCO01BQUZRLEtBQUswVixVQUFVQyxPQUFLblcsYUFBYXFXLFVBQVVDLE9BQUt0VyxZQUFZZ1c7S0FDaEVFLFVBQVVDLE9BQUtuVyxLQUFLUTtLQUNwQixHQUFHQSxLQUFNQSxTQUNQd1YsZ0JBRUFBOztJQUdKLE9BQU9ILFNBQVNLLE1BQU1DLE9BQUtJLE1BQU1ILE9BQUtHLE1BQU1QO0dBQzlDO0dJakpBLFNBQVNRLDBCQUEwQkM7SUFDMUIsSUFBSEMsU0FBUy9RLFdBQVc4UTtJQUN4QixPQUFPbEUsOEJBQThCbUUsWUFBWUE7R0FDbkQ7R0FJQSxTQUFTQyx5QkFBeUJoVztJQUN6QjtLQUFIK1Y7O1FBQVMvUTtTQUFXaEYsV0FBV0EsZUFBZUEsWUFBWUE7SUFDOUQsT0FBTzRSLDhCQUE4Qm1FLFlBQVlBO0dBQ25EO0dBckJBLFNBQVNFLDBCQUEwQjlWLElBQ2pDLE9BQU9BLGVBQ1Q7R0FHQSxTQUFTK1YseUJBQXlCL1YsSUFDaEMsT0FBT0EsUUFDVDtHSmtEQSxTQUFTZ1csU0FBU1osTUFBTUMsTUFBTUUsTUFBTUMsTUFBTXJXO0lBQ3hDLElBQVUsSUFBRkQsT0FBT0EsSUFBSUMsS0FBS0QsS0FDdEJrVyxVQUFVQyxPQUFLblcsS0FBS3FXLFVBQVVDLE9BQUt0VztJQUVyQztHQUNGO0dLckJzQjtJQUFsQitXO01BQW9CO1FBQ3RCLFNBQVNDLElBQUt4VyxHQUFHb0osR0FBSyxPQUFRcEosSUFBSW9KLE1BQVE7UUFDMUMsU0FBU3FOLEdBQUdwTixHQUFFOUosR0FBRXFELEdBQUU1QyxHQUFFSCxHQUFFZ0Q7U0FDcEJ0RCxJQUFJaVgsSUFBSUEsSUFBSWpYLEdBQUc4SixJQUFJbU4sSUFBSXhXLEdBQUc2QztTQUMxQixPQUFPMlQsSUFBS2pYLEtBQUtNLElBQU1OLFdBQVlNLEdBQUsrQztRQUMxQztRQUNBLFNBQVM4VCxHQUFHblgsR0FBRXFELEdBQUVFLEdBQUVVLEdBQUV4RCxHQUFFSCxHQUFFZ0Q7U0FDdEIsT0FBTzRULEdBQUk3VCxJQUFJRSxNQUFRRixJQUFLWSxHQUFJakUsR0FBR3FELEdBQUc1QyxHQUFHSCxHQUFHZ0Q7UUFDOUM7UUFDQSxTQUFTOFQsR0FBR3BYLEdBQUVxRCxHQUFFRSxHQUFFVSxHQUFFeEQsR0FBRUgsR0FBRWdEO1NBQ3RCLE9BQU80VCxHQUFJN1QsSUFBSVksSUFBTVYsTUFBTVUsR0FBS2pFLEdBQUdxRCxHQUFHNUMsR0FBR0gsR0FBR2dEO1FBQzlDO1FBQ0EsU0FBUytULEdBQUdyWCxHQUFFcUQsR0FBRUUsR0FBRVUsR0FBRXhELEdBQUVILEdBQUVnRCxHQUFLLE9BQU80VCxHQUFHN1QsSUFBSUUsSUFBSVUsR0FBR2pFLEdBQUdxRCxHQUFHNUMsR0FBR0gsR0FBR2dELEdBQUk7UUFDbEUsU0FBU2dVLEdBQUd0WCxHQUFFcUQsR0FBRUUsR0FBRVUsR0FBRXhELEdBQUVILEdBQUVnRDtTQUFLLE9BQU80VCxHQUFHM1QsS0FBS0YsTUFBTVksSUFBS2pFLEdBQUdxRCxHQUFHNUMsR0FBR0gsR0FBR2dEO1FBQUk7UUFFdkUsZ0JBQWlCaVUsR0FBR25MO1NBQ2xCLElBQUlwTSxJQUFJdVgsTUFBTWxVLElBQUlrVSxNQUFNaFUsSUFBSWdVLE1BQU10VCxJQUFJc1Q7U0FFdEN2WCxJQUFJbVgsR0FBR25YLEdBQUdxRCxHQUFHRSxHQUFHVSxHQUFHbUk7U0FDbkJuSSxJQUFJa1QsR0FBR2xULEdBQUdqRSxHQUFHcUQsR0FBR0UsR0FBRzZJO1NBQ25CN0ksSUFBSTRULEdBQUc1VCxHQUFHVSxHQUFHakUsR0FBR3FELEdBQUcrSTtTQUNuQi9JLElBQUk4VCxHQUFHOVQsR0FBR0UsR0FBR1UsR0FBR2pFLEdBQUdvTTtTQUNuQnBNLElBQUltWCxHQUFHblgsR0FBR3FELEdBQUdFLEdBQUdVLEdBQUdtSTtTQUNuQm5JLElBQUlrVCxHQUFHbFQsR0FBR2pFLEdBQUdxRCxHQUFHRSxHQUFHNkk7U0FDbkI3SSxJQUFJNFQsR0FBRzVULEdBQUdVLEdBQUdqRSxHQUFHcUQsR0FBRytJO1NBQ25CL0ksSUFBSThULEdBQUc5VCxHQUFHRSxHQUFHVSxHQUFHakUsR0FBR29NO1NBQ25CcE0sSUFBSW1YLEdBQUduWCxHQUFHcUQsR0FBR0UsR0FBR1UsR0FBR21JO1NBQ25CbkksSUFBSWtULEdBQUdsVCxHQUFHakUsR0FBR3FELEdBQUdFLEdBQUc2STtTQUNuQjdJLElBQUk0VCxHQUFHNVQsR0FBR1UsR0FBR2pFLEdBQUdxRCxHQUFHK0k7U0FDbkIvSSxJQUFJOFQsR0FBRzlULEdBQUdFLEdBQUdVLEdBQUdqRSxHQUFHb007U0FDbkJwTSxJQUFJbVgsR0FBR25YLEdBQUdxRCxHQUFHRSxHQUFHVSxHQUFHbUk7U0FDbkJuSSxJQUFJa1QsR0FBR2xULEdBQUdqRSxHQUFHcUQsR0FBR0UsR0FBRzZJO1NBQ25CN0ksSUFBSTRULEdBQUc1VCxHQUFHVSxHQUFHakUsR0FBR3FELEdBQUcrSTtTQUNuQi9JLElBQUk4VCxHQUFHOVQsR0FBR0UsR0FBR1UsR0FBR2pFLEdBQUdvTTtTQUVuQnBNLElBQUlvWCxHQUFHcFgsR0FBR3FELEdBQUdFLEdBQUdVLEdBQUdtSTtTQUNuQm5JLElBQUltVCxHQUFHblQsR0FBR2pFLEdBQUdxRCxHQUFHRSxHQUFHNkk7U0FDbkI3SSxJQUFJNlQsR0FBRzdULEdBQUdVLEdBQUdqRSxHQUFHcUQsR0FBRytJO1NBQ25CL0ksSUFBSStULEdBQUcvVCxHQUFHRSxHQUFHVSxHQUFHakUsR0FBR29NO1NBQ25CcE0sSUFBSW9YLEdBQUdwWCxHQUFHcUQsR0FBR0UsR0FBR1UsR0FBR21JO1NBQ25CbkksSUFBSW1ULEdBQUduVCxHQUFHakUsR0FBR3FELEdBQUdFLEdBQUc2STtTQUNuQjdJLElBQUk2VCxHQUFHN1QsR0FBR1UsR0FBR2pFLEdBQUdxRCxHQUFHK0k7U0FDbkIvSSxJQUFJK1QsR0FBRy9ULEdBQUdFLEdBQUdVLEdBQUdqRSxHQUFHb007U0FDbkJwTSxJQUFJb1gsR0FBR3BYLEdBQUdxRCxHQUFHRSxHQUFHVSxHQUFHbUk7U0FDbkJuSSxJQUFJbVQsR0FBR25ULEdBQUdqRSxHQUFHcUQsR0FBR0UsR0FBRzZJO1NBQ25CN0ksSUFBSTZULEdBQUc3VCxHQUFHVSxHQUFHakUsR0FBR3FELEdBQUcrSTtTQUNuQi9JLElBQUkrVCxHQUFHL1QsR0FBR0UsR0FBR1UsR0FBR2pFLEdBQUdvTTtTQUNuQnBNLElBQUlvWCxHQUFHcFgsR0FBR3FELEdBQUdFLEdBQUdVLEdBQUdtSTtTQUNuQm5JLElBQUltVCxHQUFHblQsR0FBR2pFLEdBQUdxRCxHQUFHRSxHQUFHNkk7U0FDbkI3SSxJQUFJNlQsR0FBRzdULEdBQUdVLEdBQUdqRSxHQUFHcUQsR0FBRytJO1NBQ25CL0ksSUFBSStULEdBQUcvVCxHQUFHRSxHQUFHVSxHQUFHakUsR0FBR29NO1NBRW5CcE0sSUFBSXFYLEdBQUdyWCxHQUFHcUQsR0FBR0UsR0FBR1UsR0FBR21JO1NBQ25CbkksSUFBSW9ULEdBQUdwVCxHQUFHakUsR0FBR3FELEdBQUdFLEdBQUc2STtTQUNuQjdJLElBQUk4VCxHQUFHOVQsR0FBR1UsR0FBR2pFLEdBQUdxRCxHQUFHK0k7U0FDbkIvSSxJQUFJZ1UsR0FBR2hVLEdBQUdFLEdBQUdVLEdBQUdqRSxHQUFHb007U0FDbkJwTSxJQUFJcVgsR0FBR3JYLEdBQUdxRCxHQUFHRSxHQUFHVSxHQUFHbUk7U0FDbkJuSSxJQUFJb1QsR0FBR3BULEdBQUdqRSxHQUFHcUQsR0FBR0UsR0FBRzZJO1NBQ25CN0ksSUFBSThULEdBQUc5VCxHQUFHVSxHQUFHakUsR0FBR3FELEdBQUcrSTtTQUNuQi9JLElBQUlnVSxHQUFHaFUsR0FBR0UsR0FBR1UsR0FBR2pFLEdBQUdvTTtTQUNuQnBNLElBQUlxWCxHQUFHclgsR0FBR3FELEdBQUdFLEdBQUdVLEdBQUdtSTtTQUNuQm5JLElBQUlvVCxHQUFHcFQsR0FBR2pFLEdBQUdxRCxHQUFHRSxHQUFHNkk7U0FDbkI3SSxJQUFJOFQsR0FBRzlULEdBQUdVLEdBQUdqRSxHQUFHcUQsR0FBRytJO1NBQ25CL0ksSUFBSWdVLEdBQUdoVSxHQUFHRSxHQUFHVSxHQUFHakUsR0FBR29NO1NBQ25CcE0sSUFBSXFYLEdBQUdyWCxHQUFHcUQsR0FBR0UsR0FBR1UsR0FBR21JO1NBQ25CbkksSUFBSW9ULEdBQUdwVCxHQUFHakUsR0FBR3FELEdBQUdFLEdBQUc2STtTQUNuQjdJLElBQUk4VCxHQUFHOVQsR0FBR1UsR0FBR2pFLEdBQUdxRCxHQUFHK0k7U0FDbkIvSSxJQUFJZ1UsR0FBR2hVLEdBQUdFLEdBQUdVLEdBQUdqRSxHQUFHb007U0FFbkJwTSxJQUFJc1gsR0FBR3RYLEdBQUdxRCxHQUFHRSxHQUFHVSxHQUFHbUk7U0FDbkJuSSxJQUFJcVQsR0FBR3JULEdBQUdqRSxHQUFHcUQsR0FBR0UsR0FBRzZJO1NBQ25CN0ksSUFBSStULEdBQUcvVCxHQUFHVSxHQUFHakUsR0FBR3FELEdBQUcrSTtTQUNuQi9JLElBQUlpVSxHQUFHalUsR0FBR0UsR0FBR1UsR0FBR2pFLEdBQUdvTTtTQUNuQnBNLElBQUlzWCxHQUFHdFgsR0FBR3FELEdBQUdFLEdBQUdVLEdBQUdtSTtTQUNuQm5JLElBQUlxVCxHQUFHclQsR0FBR2pFLEdBQUdxRCxHQUFHRSxHQUFHNkk7U0FDbkI3SSxJQUFJK1QsR0FBRy9ULEdBQUdVLEdBQUdqRSxHQUFHcUQsR0FBRytJO1NBQ25CL0ksSUFBSWlVLEdBQUdqVSxHQUFHRSxHQUFHVSxHQUFHakUsR0FBR29NO1NBQ25CcE0sSUFBSXNYLEdBQUd0WCxHQUFHcUQsR0FBR0UsR0FBR1UsR0FBR21JO1NBQ25CbkksSUFBSXFULEdBQUdyVCxHQUFHakUsR0FBR3FELEdBQUdFLEdBQUc2STtTQUNuQjdJLElBQUkrVCxHQUFHL1QsR0FBR1UsR0FBR2pFLEdBQUdxRCxHQUFHK0k7U0FDbkIvSSxJQUFJaVUsR0FBR2pVLEdBQUdFLEdBQUdVLEdBQUdqRSxHQUFHb007U0FDbkJwTSxJQUFJc1gsR0FBR3RYLEdBQUdxRCxHQUFHRSxHQUFHVSxHQUFHbUk7U0FDbkJuSSxJQUFJcVQsR0FBR3JULEdBQUdqRSxHQUFHcUQsR0FBR0UsR0FBRzZJO1NBQ25CN0ksSUFBSStULEdBQUcvVCxHQUFHVSxHQUFHakUsR0FBR3FELEdBQUcrSTtTQUNuQi9JLElBQUlpVSxHQUFHalUsR0FBR0UsR0FBR1UsR0FBR2pFLEdBQUdvTTtTQUVuQm1MLE9BQU9OLElBQUlqWCxHQUFHdVg7U0FDZEEsT0FBT04sSUFBSTVULEdBQUdrVTtTQUNkQSxPQUFPTixJQUFJMVQsR0FBR2dVO1NBQ2RBLE9BQU9OLElBQUloVCxHQUFHc1QsTUExRVQ7T0FmZ0I7O0dBb0l6QixTQUFTQyxjQUFjQztJQUNWLElBQVBDLFNBQVNEO0lBQ2JBLE9BQU9DO0lBQ1BBO0lBQ0EsR0FBR0EsWUFBYTtLQUNkLElBQVUsSUFBRnZXLElBQUl1VyxRQUFRdlcsUUFBUUEsS0FDMUJzVyxPQUFPdFc7S0FFVDZWLGtCQUFrQlMsT0FBT0E7S0FDekIsSUFBVSxJQUFGdFcsT0FBT0EsUUFBUUEsS0FDckJzVyxPQUFPdFc7OztLQUVKLElBQ0ssSUFBRkEsSUFBSXVXLFFBQVF2VyxRQUFRQSxLQUMxQnNXLE9BQU90VztJQUdYc1csY0FBY0E7SUFDZEEsY0FBZUE7SUFDZlQsa0JBQWtCUyxPQUFPQTtJQUNuQixJQUFGblUsUUFBUXNDO0lBQ1osSUFBVyxJQUFGM0YsT0FBT0EsT0FBT0E7S0FDckIsSUFBVyxJQUFGa0IsT0FBT0EsT0FBT0EsS0FDckJtQyxFQUFFckQsUUFBUWtCLEtBQU1zVyxNQUFNeFgsVUFBV2tCO0lBQ3JDLE9BQU9tQztHQUNUO0dBaEVBLFNBQVNxVTtJQUNQO0tBQUl2TCxhQUFhd0w7S0FDYkMsVUFBVUMsWUFBWTFMO0tBQ3RCMkwsU0FBU25TLFdBQVd3RztJQUN4Qjs7Z0JBQ2MwTDtpQkFDRkQ7Z0JBQ0RFO0dBQ2I7R0FJQSxTQUFTQyxlQUFlUCxLQUFLUSxPQUFPQztJQUNsQyxJQUFJUixTQUFTRCxnQkFDVFU7SUFDSlYsV0FBV1M7SUFDWCxHQUFHUixPQUFPO0tBQ0ksSUFBUlUsZUFBZVY7S0FDbkIsR0FBR1EsWUFBWUUsUUFBUztNQUN0QlgsV0FBV1Esa0JBQWlCQyxZQUFXUjtNQUN2Qzs7S0FFRkQsV0FBV1Esa0JBQWlCRyxVQUFTVjtLQUNyQ1Ysa0JBQWtCUyxPQUFPQTtLQUN6QlMsYUFBYUU7S0FDYkQsYUFBYUM7O0lBRWYsTUFBTUYsZ0JBQWdCO0tBQ3BCVCxXQUFXUSxlQUFlRSxXQUFVQTtLQUNwQ25CLGtCQUFrQlMsT0FBT0E7S0FDekJTO0tBQ0FDOztJQUVGLEdBQUdEO0tBQ0RULFdBQVdRLGVBQWVFLFdBQVVBLFlBQVlEO0dBQ3BEO0dDc0dBLFNBQVNHLGlCQUFrQjVYLEdBQUssT0FBT0YsV0FBV0UsR0FBSTtHZmxRdEQsU0FBUzZYLGNBQWNuWSxHQUFHdUU7SUFDeEI7S0FBSTNCLElBQUs1QyxXQUFVQSxNQUFLQSxNQUFNQTtLQUMxQm9ZLFVBQVU3VDtLQUNWVCxJQUFJbEIsSUFBSXdWO0lBQ1osR0FBSXRVO0tBQ0YsT0FBTzlELFFBQVFFLE1BQU1xRTtZQUNkVCxNQUFPO0tBQ1IsSUFBRnVLLElBQUlyTyxRQUFRRSxNQUFLcUUsY0FBYTNCO0tBQ2xDLFVBQVV5TCxrQkFBa0IsT0FBT0E7S0FDbkMsT0FBTzhKLGNBQWM5SixHQUFFOUosV0FBVzNCOztRQUUvQjtLQUNILE9BQVFrQjs7UUFDQTtTQUNBO1VBQUZ1SztxQkFBYy9OO2FBQ04sSUFBTitYLFlBQVl0WCxNQUFNcVg7YUFDdEIsSUFBVSxJQUFGdFksT0FBT0EsSUFBSXNZLFNBQVN0WSxLQUFNdVksTUFBTXZZLEtBQUt5RSxLQUFLekU7YUFDbER1WSxNQUFNRCxXQUFXOVg7YUFDakIsT0FBT04sUUFBUUUsTUFBTW1ZO1lBSmY7U0FNUjs7O1FBRU07U0FDQTtVQUFGaEs7cUJBQWMvTixHQUFHb0o7YUFDVCxJQUFOMk8sWUFBWXRYLE1BQU1xWDthQUN0QixJQUFVLElBQUZ0WSxPQUFPQSxJQUFJc1ksU0FBU3RZLEtBQU11WSxNQUFNdlksS0FBS3lFLEtBQUt6RTthQUNsRHVZLE1BQU1ELFdBQVc5WDthQUNqQitYLE1BQU1ELGVBQWUxTzthQUNyQixPQUFPMUosUUFBUUUsTUFBTW1ZO1lBTGY7U0FPUjs7O1FBR007U0FBRmhLOztZQUNGO2FBQUlpSyxhQUFjQyw0QkFBeUJBO2FBQ3ZDRixZQUFZdFgsTUFBTXdELGNBQVkrVDtZQUNsQyxJQUFVLElBQUZ4WSxPQUFPQSxJQUFJeUUsYUFBYXpFLEtBQU11WSxNQUFNdlksS0FBS3lFLEtBQUt6RTtZQUN0RCxJQUFVLElBQUZBLE9BQU9BLElBQUl5WSxrQkFBa0J6WTthQUFNdVksTUFBTTlULGNBQVl6RSxLQUFLeVksVUFBVXpZO1lBQzVFLE9BQU9xWSxjQUFjblksR0FBR3FZO1dBTGxCOztLQVFWaEssTUFBTXZLO0tBQ04sT0FBT3VLOztHQUVYO0dnQnhDQSxTQUFTbUs7SUFDUCxnQkFBZ0J4WSxFQUFHTSxHQUFLLE9BQU82WCxjQUFjblksUUFBUU0sSUFBOUM7R0FDVDtHQ29IQSxTQUFTbVksaUJBQWlCQyxJQUFJQyxJQUFJQyxJQUNoQyxTQUNGO0doQkpjO0lBQVZDO01BQWE7UUFDZixJQUFJalUsVUFBVUMsb0JBQ1ZpVSxnQkFDQXZVO1FBRUosR0FBR0ssV0FDR0EsZ0JBQ0FBLHdCQUF5QjtTQUNwQixJQUFMbVUsT0FBT25VO1NBRVhrVSxPQUFPQztTQUNQeFUsT0FBT3dVOztRQUdULElBQUlDLElBQUlqVix3QkFBd0IrVSxPQUM1QkcsWUFBWUQ7UUFDaEIsSUFBVSxJQUFGbFosT0FBT0EsSUFBSXlFLGFBQWF6RTtTQUM5Qm1aLFdBQVdsVix3QkFBd0JRLEtBQUt6RTtRQUMxQyxPQUFPbVo7T0FsQlM7O0dpQmhIbEIsU0FBU0Msa0JBQWtCQyxJQUFJQztJQUM3QixJQUFJQyxLQUFLRixXQUFXRyxLQUFLRixXQUNyQnRXLElBQUl1VyxLQUFHQyxRQUNQelosUUFBUWtCLE1BQU0rQjtJQUNsQmpEO0lBQ0EsSUFBSUMsT0FBTWtCO0lBQ1YsTUFBS2xCLElBQUV1WixJQUFHdlosS0FBS0QsRUFBRUMsS0FBR3FaLEdBQUdyWjtJQUN2QixNQUFLQSxJQUFFZ0QsR0FBRWhELEtBQUlrQixLQUFLbkIsRUFBRUMsS0FBR3NaLEdBQUdwWTtJQUMxQixPQUFPbkI7R0FDVDtHQWNBLFNBQVMwWixnQkFBZ0JKLElBQUl4UyxJQUFJeVMsSUFBSXZTLElBQUk5RztJQUN2QyxHQUFJOEcsTUFBTUY7S0FBSSxJQUNELElBQUYzRixPQUFPQSxLQUFLakIsS0FBS2lCLEtBQUtvWSxHQUFHdlMsS0FBSzdGLEtBQUttWSxHQUFHeFMsS0FBSzNGOztLQUMvQyxJQUNNLElBQUZBLElBQUlqQixLQUFLaUIsUUFBUUEsS0FBS29ZLEdBQUd2UyxLQUFLN0YsS0FBS21ZLEdBQUd4UyxLQUFLM0Y7SUFFdEQ7R0FDRjtHQWxCQSxTQUFTd1ksa0JBQWtCMVc7SUFDbkIsSUFBRmpEO0lBQ0osTUFBT2lELFFBQVM7S0FDUixJQUFGSSxJQUFJSjtLQUNSLElBQVcsSUFBRmhELE9BQU9BLElBQUlvRCxVQUFVcEQsS0FBS0QsT0FBT3FELEVBQUVwRDtLQUM1Q2dELElBQUlBOztJQUVOLE9BQU9qRDtHQUNUO0dBc0NBLFNBQVM0WixnQkFBZ0JDLE9BQU94TixLQUFLbk0sS0FBS3dEO0lBQ3hDLElBQVUsSUFBRnpELE9BQU9BLElBQUlDLEtBQUtELEtBQ3RCNFosTUFBTXhOLE1BQUlwTSxTQUFPeUQ7SUFFbkI7R0FDRjtHQVhBLFNBQVNvVyxlQUFnQkQsT0FBT0U7SUFDOUIsR0FBS0EsYUFBZUEsU0FBU0Ysa0JBQW1CL047SUFDaEQsT0FBTytOLE1BQU1FO0dBQ2Y7R3ZCaXpCQSxTQUFTQyxvQkFBb0J2WixHQUFLLE9BQU8rRiwwQkFBMEIvRixHQUFHO0dBSnRFLFNBQVN3WixxQkFBcUJ4WixHQUFLLE9BQU8ySiwyQkFBMkIzSixHQUFHO0d1QnZ6QnhFLFNBQVN5WixlQUFnQkwsT0FBT0UsT0FBT0k7SUFDckMsR0FBS0osYUFBZUEsU0FBU0Ysa0JBQW1CL047SUFDaEQrTixNQUFNRSxhQUFTSTtJQUFRO0dBQ3pCO0dBMURBLFNBQVNDLGVBQWdCcGEsR0FBR0MsR0FBR0M7SUFDdEIsSUFBSHFaLFNBQVNyWSxNQUFNaEI7SUFDbkJxWjtJQUNBLFFBQVF2UyxRQUFRRixLQUFJN0csT0FBSytHLE1BQU05RyxLQUFLOEcsTUFBS0YsTUFDdkN5UyxHQUFHdlMsTUFBSWhILEVBQUU4RztJQUVYLE9BQU95UztHQUNUO0dIaVFBLFNBQVNjLGlCQUFrQjVaLEdBQUssT0FBT0YsV0FBV0UsR0FBSTtHQUl0RCxTQUFTNlosaUJBQWtCN1osR0FBSyxPQUFPRixXQUFXRSxHQUFJO0dJalF0RCxTQUFTOFosZ0JBQWdCQyxLQUFJdlAsR0FBRWxJO0lBQzdCLEdBQUd5WCxXQUFXdlAsRUFBRSxDQUNkdVAsU0FBU3pYLEdBQ1Q7SUFFRjtHQUNGO0dBVUEsU0FBUzBYLHFCQUFxQkQsS0FBSzlXO0lBQzNCLElBQUZWLElBQUl3WDtJQUNSQSxTQUFTOVc7SUFDVCxPQUFPVjtHQUNUO0dBWEEsU0FBUzBYLHNCQUFzQkYsS0FBS3ZhO0lBQzFCLElBQUprSCxNQUFNcVQ7SUFDVkEsVUFBVXZhO0lBQ1YsT0FBT2tIO0dBQ1Q7R0FsQkEsU0FBU3dULGlCQUFpQkgsS0FDeEIsT0FBT0EsT0FDVDtHQTBCQSxTQUFTSSwyQkFBMkI1YSxHQUNsQyxXQUFXQSxHQUNiO0d2QmdjQSxTQUFTNmEsYUFBYTlSLEtBQUsrUjtJQUN6QixHQUFJQSxtQkFBbUIvUjtLQUNyQnRDO0lBQ0YsSUFBVyxJQUFGeEcsT0FBT0EsSUFBSTZhLGlCQUFpQjdhO0tBQ25DLEdBQUk2YSxTQUFTN2EsTUFBTThJLFNBQVM5STtNQUMxQndHO0lBQ0pxVSxhQUFhL1I7SUFDYjtHQUNGO0dBeExBLFNBQVNnUyxzQkFBc0JuYSxJQUFJc0w7SUFDakMsR0FBR3RMLGFBQWFzTCxRQUFRLE9BQU90TDtJQUNsQixJQUFUb2E7SUFDSixJQUFVLElBQUYvYSxPQUFPQSxJQUFJVyxnQkFBZ0JYO0tBQUsrYSxTQUFTL2EsS0FBS1csUUFBUUEsaUJBQWlCWDtJQUMvRSxPQUFPdVMsc0JBQXNCNVIsU0FBU3NMLFFBQVE4TyxVQUFVcGE7R0FDMUQ7R0F0Q0EsU0FBU3FhLGdCQUFnQmpiLEdBQUVxRCxHQUFFbUosT0FDM0IsT0FBT3hNLFVBQVVxRCxHQUFFbUosT0FDckI7R0FsUEEsU0FBUzBPLHNCQUFzQmpQLE1BQU1xRztJQUNuQyxJQUFJNkk7SUFDSixPQUFPbFA7O09BQ0VrUCxPQUFPQyxjQUFjOztPQUNyQkQsT0FBT0UsY0FBYzs7T0FDckJGLE9BQU9HLFdBQVc7O09BQ2xCSCxPQUFPdlYsWUFBWTs7T0FDbkJ1VixPQUFPSSxZQUFZOztPQUNuQkosT0FBT0ssYUFBYTs7T0FDcEJMLE9BQU9sUixZQUFZOztPQUNuQmtSLE9BQU9sUixZQUFZOztPQUNuQmtSLE9BQU9sUixZQUFZOztPQUNuQmtSLE9BQU9sUixZQUFZOztPQUNuQmtSLE9BQU9DLGNBQWM7O09BQ3JCRCxPQUFPRSxjQUFjOztPQUNyQkYsT0FBT3ZWLFlBQVk7O0lBRTVCLEtBQUt1VixNQUFNMVU7SUFDRixJQUFMZ0IsV0FBVzBULEtBQUs3SSxPQUFPQyw2QkFBNkJ0RztJQUN4RCxPQUFPeEU7R0FDVDtHT2dJQSxTQUFTZ1UsbUJBQW1CemIsR0FDMUIsT0FBT0EsV0FDVDtHUG1IQSxTQUFTMGIsZUFBZXpQLE1BQU1DLFFBQVF5UDtJQUNwQztLQUFJeFAsT0FBT3NQLG1CQUFtQkU7S0FDMUJsVSxPQUFPeVQsc0JBQXNCalAsTUFBTW1HLGlCQUFpQmpHO0lBQ3hELE9BQU9xRyxzQkFBc0J2RyxNQUFNQyxRQUFRQyxNQUFNMUU7R0FDbkQ7R0F5ZEEsU0FBU21VLG9CQUFvQkMsT0FBT0MsT0FBT0MsT0FBTzlQLE1BQU1DLFFBQVFDO0lBQzlELEdBQUcyUCxTQUFTdkosNkJBQTZCdEc7S0FDdkN4Rjs7SUFFRixPQUFPK0wsc0JBQXNCdkcsTUFBTUMsUUFBUUMsTUFBTTBQO0dBQ25EO0dtQm5uQkEsU0FBU0cseUJBQTBCdmI7SUFDdEIsSUFBUHdiLGFBQWFoUztJQUNqQmdTLFlBQVl4YjtJQUNDLElBQVR5YixlQUFlZCxhQUFhYTtJQUNoQyxPQUFPQztHQUNUO0dSMkxBLFNBQVNDLG9CQUFvQm5jO0lBQzNCO1lBQVdtSjthQUFRbkosWUFBYUEsWUFBY0E7YUFDM0JBLFlBQWFBLFlBQWNBO2FBQzNCQSxZQUFhQTtHQUNsQztHUXBQQSxTQUFTb2MseUJBQTBCM2I7SUFDakMsSUFBSTJJLEtBQUszSSxNQUNMNEksS0FBSzVJLE1BQ0w2SSxLQUFLN0ksTUFDTDRiLE9BQU8vUztJQUNYLEdBQUkrUztLQUFhLFFBQ1ZqVCxLQUFHQyxLQUFJQztlQUNGQSxnQkFBZWdULFdBQVVBO2VBRTFCM1A7SUFFWCxJQUFJNFAsSUFBSWhjLG1CQUNKeUgsT0FBT29CLEtBQUdtVCxJQUFFbFQsTUFBSWtULEtBQUdqVDtJQUN2QixHQUFJK1MsUUFBUztLQUNYclU7S0FDQUEsT0FBT3pILFlBQVc4Yjs7O0tBRWxCclUsT0FBT3pIO0lBQ1QsR0FBSStJLGFBQWF0QixRQUFRQTtJQUN6QixPQUFPQTtHQUNUO0duQitoQkEsU0FBU3dVLG9CQUFvQkMsUUFBUUMsSUFBSXBXO0lBQzFCLElBQVRxVyxXQUFXRjtJQUNmLEdBQUlFLGdCQUFnQkE7S0FDbEJsSTtJQUNGO0tBQUk3USxNQUFNNlk7S0FDTnhRLE9BQU9ySTtLQUNQc0ksU0FBVXRJO0tBQ1Z1STtJQUNKLEdBQUc3RjtLQUNELElBQVcsSUFBRnJHLE9BQU9BLElBQUkwYyxVQUFVMWMsSUFBSztNQUNwQixJQUFUMmMsV0FBV0g7TUFDZixHQUFHRyxtQkFBbUI7T0FDcEIsSUFBSUMsY0FBY0osa0JBQ2RLLGNBQWNMO09BQ2xCLEdBQUdJO1FBQ0RwSTtPQUNGbUksV0FBV0U7O01BRWIzUSxVQUFVeVE7OztLQUdaLElBQVcsSUFBRjNjLE9BQU9BLElBQUkwYyxVQUFVMWMsS0FBS2tNLFVBQVVzUTtJQUMvQztLQUFJbkssT0FBT0YsaUJBQWlCakc7S0FDeEIxRSxPQUFPeVQsc0JBQXNCalAsTUFBTXFHO0tBQ25DMVIsS0FBSzRSLHNCQUFzQnZHLE1BQU1DLFFBQVFDLE1BQU0xRTtJQUNuRCxPQUFPd0U7O09BRUwsSUFBVSxJQUFGaE0sT0FBT0EsSUFBSXFTLE1BQU1yUyxLQUN2QndILEtBQUt4SCxLQUFLd2MsaUJBRVo7OztPQUdBLElBQVUsSUFBRnhjLE9BQU9BLElBQUlxUyxNQUFNclMsS0FDdkJ3SCxLQUFLeEgsS0FBS3djLGlCQUVaOztPQUVBLElBQVUsSUFBRnhjLE9BQU9BLElBQUlxUyxNQUFNclMsS0FDdkJ3SCxLQUFLeEgsS0FBS3djLGtCQUVaOztPQUVBLElBQVUsSUFBRnhjLE9BQU9BLElBQUlxUyxNQUFNclMsS0FDdkJ3SCxLQUFLeEgsS0FBS3djLGtCQUVaOztPQUVBLElBQVUsSUFBRnhjLE9BQU9BLElBQUlxUyxNQUFNclMsS0FDdkJ3SCxLQUFLeEgsS0FBS3djLGtCQUVaOzs7T0FHVSxJQUFOTSxRQUFRTjtPQUNaLEdBQUdNO1FBQU90STs7T0FDVixJQUFVLElBQUZ4VSxPQUFPQSxJQUFJcVMsTUFBTXJTLEtBQ3ZCd0gsS0FBS3hILEtBQUt3YztPQUVaOztPQUVNLElBQUZuWixRQUFRcEM7T0FDWixJQUFVLElBQUZqQixPQUFPQSxJQUFJcVMsTUFBTXJTLElBQUk7UUFDM0IsSUFBVyxJQUFGa0IsT0FBTUEsT0FBTUEsS0FBS21DLEVBQUVuQyxLQUFLc2I7UUFDdkIsSUFBTk8sUUFBUWIsb0JBQW9CN1k7UUFDaEMxQyxPQUFPWCxHQUFFK2M7O09BRVg7O09BRU0sSUFBRjFaLFFBQVFwQztPQUNaLElBQVUsSUFBRmpCLE9BQU9BLElBQUlxUyxNQUFNclMsSUFBSTtRQUMzQixJQUFXLElBQUZrQixPQUFNQSxPQUFNQSxLQUFLbUMsRUFBRW5DLEtBQUtzYjtRQUMzQixJQUFGdGMsSUFBSWljLHlCQUF5QkQsb0JBQW9CN1k7UUFDckQxQyxPQUFPWCxHQUFFRTs7T0FFWDs7T0FFQSxJQUFVLElBQUZGLE9BQU9BLElBQUlxUyxNQUFNclMsSUFBSTtRQUNyQixJQUFGRSxJQUFJNmIseUJBQXlCUztRQUNqQzdiLE9BQU9YLEdBQUVFOztPQUVYOztPQUVBLElBQVUsSUFBRkYsT0FBT0EsSUFBSXFTLE1BQU1yUyxJQUFJO1FBQzNCO1NBQUlzTSxLQUFLeVAseUJBQXlCUztTQUM5Qm5RLEtBQUswUCx5QkFBeUJTO1FBQ2xDN2IsT0FBT1gsU0FBT3NNLElBQUdEOztPQUVuQjs7T0FFTSxJQUFGaEosUUFBUXBDO09BQ1osSUFBVSxJQUFGakIsT0FBT0EsSUFBSXFTLE1BQU1yUyxJQUFJO1FBQzNCLElBQVcsSUFBRmtCLE9BQU1BLE9BQU1BLEtBQUttQyxFQUFFbkMsS0FBS3NiO1FBQzFCLElBQUhsUSxLQUFLNlAseUJBQXlCRCxvQkFBb0I3WTtRQUN0RCxJQUFXLElBQUZuQyxPQUFNQSxPQUFNQSxLQUFLbUMsRUFBRW5DLEtBQUtzYjtRQUMxQixJQUFIblEsS0FBSzhQLHlCQUF5QkQsb0JBQW9CN1k7UUFDdEQxQyxPQUFPWCxTQUFPc00sSUFBR0Q7O09BRW5COztJQUVGb1EsYUFBYUM7SUFDYixPQUFPbkssc0JBQXNCdkcsTUFBTUMsUUFBUUMsTUFBTTFFO0dBQ25EO0dBaGJBLFNBQVN3VixjQUFjcmMsSUFDckIsT0FBT3FVLFlBQVlyVSxPQUNyQjtHQUlBLFNBQVNzYyxjQUFjdGMsSUFDckIsT0FBT3FVLFlBQVlyVSxPQUNyQjtHQUlBLFNBQVN1YyxjQUFjdmMsSUFDckIsT0FBT3FVLFlBQVlyVSxPQUNyQjtHQTJIQSxTQUFTd2MsYUFBYXhjLElBQUk4QyxHQUN4QjlDLFFBQVE4QyxJQUNSLFNBQ0Y7R0F5WEEsU0FBUzJaLDRCQUE0QjFHO0lBQ25DLElBQUkxSztJQUNKLEdBQVMwSyxjQUFjeUU7S0FBY25QO1lBQzVCMEssY0FBYzBFO0tBQWNwUDtZQUM1QjBLLGNBQWMyRTtLQUFXclA7WUFDekIwSyxjQUFjL1E7S0FBWXFHO1lBQzFCMEssY0FBYzJHO0tBQW1CclI7WUFDakMwSyxjQUFjNEU7S0FBWXRQO1lBQzFCMEssY0FBYzZFO0tBQWF2UDtZQUMzQjBLLGNBQWMxTTtLQUFZZ0M7WUFDMUIwSyxjQUFjbUI7S0FBYTdMOztLQUMvQnhGO0lBQ0wsT0FBT3dGO0dBQ1Q7R0FLQSxTQUFTc1IseUJBQXlCNUc7SUFDaEM7S0FBSTFLLE9BQU9vUiw0QkFBNEIxRztLQUNuQ0E7T0FHQUEsY0FBY21CO2NBQ1Y3TixXQUFXME0sV0FBV0EsZUFBZUE7VUFBYUE7SUFDMUQsT0FBT25FLHNCQUFzQnZHLFVBQVUwSyxZQUFZQTtHQUNyRDtHQXpkQSxTQUFTNkcsY0FBYzVjLElBQUlDLElBQUlpRyxJQUM3QixPQUFPbEcsT0FBT0EsV0FBV0MsSUFBR2lHLE1BQzlCO0dBR0EsU0FBUzJXLGNBQWM3YyxJQUFJQyxJQUFJaUcsSUFBSUU7SUFDakMsT0FBT3BHLE9BQU9BLFdBQVdDLElBQUdpRyxJQUFHRTtHQUNqQztHQTNEQSxTQUFTMFcsb0JBQW9COWMsSUFBSVg7SUFDdkIsSUFBSm9NLE1BQU16TCxVQUFVNmEsbUJBQW1CeGI7SUFDdkMsT0FBT1csT0FBT3lMO0dBQ2hCO0d3QmhTQSxTQUFTc1IsU0FBUzNkLEdBQUVxRCxHQUNsQixPQUFPOUMsVUFBVVAsR0FBRXFELEdBQ3JCO0dDVEEsU0FBU3VhLGtCQUFrQnBVLEdBQUV2RjtJQUMzQkEsSUFBSTBaLFNBQVMxWjtJQUNiQSxJQUFNQSxVQUFZQTtJQUNsQkEsSUFBSTBaLFNBQVMxWjtJQUNidUYsS0FBS3ZGO0lBQ0x1RixJQUFNQSxVQUFZQTtJQUNsQixRQUFVQSxLQUFLQTtHQUNqQjtHTnpFWSxJQUFScVUsVUFBVXRkLGFBQWFBO0dBQzNCLFNBQVN1ZCxnQkFBZ0JyZDtJQUN2QixHQUFHb2QsU0FBUyxPQUFPdGQsV0FBV0EsVUFBVUU7SUFDbEMsSUFBRlI7SUFDSixHQUFJUSxRQUFRLFNBQVE2YjtJQUNwQixHQUFHN2IsUUFBTSxNQUFRQSxPQUFNLENBQUNBLFFBQU1SLFdBQ3pCLE1BQVFRLE1BQU8sQ0FBQ0EsUUFBTVI7SUFDM0IsT0FBT0E7R0FDVDtHUmdVQSxTQUFTOGQsMkJBQTJCM1UsSUFBSUMsSUFBSUMsSUFDMUMsV0FBV0gsUUFBUUMsSUFBSUMsSUFBSUM7R0FDN0I7R1E5VEEsU0FBUzBVLHlCQUEwQnZkO0lBQ2pDLEtBQUt3ZCxTQUFTeGQsR0FBSTtLQUNoQixHQUFJeWQsTUFBTXpkLElBQ1IsT0FBT3NkO0tBQ1QsT0FBSXRkO2VBQ0tzZDtlQUVBQTs7SUFFRixJQUFMdFUsT0FBUWhKLGNBQVVBLE9BQU02YixvQkFBa0I3YjtJQUM5QyxHQUFJZ0osTUFBTWhKLE1BQUtBO0lBR1AsSUFBSjRiLE1BQU15QixnQkFBZ0JyZDtJQUMxQixHQUFJNGIsU0FBVTtLQUNaQTtLQUNBNWIsS0FBS0Y7O1FBQ0E7S0FDTEUsS0FBS0YsWUFBVzhiO0tBQ2hCLEdBQUk1YixPQUFRLENBQ1ZBLFFBQVE0YjtLQUNWLEdBQUlBLFVBQ0Y1Yjs7SUFFSixJQUFJOGIsSUFBSWhjLGlCQUNKNGQsS0FBSzFkO0lBQ1RBLEtBQUtBLElBQUkwZCxNQUFNNUI7SUFDUixJQUFINkIsS0FBSzNkO0lBQ1RBLEtBQUtBLElBQUkyZCxNQUFNN0I7SUFDUixJQUFIOEIsS0FBSzVkO0lBQ1QwZCxLQUFNQSxXQUFXMVUsT0FBTzRTO0lBQ3hCLE9BQU8wQiwyQkFBMkJNLElBQUlELElBQUlEO0dBQzVDO0dNa0RBLFNBQVNHLG9CQUFxQjlVLEdBQUc5RjtJQUMvQjhGLElBQUlvVSxrQkFBa0JwVSxHQUFHcUMsZ0JBQWdCbkk7SUFDekM4RixJQUFJb1Usa0JBQWtCcFUsR0FBR29DLGdCQUFnQmxJO0lBQ3pDLE9BQU84RjtHQUNUO0dBVkEsU0FBUytVLG9CQUFxQi9VLEdBQUdnVjtJQUMvQixPQUFPRixvQkFBb0I5VSxHQUFHd1UseUJBQTBCUTtHQUMxRDtHekJ3ckJBLFNBQVNDLGFBQWE3ZDtJQUNwQixJQUFJOGQsV0FBV3RNLGlCQUFpQnhSLFVBQzVCNEk7SUFDSixPQUFPNUk7Ozs7T0FJTCxHQUFHOGQsZ0JBQWdCQTtPQUNuQixJQUFJbkgsT0FBT3RYO09BQ1gsSUFBSUEsT0FBT0EsU0FBU1csZ0JBQWdCWCxPQUFLO1FBQ3ZDc1g7U0FBSTNXLFFBQVFYLFNBQVFXLFFBQVFYLGNBQWNXLFFBQVFYO1dBQWVXLFFBQVFYO1FBQ3pFdUosSUFBSW9VLGtCQUFrQnBVLEdBQUUrTjs7T0FFMUJBO09BQ0EsT0FBUW1IOztVQUNBbkgsSUFBSzNXLFFBQVFYOztVQUNic1gsS0FBSzNXLFFBQVFYOztVQUNic1gsS0FBSzNXLFFBQVFYLFFBQ25CdUosSUFBSW9VLGtCQUFrQnBVLEdBQUcrTjs7T0FFM0I7OztPQUdBLEdBQUdtSCxnQkFBZ0JBO09BQ25CLElBQUluSCxPQUFPdFg7T0FDWCxJQUFJQSxPQUFPQSxTQUFTVyxnQkFBZ0JYLE9BQUs7UUFDdkNzWCxJQUFJM1csUUFBUVgsU0FBUVcsUUFBUVg7UUFDNUJ1SixJQUFJb1Usa0JBQWtCcFUsR0FBRStOOztPQUUxQixJQUFLbUgsb0JBQ0hsVixJQUFJb1Usa0JBQWtCcFUsR0FBRzVJLFFBQVFYO09BQ25DOztPQUVBLEdBQUl5ZSxlQUFlQTtPQUNuQixJQUFXLElBQUZ6ZSxPQUFPQSxJQUFJeWUsVUFBVXplLEtBQUt1SixJQUFJb1Usa0JBQWtCcFUsR0FBRzVJLFFBQVFYO09BQ3BFOzs7T0FHQSxHQUFJeWUsZUFBZUE7T0FDbkIsSUFBVyxJQUFGemUsT0FBT0EsSUFBSXllLFVBQVV6ZSxLQUFLdUosSUFBSW9VLGtCQUFrQnBVLEdBQUc1SSxRQUFRWDtPQUNwRTs7T0FFQSxHQUFJeWUsZUFBZUE7T0FDbkJBO09BQ0EsSUFBVyxJQUFGemUsT0FBT0EsSUFBSXllLFVBQVV6ZSxLQUM1QnVKLElBQUlvVSxrQkFBa0JwVSxHQUFHNUksUUFBUVg7T0FFbkM7O09BRUF5ZTs7T0FFQSxHQUFJQSxlQUFlQTtPQUNuQixJQUFXLElBQUZ6ZSxPQUFPQSxJQUFJeWUsVUFBVXplO1FBQUt1SixJQUFJK1Usb0JBQW9CL1UsR0FBRzVJLFFBQVFYO09BQ3RFOztPQUVBeWU7O09BRUEsR0FBSUEsZUFBZUE7T0FDbkIsSUFBVyxJQUFGemUsT0FBT0EsSUFBSXllLFVBQVV6ZTtRQUFLdUosSUFBSStVLG9CQUFvQi9VLEdBQUc1SSxRQUFRWDtPQUN0RTs7SUFFRixPQUFPdUo7R0FDVDtHQXowQkEsU0FBU21WLGVBQ1AsU0FDRjtHQW1UQSxTQUFTQyxhQUFhaGUsSUFDcEIsT0FBT0EsUUFDVDtHQUdBLFNBQVNpZSxlQUFlamUsSUFDdEIsT0FBT0EsVUFDVDtHUzNFQSxTQUFTa2UsaUJBQWlCQyxLQUFLOVMsTUFBTUMsUUFBUThTLFFBQVE3UyxNQUFNOUUsS0FFekRvTjtHQUNGO0dBSUEsU0FBU3dLLDBCQUEwQi9GLE1BQUtnRztJQUN0QyxPQUFPSjthQUFpQjVGLFNBQVFBLFNBQVFBLFNBQVFBLFNBQVFBLFNBQVFBO0dBQ2xFO0dUcUVBLFNBQVNpRyxpQkFBaUJ2ZSxJQUN4QixPQUFPQSxlQUNUO0dBc09BLFNBQVN3ZSxnQkFBZ0J4ZSxJQUFJeWU7SUFDM0JBLE9BQU81RCxtQkFBbUI0RDtJQUMxQixJQUFJQyxjQUNBM0MsV0FBVzBDO0lBRWYsR0FBSTFDLGdCQUFnQkE7S0FDbEJsVztJQUVXLElBQVRpWTtJQUNKLElBQVcsSUFBRnplLE9BQU9BLElBQUkwYyxVQUFVMWMsSUFBSztLQUNqQ3FmLFFBQVFyZixLQUFLb2YsS0FBS3BmO0tBQ2xCLEdBQUlxZixRQUFRcmY7TUFDVndHO0tBQ0ZpWSxXQUFXQSxXQUFXWSxRQUFRcmY7O0lBR3ZCLElBQUxxUyxPQUFPRixpQkFBaUJ4UjtJQUU1QixHQUFJOGQsWUFBWXBNO0tBQ2Q3TDtJQUNGLE9BQU8rTCxzQkFBc0I1UixTQUFTQSxXQUFXMGUsU0FBUzFlO0dBQzVEO0dtQm5oQkEsU0FBUzJlLHlCQUEwQjllO0lBQ3BCLElBQVR5YixlQUFlZDtJQUNuQmMsY0FBY3piO0lBQ0gsSUFBUHdiLGFBQWFoUyxXQUFXaVM7SUFDNUIsT0FBT0Q7R0FDVDtHUjRTQSxTQUFTdUQsb0JBQW9CL2UsR0FBSyxPQUFPQSxZQUFZO0dYdU9yRCxTQUFTZ2Ysa0JBQWtCQyxRQUFROWUsSUFBSThiO0lBQ3JDZ0QsaUJBQWlCOWU7SUFDakI4ZSxpQkFBa0I5ZSxVQUFXQTtJQUM3QixHQUFHQTtLQUNELElBQVUsSUFBRlgsT0FBT0EsSUFBSVcsZ0JBQWdCWDtNQUFLLEdBQ25DVyxRQUFRWDtPQUNUeWYsaUJBQWlCOWUsUUFBUVg7VUFDdEI7T0FDSHlmO09BQ0FBO09BQ0FBLGlCQUFpQjllLFFBQVFYOzs7S0FJN0IsSUFBVSxJQUFGQSxPQUFPQSxJQUFJVyxnQkFBZ0JYLEtBQUt5ZixpQkFBZ0I5ZSxRQUFRWDtJQUNsRSxPQUFPVzs7OztPQUlMLElBQVUsSUFBRlgsT0FBT0EsSUFBSVcsZ0JBQWdCWCxLQUNqQ3lmLGdCQUFnQjllLFFBQVFYO09BRTFCOzs7T0FHQSxJQUFVLElBQUZBLE9BQU9BLElBQUlXLGdCQUFnQlgsS0FDakN5ZixpQkFBaUI5ZSxRQUFRWDtPQUUzQjs7T0FFQSxJQUFVLElBQUZBLE9BQU9BLElBQUlXLGdCQUFnQlgsS0FDakN5ZixpQkFBaUI5ZSxRQUFRWDtPQUUzQjs7O09BR0F5ZjtPQUNBLElBQVUsSUFBRnpmLE9BQU9BLElBQUlXLGdCQUFnQlgsS0FDakN5ZixpQkFBaUI5ZSxRQUFRWDtPQUUzQjs7T0FFQSxJQUFVLElBQUZBLE9BQU9BLElBQUlXLG9CQUFvQlgsSUFBSTtRQUNuQyxJQUFGb0QsSUFBSW1jLG9CQUFvQjVlLE9BQU9YO1FBQ25DLElBQVcsSUFBRmtCLE9BQU9BLE9BQU9BLEtBQUt1ZSxnQkFBaUJyYyxFQUFFbEM7O09BRWpEOztPQUVBLElBQVUsSUFBRmxCLE9BQU9BLElBQUlXLGdCQUFnQlgsSUFBSTtRQUMvQixJQUFGb0QsSUFBSW1jLG9CQUFvQnhCLHlCQUF5QnBkLE9BQU9YO1FBQzVELElBQVcsSUFBRmtCLE9BQU9BLE9BQU9BLEtBQUt1ZSxnQkFBaUJyYyxFQUFFbEM7O09BRWpEOztPQUVBLElBQVUsSUFBRmxCLE9BQU9BLElBQUlXLGdCQUFnQlgsSUFBSTtRQUMvQixJQUFGb0QsSUFBSWtjLHlCQUF5QjNlLE9BQU9YO1FBQ3hDeWYsaUJBQWlCcmM7O09BRW5COztPQUVBLElBQVUsSUFBRnBELE9BQU9BLElBQUlXLG9CQUFvQlgsSUFBSTtRQUNuQyxJQUFGa0IsSUFBSVAsT0FBT1g7UUFDZnlmLGlCQUFpQkgseUJBQXlCcGU7UUFDMUN1ZSxpQkFBaUJILHlCQUF5QnBlOztPQUU1Qzs7T0FFQSxJQUFVLElBQUZsQixPQUFPQSxJQUFJVyxvQkFBb0JYLElBQUk7UUFDekM7U0FBSTBmLFVBQVUvZSxPQUFPWDtTQUNqQm9ELElBQUltYyxvQkFBb0J4Qix5QkFBeUIyQjtRQUNyRCxJQUFXLElBQUZ4ZSxPQUFPQSxPQUFPQSxLQUFLdWUsZ0JBQWlCcmMsRUFBRWxDO1FBQ3pDLElBQUZrQyxJQUFJbWMsb0JBQW9CeEIseUJBQXlCMkI7UUFDckQsSUFBVyxJQUFGeGUsT0FBT0EsT0FBT0EsS0FBS3VlLGdCQUFpQnJjLEVBQUVsQzs7T0FFakQ7O0lBRUZ1YixhQUFhOWI7SUFDYjhiLGFBQWE5YjtHQUNmO0dBM01BLFNBQVNnZixjQUFjaGYsSUFBSUMsSUFBSTZDLEdBQzdCOUMsT0FBT0EsVUFBVUMsS0FBSzZDLElBQ3RCLFNBQ0Y7R0FHQSxTQUFTbWMsY0FBY2pmLElBQUlDLElBQUlpRyxJQUFJcEQ7SUFDakM5QyxPQUFPQSxXQUFXQyxJQUFHaUcsTUFBTXBEO0lBQzNCO0dBQ0Y7R0FHQSxTQUFTb2MsY0FBY2xmLElBQUlDLElBQUlpRyxJQUFJRSxJQUFJdEQ7SUFDckM5QyxPQUFPQSxXQUFXQyxJQUFHaUcsSUFBR0UsTUFBTXREO0lBQzlCO0dBQ0Y7R0FyREEsU0FBU3FjLG9CQUFvQm5mLElBQUlYLEdBQUd5RDtJQUNsQzlDLE9BQU9BLFVBQVU2YSxtQkFBbUJ4YixLQUFLeUQ7SUFDekM7R0FDRjtHQXFHQSxTQUFTc2MsY0FBY3BmLElBQUl5ZTtJQUN6QkEsT0FBTzVELG1CQUFtQjREO0lBQzFCLElBQUlZLFdBQVdaLGFBQ1h0RixZQUNBbUcsZUFDQTdUO0lBRUosR0FBSTRULFdBQVdyZjtLQUNiNkY7SUFHRixHQUFJN0YsZUFBZ0I7S0FDbEIsSUFBVyxJQUFGWCxPQUFPQSxJQUFJZ2dCLFVBQVVoZ0IsS0FDNUI4WixNQUFNOVosS0FBS29mLEtBQUtwZjtLQUNsQixNQUFPQSxJQUFJVyxnQkFBZ0JYLEtBQ3pCOFosTUFBTTlaO0tBQ1JpZ0IsV0FBV3RmLGNBQWNxZjs7UUFDcEI7S0FDTCxJQUFXLElBQUZoZ0IsT0FBT0EsSUFBSWdnQixVQUFVaGdCO01BQzVCOFosTUFBTW5aLGlCQUFpQnFmLFdBQVdoZ0IsS0FBS29mLEtBQUtwZjtLQUM5QyxJQUFXLElBQUZBLE9BQU9BLElBQUlXLGlCQUFpQnFmLFVBQVVoZ0IsS0FDN0M4WixNQUFNOVo7S0FDUmlnQixXQUFXdGYsaUJBQWlCQSxpQkFBaUJxZjs7SUFFL0M1VCxNQUFNekwsVUFBVW1aO0lBQ2hCO0tBQUl6SCxPQUFPRixpQkFBaUI4TjtLQUN4QnpOLG1CQUFtQkYsNkJBQTZCM1I7S0FDaER1ZjtPQUFXdmY7U0FBaUJ5TCxNQUFNb0csbUJBQW1CcEcsTUFBTWlHLFFBQVFHO0lBQ3ZFLE9BQU9ELHNCQUFzQjVSLFNBQVNBLFdBQVdzZixVQUFVQztHQUM3RDtHQXpEQSxTQUFTQyxZQUFZeGYsSUFBSXlMLEtBQUtuTTtJQUM1QixJQUFJbWdCLGFBQ0FDO0lBQ0osR0FBSTFmLGVBQWdCO0tBQ2xCLElBQVcsSUFBRlgsT0FBT0EsSUFBSVcsZ0JBQWdCWCxLQUNsQ3FnQixNQUFNQSxNQUFNMWYsUUFBUVg7S0FDdEJvZ0I7O1FBQ0s7S0FDTCxJQUFXLElBQUZwZ0IsT0FBT0EsSUFBS1csb0JBQXFCWCxLQUN4Q3FnQixNQUFNQSxNQUFNMWYsUUFBUVg7S0FDdEJvZ0IsY0FBY3pmO0tBQ2R5TCxNQUFNQTs7SUFFUixHQUFJQSxXQUFXbk0sV0FBWW1NLE1BQU1uTSxNQUFPVSxRQUFReWY7S0FDOUM1WjtJQUVXLElBQVR1VTtJQUNKLElBQVcsSUFBRi9hLE9BQU9BLElBQUlXLGdCQUFnQlgsS0FDbEMrYSxTQUFTL2EsS0FBS1csUUFBUVg7SUFDeEIrYSxTQUFTcUYsZUFBZW5nQjtJQUN4Qm9nQixPQUFPL04sNkJBQTZCM1I7SUFDdkIsSUFBVHVmLFdBQVd2ZixpQkFBaUJ5TCxNQUFNaVUsTUFBTWpVLE1BQU1uTSxPQUFPb2dCO0lBQ3pELE9BQU85TixzQkFBc0I1UixTQUFTQSxXQUFXb2EsVUFBVW1GO0dBQzdEO0dBM0pBLFNBQVNJLG9CQUFvQjNmLElBQUlDO0lBQ3ZCLElBQUp3TCxNQUFNekwsVUFBVUM7SUFDcEIsR0FBR3dMLFdBQVd6TCxnQkFBZ0JrTDtJQUM5QixJQUFJMFUsS0FBSzVmLE9BQU95TCxNQUNab1UsS0FBSzdmLE9BQU95TDtJQUNoQixPQUFRbVUsS0FBTUM7R0FDaEI7R0FJQSxTQUFTQyxvQkFBb0I5ZixJQUFJQztJQUN2QixJQUFKd0wsTUFBTXpMLFVBQVVDO0lBQ3BCLEdBQUd3TCxXQUFXekwsZ0JBQWdCa0w7SUFDOUI7S0FBSTBVLEtBQUs1ZixPQUFPeUw7S0FDWm9VLEtBQUs3ZixPQUFPeUw7S0FDWnNVLEtBQUsvZixPQUFPeUw7S0FDWnVVLEtBQUtoZ0IsT0FBT3lMO0lBQ2hCLE9BQVVtVSxVQUNBQyxVQUNBRSxXQUNBQztHQUNaO0dBSUEsU0FBU0Msb0JBQW9CamdCLElBQUlDO0lBQ3ZCLElBQUp3TCxNQUFNekwsVUFBVUM7SUFDcEIsR0FBR3dMLFdBQVd6TCxnQkFBZ0JrTDtJQUM5QjtLQUFJMFUsS0FBSzVmLE9BQU95TDtLQUNab1UsS0FBSzdmLE9BQU95TDtLQUNac1UsS0FBSy9mLE9BQU95TDtLQUNadVUsS0FBS2hnQixPQUFPeUw7S0FDWnlVLEtBQUtsZ0IsT0FBT3lMO0tBQ1owVSxLQUFLbmdCLE9BQU95TDtLQUNaMlUsS0FBS3BnQixPQUFPeUw7S0FDWjBMLEtBQUtuWCxPQUFPeUw7SUFDaEIsT0FBTzhQLHFCQUFxQnBFLElBQUdpSixJQUFHRCxJQUFHRCxJQUFHRixJQUFHRCxJQUFHRixJQUFHRDtHQUNuRDtHQTBCQSxTQUFTUyxvQkFBb0JyZ0IsSUFBSUMsSUFBSTZDO0lBQzNCLElBQUoySSxNQUFNekwsVUFBVUM7SUFDcEIsR0FBR3dMLFdBQVd6TCxnQkFBZ0JrTDtJQUM5QmxMLE9BQU95TCxTQUFRM0k7SUFDZjlDLE9BQU95TCxTQUFRM0k7SUFDZjtHQUNGO0dBSUEsU0FBU3dkLG9CQUFvQnRnQixJQUFJQyxJQUFJNkM7SUFDM0IsSUFBSjJJLE1BQU16TCxVQUFVQztJQUNwQixHQUFHd0wsV0FBV3pMLGdCQUFnQmtMO0lBQzlCbEwsT0FBT3lMLFNBQVEzSTtJQUNmOUMsT0FBT3lMLFNBQVEzSTtJQUNmOUMsT0FBT3lMLFNBQVEzSTtJQUNmOUMsT0FBT3lMLFNBQVEzSTtJQUNmO0dBQ0Y7R0FJQSxTQUFTeWQsb0JBQW9CdmdCLElBQUlDLElBQUk2QztJQUMzQixJQUFKMkksTUFBTXpMLFVBQVVDO0lBQ3BCLEdBQUd3TCxXQUFXekwsZ0JBQWdCa0w7SUFDeEIsSUFBRnBJLElBQUk4YixvQkFBb0I5YjtJQUM1QixJQUFVLElBQUZ6RCxPQUFPQSxPQUFPQSxLQUFLVyxPQUFPeUwsTUFBSXBNLEdBQUd5RCxNQUFJekQ7SUFDN0M7R0FDRjtHTXBiQSxTQUFTbWhCLHNCQUF1QkM7SUFBUyxPQUFPbmM7R0FBb0M7R1dNcEYsU0FBU29jLDZCQUE2QkMsS0FBS0MsTUFBTUMsS0FBS0MsTUFBTXhoQjtJQUMxRCxTQUFTcWhCO0tBQ1A5YTtJQUNGLFNBQVNnYjtLQUNQaGI7SUFDRixHQUFHdkcsVUFBVTtJQUNiLElBQUlrVyxPQUFPbUwsV0FBV0MsT0FDbEJqTCxPQUFPa0wsV0FBV0M7SUFDdEIsR0FBR3RMLE9BQU9sVyxNQUFNcWhCLGlCQUNkelY7SUFFRixHQUFHeUssT0FBT3JXLE1BQU11aEIsaUJBQ2QzVjtJQUVRLElBQU42VixRQUFRSixrQkFBa0JuTCxNQUFLQSxPQUFLbFc7SUFDeEN1aEIsYUFBYUUsT0FBTUQ7SUFDbkI7R0FDRjtHQTRDQSxTQUFTRSxnQ0FBZ0NMLEtBQUtDLE1BQU1LLFFBQVFILE1BQU14aEI7SUFDaEUsU0FBU3FoQjtLQUNQOWE7SUFDRixHQUFHdkcsVUFBVTtJQUNKLElBQUxrVyxPQUFPbUwsV0FBV0M7SUFDdEIsR0FBR3BMLE9BQU9sVyxNQUFNcWhCLGlCQUNkelY7SUFFRixHQUFHNFYsT0FBT3hoQixNQUFNeUcscUJBQXFCa2IsU0FDbkMvVjtJQUVRLElBQU42VixRQUFRSixlQUFlbkwsTUFBTUEsT0FBS2xXO0lBQ3RDMEcsZ0JBQWdCakIsb0JBQW9CZ2MsV0FBV0UsUUFBUUgsTUFBTXhoQjtJQUM3RDtHQUNGO0dBbENBLFNBQVM0aEIsZ0NBQWdDQyxNQUFNUCxNQUFNQyxLQUFLQyxNQUFNeGhCO0lBQzlELFNBQVN1aEI7S0FDUGhiO0lBQ0YsR0FBR3ZHLFVBQVU7SUFDSixJQUFMcVcsT0FBT2tMLFdBQVdDO0lBQ3RCLEdBQUdGLE9BQU90aEIsTUFBTXlHLHFCQUFxQm9iLE9BQ25Dalc7SUFFRixHQUFHeUssT0FBT3JXLE1BQU11aEIsaUJBQ2QzVjtJQUVRLElBQU42VixRQUFRbmIsMEJBQTBCdWIsWUFBWVAsTUFBS0EsT0FBT3RoQjtJQUM5RHVoQixhQUFhRSxPQUFNcEw7SUFDbkI7R0FDRjtHQWpDQSxTQUFTeUwsaUNBQWlDRCxNQUFNUCxNQUFNQyxLQUFLQyxNQUFNeGhCO0lBQy9ELFNBQVN1aEI7S0FDUGhiO0lBQ0YsR0FBR3ZHLFVBQVU7SUFDSixJQUFMcVcsT0FBT2tMLFdBQVdDO0lBQ3RCLEdBQUdGLE9BQU90aEIsTUFBTWdLLHNCQUFzQjZYLE9BQ3BDalc7SUFFRixHQUFHeUssT0FBT3JXLE1BQU11aEIsaUJBQ2QzVjtJQUVRLElBQU42VixRQUFRdlgsMkJBQTJCMlgsWUFBWVAsTUFBS0EsT0FBT3RoQjtJQUMvRHVoQixhQUFhRSxPQUFNcEw7SUFDbkI7R0FDRjtHQWhEQSxTQUFTMEwsc0JBQXNCcGIsSUFBSTJhLE1BQU16YSxJQUFJMmEsTUFBTXhoQjtJQUNqRCxJQUFXLElBQUZELE9BQU9BLElBQUlDLEtBQUtELElBQUs7S0FDNUIsSUFBSUQsSUFBSVcsY0FBY2tHLElBQUcyYSxPQUFPdmhCLElBQzVCb0QsSUFBSTFDLGNBQWNvRyxJQUFHMmEsT0FBT3poQjtLQUNoQyxHQUFJRCxJQUFJcUQsR0FBRztLQUNYLEdBQUlyRCxJQUFJcUQsR0FBRzs7SUFFYjtHQUNGO0dsQnFsQkEsU0FBUzZlLGlCQUFpQmxpQixHQUFFcUQsR0FBRUUsR0FBRVUsR0FBRXFMO0lBQ2hDMUksZ0JBQWdCYixxQkFBcUIvRixJQUFHcUQsR0FBRUUsR0FBRVUsR0FBRXFMO0lBQzlDO0dBQ0Y7R3lCbGhCQSxTQUFTNlMsYUFBYTFoQixHQUNwQixRQUFXQSxvQkFDQUEsaUJBQ2I7R3BCaUNBLFNBQVMyaEIsbUJBQW1CQztJQUNwQixJQUFGcmY7SUFDSixHQUFHcWY7S0FBTSxJQUNHLElBQUZwaUIsT0FBT0EsSUFBSW9pQixhQUFhcGlCO01BQzlCK0MsRUFBRWlRLHdCQUF3Qm9QLEtBQUtwaUIsVUFBVW9pQixLQUFLcGlCO0lBR2xELE9BQU8rQztHQUNUO0dMNFdBLFNBQVNzZixtQkFBbUJ6YixJQUFJRTtJQUM3QkYsWUFBYTNELDZCQUE2QjJEO0lBQzFDRSxZQUFhN0QsNkJBQTZCNkQ7SUFDM0MsT0FBUUYsT0FBT0UsYUFBVUYsT0FBT0U7R0FDbEM7R0FLQSxTQUFTd2IsaUJBQWlCMWIsSUFBSUU7SUFDNUIsR0FBR0YsT0FBT0UsSUFBSTtJQUNiRixZQUFhM0QsNkJBQTZCMkQ7SUFDMUNFLFlBQWE3RCw2QkFBNkI2RDtJQUMzQyxPQUFRRixRQUFRRTtHQUNsQjtHQXZXQSxTQUFTeWIsc0JBQXVCbGlCLEdBQUdMO0lBQ2pDLE9BQVFLO2VBRU4sR0FBSUwsS0FBS0ssWUFBWTs7T0FFckIsT0FBT0EsZUFBZUw7O09BRXRCLE9BQU9LLElBQUlMOztHQUVmO0dBNEdBLFNBQVN3aUIsZUFBZ0JuaUIsR0FBR0w7SUFDMUIsR0FBSUEsV0FBV0ssS0FBSytKO0lBQ3BCLE9BQU9tWSxzQkFBdUJsaUIsR0FBR0w7R0FDbkM7R0E1REEsU0FBU3lpQixpQkFBaUJwaUIsR0FBRUw7SUFDMUIsR0FBSUEsV0FBV0ssU0FBUytKO0lBQ3hCO0tBQUltVyxLQUFLZ0Msc0JBQXVCbGlCLEdBQUdMO0tBQy9Cd2dCLEtBQUsrQixzQkFBdUJsaUIsR0FBR0w7SUFDbkMsT0FBUXdnQixVQUFVRDtHQUNwQjtHQWdCQSxTQUFTbUMsaUJBQWlCcmlCLEdBQUVMO0lBQzFCLEdBQUlBLFdBQVdLLFNBQVMrSjtJQUN4QjtLQUFJbVcsS0FBS2dDLHNCQUF1QmxpQixHQUFHTDtLQUMvQndnQixLQUFLK0Isc0JBQXVCbGlCLEdBQUdMO0tBQy9CMGdCLEtBQUs2QixzQkFBdUJsaUIsR0FBR0w7S0FDL0IyZ0IsS0FBSzRCLHNCQUF1QmxpQixHQUFHTDtJQUNuQyxPQUFRMmdCLFdBQVdELFdBQVdGLFVBQVVEO0dBQzFDO0dBa0JBLFNBQVNvQyxpQkFBaUJ0aUIsR0FBRUw7SUFDMUIsR0FBSUEsV0FBV0ssU0FBUytKO0lBQ2xCLElBQUZySyxRQUFRa0I7SUFDWixJQUFVLElBQUZDLE9BQU9BLE9BQU9BLEtBQ3BCbkIsTUFBTW1CLEtBQUtxaEIsc0JBQXVCbGlCLEdBQUdMLElBQUlrQjtJQUUzQyxPQUFPZ2Isb0JBQW9CbmM7R0FDN0I7R0FrUUEsU0FBUzZpQixxQkFBcUJoYyxJQUFJRTtJQUMvQkYsWUFBYTNELDZCQUE2QjJEO0lBQzFDRSxZQUFhN0QsNkJBQTZCNkQ7SUFDM0MsT0FBUUYsUUFBUUU7R0FDbEI7R0FpQkEsU0FBUytiLHdCQUF3QmpjLElBQUlFLElBQ25DLE9BQU84YixxQkFBcUI5YixJQUFHRjtHQUNqQztHQWZBLFNBQVNrYyxvQkFBb0JsYyxJQUFJRTtJQUM5QkYsWUFBYTNELDZCQUE2QjJEO0lBQzFDRSxZQUFhN0QsNkJBQTZCNkQ7SUFDM0MsT0FBUUYsT0FBT0U7R0FDakI7R0FxQkEsU0FBU2ljLHVCQUF1Qm5jLElBQUlFLElBQ2xDLE9BQU9nYyxvQkFBb0JoYyxJQUFJRjtHQUNqQztHQXZDQSxTQUFTb2Msb0JBQW9CcGMsSUFBSUUsSUFBTSxXQUFTd2IsaUJBQWlCMWIsSUFBSUUsSUFBSztHQTdJMUUsU0FBU21jLDZCQUE4QjVpQjtJQUM3QixJQUFKc0Q7SUFDSixLQUFLVCxjQUFjN0MsSUFDakJzRCxTQUFpQ3RELElBQUkwRCxtQkFBbUIxRDtJQUMxRCxXQUFXcUQsUUFBUUMsS0FBS3RELEdBQUdBO0dBQzdCO0dBNUZBLFNBQVM2aUIsaUJBQWlCN2lCLEdBQUVMLEdBQUVtakI7SUFDNUIsR0FBSW5qQixXQUFXSyxTQUFTK0o7SUFDeEIsSUFBSW9XLFlBQVkyQyxVQUNaNUMsWUFBWTRDO0lBQ2hCOVksc0JBQXVCaEssR0FBR0wsT0FBT3VnQjtJQUNqQ2xXLHNCQUF1QmhLLEdBQUdMLE9BQU93Z0I7SUFDakM7R0FDRjtHQWtCQSxTQUFTNEMsaUJBQWlCL2lCLEdBQUVMLEdBQUVxakI7SUFDNUIsR0FBSXJqQixXQUFXSyxTQUFTK0o7SUFDeEI7S0FBSXVXLFlBQVkwQztLQUNaM0MsWUFBWTJDO0tBQ1o3QyxZQUFZNkM7S0FDWjlDLFlBQVk4QztJQUNoQmhaLHNCQUF1QmhLLEdBQUdMLE9BQU91Z0I7SUFDakNsVyxzQkFBdUJoSyxHQUFHTCxPQUFPd2dCO0lBQ2pDblcsc0JBQXVCaEssR0FBR0wsT0FBTzBnQjtJQUNqQ3JXLHNCQUF1QmhLLEdBQUdMLE9BQU8yZ0I7SUFDakM7R0FDRjtHQW1CQSxTQUFTMkMsaUJBQWlCampCLEdBQUVMLEdBQUV1akI7SUFDNUIsR0FBSXZqQixXQUFXSyxTQUFTK0o7SUFDbEIsSUFBRnJLLElBQUl3ZixvQkFBb0JnRTtJQUM1QixJQUFVLElBQUZyaUIsT0FBT0EsT0FBT0EsS0FDcEJtSixzQkFBdUJoSyxHQUFHTCxRQUFRa0IsR0FBR25CLEVBQUVtQjtJQUV6QztHQUNGO0dRclRrQixJQUFkc2lCLGdCQUFnQm5MO0dZeU9wQixTQUFTb0wsZ0JBQWlCampCLEdBQUssT0FBT0YsVUFBVUUsR0FBSTtHTzFNL0IsSUFBakJrakIsdUJBQXVCemlCO0dBb0IzQixTQUFTMGlCLG9CQUFvQkMsSUFDM0IsT0FBT0YsaUJBQWlCRSxJQUMxQjtHQTZFQSxTQUFTQyx3QkFBd0JDO0lBQ3RCLElBQUxDLE9BQU9KLG9CQUFvQkc7SUFDL0IsT0FBT0M7R0FDVDtHSnZHQSxTQUFTQyxpQkFBa0JwSyxPQUFPRTtJQUNoQyxHQUFJQSxlQUFlRixrQkFBa0IvTjtJQUNyQyxPQUFPK047R0FDVDtHSG1GQSxTQUFTcUssb0JBQXFCempCO0lBQzVCLEdBQUl3ZCxTQUFVeGQsR0FBSTtLQUNoQixHQUFJRixTQUFTRSwrQkFBK0I7S0FDNUMsR0FBSUEsUUFBUTtLQUNaOztJQUVGLE9BQU95ZCxNQUFNemQ7R0FDZjtHQ2lCQSxTQUFTMGpCLHlCQUF5QjdnQixHQUNoQyxTQUNGO0duQldBLFNBQVM4Z0IscUJBQXFCM0gsUUFBUW5LLE1BQ3BDQSxhQUNBLE9BQU9tSztHQUNUO0dBSUEsU0FBUzRILHlCQUF5QjVILFFBQVFuSztJQUN4QyxPQUFRbUs7O09BRU5uSyxhQUNBLE9BQU9tSzs7T0FFUGhJO2VBQ09BOztHQUVYO0dBaENBLFNBQVM2UCxxQkFBcUI3SCxRQUFRbks7SUFDOUIsSUFBRmhQLFFBQVFwQztJQUNaLElBQVcsSUFBRkMsT0FBTUEsT0FBTUEsS0FBS21DLEVBQUVuQyxLQUFLc2I7SUFDakNuSztJQUNBLE9BQU82SixvQkFBcUI3WTtHQUM5QjtHQUlBLFNBQVNpaEIsbUJBQW1CN0UsUUFBUWhjLEdBQUc4Z0I7SUFDL0IsSUFBRm5oQixJQUFJbWMsb0JBQXFCOWI7SUFDN0IsSUFBVyxJQUFGekQsT0FBT0EsT0FBT0EsS0FBS3lmLGdCQUFpQnJjLEVBQUVwRDtJQUMvQ3VrQjtJQUFjQTtHQUNoQjtHVUNBLFNBQVNDLG1CQUFtQmhrQixHQUFFb0osR0FBRzJDLE9BQVMsT0FBTy9MLFVBQVVvSixHQUFHO0dBOEo5RCxTQUFTNmEsZ0JBQWdCaGhCLEdBQ3ZCLE9BQVFBLFdBQWFBLFNBQ3ZCO0dWeElvQjtJQUFoQmloQjs7cUJBRWdCTDttQkFDREM7O2lCQUVIRTtjQUNIQzsyQkFHUU47MkJBSUFDOzs7aUJBSVc1SCxRQUFRQztTQUFLLE9BQU9GLG9CQUFxQkMsUUFBT0M7UUFBMUQ7bUJBQ0grQztpQkFDRnhFO2NBQ0p3RDs7O2lCQUdtQmhDLFFBQVFDO1NBQUssT0FBT0Ysb0JBQXFCQyxRQUFPQztRQUExRDttQkFDSCtDO2lCQUNGeEU7Y0FDSndEO0cwQmxPYixTQUFTbUcsNEJBQTRCNWtCO0lBQ25DLE9BQU8ya0IsZ0JBQWdCM2tCO2NBQWtCMmtCLGdCQUFnQjNrQjtHQUMzRDtHQUlBLFNBQVM2a0IsK0JBQStCQyxLQUFLQyxRQUFRQyxNQUFNeFk7SUFDaEQsSUFBTHpFLE9BQU82Yyw0QkFBNEJHO0lBQ3ZDLEdBQUdoZCxLQUFNO0tBQ0QsSUFBRnRILElBQUt1a0IsV0FBVWpkLEtBQUtnZCxRQUFPRCxLQUFJdFksU0FBT3pFLEtBQUsrYyxLQUFJQyxRQUFPdlk7S0FDMUQsR0FBR0EsU0FBUy9MLEtBQUtBLEdBQUcsT0FBT3VrQjtLQUMzQixLQUFJdmtCLE9BQU1BLEdBQUcsU0FBUUE7S0FDckIsSUFBSUEsYUFBYSxPQUFRQTs7SUFFM0IsT0FBT3VrQjtHQUNUO0dBdENBLFNBQVNDLHFCQUFxQmpsQjtJQUM1QixVQUFXQTtLQUFnQjtZQUNsQnlGLGlCQUFpQnpGO0tBQUk7WUFDckIwRixrQkFBa0IxRjtLQUFJO1lBQ3RCQSxhQUFha0IsU0FBU2xCLFNBQVVBLGNBQWFBLFlBQWEsQ0FFekQsSUFBSjRELE1BQU01RCxVQUdWLE9BQVE0RCxpQkFBY0E7WUFFZjVELGFBQWFJO0tBQVE7bUJBQ2RKO0tBQWU7WUFDdEJBLGFBQWFrbEI7S0FBUTtZQUNyQmxsQixLQUFLQTtLQUFlO1lBQ3BCQSxLQUFLQTtLQUFXO21CQUNUQTtLQUFpQjttQkFDakJBLGVBQWU7SUFDL0I7R0FDRjtHQTBNQSxTQUFTbWxCLGlCQUFrQm5sQixHQUFHcUQ7SUFDNUIsR0FBSXJELElBQUlxRCxHQUFHO0lBQWEsR0FBSXJELEtBQUtxRCxHQUFHO0lBQVU7R0FDaEQ7RzVCd2JBLFNBQVMraEIsb0JBQW9CdmUsSUFBSUU7SUFDL0IsT0FBUUYsS0FBS0UsV0FBUUYsS0FBS0U7R0FDNUI7RzRCM21CQSxTQUFTc2UsaUJBQWtCcmxCLEdBQUdxRCxHQUFHbUo7SUFDckIsSUFBTjhZO0lBQ0osT0FBUTtLQUNOLE1BQU05WSxTQUFTeE0sTUFBTXFELEdBQUk7TUFDYixJQUFOa2lCLFFBQVFOLHFCQUFxQmpsQjtNQUVqQyxHQUFHdWxCLGFBQWMsQ0FBRXZsQixJQUFJQSxNQUFNO01BRW5CLElBQU53bEIsUUFBUVAscUJBQXFCNWhCO01BRWpDLEdBQUdtaUIsYUFBYyxDQUFFbmlCLElBQUlBLE1BQU07TUFHN0IsR0FBR2tpQixVQUFVQyxNQUFPO09BQ2xCLEdBQUdELGNBQWU7UUFDaEIsR0FBR0M7U0FBZSxPQUNUWCwrQkFBK0I3a0IsR0FBR3FELFFBQU9tSjtRQUVsRDs7T0FFRixHQUFHZ1osY0FBZTtRQUNoQixHQUFHRDtTQUFlLE9BQ1RWLCtCQUErQnhoQixHQUFHckQsTUFBTXdNO1FBRWpEOztPQUVGLE9BQVErWSxRQUFRQzs7TUFFbEIsT0FBT0Q7O1NBSUw5ZSxvREFDQTs7U0FFTSxJQUFGaEcsSUFBSTBrQixpQkFBaUJubEIsTUFBTXFELE9BQy9CLEdBQUk1QyxRQUFRLE9BQVFBLE9BQ3BCOztTQUdBZ0csb0RBQ0E7O1NBR0FBO1NBQ0E7O1NBRUFBLGdEQUNBOztTQUVBLEdBQUl6RyxNQUFNcUQsRUFBRztVQUNMLElBQUY1QyxJQUFJNmhCLG1CQUFtQnRpQixHQUFHcUQ7VUFDOUIsR0FBSTVDLFFBQVEsT0FBUUE7O1NBRXRCOztTQUdBZ0c7U0FDQTs7U0FHQUE7O1NBQ0E7O1NBRUFBO1NBQ0E7O1NBRUFBLG9EQUNBOztTQUVTLElBQUxzQixPQUFPNmMsNEJBQTRCNWtCO1NBQ3ZDLEdBQUcrSCxRQUFRNmMsNEJBQTRCdmhCO1VBQUcsT0FDaENyRCxnQkFBY3FEO1NBRXhCLEtBQUkwRSxNQUNGdEI7U0FDSSxJQUFGaEcsSUFBSXNILEtBQUsvSCxHQUFFcUQsR0FBRW1KO1NBQ2pCLEdBQUcvTCxLQUFLQSxHQUFFLE9BQ0QrTCxjQUFTL0w7U0FFbEIsR0FBR0EsT0FBT0EsUUFBSztTQUdmLEdBQUlBLFFBQVEsT0FBUUE7U0FDcEI7O1NBRU0sSUFBRkEsSUFBSVQsVUFBVXFELEdBQUVtSjtTQUNwQixHQUFHL0wsS0FBS0EsR0FBRyxPQUNGK0wsY0FBUy9MO1NBRWxCLEdBQUdBLE9BQU9BLFFBQUs7U0FHZixHQUFJQSxRQUFRLE9BQVFBO1NBQ3BCOztTQUVBVCxNQUFLQTtTQUNMcUQsTUFBS0E7U0FDTCxHQUFJckQsSUFBSXFELEdBQUc7U0FDWCxHQUFJckQsSUFBSXFELEdBQUc7U0FDWCxHQUFJckQsS0FBS3FELEVBQUc7VUFDVixLQUFLbUosT0FBTyxPQUFPRztVQUNuQixHQUFJM00sS0FBS0EsR0FBRztVQUNaLEdBQUlxRCxLQUFLQSxHQUFHOztTQUVkOztTQWVBLEdBQUlyRCxJQUFJcUQsR0FBRztTQUNYLEdBQUlyRCxJQUFJcUQsR0FBRztTQUNYLEdBQUlyRCxLQUFLcUQsRUFBRztVQUNWLEtBQUttSixPQUFPLE9BQU9HO1VBQ25CLEdBQUkzTSxLQUFLQSxHQUFHO1VBQ1osR0FBSXFELEtBQUtBLEdBQUc7O1NBRWQ7O1NBRUEsR0FBR3JELE1BQU1xRCxFQUFHLENBQ1YsS0FBS21KLE9BQU8sT0FBT0csS0FDbkIsV0FFRjs7U0FFQSxJQUFJM00sSUFBSThGLHVCQUF1QjlGLElBQzNCcUQsSUFBSXlDLHVCQUF1QnpDO1NBQy9CLEdBQUdyRCxNQUFNcUQsRUFBRyxDQUNWLEdBQUdyRCxJQUFJcUQsR0FBRyxZQUNWLEdBQUdyRCxJQUFJcUQsR0FBRztTQUVaOztTQUVBLElBQUlyRCxJQUFJQSxjQUNKcUQsSUFBSUE7U0FDUixHQUFHckQsTUFBTXFELEVBQUcsQ0FDVixHQUFHckQsSUFBSXFELEdBQUcsWUFDVixHQUFHckQsSUFBSXFELEdBQUc7U0FFWjs7OztTQUlBLEdBQUc4Z0IseUJBQXlCb0IsT0FBUTtVQUNsQzllO1VBQ0E7O1NBRUYsR0FBSXpHLFlBQVlxRCxVQUFVLE9BQVFyRCxXQUFXcUQ7U0FDN0MsR0FBSXJELGNBQWNzbEIsV0FBV3RsQixHQUFHcUQ7U0FDaEM7OztLQUdKLEdBQUlpaUIsbUJBQW1CO0tBQ2pCLElBQUZybEIsSUFBSXFsQjtLQUNSamlCLElBQUlpaUI7S0FDSnRsQixJQUFJc2xCO0tBQ0osR0FBSXJsQixRQUFRRCxVQUFVc2xCLFdBQVd0bEIsR0FBR3FELEdBQUdwRDtLQUN2Q0QsSUFBSUEsRUFBRUM7S0FDTm9ELElBQUlBLEVBQUVwRDs7R0FFVjtHQUdBLFNBQVN3bEIsYUFBY3psQixHQUFHcUQsR0FBSyxPQUFPZ2lCLGlCQUFrQnJsQixHQUFHcUQsU0FBVTtHTnpGckUsU0FBU3FpQiw0QkFBNEJDO0lBQzFCLElBQUxMLFFBQU1LO0lBQ1ZBO0lBQ0EsT0FBT0w7R0FDVDtHQUlBLFNBQVNNO0lBQStDRCxNQUFNRSxNQUFNQyxNQUFNQztJQUM5RCxJQUFOVCxRQUFRSSw0QkFBNEJDO0lBQ3hDTCxlQUFlTyxNQUFNQyxNQUFNQztJQUMzQixPQUFPVDtHQUNUO0dmaEhBLFNBQVNVLDZCQUFnQyxXQUFZO0dBaUJyRCxTQUFTQztJQUNQeFI7R0FDRjtHYXlMQSxTQUFTeVIsb0JBQXFCemxCLEdBQUdvSjtJQUMvQixHQUFJQSxRQUFRQSxRQUFRQTtJQUNwQnBKLElBQUlGLFNBQVNFO0lBQ2IsT0FBUW9KLFVBQVNwSixJQUFHQTtHQUN0QjtHQXFCQSxTQUFTMGxCLGdCQUFpQjFsQixHQUFLLE9BQU9GLFVBQVVFLEdBQUk7R1Y0QnBELFNBQVMybEIsaUJBQWlCOWYsTUFBS3ZDO0lBQ3BCLElBQUwrRCxPQUFPOE0sa0JBQWtCdE87SUFDN0IsS0FBS3dCLHNCQUFzQjJNO0lBQzNCM00scUJBQXFCQSxXQUFVL0Q7SUFDL0I7R0FDRjtHVnFMQSxTQUFTc2lCLG1CQUFtQm5tQixLQUMxQnVHLHVDQUNGO0c2QjVlQSxJQUFJNmYsNkJDeW9CQUMsd0JBQXdCbG1CO0dMeGlCNUIsU0FBU21tQixTQUFTL2xCLEdBQUVvSjtJQUNsQixHQUFJQSxRQUFRWDtJQUNaLE9BQVF6SSxJQUFFb0o7R0FDWjtHRHJHb0IsSUFBaEI0YztHQW1CSixTQUFTQyxvQkFBb0JDLE1BQzNCLE9BQU9GLGdCQUNUO0dBakJBLFNBQVNHLG9CQUFvQjVtQixHQUMzQnltQixrQkFBa0J6bUIsRUFDcEI7R0FxRW1CLElBQWY2bUI7R1g3Q0osU0FBU0MscUJBQXFCeGpCLEdBQzVCQSxrQkFDQSxTQUNGO0dXbUUyQixJQUF2QnlqQjtHQUNKLFNBQVNDLGtCQUFrQjdtQixHQUFFOG1CO0lBQ3pCLElBQUlwRCxLQUFLa0QsMEJBQ0w1ZixNQUFNMGY7SUFDVkEsaUJBQWlCaEQ7SUFDVCxJQUFKN2IsTUFBTXliLGNBQWN0akI7SUFDeEIwbUIsaUJBQWlCMWY7SUFDakIyZixxQkFBcUJHO0lBQ3JCLE9BQU9wRDtHQUNYO0dPckZBLElBQUlxRCwyQkFIQUM7R0FvS0osU0FBU0MscUJBQXFCM21CO0lBQzVCLEdBQUd1RSxtQ0FBbUNBO0tBQW9CLEdBQ3JEdkUsZ0JBQWdCdUU7TUFBZ0MsSUFFdkMsSUFBRjdELElBQUlnbUIsc0JBQXNCaG1CLElBQUlWLFVBQVVVLElBQUk7T0FDMUMsSUFBSjRKLE1BQU10SyxFQUFFVTtPQUNaLEdBQUc0SixlQUFlL0YsbUJBQW9CO1FBQ3BDK0YsTUFBTUE7UUFDTixHQUFHQSxLQUFLdEssZ0JBQWdCc0s7OztJQUtoQ3RLLEVBQUV5bUIseUJBQXlCamlCO0lBQzNCO0dBQ0Y7R0FuQ0EsU0FBU29pQixtQkFBbUI1bUIsR0FBR2dIO0lBQzdCLEdBQUd6QyxtQ0FBbUNBO0tBQW9CLE1BQ2xEdkUsZ0JBQWdCdUUsaUNBQWtDO01BQ3REdkU7O1FBQVd1RTtvQkFBOENvaUIscUJBQXFCM21CLEdBQW5DO01BRTNDLElBQVUsSUFBRlUsSUFBSWdtQixzQkFBc0JobUIsSUFBSVYsVUFBVVUsSUFBSTtPQUMxQyxJQUFKNEosTUFBTXRLLEVBQUVVO09BQ1osR0FBRzRKLGVBQWUvRixtQkFBb0I7UUFDcEMrRixNQUFNQTtRQUNOLEdBQUdBLEtBQUt0SyxjQUFjc0ssS0FBSzlGLFdBQVc4Rjs7OztJQUs5Q3RLLEVBQUV5bUIseUJBQXlCemY7SUFDM0I7R0FDRjtHQTVDQSxTQUFTNmYsb0JBQW9CdmUsS0FBSytSO0lBQzFCLElBQUYvWCxJQUFJZ0csSUFBSW1lO0lBQ1osR0FBR25rQixNQUFNa0M7S0FBV21pQixxQkFBcUJ0TTs7S0FDcEN1TSxtQkFBbUJ2TSxLQUFLL1g7SUFDN0I7R0FDRjtHQWZBLFNBQVN3a0IsbUJBQW1Cak8sSUFBSXhTLElBQUl5UyxJQUFJdlMsSUFBSTlHO0lBRTFDd1o7TUFBZ0JKO01BQUk2Tix1QkFBdUJyZ0I7TUFDM0J5UztNQUFJNE4sdUJBQXVCbmdCO01BQzNCOUc7SUFDaEI7R0FDRjtHQXVFQSxTQUFTc25CLHFCQUFxQi9tQjtJQUM1QixPQUFHQSxFQUFFeW1CLDJCQUEyQmppQjtHQUlsQztHQS9GQSxTQUFTd2lCLG9CQUFvQmhuQixHQUFHUjtJQUNyQixJQUFMeW5CLE9BQU9qbkIsRUFBRTBtQix1QkFBdUJsbkI7SUFDcEMsR0FBRytFLHNCQUFzQjBpQixnQkFBZ0IxaUI7S0FBb0IwaUIsT0FBT0E7SUFDcEUsT0FBR0EsU0FBT3ppQjtHQUlaO0dBakRBLFNBQVMwaUIsaUJBQWtCNWtCO0lBQ3pCLEdBQUlBLE9BQU8wRDtJQUNMLElBQUZoRztJQUNKQSxXQUFXMG1CLHVCQUF1QnBrQjtJQUNsQyxPQUFPdEM7R0FDVDtHQVpBLFNBQVNtbkIsaUJBQWtCN2tCLEdBQ25CLElBQUZ0QyxJQUFJa25CLGlCQUFpQjVrQixJQUN6QixPQUFPdEMsRUFDVDtHQThFQSxTQUFTb25CLG1CQUFtQnBuQjtJQUMxQixPQUFHQSxFQUFFeW1CLDJCQUEyQmppQjs7a0JBR25CeEUsRUFBRXltQjtHQUNqQjtHVmpGQSxTQUFTWSxhQUFjcm5CO0lBQ3JCLElBQUl3QyxJQUFJeEMsVUFDSlQsUUFBUWtCLE1BQU0rQjtJQUNsQixJQUFVLElBQUZoRCxPQUFPQSxJQUFJZ0QsR0FBR2hELEtBQU1ELEVBQUVDLEtBQUtRLEVBQUVSO0lBQ3JDLE9BQU9EO0dBQ1Q7R1VpRkEsU0FBUytuQix3QkFBd0J0bkI7SUFDL0IsT0FBR0EsRUFBRXltQiwyQkFBMkJqaUI7O2tCQUduQjZpQixhQUFhcm5CLEVBQUV5bUI7R0FDOUI7R0F2RUEsU0FBU2Msa0JBQWtCdm5CLEdBQUdSO0lBQzVCLEdBQUdBLFNBQVNrbkIsdUJBQXVCbG5CLEtBQUtRO0tBQ3RDZ0c7SUFDTyxJQUFMaWhCLE9BQU9qbkIsRUFBRTBtQix1QkFBdUJsbkI7SUFDcEMsR0FBRytFLHNCQUFzQjBpQixnQkFBZ0IxaUI7S0FBb0IwaUIsT0FBT0E7SUFDcEUsT0FBUUEsU0FBT3ppQixvQkFBaUJ5aUI7R0FDbEM7R0FLQSxTQUFTTyx1QkFBdUJ4bkIsR0FBR1I7SUFDakMsR0FBR0EsU0FBU2tuQix1QkFBdUJsbkIsS0FBS1E7S0FDdENnRztJQUNJLElBQUZvRCxJQUFJbWUsa0JBQWtCdm5CLEdBQUdSO0lBQzdCLEdBQUk0SixTQUFTLE9BQU9BO0lBQ2QsSUFBRnFlLElBQUlyZTtJQUNSLEdBQUlxZSxhQUFhaG5CLE9BQU8sV0FBVzRtQixhQUFhSTtJQUNoRCxPQUFPcmU7R0FDVDtHQWpGQSxTQUFTc2Usa0JBQWtCMW5CLEdBQUdSLEdBQUd5RDtJQUMvQixHQUFHekQsU0FBU2tuQix1QkFBdUJsbkIsS0FBS1E7S0FDdENnRztJQUNGLEdBQUkvQyxhQUFhMGtCLFVBQVVwakIsbUJBQW9CO0tBQzdDLEdBQUd2RSxlQUFlQSxjQUFjaUQsR0FBR3VCLFdBQVd2QjtLQUM5Q2pELEVBQUUwbUIsdUJBQXVCbG5CLFNBQVMrRSxtQkFBbUJ0Qjs7O0tBRWxEakQsRUFBRTBtQix1QkFBdUJsbkIsS0FBS3lEO0lBQ25DO0dBQ0Y7R0FJQSxTQUFTMmtCLG9CQUFvQjVuQixHQUFHUjtJQUM5QixHQUFHQSxTQUFTa25CLHVCQUF1QmxuQixLQUFLUTtLQUN0Q2dHO0lBQ0Y7TUFBR3pCO1NBQXNCdkUsRUFBRTBtQix1QkFBdUJsbkIsY0FBYytFO1NBQXNCdkUsZ0JBQWlCO0tBQzdGLElBQUowRyxNQUFNMUcsRUFBRTBtQix1QkFBdUJsbkI7S0FDbkMsR0FBR2tILFFBQVFsQyxVQUFXO01BQ1YsSUFBTnFqQjtNQUNKLElBQVUsSUFBRm5uQixJQUFJZ21CLHNCQUFzQmhtQixJQUFJVixVQUFVVSxJQUFJO09BQzFDLElBQUo0SixNQUFNdEssRUFBRVU7T0FDWixHQUFHNEosZUFBZS9GLG1CQUFtQjtRQUNuQytGLE1BQU1BO1FBQ04sR0FBR0EsUUFBUTVELEtBQUttaEI7OztNQUdwQixHQUFHQSxZQUFZN25CLGdCQUFnQjBHOzs7SUFHbkMxRyxFQUFFMG1CLHVCQUF1QmxuQixLQUFLZ0Y7SUFDOUI7R0FDRjtHSHdMQSxTQUFTc2pCLFdBQVk5bkIsR0FBR29KLEdBQUssVUFBU3diLGlCQUFpQjVrQixHQUFFb0osZ0JBQWdCO0dSMER6RSxTQUFTMmUsZUFBZS9uQjtJQUN0QjtLQUFJNlk7S0FDQUM7S0FDQWtQO0tBQ0FDO0tBQ0FDO0tBQ0F4UDtLQUVBMVA7SUFDSixHQUFJaEosT0FDRmdKO0lBRUZoSixJQUFJRixTQUFTRTtJQUNiO0tBQUk2QyxpQkFBaUI2VixJQUFJMVk7S0FDckJvSjs7O1lBQWM4ZSxLQUFLcmxCLElBQUlvbEIsTUFBTXBsQixJQUFJbWxCLE1BQU1ubEIsSUFBSWlXLE1BQU1qVyxJQUFJZ1csTUFBTWhXO1VBQUkvQyxZQUFVRSxJQUFJQTtJQUVqRixPQUFPZ0osT0FBT0k7R0FDaEI7R0FJQSxTQUFTK2UsZ0JBQWdCbm9CLEdBQ3ZCLFdBQVcrbkIsZUFBZS9uQixHQUM1QjtHWTVPQSxTQUFTb29CLG9CQUFvQmxDLE1BQVEsU0FBVTtHQUgvQyxTQUFTbUMscUJBQXFCbkMsTUFBUSxTQUFVO0cxQjhFdkIsSUFBckJvQyx1QkFBdUIvUDtHY3VHM0IsU0FBU2dRLGdCQUFnQnZvQixHQUFLLE9BQU9GLFlBQVlFLEdBQUk7R0FGckQsU0FBU3dvQixpQkFBa0J4b0IsR0FBSyxPQUFPRixXQUFXRSxHQUFJO0dkdE90RCxTQUFTeW9CLDBCQUEwQjdqQjtJQUNqQyxPQUFPQSxzQ0FJTCxrQkFFQTs7R0FFSjtHQUlBLFNBQVM4akIsc0JBQXNCOWpCO0lBQ3ZCLElBQUZyQztJQUNKLEdBQUdxQyxZQUFhO0tBQ2RyQyxLQUFLcUM7S0FDTDtPQUFHQSxtQkFBbUJBLGtCQUFrQjZqQiwwQkFBMEI3akI7TUFFaEUsSUFBSStqQixTQUFTL2pCLFFBQ1Rna0I7O01BRUosSUFBSUEsV0FDQUQsU0FBUy9qQjtLQUVmckM7S0FDQSxJQUFVLElBQUYvQyxJQUFJb3BCLE9BQU9wcEIsSUFBSW1wQixlQUFlbnBCLElBQUs7TUFDekMsR0FBR0EsSUFBSW9wQixPQUFPcm1CO01BQ1IsSUFBRlUsSUFBSTBsQixPQUFPbnBCO01BQ2YsVUFBVXlEO09BQ1JWLEtBQUlVO2NBQ0VBLGFBQWFDO09BQ25CWCxXQUFVVTtxQkFFR0E7T0FDYlYsV0FBVVU7O09BRVBWOztLQUVQQTs7WUFDU3FDLGVBQ1RyQyxLQUFLcUM7SUFFUCxPQUFPckM7R0FDVDtHQUlBLFNBQVNzbUIsOEJBQThCNWU7SUFDckMsR0FBR0EsZUFBZXhKLFVBQVV3SixlQUFlQSxlQUFnQjtLQUM3QyxJQUFSNmUsVUFBVTNrQjtLQUNkLEdBQUcya0I7TUFBUzlGLGNBQWM4RixVQUFVN2U7U0FDL0I7TUFDSDtPQUFJdkUsTUFBTWdqQixzQkFBc0J6ZTtPQUM1QjhlLFVBQVU1a0I7TUFDZCxHQUFHNGtCLFNBQVMvRixjQUFjK0Y7TUFDMUIxZ0IsMENBQTBDM0M7TUFDMUMsR0FBR3VFLGNBQWMsTUFBTUE7Ozs7S0FHdEIsTUFDR0E7R0FFVjtHTnVlQSxTQUFTK2UsZ0JBQWdCbnBCLEdBQUdMLEdBQUdnRCxHQUFHTTtJQUNoQyxHQUFJTjtLQUFPLEdBQ0xoRCxXQUFXZ0QsS0FBSzNDLE9BQVFBLFlBQTBCMkMsS0FBSzNDO01BQWMsR0FDbkVpRCxPQUFRO09BQ1ZqRDtPQUNBQTs7VUFDSztPQUNMQSxNQUFNd0MsZ0JBQWlCRyxHQUFHN0Msb0JBQW9CbUQ7T0FDOUNqRCxNQUFPMkMsS0FBSzNDOztTQUVUO01BQ0wsR0FBSUEsVUFBc0JpRyw0QkFBNEJqRztNQUN0RCxJQUFLMkMsS0FBS2hELEdBQUdBLElBQUlnRCxHQUFHaEQsS0FBS0ssSUFBSUwsS0FBS3NEOztJQUd0QztHQUNGO0dnQ2ppQkEsU0FBU21tQixzQkFBeUIsU0FBVTtHQUd6QixJQUFmQyxxQkFBcUIza0I7R0FDekIsU0FBUzRrQix5Q0FBMENDLElBQUk3cEI7SUFDckQsR0FBR2dGLG1DQUFtQ2hGLGFBQWFvb0IsT0FBUTtLQUNuRDtNQUFGM25COztTQUFRdUU7bUJBQTBDdkUsR0FBR2twQixzQkFBc0JscEIsSUFBSW9wQixPQUFPLE9BQTlDO0tBQzVDcHBCLFdBQVdULEdBQUVTO0tBQ2JrcEIsbUJBQW1CbHBCOztJQUVyQjtHQUNGO0dBR0EsU0FBU3FwQixxQkFBd0IsU0FBVTtHQ00zQyxTQUFTQyx1QkFBdUI1cEIsR0FBRzZwQjtJQUNqQyxHQUFJN3BCLGFBQWE2cEIsWUFBWUE7SUFDckIsSUFBSjlwQixNQUFNOHBCO0lBRVYsR0FBSTdwQixpQkFBaUJBLGNBQWNBLHFCQUFxQkQ7SUFDeEQsR0FBSUMsWUFBYSxDQUNmLEdBQUlBLGFBQWFELFVBQ2pCLEdBQUlDLGNBQWNEO0lBR1QsSUFBUGtNO0lBQ0osR0FBSWpNLG9CQUFvQkE7S0FDdEIsSUFBVyxJQUFGRixJQUFJQyxLQUFLRCxJQUFJRSxTQUFTRixLQUFLbU07SUFDdEMsR0FBSWpNO0tBQWMsR0FDWkE7TUFBWWlNO2FBQ1BqTSxvQkFBb0JpTSxVQUFVak07SUFFekMsR0FBSUEsZUFBZUEsYUFBYWlNO0lBQ2hDLEdBQUlqTSxlQUFlQSxjQUFjaU0sVUFBVWpNO0lBQzNDLEdBQUlBLG9CQUFvQkE7S0FDdEIsSUFBVyxJQUFGRixJQUFJQyxLQUFLRCxJQUFJRSxTQUFTRixLQUFLbU07SUFDdENBLFVBQVU0ZDtJQUNWLEdBQUk3cEIsa0JBQ0YsSUFBVyxJQUFGRixJQUFJQyxLQUFLRCxJQUFJRSxTQUFTRixLQUFLbU07SUFDdEMsT0FBTzVMLHVCQUF1QjRMO0dBQ2hDO0diNklBLFNBQVM2ZCxtQkFBb0J4cEIsR0FBR29KO0lBQzlCLEdBQUlwSixNQUFNb0osR0FBRztJQUNiLEdBQUlwSixJQUFJb0osR0FBRztJQUNYLEdBQUlwSixJQUFJb0osR0FBRztJQUNYLEdBQUlwSixNQUFNQSxHQUFHO0lBQ2IsR0FBSW9KLE1BQU1BLEdBQUc7SUFDYjtHQUNGO0dsQmxFQSxTQUFTcWdCLG9CQUFxQmxxQjtJQUM1QixPQUFPb2MseUJBQTBCRCxvQkFBcUJuYztHQUN4RDtHa0IwVEEsU0FBU21xQixxQkFBcUI3cEI7SUFDNUIsSUFBSTBIO0lBQ0oxSCxJQUFJd0YsdUJBQXVCeEY7SUFDM0IwSCxRQUFPMUg7SUFDUCxHQUFLQSxnQkFBa0IwSCxRQUFRQSxLQUFNLE9BQU9BO0lBQzVDMUgsSUFBSUE7SUFDSjBILFFBQU8xSDtJQUNQLEdBQU1BLGdCQUFrQjBILFFBQVFBLE9BQVMsbUJBQW1CMUgsSUFBSSxPQUFPMEg7SUFDakUsSUFBRlEsSUFBSSwrREFBK0RsSTtJQUV2RSxHQUFHa0ksRUFBRTtLQUNIO01BQUk0aEIsS0FBSzVoQjtNQUNMNmhCLFdBQVd4WixTQUFTckksT0FBT0EsT0FBTzRoQjtNQUNsQ0UsWUFBWTloQixnQkFBWTRoQjtLQUM1QnBpQixNQUFNcWlCLFdBQVc5cEIsWUFBWStwQjtLQUM3QixPQUFPdGlCOztJQUVULEdBQUcseUJBQXlCMUgsSUFBSSxPQUFPZ2M7SUFDdkMsR0FBRyx1QkFBdUJoYyxJQUFJLFNBQVFnYztJQUN0QzdIO0dBQ0Y7R0d6Y0EsU0FBUzhWLHFCQUFxQmpSLElBQUl4UyxJQUFJeVMsSUFBSXZTLElBQUk5RztJQUM1QyxHQUFJOEcsTUFBTUY7S0FBSSxJQUNELElBQUYzRixPQUFPQSxLQUFLakIsS0FBS2lCLEtBQUtvWSxHQUFHdlMsS0FBSzdGLEtBQUttWSxHQUFHeFMsS0FBSzNGOztLQUMvQyxJQUNNLElBQUZBLElBQUlqQixLQUFLaUIsUUFBUUEsS0FBS29ZLEdBQUd2UyxLQUFLN0YsS0FBS21ZLEdBQUd4UyxLQUFLM0Y7SUFFdEQ7R0FDRjtHQXVEQSxTQUFTcXBCLHVCQUF1QnRxQjtJQUM5QixHQUFJQSxTQUFTNEw7SUFDYixJQUFJNUwsTUFBTUEsYUFDTm1ELFFBQVFuQyxNQUFNaEI7SUFDbEJtRDtJQUNBLElBQVcsSUFBRnBELE9BQU9BLElBQUlDLEtBQUtELEtBQUtvRCxFQUFFcEQ7SUFDaEMsT0FBT29EO0dBQ1Q7R0hzTUEsU0FBU29uQixlQUFlaHFCLEdBQUdvSixHQUFHcWU7SUFDNUI7S0FBSXdDLFFBQVFucUI7S0FDUm9xQixZQUFZcHFCO0tBQ1pxcUIsVUFBVXJxQjtLQUNWc3FCO0tBQ0FDLElBQUl2cUIsY0FBYXNxQjtLQUNqQkUsSUFBSXhxQixjQUFhc3FCO0lBRXJCLFNBQVNHLFNBQVVockIsR0FBR3FEO0tBQ3BCO01BQUk0bkIsS0FBS1AsUUFBUTFxQjtNQUNia3JCLE1BQU1ELE1BQU1BLEtBQUtqckI7TUFDakJtckIsTUFBTW5yQixJQUFJa3JCO01BQ1ZFLEtBQUtWLFFBQVFybkI7TUFDYmdvQixNQUFNRCxNQUFNQSxLQUFLL25CO01BQ2pCaW9CLE1BQU1qb0IsSUFBSWdvQjtNQUNWbFMsSUFBSW5aLElBQUlxRDtNQUNSaU0sSUFBTTRiLE1BQU1HLE1BQU1sUyxJQUFLK1IsTUFBTUksTUFBTUgsTUFBTUUsTUFBT0YsTUFBTUc7S0FDMUQsV0FDS25TLE1BQ0E3SjtJQUVQO0lBRUEsU0FBUzJILElBQUtqWCxHQUFHcUQ7S0FDZixJQUFJL0MsSUFBSU4sSUFBSXFELEdBQ1JLLElBQUlwRCxJQUFJTixHQUNSc1AsSUFBS3RQLEtBQUtNLElBQUlvRCxNQUFPTCxJQUFJSztLQUM3QixXQUNLcEQsTUFDQWdQO0lBRVA7SUFFQSxTQUFTaWMsT0FBUTlxQixHQUFHb0o7S0FDbEIsT0FBT3BKLFdBQVdvSixXQUFXNmdCLFFBQVFqcUIsS0FBS2lxQixRQUFRanFCLElBQUlBLE9BQU9BO2VBQUlBLFVBQVVBLHNCQUFvQm9KLHFCQUFtQitnQjtlQUFXbnFCO0lBQy9IO0lBRUE7TUFBSUEsV0FBV0EsTUFBTUEsS0FBS0EsbUJBQWdCQSxtQkFDdENvSjtTQUFXQSxNQUFNQTtTQUFLQTtTQUFnQkE7S0FBYyxPQUMvQ3BKLElBQUlvSixJQUFJcWU7SUFFakIsR0FBSUEsU0FBUyxPQUNKem5CLElBQUlvSjtJQUViLEdBQUlxZSxNQUFNQSxLQUFLQSxtQkFBZ0JBLGlCQUFjLE9BQ3BDQTtJQUdDLElBQU5zRDtJQUNKLE1BQU9qckIsU0FBU0UsS0FBS3FxQixFQUFHLENBQ3RCVSxTQUFTVixHQUNUcnFCLEtBQUtzcUI7SUFFUCxNQUFPeHFCLFNBQVNzSixLQUFLaWhCLEVBQUcsQ0FDdEJVLFNBQVNWLEdBQ1RqaEIsS0FBS2toQjtJQUVQLEdBQUlTLGlCQUFpQixPQUNaL3FCLElBQUlvSixJQUFJMmhCO0lBRWpCLE1BQU9qckIsU0FBU0UsS0FBS3NxQixFQUFHLENBQ3RCUyxTQUFTVCxHQUNUdHFCLEtBQUtxcUI7SUFFUCxNQUFPdnFCLFNBQVNzSixLQUFLa2hCLEVBQUcsQ0FDdEJTLFNBQVNULEdBQ1RsaEIsS0FBS2loQjtJQUVQLEdBQUlVLGFBQWEsT0FDUnREO0lBR1QsSUFBSXVELEtBQUtockIsR0FDTGlyQixLQUFLN2hCLEdBQ0w4aEIsS0FBS3pELElBQUlzRDtJQUViLEdBQUlqckIsU0FBU29yQixNQUFNcHJCLFNBQVNrckIsS0FBS0MsVUFBVWQsU0FBUyxPQUMzQzFDO0lBRVQsR0FBSTNuQixTQUFTb3JCLE1BQU1wckIsU0FBU2tyQixLQUFLQyxNQUFNZCxjQUFjQTtLQUNuRGUsTUFBTXpELHFCQUFtQnlDO0lBRzNCO0tBQUlpQixLQUFLWixTQUFTUyxJQUFJQztLQUNsQnByQixJQUFJMlcsSUFBSTJVLE1BQU1EO0tBQ2RFLElBQUk1VSxJQUFJMlUsTUFBTXRyQjtLQUNkTCxJQUFJZ1gsSUFBSTNXLEtBQUt1ckI7S0FFYjFyQixJQUFJRixNQUFNc3JCLE9BQU90ckIsS0FBSzRyQjtJQUMxQixHQUFJMXJCLFNBQVMsT0FDSkE7SUFHRixJQUFIMnJCLEtBQUszckIsSUFBSXFyQjtJQUNiLEdBQUlqckIsU0FBU3VyQixNQUFNbkIsV0FBVyxPQUNyQm1CO0lBSVQsT0FBT0EsS0FBS1AsT0FBT3ByQixJQUFJMnJCLEtBQUtOLE9BQU92ckIsT0FBT3VyQjtHQUM1QztHYXpaQSxTQUFTTyxrQkFBbUJDO0lBQzFCQSxNQUFNbG1CLHVCQUF1QmttQjtJQUNyQixJQUFKOXJCLE1BQU04ckI7SUFDVixHQUFJOXJCLFVBQVV1RztJQUNSO0tBQUZ0Rzs7Ozs7Ozs7Ozs7O0lBSUosSUFBVyxJQUFGRixPQUFPQSxJQUFJQyxLQUFLRCxJQUFLO0tBQ3RCLElBQUZzRCxJQUFJeW9CLFdBQVcvckI7S0FDbkIsT0FBUXNEOztRQUVOcEQsaUJBQWlCOzs7UUFFakJBLGNBQWNvRCxHQUFHOztRQUVqQnBELGdCQUFnQjs7UUFFaEJBLG9CQUFvQjs7Ozs7Ozs7OztRQUdwQkE7UUFDQSxNQUFPb0QsSUFBRXlvQixlQUFlL3JCLFNBQVNzRCxVQUFVQSxPQUFRLENBQ2pEcEQsVUFBVUEsZUFBZW9ELEdBQUd0RDtRQUU5QkE7UUFDQTs7UUFFQUU7UUFDQUY7UUFDQSxNQUFPc0QsSUFBRXlvQixlQUFlL3JCLFNBQVNzRCxVQUFVQSxPQUFRLENBQ2pEcEQsU0FBU0EsY0FBY29ELEdBQUd0RDtRQUU1QkE7OztRQUVBRTs7UUFFQUEsYUFBYTs7UUFFYkEsYUFBYTs7UUFFYkEsYUFBYUEsb0JBQW9COztRQUVqQ0EsWUFBWTs7OztRQUVaQSxxQkFBcUJBLFNBQVNvRCxHQUFHOzs7O1FBRWpDcEQ7UUFBcUJBO1FBQ3JCQSxTQUFTb0Q7UUFBa0I7OztJQUcvQixPQUFPcEQ7R0FDVDtHYnlXQSxTQUFTOHJCLGtCQUFtQkQsS0FBS3ZyQjtJQUMvQixTQUFTeXJCLFFBQVF6ckIsR0FBRTByQjtLQUNqQixHQUFJNXJCLFNBQVNFO01BQVUsT0FDZEEsVUFBVTByQjtTQUNaO01BQ0MsSUFBRjdjLElBQUl1QixTQUFTcFE7TUFDakIsR0FBSTZPLE9BQVE7T0FDVkE7T0FDQTdPLEtBQUtGLGFBQVkrTztPQUNqQjdPLEtBQUssSUFBS1MsTUFBTW9PO09BQ2hCLEdBQUc2YyxRQUNEMXJCLElBQUlBLFVBQVUsSUFBS1MsTUFBTWlyQjtPQUUzQixPQUFPMXJCOzs7T0FFSixPQUFPQSxVQUFVMHJCOztJQUUxQjtJQUNBLElBQUk3ckIsR0FBR0gsSUFBSTRyQixrQkFBa0JDLE1BQ3pCSSxPQUFRanNCLGlCQUFjQTtJQUMxQixHQUFJTSxTQUFVQSxjQUFZQSxPQUFNNmIsU0FBVyxDQUFFbmMsY0FBYU0sTUFBS0E7SUFDL0QsR0FBSXlkLE1BQU16ZCxHQUFJO0tBQUVIO0tBQVdIOztjQUNqQjhkLFNBQVN4ZCxHQUFJO0tBQUVIO0tBQVdIOzs7S0FFbEMsT0FBUUE7O1FBRU4sSUFBSUcsSUFBSUcsZ0JBQWdCMnJCLE9BRXBCbnNCLElBQUlLO1FBQ1IsR0FBSUEsU0FBU0w7U0FDWEssSUFBSUEsV0FBWUwsZUFBZUssUUFBU0w7UUFDMUM7O1FBRUFLLElBQUk0ckIsUUFBUXpyQixHQUFHMnJCLE9BQU87O1FBRXRCQSxPQUFPQSxPQUFLQTtRQUNaOXJCLElBQUlHLGdCQUFnQjJyQjtRQUNwQixJQUFJanJCLElBQUliLGdCQUNKK2IsUUFBTy9iLFFBQVFhO1FBQ25CLEdBQUlrYixhQUFZNWIsYUFBYUEsc0JBQXNCMnJCLEtBQU07U0FFakQsSUFBRm5zQixJQUFJa0I7U0FBTyxNQUFPYixTQUFTTCxXQUFXQTtTQUMxQyxHQUFJSyxTQUFTTCxXQUFXQTtTQUN4QkssSUFBSUEsV0FBV0wsU0FBU0ssUUFBUWE7U0FDaENsQixJQUFJSztTQUNKLEdBQUlBLFNBQVNMO1VBQ1hLLElBQUlBLFdBQVlMLGVBQWVLLFFBQVNMO1NBQzFDOztZQUNLO1NBQ0MsSUFBRmtaLElBQUlpVDtTQUNSLEdBQUkvUCxRQUFTO1VBQUVsRCxLQUFLa0Q7VUFBUy9iLElBQUlHLFVBQVUwWTs7O1VBQ3RDLE1BQU83WSxJQUFJRyxVQUFVMFksSUFBSTdZLFdBQVc4ckIsVUFBVWpUO1NBQ25ELEdBQUlBLEVBQUc7VUFFQyxJQUFGbFosSUFBSUs7VUFBYyxNQUFPQSxTQUFTTCxXQUFXQTtVQUNqRCxHQUFJSyxTQUFTTCxXQUFXQTtVQUN4QkssSUFBSUEsV0FBV0w7OztRQUduQjs7SUFFSixPQUFPOHBCLHVCQUF1QjVwQixHQUFHRztHQUNuQztHSzVkQSxTQUFTK3JCLGdCQUFnQkwsS0FBSy9yQjtJQUM1QixHQUFJNkYsdUJBQXVCa21CO0tBQWMsT0FBT3hyQiw0QkFBMEJQO0lBQ3BFLElBQUZFLElBQUk0ckIsa0JBQWtCQztJQUMxQixHQUFJL3JCLE9BQU8sR0FBTUUsYUFBYyxDQUFFQSxjQUFhRixNQUFLQSxTQUFVQTtJQUN2RCxJQUFGSyxJQUFJTCxXQUFXRTtJQUNuQixHQUFJQSxZQUFhO0tBQ2ZBO0tBQ00sSUFBRjRDLElBQUk1QyxTQUFTRztLQUNqQixHQUFJeUMsT0FBT3pDLElBQUl3QyxnQkFBaUJDLFVBQVV6Qzs7SUFFNUMsT0FBT3lwQix1QkFBdUI1cEIsR0FBR0c7R0FDbkM7R0p5R29CLElBQWhCZ3NCO0dBV0osU0FBU0MsbUJBQ1AsT0FBT0Qsa0JBQ1Q7R0QyRUEsU0FBU0UsaUJBQWtCL3JCO0lBQ3pCLEdBQUtBLFlBQVl3ZCxTQUFTeGQsSUFBSSxXQUFXQTtJQUNqQyxJQUFKZ3NCLE1BQU1oc0I7SUFDVixHQUFJZ3NCLEtBQUtoc0IsTUFBTUE7SUFDUCxJQUFKNGIsTUFBTTliLGlCQUFnQnVkLGdCQUFnQnJkO0lBQzFDQSxLQUFLRixjQUFZOGI7SUFDakIsTUFBTzViLFFBQVMsQ0FDZEEsUUFDQTRiO0lBRUYsTUFBTzViLE9BQVEsQ0FDYkEsVUFDQTRiO0lBRUYsR0FBSW9RLEtBQUtoc0IsTUFBTUE7SUFDZixXQUFXQSxHQUFHNGI7R0FDaEI7R1Y0RUEsU0FBU3FRLGlCQUFpQnBtQixNQUFLdkM7SUFDN0I7S0FBSXVDLE9BQU85Rix1QkFBdUI4RjtLQUM5QnZDLFVBQVV2RCx1QkFBdUJ1RDtJQUNyQyxPQUFPcWlCLGlCQUFpQjlmLE1BQU12QztHQUNoQztHQTVCQSxTQUFTNG9CO0lBQ0EsSUFBSEMsTUFBSTVuQjtJQUNSLEdBQUc0bkI7S0FBSSxJQUNLLElBQUYzc0IsT0FBT0EsSUFBSTJzQixZQUFZM3NCO01BQzdCeXNCLGlCQUFpQkUsSUFBSTNzQixTQUFRMnNCLElBQUkzc0I7SUFHckMrRSw4QkFBOEIwbkI7SUFDOUIxbkI7SUFDQTtHQUNGO0dzQnpSQSxTQUFTNm5CLHFCQUFzQixTQUFRO0dBRXZDLFNBQVNDLG1CQUFxQixzQkFBbUI7R0FSakQsU0FBU0MsbUJBQW1CcEc7SUFFMUIsVUFBVTNoQiw2QkFBNkJBO0lBQ3ZDO0dBQ0Y7R0E0QkEsU0FBU2dvQixjQUNQLDRDQUNGO0dBNENBLFNBQVNDLDRCQUE0QnRHLE1BQVEsU0FBVTtHQXBGdkQsU0FBU3VHLGNBQWN2RztJQUVyQixVQUFVM2hCLDZCQUE2QkE7SUFDdkM7R0FDRjtHQW1GQSxTQUFTbW9CLG9CQUFvQkMsTUFBUSxTQUFVO0dBN0YvQyxTQUFTQyxjQUFjMUc7SUFFckIsVUFBVTNoQiw2QkFBNkJBO0lBQ3ZDO0dBQ0Y7R0E0RkEsU0FBU3NvQixvQkFBb0IzRyxNQUFRLFNBQVU7R0F6RS9DLFNBQVM0RztJQUNQO0dBQ0Y7R0FjQSxTQUFTQyxZQUFZQyxVQUNuQixTQUNGO0dBUEEsU0FBU0MsZUFDUCxPQUFPSCxxQkFDVDtHVjZIQSxTQUFTSSxrQ0FBcUMsV0FBWTtHZnRHMUQsU0FBU0MsNkJBQWdDLFdBQVk7R0FwQnJELFNBQVNDLCtCQUFrQyxTQUFVO0dBRXJELFNBQVNDLG1DQUFzQyxXQUFZO0dGNkkzRCxTQUFTQyx1QkFBMEIsT0FBTzVvQixpQkFBa0I7RzJCaEY1RCxTQUFTNm9CLHNCQUFzQmpyQixHQUFLLFNBQVU7R0FHOUMsU0FBU2tyQixzQkFBc0JsckIsR0FBSyxTQUFVO0dBTjlDLFNBQVNtckIsb0JBQW9CdkgsTUFBUSxTQUFVO0dYV3pCLElBQWxCd0g7R0FDSixTQUFTQyx1QkFBd0JDLEtBQUt6cUIsS0FBSzBxQjtJQUN6QyxJQUFJQyxRQUFRRixRQUNSaGlCLE1BQU04aEIsa0JBQWtCRztJQUM1QixHQUFJamlCLFFBQVFwSDtLQUFXLElBRVYsSUFBRmhGLElBQUlrdUIsMEJBQTBCbHVCLElBQUlxdUIsU0FBU3J1QjtNQUNsRGt1QixrQkFBa0JsdUI7WUFDWHN1QixNQUFNbGlCLFNBQVN6SSxLQUFLLE9BQ3RCMnFCLE1BQU1saUI7SUFFZixJQUFJbWlCLFFBQVFsbEIsS0FBS2lsQixrQkFBa0JsbEI7SUFDbkMsTUFBT21sQixLQUFLbGxCLEdBQUk7S0FDZEQsS0FBT21sQixLQUFHbGxCO0tBQ1YsR0FBSTFGLE1BQU0ycUIsTUFBTWxsQixTQUFPQyxLQUFLRCxhQUN2Qm1sQixLQUFLbmxCOztJQUVaOGtCLGtCQUFrQkcsV0FBV0U7SUFFN0IsT0FBUTVxQixPQUFPMnFCLE1BQU1DLFVBQVFELE1BQU1DO0dBQ3JDO0dhb0lBLFNBQVNDLGdCQUFnQmhYLEtBQUlpWCxJQUFHQyxJQUFHQyxJQUFHQyxJQUFHdlYsSUFBR0M7SUFDMUMsTUFBTUQsS0FBR0MsSUFBSUE7SUFDYkQ7SUFDQUM7SUFDQTtLQUFJdVY7S0FBUUM7S0FBS0M7S0FBS0M7S0FBVUM7S0FDNUJDO0tBQ0FySyxPQUFTdkwsS0FBS0QsTUFBTS9ZLFlBQVlzdUIsS0FBR0QsV0FBVU87S0FDN0NDLFNBQVM3VixLQUFLRCxNQUFNL1ksVUFBVXVrQjtLQUM5QjdrQixJQUFJcVosS0FBSy9ZO0lBQ2IsSUFBVSxJQUFEWSxPQUFJQSxLQUFHMmpCLEtBQUkzakIsSUFBSTtLQUN0QjR0QjtNQUFPTCxLQUFNRyxLQUFLdHVCLFNBQVNOLEtBQU1NLFNBQVN1dUIsTUFBTXZ1QjtRQUFZcXVCLEtBQUtydUIsU0FBU04sS0FBTU0sU0FBU3V1QixNQUFNdnVCO0tBQy9Gd3VCLE9BQU9BO0tBQ1BDO01BQU9MLEtBQU1DLEtBQUtydUIsU0FBU04sS0FBTU0sU0FBU3V1QixNQUFNdnVCO1FBQVlzdUIsS0FBS3R1QixTQUFTTixLQUFNTSxTQUFTdXVCLE1BQU12dUI7S0FDL0Z5dUIsT0FBT0E7S0FDUCxHQUFJN3RCO01BQ0ZzVyxXQUFXc1gsTUFBTUM7YUFDUkMsYUFBV0YsUUFBUUcsYUFBV0YsTUFDdkN2WCxXQUFXc1gsTUFBTUM7S0FFbkJDLFlBQVVGO0tBQ1ZHLFlBQVVGO0tBQ1YvdUIsS0FBSW12Qjs7SUFFTjtHQUNGO0dBOVFBLElBQUlDO0dBTUosU0FBU0M7SUFDUCxHQUFHRCxlQUFlLE9BQ1RBO0lBRVQsTUFBTTlwQjs7YUFBK0JYO2FBQThDcEU7R0FDckY7R0FxYkEsU0FBUyt1QixtQkFBbUJqakIsSUFBRzdMLEdBQUVvSjtJQUMvQjtLQUFJdkosSUFBSWd2QjtLQUNKRTtPQUFNbHZCO1NBQXVCRyxHQUFFSCxXQUFXZ00sWUFBWXpDLEdBQUV5QyxVQUFTQTtJQUNyRSxJQUFXLElBQUZyTSxPQUFPQSxJQUFJdXZCLGlCQUFpQnZ2QixPQUFLO0tBQ3hDcU0sUUFBUXJNLEtBQUt1dkIsU0FBU3Z2QjtLQUN0QnFNLFFBQVFyTSxTQUFPdXZCLFNBQVN2dkI7S0FDeEJxTSxRQUFRck0sU0FBT3V2QixTQUFTdnZCO0tBQ3hCcU0sUUFBUXJNLFNBQU91dkIsU0FBU3Z2Qjs7SUFFMUI7R0FDRjtHQWhVQSxTQUFTd3ZCO0lBQ0QsSUFBRm52QixJQUFJZ3ZCO0lBQ1JodkIsaUJBQWlCQTtJQUNqQkEsa0JBQWtCQTtJQUVsQjtHQUNGO0dBckNBLFNBQVNvdkI7SUFDRCxJQUFGcHZCLElBQUlndkI7SUFDUmh2QjtJQUNBQTtJQUNBO0dBQ0Y7R0FtWUEsU0FBU3F2Qix3QkFBd0IzdkI7SUFDL0J5VTtHQUNGO0dBM0RBLFNBQVNtYixxQkFBcUJudkIsR0FBRW9KO0lBQ3hCLElBQUZ2SixJQUFJZ3ZCO0lBQ1IsT0FBT2h2QiwwQkFBMEJHLEdBQUVvSjtHQUNyQztHQXRPQSxTQUFTZ21CLG9CQUNELElBQUZ2dkIsSUFBSWd2QixxQkFDUixPQUFPaHZCLElBQ1Q7R0FHQSxTQUFTd3ZCLG9CQUNELElBQUZ4dkIsSUFBSWd2QixxQkFDUixPQUFPaHZCLElBQ1Q7R0FpUUEsU0FBU3l2QjtJQUNQdGI7R0FDRjtHQS9YQSxTQUFTdWIscUJBQXFCL2hCO0lBQzVCLEdBQUdBLDRCQUNELE9BQU9BO0dBQ1g7R0E0S0EsU0FBU2dpQixpQkFBaUJ4dkIsR0FBRW9KLEdBQUVnbEIsSUFBR0QsSUFBR3RWLElBQUdDO0lBQy9CLElBQUZqWixJQUFJZ3ZCO0lBQ1JodkI7SUFDQW11QixnQkFBZ0JudUIsV0FBVUcsR0FBRUgsV0FBV3VKLEdBQUVnbEIsSUFBR0QsSUFBR3RWLElBQUdDO0lBQ2xEalo7SUFDQTtHQUNGO0dBMkNBLFNBQVM0dkIsaUJBQWlCQztJQUN4QixJQUFJN3ZCLElBQUlndkIscUJBQ0o5bUIsSUFBSWxJLHNCQUFzQjZ2QixNQUMxQnZlLEtBQUtwSjtJQUNUbEksbUJBQW1CNnZCLEtBQUk3dkIsS0FBSUEsV0FBV0E7SUFDdENBLE9BQU9zUjtJQUNQO0dBQ0Y7R0FJQSxTQUFTd2Usa0JBQWtCN3NCO0lBQ3pCMnNCLGlCQUFpQjl2QixvQkFBb0JtRDtJQUNyQztHQUNGO0dBb0ZBLFNBQVM4c0IsbUJBQW1CL2pCLElBQUc3TCxHQUFFb0o7SUFDekIsSUFBRnZKLElBQUlndkI7SUFDUixLQUFJaGpCLFNBQVU7S0FDRCxJQUFQbUUsU0FBU0w7S0FDYkssZUFBZW5RO0tBQ2ZtUSxnQkFBZ0JuUTtLQUNoQm1RLHFDQUFxQ25FO0tBQzNCLElBQU53RyxZQUFZOU47S0FDaEI4Tjs7T0FDRXhTLG9CQUFvQndTLE9BQU1yUyxHQUFFSCxXQUFXZ00sWUFBWXpDO09BQ25EeUMsV0FBV3dHO01BRkU7S0FJZkEsWUFBWXJDOzs7S0FFWm5RLG9CQUFvQmdNLFVBQVM3TCxHQUFFSCxXQUFXZ00sWUFBWXpDO0lBRXhEO0dBQ0Y7R0F4TUEsU0FBU3ltQixrQkFBa0I3dkIsR0FBRW9KLEdBQUUwTixHQUFFL047SUFDekIsSUFBRmxKLElBQUlndkI7SUFDUmh2QixxQkFBcUJHLEdBQUVILFdBQVd1SixHQUFFME4sS0FBRy9OO0lBQ3ZDO0dBQ0Y7R0FvR0EsU0FBUyttQixvQkFBb0JKO0lBQzNCRCxpQkFBaUJqZCx3QkFBd0JrZDtJQUN6QztHQUNGO0dBNERBLFNBQVNLLG1CQUFtQmxrQjtJQUNqQixJQUFMN0U7SUFDSixJQUFTLElBQUR4SCxPQUFLQSxJQUFFcU0sV0FBVXJNLElBQUk7S0FDM0J3SCxLQUFLeEg7S0FDTCxJQUFTLElBQURrQixPQUFLQSxJQUFFbUwsVUFBU25MLElBQUk7TUFDMUI7T0FBSThKLElBQUloTCxLQUFHcU0sZ0JBQWVuTDtPQUN0QjZCLElBQUlzSixRQUFRckI7T0FDWnVELElBQUlsQyxRQUFRckI7T0FDWjVILElBQUlpSixRQUFRckI7TUFDaEJ4RCxLQUFLeEgsT0FBS2tCLFVBQVE2QixZQUFZd0wsVUFBVW5MOzs7SUFHNUMsT0FBT29FO0dBQ1Q7R0F6R0EsU0FBU2dwQixpQkFBaUJod0IsR0FBRW9KLEdBQUVnbEIsSUFBR0QsSUFBR3RWLElBQUdDO0lBQy9CLElBQUZqWixJQUFJZ3ZCO0lBQ1JodkI7SUFDQW11QixnQkFBZ0JudUIsV0FBVUcsR0FBRUgsV0FBV3VKLEdBQUVnbEIsSUFBR0QsSUFBR3RWLElBQUdDO0lBQ2xEalo7SUFDQTtHQUNGO0dBbkJBLFNBQVNvd0Isa0JBQWtCQztJQUNuQixJQUFGcndCLElBQUlndkI7SUFDUmh2QjtJQUNBQSxpQkFBaUJxd0IsVUFBU3J3QixXQUFXcXdCO0lBQ3JDLElBQVUsSUFBRjF3QixPQUFPQSxJQUFJMHdCLFdBQVcxd0I7S0FDNUJLLGlCQUFpQnF3QixHQUFHMXdCLE9BQU1LLFdBQVdxd0IsR0FBRzF3QjtJQUMxQ0ssaUJBQWlCcXdCLFVBQVNyd0IsV0FBV3F3QjtJQUNyQ3J3QjtJQUNBO0dBQ0Y7R0FoQkEsU0FBU3N3QixrQkFBa0Jud0IsR0FBRW9KLEdBQUUwTixHQUFFL047SUFDekIsSUFBRmxKLElBQUlndkI7SUFDUmh2QixtQkFBbUJHLEdBQUVILFdBQVd1SixHQUFFME4sS0FBRy9OO0lBQ3JDO0dBQ0Y7R0F2RUEsU0FBU3FuQixlQUFlcHdCLEdBQUVvSjtJQUNsQixJQUFGdkosSUFBSWd2QjtJQUNSaHZCO0lBQ0FBLGlCQUFpQkEsS0FBSUEsV0FBV0E7SUFDaENBLGlCQUFpQkcsR0FBRUgsV0FBV3VKO0lBQzlCdko7SUFDQUEsTUFBSUc7SUFDSkgsTUFBSXVKO0lBQ0o7R0FDRjtHQWdKQSxTQUFTaW5CLG1CQUFtQjd2QjtJQUMxQjtLQUFJWCxJQUFJZ3ZCO0tBQ0o5bEIsSUFBSXZJO0tBQ0pzVyxJQUFJdFc7S0FDSnFMLEtBQUtoTSwwQkFBMEJpWCxHQUFFL047SUFDckMsSUFBUyxJQUFEdkosT0FBSUEsSUFBRXVKLEdBQUV2SjtLQUFJLElBQ1QsSUFBRGtCLE9BQUlBLElBQUVvVyxHQUFFcFcsSUFBSTtNQUNsQixJQUFJb0MsSUFBSXRDLElBQUloQixPQUFLa0IsUUFDYjhKLElBQUloTCxLQUFHc1gsU0FBUXBXO01BQ25CLEdBQUdvQyxTQUFTO09BQ1YrSSxRQUFRckI7T0FDUnFCLFFBQVFyQjtPQUNScUIsUUFBUXJCO09BQ1JxQixRQUFRckI7O1VBQ0g7T0FDTHFCLFFBQVFyQixTQUFTMUg7T0FDakIrSSxRQUFRckIsU0FBUzFIO09BQ2pCK0ksUUFBUXJCLFNBQVMxSDtPQUNqQitJLFFBQVFyQjs7O0lBSWQsT0FBT3FCO0dBQ1Q7R0FyTUEsU0FBU3lrQixlQUFldHdCLEdBQUVvSjtJQUNsQixJQUFGdkosSUFBSWd2QjtJQUNSaHZCLE1BQUlHO0lBQ0pILE1BQUl1SjtJQUNKO0dBQ0Y7R0E5RkEsU0FBU21uQix5QkFBeUIxcUI7SUFDMUIsSUFBRmhHLElBQUlndkI7SUFDUmh2QixVQUFVZ0c7SUFDQyxJQUFQMnFCLFNBQVNoZSx3QkFBd0IzTTtJQUNyQyxHQUFHaEcsYUFBYUEsWUFBWTJ3QjtJQUM1QjtHQUNGO0dBa0tBLFNBQVNDLHVCQUF1QjNaO0lBQ3hCLElBQUZqWCxJQUFJZ3ZCO0lBQ1JodkIsZUFBZWlYO0lBQ2ZqWCxzQkFBc0JpWDtJQUN0QjtHQUNGO0dBdUVBLFNBQVM0WixzQkFBc0I3ZTtJQUN2QixJQUFGaFMsSUFBSWd2QjtJQUNSaHZCLGNBQWNnUztJQUNkaFMsaUJBQWlCQSxzQkFBc0IyUyx3QkFBd0IzUztJQUMvRDtHQUNGO0dBZkEsU0FBUzh3QixpQkFBaUJqeEI7SUFDbEIsSUFBRkcsSUFBSWd2QjtJQUNSaHZCLFNBQVNIO0lBQ1RHLGlCQUFpQkEsc0JBQXNCMlMsd0JBQXdCM1M7SUFDL0Q7R0FDRjtHQWxNQSxTQUFTK3dCLGtCQUFrQkM7SUFDbkIsSUFBRmh4QixJQUFJZ3ZCO0lBQ1IsU0FBU2lDLFFBQVFDO0tBQ1AsSUFBSnJCLFdBQVdxQjtLQUNmLE1BQU9yQixnQkFBZ0JBLFlBQVlBO0tBQ25DLE9BQU9BO0lBQ1Q7SUFDQSxJQUNBbnRCLElBQUtzdUIsb0JBQ0w5aUIsSUFBSzhpQixtQkFDTGp1QixJQUFLaXVCO0lBQ0xoeEIsVUFBUWd4QjtJQUNFLElBQU5HLGNBQWNGLFFBQVF2dUIsS0FBS3V1QixRQUFRL2lCLEtBQUsraUIsUUFBUWx1QjtJQUNwRC9DLHNCQUF3Qm14QjtJQUN4Qm54Qix3QkFBd0JteEI7SUFDeEI7R0FDRjtHQW5EQSxTQUFTQyxzQkFBc0JuYSxHQUFFL047SUFDekIsSUFBRmxKLElBQUlndkI7SUFDUmh2QixVQUFVaVg7SUFDVmpYLFdBQVdrSjtJQUNYbEosaUJBQWlCaVg7SUFDakJqWCxrQkFBa0JrSjtJQUNsQjtHQUNGO0dBbEVBLFNBQVNtb0I7SUFDUFosZUFBZTFCLGlCQUFnQkE7SUFDL0JxQyxzQkFBc0JyQyxxQkFBb0JBO0lBQzFDNkIsdUJBQXVCN0I7SUFDdkI4QixzQkFBc0I5QjtJQUN0QitCLGlCQUFpQi9CO0lBQ2pCZ0Msa0JBQWtCaEM7SUFDbEIyQix5QkFBeUIzQjtJQUV6QkE7R0FDRjtHQWhFQSxTQUFTdUMsa0JBQWtCbmE7SUFDekI0WCxnQkFBYzVYO0lBQ2RrYTtJQUNBO0dBQ0Y7R0FnRUEsU0FBU0UscUJBQXFCcGhCLFFBQU84RyxHQUFFL047SUFDekIsSUFBUnNvQixVQUFVcmhCO0lBQ2QsaUJBQ1dxaEI7b0JBQ0FyaEI7OzttQkFHRDhHO29CQUNDL047O2tCQUVGaEo7OzttQkFHQ0E7R0FFWjtHQXhFQSxTQUFTdXhCLG1CQUFtQkM7SUFDakIsSUFBTEEsT0FBTy9lLHdCQUF3QitlO0lBQ25DLFNBQVNDLElBQUkzckI7S0FDSCxJQUFKMEIsTUFBTWdxQix1QkFBcUIxckI7S0FDL0IsR0FBRzBCLEtBQUssT0FBT0E7SUFDakI7SUFDVSxJQUFOa3FCO0lBQ0osTUFBS0YsYUFBV0UsV0FBV0Y7SUFDaEIsSUFBUDVtQixTQUFTNm1CO0lBQ2IsS0FBSTdtQixRQUFRQTtJQUNELElBQVArbUIsU0FBU0Y7SUFDYixLQUFJRSxRQUFRRDtJQUVOLElBQUYzYSxJQUFJMGE7SUFDUjFhLElBQUlBLElBQUUxRyxTQUFTMEc7SUFDZjJhLHNCQUFvQjNhO0lBRWQsSUFBRi9OLElBQUl5b0I7SUFDUnpvQixJQUFJQSxJQUFFcUgsU0FBU3JIO0lBQ2Ywb0IsdUJBQXFCMW9CO0lBRWIsSUFBSjRvQixNQUFNcHRCLCtCQUE4Qm9HLFFBQU84bUI7SUFDL0MsS0FBSUUsS0FBTTNkO0lBQ1YsSUFBSTRkLE1BQU1ELGNBQ04zaEIsU0FBUzRoQjtJQUNiNWhCLGVBQWU4RztJQUNmOUcsZ0JBQWdCakg7SUFDUixJQUFKaU8sTUFBTW9hLHFCQUFxQnBoQixRQUFPOEcsR0FBRS9OO0lBQ3hDaU8seUJBQTBCbEUsT0FDeEI4ZSxZQUFZOWUsTUFERTtJQUdoQnFlLGtCQUFrQm5hO0lBQ1QsSUFBTDZhLE9BQU9EO0lBQ1hDO0lBQ0FBLGlCQUFpQjdoQjtJQUNqQjtHQUNGO0dBZ2JBLFNBQVM4aEIsdUJBQXVCdnlCLEdBQUVxRCxHQUFFRSxHQUFFVTtJQUNwQ3dRO0dBQ0Y7R0ExVEEsU0FBUytkLGFBQWEveEIsR0FBRW9KO0lBQ3RCO0tBQUl2SixJQUFJZ3ZCO0tBQ0poakIsS0FBR2hNO0tBQ0gyRCxJQUFJcUk7S0FDSmdsQixRQUFRaHhCO0lBQ1oyRCxPQUFRcXRCO0lBQ1JydEIsT0FBUXF0QixtQkFDUnJ0QixPQUFRcXRCO0lBQ1JydEI7SUFDQTNELE1BQUlHO0lBQ0pILE1BQUl1SjtJQUNKdkosdUJBQXVCZ00sSUFBRzdMLEdBQUVILFdBQVd1SjtJQUN2QztHQUNGO0dBSUEsU0FBUzRvQixvQkFBb0JoeUIsR0FBRW9KO0lBQzdCO0tBQUl2SixJQUFJZ3ZCO0tBQ0poakIsS0FBR2hNLHVCQUF1QkcsR0FBRUgsV0FBV3VKO0tBQ3ZDNUYsSUFBSXFJO0lBQ1IsUUFBUXJJLGVBQWVBLGFBQWFBO0dBQ3RDO0dBaVJBLFNBQVN5dUI7SUFDUGplO0dBQ0Y7R0FsQkEsU0FBU2tlLHdCQUF3QixTQUFRO0dBRXpDLFNBQVNDLHVCQUF1QixTQUFRO0dBMVR4QyxTQUFTQyxpQkFDRCxJQUFGdnlCLElBQUlndkIscUJBQ1IsT0FBT2h2QixRQUNUO0dBR0EsU0FBU3d5QixpQkFDRCxJQUFGeHlCLElBQUlndkIscUJBQ1IsT0FBT2h2QixTQUNUO0dBMFRBLFNBQVN5eUI7SUFDUHRlO0dBQ0Y7R0F0R0EsU0FBU3VlLGtCQUFrQkM7SUFDekI7S0FBSTN5QixJQUFJZ3ZCO0tBQ0ovWCxJQUFJalgsc0JBQXNCMlMsd0JBQXdCZ2dCO0lBQ3RELFdBQVUxYixHQUFFalg7R0FDZDtHQTBGQSxTQUFTNHlCLG1CQUFtQkM7SUFDMUIxZTs7R0FDRjtHQW9CQSxTQUFTMmUsa0JBQWtCcHpCO0lBQ3pCeVU7R0FDRjtHTmpRQSxTQUFTNGUsa0JBQW1CNXlCLEdBQUdvSjtJQUFLLFVBQVN3YixpQkFBaUI1a0IsR0FBRW9KO0dBQWdCO0dBR2hGLFNBQVN5cEIsaUJBQWtCN3lCLEdBQUdvSjtJQUFLLFVBQVN3YixpQkFBaUI1a0IsR0FBRW9KO0dBQWU7R0ZwSTlFLFNBQVMwcEIsc0JBQXNCL3BCLEdBQUdsSjtJQUNoQyxJQUFJSixNQUFNSSxVQUFVTCxHQUFHc1g7SUFDdkIsSUFBS3RYLE9BQU9BLFNBQVNDLEtBQUtELE9BQVE7S0FDaENzWDtNQUFJalgsYUFBYUwsS0FDWkssYUFBYUwsY0FDYkssYUFBYUw7UUFDYkssYUFBYUw7S0FDbEJ1SixJQUFJb1Usa0JBQWtCcFUsR0FBRytOOztJQUUzQkE7SUFDQSxPQUFRclg7O09BQ0FxWCxJQUFLalgsYUFBYUw7O09BQ2xCc1gsS0FBS2pYLGFBQWFMOztPQUV4QnNYLEtBQUtqWCxhQUFhTCxJQUNsQnVKLElBQUlvVSxrQkFBa0JwVSxHQUFHK047O0lBRzNCL04sS0FBS3RKO0lBQ0wsT0FBT3NKO0dBQ1Q7R0F1Q0EsU0FBU2dxQixxQkFBcUJocUIsR0FBRzlGO0lBQy9CLE9BQU82dkIsc0JBQXNCL3BCLEdBQUcxRCx1QkFBdUJwQztHQUN6RDtHQXJDQSxTQUFTK3ZCLHdCQUF3QmpxQixHQUFHbEo7SUFDbEMsSUFBSUosTUFBTUksVUFBVUwsR0FBR3NYO0lBQ3ZCLElBQUt0WCxPQUFPQSxTQUFTQyxLQUFLRCxPQUFRO0tBQ2hDc1gsSUFBSWpYLEVBQUVMLEtBQ0RLLEVBQUVMLGNBQ0ZLLEVBQUVMLGVBQ0ZLLEVBQUVMO0tBQ1B1SixJQUFJb1Usa0JBQWtCcFUsR0FBRytOOztJQUUzQkE7SUFDQSxPQUFRclg7O09BQ0FxWCxJQUFLalgsRUFBRUw7O09BQ1BzWCxLQUFLalgsRUFBRUw7O09BQ1BzWCxLQUFLalgsRUFBRUwsSUFDYnVKLElBQUlvVSxrQkFBa0JwVSxHQUFHK047O0lBRzNCL04sS0FBS3RKO0lBQ0wsT0FBT3NKO0dBQ1Q7RzFCcXFCQSxTQUFTa3FCLHNCQUFzQnB6QjtJQUM3QixPQUFRQTtlQUVONEMsNkJBQTZCNUM7O09BRTdCLE9BQU9BOztPQUVQLE9BQU9BOztHQUVYO0cwQnhxQkEsU0FBU3F6QixvQkFBb0JucUIsR0FBRzlGO0lBQ2xCLElBQVJLLFVBQVUydkIsc0JBQXNCaHdCO0lBQ3BDLGNBQVVLO2NBQ0R3dkIsc0JBQXNCL3BCLEdBQUd6RjtjQUV6QjB2Qix3QkFBd0JqcUIsR0FBR3pGO0dBQ3RDO0dBaEZBLFNBQVM2dkIsb0JBQW9CcHFCO0lBQzNCQSxLQUFLQTtJQUNMQSxJQUFJbVUsU0FBVW5VO0lBQ2RBLEtBQUtBO0lBQ0xBLElBQUltVSxTQUFVblU7SUFDZEEsS0FBS0E7SUFDTCxPQUFPQTtHQUNUO0dBd0ZBLFNBQVNxcUIsVUFBV3ZMLE9BQU93TCxPQUFPQyxNQUFNMUY7SUFDdEMsSUFBSTJGLE9BQU9DLElBQUlDLElBQUl4WCxJQUFJb0ksS0FBS3RiLEdBQUc5RixHQUFHekQsR0FBR0M7SUFDckN3YyxLQUFLb1g7SUFDTCxHQUFJcFgsVUFBVUEsVUFBVUE7SUFDeEJvSSxNQUFNd0Q7SUFDTjllLElBQUl1cUI7SUFDSkMsU0FBUzNGO0lBQU00RjtJQUFRQztJQUN2QixNQUFPRCxLQUFLQyxNQUFNcFAsUUFBUztLQUN6QnBoQixJQUFJc3dCLE1BQU1DO0tBQ1YsR0FBSXZ3QixLQUFLQTtNQUFjO1FBQ2xCaWhCLGdCQUFnQmpoQixrQkFBa0JpaEIsZ0JBQWdCamhCLG9CQUFxQjtPQUNqRSxJQUFIMlQsS0FBS3NOLGdCQUFnQmpoQixvQkFBb0JBO09BQzdDOEYsSUFBSW9VLGtCQUFtQnBVLEdBQUc2TjtPQUMxQnlOOzs7YUFHS3BoQixhQUFheEMsU0FBU3dDLFVBQVVBO01BQVMsT0FDeENBOztTQUdOOEYsSUFBSW9VLGtCQUFrQnBVLEdBQUc5RixPQUN6Qm9oQixPQUNBOztTQUdBa1AsUUFBUUMsTUFBTXZ3QixNQUNkOztTQUVBLEdBQUd5Z0IseUJBQXlCemdCLE9BQU87U0FLM0IsSUFBSkUsTUFBUUYscUJBQXVCQTtTQUNuQzhGLElBQUlvVSxrQkFBa0JwVSxHQUFHNUY7U0FDekIsSUFBSzNELE9BQU9DLE1BQU13RCxVQUFVekQsSUFBSUMsS0FBS0QsSUFBSyxDQUN4QyxHQUFJaTBCLE1BQU14WCxJQUFJLE9BQ2RzWCxNQUFNRSxRQUFReHdCLEVBQUV6RDs7U0FFbEI7O2FBRU93RixpQkFBaUIvQixHQUFJO01BQzlCOEYsSUFBSW1xQixvQkFBb0JucUIsR0FBRTlGO01BQzFCb2hCOzthQUNTcGYsa0JBQWtCaEMsR0FBSTtNQUMvQjhGLElBQUlncUIscUJBQXFCaHFCLEdBQUU5RjtNQUMzQm9oQjs7b0JBQ2dCcGhCLGVBQWdCO01BQ2hDOEYsSUFBSStwQixzQkFBc0IvcEIsR0FBRTlGO01BQzVCb2hCOzthQUNTcGhCLE9BQU9BLE9BQU07TUFFdEI4RixJQUFJb1Usa0JBQWtCcFUsR0FBRzlGLElBQUVBO01BQzNCb2hCOztvQkFDZ0JwaEIsZUFBZ0IsQ0FFaEM4RixJQUFJK1Usb0JBQW9CL1UsR0FBRTlGLElBQzFCb2hCOztJQUdKdGIsSUFBSW9xQixvQkFBb0JwcUI7SUFDeEIsT0FBT0E7R0FDVDtHUjFQQSxTQUFTMnFCLHdCQUF3QjNxQixHQUFHekk7SUFDbEMsT0FBTzB5Qix3QkFBd0JqcUIsR0FBRXpJO0dBQ25DO0dKMEZBLFNBQVNxekIsZUFBZXJlLEtBQUsxSixLQUFLbk07SUFDaEMsSUFBVSxJQUFGRCxJQUFJQyxTQUFTRCxRQUFRQSxLQUFLLEdBQzdCOFYsU0FBUzFKLE1BQUlwTSxTQUFTLE9BQU9BO0lBRWxDO0dBQ0Y7R0ExRUEsU0FBU28wQixjQUFjNXpCO0lBQ3JCLElBQUlQLE1BQU1rMEIsZUFBZTN6QixNQUFNQSxnQkFDM0IrSTtJQUNKLElBQVcsSUFBRnZKLE9BQU9BLElBQUlDLEtBQUtELEtBQ3ZCdUosSUFBSW9VLGtCQUFrQnBVLEdBQUcvSSxPQUFPUjtJQUVsQyxPQUFPdUo7R0FDVDtHTThDQSxTQUFTOHFCLHdCQUF5Qjd6QixHQUFHMnJCLE1BQU1ycUI7SUFDekMsS0FBS2tjLFNBQVN4ZCxHQUFJO0tBQ2hCLEdBQUl5ZCxNQUFNemQsSUFBSSxPQUFPeUQ7S0FDckIsT0FBT0Esd0JBQTBCekQ7O0lBRTFCLElBQUxnSixPQUFRaEosY0FBVUEsT0FBTTZiLGVBQWE3YjtJQUN6QyxHQUFHZ0osTUFBTWhKLE1BQUtBO0lBQ04sSUFBSjRiO0lBQ0osR0FBSTViO0tBQVE7WUFDSEE7S0FBTyxNQUNQQSxTQUFTNGIsYUFBYyxDQUFFNWIsUUFBUTRiOztLQUNuQyxNQUNFNWIsT0FBUSxDQUFFQSxRQUFRNGI7SUFFM0IsSUFBSWtZLFdBQVdsWSxvQkFDWG1ZO0lBQ0osR0FBSS9xQjtLQUFNK3FCOztLQUNMLE9BQ0l6eUI7O1FBQ1l5eUIsZ0JBQWdCOztRQUNoQkEsZ0JBQWdCO2dCQUMxQjs7SUFHWCxHQUFJcEksYUFBYUEsVUFBVztLQUVsQixJQUFKcUksTUFBTWwwQixZQUFXNnJCO0tBQ3JCM3JCLElBQUlGLFdBQVdFLElBQUlnMEIsT0FBT0E7O0lBRWxCLElBQU5DLFFBQVFqMEI7SUFDWixHQUFHMnJCLFVBQVU7S0FDSCxJQUFKdUksTUFBTUQ7S0FDVixHQUFHQztNQUNERCxlQUFlNXhCLGdCQUFnQnNwQjtTQUU1QjtNQUNNLElBQUw5WixPQUFPcWlCLFVBQU12STtNQUNqQixHQUFHc0ksZUFBZXBpQjtPQUNoQm9pQixTQUFTNXhCLGdCQUFnQndQLE9BQU9vaUI7O09BRWhDQSxRQUFRQSxnQkFBZXBpQjs7O0lBRzdCLE9BQU9wTzthQUF5QnN3QixrQkFBa0JFLGNBQWNILFdBQVdsWTtHQUM3RTtHQXNKQSxTQUFTdVksaUJBQWtCbjBCLEdBQUdvSixHQUFLLE9BQU90SixXQUFXRSxHQUFHb0osR0FBSTtHbEIwTy9CLElBQXpCZ3JCO0d5QmhQSixTQUFTQyxZQUFhOVE7SUFDcEIsR0FBR0EsZUFBZTNqQixLQUFLO0tBQ3JCLElBQUk4dkIsTUFBTW5NLGVBQ04rUSxRQUFRM3FCLDJCQUEyQitsQjtLQUN2QyxHQUFJNEU7TUFDRi9RLGNBQWMzakI7U0FFWDtNQUNILEdBQUcyakIscUJBQXFCQSxrQkFBa0IrUSxhQUFhO09BQy9DLElBQUYxeEIsUUFBUXVDLFdBQVdvZSxrQkFBa0IrUTtPQUN6QzF4QixNQUFNMmdCO09BQ05BLGNBQWMzZ0I7O01BRWhCMmdCLGdCQUFnQitRLE9BQU0vUTtNQUN0QkEsZUFBZStRO01BQ2YvUSxtQkFBbUIrUTs7O1FBRWhCO0tBQ0s7TUFBTkM7UUFBUWhSO1VBQWVBO1VBQWFBO1VBQWFBO1VBQWlCQSxxQkFBcUJBO0tBQzNGQSxlQUFlZ1I7S0FDZmhSLG1CQUFtQmdSOztHQUV2QjtHbEI3T0EsU0FBU0M7SUFDUGhzQixvQkFBb0I5RDtHQUN0QjtHUGtkQSxTQUFTK3ZCLHVCQUF3QjUwQixHQUFHK0w7SUFDNUIsSUFBRnJKLFFBQVEySyxpQkFBaUJuSCwwQkFBMEJsRyxJQUFJK0w7SUFDM0QsU0FBUzhvQixRQUFRQztLQUNmLElBQUk3eEIsSUFBSVAsWUFDSkQsSUFBSVE7S0FDUixPQUFRQSxlQUFnQjtNQUN0QkEsSUFBSVA7TUFDRyxJQUFIcXlCLEtBQUt0eUI7TUFDVCxHQUFJQSxLQUFLc3lCLFNBQVNEO01BQ2xCcnlCLElBQUlzeUIsS0FBTTl4Qjs7S0FFWixPQUFPUjtJQUNUO0lBRUEsT0FBT0M7O09BRUwsSUFBSXN5QixpQkFDQUMsV0FBV3Z5QixhQUNmOztPQUVBO1FBQUlzeUIsYUFBYXR5QjtRQUNib3lCO1FBQ0FHLFdBQVdKLFFBQVFDO09BQ3ZCLEdBQUdBO1FBQ0QzZ0I7O09BRUY7O2VBR0FBLGdEQUNBOztJQUVGLE9BQU82Z0IsYUFBYVQsMkJBQTJCVTtHQUNqRDtHQXJSQSxTQUFTQyw2QkFBNkIvWSxRQUFRcFE7SUFDNUMsU0FBUzhvQixRQUFRQztLQUNmLElBQUk3eEIsSUFBSWtaLGlCQUNKMVosSUFBSVE7S0FDUixPQUFRQSxlQUFnQjtNQUN0QkEsSUFBSWtaO01BQ0csSUFBSDRZLEtBQUt0eUI7TUFDVCxHQUFJQSxLQUFLc3lCLFNBQVNEO01BQ2xCcnlCLElBQUlzeUIsS0FBTTl4Qjs7S0FFWixPQUFPUjtJQUNUO0lBQ1UsSUFBTjB5QixRQUFRaFo7SUFDWixPQUFPZ1o7O09BRUw7UUFBSUg7UUFDQUk7UUFDQUgsV0FBVzlZO1FBQ1hrWix3QkFBd0JKO1FBQ3hCSyxjQUFjblo7UUFDZG9aLFdBQVdwWjtRQUNYcVosV0FBV3JaO09BQ2Y7O09BRUE7UUFBSTZZLGFBQWE3WTtRQUNiaVo7UUFDQU47UUFDQUcsV0FBV0osUUFBUUM7UUFDbkJPLHdCQUF3QlIsUUFBUUM7UUFDaENRLGNBQWNULFFBQVFDO1FBQ3RCUyxXQUFXVixRQUFTQztRQUNwQlUsV0FBV1gsUUFBU0M7T0FDeEIsR0FBR0E7UUFDQzNnQjs7T0FFSjs7T0FFQUE7O09BQ0E7O09BRUFBLDJEQUNBOztJQUVGO0tBQUk2UTtLQUNBeVEsbUJBQW9CSCx1QkFBb0J2MUI7S0FDeEMyMUI7SUFDSixTQUFTQyxXQUFZeFo7S0FDVixJQUFMcFksT0FBT29ZO0tBQ1gsR0FBSXBZO01BQXVDLEdBQ3JDQSxhQUF5QztPQUMzQyxJQUFJVCxNQUFNUyxZQUNOaU8sT0FBUWpPLGlCQUNSWCxLQUFLRTtPQUNULEdBQUkwTyxXQUFXLE9BQU81TztPQUN0QixHQUFJcXlCLGtCQUFrQkEsaUJBQWlCQyxpQkFBaUJ0eUI7T0FDeEQ0aEIsV0FBVzVoQixHQUFHNE87T0FDZCxPQUFPNU87OztPQUVQLE9BQVFXO2FBRU5BLGFBQTBDO01BQzVDLElBQUluRSxNQUFNbUUsYUFDTlgsSUFBSStZLGVBQWdCdmM7TUFDeEIsR0FBSTYxQixrQkFBa0JBLGlCQUFpQkMsaUJBQWlCdHlCO01BQ3hELE9BQU9BOzs7TUFDRixPQUNFVzs7U0FFTCxPQUFPb1k7O1NBRVAsT0FBT0E7O1NBRVAsT0FBT0E7O1NBRVBoSSxpREFDQTs7U0FFVyxJQUFQclQsU0FBU3FiO1NBQ2IsR0FBR2laLGlCQUFpQnQwQixTQUFTNDBCLGNBQWM1MEI7U0FDM0MsT0FBTzIwQixpQkFBaUIzMEI7O1NBRWIsSUFBUEEsU0FBU3FiO1NBQ2IsR0FBR2laLGlCQUFpQnQwQixTQUFTNDBCLGNBQWM1MEI7U0FDM0MsT0FBTzIwQixpQkFBaUIzMEI7O1NBRWIsSUFBUEEsU0FBU3FiO1NBQ2IsR0FBR2laLGlCQUFpQnQwQixTQUFTNDBCLGNBQWM1MEI7U0FDM0MsT0FBTzIwQixpQkFBaUIzMEI7O1NBRXhCO1VBQUkrUixTQUFTc0o7VUFDVDdZLE1BQU11UDtVQUNOYixPQUFPYTtVQUNQelAsS0FBS0U7U0FDVCxHQUFJME8sV0FBVyxPQUFPNU87U0FDdEIsR0FBSXF5QixrQkFBa0JBLGlCQUFpQkMsaUJBQWlCdHlCO1NBQ3hENGhCLFdBQVc1aEIsR0FBRzRPO1NBQ2QsT0FBTzVPOztTQUVQK1Esb0RBQ0E7O1NBRUEsSUFBSXZVLE1BQU11YyxpQkFDTi9ZLElBQUkrWSxlQUFnQnZjO1NBQ3hCLEdBQUk2MUIsa0JBQWtCQSxpQkFBaUJDLGlCQUFpQnR5QjtTQUN4RCxPQUFPQTs7U0FFUCxJQUFJeEQsTUFBTXVjLGtCQUNOL1ksSUFBSStZLGVBQWdCdmM7U0FDeEIsR0FBSTYxQixrQkFBa0JBLGlCQUFpQkMsaUJBQWlCdHlCO1NBQ3hELE9BQU9BOztTQUVELElBQUZKLFFBQVFwQztTQUNaLElBQVcsSUFBRmpCLE9BQU1BLE9BQU1BLEtBQUtxRCxNQUFNckQsS0FBS3djO1NBQy9CLElBQUYvWSxJQUFJd21CLG9CQUFxQjVtQjtTQUM3QixHQUFJeXlCLGtCQUFrQkEsaUJBQWlCQyxpQkFBaUJ0eUI7U0FDeEQsT0FBT0E7O1NBRUQsSUFBRkosUUFBUXBDO1NBQ1osSUFBVyxJQUFGakIsT0FBTUEsT0FBTUEsS0FBS3FELEVBQUVyRCxLQUFLd2M7U0FDM0IsSUFBRi9ZLElBQUl3bUIsb0JBQXFCNW1CO1NBQzdCLEdBQUl5eUIsa0JBQWtCQSxpQkFBaUJDLGlCQUFpQnR5QjtTQUN4RCxPQUFPQTs7U0FFUCxJQUFJeEQsTUFBTXVjLGlCQUNOL1ksUUFBUXhDLE1BQU1oQjtTQUNsQndEO1NBQ00sSUFBRkosUUFBUXBDO1NBQ1osR0FBSTYwQixrQkFBa0JBLGlCQUFpQkMsaUJBQWlCdHlCO1NBQ3hELElBQVcsSUFBRnpELE9BQU1BLEtBQUtDLEtBQUlELElBQUs7VUFDM0IsSUFBVyxJQUFGa0IsT0FBTUEsT0FBTUEsS0FBS21DLE1BQU1uQyxLQUFLc2I7VUFDckMvWSxFQUFFekQsS0FBS2lxQixvQkFBcUI1bUI7O1NBRTlCLE9BQU9JOztTQUVQLElBQUl4RCxNQUFNdWMsaUJBQ04vWSxRQUFReEMsTUFBTWhCO1NBQ2xCd0Q7U0FDTSxJQUFGSixRQUFRcEM7U0FDWixHQUFJNjBCLGtCQUFrQkEsaUJBQWlCQyxpQkFBaUJ0eUI7U0FDeEQsSUFBVyxJQUFGekQsT0FBTUEsS0FBS0MsS0FBSUQsSUFBSztVQUMzQixJQUFXLElBQUZrQixPQUFNQSxPQUFNQSxLQUFLbUMsRUFBRW5DLEtBQUtzYjtVQUNqQy9ZLEVBQUd6RCxLQUFLaXFCLG9CQUFxQjVtQjs7U0FFL0IsT0FBT0k7O1NBRVAsSUFBSXhELE1BQU11YyxrQkFDTi9ZLFFBQVF4QyxNQUFNaEI7U0FDbEJ3RDtTQUNBLEdBQUlxeUIsa0JBQWtCQSxpQkFBaUJDLGlCQUFpQnR5QjtTQUNsRCxJQUFGSixRQUFRcEM7U0FDWixJQUFXLElBQUZqQixPQUFNQSxLQUFLQyxLQUFJRCxJQUFLO1VBQzNCLElBQVcsSUFBRmtCLE9BQU1BLE9BQU1BLEtBQUttQyxNQUFNbkMsS0FBS3NiO1VBQ3JDL1ksRUFBRXpELEtBQUtpcUIsb0JBQXFCNW1COztTQUU5QixPQUFPSTs7U0FFUCxJQUFJeEQsTUFBTXVjLGtCQUNOL1ksUUFBUXhDLE1BQU1oQjtTQUNsQndEO1NBQ00sSUFBRkosUUFBUXBDO1NBQ1osSUFBVyxJQUFGakIsT0FBTUEsS0FBS0MsS0FBSUQsSUFBSztVQUMzQixJQUFXLElBQUZrQixPQUFNQSxPQUFNQSxLQUFLbUMsRUFBRW5DLEtBQUtzYjtVQUNqQy9ZLEVBQUd6RCxLQUFLaXFCLG9CQUFxQjVtQjs7U0FFL0IsT0FBT0k7OztTQUdQK1EsNENBQ0E7Ozs7U0FJQSxJQUFJbFIsR0FBR2pEO1NBQ1AsT0FBUWlELElBQUlrWix1QkFBd0JuYyxLQUFLRixvQkFBcUJtRDtTQUM5RCxJQUFJMnlCLE1BQU12UixnQkFBZ0Jya0IsSUFDdEI2MUI7U0FDSixLQUFJRDtVQUNGemhCO1NBQ0YsT0FBT3BRO3NCQUVMOztZQUVBLEtBQUk2eEI7YUFDRnpoQjtZQUNGMGhCLGdCQUFnQkQ7WUFDaEI7O1lBRUFDLGdCQUFnQjFaO1lBRWhCQTtZQUFrQkE7WUFDbEI7O1NBRUY7VUFBSTJaLFVBQVUzWjtVQUNWbks7VUFDQTVPLElBQUl3eUIsZ0JBQWdCelosUUFBUW5LO1NBQ2hDLEdBQUc2akIsaUJBQWlCbHhCO1VBQVUsR0FDekJreEIsaUJBQWlCN2pCO1dBQ2xCbUM7O1NBRUosR0FBSXNoQixrQkFBa0JBLGlCQUFpQkMsaUJBQWlCdHlCO1NBQ3hELE9BQU9BO2lCQUVQK1E7O0lBSVI7SUFDQSxHQUFHaWhCO0tBQVksR0FDVm5QO01BQ0Q7T0FBSTllLE9BQU9nVixzQkFBc0I4WTtPQUM3QnZ0QixVQUFVcEMsV0FBVyt2QjtPQUNyQjN0QixNQUFNdWUsc0JBQXNCOWUsTUFBTU87T0FDbEN5VSxhQUFhOU8saUJBQWlCM0Y7O01BRWxDeU07SUFHSSxJQUFKek0sTUFBTWl1QixXQUFZeFo7SUFDdEIsTUFBTzZJLGlCQUFrQjtLQUN2QixJQUFJaFQsT0FBT2dULGFBQ1A1aEIsSUFBSTRoQixhQUNKcmhCLElBQUlQO0tBQ1IsR0FBSU8sSUFBSXFPLE1BQU1nVCxXQUFXNWhCLEdBQUc0TztLQUM1QjVPLEVBQUVPLEtBQUtneUIsV0FBWXhaOztJQUVyQixVQUFXcFEsaUJBQWVBLFNBQVNvUTtJQUNuQyxPQUFPelU7R0FDVDtHRjRNQSxTQUFTcXVCLHFCQUFxQi8xQjtJQUMzQkEsV0FBWTRDLDZCQUE2QjVDO0lBQzFDLE9BQU9FLHVCQUF1QkY7R0FDaEM7R0VsZ0JBLFNBQVNnMkIsNEJBQTRCaDJCLEdBQUUrTDtJQUMxQjtLQUFQb1E7O1FBQWEvUTtTQUFnQjJxQixxQkFBcUIvMUIsV0FBVytMLGtCQUFjQSxNQUFJQTtJQUNuRixPQUFPbXBCLDZCQUE2Qi9ZLFFBQVFwUTtHQUM5QztHeUIwSUEsU0FBU2txQixpQkFBa0J4UztJQUN6QjtLQUFJQyxPQUFPSixvQkFBb0JHO0tBQzNCNVEsYUFBYXZOLFdBQVdpdkI7SUFDNUIsU0FBUzJCLE1BQU1wcUIsUUFBUWhMLFFBQVEyQjtLQUN2QixJQUFGQztLQUNKLE1BQU1BLElBQUlELEVBQUU7TUFDVixHQUFHaWhCLG9CQUFvQkEsZ0JBQWdCO09BQ3JDQTtPQUNBQTtPQUNBOFEsWUFBWTlROztNQUVkLEdBQUlBLG9CQUFvQkEsaUJBQ3RCO01BQ0Y1WCxPQUFPaEwsU0FBTzRCLEtBQUtnaEIsWUFBWUE7TUFDL0JBO01BQ0FoaEI7O0tBRUYsT0FBT0E7SUFDVDtJQUNNLElBQUZBLElBQUl3ekIsTUFBTXJqQixXQUFXMGhCO0lBQ3pCLEdBQUc3eEI7S0FDRGl5QjtZQUNPanlCLElBQUk2eEI7S0FDWHBnQjtJQUNGO0tBQUl2VSxNQUFNZzFCLHVCQUF3QnZ2QixvQkFBb0J3TjtLQUNsRC9MLFVBQVV4QixXQUFXMUYsTUFBTTIwQjtJQUMvQnp0QixRQUFRK0w7SUFDRixJQUFGblEsSUFBSXd6QixNQUFNcHZCLEtBQUt5dEIsMEJBQTBCMzBCO0lBQzdDLEdBQUc4QyxJQUFJOUM7S0FDTHVVLGlEQUFpRHpSLFdBQVc5QztJQUM5RDtLQUFJa0I7S0FDQTRHLE1BQU1zdUIsNEJBQTRCM3dCLG9CQUFvQnlCLE1BQU1oRztJQUNoRTRpQixjQUFjQSxjQUFjNWlCO0lBQzVCLE9BQU80RztHQUNUO0d6QnRMQSxTQUFTeXVCLDZCQUE2Qm4yQixHQUFFK0w7SUFDM0IsSUFBUG9RLGFBQWEvUSxlQUFnQnBMLFVBQVUrTCxrQkFBY0EsTUFBSUE7SUFDN0QsT0FBT21wQiw2QkFBNkIvWSxRQUFRcFE7R0FDOUM7R3lCdUxBLFNBQVNxcUIsaUNBQWlDbnpCLEdBQ3hDLE9BQU9nekIsaUJBQWlCaHpCLEdBQzFCO0dyQnpFQSxTQUFTb3pCLDhCQUE4QixTQUFRO0dtQjVML0MsU0FBU0MsaUJBQWlCbjJCO0lBQ3hCLFFBQVVBLHlCQUNBQTtjQUNBQTtjQUNBQTtHQUNaO0dic0dBLFNBQVNvMkIsZUFBZ0JwMkIsR0FBR29KLEdBQUssT0FBT3BKLE1BQU1vSixHQUFHO0dBZ0JqRCxTQUFTaXRCLGVBQWdCcjJCLEdBQUdvSixHQUFLLE9BQU9wSixNQUFNb0osR0FBSTtHYW5IbEQsU0FBU2t0QixpQkFBaUJ0MkI7SUFDbEIsSUFBRm9KLElBQUkyVixvQkFBb0IvZTtJQUM1QixPQUFPMGI7Y0FBcUJ0UyxNQUFNQSxNQUFNQSxNQUFNQSxNQUFNQSxNQUFNQSxNQUFNQSxNQUFNQTtHQUN4RTtHYmtJQSxTQUFTbXRCLGVBQWdCdjJCLEdBQUdvSixHQUFLLE9BQU9wSixNQUFNb0osR0FBRztHQXhCakQsU0FBU290QixtQkFBbUJ4MkIsR0FBSyxTQUFRQSxXQUFZO0dBK0JyRCxTQUFTeTJCLG9CQUFxQnoyQjtJQUM1QixXQUFXMEksUUFBUTFJLGNBQWVBLG9CQUFzQkE7R0FDMUQ7R0FHQSxTQUFTMDJCLG9CQUFxQjEyQixHQUFLLE9BQU9BLFVBQVU7R0FqQ3BELFNBQVMyMkIsdUJBQXVCMzJCLEdBQUssU0FBUUEsVUFBVztHQWhCeEQsU0FBUzQyQixlQUFnQjUyQixHQUFLLE9BQU9BLFFBQVE7R0FxRTdDLFNBQVM2MkIsa0JBQW1CdEwsS0FBS3ZyQjtJQUN6QixJQUFGTixJQUFJNHJCLGtCQUFrQkM7SUFDMUIsR0FBSTdyQixnQkFBZ0JpM0IsdUJBQXVCMzJCLEdBQUksQ0FDN0NOLGNBQWFNLElBQUk0MkIsZUFBZTUyQjtJQUVsQztLQUFJMkw7S0FDQW1yQixRQUFRTCxvQkFBb0IvMkI7S0FDNUJxM0I7SUFDSixFQUFHO0tBQ0ssSUFBRnJlLElBQUkxWSxVQUFVODJCO0tBQ2xCOTJCLElBQUkwWTtLQUNKL00sU0FBU29yQixhQUFhTCxvQkFBb0JoZSxjQUFjL007OztRQUMvQzZxQixtQkFBbUJ4MkI7SUFDOUIsR0FBSU4sWUFBYTtLQUNmQTtLQUNNLElBQUY0QyxJQUFJNUMsU0FBU2lNO0tBQ2pCLEdBQUlySixPQUFPcUosU0FBU3RKLGdCQUFpQkMsVUFBVXFKOztJQUVqRCxPQUFPMmQsdUJBQXVCNXBCLEdBQUdpTTtHQUNuQztHQWhEQSxTQUFTcXJCLGVBQWdCaDNCLEdBQUdvSixHQUFLLE9BQU9wSixNQUFNb0osR0FBRztHQTlCakQsU0FBUzZ0QixlQUFlajNCLEdBQUVvSixHQUFLLE9BQU9wSixNQUFNb0osR0FBRztHQWhCL0MsU0FBUzh0QixlQUFlbDNCLEdBQUVvSixHQUFLLE9BQU9wSixXQUFXb0osT0FBUTtHYXBMekQsU0FBUyt0Qix5QkFBMEJ0M0I7SUFDakMsSUFBSUwsT0FBT0MsTUFBTWdLLHNCQUFzQjVKLElBQUl1M0IsV0FBV3B1QjtJQUN0RCxHQUFJdko7S0FBUyxPQUNIaUssdUJBQXVCN0osR0FBRUw7O1FBQ3hCQSxLQUFLd0osWUFBVzs7UUFDaEJ4SixLQUFLd0osVUFBVTs7SUFHMUIsR0FBSXhKLFFBQVFDLE9BQU9pSyx1QkFBdUI3SixHQUFHTDtLQUMzQyxPQUFRa0ssdUJBQXVCN0osR0FBR0w7OztRQUNmNDNCLFdBQVc1M0IsUUFBUTs7O1FBQ25CNDNCLFVBQVc1M0IsUUFBUTs7O1FBQ25CNDNCLFVBQVc1M0IsUUFBUTs7O1FBQ25CQSxRQUFROztJQUU3QixRQUFRQSxHQUFHd0osTUFBTW91QjtHQUNuQjtHQUdBLFNBQVNDLGlCQUFpQnYwQjtJQUN4QixHQUFJQSxXQUFXQSxTQUFVLE9BQU9BO0lBQ2hDLEdBQUlBLFdBQVdBLFNBQVUsT0FBT0E7SUFDaEMsR0FBSUEsV0FBV0EsVUFBVSxPQUFPQTtJQUNoQztHQUNGO0diaVFBLFNBQVN3MEIscUJBQXFCejNCO0lBQzVCO0tBQUkwQyxJQUFJNDBCLHlCQUEwQnQzQjtLQUM5QkwsSUFBSStDO0tBQU15RyxPQUFPekc7S0FBTTYwQixPQUFPNzBCO0tBQzlCZzFCLFNBQVNkLG9CQUFvQlc7S0FDN0JJO09BQ0EsSUFBSTl1Qiw2Q0FBNkM2dUI7S0FDakR6MEIsSUFBSTRHLHVCQUF1QjdKLEdBQUdMO0tBQzlCZ0UsSUFBSTZ6QixpQkFBaUJ2MEI7SUFDekIsR0FBSVUsU0FBU0EsS0FBSzR6QixNQUFNcGpCO0lBQ2hCLElBQUp6TSxNQUFNa3ZCLG9CQUFvQmp6QjtJQUM5QixPQUFTO0tBQ1BoRTtLQUNBc0QsSUFBSTRHLHVCQUF1QjdKLEdBQUdMO0tBQzlCLEdBQUlzRCxTQUFTO0tBQ2JVLElBQUk2ekIsaUJBQWlCdjBCO0tBQ3JCLEdBQUlVLFNBQVNBLEtBQUs0ekIsTUFBTTtLQUV4QixHQUFJRixlQUFlTSxXQUFXandCLE1BQU15TTtLQUNwQ3hRLElBQUlpekIsb0JBQW9CanpCO0tBQ3hCK0QsTUFBTTZ1QixlQUFlYSxlQUFlTSxRQUFRaHdCLE1BQU0vRDtLQUVsRCxHQUFJMHpCLGVBQWUzdkIsS0FBSy9ELElBQUl3UTs7SUFFOUIsR0FBSXhVLEtBQUtpSyxzQkFBc0I1SixJQUFJbVU7SUFDbkMsR0FBSW9qQixjQUFjRixtQkFBbUJ4dUIsdUJBQXVCbkI7S0FDMUR5TTtJQUNGLEdBQUloTCxVQUFVekIsTUFBTXF2QixlQUFlcnZCO0lBQ25DLE9BQU9BO0dBQ1Q7R0FyR0EsU0FBU2t3QixjQUFlejNCLEdBQUdvSixHQUFLLE9BQU9wSixLQUFLb0osR0FBSTtHQU1oRCxTQUFTc3VCLHNCQUF1QjEzQixHQUFHSCxHQUFLLE9BQU9HLGFBQWFILEdBQUc7R0FNL0QsU0FBUzgzQix1QkFBd0IzM0IsR0FBR0gsR0FBSyxPQUFPRyxjQUFjSCxHQUFHO0dBSGpFLFNBQVMrM0IsZ0NBQWlDNTNCLEdBQUdILEdBQUssT0FBT0csdUJBQXVCSDtHQUFHO0dBekJuRixTQUFTZzRCLGVBQWdCNzNCLEdBQUdvSixHQUFLLE9BQU9wSixNQUFNb0osR0FBRztHQThDakQsU0FBUzB1QixvQkFBcUI5M0IsR0FBSyxPQUFPQSxZQUFhO0dBM0J2RCxTQUFTKzNCLGVBQWdCLzNCLEdBQUdvSixHQUFLLE9BQU9wSixNQUFNb0osR0FBRztHYXRMakQsU0FBUzR1QixtQkFBb0JuNEI7SUFDM0I7S0FBSTBDLElBQUk0MEIseUJBQTBCdDNCO0tBQzlCTCxJQUFJK0M7S0FBTXlHLE9BQU96RztLQUFNNjBCLE9BQU83MEI7S0FDOUI5QyxNQUFNZ0ssc0JBQXNCNUo7S0FDNUIyM0I7S0FDQTEwQixJQUFLdEQsSUFBSUMsTUFBS2lLLHVCQUF1QjdKLEdBQUdMO0tBQ3hDZ0UsSUFBSTZ6QixpQkFBaUJ2MEI7SUFDekIsR0FBSVUsU0FBU0EsS0FBSzR6QixNQUFNcGpCO0lBQ2hCLElBQUp6TSxNQUFNL0Q7SUFDVixJQUFLaEUsS0FBSUEsSUFBRUMsS0FBSUQsSUFBSztLQUNsQnNELElBQUk0Ryx1QkFBdUI3SixHQUFHTDtLQUM5QixHQUFJc0QsU0FBUztLQUNiVSxJQUFJNnpCLGlCQUFpQnYwQjtLQUNyQixHQUFJVSxTQUFTQSxLQUFLNHpCLE1BQU07S0FDeEI3dkIsTUFBTTZ2QixPQUFPN3ZCLE1BQU0vRDtLQUNuQixHQUFJK0QsTUFBTWl3QixXQUFXeGpCOztJQUV2QixHQUFJeFUsS0FBS0MsS0FBS3VVO0lBSWR6TSxNQUFNeUIsT0FBT3pCO0lBQ2IsR0FBSzZ2QixlQUFpQjd2QixZQUFZQSxLQUVoQ3lNO0lBQ0YsT0FBT3pNO0dBQ1Q7R2pCeUJBLFNBQVMwd0IsYUFDUCxTQUNGO0dIdUVBLFNBQVNDLGtCQUFrQnAxQixHQUFLLFVBQVNBLFVBQVVBLFNBQVU7R0cyRDdELFNBQVNxMUIsYUFBYXo0QixHQUFHOEssR0FBR3ZHO0lBQVEsT0FBT3ZFLFFBQVE4SyxHQUFHd1EsbUJBQW1CL1c7R0FBUTtHQXpOakYsU0FBU20wQixlQUFlNXRCLEdBQUU5SyxHQUFLLE9BQU84SyxFQUFFOUssSUFBSSxTQUFRO0dBMFhwRCxTQUFTMjRCLGVBQWdCcjRCLEdBQUdvSixHQUFLLFVBQVNwSixLQUFLb0osR0FBSTtHMkJ2VW5ELFNBQVNrdkIsMkJBQTJCMXpCO0lBQ2xDLEdBQUdBLGNBQWMsT0FBU0E7SUFDMUIsT0FBT2hGO0dBQ1Q7RzNCaUdBLFNBQVMyNEIsa0NBQWtDM3pCO0lBQ3pDLEdBQUdBLGNBQWMsV0FBYUE7SUFDOUI7R0FDRjtHQXVPQSxTQUFTNHpCLG9CQUFxQjM0QixHQUFJLE9BQU80NEIsS0FBS2ptQix3QkFBd0IzUyxJQUFJO0dBSTFFLFNBQVM2NEIsYUFBYTc0QjtJQUNwQndJO0lBQ0EsT0FBT293QixLQUFLam1CLHdCQUF3QjNTO0dBQUk7R0F4TzFDLFNBQVM4NEIsa0JBQWtCMzRCLEdBQUssV0FBU0EsRUFBRztHQU01QyxTQUFTNDRCLG1CQUFtQjU0QixHQUFLLE9BQU9BLEVBQUc7R1I0cUIzQyxTQUFTNjRCLG9CQUFvQmg1QixHQUMzQixPQUFPMlMsd0JBQXdCM1MsR0FDakM7R1F2bkJBLFNBQVNpNUIsaUJBQWlCcDVCLEdBQUdIO0lBQzNCLE9BQVFBOztPQUNBLE9BQU9HOztPQUNQLE9BQU9BLEVBQUdIOztPQUNWLE9BQU9HLEVBQUdILE1BQUtBOztPQUNmLE9BQU9HLEVBQUdILE1BQUtBLE1BQUtBOztPQUNwQixPQUFPRyxFQUFHSCxNQUFLQSxNQUFLQSxNQUFLQTs7T0FDekIsT0FBT0csRUFBR0gsTUFBS0EsTUFBS0EsTUFBS0EsTUFBS0E7O09BQzlCLE9BQU9HLEVBQUdILE1BQUtBLE1BQUtBLE1BQUtBLE1BQUtBLE1BQUtBOztPQUNuQyxPQUFPRyxFQUFHSCxNQUFLQSxNQUFLQSxNQUFLQSxNQUFLQSxNQUFLQSxNQUFLQTs7SUFFaEQsT0FBT0csUUFBUUUsTUFBTW9iLG1CQUFtQnpiO0dBQzFDO0dBcUlBLFNBQVN3NUIsdUJBQXVCcjVCLEdBQzlCLE9BQVFBLFdBQVVBLE1BQUtBLE1BQU1BLFNBQy9CO0dBalhBLFNBQVNzNUIsWUFBWXh1QixHQUFFOUssR0FBSyxPQUFPOEssRUFBRTlLLEdBQUk7RzJCNEJ6QyxTQUFTdTVCO0lBQ1A7S0FBSW4yQixJQUFJdUY7S0FDSk47Ozs7Ozs7Ozs7Ozs7OztJQUVKLFNBQVNySSxJQUFNO0lBQ2YsSUFBVyxJQUFGRixPQUFPQSxJQUFJdUksVUFBVXZJLEtBQUssS0FBS3NELEVBQUVpRixFQUFFdkksS0FBS3NELEVBQUVpRixFQUFFdkksTUFBSUU7SUFDekQsT0FBT29EO0dBQ1Q7R0F2QkEsU0FBU28yQixzQkFBc0JyNUI7SUFDbEIsSUFBUHM1QjtJQUNKLEdBQUd0NUIsUUFBUXM1QixRQUNYO0tBQ0UsSUFBSXpKLEtBQUswSixPQUFPenBCO0tBQ2hCeXBCLGlCQUFnQnY1QjtLQUNoQjZ2QixNQUFLMEosb0JBQW9CQTtLQUN6QkEsT0FBS3g1QjtLQUNMLE9BQU84dkI7OztLQUdQMWIsa0NBQWtDblU7R0FFdEM7R0F2Qm9CLElBQWhCdzVCO0dBQ0osU0FBU0Msb0JBQXFCejVCO0lBQzVCLEtBQUt3NUIseUJBQXlCeDVCLElBQUksT0FBT0E7SUFDekMsT0FBT0EsVUFBVXc1QjtjQUNOQTthQUNBQTtHQUNiO0czQkhBLFNBQVNFLG1CQUFtQi91QixHQUFFMUgsR0FBSyxPQUFRMEgsYUFBYTFILFVBQVk7R0F5T3BFLFNBQVMwMkIsa0JBQWtCaHZCLEdBQUc5SyxHQUFHdUU7SUFDL0IsT0FBT3VHLEVBQUVnSSx3QkFBd0I5UyxVQUFVOEssR0FBR3dRLG1CQUFtQi9XO0dBQ25FO0dBR0EsU0FBU3cxQixZQUFZMzJCLEdBQUd2RDtJQUN0QixPQUFRQTs7T0FDQSxXQUFXdUQ7O09BQ1gsV0FBV0EsRUFBR3ZEOztPQUNkLFdBQVd1RCxFQUFHdkQsTUFBS0E7O09BQ25CLFdBQVd1RCxFQUFHdkQsTUFBS0EsTUFBS0E7O09BQ3hCLFdBQVd1RCxFQUFHdkQsTUFBS0EsTUFBS0EsTUFBS0E7O09BQzdCLFdBQVd1RCxFQUFHdkQsTUFBS0EsTUFBS0EsTUFBS0EsTUFBS0E7O09BQ2xDLFdBQVd1RCxFQUFHdkQsTUFBS0EsTUFBS0EsTUFBS0EsTUFBS0EsTUFBS0E7O09BQ3ZDLFdBQVd1RCxFQUFHdkQsTUFBS0EsTUFBS0EsTUFBS0EsTUFBS0EsTUFBS0EsTUFBS0E7O0lBRXBELFNBQVNtNkIsSUFBTSxPQUFPNTJCLFFBQVF2QyxNQUFNeWEsbUJBQW1CemIsSUFBSztJQUM1RG02QixjQUFjNTJCO0lBQ2QsV0FBVzQyQjtHQUNiO0dBa0pBLFNBQVNDLGVBQWdCcDZCO0lBQ2pCLElBQUZpTDtJQUNKLElBQVcsSUFBRmhMLE9BQU9BLElBQUlELFVBQVVDLElBQUs7S0FDM0IsSUFBRmtaLElBQUluWixFQUFFQztLQUNWZ0wsRUFBRWdJLHdCQUF3QmtHLFNBQVNBOztJQUVyQyxPQUFPbE87R0FDVDtHMkJoYUEsU0FBU292QjtJQUNBO0tBQUhDO09BQ0N0MUIsd0JBQXNCQTtVQUN0QkE7O0lBQ0wsT0FBT3MxQiw2QkFBNEJBO0dBQ3JDO0czQkpBLFNBQVNDLGtCQUFtQnA2QixHQUFLLE9BQU9zakIsY0FBY3RqQixRQUFTO0dBRy9ELFNBQVNxNkIsWUFBWXZ2QixHQUFFOUssR0FBRXVELEdBQUt1SCxFQUFFOUssS0FBR3VELEdBQUUsU0FBUTtHQWlZN0MsU0FBUysyQixzQkFBdUJoNkIsR0FBR29KLEdBQUssVUFBU3BKLE1BQU1vSixHQUFJO0dBNU0zRCxTQUFTNndCLGlCQUFpQjE2QjtJQUN4QixJQUFJRSxNQUFNRixVQUNOcUQsUUFBUW5DLE1BQU1oQjtJQUNsQm1EO0lBQ0EsSUFBUyxJQUFEcEQsT0FBSUEsSUFBRUMsS0FBSUQsS0FBS29ELEVBQUVwRCxTQUFPRCxFQUFFQztJQUNsQyxPQUFPb0Q7R0FDVDtHQXRCQSxTQUFTczNCLGdCQUFnQmw2QixHQUFLLFNBQVFBLEVBQUc7R1J3cUJ6QyxTQUFTbTZCLHVCQUF1QnQ2QixHQUFLLE9BQU9FLHVCQUF1QkYsR0FBRztHUWxxQnRFLFNBQVN1NkIsaUJBQWlCcDZCLEdBQUssT0FBT0EsRUFBRztHQUd6QyxTQUFTcTZCLGlCQUFpQnI2QixHQUFLLE9BQU9BLE1BQUs7R1JtckIzQyxTQUFTczZCLGtCQUFtQno2QixHQUMxQixPQUFPNEQsd0JBQXdCNUQsR0FDakM7R1F6MUJBLFNBQVMwNkIsZUFBZS92QixHQUFLLGNBQWNBLEVBQUc7R0F3TTlDLFNBQVNnd0IsWUFBWXg2QjtJQUNiLElBQUZBLElBQUl3Uyx3QkFBd0J4UztJQUVoQyxLQUFJQTtLQUNGcUk7MEJBQWtDckk7O0lBR3BDLE9BQU95NEIsS0FBS3o0QjtHQUNkO0dBNkRBLFNBQVN5NkIsc0JBQXNCLzZCO0lBQzdCO0tBQ1UsSUFBSkQsTUFBTXdZO0tBQ1YsR0FBR3hZLFFBQVE7TUFDQSxJQUFMd0UsV0FBV3hELE1BQU1oQjtNQUNyQixJQUFXLElBQUZELE9BQU9BLElBQUlDLEtBQUtELEtBQUt5RSxLQUFLekUsS0FBS3lZLFVBQVV6WTs7O01BRWxEeUUsUUFBUU87S0FFRixJQUFKK0MsTUFBTXliLGNBQWN0akIsR0FBR3VFO0tBQzNCLE9BQVFzRCxlQUFlbXpCLFdBQVVELHNCQUFzQmx6QixPQUFLQSxJQVR2RDtHQVdUO0dBSUEsU0FBU296QixnQ0FBZ0NqN0I7SUFDdkM7S0FDRSxJQUFJRCxNQUFNd1ksa0JBQ05oVSxXQUFXeEQsTUFBTWhCO0tBQ3JCLElBQVcsSUFBRkQsT0FBT0EsSUFBSUMsS0FBS0QsS0FBS3lFLEtBQUt6RSxLQUFLeVksVUFBVXpZO0tBQ2xELE9BQU93akIsY0FBY3RqQixJQUFJdUUsT0FKcEI7R0FNVDtHQUdBLFNBQVMyMkIsNkJBQTZCQyxPQUFPbjdCO0lBQzNDO0tBQ0U7TUFBSTRDLElBQUkyVjtNQUNKaFUsV0FBV3hELE1BQU1vNkI7TUFDakJwN0IsTUFBTUssU0FBU21ZLGtCQUFrQjRpQjtLQUNyQyxJQUFXLElBQUZyN0IsT0FBT0EsSUFBSUMsS0FBS0QsS0FBS3lFLEtBQUt6RSxLQUFLeVksVUFBVXpZO0tBQ2xELE9BQU93akIsY0FBY3RqQixHQUFHdUUsTUFMbkI7R0FPVDtHQUdBLFNBQVM2MkIsNkJBQTZCcDdCO0lBQ3BDO0tBQ0UsSUFBSUQsTUFBTXM1Qix1QkFBdUJyNUIsSUFDN0J1RSxXQUFXeEQsTUFBTWhCO0tBQ3JCLElBQVcsSUFBRkQsT0FBT0EsSUFBSUMsS0FBS0QsS0FBS3lFLEtBQUt6RSxLQUFLeVksVUFBVXpZO0tBQ2xELE9BQU93akIsY0FBY3RqQixHQUFHdUUsTUFKbkI7R0FLVDtHQUdBLFNBQVM4MkIsMkJBQTJCcjdCO0lBQ2xDO0tBQ0UsSUFBSUQsTUFBTXdZLGtCQUNOaFUsV0FBV3hELE1BQU1oQjtLQUNyQndFLFVBQVUxRDtLQUNWLElBQVcsSUFBRmYsT0FBT0EsSUFBSUMsS0FBS0QsS0FBS3lFLEtBQUt6RSxTQUFPeVksVUFBVXpZO0tBQzVDLElBQUorSCxNQUFNeWIsY0FBY3RqQixHQUFFdUU7S0FDMUIsT0FBUXNELGVBQWVtekIsV0FBVUQsc0JBQXNCbHpCLE9BQUtBLElBTnZEO0dBUVQ7R0FHQSxTQUFTeXpCLHFDQUFxQ3Q3QjtJQUM1QztLQUNFLElBQUlELE1BQU13WSxrQkFDTmhVLFdBQVd4RCxNQUFNaEI7S0FDckIsSUFBVyxJQUFGRCxPQUFPQSxJQUFJQyxLQUFLRCxLQUFLeUUsS0FBS3pFLEtBQUt5WSxVQUFVelk7S0FDbEQsT0FBT3dqQixjQUFjdGpCLElBQUdhLE1BQUswRCxPQUp4QjtHQU1UO0dBR0EsU0FBU2czQixrQ0FBa0NKLE9BQU9uN0I7SUFDaEQ7S0FDRSxJQUFJdUUsV0FBV3hELE1BQU1vNkIsWUFDakJwN0IsTUFBTUssU0FBU21ZLGtCQUFrQjRpQjtLQUNyQzUyQixVQUFVMUQ7S0FDVixJQUFXLElBQUZmLE9BQU9BLElBQUlDLEtBQUtELEtBQUt5RSxLQUFLekUsU0FBT3lZLFVBQVV6WTtLQUNwRCxPQUFPd2pCLGNBQWN0akIsR0FBR3VFLE1BTG5CO0dBT1Q7R0FHQSxTQUFTaTNCLGtDQUFrQ3g3QjtJQUN6QztLQUNFLElBQUlELE1BQU1zNUIsdUJBQXVCcjVCLFFBQzdCdUUsV0FBV3hELE1BQU1oQjtLQUNyQndFLFVBQVUxRDtLQUNWLElBQVcsSUFBRmYsT0FBT0EsSUFBSUMsS0FBS0QsS0FBS3lFLEtBQUt6RSxTQUFPeVksVUFBVXpZO0tBQ3BELE9BQU93akIsY0FBY3RqQixHQUFHdUUsTUFMbkI7R0FNVDtHQTFRQSxTQUFTazNCLHdCQUF3QmpWLE1BQy9CLFNBQ0Y7R0FQQSxTQUFTa1YsOEJBQThCbFYsTUFDckMsU0FDRjtHYWJBLFNBQVNtVix1QkFBd0JwNEIsR0FBSyxhQUFhQSxHQUFJO0dBekV2RCxTQUFTcTRCLGFBQWN0N0I7SUFDckIsR0FBS0EsYUFBYVMsU0FBVVQsUUFBU0E7S0FDbkMsT0FBT0E7WUFDQWdGLGlCQUFpQmhGO0tBQ3hCO1lBQ09pRixrQkFBa0JqRjtLQUN6QjtZQUNRQSxhQUFhMDZCLG1CQUFvQjE2QjtLQUN6QztZQUNPQSxLQUFLQSxlQUNaLGlCQUVBO0dBQ0o7R0F1SkEsU0FBU3U3QixzQkFBc0Ivd0I7SUFDN0IsT0FBUTh3QixhQUFhOXdCLFlBQVdBLE9BQUtBO0dBQ3ZDO0dBbkNBLFNBQVNneEIsb0JBQW9CNTRCLEdBQUU0SCxHQUFFbEk7SUFDN0IsR0FBR00sUUFBTTRILEVBQUcsQ0FBRTVILE9BQU9OLEdBQUc7SUFDeEI7R0FDSjtHQXVCQSxTQUFTbTVCLHdCQUF3Qmp4QjtJQUMvQmd4QixvQkFBb0JoeEI7SUFDcEI7R0FDRjtHQXRCQSxTQUFTa3hCLDRCQUE0Qmx4QjtJQUNuQyxPQUFLQSxhQUFhL0osU0FBVStKLFFBQVNBO2VBQ2pDZ3hCLG9CQUFvQmh4Qjs7O0dBSzFCO0dBSUUsU0FBU214Qiw0QkFBNEJueEI7SUFDckNneEIsb0JBQW9CaHhCO0lBQ3BCO0dBQ0Y7R0RpQkEsU0FBU294QixpQkFBa0I1N0IsR0FBRTRiO0lBQzNCQTtJQUNBLEdBQUlBLFdBQVk7S0FDZEE7S0FDQTViLEtBQUtGO0tBQ0wsR0FBSThiLFdBQVksQ0FDZEEsYUFDQTViLEtBQUtGOztJQUdULEdBQUk4YixhQUFhLENBQ2ZBLGFBQ0E1YixLQUFLRjtJQUVQRSxLQUFLRixZQUFZOGI7SUFDakIsT0FBTzViO0dBQ1Q7R1FvQ0EsU0FBUzY3QixlQUFnQjc3QixHQUFHb0o7SUFBSyxVQUFTd2IsaUJBQWlCNWtCLEdBQUVvSjtHQUFnQjtHQUc3RSxTQUFTMHlCLGNBQWU5N0IsR0FBR29KLEdBQUssVUFBU3diLGlCQUFpQjVrQixHQUFFb0osZUFBZTtHUWpQM0UsU0FBUzJ5QixlQUFlbDhCO0lBQ3RCQSxJQUFJd0YsdUJBQXVCeEY7SUFDM0IsSUFBSTJDLElBQUkzQyxjQUNKTixRQUFRa0IsTUFBTStCO0lBQ2xCLElBQVcsSUFBRmhELE9BQU9BLElBQUlnRCxHQUFHaEQ7S0FDckJELEVBQUVDLE1BQU1LLGlCQUFpQkwsS0FBTUssaUJBQWlCTDtJQUNsRCxPQUFPRDtHQUNUO0dBSUEsU0FBU3k4QixnQkFBZ0JDLEtBQUtDLGFBQWFDO0lBQ3pDO0tBQUlDO0tBQ0FDO0tBQ0FDO0tBQ0FDO0tBQ0FDO0tBQ0FDO0tBQ0FDO0tBQ0FDO0tBQ0FDO0tBQ0FDO0tBQ0FDO0tBQ0FDO0lBRUosS0FBS2QsZ0JBQWlCO0tBQ3BCQSxlQUFrQkYsZUFBZ0JFLElBQUlVO0tBQ3RDVixrQkFBa0JGLGVBQWdCRSxJQUFJVztLQUN0Q1gsZ0JBQWtCRixlQUFnQkUsSUFBSWM7S0FDdENkLGdCQUFrQkYsZUFBZ0JFLElBQUlhO0tBQ3RDYixrQkFBa0JGLGVBQWdCRSxJQUFJWTs7SUFHeEM7S0FBSS81QjtLQUFHMEssUUFBUTB1QjtLQUVYdndCLFNBQVM1RiwwQkFBMEJvMkIsT0FBT0M7SUFFOUMsR0FBSTV1QixXQUFZO0tBRWQydUIsT0FBT0ssZ0JBQWdCTCxPQUFPRyxpQkFBaUJILE9BQU9JO0tBQ3RESixPQUFPTTs7O0tBR1BqdkIsVUFBU0E7SUFFWCxPQUFRO0tBRUcsSUFBTDRwQixPQUFPNkUsYUFBYXp1QjtLQUN4QixHQUFJNHBCLFVBQVUsU0FBUUE7S0FFVixJQUFSNEYsVUFBVWYsZ0JBQWdCenVCO0tBQzlCLEdBQUl3dkIsYUFBYztNQUNoQmIsT0FBT0ssZ0JBQWdCTCxPQUFPSTtNQUM5QkosT0FBT00sbUJBQW1CTzs7S0FHNUIsR0FBSWIsT0FBT0ksaUJBQWlCSixPQUFPRTtNQUFnQixHQUM3Q0YsT0FBT08sdUJBQ1QsU0FBUWx2QixnQkFFUjFLO1NBQ0MsQ0FFSEEsSUFBSTZJLE9BQU93d0IsT0FBT0ksZ0JBQ2xCSixPQUFPSTtLQUdULEdBQUlOLGNBQWM3RSxPQUFPdDBCLE1BQU0wSztNQUM3QkEsUUFBUXl1QixjQUFjN0UsT0FBT3QwQjs7TUFFN0IwSyxRQUFReXVCLGdCQUFnQnp1QjtLQUUxQixHQUFJQSxVQUFXO01BQ2IydUIsT0FBT0ksZ0JBQWdCSixPQUFPSztNQUM5QixHQUFJTCxPQUFPTTtPQUNUem9COztPQUVBLE9BQU9tb0IsT0FBT007O2FBS1ozNUIsVUFBVXE1QixPQUFPTzs7R0FHM0I7RzFCVUEsU0FBU087SUFDRSxJQUFMQztJQUNKLElBQVUsSUFBRjE5QixPQUFPQSxJQUFJMFUseUJBQXlCMVUsSUFBSTtLQUN0QyxJQUFKa0gsTUFBTXcyQjtLQUNWQSxXQUFXbjlCLHVCQUF1Qm1VLGlCQUFpQjFVLFVBQVVrSDs7SUFFL0QsT0FBT3cyQjtHQUNUO0dGK0ZBLFNBQVNDLHNCQUFzQjU5QjtJQUN2QixJQUFGaUQ7SUFDSixJQUFTLElBQURoRCxJQUFFRCxjQUFjQyxRQUFNQSxJQUFJLENBQzFCLElBQUZxUCxJQUFJdFAsRUFBRUMsSUFDVmdELFFBQU9xTSxHQUFFck07SUFFWCxPQUFPQTtHQUNUO0dBR0EsU0FBUzQ2QixzQkFBc0I1NkI7SUFDdkIsSUFBRmpEO0lBQ0osTUFBTWlELFNBQVNBLElBQUlBLE1BQ2pCakQsT0FBT2lEO0lBRVQsT0FBT2pEO0dBQ1Q7R1k0Q0EsU0FBUzg5QixpQkFBa0JyOUIsR0FBSyxPQUFPRixXQUFXRSxHQUFJO0dBTnRELFNBQVNzOUIsaUJBQWlCdDlCLEdBQUssT0FBT0YsV0FBV0UsR0FBSTtHQUVyRCxTQUFTdTlCLGdCQUFnQnY5QixHQUFLLE9BQU9GLFVBQVVFLEdBQUk7R3BCMmxCbkQsU0FBU3c5QixnQkFBaUIzOUIsR0FBSyxPQUFPRSx1QkFBdUJGLEdBQUc7R3FDLzFCaEUsU0FBUzQ5QixjQUFjeDZCO0lBQ3JCLFNBQVN5NkIsUUFBUTE5QixHQUFHOGIsR0FDbEIsT0FBTzRiLHNCQUFzQjEzQixHQUFFOGIsR0FDakM7SUFDQSxTQUFTNmhCLFFBQVEzOUIsR0FBRzhiLEdBQ2xCLE9BQU84YixnQ0FBZ0M1M0IsR0FBRThiLEdBQzNDO0lBQ0EsU0FBUzhoQixHQUFHcitCLEdBQUdxRCxHQUNiLE9BQU82MEIsY0FBY2w0QixHQUFFcUQsR0FDekI7SUFDQSxTQUFTaTdCLElBQUl0K0IsR0FBR3FELEdBQ2QsT0FBT20xQixlQUFleDRCLEdBQUVxRCxHQUMxQjtJQUNBLFNBQVM0VCxJQUFJalgsR0FBR3FELEdBQ2QsT0FBT3d6QixlQUFlNzJCLEdBQUVxRCxHQUMxQjtJQUNBLFNBQVNpZCxJQUFJdGdCLEdBQUdxRCxHQUNkLE9BQU9xMEIsZUFBZTEzQixHQUFFcUQsR0FDMUI7SUFDQSxTQUFTazdCLEtBQUs5OUIsR0FBRzhiLEdBQ2YsT0FBTzhoQixHQUFHRixRQUFRMTlCLEdBQUU4YixJQUFHNmhCLFFBQVMzOUIsUUFBUThiLElBQzFDO0lBQ0EsU0FBUzBWLElBQUlqeUIsR0FBR0MsR0FDZCxPQUFPVSxjQUFjWCxHQUFHQyxHQUMxQjtJQUNBLFNBQVN1K0IsSUFBSXgrQixHQUFHQyxHQUFHUSxHQUNqQixPQUFPbWYsY0FBYzVmLEdBQUdDLEdBQUdRLEdBQzdCO0lBQ0E7S0FBSWcrQixJQUFJMUcscUJBQXFCa0c7S0FDekJTLE9BQU8zRyxxQkFBcUJrRztLQUM1Qi9WO0tBQUd5VztLQUFJQztLQUNQQyxLQUFLbjdCO0tBQ0wxRCxJQUFJaXlCLElBQUk0TTtLQUNSditCLElBQUkyeEIsSUFBSTRNO0tBQ1JDLEtBQUs3TSxJQUFJNE07S0FDVEUsS0FBSzlNLElBQUk0TTtJQUViM1csSUFBSWpSLElBQUkzVyxHQUFHdytCO0lBRVg1VyxJQUFJNUgsSUFBSWdlLElBQUlwVyxHQUFFa1csUUFBUWxXLFNBQVF3VztJQUM5QnhXLElBQUk1SCxJQUFJZ2UsSUFBSXBXLEdBQUVrVyxRQUFRbFcsU0FBUXdXO0lBQzlCeFcsSUFBSW9XLElBQUlwVyxHQUFFa1csUUFBUWxXO0lBRWxCc1csSUFBSUssT0FBTzVuQixJQUFLcUosSUFBSWhnQixHQUFFbStCLElBQUl6K0I7SUFFMUIsSUFBSTIrQixLQUFLRyxJQUNMRixLQUFLRztJQUNUSCxLQUFLTixJQUFJTSxJQUFHRDtJQUNaQSxLQUFLSixLQUFLSTtJQUNWQSxLQUFLTCxJQUFJQSxJQUFJSyxJQUFJQyxLQUFNVCxRQUFRUztJQUMvQkEsS0FBS0wsS0FBS0s7SUFDVkosSUFBSUssT0FBT0Y7SUFDWEgsSUFBSUssT0FBT0Q7SUFFWCxPQUFPMVc7R0FDVDtHZGdEQSxTQUFTOFcscUJBQXFCOStCO0lBQzVCLEdBQUlBLFNBQVM0TDtJQUNiLElBQUk1TCxNQUFNQSxhQUNObUQsUUFBUW5DLE1BQU1oQjtJQUNsQm1EO0lBQ0EsSUFBVyxJQUFGcEQsT0FBT0EsSUFBSUMsS0FBS0QsS0FBS29ELEVBQUVwRDtJQUNoQyxPQUFPb0Q7R0FDVDtHQWxCQSxTQUFTNDdCLGVBQWdCLytCLEtBQUtnL0I7SUFDNUIsR0FBSWgvQixTQUFTNEw7SUFDYixJQUFJNUwsTUFBTUEsYUFDTm1ELFFBQVFuQyxNQUFNaEI7SUFDbEJtRDtJQUNBLElBQVcsSUFBRnBELE9BQU9BLElBQUlDLEtBQUtELEtBQUtvRCxFQUFFcEQsS0FBS2kvQjtJQUNyQyxPQUFPNzdCO0dBQ1Q7R3JCM0YyQjtJQUF2Qjg3Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0cyS0osU0FBU0MsdUJBQXVCelksTUFBUSxTQUFTO0djc0JqRCxTQUFTMFksZUFBZS8rQixHQUFHK0wsS0FBS25NO0lBQzlCLElBQUl1WCxNQUFNRSxnQkFDTjNYLElBQUl3RywwQkFBMEJsRztJQUNsQzBYLGVBQWVQLEtBQUl6WCxXQUFXcU0sS0FBS0EsTUFBTW5NLE1BQU1BO0lBQy9DLE9BQU9RLHFCQUFxQjhXLGNBQWNDO0dBQzVDO0dRNEZBLFNBQVM2bkIsb0JBQXFCdmIsUUFBUW5qQixJQUFJWCxHQUFHZ0Q7SUFDM0M7S0FBSStnQixPQUFPSixvQkFBb0JHO0tBQzNCaGhCLElBQUlFO0tBQ0pzOEIsUUFBUXZiLGtCQUFrQkE7SUFDOUIsR0FBRy9nQixLQUFLczhCLE1BQU87S0FDYjMrQixPQUFPb2pCLHFCQUFxQkEsa0JBQWlCQSxtQkFBbUIvZ0IsSUFBSWhEO0tBQ3BFK2pCLG9CQUFvQi9nQjs7WUFFZHM4QixVQUFXO0tBQ2pCMytCO09BQU9vakIscUJBQXFCQSxrQkFBaUJBLG1CQUFtQnViLFFBQVF0L0I7S0FDeEUrakIsb0JBQW9CdWI7S0FDcEJ4OEIsSUFBSXc4Qjs7UUFDQztLQUNMdmI7S0FDQUE7S0FDQThRLFlBQVk5UTtLQUNGLElBQU51YixRQUFRdmIsa0JBQWtCQTtLQUM5QixHQUFHamhCLElBQUl3OEIsT0FBT3g4QixJQUFJdzhCO0tBQ2xCMytCLE9BQU9vakIscUJBQXFCQSxrQkFBaUJBLG1CQUFtQmpoQixJQUFJOUM7S0FDcEUrakIsb0JBQW9CamhCOztJQUV0QixPQUFPQTtHQUNUO0dSclRBLFNBQVN5OEIsY0FBY3piLFFBQU8wYjtJQUM1QixJQUFJaG9CLE1BQU1FLGdCQUNOdkwsYUFBYXhHO0lBQ2pCLEdBQUc2NUI7S0FBVyxXQUNEO01BQ0EsSUFBTDcwQixPQUFPMDBCLG9CQUFvQnZiLFFBQU8zWCxXQUFTQTtNQUMvQyxHQUFHeEIsV0FBVztNQUNkb04sZUFBZVAsS0FBSXJMLG1CQUFtQnhCLE9BQU9BOzs7S0FFMUMsTUFDQzYwQixXQUFZO01BQ1A7T0FBTDcwQjtTQUFPMDBCO1dBQW9CdmIsUUFBTzNYLFdBQVdxekIsU0FBU3J6QixnQkFBZ0JBLGdCQUFnQnF6QjtNQUMxRixHQUFHNzBCLFdBQVdxcUI7TUFDZGpkLGVBQWVQLEtBQUlyTCxtQkFBbUJ4QixPQUFPQTtNQUM3QzYwQixVQUFVNzBCOztJQUdkLE9BQU9sSyxxQkFBcUI4VyxjQUFjQztHQUM1QztHQUlBLFNBQVNpb0IsZ0JBQWdCcC9CLEdBQUcrTCxLQUFLbk07SUFDL0IsT0FBT20vQixlQUFldDVCLHFCQUFxQnpGLElBQUcrTCxLQUFJbk07R0FDcEQ7R2FxQ0EsU0FBU3kvQixxQkFBcUJyOEIsR0FBSyxTQUFTO0dBaEM1QyxTQUFTczhCLGlCQUFpQm5TLFVBQ3hCLFNBQ0Y7R0FvQkEsU0FBU29TLG1CQUFtQkMsTUFBS0MsWUFBV0MsU0FDMUMsU0FDRjtHQUdBLFNBQVNDLGtCQUFrQnRaLE1BQ3pCLFNBQ0Y7R0xxQkEsU0FBU3VaLHlCQUEwQkMsVUFBVUM7SUFDM0M7S0FBSUMsYUFBYXpjLG9CQUFvQnVjO0tBQ2pDRyxPQUFPMWMsb0JBQW9Cd2M7SUFDL0J6YyxpQkFBaUJ3YyxZQUFZRztJQUM3QixPQUFPRDtHQUNUO0dBSUEsU0FBU0Usd0JBQXlCSixVQUFVRSxZQUMxQzFjLGlCQUFpQndjLFlBQVlFLFlBQzdCO0dBQ0Y7R0E2SEEsU0FBU0cscUJBQXFCemM7SUFDbkIsSUFBTEMsT0FBT0osb0JBQW9CRztJQUMvQixPQUFPQztHQUNUO0dBSUEsU0FBU3ljLHdCQUF3QjFjO0lBQ3RCLElBQUxDLE9BQU9KLG9CQUFvQkc7SUFDL0IsT0FBT3ZVLG9CQUFvQndVO0dBQzdCO0dBbk9pQixJQUFiMGMsbUJBQW1CeC9CO0dBSXZCLFNBQVN5L0IsZUFBZTkzQjtJQUNiLElBQUxsQixPQUFPKzRCLGFBQWE3M0I7SUFDeEIsR0FBR2xCLE1BQU1BO0lBQ1QsT0FBTys0QixhQUFhNzNCO0lBQ3BCO0dBQ0Y7R0F5Y0EsU0FBUyszQixjQUFlN2M7SUFDYixJQUFMQyxPQUFPSixvQkFBb0JHO0lBQy9CLEtBQUtDLGFBQWE1ZDtJQUNsQixLQUFJNGQsZUFBZUEsdUJBQXVCO0lBQzFDLEdBQUdBO0tBQ0RBLFlBQVlqa0IseUJBQXlCaWtCLGdCQUFnQkE7O0tBRXJEQSxnQkFBZ0JBLGFBQWFBLGdCQUFnQkE7SUFFL0NBLGVBQWVBO0lBQ2ZBO0lBQ0E7R0FDRjtHQXBSQSxTQUFTNmMsc0JBQXVCOWM7SUFDckIsSUFBTEMsT0FBT0osb0JBQW9CRztJQUMvQixHQUFHQyxZQUFhO0tBQ2RBO0tBQ0EyYyxlQUFlM2M7S0FDZkE7S0FDQUEsa0JBQWtCcGU7S0FDbEJvZTtLQUNBQTs7SUFFRjtHQUNGO0dMMURBLFNBQVM4Yyw0QkFBNEJ4OUIsR0FDakMsU0FDSjtHQVpBLFNBQVN5OUIsc0JBQXNCcGEsTUFDM0Isc0JBQ0o7R0FhQSxTQUFTcWEseUJBQXlCMTlCLEdBQzlCLFNBQ0o7R0FaQSxTQUFTMjlCLHVCQUF1QjM5QixHQUFFNDlCLFFBQzlCLFNBQ0o7R2Z6SUEsU0FBU0MsNEJBQStCLFNBQVU7R2lCb0ZsRCxTQUFTQyx5QkFBeUJ6YSxNQUM5QixTQUNKO0dBUkEsU0FBUzBhLGtCQUFrQjFhLE1BQ3ZCLE9BQU9FLGVBQ1g7R0FsREEsU0FBU3lhLHdCQUF3QkMsT0FDL0IsU0FDRjtHQVRpQyxJQUE3QkM7R0FDSixTQUFTQyw0QkFBNEI5YSxNQUNuQyxPQUFPNmE7R0FDVDtHbEJxUDBCLElBQXRCRTtHQUlKLFNBQVNDLGdDQUFpQ0MsTUFDeENGLHdCQUF3QkUsTUFDeEI7R0FDRjtHcUJwQkEsU0FBU0MsY0FBZTlkLFFBQVExZ0IsR0FBR3BELEdBQUdnRDtJQUM3QixJQUFIckMsS0FBSzRGLDBCQUEwQm5EO0lBQ25DLE9BQU9pOEIsb0JBQW9CdmIsUUFBUW5qQixJQUFJWCxHQUFHZ0Q7R0FDNUM7R0FLQSxTQUFTNitCLHVCQUF3Qi9kLFFBQVExZ0IsR0FBR3BELEdBQUdnRDtJQUN0QyxJQUFIckMsS0FBS3NVLHVCQUF1QjdSO0lBQ2hDLE9BQU9pOEIsb0JBQW9CdmIsUUFBUW5qQixJQUFJWCxHQUFHZ0Q7R0FDNUM7R0E2RUEsU0FBUzgrQixtQkFBb0JoZTtJQUNsQixJQUFMQyxPQUFPSixvQkFBb0JHO0lBQy9CLEdBQUdDLG9CQUFvQkEsZ0JBQWdCO0tBQ3JDQTtLQUNBQTtLQUNBOFEsWUFBWTlROztJQUVkLEdBQUlBLG9CQUFvQkEsaUJBQ3RCaVI7SUFDTSxJQUFKanRCLE1BQU1nYyxZQUFZQTtJQUN0QkE7SUFDQSxPQUFPaGM7R0FDVDtHQUtBLFNBQVNnNkIsa0JBQW1CamU7SUFDMUIsSUFBSUMsT0FBT0osb0JBQW9CRyxTQUMzQi9iO0lBQ0osSUFBVSxJQUFGL0gsT0FBT0EsT0FBT0E7S0FDcEIrSCxPQUFPQSxZQUFZKzVCLG1CQUFtQmhlO0lBRXhDLE9BQU8vYjtHQUNUO0dBc0RBLFNBQVNpNkIsd0JBQXdCbGU7SUFDL0IsSUFBSUMsT0FBT0osb0JBQW9CRyxTQUMzQjVLLElBQUk2SztJQUNSO0tBQUcsR0FDRTdLLEtBQUs2SyxnQkFBaUI7TUFDdkIsR0FBR0EscUJBQXNCO09BQ3ZCQSxnQkFBZ0JBLHFCQUFxQkE7T0FDckM3SyxLQUFLNks7T0FDTEEsbUJBQW1CQTtPQUNuQkE7O01BRUYsR0FBR0EsbUJBQW1CQSxvQkFBb0IsU0FDL0JBO01BRUUsSUFBVGtlLFdBQVdsZTtNQUNmOFEsWUFBYTlRO01BQ2IsR0FBR2tlLFlBQVlsZSxpQkFBaUIsU0FDckJBOzs7TUFHTkEsWUFBWTdLO0lBQ3JCLE9BQVFBLElBQUk2SztHQUNkO0dBOEpBLFNBQVNtZSxvQkFBb0JwZTtJQUMzQixPQUFPSCxvQkFBb0JHO0dBQzdCO0dkcm5CQSxTQUFTcWUsbUJBQW1COStCO0lBQzFCLEdBQUdBO0tBQ0RtUjs7S0FDR25SO0lBQ0w7R0FDRjtHQVhBLFNBQVMrK0Isa0JBQWtCMWIsTUFDekIsV0FBVzVjLFVBQ2I7R0FZQSxTQUFTdTRCLHVCQUF1QmgvQjtJQUM5QixLQUFJQSxTQUFVLENBQ1pBLGlCQUNBO0lBRUY7R0FDRjtHRTBSQSxTQUFTaS9CLHVCQUF1QjE1QixJQUFJakI7SUFDbEMsR0FBR0E7S0FBWTtNQUVYLElBQUlra0IsS0FBS3JoQixlQUNMKzNCLE1BQU0xVyxZQUFZbGtCO01BQ3RCLFdBQVc0QyxTQUFTZzRCLEtBQUs1NkI7O1dBQ25CMEg7SUFFVixXQUFXOUUsU0FBUzNCLElBQUlqQjtHQUMxQjtHWXJSQSxTQUFTNjZCLHVCQUF1Qjk2QixNQUFLZ3RCO0lBQ25DLEdBQUdBLE9BQU8xdkIsV0FDUjB2QixNQUFNK0w7SUFFUkEsYUFBYS9MLE9BQU9odEI7SUFDcEIsT0FBT2d0QjtHQUNUO0dBQ0EsU0FBUytOLGNBQWVwOEIsTUFBTXNCLE9BQU8rNkI7SUFDN0IsSUFBRnhpQztJQUNKLE1BQU15SCxNQUFNO0tBQ1YsT0FBT0E7O1FBQ0N6SCxjQUFhOztRQUNiQSxjQUFhOztRQUNiQSxjQUFhOztRQUNiQSxjQUFhOztRQUNiQSxnQkFBZTs7UUFDZkEsWUFBWTs7UUFDWkEsY0FBYTs7UUFDYkEsWUFBVzs7UUFDWEEsZ0JBQWU7O0tBRXZCeUgsUUFBTUE7O0lBRVIsR0FBR3pILFlBQVlBO0tBQ2JpRztPQUFxQk4sdUJBQXVCUTs7SUFDOUMsR0FBR25HLFVBQVVBO0tBQ1hpRztPQUFxQk4sdUJBQXVCUTs7SUFDOUMsSUFBSXdCLE9BQU84TSxrQkFBa0J0TyxPQUN6QnFCLE9BQU9HLGlCQUFpQkEsV0FBVTNIO0lBQ3RDLE9BQU9zaUMsdUJBQXdCOTZCLE1BQU0xQztHQUN2QztHQUNBLENBQUE7TUFDRSxTQUFTMEMsS0FBS2tCLElBQUlqQjtPQUNoQixPQUFHNEw7aUJBQ00rdUIsdUJBQXVCMTVCLElBQUlqQjtxQkFHdkJnQixhQUFhQyxJQUFJakI7TUFDaEM7TUFDQTY2QjtRQUF1Qjk2Qjs7TUFDdkI4NkI7UUFBdUI5NkI7TUFDdkI4NkI7UUFBdUI5NkI7S0FWeEI7O0dBdUZELFNBQVNpN0IsMkJBQTRCLzVCO0lBQzFCLElBQUxsQixPQUFPKzRCLGFBQWE3M0I7SUFDeEIsR0FBR2xCLG1CQUFtQnZCLDZCQUE0QnlDO0lBQ2xEO0tBQUlnNkIsU0FBU3hpQztLQUNUeWlDO2NBQ0duN0I7Z0JBQ0VBLG9CQUFrQkE7WUFDdEJrQjs7Ozs7b0JBS1FqRDtnQkFDSmk5QjtJQUVUbGYsaUJBQWlCbWYsY0FBWUE7SUFDN0IsT0FBT0E7R0FDVDtHQXZDQSxTQUFTQyw0QkFBNkJsNkI7SUFDM0IsSUFBTGxCLE9BQU8rNEIsYUFBYTczQjtJQUN4QixHQUFHbEIsbUJBQW1CdkIsNkJBQTRCeUM7SUFDbEQ7S0FBSW02QixXQUFZcjdCLHdCQUF3QjFDLFlBQWEwQztLQUNqRG03QjtjQUNHbjdCO2dCQUNFQSxvQkFBa0JBO1lBQ3RCa0I7Ozs7b0JBSVFqRDtrQkFDRm85QjtJQUVYcmYsaUJBQWlCbWYsY0FBWUE7SUFDN0IsT0FBT0E7R0FDVDtHQTlCQSxTQUFTRztJQUNELElBQUZoZ0M7SUFDSixJQUFVLElBQUZNLE9BQU9BLElBQUlvZ0IseUJBQXlCcGdCO0tBQUk7T0FDM0NvZ0IsaUJBQWlCcGdCLE1BQU1vZ0IsaUJBQWlCcGdCO1VBQWFvZ0IsaUJBQWlCcGdCO01BQ3ZFTixRQUFLMGdCLGlCQUFpQnBnQixPQUFNTjtJQUVoQyxPQUFPQTtHQUNUO0dBd1hBLFNBQVNpZ0Msa0JBQWtCbmYsUUFBTzNYLFFBQU9oTCxRQUFPbEI7SUFDckMsSUFBTDhqQixPQUFPSixvQkFBb0JHO0lBQy9CLEtBQUtDO0tBQWE1ZDtJQUNsQmdHLFNBQVNBLGdCQUFnQmhMLFFBQVFBLFNBQVNsQjtJQUMxQyxHQUFHOGpCLG1CQUFtQjVYLGdCQUFnQjRYLG1CQUFvQjtLQUNsRCxJQUFGM2dCLFFBQVF1QyxXQUFXb2UsbUJBQW1CNVg7S0FDMUMvSSxNQUFNMmdCO0tBQ05BLGNBQWMzZ0I7O0lBRWhCLE9BQU8yZ0I7O09BRUxBLGdCQUFnQjVYLFFBQVE0WDtPQUN4QkEsb0JBQW9CNVg7T0FDcEJ3MEIsY0FBZTdjO09BQ2Y7O09BRUFDLGdCQUFnQjVYLFFBQVE0WDtPQUN4QkEsb0JBQW9CNVg7T0FDcEIsR0FBRzRYLG9CQUFvQkEsb0JBQ3JCNGMsY0FBZTdjO09BQ2pCOztPQUVPLElBQUhGLEtBQUt6WDtPQUNULEdBQUd5WCxPQUFRO1FBQ1RHLGdCQUFnQjVYLFFBQVE0WDtRQUN4QkEsb0JBQW9CNVg7UUFDcEIsR0FBRzRYLG9CQUFvQkEsb0JBQ3JCNGMsY0FBZTdjOztXQUVkO1FBQ0hDLGdCQUFnQjVYLG1CQUFtQnlYLFNBQVNHO1FBQzVDQSxvQkFBb0JIO1FBQ3BCK2MsY0FBZTdjO1FBQ2ZDLGdCQUFnQjVYLGdCQUFnQnlYLFNBQVNHO1FBQ3pDQSxvQkFBb0I1WCxnQkFBZ0J5WDs7T0FFdEM7O0lBRUY7R0FDRjtHQUlBLFNBQVNzZixxQkFBcUJwZixRQUFPM1gsUUFBT2hMLFFBQU9sQjtJQUN0QyxJQUFQa00sU0FBUzVGLDBCQUEwQjRGO0lBQ3ZDLE9BQU84MkIsa0JBQWtCbmYsUUFBTzNYLFFBQU9oTCxRQUFPbEI7R0FDaEQ7R0FjQSxTQUFTa2pDLGVBQWVyZixRQUFPM1gsUUFBT2hMLFFBQU9sQjtJQUMzQyxPQUFPaWpDO2FBQXFCcGYsUUFBT2hlLHFCQUFxQnFHLFNBQVFoTCxRQUFPbEI7R0FDekU7R0FYQSxTQUFTbWpDLHdCQUF3QnRmLFFBQU8zWCxRQUFPaEwsUUFBT2xCO0lBQ3pDLElBQVBrTSxTQUFTOEksdUJBQXVCOUk7SUFDcEMsT0FBTzgyQixrQkFBa0JuZixRQUFPM1gsUUFBT2hMLFFBQU9sQjtHQUNoRDtHQWFBLFNBQVNvakMsb0JBQXFCdmYsUUFBT3hnQjtJQUM3QixJQUFGakQsSUFBSUUsdUJBQXVCSixvQkFBb0JtRDtJQUNuRDYvQixlQUFlcmYsUUFBT3pqQjtJQUN0QjtHQUNGO0dBc0RBLFNBQVNpakMsbUJBQW9CeGYsUUFBTzlqQjtJQUNsQztLQUFJZ0IsT0FBUWhCLGdCQUFlQSxnQkFBZUEsZUFBYUE7S0FDbkRLLElBQUlJLHFCQUFxQk87SUFDN0JtaUMsZUFBZXJmLFFBQU96akI7SUFDdEI7R0FDRjtHQXBNQSxTQUFTa2pDLFlBQVl6ZjtJQUNWLElBQUxDLE9BQU9KLG9CQUFvQkc7SUFDL0IsT0FBT0MsZUFBZUEsa0JBQWtCQTtHQUMxQztHQUlBLFNBQVN5ZixlQUFlMWYsUUFDdEIsT0FBT3lmLFlBQVl6ZixRQUNyQjtHQUlBLFNBQVMyZixrQkFBa0IzZjtJQUN6QixPQUFPdlUsb0JBQW9CZzBCLFlBQVl6ZjtHQUN6QztHQTRKQSxTQUFTNGYsYUFBYTVmO0lBQ1gsSUFBTEMsT0FBT0osb0JBQW9CRztJQUMvQixPQUFPQyxjQUFjQTtHQUN2QjtHQUlBLFNBQVM0ZixnQkFBZ0I3ZixRQUN2QixPQUFPNGYsYUFBYTVmLFFBQ3RCO0dBSUEsU0FBUzhmLG1CQUFtQjlmO0lBQzFCLE9BQU92VSxvQkFBcUJtMEIsYUFBYTVmO0dBQzNDO0dFdGxCQSxTQUFTK2YsK0JBQ1AsU0FDRjtHQVVBLFNBQVNDLGdDQUNQLFNBQ0Y7R0FwQkEsU0FBU0MsK0JBQ1AsU0FDRjtHdkJzU0EsU0FBU0MsaUNBQWtDNWlCLE9BQ3pDLE9BQU9xZ0I7R0FDVDtHcUIwRkEsU0FBU3dDLGFBQWFuZ0IsUUFBUTFjO0lBQ25CLElBQUwyYyxPQUFPSixvQkFBb0JHO0lBQy9CLEdBQUlDLGVBQWUzakIsTUFBTStGO0lBQ3pCO01BQUdpQixPQUFPMmMsY0FBY0EsbUJBQ2xCM2MsT0FBTzJjO1NBQ1BBO0tBQ0pBLG1CQUFtQkEsbUJBQW1CQSxjQUFjM2M7UUFDL0MsQ0FDTDJjLGNBQWMzYyxLQUNkMmMsc0JBQ0FBO0lBRUY7R0FDRjtHQUlBLFNBQVNtZ0IsZ0JBQWdCcGdCLFFBQU8xYyxLQUM5QixPQUFPNjhCLGFBQWFuZ0IsUUFBTzFjLEtBQzdCO0dBSUEsU0FBUys4QixtQkFBbUJyZ0IsUUFBTzFjO0lBQ3pCLElBQUpBLE1BQU1reEIsb0JBQW9CbHhCO0lBQzlCLE9BQU82OEIsYUFBYW5nQixRQUFRMWM7R0FDOUI7R0EwSkEsU0FBU2c5QixjQUFjdGdCLFFBQVExYztJQUM3QnU1QixjQUFjN2M7SUFDTCxJQUFMQyxPQUFPSixvQkFBb0JHO0lBQy9CQyxjQUFjM2M7SUFDZDtHQUNGO0dBSUEsU0FBU2k5QixpQkFBaUJ2Z0IsUUFBTzFjLEtBQy9CLE9BQU9nOUIsY0FBY3RnQixRQUFRMWMsS0FDL0I7R0FHQSxTQUFTazlCLG9CQUFvQnhnQixRQUFPMWM7SUFDMUIsSUFBSkEsTUFBTWt4QixvQkFBb0JseEI7SUFDOUIsT0FBT2c5QixjQUFjdGdCLFFBQVExYztHQUMvQjtHQXBaQSxTQUFTbTlCLHdCQUF3QnpnQixRQUFPNWI7SUFDN0IsSUFBTDZiLE9BQU9KLG9CQUFvQkc7SUFDL0JDLHlCQUF3QjdiO0lBQ3hCNmIseUJBQXlCN2I7SUFDekI7R0FDRjtHQXNiQSxTQUFTczhCLHFCQUFxQjFnQixRQUFPcmdCO0lBQ25Da2dCLG9CQUFvQkcsbUJBQW1CcmdCO0lBQ3ZDLEtBQUlBLEdBQUdrOUIsY0FBYzdjO0lBQ3JCO0dBQ0Y7R0FoakJBLFNBQVMyZ0IseUJBQXlCM2dCLFFBQVF6ZDtJQUMvQixJQUFMMGQsT0FBT0osb0JBQW9CRztJQUMvQkMsWUFBWTFkO0lBQ1o7R0FDRjtHQThKQSxTQUFTcStCLDJCQUEyQjVnQixRQUFPNWpCO0lBQ2hDLElBQUw2akIsT0FBT0osb0JBQW9CRztJQUMvQkMsdUJBQXlCMWpCLEdBQUlILEVBQUVHLEdBQWhCO0lBQ2Y7R0FDRjtHQUlBLFNBQVNza0MsMkJBQTJCN2dCLFFBQU81akI7SUFDekN5akIsb0JBQW9CRyxpQkFBaUI1akI7SUFDckM7R0FDRjtHRjlKQSxTQUFTMGtDLFNBQVNwa0MsR0FBRW9KLEdBQ2xCLEdBQUlBLFFBQVFYLDBCQUNaLE9BQU96SSxJQUFFb0osRUFDWDtHTG1GQSxTQUFTaTdCLGdCQUFpQnJrQztJQUN4QixHQUFJd2QsU0FBVXhkLEdBQUk7S0FDUixJQUFKZ3NCLFVBQVNoc0I7S0FDYkEsSUFBSUYsU0FBU0U7S0FDYixJQUFJUixJQUFJTSxXQUFZRSxJQUNoQk4sSUFBSU0sSUFBSVI7S0FDWixHQUFJd3NCLElBQUssQ0FBRXhzQixNQUFLQSxHQUFHRSxNQUFLQTtLQUN4QixXQUFXQSxHQUFHRjs7SUFFaEIsR0FBSWllLE1BQU96ZCxJQUFJLFdBQVdrTSxLQUFLQTtJQUMvQixlQUFhbE0sR0FBR0E7R0FDbEI7R1ZyREEsU0FBU3NrQyxvQkFBb0J6K0IsTUFBS25HO0lBQ2hDO0tBQUlvRSxPQUFPOFAsZUFBZS9OO0tBQ3RCQSxPQUFPNk4sb0JBQW9CNVA7SUFDL0JvUSw2QkFBNEJyTyxrQkFBZ0J1QixhQUFhdkIsTUFBS25HO0lBQzlEO0dBQ0Y7RzBCMUNBLFNBQVM2a0MsaUJBQWlCMWtDLEdBQUdMLEdBQUdnbEMsS0FBS0M7SUFDbkMsT0FBUztLQUNDLElBQUpwcUIsTUFBTXhhLGFBQWFMO0tBQUlBO0tBQzNCLEdBQUk2YSxhQUFhO0tBQ1QsSUFBSi9SLE1BQU16SSxhQUFhTDtLQUFJQTtLQUMzQixHQUFJOEk7TUFDRms4QixJQUFLbnFCLFdBQVdvcUI7O01BRWhCRCxJQUFLbnFCLFdBQVdtcUIsSUFBS2w4Qjs7R0FFM0I7R0FFQSxTQUFTbzhCLGlCQUFpQjdrQyxHQUFHTCxHQUFHZ2xDO0lBQzlCLE9BQVM7S0FDQyxJQUFKbnFCLE1BQU14YSxhQUFhTDtLQUFJQTtLQUMzQixHQUFJNmEsYUFBYTtLQUNULElBQUovUixNQUFNekksYUFBYUw7S0FBSUE7S0FDM0IsR0FBSThJLGFBQ0ZrOEIsSUFBS25xQixxQkFFTG1xQixJQUFLbnFCLFdBQVdtcUIsSUFBS2w4Qjs7R0FFM0I7R0FFQSxTQUFTcThCLG9CQUFvQjFJLEtBQUtDLGFBQWFDO0lBQzdDO0tBQUlDO0tBQ0FDO0tBQ0FDO0tBQ0FDO0tBQ0FDO0tBQ0FDO0tBQ0FDO0tBQ0FrSTtLQUNBakk7S0FDQUM7S0FDQUM7S0FDQUM7S0FDQUM7S0FDQThIO0tBQ0FDO0tBQ0FDO0tBQ0FDO0tBQ0FDO0tBQ0FDO0lBRUosS0FBS2pKLGdCQUFpQjtLQUNwQkEsZUFBa0JGLGVBQWdCRSxJQUFJVTtLQUN0Q1Ysa0JBQWtCRixlQUFnQkUsSUFBSVc7S0FDdENYLGdCQUFrQkYsZUFBZ0JFLElBQUljO0tBQ3RDZCxnQkFBa0JGLGVBQWdCRSxJQUFJYTtLQUN0Q2Isa0JBQWtCRixlQUFnQkUsSUFBSVk7O0lBRXhDLEtBQUtaLHFCQUFzQjtLQUN6QkEsb0JBQXVCRixlQUFnQkUsSUFBSTRJO0tBQzNDNUksdUJBQXVCRixlQUFnQkUsSUFBSTZJO0tBQzNDN0kscUJBQXVCRixlQUFnQkUsSUFBSWdKO0tBQzNDaEoscUJBQXVCRixlQUFnQkUsSUFBSStJO0tBQzNDL0ksdUJBQXVCRixlQUFnQkUsSUFBSThJOztJQUU3QyxHQUFJOUksZ0JBQWdCcjhCO0tBQU1xOEIsZUFBZTUyQix1QkFBdUI0MkIsSUFBSWlKO0lBRXBFO0tBQUlwaUM7S0FBRzBLLFFBQVEwdUI7S0FFWHZ3QixTQUFTNUYsMEJBQTBCbzJCLE9BQU9DO0lBRTlDLEdBQUk1dUIsV0FBWTtLQUVkMnVCLE9BQU9LLGdCQUFnQkwsT0FBT0csaUJBQWlCSCxPQUFPSTtLQUN0REosT0FBT007OztLQUdQanZCLFVBQVNBO0lBRVgsT0FBUTtLQUVHLElBQUw0cEIsT0FBTzZFLGFBQWF6dUI7S0FDeEIsR0FBSTRwQixTQUFVO01BQ0QsSUFBUCtOLFNBQVNsSixrQkFBa0J6dUI7TUFDL0JrM0IsaUJBQWlCekksY0FBY2tKLFFBQVFoSixPQUFPeUk7TUFDOUMsU0FBUXhOOztLQUdFLElBQVI0RixVQUFVZixnQkFBZ0J6dUI7S0FDOUIsR0FBSXd2QixhQUFjO01BQ0wsSUFBUG1JLFNBQVNsSixxQkFBcUJ6dUI7TUFDbENrM0IsaUJBQWlCekksY0FBY2tKLFFBQVFoSixPQUFPeUk7TUFDOUN6SSxPQUFPSyxnQkFBZ0JMLE9BQU9JO01BQzlCSixPQUFPTSxtQkFBbUJPOztLQUc1QixHQUFJYixPQUFPSSxpQkFBaUJKLE9BQU9FO01BQWdCLEdBQzdDRixPQUFPTyx1QkFDVCxTQUFRbHZCLGdCQUVSMUs7U0FDQyxDQUVIQSxJQUFJNkksT0FBT3d3QixPQUFPSSxnQkFDbEJKLE9BQU9JO0tBR0UsSUFBUDZJLFNBQVM1M0I7S0FDYixHQUFJeXVCLGNBQWM3RSxPQUFPdDBCLE1BQU0wSztNQUM3QkEsUUFBUXl1QixjQUFjN0UsT0FBT3QwQjs7TUFFN0IwSyxRQUFReXVCLGdCQUFnQnp1QjtLQUUxQixHQUFJQSxVQUFXO01BQ2IydUIsT0FBT0ksZ0JBQWdCSixPQUFPSztNQUM5QixHQUFJTCxPQUFPTTtPQUNUem9COztPQUVBLE9BQU9tb0IsT0FBT007O1NBQ2I7TUFFSCxJQUFJNEksWUFBWXBKLGtCQUFrQm1KLFNBQVNEO01BQzNDLEdBQUlsSixtQkFBbUJvSixZQUFZdmlDLE1BQU1zaUM7T0FDdkNELFNBQVNsSixtQkFBbUJvSixZQUFZdmlDOztPQUV4Q3FpQyxTQUFTbEoscUJBQXFCbUo7TUFDaEMsR0FBSUQ7T0FDRlo7U0FDRHRJLGNBQWNrSixRQUFRaEosT0FBT3lJLFVBQVV6SSxPQUFPSTtNQUkvQyxHQUFJejVCLFVBQVVxNUIsT0FBT087OztHQUczQjtHaEIzRkEsU0FBUzRJLHFCQUFzQnRsQyxHQUFFb0o7SUFDL0IsR0FBR3FVLE1BQU16ZCxNQUFNeWQsTUFBTXJVLElBQUksT0FBTzhDO0lBQ2hDLEdBQUdsTSxLQUFHb0osR0FBRyxPQUFPQTtJQUNoQixHQUFHcEosUUFBSyxPQUNIb0osVUFDT3RKLHNCQUVEQTtJQUVYLElBQUl5bEMsT0FBT2hvQix5QkFBeUJ2ZCxJQUNoQ3dsQyxNQUFNL087SUFDVixHQUFLejJCLElBQUVvSixLQUFPcEo7S0FDWnVsQyxPQUFPblAsZUFBZW1QLE1BQU1DOztLQUU1QkQsT0FBTzFOLGVBQWUwTixNQUFNQztJQUM5QixPQUFPN3BCLHlCQUF5QjRwQjtHQUNsQztHUWlGQSxTQUFTRSxjQUFlemxDLEdBQUdvSjtJQUFLLFVBQVN3YixpQkFBaUI1a0IsR0FBRW9KO0dBQWdCO0dQdEY1RSxTQUFTczhCLG9CQUFvQnppQyxHQUFFdEM7SUFDN0JxVDtHQUNGO0dBOUdBLFNBQVMyeEIsZUFBZ0J4aUMsS0FBSzBPO0lBQ3RCLElBQUZySCxRQUFRL0osTUFBTW9SO0lBQ2xCckgsT0FBS3JIO0lBQ0wsSUFBVyxJQUFGM0QsT0FBT0EsS0FBS3FTLE1BQU1yUyxLQUFLZ0wsRUFBRWhMO0lBQ2xDLE9BQU9nTDtHQUNUO0dBb0NBLFNBQVNvN0IsMEJBQTBCNWxDLEdBQUVSLEdBQUVrSCxLQUFJcEU7SUFDekMsR0FBR3RDLEVBQUVSLFVBQVFrSCxJQUFLLENBQ2hCMUcsRUFBRVIsU0FBTzhDLEdBQ1Q7SUFFRjtHQUNGO0dBdEVBLFNBQVN1akMsa0JBQW1CN2xDLEdBQUssVUFBU0EsYUFBYVMsT0FBUTtHQXlFL0QsU0FBU3FsQyxtQkFBbUI5bEMsR0FDMUIsU0FDRjtHQWxCQSxTQUFTK2xDLHNCQUF1Qm5qQyxHQUFFSyxHQUNoQ0wsWUFDQUEsT0FBS0ssR0FDTCxTQUNGO0dBNERBLFNBQVMraUMsbUJBQW1CeDdCLEdBQUVoTCxHQUFLLE9BQU9nTCxFQUFFaEwsT0FBSztHQU1qRCxTQUFTeW1DLHlCQUF5Qno3QixHQUFLLFNBQVU7R0FIakQsU0FBUzA3Qix1QkFBdUIxN0IsR0FBRWhMLEdBQUV5RCxHQUFLLE9BQU91SCxFQUFFaEwsU0FBT3lELEVBQUU7R0F2RzNELFNBQVNrakMsaUJBQWtCbm1DLEdBQUdtRCxLQUFPbkQsT0FBT21ELEtBQUssU0FBVTtHQTRCM0QsU0FBU2lqQyxrQkFBbUJwbUMsR0FBR0g7SUFDN0IsR0FBSUEsVUFBUUEsUUFBUUcsVUFDbEJnRztJQUNGLEdBQUloRyxZQUFZSCxPQUFPRyxXQUFXSDtJQUNsQztHQUNGO0dBdkJBLFNBQVN3bUMsa0JBQWtCbGpDLEtBQUluRDtJQUM3QixJQUFJd0MsSUFBSXhDLFVBQ0pULFFBQVFrQixNQUFNK0I7SUFDbEJqRCxPQUFPNEQ7SUFDUCxJQUFVLElBQUYzRCxPQUFPQSxJQUFJZ0QsR0FBR2hELEtBQU1ELEVBQUVDLEtBQUtRLEVBQUVSO0lBQ3JDLE9BQU9EO0dBQ1Q7R2I0TkEsU0FBUyttQyxpQkFBaUJ4akMsR0FBR3ZEO0lBQzNCLE9BQVFBOztPQUNBLFdBQVd1RDs7T0FDWCxXQUFXQSxFQUFHdkQ7O09BQ2QsV0FBV3VELEVBQUd2RCxNQUFLQTs7T0FDbkIsV0FBV3VELEVBQUd2RCxNQUFLQSxNQUFLQTs7T0FDeEIsV0FBV3VELEVBQUd2RCxNQUFLQSxNQUFLQSxNQUFLQTs7T0FDN0IsV0FBV3VELEVBQUd2RCxNQUFLQSxNQUFLQSxNQUFLQSxNQUFLQTs7T0FDbEMsV0FBV3VELEVBQUd2RCxNQUFLQSxNQUFLQSxNQUFLQSxNQUFLQSxNQUFLQTs7T0FDdkMsV0FBV3VELEVBQUd2RCxNQUFLQSxNQUFLQSxNQUFLQSxNQUFLQSxNQUFLQSxNQUFLQTs7SUFFcEQsU0FBU202QixJQUFNLE9BQU81MkIsUUFBUXZDLE1BQU1oQixHQUFJO0lBQ3hDbTZCLGNBQWM1MkI7SUFDZCxXQUFXNDJCO0dBQ2I7R04wU29CO0lBQWhCNk07TUFBa0I7UUFDcEIsU0FBU0MsU0FBWWptQyxnQkFBaUI7UUFDdENpbUM7Ozs7Ozs7bUJBRWtCMzBCLE1BQU00MEI7V0FDcEIsSUFBVyxJQUFGam5DLElBQUlxUyxVQUFTclMsUUFBT0E7WUFDM0JlLFdBQVdBLG9CQUFxQmttQyxTQUFTam5DO1VBRnZDOzttQkFJYW9ILEtBQUtpTCxNQUFNNDBCO1dBQ3BCLElBQUo3L0IsTUFBTUE7V0FDVixJQUFXLElBQUZwSCxJQUFJcVMsVUFBU3JTLFFBQU9BO1lBQzNCZSxXQUFXcUcsU0FBVTYvQixTQUFTam5DO1VBSHpCOzttQkFLWXFTLE1BQU1qTyxNQUFNNmlDO1dBQy9CbG1DLFdBQVdBLG9CQUFvQnFEO1dBQy9CLElBQVcsSUFBRnBFLElBQUlxUyxVQUFTclMsUUFBT0E7WUFDM0JlLFdBQVdBLG9CQUFxQmttQyxTQUFTam5DO1VBSGxDOzttQkFLWW1CO1dBQ3JCLEdBQUlBO1lBQW1CSix5QkFBOENJO21CQUM1REE7WUFBb0JKLDBCQUFnREk7O1lBQ3hFSiwwQkFBZ0RJO1VBSDFDOzBCQUtLLE9BQU9KLGVBQXJCOzs7V0FFRkEsaUJBQWlCQTtXQUNqQkE7V0FDQUE7V0FDQUEsZUFBZ0JBO1dBQ2hCQSxlQUFnQkE7V0FDaEJBLGVBQWdCQTtXQUNoQkEsZUFBZ0JBO1dBQ2hCLE9BQU9BO1VBUkE7UUFXWCxnQkFBaUIwQyxHQUFHa0U7U0FDbEJBLFFBQVFpMkIsc0JBQXNCajJCO1NBRTlCO1VBQUl1L0IsYUFBY3YvQjtVQUNkdy9CLFdBQWF4L0I7U0FHakIsR0FBSXcvQjtVQUNGdCtCOztTQUVGO1VBQUk0VyxhQUFhdW5CO1VBQ2IzaEI7VUFDQXlRLG1CQUFtQm9SLGFBQWE5bUMsV0FBV2tMO1NBRS9DLFNBQVM4N0IsS0FBSzNqQztVQUNaLEdBQUl5akMsWUFBWTtVQUNJLElBQWhCRyxrQkFBa0J2Uix3QkFBd0JyeUI7VUFDOUMsR0FBSTRqQyxnQkFBaUI7V0FBRTVuQixvQkFBb0I0bkI7V0FBa0I7O2NBQ3hELENBQUV2Uix1QkFBdUJyeUIsSUFBSTtTQUNwQztTQUVBLFNBQVM2akMsV0FBWTdqQztVQUNuQixHQUFJQSxjQUFlO1dBQ2pCLEdBQUkyakMsS0FBSzNqQyxJQUFJO1dBQ2I7WUFBSTRDLE9BQU81QztZQUNQd3lCLE1BQU12UixnQkFBZ0JyZTtZQUN0QmtoQztXQUNKLEtBQUl0UjtZQUNGenZCO1dBQ0YsR0FBR3l2QixvQkFBb0JqeEIsVUFBVTtZQUMvQnlhO1lBQ0EsSUFBVyxJQUFGemYsT0FBT0EsSUFBSXFHLGFBQWFyRzthQUMvQnlmLGdCQUFpQnBaLGdCQUFnQnJHO1lBQ25DeWY7WUFDZSxJQUFYK25CLGFBQWEvbkI7WUFDakIsSUFBVSxJQUFGemYsT0FBT0EsUUFBUUEsS0FDckJ5ZjtZQUVGd1csY0FBY3hXLFFBQVFoYyxHQUFHOGpDO1lBQ3pCOW5CLGdCQUFnQituQixnQkFBZ0JEO1lBQ2hDOW5CLGdCQUFnQituQjtZQUNoQi9uQixnQkFBZ0IrbkIsb0JBQW9CRDs7ZUFDL0I7WUFDTDluQjtZQUNBLElBQVcsSUFBRnpmLE9BQU9BLElBQUlxRyxhQUFhckc7YUFDL0J5ZixnQkFBaUJwWixnQkFBZ0JyRztZQUNuQ3lmO1lBQ1ksSUFBUjBXLFVBQVUxVztZQUNkd1csY0FBY3hXLFFBQVFoYyxHQUFHOGpDO1lBQ3pCLEdBQUl0UixvQkFBb0J4VyxlQUFlMFc7YUFDckMzaEI7cUVBQW9Fbk87O1dBRXhFb1osdUJBQXdCOG5CO1dBQ3hCOW5CLHVCQUF3QjhuQjs7a0JBRWpCOWpDLGFBQWF4QyxTQUFTd0MsVUFBVUEsVUFBUztXQUNoRCxHQUFJQTtZQUNGK1E7V0FFRixHQUFJMFAseUJBQXlCemdCO1lBQzNCK0M7V0FDRixHQUFJL0MsZ0JBQWdCMmpDLEtBQUszakMsSUFBSTtXQUM3QixHQUFJQSxhQUFhQTtZQUNmZ2MsdUJBQW1EaGMsUUFBU0E7O1lBRTVEZ2MsNEJBQW1EaGMscUJBQXFCQTtXQUMxRWdjLGtCQUFrQmhjO1dBQ2xCZ2Msa0JBQWtCaGM7V0FDbEIsR0FBSUEsY0FBYzRoQixXQUFZNWhCOztrQkFDckIrQixpQkFBaUIvQixHQUFJO1dBQzlCLEtBQUsrQixpQkFBaUJqRjtZQUNwQmlVOztXQUVGLEdBQUk0eUIsS0FBSzNqQyxJQUFJO1dBQ0wsSUFBSnhELE1BQU15RyxxQkFBcUJqRDtXQUMvQixHQUFJeEQ7WUFDRndmLHVCQUFvRHhmO21CQUM3Q0E7WUFDUHdmLDJCQUFnRHhmOztZQUVoRHdmLDRCQUFtRHhmO1dBQ3JELElBQVcsSUFBRkQsT0FBTUEsSUFBSUMsS0FBSUQ7WUFDckJ5ZixnQkFBaUI4QyxzQkFBc0I5ZSxHQUFFekQ7V0FDM0N5Zix3QkFBeUJ4ZjtXQUN6QndmLHdCQUF5QnhmOztrQkFDaEJ3RixrQkFBa0JoQyxHQUFJO1dBQy9CLEdBQUkyakMsS0FBSzNqQyxJQUFJO1dBQ0wsSUFBSnhELE1BQU1nSyxzQkFBc0J4RztXQUNoQyxHQUFJeEQ7WUFDRndmLHVCQUFvRHhmO21CQUM3Q0E7WUFDUHdmLDJCQUFnRHhmOztZQUVoRHdmLDRCQUFtRHhmO1dBQ3JELElBQVcsSUFBRkQsT0FBTUEsSUFBSUMsS0FBSUQ7WUFDckJ5ZixnQkFBaUJ2Vix1QkFBdUJ6RyxHQUFFekQ7V0FDNUN5Zix3QkFBeUJ4ZjtXQUN6QndmLHdCQUF5QnhmOztrQkFFckJ3RCxNQUFNQSxPQUFLO1dBQ0MsSUFBVmdrQyxtQkFBbUJoa0M7V0FDdkIsR0FBR2drQztZQUNEanpCLGlEQUErQ2l6QjtXQUtqRCxHQUFJTCxLQUFLM2pDLElBQUk7V0FDUCxJQUFGSixJQUFJa2Msb0JBQW9CeEIseUJBQXlCdGE7V0FDckRnYztXQUNBLElBQVUsSUFBRnpmLE9BQU9BLE9BQUtBLEtBQUt5ZixnQkFBZXBjLE1BQU1yRDtXQUM5Q3lmO1dBQ0FBOztrQkFFT2hjLFVBQVVBO1dBQ2pCZ2MsdUJBQWlEaGM7a0JBRTdDQSxtQkFBa0JBO1dBQ3BCZ2MsMkJBQTZDaGM7a0JBQ3RDQSxvQkFBbUJBO1dBQzFCZ2MsNEJBQStDaGM7O1dBRS9DZ2MsNEJBQStDaGM7U0FHdkQ7U0FDQTZqQyxXQUFZN2pDO1NBQ1osTUFBTzRoQixpQkFBa0I7VUFDdkIsSUFBSXJsQixJQUFJcWxCLGFBQ0o1aEIsSUFBSTRoQjtVQUNSLEdBQUlybEIsUUFBUXlELFVBQVU0aEIsV0FBWTVoQixHQUFHekQ7VUFDckNzbkMsV0FBWTdqQyxFQUFFekQ7O1NBRWhCLEdBQUk4MUI7VUFBa0JyVyxxQkFBcUJxVztTQUMzQ3JXO1NBQ0EsT0FBT0EsYUF2SUY7T0FuQ2E7O0dBZ0x0QixTQUFTaW9CLDRCQUE2QmprQyxHQUFHa0U7SUFDdkMsT0FBT2xILHFCQUFzQnNtQyxnQkFBaUJ0akMsR0FBR2tFO0dBQ25EO0d5QnBNQSxTQUFTZ2dDLGtCQUFtQjdqQixRQUFPcmdCLEdBQUVrRTtJQUM3QixJQUFGdEgsSUFBSXFuQyw0QkFBNEJqa0MsR0FBR2tFO0lBQ3ZDdzdCLGVBQWVyZixRQUFPempCLE1BQUk0SixzQkFBc0I1SjtJQUNoRDtHQUNGO0d6QjBNQSxTQUFTdW5DLDRCQUE2QnZuQyxHQUFHK0wsS0FBS25NLEtBQUt3RCxHQUFHa0U7SUFDOUMsSUFBRnRFLElBQUkwakMsZ0JBQWlCdGpDLEdBQUdrRTtJQUM1QixHQUFJdEUsV0FBV3BELEtBQUt1VTtJQUNwQjdOLGdCQUFnQnRELE1BQU1oRCxHQUFHK0wsS0FBSy9JO0lBQzlCO0dBQ0Y7R0FYQSxTQUFTd2tDLDJCQUE0QnBrQyxHQUFHa0U7SUFDdEMsT0FBT2pDLG9CQUFxQnFoQyxnQkFBaUJ0akMsR0FBR2tFO0dBQ2xEO0dvQzV2QnNCLElBQWxCbWdDO0dBTUosU0FBU0Msa0JBQWtCQyxRQUFRQyxLQUFLQyxLQUFLbGlDO0lBRTNDO0tBQUltaUM7S0FRQUM7S0FDQUM7S0FDQUM7S0FDQUM7S0FDQUM7S0FFQUM7S0FDQUM7S0FDQUM7S0FDQUM7S0FDQUM7S0FDQUM7S0FFQUM7S0FDQUM7S0FDQUM7S0FDQUM7S0FDQUM7S0FDQUM7S0FDQUM7S0FDQUM7S0FDQUM7S0FDQUM7S0FDQUM7S0FDQUM7S0FDQUM7S0FDQUM7S0FDQUM7S0FDQUM7S0FHQUM7S0FDQUM7S0FDQUM7S0FDQUM7S0FDQUM7S0FDQUM7S0FDQUM7S0FDQUM7S0FDQUM7S0FDQUM7S0FDQUM7S0FDQUM7S0FFQUM7S0FDQUM7SUFHSixTQUFTQyxJQUFJcnFDO0tBQ0wsSUFBRkgsSUFBSUUsdUJBQXVCQztLQUMvQjJpQyxrQkFBa0I5aUMsTUFBTTRKLHNCQUFzQjVKO0lBQ2hEO0lBRUEsU0FBU3lxQyxXQUFXQyxPQUFPeFo7S0FFakIsSUFBSnJCLE1BQU1sZCx3QkFBd0IrM0I7S0FDbEMsR0FBSTdhLGtCQUNGO0tBQ0YsT0FBT0Esa0JBQWtCcUI7SUFDM0I7SUFFQSxTQUFTeVosWUFBWWg5QixPQUFPaTlCO0tBRTFCLElBQUlDLE9BQU9sL0I7S0FDWCxHQUFJaS9CLGVBQWVocUMsTUFBTztNQUN4QmlxQyxRQUFRSixXQUFXOUMsT0FBTzRDLGtCQUFrQks7TUFDNUMsVUFBV0E7T0FDVGovQixZQUFZaS9CO3FCQUNFQTtPQUNkai9CLE9BQU9pL0I7Y0FDQUEsa0JBQWtCdm5DO09BQ3pCc0ksT0FBT25HLHVCQUF1Qm9sQzs7T0FFOUJqL0I7TUFDRjYrQixlQUFlNzhCLDBCQUEwQms5QixjQUFjbC9COztTQUNsRDtNQUNMay9CLFFBQVFKLFdBQVc5QyxPQUFPMkMsa0JBQWtCTTtNQUM1Q0osZUFBZTc4QiwwQkFBMEJrOUI7O0lBRTdDO0lBRUEsS0FBS2xELGFBQWM7S0FDakJBLGdCQUFnQnpMLGVBQWdCeUwsT0FBT21DO0tBQ3ZDbkMsZ0JBQWdCekwsZUFBZ0J5TCxPQUFPcUM7S0FDdkNyQyxlQUFnQnpMLGVBQWdCeUwsT0FBTzBDO0tBQ3ZDMUMsZ0JBQWdCekwsZUFBZ0J5TCxPQUFPc0M7S0FDdkN0QyxlQUFnQnpMLGVBQWdCeUwsT0FBT3lDO0tBQ3ZDekMsYUFBZ0J6TCxlQUFnQnlMLE9BQU9rQztLQUN2Q2xDLGFBQWdCekwsZUFBZ0J5TCxPQUFPaUM7S0FDdkNqQyxnQkFBZ0J6TCxlQUFnQnlMLE9BQU91QztLQUN2Q3ZDLGVBQWdCekwsZUFBZ0J5TCxPQUFPb0M7O0lBR3pDO0tBQUlyaUM7S0FBU2pGO0tBQUdxb0M7S0FBSUM7S0FBSUM7S0FHcEJDLEtBQUtyRCxJQUFJMkI7S0FDVDU3QixRQUFRaTZCLElBQUk0QjtLQUNaMEIsVUFBVXRELElBQUk2QjtJQUVsQjtJQUFLO0tBQVM7S0FDUCxPQUFPNUI7O1FBRVZsNkIsV0FDQXU5Qjs7UUFJQXpvQyxJQUFJa2xDLGNBQWNoNkI7UUFDbEIsR0FBSWxMLE9BQVEsQ0FBRW9sQyxNQUFNTSxRQUFRO1FBQzVCLEdBQUlQLElBQUlvQixvQkFBcUIsQ0FBRW5CLE1BQU1HLFdBQVc7UUFDaER0Z0MsTUFBTTBnQztRQUNOOztRQUlBLEdBQUl6aUMsZUFBZS9FLE1BQU87U0FDeEJnbkMsSUFBSW9CLGlCQUFpQnJCLE9BQU9nQyxrQkFBa0Joa0M7U0FDOUNpaUMsSUFBSXFCLFlBQVl0akM7O1lBQ1g7U0FDTGlpQyxJQUFJb0IsaUJBQWlCckIsT0FBTytCLGtCQUFrQi9qQztTQUM5Q2lpQyxJQUFJcUI7O1FBRU4sR0FBSXhCLG1CQUFtQmtELFlBQWFoOUIsT0FBT2hJOztRQUkzQ21sQyxLQUFLbkQsY0FBY2g2QjtRQUNuQm85QixLQUFLRCxLQUFLbEQsSUFBSW9CO1FBQ2Q7VUFBSThCLFdBQVdDLFdBQVdBLE1BQU1wRCxPQUFPd0M7YUFDbkN4QyxhQUFhb0QsT0FBT25ELElBQUlvQixlQUFnQixDQUMxQ25CLE1BQU1JLE9BQU87UUFFZjZDLEtBQUtuRCxjQUFjaDZCO1FBQ25CbzlCLEtBQUtELEtBQUtsRCxJQUFJb0I7UUFDZDtVQUFJOEIsV0FBV0MsV0FBV0EsTUFBTXBELE9BQU93QzthQUNuQ3hDLGFBQWFvRCxPQUFPbkQsSUFBSW9CLGVBQWdCO1NBQzFDdm1DLElBQUlrbEMsYUFBYW9EO1NBQ2pCbEQsTUFBTU07U0FBUTs7UUFFaEIsR0FBSStDLGFBQWMsQ0FDaEJ4akMsTUFBTStnQyxxQkFDTjs7UUFLRixHQUFJeUMsWUFBYTtTQUNmQTtTQUNBLE9BQVM7VUFDUEYsU0FBU3BELElBQUljLGFBQWF1QztVQUMxQkgsS0FBS25ELGNBQWNxRDtVQUNuQkQsS0FBS0QsS0FBS2hEO1VBQ1Y7WUFBSWdELFdBQVdDLFdBQVdBLE1BQU1wRCxPQUFPd0M7ZUFDbkN4QyxhQUFhb0QsT0FBT2pELFFBQVM7V0FDL0IsR0FBSUwsbUJBQ0YrQyw2QkFBNkJRO1dBQy9CbkQsTUFBTUs7V0FBZTs7Y0FDaEI7V0FDTCxHQUFJVCxtQkFDRitDLDBCQUEwQlE7V0FDNUIsR0FBSUMsTUFBTXJELElBQUltQixlQUFnQjtZQUM1QixHQUFJdEIsbUJBQ0YrQztZQUNGLE9BQU9uQzs7V0FHVDRDOzs7O1lBR0M7U0FDTCxHQUFJckQsSUFBSW9CLHFCQUNOLE9BQU9YO1NBQ1QsR0FBSVosbUJBQ0YrQztTQUNGNUMsSUFBSW9CO1NBQ0puQixNQUFNRTtTQUFNOzs7UUFJZEgsSUFBSW9CLHNCQUNKLEdBQUlrQyxhQUFhQTs7UUFHakIsR0FBSXpEO1NBQ0YrQyxlQUFlNzhCLDhCQUE4Qmc2QixhQUFhb0Q7UUFDNURwOUIsUUFBUWc2QixhQUFhb0Q7UUFDckJFO1FBQ0EsR0FBSUEsTUFBTXJELElBQUlrQixlQUFnQixDQUM1QnBoQyxNQUFNNGdDLGVBQ047O1FBS0ZWLElBQUljLGFBQWF1QyxVQUFVdDlCO1FBQzNCaTZCLElBQUllLGFBQWFzQyxVQUFVckQsSUFBSXFCO1FBQy9CckIsSUFBSWdCLHNCQUFzQnFDLFVBQVVyRCxJQUFJc0I7UUFDeEN0QixJQUFJaUIsb0JBQW9Cb0MsVUFBVXJELElBQUl1QjtRQUN0Q3RCLE1BQU1FO1FBQ047O1FBR0EsR0FBSU4sbUJBQ0YrQyxlQUFlNzhCLDhCQUE4QmxMO1FBQ3pDLElBQUZ5RixJQUFJeS9CLFdBQVdsbEM7UUFDbkJtbEMsSUFBSXdCLFdBQVc2QjtRQUNmckQsSUFBSTBCLG1CQUFtQjdtQztRQUN2Qm1sQyxJQUFJeUIsZ0JBQWdCbmhDO1FBQ3BCK2lDLEtBQUtBLEtBQUsvaUM7UUFDVkEsSUFBSXkvQixXQUFXbGxDO1FBQ2Z1b0MsU0FBU3BELElBQUljLGFBQWF1QztRQUMxQkgsS0FBS25ELGNBQWN6L0I7UUFDbkI2aUMsS0FBS0QsS0FBS0U7UUFDVjtVQUFJRixXQUFXQyxXQUFXQSxNQUFNcEQsT0FBT3dDO2FBQ25DeEMsYUFBYW9ELE9BQU9DO1NBQ3RCcjlCLFFBQVFnNkIsYUFBYW9EOztTQUVyQnA5QixRQUFRZzZCLGFBQWF6L0I7UUFDdkIsR0FBSStpQyxNQUFNckQsSUFBSWtCLGVBQWdCLENBQzVCcGhDLE1BQU02Z0MsZUFDTjs7UUFLRjdnQyxNQUFNOGdDLHlCQUNOOztRQUdBWixJQUFJYyxhQUFhdUMsVUFBVXQ5QjtRQUMzQmk2QixJQUFJZSxhQUFhc0MsVUFBVXRsQztRQUNuQixJQUFKd2xDLE1BQU12RCxJQUFJd0I7UUFDZHhCLElBQUlpQixvQkFBb0JvQyxVQUFVckQsSUFBSWlCLG9CQUFvQnNDO1FBQzFELEdBQUlGLEtBQUtFO1NBRVB2RCxJQUFJZ0Isc0JBQXNCcUMsVUFBVXJELElBQUlpQixvQkFBb0JzQztRQUU5RHRELE1BQU1FO1FBQU07Z0JBR1osT0FBT007O0lBSVhULElBQUkyQixVQUFVMEI7SUFDZHJELElBQUk0QixhQUFhNzdCO0lBQ2pCaTZCLElBQUk2QixlQUFleUI7SUFDbkIsT0FBT3hqQztHQUNUO0c5QjRJQSxTQUFTMGpDLGtCQUFtQnByQztJQUMxQndJO0lBQ0EsT0FBT293QixLQUFLam1CLHdCQUF3QjNTO0dBQUk7R0V0TzFDLFNBQVNxckMscUJBQXFCcmxDO0lBQzVCRixxQkFBc0JFO0dBQ3hCO0dEdElBLFNBQVNzbEM7SUFDUDNpQyxvQkFBb0I5RDtHQUE2QjtHRmZuRCxTQUFTMG1DLDRCQUE4QixTQUFVO0dBRWpELFNBQVNDLCtCQUFpQyxTQUFTO0dBR25ELFNBQVNDO0lBQ1B0bEM7O0dBQ0Y7R2lCY0EsU0FBU3VsQyw4QkFBOEJybEIsTUFBUSxTQUFTO0dqQnpCeEQsU0FBU3NsQixzQkFBdUI1b0M7SUFBSzZCLDZCQUE2QjdCO0lBQUc7R0FBVTtHRGdTL0UsU0FBUzZvQyxvQ0FBb0NDLFVBQzNDLFNBQ0Y7R0RoTEEsU0FBU0MscUJBQXNCcnBDLEdBQUdXLEdBQUcyb0M7SUFDbkMsR0FBSUEsU0FBVTtLQUNILElBQUwvbEMsT0FBTytsQztLQUNYLEdBQUdybkM7TUFDRGpDLElBQUkwZ0IsY0FBY3plLDJCQUEyQnNCO2FBRXRDbkIseUJBQTBCO01BQ2pDLEtBQUlBO09BQ0ZBLDBCQUEwQmlkLG1CQUFtQmpkO01BRXZDLElBQUptbkMsTUFBTW5uQyx3QkFBd0JtQjtNQUNsQyxHQUFHZ21DO09BQ0R2cEMsSUFBSXVwQzs7T0FFSjczQix1REFBdURuTzs7O0lBSTdEbkIsaUJBQWlCcEMsU0FBU1c7SUFDMUIsR0FBRzJvQyxVQUFVbG5DLGlCQUFpQmtuQyxZQUFZM29DO0dBQzVDO0dBakRBLFNBQVM2b0MsMEJBQTBCMW5DLElBQUduQjtJQUNwQ2lCLGtCQUFrQm1CLHVCQUF1QmpCLE9BQU9uQjtJQUNoRDtHQUNGO0dFM0VBLFNBQVM4b0MsMkJBQTJCbm5DLEtBQUsrbEIsSUFBTSxTQUFTO0dhc094RCxTQUFTcWhCLGlCQUFrQmhzQztJQUN6QixHQUFJQSxPQUFRO0tBQ0osSUFBRm9KLElBQUl0SixXQUFXRTtLQUNuQixPQUFRQSxJQUFJb0osV0FBV0EsUUFBT0E7O1FBQ3pCLENBQ0MsSUFBRkEsSUFBSXRKLFVBQVVFLElBQ2xCLE9BQVFvSixJQUFJcEosV0FBV29KLFFBQU9BO0dBRWxDO0dTNVBBLFNBQVM2aUMsa0NBQWtDdGhDLFFBQ3pDLFVBQ0Y7R0FHQSxTQUFTdWhDLGdDQUFnQ0MsUUFDdkMsU0FDRjtHQUdBLFNBQVNDLDhCQUE4QkQsUUFBUUUsV0FBV2hvQixLQUN4RCxTQUNGO0dBcERBLFNBQVNpb0I7SUFBa0NDLFlBQVlDLFdBQVdDO0lBQ2hFNW1CO0lBQ0EsV0FBV0EseUJBQXlCMG1CLFlBQVlFLFlBQVlEO0dBQzlEO0dBUUEsU0FBU0UsbUNBQ1AsU0FDRjtHQVBBLFNBQVNDLCtCQUErQkMsT0FBT0MsZUFDN0MsU0FDRjtHdkI4UkEsU0FBU0Msd0JBQXdCbHNCLE9BQy9CLE9BQU83Z0IsMkJBQ1Q7R0FQQSxTQUFTZ3RDLHFCQUFxQm5zQixPQUM1QixPQUFPN2dCLDJCQUNUO0dlN0pBLFNBQVNpdEMsZUFBZ0JwcUMsR0FDdkJBLE9BQUtpcEIsbUJBQ0wsT0FBT2pwQixFQUNUO0dpQmtKQSxTQUFTcXFDLHNCQUFzQjlMO0lBQ2pCLElBQVIrTCxVQUFVNUY7SUFDZEEsb0JBQW9Cbkc7SUFDcEIsT0FBTytMO0dBQ1Q7R2hDL0xBLFNBQVNDLG9CQUFvQnJ4QixHQUFFN1k7SUFDN0IsS0FBSXNCLDRCQUNGQTtJQUNGQSwyQkFBMkJ1WCxLQUFLN1k7SUFDaEM7R0FDRjtHY3lKQSxTQUFTbXFDLG1CQUFtQnB0QyxHQUMxQixHQUFJQSxRQUFRQSxRQUFRQSxHQUNwQixPQUFRQSxjQUNWO0dBbUJBLFNBQVNxdEMsZ0JBQWlCcnRDLEdBQUssT0FBT0YsVUFBVUUsR0FBSTtHZDJDcEQsU0FBU3N0Qyx1QkFBdUIxc0IsT0FDOUIsU0FDRjtHQWNBLFNBQVMyc0I7SUFDUHY1QjtHQUNGO0dpQ0xBLFNBQVN3NUIsb0JBQW9CdG5CLE1BQzNCLFNBQ0Y7R3ZDdklBLFNBQVN1bkI7SUFDUHpuQztHQUNGO0dBMGJBLFNBQVMwbkMsbUJBQW1CbnVDLEdBQUVxRCxHQUFLLE9BQU9yRCxJQUFJcUQsRUFBRTtHQXVDaEQsU0FBUytxQyxrQkFBa0J2bkMsSUFBSUUsSUFDN0IsR0FBR0YsT0FBT0UsSUFBSSxVQUNkLFNBQ0Y7R0F6ZEEsU0FBU3NuQyxnQkFBaUIvdEMsR0FBR0w7SUFDM0IsR0FBSUEsV0FBV2lLLHNCQUFzQjVKLElBQUk0dEM7SUFDekMsT0FBTy9qQyx1QkFBd0I3SixHQUFHTDtHQUNwQztHQUtBLFNBQVNxdUMsa0JBQWtCaHVDLEdBQUVMO0lBQzNCLEdBQUlBLFdBQVdpSyxzQkFBc0I1SixRQUFRNHRDO0lBQzdDO0tBQUkxdEIsS0FBS3JXLHVCQUF3QjdKLEdBQUdMO0tBQ2hDd2dCLEtBQUt0Vyx1QkFBd0I3SixHQUFHTDtJQUNwQyxPQUFRd2dCLFVBQVVEO0dBQ3BCO0dBY0EsU0FBUyt0QixrQkFBa0JqdUMsR0FBRUw7SUFDM0IsR0FBSUEsV0FBV2lLLHNCQUFzQjVKLFFBQVE0dEM7SUFDN0M7S0FBSTF0QixLQUFLclcsdUJBQXdCN0osR0FBR0w7S0FDaEN3Z0IsS0FBS3RXLHVCQUF3QjdKLEdBQUdMO0tBQ2hDMGdCLEtBQUt4Vyx1QkFBd0I3SixHQUFHTDtLQUNoQzJnQixLQUFLelcsdUJBQXdCN0osR0FBR0w7SUFDcEMsT0FBUTJnQixXQUFXRCxXQUFXRixVQUFVRDtHQUMxQztHQWlCQSxTQUFTZ3VCLGtCQUFrQmx1QyxHQUFFTDtJQUMzQixHQUFJQSxXQUFXaUssc0JBQXNCNUosUUFBUTR0QztJQUN2QyxJQUFGbHVDLFFBQVFrQjtJQUNaLElBQVUsSUFBRkMsT0FBT0EsT0FBT0EsS0FDcEJuQixNQUFNbUIsS0FBS2dKLHVCQUF3QjdKLEdBQUdMLElBQUlrQjtJQUU1QyxPQUFPZ2Isb0JBQW9CbmM7R0FDN0I7R0FtYUEsU0FBU3l1QyxzQkFBc0I1bkMsSUFBSUUsSUFDakMsT0FBUUYsTUFBTUUsV0FDaEI7R0F2SUEsU0FBUzJuQyx5QkFBeUI3bkMsSUFBSUUsSUFDcEMsT0FBTzBuQyxzQkFBc0IxbkMsSUFBR0Y7R0FDbEM7R0F5SUEsU0FBUzhuQyxxQkFBcUI5bkMsSUFBSUUsSUFDaEMsT0FBUUYsS0FBS0UsV0FDZjtHQWxJQSxTQUFTNm5DLHdCQUF3Qi9uQyxJQUFJRSxJQUNuQyxPQUFPNG5DLHFCQUFxQjVuQyxJQUFJRjtHQUNsQztHMEI3VEEsU0FBU2dvQyxpQkFBaUJybEMsR0FBRzlGO0lBQzNCLElBQUk4RixJQUFJZ3FCLHFCQUFxQmhxQixHQUFFOUYsSUFDM0I4RixJQUFJb3FCLG9CQUFvQnBxQjtJQUM1QixPQUFPQTtHQUNUO0cxQm9SQSxTQUFTc2xDLHFCQUFxQmpvQyxJQUFJRTtJQUFNLFdBQVNxbkMsa0JBQWtCdm5DLElBQUlFO0dBQUs7R0E5TzVFLFNBQVNnb0MsZ0JBQWlCenVDLEdBQUdMLEdBQUdzRCxHQUM5QmtSLGlDQUNGO0dBd0JBLFNBQVN1NkIsa0JBQWtCMXVDLEdBQUVMLEdBQUVtakIsS0FDN0IzTyxtQ0FDRjtHQTJCQSxTQUFTdzZCLGtCQUFrQjN1QyxHQUFFTCxHQUFFcWpCLEtBQzdCN08sbUNBQ0Y7R0F3QkEsU0FBU3k2QixrQkFBa0I1dUMsR0FBRUwsR0FBRXVqQixLQUM3Qi9PLG1DQUNGO0dBK1JBLFNBQVMwNkIsdUJBQXdCN3VDLEdBQUdMLEdBQUdzRDtJQUNyQ2tSO0dBQ0Y7R01qZkEsU0FBUzI2QixjQUFlcHZDLEdBQ3RCLE9BQU9nWixVQUNUO0dJQUEsU0FBU3EyQixlQUFlQztJQUNiLElBQUx4bkMsT0FBTzhNLGtCQUFrQjA2QjtJQUM3QixHQUFHeG5DLG1CQUFtQkEsV0FBWTtLQUNoQyxHQUFHQTtNQUFXc00sbUJBQW1CRCxvQkFBb0JyTSxZQUFZQTs7TUFDNURzTSxtQkFBbUJ0TTtLQUN4Qjs7O0tBR0F6Qix3QkFBd0JQLHVCQUF1QndwQztHQUVuRDtHSnFGQSxTQUFTQztJQUNQLFdBQVcvdUM7R0FDYjtHQTNCQSxTQUFTZ3ZDLDRCQUErQixTQUFVO0dBTWxELFNBQVNDLDBCQUE2QixVQUFXO0dBS2pELFNBQVNDLDRCQUErQiwwQkFBMEI7R0F3RWxFLFNBQVNDLHNDQUFzQ3R1QixPQUM3QyxTQUNGO0dBdkRZO0lBQVJ1dUI7TUFBVzVxQyxzQkFDQUE7VUFDQUE7OztHQVhmLFNBQVM2cUMsK0JBQWtDLE9BQU9EO0dBQTZCO0dBTi9FLFNBQVNFLDZCQUFnQyxPQUFPRiwwQkFBMkI7R0FHM0UsU0FBU0csOEJBQWlDLE9BQU9ILDJCQUE0QjtHQWY3RSxTQUFTSSwyQkFBOEIsVUFBVztHQTlEbEQsU0FBU0MseUJBQXlCandDLEdBQ2hDLE9BQU8rb0IscUJBQ1Q7R0FuS0EsU0FBU21uQixjQUFlN3JDO0lBQ3RCLEdBQUdXLGlCQUFpQkEsZ0JBQWdCWDtJQUVwQyxHQUFHVyxzQkFBc0JBO0tBQ3ZCQSx3QkFBd0JYO0lBQzFCb0M7R0FDRjtHSTBLQSxTQUFTMHBDLHFCQUFzQjdwQztJQUNwQixJQUFMd0IsT0FBTzhNLGtCQUFrQnRPO0lBQzdCLE9BQU93QixtQkFBbUJBO0dBQzVCO0dKckNBLFNBQVNzb0Msa0JBQW1CcHdDLEdBQzFCLFdBQVdnWixjQUFjQSxXQUMzQjtHQWlIQSxTQUFTcTNCO0lBQ1AsV0FBVzd2Qyx1QkFBdUJvdkM7R0FDcEM7R0luSEEsU0FBU1U7SUFDUCxPQUFPOXZDLHVCQUF1QjRUO0dBQ2hDO0dKOUNBLFNBQVNtOEIsZ0JBQWlCanFDO0lBQ2xCLElBQUZ0RCxJQUFJOEIsZ0JBQWdCbU8sd0JBQXdCM007SUFDaEQsR0FBR3RELE1BQU1pQyxXQUNQMm1DO0lBQ0YsT0FBTzFuQyx3QkFBd0JsQjtHQUNqQztHSW9HQSxTQUFTd3RDLHNCQUFzQmxxQztJQUM3QixJQUFJd0IsT0FBTzhNLGtCQUFrQnRPLE9BQ3pCdEcsSUFBSThILG1CQUFtQkE7SUFDM0IsT0FBTzlIO0dBQ1Q7R0pxSEEsU0FBU3l3Qyx5QkFBeUJucUM7SUFDdkIsSUFBTHdCLE9BQU84TSxrQkFBa0J0TztJQUM3QixPQUFPd0IsbUJBQW1CQTtHQUM1QjtHQW5FQSxTQUFTNG9DLGdCQUFnQkMsT0FDdkIsU0FDRjtHSXZDQSxTQUFTQyxlQUFldHFDLE1BQU11cUM7SUFDbkIsSUFBTC9vQyxPQUFPOE0sa0JBQWtCdE87SUFDN0J3QixrQkFBa0JBLFdBQVUrb0M7SUFDNUI7R0FDRjtHSjNFQSxTQUFTQyxxQkFBcUI3cUMsS0FDNUIrUyxZQUFZL1MsS0FDWixTQUNGO0dBK0NBLFNBQVM4cUM7SUFDUCxHQUFJL3JDO0tBQW1CLEdBQ2hCQSxrQ0FBbUM7TUFDL0IsSUFBRmhGLElBQUlnRixzQ0FBc0NpRjtNQUM5QyxXQUFXakssTUFBTUEsTUFBTUEsTUFBTUE7O2FBQ3BCZ0YsOEJBQStCO01BQ2xDLElBQUZoRixRQUFRaUssV0FBV2pGO01BQ3ZCLFdBQVdoRixNQUFNQSxNQUFNQSxNQUFNQTs7SUFHbEMsSUFBSWd4QyxNQUFNLElBQUtDLGtCQUNYeHdDLElBQUl1d0MsbUJBQWV6d0M7SUFDdkIsV0FBVUU7R0FDWjtHSWpDQSxTQUFTeXdDLHdCQUF3QjVxQztJQUMvQjtLQUFJd0IsT0FBTzhNLGtCQUFrQnRPO0tBQ3pCdEcsSUFBSThILG9CQUFvQkE7S0FDeEI3RSxRQUFRL0IsTUFBTWxCO0lBQ2xCaUQ7SUFDQSxJQUFTLElBQURoRCxPQUFJQSxJQUFFRCxVQUFTQyxLQUNyQmdELEVBQUVoRCxTQUFPTyx1QkFBdUJSLEVBQUVDO0lBQ3BDLE9BQU9nRDtHQUNUO0dBSUEsU0FBU2t1QyxnQkFBZ0I3cUM7SUFDdkIsSUFBSXdCLE9BQU84TSxrQkFBa0J0TyxPQUN6Qm9DLEtBQUtaLG1CQUFtQkE7SUFDNUIsR0FBR1ksU0FBU3JDLHdCQUF3QlAsdUJBQXVCUTtJQUMzRDtHQUNGO0dBWUEsU0FBUzhxQyxnQkFBZ0JubUMsR0FBRWxJO0lBQ3pCLElBQUlzdUMsU0FBU3o4QixrQkFBa0IzSixJQUMzQnFtQyxTQUFTMThCLGtCQUFrQjdSO0lBQy9CLEdBQUdzdUMsaUJBQWlCQztLQUNsQjc4QjtJQUNGLEtBQUk0OEI7S0FDRjU4QjtJQUNGNDhCLHFCQUFxQkEsYUFBYUM7R0FDcEM7R0FZQSxTQUFTQyxlQUFlanJDO0lBQ2IsSUFBTHdCLE9BQU84TSxrQkFBa0J0TztJQUM3QndCLGtCQUFrQkE7SUFDbEI7R0FDRjtHSnRFQSxTQUFTMHBDLHdCQUF3QnJKO0lBQ3ZCLElBQUpBLE1BQU1sMUIsd0JBQXdCazFCO0lBQ2xDLFVBQVcxOUIsdUJBQXVCO0tBQ2QsSUFBZGduQyxnQkFBZ0JobkM7S0FDcEIsR0FBR2duQyxpQkFBaUJBO01BQ2xCLElBQ0VBLHVCQUF1QnRKLDBCQUN2QjtZQUNPNzRCLEdBQ1A7OztLQUdEO0dBQ1A7R0FVc0IsSUFBbEJvaUMsb0JBQW9CLElBQUtUO0dBQzdCLFNBQVNVO0lBQ0MsSUFBSlgsTUFBTSxJQUFLQztJQUNmLE9BQU9ELGNBQWNVO0dBQ3ZCO0dBSUEsU0FBU0UsK0JBQStCdnVDLEdBQ3RDLE9BQU9zdUMsZ0JBQ1Q7R0EzRkEsU0FBU0UsdUJBQXVCdnJDLE1BQzlCLE9BQU9pcUMsZ0JBQWlCanFDLE1BQzFCO0djb0pBLFNBQVN3ckMsZ0JBQWlCcnhDLEdBQUssT0FBT0YsVUFBVUUsR0FBSTtHcEJ1bEJwRCxTQUFTc3hDLGtCQUFrQnp4QyxHQUN6QixPQUFPMlMsd0JBQXdCM1MsR0FDakM7R1FoMUJBLFNBQVMweEMsZ0JBQWdCaHFDO0lBQ2pCLElBQUZ6RTtJQUNKLE1BQU15RSxPQUFPQSxjQUFjO0tBQ3pCQSxNQUFNQSxvQkFBb0IzSCxNQUFNMkg7S0FDaEN6RTs7SUFFRixPQUFPeUU7R0FDVDtHQUdBLFNBQVNpcUMsdUJBQXVCOXhDLEdBQUV1RSxNQUNoQyxtQkFBa0J2RSxhQUFXdUU7R0FDL0I7R1l1SEEsU0FBU3d0QyxpQkFBaUJ6eEMsR0FDeEIsT0FBT0YsV0FBV0UsR0FDcEI7R2hCbkhBLFNBQVMweEMsb0JBQXFCO0dBNE45QixTQUFTQyxtQkFBbUJDO0lBQzFCLElBQ0lBO1VBQ0svaUM7S0FDVSxJQUFYbkwsYUFBYVM7S0FDakJZO09BQXFCckIsWUFBWUMsd0NBQXdDaXVDOztHQUUvRTtHQS9OQSxTQUFTQywwQkFBMEI3eEMsR0FBSSxPQUFPQSxFQUFFO0dBcVFoRCxTQUFTOHhDLG9CQUFvQkYsWUFDM0IsT0FBT0QsbUJBQW1CQztHQUM1QjtHQS9FQSxTQUFTRyxrQkFBa0JqdUM7SUFDaEIsSUFBTHVELE9BQU84TSxrQkFBa0JyUTtJQUM3QixLQUFLdUQ7S0FDSDJNO0lBRWEsSUFBWDQ5QixhQUFhdnFDLG9CQUFvQkE7SUFDckMsaUJBQW1CdXFDLGtCQUFrQjl0QztHQUN2QztHQU9BLFNBQVNrdUMsa0JBQWtCSjtJQUN6QixJQUFJNXBDO0lBQ0osSUFDSUEsUUFBUTRwQztVQUNIL2lDO0tBQ1UsSUFBWG5MLGFBQWFTO0tBQ2pCWTtPQUFxQnJCLFlBQVlDLHVDQUF1Q2l1Qzs7SUFFNUUsR0FBSTVwQyxVQUFVcEk7S0FDVjQwQjs7S0FDRyxPQUNJL3dCLHdCQUF3QnVFO0dBRXJDO0dBNEJBLFNBQVNpcUMsb0JBQW9CbnVDO0lBRWYsSUFBUm91QyxVQUFVMS9CLHdCQUF3QjFPO0lBQ3RDb3VDLFVBQVVBO0lBQ1ZwdUMsT0FBT0wsd0JBQXdCeXVDO0lBRS9CO0tBQUlOLGFBQWFHLGtCQUFrQmp1QztLQUMvQnF1QyxjQUFjSCxrQkFBa0JKO0lBRXBDLFdBQVdPLGFBQWFQO0dBQzFCO0dBS0EsU0FBU1EsbUJBQW1CUixZQUMxQixPQUFPSSxrQkFBa0JKO0dBQzNCO0dBdEZBLFNBQVNTLG1CQUFtQm5zQixNQUMxQmlsQix1QkFDRjtHQXZPQSxTQUFTbUgseUJBQ1AsT0FBTyxJQUFLOUIsd0JBQ2Q7R0F5TkEsU0FBUytCLGlCQUFpQnJzQjtJQUN4QixHQUFHM2hCLHNCQUFzQkE7S0FBMEIsT0FDMUNBO0lBRVQ0bUM7R0FDRjtHQW5OQSxTQUFTcUgsaUJBQWtCM3ZDO0lBQ3pCO0tBQUlXLFFBQVFndEMsS0FBTTN0QztLQUNkNHZDLFFBQVFqdkM7S0FDUmt2QyxlQUFlLElBQUtsQyxLQUFLQSxTQUFTaHRDO0tBQ2xDbXZDLE1BQU03eUMsWUFBWTJ5QyxRQUFRQztJQUM5QjtZQUFnQmx2QztZQUFtQkE7WUFBbUJBO1lBQ3pDQTtZQUFnQkE7WUFBaUJBO1lBQ2pDQTtZQUFlbXZDOztHQUU5QjtHQXNOQSxTQUFTQyxzQkFBc0Ixc0IsTUFDN0IsT0FBT25ULDRCQUNUO0dBeUZBLFNBQVM4L0IsZ0NBQWtDLFNBQVM7R0F2UXBELFNBQVNDLGlCQUFpQkM7SUFDeEIsR0FBR2hnQyxvQkFBcUI7S0FDZCxJQUFKaWdDLE1BQU1ocEM7S0FDVixPQUFPZ3BDLFdBQVdEOzs7S0FDYjtHQUdUO0dBN0NBLFNBQVNFLG9CQUFxQnB3QztJQUM1QjtLQUFJVyxRQUFRZ3RDLEtBQU0zdEM7S0FDZDR2QyxRQUFRanZDO0tBQ1JrdkMsZUFBZSxJQUFLbEMsS0FBS2h0QztLQUN6Qm12QyxNQUFNN3lDLFlBQVkyeUMsUUFBUUM7S0FDMUJRLFVBQVUxQyxLQUFLaHRDO0tBQ2YydkMsVUFBVTNDLEtBQUtodEM7S0FDZjR2QztPQUFvQnR6QyxTQUFTb3pDLHlCQUF5QkM7SUFDMUQ7WUFBZ0IzdkM7WUFBZ0JBO1lBQWdCQTtZQUNuQ0E7WUFBYUE7WUFBY0E7WUFDM0JBO1lBQVltdkM7WUFDWG52Qyx3QkFBd0I0dkM7R0FDeEM7R0F1R0EsU0FBU0MsZ0JBQWdCeHRDO0lBQ2QsSUFBTHdCLE9BQU84TSxrQkFBa0J0TztJQUM3QixLQUFLd0IsbUJBQ0gyTTtJQUVGLE9BQU8zTSxrQkFBa0JBO0dBQzNCO0dBS0EsU0FBU2lzQyxtQkFBbUJ6dEM7SUFDcEIsSUFBRnRELElBQUk4d0MsZ0JBQWdCeHRDO0lBQ3hCdEQsT0FBT2swQixvQkFBb0JsMEI7SUFDM0IsT0FBT0E7R0FDVDtHQUtBLFNBQVNneEMsZ0JBQWdCMXRDLE1BQU11cUM7SUFDcEIsSUFBTC9vQyxPQUFPOE0sa0JBQWtCdE87SUFDN0IsS0FBS3dCLG1CQUNIMk07SUFFRixPQUFPM00sa0JBQWtCQSxXQUFXK29DO0dBQ3RDO0dBNUhBLFNBQVNvRCxpQkFBaUJDO0lBQ3hCO0tBQUlqd0MsSUFBSSxJQUFLZ3RDLEtBQUtpRCxjQUFXQSxPQUFNQSxPQUFNQSxPQUFNQSxPQUFNQTtLQUNqRDV3QyxJQUFJL0MsV0FBVzBEO0tBQ2Zrd0MsTUFBTVQsb0JBQW9CcHdDO0lBQzlCLFdBQWVBLEdBQUU2d0M7R0FDbkI7R0FxSkEsU0FBU0MsbUJBQW1COXRDO0lBQ2pCLElBQUx3QixPQUFPOE0sa0JBQWtCdE87SUFDN0IsS0FBS3dCO0tBQ0gyTTtJQUVGLE9BQU8zTSxxQkFBcUJBO0dBQzlCO0dBb0ZBLFNBQVN1c0Msb0JBQW9CaEM7SUFDM0JELG1CQUFtQkM7SUFDQSxJQUFmaUMsaUJBQWlCOUIsa0JBQWtCSDtJQUN2Q0EscUJBQXFCaUM7SUFDckI7R0FDRjtHQXhIQSxTQUFTQyxnQkFBZ0JqdUM7SUFDZCxJQUFMd0IsT0FBTzhNLGtCQUFrQnRPO0lBQzdCLEtBQUt3QixtQkFDSDJNO0lBRUYsT0FBTzNNLGtCQUFrQkE7R0FDM0I7R0EvSEEsU0FBUzBzQyxvQkFBcUI7R0FzRTlCLFNBQVNDLGVBQWVudUM7SUFDYixJQUFMd0IsT0FBTzhNLGtCQUFrQnRPO0lBQzdCLEtBQUt3QixrQkFDSDJNO0lBRUYsT0FBTzNNLGlCQUFpQkE7R0FDMUI7R0FLQSxTQUFTNHNDLGtCQUFrQnB1QztJQUNuQixJQUFGdEQsSUFBSXl4QyxlQUFlbnVDO0lBQ3ZCdEQsT0FBT2swQixvQkFBb0JsMEI7SUFDM0IsT0FBT0E7R0FDVDtHQStDQSxTQUFTMnhDLGtCQUFrQnhwQyxRQUFRcEMsS0FBSytSO0lBQ3RDLElBQUk4NUIsV0FBV2hnQyxrQkFBa0I3TCxNQUM3QjhyQyxXQUFXamdDLGtCQUFrQmtHO0lBQ2pDLEdBQUc4NUIsbUJBQW1CQztLQUNwQnBnQzs7SUFDRixLQUFLbWdDO0tBQ0huZ0M7SUFFRixPQUFPbWdDLHdCQUF3QnpwQyxRQUFReXBDLGVBQWVDO0dBQ3hEO0dBekxBLFNBQVNDLGlCQUNQLE9BQU92MEMsV0FBV3d5QywwQkFDcEI7R0F1TUEsU0FBU2dDLGlCQUFpQnp1QztJQUNmLElBQUx3QixPQUFPOE0sa0JBQWtCdE87SUFDN0IsS0FBS3dCO0tBQ0gyTTtJQUVGLE9BQU8zTSxtQkFBbUJBO0dBQzVCO0dNekRBLFNBQVNrdEMsYUFBYTF1QztJQUNwQjtLQUFJL0IsT0FBTzhQLGVBQWUvTjtLQUN0QkEsT0FBTzZOLG9CQUFvQjVQO0tBQzNCb3dCO0lBQ0osSUFBVSxJQUFGMTBCLE9BQU9BLElBQUkwVSx5QkFBeUIxVTtLQUMxQyxHQUFHMFUsaUJBQWlCMVUsV0FBV3FHLE1BQU1xdUIsTUFBTTEwQjtJQUM3QyxHQUFHMDBCLFdBQVVoZ0Isd0JBQXdCZ2dCO0lBQ3JDO0dBQ0Y7R1dySkEsU0FBU3NnQixrQkFBbUJ4MEMsR0FBR29KO0lBQzdCLEdBQUlBLE1BQVEsQ0FBRXBKLFFBQVFvSixPQUFPO0lBQzdCLFVBQVdBLGlCQUFpQixDQUFFcEosUUFBUW9KLEdBQUc7SUFDbkMsSUFBRjVKLElBQUk0SjtJQUFVLE1BQU81SixLQUFLUSxFQUFFUixLQUFLNEosRUFBRTVKO0lBQUk7R0FDN0M7R1U2REEsU0FBU2kxQyxjQUFjejBDLEdBQUdSLEdBQUd5RDtJQUMzQixHQUFHQSxRQUFRMmtCLG9CQUFvQjVuQixHQUFFUixTQUM1QmtvQixrQkFBa0IxbkIsR0FBRVIsR0FBRXlEO0lBQzNCO0dBQ0Y7R3ZCNENBLFNBQVN5eEMsb0JBQW9CN2xDO0lBQ047S0FDbkIsR0FBR0EsYUFBYXBPLE9BQU8sT0FBT29PO0tBQzlCLElBQUlqSztLQUVKO09BQUdMLHlCQUNHc0ssYUFBYXRLO1VBQ2JzSztVQUNBQTtNQUNKakssTUFBTUY7O09BRUFILDRCQUNGc0ssYUFBYXRLO1VBQ2JzSztVQUNBQTtNQUNKakssTUFBTUY7YUFFQW1LLGFBQWF0SyxvQkFBb0JKO01BQ3ZDUyxVQUFTVCw2QkFBNEIwSzs7TUFHckNqSyxVQUFTRiwwQkFBeUJqQix3QkFBeUI5RCxPQUFPa1A7S0FFcEUsR0FBSUEsYUFBYXRLLGtCQUNmSyxlQUFlaUs7S0FDakIsT0FBT2pLOztHQUdYO0cyQjNGQSxTQUFTK3ZDLDJCQUEyQnp1QjtJQUNsQyxVQUFVM2hCO0tBQ1IsSUFBTSxXQUFXQSxpQ0FBbUNzSztJQUV0RCxVQUFVdEsseUNBQTBDO0tBQ2xELElBQU0sV0FBV0Esa0RBQW1Ec0s7S0FDcEUsSUFBTSxXQUFXdEssa0RBQW1Ec0s7S0FDcEUsSUFBTSxXQUFXdEsscURBQXNEc0s7O0lBRXpFbUY7R0FDRjtHckJxUkEsU0FBUzRnQyxtQkFBbUJsL0IsTUFBTUMsTUFBTUUsTUFBTUM7SUFDNUMsR0FBR0osVUFBVUMsUUFBUUUsVUFBVUMsT0FBTztJQUN0QyxHQUFHSixVQUFVQyxRQUFRRSxVQUFVQyxPQUFPO0lBQ3RDO0dBQ0Y7R0FJQSxTQUFTKytCLFlBQVluL0IsTUFBTUMsTUFBTUMsTUFBTUMsTUFBTUMsTUFBTUM7SUFDakQ7S0FBSXhXLElBQUlvMEIsZUFBZWplLE1BQU1DLE1BQU1DO0tBQy9CaFQsSUFBSSt3QixlQUFlOWQsTUFBTUMsTUFBTUM7SUFDbkMsR0FBR3hXLElBQUlxRCxHQUFHO0lBQ1YsR0FBR3JELElBQUlxRCxHQUFHO0lBQ1YsSUFBVSxJQUFGcEQsSUFBSW9XLFVBQVVwVyxRQUFRQSxJQUFLO0tBQ2pDLEdBQUtrVyxVQUFVQyxPQUFLblcsV0FBYXFXLFVBQVVDLE9BQUt0VyxVQUFXO0tBQzNELEdBQUtrVyxVQUFVQyxPQUFLblcsV0FBYXFXLFVBQVVDLE9BQUt0VyxVQUFXOztJQUU3RDtHQUNGO0dBSUEsU0FBU3MxQyxpQkFBaUJwL0IsTUFBS0c7SUFDN0IsT0FBT2cvQixZQUFZbi9CLFNBQU9BLGtCQUFpQkcsU0FBT0E7R0FDcEQ7R0FuTkEsU0FBU2svQixlQUFlei9CLEtBQUsxSixLQUFLbk07SUFDaEMsSUFBVSxJQUFGRCxPQUFPQSxJQUFJQyxLQUFLRDtLQUN0QjhWLFNBQVMxSixNQUFJcE0sb0JBQW1COFYsU0FBUzFKLE1BQUlwTTtHQUVqRDtHQTNIQSxTQUFTdzFDLFdBQVduakM7SUFDVixJQUFKclIsVUFBVStJLE1BQU1zSTtJQUNwQixJQUFVLElBQUZyUyxPQUFPQSxJQUFJcVMsTUFBTXJTLEtBQ3ZCZ0IsU0FBU2hCO0lBRVgsT0FBT2dCO0dBQ1Q7R0F5SEEsU0FBU3kwQyxTQUFTMy9CLEtBQUsxSixLQUFLbk0sS0FBSzhWO0lBQ3BCLElBQVAyL0IsU0FBVTMvQjtJQUNkLElBQVUsSUFBRi9WLE9BQU9BLElBQUlDLEtBQUtELElBQUs7S0FDckIsSUFBRlEsS0FBS3NWLFNBQVMxSixNQUFJcE0sWUFBVzAxQztLQUNqQzUvQixTQUFTMUosTUFBSXBNLEtBQUtRO0tBQ2xCLEdBQUlBLE9BQVEsQ0FDVmsxQyxZQUNBLGFBRUFBOztJQUdKLE9BQVFBO0dBQ1Y7R0FnT0EsU0FBU0MsZ0JBQWdCbjVCLFFBQVFDO0lBQy9CLElBQUl4YyxNQUFNdWMsa0JBQ04xRyxVQUFVL0wsTUFBTTlKO0lBQ3BCLElBQVUsSUFBRkQsT0FBT0EsSUFBSUMsS0FBS0QsS0FDdEI4VixTQUFTOVYsS0FBS3djO0lBRWhCQyxRQUFReGM7SUFDUixPQUFPNlY7R0FDVDtHQWxKQSxTQUFTOC9CLFdBQVc3MUMsR0FBR3FELEdBQUdFO0lBQ3hCO0tBQUk5QyxJQUFJVCxhQUFhcUQ7S0FDakJ3RyxJQUFJdEosV0FBV0UsSUFBRThDO0tBQ2pCMmtCLElBQUt6bkIsSUFBSThDO0tBQ1RnVSxJQUFJMlEsS0FBSzdrQjtJQUNiLFFBQVF3RyxJQUFJdEosV0FBV2dYLElBQUVoVSxJQUFJZ1UsSUFBSWhVO0dBQ25DO0dBS0EsU0FBU3V5QyxjQUFjQyxNQUFNQyxNQUFNQyxNQUFNQyxNQUFNLy9CLE1BQU1DLE1BQU1sVyxLQUFLb1csTUFBTUM7SUFDNUQsSUFBSjQvQixNQUFPaGdDLFVBQVVDLE9BQUtsVztJQUcxQixJQUFVLElBQUZELElBQUlDLFNBQU9ELFFBQVFBLElBQUs7S0FDeEI7TUFBRlEsSUFBSW8xQyxXQUFXTSxLQUFNaGdDLFVBQVVDLE9BQUtuVyxVQUFZcVcsVUFBVUM7S0FDOUR3L0IsVUFBVUMsT0FBSy8xQyxLQUFLUTtLQUNwQjAxQyxNQUFNMTFDOztJQUVSdzFDLFVBQVVDLFFBQVFDO0lBQ2xCO0dBQ0Y7R0FqTUEsU0FBU0MsK0JBQStCcmdDLEtBQUsxSjtJQUMzQyxJQUFJck0sSUFBSStWLFNBQVMxSixNQUNiaEo7SUFDSixHQUFHckQsZUFBZ0IsQ0FBRXFELFNBQVFyRDtJQUM3QixHQUFHQSxXQUFnQixDQUFFcUQsUUFBUXJEO0lBQzdCLEdBQUdBLFNBQWdCLENBQUVxRCxRQUFRckQ7SUFDN0IsR0FBR0EsT0FBZ0IsQ0FBRXFELFFBQVFyRDtJQUM3QixHQUFHQSxNQUFnQixDQUFFcUQsUUFBUXJEO0lBQzdCLEdBQUdBLE9BQWtCcUQ7SUFDckIsWUFBWUE7R0FDZDtHQWdKQSxTQUFTZ3pDLGVBQWVsZ0MsTUFBTUMsTUFBTUMsTUFBTUMsTUFBTUMsTUFBTSsvQjtJQUNwRCxHQUFHQSxXQUFZLENBQ2JoZ0MsVUFBVUMsV0FDVjtJQUVPLElBQUxnZ0M7SUFDSixJQUFVLElBQUZ0MkMsT0FBT0EsSUFBSW9XLE1BQU1wVyxJQUFLO0tBQ3RCLElBQUZELElBQUttVyxVQUFVQyxPQUFLblc7S0FDeEJrVyxVQUFVQyxPQUFLblcsS0FBTUQsS0FBS3MyQyxRQUFTQztLQUNuQ0EsT0FBT3YyQyxXQUFZczJDOztJQUVyQmhnQyxVQUFVQyxRQUFRZ2dDO0lBQ2xCO0dBQ0Y7R0FvRUEsU0FBU0MsZ0JBQWdCcmdDLE1BQU1DLE1BQU1DLE1BQU1DLE1BQU1DLE1BQU0rL0I7SUFDckQsR0FBR0EsV0FBWSxDQUNiaGdDLFVBQVVDLFdBQ1Y7SUFFTyxJQUFMZ2dDO0lBQ0osSUFBVSxJQUFGdDJDLElBQUlvVyxVQUFRcFcsUUFBUUEsSUFBSztLQUN6QixJQUFGRCxJQUFJbVcsVUFBVUMsT0FBS25XO0tBQ3ZCa1csVUFBVUMsT0FBS25XLEtBQU1ELE1BQU1zMkMsUUFBU0M7S0FDcENBLE9BQU92MkMsVUFBV3MyQzs7SUFFcEJoZ0MsVUFBVUMsUUFBUWdnQztJQUNsQjtHQUNGO0dBdFNBLFNBQVNFLGdCQUFnQjFnQyxLQUFLMUosS0FBS25NO0lBQ2pDLElBQVUsSUFBRkQsT0FBT0EsSUFBSUMsS0FBS0QsS0FDdEI4VixTQUFTMUosTUFBSXBNO0lBRWY7R0FDRjtHQXBCQSxTQUFTeTJDLGFBQWF6ekMsR0FDcEIsV0FBVytHLE1BQU0vRyxHQUNuQjtHQXdLQSxTQUFTMHpDLGVBQWV4Z0MsTUFBTUMsTUFBTUMsTUFBTUMsTUFBTUMsTUFBTUMsTUFBTW9nQyxNQUFNQztJQUNoRSxJQUFJNWdDLFdBQ0FqVyxJQUFLNDJDLFVBQVVDO0lBQ25CLElBQVUsSUFBRjUyQyxPQUFPQSxJQUFJdVcsTUFBTXZXLElBQUs7S0FDNUI7TUFBSTgrQjtTQUFNNW9CLFVBQVVDLE9BQUtuVztXQUFhcVcsVUFBVUMsT0FBS3RXLGFBQWFEO1VBQWtCaVc7TUFDaEY2Z0MsTUFBTXhnQyxVQUFVQyxPQUFLdFcsYUFBYUQ7S0FDdENpVyxRQUFRMVYsV0FBV3UyQztLQUNaLElBQUhDLEtBQUtoWSxLQUFNK1g7S0FDZjNnQyxVQUFVQyxPQUFLblcsS0FBSzgyQztLQUNwQjlnQyxTQUFTMVYsV0FBV3cyQzs7SUFHdEIsT0FBR3ZnQyxPQUFPSCxRQUFRSjtjQUNUQztlQUFRQyxNQUFNQyxPQUFLSSxNQUFNSCxPQUFLRyxNQUFNa2dDLGNBQWN6Z0M7Y0FFbERBO0dBRVg7R0FuQ0EsU0FBUytnQyxRQUFRN2dDLE1BQU1DLE1BQU1DLE1BQU1DLE1BQU1DLE1BQU1DLE1BQU1SO0lBQ3hDLElBQVAyL0IsU0FBVTMvQjtJQUNkLElBQVUsSUFBRi9WLE9BQU9BLElBQUl1VyxNQUFNdlcsSUFBSztLQUN0QjtNQUFGUSxLQUFLMFYsVUFBVUMsT0FBS25XLGFBQWFxVyxVQUFVQyxPQUFLdFcsWUFBWTAxQztLQUNoRXgvQixVQUFVQyxPQUFLblcsS0FBS1E7S0FDcEIsR0FBSUEsUUFDRmsxQyxpQkFFQUE7O0lBR0osT0FBT0QsU0FBU3YvQixNQUFNQyxPQUFLSSxNQUFNSCxPQUFLRyxNQUFPbS9CO0dBQy9DO0dBaUdBLFNBQVNzQixRQUFROWdDLE1BQU1DLE1BQU1DLE1BQU1DLE1BQU1DLE1BQU1DO0lBQzdDLEdBQUdBLFVBQVc7S0FDWnMvQixjQUFjMy9CLE1BQU1DLFVBQVFELE1BQU1DLE1BQU1ELE1BQU1DLE1BQU1DLE1BQU1DLE1BQU1DO0tBQ2hFOztJQUdJLElBQUZqVyxJQUFJODFDLCtCQUErQjkvQixNQUFNQyxPQUFLQztJQUNsRDYvQixlQUFlLy9CLE1BQU1DLE1BQU1DLE1BQU1rZ0Msc0JBQXNCcDJDO0lBQ3ZEKzFDLGVBQWVsZ0MsTUFBTUMsTUFBTUMsTUFBTXFnQyxzQkFBc0JwMkM7SUFFdkQsSUFBSTJELEtBQUtxUyxVQUFVQyxPQUFLQyxzQkFDcEJ4VyxJQUFJeTFDLFdBQVdqL0I7SUFDbkIsSUFBVyxJQUFGdlcsSUFBSW9XLFVBQVVwVyxLQUFLdVcsTUFBTXZXLElBQUs7S0FFN0I7TUFBSmkzQztRQUFNanpDO1dBQW1Ca1MsVUFBVUMsT0FBS25XO1dBQVk0MUM7YUFBWTEvQixVQUFVQyxPQUFLblcsVUFBWWtXLFVBQVVDLE9BQUtuVyxjQUFZZ0U7O0tBQzFId3lDLGdCQUFnQnoyQyxNQUFNd1c7S0FDdEJtZ0MsZUFBZTMyQyxNQUFNd1csVUFBUUYsTUFBTUMsTUFBTUMsTUFBTWtnQyxjQUFjUTtLQUM3REYsUUFBUTdnQyxNQUFNQyxPQUFLblcsSUFBRXVXLE1BQU1BLFVBQVF4VyxNQUFNd1c7S0FFekM7TUFBT0wsVUFBVUMsT0FBS25XO1NBQVdxMUMsWUFBWW4vQixNQUFNQyxPQUFLblcsSUFBRXVXLE1BQU1BLE1BQU1GLE1BQU1DLE1BQU1DLFdBQVk7TUFDNUYwZ0MsTUFBTUE7TUFDTkYsUUFBUTdnQyxNQUFNQyxPQUFLblcsSUFBRXVXLE1BQU1BLFVBQVFGLE1BQU1DLE1BQU1DOztLQUdqREwsVUFBVUMsT0FBS25XLEtBQUtpM0M7O0lBR3RCVixnQkFBZ0JyZ0MsTUFBTUMsTUFBTUksTUFBTWtnQyxzQkFBc0JwMkM7SUFDeERrMkMsZ0JBQWdCbGdDLE1BQU1DLE1BQU1DLE1BQU1rZ0Msc0JBQXNCcDJDO0lBQ3hEO0dBQ0Y7R0FtRUEsU0FBUzYyQyxjQUFjejNCLFFBQVEzSixLQUFLMkc7SUFDMUIsSUFBSnhjLE1BQU02VjtJQUNWMkosaUJBQWlCeGY7SUFDakIsSUFBVSxJQUFGRCxPQUFPQSxJQUFJQyxLQUFLRCxLQUN0QnlmLGlCQUFpQjNKLFNBQVM5VjtJQUU1QnljLFFBQVF4YztJQUNSd2MsUUFBUXhjO0dBQ1Y7R0F0WkEsU0FBU2szQztJQUNQenlCO21CQUNrQml4QjtpQkFDRnVCO1lBQ0w5aUI7R0FFYjtHQTRHQSxTQUFTZ2pCLGFBQWF0aEMsS0FBSzFKLEtBQ3pCLEdBQUkwSixTQUFTMUosV0FBVyxVQUN4QixTQUNGO0dBU0EsU0FBU2lyQyxhQUFhdmhDLEtBQUsxSixLQUN6QixHQUFHMEosU0FBUzFKLFVBQVUsVUFDdEIsU0FDRjtHQVRBLFNBQVNrckMsY0FBY3hoQyxLQUFLMUo7SUFDMUIsR0FBRzBKLFNBQVMxSixXQUFXO0lBQ3ZCO0dBQ0Y7R0owSkEsU0FBU21yQyx3QkFBd0JseEMsTUFBS3ZDO0lBQ3BDLEdBQUdpQjtLQUNEQSw0QkFBNEJzQixNQUFLdkM7UUFDOUI7S0FDSCxLQUFJaUIsd0JBQXdCQTtLQUM1QkEsbUNBQWtDc0IsZUFBYXZDOztJQUVqRDtHQUNGO0dZbkdBLFNBQVMwekM7SUFDUGhqQztHQUNGO0dSK0xBLFNBQVNpakMsZUFBZXZoQyxNQUFNQyxNQUFNRSxNQUFNQyxNQUN4Q0osVUFBVUMsU0FBU0UsVUFBVUMsT0FDN0I7R0FDRjtHQTVWQSxTQUFTb2hDLFdBQVdsM0MsR0FDbEIsT0FBT0EsY0FDVDtHQTZWQSxTQUFTbTNDLGNBQWN6aEMsTUFBTUMsTUFBTUUsTUFBTUMsTUFDdkNKLFVBQVVDLFNBQVNFLFVBQVVDLE9BQzdCO0dBQ0Y7R0FHQSxTQUFTc2hDLGVBQWUxaEMsTUFBTUMsTUFBTUUsTUFBTUMsTUFDeENKLFVBQVVDLFNBQVNFLFVBQVVDLE9BQzdCO0dBQ0Y7R0V5NUJBLFNBQVN1aEMsY0FBY3JuQyxRQUFRMEksR0FBRzQrQixRQUFRQyxRQUFRQyxRQUFRQztJQUN4RHpuQyxnQkFBZ0IwSSxNQUFNQSxNQUFNNCtCLFFBQVFDLFFBQVFDLFFBQVFDO0lBQ3BEO0dBQ0Y7R0FHQSxTQUFTQyxpQkFBaUIxbkMsUUFBUTJuQyxJQUFJQyxJQUFJTjtJQUN4Q3RuQyxrQkFBa0IybkMsT0FBT0EsT0FBT0MsT0FBT0EsT0FBT047SUFDOUM7R0FDRjtHQVNBLFNBQVNPLDBCQUEwQjduQyxRQUFRMm5DLElBQUlDLElBQUlFO0lBQ2pEOW5DLDBCQUEwQjJuQyxPQUFPQSxPQUFPQyxPQUFPQSxPQUFPRSxPQUFPQTtJQUM3RDtHQUNGO0dBd0dBLFNBQVNDLGVBQWVDLFlBQVlDLE1BQU1DLFlBQVlDLE1BQU10bUM7SUFDMUQsSUFBSUosUUFBUUksU0FDUkgsU0FBU0c7SUFDYixLQUFLOEMsNkJBQTZCbEQsT0FBT0M7S0FDdkMxTDtJQUVGZ3lDO01BQTBCRTtNQUNBQztNQUFTQTtNQUFTMW1DO01BQU9DO01BQ3pCdW1DO01BQVNBO01BQVN4bUM7TUFBT0M7SUFDbkQ7R0FDRjtHQS9KQSxTQUFTMG1DLHFCQUFxQnBvQyxRQUM1QkEseUJBQ0EsU0FDRjtHQTZGQSxTQUFTcW9DLGVBQWVyb0MsUUFBUXNvQztJQUM5QixHQUFJQSxTQUNGdG9DLGtDQUVBQTtJQUVGO0dBQ0Y7R0FHQSxTQUFTdW9DLG9CQUFvQnZvQyxRQUFRbE0sTUFBTXcwQztJQUN6QyxHQUFJQTtLQUNGdG9DLGlCQUFpQmxNOztLQUVqQmtNLGlCQUFpQmxNO0lBRW5CO0dBQ0Y7R0EzR0EsU0FBUzAwQyxxQkFBcUJ4b0MsUUFDNUJBLHlCQUNBLFNBQ0Y7R0FyWUEsU0FBU3lvQyxpQkFBaUJ6b0MsUUFDeEIsU0FDRjtHQWhVQSxTQUFTMG9DLGtCQUFrQkMsU0FBU0M7SUFDbEMsR0FBSUQsYUFBYUM7S0FBWTtZQUVsQkQsYUFBYUMsWUFBWSxlQUU3QjtHQUdUO0dBcUpBLFNBQVNDLDJCQUEyQmhuQztJQUVsQzFDO0lBRUEsSUFBSXNDLFFBQVFJLFNBQ1JILFNBQVNHO0lBRWIsS0FBSzhDLDZCQUE2QmxELE9BQU9DO0tBQ3ZDMUw7SUFHRjtLQUFJb2QsT0FBT3JPO0tBRVAvRTtjQUNJcFE7ZUFDQ0E7Z0JBQ0NBO2lCQUNDdVM7Y0FDSEM7OztlQUVDWDtnQkFDQ0M7WUFDSjBSOzs7Ozs7S0FRRmpSLFVBQVV4QztJQUNkd0MsbUJBQW1CaVI7SUFDbkJqUixnQkFBZ0JWO0lBQ2hCVSxpQkFBaUJUO0lBQ2pCUztJQUNBQSxpQkFBaUJuQztJQUNqQkEsaUJBQWlCbUM7SUFFUixJQUFMQyxPQUFPRDtJQUNYQztJQUNBQTtJQUNBQTtJQUNBQTtJQUNBcEMsY0FBY29DO0lBRWQsT0FBT3BDO0dBQ1Q7R0FLQSxTQUFTOG9DLDJDQUEyQzl4QztJQUNsRG1JO0lBQ0E7S0FBSXNDLFFBQVErQyxZQUFZeE47S0FDcEIwSyxTQUFTOEMsWUFBWXhOO0tBQ3JCZ0osU0FBUzZvQywrQkFBK0JwbkMsT0FBT0M7SUFDbkQsR0FBSTFCLFdBQVdwUSxNQUFNLE9BQ1pBO0lBRVQ7S0FBSTBTLFVBQVV6QyxrQkFBa0I0RSx1QkFBdUJ6TjtLQUNuRHVMLFVBQVUxQyx5QkFBeUJ5QztJQUV2QyxJQUFXLElBQUY5UyxPQUFPQSxJQUFJOFMsWUFBWTlTLE9BQVE7S0FDdEMrUyxJQUFJL1MsU0FBTzhTLElBQUk5UztLQUNmK1MsSUFBSS9TLFNBQU84UyxJQUFJOVM7S0FDZitTLElBQUkvUyxTQUFPOFMsSUFBSTlTO0tBQ2YrUyxJQUFJL1MsU0FBTzhTLElBQUk5Uzs7SUFFakIsR0FBSXFRLHFCQUFxQnJMLFVBQVc7S0FDeEIsSUFBTjZOLFFBQVFyQyw0QkFBNEJ5QixPQUFPQztLQUMvQ1csZUFBZUU7OztLQUVMLElBQU5GLFlBQVl4QyxpQkFBaUIwQyxLQUFLZCxPQUFPQztJQUUvQzFCLHlCQUF5QnFDO0lBQ3pCLE9BQU9yQztHQUNUO0dBS0EsU0FBUytvQyxvQ0FBb0N6a0MsVUFBVTBrQztJQUNyRDdwQztJQUNRLElBQUorQyxNQUFNbUMsNkJBQTZCQztJQUN2QyxHQUFJcEMsUUFBUXRTLEtBQU07S0FDaEI2Rix1QkFBdUJ0QixxQ0FBcUNtUTtLQUM1RDs7SUFFRnBDO2VBQXNCK21DO09BQ1Q7UUFBUGpwQyxTQUFTNm9DLCtCQUErQjNtQyxjQUFjQTtPQUMxRCxHQUFJbEMsV0FBV3BRLE1BQU07T0FHckJvUSxzQkFBc0JrQztPQUN0QjhtQyxPQUFPaHBDO09BQ1A7TUFQVTtJQVNaO0dBQ0Y7R0FoTkEsU0FBU2twQztJQUEwQkM7SUFBWUM7SUFBV0M7SUFBWTFtQztJQUNuQ0M7SUFBVUM7SUFBT0M7SUFBT25JO0lBQVEvRDtJQUFLaUw7SUFFdEUxQztJQUVBLElBQUlzQyxRQUFRSSxTQUNSSCxTQUFTRztJQUNiLEtBQUs4Qyw2QkFBNkJsRCxPQUFPQztLQUN2QzFMO0lBR0Y7S0FBSVksTUFBTTJGLGFBQWEzRjtLQUNuQjVHLElBQUk0RztLQUNKd0MsSUFBSXhDO0tBRUp1eUMsYUFBYS9zQyxrQkFBa0Irc0M7S0FDL0JDO0tBQ0FDLGFBQWFqdEMsa0JBQWtCaXRDO0tBQy9CMW1DLFdBQVd2RyxrQkFBa0J1RztLQUM3QkMsV0FBV3hHLGtCQUFrQndHO0tBQzdCQyxRQUFRekcsa0JBQWtCeUc7S0FDMUJDLFFBQVF2RyxhQUFhdUcsT0FBT2xUO0tBQzVCK0ssU0FBUzRCLGFBQWE1QixRQUFRL0s7SUFDbEMrSyxTQUFTZ0Ysd0JBQXdCaEY7SUFDakMsR0FBR0EsVUFBVS9LLE1BQ1grSyxTQUFTZ0Y7SUFHWDtLQUFJeVQsT0FBT3JPO0tBRVAvRTtjQUNJOEM7Z0JBQ0VuSTtlQUNEL0s7Z0JBQ0NBO2lCQUNDQTtjQUNIQTtXQUNISTtXQUFNb0o7ZUFDRnFJO2dCQUNDQztZQUNKMFI7b0JBQ1ErMUI7b0JBQ0FFO2tCQUNGMW1DO2tCQUNBQztlQUNIQztLQUdMeW1DLGdCQUFpQkY7S0FFakJHLFFBQVE1cEM7SUFDWjRwQyxpQkFBaUJuMkI7SUFDakIsR0FBSWkyQixtQkFBb0I7S0FDdEJFO0tBQ0FBOztRQUNLO0tBQ0xBLG9CQUFvQjluQztLQUNwQjhuQyxxQkFBcUI3bkMsU0FBUzRuQzs7SUFFaENDO0lBQ0FBLGlDQUFtQyxhQUFiO0lBQ3RCQSxlQUFldnBDO0lBQ2ZBLGVBQWV1cEM7SUFDZjV1QyxtQkFBbUI0dUM7SUFFUixJQUFQN21DLFNBQVM5UztJQUNiLEdBQUl3NUMsbUJBQW9CO0tBQ3RCRztLQUNBN21DLFNBQVMvQztLQUNUK0Msa0JBQWtCMFE7S0FDbEIxUSxlQUFlakI7S0FDZmlCO0tBQ0FELG9CQUFvQkMsUUFBUUMsVUFBVUMsVUFBVUMsT0FBT0M7S0FDdkRKLHFCQUFxQnhDO0tBQ3JCd0MsZ0JBQWdCMUM7S0FDaEJBLGdCQUFnQjBDO0tBQ2hCNm1DLGtCQUFrQjdtQzs7SUFHUixJQUFSUCxVQUFVeEM7SUFDZHdDLG1CQUFtQmlSO0lBQ25CalIsZ0JBQWdCVjtJQUNoQlUsaUJBQWlCVDtJQUNqQlMsc0JBQXNCZ0Q7SUFDdEJoRCxpQkFBaUJuQztJQUNqQkEsaUJBQWlCbUM7SUFDakJvbkMsa0JBQWtCcG5DO0lBRWxCLEdBQUlrbkMsb0JBQXFCO0tBQ3ZCbG5DO0tBQ0FBO0tBQ0ErQyxnQkFBZ0IvQzs7SUFHVCxJQUFMQyxPQUFPRDtJQUNYQztJQUNBQTtJQUNBQTtJQUNBQTtJQUNBcEMsY0FBY29DO0lBR2RBLG9CQUFvQlgsT0FBT0M7SUFFM0IsT0FBTzFCO0dBQ1Q7R0F3bEJBLFNBQVN3cEM7SUFBa0J4cEMsUUFBUTBJLEdBQUc0K0IsUUFBUW1DLFVBQVVsQyxRQUFRQyxRQUFRQztJQUN0RXpuQztNQUFvQjBJLE1BQU1BLE1BQU00K0IsV0FBV0EsV0FDdkJtQyxVQUFVbEMsUUFBUUMsUUFBUUM7SUFDOUM7R0FDRjtHQXlNQSxTQUFTaUMscUJBQXFCMXBDLFFBQVFzRTtJQUNwQztLQUNXLElBQUx0TixPQUFPZ0o7S0FDWDJWLGlCQUFpQnJSLFVBQVV6RSxZQUFZN0k7O1VBQ2hDcEM7S0FDUGEsdUJBQXVCdEIsc0NBQXNDbVE7O0lBRS9EO0dBQ0Y7R0EzTUEsU0FBU3FsQyxlQUFlM3BDLFFBQVFzb0M7SUFDOUIsR0FBSUEsU0FDRnRvQyxrQ0FFQUE7SUFFRjtHQUNGO0dBR0EsU0FBUzRwQyxvQkFBb0I1cEMsUUFBUWxNLE1BQU13MEM7SUFDekMsR0FBSUE7S0FDRnRvQyxpQkFBaUJsTTs7S0FFakJrTSxpQkFBaUJsTTtJQUVuQjtHQUNGO0dBdUNBLFNBQVMrMUMsb0JBQW9CN3BDLFFBQVFwSixLQUFLaUw7SUFDeEM3QixxQkFBcUJwSixRQUFRQSxRQUFRaUwsU0FBU0E7SUFDOUM7R0FDRjtHQVdBLFNBQVNpb0Msb0JBQW9COXBDLFFBQVErcEMsTUFBTW56QztJQUN6Q29KLHFCQUFxQndDLHdCQUF3QnVuQyxPQUFPbnpDLFFBQVFBO0lBQzVEO0dBQ0Y7R0F5T0EsU0FBU296QyxxQkFBcUI1MkI7SUFDNUJqVTtJQUNZLElBQVJnRCxVQUFVeEMsOEJBQThCeVQ7SUFDNUMsR0FBSWpSLFlBQVl2UyxLQUFNLENBQ3BCdXJDLHdCQUNBO0lBRUYsT0FBT2g1QjtHQUNUO0dBS0EsU0FBUzhuQztJQUNQOXFDO0lBQ00sSUFBRk4sUUFBUWdCO0lBQ1osT0FBT2Qsb0JBQW9CRjtHQUM3QjtHQXJmQSxTQUFTcXJDLHlCQUF5QmxxQztJQUNoQyxjQUFXQTtjQUNGRyxjQUFjSDs7R0FJekI7R0F5Q0EsU0FBU21xQyx5QkFBeUJucUM7SUFDaEMsT0FBTzNPLGVBQWUyTztHQUN4QjtHQWpDQSxTQUFTb3FDLDJCQUEyQnBxQyxRQUNsQyxPQUFPQTtHQUNUO0dBbUNBLFNBQVNxcUMseUNBQXlDcnFDLFFBQ2hELE9BQU9wQyxXQUFXb0M7R0FDcEI7R0F4VEEsU0FBU3NxQyxpQkFBaUJ0cUMsUUFDeEIsT0FBT0EsVUFDVDtHQTRpQkEsU0FBU3VxQyx5QkFBeUJ2cUMsUUFBUXBKLEtBQUtpTDtJQUM3QyxJQUFJSixRQUFRSSxTQUNSSCxTQUFTRztJQUNiLEtBQUs4Qyw2QkFBNkJsRCxPQUFPQztLQUN2QzFMO0lBRUY7S0FBSXFNLFFBQVFyQyx5QkFBeUJwSixRQUFRQSxRQUFRNkssT0FBT0M7S0FDeERZLFVBQVV6QyxrQkFBa0J3QztLQUM1QkUsVUFBVTFDLGtCQUFrQnlDO0lBRWhDLElBQVcsSUFBRjlTLE9BQU9BLElBQUk4UyxZQUFZOVMsT0FBUTtLQUN0QytTLElBQUkvUyxTQUFPOFMsSUFBSTlTO0tBQ2YrUyxJQUFJL1MsU0FBTzhTLElBQUk5UztLQUNmK1MsSUFBSS9TLFNBQU84UyxJQUFJOVM7S0FDZitTLElBQUkvUyxTQUFPOFMsSUFBSTlTOztJQUVqQixPQUFPdVMsNkJBQ3VCTCxRQUFRRCxXQUFXYztHQUNuRDtHQXhhQSxTQUFTaW9DLHVCQUF1QnhxQyxRQUM5QixPQUFPdEMsYUFBYXNDO0dBQ3RCO0dBcUJBLFNBQVN5cUMsd0JBQXdCenFDO0lBQ3ZCLElBQUp4UCxNQUFNd1A7SUFDVnhQO0lBQ0EsT0FBT0E7R0FDVDtHQWZBLFNBQVNrNkMsK0JBQStCMXFDLFFBQ3RDLE9BQU9BO0dBQ1Q7R0F3QkEsU0FBUzJxQyx3QkFBd0IzcUMsUUFDL0IsT0FBTzNCLGNBQWMyQjtHQUN2QjtHQXBEQSxTQUFTNHFDLHlCQUF5QjVxQyxRQUNoQyxPQUFPQSxzQkFDVDtHQTREQSxTQUFTNnFDLDBCQUEwQjdxQyxRQUNqQyxPQUFPQSx1QkFDVDtHQTRVQSxTQUFTOHFDLG9CQUFvQjlxQyxRQUFRcEo7SUFDekIsSUFBTnlMLFFBQVFyQyx5QkFBeUJwSixRQUFRQTtJQUM3QyxPQUFTeUwsNEJBQ0FBO2FBQ0FBO2FBQ0FBO0dBQ1g7R0E5ZkEsU0FBUzBvQyx1QkFBdUIvcUM7SUFDOUIsT0FBSUEsaUJBQWlCcFEsV0FDUm9RLFVBQVVBO0dBSXpCO0dBeVNBLFNBQVNnckMsMEJBQTBCaHJDLFFBQ2pDLE9BQU9BLHVCQUNUO0dBZEEsU0FBU2lyQywyQkFBMkJqckM7SUFDbEMsT0FBT0csY0FBY0g7R0FDdkI7R0FxQkEsU0FBU2tyQyw0QkFBNEJsckMsUUFBUXJQO0lBQzNDLFdBQVdxUCwyQkFBMkJBO0dBQ3hDO0dBdlZBLFNBQVNtckMsbUJBQW1CbnJDO0lBQzFCLFdBQVdBLGNBQWNBO0dBQzNCO0dBK01BLFNBQVNvckMsMkJBQTJCcHJDO0lBQ2xDLGNBQVdBO2NBQ0ZHLGNBQWNIOztHQUl6QjtHQThCQSxTQUFTcXJDLDJCQUEyQnJyQztJQUNsQyxPQUFPM08sZUFBZTJPO0lBQ3RCO0dBQ0Y7R0FsbUJBLFNBQVNzckMsa0NBQWtDQyxVQUFVMXFCLE9BQU9qcUIsS0FDMUQyMEMsc0JBQXNCMzBDLEtBQUtrSCxjQUFjK2lCLFNBQ3pDO0dBQ0Y7R0FUQSxTQUFTMnFCLGdDQUFnQ0MsUUFBUUM7SUFDL0MsT0FBT2xyQyxtQ0FBbUNrckMsT0FBT0QsV0FBV0E7R0FDOUQ7R0FoQkEsU0FBU0UsaUNBQWlDNTZCLE1BQU1FO0lBQzlDLE9BQU96UTthQUFvQ3VRLFNBQVNBLFNBQ1RFLFNBQVNBO0dBQ3REO0dBSUEsU0FBUzI2QixpQ0FBaUNDLFNBQVNDLE1BQU1DLFNBQVNDO0lBQ2hFLE9BQU94ckM7YUFBb0NxckMsWUFBWUEsWUFBWUMsTUFDeEJDLFlBQVlBLFlBQVlDO0dBQ3JFO0dBa0NBLFNBQVNDLGVBQWVqc0M7SUFDYixJQUFMa3NDLE9BQU8vM0M7SUFDWCxPQUFPKzNDLEtBQUtsc0M7R0FDZDtHQTlOQSxTQUFTbXNDLDBCQUEwQkMsVUFBVW5FLE1BQU1vRSxVQUFVbEUsTUFBTXRtQztJQUNqRSxJQUFJSixRQUFRSSxTQUNSSCxTQUFTRztJQUNiLEtBQUs4Qyw2QkFBNkJsRCxPQUFPQztLQUN2QzFMO0lBRUY7S0FBSWlMLFNBQVN1RCxZQUFZNG5DO0tBQ3JCbHJDLFVBQVVzRCxZQUFZNG5DO0tBQ3RCL3FDLFNBQVNtRCxZQUFZNm5DO0tBQ3JCL3FDLFVBQVVrRCxZQUFZNm5DO0tBQ3RCQztPQUNGdHJDO1NBQTRCQztTQUFRQztTQUFTK21DO1NBQVNBO1NBQzFCNW1DO1NBQVFDO1NBQVM2bUM7U0FBU0E7U0FDMUIxbUM7U0FBT0M7S0FDakNQLEtBQUttckM7S0FDTGxyQyxLQUFLa3JDO0tBQ0wvcUMsS0FBSytxQztLQUNMOXFDLEtBQUs4cUM7S0FDTDdxQyxRQUFRNnFDO0tBQ1I1cUMsU0FBUzRxQztJQUNiLEdBQUs3cUMsYUFBZUMsV0FBYTtLQUMvQjtNQUFJYSxVQUFVMUMsbUJBQW1CNEUsdUJBQXVCMm5DO01BQ3BEOXBDLFVBQVV6QyxtQkFBbUI0RSx1QkFBdUI0bkM7S0FDeEQsSUFBVyxJQUFGanpDLE9BQU9BLElBQUlzSSxVQUFVdEk7TUFBRyxJQUNwQixJQUFGcEosT0FBT0EsSUFBSXlSLFNBQVN6UjtPQUMzQnVTLEtBQUtuQixLQUFLaEksS0FBSzZILFVBQVVFLEtBQUtuUixNQUM1QnNTLEtBQUtkLEtBQUtwSSxLQUFLaUksVUFBVUUsS0FBS3ZSOztJQUl0QztHQUNGO0dBcEhBLFNBQVN1OEMscUNBQXFDam9DLFVBQVUwa0M7SUFDdEQ3cEM7SUFDUSxJQUFKK0MsTUFBTW1DLDZCQUE2QkM7SUFDdkMsR0FBSXBDLFFBQVF0UyxLQUFNO0tBQ2hCNkYsdUJBQXVCdEIscUNBQXFDbVE7S0FDNUQ7O0lBRUZwQztlQUFzQittQztPQUNiLElBQUg5NEMsS0FBSzhSLHFCQUFxQkM7T0FDOUI4bUMsT0FBTzc0QztPQUNQO01BSFU7SUFLWjtHQUNGO0dBcUpBLFNBQVNxOEMsZ0NBQWdDeDFDLE1BQU1zTjtJQUM3Q25GO0lBQ0E7S0FDYyxJQUFSZ0QsVUFBVXVDLHlCQUF5QjFOO0tBQ3ZDLEdBQUltTCxZQUFZdlMsS0FBTTtNQUNYLElBQUxvSCxPQUFPbUw7TUFDWHdULGlCQUFpQnJSLFVBQVV6RSxZQUFZN0k7OztVQUVsQ3BDO0tBQ1BhLHVCQUF1QnRCLHNDQUFzQ21ROztJQUUvRDtHQUNGO0dBdkpBLFNBQVNtb0MsMEJBQTBCejFDLE1BQU02cEI7SUFDaEMsSUFBSDNhLFNBQVNyRyxtQkFBbUI0RSx1QkFBdUJ6TjtJQUN2RCxJQUFXLElBQUZ4SCxPQUFPQSxJQUFJMFcsV0FBVzFXLEtBQzdCMFcsR0FBRzFXLEtBQUtxeEI7SUFFVjtHQUNGO0dBMkZBLFNBQVM2ckIsK0JBQStCMTFDLE1BQU1KO0lBQ3JDLElBQUhzUCxTQUFTckcsbUJBQW1CNEUsdUJBQXVCek47SUFDdkQsT0FBT2tQLEdBQUd0UCxTQUFTNE4sWUFBWXhOLFdBQVdKO0dBQzVDO0dBMUdBLFNBQVMrMUMsOEJBQThCMzFDO0lBQ3JDLFdBQVd3TixZQUFZeE4sVUFBVXdOLFlBQVl4TjtHQUMvQztHQXFIQSxTQUFTNDFDLGdDQUFnQzUxQyxNQUFNSixLQUFLME4sVUFBVTBrQztJQUM1RDdwQztJQUNBO0tBQUkrQyxNQUFNbUMsNkJBQTZCQztLQUNuQ25DLFVBQVV1Qyx5QkFBeUIxTjtJQUN2QyxHQUFLa0wsUUFBUXRTLFFBQVV1UyxZQUFZdlMsS0FBTztLQUN4QzZGLHVCQUF1QnRCLHFDQUFxQ21RO0tBQzVEOztJQUVGcEM7ZUFBc0IrbUM7T0FDWCxJQUFMN21DLE9BQU9EO09BQ1hDLGVBQWVGLFFBQVF0TCxRQUFRQTtPQUMvQjtRQUFJeUwsUUFBUUQsd0JBQXdCRCxlQUFlQTtRQUMvQ0csVUFBVXpDLGtCQUFrQndDO1FBQzVCRSxNQUFNa0MsdUJBQXVCek47T0FDakMsSUFBVyxJQUFGeEgsT0FBT0EsSUFBSStTLFlBQVkvUyxLQUM5QitTLElBQUkvUyxLQUFLOFMsSUFBSTlTO09BRWZ3NUMsT0FBT2h5QztPQUNQO01BVlU7SUFZWjtHQUNGO0dBOUJBLFNBQVM2MUMsK0JBQStCNzFDLE1BQU1KLEtBQUtpcUI7SUFDMUMsSUFBSDNhLFNBQVNyRyxtQkFBbUI0RSx1QkFBdUJ6TjtJQUN2RGtQLEdBQUd0UCxTQUFTNE4sWUFBWXhOLFdBQVdKLFVBQVVpcUI7SUFDN0M7R0FDRjtHQW5GQSxTQUFTaXNCLHlCQUF5QlQsVUFBVWxFLE1BQU10bUM7SUFDaEQsSUFBSVosU0FBU1ksU0FDVFgsVUFBVVc7SUFDZCxLQUFLOEMsNkJBQTZCMUQsUUFBUUM7S0FDeENsTDtJQUVGO0tBQUlxTCxTQUFTbUQsWUFBWTZuQztLQUNyQi9xQyxVQUFVa0QsWUFBWTZuQztLQUN0Qm5tQyxTQUFTckcsa0JBQWtCb0IsU0FBU0M7S0FDcENrckMsV0FBV3JxQyw2QkFDdUJiLFNBQVNELFlBQVlpRjtLQUN2RG9tQztPQUNGdHJDO1NBQTRCQztTQUFRQzs7O1NBQ1JHO1NBQVFDO1NBQVM2bUM7U0FBU0E7U0FDMUJsbkM7U0FBUUM7S0FDbENDLEtBQUttckM7S0FDTGxyQyxLQUFLa3JDO0tBQ0wvcUMsS0FBSytxQztLQUNMOXFDLEtBQUs4cUM7S0FDTDdxQyxRQUFRNnFDO0tBQ1I1cUMsU0FBUzRxQztJQUNiLEdBQUs3cUMsYUFBZUMsV0FBYTtLQUMvQjtNQUFJYSxVQUFVMUMsbUJBQW1CNEUsdUJBQXVCMm5DO01BQ3BEOXBDLFVBQVV6QyxtQkFBbUI0RSx1QkFBdUI0bkM7S0FDeEQsSUFBVyxJQUFGanpDLE9BQU9BLElBQUlzSSxVQUFVdEk7TUFBRyxJQUNwQixJQUFGcEosT0FBT0EsSUFBSXlSLFNBQVN6UjtPQUMzQnVTLEtBQUtuQixLQUFLaEksS0FBSzZILFVBQVVFLEtBQUtuUixNQUM1QnNTLEtBQUtkLEtBQUtwSSxLQUFLaUksVUFBVUUsS0FBS3ZSOztJQUl0QyxPQUFPbzhDO0dBQ1Q7R0FpcENBLFNBQVNXLHFCQUFxQi9zQyxRQUFRcEosS0FBSzBOLFVBQVUwa0M7SUFFM0MsSUFBSjltQyxNQUFNbUMsNkJBQTZCQztJQUN2QyxHQUFJcEMsUUFBUXRTLEtBQU07S0FDaEI2Rix1QkFBdUJ0QixxQ0FBcUNtUTtLQUM1RDs7SUFFRnBDO2VBQXNCK21DO09BQ3BCanBDLHNCQUFzQmtDLFFBQVF0TCxRQUFRQTtPQUV0Q295QyxPQUFPaHBDO09BQ1A7TUFKVTtJQU1aO0dBQ0Y7R0F1Q0EsU0FBU2d0QztJQUNQLEdBQUk5dEMsaUNBQWlDO0lBR3JDUyxxQ0FBcUNtQjtJQUNyQ25CLG1DQUFtQ29CO0lBQ25DcEIscUNBQXFDeUY7SUFDckN6Rix1Q0FBdUNpRjtJQUN2Qy9FLDZCQUE2Qkw7SUFDN0JOO0lBQ0E7R0FDRjtHQTlCQSxTQUFTK3RDLHFCQUFxQjc2QyxTQUM1QixPQUFPRCxhQUFhQyxTQUN0QjtHQUtBLFNBQVM4NkMscUJBQXFCOTZDO0lBQzVCNEQ7SUFDQSxPQUFPdUksYUFBYW5NO0dBQ3RCO0dBM1FBLFNBQVMrNkMsa0JBQWtCbnRDLFFBQVEwSTtJQUNqQzFJLG1CQUFtQjBJLE1BQU1BO0lBQ3pCO0dBQ0Y7R0FUQSxTQUFTMGtDLGtCQUFrQnB0QyxRQUFRMEk7SUFDakMxSSxtQkFBbUIwSSxNQUFNQTtJQUN6QjtHQUNGO0dBN3dCQSxTQUFTMmtDLG1CQUFtQkMsT0FBT0MsT0FDakNELGNBQWNDLFFBQ2QsU0FDRjtHQUdBLFNBQVNDLCtCQUErQkYsT0FBT0MsT0FBTzE2QztJQUM5QyxJQUFGa0YsUUFBUThILHVCQUF1QmhOLE1BQU1BLE1BQU1BLE1BQU1BLE1BQU1BO0lBQzNEeTZDLGNBQWNDLE9BQU94MUM7SUFDckI7R0FDRjtHQWhEQSxTQUFTMDFDLG1CQUFtQjM1QyxNQUFNNFUsR0FBRzQrQixRQUFRQyxRQUFRQyxRQUFRQyxLQUMzRDN6QyxTQUFTNFUsTUFBTUEsTUFBTTQrQixRQUFRQyxRQUFRQyxRQUFRQyxNQUM3QztHQUNGO0dBR0EsU0FBU2lHLHNCQUFzQjU1QyxNQUFNNnpDLElBQUlDLElBQUlOO0lBQzNDeHpDLFdBQVc2ekMsT0FBT0EsT0FBT0MsT0FBT0EsT0FBT047SUFDdkM7R0FDRjtHQVNBLFNBQVNxRywrQkFBK0I3NUMsTUFBTTg1QyxLQUFLQyxLQUFLbmxDO0lBQ3RENVUsbUJBQW1CODVDLFFBQVFBLFFBQVFDLFFBQVFBLFFBQVFubEMsTUFBTUE7SUFDekQ7R0FDRjtHQXZDQSxTQUFTb2xDLHFCQUFxQmg2QyxNQUM1QkEsa0JBQ0EsU0FDRjtHQVJBLFNBQVNpNkMsd0JBQ1AsV0FBV2x1QyxnQkFDYjtHQW1EQSxTQUFTbXVDO0lBQXVCbDZDLE1BQU00VSxHQUFHNCtCLFFBQVFtQyxVQUNqQmxDLFFBQVFDLFFBQVFDO0lBQzlDM3pDO01BQWE0VSxNQUFNQSxNQUFNNCtCLFdBQVdBLFdBQ3ZCbUMsVUFBVWxDLFFBQVFDLFFBQVFDO0lBQ3ZDO0dBQ0Y7R0F6Q0EsU0FBU3dHLHVCQUF1Qm42QyxNQUFNNFUsR0FDcEM1VSxZQUFZNFUsTUFBTUEsT0FDbEI7R0FDRjtHQVRBLFNBQVN3bEMsdUJBQXVCcDZDLE1BQU00VSxHQUNwQzVVLFlBQVk0VSxNQUFNQSxPQUNsQjtHQUNGO0dBcUJBLFNBQVN5bEMsa0NBQWtDcjZDLE1BQU1zNkMsSUFBSTFsQztJQUNuRDVVLHNCQUFzQnM2QyxPQUFPQSxPQUFPMWxDLE1BQU1BO0lBQzFDO0dBQ0Y7R0FTQSxTQUFTMmxDLG9CQUFvQnY2QyxNQUFNOEMsS0FBS2lMO0lBQ3RDL04sVUFBVThDLFFBQVFBLFFBQVFpTCxTQUFTQTtJQUNuQztHQUNGO0dBNERBLFNBQVN5c0MseUJBQXlCanNDLE9BQU96RjtJQUMxQixJQUFUMnhDLFdBQVc3cEMseUJBQXlCckM7SUFDeEMsT0FBTzdCLDZCQUE2Qit0QyxVQUFVNXhDLFdBQVdDO0dBQzNEO0dBNDVCQSxTQUFTNHhDLHlCQUF5Qnh1QyxRQUFRaW9DLE1BQU1qeEMsTUFBTW14QyxNQUFNdG1DO0lBQzFELElBQUlKLFFBQVFJLFNBQ1JILFNBQVNHO0lBQ2IsS0FBSzhDLDZCQUE2QmxELE9BQU9DO0tBQ3ZDMUw7SUFFRjtLQUFJc00sVUFBVXpDLGtCQUFrQjRFLHVCQUF1QnpOO0tBQ25EdUwsVUFBVTFDLHlCQUF5QnlDO0lBRXZDLElBQVcsSUFBRjlTLE9BQU9BLElBQUk4UyxZQUFZOVMsT0FBUTtLQUN0QytTLElBQUkvUyxTQUFPOFMsSUFBSTlTO0tBQ2YrUyxJQUFJL1MsU0FBTzhTLElBQUk5UztLQUNmK1MsSUFBSS9TLFNBQU84UyxJQUFJOVM7S0FDZitTLElBQUkvUyxTQUFPOFMsSUFBSTlTOztJQUVqQixHQUFJcVEscUJBQXFCckwsVUFBVztLQUN4QjtNQUFONk47UUFDRnJDO1VBQTRCd0UsWUFBWXhOLFVBQVV3TixZQUFZeE47S0FDaEVxTCxlQUFlRTs7O0tBRUw7TUFBTkY7WUFDRXhDLGlCQUFpQjBDLEtBQUtpQyxZQUFZeE4sVUFBVXdOLFlBQVl4TjtJQUVoRWdKO01BQXlCcUMsT0FBTzRsQyxTQUFTQSxTQUNoQkUsU0FBU0EsU0FBUzFtQyxPQUFPQztJQUNsRDtHQUNGO0dBOURBLFNBQVMrc0Msb0JBQW9CenVDLFFBQVFwSixLQUFLaXFCO0lBQzlCLElBQU54ZSxRQUFRckM7SUFDWnFDLGlCQUFpQndlO0lBQ2pCeGUsaUJBQWlCd2U7SUFDakJ4ZSxpQkFBaUJ3ZTtJQUNqQnhlLGlCQUFpQndlO0lBQ2pCN2dCLHlCQUF5QnFDLE9BQU96TCxRQUFRQTtJQUN4QztHQUNGO0dBbEpBLFNBQVM4M0MsNkJBQTZCMXVDLFFBQVEybkMsSUFBSUM7SUFDaEQ1bkMsNkJBQTZCMm5DLE9BQU9BLE9BQU9DLE9BQU9BO0lBQ2xEO0dBQ0Y7R0FTQSxTQUFTK0csZUFBZTN1QyxRQUFRcEosS0FBS2lMO0lBQ25DN0IsaUJBQWlCcEosUUFBUUEsUUFBUWlMLFNBQVNBO0lBQzFDO0dBQ0Y7R0E5VEEsU0FBUytzQyxrQkFBa0I1dUMsUUFDekJBLHVCQUNBLFNBQ0Y7R0FuQkEsU0FBUzZ1QyxpQkFBaUI3dUMsUUFBUTh1QyxPQUNoQzl1QyxtQkFBbUI4dUMsUUFDbkI7R0FDRjtHQXNtQkEsU0FBU0MsY0FBY0MsZ0JBQWdCQztJQUNyQzl2QztJQUNBLEdBQUlILDhCQUE4QnBQLE1BQU07SUFHeENvUCw0QkFBNEJnd0M7SUFDNUI1dkMsNEJBQTRCNnZDO0lBQzVCaHdDLHlCQUF5QnJQO0lBQ3pCO0dBQ0Y7R0F4bUJBLFNBQVNzL0MsZUFBZWx2QyxRQUN0QkEsb0JBQ0EsU0FDRjtHQXpCQSxTQUFTbXZDLGdCQUFnQm52QyxRQUFRb3ZDO0lBQy9CcHZDLGtCQUFrQm92QyxRQUFRQTtJQUMxQjtHQUNGO0dBNExBLFNBQVNDLHlCQUF5QnJ2QyxRQUFRNmdCO0lBQ3hDN2dCLHdCQUF3QmxDLGNBQWMraUI7SUFDdEM7R0FDRjtHQWNBLFNBQVN5dUIsNEJBQTRCdHZDLFFBQVF1dkMsTUFDM0N2dkMsd0JBQXdCdXZDLE1BQ3hCO0dBQ0Y7R0FHQSxTQUFTQywyQkFBMkJ4dkMsUUFBUXl2QyxTQUMxQ3p2Qyx3QkFBd0J5dkMsU0FDeEI7R0FDRjtHQUlBLFNBQVNDLHlCQUF5QjF2QyxRQUFRMU87SUFDeEMwTyx3QkFBd0JoQyxlQUFlMU07SUFDdkM7R0FDRjtHQTJEQSxTQUFTcStDLG1CQUFtQjN2QyxRQUFRNHZDLFFBQVEvdEMsTUFBTTVFLE9BQU80eUM7SUFDdkQ3dkM7S0FDRWhELFVBQVVDLGVBQWU0eUMsZUFBZWh1QztPQUNwQ1csd0JBQXdCb3RDO0lBQzlCO0dBQ0Y7R0F0RkEsU0FBU0UsMkJBQTJCOXZDLFFBQVErdkMsY0FDMUMvdkMsMEJBQTBCK3ZDLGNBQzFCO0dBQ0Y7R0FtQ0EsU0FBU0MseUNBQXlDaHdDLFFBQVFpd0M7SUFDeERqd0MsdUNBQXVDN08sV0FBVzgrQztJQUNsRDtHQUNGO0dBaktBLFNBQVNDLHVCQUF1Qmx3QyxRQUFRL087SUFDdEMrTyxzQkFBc0JoUCxhQUFhQztJQUNuQztHQUNGO0dBcUJBLFNBQVNrL0Msd0JBQXdCbndDLFFBQVFvd0M7SUFDdkNBO0lBQ0Fwd0Msd0JBQXdCb3dDO0lBQ3hCO0dBQ0Y7R0FqQkEsU0FBU0MsK0JBQStCcndDLFFBQVFyUCxRQUM5Q3FQLDZCQUE2QnJQLFFBQzdCO0dBQ0Y7R0F3QkEsU0FBUzIvQyx3QkFBd0J0d0MsUUFBUW5PO0lBQ3ZDbU8sdUJBQXVCcE8sY0FBY0M7SUFDckM7R0FDRjtHQXREQSxTQUFTMCtDLHlCQUF5QnZ3QyxRQUFReUIsT0FDeEN6Qix3QkFBd0J5QixPQUN4QjtHQUNGO0dBMkRBLFNBQVMrdUMsMEJBQTBCeHdDLFFBQVFxakIsT0FDekNyakIseUJBQXlCcWpCLE9BQ3pCO0dBQ0Y7R0F6S0EsU0FBU290Qix1QkFBdUJ6d0MsUUFBUXBKO0lBQ3RDLEdBQUlvSixpQkFBaUJwUSxLQUFNO0tBQ3pCLElBQUlJLElBQUk0RyxRQUNKd0MsSUFBSXhDO0tBQ1JvSixXQUFXaFE7S0FDWGdRLFdBQVc1RztLQUNYNEcsMEJBQTBCaFE7S0FDMUJnUSx5QkFBeUI1Rzs7SUFFM0I7R0FDRjtHQWlTQSxTQUFTczNDLDBCQUEwQjF3QyxRQUFRMndDLE1BQ3pDM3dDLHlCQUF5QjJ3QyxNQUN6QjtHQUNGO0dBZEEsU0FBU0MsMkJBQTJCNXdDLFFBQVE2Z0I7SUFDMUM3Z0IsMEJBQTBCbEMsY0FBYytpQjtJQUN4QztHQUNGO0dBbUJBLFNBQVNnd0IsNEJBQTRCN3dDLFFBQVFyUDtJQUMzQ3FQLDRCQUE0QnJQO0lBQzVCcVAsNEJBQTRCclA7SUFDNUI7R0FDRjtHQXZWQSxTQUFTbWdELG1CQUFtQjl3QyxRQUFRNkI7SUFDbEMsSUFBSUosUUFBUUksU0FDUkgsU0FBU0c7SUFDYixLQUFLOEMsNkJBQTZCbEQsT0FBT0M7S0FDdkMxTDtJQUVNLElBQUprTSxNQUFNbEMsK0JBQStCQSxjQUFjQTtJQUN2RCxHQUFJQSxrQkFBa0JwUSxLQUFNO0tBQ3hCb1Esc0JBQXNCeUI7S0FDdEJnQjtPQUFvQnpDO09BQWVBO09BQ2ZBO09BQWlCQTtPQUFjQTs7SUFFdkRBLHVCQUF1QkEsZUFBZXlCO0lBQ3RDekIsd0JBQXdCQSxnQkFBZ0IwQjtJQUN4QzFCLDJCQUEyQnlCLE9BQU9DO0lBQ2xDMUIseUJBQXlCa0M7SUFDekI7R0FDRjtHQW1NQSxTQUFTNnVDLDJCQUEyQi93QyxRQUFRNmdCO0lBQzFDN2dCLDBCQUEwQmxDLGNBQWMraUI7SUFDeEM7R0FDRjtHQUdBLFNBQVNtd0IsOEJBQThCaHhDLFFBQVF1dkMsTUFDN0N2dkMsMEJBQTBCdXZDLE1BQzFCO0dBQ0Y7R0FHQSxTQUFTMEIsNkJBQTZCanhDLFFBQVF5dkMsU0FDNUN6dkMsMEJBQTBCeXZDLFNBQzFCO0dBQ0Y7R0FJQSxTQUFTeUIsMkJBQTJCbHhDLFFBQVExTztJQUMxQzBPLDBCQUEwQmhDLGVBQWUxTTtJQUN6QztHQUNGO0dBNUxBLFNBQVM2L0Msd0JBQXdCbnhDLFFBQVFuTjtJQUN2Q21OLHlCQUF5Qm5OLE1BQU1BLE1BQU1BLE1BQU1BLE1BQU1BLE1BQU1BO0lBQ3ZEO0dBQ0Y7R0FxQkEsU0FBU3UrQyxnQkFBZ0JweEMsUUFBUW92QztJQUMvQnB2QywyQkFBMkJvdkMsUUFBUUE7SUFDbkM7R0FDRjtHQXJKQSxTQUFTaUMsZUFBZXJ4QztJQUN0QixHQUFJQSxpQkFBaUJwUSxLQUFNO0tBQ3pCa1AsU0FBU2tCO0tBQ1RBOztJQUVGO0dBQ0Y7R0FpZ0JBLFNBQVNzeEMsaUJBQWlCdHhDLFFBQ3hCQSxzQkFDQSxTQUNGO0dBR0EsU0FBU3V4QyxzQkFBc0J2eEMsUUFBUWxNLE1BQ3JDa00sbUJBQW1CbE0sT0FDbkI7R0FDRjtHQWlDQSxTQUFTMDlDLHNCQUFzQnh4QyxRQUFRcEosS0FBS2lMO0lBQzFDN0IsdUJBQXVCcEosUUFBUUEsUUFBUWlMLFNBQVNBO0lBQ2hEO0dBQ0Y7R0FZQSxTQUFTNHZDLHNCQUFzQnp4QyxRQUFRK3BDLE1BQU1uekM7SUFDM0NvSix1QkFBdUJ3Qyx3QkFBd0J1bkMsT0FBT256QyxRQUFRQTtJQUM5RDtHQUNGO0dBbmNBLFNBQVM4NkMsb0JBQW9CMXhDLFFBQVFuTjtJQUNuQ21OLHNCQUFzQm5OLE1BQU1BLE1BQU1BLE1BQU1BLE1BQU1BLE1BQU1BO0lBQ3BEO0dBQ0Y7R0FHQSxTQUFTOCtDLG9CQUFvQjN4QyxRQUFRb3ZDO0lBQ25DcHZDLHNCQUFzQm92QyxRQUFRQTtJQUM5QjtHQUNGO0dGeHZCQSxTQUFTd0MsU0FBU2xzQyxNQUFNQyxNQUFNQyxNQUFNQyxNQUFNQyxNQUFNQyxNQUFNb2dDLE1BQU1DLE1BQU15TDtJQUN0RCxJQUFOcnNDO0lBQ0osSUFBVSxJQUFGaFcsT0FBT0EsSUFBSXFpRCxNQUFNcmlEO0tBQ3ZCZ1c7TUFBUzBnQztRQUFleGdDLE1BQU1DLE9BQUtuVyxHQUFHb1csT0FBS3BXLEdBQUdxVyxNQUFNQyxNQUFNQyxNQUFNb2dDLE1BQU1DLE9BQUs1MkM7SUFFN0UsT0FBT2dXO0dBQ1Q7R0FsS0EsU0FBU3NzQyxjQUFjeHNDLEtBQUsxSixLQUMxQixPQUFPMEosU0FBUzFKLEtBQ2xCO0dBU0EsU0FBU20yQyxxQkFBcUJ6c0MsS0FBSzFKLEtBQ2pDLE9BQU8wSixTQUFTMUosS0FDbEI7R3lCbkVhO0lBQVRvMkM7TUFBVztRQUNiO1NBQUlDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7U0FXQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1FBVUosU0FBU0MsZUFBZXIvQztTQUN0QixPQUFRbS9DLGdCQUFtQm4vQyxZQUFhQTtRQUMxQztRQUVBLFNBQVNzL0MsVUFBVXZpRCxHQUFFTDtTQUNuQixPQUFRb3VDLGdCQUFnQi90QyxHQUFHTCxZQUFhQTtRQUMxQztRQUVBLFNBQVM2aUQsY0FBY3YyQyxJQUFJak0sR0FBRytHLEtBQUswN0M7U0FFakM7VUFBSUMsT0FBZ0J2bkMsbUJBQW1CbFA7VUFDbkMwMkMsUUFBZ0J4bkMsbUJBQW1CbFA7VUFDbkMyMkMsWUFBZ0JwOUMsdUJBQXVCeUc7VUFDdkM0MkMsWUFBZ0I1MkM7VUFDaEI2MkMsZUFBZ0I3MkM7VUFDaEI4MkMsYUFBZ0I5MkM7VUFFaEJqTSxJQUFJOEosMkJBQTJCOUo7VUFFL0JnakQ7VUFDQUM7VUFDQWorQjtVQUNBaytCLGFBQWF0aUQsTUFBTWlpRDtVQUNuQk0sa0JBQWtCdmlELE1BQU1raUQ7U0FFNUIsSUFBVSxJQUFGbmpELE9BQU9BLElBQUl1akQsZUFBZXZqRDtVQUNoQ3VqRCxPQUFPdmpEO1NBRVR1akQsa0JBQWtCbjhDO1NBRUosU0FBVnE4QztVQUNGLE1BQU9wK0IsYUFBYztXQUNWLElBQUxxK0IsT0FBT3IrQjtXQUNYLEdBQUlxK0I7WUFDRkEsY0FBY0Esa0JBQWtCQTttQkFFMUJBLFNBQVUsQ0FDaEJMLEtBQUtLLGFBQ0x0OEMsTUFBTXM4QyxjQUNOOztVQUdKSjtTQVpjO1NBZVAsU0FBTEssS0FBZ0JELE1BQVFyK0IsV0FBV3ErQixNQUE1QjtTQUVBLFNBQVBFO1VBQ0ZMLGdCQUFnQm44QztVQUNMLElBQVB3TSxhQUFhM1MsVUFBVXNpRDtVQUMzQjN2QztVQUNBLElBQVUsSUFBRjVULE9BQU9BLElBQUl1akQsZUFBZXZqRCxJQUFJO1dBQzlCLElBQUZ1TyxJQUFJZzFDLE9BQU92akQ7V0FDZixHQUFHdU8sZUFBZUEsV0FDaEJBLFVBQVVBO1dBRVpxRixXQUFTNVQsU0FBVXVPO1dBQ25CcUYsV0FBUzVULGFBQWN1Tzs7VUFFekIsT0FBT3FGO1NBWkk7U0FlSSxTQUFiaXdDO1VBQ0YsR0FBR2YsU0FBUyxPQUFPYyxlQUNkSDtTQUZZO1NBTW5CLFFBQVFILEtBQU07VUFDWjtXQUFJN0MsS0FBS3NDLEtBQUtNO1dBQ1ZTLE9BQU9mLEtBQUtNO1dBQ1pVLE9BQU9EO1dBQ1B4Z0QsSUFBSWpELEVBQUUrRztXQUNONDhDO1VBRUpYO1VBRUEsT0FBUTVDO2lCQUNIaUM7YUFDSCxHQUFHdDdDLFFBQVEvRyxTQUFVLENBQUN3akQsZ0JBQWlCO2FBQ3ZDLEdBQUl2Z0QsTUFBTXlnRCxNQUFNMzhDLFlBQ1hxOEM7YUFDTDtpQkFDR2Y7YUFDSCxHQUFHdDdDLFFBQVEvRyxTQUFVLENBQUN3akQsZ0JBQWlCO2FBQ3ZDLEdBQUlaLHFCQUFxQjMvQyxPQUFPeWdELE1BQU0zOEMsWUFDakNxOEM7YUFDTDtpQkFDR2Y7YUFDSDtrQkFBUzE4QyxNQUFNSCx1QkFBdUJtOUMsTUFBTWUsUUFBUS9qRDtjQUFPQSxJQUFJZ0c7Y0FBWWhHLElBQUs7Y0FDOUUsR0FBR29ILFFBQVEvRyxTQUFVLENBQUN3akQsZ0JBQWlCO2NBQ3ZDLEdBQUl2Z0QsTUFBTTBDLGVBQWVoRztlQUN2QnNELElBQUlqRCxJQUFJK0c7a0JBQ0wsQ0FBRXE4QyxhQUFhOzthQUV0QjtpQkFDR2Y7YUFDSDtrQkFBUzE4QyxNQUFNSCx1QkFBdUJtOUMsTUFBTWUsUUFBUS9qRDtjQUFPQSxJQUFJZ0c7Y0FBWWhHLElBQUs7Y0FDOUUsR0FBR29ILFFBQVEvRyxTQUFVLENBQUN3akQsZ0JBQWlCO2NBQ3ZDLEdBQUlaLHFCQUFxQjMvQyxPQUFPMEMsZUFBZWhHO2VBQzdDc0QsSUFBSWpELElBQUkrRztrQkFDTCxDQUFFcThDLGFBQWE7O2FBRXRCO2lCQUNHZjthQUNILEdBQUd0N0MsUUFBUS9HLFNBQVUsQ0FBQ3dqRCxnQkFBaUI7YUFDdkMsR0FBSWpCLFVBQVVJLE1BQU1lLE9BQU96Z0QsSUFBSThELFlBQzFCcThDO2FBQ0w7aUJBQ0dmO2FBQ0gsR0FBR3Q3QyxXQUFXL0csRUFBRStHLGdCQUEwQnE4QyxhQUMxQztpQkFDR2Y7YUFDSCxHQUFHdDdDLE1BQU0vRyxZQUFZQSxFQUFFK0csWUFBc0JxOEMsYUFDN0M7aUJBQ0dmO2FBQ0gsR0FBR3Q3QyxTQUFVO2NBQ1gsR0FBR0EsUUFBUS9HLFNBQVUsQ0FBQ3dqRCxnQkFBaUI7Y0FDdkMsR0FBR2xCLGVBQWV0aUQsT0FBTztjQUN6Qm9qRDs7cUJBRU9yOEMsUUFBUS9HLFNBQVU7Y0FDekIsR0FBR3NpRCxlQUFldGlELEVBQUUrRyxXQUFXO2NBQy9CcThDOztpQkFFRztjQUNILEdBQUdkLGVBQWV0aUQsRUFBRStHLGFBQWF1N0MsZUFBZXRpRCxFQUFFK0csT0FBTztjQUN6RHE4Qzs7YUFFRjtpQkFDR2Y7YUFDSHNCLFFBQVFULE9BQU9RO2FBQ2ZKLGtCQUFpQkssNkJBRUdBO2FBQ3BCQSxjQUFjNThDO2FBQ2Q7aUJBQ0dzN0M7YUFDSHNCLFFBQVFULE9BQU9RO2FBQ2ZKLGtCQUFrQkssMkJBRUVBO2FBQ3BCQSxZQUFZNThDO2FBQ1o7aUJBQ0dzN0M7YUFDSHNCLFFBQVFULE9BQU9RO2FBQ2YsR0FBR0MsbUJBQW1CQSxjQUFlLENBQUNQLGFBQWM7YUFDcEQsSUFBVyxJQUFGempELElBQUlna0QsYUFBYWhrRCxJQUFJZ2tELFdBQVdoa0QsSUFBSTtjQUMzQyxHQUFHb0gsUUFBUS9HLFNBQVUsQ0FBQ3dqRCxnQkFBaUI7Y0FDdkMsR0FBR3hqRCxFQUFFTCxNQUFNSyxFQUFFK0csS0FBTSxDQUFDcThDLGFBQWM7Y0FDbENyOEM7O2FBRUY7aUJBQ0dzN0M7YUFDSCxHQUFJRSxVQUFVSSxNQUFNZSxPQUFPemdELElBQUk4RCxPQUMvQjtpQkFDR3M3QzthQUNILE1BQU9FLFVBQVVJLE1BQU1lLE9BQU96Z0QsSUFDNUJBLElBQUlqRCxJQUFJK0csTUFDVjtpQkFDR3M3QzthQUNILEdBQUd0N0MsUUFBUS9HLFNBQVUsQ0FBQ3dqRCxnQkFBaUI7YUFDdkMsR0FBSWpCLFVBQVVJLE1BQU1lLE9BQU96Z0Q7Y0FBSSxHQUUzQkEsSUFBSWpELElBQUkrRyxXQUNEdzdDLFVBQVVJLE1BQU1lLE9BQU96Z0Q7O2NBRTdCbWdEO2FBQ0w7aUJBQ0dmLGdCQUNILE9BQU9rQjtpQkFDSmxCO2FBQ0hXLEtBQUtBLEtBQUtTLE1BQ1Y7aUJBQ0dwQjthQUNIaUIsZ0JBQWdCTixLQUFLUyxXQUFXMThDLFFBQ2hDO2lCQUNHczdDO2FBQ0hpQjs0QkFBaUJILG1CQUNFTyxhQUNDUCxZQUFZTzthQUNoQ1AsWUFBWU8sUUFBUTM4QzthQUNwQjtpQkFDR3M3QzthQUNILEdBQUljLFlBQVlPLFVBQVUzOEMsS0FBS3E4QyxhQUMvQjtxQkFDTyxVQUFVUTs7O1NBR3JCO1FBQ0Y7UUFFQSxPQUFPcEI7T0F0Tk07O0dBbVFmLFNBQVNxQixpQkFBaUI1M0MsSUFBR2pNLEdBQUUrRztJQUM3QixHQUFHQSxXQUFXQSxNQUFNNkMsc0JBQXNCNUo7S0FDeENtRztJQUNNLElBQUp1QixNQUFNeTZDLFNBQVNsMkMsSUFBSWpNLEdBQUcrRztJQUMxQixPQUFJVyxNQUFZQTtHQUVsQjtHQU9BLFNBQVNvOEMsb0JBQW9CQyxNQUFLYixRQUFPYztJQUN2QztLQUFJRCxPQUFPditDLHVCQUF1QnUrQztLQUM5Qm5rRCxNQUFNbWtEO0tBQ05DLE9BQU94K0MsdUJBQXVCdytDO0tBQzlCdDhDO0tBQ0FqRjtLQUNBd2hEO0tBQ0FsN0I7S0FBT203QjtLQUFLamhEO0lBQ2hCLE1BQU1SLElBQUk3QyxJQUFJO0tBQ1pxa0QsTUFBTUYsWUFBWXRoRDtLQUNsQixHQUFHd2hEO01BQ0R2OEMsT0FBT3U4QztTQUVKO01BQ0gsR0FBR3hoRCxLQUFLN0MsS0FBS3VVO01BQ2I4dkMsTUFBTUYsWUFBWXRoRDtNQUNsQixPQUFPd2hEOztTQUVMdjhDLE9BQU91OEMsS0FDUDs7Ozs7Ozs7Ozs7U0FHQWhoRCxNQUFLZ2hEO1NBQ0wsR0FBSWhoRCxTQUFPaWdEO1VBQ1QvdUM7U0FDRjRVLFFBQVF2UCxlQUFlMHBDLFFBQU9qZ0Q7U0FDOUJpaEQsTUFBTTFxQyxlQUFlMHBDLFFBQVFqZ0Q7U0FDN0IsR0FBSThsQjtVQUNGNVU7U0FDRnpNLE9BQUtzOEMsV0FBV2o3QixPQUFNbTdCO1NBQ3RCO2lCQUVBeDhDLGNBQWdCdThDOzs7O0lBSXRCLE9BQU8vakQsdUJBQXVCd0g7R0FBTTtHQTFFdEMsU0FBU3k4QyxtQkFBbUJsNEMsSUFBSWpNLEdBQUcrRztJQUNqQyxHQUFHQSxXQUFXQSxNQUFNNkMsc0JBQXNCNUo7S0FDeENtRztJQUNGLE1BQU9ZLFNBQVU7S0FDUCxJQUFKVyxNQUFNeTZDLFNBQVNsMkMsSUFBSWpNLEdBQUcrRztLQUMxQixHQUFJVyxLQUFLLE9BQU9BO0tBQ2hCWDs7SUFHRjtHQUNGO0dBeEJBLFNBQVNxOUMsa0JBQWtCbjRDLElBQUlqTSxHQUFHK0c7SUFDaEMsR0FBR0EsV0FBV0EsTUFBTTZDLHNCQUFzQjVKO0tBQ3hDbUc7SUFDRixNQUFPWSxPQUFPNkMsc0JBQXNCNUosR0FBSTtLQUM5QixJQUFKMEgsTUFBTXk2QyxTQUFTbDJDLElBQUlqTSxHQUFHK0c7S0FDMUIsR0FBSVcsS0FBSyxPQUFPQTtLQUNoQlg7O0lBR0Y7R0FDRjtHQW1CQSxTQUFTczlDLGdCQUFnQnA0QyxJQUFHak0sR0FBRStHO0lBQzVCLEdBQUdBLFdBQVdBLE1BQU02QyxzQkFBc0I1SjtLQUN4Q21HO0lBQ00sSUFBSnVCLE1BQU15NkMsU0FBU2wyQyxJQUFJak0sR0FBRytHO0lBQzFCLE9BQUlXLE1BQVlBO0dBRWxCO0d6Qi9NQSxTQUFTNDhDLGNBQWM3dUMsS0FBSzFKLEtBQUt3NEMsT0FDL0I5dUMsU0FBUzFKLE9BQU93NEMsT0FDaEIsU0FDRjtHQVFBLFNBQVNDLHFCQUFxQi91QyxLQUFLMUosS0FBS3c0QyxPQUN0Qzl1QyxTQUFTMUosT0FBT3c0QyxPQUNoQjtHQUNGO0dBZ0tBLFNBQVNFLFdBQVc1dUMsTUFBTUMsTUFBTUMsTUFBTUMsTUFBTUMsTUFBTUM7SUFDdEMsSUFBTlA7SUFDSkEsU0FBU0MsUUFBUUMsTUFBTUMsTUFBTUMsTUFBTUYsTUFBTUMsTUFBTUM7SUFDL0NKLFNBQVNvc0MsU0FBU2xzQyxNQUFNQyxNQUFNQyxNQUFNQyxNQUFNQyxNQUFNQyxNQUFNRixNQUFNQyxNQUFNQztJQUNsRSxPQUFPUDtHQUNUO0dSMEdBLFNBQVMrdUM7SUFDSyxJQUFSamdELFVBQVVDO0lBQ2QsR0FBR0QsV0FBV0E7S0FDWkE7O2dCQUEwQzJGLEtBQUt1NkM7UUFDN0MzN0IsOEJBQThCNWU7UUFDOUIzRjtPQUY4QjtZQUsxQkM7S0FDTkE7O2dCQUE4Q3FvQztRQUM1QyxHQUFHQSxhQUNEL2pCLDhCQUE4QitqQjtPQUZHO0dBTXpDO0dBQ0EyWDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Rzs7O00sNEI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzJCO00sVztLOzs7SSxJLFcsb0I7Ozs7Szs7OztNO0s7SztLO0s7O007TTtNOztLO0ssVztLO0ssTzs7Rzs7Ozs7Ozs7OztJO0ssTztJLE87Rzs7STtLLE87SSxPO0c7O0k7SyxPO0ksTztHOztJLGlCO0c7O0ksd0I7Rzs7STtJLE87O0c7O0ksVztJLE87Rzs0QixPLDZCOzZCLCtDO0c7SSxnQjtJLHFCO0ksaUI7SSxzQjs7Ozs7Ozs7Ozs7Ozs7OztJLG1COztJO0c7O0k7SyxPO0ksTztHOztJO0ssTztJLE87Rzs7STtLLE87SSxPO0c7O0k7SyxPO0ksTztHOztJLGdCO0c7O0k7aUI7RztnQywyQzs7STtHOztJO0c7O0k7Rzs7STtHOztJO0c7O0k7Rzs7STtHO2lDLHlDOztJO0s7TSxPO00sTztLOzs7OztLLEksdUI7Szs7O1E7Ozs7Ozs7O1E7Tzs7Szs7O1MscUI7UztVLHVCO1U7Ozs7OztVO1c7OzBCO1c7Ozs7a0M7Ozs7UTtNOzs7Ozs7Ozs7Ozs7TTtPO087ZTtLO007O1c7Ozs7bUI7TTtROzs7VztXLE87OztxQjtxQjtvQjs7VTs7SyxPOztHOztJLEksVyxzQzs7Ozt3Qzs7SztNLEc7TyxNO00sSSxPOzs7OztNLEc7TyxNO3FCOztLO00sRztPLE07TTtPLE87TyxPOzs7Ozs7b0I7O0s7O0c7O0k7SyxJLFcsOEI7Ozs7Ozs7OztHOztJOztPOztJO0c7OztJOztLLE87OztlLEksVyx3Qjs7OzJDOzs7Yzs7STtJO0s7SztvQjtNLFc7Ozs7STtJOzs7O0s7SSxPOzs7O2MsTzthO0c7O0k7Rzs7O0k7O0c7RztJLGtCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7STtJLE87Rzs7STtLLFE7OztLLFM7SSxJOzs7SztLO0ssTTs7STtJO0c7O0k7SyxROzs7SyxVO0ksSTs7O0s7SztLLE07O0k7STtHOztJO0ssUTs7O0ksSSxjOzs7SztLO0ssTTs7STs7O0ssUztLLFU7STtLOzs7OztLO0s7SztLO0ssTTs7STtJO0k7Rzs7STtLLFE7OztJLEksYzs7O0s7SztLLE07OztJLEksYzs7O0s7SztLO0s7SyxNOztJOzs7SyxTO0ssVTtLLFU7STtLOzs7Ozs7Ozs7OztLO0s7SztLO0s7SztLLE07O0k7STtJO0k7Rzs7SSxPO0c7O0k7Rzs7STtHOztJO0c7O0k7Rzs7STtLLFc7Szs7Ozs7TSxNOzs7O0c7O0ksTztHOztJO0c7O0k7Rzs7O0k7Ozs7STs7O0ksSSxvQjtJO0k7STtHOztJLEkscUI7STtJLEk7Ozs7O0k7Rzs7STs7O0s7SztJO0k7SSxJOzs7OztJOzs7STs7OztLO0s7STtJO0ksSTs7Ozs7STtJOzs7SSxXO0k7SztLO00sTztNLFc7Szs7OztLO0ssTTs7Rzs7SSxPLHNCO0c7O0ksVzs7STtJOztLO00sSSxZOzs7Ozs7Ozs7SyxrQixLOztlLHNCO007TTtPLFM7TyxVO007TTs7VSx1Qjs7Rzs7Ozs7c0I7O3NCO3NCOzs7NEI7NEI7O1E7OzRCOztROztzQjtzQjs0Qjs7c0I7c0I7c0I7c0I7Ozs7a0M7c0I7c0I7Ozs7OztzQjtzQjs7OztROzs0Qjs0Qjs7O3NCOzs7O1M7OzZCOzZCOzs7dUI7Ozs0QjtrQztzQjs0Qjs0Qjs7UTs7O1E7O3NCOzRCOzRCO2tDO3NCO3NCO3NCO3NCOzs7c0I7c0I7c0I7Ozs7OzRCOzRCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztROzs7UTs7NEI7NEI7c0I7c0I7O3NCO3NCOzs7O3NCOztzQjtzQjs7UTs7c0I7NEI7O3NCO3NCO3NCO3NCO3NCO3NCO3NCOzRCO3NCO3NCO3NCOztzQjtzQjtzQjs7Ozs7OztROzs7O1E7OzBCOzBCOzBCOzBCOzBCO3FCO3FCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O3FCO3FCO3FCO3FCO3FCOzBCOzBCOzs7cUI7K0I7MEI7cUI7MEI7MEI7cUI7OztFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0U7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt5QixXLHFDOztJLE87OztHO3NCLE8sb0M7O0ksUTtJO0ksTztHOztJLFc7O0ssVTtLOzs7STs7O0c7O0k7O0ksTztHOztJLEksdUM7Ozs7TSxZOzZDO007Ozs7OztHOztJLEkscUI7OztrQjs7O0c7O0k7STtLO007O007TTtrQjs7Ozs7Szs7O0c7RywrQjs0QixvQix1Qjs7SSxpQjs7O0k7SSxJO0k7O0ssNkIsbUI7aUI7Ozs7OztNOzs7O1U7O0c7O0ksbUM7Ozs7TSxZOztNOzs7Ozs7RzsyQiwrQjtnQyxtQjs7STs7O2EsWTs7O0c7O0k7O0k7SztNOztTO3lDLE8sa0I7OztRO007O1M7eUMsTyxrQjs7O1E7TSxxQixxQztLOzs7Ozs7UTs7UztTO1M7VTtVLFc7VTtVOzs7VTs7Ozs7Ozs7a0IsUyxTOzs7TTs7SztLOzs7Syx3QyxtQjtLO29DLE8sc0I7SztLOzs7Rzs7STs7Ozs7Ozs7OztRLGlCOzs7Ozs7Ozs7O0c7O3VCLFM7Z0MsUzs7STtHOztJO0k7Ozs7O08sWTs7OztTO1MsTTs7Ozs7Ozs7Ozs7OzRCOzs7Rzs7STtJOzs7OztZO1E7USxNOzs7Ozs7O0s7Szs7Ozs0Qjs7O0c7O0ksNkIsbUI7RzswQiw2Qjs7STtJOzs7OztJLGdCOzs7STs7Ozs7TTs7O087Ozs7O1UsRztXLE07Ozs7OztRLEk7Ozs7Ozs7TztRLFk7OztRO1E7Ozs7Ozs7OztpQjs7Ozs7Ozs7OztHO0c7STs7O3lCLCtCOztJOzs7Ozs7O0c7O0ksSSxnQjs7Rzs7SSxjOzs7STtpQjs7Ozs7O1MsMkQ7UztROzs7Rzs7STs7SyxNOztJO0c7dUIsbUM7MkIsa0IsYzs7STs7SSxrQjs7O0c7O0k7O0ssTTs7STtHOzJCLGtDOztJOztJLHdCO2tCLCtCO0k7Rzs7STs7O0ksRywwQjs7OztHOztJOzs7Rzs7Ozs7OztJO0k7OzthO2M7O2M7Yzs7OztjOzs7O2M7YTs7Rzs7STs7O0k7Rzs7SSxZOztJOzs7STs7O2lCO0k7Rzs7STtJO2tCO2E7Szs7TTswQixvQjs7O1M7UztTO1E7SztLOzs7SSxRO0ksZ0I7d0Isa0M7O0s7aUI7O0ssYTtLO0k7STtJO0k7Rzs7SSxZO0ksa0I7c0Isb0I7O0s7Szs7STtJO0k7Rzs7SSxZO0ksa0I7c0Isb0I7O21CLGtDO0s7STtJO0k7Rzs7SSxZOztJLFM7SSxnQjtzQixnQzs7Szs7O00sZTs7SztJO0k7STtJOzs7SSxZO0ksa0I7c0Isb0I7a0IsZSxrQztJO0k7OztJLFE7SSxjO3NCLG9CO2tCLDBCO0k7STtHOztJLFk7SSxrQjtzQixvQjs7SztLLE87STtJO0k7OztJLFk7SSxrQjtzQixvQjs7SyxZO2lCOztLO0k7STtJOzs7SSxZO0ksa0IseUI7c0Isb0I7O0ssSSxlOzs7O00sZTs7OztJO0k7STs7O0k7SSxZO0ksa0IseUI7c0Isb0I7O0ssSSxlOzs7O00sTzs7O0s7STtJO0k7OztJLFE7O0k7SSxlO3NCLGdDOztLO0k7STtJO0k7OztJLFE7O0ksUTtJLGU7c0IsZ0M7a0IsaUQ7STtJO0k7OztJLFE7O0ksUTtJLGU7c0IsZ0M7O0s7Ozs7OztJO0k7STtJOzs7SSxTO0ksZSx5QjtzQixvQjs7SztjO0s7STtJO0k7Rzs7SSxZO0ksa0IseUI7c0Isb0I7O0s7YztLO0k7STtJOztzQiw2Qjs7STs7O007TSxXOzs7O007OztPO087Ozs7Ozs7Rzs7STtLOzs7Szs7SyxPLHdDLFk7STs7SztNOzt3QjtNOzs7OztPLE07OztJO0k7cUMsNEI7STtHOztJO0s7OztLOztLLE8sd0MsWTtJOztLOztrQjs7TTtPLFk7Ozs7OztJO0k7cUMsNEI7STtHOztJLFk7O0k7SSxJLGU7O0s7aUI7O0s7STs7Szs7OztPLE07O007O0ssa0I7cUM7O2EseUIsMkI7O0s7SztLO007TTs7O21COztLO0k7MEI7STtJOzs7STtLO0s7Ozt5QixTOztVLE07UztLLE87O21DOzttQztzQixTOztLOzs7SywwQjs7STtJO0k7STtHOztJLFM7YTtJLDRCLDBCO3NCLGlDOztLOzs7TSxlOztLO0k7STtJO0k7Rzs7SSxTO2E7YTtJOzs7O0s7SztLO3NCLDZDOztLOzs7TSxlOztLO0k7STtJO0k7STtHOztJLFM7YTthO2E7STs7Ozs7SztLO0s7O0s7STs7Szs7O00sZTs7SztJO0k7STtJO0k7STtHOztJLFM7YTthO2E7YTtJOzs7Ozs7SztLO0s7Szs7SztJOztLOzs7Ozs7Ozs7Ozs7O00sZTs7SztJO0k7STtJO0k7STtJO0c7O0ksUzthO2E7YTthO2E7STs7Ozs7OztLO0s7SztLOztLOzs7STs7Szs7Ozs7Ozs7Ozs7Ozs7O00sZTs7SztJO0k7STtJO0k7STtJO0k7RztvQix1QixjLE07O0ksZ0Isd0IsUzs7OztLOztlLFk7O2U7Yzs7OztJLFE7SSxjO3NCLGdDOztLO2dCOztpQjs7SztJO0k7STtJO0c7RztJOzs7O0k7Ozt1QyxTO0ksd0I7a0IsdUIsTzs7Szs7SztLO0s7SyxPO0k7STtHO3VCLGM7O0k7STs7STs7O2E7YSxHLDJCOztjOzs7YztjOzs7O2M7Ozs7Yzs7OztHOztJOzs7STtHOztJLG1COztJO0c7O0k7Ozs7Z0IsTzs7O0k7Rzs7SSxtQjs7O0ksd0I7O0ssTTsyQiwwQjtJOzs7STtJOztvQyxPOzs7Ozs7STtHOztJO0k7a0I7a0Msa0I7Szs7TTtNO00sb0Isb0I7OztTO1M7UztRO0s7Szs7O0k7Szs7TTs0QixxQjs7O1MsYTtTOztRO0s7Szs7SSxnQixlO3dCLGtDOztLLEksZTttQyxHLDRCO0ssYTtLO0k7STtJO0k7Rzs7STtJLFk7SSxrQjtzQixvQjs7SztpQjs7SztJO0k7STs7O0k7SSxxQyxXO0ksa0I7c0Isb0I7a0IsZSxnQztJO0k7OztJO0k7O3FCOztLLFc7Ozs7Szs7TTswQixxQjtzQixlLGlDO0s7Szs7SSxnQjt3QixpQzs7SztLLGU7STtJO0k7STtHOztJO0ksNkIsTztJLGM7c0Isb0I7O0s7SyxPO0k7STtJO0c7O0k7STtLOztNOzBCLG9COzs7UyxZO3FCOztTO1E7SztLOztJLGtCLFE7Z0I7O0k7OztJLG1CO0ksa0IseUI7c0Isb0I7O0ssSSxhOztNLE07OztLLGU7STtnQyxpQztJO0k7OztJLG1CO0ksa0I7c0Isb0I7a0IsZ0M7STtJO0c7O0k7O0ssd0IsTyxxQjs7O0ksUTtJLGU7c0IsaUM7O0s7aUI7O0ssZTtJO0k7STtJOzs7STtJOztJO0s7O007MEIscUI7c0IsdUM7SztLOztJLGU7d0IsaUM7b0IsZ0Q7STtJO0k7Rzs7STtJLFE7O0k7Szs7TTswQixxQjtzQix1QztLO0s7O0ksZTt3QixpQztvQixnRDtJO0k7STtHOztJO0ksUztJLGU7c0Isb0I7O0s7aUI7O0ssZTtJO0k7STtHOztJO0ksWTtJLGtCO3NCLG9COztLO2lCOztLLGU7STtJO0k7OztJO0k7SyxtQjs7Szs7STtLLG1COztLOztJLG1CO3NCLGlEOztLO2M7OztpQjs7a0IsTzs7O2lCLE87Ozs7OztJOztLLG1COztLO0k7STtJO0c7O0k7SSxxQztJOztLO0s7Szs7Szt3Qjs7SztJOztLOzs7eUI7O007OztnRDtLOzs7TSxvQjtNO007OztLOztNO007TTs7O0s7Szs7O0k7STtJO0k7OztJOzs7d0M7OztHOztJOztLO0s7bUI7SztLO0s7STtJO0s7Szs7b0MsUyxtQixTO0ssTzs7O0s7OzswQixTO3NCLHdCO007SztLOzs7bUM7d0IsUztvQixnQztJO0k7STtJO0c7O0k7STs7b0MsVztLOztNOzBCLG9CO3NCLGUsbUM7SztLOzs7O0s7O007NEIscUI7d0IsZSxzQztLO0s7O0ksZTt3QixpQzs7SztLLGU7STtJO0k7STtHOztJO0k7Ozs7c0MsVzs7Ozs7Ozs7Tzs7UTtRO1E7NEIsNkM7OztXLEksaUI7VyxlO1U7TztPO087Tzs7OztJOzs7d0M7Ozs7O0c7O0k7STs7Ozs7Ozs7USxXOzs7Ozs7Ozs7Ozs7UTs7UztTO1M7OztZO1c7OztZLEksaUIsaUI7WSxlO1c7UTtRO1E7UTtROzs7OztJOzs7d0M7Ozs7OztHOztJO0k7Ozs7Ozs7Ozs7UyxXOzs7Ozs7Ozs7Ozs7Ozs7Uzs7VTtVO1U7VTs7O2E7OztZOzs7YTtjO2M7YztjO2MsSTthO1k7UztTO1M7UztTO1M7Ozs7OztJOzs7d0M7Ozs7Ozs7Rzs7STtJOzs7Ozs7Ozs7Ozs7VSxXOzs7Ozs7Ozs7Ozs7Ozs7Ozs7VTs7VztXO1c7VztXOzs7Yzs7Ozs7YTs7O2M7ZTtlO2U7ZTtlO2UsSTtjO2E7VTtVO1U7VTtVO1U7VTs7Ozs7OztJOzs7d0M7Ozs7Ozs7O0c7NkI7Z0M7bUIsMEM7O0k7Ozs7O0c7O0k7Ozs7O0c7b0Isb0I7O0ksbUI7SSxrQjtzQixvQjs7SyxXO0s7STtJO0k7O29CLHlCO29CLHlCOztJLFk7STs7Szs4QztzQixvQjtrQixvRDtJO0k7O2dDOztJLDBDO0c7O0ksMEM7Rzs7SSwwQztHOztJOztrQzs7O0c7O0k7O2tDOzs7Rzs7STtHO3dCLG9EO21CLDBDO0csb0Isa0Isa0I7O0k7Z0Q7Rzs7STtnRDtHOztJO2dEO0c7b0IsMEM7O0k7Z0Q7Rzs7STs7a0M7OztHOztJO2dEO0c7Z0M7O0ksMEM7Rzs7STtnRDtHOztJO2dEO0c7O0ksOEM7Rzs7SSw2QztHOztJOztnQzs7O0c7O0kseUM7Rzs7SSx5QztHOztJLHlDO0c7cUIsd0Q7O0kseUM7Rzs7SSx5QztHOztJLHlDO0c7O0kseUM7Rzs7SSx5QztHOztJLHlDO0c7O0k7O2dDOzs7RztvQix1RDtvQix1RDtvQix1RDs7SSx5QztHOztJLHlDO0c7O0kseUM7Rzs7SSw2QztHOztJO0c7O0k7Rzs7STtHOztJLHlDO0c7O0kseUM7Rzs7SSx5QztHOztJLHlDO0c7Rzs7STtJO0k7STtJO0k7STtJO0k7STtJOztJO29DOzs7Rzs7SSwrQixpQjtHO3VCLCtCLG9CO3VCLCtCLG9CO0csSTs7STs7Szs7TTs7Uzs7VSxPOztTLE07UTs7OztJLCtCLGM7Rzs7STtJOztpQzswRDs7SywrQjtLLGU7bUI7SztNOzBCLHFCOzs7UztTOztRO0s7Szs7Ozs7OztNLG1DLFM7O0ssdUI7O007Tzs2QixzQjs7O1U7c0I7O1U7UztNO007O0s7TTtNLHNCLHNCOzs7UztxQjs7UztRO2dDLG9DOzs7UztTOzs7VTs7O1U7UztRO0s7SztLOzs7OztLOzs7ZSxZOztlO2M7OztJLHVCO3dCLG9DOztLO2lCOztLO0k7STtJO0k7RztHOzhCLDhDOztJO0c7O0k7Rzs7STtHOztJO0c7O0k7Rzs7STtHOztJOztnQzs7O0c7O0k7O2dDOzs7Rzs7O3VCLDRCOzJCLGdDOzBCLDJCO3lCLDhCO3VCLDRCOztLO0sscUI7STs7SztLLHFCO0k7MkIsOEI7O0s7SyxxQjtJOzBCLCtCOztLO0sscUI7STs2QixrQzt5Qiw0Qjt5Qiw4Qjs7SztLLHFCO0k7MkIsZ0M7K0Isb0M7bUMsd0M7O0s7STs7SztJO0k7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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d0I7O1U7OztVOzt3Qjt3Qjs4Qjs4Qjs7VTs7O1U7OztVOzs7VTs7O1U7OztVOzs7NEI7O1U7O3VCOzRCOzRCOztVOzs7VTs7O1U7OztVOzs7VTs7O1U7OzRCOztVOzs7VTs7O1U7O1NBOFFBQzs0Qjs7U0E0TkFFO1NBRUFFO1NBRUFFO1NBRUFFO1NBRUFFO1NBRUFFO1NBRUFFO1NBRUFFO1NBRUFFO1NBRUFFO1NBRUFFO1NBS0FFO3VCO3VCOzt1QjtTQWdIQUM7dUI7dUI7dUI7OztFOzs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7R0MxcENOO0dBRVE7SUFBSndDO01BQUk7Ozs7Ozs7Ozs7Ozs7R0FHUixtQ0FISUE7R0FJSixtQ0FKSUE7R0FNSixtQ0FOSUE7R0FPSixtQ0FQSUE7R0FRSixtQ0FSSUE7R0FTSixtQ0FUSUE7R0FVSixtQ0FWSUE7R0FXSixtQ0FYSUE7R0FZSixtQ0FaSUE7R0FhSixtQ0FiSUE7R0FlSixtQ0FmSUE7R0FnQkosbUNBaEJJQTtHQWlCSjs7S0FqQklBOzs7O0dBbUJKLG1DQW5CSUE7R0FxQkosa0NBckJJQTtHQXdCRjs7cUJBQ0ksT0FBQSxxQ0FBZTs7R0FLbkI7OztNQUFZLElBQ2dCQywrQkFBQUE7bUJBRXRCO0tBQ0g7O0dBR0wsa0RBQXVCLFNBQW9COzs7O0U7Ozs7Ozs7Ozs7Ozs7Rzs7Ozs7Ozs7R0MzQnJDO0dBQUE7OztFIiwic291cmNlc0NvbnRlbnQiOlsiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogICAgQ29weXJpZ2h0IDIwMjIgT0NhbWxQcm8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogIEFsbCByaWdodHMgcmVzZXJ2ZWQuIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlICAqL1xuLyogIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgc3BlY2lhbCAgICAgICAqL1xuLyogIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAgICAgICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vL1Byb3ZpZGVzOiBTTEFOVFxudmFyIFNMQU5UID0ge1xuICBST01BTiAgIDogXCJub3JtYWxcIixcbiAgSVRBTElDICA6IFwiaXRhbGljXCIsXG4gIE9CTElRVUUgOiBcIm9ibGlxdWVcIixcbn07XG5cbi8vUHJvdmlkZXM6IEZPQ1VTXG52YXIgRk9DVVMgPSB7XG4gIE9VVCA6IDAsXG4gIElOICA6IDFcbn07XG5cbi8vUHJvdmlkZXM6IEtFWVxudmFyIEtFWSA9IHtcbiAgVU5ERUZJTkVEIDogMHgwMywgLyogdG8gaGFuZGxlIHRyYW5zbGF0aW9uIGVycm9ycyAqL1xuXG4gIC8qIEZ1bmN0aW9uICovXG4gIEVTQ0FQRSA6IDB4MjksXG4gIEYxIDogMHgzQSxcbiAgRjIgOiAweDNCLFxuICBGMyA6IDB4M0MsXG4gIEY0IDogMHgzRCxcbiAgRjUgOiAweDNFLFxuICBGNiA6IDB4M0YsXG4gIEY3IDogMHg0MCxcbiAgRjggOiAweDQxLFxuICBGOSA6IDB4NDIsXG4gIEYxMCA6IDB4NDMsXG4gIEYxMSA6IDB4NDQsXG4gIEYxMiA6IDB4NDUsXG4gIFBSSU5UU0NSRUVOIDogMHg0NixcbiAgU0NST0xMTE9DSyA6IDB4NDcsXG4gIFBBVVNFIDogMHg0OCxcblxuICAvKiBBbHBoYW51bWVyaWMsIGZpcnN0IHJvdyAqL1xuICBHUkFWRV9USUxERSA6IDB4MzUsIC8qIHBvc3NpYmx5IFplbmtha3UvSGFua2FrdSBrZXkgb24gSmFwYW5lc2UgS0IgKi9cbiAgXzFfRVhDTEFNQVRJT04gOiAweDFFLFxuICBfMl9BVCA6IDB4MUYsXG4gIF8zX05VTUJFUiA6IDB4MjAsXG4gIF80X0RPTExBUiA6IDB4MjEsXG4gIF81X1BFUkNFTlQgOiAweDIyLFxuICBfNl9DQVJFVCA6IDB4MjMsXG4gIF83X0FNUEVSU0FORCA6IDB4MjQsXG4gIF84X0FTVEVSSVNLIDogMHgyNSxcbiAgXzlfTFBBUkVOVEhFU0lTIDogMHgyNixcbiAgXzBfUlBBUkVOVEhFU0lTIDogMHgyNyxcbiAgTUlOVVNfVU5ERVJTQ09SRSA6IDB4MkQsXG4gIEVRVUFMX1BMVVMgOiAweDJFLFxuICBCQUNLU1BBQ0UgOiAweDJBLCAvKiBhbHNvIGNhbGxlZCBEZWxldGUgKi9cblxuICAvKiBBbHBoYW51bWVyaWMsIHNlY29uZCByb3cgKi9cbiAgVEFCIDogMHgyQixcbiAgUSA6IDB4MTQsXG4gIFcgOiAweDFBLFxuICBFIDogMHgwOCxcbiAgUiA6IDB4MTUsXG4gIFQgOiAweDE3LFxuICBZIDogMHgxQyxcbiAgVSA6IDB4MTgsXG4gIEkgOiAweDBDLFxuICBPIDogMHgxMixcbiAgUCA6IDB4MTMsXG4gIExCUkFDS0VUX0NVUkxZIDogMHgyRixcbiAgUkJSQUNLRVRfQ1VSTFkgOiAweDMwLFxuICBCQUNLU0xBU0hfUElQRSA6IDB4MzEsIC8qIHJlcGxhY2VkIGJ5IE5PTlVTX05VTUJFUl9USUxERSBvbiBJU08gS0IgKi9cblxuICAvKiBBbHBoYW51bWVyaWMsIHRoaXJkIHJvdyAqL1xuICBDQVBTTE9DSyA6IDB4MzksIC8qIGFsc28gRWlzdSAo6Iux5pWwKSBvbiBKSVMga2V5Ym9hcmRzICovXG4gIEEgOiAweDA0LFxuICBTIDogMHgxNixcbiAgRCA6IDB4MDcsXG4gIEYgOiAweDA5LFxuICBHIDogMHgwQSxcbiAgSCA6IDB4MEIsXG4gIEogOiAweDBELFxuICBLIDogMHgwRSxcbiAgTCA6IDB4MEYsXG4gIFNFTUlDT0xPTl9DT0xPTiA6IDB4MzMsXG4gIFFVT1RFX0RPVUJMRVFVT1RFIDogMHgzNCxcbiAgTk9OVVNfTlVNQkVSX1RJTERFIDogMHgzMiwgLyogZXh0cmEga2V5IGxlZnQgb2YgUmV0dXJuIG9uIElTTyBLQiAqL1xuICBSRVRVUk4gOiAweDI4LCAvKiBhbHNvIGNhbGxlZCBFbnRlciAqL1xuXG4gIC8qIEFscGhhbnVtZXJpYywgZm91cnRoIHJvdyAqL1xuICBMU0hJRlQgOiAweEUxLFxuICBOT05VU19CQUNLU0xBU0hfUElQRSA6IDB4NjQsIC8qIGV4dHJhIGtleSByaWdodCBvZiBMU2hpZnQgb24gSVNPIEtCICovXG4gIFogOiAweDFELFxuICBYIDogMHgxQixcbiAgQyA6IDB4MDYsXG4gIFYgOiAweDE5LFxuICBCIDogMHgwNSxcbiAgTiA6IDB4MTEsXG4gIE0gOiAweDEwLFxuICBDT01NQV9MRVNTIDogMHgzNixcbiAgUEVSSU9EX0dSRUFURVIgOiAweDM3LFxuICBTTEFTSF9RVUVTVElPTiA6IDB4MzgsXG4gIFJTSElGVCA6IDB4RTUsXG5cbiAgLyogQWxwaGFudW1lcmljLCBmaWZ0aCByb3cgKi9cbiAgTENPTlRST0wgOiAweEUwLFxuICBMTUVUQSA6IDB4RTMsIC8qIExlZnQgV2luZG93cywgTGVmdCBDb21tYW5kICovXG4gIExBTFQgOiAweEUyLFxuICBTUEFDRUJBUiA6IDB4MkMsXG4gIFJBTFQgOiAweEU2LFxuICBSTUVUQSA6IDB4RTcsIC8qIFJpZ2h0IFdpbmRvd3MsIFJpZ2h0IENvbW1hbmQgKi9cbiAgTUVOVSA6IDB4NzYsXG4gIFJDT05UUk9MIDogMHhFNCxcblxuICAvKiBDb250cm9sIHBhZCAqL1xuICBJTlNFUlQgOiAweDQ5LCAvKiByZXBsYWNlZCBieSBhIEZuIGtleSBvbiBNYWMgKGRpZmZlcmVudCBjb2RlKSAqL1xuICBIT01FIDogMHg0QSxcbiAgUEFHRVVQIDogMHg0QixcbiAgREVMRVRFRk9SV0FSRCA6IDB4NEMsXG4gIEVORCA6IDB4NEQsXG4gIFBBR0VET1dOIDogMHg0RSxcblxuICAvKiBBcnJvdyBwYWQgKi9cbiAgVVBBUlJPVyA6IDB4NTIsXG4gIExFRlRBUlJPVyA6IDB4NTAsXG4gIERPV05BUlJPVyA6IDB4NTEsXG4gIFJJR0hUQVJST1cgOiAweDRGLFxuXG4gIC8qIE51bWVyaWMgcGFkICovXG4gIFBBRF9OVU1MT0NLX0NMRUFSIDogMHg1MywgLyogbm8gTnVtTG9jayBvbiBNYWMga2V5Ym9hcmRzICovXG4gIFBBRF9FUVVBTFMgOiAweDY3LCAvKiBvbiBNYWMga2V5Ym9hcmRzICovXG4gIFBBRF9ESVZJREUgOiAweDU0LFxuICBQQURfTVVMVElQTFkgOiAweDU1LFxuICBQQURfTUlOVVMgOiAweDU2LFxuICBQQURfN19IT01FIDogMHg1RixcbiAgUEFEXzhfVVBBUlJPVyA6IDB4NjAsXG4gIFBBRF85X1BBR0VVUCA6IDB4NjEsXG4gIFBBRF9QTFVTIDogMHg1NyxcbiAgUEFEXzRfTEVGVEFSUk9XIDogMHg1QyxcbiAgUEFEXzUgOiAweDVELFxuICBQQURfNl9SSUdIVEFSUk9XIDogMHg1RSxcbiAgUEFEX0NPTU1BIDogMHg4NSwgLyogc3BlY2lmaWMgdG8gQnJhemlsaWFuIGtleWJvYXJkcyAqL1xuICBQQURfMV9FTkQgOiAweDU5LFxuICBQQURfMl9ET1dOQVJST1cgOiAweDVBLFxuICBQQURfM19QQUdFRE9XTiA6IDB4NUIsXG4gIFBBRF8wX0lOU0VSVCA6IDB4NjIsXG4gIFBBRF9ERUNJTUFMX0RFTEVURSA6IDB4NjMsXG4gIFBBRF9FTlRFUiA6IDB4NTgsXG4gIC8vIEFTLzQwMCBrZXlib2FyZHMgYWxzbyBoYXZlIGFuIGVxdWFscyBzaWduIGF0IDB4ODZcblxuICAvKiBFeHRyYSBmdW5jdGlvbiBrZXlzICovXG4gIEYxMyA6IDB4NjgsXG4gIEYxNCA6IDB4NjksXG4gIEYxNSA6IDB4NkEsXG4gIEYxNiA6IDB4NkIsXG4gIEYxNyA6IDB4NkMsXG4gIEYxOCA6IDB4NkQsXG4gIEYxOSA6IDB4NkUsXG4gIEYyMCA6IDB4NkYsXG4gIEYyMSA6IDB4NzAsXG4gIEYyMiA6IDB4NzEsXG4gIEYyMyA6IDB4NzIsXG4gIEYyNCA6IDB4NzMsXG5cbiAgLyogSW50ZXJuYXRpb25hbCAmIExBTkcga2V5cyAqL1xuICBJTlRFUk5BVElPTkFMMSA6IDB4ODcsIC8qIF8gYW5kIFxcIGtleSBsZWZ0IG9mIFJTaGlmdCBvbiBKSVMgS0IgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogYWxzbyBCcmF6aWxpYW4gLyBhbmQgPyBrZXkgKi9cbiAgSU5URVJOQVRJT05BTDIgOiAweDg4LCAvKiBLYXRha2FuYS9IaXJhZ2FuYSBrZXkgcmlnaHQgb2YgU3BhY2Ugb24gSklTIEtCICovXG4gIElOVEVSTkFUSU9OQUwzIDogMHg4OSwgLyogfCBhbmQgWWVuIGtleSBsZWZ0IG9mIEJhY2tzcGFjZSBvbiBKSVMgS0IgKi9cbiAgSU5URVJOQVRJT05BTDQgOiAweDhBLCAvKiBIZW5rYW4ga2V5IHJpZ2h0IG9mIFNwYWNlIG9uIEpJUyBLQiArIOWJjeWAmeijnCAqL1xuICBJTlRFUk5BVElPTkFMNSA6IDB4OEIsIC8qIE11aGVua2FuIGtleSBsZWZ0IG9mIFNwYWNlIG9uIEpJUyBLQiAqL1xuICBJTlRFUk5BVElPTkFMNiA6IDB4OEMsIC8qIEthbm1hIChjb21tYSksIHJpZ2h0IG9mIEtQMCBvbiBKSVMgS0IgKi9cbiAgSU5URVJOQVRJT05BTDcgOiAweDhELCAvKiBEb3VibGUtQnl0ZS9TaW5nbGUtQnl0ZSB0b2dnbGUga2V5ICovXG4gIElOVEVSTkFUSU9OQUw4IDogMHg4RSwgLyogVW5kZWZpbmVkICovXG4gIElOVEVSTkFUSU9OQUw5IDogMHg4RiwgLyogVW5kZWZpbmVkICovXG4gIExBTkcxIDogMHg5MCwgLyogSGFuZ3VsL0VuZ2xpc2ggdG9nZ2xlIGtleSAoS29yZWFuKSAqL1xuICBMQU5HMiA6IDB4OTEsIC8qIEhhbmphIGNvbnZlcnNpb24ga2V5IChLb3JlYW4pICovXG4gIExBTkczIDogMHg5MiwgLyogS2F0YWthbmEga2V5IChKYXBhbmVzZSkgKi9cbiAgTEFORzQgOiAweDkzLCAvKiBIaXJhZ2FuYSBrZXkgKEphcGFuZXNlKSAqL1xuICBMQU5HNSA6IDB4OTQsIC8qIFplbmtha3UvSGFua2FrdSBrZXkgKEphcGFuZXNlKSAqL1xuXG4gIC8qIEV4dGVuc2lvbnMgKi9cbiAgSEVMUCA6IDB4NzUsXG4gIE1VVEUgOiAweDdGLFxuICBWT0xVTUVVUCA6IDB4ODAsXG4gIFZPTFVNRURPV04gOiAweDgxXG59O1xuXG4vL1Byb3ZpZGVzOiBLRVlfU1RBVEVcbnZhciBLRVlfU1RBVEUgPSB7XG4gIFVQIDogMCxcbiAgRE9XTiAgOiAxXG59O1xuXG4vL1Byb3ZpZGVzOiBCVVRUT05cbnZhciBCVVRUT04gPSB7XG4gIE5PTkUgICAgICAgOiAwLFxuICBMRUZUICAgICAgIDogMSxcbiAgTUlERExFICAgICA6IDIsXG4gIFJJR0hUICAgICAgOiAzLFxuICBXSEVFTF9VUCAgIDogNCxcbiAgV0hFRUxfRE9XTiA6IDVcbn07XG5cbi8vUHJvdmlkZXM6IEJVVFRPTl9TVEFURVxudmFyIEJVVFRPTl9TVEFURSA9IHtcbiAgVVAgOiAwLFxuICBET1dOICA6IDFcbn07XG4iLCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKiAgICBDb3B5cmlnaHQgMjAyMiBPQ2FtbFBybyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKiAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgICovXG4vKiAgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSBzcGVjaWFsICAgICAgICovXG4vKiAgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICAgICAgICAgICovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8vUHJvdmlkZXM6IEZPQ1VTX1RBR1xudmFyIEZPQ1VTX1RBRyA9IHtcbiAgT1VUIDogMCxcbiAgSU4gIDogMVxufTtcblxuLy9Qcm92aWRlczogS0VZX1RBR1xudmFyIEtFWV9UQUcgPSB7XG4gIEVTQ0FQRSAgICAgICAgICAgICAgIDogMCxcbiAgRjEgICAgICAgICAgICAgICAgICAgOiAxLFxuICBGMiAgICAgICAgICAgICAgICAgICA6IDIsXG4gIEYzICAgICAgICAgICAgICAgICAgIDogMyxcbiAgRjQgICAgICAgICAgICAgICAgICAgOiA0LFxuICBGNSAgICAgICAgICAgICAgICAgICA6IDUsXG4gIEY2ICAgICAgICAgICAgICAgICAgIDogNixcbiAgRjcgICAgICAgICAgICAgICAgICAgOiA3LFxuICBGOCAgICAgICAgICAgICAgICAgICA6IDgsXG4gIEY5ICAgICAgICAgICAgICAgICAgIDogOSxcbiAgRjEwICAgICAgICAgICAgICAgICAgOiAxMCxcbiAgRjExICAgICAgICAgICAgICAgICAgOiAxMSxcbiAgRjEyICAgICAgICAgICAgICAgICAgOiAxMixcbiAgUFJJTlRTQ1JFRU4gICAgICAgICAgOiAxMyxcbiAgU0NST0xMTE9DSyAgICAgICAgICAgOiAxNCxcbiAgUEFVU0UgICAgICAgICAgICAgICAgOiAxNSxcbiAgR1JBVkVfVElMREUgICAgICAgICAgOiAxNixcbiAgXzFfRVhDTEFNQVRJT04gICAgICAgOiAxNyxcbiAgXzJfQVQgICAgICAgICAgICAgICAgOiAxOCxcbiAgXzNfTlVNQkVSICAgICAgICAgICAgOiAxOSxcbiAgXzRfRE9MTEFSICAgICAgICAgICAgOiAyMCxcbiAgXzVfUEVSQ0VOVCAgICAgICAgICAgOiAyMSxcbiAgXzZfQ0FSRVQgICAgICAgICAgICAgOiAyMixcbiAgXzdfQU1QRVJTQU5EICAgICAgICAgOiAyMyxcbiAgXzhfQVNURVJJU0sgICAgICAgICAgOiAyNCxcbiAgXzlfTFBBUkVOVEhFU0lTICAgICAgOiAyNSxcbiAgXzBfUlBBUkVOVEhFU0lTICAgICAgOiAyNixcbiAgTUlOVVNfVU5ERVJTQ09SRSAgICAgOiAyNyxcbiAgRVFVQUxfUExVUyAgICAgICAgICAgOiAyOCxcbiAgQkFDS1NQQUNFICAgICAgICAgICAgOiAyOSxcbiAgVEFCICAgICAgICAgICAgICAgICAgOiAzMCxcbiAgUSAgICAgICAgICAgICAgICAgICAgOiAzMSxcbiAgVyAgICAgICAgICAgICAgICAgICAgOiAzMixcbiAgRSAgICAgICAgICAgICAgICAgICAgOiAzMyxcbiAgUiAgICAgICAgICAgICAgICAgICAgOiAzNCxcbiAgVCAgICAgICAgICAgICAgICAgICAgOiAzNSxcbiAgWSAgICAgICAgICAgICAgICAgICAgOiAzNixcbiAgVSAgICAgICAgICAgICAgICAgICAgOiAzNyxcbiAgSSAgICAgICAgICAgICAgICAgICAgOiAzOCxcbiAgTyAgICAgICAgICAgICAgICAgICAgOiAzOSxcbiAgUCAgICAgICAgICAgICAgICAgICAgOiA0MCxcbiAgTEJSQUNLRVRfQ1VSTFkgICAgICAgOiA0MSxcbiAgUkJSQUNLRVRfQ1VSTFkgICAgICAgOiA0MixcbiAgQkFDS1NMQVNIX1BJUEUgICAgICAgOiA0MyxcbiAgQ0FQU0xPQ0sgICAgICAgICAgICAgOiA0NCxcbiAgQSAgICAgICAgICAgICAgICAgICAgOiA0NSxcbiAgUyAgICAgICAgICAgICAgICAgICAgOiA0NixcbiAgRCAgICAgICAgICAgICAgICAgICAgOiA0NyxcbiAgRiAgICAgICAgICAgICAgICAgICAgOiA0OCxcbiAgRyAgICAgICAgICAgICAgICAgICAgOiA0OSxcbiAgSCAgICAgICAgICAgICAgICAgICAgOiA1MCxcbiAgSiAgICAgICAgICAgICAgICAgICAgOiA1MSxcbiAgSyAgICAgICAgICAgICAgICAgICAgOiA1MixcbiAgTCAgICAgICAgICAgICAgICAgICAgOiA1MyxcbiAgU0VNSUNPTE9OX0NPTE9OICAgICAgOiA1NCxcbiAgUVVPVEVfRE9VQkxFUVVPVEUgICAgOiA1NSxcbiAgTk9OVVNfTlVNQkVSX1RJTERFICAgOiA1NixcbiAgUkVUVVJOICAgICAgICAgICAgICAgOiA1NyxcbiAgTFNISUZUICAgICAgICAgICAgICAgOiA1OCxcbiAgTk9OVVNfQkFDS1NMQVNIX1BJUEUgOiA1OSxcbiAgWiAgICAgICAgICAgICAgICAgICAgOiA2MCxcbiAgWCAgICAgICAgICAgICAgICAgICAgOiA2MSxcbiAgQyAgICAgICAgICAgICAgICAgICAgOiA2MixcbiAgViAgICAgICAgICAgICAgICAgICAgOiA2MyxcbiAgQiAgICAgICAgICAgICAgICAgICAgOiA2NCxcbiAgTiAgICAgICAgICAgICAgICAgICAgOiA2NSxcbiAgTSAgICAgICAgICAgICAgICAgICAgOiA2NixcbiAgQ09NTUFfTEVTUyAgICAgICAgICAgOiA2NyxcbiAgUEVSSU9EX0dSRUFURVIgICAgICAgOiA2OCxcbiAgU0xBU0hfUVVFU1RJT04gICAgICAgOiA2OSxcbiAgUlNISUZUICAgICAgICAgICAgICAgOiA3MCxcbiAgTENPTlRST0wgICAgICAgICAgICAgOiA3MSxcbiAgTE1FVEEgICAgICAgICAgICAgICAgOiA3MixcbiAgTEFMVCAgICAgICAgICAgICAgICAgOiA3MyxcbiAgU1BBQ0VCQVIgICAgICAgICAgICAgOiA3NCxcbiAgUkFMVCAgICAgICAgICAgICAgICAgOiA3NSxcbiAgUk1FVEEgICAgICAgICAgICAgICAgOiA3NixcbiAgTUVOVSAgICAgICAgICAgICAgICAgOiA3NyxcbiAgUkNPTlRST0wgICAgICAgICAgICAgOiA3OCxcbiAgSU5TRVJUICAgICAgICAgICAgICAgOiA3OSxcbiAgSE9NRSAgICAgICAgICAgICAgICAgOiA4MCxcbiAgUEFHRVVQICAgICAgICAgICAgICAgOiA4MSxcbiAgREVMRVRFRk9SV0FSRCAgICAgICAgOiA4MixcbiAgRU5EICAgICAgICAgICAgICAgICAgOiA4MyxcbiAgUEFHRURPV04gICAgICAgICAgICAgOiA4NCxcbiAgVVBBUlJPVyAgICAgICAgICAgICAgOiA4NSxcbiAgTEVGVEFSUk9XICAgICAgICAgICAgOiA4NixcbiAgRE9XTkFSUk9XICAgICAgICAgICAgOiA4NyxcbiAgUklHSFRBUlJPVyAgICAgICAgICAgOiA4OCxcbiAgUEFEX05VTUxPQ0tfQ0xFQVIgICAgOiA4OSxcbiAgUEFEX0VRVUFMUyAgICAgICAgICAgOiA5MCxcbiAgUEFEX0RJVklERSAgICAgICAgICAgOiA5MSxcbiAgUEFEX01VTFRJUExZICAgICAgICAgOiA5MixcbiAgUEFEX01JTlVTICAgICAgICAgICAgOiA5MyxcbiAgUEFEXzdfSE9NRSAgICAgICAgICAgOiA5NCxcbiAgUEFEXzhfVVBBUlJPVyAgICAgICAgOiA5NSxcbiAgUEFEXzlfUEFHRVVQICAgICAgICAgOiA5NixcbiAgUEFEX1BMVVMgICAgICAgICAgICAgOiA5NyxcbiAgUEFEXzRfTEVGVEFSUk9XICAgICAgOiA5OCxcbiAgUEFEXzUgICAgICAgICAgICAgICAgOiA5OSxcbiAgUEFEXzZfUklHSFRBUlJPVyAgICAgOiAxMDAsXG4gIFBBRF9DT01NQSAgICAgICAgICAgIDogMTAxLFxuICBQQURfMV9FTkQgICAgICAgICAgICA6IDEwMixcbiAgUEFEXzJfRE9XTkFSUk9XICAgICAgOiAxMDMsXG4gIFBBRF8zX1BBR0VET1dOICAgICAgIDogMTA0LFxuICBQQURfMF9JTlNFUlQgICAgICAgICA6IDEwNSxcbiAgUEFEX0RFQ0lNQUxfREVMRVRFICAgOiAxMDYsXG4gIFBBRF9FTlRFUiAgICAgICAgICAgIDogMTA3LFxuICBGMTMgICAgICAgICAgICAgICAgICA6IDEwOCxcbiAgRjE0ICAgICAgICAgICAgICAgICAgOiAxMDksXG4gIEYxNSAgICAgICAgICAgICAgICAgIDogMTEwLFxuICBGMTYgICAgICAgICAgICAgICAgICA6IDExMSxcbiAgRjE3ICAgICAgICAgICAgICAgICAgOiAxMTIsXG4gIEYxOCAgICAgICAgICAgICAgICAgIDogMTEzLFxuICBGMTkgICAgICAgICAgICAgICAgICA6IDExNCxcbiAgRjIwICAgICAgICAgICAgICAgICAgOiAxMTUsXG4gIEYyMSAgICAgICAgICAgICAgICAgIDogMTE2LFxuICBGMjIgICAgICAgICAgICAgICAgICA6IDExNyxcbiAgRjIzICAgICAgICAgICAgICAgICAgOiAxMTgsXG4gIEYyNCAgICAgICAgICAgICAgICAgIDogMTE5LFxuICBJTlRFUk5BVElPTkFMMSAgICAgICA6IDEyMCxcbiAgSU5URVJOQVRJT05BTDIgICAgICAgOiAxMjEsXG4gIElOVEVSTkFUSU9OQUwzICAgICAgIDogMTIyLFxuICBJTlRFUk5BVElPTkFMNCAgICAgICA6IDEyMyxcbiAgSU5URVJOQVRJT05BTDUgICAgICAgOiAxMjQsXG4gIElOVEVSTkFUSU9OQUw2ICAgICAgIDogMTI1LFxuICBJTlRFUk5BVElPTkFMNyAgICAgICA6IDEyNixcbiAgSU5URVJOQVRJT05BTDggICAgICAgOiAxMjcsXG4gIElOVEVSTkFUSU9OQUw5ICAgICAgIDogMTI4LFxuICBMQU5HMSAgICAgICAgICAgICAgICA6IDEyOSxcbiAgTEFORzIgICAgICAgICAgICAgICAgOiAxMzAsXG4gIExBTkczICAgICAgICAgICAgICAgIDogMTMxLFxuICBMQU5HNCAgICAgICAgICAgICAgICA6IDEzMixcbiAgTEFORzUgICAgICAgICAgICAgICAgOiAxMzMsXG4gIEhFTFAgICAgICAgICAgICAgICAgIDogMTM0LFxuICBNVVRFICAgICAgICAgICAgICAgICA6IDEzNSxcbiAgVk9MVU1FVVAgICAgICAgICAgICAgOiAxMzYsXG4gIFZPTFVNRURPV04gICAgICAgICAgIDogMTM3XG59O1xuXG4vLyBQcm92aWRlczogS0VZX1NUQVRFX1RBR1xudmFyIEtFWV9TVEFURV9UQUcgPSB7XG4gIFVQICAgOiAwLFxuICBET1dOIDogMVxufTtcblxuLy8gUHJvdmlkZXM6IEJVVFRPTl9UQUdcbnZhciBCVVRUT05fVEFHID0ge1xuICBOT05FICAgICAgIDogMCxcbiAgTEVGVCAgICAgICA6IDEsXG4gIE1JRERMRSAgICAgOiAyLFxuICBSSUdIVCAgICAgIDogMyxcbiAgV0hFRUxfVVAgICA6IDQsXG4gIFdIRUVMX0RPV04gOiA1XG59O1xuXG4vLyBQcm92aWRlczogQlVUVE9OX1NUQVRFX1RBR1xudmFyIEJVVFRPTl9TVEFURV9UQUcgPSB7XG4gIFVQICAgOiAwLFxuICBET1dOIDogMVxufTtcblxuLy8gUHJvdmlkZXM6IEVWRU5UX1RBR1xudmFyIEVWRU5UX1RBRyA9IHtcbiAgRlJBTUVfQ1lDTEUgICAgOiAwLFxuICBGUkFNRSAgICAgICAgICA6IDEsXG4gIENBTlZBU19GT0NVU0VEIDogMixcbiAgQ0FOVkFTX1JFU0laRUQgOiAzLFxuICBDQU5WQVNfTU9WRUQgICA6IDQsXG4gIENBTlZBU19DTE9TRUQgIDogNSxcbiAgS0VZX0FDVElPTiAgICAgOiA2LFxuICBCVVRUT05fQUNUSU9OICA6IDcsXG4gIE1PVVNFX01PVkUgICAgIDogOFxufTtcblxuLy9Qcm92aWRlczogU1RZTEVfVEFHXG52YXIgU1RZTEVfVEFHID0ge1xuICBDT0xPUiAgICA6IDAsXG4gIEdSQURJRU5UIDogMSxcbiAgUEFUVEVSTiAgOiAyXG59O1xuXG4vL1Byb3ZpZGVzOiBSRVBFQVRfVEFHXG52YXIgUkVQRUFUX1RBRyA9IHtcbiAgTk9fUkVQRUFUIDogMCxcbiAgUkVQRUFUX1ggIDogMSxcbiAgUkVQRUFUX1kgIDogMixcbiAgUkVQRUFUX1hZIDogM1xufTtcblxuLy9Qcm92aWRlczogU0xBTlRfVEFHXG52YXIgU0xBTlRfVEFHID0ge1xuICBST01BTiAgIDogMCxcbiAgSVRBTElDICA6IDEsXG4gIE9CTElRVUUgOiAyXG59O1xuXG4vL1Byb3ZpZGVzOiBKT0lOX1RZUEVfVEFHXG52YXIgSk9JTl9UWVBFX1RBRyA9IHtcbiAgUk9VTkQgOiAwLFxuICBNSVRFUiA6IDEsXG4gIEJFVkVMIDogMlxufVxuXG4vL1Byb3ZpZGVzOiBDQVBfVFlQRV9UQUdcbnZhciBDQVBfVFlQRV9UQUcgPSB7XG4gIEJVVFQgICA6IDAsXG4gIFNRVUFSRSA6IDEsXG4gIFJPVU5EICA6IDJcbn07XG5cbi8vUHJvdmlkZXMgOiBDT01QT1BfVEFHXG52YXIgQ09NUE9QX1RBRyA9IHtcbiAgU09VUkNFX09WRVIgICAgICA6IDAsXG4gIFNPVVJDRV9JTiAgICAgICAgOiAxLFxuICBTT1VSQ0VfT1VUICAgICAgIDogMixcbiAgU09VUkNFX0FUT1AgICAgICA6IDMsXG4gIERFU1RJTkFUSU9OX09WRVIgOiA0LFxuICBERVNUSU5BVElPTl9JTiAgIDogNSxcbiAgREVTVElOQVRJT05fT1VUICA6IDYsXG4gIERFU1RJTkFUSU9OX0FUT1AgOiA3LFxuICBMSUdIVEVSICAgICAgICAgIDogOCxcbiAgQ09QWSAgICAgICAgICAgICA6IDksXG4gIFhPUiAgICAgICAgICAgICAgOiAxMCxcbiAgTVVMVElQTFkgICAgICAgICA6IDExLFxuICBTQ1JFRU4gICAgICAgICAgIDogMTIsXG4gIE9WRVJMQVkgICAgICAgICAgOiAxMyxcbiAgREFSS0VOICAgICAgICAgICA6IDE0LFxuICBMSUdIVEVOICAgICAgICAgIDogMTUsXG4gIENPTE9SX0RPREdFICAgICAgOiAxNixcbiAgQ09MT1JfQlVSTiAgICAgICA6IDE3LFxuICBIQVJEX0xJR0hUICAgICAgIDogMTgsXG4gIFNPRlRfTElHSFQgICAgICAgOiAxOSxcbiAgRElGRkVSRU5DRSAgICAgICA6IDIwLFxuICBFWENMVVNJT04gICAgICAgIDogMjEsXG4gIEhVRSAgICAgICAgICAgICAgOiAyMixcbiAgU0FUVVJBVElPTiAgICAgICA6IDIzLFxuICBDT0xPUiAgICAgICAgICAgIDogMjQsXG4gIExVTUlOT1NJVFkgICAgICAgOiAyNVxufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwLTIwMTQgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8gQW4gT0NhbWwgc3RyaW5nIGlzIGFuIG9iamVjdCB3aXRoIHRocmVlIGZpZWxkczpcbi8vIC0gdGFnICd0J1xuLy8gLSBsZW5ndGggJ2wnXG4vLyAtIGNvbnRlbnRzICdjJ1xuLy9cbi8vIFRoZSBjb250ZW50cyBvZiB0aGUgc3RyaW5nIGNhbiBiZSBlaXRoZXIgYSBKYXZhU2NyaXB0IGFycmF5IG9yXG4vLyBhIEphdmFTY3JpcHQgc3RyaW5nLiBUaGUgbGVuZ3RoIG9mIHRoaXMgc3RyaW5nIGNhbiBiZSBsZXNzIHRoYW4gdGhlXG4vLyBsZW5ndGggb2YgdGhlIE9DYW1sIHN0cmluZy4gSW4gdGhpcyBjYXNlLCByZW1haW5pbmcgYnl0ZXMgYXJlXG4vLyBhc3N1bWVkIHRvIGJlIHplcm9lcy4gQXJyYXlzIGFyZSBtdXRhYmxlIGJ1dCBjb25zdW1lcyBtb3JlIG1lbW9yeVxuLy8gdGhhbiBzdHJpbmdzLiBBIGNvbW1vbiBwYXR0ZXJuIGlzIHRvIHN0YXJ0IGZyb20gYW4gZW1wdHkgc3RyaW5nIGFuZFxuLy8gcHJvZ3Jlc3NpdmVseSBmaWxsIGl0IGZyb20gdGhlIHN0YXJ0LiBQYXJ0aWFsIHN0cmluZ3MgbWFrZXMgaXRcbi8vIHBvc3NpYmxlIHRvIGltcGxlbWVudCB0aGlzIGVmZmljaWVudGx5LlxuLy9cbi8vIFdoZW4gY29udmVydGluZyB0byBhbmQgZnJvbSBVVEYtMTYsIHdlIGtlZXAgdHJhY2sgb2Ygd2hldGhlciB0aGVcbi8vIHN0cmluZyBpcyBjb21wb3NlZCBvbmx5IG9mIEFTQ0lJIGNoYXJhY3RlcnMgKGluIHdoaWNoIGNhc2UsIG5vXG4vLyBjb252ZXJzaW9uIG5lZWRzIHRvIGJlIHBlcmZvcm1lZCkgb3Igbm90LlxuLy9cbi8vIFRoZSBzdHJpbmcgdGFnIGNhbiB0aHVzIHRha2UgdGhlIGZvbGxvd2luZyB2YWx1ZXM6XG4vLyAgIGZ1bGwgc3RyaW5nICAgICBCWVRFIHwgVU5LTk9XTjogICAgICAwXG4vLyAgICAgICAgICAgICAgICAgICBCWVRFIHwgQVNDSUk6ICAgICAgICA5XG4vLyAgICAgICAgICAgICAgICAgICBCWVRFIHwgTk9UX0FTQ0lJOiAgICA4XG4vLyAgIHN0cmluZyBwcmVmaXggICBQQVJUSUFMOiAgICAgICAgICAgICAyXG4vLyAgIGFycmF5ICAgICAgICAgICBBUlJBWTogICAgICAgICAgICAgICA0XG4vL1xuLy8gT25lIGNhbiB1c2UgYml0IG1hc2tpbmcgdG8gZGlzY3JpbWluYXRlIHRoZXNlIGRpZmZlcmVudCBjYXNlczpcbi8vICAga25vd25fZW5jb2RpbmcoeCkgPSB4Jjhcbi8vICAgaXNfYXNjaWkoeCkgPSAgICAgICB4JjFcbi8vICAga2luZCh4KSA9ICAgICAgICAgICB4JjZcblxuLy9Qcm92aWRlczogY2FtbF9zdHJfcmVwZWF0XG5mdW5jdGlvbiBjYW1sX3N0cl9yZXBlYXQobiwgcykge1xuICBpZihuID09IDApIHJldHVybiBcIlwiO1xuICBpZiAocy5yZXBlYXQpIHtyZXR1cm4gcy5yZXBlYXQobik7fSAvLyBFQ01Bc2NyaXB0IDYgYW5kIEZpcmVmb3ggMjQrXG4gIHZhciByID0gXCJcIiwgbCA9IDA7XG4gIGZvcig7Oykge1xuICAgIGlmIChuICYgMSkgciArPSBzO1xuICAgIG4gPj49IDE7XG4gICAgaWYgKG4gPT0gMCkgcmV0dXJuIHI7XG4gICAgcyArPSBzO1xuICAgIGwrKztcbiAgICBpZiAobCA9PSA5KSB7XG4gICAgICBzLnNsaWNlKDAsMSk7IC8vIGZsYXR0ZW4gdGhlIHN0cmluZ1xuICAgICAgLy8gdGhlbiwgdGhlIGZsYXR0ZW5pbmcgb2YgdGhlIHdob2xlIHN0cmluZyB3aWxsIGJlIGZhc3RlcixcbiAgICAgIC8vIGFzIGl0IHdpbGwgYmUgY29tcG9zZWQgb2YgbGFyZ2VyIHBpZWNlc1xuICAgIH1cbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N1YmFycmF5X3RvX2pzYnl0ZXNcbi8vV2Vha2RlZlxuLy8gUHJlIEVDTUFTY3JpcHQgNSwgW2FwcGx5XSB3b3VsZCBub3Qgc3VwcG9ydCBhcnJheS1saWtlIG9iamVjdC5cbi8vIEluIHN1Y2ggc2V0dXAsIFR5cGVkX2FycmF5IHdvdWxkIGJlIGltcGxlbWVudGVkIGFzIHBvbHlmaWxsLCBhbmQgW2YuYXBwbHldIHdvdWxkXG4vLyBmYWlsIGhlcmUuIE1hcmsgdGhlIHByaW1pdGl2ZSBhcyBXZWFrZGVmLCBzbyB0aGF0IHBlb3BsZSBjYW4gb3ZlcnJpZGUgaXQgZWFzaWx5LlxuZnVuY3Rpb24gY2FtbF9zdWJhcnJheV90b19qc2J5dGVzIChhLCBpLCBsZW4pIHtcbiAgdmFyIGYgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuICBpZiAoaSA9PSAwICYmIGxlbiA8PSA0MDk2ICYmIGxlbiA9PSBhLmxlbmd0aCkgcmV0dXJuIGYuYXBwbHkgKG51bGwsIGEpO1xuICB2YXIgcyA9IFwiXCI7XG4gIGZvciAoOyAwIDwgbGVuOyBpICs9IDEwMjQsbGVuLT0xMDI0KVxuICAgIHMgKz0gZi5hcHBseSAobnVsbCwgYS5zbGljZShpLGkgKyBNYXRoLm1pbihsZW4sIDEwMjQpKSk7XG4gIHJldHVybiBzO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3V0Zjhfb2ZfdXRmMTZcbmZ1bmN0aW9uIGNhbWxfdXRmOF9vZl91dGYxNihzKSB7XG4gIGZvciAodmFyIGIgPSBcIlwiLCB0ID0gYiwgYywgZCwgaSA9IDAsIGwgPSBzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGMgPSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGMgPCAweDgwKSB7XG4gICAgICBmb3IgKHZhciBqID0gaSArIDE7IChqIDwgbCkgJiYgKGMgPSBzLmNoYXJDb2RlQXQoaikpIDwgMHg4MDsgaisrKTtcbiAgICAgIGlmIChqIC0gaSA+IDUxMikgeyB0LnN1YnN0cigwLCAxKTsgYiArPSB0OyB0ID0gXCJcIjsgYiArPSBzLnNsaWNlKGksIGopIH1cbiAgICAgIGVsc2UgdCArPSBzLnNsaWNlKGksIGopO1xuICAgICAgaWYgKGogPT0gbCkgYnJlYWs7XG4gICAgICBpID0gajtcbiAgICB9XG4gICAgaWYgKGMgPCAweDgwMCkge1xuICAgICAgdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4YzAgfCAoYyA+PiA2KSk7XG4gICAgICB0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHg4MCB8IChjICYgMHgzZikpO1xuICAgIH0gZWxzZSBpZiAoYyA8IDB4ZDgwMCB8fCBjID49IDB4ZGZmZikge1xuICAgICAgdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZTAgfCAoYyA+PiAxMiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg4MCB8ICgoYyA+PiA2KSAmIDB4M2YpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4ODAgfCAoYyAmIDB4M2YpKTtcbiAgICB9IGVsc2UgaWYgKGMgPj0gMHhkYmZmIHx8IGkgKyAxID09IGwgfHxcbiAgICAgICAgICAgICAgIChkID0gcy5jaGFyQ29kZUF0KGkgKyAxKSkgPCAweGRjMDAgfHwgZCA+IDB4ZGZmZikge1xuICAgICAgLy8gVW5tYXRjaGVkIHN1cnJvZ2F0ZSBwYWlyLCByZXBsYWNlZCBieSBcXHVmZmZkIChyZXBsYWNlbWVudCBjaGFyYWN0ZXIpXG4gICAgICB0ICs9IFwiXFx4ZWZcXHhiZlxceGJkXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGkrKztcbiAgICAgIGMgPSAoYyA8PCAxMCkgKyBkIC0gMHgzNWZkYzAwO1xuICAgICAgdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZjAgfCAoYyA+PiAxOCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg4MCB8ICgoYyA+PiAxMikgJiAweDNmKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDgwIHwgKChjID4+IDYpICYgMHgzZiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg4MCB8IChjICYgMHgzZikpO1xuICAgIH1cbiAgICBpZiAodC5sZW5ndGggPiAxMDI0KSB7dC5zdWJzdHIoMCwgMSk7IGIgKz0gdDsgdCA9IFwiXCI7fVxuICB9XG4gIHJldHVybiBiK3Q7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdXRmMTZfb2ZfdXRmOFxuZnVuY3Rpb24gY2FtbF91dGYxNl9vZl91dGY4KHMpIHtcbiAgZm9yICh2YXIgYiA9IFwiXCIsIHQgPSBcIlwiLCBjLCBjMSwgYzIsIHYsIGkgPSAwLCBsID0gcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBjMSA9IHMuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoYzEgPCAweDgwKSB7XG4gICAgICBmb3IgKHZhciBqID0gaSArIDE7IChqIDwgbCkgJiYgKGMxID0gcy5jaGFyQ29kZUF0KGopKSA8IDB4ODA7IGorKyk7XG4gICAgICBpZiAoaiAtIGkgPiA1MTIpIHsgdC5zdWJzdHIoMCwgMSk7IGIgKz0gdDsgdCA9IFwiXCI7IGIgKz0gcy5zbGljZShpLCBqKSB9XG4gICAgICBlbHNlIHQgKz0gcy5zbGljZShpLCBqKTtcbiAgICAgIGlmIChqID09IGwpIGJyZWFrO1xuICAgICAgaSA9IGo7XG4gICAgfVxuICAgIHYgPSAxO1xuICAgIGlmICgoKytpIDwgbCkgJiYgKCgoYzIgPSBzLmNoYXJDb2RlQXQoaSkpICYgLTY0KSA9PSAxMjgpKSB7XG4gICAgICBjID0gYzIgKyAoYzEgPDwgNik7XG4gICAgICBpZiAoYzEgPCAweGUwKSB7XG4gICAgICAgIHYgPSBjIC0gMHgzMDgwO1xuICAgICAgICBpZiAodiA8IDB4ODApIHYgPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdiA9IDI7XG4gICAgICAgIGlmICgoKytpIDwgbCkgJiYgKCgoYzIgPSBzLmNoYXJDb2RlQXQoaSkpICYgLTY0KSA9PSAxMjgpKSB7XG4gICAgICAgICAgYyA9IGMyICsgKGMgPDwgNik7XG4gICAgICAgICAgaWYgKGMxIDwgMHhmMCkge1xuICAgICAgICAgICAgdiA9IGMgLSAweGUyMDgwO1xuICAgICAgICAgICAgaWYgKCh2IDwgMHg4MDApIHx8ICgodiA+PSAweGQ3ZmYpICYmICh2IDwgMHhlMDAwKSkpIHYgPSAyO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2ID0gMztcbiAgICAgICAgICAgIGlmICgoKytpIDwgbCkgJiYgKCgoYzIgPSBzLmNoYXJDb2RlQXQoaSkpICYgLTY0KSA9PSAxMjgpICYmXG4gICAgICAgICAgICAgICAgKGMxIDwgMHhmNSkpIHtcbiAgICAgICAgICAgICAgdiA9IGMyIC0gMHgzYzgyMDgwICsgKGMgPDwgNik7XG4gICAgICAgICAgICAgIGlmICh2IDwgMHgxMDAwMCB8fCB2ID4gMHgxMGZmZmYpIHYgPSAzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAodiA8IDQpIHsgLy8gSW52YWxpZCBzZXF1ZW5jZVxuICAgICAgaSAtPSB2O1xuICAgICAgdCArPSBcIlxcdWZmZmRcIjtcbiAgICB9IGVsc2UgaWYgKHYgPiAweGZmZmYpXG4gICAgICB0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhkN2MwICsgKHYgPj4gMTApLCAweGRjMDAgKyAodiAmIDB4M0ZGKSlcbiAgICBlbHNlXG4gICAgICB0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodik7XG4gICAgaWYgKHQubGVuZ3RoID4gMTAyNCkge3Quc3Vic3RyKDAsIDEpOyBiICs9IHQ7IHQgPSBcIlwiO31cbiAgfVxuICByZXR1cm4gYit0O1xufVxuXG4vL1Byb3ZpZGVzOiBqc29vX2lzX2FzY2lpXG5mdW5jdGlvbiBqc29vX2lzX2FzY2lpIChzKSB7XG4gIC8vIFRoZSByZWd1bGFyIGV4cHJlc3Npb24gZ2V0cyBiZXR0ZXIgYXQgYXJvdW5kIHRoaXMgcG9pbnQgZm9yIGFsbCBicm93c2Vyc1xuICBpZiAocy5sZW5ndGggPCAyNCkge1xuICAgIC8vIFNwaWRlcm1vbmtleSBnZXRzIG11Y2ggc2xvd2VyIHdoZW4gcy5sZW5ndGggPj0gMjQgKG9uIDY0IGJpdCBhcmNocylcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHMubGVuZ3RoOyBpKyspIGlmIChzLmNoYXJDb2RlQXQoaSkgPiAxMjcpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlXG4gICAgcmV0dXJuICEvW15cXHgwMC1cXHg3Zl0vLnRlc3Qocyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfdW5zYWZlX2dldCBtdXRhYmxlXG5mdW5jdGlvbiBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQgKHMsIGkpIHtcbiAgc3dpdGNoIChzLnQgJiA2KSB7XG4gIGRlZmF1bHQ6IC8qIFBBUlRJQUwgKi9cbiAgICBpZiAoaSA+PSBzLmMubGVuZ3RoKSByZXR1cm4gMDtcbiAgY2FzZSAwOiAvKiBCWVRFUyAqL1xuICAgIHJldHVybiBzLmMuY2hhckNvZGVBdChpKTtcbiAgY2FzZSA0OiAvKiBBUlJBWSAqL1xuICAgIHJldHVybiBzLmNbaV1cbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX3Vuc2FmZV9zZXRcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9ieXRlc190b19hcnJheVxuZnVuY3Rpb24gY2FtbF9ieXRlc191bnNhZmVfc2V0IChzLCBpLCBjKSB7XG4gIC8vIFRoZSBPQ2FtbCBjb21waWxlciB1c2VzIENoYXIudW5zYWZlX2NociBvbiBpbnRlZ2VycyBsYXJnZXIgdGhhbiAyNTUhXG4gIGMgJj0gMHhmZjtcbiAgaWYgKHMudCAhPSA0IC8qIEFSUkFZICovKSB7XG4gICAgaWYgKGkgPT0gcy5jLmxlbmd0aCkge1xuICAgICAgcy5jICs9IFN0cmluZy5mcm9tQ2hhckNvZGUgKGMpO1xuICAgICAgaWYgKGkgKyAxID09IHMubCkgcy50ID0gMDsgLypCWVRFUyB8IFVOS09XTiovXG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5IChzKTtcbiAgfVxuICBzLmNbaV0gPSBjO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfYm91bmRfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IgKCkge1xuICBjYW1sX2ludmFsaWRfYXJndW1lbnQgKFwiaW5kZXggb3V0IG9mIGJvdW5kc1wiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yICgpIHtcbiAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50IChcImluZGV4IG91dCBvZiBib3VuZHNcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2dldFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IsIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9zdHJpbmdfZ2V0IChzLCBpKSB7XG4gIGlmIChpID4+PiAwID49IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSkgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IoKTtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19nZXQxNlxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfdW5zYWZlX2dldCwgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9zdHJpbmdfZ2V0MTYocyxpKSB7XG4gIGlmIChpID4+PiAwID49IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSAtIDEpIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yKCk7XG4gIHZhciBiMSA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkpLFxuICAgICAgYjIgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpICsgMSk7XG4gIHJldHVybiAoYjIgPDwgOCB8IGIxKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19nZXQxNlxuLy9SZXF1aXJlczogY2FtbF9ieXRlc191bnNhZmVfZ2V0LCBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2dldDE2KHMsaSkge1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwgLSAxKSBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yKCk7XG4gIHZhciBiMSA9IGNhbWxfYnl0ZXNfdW5zYWZlX2dldCAocywgaSksXG4gICAgICBiMiA9IGNhbWxfYnl0ZXNfdW5zYWZlX2dldCAocywgaSArIDEpO1xuICByZXR1cm4gKGIyIDw8IDggfCBiMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2dldDMyXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0LCBjYW1sX3N0cmluZ19ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19nZXQzMihzLGkpIHtcbiAgaWYgKGkgPj4+IDAgPj0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpIC0gMykgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGIxID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSksXG4gICAgICBiMiA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkgKyAxKSxcbiAgICAgIGIzID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSArIDIpLFxuICAgICAgYjQgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpICsgMyk7XG4gIHJldHVybiAoYjQgPDwgMjQgfCBiMyA8PCAxNiB8IGIyIDw8IDggfCBiMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfZ2V0MzJcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfdW5zYWZlX2dldCwgY2FtbF9ieXRlc19ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9ieXRlc19nZXQzMihzLGkpIHtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sIC0gMykgY2FtbF9ieXRlc19ib3VuZF9lcnJvcigpO1xuICB2YXIgYjEgPSBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQgKHMsIGkpLFxuICAgICAgYjIgPSBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQgKHMsIGkgKyAxKSxcbiAgICAgIGIzID0gY2FtbF9ieXRlc191bnNhZmVfZ2V0IChzLCBpICsgMiksXG4gICAgICBiNCA9IGNhbWxfYnl0ZXNfdW5zYWZlX2dldCAocywgaSArIDMpO1xuICByZXR1cm4gKGI0IDw8IDI0IHwgYjMgPDwgMTYgfCBiMiA8PCA4IHwgYjEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19nZXQ2NFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfdW5zYWZlX2dldCwgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9zdHJpbmdfZ2V0NjQocyxpKSB7XG4gIGlmIChpID4+PiAwID49IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSAtIDcpIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yKCk7XG4gIHZhciBhID0gbmV3IEFycmF5KDgpO1xuICBmb3IodmFyIGogPSAwOyBqIDwgODsgaisrKXtcbiAgICBhWzcgLSBqXSA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkgKyBqKTtcbiAgfVxuICByZXR1cm4gY2FtbF9pbnQ2NF9vZl9ieXRlcyhhKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19nZXQ2NFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc191bnNhZmVfZ2V0LCBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2dldDY0KHMsaSkge1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwgLSA3KSBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yKCk7XG4gIHZhciBhID0gbmV3IEFycmF5KDgpO1xuICBmb3IodmFyIGogPSAwOyBqIDwgODsgaisrKXtcbiAgICBhWzcgLSBqXSA9IGNhbWxfYnl0ZXNfdW5zYWZlX2dldCAocywgaSArIGopO1xuICB9XG4gIHJldHVybiBjYW1sX2ludDY0X29mX2J5dGVzKGEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2dldFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19ib3VuZF9lcnJvciwgY2FtbF9ieXRlc191bnNhZmVfZ2V0XG5mdW5jdGlvbiBjYW1sX2J5dGVzX2dldCAocywgaSkge1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwpIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IoKTtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfdW5zYWZlX2dldCAocywgaSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3NldFxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19zZXQgKHMsIGksIGMpIHtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfc3RyaW5nX3NldFwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ191bnNhZmVfc2V0LCBjYW1sX3N0cmluZ19ib3VuZF9lcnJvclxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfc2V0IChzLCBpLCBjKSB7XG4gIGlmIChpID4+PiAwID49IHMubCkgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IoKTtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX3Vuc2FmZV9zZXQgKHMsIGksIGMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX3NldDE2XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yLCBjYW1sX2J5dGVzX3Vuc2FmZV9zZXRcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfc2V0MTYocyxpLGkxNil7XG4gIGlmIChpID4+PiAwID49IHMubCAtIDEpIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGIyID0gMHhGRiAmIGkxNiA+PiA4LFxuICAgICAgYjEgPSAweEZGICYgaTE2O1xuICBjYW1sX2J5dGVzX3Vuc2FmZV9zZXQgKHMsIGkgKyAwLCBiMSk7XG4gIGNhbWxfYnl0ZXNfdW5zYWZlX3NldCAocywgaSArIDEsIGIyKTtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfc2V0MTZcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfc2V0MTYocyxpLGkxNil7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3N0cmluZ19zZXQxNlwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfc2V0MTZcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfc2V0MTZcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3NldDE2KHMsaSxpMTYpe1xuICByZXR1cm4gY2FtbF9ieXRlc19zZXQxNihzLGksaTE2KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19zZXQzMlxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19ib3VuZF9lcnJvciwgY2FtbF9ieXRlc191bnNhZmVfc2V0XG5mdW5jdGlvbiBjYW1sX2J5dGVzX3NldDMyKHMsaSxpMzIpe1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwgLSAzKSBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yKCk7XG4gIHZhciBiNCA9IDB4RkYgJiBpMzIgPj4gMjQsXG4gICAgICBiMyA9IDB4RkYgJiBpMzIgPj4gMTYsXG4gICAgICBiMiA9IDB4RkYgJiBpMzIgPj4gOCxcbiAgICAgIGIxID0gMHhGRiAmIGkzMjtcbiAgY2FtbF9ieXRlc191bnNhZmVfc2V0IChzLCBpICsgMCwgYjEpO1xuICBjYW1sX2J5dGVzX3Vuc2FmZV9zZXQgKHMsIGkgKyAxLCBiMik7XG4gIGNhbWxfYnl0ZXNfdW5zYWZlX3NldCAocywgaSArIDIsIGIzKTtcbiAgY2FtbF9ieXRlc191bnNhZmVfc2V0IChzLCBpICsgMywgYjQpO1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19zZXQzMlxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19zZXQzMihzLGksaTMyKXtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfc3RyaW5nX3NldDMyXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19zZXQzMlxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19zZXQzMlxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfc2V0MzIocyxpLGkzMil7XG4gIHJldHVybiBjYW1sX2J5dGVzX3NldDMyKHMsaSxpMzIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX3NldDY0XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yLCBjYW1sX2J5dGVzX3Vuc2FmZV9zZXRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfdG9fYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfc2V0NjQocyxpLGk2NCl7XG4gIGlmIChpID4+PiAwID49IHMubCAtIDcpIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGEgPSBjYW1sX2ludDY0X3RvX2J5dGVzKGk2NCk7XG4gIGZvcih2YXIgaiA9IDA7IGogPCA4OyBqKyspIHtcbiAgICBjYW1sX2J5dGVzX3Vuc2FmZV9zZXQgKHMsIGkgKyA3IC0gaiwgYVtqXSk7XG4gIH1cbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfc2V0NjRcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfc2V0NjQocyxpLGk2NCl7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3N0cmluZ19zZXQ2NFwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfc2V0NjRcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfc2V0NjRcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3NldDY0KHMsaSxpNjQpe1xuICByZXR1cm4gY2FtbF9ieXRlc19zZXQ2NChzLGksaTY0KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19zZXRcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IsIGNhbWxfYnl0ZXNfdW5zYWZlX3NldFxuZnVuY3Rpb24gY2FtbF9ieXRlc19zZXQgKHMsIGksIGMpIHtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sKSBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yKCk7XG4gIHJldHVybiBjYW1sX2J5dGVzX3Vuc2FmZV9zZXQgKHMsIGksIGMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX29mX3V0ZjE2X2pzc3RyaW5nXG4vL1JlcXVpcmVzOiBqc29vX2lzX2FzY2lpLCBjYW1sX3V0Zjhfb2ZfdXRmMTYsIE1sQnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfb2ZfdXRmMTZfanNzdHJpbmcgKHMpIHtcbiAgdmFyIHRhZyA9IDkgLyogQllURVMgfCBBU0NJSSAqLztcbiAgaWYgKCFqc29vX2lzX2FzY2lpKHMpKVxuICAgIHRhZyA9IDggLyogQllURVMgfCBOT1RfQVNDSUkgKi8sIHMgPSBjYW1sX3V0Zjhfb2ZfdXRmMTYocyk7XG4gIHJldHVybiBuZXcgTWxCeXRlcyh0YWcsIHMsIHMubGVuZ3RoKTtcbn1cblxuXG4vL1Byb3ZpZGVzOiBNbEJ5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzLCBqc29vX2lzX2FzY2lpLCBjYW1sX3V0ZjE2X29mX3V0ZjhcbmZ1bmN0aW9uIE1sQnl0ZXMgKHRhZywgY29udGVudHMsIGxlbmd0aCkge1xuICB0aGlzLnQ9dGFnOyB0aGlzLmM9Y29udGVudHM7IHRoaXMubD1sZW5ndGg7XG59XG5NbEJ5dGVzLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCl7XG4gIHN3aXRjaCAodGhpcy50KSB7XG4gIGNhc2UgOTogLypCWVRFUyB8IEFTQ0lJKi9cbiAgICByZXR1cm4gdGhpcy5jO1xuICBkZWZhdWx0OlxuICAgIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXModGhpcyk7XG4gIGNhc2UgMDogLypCWVRFUyB8IFVOS09XTiovXG4gICAgaWYgKGpzb29faXNfYXNjaWkodGhpcy5jKSkge1xuICAgICAgdGhpcy50ID0gOTsgLypCWVRFUyB8IEFTQ0lJKi9cbiAgICAgIHJldHVybiB0aGlzLmM7XG4gICAgfVxuICAgIHRoaXMudCA9IDg7IC8qQllURVMgfCBOT1RfQVNDSUkqL1xuICBjYXNlIDg6IC8qQllURVMgfCBOT1RfQVNDSUkqL1xuICAgIHJldHVybiB0aGlzLmM7XG4gIH1cbn07XG5NbEJ5dGVzLnByb3RvdHlwZS50b1V0ZjE2ID0gZnVuY3Rpb24gKCl7XG4gIHZhciByID0gdGhpcy50b1N0cmluZygpO1xuICBpZih0aGlzLnQgPT0gOSkgcmV0dXJuIHJcbiAgcmV0dXJuIGNhbWxfdXRmMTZfb2ZfdXRmOChyKTtcbn1cbk1sQnl0ZXMucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gKCl7XG4gIHZhciBjb250ZW50ID0gdGhpcy50ID09IDQgPyB0aGlzLmMuc2xpY2UoKSA6IHRoaXMuYztcbiAgcmV0dXJuIG5ldyBNbEJ5dGVzKHRoaXMudCxjb250ZW50LHRoaXMubCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfc3RyX3JlcGVhdCwgY2FtbF9zdWJhcnJheV90b19qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzIChzKSB7XG4gIC8qIEFzc3VtZXMgbm90IEJZVEVTICovXG4gIGlmIChzLnQgPT0gMiAvKiBQQVJUSUFMICovKVxuICAgIHMuYyArPSBjYW1sX3N0cl9yZXBlYXQocy5sIC0gcy5jLmxlbmd0aCwgJ1xcMCcpXG4gIGVsc2VcbiAgICBzLmMgPSBjYW1sX3N1YmFycmF5X3RvX2pzYnl0ZXMgKHMuYywgMCwgcy5jLmxlbmd0aCk7XG4gIHMudCA9IDA7IC8qQllURVMgfCBVTktPV04qL1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfY29udmVydF9ieXRlc190b19hcnJheSAocykge1xuICAvKiBBc3N1bWVzIG5vdCBBUlJBWSAqL1xuICB2YXIgYSA9IG5ldyBVaW50OEFycmF5KHMubCk7XG4gIHZhciBiID0gcy5jLCBsID0gYi5sZW5ndGgsIGkgPSAwO1xuICBmb3IgKDsgaSA8IGw7IGkrKykgYVtpXSA9IGIuY2hhckNvZGVBdChpKTtcbiAgZm9yIChsID0gcy5sOyBpIDwgbDsgaSsrKSBhW2ldID0gMDtcbiAgcy5jID0gYTtcbiAgcy50ID0gNDsgLyogQVJSQVkgKi9cbiAgcmV0dXJuIGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdWludDhfYXJyYXlfb2ZfYnl0ZXMgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5XG5mdW5jdGlvbiBjYW1sX3VpbnQ4X2FycmF5X29mX2J5dGVzIChzKSB7XG4gIGlmIChzLnQgIT0gNCAvKiBBUlJBWSAqLykgY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5KHMpO1xuICByZXR1cm4gcy5jO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VpbnQ4X2FycmF5X29mX3N0cmluZyBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aCwgY2FtbF9zdHJpbmdfdW5zYWZlX2dldFxuZnVuY3Rpb24gY2FtbF91aW50OF9hcnJheV9vZl9zdHJpbmcgKHMpIHtcbiAgdmFyIGwgPSBjYW1sX21sX3N0cmluZ19sZW5ndGgocyk7XG4gIHZhciBhID0gbmV3IFVpbnQ4QXJyYXkobCk7XG4gIHZhciBpID0gMDtcbiAgZm9yICg7IGkgPCBsOyBpKyspIGFbaV0gPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0KHMsaSk7XG4gIHJldHVybiBhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NyZWF0ZV9zdHJpbmcgY29uc3Rcbi8vUmVxdWlyZXM6IE1sQnl0ZXMsIGNhbWxfaW52YWxpZF9hcmd1bWVudFxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9jcmVhdGVfc3RyaW5nKGxlbikge1xuICBpZihsZW4gPCAwKSBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJTdHJpbmcuY3JlYXRlXCIpO1xuICByZXR1cm4gbmV3IE1sQnl0ZXMobGVuPzI6OSxcIlwiLGxlbik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY3JlYXRlX3N0cmluZyBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfY3JlYXRlX3N0cmluZyhsZW4pIHtcbiAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiU3RyaW5nLmNyZWF0ZVwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jcmVhdGVfYnl0ZXMgY29uc3Rcbi8vUmVxdWlyZXM6IE1sQnl0ZXMsY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX2NyZWF0ZV9ieXRlcyhsZW4pIHtcbiAgaWYgKGxlbiA8IDApIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJ5dGVzLmNyZWF0ZVwiKTtcbiAgcmV0dXJuIG5ldyBNbEJ5dGVzKGxlbj8yOjksXCJcIixsZW4pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19vZl9hcnJheVxuLy9SZXF1aXJlczogY2FtbF9zdWJhcnJheV90b19qc2J5dGVzLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19vZl9hcnJheSAoYSkge1xuICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhjYW1sX3N1YmFycmF5X3RvX2pzYnl0ZXMoYSwwLGEubGVuZ3RoKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfb2ZfYXJyYXlcbi8vUmVxdWlyZXM6IE1sQnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfb2ZfYXJyYXkgKGEpIHtcbiAgaWYoISAoYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgYSA9IG5ldyBVaW50OEFycmF5KGEpO1xuICB9XG4gIHJldHVybiBuZXcgTWxCeXRlcyg0LGEsYS5sZW5ndGgpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2NvbXBhcmUgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlc1xuZnVuY3Rpb24gY2FtbF9ieXRlc19jb21wYXJlKHMxLCBzMikge1xuICAoczEudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczEpO1xuICAoczIudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczIpO1xuICByZXR1cm4gKHMxLmMgPCBzMi5jKT8tMTooczEuYyA+IHMyLmMpPzE6MDtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2VxdWFsIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfZXF1YWwoczEsIHMyKSB7XG4gIGlmKHMxID09PSBzMikgcmV0dXJuIDE7XG4gIChzMS50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzMSk7XG4gIChzMi50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzMik7XG4gIHJldHVybiAoczEuYyA9PSBzMi5jKT8xOjA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX25vdGVxdWFsIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX2VxdWFsXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19ub3RlcXVhbChzMSwgczIpIHsgcmV0dXJuIDEtY2FtbF9zdHJpbmdfZXF1YWwoczEsIHMyKTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX25vdGVxdWFsIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfZXF1YWxcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfbm90ZXF1YWwoczEsIHMyKSB7IHJldHVybiAxLWNhbWxfYnl0ZXNfZXF1YWwoczEsIHMyKTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2xlc3NlcXVhbCBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2xlc3NlcXVhbChzMSwgczIpIHtcbiAgKHMxLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMxKTtcbiAgKHMyLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMyKTtcbiAgcmV0dXJuIChzMS5jIDw9IHMyLmMpPzE6MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19sZXNzdGhhbiBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2xlc3N0aGFuKHMxLCBzMikge1xuICAoczEudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczEpO1xuICAoczIudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczIpO1xuICByZXR1cm4gKHMxLmMgPCBzMi5jKT8xOjA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2dyZWF0ZXJlcXVhbFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfbGVzc2VxdWFsXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19ncmVhdGVyZXF1YWwoczEsIHMyKSB7XG4gIHJldHVybiBjYW1sX3N0cmluZ19sZXNzZXF1YWwoczIsczEpO1xufVxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19ncmVhdGVyZXF1YWxcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfbGVzc2VxdWFsXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2dyZWF0ZXJlcXVhbChzMSwgczIpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfbGVzc2VxdWFsKHMyLHMxKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfZ3JlYXRlcnRoYW5cbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX2xlc3N0aGFuXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19ncmVhdGVydGhhbihzMSwgczIpIHtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX2xlc3N0aGFuKHMyLCBzMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfZ3JlYXRlcnRoYW5cbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfbGVzc3RoYW5cbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfZ3JlYXRlcnRoYW4oczEsIHMyKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX2xlc3N0aGFuKHMyLCBzMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmlsbF9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9zdHJfcmVwZWF0LCBjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXlcbi8vQWxpYXM6IGNhbWxfZmlsbF9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfZmlsbF9ieXRlcyhzLCBpLCBsLCBjKSB7XG4gIGlmIChsID4gMCkge1xuICAgIGlmIChpID09IDAgJiYgKGwgPj0gcy5sIHx8IChzLnQgPT0gMiAvKiBQQVJUSUFMICovICYmIGwgPj0gcy5jLmxlbmd0aCkpKSB7XG4gICAgICBpZiAoYyA9PSAwKSB7XG4gICAgICAgIHMuYyA9IFwiXCI7XG4gICAgICAgIHMudCA9IDI7IC8qIFBBUlRJQUwgKi9cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMuYyA9IGNhbWxfc3RyX3JlcGVhdCAobCwgU3RyaW5nLmZyb21DaGFyQ29kZShjKSk7XG4gICAgICAgIHMudCA9IChsID09IHMubCk/MCAvKiBCWVRFUyB8IFVOS09XTiAqLyA6MjsgLyogUEFSVElBTCAqL1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocy50ICE9IDQgLyogQVJSQVkgKi8pIGNhbWxfY29udmVydF9ieXRlc190b19hcnJheShzKTtcbiAgICAgIGZvciAobCArPSBpOyBpIDwgbDsgaSsrKSBzLmNbaV0gPSBjO1xuICAgIH1cbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ibGl0X2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX3N1YmFycmF5X3RvX2pzYnl0ZXMsIGNhbWxfY29udmVydF9ieXRlc190b19hcnJheVxuZnVuY3Rpb24gY2FtbF9ibGl0X2J5dGVzKHMxLCBpMSwgczIsIGkyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PSAwKSByZXR1cm4gMDtcbiAgaWYgKChpMiA9PSAwKSAmJlxuICAgICAgKGxlbiA+PSBzMi5sIHx8IChzMi50ID09IDIgLyogUEFSVElBTCAqLyAmJiBsZW4gPj0gczIuYy5sZW5ndGgpKSkge1xuICAgIHMyLmMgPSAoczEudCA9PSA0IC8qIEFSUkFZICovKT9cbiAgICAgIGNhbWxfc3ViYXJyYXlfdG9fanNieXRlcyhzMS5jLCBpMSwgbGVuKTpcbiAgICAgIChpMSA9PSAwICYmIHMxLmMubGVuZ3RoID09IGxlbik/czEuYzpzMS5jLnN1YnN0cihpMSwgbGVuKTtcbiAgICBzMi50ID0gKHMyLmMubGVuZ3RoID09IHMyLmwpPzAgLyogQllURVMgfCBVTktPV04gKi8gOjI7IC8qIFBBUlRJQUwgKi9cbiAgfSBlbHNlIGlmIChzMi50ID09IDIgLyogUEFSVElBTCAqLyAmJiBpMiA9PSBzMi5jLmxlbmd0aCkge1xuICAgIHMyLmMgKz0gKHMxLnQgPT0gNCAvKiBBUlJBWSAqLyk/XG4gICAgICBjYW1sX3N1YmFycmF5X3RvX2pzYnl0ZXMoczEuYywgaTEsIGxlbik6XG4gICAgICAoaTEgPT0gMCAmJiBzMS5jLmxlbmd0aCA9PSBsZW4pP3MxLmM6czEuYy5zdWJzdHIoaTEsIGxlbik7XG4gICAgczIudCA9IChzMi5jLmxlbmd0aCA9PSBzMi5sKT8wIC8qIEJZVEVTIHwgVU5LT1dOICovIDoyOyAvKiBQQVJUSUFMICovXG4gIH0gZWxzZSB7XG4gICAgaWYgKHMyLnQgIT0gNCAvKiBBUlJBWSAqLykgY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5KHMyKTtcbiAgICB2YXIgYzEgPSBzMS5jLCBjMiA9IHMyLmM7XG4gICAgaWYgKHMxLnQgPT0gNCAvKiBBUlJBWSAqLykge1xuICAgICAgaWYgKGkyIDw9IGkxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIGMyIFtpMiArIGldID0gYzEgW2kxICsgaV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpID0gbGVuIC0gMTsgaSA+PSAwOyBpLS0pIGMyIFtpMiArIGldID0gYzEgW2kxICsgaV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBsID0gTWF0aC5taW4gKGxlbiwgYzEubGVuZ3RoIC0gaTEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIGMyIFtpMiArIGldID0gYzEuY2hhckNvZGVBdChpMSArIGkpO1xuICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykgYzIgW2kyICsgaV0gPSAwO1xuICAgIH1cbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ibGl0X3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9ibGl0X2J5dGVzLCBjYW1sX2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9ibGl0X3N0cmluZyhhLGIsYyxkLGUpIHtcbiAgY2FtbF9ibGl0X2J5dGVzKGNhbWxfYnl0ZXNfb2Zfc3RyaW5nKGEpLGIsYyxkLGUpO1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2J5dGVzX2xlbmd0aCBjb25zdFxuZnVuY3Rpb24gY2FtbF9tbF9ieXRlc19sZW5ndGgocykgeyByZXR1cm4gcy5sIH1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfY29uY2F0XG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2NvbmNhdChhLGIpIHsgcmV0dXJuIGEgKyBiIH1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfY29uY2F0XG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzLCBNbEJ5dGVzXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19jb25jYXQoczEsczIpe1xuICAoczEudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczEpO1xuICAoczIudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczIpO1xuICByZXR1cm4gbmV3IE1sQnl0ZXMoczEudCxzMS5jK3MyLmMsczEubCtzMi5sKVxufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgY29uc3Rcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSkge1xuICByZXR1cm4gcy5jaGFyQ29kZUF0KGkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ191bnNhZmVfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3Vuc2FmZV9zZXQgKHMsIGksIGMpIHtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfc3RyaW5nX3Vuc2FmZV9zZXRcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aCBjb25zdFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX21sX3N0cmluZ19sZW5ndGgocykge1xuICByZXR1cm4gcy5sZW5ndGhcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfY29tcGFyZSBjb25zdFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19jb21wYXJlKHMxLCBzMikge1xuICByZXR1cm4gKHMxIDwgczIpPy0xOihzMSA+IHMyKT8xOjA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2VxdWFsIGNvbnN0XG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2VxdWFsKHMxLCBzMikge1xuICBpZihzMSA9PT0gczIpIHJldHVybiAxO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfbGVzc2VxdWFsIGNvbnN0XG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2xlc3NlcXVhbChzMSwgczIpIHtcbiAgcmV0dXJuIChzMSA8PSBzMik/MTowO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19sZXNzdGhhbiBjb25zdFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19sZXNzdGhhbihzMSwgczIpIHtcbiAgcmV0dXJuIChzMSA8IHMyKT8xOjA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX29mX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX29mX2J5dGVzKHMpIHtcbiAgKHMudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMocyk7XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKHMuYyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfb2Zfc3RyaW5nIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX29mX2pzYnl0ZXMsIGNhbWxfanNieXRlc19vZl9zdHJpbmdcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9ieXRlc19vZl9zdHJpbmcocykge1xuICByZXR1cm4gY2FtbF9ieXRlc19vZl9qc2J5dGVzKGNhbWxfanNieXRlc19vZl9zdHJpbmcocykpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzIGNvbnN0XG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoeCkgeyByZXR1cm4geCB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmcgY29uc3Rcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc2J5dGVzX29mX3N0cmluZyh4KSB7IHJldHVybiB4IH1cblxuLy9Qcm92aWRlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcgY29uc3Rcbi8vUmVxdWlyZXM6IGpzb29faXNfYXNjaWksIGNhbWxfdXRmMTZfb2ZfdXRmOFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhzKSB7XG4gIGlmKGpzb29faXNfYXNjaWkocykpXG4gICAgcmV0dXJuIHM7XG4gIHJldHVybiBjYW1sX3V0ZjE2X29mX3V0Zjgocyk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcgY29uc3Rcbi8vUmVxdWlyZXM6IGpzb29faXNfYXNjaWksIGNhbWxfdXRmOF9vZl91dGYxNiwgY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyAocykge1xuICBpZiAoanNvb19pc19hc2NpaShzKSlcbiAgICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhzKVxuICBlbHNlIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKGNhbWxfdXRmOF9vZl91dGYxNihzKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfb2ZfanNieXRlcyBjb25zdFxuLy9SZXF1aXJlczogTWxCeXRlc1xuZnVuY3Rpb24gY2FtbF9ieXRlc19vZl9qc2J5dGVzKHMpIHsgcmV0dXJuIG5ldyBNbEJ5dGVzKDAscyxzLmxlbmd0aCk7IH1cblxuXG4vLyBUaGUgc2VjdGlvbiBiZWxvdyBzaG91bGQgYmUgdXNlZCB3aGVuIHVzZS1qcy1zdHJpbmc9ZmFsc2VcblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfdW5zYWZlX2dldCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc191bnNhZmVfZ2V0XG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQocyxpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfdW5zYWZlX3NldFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc191bnNhZmVfc2V0XG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ191bnNhZmVfc2V0IChzLCBpLCBjKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX3Vuc2FmZV9zZXQocyxpLGMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGggY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfbWxfYnl0ZXNfbGVuZ3RoXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX21sX3N0cmluZ19sZW5ndGgocykge1xuICByZXR1cm4gY2FtbF9tbF9ieXRlc19sZW5ndGgocylcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfY29tcGFyZVxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19jb21wYXJlXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19jb21wYXJlKHMxLCBzMikge1xuICByZXR1cm4gY2FtbF9ieXRlc19jb21wYXJlKHMxLHMyKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19lcXVhbFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19lcXVhbFxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfZXF1YWwoczEsIHMyKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX2VxdWFsKHMxLHMyKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19sZXNzZXF1YWxcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfbGVzc2VxdWFsXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19sZXNzZXF1YWwoczEsIHMyKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX2xlc3NlcXVhbChzMSxzMilcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfbGVzc3RoYW5cbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfbGVzc3RoYW5cbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2xlc3N0aGFuKHMxLCBzMikge1xuICByZXR1cm4gY2FtbF9ieXRlc19sZXNzdGhhbihzMSxzMilcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfb2ZfYnl0ZXNcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX29mX2J5dGVzKHMpIHsgcmV0dXJuIHMgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX29mX3N0cmluZyBjb25zdFxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9ieXRlc19vZl9zdHJpbmcocykgeyByZXR1cm4gcyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfb2ZfanNieXRlc1xuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhzKSB7IHJldHVybiBjYW1sX2J5dGVzX29mX2pzYnl0ZXMocyk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZyBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlc1xuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhzKSB7XG4gIChzLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMpO1xuICByZXR1cm4gcy5jIH1cblxuLy9Qcm92aWRlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcgbXV0YWJsZSAoY29uc3QpXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhzKXtcbiAgcmV0dXJuIHMudG9VdGYxNigpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX29mX3V0ZjE2X2pzc3RyaW5nXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyAocykge1xuICByZXR1cm4gY2FtbF9ieXRlc19vZl91dGYxNl9qc3N0cmluZyhzKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pc19tbF9ieXRlc1xuLy9SZXF1aXJlczogTWxCeXRlc1xuZnVuY3Rpb24gY2FtbF9pc19tbF9ieXRlcyhzKSB7XG4gIHJldHVybiAocyBpbnN0YW5jZW9mIE1sQnl0ZXMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2J5dGVzX2NvbnRlbnRcbi8vUmVxdWlyZXM6IE1sQnl0ZXMsIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfbWxfYnl0ZXNfY29udGVudChzKSB7XG4gIHN3aXRjaCAocy50ICYgNikge1xuICBkZWZhdWx0OiAvKiBQQVJUSUFMICovXG4gICAgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzKTtcbiAgY2FzZSAwOiAvKiBCWVRFUyAqL1xuICAgIHJldHVybiBzLmM7XG4gIGNhc2UgNDpcbiAgICByZXR1cm4gcy5jXG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9pc19tbF9zdHJpbmdcbi8vUmVxdWlyZXM6IGpzb29faXNfYXNjaWlcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9pc19tbF9zdHJpbmcocykge1xuICByZXR1cm4gKHR5cGVvZiBzID09PSBcInN0cmluZ1wiICYmICEvW15cXHgwMC1cXHhmZl0vLnRlc3QocykpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lzX21sX3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9pc19tbF9ieXRlc1xuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9pc19tbF9zdHJpbmcocykge1xuICByZXR1cm4gY2FtbF9pc19tbF9ieXRlcyhzKTtcbn1cblxuLy8gVGhlIGZ1bmN0aW9ucyBiZWxvdyBhcmUgZGVwcmVjYXRlZFxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3RvX2J5dGVfc3RyaW5nIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX2pzX3RvX2J5dGVfc3RyaW5nKHMpIHsgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMocykgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX25ld19zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfbmV3X3N0cmluZyAocykgeyByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhzKSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZnJvbV9zdHJpbmcgbXV0YWJsZSAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc19mcm9tX3N0cmluZyhzKSB7XG4gIHJldHVybiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhzKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3RvX2pzX3N0cmluZyBtdXRhYmxlIChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3RvX2pzX3N0cmluZyhzKSB7XG4gIHJldHVybiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhzKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3RvX3N0cmluZyBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmdcbmZ1bmN0aW9uIGNhbWxfanNfdG9fc3RyaW5nIChzKSB7XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhzKTtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X29mX3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF91aW50OF9hcnJheV9vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfYXJyYXlfb2Zfc3RyaW5nKHgpIHsgcmV0dXJuIGNhbWxfdWludDhfYXJyYXlfb2Zfc3RyaW5nKHgpIH1cblxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9vZl9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF91aW50OF9hcnJheV9vZl9ieXRlc1xuZnVuY3Rpb24gY2FtbF9hcnJheV9vZl9ieXRlcyh4KSB7IHJldHVybiBjYW1sX3VpbnQ4X2FycmF5X29mX2J5dGVzKHgpIH1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxNCBKw6lyw7RtZSBWb3VpbGxvbiwgSHVnbyBIZXV6YXJkLCBBbmR5IFJheVxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuLy9cbi8vIEJpZ2FycmF5LlxuLy9cbi8vIC0gYWxsIGJpZ2FycmF5IHR5cGVzIGluY2x1ZGluZyBJbnQ2NCBhbmQgQ29tcGxleC5cbi8vIC0gZm9ydHJhbiArIGMgbGF5b3V0c1xuLy8gLSBzdWIvc2xpY2UvcmVzaGFwZVxuLy8gLSByZXRhaW4gZmFzdCBwYXRoIGZvciAxZCBhcnJheSBhY2Nlc3NcblxuLy9Qcm92aWRlczogY2FtbF9iYV9pbml0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2JhX2luaXQoKSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2dldF9zaXplXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfYmFfZ2V0X3NpemUoZGltcykge1xuICB2YXIgbl9kaW1zID0gZGltcy5sZW5ndGg7XG4gIHZhciBzaXplID0gMTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuX2RpbXM7IGkrKykge1xuICAgIGlmIChkaW1zW2ldIDwgMClcbiAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LmNyZWF0ZTogbmVnYXRpdmUgZGltZW5zaW9uXCIpO1xuICAgIHNpemUgPSBzaXplICogZGltc1tpXTtcbiAgfVxuICByZXR1cm4gc2l6ZTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudFxuZnVuY3Rpb24gY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudChraW5kKXtcbiAgc3dpdGNoKGtpbmQpe1xuICBjYXNlIDc6IGNhc2UgMTA6IGNhc2UgMTE6IHJldHVybiAyO1xuICBkZWZhdWx0OiByZXR1cm4gMTtcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2NyZWF0ZV9idWZmZXJcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnRcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9iYV9jcmVhdGVfYnVmZmVyKGtpbmQsIHNpemUpe1xuICB2YXIgdmlldztcbiAgc3dpdGNoKGtpbmQpe1xuICBjYXNlIDA6ICB2aWV3ID0gRmxvYXQzMkFycmF5OyBicmVhaztcbiAgY2FzZSAxOiAgdmlldyA9IEZsb2F0NjRBcnJheTsgYnJlYWs7XG4gIGNhc2UgMjogIHZpZXcgPSBJbnQ4QXJyYXk7IGJyZWFrO1xuICBjYXNlIDM6ICB2aWV3ID0gVWludDhBcnJheTsgYnJlYWs7XG4gIGNhc2UgNDogIHZpZXcgPSBJbnQxNkFycmF5OyBicmVhaztcbiAgY2FzZSA1OiAgdmlldyA9IFVpbnQxNkFycmF5OyBicmVhaztcbiAgY2FzZSA2OiAgdmlldyA9IEludDMyQXJyYXk7IGJyZWFrO1xuICBjYXNlIDc6ICB2aWV3ID0gSW50MzJBcnJheTsgYnJlYWs7XG4gIGNhc2UgODogIHZpZXcgPSBJbnQzMkFycmF5OyBicmVhaztcbiAgY2FzZSA5OiAgdmlldyA9IEludDMyQXJyYXk7IGJyZWFrO1xuICBjYXNlIDEwOiB2aWV3ID0gRmxvYXQzMkFycmF5OyBicmVhaztcbiAgY2FzZSAxMTogdmlldyA9IEZsb2F0NjRBcnJheTsgYnJlYWs7XG4gIGNhc2UgMTI6IHZpZXcgPSBVaW50OEFycmF5OyBicmVhaztcbiAgfVxuICBpZiAoIXZpZXcpIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LmNyZWF0ZTogdW5zdXBwb3J0ZWQga2luZFwiKTtcbiAgdmFyIGRhdGEgPSBuZXcgdmlldyhzaXplICogY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudChraW5kKSk7XG4gIHJldHVybiBkYXRhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2N1c3RvbV9uYW1lXG4vL1ZlcnNpb246IDwgNC4xMVxudmFyIGNhbWxfYmFfY3VzdG9tX25hbWUgPSBcIl9iaWdhcnJheVwiXG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfY3VzdG9tX25hbWVcbi8vVmVyc2lvbjogPj0gNC4xMVxudmFyIGNhbWxfYmFfY3VzdG9tX25hbWUgPSBcIl9iaWdhcnIwMlwiXG5cbi8vUHJvdmlkZXM6IE1sX0JpZ2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yLCBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfYmFfY3VzdG9tX25hbWVcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfY3JlYXRlX2xvX2hpLCBjYW1sX2ludDY0X2hpMzIsIGNhbWxfaW50NjRfbG8zMlxuZnVuY3Rpb24gTWxfQmlnYXJyYXkgKGtpbmQsIGxheW91dCwgZGltcywgYnVmZmVyKSB7XG5cbiAgdGhpcy5raW5kICAgPSBraW5kIDtcbiAgdGhpcy5sYXlvdXQgPSBsYXlvdXQ7XG4gIHRoaXMuZGltcyAgID0gZGltcztcbiAgdGhpcy5kYXRhID0gYnVmZmVyO1xufVxuXG5NbF9CaWdhcnJheS5wcm90b3R5cGUuY2FtbF9jdXN0b20gPSBjYW1sX2JhX2N1c3RvbV9uYW1lO1xuXG5NbF9CaWdhcnJheS5wcm90b3R5cGUub2Zmc2V0ID0gZnVuY3Rpb24gKGFyZykge1xuICB2YXIgb2ZzID0gMDtcbiAgaWYodHlwZW9mIGFyZyA9PT0gXCJudW1iZXJcIikgYXJnID0gW2FyZ107XG4gIGlmICghIChhcmcgaW5zdGFuY2VvZiBBcnJheSkpIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImJpZ2FycmF5LmpzOiBpbnZhbGlkIG9mZnNldFwiKTtcbiAgaWYgKHRoaXMuZGltcy5sZW5ndGggIT0gYXJnLmxlbmd0aClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5nZXQvc2V0OiBiYWQgbnVtYmVyIG9mIGRpbWVuc2lvbnNcIik7XG4gIGlmKHRoaXMubGF5b3V0ID09IDAgLyogY19sYXlvdXQgKi8pIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGltcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFyZ1tpXSA8IDAgfHwgYXJnW2ldID49IHRoaXMuZGltc1tpXSlcbiAgICAgICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICAgICAgb2ZzID0gKG9mcyAqIHRoaXMuZGltc1tpXSkgKyBhcmdbaV07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSB0aGlzLmRpbXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGlmIChhcmdbaV0gPCAxIHx8IGFyZ1tpXSA+IHRoaXMuZGltc1tpXSl7XG4gICAgICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgICAgIH1cbiAgICAgIG9mcyA9IChvZnMgKiB0aGlzLmRpbXNbaV0pICsgKGFyZ1tpXSAtIDEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb2ZzO1xufVxuXG5NbF9CaWdhcnJheS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKG9mcykge1xuICBzd2l0Y2godGhpcy5raW5kKXtcbiAgY2FzZSA3OlxuICAgIC8vIEludDY0XG4gICAgdmFyIGwgPSB0aGlzLmRhdGFbb2ZzICogMiArIDBdO1xuICAgIHZhciBoID0gdGhpcy5kYXRhW29mcyAqIDIgKyAxXTtcbiAgICByZXR1cm4gY2FtbF9pbnQ2NF9jcmVhdGVfbG9faGkobCxoKTtcbiAgY2FzZSAxMDogY2FzZSAxMTpcbiAgICAvLyBDb21wbGV4MzIsIENvbXBsZXg2NFxuICAgIHZhciByID0gdGhpcy5kYXRhW29mcyAqIDIgKyAwXTtcbiAgICB2YXIgaSA9IHRoaXMuZGF0YVtvZnMgKiAyICsgMV07XG4gICAgcmV0dXJuIFsyNTQsIHIsIGldO1xuICBkZWZhdWx0OlxuICAgIHJldHVybiB0aGlzLmRhdGFbb2ZzXVxuICB9XG59XG5cbk1sX0JpZ2FycmF5LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAob2ZzLHYpIHtcbiAgc3dpdGNoKHRoaXMua2luZCl7XG4gIGNhc2UgNzpcbiAgICAvLyBJbnQ2NFxuICAgIHRoaXMuZGF0YVtvZnMgKiAyICsgMF0gPSBjYW1sX2ludDY0X2xvMzIodik7XG4gICAgdGhpcy5kYXRhW29mcyAqIDIgKyAxXSA9IGNhbWxfaW50NjRfaGkzMih2KTtcbiAgICBicmVhaztcbiAgY2FzZSAxMDogY2FzZSAxMTpcbiAgICAvLyBDb21wbGV4MzIsIENvbXBsZXg2NFxuICAgIHRoaXMuZGF0YVtvZnMgKiAyICsgMF0gPSB2WzFdO1xuICAgIHRoaXMuZGF0YVtvZnMgKiAyICsgMV0gPSB2WzJdO1xuICAgIGJyZWFrO1xuICBkZWZhdWx0OlxuICAgIHRoaXMuZGF0YVtvZnNdID0gdjtcbiAgICBicmVhaztcbiAgfVxuICByZXR1cm4gMFxufVxuXG5cbk1sX0JpZ2FycmF5LnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gKHYpIHtcbiAgc3dpdGNoKHRoaXMua2luZCl7XG4gIGNhc2UgNzpcbiAgICAvLyBJbnQ2NFxuICAgIHZhciBhID0gY2FtbF9pbnQ2NF9sbzMyKHYpO1xuICAgIHZhciBiID0gY2FtbF9pbnQ2NF9oaTMyKHYpO1xuICAgIGlmKGEgPT0gYil7XG4gICAgICB0aGlzLmRhdGEuZmlsbChhKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBmb3IodmFyIGkgPSAwOyBpPHRoaXMuZGF0YS5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHRoaXMuZGF0YVtpXSA9IChpJTIgPT0gMCkgPyBhIDogYjtcbiAgICAgIH1cbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMTA6IGNhc2UgMTE6XG4gICAgLy8gQ29tcGxleDMyLCBDb21wbGV4NjRcbiAgICB2YXIgaW0gPSB2WzFdO1xuICAgIHZhciByZSA9IHZbMl07XG4gICAgaWYoaW0gPT0gcmUpe1xuICAgICAgdGhpcy5kYXRhLmZpbGwoaW0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGk8dGhpcy5kYXRhLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdGhpcy5kYXRhW2ldID0gKGklMiA9PSAwKSA/IGltIDogcmU7XG4gICAgICB9XG4gICAgfVxuICAgIGJyZWFrO1xuICBkZWZhdWx0OlxuICAgIHRoaXMuZGF0YS5maWxsKHYpO1xuICAgIGJyZWFrO1xuICB9XG59XG5cblxuTWxfQmlnYXJyYXkucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiAoYiwgdG90YWwpIHtcbiAgaWYgKHRoaXMubGF5b3V0ICE9IGIubGF5b3V0IHx8IHRoaXMua2luZCAhPSBiLmtpbmQpIHtcbiAgICB2YXIgazEgPSB0aGlzLmtpbmQgfCAodGhpcy5sYXlvdXQgPDwgOCk7XG4gICAgdmFyIGsyID0gICAgYi5raW5kIHwgKGIubGF5b3V0IDw8IDgpO1xuICAgIHJldHVybiBrMiAtIGsxO1xuICB9XG4gIGlmICh0aGlzLmRpbXMubGVuZ3RoICE9IGIuZGltcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gYi5kaW1zLmxlbmd0aCAtIHRoaXMuZGltcy5sZW5ndGg7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRpbXMubGVuZ3RoOyBpKyspXG4gICAgaWYgKHRoaXMuZGltc1tpXSAhPSBiLmRpbXNbaV0pXG4gICAgICByZXR1cm4gKHRoaXMuZGltc1tpXSA8IGIuZGltc1tpXSkgPyAtMSA6IDE7XG4gIHN3aXRjaCAodGhpcy5raW5kKSB7XG4gIGNhc2UgMDpcbiAgY2FzZSAxOlxuICBjYXNlIDEwOlxuICBjYXNlIDExOlxuICAgIC8vIEZsb2F0c1xuICAgIHZhciB4LCB5O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICB4ID0gdGhpcy5kYXRhW2ldO1xuICAgICAgeSA9IGIuZGF0YVtpXTtcbiAgICAgIGlmICh4IDwgeSlcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgaWYgKHggPiB5KVxuICAgICAgICByZXR1cm4gMTtcbiAgICAgIGlmICh4ICE9IHkpIHtcbiAgICAgICAgaWYgKCF0b3RhbCkgcmV0dXJuIE5hTjtcbiAgICAgICAgaWYgKHggPT0geCkgcmV0dXJuIDE7XG4gICAgICAgIGlmICh5ID09IHkpIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgNzpcbiAgICAvLyBJbnQ2NFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgaSs9Mikge1xuICAgICAgLy8gQ2hlY2sgaGlnaGVzdCBiaXRzIGZpcnN0XG4gICAgICBpZiAodGhpcy5kYXRhW2krMV0gPCBiLmRhdGFbaSsxXSlcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgaWYgKHRoaXMuZGF0YVtpKzFdID4gYi5kYXRhW2krMV0pXG4gICAgICAgIHJldHVybiAxO1xuICAgICAgaWYgKCh0aGlzLmRhdGFbaV0gPj4+IDApIDwgKGIuZGF0YVtpXSA+Pj4gMCkpXG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIGlmICgodGhpcy5kYXRhW2ldID4+PiAwKSA+IChiLmRhdGFbaV0gPj4+IDApKVxuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMjpcbiAgY2FzZSAzOlxuICBjYXNlIDQ6XG4gIGNhc2UgNTpcbiAgY2FzZSA2OlxuICBjYXNlIDg6XG4gIGNhc2UgOTpcbiAgY2FzZSAxMjpcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRoaXMuZGF0YVtpXSA8IGIuZGF0YVtpXSlcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgaWYgKHRoaXMuZGF0YVtpXSA+IGIuZGF0YVtpXSlcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBNbF9CaWdhcnJheV9jXzFfMVxuLy9SZXF1aXJlczogTWxfQmlnYXJyYXksIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IsIGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gTWxfQmlnYXJyYXlfY18xXzEoa2luZCwgbGF5b3V0LCBkaW1zLCBidWZmZXIpIHtcbiAgdGhpcy5raW5kICAgPSBraW5kIDtcbiAgdGhpcy5sYXlvdXQgPSBsYXlvdXQ7XG4gIHRoaXMuZGltcyAgID0gZGltcztcbiAgdGhpcy5kYXRhICAgPSBidWZmZXI7XG59XG5cbk1sX0JpZ2FycmF5X2NfMV8xLnByb3RvdHlwZSA9IG5ldyBNbF9CaWdhcnJheSgpXG5NbF9CaWdhcnJheV9jXzFfMS5wcm90b3R5cGUub2Zmc2V0ID0gZnVuY3Rpb24gKGFyZykge1xuICBpZih0eXBlb2YgYXJnICE9PSBcIm51bWJlclwiKXtcbiAgICBpZigoYXJnIGluc3RhbmNlb2YgQXJyYXkpICYmIGFyZy5sZW5ndGggPT0gMSlcbiAgICAgIGFyZyA9IGFyZ1swXTtcbiAgICBlbHNlIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIk1sX0JpZ2FycmF5X2NfMV8xLm9mZnNldFwiKTtcbiAgfVxuICBpZiAoYXJnIDwgMCB8fCBhcmcgPj0gdGhpcy5kaW1zWzBdKVxuICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgcmV0dXJuIGFyZztcbn1cblxuTWxfQmlnYXJyYXlfY18xXzEucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChvZnMpIHtcbiAgcmV0dXJuIHRoaXMuZGF0YVtvZnNdO1xufVxuXG5NbF9CaWdhcnJheV9jXzFfMS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKG9mcyx2KSB7XG4gIHRoaXMuZGF0YVtvZnNdID0gdjtcbiAgcmV0dXJuIDBcbn1cblxuTWxfQmlnYXJyYXlfY18xXzEucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiAodikge1xuICB0aGlzLmRhdGEuZmlsbCh2KTtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9jb21wYXJlXG5mdW5jdGlvbiBjYW1sX2JhX2NvbXBhcmUoYSxiLHRvdGFsKXtcbiAgcmV0dXJuIGEuY29tcGFyZShiLHRvdGFsKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2NyZWF0ZV91bnNhZmVcbi8vUmVxdWlyZXM6IE1sX0JpZ2FycmF5LCBNbF9CaWdhcnJheV9jXzFfMSwgY2FtbF9iYV9nZXRfc2l6ZSwgY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudFxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoa2luZCwgbGF5b3V0LCBkaW1zLCBkYXRhKXtcbiAgdmFyIHNpemVfcGVyX2VsZW1lbnQgPSBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50KGtpbmQpO1xuICBpZihjYW1sX2JhX2dldF9zaXplKGRpbXMpICogc2l6ZV9wZXJfZWxlbWVudCAhPSBkYXRhLmxlbmd0aCkge1xuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImxlbmd0aCBkb2Vzbid0IG1hdGNoIGRpbXNcIik7XG4gIH1cbiAgaWYobGF5b3V0ID09IDAgJiYgLy8gY19sYXlvdXRcbiAgICAgZGltcy5sZW5ndGggPT0gMSAmJiAvLyBBcnJheTFcbiAgICAgc2l6ZV9wZXJfZWxlbWVudCA9PSAxKSAvLyAxLXRvLTEgbWFwcGluZ1xuICAgIHJldHVybiBuZXcgTWxfQmlnYXJyYXlfY18xXzEoa2luZCwgbGF5b3V0LCBkaW1zLCBkYXRhKTtcbiAgcmV0dXJuIG5ldyBNbF9CaWdhcnJheShraW5kLCBsYXlvdXQsIGRpbXMsIGRhdGEpO1xuXG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9iYV9jcmVhdGVcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheVxuLy9SZXF1aXJlczogY2FtbF9iYV9nZXRfc2l6ZSwgY2FtbF9iYV9jcmVhdGVfdW5zYWZlXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2NyZWF0ZV9idWZmZXJcbmZ1bmN0aW9uIGNhbWxfYmFfY3JlYXRlKGtpbmQsIGxheW91dCwgZGltc19tbCkge1xuICB2YXIgZGltcyA9IGNhbWxfanNfZnJvbV9hcnJheShkaW1zX21sKTtcbiAgdmFyIGRhdGEgPSBjYW1sX2JhX2NyZWF0ZV9idWZmZXIoa2luZCwgY2FtbF9iYV9nZXRfc2l6ZShkaW1zKSk7XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoa2luZCwgbGF5b3V0LCBkaW1zLCBkYXRhKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9jaGFuZ2VfbGF5b3V0XG4vL1JlcXVpcmVzOiBjYW1sX2JhX2NyZWF0ZV91bnNhZmVcbmZ1bmN0aW9uIGNhbWxfYmFfY2hhbmdlX2xheW91dChiYSwgbGF5b3V0KSB7XG4gIGlmKGJhLmxheW91dCA9PSBsYXlvdXQpIHJldHVybiBiYTtcbiAgdmFyIG5ld19kaW1zID0gW11cbiAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRpbXMubGVuZ3RoOyBpKyspIG5ld19kaW1zW2ldID0gYmEuZGltc1tiYS5kaW1zLmxlbmd0aCAtIGkgLSAxXTtcbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZShiYS5raW5kLCBsYXlvdXQsIG5ld19kaW1zLCBiYS5kYXRhKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9raW5kXG5mdW5jdGlvbiBjYW1sX2JhX2tpbmQoYmEpIHtcbiAgcmV0dXJuIGJhLmtpbmQ7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfbGF5b3V0XG5mdW5jdGlvbiBjYW1sX2JhX2xheW91dChiYSkge1xuICByZXR1cm4gYmEubGF5b3V0O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX251bV9kaW1zXG5mdW5jdGlvbiBjYW1sX2JhX251bV9kaW1zKGJhKSB7XG4gIHJldHVybiBiYS5kaW1zLmxlbmd0aDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9kaW1cbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9iYV9kaW0oYmEsIGkpIHtcbiAgaWYgKGkgPCAwIHx8IGkgPj0gYmEuZGltcy5sZW5ndGgpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkuZGltXCIpO1xuICByZXR1cm4gYmEuZGltc1tpXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9kaW1fMVxuLy9SZXF1aXJlczogY2FtbF9iYV9kaW1cbmZ1bmN0aW9uIGNhbWxfYmFfZGltXzEoYmEpIHtcbiAgcmV0dXJuIGNhbWxfYmFfZGltKGJhLCAwKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9kaW1fMlxuLy9SZXF1aXJlczogY2FtbF9iYV9kaW1cbmZ1bmN0aW9uIGNhbWxfYmFfZGltXzIoYmEpIHtcbiAgcmV0dXJuIGNhbWxfYmFfZGltKGJhLCAxKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9kaW1fM1xuLy9SZXF1aXJlczogY2FtbF9iYV9kaW1cbmZ1bmN0aW9uIGNhbWxfYmFfZGltXzMoYmEpIHtcbiAgcmV0dXJuIGNhbWxfYmFfZGltKGJhLCAyKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9nZXRfZ2VuZXJpY1xuLy9SZXF1aXJlczogY2FtbF9qc19mcm9tX2FycmF5XG5mdW5jdGlvbiBjYW1sX2JhX2dldF9nZW5lcmljKGJhLCBpKSB7XG4gIHZhciBvZnMgPSBiYS5vZmZzZXQoY2FtbF9qc19mcm9tX2FycmF5KGkpKTtcbiAgcmV0dXJuIGJhLmdldChvZnMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3VpbnQ4X2dldDE2XG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX2JhX3VpbnQ4X2dldDE2KGJhLCBpMCkge1xuICB2YXIgb2ZzID0gYmEub2Zmc2V0KGkwKTtcbiAgaWYob2ZzICsgMSA+PSBiYS5kYXRhLmxlbmd0aCkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB2YXIgYjEgPSBiYS5nZXQob2ZzKTtcbiAgdmFyIGIyID0gYmEuZ2V0KG9mcyArIDEpO1xuICByZXR1cm4gKGIxIHwgKGIyIDw8IDgpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV91aW50OF9nZXQzMlxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9iYV91aW50OF9nZXQzMihiYSwgaTApIHtcbiAgdmFyIG9mcyA9IGJhLm9mZnNldChpMCk7XG4gIGlmKG9mcyArIDMgPj0gYmEuZGF0YS5sZW5ndGgpIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGIxID0gYmEuZ2V0KG9mcyswKTtcbiAgdmFyIGIyID0gYmEuZ2V0KG9mcysxKTtcbiAgdmFyIGIzID0gYmEuZ2V0KG9mcysyKTtcbiAgdmFyIGI0ID0gYmEuZ2V0KG9mcyszKTtcbiAgcmV0dXJuICggKGIxIDw8IDApICB8XG4gICAgICAgICAgIChiMiA8PCA4KSAgfFxuICAgICAgICAgICAoYjMgPDwgMTYpIHxcbiAgICAgICAgICAgKGI0IDw8IDI0KSApO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3VpbnQ4X2dldDY0XG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yLCBjYW1sX2ludDY0X29mX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2JhX3VpbnQ4X2dldDY0KGJhLCBpMCkge1xuICB2YXIgb2ZzID0gYmEub2Zmc2V0KGkwKTtcbiAgaWYob2ZzICsgNyA+PSBiYS5kYXRhLmxlbmd0aCkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB2YXIgYjEgPSBiYS5nZXQob2ZzKzApO1xuICB2YXIgYjIgPSBiYS5nZXQob2ZzKzEpO1xuICB2YXIgYjMgPSBiYS5nZXQob2ZzKzIpO1xuICB2YXIgYjQgPSBiYS5nZXQob2ZzKzMpO1xuICB2YXIgYjUgPSBiYS5nZXQob2ZzKzQpO1xuICB2YXIgYjYgPSBiYS5nZXQob2ZzKzUpO1xuICB2YXIgYjcgPSBiYS5nZXQob2ZzKzYpO1xuICB2YXIgYjggPSBiYS5nZXQob2ZzKzcpO1xuICByZXR1cm4gY2FtbF9pbnQ2NF9vZl9ieXRlcyhbYjgsYjcsYjYsYjUsYjQsYjMsYjIsYjFdKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9nZXRfMVxuZnVuY3Rpb24gY2FtbF9iYV9nZXRfMShiYSwgaTApIHtcbiAgcmV0dXJuIGJhLmdldChiYS5vZmZzZXQoaTApKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9nZXRfMlxuZnVuY3Rpb24gY2FtbF9iYV9nZXRfMihiYSwgaTAsIGkxKSB7XG4gIHJldHVybiBiYS5nZXQoYmEub2Zmc2V0KFtpMCxpMV0pKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9nZXRfM1xuZnVuY3Rpb24gY2FtbF9iYV9nZXRfMyhiYSwgaTAsIGkxLCBpMikge1xuICByZXR1cm4gYmEuZ2V0KGJhLm9mZnNldChbaTAsaTEsaTJdKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfc2V0X2dlbmVyaWNcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheVxuZnVuY3Rpb24gY2FtbF9iYV9zZXRfZ2VuZXJpYyhiYSwgaSwgdikge1xuICBiYS5zZXQoYmEub2Zmc2V0KGNhbWxfanNfZnJvbV9hcnJheShpKSksIHYpO1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3VpbnQ4X3NldDE2XG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX2JhX3VpbnQ4X3NldDE2KGJhLCBpMCwgdikge1xuICB2YXIgb2ZzID0gYmEub2Zmc2V0KGkwKTtcbiAgaWYob2ZzICsgMSA+PSBiYS5kYXRhLmxlbmd0aCkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICBiYS5zZXQob2ZzKzAsICB2ICAgICAgICAmIDB4ZmYpO1xuICBiYS5zZXQob2ZzKzEsICh2ID4+PiA4KSAmIDB4ZmYpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV91aW50OF9zZXQzMlxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9iYV91aW50OF9zZXQzMihiYSwgaTAsIHYpIHtcbiAgdmFyIG9mcyA9IGJhLm9mZnNldChpMCk7XG4gIGlmKG9mcyArIDMgPj0gYmEuZGF0YS5sZW5ndGgpIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgYmEuc2V0KG9mcyswLCAgdiAgICAgICAgICYgMHhmZik7XG4gIGJhLnNldChvZnMrMSwgKHYgPj4+IDgpICAmIDB4ZmYpO1xuICBiYS5zZXQob2ZzKzIsICh2ID4+PiAxNikgJiAweGZmKTtcbiAgYmEuc2V0KG9mcyszLCAodiA+Pj4gMjQpICYgMHhmZik7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3VpbnQ4X3NldDY0XG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yLCBjYW1sX2ludDY0X3RvX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2JhX3VpbnQ4X3NldDY0KGJhLCBpMCwgdikge1xuICB2YXIgb2ZzID0gYmEub2Zmc2V0KGkwKTtcbiAgaWYob2ZzICsgNyA+PSBiYS5kYXRhLmxlbmd0aCkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB2YXIgdiA9IGNhbWxfaW50NjRfdG9fYnl0ZXModik7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCA4OyBpKyspIGJhLnNldChvZnMraSwgdls3LWldKVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9zZXRfMVxuZnVuY3Rpb24gY2FtbF9iYV9zZXRfMShiYSwgaTAsIHYpIHtcbiAgYmEuc2V0KGJhLm9mZnNldChpMCksIHYpO1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3NldF8yXG5mdW5jdGlvbiBjYW1sX2JhX3NldF8yKGJhLCBpMCwgaTEsIHYpIHtcbiAgYmEuc2V0KGJhLm9mZnNldChbaTAsaTFdKSwgdik7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3NldF8zXG5mdW5jdGlvbiBjYW1sX2JhX3NldF8zKGJhLCBpMCwgaTEsIGkyLCB2KSB7XG4gIGJhLnNldChiYS5vZmZzZXQoW2kwLGkxLGkyXSksIHYpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9maWxsXG5mdW5jdGlvbiBjYW1sX2JhX2ZpbGwoYmEsIHYpIHtcbiAgYmEuZmlsbCh2KTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfYmxpdFxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX2JhX2JsaXQoc3JjLCBkc3QpIHtcbiAgaWYgKGRzdC5kaW1zLmxlbmd0aCAhPSBzcmMuZGltcy5sZW5ndGgpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkuYmxpdDogZGltZW5zaW9uIG1pc21hdGNoXCIpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGRzdC5kaW1zLmxlbmd0aDsgaSsrKVxuICAgIGlmIChkc3QuZGltc1tpXSAhPSBzcmMuZGltc1tpXSlcbiAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LmJsaXQ6IGRpbWVuc2lvbiBtaXNtYXRjaFwiKTtcbiAgZHN0LmRhdGEuc2V0KHNyYy5kYXRhKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfc3ViXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZSwgY2FtbF9iYV9nZXRfc2l6ZVxuLy9SZXF1aXJlczogY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudFxuZnVuY3Rpb24gY2FtbF9iYV9zdWIoYmEsIG9mcywgbGVuKSB7XG4gIHZhciBjaGFuZ2VkX2RpbTtcbiAgdmFyIG11bCA9IDE7XG4gIGlmIChiYS5sYXlvdXQgPT0gMCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYmEuZGltcy5sZW5ndGg7IGkrKylcbiAgICAgIG11bCA9IG11bCAqIGJhLmRpbXNbaV07XG4gICAgY2hhbmdlZF9kaW0gPSAwO1xuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgKGJhLmRpbXMubGVuZ3RoIC0gMSk7IGkrKylcbiAgICAgIG11bCA9IG11bCAqIGJhLmRpbXNbaV07XG4gICAgY2hhbmdlZF9kaW0gPSBiYS5kaW1zLmxlbmd0aCAtIDE7XG4gICAgb2ZzID0gb2ZzIC0gMTtcbiAgfVxuICBpZiAob2ZzIDwgMCB8fCBsZW4gPCAwIHx8IChvZnMgKyBsZW4pID4gYmEuZGltc1tjaGFuZ2VkX2RpbV0pe1xuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LnN1YjogYmFkIHN1Yi1hcnJheVwiKTtcbiAgfVxuICB2YXIgbmV3X2RpbXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBiYS5kaW1zLmxlbmd0aDsgaSsrKVxuICAgIG5ld19kaW1zW2ldID0gYmEuZGltc1tpXTtcbiAgbmV3X2RpbXNbY2hhbmdlZF9kaW1dID0gbGVuO1xuICBtdWwgKj0gY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudChiYS5raW5kKTtcbiAgdmFyIG5ld19kYXRhID0gYmEuZGF0YS5zdWJhcnJheShvZnMgKiBtdWwsIChvZnMgKyBsZW4pICogbXVsKTtcbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZShiYS5raW5kLCBiYS5sYXlvdXQsIG5ld19kaW1zLCBuZXdfZGF0YSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfc2xpY2Vcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheSwgY2FtbF9iYV9jcmVhdGVfdW5zYWZlLCBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfYmFfZ2V0X3NpemVcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnRcbmZ1bmN0aW9uIGNhbWxfYmFfc2xpY2UoYmEsIHZpbmQpIHtcbiAgdmluZCA9IGNhbWxfanNfZnJvbV9hcnJheSh2aW5kKTtcbiAgdmFyIG51bV9pbmRzID0gdmluZC5sZW5ndGg7XG4gIHZhciBpbmRleCA9IFtdO1xuICB2YXIgc3ViX2RpbXMgPSBbXTtcbiAgdmFyIG9mcztcblxuICBpZiAobnVtX2luZHMgPiBiYS5kaW1zLmxlbmd0aClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5zbGljZTogdG9vIG1hbnkgaW5kaWNlc1wiKTtcblxuICAvLyBDb21wdXRlIG9mZnNldCBhbmQgY2hlY2sgYm91bmRzXG4gIGlmIChiYS5sYXlvdXQgPT0gMCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2luZHM7IGkrKylcbiAgICAgIGluZGV4W2ldID0gdmluZFtpXTtcbiAgICBmb3IgKDsgaSA8IGJhLmRpbXMubGVuZ3RoOyBpKyspXG4gICAgICBpbmRleFtpXSA9IDA7XG4gICAgc3ViX2RpbXMgPSBiYS5kaW1zLnNsaWNlKG51bV9pbmRzKTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9pbmRzOyBpKyspXG4gICAgICBpbmRleFtiYS5kaW1zLmxlbmd0aCAtIG51bV9pbmRzICsgaV0gPSB2aW5kW2ldO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmEuZGltcy5sZW5ndGggLSBudW1faW5kczsgaSsrKVxuICAgICAgaW5kZXhbaV0gPSAxO1xuICAgIHN1Yl9kaW1zID0gYmEuZGltcy5zbGljZSgwLCBiYS5kaW1zLmxlbmd0aCAtIG51bV9pbmRzKTtcbiAgfVxuICBvZnMgPSBiYS5vZmZzZXQoaW5kZXgpO1xuICB2YXIgc2l6ZSA9IGNhbWxfYmFfZ2V0X3NpemUoc3ViX2RpbXMpO1xuICB2YXIgc2l6ZV9wZXJfZWxlbWVudCA9IGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnQoYmEua2luZCk7XG4gIHZhciBuZXdfZGF0YSA9IGJhLmRhdGEuc3ViYXJyYXkob2ZzICogc2l6ZV9wZXJfZWxlbWVudCwgKG9mcyArIHNpemUpICogc2l6ZV9wZXJfZWxlbWVudCk7XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoYmEua2luZCwgYmEubGF5b3V0LCBzdWJfZGltcywgbmV3X2RhdGEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3Jlc2hhcGVcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheSwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2JhX2NyZWF0ZV91bnNhZmUsIGNhbWxfYmFfZ2V0X3NpemVcbmZ1bmN0aW9uIGNhbWxfYmFfcmVzaGFwZShiYSwgdmluZCkge1xuICB2aW5kID0gY2FtbF9qc19mcm9tX2FycmF5KHZpbmQpO1xuICB2YXIgbmV3X2RpbSA9IFtdO1xuICB2YXIgbnVtX2RpbXMgPSB2aW5kLmxlbmd0aDtcblxuICBpZiAobnVtX2RpbXMgPCAwIHx8IG51bV9kaW1zID4gMTYpe1xuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LnJlc2hhcGU6IGJhZCBudW1iZXIgb2YgZGltZW5zaW9uc1wiKTtcbiAgfVxuICB2YXIgbnVtX2VsdHMgPSAxO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9kaW1zOyBpKyspIHtcbiAgICBuZXdfZGltW2ldID0gdmluZFtpXTtcbiAgICBpZiAobmV3X2RpbVtpXSA8IDApXG4gICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5yZXNoYXBlOiBuZWdhdGl2ZSBkaW1lbnNpb25cIik7XG4gICAgbnVtX2VsdHMgPSBudW1fZWx0cyAqIG5ld19kaW1baV07XG4gIH1cblxuICB2YXIgc2l6ZSA9IGNhbWxfYmFfZ2V0X3NpemUoYmEuZGltcyk7XG4gIC8vIENoZWNrIHRoYXQgc2l6ZXMgYWdyZWVcbiAgaWYgKG51bV9lbHRzICE9IHNpemUpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkucmVzaGFwZTogc2l6ZSBtaXNtYXRjaFwiKTtcbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZShiYS5raW5kLCBiYS5sYXlvdXQsIG5ld19kaW0sIGJhLmRhdGEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3NlcmlhbGl6ZVxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0LCBjYW1sX2ludDY0X3RvX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXRcbmZ1bmN0aW9uIGNhbWxfYmFfc2VyaWFsaXplKHdyaXRlciwgYmEsIHN6KSB7XG4gIHdyaXRlci53cml0ZSgzMiwgYmEuZGltcy5sZW5ndGgpO1xuICB3cml0ZXIud3JpdGUoMzIsIChiYS5raW5kIHwgKGJhLmxheW91dCA8PCA4KSkpO1xuICBpZihiYS5jYW1sX2N1c3RvbSA9PSBcIl9iaWdhcnIwMlwiKVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kaW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZihiYS5kaW1zW2ldIDwgMHhmZmZmKVxuICAgICAgICB3cml0ZXIud3JpdGUoMTYsIGJhLmRpbXNbaV0pO1xuICAgICAgZWxzZSB7XG4gICAgICAgIHdyaXRlci53cml0ZSgxNiwgMHhmZmZmKTtcbiAgICAgICAgd3JpdGVyLndyaXRlKDMyLCAwKTtcbiAgICAgICAgd3JpdGVyLndyaXRlKDMyLCBiYS5kaW1zW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIGVsc2VcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGltcy5sZW5ndGg7IGkrKykgd3JpdGVyLndyaXRlKDMyLGJhLmRpbXNbaV0pXG4gIHN3aXRjaChiYS5raW5kKXtcbiAgY2FzZSAyOiAgLy9JbnQ4QXJyYXlcbiAgY2FzZSAzOiAgLy9VaW50OEFycmF5XG4gIGNhc2UgMTI6IC8vVWludDhBcnJheVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kYXRhLmxlbmd0aDsgaSsrKXtcbiAgICAgIHdyaXRlci53cml0ZSg4LCBiYS5kYXRhW2ldKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgNDogIC8vIEludDE2QXJyYXlcbiAgY2FzZSA1OiAgLy8gVWludDE2QXJyYXlcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGF0YS5sZW5ndGg7IGkrKyl7XG4gICAgICB3cml0ZXIud3JpdGUoMTYsIGJhLmRhdGFbaV0pO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSA2OiAgLy8gSW50MzJBcnJheSAoaW50MzIpXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRhdGEubGVuZ3RoOyBpKyspe1xuICAgICAgd3JpdGVyLndyaXRlKDMyLCBiYS5kYXRhW2ldKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgODogIC8vIEludDMyQXJyYXkgKGludClcbiAgY2FzZSA5OiAgLy8gSW50MzJBcnJheSAobmF0aXZlaW50KVxuICAgIHdyaXRlci53cml0ZSg4LDApO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kYXRhLmxlbmd0aDsgaSsrKXtcbiAgICAgIHdyaXRlci53cml0ZSgzMiwgYmEuZGF0YVtpXSk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDc6ICAvLyBJbnQzMkFycmF5IChpbnQ2NClcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGF0YS5sZW5ndGggLyAyOyBpKyspe1xuICAgICAgdmFyIGIgPSBjYW1sX2ludDY0X3RvX2J5dGVzKGJhLmdldChpKSk7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDg7IGorKykgd3JpdGVyLndyaXRlICg4LCBiW2pdKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMTogIC8vIEZsb2F0NjRBcnJheVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kYXRhLmxlbmd0aDsgaSsrKXtcbiAgICAgIHZhciBiID0gY2FtbF9pbnQ2NF90b19ieXRlcyhjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQoYmEuZ2V0KGkpKSk7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDg7IGorKykgd3JpdGVyLndyaXRlICg4LCBiW2pdKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMDogIC8vIEZsb2F0MzJBcnJheVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kYXRhLmxlbmd0aDsgaSsrKXtcbiAgICAgIHZhciBiID0gY2FtbF9pbnQzMl9iaXRzX29mX2Zsb2F0KGJhLmdldChpKSk7XG4gICAgICB3cml0ZXIud3JpdGUoMzIsIGIpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAxMDogLy8gRmxvYXQzMkFycmF5IChjb21wbGV4MzIpXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRhdGEubGVuZ3RoIC8gMjsgaSsrKXtcbiAgICAgIHZhciBqID0gYmEuZ2V0KGkpO1xuICAgICAgd3JpdGVyLndyaXRlKDMyLCBjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXQoalsxXSkpO1xuICAgICAgd3JpdGVyLndyaXRlKDMyLCBjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXQoalsyXSkpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAxMTogLy8gRmxvYXQ2NEFycmF5IChjb21wbGV4NjQpXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRhdGEubGVuZ3RoIC8gMjsgaSsrKXtcbiAgICAgIHZhciBjb21wbGV4ID0gYmEuZ2V0KGkpO1xuICAgICAgdmFyIGIgPSBjYW1sX2ludDY0X3RvX2J5dGVzKGNhbWxfaW50NjRfYml0c19vZl9mbG9hdChjb21wbGV4WzFdKSk7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDg7IGorKykgd3JpdGVyLndyaXRlICg4LCBiW2pdKTtcbiAgICAgIHZhciBiID0gY2FtbF9pbnQ2NF90b19ieXRlcyhjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQoY29tcGxleFsyXSkpO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCA4OyBqKyspIHdyaXRlci53cml0ZSAoOCwgYltqXSk7XG4gICAgfVxuICAgIGJyZWFrO1xuICB9XG4gIHN6WzBdID0gKDQgKyBiYS5kaW1zLmxlbmd0aCkgKiA0O1xuICBzelsxXSA9ICg0ICsgYmEuZGltcy5sZW5ndGgpICogODtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9kZXNlcmlhbGl6ZVxuLy9SZXF1aXJlczogY2FtbF9iYV9jcmVhdGVfdW5zYWZlLCBjYW1sX2ZhaWx3aXRoXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF9zaXplXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2J5dGVzLCBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHNcbi8vUmVxdWlyZXM6IGNhbWxfaW50MzJfZmxvYXRfb2ZfYml0c1xuLy9SZXF1aXJlczogY2FtbF9iYV9jcmVhdGVfYnVmZmVyXG5mdW5jdGlvbiBjYW1sX2JhX2Rlc2VyaWFsaXplKHJlYWRlciwgc3osIG5hbWUpe1xuICB2YXIgbnVtX2RpbXMgPSByZWFkZXIucmVhZDMycygpO1xuICBpZiAobnVtX2RpbXMgPCAwIHx8IG51bV9kaW1zID4gMTYpXG4gICAgY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiB3cm9uZyBudW1iZXIgb2YgYmlnYXJyYXkgZGltZW5zaW9uc1wiKTtcbiAgdmFyIHRhZyA9IHJlYWRlci5yZWFkMzJzKCk7XG4gIHZhciBraW5kID0gdGFnICYgMHhmZlxuICB2YXIgbGF5b3V0ID0gKHRhZyA+PiA4KSAmIDE7XG4gIHZhciBkaW1zID0gW11cbiAgaWYobmFtZSA9PSBcIl9iaWdhcnIwMlwiKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2RpbXM7IGkrKykge1xuICAgICAgdmFyIHNpemVfZGltID0gcmVhZGVyLnJlYWQxNnUoKTtcbiAgICAgIGlmKHNpemVfZGltID09IDB4ZmZmZil7XG4gICAgICAgIHZhciBzaXplX2RpbV9oaSA9IHJlYWRlci5yZWFkMzJ1KCk7XG4gICAgICAgIHZhciBzaXplX2RpbV9sbyA9IHJlYWRlci5yZWFkMzJ1KCk7XG4gICAgICAgIGlmKHNpemVfZGltX2hpICE9IDApXG4gICAgICAgICAgY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiBiaWdhcnJheSBkaW1lbnNpb24gb3ZlcmZsb3cgaW4gMzJiaXRcIik7XG4gICAgICAgIHNpemVfZGltID0gc2l6ZV9kaW1fbG87XG4gICAgICB9XG4gICAgICBkaW1zLnB1c2goc2l6ZV9kaW0pO1xuICAgIH1cbiAgZWxzZVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2RpbXM7IGkrKykgZGltcy5wdXNoKHJlYWRlci5yZWFkMzJ1KCkpO1xuICB2YXIgc2l6ZSA9IGNhbWxfYmFfZ2V0X3NpemUoZGltcyk7XG4gIHZhciBkYXRhID0gY2FtbF9iYV9jcmVhdGVfYnVmZmVyKGtpbmQsIHNpemUpO1xuICB2YXIgYmEgPSBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoa2luZCwgbGF5b3V0LCBkaW1zLCBkYXRhKTtcbiAgc3dpdGNoKGtpbmQpe1xuICBjYXNlIDI6ICAvL0ludDhBcnJheVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspe1xuICAgICAgZGF0YVtpXSA9IHJlYWRlci5yZWFkOHMoKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMzogIC8vVWludDhBcnJheVxuICBjYXNlIDEyOiAvL1VpbnQ4QXJyYXlcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIGRhdGFbaV0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDQ6ICAvLyBJbnQxNkFycmF5XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICBkYXRhW2ldID0gcmVhZGVyLnJlYWQxNnMoKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgNTogIC8vIFVpbnQxNkFycmF5XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICBkYXRhW2ldID0gcmVhZGVyLnJlYWQxNnUoKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgNjogIC8vIEludDMyQXJyYXkgKGludDMyKVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspe1xuICAgICAgZGF0YVtpXSA9IHJlYWRlci5yZWFkMzJzKCk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDg6ICAvLyBJbnQzMkFycmF5IChpbnQpXG4gIGNhc2UgOTogIC8vIEludDMyQXJyYXkgKG5hdGl2ZWludClcbiAgICB2YXIgc2l4dHkgPSByZWFkZXIucmVhZDh1KCk7XG4gICAgaWYoc2l4dHkpIGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogY2Fubm90IHJlYWQgYmlnYXJyYXkgd2l0aCA2NC1iaXQgT0NhbWwgaW50c1wiKTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIGRhdGFbaV0gPSByZWFkZXIucmVhZDMycygpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSA3OiAvLyAoaW50NjQpXG4gICAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7O1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspe1xuICAgICAgZm9yICh2YXIgaiA9IDA7aiA8IDg7aisrKSB0W2pdID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgdmFyIGludDY0ID0gY2FtbF9pbnQ2NF9vZl9ieXRlcyh0KTtcbiAgICAgIGJhLnNldChpLGludDY0KTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMTogIC8vIEZsb2F0NjRBcnJheVxuICAgIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFtqXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgIHZhciBmID0gY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzKGNhbWxfaW50NjRfb2ZfYnl0ZXModCkpO1xuICAgICAgYmEuc2V0KGksZik7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDA6ICAvLyBGbG9hdDMyQXJyYXlcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIHZhciBmID0gY2FtbF9pbnQzMl9mbG9hdF9vZl9iaXRzKHJlYWRlci5yZWFkMzJzKCkpO1xuICAgICAgYmEuc2V0KGksZik7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDEwOiAvLyBGbG9hdDMyQXJyYXkgKGNvbXBsZXgzMilcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIHZhciByZSA9IGNhbWxfaW50MzJfZmxvYXRfb2ZfYml0cyhyZWFkZXIucmVhZDMycygpKTtcbiAgICAgIHZhciBpbSA9IGNhbWxfaW50MzJfZmxvYXRfb2ZfYml0cyhyZWFkZXIucmVhZDMycygpKTtcbiAgICAgIGJhLnNldChpLFsyNTQscmUsaW1dKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMTE6IC8vIEZsb2F0NjRBcnJheSAoY29tcGxleDY0KVxuICAgIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFtqXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgIHZhciByZSA9IGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cyhjYW1sX2ludDY0X29mX2J5dGVzKHQpKTtcbiAgICAgIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFtqXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgIHZhciBpbSA9IGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cyhjYW1sX2ludDY0X29mX2J5dGVzKHQpKTtcbiAgICAgIGJhLnNldChpLFsyNTQscmUsaW1dKTtcbiAgICB9XG4gICAgYnJlYWtcbiAgfVxuICBzelswXSA9ICg0ICsgbnVtX2RpbXMpICogNDtcbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZShraW5kLCBsYXlvdXQsIGRpbXMsIGRhdGEpO1xufVxuXG4vL0RlcHJlY2F0ZWRcbi8vUHJvdmlkZXM6IGNhbWxfYmFfY3JlYXRlX2Zyb21cbi8vUmVxdWlyZXM6IGNhbWxfYmFfY3JlYXRlX3Vuc2FmZSwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50XG5mdW5jdGlvbiBjYW1sX2JhX2NyZWF0ZV9mcm9tKGRhdGExLCBkYXRhMiwganN0eXAsIGtpbmQsIGxheW91dCwgZGltcyl7XG4gIGlmKGRhdGEyIHx8IGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnQoa2luZCkgPT0gMil7XG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY2FtbF9iYV9jcmVhdGVfZnJvbTogdXNlIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmVcIik7XG4gIH1cbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZShraW5kLCBsYXlvdXQsIGRpbXMsIGRhdGExKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9oYXNoIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF9zaXplLCBjYW1sX2hhc2hfbWl4X2ludCwgY2FtbF9oYXNoX21peF9mbG9hdFxuZnVuY3Rpb24gY2FtbF9iYV9oYXNoKGJhKXtcbiAgdmFyIG51bV9lbHRzID0gY2FtbF9iYV9nZXRfc2l6ZShiYS5kaW1zKTtcbiAgdmFyIGggPSAwO1xuICBzd2l0Y2goYmEua2luZCl7XG4gIGNhc2UgMjogIC8vSW50OEFycmF5XG4gIGNhc2UgMzogIC8vVWludDhBcnJheVxuICBjYXNlIDEyOiAvL1VpbnQ4QXJyYXlcbiAgICBpZihudW1fZWx0cyA+IDI1NikgbnVtX2VsdHMgPSAyNTY7XG4gICAgdmFyIHcgPSAwLCBpID0wO1xuICAgIGZvcihpID0gMDsgaSArIDQgPD0gYmEuZGF0YS5sZW5ndGg7IGkrPTQpe1xuICAgICAgdyA9IGJhLmRhdGFbaSswXSB8IChiYS5kYXRhW2krMV0gPDwgOCkgfCAoYmEuZGF0YVtpKzJdIDw8IDE2KSB8IChiYS5kYXRhW2krM10gPDwgMjQpO1xuICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsdyk7XG4gICAgfVxuICAgIHcgPSAwO1xuICAgIHN3aXRjaCAobnVtX2VsdHMgJiAzKSB7XG4gICAgY2FzZSAzOiB3ICA9IGJhLmRhdGFbaSsyXSA8PCAxNjsgICAgLyogZmFsbHRocm91Z2ggKi9cbiAgICBjYXNlIDI6IHcgfD0gYmEuZGF0YVtpKzFdIDw8IDg7ICAgICAvKiBmYWxsdGhyb3VnaCAqL1xuICAgIGNhc2UgMTogdyB8PSBiYS5kYXRhW2krMF07XG4gICAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgdyk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDQ6ICAvLyBJbnQxNkFycmF5XG4gIGNhc2UgNTogIC8vIFVpbnQxNkFycmF5XG4gICAgaWYobnVtX2VsdHMgPiAxMjgpIG51bV9lbHRzID0gMTI4O1xuICAgIHZhciB3ID0gMCwgaSA9MDtcbiAgICBmb3IoaSA9IDA7IGkgKyAyIDw9IGJhLmRhdGEubGVuZ3RoOyBpKz0yKXtcbiAgICAgIHcgPSBiYS5kYXRhW2krMF0gfCAoYmEuZGF0YVtpKzFdIDw8IDE2KTtcbiAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLHcpO1xuICAgIH1cbiAgICBpZiAoKG51bV9lbHRzICYgMSkgIT0gMClcbiAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCBiYS5kYXRhW2ldKTtcbiAgICBicmVhaztcbiAgY2FzZSA2OiAgLy8gSW50MzJBcnJheSAoaW50MzIpXG4gICAgaWYgKG51bV9lbHRzID4gNjQpIG51bV9lbHRzID0gNjQ7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1fZWx0czsgaSsrKSBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgYmEuZGF0YVtpXSk7XG4gICAgYnJlYWs7XG4gIGNhc2UgODogIC8vIEludDMyQXJyYXkgKGludClcbiAgY2FzZSA5OiAgLy8gSW50MzJBcnJheSAobmF0aXZlaW50KVxuICAgIGlmIChudW1fZWx0cyA+IDY0KSBudW1fZWx0cyA9IDY0O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2VsdHM7IGkrKykgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIGJhLmRhdGFbaV0pO1xuICAgIGJyZWFrO1xuICBjYXNlIDc6ICAvLyBJbnQzMkFycmF5IChpbnQ2NClcbiAgICBpZiAobnVtX2VsdHMgPiAzMikgbnVtX2VsdHMgPSAzMjtcbiAgICBudW1fZWx0cyAqPSAyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1fZWx0czsgaSsrKSB7XG4gICAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgYmEuZGF0YVtpXSk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDEwOiAvLyBGbG9hdDMyQXJyYXkgKGNvbXBsZXgzMilcbiAgICBudW1fZWx0cyAqPTI7IC8qIGZhbGx0aHJvdWdoICovXG4gIGNhc2UgMDogIC8vIEZsb2F0MzJBcnJheVxuICAgIGlmIChudW1fZWx0cyA+IDY0KSBudW1fZWx0cyA9IDY0O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2VsdHM7IGkrKykgaCA9IGNhbWxfaGFzaF9taXhfZmxvYXQoaCwgYmEuZGF0YVtpXSk7XG4gICAgYnJlYWs7XG4gIGNhc2UgMTE6IC8vIEZsb2F0NjRBcnJheSAoY29tcGxleDY0KVxuICAgIG51bV9lbHRzICo9MjsgLyogZmFsbHRocm91Z2ggKi9cbiAgY2FzZSAxOiAgLy8gRmxvYXQ2NEFycmF5XG4gICAgaWYgKG51bV9lbHRzID4gMzIpIG51bV9lbHRzID0gMzI7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1fZWx0czsgaSsrKSBoID0gY2FtbF9oYXNoX21peF9mbG9hdChoLCBiYS5kYXRhW2ldKTtcbiAgICBicmVhaztcbiAgfVxuICByZXR1cm4gaDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV90b190eXBlZF9hcnJheSBtdXRhYmxlXG5mdW5jdGlvbiBjYW1sX2JhX3RvX3R5cGVkX2FycmF5KGJhKXtcbiAgcmV0dXJuIGJhLmRhdGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfa2luZF9vZl90eXBlZF9hcnJheSBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfYmFfa2luZF9vZl90eXBlZF9hcnJheSh0YSl7XG4gIHZhciBraW5kO1xuICBpZiAgICAgICh0YSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSkga2luZCA9IDA7XG4gIGVsc2UgaWYgKHRhIGluc3RhbmNlb2YgRmxvYXQ2NEFycmF5KSBraW5kID0gMTtcbiAgZWxzZSBpZiAodGEgaW5zdGFuY2VvZiBJbnQ4QXJyYXkpIGtpbmQgPSAyO1xuICBlbHNlIGlmICh0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIGtpbmQgPSAzO1xuICBlbHNlIGlmICh0YSBpbnN0YW5jZW9mIFVpbnQ4Q2xhbXBlZEFycmF5KSBraW5kID0gMztcbiAgZWxzZSBpZiAodGEgaW5zdGFuY2VvZiBJbnQxNkFycmF5KSBraW5kID0gNDtcbiAgZWxzZSBpZiAodGEgaW5zdGFuY2VvZiBVaW50MTZBcnJheSkga2luZCA9IDU7XG4gIGVsc2UgaWYgKHRhIGluc3RhbmNlb2YgSW50MzJBcnJheSkga2luZCA9IDY7XG4gIGVsc2UgaWYgKHRhIGluc3RhbmNlb2YgVWludDMyQXJyYXkpIGtpbmQgPSA2O1xuICBlbHNlIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNhbWxfYmFfa2luZF9vZl90eXBlZF9hcnJheTogdW5zdXBwb3J0ZWQga2luZFwiKTtcbiAgcmV0dXJuIGtpbmQ7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZnJvbV90eXBlZF9hcnJheSBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2tpbmRfb2ZfdHlwZWRfYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfYmFfY3JlYXRlX3Vuc2FmZVxuZnVuY3Rpb24gY2FtbF9iYV9mcm9tX3R5cGVkX2FycmF5KHRhKXtcbiAgdmFyIGtpbmQgPSBjYW1sX2JhX2tpbmRfb2ZfdHlwZWRfYXJyYXkodGEpO1xuICB2YXIgdGEgPVxuICAgICAgLyogTmVlZGVkIHRvIGF2b2lkIHVuc2lnbmVkIHNldHRlcnMgb3ZlcmZsb3dpbmdcbiAgICAgICAgIHRoZSByYW5nZSBvZiBPQ2FtbCBbaW50MzJdIHZhbHVlcy4gKi9cbiAgICAgIHRhIGluc3RhbmNlb2YgVWludDMyQXJyYXkgP1xuICAgICAgbmV3IEludDMyQXJyYXkodGEuYnVmZmVyICx0YS5ieXRlT2Zmc2V0LCB0YS5sZW5ndGgpIDogdGE7XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoa2luZCwgMCwgW3RhLmxlbmd0aF0sIHRhKTtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxMCBKw6lyw7RtZSBWb3VpbGxvblxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBjYW1sX21hcnNoYWxfY29uc3RhbnRzXG52YXIgY2FtbF9tYXJzaGFsX2NvbnN0YW50cyA9IHtcbiAgUFJFRklYX1NNQUxMX0JMT0NLOiAgICAgICAgIDB4ODAsXG4gIFBSRUZJWF9TTUFMTF9JTlQ6ICAgICAgICAgICAweDQwLFxuICBQUkVGSVhfU01BTExfU1RSSU5HOiAgICAgICAgMHgyMCxcbiAgQ09ERV9JTlQ4OiAgICAgICAgICAgICAgICAgIDB4MDAsXG4gIENPREVfSU5UMTY6ICAgICAgICAgICAgICAgICAweDAxLFxuICBDT0RFX0lOVDMyOiAgICAgICAgICAgICAgICAgMHgwMixcbiAgQ09ERV9JTlQ2NDogICAgICAgICAgICAgICAgIDB4MDMsXG4gIENPREVfU0hBUkVEODogICAgICAgICAgICAgICAweDA0LFxuICBDT0RFX1NIQVJFRDE2OiAgICAgICAgICAgICAgMHgwNSxcbiAgQ09ERV9TSEFSRUQzMjogICAgICAgICAgICAgIDB4MDYsXG4gIENPREVfQkxPQ0szMjogICAgICAgICAgICAgICAweDA4LFxuICBDT0RFX0JMT0NLNjQ6ICAgICAgICAgICAgICAgMHgxMyxcbiAgQ09ERV9TVFJJTkc4OiAgICAgICAgICAgICAgIDB4MDksXG4gIENPREVfU1RSSU5HMzI6ICAgICAgICAgICAgICAweDBBLFxuICBDT0RFX0RPVUJMRV9CSUc6ICAgICAgICAgICAgMHgwQixcbiAgQ09ERV9ET1VCTEVfTElUVExFOiAgICAgICAgIDB4MEMsXG4gIENPREVfRE9VQkxFX0FSUkFZOF9CSUc6ICAgICAweDBELFxuICBDT0RFX0RPVUJMRV9BUlJBWThfTElUVExFOiAgMHgwRSxcbiAgQ09ERV9ET1VCTEVfQVJSQVkzMl9CSUc6ICAgIDB4MEYsXG4gIENPREVfRE9VQkxFX0FSUkFZMzJfTElUVExFOiAweDA3LFxuICBDT0RFX0NPREVQT0lOVEVSOiAgICAgICAgICAgMHgxMCxcbiAgQ09ERV9JTkZJWFBPSU5URVI6ICAgICAgICAgIDB4MTEsXG4gIENPREVfQ1VTVE9NOiAgICAgICAgICAgICAgICAweDEyLFxuICBDT0RFX0NVU1RPTV9MRU46ICAgICAgICAgICAgMHgxOCxcbiAgQ09ERV9DVVNUT01fRklYRUQ6ICAgICAgICAgIDB4MTlcbn1cblxuXG4vL1Byb3ZpZGVzOiBVSW50OEFycmF5UmVhZGVyXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9hcnJheSwgY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gVUludDhBcnJheVJlYWRlciAocywgaSkgeyB0aGlzLnMgPSBzOyB0aGlzLmkgPSBpOyB9XG5VSW50OEFycmF5UmVhZGVyLnByb3RvdHlwZSA9IHtcbiAgcmVhZDh1OmZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuc1t0aGlzLmkrK107IH0sXG4gIHJlYWQ4czpmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnNbdGhpcy5pKytdIDw8IDI0ID4+IDI0OyB9LFxuICByZWFkMTZ1OmZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IHRoaXMucywgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgMjtcbiAgICByZXR1cm4gKHNbaV0gPDwgOCkgfCBzW2kgKyAxXVxuICB9LFxuICByZWFkMTZzOmZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IHRoaXMucywgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgMjtcbiAgICByZXR1cm4gKHNbaV0gPDwgMjQgPj4gMTYpIHwgc1tpICsgMV07XG4gIH0sXG4gIHJlYWQzMnU6ZnVuY3Rpb24gKCkge1xuICAgIHZhciBzID0gdGhpcy5zLCBpID0gdGhpcy5pO1xuICAgIHRoaXMuaSA9IGkgKyA0O1xuICAgIHJldHVybiAoKHNbaV0gPDwgMjQpIHwgKHNbaSsxXSA8PCAxNikgfFxuICAgICAgICAgICAgKHNbaSsyXSA8PCA4KSB8IHNbaSszXSkgPj4+IDA7XG4gIH0sXG4gIHJlYWQzMnM6ZnVuY3Rpb24gKCkge1xuICAgIHZhciBzID0gdGhpcy5zLCBpID0gdGhpcy5pO1xuICAgIHRoaXMuaSA9IGkgKyA0O1xuICAgIHJldHVybiAoc1tpXSA8PCAyNCkgfCAoc1tpKzFdIDw8IDE2KSB8XG4gICAgICAoc1tpKzJdIDw8IDgpIHwgc1tpKzNdO1xuICB9LFxuICByZWFkc3RyOmZ1bmN0aW9uIChsZW4pIHtcbiAgICB2YXIgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgbGVuO1xuICAgIHJldHVybiBjYW1sX3N0cmluZ19vZl9hcnJheSh0aGlzLnMuc3ViYXJyYXkoaSwgaSArIGxlbikpO1xuICB9LFxuICByZWFkdWludDhhcnJheTpmdW5jdGlvbiAobGVuKSB7XG4gICAgdmFyIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIGxlbjtcbiAgICByZXR1cm4gdGhpcy5zLnN1YmFycmF5KGksIGkgKyBsZW4pO1xuICB9XG59XG5cblxuLy9Qcm92aWRlczogTWxTdHJpbmdSZWFkZXJcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMsIGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIE1sU3RyaW5nUmVhZGVyIChzLCBpKSB7IHRoaXMucyA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcocyk7IHRoaXMuaSA9IGk7IH1cbk1sU3RyaW5nUmVhZGVyLnByb3RvdHlwZSA9IHtcbiAgcmVhZDh1OmZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMucy5jaGFyQ29kZUF0KHRoaXMuaSsrKTsgfSxcbiAgcmVhZDhzOmZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMucy5jaGFyQ29kZUF0KHRoaXMuaSsrKSA8PCAyNCA+PiAyNDsgfSxcbiAgcmVhZDE2dTpmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDI7XG4gICAgcmV0dXJuIChzLmNoYXJDb2RlQXQoaSkgPDwgOCkgfCBzLmNoYXJDb2RlQXQoaSArIDEpXG4gIH0sXG4gIHJlYWQxNnM6ZnVuY3Rpb24gKCkge1xuICAgIHZhciBzID0gdGhpcy5zLCBpID0gdGhpcy5pO1xuICAgIHRoaXMuaSA9IGkgKyAyO1xuICAgIHJldHVybiAocy5jaGFyQ29kZUF0KGkpIDw8IDI0ID4+IDE2KSB8IHMuY2hhckNvZGVBdChpICsgMSk7XG4gIH0sXG4gIHJlYWQzMnU6ZnVuY3Rpb24gKCkge1xuICAgIHZhciBzID0gdGhpcy5zLCBpID0gdGhpcy5pO1xuICAgIHRoaXMuaSA9IGkgKyA0O1xuICAgIHJldHVybiAoKHMuY2hhckNvZGVBdChpKSA8PCAyNCkgfCAocy5jaGFyQ29kZUF0KGkrMSkgPDwgMTYpIHxcbiAgICAgICAgICAgIChzLmNoYXJDb2RlQXQoaSsyKSA8PCA4KSB8IHMuY2hhckNvZGVBdChpKzMpKSA+Pj4gMDtcbiAgfSxcbiAgcmVhZDMyczpmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDQ7XG4gICAgcmV0dXJuIChzLmNoYXJDb2RlQXQoaSkgPDwgMjQpIHwgKHMuY2hhckNvZGVBdChpKzEpIDw8IDE2KSB8XG4gICAgICAocy5jaGFyQ29kZUF0KGkrMikgPDwgOCkgfCBzLmNoYXJDb2RlQXQoaSszKTtcbiAgfSxcbiAgcmVhZHN0cjpmdW5jdGlvbiAobGVuKSB7XG4gICAgdmFyIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIGxlbjtcbiAgICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyh0aGlzLnMuc3Vic3RyaW5nKGksIGkgKyBsZW4pKTtcbiAgfSxcbiAgcmVhZHVpbnQ4YXJyYXk6ZnVuY3Rpb24gKGxlbikge1xuICAgIHZhciBiID0gbmV3IFVpbnQ4QXJyYXkobGVuKTtcbiAgICB2YXIgcyA9IHRoaXMucztcbiAgICB2YXIgaSA9IHRoaXMuaTtcbiAgICBmb3IodmFyIGogPSAwOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgIGJbal0gPSBzLmNoYXJDb2RlQXQoaSArIGopO1xuICAgIH1cbiAgICB0aGlzLmkgPSBpICsgbGVuO1xuICAgIHJldHVybiBiO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IEJpZ1N0cmluZ1JlYWRlclxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfYXJyYXksIGNhbWxfYmFfZ2V0XzFcbmZ1bmN0aW9uIEJpZ1N0cmluZ1JlYWRlciAoYnMsIGkpIHsgdGhpcy5zID0gYnM7IHRoaXMuaSA9IGk7IH1cbkJpZ1N0cmluZ1JlYWRlci5wcm90b3R5cGUgPSB7XG4gIHJlYWQ4dTpmdW5jdGlvbiAoKSB7IHJldHVybiBjYW1sX2JhX2dldF8xKHRoaXMucyx0aGlzLmkrKyk7IH0sXG4gIHJlYWQ4czpmdW5jdGlvbiAoKSB7IHJldHVybiBjYW1sX2JhX2dldF8xKHRoaXMucyx0aGlzLmkrKykgPDwgMjQgPj4gMjQ7IH0sXG4gIHJlYWQxNnU6ZnVuY3Rpb24gKCkge1xuICAgIHZhciBzID0gdGhpcy5zLCBpID0gdGhpcy5pO1xuICAgIHRoaXMuaSA9IGkgKyAyO1xuICAgIHJldHVybiAoY2FtbF9iYV9nZXRfMShzLGkpIDw8IDgpIHwgY2FtbF9iYV9nZXRfMShzLGkgKyAxKVxuICB9LFxuICByZWFkMTZzOmZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IHRoaXMucywgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgMjtcbiAgICByZXR1cm4gKGNhbWxfYmFfZ2V0XzEocyxpKSA8PCAyNCA+PiAxNikgfCBjYW1sX2JhX2dldF8xKHMsaSArIDEpO1xuICB9LFxuICByZWFkMzJ1OmZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IHRoaXMucywgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgNDtcbiAgICByZXR1cm4gKChjYW1sX2JhX2dldF8xKHMsaSkgICA8PCAyNCkgfCAoY2FtbF9iYV9nZXRfMShzLGkrMSkgPDwgMTYpIHxcbiAgICAgICAgICAgIChjYW1sX2JhX2dldF8xKHMsaSsyKSA8PCA4KSAgfCBjYW1sX2JhX2dldF8xKHMsaSszKSAgICAgICAgICkgPj4+IDA7XG4gIH0sXG4gIHJlYWQzMnM6ZnVuY3Rpb24gKCkge1xuICAgIHZhciBzID0gdGhpcy5zLCBpID0gdGhpcy5pO1xuICAgIHRoaXMuaSA9IGkgKyA0O1xuICAgIHJldHVybiAoY2FtbF9iYV9nZXRfMShzLGkpICAgPDwgMjQpIHwgKGNhbWxfYmFfZ2V0XzEocyxpKzEpIDw8IDE2KSB8XG4gICAgICAoY2FtbF9iYV9nZXRfMShzLGkrMikgPDwgOCkgIHwgY2FtbF9iYV9nZXRfMShzLGkrMyk7XG4gIH0sXG4gIHJlYWRzdHI6ZnVuY3Rpb24gKGxlbikge1xuICAgIHZhciBpID0gdGhpcy5pO1xuICAgIHZhciBhcnIgPSBuZXcgQXJyYXkobGVuKVxuICAgIGZvcih2YXIgaiA9IDA7IGogPCBsZW47IGorKyl7XG4gICAgICBhcnJbal0gPSBjYW1sX2JhX2dldF8xKHRoaXMucywgaStqKTtcbiAgICB9XG4gICAgdGhpcy5pID0gaSArIGxlbjtcbiAgICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfYXJyYXkoYXJyKTtcbiAgfSxcbiAgcmVhZHVpbnQ4YXJyYXk6ZnVuY3Rpb24gKGxlbikge1xuICAgIHZhciBpID0gdGhpcy5pO1xuICAgIHZhciBvZmZzZXQgPSB0aGlzLm9mZnNldChpKTtcbiAgICB0aGlzLmkgPSBpICsgbGVuO1xuICAgIHJldHVybiB0aGlzLnMuZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gIH1cbn1cblxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfZmxvYXRfb2ZfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cywgY2FtbF9pbnQ2NF9vZl9ieXRlc1xuZnVuY3Rpb24gY2FtbF9mbG9hdF9vZl9ieXRlcyAoYSkge1xuICByZXR1cm4gY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzIChjYW1sX2ludDY0X29mX2J5dGVzIChhKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9zdHJpbmcgbXV0YWJsZVxuLy9SZXF1aXJlczogTWxTdHJpbmdSZWFkZXIsIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9yZWFkZXJcbmZ1bmN0aW9uIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9zdHJpbmcocyxvZnMpIHtcbiAgdmFyIHJlYWRlciA9IG5ldyBNbFN0cmluZ1JlYWRlciAocywgdHlwZW9mIG9mcz09XCJudW1iZXJcIj9vZnM6b2ZzWzBdKTtcbiAgcmV0dXJuIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9yZWFkZXIocmVhZGVyLCBvZnMpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9ieXRlcyBtdXRhYmxlXG4vL1JlcXVpcmVzOiBNbFN0cmluZ1JlYWRlciwgY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3JlYWRlciwgY2FtbF9zdHJpbmdfb2ZfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9ieXRlcyhzLG9mcykge1xuICB2YXIgcmVhZGVyID0gbmV3IE1sU3RyaW5nUmVhZGVyIChjYW1sX3N0cmluZ19vZl9ieXRlcyhzKSwgdHlwZW9mIG9mcz09XCJudW1iZXJcIj9vZnM6b2ZzWzBdKTtcbiAgcmV0dXJuIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9yZWFkZXIocmVhZGVyLCBvZnMpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfdW5tYXJzaGFsXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2ludDY0X3VubWFyc2hhbChyZWFkZXIsIHNpemUpe1xuICB2YXIgdCA9IG5ldyBBcnJheSg4KTs7XG4gIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFtqXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgc2l6ZVswXSA9IDg7XG4gIHJldHVybiBjYW1sX2ludDY0X29mX2J5dGVzICh0KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9tYXJzaGFsXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3RvX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2ludDY0X21hcnNoYWwod3JpdGVyLCB2LCBzaXplcykge1xuICB2YXIgYiA9IGNhbWxfaW50NjRfdG9fYnl0ZXMgKHYpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkrKykgd3JpdGVyLndyaXRlICg4LCBiW2ldKTtcbiAgc2l6ZXNbMF0gPSA4OyBzaXplc1sxXSA9IDg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50MzJfdW5tYXJzaGFsXG5mdW5jdGlvbiBjYW1sX2ludDMyX3VubWFyc2hhbChyZWFkZXIsIHNpemUpe1xuICBzaXplWzBdID0gNDtcbiAgcmV0dXJuIHJlYWRlci5yZWFkMzJzICgpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX25hdGl2ZWludF91bm1hcnNoYWxcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfbmF0aXZlaW50X3VubWFyc2hhbChyZWFkZXIsIHNpemUpe1xuICBzd2l0Y2ggKHJlYWRlci5yZWFkOHUgKCkpIHtcbiAgY2FzZSAxOlxuICAgIHNpemVbMF0gPSA0O1xuICAgIHJldHVybiByZWFkZXIucmVhZDMycyAoKTtcbiAgY2FzZSAyOlxuICAgIGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogbmF0aXZlIGludGVnZXIgdmFsdWUgdG9vIGxhcmdlXCIpO1xuICBkZWZhdWx0OiBjYW1sX2ZhaWx3aXRoKFwiaW5wdXRfdmFsdWU6IGlsbC1mb3JtZWQgbmF0aXZlIGludGVnZXJcIik7XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9jdXN0b21fb3BzXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3VubWFyc2hhbCwgY2FtbF9pbnQ2NF9tYXJzaGFsLCBjYW1sX2ludDY0X2NvbXBhcmUsIGNhbWxfaW50NjRfaGFzaFxuLy9SZXF1aXJlczogY2FtbF9pbnQzMl91bm1hcnNoYWwsIGNhbWxfbmF0aXZlaW50X3VubWFyc2hhbFxuLy9SZXF1aXJlczogY2FtbF9iYV9zZXJpYWxpemUsIGNhbWxfYmFfZGVzZXJpYWxpemUsIGNhbWxfYmFfY29tcGFyZSwgY2FtbF9iYV9oYXNoXG52YXIgY2FtbF9jdXN0b21fb3BzID1cbiAgICB7XCJfalwiOiB7XG4gICAgICBkZXNlcmlhbGl6ZSA6IGNhbWxfaW50NjRfdW5tYXJzaGFsLFxuICAgICAgc2VyaWFsaXplICA6IGNhbWxfaW50NjRfbWFyc2hhbCxcbiAgICAgIGZpeGVkX2xlbmd0aCA6IDgsXG4gICAgICBjb21wYXJlIDogY2FtbF9pbnQ2NF9jb21wYXJlLFxuICAgICAgaGFzaCA6IGNhbWxfaW50NjRfaGFzaFxuICAgIH0sXG4gICAgIFwiX2lcIjoge1xuICAgICAgIGRlc2VyaWFsaXplIDogY2FtbF9pbnQzMl91bm1hcnNoYWwsXG4gICAgICAgZml4ZWRfbGVuZ3RoIDogNCxcbiAgICAgfSxcbiAgICAgXCJfblwiOiB7XG4gICAgICAgZGVzZXJpYWxpemUgOiBjYW1sX25hdGl2ZWludF91bm1hcnNoYWwsXG4gICAgICAgZml4ZWRfbGVuZ3RoIDogNCxcbiAgICAgfSxcbiAgICAgXCJfYmlnYXJyYXlcIjp7XG4gICAgICAgZGVzZXJpYWxpemUgOiAoZnVuY3Rpb24gKHJlYWRlciwgc3opIHtyZXR1cm4gY2FtbF9iYV9kZXNlcmlhbGl6ZSAocmVhZGVyLHN6LFwiX2JpZ2FycmF5XCIpfSksXG4gICAgICAgc2VyaWFsaXplIDogY2FtbF9iYV9zZXJpYWxpemUsXG4gICAgICAgY29tcGFyZSA6IGNhbWxfYmFfY29tcGFyZSxcbiAgICAgICBoYXNoOiBjYW1sX2JhX2hhc2gsXG4gICAgIH0sXG4gICAgIFwiX2JpZ2FycjAyXCI6e1xuICAgICAgIGRlc2VyaWFsaXplIDogKGZ1bmN0aW9uIChyZWFkZXIsIHN6KSB7cmV0dXJuIGNhbWxfYmFfZGVzZXJpYWxpemUgKHJlYWRlcixzeixcIl9iaWdhcnIwMlwiKX0pLFxuICAgICAgIHNlcmlhbGl6ZSA6IGNhbWxfYmFfc2VyaWFsaXplLFxuICAgICAgIGNvbXBhcmUgOiBjYW1sX2JhX2NvbXBhcmUsXG4gICAgICAgaGFzaDogY2FtbF9iYV9oYXNoLFxuICAgICB9XG4gICAgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fcmVhZGVyIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbi8vUmVxdWlyZXM6IGNhbWxfZmxvYXRfb2ZfYnl0ZXMsIGNhbWxfY3VzdG9tX29wc1xuLy9SZXF1aXJlczogVUludDhBcnJheVJlYWRlclxuLy9SZXF1aXJlczogY2FtbF9kZWNvbXByZXNzX2lucHV0XG5mdW5jdGlvbiBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fcmVhZGVyKHJlYWRlciwgb2ZzKSB7XG4gIGZ1bmN0aW9uIHJlYWR2bHEob3ZlcmZsb3cpIHtcbiAgICB2YXIgYyA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICB2YXIgbiA9IGMgJiAweDdGO1xuICAgIHdoaWxlICgoYyAmIDB4ODApICE9IDApIHtcbiAgICAgIGMgPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICB2YXIgbjcgPSBuIDw8IDc7XG4gICAgICBpZiAobiAhPSBuNyA+PiA3KSBvdmVyZmxvd1swXSA9IHRydWU7XG4gICAgICBuID0gbjcgfCAoYyAmIDB4N0YpO1xuICAgIH1cbiAgICByZXR1cm4gbjtcbiAgfVxuICB2YXIgbWFnaWMgPSByZWFkZXIucmVhZDMydSAoKVxuICBzd2l0Y2gobWFnaWMpe1xuICBjYXNlIDB4ODQ5NUE2QkU6IC8qIEludGV4dF9tYWdpY19udW1iZXJfc21hbGwgKi9cbiAgICB2YXIgaGVhZGVyX2xlbiA9IDIwO1xuICAgIHZhciBjb21wcmVzc2VkID0gMDtcbiAgICB2YXIgZGF0YV9sZW4gPSByZWFkZXIucmVhZDMydSAoKTtcbiAgICB2YXIgdW5jb21wcmVzc2VkX2RhdGFfbGVuID0gZGF0YV9sZW47XG4gICAgdmFyIG51bV9vYmplY3RzID0gcmVhZGVyLnJlYWQzMnUgKCk7XG4gICAgdmFyIF9zaXplXzMyID0gcmVhZGVyLnJlYWQzMnUgKCk7XG4gICAgdmFyIF9zaXplXzY0ID0gcmVhZGVyLnJlYWQzMnUgKCk7XG4gICAgYnJlYWtcbiAgY2FzZSAweDg0OTVBNkJEOiAvKiBJbnRleHRfbWFnaWNfbnVtYmVyX2NvbXByZXNzZWQgKi9cbiAgICB2YXIgaGVhZGVyX2xlbiA9IHJlYWRlci5yZWFkOHUoKSAmIDB4M0Y7XG4gICAgdmFyIGNvbXByZXNzZWQgPSAxO1xuICAgIHZhciBvdmVyZmxvdyA9IFtmYWxzZV07XG4gICAgdmFyIGRhdGFfbGVuID0gcmVhZHZscShvdmVyZmxvdyk7XG4gICAgdmFyIHVuY29tcHJlc3NlZF9kYXRhX2xlbiA9IHJlYWR2bHEob3ZlcmZsb3cpO1xuICAgIHZhciBudW1fb2JqZWN0cyA9IHJlYWR2bHEob3ZlcmZsb3cpO1xuICAgIHZhciBfc2l6ZV8zMiA9IHJlYWR2bHEgKG92ZXJmbG93KTtcbiAgICB2YXIgX3NpemVfNjQgPSByZWFkdmxxIChvdmVyZmxvdyk7XG4gICAgaWYob3ZlcmZsb3dbMF0pe1xuICAgICAgICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3JlYWRlcjogb2JqZWN0IHRvbyBsYXJnZSB0byBiZSByZWFkIGJhY2sgb24gdGhpcyBwbGF0Zm9ybVwiKTtcbiAgICB9XG4gICAgYnJlYWtcbiAgY2FzZSAweDg0OTVBNkJGOiAvKiBJbnRleHRfbWFnaWNfbnVtYmVyX2JpZyAqL1xuICAgIGNhbWxfZmFpbHdpdGgoXCJjYW1sX2lucHV0X3ZhbHVlX2Zyb21fcmVhZGVyOiBvYmplY3QgdG9vIGxhcmdlIHRvIGJlIHJlYWQgYmFjayBvbiBhIDMyLWJpdCBwbGF0Zm9ybVwiKTtcbiAgICBicmVha1xuICBkZWZhdWx0OlxuICAgIGNhbWxfZmFpbHdpdGgoXCJjYW1sX2lucHV0X3ZhbHVlX2Zyb21fcmVhZGVyOiBiYWQgb2JqZWN0XCIpO1xuICAgIGJyZWFrO1xuICB9XG4gIHZhciBzdGFjayA9IFtdO1xuICB2YXIgaW50ZXJuX29ial90YWJsZSA9IChudW1fb2JqZWN0cyA+IDApP1tdOm51bGw7XG4gIHZhciBvYmpfY291bnRlciA9IDA7XG4gIGZ1bmN0aW9uIGludGVybl9yZWMgKHJlYWRlcikge1xuICAgIHZhciBjb2RlID0gcmVhZGVyLnJlYWQ4dSAoKTtcbiAgICBpZiAoY29kZSA+PSAweDQwIC8qY3N0LlBSRUZJWF9TTUFMTF9JTlQqLykge1xuICAgICAgaWYgKGNvZGUgPj0gMHg4MCAvKmNzdC5QUkVGSVhfU01BTExfQkxPQ0sqLykge1xuICAgICAgICB2YXIgdGFnID0gY29kZSAmIDB4RjtcbiAgICAgICAgdmFyIHNpemUgPSAoY29kZSA+PiA0KSAmIDB4NztcbiAgICAgICAgdmFyIHYgPSBbdGFnXTtcbiAgICAgICAgaWYgKHNpemUgPT0gMCkgcmV0dXJuIHY7XG4gICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgc3RhY2sucHVzaCh2LCBzaXplKTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgICB9IGVsc2VcbiAgICAgICAgcmV0dXJuIChjb2RlICYgMHgzRik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjb2RlID49IDB4MjAvKmNzdC5QUkVGSVhfU01BTExfU1RSSU5HICovKSB7XG4gICAgICAgIHZhciBsZW4gPSBjb2RlICYgMHgxRjtcbiAgICAgICAgdmFyIHYgPSByZWFkZXIucmVhZHN0ciAobGVuKTtcbiAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICByZXR1cm4gdjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN3aXRjaChjb2RlKSB7XG4gICAgICAgIGNhc2UgMHgwMDogLy9jc3QuQ09ERV9JTlQ4OlxuICAgICAgICAgIHJldHVybiByZWFkZXIucmVhZDhzICgpO1xuICAgICAgICBjYXNlIDB4MDE6IC8vY3N0LkNPREVfSU5UMTY6XG4gICAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkMTZzICgpO1xuICAgICAgICBjYXNlIDB4MDI6IC8vY3N0LkNPREVfSU5UMzI6XG4gICAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkMzJzICgpO1xuICAgICAgICBjYXNlIDB4MDM6IC8vY3N0LkNPREVfSU5UNjQ6XG4gICAgICAgICAgY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiBpbnRlZ2VyIHRvbyBsYXJnZVwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAweDA0OiAvL2NzdC5DT0RFX1NIQVJFRDg6XG4gICAgICAgICAgdmFyIG9mZnNldCA9IHJlYWRlci5yZWFkOHUgKCk7XG4gICAgICAgICAgaWYoY29tcHJlc3NlZCA9PSAwKSBvZmZzZXQgPSBvYmpfY291bnRlciAtIG9mZnNldDtcbiAgICAgICAgICByZXR1cm4gaW50ZXJuX29ial90YWJsZVtvZmZzZXRdO1xuICAgICAgICBjYXNlIDB4MDU6IC8vY3N0LkNPREVfU0hBUkVEMTY6XG4gICAgICAgICAgdmFyIG9mZnNldCA9IHJlYWRlci5yZWFkMTZ1ICgpO1xuICAgICAgICAgIGlmKGNvbXByZXNzZWQgPT0gMCkgb2Zmc2V0ID0gb2JqX2NvdW50ZXIgLSBvZmZzZXQ7XG4gICAgICAgICAgcmV0dXJuIGludGVybl9vYmpfdGFibGVbb2Zmc2V0XTtcbiAgICAgICAgY2FzZSAweDA2OiAvL2NzdC5DT0RFX1NIQVJFRDMyOlxuICAgICAgICAgIHZhciBvZmZzZXQgPSByZWFkZXIucmVhZDMydSAoKTtcbiAgICAgICAgICBpZihjb21wcmVzc2VkID09IDApIG9mZnNldCA9IG9ial9jb3VudGVyIC0gb2Zmc2V0O1xuICAgICAgICAgIHJldHVybiBpbnRlcm5fb2JqX3RhYmxlW29mZnNldF07XG4gICAgICAgIGNhc2UgMHgwODogLy9jc3QuQ09ERV9CTE9DSzMyOlxuICAgICAgICAgIHZhciBoZWFkZXIgPSByZWFkZXIucmVhZDMydSAoKTtcbiAgICAgICAgICB2YXIgdGFnID0gaGVhZGVyICYgMHhGRjtcbiAgICAgICAgICB2YXIgc2l6ZSA9IGhlYWRlciA+PiAxMDtcbiAgICAgICAgICB2YXIgdiA9IFt0YWddO1xuICAgICAgICAgIGlmIChzaXplID09IDApIHJldHVybiB2O1xuICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICBzdGFjay5wdXNoKHYsIHNpemUpO1xuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjYXNlIDB4MTM6IC8vY3N0LkNPREVfQkxPQ0s2NDpcbiAgICAgICAgICBjYW1sX2ZhaWx3aXRoIChcImlucHV0X3ZhbHVlOiBkYXRhIGJsb2NrIHRvbyBsYXJnZVwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAweDA5OiAvL2NzdC5DT0RFX1NUUklORzg6XG4gICAgICAgICAgdmFyIGxlbiA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgICAgICB2YXIgdiA9IHJlYWRlci5yZWFkc3RyIChsZW4pO1xuICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgY2FzZSAweDBBOiAvL2NzdC5DT0RFX1NUUklORzMyOlxuICAgICAgICAgIHZhciBsZW4gPSByZWFkZXIucmVhZDMydSgpO1xuICAgICAgICAgIHZhciB2ID0gcmVhZGVyLnJlYWRzdHIgKGxlbik7XG4gICAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjYXNlIDB4MEM6IC8vY3N0LkNPREVfRE9VQkxFX0xJVFRMRTpcbiAgICAgICAgICB2YXIgdCA9IG5ldyBBcnJheSg4KTs7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7aSA8IDg7aSsrKSB0WzcgLSBpXSA9IHJlYWRlci5yZWFkOHUgKCk7XG4gICAgICAgICAgdmFyIHYgPSBjYW1sX2Zsb2F0X29mX2J5dGVzICh0KTtcbiAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGNhc2UgMHgwQjogLy9jc3QuQ09ERV9ET1VCTEVfQklHOlxuICAgICAgICAgIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDtpIDwgODtpKyspIHRbaV0gPSByZWFkZXIucmVhZDh1ICgpO1xuICAgICAgICAgIHZhciB2ID0gY2FtbF9mbG9hdF9vZl9ieXRlcyAodCk7XG4gICAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjYXNlIDB4MEU6IC8vY3N0LkNPREVfRE9VQkxFX0FSUkFZOF9MSVRUTEU6XG4gICAgICAgICAgdmFyIGxlbiA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgICAgICB2YXIgdiA9IG5ldyBBcnJheShsZW4rMSk7XG4gICAgICAgICAgdlswXSA9IDI1NDtcbiAgICAgICAgICB2YXIgdCA9IG5ldyBBcnJheSg4KTs7XG4gICAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICAgIGZvciAodmFyIGkgPSAxO2kgPD0gbGVuO2krKykge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7aiA8IDg7aisrKSB0WzcgLSBqXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgICAgICAgIHZbaV0gPSBjYW1sX2Zsb2F0X29mX2J5dGVzICh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGNhc2UgMHgwRDogLy9jc3QuQ09ERV9ET1VCTEVfQVJSQVk4X0JJRzpcbiAgICAgICAgICB2YXIgbGVuID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgICAgIHZhciB2ID0gbmV3IEFycmF5KGxlbisxKTtcbiAgICAgICAgICB2WzBdID0gMjU0O1xuICAgICAgICAgIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDE7aSA8PSBsZW47aSsrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDtqIDwgODtqKyspIHRbal0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICAgICAgICB2IFtpXSA9IGNhbWxfZmxvYXRfb2ZfYnl0ZXMgKHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgY2FzZSAweDA3OiAvL2NzdC5DT0RFX0RPVUJMRV9BUlJBWTMyX0xJVFRMRTpcbiAgICAgICAgICB2YXIgbGVuID0gcmVhZGVyLnJlYWQzMnUoKTtcbiAgICAgICAgICB2YXIgdiA9IG5ldyBBcnJheShsZW4rMSk7XG4gICAgICAgICAgdlswXSA9IDI1NDtcbiAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7O1xuICAgICAgICAgIGZvciAodmFyIGkgPSAxO2kgPD0gbGVuO2krKykge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7aiA8IDg7aisrKSB0WzcgLSBqXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgICAgICAgIHZbaV0gPSBjYW1sX2Zsb2F0X29mX2J5dGVzICh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGNhc2UgMHgwRjogLy9jc3QuQ09ERV9ET1VCTEVfQVJSQVkzMl9CSUc6XG4gICAgICAgICAgdmFyIGxlbiA9IHJlYWRlci5yZWFkMzJ1KCk7XG4gICAgICAgICAgdmFyIHYgPSBuZXcgQXJyYXkobGVuKzEpO1xuICAgICAgICAgIHZbMF0gPSAyNTQ7XG4gICAgICAgICAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7O1xuICAgICAgICAgIGZvciAodmFyIGkgPSAxO2kgPD0gbGVuO2krKykge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7aiA8IDg7aisrKSB0W2pdID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgICAgICAgdiBbaV0gPSBjYW1sX2Zsb2F0X29mX2J5dGVzICh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGNhc2UgMHgxMDogLy9jc3QuQ09ERV9DT0RFUE9JTlRFUjpcbiAgICAgICAgY2FzZSAweDExOiAvL2NzdC5DT0RFX0lORklYUE9JTlRFUjpcbiAgICAgICAgICBjYW1sX2ZhaWx3aXRoIChcImlucHV0X3ZhbHVlOiBjb2RlIHBvaW50ZXJcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMHgxMjogLy9jc3QuQ09ERV9DVVNUT006XG4gICAgICAgIGNhc2UgMHgxODogLy9jc3QuQ09ERV9DVVNUT01fTEVOOlxuICAgICAgICBjYXNlIDB4MTk6IC8vY3N0LkNPREVfQ1VTVE9NX0ZJWEVEOlxuICAgICAgICAgIHZhciBjLCBzID0gXCJcIjtcbiAgICAgICAgICB3aGlsZSAoKGMgPSByZWFkZXIucmVhZDh1ICgpKSAhPSAwKSBzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUgKGMpO1xuICAgICAgICAgIHZhciBvcHMgPSBjYW1sX2N1c3RvbV9vcHNbc107XG4gICAgICAgICAgdmFyIGV4cGVjdGVkX3NpemU7XG4gICAgICAgICAgaWYoIW9wcylcbiAgICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogdW5rbm93biBjdXN0b20gYmxvY2sgaWRlbnRpZmllclwiKTtcbiAgICAgICAgICBzd2l0Y2goY29kZSl7XG4gICAgICAgICAgY2FzZSAweDEyOiAvLyBjc3QuQ09ERV9DVVNUT00gKGRlcHJlY2F0ZWQpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDB4MTk6IC8vIGNzdC5DT0RFX0NVU1RPTV9GSVhFRFxuICAgICAgICAgICAgaWYoIW9wcy5maXhlZF9sZW5ndGgpXG4gICAgICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogZXhwZWN0ZWQgYSBmaXhlZC1zaXplIGN1c3RvbSBibG9ja1wiKTtcbiAgICAgICAgICAgIGV4cGVjdGVkX3NpemUgPSBvcHMuZml4ZWRfbGVuZ3RoO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAweDE4OiAvLyBjc3QuQ09ERV9DVVNUT01fTEVOXG4gICAgICAgICAgICBleHBlY3RlZF9zaXplID0gcmVhZGVyLnJlYWQzMnUgKCk7XG4gICAgICAgICAgICAvLyBTa2lwIHNpemU2NFxuICAgICAgICAgICAgcmVhZGVyLnJlYWQzMnMoKTsgcmVhZGVyLnJlYWQzMnMoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgb2xkX3BvcyA9IHJlYWRlci5pO1xuICAgICAgICAgIHZhciBzaXplID0gWzBdO1xuICAgICAgICAgIHZhciB2ID0gb3BzLmRlc2VyaWFsaXplKHJlYWRlciwgc2l6ZSk7XG4gICAgICAgICAgaWYoZXhwZWN0ZWRfc2l6ZSAhPSB1bmRlZmluZWQpe1xuICAgICAgICAgICAgaWYoZXhwZWN0ZWRfc2l6ZSAhPSBzaXplWzBdKVxuICAgICAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwiaW5wdXRfdmFsdWU6IGluY29ycmVjdCBsZW5ndGggb2Ygc2VyaWFsaXplZCBjdXN0b20gYmxvY2tcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjYW1sX2ZhaWx3aXRoIChcImlucHV0X3ZhbHVlOiBpbGwtZm9ybWVkIG1lc3NhZ2VcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYoY29tcHJlc3NlZCkge1xuICAgIGlmKGNhbWxfZGVjb21wcmVzc19pbnB1dCkge1xuICAgICAgdmFyIGRhdGEgPSByZWFkZXIucmVhZHVpbnQ4YXJyYXkoZGF0YV9sZW4pO1xuICAgICAgdmFyIHJlcyA9IG5ldyBVaW50OEFycmF5KHVuY29tcHJlc3NlZF9kYXRhX2xlbik7XG4gICAgICB2YXIgcmVzID0gY2FtbF9kZWNvbXByZXNzX2lucHV0KGRhdGEsIHJlcyk7XG4gICAgICB2YXIgcmVhZGVyID0gbmV3IFVJbnQ4QXJyYXlSZWFkZXIocmVzLCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiBjb21wcmVzc2VkIG9iamVjdCwgY2Fubm90IGRlY29tcHJlc3NcIik7XG4gICAgfVxuICB9XG4gIHZhciByZXMgPSBpbnRlcm5fcmVjIChyZWFkZXIpO1xuICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgIHZhciBzaXplID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIHYgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgZCA9IHYubGVuZ3RoO1xuICAgIGlmIChkIDwgc2l6ZSkgc3RhY2sucHVzaCh2LCBzaXplKTtcbiAgICB2W2RdID0gaW50ZXJuX3JlYyAocmVhZGVyKTtcbiAgfVxuICBpZiAodHlwZW9mIG9mcyE9XCJudW1iZXJcIikgb2ZzWzBdID0gcmVhZGVyLmk7XG4gIHJldHVybiByZXM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWFyc2hhbF9oZWFkZXJfc2l6ZVxuLy9WZXJzaW9uOiA8IDUuMS4wXG52YXIgY2FtbF9tYXJzaGFsX2hlYWRlcl9zaXplID0gMjBcblxuLy9Qcm92aWRlczogY2FtbF9tYXJzaGFsX2hlYWRlcl9zaXplXG4vL1ZlcnNpb246ID49IDUuMS4wXG52YXIgY2FtbF9tYXJzaGFsX2hlYWRlcl9zaXplID0gMTZcblxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWFyc2hhbF9kYXRhX3NpemUgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aCwgY2FtbF9ieXRlc191bnNhZmVfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX3VpbnQ4X2FycmF5X29mX2J5dGVzXG4vL1JlcXVpcmVzOiBVSW50OEFycmF5UmVhZGVyXG4vL1JlcXVpcmVzOiBjYW1sX21hcnNoYWxfaGVhZGVyX3NpemVcbmZ1bmN0aW9uIGNhbWxfbWFyc2hhbF9kYXRhX3NpemUgKHMsIG9mcykge1xuICB2YXIgciA9IG5ldyBVSW50OEFycmF5UmVhZGVyKGNhbWxfdWludDhfYXJyYXlfb2ZfYnl0ZXMocyksIG9mcyk7XG4gIGZ1bmN0aW9uIHJlYWR2bHEob3ZlcmZsb3cpIHtcbiAgICB2YXIgYyA9IHIucmVhZDh1KCk7XG4gICAgdmFyIG4gPSBjICYgMHg3RjtcbiAgICB3aGlsZSAoKGMgJiAweDgwKSAhPSAwKSB7XG4gICAgICBjID0gci5yZWFkOHUoKTtcbiAgICAgIHZhciBuNyA9IG4gPDwgNztcbiAgICAgIGlmIChuICE9IG43ID4+IDcpIG92ZXJmbG93WzBdID0gdHJ1ZTtcbiAgICAgIG4gPSBuNyB8IChjICYgMHg3Rik7XG4gICAgfVxuICAgIHJldHVybiBuO1xuICB9XG5cbiAgc3dpdGNoKHIucmVhZDMydSgpKXtcbiAgY2FzZSAweDg0OTVBNkJFOiAvKiBJbnRleHRfbWFnaWNfbnVtYmVyX3NtYWxsICovXG4gICAgdmFyIGhlYWRlcl9sZW4gPSAyMDtcbiAgICB2YXIgZGF0YV9sZW4gPSByLnJlYWQzMnUoKTtcbiAgICBicmVhaztcbiAgY2FzZSAweDg0OTVBNkJEOiAvKiBJbnRleHRfbWFnaWNfbnVtYmVyX2NvbXByZXNzZWQgKi9cbiAgICB2YXIgaGVhZGVyX2xlbiA9IHIucmVhZDh1KCkgJiAweDNGO1xuICAgIHZhciBvdmVyZmxvdyA9IFtmYWxzZV07XG4gICAgdmFyIGRhdGFfbGVuID0gcmVhZHZscShvdmVyZmxvdyk7XG4gICAgaWYob3ZlcmZsb3dbMF0pe1xuICAgICAgY2FtbF9mYWlsd2l0aChcIk1hcnNoYWwuZGF0YV9zaXplOiBvYmplY3QgdG9vIGxhcmdlIHRvIGJlIHJlYWQgYmFjayBvbiB0aGlzIHBsYXRmb3JtXCIpO1xuICAgIH1cbiAgICBicmVha1xuICBjYXNlIDB4ODQ5NUE2QkY6IC8qIEludGV4dF9tYWdpY19udW1iZXJfYmlnICovXG4gIGRlZmF1bHQ6XG4gICAgY2FtbF9mYWlsd2l0aChcIk1hcnNoYWwuZGF0YV9zaXplOiBiYWQgb2JqZWN0XCIpO1xuICAgIGJyZWFrXG4gIH1cbiAgcmV0dXJuIGhlYWRlcl9sZW4gLSBjYW1sX21hcnNoYWxfaGVhZGVyX3NpemUgKyBkYXRhX2xlbjtcbn1cblxuLy9Qcm92aWRlczogTWxPYmplY3RUYWJsZVxudmFyIE1sT2JqZWN0VGFibGU7XG5pZiAodHlwZW9mIGdsb2JhbFRoaXMuTWFwID09PSAndW5kZWZpbmVkJykge1xuICBNbE9iamVjdFRhYmxlID0gZnVuY3Rpb24oKSB7XG4gICAgLyogcG9seWZpbGwgKHVzaW5nIGxpbmVhciBzZWFyY2gpICovXG4gICAgZnVuY3Rpb24gTmFpdmVMb29rdXAob2JqcykgeyB0aGlzLm9ianMgPSBvYmpzOyB9XG4gICAgTmFpdmVMb29rdXAucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5vYmpzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzLm9ianNbaV0gPT09IHYpIHJldHVybiBpO1xuICAgICAgfVxuICAgIH07XG4gICAgTmFpdmVMb29rdXAucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gRG8gbm90aGluZyBoZXJlLiBbTWxPYmplY3RUYWJsZS5zdG9yZV0gd2lsbCBwdXNoIHRvIFt0aGlzLm9ianNdIGRpcmVjdGx5LlxuICAgIH07XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gTWxPYmplY3RUYWJsZSgpIHtcbiAgICAgIHRoaXMub2JqcyA9IFtdOyB0aGlzLmxvb2t1cCA9IG5ldyBOYWl2ZUxvb2t1cCh0aGlzLm9ianMpO1xuICAgIH07XG4gIH0oKTtcbn1cbmVsc2Uge1xuICBNbE9iamVjdFRhYmxlID0gZnVuY3Rpb24gTWxPYmplY3RUYWJsZSgpIHtcbiAgICB0aGlzLm9ianMgPSBbXTsgdGhpcy5sb29rdXAgPSBuZXcgZ2xvYmFsVGhpcy5NYXAoKTtcbiAgfTtcbn1cblxuTWxPYmplY3RUYWJsZS5wcm90b3R5cGUuc3RvcmUgPSBmdW5jdGlvbih2KSB7XG4gIHRoaXMubG9va3VwLnNldCh2LCB0aGlzLm9ianMubGVuZ3RoKTtcbiAgdGhpcy5vYmpzLnB1c2godik7XG59XG5cbk1sT2JqZWN0VGFibGUucHJvdG90eXBlLnJlY2FsbCA9IGZ1bmN0aW9uKHYpIHtcbiAgdmFyIGkgPSB0aGlzLmxvb2t1cC5nZXQodik7XG4gIHJldHVybiAoaSA9PT0gdW5kZWZpbmVkKVxuICAgID8gdW5kZWZpbmVkIDogdGhpcy5vYmpzLmxlbmd0aCAtIGk7ICAgLyogaW5kZXggaXMgcmVsYXRpdmUgKi9cbn1cblxuLy9Qcm92aWRlczogY2FtbF9vdXRwdXRfdmFsXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3RvX2J5dGVzLCBjYW1sX2ZhaWx3aXRoXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXRcbi8vUmVxdWlyZXM6IGNhbWxfaXNfbWxfYnl0ZXMsIGNhbWxfbWxfYnl0ZXNfbGVuZ3RoLCBjYW1sX2J5dGVzX3Vuc2FmZV9nZXRcbi8vUmVxdWlyZXM6IGNhbWxfaXNfbWxfc3RyaW5nLCBjYW1sX21sX3N0cmluZ19sZW5ndGgsIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXRcbi8vUmVxdWlyZXM6IE1sT2JqZWN0VGFibGUsIGNhbWxfbGlzdF90b19qc19hcnJheSwgY2FtbF9jdXN0b21fb3BzXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnQsY2FtbF9zdHJpbmdfb2ZfanNieXRlcywgY2FtbF9pc19jb250aW51YXRpb25fdGFnXG52YXIgY2FtbF9vdXRwdXRfdmFsID0gZnVuY3Rpb24gKCl7XG4gIGZ1bmN0aW9uIFdyaXRlciAoKSB7IHRoaXMuY2h1bmsgPSBbXTsgfVxuICBXcml0ZXIucHJvdG90eXBlID0ge1xuICAgIGNodW5rX2lkeDoyMCwgYmxvY2tfbGVuOjAsIG9ial9jb3VudGVyOjAsIHNpemVfMzI6MCwgc2l6ZV82NDowLFxuICAgIHdyaXRlOmZ1bmN0aW9uIChzaXplLCB2YWx1ZSkge1xuICAgICAgZm9yICh2YXIgaSA9IHNpemUgLSA4O2kgPj0gMDtpIC09IDgpXG4gICAgICAgIHRoaXMuY2h1bmtbdGhpcy5jaHVua19pZHgrK10gPSAodmFsdWUgPj4gaSkgJiAweEZGO1xuICAgIH0sXG4gICAgd3JpdGVfYXQ6ZnVuY3Rpb24gKHBvcywgc2l6ZSwgdmFsdWUpIHtcbiAgICAgIHZhciBwb3MgPSBwb3M7XG4gICAgICBmb3IgKHZhciBpID0gc2l6ZSAtIDg7aSA+PSAwO2kgLT0gOClcbiAgICAgICAgdGhpcy5jaHVua1twb3MrK10gPSAodmFsdWUgPj4gaSkgJiAweEZGO1xuICAgIH0sXG4gICAgd3JpdGVfY29kZTpmdW5jdGlvbiAoc2l6ZSwgY29kZSwgdmFsdWUpIHtcbiAgICAgIHRoaXMuY2h1bmtbdGhpcy5jaHVua19pZHgrK10gPSBjb2RlO1xuICAgICAgZm9yICh2YXIgaSA9IHNpemUgLSA4O2kgPj0gMDtpIC09IDgpXG4gICAgICAgIHRoaXMuY2h1bmtbdGhpcy5jaHVua19pZHgrK10gPSAodmFsdWUgPj4gaSkgJiAweEZGO1xuICAgIH0sXG4gICAgd3JpdGVfc2hhcmVkOmZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgIGlmIChvZmZzZXQgPCAoMSA8PCA4KSkgdGhpcy53cml0ZV9jb2RlKDgsIDB4MDQgLypjc3QuQ09ERV9TSEFSRUQ4Ki8sIG9mZnNldCk7XG4gICAgICBlbHNlIGlmIChvZmZzZXQgPCAoMSA8PCAxNikpIHRoaXMud3JpdGVfY29kZSgxNiwgMHgwNSAvKmNzdC5DT0RFX1NIQVJFRDE2Ki8sIG9mZnNldCk7XG4gICAgICBlbHNlIHRoaXMud3JpdGVfY29kZSgzMiwgMHgwNiAvKmNzdC5DT0RFX1NIQVJFRDMyKi8sIG9mZnNldCk7XG4gICAgfSxcbiAgICBwb3M6ZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5jaHVua19pZHggfSxcbiAgICBmaW5hbGl6ZTpmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmJsb2NrX2xlbiA9IHRoaXMuY2h1bmtfaWR4IC0gMjA7XG4gICAgICB0aGlzLmNodW5rX2lkeCA9IDA7XG4gICAgICB0aGlzLndyaXRlICgzMiwgMHg4NDk1QTZCRSk7XG4gICAgICB0aGlzLndyaXRlICgzMiwgdGhpcy5ibG9ja19sZW4pO1xuICAgICAgdGhpcy53cml0ZSAoMzIsIHRoaXMub2JqX2NvdW50ZXIpO1xuICAgICAgdGhpcy53cml0ZSAoMzIsIHRoaXMuc2l6ZV8zMik7XG4gICAgICB0aGlzLndyaXRlICgzMiwgdGhpcy5zaXplXzY0KTtcbiAgICAgIHJldHVybiB0aGlzLmNodW5rO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKHYsIGZsYWdzKSB7XG4gICAgZmxhZ3MgPSBjYW1sX2xpc3RfdG9fanNfYXJyYXkoZmxhZ3MpO1xuXG4gICAgdmFyIG5vX3NoYXJpbmcgPSAoZmxhZ3MuaW5kZXhPZigwIC8qTWFyc2hhbC5Ob19zaGFyaW5nKi8pICE9PSAtMSksXG4gICAgICAgIGNsb3N1cmVzID0gIChmbGFncy5pbmRleE9mKDEgLypNYXJzaGFsLkNsb3N1cmVzKi8pICE9PSAtMSk7XG4gICAgLyogTWFyc2hhbC5Db21wYXRfMzIgaXMgcmVkdW5kYW50IHNpbmNlIGludGVnZXJzIGFyZSAzMi1iaXQgYW55d2F5ICovXG5cbiAgICBpZiAoY2xvc3VyZXMpXG4gICAgICBjb25zb2xlLndhcm4oXCJpbiBjYW1sX291dHB1dF92YWw6IGZsYWcgTWFyc2hhbC5DbG9zdXJlcyBpcyBub3Qgc3VwcG9ydGVkLlwiKTtcblxuICAgIHZhciB3cml0ZXIgPSBuZXcgV3JpdGVyICgpO1xuICAgIHZhciBzdGFjayA9IFtdO1xuICAgIHZhciBpbnRlcm5fb2JqX3RhYmxlID0gbm9fc2hhcmluZyA/IG51bGwgOiBuZXcgTWxPYmplY3RUYWJsZSgpO1xuXG4gICAgZnVuY3Rpb24gbWVtbyh2KSB7XG4gICAgICBpZiAobm9fc2hhcmluZykgcmV0dXJuIGZhbHNlO1xuICAgICAgdmFyIGV4aXN0aW5nX29mZnNldCA9IGludGVybl9vYmpfdGFibGUucmVjYWxsKHYpO1xuICAgICAgaWYgKGV4aXN0aW5nX29mZnNldCkgeyB3cml0ZXIud3JpdGVfc2hhcmVkKGV4aXN0aW5nX29mZnNldCk7IHJldHVybiB0cnVlOyB9XG4gICAgICBlbHNlIHsgaW50ZXJuX29ial90YWJsZS5zdG9yZSh2KTsgcmV0dXJuIGZhbHNlOyB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXh0ZXJuX3JlYyAodikge1xuICAgICAgaWYgKHYuY2FtbF9jdXN0b20pIHtcbiAgICAgICAgaWYgKG1lbW8odikpIHJldHVybjtcbiAgICAgICAgdmFyIG5hbWUgPSB2LmNhbWxfY3VzdG9tO1xuICAgICAgICB2YXIgb3BzID0gY2FtbF9jdXN0b21fb3BzW25hbWVdO1xuICAgICAgICB2YXIgc3pfMzJfNjQgPSBbMCwwXTtcbiAgICAgICAgaWYoIW9wcy5zZXJpYWxpemUpXG4gICAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwib3V0cHV0X3ZhbHVlOiBhYnN0cmFjdCB2YWx1ZSAoQ3VzdG9tKVwiKTtcbiAgICAgICAgaWYob3BzLmZpeGVkX2xlbmd0aCA9PSB1bmRlZmluZWQpe1xuICAgICAgICAgIHdyaXRlci53cml0ZSAoOCwgMHgxOCAvKmNzdC5DT0RFX0NVU1RPTV9MRU4qLyk7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgd3JpdGVyLndyaXRlICg4LCBuYW1lLmNoYXJDb2RlQXQoaSkpO1xuICAgICAgICAgIHdyaXRlci53cml0ZSg4LCAwKTtcbiAgICAgICAgICB2YXIgaGVhZGVyX3BvcyA9IHdyaXRlci5wb3MgKCk7XG4gICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgIHdyaXRlci53cml0ZSg4LCAwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3BzLnNlcmlhbGl6ZSh3cml0ZXIsIHYsIHN6XzMyXzY0KTtcbiAgICAgICAgICB3cml0ZXIud3JpdGVfYXQoaGVhZGVyX3BvcywgMzIsIHN6XzMyXzY0WzBdKTtcbiAgICAgICAgICB3cml0ZXIud3JpdGVfYXQoaGVhZGVyX3BvcyArIDQsIDMyLCAwKTsgLy8gemVyb1xuICAgICAgICAgIHdyaXRlci53cml0ZV9hdChoZWFkZXJfcG9zICsgOCwgMzIsIHN6XzMyXzY0WzFdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIDB4MTkgLypjc3QuQ09ERV9DVVNUT01fRklYRUQqLyk7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgd3JpdGVyLndyaXRlICg4LCBuYW1lLmNoYXJDb2RlQXQoaSkpO1xuICAgICAgICAgIHdyaXRlci53cml0ZSg4LCAwKTtcbiAgICAgICAgICB2YXIgb2xkX3BvcyA9IHdyaXRlci5wb3MoKTtcbiAgICAgICAgICBvcHMuc2VyaWFsaXplKHdyaXRlciwgdiwgc3pfMzJfNjQpO1xuICAgICAgICAgIGlmIChvcHMuZml4ZWRfbGVuZ3RoICE9IHdyaXRlci5wb3MoKSAtIG9sZF9wb3MpXG4gICAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwib3V0cHV0X3ZhbHVlOiBpbmNvcnJlY3QgZml4ZWQgc2l6ZXMgc3BlY2lmaWVkIGJ5IFwiICsgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgd3JpdGVyLnNpemVfMzIgKz0gMiArICgoc3pfMzJfNjRbMF0gKyAzKSA+PiAyKTtcbiAgICAgICAgd3JpdGVyLnNpemVfNjQgKz0gMiArICgoc3pfMzJfNjRbMV0gKyA3KSA+PiAzKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHYgaW5zdGFuY2VvZiBBcnJheSAmJiB2WzBdID09PSAodlswXXwwKSkge1xuICAgICAgICBpZiAodlswXSA9PSAyNTEpIHtcbiAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwib3V0cHV0X3ZhbHVlOiBhYnN0cmFjdCB2YWx1ZSAoQWJzdHJhY3QpXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYW1sX2lzX2NvbnRpbnVhdGlvbl90YWcodlswXSkpXG4gICAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwib3V0cHV0X3ZhbHVlOiBjb250aW51YXRpb24gdmFsdWVcIik7XG4gICAgICAgIGlmICh2Lmxlbmd0aCA+IDEgJiYgbWVtbyh2KSkgcmV0dXJuO1xuICAgICAgICBpZiAodlswXSA8IDE2ICYmIHYubGVuZ3RoIC0gMSA8IDgpXG4gICAgICAgICAgd3JpdGVyLndyaXRlICg4LCAweDgwIC8qY3N0LlBSRUZJWF9TTUFMTF9CTE9DSyovICsgdlswXSArICgodi5sZW5ndGggLSAxKTw8NCkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgd3JpdGVyLndyaXRlX2NvZGUoMzIsIDB4MDggLypjc3QuQ09ERV9CTE9DSzMyKi8sICgodi5sZW5ndGgtMSkgPDwgMTApIHwgdlswXSk7XG4gICAgICAgIHdyaXRlci5zaXplXzMyICs9IHYubGVuZ3RoO1xuICAgICAgICB3cml0ZXIuc2l6ZV82NCArPSB2Lmxlbmd0aDtcbiAgICAgICAgaWYgKHYubGVuZ3RoID4gMSkgc3RhY2sucHVzaCAodiwgMSk7XG4gICAgICB9IGVsc2UgaWYgKGNhbWxfaXNfbWxfYnl0ZXModikpIHtcbiAgICAgICAgaWYoIShjYW1sX2lzX21sX2J5dGVzKGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoXCJcIikpKSkge1xuICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJvdXRwdXRfdmFsdWU6IFtCeXRlcy50XSBjYW5ub3Qgc2FmZWx5IGJlIG1hcnNoYWxlZCB3aXRoIFstLWVuYWJsZSB1c2UtanMtc3RyaW5nXVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVtbyh2KSkgcmV0dXJuO1xuICAgICAgICB2YXIgbGVuID0gY2FtbF9tbF9ieXRlc19sZW5ndGgodik7XG4gICAgICAgIGlmIChsZW4gPCAweDIwKVxuICAgICAgICAgIHdyaXRlci53cml0ZSAoOCwgMHgyMCAvKmNzdC5QUkVGSVhfU01BTExfU1RSSU5HKi8gKyBsZW4pO1xuICAgICAgICBlbHNlIGlmIChsZW4gPCAweDEwMClcbiAgICAgICAgICB3cml0ZXIud3JpdGVfY29kZSAoOCwgMHgwOS8qY3N0LkNPREVfU1RSSU5HOCovLCBsZW4pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgd3JpdGVyLndyaXRlX2NvZGUgKDMyLCAweDBBIC8qY3N0LkNPREVfU1RSSU5HMzIqLywgbGVuKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7aSA8IGxlbjtpKyspXG4gICAgICAgICAgd3JpdGVyLndyaXRlICg4LCBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQodixpKSk7XG4gICAgICAgIHdyaXRlci5zaXplXzMyICs9IDEgKyAoKChsZW4gKyA0KSAvIDQpfDApO1xuICAgICAgICB3cml0ZXIuc2l6ZV82NCArPSAxICsgKCgobGVuICsgOCkgLyA4KXwwKTtcbiAgICAgIH0gZWxzZSBpZiAoY2FtbF9pc19tbF9zdHJpbmcodikpIHtcbiAgICAgICAgaWYgKG1lbW8odikpIHJldHVybjtcbiAgICAgICAgdmFyIGxlbiA9IGNhbWxfbWxfc3RyaW5nX2xlbmd0aCh2KTtcbiAgICAgICAgaWYgKGxlbiA8IDB4MjApXG4gICAgICAgICAgd3JpdGVyLndyaXRlICg4LCAweDIwIC8qY3N0LlBSRUZJWF9TTUFMTF9TVFJJTkcqLyArIGxlbik7XG4gICAgICAgIGVsc2UgaWYgKGxlbiA8IDB4MTAwKVxuICAgICAgICAgIHdyaXRlci53cml0ZV9jb2RlICg4LCAweDA5Lypjc3QuQ09ERV9TVFJJTkc4Ki8sIGxlbik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB3cml0ZXIud3JpdGVfY29kZSAoMzIsIDB4MEEgLypjc3QuQ09ERV9TVFJJTkczMiovLCBsZW4pO1xuICAgICAgICBmb3IgKHZhciBpID0gMDtpIDwgbGVuO2krKylcbiAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQodixpKSk7XG4gICAgICAgIHdyaXRlci5zaXplXzMyICs9IDEgKyAoKChsZW4gKyA0KSAvIDQpfDApO1xuICAgICAgICB3cml0ZXIuc2l6ZV82NCArPSAxICsgKCgobGVuICsgOCkgLyA4KXwwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh2ICE9ICh2fDApKXtcbiAgICAgICAgICB2YXIgdHlwZV9vZl92ID0gdHlwZW9mIHY7XG4gICAgICAgICAgaWYodHlwZV9vZl92ICE9IFwibnVtYmVyXCIpXG4gICAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwib3V0cHV0X3ZhbHVlOiBhYnN0cmFjdCB2YWx1ZSAoXCIrdHlwZV9vZl92K1wiKVwiKTtcbiAgICAgICAgICAvLyBJZiBhIGZsb2F0IGhhcHBlbnMgdG8gYmUgYW4gaW50ZWdlciBpdCBpcyBzZXJpYWxpemVkIGFzIGFuIGludGVnZXJcbiAgICAgICAgICAvLyAoSnNfb2Zfb2NhbWwgY2Fubm90IHRlbGwgd2hldGhlciB0aGUgdHlwZSBvZiBhbiBpbnRlZ2VyIG51bWJlciBpc1xuICAgICAgICAgIC8vIGZsb2F0IG9yIGludGVnZXIuKSBUaGlzIGNhbiByZXN1bHQgaW4gdW5leHBlY3RlZCBjcmFzaGVzIHdoZW5cbiAgICAgICAgICAvLyB1bm1hcnNoYWxsaW5nIHVzaW5nIHRoZSBzdGFuZGFyZCBydW50aW1lLlxuICAgICAgICAgIGlmIChtZW1vKHYpKSByZXR1cm47XG4gICAgICAgICAgdmFyIHQgPSBjYW1sX2ludDY0X3RvX2J5dGVzKGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCh2KSk7XG4gICAgICAgICAgd3JpdGVyLndyaXRlICg4LCAweDBDIC8qY3N0LkNPREVfRE9VQkxFX0xJVFRMRSovKTtcbiAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpPDg7IGkrKyl7d3JpdGVyLndyaXRlKDgsdFs3IC0gaV0pfVxuICAgICAgICAgIHdyaXRlci5zaXplXzMyICs9IDNcbiAgICAgICAgICB3cml0ZXIuc2l6ZV82NCArPSAyXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodiA+PSAwICYmIHYgPCAweDQwKSB7XG4gICAgICAgICAgd3JpdGVyLndyaXRlICg4LCAwWDQwIC8qY3N0LlBSRUZJWF9TTUFMTF9JTlQqLyArIHYpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh2ID49IC0oMSA8PCA3KSAmJiB2IDwgKDEgPDwgNykpXG4gICAgICAgICAgICB3cml0ZXIud3JpdGVfY29kZSg4LCAweDAwIC8qY3N0LkNPREVfSU5UOCovLCB2KTtcbiAgICAgICAgICBlbHNlIGlmICh2ID49IC0oMSA8PCAxNSkgJiYgdiA8ICgxIDw8IDE1KSlcbiAgICAgICAgICAgIHdyaXRlci53cml0ZV9jb2RlKDE2LCAweDAxIC8qY3N0LkNPREVfSU5UMTYqLywgdik7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgd3JpdGVyLndyaXRlX2NvZGUoMzIsIDB4MDIgLypjc3QuQ09ERV9JTlQzMiovLCB2KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBleHRlcm5fcmVjICh2KTtcbiAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgdmFyIGkgPSBzdGFjay5wb3AgKCk7XG4gICAgICB2YXIgdiA9IHN0YWNrLnBvcCAoKTtcbiAgICAgIGlmIChpICsgMSA8IHYubGVuZ3RoKSBzdGFjay5wdXNoICh2LCBpICsgMSk7XG4gICAgICBleHRlcm5fcmVjICh2W2ldKTtcbiAgICB9XG4gICAgaWYgKGludGVybl9vYmpfdGFibGUpIHdyaXRlci5vYmpfY291bnRlciA9IGludGVybl9vYmpfdGFibGUub2Jqcy5sZW5ndGg7XG4gICAgd3JpdGVyLmZpbmFsaXplKCk7XG4gICAgcmV0dXJuIHdyaXRlci5jaHVuaztcbiAgfVxufSAoKTtcblxuLy9Qcm92aWRlczogY2FtbF9vdXRwdXRfdmFsdWVfdG9fc3RyaW5nIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfb3V0cHV0X3ZhbCwgY2FtbF9zdHJpbmdfb2ZfYXJyYXlcbmZ1bmN0aW9uIGNhbWxfb3V0cHV0X3ZhbHVlX3RvX3N0cmluZyAodiwgZmxhZ3MpIHtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2FycmF5IChjYW1sX291dHB1dF92YWwgKHYsIGZsYWdzKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb3V0cHV0X3ZhbHVlX3RvX2J5dGVzIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfb3V0cHV0X3ZhbCwgY2FtbF9ieXRlc19vZl9hcnJheVxuZnVuY3Rpb24gY2FtbF9vdXRwdXRfdmFsdWVfdG9fYnl0ZXMgKHYsIGZsYWdzKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX29mX2FycmF5IChjYW1sX291dHB1dF92YWwgKHYsIGZsYWdzKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb3V0cHV0X3ZhbHVlX3RvX2J1ZmZlclxuLy9SZXF1aXJlczogY2FtbF9vdXRwdXRfdmFsLCBjYW1sX2ZhaWx3aXRoLCBjYW1sX2JsaXRfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfb3V0cHV0X3ZhbHVlX3RvX2J1ZmZlciAocywgb2ZzLCBsZW4sIHYsIGZsYWdzKSB7XG4gIHZhciB0ID0gY2FtbF9vdXRwdXRfdmFsICh2LCBmbGFncyk7XG4gIGlmICh0Lmxlbmd0aCA+IGxlbikgY2FtbF9mYWlsd2l0aCAoXCJNYXJzaGFsLnRvX2J1ZmZlcjogYnVmZmVyIG92ZXJmbG93XCIpO1xuICBjYW1sX2JsaXRfYnl0ZXModCwgMCwgcywgb2ZzLCB0Lmxlbmd0aCk7XG4gIHJldHVybiAwO1xufVxuIiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogICAgQ29weXJpZ2h0IDIwMjIgT0NhbWxQcm8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogIEFsbCByaWdodHMgcmVzZXJ2ZWQuIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlICAqL1xuLyogIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgc3BlY2lhbCAgICAgICAqL1xuLyogIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAgICAgICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vL1Byb3ZpZGVzOiBPcHRpb25hbF9ib29sX3ZhbFxuZnVuY3Rpb24gT3B0aW9uYWxfYm9vbF92YWwobWxPcHRCb29sLCBkZWYpIHtcbiAgcmV0dXJuICh0eXBlb2YobWxPcHRCb29sKSA9PSBcIm9iamVjdFwiKSA/IChtbE9wdEJvb2xbMV0gIT09IDApIDogZGVmO1xufVxuXG4vL1Byb3ZpZGVzOiBPcHRpb25hbF92YWxcbmZ1bmN0aW9uIE9wdGlvbmFsX3ZhbChtbE9wdFZhbCwgZGVmKSB7XG4gIHJldHVybiAodHlwZW9mKG1sT3B0VmFsKSA9PSBcIm9iamVjdFwiKSA/IG1sT3B0VmFsWzFdIDogZGVmO1xufVxuXG4vL1Byb3ZpZGVzOiBWYWxfZm9jdXNfaW5fb3V0XG4vL1JlcXVpcmVzOiBGT0NVUyxGT0NVU19UQUdcblxudmFyIGZvY3VzX3RvX3RhZyA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5NYXAoW1xuICBbRk9DVVMuT1VULCBGT0NVU19UQUcuT1VUXSxcbiAgW0ZPQ1VTLklOLCAgRk9DVVNfVEFHLklOXSxcbl0pO1xuXG5mdW5jdGlvbiBWYWxfZm9jdXNfaW5fb3V0KGZvY3VzKSB7XG4gIHJldHVybiBmb2N1c190b190YWcuZ2V0KGZvY3VzKTtcbn1cblxuLy9Qcm92aWRlczogVmFsX2tleV9jb2RlXG4vL1JlcXVpcmVzOiBLRVksS0VZX1RBR1xuXG52YXIga2NfdG9fdGFnID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0Lk1hcChbXG4gIFtLRVkuRVNDQVBFLCAgICAgICAgICAgICAgIEtFWV9UQUcuRVNDQVBFXSxcbiAgW0tFWS5GMSwgICAgICAgICAgICAgICAgICAgS0VZX1RBRy5GMV0sXG4gIFtLRVkuRjIsICAgICAgICAgICAgICAgICAgIEtFWV9UQUcuRjJdLFxuICBbS0VZLkYzLCAgICAgICAgICAgICAgICAgICBLRVlfVEFHLkYzXSxcbiAgW0tFWS5GNCwgICAgICAgICAgICAgICAgICAgS0VZX1RBRy5GNF0sXG4gIFtLRVkuRjUsICAgICAgICAgICAgICAgICAgIEtFWV9UQUcuRjVdLFxuICBbS0VZLkY2LCAgICAgICAgICAgICAgICAgICBLRVlfVEFHLkY2XSxcbiAgW0tFWS5GNywgICAgICAgICAgICAgICAgICAgS0VZX1RBRy5GN10sXG4gIFtLRVkuRjgsICAgICAgICAgICAgICAgICAgIEtFWV9UQUcuRjhdLFxuICBbS0VZLkY5LCAgICAgICAgICAgICAgICAgICBLRVlfVEFHLkY5XSxcbiAgW0tFWS5GMTAsICAgICAgICAgICAgICAgICAgS0VZX1RBRy5GMTBdLFxuICBbS0VZLkYxMSwgICAgICAgICAgICAgICAgICBLRVlfVEFHLkYxMV0sXG4gIFtLRVkuRjEyLCAgICAgICAgICAgICAgICAgIEtFWV9UQUcuRjEyXSxcbiAgW0tFWS5QUklOVFNDUkVFTiwgICAgICAgICAgS0VZX1RBRy5QUklOVFNDUkVFTl0sXG4gIFtLRVkuU0NST0xMTE9DSywgICAgICAgICAgIEtFWV9UQUcuU0NST0xMTE9DS10sXG4gIFtLRVkuUEFVU0UsICAgICAgICAgICAgICAgIEtFWV9UQUcuUEFVU0VdLFxuICBbS0VZLkdSQVZFX1RJTERFLCAgICAgICAgICBLRVlfVEFHLkdSQVZFX1RJTERFXSxcbiAgW0tFWS5fMV9FWENMQU1BVElPTiwgICAgICAgS0VZX1RBRy5fMV9FWENMQU1BVElPTl0sXG4gIFtLRVkuXzJfQVQsICAgICAgICAgICAgICAgIEtFWV9UQUcuXzJfQVRdLFxuICBbS0VZLl8zX05VTUJFUiwgICAgICAgICAgICBLRVlfVEFHLl8zX05VTUJFUl0sXG4gIFtLRVkuXzRfRE9MTEFSLCAgICAgICAgICAgIEtFWV9UQUcuXzRfRE9MTEFSXSxcbiAgW0tFWS5fNV9QRVJDRU5ULCAgICAgICAgICAgS0VZX1RBRy5fNV9QRVJDRU5UXSxcbiAgW0tFWS5fNl9DQVJFVCwgICAgICAgICAgICAgS0VZX1RBRy5fNl9DQVJFVF0sXG4gIFtLRVkuXzdfQU1QRVJTQU5ELCAgICAgICAgIEtFWV9UQUcuXzdfQU1QRVJTQU5EXSxcbiAgW0tFWS5fOF9BU1RFUklTSywgICAgICAgICAgS0VZX1RBRy5fOF9BU1RFUklTS10sXG4gIFtLRVkuXzlfTFBBUkVOVEhFU0lTLCAgICAgIEtFWV9UQUcuXzlfTFBBUkVOVEhFU0lTXSxcbiAgW0tFWS5fMF9SUEFSRU5USEVTSVMsICAgICAgS0VZX1RBRy5fMF9SUEFSRU5USEVTSVNdLFxuICBbS0VZLk1JTlVTX1VOREVSU0NPUkUsICAgICBLRVlfVEFHLk1JTlVTX1VOREVSU0NPUkVdLFxuICBbS0VZLkVRVUFMX1BMVVMsICAgICAgICAgICBLRVlfVEFHLkVRVUFMX1BMVVNdLFxuICBbS0VZLkJBQ0tTUEFDRSwgICAgICAgICAgICBLRVlfVEFHLkJBQ0tTUEFDRV0sXG4gIFtLRVkuVEFCLCAgICAgICAgICAgICAgICAgIEtFWV9UQUcuVEFCXSxcbiAgW0tFWS5RLCAgICAgICAgICAgICAgICAgICAgS0VZX1RBRy5RXSxcbiAgW0tFWS5XLCAgICAgICAgICAgICAgICAgICAgS0VZX1RBRy5XXSxcbiAgW0tFWS5FLCAgICAgICAgICAgICAgICAgICAgS0VZX1RBRy5FXSxcbiAgW0tFWS5SLCAgICAgICAgICAgICAgICAgICAgS0VZX1RBRy5SXSxcbiAgW0tFWS5ULCAgICAgICAgICAgICAgICAgICAgS0VZX1RBRy5UXSxcbiAgW0tFWS5ZLCAgICAgICAgICAgICAgICAgICAgS0VZX1RBRy5ZXSxcbiAgW0tFWS5VLCAgICAgICAgICAgICAgICAgICAgS0VZX1RBRy5VXSxcbiAgW0tFWS5JLCAgICAgICAgICAgICAgICAgICAgS0VZX1RBRy5JXSxcbiAgW0tFWS5PLCAgICAgICAgICAgICAgICAgICAgS0VZX1RBRy5PXSxcbiAgW0tFWS5QLCAgICAgICAgICAgICAgICAgICAgS0VZX1RBRy5QXSxcbiAgW0tFWS5MQlJBQ0tFVF9DVVJMWSwgICAgICAgS0VZX1RBRy5MQlJBQ0tFVF9DVVJMWV0sXG4gIFtLRVkuUkJSQUNLRVRfQ1VSTFksICAgICAgIEtFWV9UQUcuUkJSQUNLRVRfQ1VSTFldLFxuICBbS0VZLkJBQ0tTTEFTSF9QSVBFLCAgICAgICBLRVlfVEFHLkJBQ0tTTEFTSF9QSVBFXSxcbiAgW0tFWS5DQVBTTE9DSywgICAgICAgICAgICAgS0VZX1RBRy5DQVBTTE9DS10sXG4gIFtLRVkuQSwgICAgICAgICAgICAgICAgICAgIEtFWV9UQUcuQV0sXG4gIFtLRVkuUywgICAgICAgICAgICAgICAgICAgIEtFWV9UQUcuU10sXG4gIFtLRVkuRCwgICAgICAgICAgICAgICAgICAgIEtFWV9UQUcuRF0sXG4gIFtLRVkuRiwgICAgICAgICAgICAgICAgICAgIEtFWV9UQUcuRl0sXG4gIFtLRVkuRywgICAgICAgICAgICAgICAgICAgIEtFWV9UQUcuR10sXG4gIFtLRVkuSCwgICAgICAgICAgICAgICAgICAgIEtFWV9UQUcuSF0sXG4gIFtLRVkuSiwgICAgICAgICAgICAgICAgICAgIEtFWV9UQUcuSl0sXG4gIFtLRVkuSywgICAgICAgICAgICAgICAgICAgIEtFWV9UQUcuS10sXG4gIFtLRVkuTCwgICAgICAgICAgICAgICAgICAgIEtFWV9UQUcuTF0sXG4gIFtLRVkuU0VNSUNPTE9OX0NPTE9OLCAgICAgIEtFWV9UQUcuU0VNSUNPTE9OX0NPTE9OXSxcbiAgW0tFWS5RVU9URV9ET1VCTEVRVU9URSwgICAgS0VZX1RBRy5RVU9URV9ET1VCTEVRVU9URV0sXG4gIFtLRVkuTk9OVVNfTlVNQkVSX1RJTERFLCAgIEtFWV9UQUcuTk9OVVNfTlVNQkVSX1RJTERFXSxcbiAgW0tFWS5SRVRVUk4sICAgICAgICAgICAgICAgS0VZX1RBRy5SRVRVUk5dLFxuICBbS0VZLkxTSElGVCwgICAgICAgICAgICAgICBLRVlfVEFHLkxTSElGVF0sXG4gIFtLRVkuTk9OVVNfQkFDS1NMQVNIX1BJUEUsIEtFWV9UQUcuTk9OVVNfQkFDS1NMQVNIX1BJUEVdLFxuICBbS0VZLlosICAgICAgICAgICAgICAgICAgICBLRVlfVEFHLlpdLFxuICBbS0VZLlgsICAgICAgICAgICAgICAgICAgICBLRVlfVEFHLlhdLFxuICBbS0VZLkMsICAgICAgICAgICAgICAgICAgICBLRVlfVEFHLkNdLFxuICBbS0VZLlYsICAgICAgICAgICAgICAgICAgICBLRVlfVEFHLlZdLFxuICBbS0VZLkIsICAgICAgICAgICAgICAgICAgICBLRVlfVEFHLkJdLFxuICBbS0VZLk4sICAgICAgICAgICAgICAgICAgICBLRVlfVEFHLk5dLFxuICBbS0VZLk0sICAgICAgICAgICAgICAgICAgICBLRVlfVEFHLk1dLFxuICBbS0VZLkNPTU1BX0xFU1MsICAgICAgICAgICBLRVlfVEFHLkNPTU1BX0xFU1NdLFxuICBbS0VZLlBFUklPRF9HUkVBVEVSLCAgICAgICBLRVlfVEFHLlBFUklPRF9HUkVBVEVSXSxcbiAgW0tFWS5TTEFTSF9RVUVTVElPTiwgICAgICAgS0VZX1RBRy5TTEFTSF9RVUVTVElPTl0sXG4gIFtLRVkuUlNISUZULCAgICAgICAgICAgICAgIEtFWV9UQUcuUlNISUZUXSxcbiAgW0tFWS5MQ09OVFJPTCwgICAgICAgICAgICAgS0VZX1RBRy5MQ09OVFJPTF0sXG4gIFtLRVkuTE1FVEEsICAgICAgICAgICAgICAgIEtFWV9UQUcuTE1FVEFdLFxuICBbS0VZLkxBTFQsICAgICAgICAgICAgICAgICBLRVlfVEFHLkxBTFRdLFxuICBbS0VZLlNQQUNFQkFSLCAgICAgICAgICAgICBLRVlfVEFHLlNQQUNFQkFSXSxcbiAgW0tFWS5SQUxULCAgICAgICAgICAgICAgICAgS0VZX1RBRy5SQUxUXSxcbiAgW0tFWS5STUVUQSwgICAgICAgICAgICAgICAgS0VZX1RBRy5STUVUQV0sXG4gIFtLRVkuTUVOVSwgICAgICAgICAgICAgICAgIEtFWV9UQUcuTUVOVV0sXG4gIFtLRVkuUkNPTlRST0wsICAgICAgICAgICAgIEtFWV9UQUcuUkNPTlRST0xdLFxuICBbS0VZLklOU0VSVCwgICAgICAgICAgICAgICBLRVlfVEFHLklOU0VSVF0sXG4gIFtLRVkuSE9NRSwgICAgICAgICAgICAgICAgIEtFWV9UQUcuSE9NRV0sXG4gIFtLRVkuUEFHRVVQLCAgICAgICAgICAgICAgIEtFWV9UQUcuUEFHRVVQXSxcbiAgW0tFWS5ERUxFVEVGT1JXQVJELCAgICAgICAgS0VZX1RBRy5ERUxFVEVGT1JXQVJEXSxcbiAgW0tFWS5FTkQsICAgICAgICAgICAgICAgICAgS0VZX1RBRy5FTkRdLFxuICBbS0VZLlBBR0VET1dOLCAgICAgICAgICAgICBLRVlfVEFHLlBBR0VET1dOXSxcbiAgW0tFWS5VUEFSUk9XLCAgICAgICAgICAgICAgS0VZX1RBRy5VUEFSUk9XXSxcbiAgW0tFWS5MRUZUQVJST1csICAgICAgICAgICAgS0VZX1RBRy5MRUZUQVJST1ddLFxuICBbS0VZLkRPV05BUlJPVywgICAgICAgICAgICBLRVlfVEFHLkRPV05BUlJPV10sXG4gIFtLRVkuUklHSFRBUlJPVywgICAgICAgICAgIEtFWV9UQUcuUklHSFRBUlJPV10sXG4gIFtLRVkuUEFEX05VTUxPQ0tfQ0xFQVIsICAgIEtFWV9UQUcuUEFEX05VTUxPQ0tfQ0xFQVJdLFxuICBbS0VZLlBBRF9FUVVBTFMsICAgICAgICAgICBLRVlfVEFHLlBBRF9FUVVBTFNdLFxuICBbS0VZLlBBRF9ESVZJREUsICAgICAgICAgICBLRVlfVEFHLlBBRF9ESVZJREVdLFxuICBbS0VZLlBBRF9NVUxUSVBMWSwgICAgICAgICBLRVlfVEFHLlBBRF9NVUxUSVBMWV0sXG4gIFtLRVkuUEFEX01JTlVTLCAgICAgICAgICAgIEtFWV9UQUcuUEFEX01JTlVTXSxcbiAgW0tFWS5QQURfN19IT01FLCAgICAgICAgICAgS0VZX1RBRy5QQURfN19IT01FXSxcbiAgW0tFWS5QQURfOF9VUEFSUk9XLCAgICAgICAgS0VZX1RBRy5QQURfOF9VUEFSUk9XXSxcbiAgW0tFWS5QQURfOV9QQUdFVVAsICAgICAgICAgS0VZX1RBRy5QQURfOV9QQUdFVVBdLFxuICBbS0VZLlBBRF9QTFVTLCAgICAgICAgICAgICBLRVlfVEFHLlBBRF9QTFVTXSxcbiAgW0tFWS5QQURfNF9MRUZUQVJST1csICAgICAgS0VZX1RBRy5QQURfNF9MRUZUQVJST1ddLFxuICBbS0VZLlBBRF81LCAgICAgICAgICAgICAgICBLRVlfVEFHLlBBRF81XSxcbiAgW0tFWS5QQURfNl9SSUdIVEFSUk9XLCAgICAgS0VZX1RBRy5QQURfNl9SSUdIVEFSUk9XXSxcbiAgW0tFWS5QQURfQ09NTUEsICAgICAgICAgICAgS0VZX1RBRy5QQURfQ09NTUFdLFxuICBbS0VZLlBBRF8xX0VORCwgICAgICAgICAgICBLRVlfVEFHLlBBRF8xX0VORF0sXG4gIFtLRVkuUEFEXzJfRE9XTkFSUk9XLCAgICAgIEtFWV9UQUcuUEFEXzJfRE9XTkFSUk9XXSxcbiAgW0tFWS5QQURfM19QQUdFRE9XTiwgICAgICAgS0VZX1RBRy5QQURfM19QQUdFRE9XTl0sXG4gIFtLRVkuUEFEXzBfSU5TRVJULCAgICAgICAgIEtFWV9UQUcuUEFEXzBfSU5TRVJUXSxcbiAgW0tFWS5QQURfREVDSU1BTF9ERUxFVEUsICAgS0VZX1RBRy5QQURfREVDSU1BTF9ERUxFVEVdLFxuICBbS0VZLlBBRF9FTlRFUiwgICAgICAgICAgICBLRVlfVEFHLlBBRF9FTlRFUl0sXG4gIFtLRVkuRjEzLCAgICAgICAgICAgICAgICAgIEtFWV9UQUcuRjEzXSxcbiAgW0tFWS5GMTQsICAgICAgICAgICAgICAgICAgS0VZX1RBRy5GMTRdLFxuICBbS0VZLkYxNSwgICAgICAgICAgICAgICAgICBLRVlfVEFHLkYxNV0sXG4gIFtLRVkuRjE2LCAgICAgICAgICAgICAgICAgIEtFWV9UQUcuRjE2XSxcbiAgW0tFWS5GMTcsICAgICAgICAgICAgICAgICAgS0VZX1RBRy5GMTddLFxuICBbS0VZLkYxOCwgICAgICAgICAgICAgICAgICBLRVlfVEFHLkYxOF0sXG4gIFtLRVkuRjE5LCAgICAgICAgICAgICAgICAgIEtFWV9UQUcuRjE5XSxcbiAgW0tFWS5GMjAsICAgICAgICAgICAgICAgICAgS0VZX1RBRy5GMjBdLFxuICBbS0VZLkYyMSwgICAgICAgICAgICAgICAgICBLRVlfVEFHLkYyMV0sXG4gIFtLRVkuRjIyLCAgICAgICAgICAgICAgICAgIEtFWV9UQUcuRjIyXSxcbiAgW0tFWS5GMjMsICAgICAgICAgICAgICAgICAgS0VZX1RBRy5GMjNdLFxuICBbS0VZLkYyNCwgICAgICAgICAgICAgICAgICBLRVlfVEFHLkYyNF0sXG4gIFtLRVkuSU5URVJOQVRJT05BTDEsICAgICAgIEtFWV9UQUcuSU5URVJOQVRJT05BTDFdLFxuICBbS0VZLklOVEVSTkFUSU9OQUwyLCAgICAgICBLRVlfVEFHLklOVEVSTkFUSU9OQUwyXSxcbiAgW0tFWS5JTlRFUk5BVElPTkFMMywgICAgICAgS0VZX1RBRy5JTlRFUk5BVElPTkFMM10sXG4gIFtLRVkuSU5URVJOQVRJT05BTDQsICAgICAgIEtFWV9UQUcuSU5URVJOQVRJT05BTDRdLFxuICBbS0VZLklOVEVSTkFUSU9OQUw1LCAgICAgICBLRVlfVEFHLklOVEVSTkFUSU9OQUw1XSxcbiAgW0tFWS5JTlRFUk5BVElPTkFMNiwgICAgICAgS0VZX1RBRy5JTlRFUk5BVElPTkFMNl0sXG4gIFtLRVkuSU5URVJOQVRJT05BTDcsICAgICAgIEtFWV9UQUcuSU5URVJOQVRJT05BTDddLFxuICBbS0VZLklOVEVSTkFUSU9OQUw4LCAgICAgICBLRVlfVEFHLklOVEVSTkFUSU9OQUw4XSxcbiAgW0tFWS5JTlRFUk5BVElPTkFMOSwgICAgICAgS0VZX1RBRy5JTlRFUk5BVElPTkFMOV0sXG4gIFtLRVkuTEFORzEsICAgICAgICAgICAgICAgIEtFWV9UQUcuTEFORzFdLFxuICBbS0VZLkxBTkcyLCAgICAgICAgICAgICAgICBLRVlfVEFHLkxBTkcyXSxcbiAgW0tFWS5MQU5HMywgICAgICAgICAgICAgICAgS0VZX1RBRy5MQU5HM10sXG4gIFtLRVkuTEFORzQsICAgICAgICAgICAgICAgIEtFWV9UQUcuTEFORzRdLFxuICBbS0VZLkxBTkc1LCAgICAgICAgICAgICAgICBLRVlfVEFHLkxBTkc1XSxcbiAgW0tFWS5IRUxQLCAgICAgICAgICAgICAgICAgS0VZX1RBRy5IRUxQXSxcbiAgW0tFWS5NVVRFLCAgICAgICAgICAgICAgICAgS0VZX1RBRy5NVVRFXSxcbiAgW0tFWS5WT0xVTUVVUCwgICAgICAgICAgICAgS0VZX1RBRy5WT0xVTUVVUF0sXG4gIFtLRVkuVk9MVU1FRE9XTiwgICAgICAgICAgIEtFWV9UQUcuVk9MVU1FRE9XTl0sXG5dKTtcblxuZnVuY3Rpb24gVmFsX2tleV9jb2RlKGtleWNvZGUpIHtcbiAgcmV0dXJuIGtjX3RvX3RhZy5nZXQoa2V5Y29kZSk7XG59XG5cbi8vUHJvdmlkZXM6IEtleV9jb2RlX3ZhbFxuLy9SZXF1aXJlczogS0VZLEtFWV9UQUdcblxudmFyIHRhZ190b19rYyA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5NYXAoW1xuICBbS0VZX1RBRy5FU0NBUEUsICAgICAgICAgICAgICAgS0VZLkVTQ0FQRV0sXG4gIFtLRVlfVEFHLkYxLCAgICAgICAgICAgICAgICAgICBLRVkuRjFdLFxuICBbS0VZX1RBRy5GMiwgICAgICAgICAgICAgICAgICAgS0VZLkYyXSxcbiAgW0tFWV9UQUcuRjMsICAgICAgICAgICAgICAgICAgIEtFWS5GM10sXG4gIFtLRVlfVEFHLkY0LCAgICAgICAgICAgICAgICAgICBLRVkuRjRdLFxuICBbS0VZX1RBRy5GNSwgICAgICAgICAgICAgICAgICAgS0VZLkY1XSxcbiAgW0tFWV9UQUcuRjYsICAgICAgICAgICAgICAgICAgIEtFWS5GNl0sXG4gIFtLRVlfVEFHLkY3LCAgICAgICAgICAgICAgICAgICBLRVkuRjddLFxuICBbS0VZX1RBRy5GOCwgICAgICAgICAgICAgICAgICAgS0VZLkY4XSxcbiAgW0tFWV9UQUcuRjksICAgICAgICAgICAgICAgICAgIEtFWS5GOV0sXG4gIFtLRVlfVEFHLkYxMCwgICAgICAgICAgICAgICAgICBLRVkuRjEwXSxcbiAgW0tFWV9UQUcuRjExLCAgICAgICAgICAgICAgICAgIEtFWS5GMTFdLFxuICBbS0VZX1RBRy5GMTIsICAgICAgICAgICAgICAgICAgS0VZLkYxMl0sXG4gIFtLRVlfVEFHLlBSSU5UU0NSRUVOLCAgICAgICAgICBLRVkuUFJJTlRTQ1JFRU5dLFxuICBbS0VZX1RBRy5TQ1JPTExMT0NLLCAgICAgICAgICAgS0VZLlNDUk9MTExPQ0tdLFxuICBbS0VZX1RBRy5QQVVTRSwgICAgICAgICAgICAgICAgS0VZLlBBVVNFXSxcbiAgW0tFWV9UQUcuR1JBVkVfVElMREUsICAgICAgICAgIEtFWS5HUkFWRV9USUxERV0sXG4gIFtLRVlfVEFHLl8xX0VYQ0xBTUFUSU9OLCAgICAgICBLRVkuXzFfRVhDTEFNQVRJT05dLFxuICBbS0VZX1RBRy5fMl9BVCwgICAgICAgICAgICAgICAgS0VZLl8yX0FUXSxcbiAgW0tFWV9UQUcuXzNfTlVNQkVSLCAgICAgICAgICAgIEtFWS5fM19OVU1CRVJdLFxuICBbS0VZX1RBRy5fNF9ET0xMQVIsICAgICAgICAgICAgS0VZLl80X0RPTExBUl0sXG4gIFtLRVlfVEFHLl81X1BFUkNFTlQsICAgICAgICAgICBLRVkuXzVfUEVSQ0VOVF0sXG4gIFtLRVlfVEFHLl82X0NBUkVULCAgICAgICAgICAgICBLRVkuXzZfQ0FSRVRdLFxuICBbS0VZX1RBRy5fN19BTVBFUlNBTkQsICAgICAgICAgS0VZLl83X0FNUEVSU0FORF0sXG4gIFtLRVlfVEFHLl84X0FTVEVSSVNLLCAgICAgICAgICBLRVkuXzhfQVNURVJJU0tdLFxuICBbS0VZX1RBRy5fOV9MUEFSRU5USEVTSVMsICAgICAgS0VZLl85X0xQQVJFTlRIRVNJU10sXG4gIFtLRVlfVEFHLl8wX1JQQVJFTlRIRVNJUywgICAgICBLRVkuXzBfUlBBUkVOVEhFU0lTXSxcbiAgW0tFWV9UQUcuTUlOVVNfVU5ERVJTQ09SRSwgICAgIEtFWS5NSU5VU19VTkRFUlNDT1JFXSxcbiAgW0tFWV9UQUcuRVFVQUxfUExVUywgICAgICAgICAgIEtFWS5FUVVBTF9QTFVTXSxcbiAgW0tFWV9UQUcuQkFDS1NQQUNFLCAgICAgICAgICAgIEtFWS5CQUNLU1BBQ0VdLFxuICBbS0VZX1RBRy5UQUIsICAgICAgICAgICAgICAgICAgS0VZLlRBQl0sXG4gIFtLRVlfVEFHLlEsICAgICAgICAgICAgICAgICAgICBLRVkuUV0sXG4gIFtLRVlfVEFHLlcsICAgICAgICAgICAgICAgICAgICBLRVkuV10sXG4gIFtLRVlfVEFHLkUsICAgICAgICAgICAgICAgICAgICBLRVkuRV0sXG4gIFtLRVlfVEFHLlIsICAgICAgICAgICAgICAgICAgICBLRVkuUl0sXG4gIFtLRVlfVEFHLlQsICAgICAgICAgICAgICAgICAgICBLRVkuVF0sXG4gIFtLRVlfVEFHLlksICAgICAgICAgICAgICAgICAgICBLRVkuWV0sXG4gIFtLRVlfVEFHLlUsICAgICAgICAgICAgICAgICAgICBLRVkuVV0sXG4gIFtLRVlfVEFHLkksICAgICAgICAgICAgICAgICAgICBLRVkuSV0sXG4gIFtLRVlfVEFHLk8sICAgICAgICAgICAgICAgICAgICBLRVkuT10sXG4gIFtLRVlfVEFHLlAsICAgICAgICAgICAgICAgICAgICBLRVkuUF0sXG4gIFtLRVlfVEFHLkxCUkFDS0VUX0NVUkxZLCAgICAgICBLRVkuTEJSQUNLRVRfQ1VSTFldLFxuICBbS0VZX1RBRy5SQlJBQ0tFVF9DVVJMWSwgICAgICAgS0VZLlJCUkFDS0VUX0NVUkxZXSxcbiAgW0tFWV9UQUcuQkFDS1NMQVNIX1BJUEUsICAgICAgIEtFWS5CQUNLU0xBU0hfUElQRV0sXG4gIFtLRVlfVEFHLkNBUFNMT0NLLCAgICAgICAgICAgICBLRVkuQ0FQU0xPQ0tdLFxuICBbS0VZX1RBRy5BLCAgICAgICAgICAgICAgICAgICAgS0VZLkFdLFxuICBbS0VZX1RBRy5TLCAgICAgICAgICAgICAgICAgICAgS0VZLlNdLFxuICBbS0VZX1RBRy5ELCAgICAgICAgICAgICAgICAgICAgS0VZLkRdLFxuICBbS0VZX1RBRy5GLCAgICAgICAgICAgICAgICAgICAgS0VZLkZdLFxuICBbS0VZX1RBRy5HLCAgICAgICAgICAgICAgICAgICAgS0VZLkddLFxuICBbS0VZX1RBRy5ILCAgICAgICAgICAgICAgICAgICAgS0VZLkhdLFxuICBbS0VZX1RBRy5KLCAgICAgICAgICAgICAgICAgICAgS0VZLkpdLFxuICBbS0VZX1RBRy5LLCAgICAgICAgICAgICAgICAgICAgS0VZLktdLFxuICBbS0VZX1RBRy5MLCAgICAgICAgICAgICAgICAgICAgS0VZLkxdLFxuICBbS0VZX1RBRy5TRU1JQ09MT05fQ09MT04sICAgICAgS0VZLlNFTUlDT0xPTl9DT0xPTl0sXG4gIFtLRVlfVEFHLlFVT1RFX0RPVUJMRVFVT1RFLCAgICBLRVkuUVVPVEVfRE9VQkxFUVVPVEVdLFxuICBbS0VZX1RBRy5OT05VU19OVU1CRVJfVElMREUsICAgS0VZLk5PTlVTX05VTUJFUl9USUxERV0sXG4gIFtLRVlfVEFHLlJFVFVSTiwgICAgICAgICAgICAgICBLRVkuUkVUVVJOXSxcbiAgW0tFWV9UQUcuTFNISUZULCAgICAgICAgICAgICAgIEtFWS5MU0hJRlRdLFxuICBbS0VZX1RBRy5OT05VU19CQUNLU0xBU0hfUElQRSwgS0VZLk5PTlVTX0JBQ0tTTEFTSF9QSVBFXSxcbiAgW0tFWV9UQUcuWiwgICAgICAgICAgICAgICAgICAgIEtFWS5aXSxcbiAgW0tFWV9UQUcuWCwgICAgICAgICAgICAgICAgICAgIEtFWS5YXSxcbiAgW0tFWV9UQUcuQywgICAgICAgICAgICAgICAgICAgIEtFWS5DXSxcbiAgW0tFWV9UQUcuViwgICAgICAgICAgICAgICAgICAgIEtFWS5WXSxcbiAgW0tFWV9UQUcuQiwgICAgICAgICAgICAgICAgICAgIEtFWS5CXSxcbiAgW0tFWV9UQUcuTiwgICAgICAgICAgICAgICAgICAgIEtFWS5OXSxcbiAgW0tFWV9UQUcuTSwgICAgICAgICAgICAgICAgICAgIEtFWS5NXSxcbiAgW0tFWV9UQUcuQ09NTUFfTEVTUywgICAgICAgICAgIEtFWS5DT01NQV9MRVNTXSxcbiAgW0tFWV9UQUcuUEVSSU9EX0dSRUFURVIsICAgICAgIEtFWS5QRVJJT0RfR1JFQVRFUl0sXG4gIFtLRVlfVEFHLlNMQVNIX1FVRVNUSU9OLCAgICAgICBLRVkuU0xBU0hfUVVFU1RJT05dLFxuICBbS0VZX1RBRy5SU0hJRlQsICAgICAgICAgICAgICAgS0VZLlJTSElGVF0sXG4gIFtLRVlfVEFHLkxDT05UUk9MLCAgICAgICAgICAgICBLRVkuTENPTlRST0xdLFxuICBbS0VZX1RBRy5MTUVUQSwgICAgICAgICAgICAgICAgS0VZLkxNRVRBXSxcbiAgW0tFWV9UQUcuTEFMVCwgICAgICAgICAgICAgICAgIEtFWS5MQUxUXSxcbiAgW0tFWV9UQUcuU1BBQ0VCQVIsICAgICAgICAgICAgIEtFWS5TUEFDRUJBUl0sXG4gIFtLRVlfVEFHLlJBTFQsICAgICAgICAgICAgICAgICBLRVkuUkFMVF0sXG4gIFtLRVlfVEFHLlJNRVRBLCAgICAgICAgICAgICAgICBLRVkuUk1FVEFdLFxuICBbS0VZX1RBRy5NRU5VLCAgICAgICAgICAgICAgICAgS0VZLk1FTlVdLFxuICBbS0VZX1RBRy5SQ09OVFJPTCwgICAgICAgICAgICAgS0VZLlJDT05UUk9MXSxcbiAgW0tFWV9UQUcuSU5TRVJULCAgICAgICAgICAgICAgIEtFWS5JTlNFUlRdLFxuICBbS0VZX1RBRy5IT01FLCAgICAgICAgICAgICAgICAgS0VZLkhPTUVdLFxuICBbS0VZX1RBRy5QQUdFVVAsICAgICAgICAgICAgICAgS0VZLlBBR0VVUF0sXG4gIFtLRVlfVEFHLkRFTEVURUZPUldBUkQsICAgICAgICBLRVkuREVMRVRFRk9SV0FSRF0sXG4gIFtLRVlfVEFHLkVORCwgICAgICAgICAgICAgICAgICBLRVkuRU5EXSxcbiAgW0tFWV9UQUcuUEFHRURPV04sICAgICAgICAgICAgIEtFWS5QQUdFRE9XTl0sXG4gIFtLRVlfVEFHLlVQQVJST1csICAgICAgICAgICAgICBLRVkuVVBBUlJPV10sXG4gIFtLRVlfVEFHLkxFRlRBUlJPVywgICAgICAgICAgICBLRVkuTEVGVEFSUk9XXSxcbiAgW0tFWV9UQUcuRE9XTkFSUk9XLCAgICAgICAgICAgIEtFWS5ET1dOQVJST1ddLFxuICBbS0VZX1RBRy5SSUdIVEFSUk9XLCAgICAgICAgICAgS0VZLlJJR0hUQVJST1ddLFxuICBbS0VZX1RBRy5QQURfTlVNTE9DS19DTEVBUiwgICAgS0VZLlBBRF9OVU1MT0NLX0NMRUFSXSxcbiAgW0tFWV9UQUcuUEFEX0VRVUFMUywgICAgICAgICAgIEtFWS5QQURfRVFVQUxTXSxcbiAgW0tFWV9UQUcuUEFEX0RJVklERSwgICAgICAgICAgIEtFWS5QQURfRElWSURFXSxcbiAgW0tFWV9UQUcuUEFEX01VTFRJUExZLCAgICAgICAgIEtFWS5QQURfTVVMVElQTFldLFxuICBbS0VZX1RBRy5QQURfTUlOVVMsICAgICAgICAgICAgS0VZLlBBRF9NSU5VU10sXG4gIFtLRVlfVEFHLlBBRF83X0hPTUUsICAgICAgICAgICBLRVkuUEFEXzdfSE9NRV0sXG4gIFtLRVlfVEFHLlBBRF84X1VQQVJST1csICAgICAgICBLRVkuUEFEXzhfVVBBUlJPV10sXG4gIFtLRVlfVEFHLlBBRF85X1BBR0VVUCwgICAgICAgICBLRVkuUEFEXzlfUEFHRVVQXSxcbiAgW0tFWV9UQUcuUEFEX1BMVVMsICAgICAgICAgICAgIEtFWS5QQURfUExVU10sXG4gIFtLRVlfVEFHLlBBRF80X0xFRlRBUlJPVywgICAgICBLRVkuUEFEXzRfTEVGVEFSUk9XXSxcbiAgW0tFWV9UQUcuUEFEXzUsICAgICAgICAgICAgICAgIEtFWS5QQURfNV0sXG4gIFtLRVlfVEFHLlBBRF82X1JJR0hUQVJST1csICAgICBLRVkuUEFEXzZfUklHSFRBUlJPV10sXG4gIFtLRVlfVEFHLlBBRF9DT01NQSwgICAgICAgICAgICBLRVkuUEFEX0NPTU1BXSxcbiAgW0tFWV9UQUcuUEFEXzFfRU5ELCAgICAgICAgICAgIEtFWS5QQURfMV9FTkRdLFxuICBbS0VZX1RBRy5QQURfMl9ET1dOQVJST1csICAgICAgS0VZLlBBRF8yX0RPV05BUlJPV10sXG4gIFtLRVlfVEFHLlBBRF8zX1BBR0VET1dOLCAgICAgICBLRVkuUEFEXzNfUEFHRURPV05dLFxuICBbS0VZX1RBRy5QQURfMF9JTlNFUlQsICAgICAgICAgS0VZLlBBRF8wX0lOU0VSVF0sXG4gIFtLRVlfVEFHLlBBRF9ERUNJTUFMX0RFTEVURSwgICBLRVkuUEFEX0RFQ0lNQUxfREVMRVRFXSxcbiAgW0tFWV9UQUcuUEFEX0VOVEVSLCAgICAgICAgICAgIEtFWS5QQURfRU5URVJdLFxuICBbS0VZX1RBRy5GMTMsICAgICAgICAgICAgICAgICAgS0VZLkYxM10sXG4gIFtLRVlfVEFHLkYxNCwgICAgICAgICAgICAgICAgICBLRVkuRjE0XSxcbiAgW0tFWV9UQUcuRjE1LCAgICAgICAgICAgICAgICAgIEtFWS5GMTVdLFxuICBbS0VZX1RBRy5GMTYsICAgICAgICAgICAgICAgICAgS0VZLkYxNl0sXG4gIFtLRVlfVEFHLkYxNywgICAgICAgICAgICAgICAgICBLRVkuRjE3XSxcbiAgW0tFWV9UQUcuRjE4LCAgICAgICAgICAgICAgICAgIEtFWS5GMThdLFxuICBbS0VZX1RBRy5GMTksICAgICAgICAgICAgICAgICAgS0VZLkYxOV0sXG4gIFtLRVlfVEFHLkYyMCwgICAgICAgICAgICAgICAgICBLRVkuRjIwXSxcbiAgW0tFWV9UQUcuRjIxLCAgICAgICAgICAgICAgICAgIEtFWS5GMjFdLFxuICBbS0VZX1RBRy5GMjIsICAgICAgICAgICAgICAgICAgS0VZLkYyMl0sXG4gIFtLRVlfVEFHLkYyMywgICAgICAgICAgICAgICAgICBLRVkuRjIzXSxcbiAgW0tFWV9UQUcuRjI0LCAgICAgICAgICAgICAgICAgIEtFWS5GMjRdLFxuICBbS0VZX1RBRy5JTlRFUk5BVElPTkFMMSwgICAgICAgS0VZLklOVEVSTkFUSU9OQUwxXSxcbiAgW0tFWV9UQUcuSU5URVJOQVRJT05BTDIsICAgICAgIEtFWS5JTlRFUk5BVElPTkFMMl0sXG4gIFtLRVlfVEFHLklOVEVSTkFUSU9OQUwzLCAgICAgICBLRVkuSU5URVJOQVRJT05BTDNdLFxuICBbS0VZX1RBRy5JTlRFUk5BVElPTkFMNCwgICAgICAgS0VZLklOVEVSTkFUSU9OQUw0XSxcbiAgW0tFWV9UQUcuSU5URVJOQVRJT05BTDUsICAgICAgIEtFWS5JTlRFUk5BVElPTkFMNV0sXG4gIFtLRVlfVEFHLklOVEVSTkFUSU9OQUw2LCAgICAgICBLRVkuSU5URVJOQVRJT05BTDZdLFxuICBbS0VZX1RBRy5JTlRFUk5BVElPTkFMNywgICAgICAgS0VZLklOVEVSTkFUSU9OQUw3XSxcbiAgW0tFWV9UQUcuSU5URVJOQVRJT05BTDgsICAgICAgIEtFWS5JTlRFUk5BVElPTkFMOF0sXG4gIFtLRVlfVEFHLklOVEVSTkFUSU9OQUw5LCAgICAgICBLRVkuSU5URVJOQVRJT05BTDldLFxuICBbS0VZX1RBRy5MQU5HMSwgICAgICAgICAgICAgICAgS0VZLkxBTkcxXSxcbiAgW0tFWV9UQUcuTEFORzIsICAgICAgICAgICAgICAgIEtFWS5MQU5HMl0sXG4gIFtLRVlfVEFHLkxBTkczLCAgICAgICAgICAgICAgICBLRVkuTEFORzNdLFxuICBbS0VZX1RBRy5MQU5HNCwgICAgICAgICAgICAgICAgS0VZLkxBTkc0XSxcbiAgW0tFWV9UQUcuTEFORzUsICAgICAgICAgICAgICAgIEtFWS5MQU5HNV0sXG4gIFtLRVlfVEFHLkhFTFAsICAgICAgICAgICAgICAgICBLRVkuSEVMUF0sXG4gIFtLRVlfVEFHLk1VVEUsICAgICAgICAgICAgICAgICBLRVkuTVVURV0sXG4gIFtLRVlfVEFHLlZPTFVNRVVQLCAgICAgICAgICAgICBLRVkuVk9MVU1FVVBdLFxuICBbS0VZX1RBRy5WT0xVTUVET1dOLCAgICAgICAgICAgS0VZLlZPTFVNRURPV05dLFxuXSk7XG5cbmZ1bmN0aW9uIEtleV9jb2RlX3ZhbChrZXljb2RlKSB7XG4gIHJldHVybiB0YWdfdG9fa2MuZ2V0KGtleWNvZGUpO1xufVxuXG4vL1Byb3ZpZGVzOiBWYWxfa2V5X3N0YXRlXG4vL1JlcXVpcmVzOiBLRVlfU1RBVEUsS0VZX1NUQVRFX1RBR1xuXG52YXIga2V5X3N0YXRlX3RvX3RhZyA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5NYXAoW1xuICBbS0VZX1NUQVRFLlVQLCAgIEtFWV9TVEFURV9UQUcuVVBdLFxuICBbS0VZX1NUQVRFLkRPV04sIEtFWV9TVEFURV9UQUcuRE9XTl0sXG5dKTtcblxuZnVuY3Rpb24gVmFsX2tleV9zdGF0ZShzdGF0ZSkge1xuICByZXR1cm4ga2V5X3N0YXRlX3RvX3RhZy5nZXQoc3RhdGUpO1xufVxuXG4vL1Byb3ZpZGVzOiBWYWxfYnV0dG9uXG4vL1JlcXVpcmVzOiBCVVRUT04sQlVUVE9OX1RBR1xuXG52YXIgYnV0dG9uX3RvX3RhZyA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5NYXAoW1xuICBbQlVUVE9OLk5PTkUsICAgICAgIEJVVFRPTl9UQUcuTk9ORV0sXG4gIFtCVVRUT04uTEVGVCwgICAgICAgQlVUVE9OX1RBRy5MRUZUXSxcbiAgW0JVVFRPTi5NSURETEUsICAgICBCVVRUT05fVEFHLk1JRERMRV0sXG4gIFtCVVRUT04uTUlERExFLCAgICAgQlVUVE9OX1RBRy5SSUdIVF0sXG4gIFtCVVRUT04uV0hFRUxfVVAsICAgQlVUVE9OX1RBRy5XSEVFTF9VUF0sXG4gIFtCVVRUT04uV0hFRUxfRE9XTiwgQlVUVE9OX1RBRy5XSEVFTF9ET1dOXSxcbl0pO1xuXG5mdW5jdGlvbiBWYWxfYnV0dG9uKGJ1dHRvbikge1xuICByZXR1cm4gYnV0dG9uX3RvX3RhZy5nZXQoYnV0dG9uKTtcbn1cblxuLy9Qcm92aWRlczogVmFsX2J1dHRvbl9zdGF0ZVxuLy9SZXF1aXJlczogQlVUVE9OX1NUQVRFLEJVVFRPTl9TVEFURV9UQUdcblxudmFyIGJ1dHRvbl9zdGF0ZV90b190YWcgPSBuZXcgam9vX2dsb2JhbF9vYmplY3QuTWFwKFtcbiAgW0JVVFRPTl9TVEFURS5VUCwgICBCVVRUT05fU1RBVEVfVEFHLlVQXSxcbiAgW0JVVFRPTl9TVEFURS5ET1dOLCBCVVRUT05fU1RBVEVfVEFHLkRPV05dLFxuXSk7XG5cbmZ1bmN0aW9uIFZhbF9idXR0b25fc3RhdGUoc3RhdGUpIHtcbiAgcmV0dXJuIGJ1dHRvbl9zdGF0ZV90b190YWcuZ2V0KHN0YXRlKTtcbn1cblxuLy9Qcm92aWRlczogVmFsX3JlcGVhdFxuLy9SZXF1aXJlczogUkVQRUFUX1RBR1xuXG52YXIgcmVwZWF0X3RvX3RhZyA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5NYXAoW1xuICBbXCJuby1yZXBlYXRcIiwgUkVQRUFUX1RBRy5OT19SRVBFQVRdLFxuICBbXCJyZXBlYXQteFwiLCAgUkVQRUFUX1RBRy5SRVBFQVRfWF0sXG4gIFtcInJlcGVhdC15XCIsICBSRVBFQVRfVEFHLlJFUEVBVF9ZXSxcbiAgW1wicmVwZWF0XCIsICAgIFJFUEVBVF9UQUcuUkVQRUFUX1hZXSxcbl0pO1xuXG5mdW5jdGlvbiBWYWxfcmVwZWF0KHJlcGVhdCkge1xuICByZXR1cm4gcmVwZWF0X3RvX3RhZy5nZXQocmVwZWF0KTtcbn1cblxuLy9Qcm92aWRlczogUmVwZWF0X3ZhbFxuLy9SZXF1aXJlczogUkVQRUFUX1RBR1xuXG52YXIgdGFnX3RvX3JlcGVhdCA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5NYXAoW1xuICBbUkVQRUFUX1RBRy5OT19SRVBFQVQsIFwibm8tcmVwZWF0XCJdLFxuICBbUkVQRUFUX1RBRy5SRVBFQVRfWCwgIFwicmVwZWF0LXhcIl0sXG4gIFtSRVBFQVRfVEFHLlJFUEVBVF9ZLCAgXCJyZXBlYXQteVwiXSxcbiAgW1JFUEVBVF9UQUcuUkVQRUFUX1hZLCBcInJlcGVhdFwiXSxcbl0pO1xuXG5mdW5jdGlvbiBSZXBlYXRfdmFsKHJlcGVhdCkge1xuICByZXR1cm4gdGFnX3RvX3JlcGVhdC5nZXQocmVwZWF0KTtcbn1cblxuLy9Qcm92aWRlczogVmFsX2RyYXdfc3R5bGVcbi8vUmVxdWlyZXM6IF9jb2xvcl9vZl9pbnQsU1RZTEVfVEFHXG5mdW5jdGlvbiBWYWxfZHJhd19zdHlsZShzdHlsZSkge1xuICB2YXIgcyA9IDA7XG4gIHN3aXRjaCAoc3R5bGVbMF0pIHtcbiAgICBjYXNlIFNUWUxFX1RBRy5DT0xPUjpcbiAgICAgIHMgPSBfY29sb3Jfb2ZfaW50KHN0eWxlWzFdKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgU1RZTEVfVEFHLkdSQURJRU5UOlxuICAgIGNhc2UgU1RZTEVfVEFHLlBBVFRFUk46XG4gICAgICBzID0gc3R5bGVbMV07XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIHM7XG59XG5cbi8vUHJvdmlkZXM6IERyYXdfc3R5bGVfdmFsXG4vL1JlcXVpcmVzOiBTVFlMRV9UQUdcbmZ1bmN0aW9uIERyYXdfc3R5bGVfdmFsKHN0eWxlKSB7XG4gIHZhciBzID0gW107XG4gIHNbMV0gPSBzdHlsZTtcbiAgc3dpdGNoICh0eXBlb2Yoc3R5bGUpKSB7XG4gICAgY2FzZSBcInN0cmluZ1wiIDpcbiAgICAgIHNbMF0gPSBTVFlMRV9UQUcuQ09MT1I7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiQ2FudmFzR3JhZGllbnRcIiA6XG4gICAgICBzWzBdID0gU1RZTEVfVEFHLkdSQURJRU5UO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIkNhbnZhc1BhdHRlcm5cIiA6XG4gICAgICBzWzBdID0gU1RZTEVfVEFHLlBBVFRFUk47XG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4gcztcbn1cblxuLy9Qcm92aWRlczogU2xhbnRfdmFsXG4vL1JlcXVpcmVzOiBTTEFOVCxTTEFOVF9UQUdcblxudmFyIHRhZ190b19zbGFudCA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5NYXAoW1xuICBbU0xBTlRfVEFHLlJPTUFOLCAgIFNMQU5ULlJPTUFOXSxcbiAgW1NMQU5UX1RBRy5JVEFMSUMsICBTTEFOVC5JVEFMSUNdLFxuICBbU0xBTlRfVEFHLk9CTElRVUUsIFNMQU5ULk9CTElRVUVdLFxuXSk7XG5cbmZ1bmN0aW9uIFNsYW50X3ZhbChzbGFudCkge1xuICByZXR1cm4gdGFnX3RvX3NsYW50LmdldChzbGFudCk7XG59XG5cbi8vUHJvdmlkZXM6IFZhbF9qb2luX3R5cGVcbi8vUmVxdWlyZXM6IEpPSU5fVFlQRV9UQUdcblxudmFyIGpvaW5fdHlwZV90b190YWcgPSBuZXcgam9vX2dsb2JhbF9vYmplY3QuTWFwKFtcbiAgW1wicm91bmRcIiwgSk9JTl9UWVBFX1RBRy5ST1VORF0sXG4gIFtcIm1pdGVyXCIsIEpPSU5fVFlQRV9UQUcuTUlURVJdLFxuICBbXCJiZXZlbFwiLCBKT0lOX1RZUEVfVEFHLkJFVkVMXSxcbl0pO1xuXG5mdW5jdGlvbiBWYWxfam9pbl90eXBlKGpvaW4pIHtcbiAgcmV0dXJuIGpvaW5fdHlwZV90b190YWcuZ2V0KGpvaW4pO1xufVxuXG4vL1Byb3ZpZGVzOiBKb2luX3R5cGVfdmFsXG4vL1JlcXVpcmVzOiBKT0lOX1RZUEVfVEFHXG5cbnZhciB0YWdfdG9fam9pbl90eXBlID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0Lk1hcChbXG4gIFtKT0lOX1RZUEVfVEFHLlJPVU5ELCBcInJvdW5kXCJdLFxuICBbSk9JTl9UWVBFX1RBRy5NSVRFUiwgXCJtaXRlclwiXSxcbiAgW0pPSU5fVFlQRV9UQUcuQkVWRUwsIFwiYmV2ZWxcIl0sXG5dKTtcblxuZnVuY3Rpb24gSm9pbl90eXBlX3ZhbChqb2luKSB7XG4gIHJldHVybiB0YWdfdG9fam9pbl90eXBlLmdldChqb2luKTtcbn1cblxuLy9Qcm92aWRlczogVmFsX2NhcF90eXBlXG4vL1JlcXVpcmVzOiBDQVBfVFlQRV9UQUdcblxudmFyIGNhcF90eXBlX3RvX3RhZyA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5NYXAoW1xuICBbXCJidXR0XCIsICAgQ0FQX1RZUEVfVEFHLkJVVFRdLFxuICBbXCJzcXVhcmVcIiwgQ0FQX1RZUEVfVEFHLlNRVUFSRV0sXG4gIFtcInJvdW5kXCIsICBDQVBfVFlQRV9UQUcuUk9VTkRdLFxuXSk7XG5cbmZ1bmN0aW9uIFZhbF9jYXBfdHlwZShjYXApIHtcbiAgcmV0dXJuIGNhcF90eXBlX3RvX3RhZy5nZXQoY2FwKTtcbn1cblxuLy9Qcm92aWRlczogQ2FwX3R5cGVfdmFsXG4vL1JlcXVpcmVzOiBDQVBfVFlQRV9UQUdcblxudmFyIHRhZ190b19jYXBfdHlwZSA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5NYXAoW1xuICBbQ0FQX1RZUEVfVEFHLkJVVFQsICAgXCJidXR0XCJdLFxuICBbQ0FQX1RZUEVfVEFHLlNRVUFSRSwgXCJzcXVhcmVcIl0sXG4gIFtDQVBfVFlQRV9UQUcuUk9VTkQsICBcInJvdW5kXCJdLFxuXSk7XG5cbmZ1bmN0aW9uIENhcF90eXBlX3ZhbChjYXApIHtcbiAgcmV0dXJuIHRhZ190b19jYXBfdHlwZS5nZXQoY2FwKTtcbn1cblxuLy9Qcm92aWRlczogVmFsX2NvbXBvcFxuLy9SZXF1aXJlczogQ09NUE9QX1RBR1xuXG52YXIgY29tcG9wX3RvX3RhZyA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5NYXAoW1xuICBbXCJzb3VyY2Utb3ZlclwiLCAgICAgIENPTVBPUF9UQUcuU09VUkNFX09WRVJdLFxuICBbXCJzb3VyY2UtaW5cIiwgICAgICAgIENPTVBPUF9UQUcuU09VUkNFX0lOXSxcbiAgW1wic291cmNlLW91dFwiLCAgICAgICBDT01QT1BfVEFHLlNPVVJDRV9PVVRdLFxuICBbXCJzb3VyY2UtYXRvcFwiLCAgICAgIENPTVBPUF9UQUcuU09VUkNFX0FUT1BdLFxuICBbXCJkZXN0aW5hdGlvbi1vdmVyXCIsIENPTVBPUF9UQUcuREVTVElOQVRJT05fT1ZFUl0sXG4gIFtcImRlc3RpbmF0aW9uLWluXCIsICAgQ09NUE9QX1RBRy5ERVNUSU5BVElPTl9JTl0sXG4gIFtcImRlc3RpbmF0aW9uLW91dFwiLCAgQ09NUE9QX1RBRy5ERVNUSU5BVElPTl9PVVRdLFxuICBbXCJkZXN0aW5hdGlvbi1hdG9wXCIsIENPTVBPUF9UQUcuREVTVElOQVRJT05fQVRPUF0sXG4gIFtcImxpZ2h0ZXJcIiwgICAgICAgICAgQ09NUE9QX1RBRy5MSUdIVEVSXSxcbiAgW1wiY29weVwiLCAgICAgICAgICAgICBDT01QT1BfVEFHLkNPUFldLFxuICBbXCJ4b3JcIiwgICAgICAgICAgICAgIENPTVBPUF9UQUcuWE9SXSxcbiAgW1wibXVsdGlwbHlcIiwgICAgICAgICBDT01QT1BfVEFHLk1VTFRJUExZXSxcbiAgW1wic2NyZWVuXCIsICAgICAgICAgICBDT01QT1BfVEFHLlNDUkVFTl0sXG4gIFtcIm92ZXJsYXlcIiwgICAgICAgICAgQ09NUE9QX1RBRy5PVkVSTEFZXSxcbiAgW1wiZGFya2VuXCIsICAgICAgICAgICBDT01QT1BfVEFHLkRBUktFTl0sXG4gIFtcImxpZ2h0ZW5cIiwgICAgICAgICAgQ09NUE9QX1RBRy5MSUdIVEVOXSxcbiAgW1wiY29sb3ItZG9kZ2VcIiwgICAgICBDT01QT1BfVEFHLkNPTE9SX0RPREdFXSxcbiAgW1wiY29sb3ItYnVyblwiLCAgICAgICBDT01QT1BfVEFHLkNPTE9SX0JVUk5dLFxuICBbXCJoYXJkLWxpZ2h0XCIsICAgICAgIENPTVBPUF9UQUcuSEFSRF9MSUdIVF0sXG4gIFtcInNvZnQtbGlnaHRcIiwgICAgICAgQ09NUE9QX1RBRy5TT0ZUX0xJR0hUXSxcbiAgW1wiZGlmZmVyZW5jZVwiLCAgICAgICBDT01QT1BfVEFHLkRJRkZFUkVOQ0VdLFxuICBbXCJleGNsdXNpb25cIiwgICAgICAgIENPTVBPUF9UQUcuRVhDTFVTSU9OXSxcbiAgW1wiaHVlXCIsICAgICAgICAgICAgICBDT01QT1BfVEFHLkhVRV0sXG4gIFtcInNhdHVyYXRpb25cIiwgICAgICAgQ09NUE9QX1RBRy5TQVRVUkFUSU9OXSxcbiAgW1wiY29sb3JcIiwgICAgICAgICAgICBDT01QT1BfVEFHLkNPTE9SXSxcbiAgW1wibHVtaW5vc2l0eVwiLCAgICAgICBDT01QT1BfVEFHLkxVTUlOT1NJVFldLFxuXSk7XG5cbmZ1bmN0aW9uIFZhbF9jb21wb3AoY29tcG9wKSB7XG4gIHJldHVybiBjb21wb3BfdG9fdGFnLmdldChjb21wb3ApO1xufVxuXG4vL1Byb3ZpZGVzOiBDb21wb3BfdmFsXG4vL1JlcXVpcmVzOiBDT01QT1BfVEFHXG5cbnZhciB0YWdfdG9fY29tcG9wID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0Lk1hcChbXG4gIFtDT01QT1BfVEFHLlNPVVJDRV9PVkVSLCAgICAgIFwic291cmNlLW92ZXJcIl0sXG4gIFtDT01QT1BfVEFHLlNPVVJDRV9JTiwgICAgICAgIFwic291cmNlLWluXCJdLFxuICBbQ09NUE9QX1RBRy5TT1VSQ0VfT1VULCAgICAgICBcInNvdXJjZS1vdXRcIl0sXG4gIFtDT01QT1BfVEFHLlNPVVJDRV9BVE9QLCAgICAgIFwic291cmNlLWF0b3BcIl0sXG4gIFtDT01QT1BfVEFHLkRFU1RJTkFUSU9OX09WRVIsIFwiZGVzdGluYXRpb24tb3ZlclwiXSxcbiAgW0NPTVBPUF9UQUcuREVTVElOQVRJT05fSU4sICAgXCJkZXN0aW5hdGlvbi1pblwiXSxcbiAgW0NPTVBPUF9UQUcuREVTVElOQVRJT05fT1VULCAgXCJkZXN0aW5hdGlvbi1vdXRcIl0sXG4gIFtDT01QT1BfVEFHLkRFU1RJTkFUSU9OX0FUT1AsIFwiZGVzdGluYXRpb24tYXRvcFwiXSxcbiAgW0NPTVBPUF9UQUcuTElHSFRFUiwgICAgICAgICAgXCJsaWdodGVyXCJdLFxuICBbQ09NUE9QX1RBRy5DT1BZLCAgICAgICAgICAgICBcImNvcHlcIl0sXG4gIFtDT01QT1BfVEFHLlhPUiwgICAgICAgICAgICAgIFwieG9yXCJdLFxuICBbQ09NUE9QX1RBRy5NVUxUSVBMWSwgICAgICAgICBcIm11bHRpcGx5XCJdLFxuICBbQ09NUE9QX1RBRy5TQ1JFRU4sICAgICAgICAgICBcInNjcmVlblwiXSxcbiAgW0NPTVBPUF9UQUcuT1ZFUkxBWSwgICAgICAgICAgXCJvdmVybGF5XCJdLFxuICBbQ09NUE9QX1RBRy5EQVJLRU4sICAgICAgICAgICBcImRhcmtlblwiXSxcbiAgW0NPTVBPUF9UQUcuTElHSFRFTiwgICAgICAgICAgXCJsaWdodGVuXCJdLFxuICBbQ09NUE9QX1RBRy5DT0xPUl9ET0RHRSwgICAgICBcImNvbG9yLWRvZGdlXCJdLFxuICBbQ09NUE9QX1RBRy5DT0xPUl9CVVJOLCAgICAgICBcImNvbG9yLWJ1cm5cIl0sXG4gIFtDT01QT1BfVEFHLkhBUkRfTElHSFQsICAgICAgIFwiaGFyZC1saWdodFwiXSxcbiAgW0NPTVBPUF9UQUcuU09GVF9MSUdIVCwgICAgICAgXCJzb2Z0LWxpZ2h0XCJdLFxuICBbQ09NUE9QX1RBRy5ESUZGRVJFTkNFLCAgICAgICBcImRpZmZlcmVuY2VcIl0sXG4gIFtDT01QT1BfVEFHLkVYQ0xVU0lPTiwgICAgICAgIFwiZXhjbHVzaW9uXCJdLFxuICBbQ09NUE9QX1RBRy5IVUUsICAgICAgICAgICAgICBcImh1ZVwiXSxcbiAgW0NPTVBPUF9UQUcuU0FUVVJBVElPTiwgICAgICAgXCJzYXR1cmF0aW9uXCJdLFxuICBbQ09NUE9QX1RBRy5DT0xPUiwgICAgICAgICAgICBcImNvbG9yXCJdLFxuICBbQ09NUE9QX1RBRy5MVU1JTk9TSVRZLCAgICAgICBcImx1bWlub3NpdHlcIl0sXG5dKTtcblxuZnVuY3Rpb24gQ29tcG9wX3ZhbChjYXApIHtcbiAgcmV0dXJuIHRhZ190b19jb21wb3AuZ2V0KGNhcCk7XG59XG4iLCIvL1Byb3ZpZGVzOiBjYW1sX3VuaXhfZ2V0dGltZW9mZGF5XG4vL0FsaWFzOiB1bml4X2dldHRpbWVvZmRheVxuZnVuY3Rpb24gY2FtbF91bml4X2dldHRpbWVvZmRheSAoKSB7XG4gIHJldHVybiAobmV3IERhdGUoKSkuZ2V0VGltZSgpIC8gMTAwMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X3RpbWVcbi8vUmVxdWlyZXM6IGNhbWxfdW5peF9nZXR0aW1lb2ZkYXlcbi8vQWxpYXM6IHVuaXhfdGltZVxuZnVuY3Rpb24gY2FtbF91bml4X3RpbWUgKCkge1xuICByZXR1cm4gTWF0aC5mbG9vcihjYW1sX3VuaXhfZ2V0dGltZW9mZGF5ICgpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X2dtdGltZVxuLy9BbGlhczogdW5peF9nbXRpbWVcbmZ1bmN0aW9uIGNhbWxfdW5peF9nbXRpbWUgKHQpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSAodCAqIDEwMDApO1xuICB2YXIgZF9udW0gPSBkLmdldFRpbWUoKTtcbiAgdmFyIGphbnVhcnlmaXJzdCA9IChuZXcgRGF0ZShEYXRlLlVUQyhkLmdldFVUQ0Z1bGxZZWFyKCksIDAsIDEpKSkuZ2V0VGltZSgpO1xuICB2YXIgZG95ID0gTWF0aC5mbG9vcigoZF9udW0gLSBqYW51YXJ5Zmlyc3QpIC8gODY0MDAwMDApO1xuICByZXR1cm4gQkxPQ0soMCwgZC5nZXRVVENTZWNvbmRzKCksIGQuZ2V0VVRDTWludXRlcygpLCBkLmdldFVUQ0hvdXJzKCksXG4gICAgICAgICAgICAgICBkLmdldFVUQ0RhdGUoKSwgZC5nZXRVVENNb250aCgpLCBkLmdldFVUQ0Z1bGxZZWFyKCkgLSAxOTAwLFxuICAgICAgICAgICAgICAgZC5nZXRVVENEYXkoKSwgZG95LFxuICAgICAgICAgICAgICAgZmFsc2UgfCAwIC8qIGZvciBVVEMgZGF5bGlnaHQgc2F2aW5ncyB0aW1lIGlzIGZhbHNlICovKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfbG9jYWx0aW1lXG4vL0FsaWFzOiB1bml4X2xvY2FsdGltZVxuZnVuY3Rpb24gY2FtbF91bml4X2xvY2FsdGltZSAodCkge1xuICB2YXIgZCA9IG5ldyBEYXRlICh0ICogMTAwMCk7XG4gIHZhciBkX251bSA9IGQuZ2V0VGltZSgpO1xuICB2YXIgamFudWFyeWZpcnN0ID0gKG5ldyBEYXRlKGQuZ2V0RnVsbFllYXIoKSwgMCwgMSkpLmdldFRpbWUoKTtcbiAgdmFyIGRveSA9IE1hdGguZmxvb3IoKGRfbnVtIC0gamFudWFyeWZpcnN0KSAvIDg2NDAwMDAwKTtcbiAgdmFyIGphbiA9IG5ldyBEYXRlKGQuZ2V0RnVsbFllYXIoKSwgMCwgMSk7XG4gIHZhciBqdWwgPSBuZXcgRGF0ZShkLmdldEZ1bGxZZWFyKCksIDYsIDEpO1xuICB2YXIgc3RkVGltZXpvbmVPZmZzZXQgPSBNYXRoLm1heChqYW4uZ2V0VGltZXpvbmVPZmZzZXQoKSwganVsLmdldFRpbWV6b25lT2Zmc2V0KCkpO1xuICByZXR1cm4gQkxPQ0soMCwgZC5nZXRTZWNvbmRzKCksIGQuZ2V0TWludXRlcygpLCBkLmdldEhvdXJzKCksXG4gICAgICAgICAgICAgICBkLmdldERhdGUoKSwgZC5nZXRNb250aCgpLCBkLmdldEZ1bGxZZWFyKCkgLSAxOTAwLFxuICAgICAgICAgICAgICAgZC5nZXREYXkoKSwgZG95LFxuICAgICAgICAgICAgICAgKGQuZ2V0VGltZXpvbmVPZmZzZXQoKSA8IHN0ZFRpbWV6b25lT2Zmc2V0KSB8IDAgLyogZGF5bGlnaHQgc2F2aW5ncyB0aW1lICBmaWVsZC4gKi8pXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9ta3RpbWVcbi8vUmVxdWlyZXM6IGNhbWxfdW5peF9sb2NhbHRpbWVcbi8vQWxpYXM6IHVuaXhfbWt0aW1lXG5mdW5jdGlvbiBjYW1sX3VuaXhfbWt0aW1lKHRtKXtcbiAgdmFyIGQgPSAobmV3IERhdGUodG1bNl0rMTkwMCx0bVs1XSx0bVs0XSx0bVszXSx0bVsyXSx0bVsxXSkpLmdldFRpbWUoKTtcbiAgdmFyIHQgPSBNYXRoLmZsb29yKGQgLyAxMDAwKTtcbiAgdmFyIHRtMiA9IGNhbWxfdW5peF9sb2NhbHRpbWUodCk7XG4gIHJldHVybiBCTE9DSygwLHQsdG0yKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9zdGFydHVwIGNvbnN0XG4vL0FsaWFzOiB3aW5fc3RhcnR1cFxuZnVuY3Rpb24gY2FtbF91bml4X3N0YXJ0dXAoKSB7fVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfY2xlYW51cCBjb25zdFxuLy9BbGlhczogd2luX2NsZWFudXBcbmZ1bmN0aW9uIGNhbWxfdW5peF9jbGVhbnVwKCkge31cblxuLy9Qcm92aWRlczogY2FtbF91bml4X2ZpbGVkZXNjcl9vZl9mZCBjb25zdFxuLy9BbGlhczogd2luX2hhbmRsZV9mZFxuZnVuY3Rpb24gY2FtbF91bml4X2ZpbGVkZXNjcl9vZl9mZCh4KSB7cmV0dXJuIHg7fVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfaXNhdHR5XG4vL1JlcXVpcmVzOiBmc19ub2RlX3N1cHBvcnRlZFxuLy9BbGlhczogdW5peF9pc2F0dHlcbmZ1bmN0aW9uIGNhbWxfdW5peF9pc2F0dHkoZmlsZURlc2NyaXB0b3IpIHtcbiAgaWYoZnNfbm9kZV9zdXBwb3J0ZWQoKSkge1xuICAgIHZhciB0dHkgPSByZXF1aXJlKCd0dHknKTtcbiAgICByZXR1cm4gdHR5LmlzYXR0eShmaWxlRGVzY3JpcHRvcik/MTowO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAwO1xuICB9XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF91bml4X2lzYXR0eVxuLy9BbGlhczogdW5peF9pc2F0dHlcbi8vSWY6IGJyb3dzZXJcbmZ1bmN0aW9uIGNhbWxfdW5peF9pc2F0dHkoZmlsZURlc2NyaXB0b3IpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IG1ha2VfdW5peF9lcnJfYXJnc1xuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmdcbnZhciB1bml4X2Vycm9yID0gW1xuICAvKiA9PT1Vbml4LmVycm9yPT09XG4gICAqXG4gICAqIFRoaXMgYXJyYXkgaXMgaW4gb3JkZXIgb2YgdGhlIHZhcmlhbnQgaW4gT0NhbWxcbiAgICovXG4gIFwiRTJCSUdcIiwgXCJFQUNDRVNcIiwgXCJFQUdBSU5cIiwgXCJFQkFERlwiLCBcIkVCVVNZXCIsIFwiRUNISUxEXCIsIFwiRURFQURMS1wiLCBcIkVET01cIixcbiAgXCJFRVhJU1RcIiwgXCJFRkFVTFRcIiwgXCJFRkJJR1wiLCBcIkVJTlRSXCIsIFwiRUlOVkFMXCIsIFwiRUlPXCIsIFwiRUlTRElSXCIsIFwiRU1GSUxFXCIsXG4gIFwiRU1MSU5LXCIsIFwiRU5BTUVUT09MT05HXCIsIFwiRU5GSUxFXCIsIFwiRU5PREVWXCIsIFwiRU5PRU5UXCIsIFwiRU5PRVhFQ1wiLCBcIkVOT0xDS1wiLFxuICBcIkVOT01FTVwiLCBcIkVOT1NQQ1wiLCBcIkVOT1NZU1wiLCBcIkVOT1RESVJcIiwgXCJFTk9URU1QVFlcIiwgXCJFTk9UVFlcIiwgXCJFTlhJT1wiLFxuICBcIkVQRVJNXCIsIFwiRVBJUEVcIiwgXCJFUkFOR0VcIiwgXCJFUk9GU1wiLCBcIkVTUElQRVwiLCBcIkVTUkNIXCIsIFwiRVhERVZcIiwgXCJFV09VTERCTE9DS1wiLFxuICBcIkVJTlBST0dSRVNTXCIsIFwiRUFMUkVBRFlcIiwgXCJFTk9UU09DS1wiLCBcIkVERVNUQUREUlJFUVwiLCBcIkVNU0dTSVpFXCIsXG4gIFwiRVBST1RPVFlQRVwiLCBcIkVOT1BST1RPT1BUXCIsIFwiRVBST1RPTk9TVVBQT1JUXCIsIFwiRVNPQ0tUTk9TVVBQT1JUXCIsXG4gIFwiRU9QTk9UU1VQUFwiLCBcIkVQRk5PU1VQUE9SVFwiLCBcIkVBRk5PU1VQUE9SVFwiLCBcIkVBRERSSU5VU0VcIiwgXCJFQUREUk5PVEFWQUlMXCIsXG4gIFwiRU5FVERPV05cIiwgXCJFTkVUVU5SRUFDSFwiLCBcIkVORVRSRVNFVFwiLCBcIkVDT05OQUJPUlRFRFwiLCBcIkVDT05OUkVTRVRcIiwgXCJFTk9CVUZTXCIsXG4gIFwiRUlTQ09OTlwiLCBcIkVOT1RDT05OXCIsIFwiRVNIVVRET1dOXCIsIFwiRVRPT01BTllSRUZTXCIsIFwiRVRJTUVET1VUXCIsIFwiRUNPTk5SRUZVU0VEXCIsXG4gIFwiRUhPU1RET1dOXCIsIFwiRUhPU1RVTlJFQUNIXCIsIFwiRUxPT1BcIiwgXCJFT1ZFUkZMT1dcIlxuXTtcbmZ1bmN0aW9uIG1ha2VfdW5peF9lcnJfYXJncyhjb2RlLCBzeXNjYWxsLCBwYXRoLCBlcnJubykge1xuICB2YXIgdmFyaWFudCA9IHVuaXhfZXJyb3IuaW5kZXhPZihjb2RlKTtcbiAgaWYgKHZhcmlhbnQgPCAwKSB7XG4gICAgLy8gRGVmYXVsdCBpZiB1bmRlZmluZWRcbiAgICBpZiAoZXJybm8gPT0gbnVsbCkge1xuICAgICAgZXJybm8gPSAtOTk5OVxuICAgIH1cbiAgICAvLyBJZiBub25lIG9mIHRoZSBhYm92ZSB2YXJpYW50cywgZmFsbGJhY2sgdG8gRVVOS05PV05FUlIoaW50KVxuICAgIHZhcmlhbnQgPSBCTE9DSygwLCBlcnJubyk7XG4gIH1cbiAgdmFyIGFyZ3MgPSBbXG4gICAgdmFyaWFudCxcbiAgICBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhzeXNjYWxsIHx8IFwiXCIpLFxuICAgIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKHBhdGggfHwgXCJcIilcbiAgXTtcbiAgcmV0dXJuIGFyZ3M7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9zdGF0XG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZSwgY2FtbF9mYWlsd2l0aFxuLy9BbGlhczogdW5peF9zdGF0XG5mdW5jdGlvbiBjYW1sX3VuaXhfc3RhdChuYW1lKSB7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIGlmICghcm9vdC5kZXZpY2Uuc3RhdCkge1xuICAgIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3VuaXhfc3RhdDogbm90IGltcGxlbWVudGVkXCIpO1xuICB9XG4gIHJldHVybiByb290LmRldmljZS5zdGF0KHJvb3QucmVzdCwgLyogcmFpc2UgVW5peF9lcnJvciAqLyB0cnVlKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X3N0YXRfNjRcbi8vUmVxdWlyZXM6IGNhbWxfdW5peF9zdGF0LCBjYW1sX2ludDY0X29mX2ludDMyXG4vL0FsaWFzOiB1bml4X3N0YXRfNjRcbmZ1bmN0aW9uIGNhbWxfdW5peF9zdGF0XzY0KG5hbWUpIHtcbiAgdmFyIHIgPSBjYW1sX3VuaXhfc3RhdChuYW1lKTtcbiAgcls5XSA9IGNhbWxfaW50NjRfb2ZfaW50MzIocls5XSk7XG4gIHJldHVybiByO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfbHN0YXRcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlLCBjYW1sX2ZhaWx3aXRoXG4vL0FsaWFzOiB1bml4X2xzdGF0XG5mdW5jdGlvbiBjYW1sX3VuaXhfbHN0YXQobmFtZSkge1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICBpZiAoIXJvb3QuZGV2aWNlLmxzdGF0KSB7XG4gICAgY2FtbF9mYWlsd2l0aChcImNhbWxfdW5peF9sc3RhdDogbm90IGltcGxlbWVudGVkXCIpO1xuICB9XG4gIHJldHVybiByb290LmRldmljZS5sc3RhdChyb290LnJlc3QsIC8qIHJhaXNlIFVuaXhfZXJyb3IgKi8gdHJ1ZSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9sc3RhdF82NFxuLy9SZXF1aXJlczogY2FtbF91bml4X2xzdGF0LCBjYW1sX2ludDY0X29mX2ludDMyXG4vL0FsaWFzOiB1bml4X2xzdGF0XzY0XG5mdW5jdGlvbiBjYW1sX3VuaXhfbHN0YXRfNjQobmFtZSkge1xuICB2YXIgciA9IGNhbWxfdW5peF9sc3RhdChuYW1lKTtcbiAgcls5XSA9IGNhbWxfaW50NjRfb2ZfaW50MzIocls5XSk7XG4gIHJldHVybiByO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfbWtkaXJcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlLCBjYW1sX2ZhaWx3aXRoXG4vL0FsaWFzOiB1bml4X21rZGlyXG5mdW5jdGlvbiBjYW1sX3VuaXhfbWtkaXIobmFtZSwgcGVybSkge1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICBpZiAoIXJvb3QuZGV2aWNlLm1rZGlyKSB7XG4gICAgY2FtbF9mYWlsd2l0aChcImNhbWxfdW5peF9ta2Rpcjogbm90IGltcGxlbWVudGVkXCIpO1xuICB9XG4gIHJldHVybiByb290LmRldmljZS5ta2Rpcihyb290LnJlc3QsIHBlcm0sIC8qIHJhaXNlIFVuaXhfZXJyb3IgKi8gdHJ1ZSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9ybWRpclxuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2UsIGNhbWxfZmFpbHdpdGhcbi8vQWxpYXM6IHVuaXhfcm1kaXJcbmZ1bmN0aW9uIGNhbWxfdW5peF9ybWRpcihuYW1lKSB7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIGlmICghcm9vdC5kZXZpY2Uucm1kaXIpIHtcbiAgICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF91bml4X3JtZGlyOiBub3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbiAgcmV0dXJuIHJvb3QuZGV2aWNlLnJtZGlyKHJvb3QucmVzdCwgLyogcmFpc2UgVW5peF9lcnJvciAqLyB0cnVlKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X3N5bWxpbmtcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlLCBjYW1sX2ZhaWx3aXRoXG4vL0FsaWFzOiB1bml4X3N5bWxpbmtcbmZ1bmN0aW9uIGNhbWxfdW5peF9zeW1saW5rKHRvX2Rpciwgc3JjLCBkc3QpIHtcbiAgdmFyIHNyY19yb290ID0gcmVzb2x2ZV9mc19kZXZpY2Uoc3JjKTtcbiAgdmFyIGRzdF9yb290ID0gcmVzb2x2ZV9mc19kZXZpY2UoZHN0KTtcbiAgaWYoc3JjX3Jvb3QuZGV2aWNlICE9IGRzdF9yb290LmRldmljZSlcbiAgICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF91bml4X3N5bWxpbms6IGNhbm5vdCBzeW1saW5rIGJldHdlZW4gdHdvIGZpbGVzeXN0ZW1zXCIpO1xuICBpZiAoIXNyY19yb290LmRldmljZS5zeW1saW5rKSB7XG4gICAgY2FtbF9mYWlsd2l0aChcImNhbWxfdW5peF9zeW1saW5rOiBub3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbiAgcmV0dXJuIHNyY19yb290LmRldmljZS5zeW1saW5rKHRvX2Rpciwgc3JjX3Jvb3QucmVzdCwgZHN0X3Jvb3QucmVzdCwgLyogcmFpc2UgVW5peF9lcnJvciAqLyB0cnVlKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X3JlYWRsaW5rXG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZSwgY2FtbF9mYWlsd2l0aFxuLy9BbGlhczogdW5peF9yZWFkbGlua1xuZnVuY3Rpb24gY2FtbF91bml4X3JlYWRsaW5rKG5hbWUpIHtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgaWYgKCFyb290LmRldmljZS5yZWFkbGluaykge1xuICAgIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3VuaXhfcmVhZGxpbms6IG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfVxuICByZXR1cm4gcm9vdC5kZXZpY2UucmVhZGxpbmsocm9vdC5yZXN0LCAvKiByYWlzZSBVbml4X2Vycm9yICovIHRydWUpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfdW5saW5rXG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZSwgY2FtbF9mYWlsd2l0aFxuLy9BbGlhczogdW5peF91bmxpbmtcbmZ1bmN0aW9uIGNhbWxfdW5peF91bmxpbmsobmFtZSkge1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICBpZiAoIXJvb3QuZGV2aWNlLnVubGluaykge1xuICAgIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3VuaXhfdW5saW5rOiBub3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbiAgcmV0dXJuIHJvb3QuZGV2aWNlLnVubGluayhyb290LnJlc3QsIC8qIHJhaXNlIFVuaXhfZXJyb3IgKi8gdHJ1ZSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9nZXR1aWRcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfbm90X2ZvdW5kXG4vL0FsaWFzOiB1bml4X2dldHVpZFxuZnVuY3Rpb24gY2FtbF91bml4X2dldHVpZCh1bml0KSB7XG4gIGlmKGdsb2JhbFRoaXMucHJvY2VzcyAmJiBnbG9iYWxUaGlzLnByb2Nlc3MuZ2V0dWlkKXtcbiAgICByZXR1cm4gZ2xvYmFsVGhpcy5wcm9jZXNzLmdldHVpZCgpO1xuICB9XG4gIGNhbWxfcmFpc2Vfbm90X2ZvdW5kKCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9nZXRwd3VpZFxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9ub3RfZm91bmRcbi8vQWxpYXM6IHVuaXhfZ2V0cHd1aWRcbmZ1bmN0aW9uIGNhbWxfdW5peF9nZXRwd3VpZCh1bml0KSB7XG4gIGNhbWxfcmFpc2Vfbm90X2ZvdW5kKCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9oYXNfc3ltbGlua1xuLy9SZXF1aXJlczogZnNfbm9kZV9zdXBwb3J0ZWRcbi8vQWxpYXM6IHVuaXhfaGFzX3N5bWxpbmtcbmZ1bmN0aW9uIGNhbWxfdW5peF9oYXNfc3ltbGluayh1bml0KSB7XG4gIHJldHVybiBmc19ub2RlX3N1cHBvcnRlZCgpPzE6MFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfb3BlbmRpclxuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2UsIGNhbWxfZmFpbHdpdGhcbi8vQWxpYXM6IHVuaXhfb3BlbmRpclxuZnVuY3Rpb24gY2FtbF91bml4X29wZW5kaXIocGF0aCkge1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKHBhdGgpO1xuICBpZiAoIXJvb3QuZGV2aWNlLm9wZW5kaXIpIHtcbiAgICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF91bml4X29wZW5kaXI6IG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfVxuICB2YXIgZGlyX2hhbmRsZSA9IHJvb3QuZGV2aWNlLm9wZW5kaXIocm9vdC5yZXN0LCAvKiByYWlzZSBVbml4X2Vycm9yICovIHRydWUpO1xuICByZXR1cm4geyBwb2ludGVyIDogZGlyX2hhbmRsZSwgcGF0aDogcGF0aCB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9yZWFkZGlyXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX2VuZF9vZl9maWxlXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZ1xuLy9SZXF1aXJlczogbWFrZV91bml4X2Vycl9hcmdzLCBjYW1sX3JhaXNlX3dpdGhfYXJncywgY2FtbF9uYW1lZF92YWx1ZVxuLy9BbGlhczogdW5peF9yZWFkZGlyXG5mdW5jdGlvbiBjYW1sX3VuaXhfcmVhZGRpcihkaXJfaGFuZGxlKSB7XG4gIHZhciBlbnRyeTtcbiAgdHJ5IHtcbiAgICAgIGVudHJ5ID0gZGlyX2hhbmRsZS5wb2ludGVyLnJlYWRTeW5jKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHZhciB1bml4X2Vycm9yID0gY2FtbF9uYW1lZF92YWx1ZSgnVW5peC5Vbml4X2Vycm9yJyk7XG4gICAgICBjYW1sX3JhaXNlX3dpdGhfYXJncyh1bml4X2Vycm9yLCBtYWtlX3VuaXhfZXJyX2FyZ3MoXCJFQkFERlwiLCBcInJlYWRkaXJcIiwgZGlyX2hhbmRsZS5wYXRoKSk7XG4gIH1cbiAgaWYgKGVudHJ5ID09PSBudWxsKSB7XG4gICAgICBjYW1sX3JhaXNlX2VuZF9vZl9maWxlKCk7XG4gIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcoZW50cnkubmFtZSk7XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X2Nsb3NlZGlyXG4vL1JlcXVpcmVzOiBtYWtlX3VuaXhfZXJyX2FyZ3MsIGNhbWxfcmFpc2Vfd2l0aF9hcmdzLCBjYW1sX25hbWVkX3ZhbHVlXG4vL0FsaWFzOiB1bml4X2Nsb3NlZGlyXG5mdW5jdGlvbiBjYW1sX3VuaXhfY2xvc2VkaXIoZGlyX2hhbmRsZSkge1xuICB0cnkge1xuICAgICAgZGlyX2hhbmRsZS5wb2ludGVyLmNsb3NlU3luYygpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgICB2YXIgdW5peF9lcnJvciA9IGNhbWxfbmFtZWRfdmFsdWUoJ1VuaXguVW5peF9lcnJvcicpO1xuICAgICAgY2FtbF9yYWlzZV93aXRoX2FyZ3ModW5peF9lcnJvciwgbWFrZV91bml4X2Vycl9hcmdzKFwiRUJBREZcIiwgXCJjbG9zZWRpclwiLCBkaXJfaGFuZGxlLnBhdGgpKTtcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfcmV3aW5kZGlyXG4vL1JlcXVpcmVzOiBjYW1sX3VuaXhfY2xvc2VkaXIsIGNhbWxfdW5peF9vcGVuZGlyXG4vL0FsaWFzOiB1bml4X3Jld2luZGRpclxuZnVuY3Rpb24gY2FtbF91bml4X3Jld2luZGRpcihkaXJfaGFuZGxlKSB7XG4gIGNhbWxfdW5peF9jbG9zZWRpcihkaXJfaGFuZGxlKTtcbiAgdmFyIG5ld19kaXJfaGFuZGxlID0gY2FtbF91bml4X29wZW5kaXIoZGlyX2hhbmRsZS5wYXRoKTtcbiAgZGlyX2hhbmRsZS5wb2ludGVyID0gbmV3X2Rpcl9oYW5kbGUucG9pbnRlcjtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9maW5kZmlyc3Rcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nLCBjYW1sX3N0cmluZ19vZl9qc3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF91bml4X29wZW5kaXIsIGNhbWxfdW5peF9yZWFkZGlyXG4vL0FsaWFzOiB3aW5fZmluZGZpcnN0XG5mdW5jdGlvbiBjYW1sX3VuaXhfZmluZGZpcnN0KHBhdGgpIHtcbiAgLy8gVGhlIFdpbmRvd3MgY29kZSBhZGRzIHRoaXMgZ2xvYiB0byB0aGUgcGF0aCwgc28gd2UgbmVlZCB0byByZW1vdmUgaXRcbiAgdmFyIHBhdGhfanMgPSBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhwYXRoKTtcbiAgcGF0aF9qcyA9IHBhdGhfanMucmVwbGFjZSgvKF58W1xcXFxcXC9dKVxcKlxcLlxcKiQvLCBcIlwiKTtcbiAgcGF0aCA9IGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKHBhdGhfanMpO1xuICAvLyAqLiogaXMgbm93IHN0cmlwcGVkXG4gIHZhciBkaXJfaGFuZGxlID0gY2FtbF91bml4X29wZW5kaXIocGF0aCk7XG4gIHZhciBmaXJzdF9lbnRyeSA9IGNhbWxfdW5peF9yZWFkZGlyKGRpcl9oYW5kbGUpO1xuICAvLyBUaGUgV2luZG93cyBiaW5kaW5ncyB0eXBlIGRpcl9oYW5kbGUgYXMgYW4gYGludGAgYnV0IGl0J3Mgbm90IGluIEpTXG4gIHJldHVybiBbMCwgZmlyc3RfZW50cnksIGRpcl9oYW5kbGVdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfZmluZG5leHRcbi8vUmVxdWlyZXM6IGNhbWxfdW5peF9yZWFkZGlyXG4vL0FsaWFzOiB3aW5fZmluZG5leHRcbmZ1bmN0aW9uIGNhbWxfdW5peF9maW5kbmV4dChkaXJfaGFuZGxlKSB7XG4gIHJldHVybiBjYW1sX3VuaXhfcmVhZGRpcihkaXJfaGFuZGxlKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X2ZpbmRjbG9zZVxuLy9SZXF1aXJlczogY2FtbF91bml4X2Nsb3NlZGlyXG4vL0FsaWFzOiB3aW5fZmluZGNsb3NlXG5mdW5jdGlvbiBjYW1sX3VuaXhfZmluZGNsb3NlKGRpcl9oYW5kbGUpIHtcbiAgcmV0dXJuIGNhbWxfdW5peF9jbG9zZWRpcihkaXJfaGFuZGxlKTtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfaW5ldF9hZGRyX29mX3N0cmluZyBjb25zdFxuLy9BbGlhczogdW5peF9pbmV0X2FkZHJfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3VuaXhfaW5ldF9hZGRyX29mX3N0cmluZyAoKSB7cmV0dXJuIDA7fVxuXG5cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxMCBKw6lyw7RtZSBWb3VpbGxvblxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NhbGxfZ2VuIChjb25zdCwgc2hhbGxvdylcbi8vSWY6ICFlZmZlY3RzXG4vL1dlYWtkZWZcbmZ1bmN0aW9uIGNhbWxfY2FsbF9nZW4oZiwgYXJncykge1xuICB2YXIgbiA9IChmLmwgPj0gMCk/Zi5sOihmLmwgPSBmLmxlbmd0aCk7XG4gIHZhciBhcmdzTGVuID0gYXJncy5sZW5ndGg7XG4gIHZhciBkID0gbiAtIGFyZ3NMZW47XG4gIGlmIChkID09IDApXG4gICAgcmV0dXJuIGYuYXBwbHkobnVsbCwgYXJncyk7XG4gIGVsc2UgaWYgKGQgPCAwKSB7XG4gICAgdmFyIGcgPSBmLmFwcGx5KG51bGwsYXJncy5zbGljZSgwLG4pKTtcbiAgICBpZih0eXBlb2YgZyAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gZztcbiAgICByZXR1cm4gY2FtbF9jYWxsX2dlbihnLGFyZ3Muc2xpY2UobikpO1xuICB9XG4gIGVsc2Uge1xuICAgIHN3aXRjaCAoZCkge1xuICAgIGNhc2UgMToge1xuICAgICAgdmFyIGcgPSBmdW5jdGlvbiAoeCl7XG4gICAgICAgIHZhciBuYXJncyA9IG5ldyBBcnJheShhcmdzTGVuICsgMSk7XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBhcmdzTGVuOyBpKysgKSBuYXJnc1tpXSA9IGFyZ3NbaV07XG4gICAgICAgIG5hcmdzW2FyZ3NMZW5dID0geDtcbiAgICAgICAgcmV0dXJuIGYuYXBwbHkobnVsbCwgbmFyZ3MpXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgMjoge1xuICAgICAgdmFyIGcgPSBmdW5jdGlvbiAoeCwgeSl7XG4gICAgICAgIHZhciBuYXJncyA9IG5ldyBBcnJheShhcmdzTGVuICsgMik7XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBhcmdzTGVuOyBpKysgKSBuYXJnc1tpXSA9IGFyZ3NbaV07XG4gICAgICAgIG5hcmdzW2FyZ3NMZW5dID0geDtcbiAgICAgICAgbmFyZ3NbYXJnc0xlbiArIDFdID0geTtcbiAgICAgICAgcmV0dXJuIGYuYXBwbHkobnVsbCwgbmFyZ3MpXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIHZhciBnID0gZnVuY3Rpb24gKCl7XG4gICAgICAgIHZhciBleHRyYV9hcmdzID0gKGFyZ3VtZW50cy5sZW5ndGggPT0gMCk/MTphcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB2YXIgbmFyZ3MgPSBuZXcgQXJyYXkoYXJncy5sZW5ndGgrZXh0cmFfYXJncyk7XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrICkgbmFyZ3NbaV0gPSBhcmdzW2ldO1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrICkgbmFyZ3NbYXJncy5sZW5ndGgraV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIHJldHVybiBjYW1sX2NhbGxfZ2VuKGYsIG5hcmdzKVxuICAgICAgfTtcbiAgICB9fVxuICAgIGcubCA9IGQ7XG4gICAgcmV0dXJuIGc7XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9jYWxsX2dlbiAoY29uc3QsIHNoYWxsb3cpXG4vL0lmOiBlZmZlY3RzXG4vL1dlYWtkZWZcbmZ1bmN0aW9uIGNhbWxfY2FsbF9nZW4oZiwgYXJncykge1xuICB2YXIgbiA9IChmLmwgPj0gMCk/Zi5sOihmLmwgPSBmLmxlbmd0aCk7XG4gIHZhciBhcmdzTGVuID0gYXJncy5sZW5ndGg7XG4gIHZhciBkID0gbiAtIGFyZ3NMZW47XG4gIGlmIChkID09IDApIHtcbiAgICByZXR1cm4gZi5hcHBseShudWxsLCBhcmdzKTtcbiAgfSBlbHNlIGlmIChkIDwgMCkge1xuICAgIHZhciByZXN0ID0gYXJncy5zbGljZShuIC0gMSk7XG4gICAgdmFyIGsgPSBhcmdzIFthcmdzTGVuIC0gMV07XG4gICAgYXJncyA9IGFyZ3Muc2xpY2UoMCwgbik7XG4gICAgYXJnc1tuIC0gMV0gPSBmdW5jdGlvbiAoZykge1xuICAgICAgaWYgKHR5cGVvZiBnICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBrKGcpO1xuICAgICAgdmFyIGFyZ3MgPSByZXN0LnNsaWNlKCk7XG4gICAgICBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gPSBrO1xuICAgICAgcmV0dXJuIGNhbWxfY2FsbF9nZW4oZywgYXJncyk7IH07XG4gICAgcmV0dXJuIGYuYXBwbHkobnVsbCwgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgYXJnc0xlbi0tO1xuICAgIHZhciBrID0gYXJncyBbYXJnc0xlbl07XG4gICAgc3dpdGNoIChkKSB7XG4gICAgY2FzZSAxOiB7XG4gICAgICB2YXIgZyA9IGZ1bmN0aW9uICh4LCB5KXtcbiAgICAgICAgdmFyIG5hcmdzID0gbmV3IEFycmF5KGFyZ3NMZW4gKyAyKTtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGFyZ3NMZW47IGkrKyApIG5hcmdzW2ldID0gYXJnc1tpXTtcbiAgICAgICAgbmFyZ3NbYXJnc0xlbl0gPSB4O1xuICAgICAgICBuYXJnc1thcmdzTGVuICsgMV0gPSB5O1xuICAgICAgICByZXR1cm4gZi5hcHBseShudWxsLCBuYXJncylcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSAyOiB7XG4gICAgICB2YXIgZyA9IGZ1bmN0aW9uICh4LCB5LCB6KXtcbiAgICAgICAgdmFyIG5hcmdzID0gbmV3IEFycmF5KGFyZ3NMZW4gKyAzKTtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGFyZ3NMZW47IGkrKyApIG5hcmdzW2ldID0gYXJnc1tpXTtcbiAgICAgICAgbmFyZ3NbYXJnc0xlbl0gPSB4O1xuICAgICAgICBuYXJnc1thcmdzTGVuICsgMV0gPSB5O1xuICAgICAgICBuYXJnc1thcmdzTGVuICsgMl0gPSB6O1xuICAgICAgICByZXR1cm4gZi5hcHBseShudWxsLCBuYXJncylcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgdmFyIGcgPSBmdW5jdGlvbiAoKXtcbiAgICAgICAgdmFyIGV4dHJhX2FyZ3MgPSAoYXJndW1lbnRzLmxlbmd0aCA9PSAwKT8xOmFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHZhciBuYXJncyA9IG5ldyBBcnJheShhcmdzTGVuICsgZXh0cmFfYXJncyk7XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBhcmdzTGVuOyBpKysgKSBuYXJnc1tpXSA9IGFyZ3NbaV07XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKysgKVxuICAgICAgICAgIG5hcmdzW2FyZ3NMZW4gKyBpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgcmV0dXJuIGNhbWxfY2FsbF9nZW4oZiwgbmFyZ3MpXG4gICAgICB9O1xuICAgIH19XG4gICAgZy5sID0gZCArIDE7XG4gICAgcmV0dXJuIGsoZyk7XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9uYW1lZF92YWx1ZXNcbnZhciBjYW1sX25hbWVkX3ZhbHVlcyA9IHt9O1xuXG4vL1Byb3ZpZGVzOiBjYW1sX3JlZ2lzdGVyX25hbWVkX3ZhbHVlIChjb25zdCxtdXRhYmxlKVxuLy9SZXF1aXJlczogY2FtbF9uYW1lZF92YWx1ZXMsIGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfcmVnaXN0ZXJfbmFtZWRfdmFsdWUobm0sdikge1xuICBjYW1sX25hbWVkX3ZhbHVlc1tjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKG5tKV0gPSB2O1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9uYW1lZF92YWx1ZVxuLy9SZXF1aXJlczogY2FtbF9uYW1lZF92YWx1ZXNcbmZ1bmN0aW9uIGNhbWxfbmFtZWRfdmFsdWUobm0pIHtcbiAgcmV0dXJuIGNhbWxfbmFtZWRfdmFsdWVzW25tXVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dsb2JhbF9kYXRhXG52YXIgY2FtbF9nbG9iYWxfZGF0YSA9IFswXTtcblxuLy9Qcm92aWRlczogY2FtbF9idWlsZF9zeW1ib2xzXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9idWlsZF9zeW1ib2xzKHN5bWIpIHtcbiAgdmFyIHIgPSB7fTtcbiAgaWYoc3ltYikge1xuICAgIGZvcih2YXIgaSA9IDE7IGkgPCBzeW1iLmxlbmd0aDsgaSsrKXtcbiAgICAgIHJbY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcoc3ltYltpXVsxXSldID0gc3ltYltpXVsyXVxuICAgIH1cbiAgfVxuICByZXR1cm4gcjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9yZWdpc3Rlcl9nbG9iYWwgKGNvbnN0LCBzaGFsbG93LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfZ2xvYmFsX2RhdGEsIGNhbWxfY2FsbGJhY2ssIGNhbWxfYnVpbGRfc3ltYm9sc1xuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9yZWdpc3Rlcl9nbG9iYWwgKG4sIHYsIG5hbWVfb3B0KSB7XG4gIGlmIChuYW1lX29wdCkge1xuICAgIHZhciBuYW1lID0gbmFtZV9vcHQ7XG4gICAgaWYoZ2xvYmFsVGhpcy50b3BsZXZlbFJlbG9jKSB7XG4gICAgICBuID0gY2FtbF9jYWxsYmFjayhnbG9iYWxUaGlzLnRvcGxldmVsUmVsb2MsIFtuYW1lXSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNhbWxfZ2xvYmFsX2RhdGEuc3ltYm9scykge1xuICAgICAgaWYoIWNhbWxfZ2xvYmFsX2RhdGEuc3ltaWR4KSB7XG4gICAgICAgIGNhbWxfZ2xvYmFsX2RhdGEuc3ltaWR4ID0gY2FtbF9idWlsZF9zeW1ib2xzKGNhbWxfZ2xvYmFsX2RhdGEuc3ltYm9scylcbiAgICAgIH1cbiAgICAgIHZhciBuaWQgPSBjYW1sX2dsb2JhbF9kYXRhLnN5bWlkeFtuYW1lXVxuICAgICAgaWYobmlkID49IDApXG4gICAgICAgIG4gPSBuaWRcbiAgICAgIGVsc2Uge1xuICAgICAgICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9yZWdpc3Rlcl9nbG9iYWw6IGNhbm5vdCBsb2NhdGUgXCIgKyBuYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY2FtbF9nbG9iYWxfZGF0YVtuICsgMV0gPSB2O1xuICBpZihuYW1lX29wdCkgY2FtbF9nbG9iYWxfZGF0YVtuYW1lX29wdF0gPSB2O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dldF9nbG9iYWxfZGF0YSBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX2dldF9nbG9iYWxfZGF0YSAoKSB7IHJldHVybiBjYW1sX2dsb2JhbF9kYXRhOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaXNfcHJpbnRhYmxlIGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfaXNfcHJpbnRhYmxlKGMpIHsgcmV0dXJuICsoYyA+IDMxICYmIGMgPCAxMjcpOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWF5YmVfcHJpbnRfc3RhdHNcbmZ1bmN0aW9uIGNhbWxfbWF5YmVfcHJpbnRfc3RhdHModW5pdCkgeyByZXR1cm4gMCB9XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vLy8vLy8vLy8vLy8vIFN5c1xuXG4vL1Byb3ZpZGVzOiBjYW1sX3JhaXNlX3N5c19lcnJvciAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3dpdGhfc3RyaW5nLCBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX3JhaXNlX3N5c19lcnJvciAobXNnKSB7XG4gIGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcoY2FtbF9nbG9iYWxfZGF0YS5TeXNfZXJyb3IsIG1zZyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2V4aXRcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9zeXNfZXhpdCAoY29kZSkge1xuICBpZihnbG9iYWxUaGlzLnF1aXQpIGdsb2JhbFRoaXMucXVpdChjb2RlKTtcbiAgLy9ub2RlanNcbiAgaWYoZ2xvYmFsVGhpcy5wcm9jZXNzICYmIGdsb2JhbFRoaXMucHJvY2Vzcy5leGl0KVxuICAgIGdsb2JhbFRoaXMucHJvY2Vzcy5leGl0KGNvZGUpO1xuICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJGdW5jdGlvbiAnZXhpdCcgbm90IGltcGxlbWVudGVkXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lzX3NwZWNpYWxfZXhjZXB0aW9uXG5mdW5jdGlvbiBjYW1sX2lzX3NwZWNpYWxfZXhjZXB0aW9uKGV4bil7XG4gIHN3aXRjaChleG5bMl0pIHtcbiAgY2FzZSAtODogLy8gTWF0Y2hfZmFpbHVyZVxuICBjYXNlIC0xMTogLy8gQXNzZXJ0X2ZhaWx1cmVcbiAgY2FzZSAtMTI6IC8vIFVuZGVmaW5lZF9yZWN1cnNpdmVfbW9kdWxlXG4gICAgcmV0dXJuIDE7XG4gIGRlZmF1bHQ6XG4gICAgcmV0dXJuIDA7XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9mb3JtYXRfZXhjZXB0aW9uXG4vL1JlcXVpcmVzOiBNbEJ5dGVzLCBjYW1sX2lzX3NwZWNpYWxfZXhjZXB0aW9uXG5mdW5jdGlvbiBjYW1sX2Zvcm1hdF9leGNlcHRpb24oZXhuKXtcbiAgdmFyIHIgPSBcIlwiO1xuICBpZihleG5bMF0gPT0gMCkge1xuICAgIHIgKz0gZXhuWzFdWzFdO1xuICAgIGlmKGV4bi5sZW5ndGggPT0gMyAmJiBleG5bMl1bMF0gPT0gMCAmJiBjYW1sX2lzX3NwZWNpYWxfZXhjZXB0aW9uKGV4blsxXSkpIHtcblxuICAgICAgdmFyIGJ1Y2tldCA9IGV4blsyXTtcbiAgICAgIHZhciBzdGFydCA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzdGFydCA9IDJcbiAgICAgIHZhciBidWNrZXQgPSBleG47XG4gICAgfVxuICAgIHIgKz0gXCIoXCI7XG4gICAgZm9yKHZhciBpID0gc3RhcnQ7IGkgPCBidWNrZXQubGVuZ3RoOyBpICsrKXtcbiAgICAgIGlmKGkgPiBzdGFydCkgcis9XCIsIFwiO1xuICAgICAgdmFyIHYgPSBidWNrZXRbaV1cbiAgICAgIGlmKHR5cGVvZiB2ID09IFwibnVtYmVyXCIpXG4gICAgICAgIHIrPSB2LnRvU3RyaW5nKCk7XG4gICAgICBlbHNlIGlmKHYgaW5zdGFuY2VvZiBNbEJ5dGVzKXtcbiAgICAgICAgcis9ICdcIicgKyB2LnRvU3RyaW5nKCkgKyAnXCInO1xuICAgICAgfVxuICAgICAgZWxzZSBpZih0eXBlb2YgdiA9PSBcInN0cmluZ1wiKXtcbiAgICAgICAgcis9ICdcIicgKyB2LnRvU3RyaW5nKCkgKyAnXCInO1xuICAgICAgfVxuICAgICAgZWxzZSByICs9IFwiX1wiO1xuICAgIH1cbiAgICByICs9IFwiKVwiXG4gIH0gZWxzZSBpZiAoZXhuWzBdID09IDI0OCl7XG4gICAgciArPSBleG5bMV1cbiAgfVxuICByZXR1cm4gclxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ZhdGFsX3VuY2F1Z2h0X2V4Y2VwdGlvblxuLy9SZXF1aXJlczogY2FtbF9uYW1lZF92YWx1ZSwgY2FtbF9mb3JtYXRfZXhjZXB0aW9uLCBjYW1sX2NhbGxiYWNrXG5mdW5jdGlvbiBjYW1sX2ZhdGFsX3VuY2F1Z2h0X2V4Y2VwdGlvbihlcnIpe1xuICBpZihlcnIgaW5zdGFuY2VvZiBBcnJheSAmJiAoZXJyWzBdID09IDAgfHwgZXJyWzBdID09IDI0OCkpIHtcbiAgICB2YXIgaGFuZGxlciA9IGNhbWxfbmFtZWRfdmFsdWUoXCJQcmludGV4Yy5oYW5kbGVfdW5jYXVnaHRfZXhjZXB0aW9uXCIpO1xuICAgIGlmKGhhbmRsZXIpIGNhbWxfY2FsbGJhY2soaGFuZGxlciwgW2VycixmYWxzZV0pO1xuICAgIGVsc2Uge1xuICAgICAgdmFyIG1zZyA9IGNhbWxfZm9ybWF0X2V4Y2VwdGlvbihlcnIpO1xuICAgICAgdmFyIGF0X2V4aXQgPSBjYW1sX25hbWVkX3ZhbHVlKFwiUGVydmFzaXZlcy5kb19hdF9leGl0XCIpO1xuICAgICAgaWYoYXRfZXhpdCkgY2FtbF9jYWxsYmFjayhhdF9leGl0LCBbMF0pO1xuICAgICAgY29uc29sZS5lcnJvcihcIkZhdGFsIGVycm9yOiBleGNlcHRpb24gXCIgKyBtc2cpO1xuICAgICAgaWYoZXJyLmpzX2Vycm9yKSB0aHJvdyBlcnIuanNfZXJyb3I7XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIHRocm93IGVyclxuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc2V0X3N0YXRpY19lbnZcbmZ1bmN0aW9uIGNhbWxfc2V0X3N0YXRpY19lbnYoayx2KXtcbiAgaWYoIWdsb2JhbFRoaXMuanNvb19zdGF0aWNfZW52KVxuICAgIGdsb2JhbFRoaXMuanNvb19zdGF0aWNfZW52ID0ge31cbiAgZ2xvYmFsVGhpcy5qc29vX3N0YXRpY19lbnZba10gPSB2O1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczoganNvb19zeXNfZ2V0ZW52IChjb25zdClcbmZ1bmN0aW9uIGpzb29fc3lzX2dldGVudihuKSB7XG4gIHZhciBwcm9jZXNzID0gZ2xvYmFsVGhpcy5wcm9jZXNzO1xuICAvL25vZGVqcyBlbnZcbiAgaWYocHJvY2Vzc1xuICAgICAmJiBwcm9jZXNzLmVudlxuICAgICAmJiBwcm9jZXNzLmVudltuXSAhPSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIHByb2Nlc3MuZW52W25dO1xuICBpZihnbG9iYWxUaGlzLmpzb29fc3RhdGljX2VudlxuICAgICAmJiBnbG9iYWxUaGlzLmpzb29fc3RhdGljX2VudltuXSlcbiAgICByZXR1cm4gZ2xvYmFsVGhpcy5qc29vX3N0YXRpY19lbnZbbl1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfZ2V0ZW52IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfbm90X2ZvdW5kXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbi8vUmVxdWlyZXM6IGpzb29fc3lzX2dldGVudlxuZnVuY3Rpb24gY2FtbF9zeXNfZ2V0ZW52IChuYW1lKSB7XG4gIHZhciByID0ganNvb19zeXNfZ2V0ZW52KGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKG5hbWUpKTtcbiAgaWYociA9PT0gdW5kZWZpbmVkKVxuICAgIGNhbWxfcmFpc2Vfbm90X2ZvdW5kICgpO1xuICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcocilcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfdW5zYWZlX2dldGVudlxuLy9SZXF1aXJlczogY2FtbF9zeXNfZ2V0ZW52XG5mdW5jdGlvbiBjYW1sX3N5c191bnNhZmVfZ2V0ZW52KG5hbWUpe1xuICByZXR1cm4gY2FtbF9zeXNfZ2V0ZW52IChuYW1lKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hcmd2XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZ1xudmFyIGNhbWxfYXJndiA9ICgoZnVuY3Rpb24gKCkge1xuICB2YXIgcHJvY2VzcyA9IGdsb2JhbFRoaXMucHJvY2VzcztcbiAgdmFyIG1haW4gPSBcImEub3V0XCI7XG4gIHZhciBhcmdzID0gW11cblxuICBpZihwcm9jZXNzXG4gICAgICYmIHByb2Nlc3MuYXJndlxuICAgICAmJiBwcm9jZXNzLmFyZ3YubGVuZ3RoID4gMSkge1xuICAgIHZhciBhcmd2ID0gcHJvY2Vzcy5hcmd2XG4gICAgLy9ub2RlanNcbiAgICBtYWluID0gYXJndlsxXTtcbiAgICBhcmdzID0gYXJndi5zbGljZSgyKTtcbiAgfVxuXG4gIHZhciBwID0gY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcobWFpbik7XG4gIHZhciBhcmdzMiA9IFswLCBwXTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspXG4gICAgYXJnczIucHVzaChjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhhcmdzW2ldKSk7XG4gIHJldHVybiBhcmdzMjtcbn0pKCkpXG5cbi8vUHJvdmlkZXM6IGNhbWxfZXhlY3V0YWJsZV9uYW1lXG4vL1JlcXVpcmVzOiBjYW1sX2FyZ3ZcbnZhciBjYW1sX2V4ZWN1dGFibGVfbmFtZSA9IGNhbWxfYXJndlsxXVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19nZXRfYXJndlxuLy9SZXF1aXJlczogY2FtbF9hcmd2XG5mdW5jdGlvbiBjYW1sX3N5c19nZXRfYXJndiAoYSkge1xuICByZXR1cm4gWzAsIGNhbWxfYXJndlsxXSwgY2FtbF9hcmd2XTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfYXJndlxuLy9SZXF1aXJlczogY2FtbF9hcmd2XG5mdW5jdGlvbiBjYW1sX3N5c19hcmd2IChhKSB7XG4gIHJldHVybiBjYW1sX2FyZ3Y7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX21vZGlmeV9hcmd2XG4vL1JlcXVpcmVzOiBjYW1sX2FyZ3ZcbmZ1bmN0aW9uIGNhbWxfc3lzX21vZGlmeV9hcmd2KGFyZyl7XG4gIGNhbWxfYXJndiA9IGFyZztcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2V4ZWN1dGFibGVfbmFtZSBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9leGVjdXRhYmxlX25hbWVcbmZ1bmN0aW9uIGNhbWxfc3lzX2V4ZWN1dGFibGVfbmFtZShhKXtcbiAgcmV0dXJuIGNhbWxfZXhlY3V0YWJsZV9uYW1lXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX3N5c3RlbV9jb21tYW5kXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9zeXNfc3lzdGVtX2NvbW1hbmQoY21kKXtcbiAgdmFyIGNtZCA9IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKGNtZCk7XG4gIGlmICh0eXBlb2YgcmVxdWlyZSAhPSBcInVuZGVmaW5lZFwiKXtcbiAgICB2YXIgY2hpbGRfcHJvY2VzcyA9IHJlcXVpcmUoJ2NoaWxkX3Byb2Nlc3MnKTtcbiAgICBpZihjaGlsZF9wcm9jZXNzICYmIGNoaWxkX3Byb2Nlc3MuZXhlY1N5bmMpXG4gICAgICB0cnkge1xuICAgICAgICBjaGlsZF9wcm9jZXNzLmV4ZWNTeW5jKGNtZCx7c3RkaW86ICdpbmhlcml0J30pO1xuICAgICAgICByZXR1cm4gMFxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gMVxuICAgICAgfVxuICB9XG4gIGVsc2UgcmV0dXJuIDEyNztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfc3lzdGVtX2NvbW1hbmRcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG4vL0lmOiBicm93c2VyXG5mdW5jdGlvbiBjYW1sX3N5c19zeXN0ZW1fY29tbWFuZChjbWQpe1xuICByZXR1cm4gMTI3O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c190aW1lIG11dGFibGVcbnZhciBjYW1sX2luaXRpYWxfdGltZSA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkgKiAwLjAwMTtcbmZ1bmN0aW9uIGNhbWxfc3lzX3RpbWUgKCkge1xuICB2YXIgbm93ID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcbiAgcmV0dXJuIG5vdyAqIDAuMDAxIC0gY2FtbF9pbml0aWFsX3RpbWU7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX3RpbWVfaW5jbHVkZV9jaGlsZHJlblxuLy9SZXF1aXJlczogY2FtbF9zeXNfdGltZVxuZnVuY3Rpb24gY2FtbF9zeXNfdGltZV9pbmNsdWRlX2NoaWxkcmVuKGIpIHtcbiAgcmV0dXJuIGNhbWxfc3lzX3RpbWUoKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfcmFuZG9tX3NlZWQgbXV0YWJsZVxuLy9UaGUgZnVuY3Rpb24gbmVlZHMgdG8gcmV0dXJuIGFuIGFycmF5IHNpbmNlIE9DYW1sIDQuMC4uLlxuZnVuY3Rpb24gY2FtbF9zeXNfcmFuZG9tX3NlZWQgKCkge1xuICBpZiAoZ2xvYmFsVGhpcy5jcnlwdG8pIHtcbiAgICAgaWYgKGdsb2JhbFRoaXMuY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xuICAgICAgIHZhciBhID0gZ2xvYmFsVGhpcy5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBJbnQzMkFycmF5KDQpKTtcbiAgICAgICByZXR1cm4gWzAsIGFbMF0sIGFbMV0sIGFbMl0sIGFbM11dO1xuICAgICB9IGVsc2UgaWYgKGdsb2JhbFRoaXMuY3J5cHRvLnJhbmRvbUJ5dGVzKSB7XG4gICAgICAgdmFyIGEgPSBuZXcgSW50MzJBcnJheShnbG9iYWxUaGlzLmNyeXB0by5yYW5kb21CeXRlcygxNikuYnVmZmVyKTtcbiAgICAgICByZXR1cm4gWzAsIGFbMF0sIGFbMV0sIGFbMl0sIGFbM11dO1xuICAgICB9XG4gIH1cbiAgdmFyIG5vdyA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG4gIHZhciB4ID0gbm93XjB4ZmZmZmZmZmYqTWF0aC5yYW5kb20oKTtcbiAgcmV0dXJuIFswLHhdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jb25zdF9iaWdfZW5kaWFuIGNvbnN0XG5mdW5jdGlvbiBjYW1sX3N5c19jb25zdF9iaWdfZW5kaWFuICgpIHsgcmV0dXJuIDA7IH1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfY29uc3Rfd29yZF9zaXplIGNvbnN0XG5mdW5jdGlvbiBjYW1sX3N5c19jb25zdF93b3JkX3NpemUgKCkgeyByZXR1cm4gMzI7IH1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfY29uc3RfaW50X3NpemUgY29uc3RcbmZ1bmN0aW9uIGNhbWxfc3lzX2NvbnN0X2ludF9zaXplICgpIHsgcmV0dXJuIDMyOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X21heF93b3NpemUgY29uc3Rcbi8vIG1heF9pbnQgLyA0IHNvIHRoYXQgdGhlIGZvbGxvd2luZyBkb2VzIG5vdCBvdmVyZmxvd1xuLy9sZXQgbWF4X3N0cmluZ19sZW5ndGggPSB3b3JkX3NpemUgLyA4ICogbWF4X2FycmF5X2xlbmd0aCAtIDE7O1xuZnVuY3Rpb24gY2FtbF9zeXNfY29uc3RfbWF4X3dvc2l6ZSAoKSB7IHJldHVybiAoMHg3RkZGRkZGRi80KSB8IDA7fVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jb25zdF9vc3R5cGVfdW5peCBjb25zdFxuLy9SZXF1aXJlczogb3NfdHlwZVxuZnVuY3Rpb24gY2FtbF9zeXNfY29uc3Rfb3N0eXBlX3VuaXggKCkgeyByZXR1cm4gb3NfdHlwZSA9PSBcIlVuaXhcIiA/IDEgOiAwOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jb25zdF9vc3R5cGVfd2luMzIgY29uc3Rcbi8vUmVxdWlyZXM6IG9zX3R5cGVcbmZ1bmN0aW9uIGNhbWxfc3lzX2NvbnN0X29zdHlwZV93aW4zMiAoKSB7IHJldHVybiBvc190eXBlID09IFwiV2luMzJcIiA/IDEgOiAwOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jb25zdF9vc3R5cGVfY3lnd2luIGNvbnN0XG4vL1JlcXVpcmVzOiBvc190eXBlXG5mdW5jdGlvbiBjYW1sX3N5c19jb25zdF9vc3R5cGVfY3lnd2luICgpIHsgcmV0dXJuIG9zX3R5cGUgPT0gXCJDeWd3aW5cIiA/IDEgOiAwOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X2JhY2tlbmRfdHlwZSBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9zeXNfY29uc3RfYmFja2VuZF90eXBlICgpIHtcbiAgcmV0dXJuIFswLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKFwianNfb2Zfb2NhbWxcIildO1xufVxuXG4vL1Byb3ZpZGVzOiBvc190eXBlXG52YXIgb3NfdHlwZSA9IChnbG9iYWxUaGlzLnByb2Nlc3MgJiZcbiAgICAgICAgICAgICAgIGdsb2JhbFRoaXMucHJvY2Vzcy5wbGF0Zm9ybSAmJlxuICAgICAgICAgICAgICAgZ2xvYmFsVGhpcy5wcm9jZXNzLnBsYXRmb3JtID09IFwid2luMzJcIikgPyBcIkN5Z3dpblwiIDogXCJVbml4XCI7XG5cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfZ2V0X2NvbmZpZyBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlcywgb3NfdHlwZVxuZnVuY3Rpb24gY2FtbF9zeXNfZ2V0X2NvbmZpZyAoKSB7XG4gIHJldHVybiBbMCwgY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhvc190eXBlKSwgMzIsIDBdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19pc2F0dHlcbmZ1bmN0aW9uIGNhbWxfc3lzX2lzYXR0eShfY2hhbikge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ydW50aW1lX3ZhcmlhbnRcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfcnVudGltZV92YXJpYW50KF91bml0KSB7XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKFwiXCIpO1xufVxuLy9Qcm92aWRlczogY2FtbF9ydW50aW1lX3BhcmFtZXRlcnNcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfcnVudGltZV9wYXJhbWV0ZXJzKF91bml0KSB7XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKFwiXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2luc3RhbGxfc2lnbmFsX2hhbmRsZXIgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW5zdGFsbF9zaWduYWxfaGFuZGxlcigpe3JldHVybiAwfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3J1bnRpbWVfd2FybmluZ3NcbnZhciBjYW1sX3J1bnRpbWVfd2FybmluZ3MgPSAwO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2VuYWJsZV9ydW50aW1lX3dhcm5pbmdzXG4vL1JlcXVpcmVzOiBjYW1sX3J1bnRpbWVfd2FybmluZ3NcbmZ1bmN0aW9uIGNhbWxfbWxfZW5hYmxlX3J1bnRpbWVfd2FybmluZ3MgKGJvb2wpIHtcbiAgY2FtbF9ydW50aW1lX3dhcm5pbmdzID0gYm9vbDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfcnVudGltZV93YXJuaW5nc19lbmFibGVkXG4vL1JlcXVpcmVzOiBjYW1sX3J1bnRpbWVfd2FybmluZ3NcbmZ1bmN0aW9uIGNhbWxfbWxfcnVudGltZV93YXJuaW5nc19lbmFibGVkIChfdW5pdCkge1xuICByZXR1cm4gY2FtbF9ydW50aW1lX3dhcm5pbmdzO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfc3BhY2V0aW1lX2VuYWJsZWQgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9zcGFjZXRpbWVfZW5hYmxlZChfdW5pdCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfY29uc3RfbmFrZWRfcG9pbnRlcnNfY2hlY2tlZCBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX3N5c19jb25zdF9uYWtlZF9wb2ludGVyc19jaGVja2VkKF91bml0KSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JlZ2lzdGVyX2NoYW5uZWxfZm9yX3NwYWNldGltZSBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX3JlZ2lzdGVyX2NoYW5uZWxfZm9yX3NwYWNldGltZShfY2hhbm5lbCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zcGFjZXRpbWVfb25seV93b3Jrc19mb3JfbmF0aXZlX2NvZGVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfc3BhY2V0aW1lX29ubHlfd29ya3NfZm9yX25hdGl2ZV9jb2RlKCkge1xuICBjYW1sX2ZhaWx3aXRoKFwiU3BhY2V0aW1lIHByb2ZpbGluZyBvbmx5IHdvcmtzIGZvciBuYXRpdmUgY29kZVwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF94ZGdfZGVmYXVsdHNcbi8vVmVyc2lvbjogPj0gNS4yXG5mdW5jdGlvbiBjYW1sX3hkZ19kZWZhdWx0cyhfdW5pdCkge1xuICByZXR1cm4gMDsgLy8gZW1wdHkgbGlzdFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19pc19yZWd1bGFyX2ZpbGVcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlXG5mdW5jdGlvbiBjYW1sX3N5c19pc19yZWd1bGFyX2ZpbGUobmFtZSkge1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICByZXR1cm4gcm9vdC5kZXZpY2UuaXNGaWxlKHJvb3QucmVzdCk7XG59XG4vL0Fsd2F5c1xuLy9SZXF1aXJlczogY2FtbF9mYXRhbF91bmNhdWdodF9leGNlcHRpb25cbmZ1bmN0aW9uIGNhbWxfc2V0dXBfdW5jYXVnaHRfZXhjZXB0aW9uX2hhbmRsZXIoKSB7XG4gIHZhciBwcm9jZXNzID0gZ2xvYmFsVGhpcy5wcm9jZXNzO1xuICBpZihwcm9jZXNzICYmIHByb2Nlc3Mub24pIHtcbiAgICBwcm9jZXNzLm9uKCd1bmNhdWdodEV4Y2VwdGlvbicsIGZ1bmN0aW9uIChlcnIsIG9yaWdpbikge1xuICAgICAgY2FtbF9mYXRhbF91bmNhdWdodF9leGNlcHRpb24oZXJyKTtcbiAgICAgIHByb2Nlc3MuZXhpdCAoMik7XG4gICAgfSlcbiAgfVxuICBlbHNlIGlmKGdsb2JhbFRoaXMuYWRkRXZlbnRMaXN0ZW5lcil7XG4gICAgZ2xvYmFsVGhpcy5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGZ1bmN0aW9uKGV2ZW50KXtcbiAgICAgIGlmKGV2ZW50LmVycm9yKXtcbiAgICAgICAgY2FtbF9mYXRhbF91bmNhdWdodF9leGNlcHRpb24oZXZlbnQuZXJyb3IpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5jYW1sX3NldHVwX3VuY2F1Z2h0X2V4Y2VwdGlvbl9oYW5kbGVyKCk7XG5cblxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JlY29yZF9iYWNrdHJhY2VfZmxhZ1xuLy9SZXF1aXJlczoganNvb19zeXNfZ2V0ZW52XG52YXIgY2FtbF9yZWNvcmRfYmFja3RyYWNlX2ZsYWcgPSBGTEFHKFwid2l0aC1qcy1lcnJvclwiKTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHIgPSBqc29vX3N5c19nZXRlbnYoXCJPQ0FNTFJVTlBBUkFNXCIpXG4gIGlmKHIgIT09IHVuZGVmaW5lZCl7XG4gICAgdmFyIGwgPSByLnNwbGl0KFwiLFwiKTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbC5sZW5ndGg7IGkrKyl7XG4gICAgICBpZihsW2ldID09IFwiYlwiKSB7IGNhbWxfcmVjb3JkX2JhY2t0cmFjZV9mbGFnID0gMTsgYnJlYWsgfVxuICAgICAgZWxzZSBpZiAobFtpXS5zdGFydHNXaXRoKFwiYj1cIikpIHtcbiAgICAgICAgY2FtbF9yZWNvcmRfYmFja3RyYWNlX2ZsYWcgPSArKGxbaV0uc2xpY2UoMikpfVxuICAgICAgZWxzZSBjb250aW51ZTtcbiAgICB9XG4gIH1cbn0pICgpXG5cblxuLy9Qcm92aWRlczogY2FtbF9tbF9kZWJ1Z19pbmZvX3N0YXR1cyBjb25zdFxuZnVuY3Rpb24gY2FtbF9tbF9kZWJ1Z19pbmZvX3N0YXR1cyAoKSB7IHJldHVybiAwOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2JhY2t0cmFjZV9zdGF0dXNcbi8vUmVxdWlyZXM6IGNhbWxfcmVjb3JkX2JhY2t0cmFjZV9mbGFnXG5mdW5jdGlvbiBjYW1sX2JhY2t0cmFjZV9zdGF0dXMgKF91bml0KSB7IHJldHVybiBjYW1sX3JlY29yZF9iYWNrdHJhY2VfZmxhZyA/IDEgOiAwOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2dldF9leGNlcHRpb25fYmFja3RyYWNlIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2dldF9leGNlcHRpb25fYmFja3RyYWNlICgpIHsgcmV0dXJuIDA7IH1cbi8vUHJvdmlkZXM6IGNhbWxfZ2V0X2V4Y2VwdGlvbl9yYXdfYmFja3RyYWNlIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2dldF9leGNlcHRpb25fcmF3X2JhY2t0cmFjZSAoKSB7IHJldHVybiBbMF07IH1cbi8vUHJvdmlkZXM6IGNhbWxfcmVjb3JkX2JhY2t0cmFjZVxuLy9SZXF1aXJlczogY2FtbF9yZWNvcmRfYmFja3RyYWNlX2ZsYWdcbmZ1bmN0aW9uIGNhbWxfcmVjb3JkX2JhY2t0cmFjZSAoYikgeyBjYW1sX3JlY29yZF9iYWNrdHJhY2VfZmxhZyA9IGI7IHJldHVybiAwOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2NvbnZlcnRfcmF3X2JhY2t0cmFjZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9jb252ZXJ0X3Jhd19iYWNrdHJhY2UgKCkgeyByZXR1cm4gWzBdOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX3Jhd19iYWNrdHJhY2VfbGVuZ3RoXG5mdW5jdGlvbiBjYW1sX3Jhd19iYWNrdHJhY2VfbGVuZ3RoKCkgeyByZXR1cm4gMDsgfVxuLy9Qcm92aWRlczogY2FtbF9yYXdfYmFja3RyYWNlX25leHRfc2xvdFxuZnVuY3Rpb24gY2FtbF9yYXdfYmFja3RyYWNlX25leHRfc2xvdCgpIHsgcmV0dXJuIDAgfVxuLy9Qcm92aWRlczogY2FtbF9yYXdfYmFja3RyYWNlX3Nsb3Rcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9yYXdfYmFja3RyYWNlX3Nsb3QgKCkge1xuICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJQcmludGV4Yy5nZXRfcmF3X2JhY2t0cmFjZV9zbG90OiBpbmRleCBvdXQgb2YgYm91bmRzXCIpO1xufVxuLy9Qcm92aWRlczogY2FtbF9yZXN0b3JlX3Jhd19iYWNrdHJhY2VcbmZ1bmN0aW9uIGNhbWxfcmVzdG9yZV9yYXdfYmFja3RyYWNlKGV4biwgYnQpIHsgcmV0dXJuIDAgfVxuLy9Qcm92aWRlczogY2FtbF9nZXRfY3VycmVudF9jYWxsc3RhY2sgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZ2V0X2N1cnJlbnRfY2FsbHN0YWNrICgpIHsgcmV0dXJuIFswXTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvbnZlcnRfcmF3X2JhY2t0cmFjZV9zbG90XG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2NvbnZlcnRfcmF3X2JhY2t0cmFjZV9zbG90KCl7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX2NvbnZlcnRfcmF3X2JhY2t0cmFjZV9zbG90XCIpO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgbGlicmFyeVxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxMCBKw6lyw7RtZSBWb3VpbGxvblxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vLy8vLy8vLy8vLy8vIEpzbGliXG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfcHVyZV9leHByIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2NhbGxiYWNrXG5mdW5jdGlvbiBjYW1sX2pzX3B1cmVfZXhwciAoZikgeyByZXR1cm4gY2FtbF9jYWxsYmFjayhmLCBbMF0pOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfc2V0IChtdXRhYmxlLCBjb25zdCwgbXV0YWJsZSlcbmZ1bmN0aW9uIGNhbWxfanNfc2V0KG8sZix2KSB7IG9bZl09djtyZXR1cm4gMH1cbi8vUHJvdmlkZXM6IGNhbWxfanNfZ2V0IChtdXRhYmxlLCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfZ2V0KG8sZikgeyByZXR1cm4gb1tmXTsgfVxuLy9Qcm92aWRlczogY2FtbF9qc19kZWxldGUgKG11dGFibGUsIGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc19kZWxldGUobyxmKSB7IGRlbGV0ZSBvW2ZdOyByZXR1cm4gMH1cblxuLy9Qcm92aWRlczogY2FtbF9qc19pbnN0YW5jZW9mIChjb25zdCwgY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX2luc3RhbmNlb2YobyxjKSB7IHJldHVybiAobyBpbnN0YW5jZW9mIGMpID8gMSA6IDA7IH1cblxuLy9Qcm92aWRlczogY2FtbF9qc190eXBlb2YgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc190eXBlb2YobykgeyByZXR1cm4gdHlwZW9mIG87IH1cblxuLy9Qcm92aWRlczpjYW1sX3RyYW1wb2xpbmVcbmZ1bmN0aW9uIGNhbWxfdHJhbXBvbGluZShyZXMpIHtcbiAgdmFyIGMgPSAxO1xuICB3aGlsZShyZXMgJiYgcmVzLmpvb190cmFtcCl7XG4gICAgcmVzID0gcmVzLmpvb190cmFtcC5hcHBseShudWxsLCByZXMuam9vX2FyZ3MpO1xuICAgIGMrKztcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG4vL1Byb3ZpZGVzOmNhbWxfdHJhbXBvbGluZV9yZXR1cm5cbmZ1bmN0aW9uIGNhbWxfdHJhbXBvbGluZV9yZXR1cm4oZixhcmdzKSB7XG4gIHJldHVybiB7am9vX3RyYW1wOmYsam9vX2FyZ3M6YXJnc307XG59XG5cbi8vUHJvdmlkZXM6Y2FtbF9zdGFja19kZXB0aFxuLy9JZjogZWZmZWN0c1xudmFyIGNhbWxfc3RhY2tfZGVwdGggPSAwO1xuXG4vL1Byb3ZpZGVzOmNhbWxfc3RhY2tfY2hlY2tfZGVwdGhcbi8vSWY6IGVmZmVjdHNcbi8vUmVxdWlyZXM6Y2FtbF9zdGFja19kZXB0aFxuZnVuY3Rpb24gY2FtbF9zdGFja19jaGVja19kZXB0aCgpIHtcbiAgICByZXR1cm4gLS1jYW1sX3N0YWNrX2RlcHRoID4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jYWxsYmFja1xuLy9JZjogIWVmZmVjdHNcbi8vUmVxdWlyZXM6Y2FtbF9jYWxsX2dlblxudmFyIGNhbWxfY2FsbGJhY2sgPSBjYW1sX2NhbGxfZ2VuO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2NhbGxiYWNrXG4vL0lmOiBlZmZlY3RzXG4vL1JlcXVpcmVzOmNhbWxfc3RhY2tfZGVwdGgsIGNhbWxfY2FsbF9nZW4sIGNhbWxfZXhuX3N0YWNrLCBjYW1sX2ZpYmVyX3N0YWNrLCBjYW1sX3dyYXBfZXhjZXB0aW9uLCBjYW1sX3Jlc3VtZV9zdGFjaywgY2FtbF9mcmVzaF9vb19pZCwgY2FtbF9uYW1lZF92YWx1ZSwgY2FtbF9yYWlzZV93aXRoX2FyZywgY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9jb25zdGFudFxuZnVuY3Rpb24gY2FtbF9jYWxsYmFjayhmLGFyZ3MpIHtcbiAgZnVuY3Rpb24gdW5jYXVnaHRfZWZmZWN0X2hhbmRsZXIoZWZmLGssbXMpIHtcbiAgICAvLyBSZXN1bWVzIHRoZSBjb250aW51YXRpb24gayBieSByYWlzaW5nIGV4Y2VwdGlvbiBVbmhhbmRsZWQuXG4gICAgY2FtbF9yZXN1bWVfc3RhY2soa1sxXSxtcyk7XG4gICAgdmFyIGV4biA9IGNhbWxfbmFtZWRfdmFsdWUoXCJFZmZlY3QuVW5oYW5kbGVkXCIpO1xuICAgIGlmKGV4bikgY2FtbF9yYWlzZV93aXRoX2FyZyhleG4sIGVmZik7XG4gICAgZWxzZSB7XG4gICAgICBleG4gPSBbMjQ4LGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoXCJFZmZlY3QuVW5oYW5kbGVkXCIpLCBjYW1sX2ZyZXNoX29vX2lkKDApXTtcbiAgICAgIGNhbWxfcmFpc2VfY29uc3RhbnQoZXhuKTtcbiAgICB9XG4gIH1cbiAgdmFyIHNhdmVkX3N0YWNrX2RlcHRoID0gY2FtbF9zdGFja19kZXB0aDtcbiAgdmFyIHNhdmVkX2V4bl9zdGFjayA9IGNhbWxfZXhuX3N0YWNrO1xuICB2YXIgc2F2ZWRfZmliZXJfc3RhY2sgPSBjYW1sX2ZpYmVyX3N0YWNrO1xuICB0cnkge1xuICAgIGNhbWxfZXhuX3N0YWNrID0gMDtcbiAgICBjYW1sX2ZpYmVyX3N0YWNrID1cbiAgICAgIHtoOlswLCAwLCAwLCB1bmNhdWdodF9lZmZlY3RfaGFuZGxlcl0sIHI6e2s6MCwgeDowLCBlOjB9fTtcbiAgICB2YXIgcmVzID0ge2pvb190cmFtcDogZixcbiAgICAgICAgICAgICAgIGpvb19hcmdzOiBhcmdzLmNvbmNhdChmdW5jdGlvbiAoeCl7cmV0dXJuIHg7fSl9O1xuICAgIGRvIHtcbiAgICAgIGNhbWxfc3RhY2tfZGVwdGggPSA0MDtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlcyA9IGNhbWxfY2FsbF9nZW4ocmVzLmpvb190cmFtcCwgcmVzLmpvb19hcmdzKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLyogSGFuZGxlIGV4Y2VwdGlvbiBjb21pbmcgZnJvbSBKYXZhU2NyaXB0IG9yIGZyb20gdGhlIHJ1bnRpbWUuICovXG4gICAgICAgIGlmICghY2FtbF9leG5fc3RhY2spIHRocm93IGU7XG4gICAgICAgIHZhciBoYW5kbGVyID0gY2FtbF9leG5fc3RhY2tbMV07XG4gICAgICAgIGNhbWxfZXhuX3N0YWNrID0gY2FtbF9leG5fc3RhY2tbMl07XG4gICAgICAgIHJlcyA9IHtqb29fdHJhbXA6IGhhbmRsZXIsXG4gICAgICAgICAgICAgICBqb29fYXJnczogW2NhbWxfd3JhcF9leGNlcHRpb24oZSldfTtcbiAgICAgIH1cbiAgICB9IHdoaWxlKHJlcyAmJiByZXMuam9vX2FyZ3MpXG4gIH0gZmluYWxseSB7XG4gICAgY2FtbF9zdGFja19kZXB0aCA9IHNhdmVkX3N0YWNrX2RlcHRoO1xuICAgIGNhbWxfZXhuX3N0YWNrID0gc2F2ZWRfZXhuX3N0YWNrO1xuICAgIGNhbWxfZmliZXJfc3RhY2sgPSBzYXZlZF9maWJlcl9zdGFjaztcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lzX2pzXG5mdW5jdGlvbiBjYW1sX2lzX2pzKCkge1xuICByZXR1cm4gMTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9qc29vX2ZsYWdzX3VzZV9qc19zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfanNvb19mbGFnc191c2VfanNfc3RyaW5nKHVuaXQpe1xuICByZXR1cm4gRkxBRyhcInVzZS1qcy1zdHJpbmdcIilcbn1cblxuLy9Qcm92aWRlczogY2FtbF9qc29vX2ZsYWdzX2VmZmVjdHNcbmZ1bmN0aW9uIGNhbWxfanNvb19mbGFnc19lZmZlY3RzKHVuaXQpe1xuICByZXR1cm4gRkxBRyhcImVmZmVjdHNcIilcbn1cblxuLy9Qcm92aWRlczogY2FtbF93cmFwX2V4Y2VwdGlvbiBjb25zdCAobXV0YWJsZSlcbi8vUmVxdWlyZXM6IGNhbWxfZ2xvYmFsX2RhdGEsY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcsY2FtbF9uYW1lZF92YWx1ZVxuZnVuY3Rpb24gY2FtbF93cmFwX2V4Y2VwdGlvbihlKSB7XG4gIGlmIChGTEFHKFwiZXhjd3JhcFwiKSkge1xuICAgIGlmKGUgaW5zdGFuY2VvZiBBcnJheSkgcmV0dXJuIGU7XG4gICAgdmFyIGV4bjtcbiAgICAvL1N0YWNrX292ZXJmbG93OiBjaHJvbWUsIHNhZmFyaVxuICAgIGlmKGdsb2JhbFRoaXMuUmFuZ2VFcnJvclxuICAgICAgICYmIGUgaW5zdGFuY2VvZiBnbG9iYWxUaGlzLlJhbmdlRXJyb3JcbiAgICAgICAmJiBlLm1lc3NhZ2VcbiAgICAgICAmJiBlLm1lc3NhZ2UubWF0Y2goL21heGltdW0gY2FsbCBzdGFjay9pKSlcbiAgICAgIGV4biA9IGNhbWxfZ2xvYmFsX2RhdGEuU3RhY2tfb3ZlcmZsb3c7XG4gICAgLy9TdGFja19vdmVyZmxvdzogZmlyZWZveFxuICAgIGVsc2UgaWYoZ2xvYmFsVGhpcy5JbnRlcm5hbEVycm9yXG4gICAgICAgJiYgZSBpbnN0YW5jZW9mIGdsb2JhbFRoaXMuSW50ZXJuYWxFcnJvclxuICAgICAgICYmIGUubWVzc2FnZVxuICAgICAgICYmIGUubWVzc2FnZS5tYXRjaCgvdG9vIG11Y2ggcmVjdXJzaW9uL2kpKVxuICAgICAgZXhuID0gY2FtbF9nbG9iYWxfZGF0YS5TdGFja19vdmVyZmxvdztcbiAgICAvL1dyYXAgRXJyb3IgaW4gSnMuRXJyb3IgZXhjZXB0aW9uXG4gICAgZWxzZSBpZihlIGluc3RhbmNlb2YgZ2xvYmFsVGhpcy5FcnJvciAmJiBjYW1sX25hbWVkX3ZhbHVlKFwianNFcnJvclwiKSlcbiAgICAgIGV4biA9IFswLGNhbWxfbmFtZWRfdmFsdWUoXCJqc0Vycm9yXCIpLGVdO1xuICAgIGVsc2VcbiAgICAgIC8vZmFsbGJhY2s6IHdyYXBwZWQgaW4gRmFpbHVyZVxuICAgICAgZXhuID0gWzAsY2FtbF9nbG9iYWxfZGF0YS5GYWlsdXJlLGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nIChTdHJpbmcoZSkpXTtcbiAgICAvLyBXZSBhbHJlYWR5IGhhdmUgYW4gZXJyb3IgYXQgaGFuZCwgbGV0J3MgdXNlIGl0LlxuICAgIGlmIChlIGluc3RhbmNlb2YgZ2xvYmFsVGhpcy5FcnJvcilcbiAgICAgIGV4bi5qc19lcnJvciA9IGU7XG4gICAgcmV0dXJuIGV4bjtcbiAgfSBlbHNlXG4gICAgcmV0dXJuIGU7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZVxuLy9SZXF1aXJlczogY2FtbF9leG5fd2l0aF9qc19iYWNrdHJhY2Vcbi8vUmVxdWlyZXM6IGNhbWxfcmVjb3JkX2JhY2t0cmFjZV9mbGFnXG5mdW5jdGlvbiBjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UoZXhuLCBmb3JjZSkge1xuICBpZihjYW1sX3JlY29yZF9iYWNrdHJhY2VfZmxhZylcbiAgICByZXR1cm4gY2FtbF9leG5fd2l0aF9qc19iYWNrdHJhY2UoZXhuLCBmb3JjZSk7XG4gIGVsc2UgcmV0dXJuIGV4blxufVxuXG4vLyBFeHBlcmltZW50YWxcbi8vUHJvdmlkZXM6IGNhbWxfZXhuX3dpdGhfanNfYmFja3RyYWNlXG4vL1JlcXVpcmVzOiBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX2V4bl93aXRoX2pzX2JhY2t0cmFjZShleG4sIGZvcmNlKSB7XG4gIC8vbmV2ZXIgcmVyYWlzZSBmb3IgY29uc3RhbnQgZXhuXG4gIGlmKCFleG4uanNfZXJyb3IgfHwgZm9yY2UgfHwgZXhuWzBdID09IDI0OCkgZXhuLmpzX2Vycm9yID0gbmV3IGdsb2JhbFRoaXMuRXJyb3IoXCJKcyBleGNlcHRpb24gY29udGFpbmluZyBiYWNrdHJhY2VcIik7XG4gIHJldHVybiBleG47XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9qc19lcnJvcl9vcHRpb25fb2ZfZXhjZXB0aW9uXG5mdW5jdGlvbiBjYW1sX2pzX2Vycm9yX29wdGlvbl9vZl9leGNlcHRpb24oZXhuKSB7XG4gIGlmKGV4bi5qc19lcnJvcikgeyByZXR1cm4gWzAsIGV4bi5qc19lcnJvcl07IH1cbiAgcmV0dXJuIDA7XG59XG5cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2Zyb21fYm9vbCBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX2Zyb21fYm9vbCh4KSB7IHJldHVybiAhIXg7IH1cbi8vUHJvdmlkZXM6IGNhbWxfanNfdG9fYm9vbCBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX3RvX2Jvb2woeCkgeyByZXR1cm4gK3g7IH1cbi8vUHJvdmlkZXM6IGNhbWxfanNfZnJvbV9mbG9hdCBjb25zdCAoY29uc3QpXG4vL0FsaWFzOiBjYW1sX2pzX2Zyb21faW50MzJcbi8vQWxpYXM6IGNhbWxfanNfZnJvbV9uYXRpdmVpbnRcbmZ1bmN0aW9uIGNhbWxfanNfZnJvbV9mbG9hdCh4KSB7IHJldHVybiB4OyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3RvX2Zsb2F0IGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfdG9fZmxvYXQoeCkgeyByZXR1cm4geDsgfVxuLy9Qcm92aWRlczogY2FtbF9qc190b19pbnQzMiBjb25zdCAoY29uc3QpXG4vL0FsaWFzOiBjYW1sX2pzX3RvX25hdGl2ZWludFxuZnVuY3Rpb24gY2FtbF9qc190b19pbnQzMih4KSB7IHJldHVybiB4fDA7IH1cblxuLy9Qcm92aWRlczogY2FtbF9qc19mcm9tX2FycmF5IG11dGFibGUgKHNoYWxsb3cpXG5mdW5jdGlvbiBjYW1sX2pzX2Zyb21fYXJyYXkoYSkge1xuICByZXR1cm4gYS5zbGljZSgxKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfdG9fYXJyYXkgbXV0YWJsZSAoc2hhbGxvdylcbmZ1bmN0aW9uIGNhbWxfanNfdG9fYXJyYXkoYSkge1xuICB2YXIgbGVuID0gYS5sZW5ndGg7XG4gIHZhciBiID0gbmV3IEFycmF5KGxlbisxKTtcbiAgYlswXSA9IDA7XG4gIGZvcih2YXIgaT0wO2k8bGVuO2krKykgYltpKzFdID0gYVtpXTtcbiAgcmV0dXJuIGI7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbGlzdF9vZl9qc19hcnJheSBjb25zdCAobXV0YWJsZSlcbmZ1bmN0aW9uIGNhbWxfbGlzdF9vZl9qc19hcnJheShhKXtcbiAgdmFyIGwgPSAwO1xuICBmb3IodmFyIGk9YS5sZW5ndGggLSAxOyBpPj0wOyBpLS0pe1xuICAgIHZhciBlID0gYVtpXTtcbiAgICBsID0gWzAsZSxsXTtcbiAgfVxuICByZXR1cm4gbFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2xpc3RfdG9fanNfYXJyYXkgY29uc3QgKG11dGFibGUpXG5mdW5jdGlvbiBjYW1sX2xpc3RfdG9fanNfYXJyYXkobCl7XG4gIHZhciBhID0gW107XG4gIGZvcig7IGwgIT09IDA7IGwgPSBsWzJdKSB7XG4gICAgYS5wdXNoKGxbMV0pO1xuICB9XG4gIHJldHVybiBhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3ZhciBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc192YXIoeCkge1xuICB2YXIgeCA9IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHgpO1xuICAvL0NoZWNrcyB0aGF0IHggaGFzIHRoZSBmb3JtIGlkZW50Wy5pZGVudF0qXG4gIGlmKCF4Lm1hdGNoKC9eW2EtekEtWl8kXVthLXpBLVpfJDAtOV0qKFxcLlthLXpBLVpfJF1bYS16QS1aXyQwLTldKikqJC8pKXtcbiAgICBjb25zb2xlLmVycm9yKFwiY2FtbF9qc192YXI6IFxcXCJcIiArIHggKyBcIlxcXCIgaXMgbm90IGEgdmFsaWQgSmF2YVNjcmlwdCB2YXJpYWJsZS4gY29udGludWluZyAuLlwiKTtcbiAgICAvL2NvbnNvbGUuZXJyb3IoXCJKcy5VbnNhZmUuZXZhbF9zdHJpbmdcIilcbiAgfVxuICByZXR1cm4gZXZhbCh4KTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfY2FsbCAoY29uc3QsIG11dGFibGUsIHNoYWxsb3cpXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfanNfY2FsbChmLCBvLCBhcmdzKSB7IHJldHVybiBmLmFwcGx5KG8sIGNhbWxfanNfZnJvbV9hcnJheShhcmdzKSk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfanNfZnVuX2NhbGwgKGNvbnN0LCBzaGFsbG93KVxuLy9SZXF1aXJlczogY2FtbF9qc19mcm9tX2FycmF5XG5mdW5jdGlvbiBjYW1sX2pzX2Z1bl9jYWxsKGYsIGEpIHtcbiAgc3dpdGNoIChhLmxlbmd0aCkge1xuICBjYXNlIDE6IHJldHVybiBmKCk7XG4gIGNhc2UgMjogcmV0dXJuIGYgKGFbMV0pO1xuICBjYXNlIDM6IHJldHVybiBmIChhWzFdLGFbMl0pO1xuICBjYXNlIDQ6IHJldHVybiBmIChhWzFdLGFbMl0sYVszXSk7XG4gIGNhc2UgNTogcmV0dXJuIGYgKGFbMV0sYVsyXSxhWzNdLGFbNF0pO1xuICBjYXNlIDY6IHJldHVybiBmIChhWzFdLGFbMl0sYVszXSxhWzRdLGFbNV0pO1xuICBjYXNlIDc6IHJldHVybiBmIChhWzFdLGFbMl0sYVszXSxhWzRdLGFbNV0sYVs2XSk7XG4gIGNhc2UgODogcmV0dXJuIGYgKGFbMV0sYVsyXSxhWzNdLGFbNF0sYVs1XSxhWzZdLGFbN10pO1xuICB9XG4gIHJldHVybiBmLmFwcGx5KG51bGwsIGNhbWxfanNfZnJvbV9hcnJheShhKSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX21ldGhfY2FsbCAobXV0YWJsZSwgY29uc3QsIHNoYWxsb3cpXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9qc19mcm9tX2FycmF5XG5mdW5jdGlvbiBjYW1sX2pzX21ldGhfY2FsbChvLCBmLCBhcmdzKSB7XG4gIHJldHVybiBvW2NhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKGYpXS5hcHBseShvLCBjYW1sX2pzX2Zyb21fYXJyYXkoYXJncykpO1xufVxuLy9Qcm92aWRlczogY2FtbF9qc19uZXcgKGNvbnN0LCBzaGFsbG93KVxuLy9SZXF1aXJlczogY2FtbF9qc19mcm9tX2FycmF5XG5mdW5jdGlvbiBjYW1sX2pzX25ldyhjLCBhKSB7XG4gIHN3aXRjaCAoYS5sZW5ndGgpIHtcbiAgY2FzZSAxOiByZXR1cm4gbmV3IGM7XG4gIGNhc2UgMjogcmV0dXJuIG5ldyBjIChhWzFdKTtcbiAgY2FzZSAzOiByZXR1cm4gbmV3IGMgKGFbMV0sYVsyXSk7XG4gIGNhc2UgNDogcmV0dXJuIG5ldyBjIChhWzFdLGFbMl0sYVszXSk7XG4gIGNhc2UgNTogcmV0dXJuIG5ldyBjIChhWzFdLGFbMl0sYVszXSxhWzRdKTtcbiAgY2FzZSA2OiByZXR1cm4gbmV3IGMgKGFbMV0sYVsyXSxhWzNdLGFbNF0sYVs1XSk7XG4gIGNhc2UgNzogcmV0dXJuIG5ldyBjIChhWzFdLGFbMl0sYVszXSxhWzRdLGFbNV0sYVs2XSk7XG4gIGNhc2UgODogcmV0dXJuIG5ldyBjIChhWzFdLGFbMl0sYVszXSxhWzRdLGFbNV0sYVs2XSxhWzddKTtcbiAgfVxuICBmdW5jdGlvbiBGKCkgeyByZXR1cm4gYy5hcHBseSh0aGlzLCBjYW1sX2pzX2Zyb21fYXJyYXkoYSkpOyB9XG4gIEYucHJvdG90eXBlID0gYy5wcm90b3R5cGU7XG4gIHJldHVybiBuZXcgRjtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfb2pzX25ld19hcnIgKGNvbnN0LCBzaGFsbG93KVxuLy9SZXF1aXJlczogY2FtbF9qc19mcm9tX2FycmF5XG5mdW5jdGlvbiBjYW1sX29qc19uZXdfYXJyKGMsIGEpIHtcbiAgc3dpdGNoIChhLmxlbmd0aCkge1xuICBjYXNlIDA6IHJldHVybiBuZXcgYztcbiAgY2FzZSAxOiByZXR1cm4gbmV3IGMgKGFbMF0pO1xuICBjYXNlIDI6IHJldHVybiBuZXcgYyAoYVswXSxhWzFdKTtcbiAgY2FzZSAzOiByZXR1cm4gbmV3IGMgKGFbMF0sYVsxXSxhWzJdKTtcbiAgY2FzZSA0OiByZXR1cm4gbmV3IGMgKGFbMF0sYVsxXSxhWzJdLGFbM10pO1xuICBjYXNlIDU6IHJldHVybiBuZXcgYyAoYVswXSxhWzFdLGFbMl0sYVszXSxhWzRdKTtcbiAgY2FzZSA2OiByZXR1cm4gbmV3IGMgKGFbMF0sYVsxXSxhWzJdLGFbM10sYVs0XSxhWzVdKTtcbiAgY2FzZSA3OiByZXR1cm4gbmV3IGMgKGFbMF0sYVsxXSxhWzJdLGFbM10sYVs0XSxhWzVdLGFbNl0pO1xuICB9XG4gIGZ1bmN0aW9uIEYoKSB7IHJldHVybiBjLmFwcGx5KHRoaXMsIGEpOyB9XG4gIEYucHJvdG90eXBlID0gYy5wcm90b3R5cGU7XG4gIHJldHVybiBuZXcgRjtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfd3JhcF9jYWxsYmFjayBjb25zdCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NhbGxiYWNrXG5mdW5jdGlvbiBjYW1sX2pzX3dyYXBfY2FsbGJhY2soZikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGlmKGxlbiA+IDApe1xuICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkobGVuKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGFyZ3MgPSBbdW5kZWZpbmVkXTtcbiAgICB9XG4gICAgdmFyIHJlcyA9IGNhbWxfY2FsbGJhY2soZiwgYXJncyk7XG4gICAgcmV0dXJuIChyZXMgaW5zdGFuY2VvZiBGdW5jdGlvbik/Y2FtbF9qc193cmFwX2NhbGxiYWNrKHJlcyk6cmVzO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfd3JhcF9jYWxsYmFja19hcmd1bWVudHNcbi8vUmVxdWlyZXM6IGNhbWxfY2FsbGJhY2tcbmZ1bmN0aW9uIGNhbWxfanNfd3JhcF9jYWxsYmFja19hcmd1bWVudHMoZikge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkobGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIHJldHVybiBjYW1sX2NhbGxiYWNrKGYsIFthcmdzXSk7XG4gIH1cbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfd3JhcF9jYWxsYmFja19zdHJpY3QgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfY2FsbGJhY2tcbmZ1bmN0aW9uIGNhbWxfanNfd3JhcF9jYWxsYmFja19zdHJpY3QoYXJpdHksIGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJpdHkpO1xuICAgIHZhciBsZW4gPSBNYXRoLm1pbihhcmd1bWVudHMubGVuZ3RoLCBhcml0eSlcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIHJldHVybiBjYW1sX2NhbGxiYWNrKGYsIGFyZ3MpO1xuICB9O1xufVxuLy9Qcm92aWRlczogY2FtbF9qc193cmFwX2NhbGxiYWNrX3Vuc2FmZSBjb25zdCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NhbGxiYWNrLCBjYW1sX2pzX2Z1bmN0aW9uX2FyaXR5XG5mdW5jdGlvbiBjYW1sX2pzX3dyYXBfY2FsbGJhY2tfdW5zYWZlKGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbGVuID0gY2FtbF9qc19mdW5jdGlvbl9hcml0eShmKTtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgcmV0dXJuIGNhbWxfY2FsbGJhY2soZiwgYXJncyk7IH1cbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrIGNvbnN0IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY2FsbGJhY2ssIGNhbWxfanNfd3JhcF9jYWxsYmFja1xuZnVuY3Rpb24gY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2soZikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGxlbiArIDEpO1xuICAgIGFyZ3NbMF0gPSB0aGlzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIGFyZ3NbaSsxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB2YXIgcmVzID0gY2FtbF9jYWxsYmFjayhmLGFyZ3MpO1xuICAgIHJldHVybiAocmVzIGluc3RhbmNlb2YgRnVuY3Rpb24pP2NhbWxfanNfd3JhcF9jYWxsYmFjayhyZXMpOnJlcztcbiAgfVxufVxuLy9Qcm92aWRlczogY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2tfYXJndW1lbnRzIGNvbnN0IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY2FsbGJhY2tcbmZ1bmN0aW9uIGNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrX2FyZ3VtZW50cyhmKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkobGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIHJldHVybiBjYW1sX2NhbGxiYWNrKGYsW3RoaXMsYXJnc10pO1xuICB9XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja19zdHJpY3QgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfY2FsbGJhY2tcbmZ1bmN0aW9uIGNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrX3N0cmljdChhcml0eSwgZikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyaXR5ICsgMSk7XG4gICAgdmFyIGxlbiA9IE1hdGgubWluKGFyZ3VtZW50cy5sZW5ndGgsIGFyaXR5KVxuICAgIGFyZ3NbMF0gPSB0aGlzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIGFyZ3NbaSsxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICByZXR1cm4gY2FtbF9jYWxsYmFjayhmLCBhcmdzKTtcbiAgfTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrX3Vuc2FmZSBjb25zdCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NhbGxiYWNrLCBjYW1sX2pzX2Z1bmN0aW9uX2FyaXR5XG5mdW5jdGlvbiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja191bnNhZmUoZikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBsZW4gPSBjYW1sX2pzX2Z1bmN0aW9uX2FyaXR5KGYpIC0gMTtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShsZW4gKyAxKTtcbiAgICBhcmdzWzBdID0gdGhpcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSBhcmdzW2krMV0gPSBhcmd1bWVudHNbaV07XG4gICAgcmV0dXJuIGNhbWxfY2FsbGJhY2soZiwgYXJncyk7IH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9qc19mdW5jdGlvbl9hcml0eVxuLy9JZjogIWVmZmVjdHNcbmZ1bmN0aW9uIGNhbWxfanNfZnVuY3Rpb25fYXJpdHkoZikge1xuICByZXR1cm4gKGYubCA+PSAwKT9mLmw6KGYubCA9IGYubGVuZ3RoKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2Z1bmN0aW9uX2FyaXR5XG4vL0lmOiBlZmZlY3RzXG5mdW5jdGlvbiBjYW1sX2pzX2Z1bmN0aW9uX2FyaXR5KGYpIHtcbiAgLy8gRnVuY3Rpb25zIGhhdmUgYW4gYWRkaXRpb25hbCBjb250aW51YXRpb24gcGFyYW1ldGVyLiBUaGlzIHNob3VsZFxuICAvLyBub3QgYmUgdmlzaWJsZSB3aGVuIGNhbGxpbmcgdGhlbSBmcm9tIEphdmFTY3JpcHRcbiAgcmV0dXJuICgoZi5sID49IDApP2YubDooZi5sID0gZi5sZW5ndGgpKSAtIDFcbn1cblxuLy9Qcm92aWRlczogY2FtbF9qc19lcXVhbHMgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc19lcXVhbHMgKHgsIHkpIHsgcmV0dXJuICsoeCA9PSB5KTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3N0cmljdF9lcXVhbHMgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc19zdHJpY3RfZXF1YWxzICh4LCB5KSB7IHJldHVybiArKHggPT09IHkpOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZXZhbF9zdHJpbmcgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfanNfZXZhbF9zdHJpbmcgKHMpIHtyZXR1cm4gZXZhbChjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhzKSk7fVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2V4cHIgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfanNfZXhwcihzKSB7XG4gIGNvbnNvbGUuZXJyb3IoXCJjYW1sX2pzX2V4cHI6IGZhbGxiYWNrIHRvIHJ1bnRpbWUgZXZhbHVhdGlvblxcblwiKTtcbiAgcmV0dXJuIGV2YWwoY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocykpO31cblxuLy9Qcm92aWRlczogY2FtbF9wdXJlX2pzX2V4cHIgY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfcHVyZV9qc19leHByIChzKXtcbiAgY29uc29sZS5lcnJvcihcImNhbWxfcHVyZV9qc19leHByOiBmYWxsYmFjayB0byBydW50aW1lIGV2YWx1YXRpb25cXG5cIik7XG4gIHJldHVybiBldmFsKGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHMpKTt9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfb2JqZWN0IChvYmplY3RfbGl0ZXJhbClcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2pzX29iamVjdCAoYSkge1xuICB2YXIgbyA9IHt9O1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcCA9IGFbaV07XG4gICAgb1tjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhwWzFdKV0gPSBwWzJdO1xuICB9XG4gIHJldHVybiBvO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9SYWlzZSBleGNlcHRpb25cblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV9jb25zdGFudCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX3JhaXNlX2NvbnN0YW50ICh0YWcpIHsgdGhyb3cgdGFnOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2Vfd2l0aF9hcmcgKGNvbnN0LCBtdXRhYmxlKVxuLy9SZXF1aXJlczogY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlXG5mdW5jdGlvbiBjYW1sX3JhaXNlX3dpdGhfYXJnICh0YWcsIGFyZykgeyB0aHJvdyBjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UoWzAsIHRhZywgYXJnXSk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV93aXRoX2FyZ3MgKGNvbnN0LCBtdXRhYmxlKVxuLy9SZXF1aXJlczogY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlXG5mdW5jdGlvbiBjYW1sX3JhaXNlX3dpdGhfYXJncyAodGFnLCBhcmdzKSB7IHRocm93IGNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZShbMCwgdGFnXS5jb25jYXQoYXJncykpOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfd2l0aF9hcmcsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcgKHRhZywgbXNnKSB7XG4gIGNhbWxfcmFpc2Vfd2l0aF9hcmcgKHRhZywgY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhtc2cpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9mYWlsd2l0aCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3dpdGhfc3RyaW5nLCBjYW1sX2dsb2JhbF9kYXRhLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX2ZhaWx3aXRoIChtc2cpIHtcbiAgaWYoIWNhbWxfZ2xvYmFsX2RhdGEuRmFpbHVyZSlcbiAgICBjYW1sX2dsb2JhbF9kYXRhLkZhaWx1cmU9WzI0OCxjYW1sX3N0cmluZ19vZl9qc2J5dGVzKFwiRmFpbHVyZVwiKSwtM107XG4gIGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcoY2FtbF9nbG9iYWxfZGF0YS5GYWlsdXJlLCBtc2cpO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3dpdGhfc3RyaW5nLCBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX2ludmFsaWRfYXJndW1lbnQgKG1zZykge1xuICBjYW1sX3JhaXNlX3dpdGhfc3RyaW5nKGNhbWxfZ2xvYmFsX2RhdGEuSW52YWxpZF9hcmd1bWVudCwgbXNnKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9jb25zdGFudCwgY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZSAoKSB7XG4gIGNhbWxfcmFpc2VfY29uc3RhbnQoY2FtbF9nbG9iYWxfZGF0YS5FbmRfb2ZfZmlsZSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2VfemVyb19kaXZpZGVcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2VfY29uc3RhbnQsIGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfcmFpc2VfemVyb19kaXZpZGUgKCkge1xuICBjYW1sX3JhaXNlX2NvbnN0YW50KGNhbWxfZ2xvYmFsX2RhdGEuRGl2aXNpb25fYnlfemVybyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2Vfbm90X2ZvdW5kXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX2NvbnN0YW50LCBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX3JhaXNlX25vdF9mb3VuZCAoKSB7XG4gIGNhbWxfcmFpc2VfY29uc3RhbnQoY2FtbF9nbG9iYWxfZGF0YS5Ob3RfZm91bmQpOyB9XG5cblxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yICgpIHtcbiAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiaW5kZXggb3V0IG9mIGJvdW5kc1wiKTtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxNCBKw6lyw7RtZSBWb3VpbGxvbiwgSHVnbyBIZXV6YXJkXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vLy8vLy8vLy8vLy8gRHVtbXkgZmlsZXN5c3RlbVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3RyYWlsaW5nX3NsYXNoXG5mdW5jdGlvbiBjYW1sX3RyYWlsaW5nX3NsYXNoKG5hbWUpe1xuICByZXR1cm4gKG5hbWUuc2xpY2UoLTEpICE9PSBcIi9cIikgPyAobmFtZSArIFwiL1wiKSA6IG5hbWU7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY3VycmVudF9kaXJcbi8vUmVxdWlyZXM6IGNhbWxfdHJhaWxpbmdfc2xhc2gsIGZzX25vZGVfc3VwcG9ydGVkXG5pZihmc19ub2RlX3N1cHBvcnRlZCAoKSAmJiBnbG9iYWxUaGlzLnByb2Nlc3MgJiYgZ2xvYmFsVGhpcy5wcm9jZXNzLmN3ZClcbiAgdmFyIGNhbWxfY3VycmVudF9kaXIgPSBnbG9iYWxUaGlzLnByb2Nlc3MuY3dkKCkucmVwbGFjZSgvXFxcXC9nLCcvJyk7XG5lbHNlXG4gIHZhciBjYW1sX2N1cnJlbnRfZGlyID0gIFwiL3N0YXRpY1wiO1xuY2FtbF9jdXJyZW50X2RpciA9IGNhbWxfdHJhaWxpbmdfc2xhc2goY2FtbF9jdXJyZW50X2Rpcik7XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2V0X3Jvb3Rcbi8vUmVxdWlyZXM6IHBhdGhfaXNfYWJzb2x1dGVcbmZ1bmN0aW9uIGNhbWxfZ2V0X3Jvb3QocGF0aCl7XG4gIHZhciB4ID0gcGF0aF9pc19hYnNvbHV0ZShwYXRoKTtcbiAgaWYgKCF4KSByZXR1cm47XG4gIHJldHVybiB4WzBdICsgXCIvXCJ9XG5cbi8vUHJvdmlkZXM6IGNhbWxfcm9vdFxuLy9SZXF1aXJlczogY2FtbF9nZXRfcm9vdCwgY2FtbF9jdXJyZW50X2RpciwgY2FtbF9mYWlsd2l0aFxudmFyIGNhbWxfcm9vdCA9IGNhbWxfZ2V0X3Jvb3QoY2FtbF9jdXJyZW50X2RpcikgfHwgY2FtbF9mYWlsd2l0aChcInVuYWJsZSB0byBjb21wdXRlIGNhbWxfcm9vdFwiKTtcblxuXG4vL1Byb3ZpZGVzOiBNbEZpbGVcbmZ1bmN0aW9uIE1sRmlsZSgpeyAgfVxuXG4vL1Byb3ZpZGVzOiBwYXRoX2lzX2Fic29sdXRlXG4vL1JlcXVpcmVzOiBmc19ub2RlX3N1cHBvcnRlZFxuZnVuY3Rpb24gbWFrZV9wYXRoX2lzX2Fic29sdXRlKCkge1xuICBmdW5jdGlvbiBwb3NpeChwYXRoKSB7XG4gICAgaWYgKHBhdGguY2hhckF0KDApID09PSAnLycpIHJldHVybiBbXCJcIiwgcGF0aC5zdWJzdHJpbmcoMSldO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdpbjMyKHBhdGgpIHtcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvYmxvYi9iM2ZjYzI0NWZiMjU1Mzk5MDllZjFkNWVhYTAxZGJmOTJlMTY4NjMzL2xpYi9wYXRoLmpzI0w1NlxuICAgIHZhciBzcGxpdERldmljZVJlID0gL14oW2EtekEtWl06fFtcXFxcL117Mn1bXlxcXFwvXStbXFxcXC9dK1teXFxcXC9dKyk/KFtcXFxcL10pPyhbXFxzXFxTXSo/KSQvO1xuICAgIHZhciByZXN1bHQgPSBzcGxpdERldmljZVJlLmV4ZWMocGF0aCk7XG4gICAgdmFyIGRldmljZSA9IHJlc3VsdFsxXSB8fCAnJztcbiAgICB2YXIgaXNVbmMgPSBCb29sZWFuKGRldmljZSAmJiBkZXZpY2UuY2hhckF0KDEpICE9PSAnOicpO1xuXG4gICAgLy8gVU5DIHBhdGhzIGFyZSBhbHdheXMgYWJzb2x1dGVcbiAgICBpZiAoQm9vbGVhbihyZXN1bHRbMl0gfHwgaXNVbmMpKSB7XG4gICAgICB2YXIgcm9vdCA9IChyZXN1bHRbMV0gfHwgJycpO1xuICAgICAgdmFyIHNlcCA9IChyZXN1bHRbMl0gfHwgJycpO1xuICAgICAgcmV0dXJuIFtyb290LCBwYXRoLnN1YnN0cmluZyhyb290Lmxlbmd0aCArIHNlcC5sZW5ndGgpXVxuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgaWYoZnNfbm9kZV9zdXBwb3J0ZWQgKCkgJiYgZ2xvYmFsVGhpcy5wcm9jZXNzICYmIGdsb2JhbFRoaXMucHJvY2Vzcy5wbGF0Zm9ybSkge1xuICAgIHJldHVybiBnbG9iYWxUaGlzLnByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicgPyB3aW4zMiA6IHBvc2l4O1xuICB9XG4gIGVsc2UgcmV0dXJuIHBvc2l4XG59XG52YXIgcGF0aF9pc19hYnNvbHV0ZSA9IG1ha2VfcGF0aF9pc19hYnNvbHV0ZSgpO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX21ha2VfcGF0aFxuLy9SZXF1aXJlczogY2FtbF9jdXJyZW50X2RpclxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcsIHBhdGhfaXNfYWJzb2x1dGVcbmZ1bmN0aW9uIGNhbWxfbWFrZV9wYXRoIChuYW1lKSB7XG4gIG5hbWU9Y2FtbF9qc3N0cmluZ19vZl9zdHJpbmcobmFtZSk7XG4gIGlmKCAhcGF0aF9pc19hYnNvbHV0ZShuYW1lKSApXG4gICAgbmFtZSA9IGNhbWxfY3VycmVudF9kaXIgKyBuYW1lO1xuICB2YXIgY29tcDAgPSBwYXRoX2lzX2Fic29sdXRlKG5hbWUpO1xuICB2YXIgY29tcCA9IGNvbXAwWzFdLnNwbGl0KFwiL1wiKTtcbiAgdmFyIG5jb21wID0gW11cbiAgZm9yKHZhciBpID0gMDsgaTxjb21wLmxlbmd0aDsgaSsrKXtcbiAgICBzd2l0Y2goY29tcFtpXSl7XG4gICAgY2FzZSBcIi4uXCI6IGlmKG5jb21wLmxlbmd0aD4xKSBuY29tcC5wb3AoKTsgYnJlYWs7XG4gICAgY2FzZSBcIi5cIjogYnJlYWs7XG4gICAgY2FzZSBcIlwiOiBicmVhaztcbiAgICBkZWZhdWx0OiBuY29tcC5wdXNoKGNvbXBbaV0pO2JyZWFrXG4gICAgfVxuICB9XG4gIG5jb21wLnVuc2hpZnQoY29tcDBbMF0pO1xuICBuY29tcC5vcmlnID0gbmFtZTtcbiAgcmV0dXJuIG5jb21wO1xufVxuXG4vL1Byb3ZpZGVzOmpzb29fbW91bnRfcG9pbnRcbi8vUmVxdWlyZXM6IE1sRmFrZURldmljZSwgTWxOb2RlRGV2aWNlLCBjYW1sX3Jvb3QsIGZzX25vZGVfc3VwcG9ydGVkXG52YXIganNvb19tb3VudF9wb2ludCA9IFtdXG5pZiAoZnNfbm9kZV9zdXBwb3J0ZWQoKSkge1xuICBqc29vX21vdW50X3BvaW50LnB1c2goe3BhdGg6Y2FtbF9yb290LGRldmljZTpuZXcgTWxOb2RlRGV2aWNlKGNhbWxfcm9vdCl9KTtcbn0gZWxzZSB7XG4gIGpzb29fbW91bnRfcG9pbnQucHVzaCh7cGF0aDpjYW1sX3Jvb3QsZGV2aWNlOm5ldyBNbEZha2VEZXZpY2UoY2FtbF9yb290KX0pO1xufVxuanNvb19tb3VudF9wb2ludC5wdXNoKHtwYXRoOlwiL3N0YXRpYy9cIiwgZGV2aWNlOm5ldyBNbEZha2VEZXZpY2UoXCIvc3RhdGljL1wiKX0pO1xuXG4vL1Byb3ZpZGVzOmNhbWxfbGlzdF9tb3VudF9wb2ludFxuLy9SZXF1aXJlczoganNvb19tb3VudF9wb2ludCwgY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9saXN0X21vdW50X3BvaW50KCl7XG4gIHZhciBwcmV2ID0gMFxuICBmb3IodmFyIGkgPSAwOyBpIDwganNvb19tb3VudF9wb2ludC5sZW5ndGg7IGkrKyl7XG4gICAgdmFyIG9sZCA9IHByZXY7XG4gICAgcHJldiA9IFswLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKGpzb29fbW91bnRfcG9pbnRbaV0ucGF0aCksIG9sZF1cbiAgfVxuICByZXR1cm4gcHJldjtcbn1cblxuLy9Qcm92aWRlczogcmVzb2x2ZV9mc19kZXZpY2Vcbi8vUmVxdWlyZXM6IGNhbWxfbWFrZV9wYXRoLCBqc29vX21vdW50X3BvaW50LCBjYW1sX3JhaXNlX3N5c19lcnJvciwgY2FtbF9nZXRfcm9vdCwgTWxOb2RlRGV2aWNlLCBjYW1sX3RyYWlsaW5nX3NsYXNoLCBmc19ub2RlX3N1cHBvcnRlZFxuZnVuY3Rpb24gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSl7XG4gIHZhciBwYXRoID0gY2FtbF9tYWtlX3BhdGgobmFtZSk7XG4gIHZhciBuYW1lID0gcGF0aC5qb2luKFwiL1wiKTtcbiAgdmFyIG5hbWVfc2xhc2ggPSBjYW1sX3RyYWlsaW5nX3NsYXNoKG5hbWUpO1xuICB2YXIgcmVzO1xuICBmb3IodmFyIGkgPSAwOyBpIDwganNvb19tb3VudF9wb2ludC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBtID0ganNvb19tb3VudF9wb2ludFtpXTtcbiAgICBpZihuYW1lX3NsYXNoLnNlYXJjaChtLnBhdGgpID09IDBcbiAgICAgICAmJiAoIXJlcyB8fCByZXMucGF0aC5sZW5ndGggPCBtLnBhdGgubGVuZ3RoKSlcbiAgICAgIHJlcyA9IHtwYXRoOm0ucGF0aCxkZXZpY2U6bS5kZXZpY2UscmVzdDpuYW1lLnN1YnN0cmluZyhtLnBhdGgubGVuZ3RoLG5hbWUubGVuZ3RoKX07XG4gIH1cbiAgaWYoICFyZXMgJiYgZnNfbm9kZV9zdXBwb3J0ZWQoKSkge1xuICAgIHZhciByb290ID0gY2FtbF9nZXRfcm9vdChuYW1lKTtcbiAgICBpZiAocm9vdCAmJiByb290Lm1hdGNoKC9eW2EtekEtWl06XFwvJC8pKXtcbiAgICAgIHZhciBtID0ge3BhdGg6cm9vdCxkZXZpY2U6bmV3IE1sTm9kZURldmljZShyb290KX07XG4gICAgICBqc29vX21vdW50X3BvaW50LnB1c2gobSk7XG4gICAgICByZXMgPSB7cGF0aDptLnBhdGgsZGV2aWNlOm0uZGV2aWNlLHJlc3Q6bmFtZS5zdWJzdHJpbmcobS5wYXRoLmxlbmd0aCxuYW1lLmxlbmd0aCl9O1xuICAgIH1cbiAgfVxuICBpZiggcmVzICkgcmV0dXJuIHJlcztcbiAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoXCJubyBkZXZpY2UgZm91bmQgZm9yIFwiICsgbmFtZV9zbGFzaCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbW91bnRfYXV0b2xvYWRcbi8vUmVxdWlyZXM6IE1sRmFrZURldmljZSwgY2FtbF9tYWtlX3BhdGgsIGpzb29fbW91bnRfcG9pbnQsIGNhbWxfdHJhaWxpbmdfc2xhc2hcbmZ1bmN0aW9uIGNhbWxfbW91bnRfYXV0b2xvYWQobmFtZSxmKXtcbiAgdmFyIHBhdGggPSBjYW1sX21ha2VfcGF0aChuYW1lKTtcbiAgdmFyIG5hbWUgPSBjYW1sX3RyYWlsaW5nX3NsYXNoKHBhdGguam9pbihcIi9cIikpO1xuICBqc29vX21vdW50X3BvaW50LnB1c2goe3BhdGg6bmFtZSxkZXZpY2U6bmV3IE1sRmFrZURldmljZShuYW1lLGYpfSlcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5tb3VudFxuLy9SZXF1aXJlczoganNvb19tb3VudF9wb2ludCwgY2FtbF9tYWtlX3BhdGgsIGNhbWxfdHJhaWxpbmdfc2xhc2hcbmZ1bmN0aW9uIGNhbWxfdW5tb3VudChuYW1lKXtcbiAgdmFyIHBhdGggPSBjYW1sX21ha2VfcGF0aChuYW1lKTtcbiAgdmFyIG5hbWUgPSBjYW1sX3RyYWlsaW5nX3NsYXNoKHBhdGguam9pbihcIi9cIikpO1xuICB2YXIgaWR4ID0gLTE7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBqc29vX21vdW50X3BvaW50Lmxlbmd0aDsgaSsrKVxuICAgIGlmKGpzb29fbW91bnRfcG9pbnRbaV0ucGF0aCA9PSBuYW1lKSBpZHggPSBpO1xuICBpZihpZHggPiAtMSkganNvb19tb3VudF9wb2ludC5zcGxpY2UoaWR4LDEpO1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19nZXRjd2Rcbi8vUmVxdWlyZXM6IGNhbWxfY3VycmVudF9kaXIsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfc3lzX2dldGN3ZCgpIHtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoY2FtbF9jdXJyZW50X2Rpcik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NoZGlyXG4vL1JlcXVpcmVzOiBjYW1sX2N1cnJlbnRfZGlyLCBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZSwgcmVzb2x2ZV9mc19kZXZpY2UsIGNhbWxfdHJhaWxpbmdfc2xhc2gsIGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3lzX2NoZGlyKGRpcikge1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKGRpcik7XG4gIGlmKHJvb3QuZGV2aWNlLmV4aXN0cyhyb290LnJlc3QpKSB7XG4gICAgaWYocm9vdC5yZXN0KSBjYW1sX2N1cnJlbnRfZGlyID0gY2FtbF90cmFpbGluZ19zbGFzaChyb290LnBhdGggKyByb290LnJlc3QpO1xuICAgIGVsc2UgY2FtbF9jdXJyZW50X2RpciA9IHJvb3QucGF0aDtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBlbHNlIHtcbiAgICBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZShjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKGRpcikpO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3N5c19lcnJvclxuZnVuY3Rpb24gY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUobmFtZSl7XG4gIGNhbWxfcmFpc2Vfc3lzX2Vycm9yIChuYW1lICsgXCI6IE5vIHN1Y2ggZmlsZSBvciBkaXJlY3RvcnlcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2Vfbm90X2FfZGlyXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3N5c19lcnJvclxuZnVuY3Rpb24gY2FtbF9yYWlzZV9ub3RfYV9kaXIobmFtZSl7XG4gIGNhbWxfcmFpc2Vfc3lzX2Vycm9yIChuYW1lICsgXCI6IE5vdCBhIGRpcmVjdG9yeVwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfZmlsZV9leGlzdHNcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlXG5mdW5jdGlvbiBjYW1sX3N5c19maWxlX2V4aXN0cyAobmFtZSkge1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICByZXR1cm4gcm9vdC5kZXZpY2UuZXhpc3RzKHJvb3QucmVzdCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX3JlYWRfZGlyZWN0b3J5XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX25vdF9hX2RpciwgcmVzb2x2ZV9mc19kZXZpY2VcbmZ1bmN0aW9uIGNhbWxfc3lzX3JlYWRfZGlyZWN0b3J5KG5hbWUpe1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICB2YXIgYSA9IHJvb3QuZGV2aWNlLnJlYWRkaXIocm9vdC5yZXN0KTtcbiAgdmFyIGwgPSBuZXcgQXJyYXkoYS5sZW5ndGggKyAxKTtcbiAgbFswXSA9IDA7XG4gIGZvcih2YXIgaT0wO2k8YS5sZW5ndGg7aSsrKVxuICAgIGxbaSsxXSA9IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoYVtpXSk7XG4gIHJldHVybiBsO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19yZW1vdmVcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlLCByZXNvbHZlX2ZzX2RldmljZSwgY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9zeXNfcmVtb3ZlKG5hbWUpe1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICB2YXIgb2sgPSByb290LmRldmljZS51bmxpbmsocm9vdC5yZXN0KTtcbiAgaWYob2sgPT0gMCkgY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUoY2FtbF9qc2J5dGVzX29mX3N0cmluZyhuYW1lKSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19pc19kaXJlY3Rvcnlcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlXG5mdW5jdGlvbiBjYW1sX3N5c19pc19kaXJlY3RvcnkobmFtZSl7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIHZhciBhID0gcm9vdC5kZXZpY2UuaXNfZGlyKHJvb3QucmVzdCk7XG4gIHJldHVybiBhPzE6MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfcmVuYW1lXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoLCByZXNvbHZlX2ZzX2RldmljZVxuZnVuY3Rpb24gY2FtbF9zeXNfcmVuYW1lKG8sbil7XG4gIHZhciBvX3Jvb3QgPSByZXNvbHZlX2ZzX2RldmljZShvKTtcbiAgdmFyIG5fcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG4pO1xuICBpZihvX3Jvb3QuZGV2aWNlICE9IG5fcm9vdC5kZXZpY2UpXG4gICAgY2FtbF9mYWlsd2l0aChcImNhbWxfc3lzX3JlbmFtZTogY2Fubm90IG1vdmUgZmlsZSBiZXR3ZWVuIHR3byBmaWxlc3lzdGVtXCIpO1xuICBpZighb19yb290LmRldmljZS5yZW5hbWUpXG4gICAgY2FtbF9mYWlsd2l0aChcImNhbWxfc3lzX3JlbmFtZTogbm8gaW1wbGVtZW50ZWRcIik7XG4gIG9fcm9vdC5kZXZpY2UucmVuYW1lKG9fcm9vdC5yZXN0LCBuX3Jvb3QucmVzdCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX21rZGlyXG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZSwgY2FtbF9yYWlzZV9zeXNfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfc3lzX21rZGlyKG5hbWUsIHBlcm0pe1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICByb290LmRldmljZS5ta2Rpcihyb290LnJlc3QscGVybSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19ybWRpclxuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2UsIGNhbWxfcmFpc2Vfc3lzX2Vycm9yLCBjYW1sX3JhaXNlX25vdF9hX2RpclxuZnVuY3Rpb24gY2FtbF9zeXNfcm1kaXIobmFtZSl7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIHJvb3QuZGV2aWNlLnJtZGlyKHJvb3QucmVzdCk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX21hcF9maWxlXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2JhX21hcF9maWxlKHZmZCwga2luZCwgbGF5b3V0LCBzaGFyZWQsIGRpbXMsIHBvcykge1xuICAvLyB2YXIgZGF0YSA9IGNhbWxfc3lzX2Zkc1t2ZmRdO1xuICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9iYV9tYXBfZmlsZSBub3QgaW1wbGVtZW50ZWRcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfbWFwX2ZpbGVfYnl0ZWNvZGVcbi8vUmVxdWlyZXM6IGNhbWxfYmFfbWFwX2ZpbGVcbmZ1bmN0aW9uIGNhbWxfYmFfbWFwX2ZpbGVfYnl0ZWNvZGUoYXJndixhcmduKXtcbiAgcmV0dXJuIGNhbWxfYmFfbWFwX2ZpbGUoYXJndlswXSxhcmd2WzFdLGFyZ3ZbMl0sYXJndlszXSxhcmd2WzRdLGFyZ3ZbNV0pO1xufVxuXG4vL1Byb3ZpZGVzOiBqc29vX2NyZWF0ZV9maWxlX2V4dGVyblxuZnVuY3Rpb24ganNvb19jcmVhdGVfZmlsZV9leHRlcm4obmFtZSxjb250ZW50KXtcbiAgaWYoZ2xvYmFsVGhpcy5qc29vX2NyZWF0ZV9maWxlKVxuICAgIGdsb2JhbFRoaXMuanNvb19jcmVhdGVfZmlsZShuYW1lLGNvbnRlbnQpO1xuICBlbHNlIHtcbiAgICBpZighZ2xvYmFsVGhpcy5jYW1sX2ZzX3RtcCkgZ2xvYmFsVGhpcy5jYW1sX2ZzX3RtcCA9IFtdO1xuICAgIGdsb2JhbFRoaXMuY2FtbF9mc190bXAucHVzaCh7bmFtZTpuYW1lLGNvbnRlbnQ6Y29udGVudH0pO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ZzX2luaXRcbi8vUmVxdWlyZXM6IGpzb29fY3JlYXRlX2ZpbGVcbmZ1bmN0aW9uIGNhbWxfZnNfaW5pdCAoKXtcbiAgdmFyIHRtcD1nbG9iYWxUaGlzLmNhbWxfZnNfdG1wXG4gIGlmKHRtcCl7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHRtcC5sZW5ndGg7IGkrKyl7XG4gICAgICBqc29vX2NyZWF0ZV9maWxlKHRtcFtpXS5uYW1lLHRtcFtpXS5jb250ZW50KTtcbiAgICB9XG4gIH1cbiAgZ2xvYmFsVGhpcy5qc29vX2NyZWF0ZV9maWxlID0ganNvb19jcmVhdGVfZmlsZTtcbiAgZ2xvYmFsVGhpcy5jYW1sX2ZzX3RtcCA9IFtdO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jcmVhdGVfZmlsZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aCwgcmVzb2x2ZV9mc19kZXZpY2VcbmZ1bmN0aW9uIGNhbWxfY3JlYXRlX2ZpbGUobmFtZSxjb250ZW50KSB7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIGlmKCEgcm9vdC5kZXZpY2UucmVnaXN0ZXIpIGNhbWxfZmFpbHdpdGgoXCJjYW5ub3QgcmVnaXN0ZXIgZmlsZVwiKTtcbiAgcm9vdC5kZXZpY2UucmVnaXN0ZXIocm9vdC5yZXN0LGNvbnRlbnQpO1xuICByZXR1cm4gMDtcbn1cblxuXG4vL1Byb3ZpZGVzOiBqc29vX2NyZWF0ZV9maWxlXG4vL1JlcXVpcmVzOiBjYW1sX2NyZWF0ZV9maWxlLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBqc29vX2NyZWF0ZV9maWxlKG5hbWUsY29udGVudCkge1xuICB2YXIgbmFtZSA9IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMobmFtZSk7XG4gIHZhciBjb250ZW50ID0gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhjb250ZW50KTtcbiAgcmV0dXJuIGNhbWxfY3JlYXRlX2ZpbGUobmFtZSwgY29udGVudCk7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9yZWFkX2ZpbGVfY29udGVudFxuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2UsIGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlLCBjYW1sX3N0cmluZ19vZl9hcnJheVxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlcywgY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9yZWFkX2ZpbGVfY29udGVudCAobmFtZSkge1xuICB2YXIgbmFtZSA9ICh0eXBlb2YgbmFtZSA9PSBcInN0cmluZ1wiKT9jYW1sX3N0cmluZ19vZl9qc2J5dGVzKG5hbWUpOm5hbWU7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIGlmKHJvb3QuZGV2aWNlLmV4aXN0cyhyb290LnJlc3QpKSB7XG4gICAgdmFyIGZpbGUgPSByb290LmRldmljZS5vcGVuKHJvb3QucmVzdCx7cmRvbmx5OjF9KTtcbiAgICB2YXIgbGVuICA9IGZpbGUubGVuZ3RoKCk7XG4gICAgdmFyIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGxlbik7XG4gICAgZmlsZS5yZWFkKDAsYnVmLDAsbGVuKTtcbiAgICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfYXJyYXkoYnVmKVxuICB9XG4gIGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlKGNhbWxfanNieXRlc19vZl9zdHJpbmcobmFtZSkpO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDE0IErDqXLDtG1lIFZvdWlsbG9uLCBIdWdvIEhldXphcmRcbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogTWxGYWtlRGV2aWNlXG4vL1JlcXVpcmVzOiBNbEZha2VGaWxlLCBNbEZha2VGZCwgY2FtbF9jcmVhdGVfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfc3lzX2Vycm9yLCBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZVxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlcywgY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfb2ZfYXJyYXksIGNhbWxfYnl0ZXNfb2Zfc3RyaW5nLCBjYW1sX2J5dGVzX29mX2pzYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfaXNfbWxfYnl0ZXMsIGNhbWxfaXNfbWxfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX25hbWVkX3ZhbHVlLCBjYW1sX3JhaXNlX3dpdGhfYXJncywgY2FtbF9uYW1lZF92YWx1ZXNcbi8vUmVxdWlyZXM6IG1ha2VfdW5peF9lcnJfYXJnc1xuZnVuY3Rpb24gTWxGYWtlRGV2aWNlIChyb290LCBmKSB7XG4gIHRoaXMuY29udGVudD17fTtcbiAgdGhpcy5yb290ID0gcm9vdDtcbiAgdGhpcy5sb29rdXBGdW4gPSBmO1xufVxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5ubSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgcmV0dXJuICh0aGlzLnJvb3QgKyBuYW1lKTtcbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUuY3JlYXRlX2Rpcl9pZl9uZWVkZWQgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHZhciBjb21wID0gbmFtZS5zcGxpdChcIi9cIik7XG4gIHZhciByZXMgPSBcIlwiO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgY29tcC5sZW5ndGggLSAxOyBpKyspe1xuICAgIHJlcyArPSBjb21wW2ldICsgXCIvXCI7XG4gICAgaWYodGhpcy5jb250ZW50W3Jlc10pIGNvbnRpbnVlO1xuICAgIHRoaXMuY29udGVudFtyZXNdID0gU3ltYm9sKFwiZGlyZWN0b3J5XCIpO1xuICB9XG59XG5NbEZha2VEZXZpY2UucHJvdG90eXBlLnNsYXNoID0gZnVuY3Rpb24obmFtZSl7XG4gIHJldHVybiAvXFwvJC8udGVzdChuYW1lKT9uYW1lOihuYW1lICsgXCIvXCIpO1xufVxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5sb29rdXAgPSBmdW5jdGlvbihuYW1lKSB7XG4gIGlmKCF0aGlzLmNvbnRlbnRbbmFtZV0gJiYgdGhpcy5sb29rdXBGdW4pIHtcbiAgICB2YXIgcmVzID0gdGhpcy5sb29rdXBGdW4oY2FtbF9zdHJpbmdfb2ZfanNieXRlcyh0aGlzLnJvb3QpLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKG5hbWUpKTtcbiAgICBpZihyZXMgIT09IDApIHtcbiAgICAgIHRoaXMuY3JlYXRlX2Rpcl9pZl9uZWVkZWQobmFtZSk7XG4gICAgICB0aGlzLmNvbnRlbnRbbmFtZV09bmV3IE1sRmFrZUZpbGUoY2FtbF9ieXRlc19vZl9zdHJpbmcocmVzWzFdKSk7XG4gICAgfVxuICB9XG59XG5NbEZha2VEZXZpY2UucHJvdG90eXBlLmV4aXN0cyA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgLy8gVGhlIHJvb3Qgb2YgdGhlIGRldmljZSBleGlzdHNcbiAgaWYobmFtZSA9PSBcIlwiKSByZXR1cm4gMTtcbiAgLy8gQ2hlY2sgaWYgYSBkaXJlY3RvcnkgZXhpc3RzXG4gIHZhciBuYW1lX3NsYXNoID0gdGhpcy5zbGFzaChuYW1lKTtcbiAgaWYodGhpcy5jb250ZW50W25hbWVfc2xhc2hdKSByZXR1cm4gMTtcbiAgLy8gQ2hlY2sgaWYgYSBmaWxlIGV4aXN0c1xuICB0aGlzLmxvb2t1cChuYW1lKTtcbiAgcmV0dXJuIHRoaXMuY29udGVudFtuYW1lXT8xOjA7XG59XG5NbEZha2VEZXZpY2UucHJvdG90eXBlLmlzRmlsZSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgaWYodGhpcy5leGlzdHMobmFtZSkgJiYgIXRoaXMuaXNfZGlyKG5hbWUpKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuICBlbHNlIHtcbiAgICByZXR1cm4gMFxuICB9XG59XG5NbEZha2VEZXZpY2UucHJvdG90eXBlLm1rZGlyID0gZnVuY3Rpb24obmFtZSxtb2RlLCByYWlzZV91bml4KSB7XG4gIHZhciB1bml4X2Vycm9yID0gcmFpc2VfdW5peCAmJiBjYW1sX25hbWVkX3ZhbHVlKCdVbml4LlVuaXhfZXJyb3InKTtcbiAgaWYodGhpcy5leGlzdHMobmFtZSkpIHtcbiAgICBpZiAodW5peF9lcnJvcikge1xuICAgICAgY2FtbF9yYWlzZV93aXRoX2FyZ3ModW5peF9lcnJvciwgbWFrZV91bml4X2Vycl9hcmdzKFwiRUVYSVNUXCIsIFwibWtkaXJcIiwgdGhpcy5ubShuYW1lKSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKG5hbWUgKyBcIjogRmlsZSBleGlzdHNcIik7XG4gICAgfVxuICB9XG4gIHZhciBwYXJlbnQgPSAvXiguKilcXC9bXi9dKy8uZXhlYyhuYW1lKTtcbiAgcGFyZW50ID0gKHBhcmVudCAmJiBwYXJlbnRbMV0pIHx8ICcnO1xuICBpZighdGhpcy5leGlzdHMocGFyZW50KSl7XG4gICAgaWYgKHVuaXhfZXJyb3IpIHtcbiAgICAgIGNhbWxfcmFpc2Vfd2l0aF9hcmdzKHVuaXhfZXJyb3IsIG1ha2VfdW5peF9lcnJfYXJncyhcIkVOT0VOVFwiLCBcIm1rZGlyXCIsIHRoaXMubm0ocGFyZW50KSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHBhcmVudCArIFwiOiBObyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5XCIpO1xuICAgIH1cbiAgfVxuICBpZighdGhpcy5pc19kaXIocGFyZW50KSl7XG4gICAgaWYgKHVuaXhfZXJyb3IpIHtcbiAgICAgIGNhbWxfcmFpc2Vfd2l0aF9hcmdzKHVuaXhfZXJyb3IsIG1ha2VfdW5peF9lcnJfYXJncyhcIkVOT1RESVJcIiwgXCJta2RpclwiLCB0aGlzLm5tKHBhcmVudCkpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihwYXJlbnQgKyBcIjogTm90IGEgZGlyZWN0b3J5XCIpO1xuICAgIH1cbiAgfVxuICB0aGlzLmNyZWF0ZV9kaXJfaWZfbmVlZGVkKHRoaXMuc2xhc2gobmFtZSkpO1xufVxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5ybWRpciA9IGZ1bmN0aW9uKG5hbWUsIHJhaXNlX3VuaXgpIHtcbiAgdmFyIHVuaXhfZXJyb3IgPSByYWlzZV91bml4ICYmIGNhbWxfbmFtZWRfdmFsdWUoJ1VuaXguVW5peF9lcnJvcicpO1xuICB2YXIgbmFtZV9zbGFzaCA9IChuYW1lID09IFwiXCIpP1wiXCI6KHRoaXMuc2xhc2gobmFtZSkpO1xuICB2YXIgciA9IG5ldyBSZWdFeHAoXCJeXCIgKyBuYW1lX3NsYXNoICsgXCIoW14vXSspXCIpO1xuICBpZighdGhpcy5leGlzdHMobmFtZSkpIHtcbiAgICBpZiAodW5peF9lcnJvcikge1xuICAgICAgY2FtbF9yYWlzZV93aXRoX2FyZ3ModW5peF9lcnJvciwgbWFrZV91bml4X2Vycl9hcmdzKFwiRU5PRU5UXCIsIFwicm1kaXJcIiwgdGhpcy5ubShuYW1lKSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKG5hbWUgKyBcIjogTm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeVwiKTtcbiAgICB9XG4gIH1cbiAgaWYoIXRoaXMuaXNfZGlyKG5hbWUpKSB7XG4gICAgaWYgKHVuaXhfZXJyb3IpIHtcbiAgICAgIGNhbWxfcmFpc2Vfd2l0aF9hcmdzKHVuaXhfZXJyb3IsIG1ha2VfdW5peF9lcnJfYXJncyhcIkVOT1RESVJcIiwgXCJybWRpclwiLCB0aGlzLm5tKG5hbWUpKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IobmFtZSArIFwiOiBOb3QgYSBkaXJlY3RvcnlcIik7XG4gICAgfVxuICB9XG4gIGZvcih2YXIgbiBpbiB0aGlzLmNvbnRlbnQpIHtcbiAgICBpZihuLm1hdGNoKHIpKSB7XG4gICAgICBpZiAodW5peF9lcnJvcikge1xuICAgICAgICBjYW1sX3JhaXNlX3dpdGhfYXJncyh1bml4X2Vycm9yLCBtYWtlX3VuaXhfZXJyX2FyZ3MoXCJFTk9URU1QVFlcIiwgXCJybWRpclwiLCB0aGlzLm5tKG5hbWUpKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYW1sX3JhaXNlX3N5c19lcnJvcih0aGlzLm5tKG5hbWUpICsgXCI6IERpcmVjdG9yeSBub3QgZW1wdHlcIik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGRlbGV0ZSB0aGlzLmNvbnRlbnRbbmFtZV9zbGFzaF07XG59XG5NbEZha2VEZXZpY2UucHJvdG90eXBlLnJlYWRkaXIgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHZhciBuYW1lX3NsYXNoID0gKG5hbWUgPT0gXCJcIik/XCJcIjoodGhpcy5zbGFzaChuYW1lKSk7XG4gIGlmKCF0aGlzLmV4aXN0cyhuYW1lKSkge1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKG5hbWUgKyBcIjogTm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeVwiKTtcbiAgfVxuICBpZighdGhpcy5pc19kaXIobmFtZSkpIHtcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihuYW1lICsgXCI6IE5vdCBhIGRpcmVjdG9yeVwiKTtcbiAgfVxuICB2YXIgciA9IG5ldyBSZWdFeHAoXCJeXCIgKyBuYW1lX3NsYXNoICsgXCIoW14vXSspXCIpO1xuICB2YXIgc2VlbiA9IHt9XG4gIHZhciBhID0gW107XG4gIGZvcih2YXIgbiBpbiB0aGlzLmNvbnRlbnQpIHtcbiAgICB2YXIgbSA9IG4ubWF0Y2gocik7XG4gICAgaWYobSAmJiAhc2VlblttWzFdXSkge3NlZW5bbVsxXV0gPSB0cnVlOyBhLnB1c2gobVsxXSl9XG4gIH1cbiAgcmV0dXJuIGE7XG59XG5NbEZha2VEZXZpY2UucHJvdG90eXBlLm9wZW5kaXIgPSBmdW5jdGlvbihuYW1lLCByYWlzZV91bml4KSB7XG4gIHZhciB1bml4X2Vycm9yID0gcmFpc2VfdW5peCAmJiBjYW1sX25hbWVkX3ZhbHVlKCdVbml4LlVuaXhfZXJyb3InKTtcblxuICB2YXIgYSA9IHRoaXMucmVhZGRpcihuYW1lKTtcbiAgdmFyIGMgPSBmYWxzZTtcbiAgdmFyIGkgPSAwO1xuICByZXR1cm4geyByZWFkU3luYyA6IChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGMpIHtcbiAgICAgIGlmICh1bml4X2Vycm9yKSB7XG4gICAgICAgIGNhbWxfcmFpc2Vfd2l0aF9hcmdzKHVuaXhfZXJyb3IsIG1ha2VfdW5peF9lcnJfYXJncyhcIkVCQURGXCIsIFwiY2xvc2VkaXJcIiwgdGhpcy5ubShuYW1lKSkpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKG5hbWUgKyBcIjogY2xvc2VkaXIgZmFpbGVkXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZihpID09IGEubGVuZ3RoKSByZXR1cm4gbnVsbDtcbiAgICB2YXIgZW50cnkgPSBhW2ldO1xuICAgIGkrKztcbiAgICByZXR1cm4geyBuYW1lOiBlbnRyeSB9XG4gIH0pXG4gICAgLCBjbG9zZVN5bmM6IChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoYykge1xuICAgICAgICBpZiAodW5peF9lcnJvcikge1xuICAgICAgICAgIGNhbWxfcmFpc2Vfd2l0aF9hcmdzKHVuaXhfZXJyb3IsIG1ha2VfdW5peF9lcnJfYXJncyhcIkVCQURGXCIsIFwiY2xvc2VkaXJcIiwgdGhpcy5ubShuYW1lKSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKG5hbWUgKyBcIjogY2xvc2VkaXIgZmFpbGVkXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjID0gdHJ1ZTtcbiAgICAgIGEgPSBbXTtcbiAgICB9KVxuICB9XG59XG5NbEZha2VEZXZpY2UucHJvdG90eXBlLmlzX2RpciA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgaWYobmFtZSA9PSBcIlwiKSAgcmV0dXJuIHRydWU7XG4gIHZhciBuYW1lX3NsYXNoID0gdGhpcy5zbGFzaChuYW1lKTtcbiAgcmV0dXJuIHRoaXMuY29udGVudFtuYW1lX3NsYXNoXT8xOjA7XG59XG5NbEZha2VEZXZpY2UucHJvdG90eXBlLnVubGluayA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdmFyIG9rID0gdGhpcy5jb250ZW50W25hbWVdP3RydWU6ZmFsc2U7XG4gIGRlbGV0ZSB0aGlzLmNvbnRlbnRbbmFtZV07XG4gIHJldHVybiBvaztcbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uKG5hbWUsIGYpIHtcbiAgdmFyIGZpbGU7XG4gIGlmKGYucmRvbmx5ICYmIGYud3Jvbmx5KVxuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHRoaXMubm0obmFtZSkgKyBcIiA6IGZsYWdzIE9wZW5fcmRvbmx5IGFuZCBPcGVuX3dyb25seSBhcmUgbm90IGNvbXBhdGlibGVcIik7XG4gIGlmKGYudGV4dCAmJiBmLmJpbmFyeSlcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcih0aGlzLm5tKG5hbWUpICsgXCIgOiBmbGFncyBPcGVuX3RleHQgYW5kIE9wZW5fYmluYXJ5IGFyZSBub3QgY29tcGF0aWJsZVwiKTtcbiAgdGhpcy5sb29rdXAobmFtZSk7XG4gIGlmICh0aGlzLmNvbnRlbnRbbmFtZV0pIHtcbiAgICBpZiAodGhpcy5pc19kaXIobmFtZSkpIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHRoaXMubm0obmFtZSkgKyBcIiA6IGlzIGEgZGlyZWN0b3J5XCIpO1xuICAgIGlmIChmLmNyZWF0ZSAmJiBmLmV4Y2wpIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHRoaXMubm0obmFtZSkgKyBcIiA6IGZpbGUgYWxyZWFkeSBleGlzdHNcIik7XG4gICAgZmlsZSA9IHRoaXMuY29udGVudFtuYW1lXTtcbiAgICBpZihmLnRydW5jYXRlKSBmaWxlLnRydW5jYXRlKCk7XG4gIH0gZWxzZSBpZiAoZi5jcmVhdGUpIHtcbiAgICB0aGlzLmNyZWF0ZV9kaXJfaWZfbmVlZGVkKG5hbWUpO1xuICAgIHRoaXMuY29udGVudFtuYW1lXSA9IG5ldyBNbEZha2VGaWxlKGNhbWxfY3JlYXRlX2J5dGVzKDApKTtcbiAgICBmaWxlID0gdGhpcy5jb250ZW50W25hbWVdO1xuICB9IGVsc2Uge1xuICAgIGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlICh0aGlzLm5tKG5hbWUpKTtcbiAgfVxuICByZXR1cm4gbmV3IE1sRmFrZUZkKHRoaXMubm0obmFtZSksIGZpbGUsIGYpO1xufVxuXG5NbEZha2VEZXZpY2UucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbihuYW1lLCBmKSB7XG4gIHZhciBmaWxlO1xuICBpZihmLnJkb25seSAmJiBmLndyb25seSlcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcih0aGlzLm5tKG5hbWUpICsgXCIgOiBmbGFncyBPcGVuX3Jkb25seSBhbmQgT3Blbl93cm9ubHkgYXJlIG5vdCBjb21wYXRpYmxlXCIpO1xuICBpZihmLnRleHQgJiYgZi5iaW5hcnkpXG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IodGhpcy5ubShuYW1lKSArIFwiIDogZmxhZ3MgT3Blbl90ZXh0IGFuZCBPcGVuX2JpbmFyeSBhcmUgbm90IGNvbXBhdGlibGVcIik7XG4gIHRoaXMubG9va3VwKG5hbWUpO1xuICBpZiAodGhpcy5jb250ZW50W25hbWVdKSB7XG4gICAgaWYgKHRoaXMuaXNfZGlyKG5hbWUpKSBjYW1sX3JhaXNlX3N5c19lcnJvcih0aGlzLm5tKG5hbWUpICsgXCIgOiBpcyBhIGRpcmVjdG9yeVwiKTtcbiAgICBpZiAoZi5jcmVhdGUgJiYgZi5leGNsKSBjYW1sX3JhaXNlX3N5c19lcnJvcih0aGlzLm5tKG5hbWUpICsgXCIgOiBmaWxlIGFscmVhZHkgZXhpc3RzXCIpO1xuICAgIGZpbGUgPSB0aGlzLmNvbnRlbnRbbmFtZV07XG4gICAgaWYoZi50cnVuY2F0ZSkgZmlsZS50cnVuY2F0ZSgpO1xuICB9IGVsc2UgaWYgKGYuY3JlYXRlKSB7XG4gICAgdGhpcy5jcmVhdGVfZGlyX2lmX25lZWRlZChuYW1lKTtcbiAgICB0aGlzLmNvbnRlbnRbbmFtZV0gPSBuZXcgTWxGYWtlRmlsZShjYW1sX2NyZWF0ZV9ieXRlcygwKSk7XG4gICAgZmlsZSA9IHRoaXMuY29udGVudFtuYW1lXTtcbiAgfSBlbHNlIHtcbiAgICBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZSAodGhpcy5ubShuYW1lKSk7XG4gIH1cbiAgcmV0dXJuIG5ldyBNbEZha2VGZCh0aGlzLm5tKG5hbWUpLCBmaWxlLCBmKTtcbn1cblxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5yZWdpc3Rlcj0gZnVuY3Rpb24gKG5hbWUsY29udGVudCl7XG4gIHZhciBmaWxlO1xuICBpZih0aGlzLmNvbnRlbnRbbmFtZV0pIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHRoaXMubm0obmFtZSkgKyBcIiA6IGZpbGUgYWxyZWFkeSBleGlzdHNcIik7XG4gIGlmKGNhbWxfaXNfbWxfYnl0ZXMoY29udGVudCkpXG4gICAgZmlsZSA9IG5ldyBNbEZha2VGaWxlKGNvbnRlbnQpO1xuICBpZihjYW1sX2lzX21sX3N0cmluZyhjb250ZW50KSlcbiAgICBmaWxlID0gbmV3IE1sRmFrZUZpbGUoY2FtbF9ieXRlc19vZl9zdHJpbmcoY29udGVudCkpO1xuICBlbHNlIGlmKGNvbnRlbnQgaW5zdGFuY2VvZiBBcnJheSlcbiAgICBmaWxlID0gbmV3IE1sRmFrZUZpbGUoY2FtbF9ieXRlc19vZl9hcnJheShjb250ZW50KSk7XG4gIGVsc2UgaWYodHlwZW9mIGNvbnRlbnQgPT09IFwic3RyaW5nXCIpXG4gICAgZmlsZSA9IG5ldyBNbEZha2VGaWxlKGNhbWxfYnl0ZXNfb2ZfanNieXRlcyhjb250ZW50KSk7XG4gIGVsc2UgaWYoY29udGVudC50b1N0cmluZykge1xuICAgIHZhciBieXRlcyA9IGNhbWxfYnl0ZXNfb2Zfc3RyaW5nKGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKGNvbnRlbnQudG9TdHJpbmcoKSkpO1xuICAgIGZpbGUgPSBuZXcgTWxGYWtlRmlsZShieXRlcyk7XG4gIH1cbiAgaWYoZmlsZSl7XG4gICAgdGhpcy5jcmVhdGVfZGlyX2lmX25lZWRlZChuYW1lKTtcbiAgICB0aGlzLmNvbnRlbnRbbmFtZV0gPSBmaWxlO1xuICB9XG4gIGVsc2UgY2FtbF9yYWlzZV9zeXNfZXJyb3IodGhpcy5ubShuYW1lKSArIFwiIDogcmVnaXN0ZXJpbmcgZmlsZSB3aXRoIGludmFsaWQgY29udGVudCB0eXBlXCIpO1xufVxuXG5NbEZha2VEZXZpY2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWxGYWtlRGV2aWNlXG5cbi8vUHJvdmlkZXM6IE1sRmFrZUZpbGVcbi8vUmVxdWlyZXM6IE1sRmlsZVxuLy9SZXF1aXJlczogY2FtbF9jcmVhdGVfYnl0ZXMsIGNhbWxfbWxfYnl0ZXNfbGVuZ3RoLCBjYW1sX2JsaXRfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfdWludDhfYXJyYXlfb2ZfYnl0ZXMsIGNhbWxfYnl0ZXNfb2ZfYXJyYXlcbmZ1bmN0aW9uIE1sRmFrZUZpbGUoY29udGVudCl7XG4gIHRoaXMuZGF0YSA9IGNvbnRlbnQ7XG59XG5NbEZha2VGaWxlLnByb3RvdHlwZSA9IG5ldyBNbEZpbGUgKCk7XG5NbEZha2VGaWxlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1sRmFrZUZpbGVcbk1sRmFrZUZpbGUucHJvdG90eXBlLnRydW5jYXRlID0gZnVuY3Rpb24obGVuKXtcbiAgdmFyIG9sZCA9IHRoaXMuZGF0YTtcbiAgdGhpcy5kYXRhID0gY2FtbF9jcmVhdGVfYnl0ZXMobGVufDApO1xuICBjYW1sX2JsaXRfYnl0ZXMob2xkLCAwLCB0aGlzLmRhdGEsIDAsIGxlbik7XG59XG5NbEZha2VGaWxlLnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBjYW1sX21sX2J5dGVzX2xlbmd0aCh0aGlzLmRhdGEpO1xufVxuTWxGYWtlRmlsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihvZmZzZXQsYnVmLHBvcyxsZW4pe1xuICB2YXIgY2xlbiA9IHRoaXMubGVuZ3RoKCk7XG4gIGlmKG9mZnNldCArIGxlbiA+PSBjbGVuKSB7XG4gICAgdmFyIG5ld19zdHIgPSBjYW1sX2NyZWF0ZV9ieXRlcyhvZmZzZXQgKyBsZW4pO1xuICAgIHZhciBvbGRfZGF0YSA9IHRoaXMuZGF0YTtcbiAgICB0aGlzLmRhdGEgPSBuZXdfc3RyO1xuICAgIGNhbWxfYmxpdF9ieXRlcyhvbGRfZGF0YSwgMCwgdGhpcy5kYXRhLCAwLCBjbGVuKTtcbiAgfVxuICBjYW1sX2JsaXRfYnl0ZXMoY2FtbF9ieXRlc19vZl9hcnJheShidWYpLCBwb3MsIHRoaXMuZGF0YSwgb2Zmc2V0LCBsZW4pO1xuICByZXR1cm4gMFxufVxuTWxGYWtlRmlsZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uKG9mZnNldCxidWYscG9zLGxlbil7XG4gIHZhciBjbGVuID0gdGhpcy5sZW5ndGgoKTtcbiAgaWYob2Zmc2V0ICsgbGVuID49IGNsZW4pIHtcbiAgICBsZW4gPSBjbGVuIC0gb2Zmc2V0O1xuICB9XG4gIGlmKGxlbikge1xuICAgIHZhciBkYXRhID0gY2FtbF9jcmVhdGVfYnl0ZXMobGVufDApO1xuICAgIGNhbWxfYmxpdF9ieXRlcyh0aGlzLmRhdGEsIG9mZnNldCwgZGF0YSwgMCwgbGVuKTtcbiAgICBidWYuc2V0KGNhbWxfdWludDhfYXJyYXlfb2ZfYnl0ZXMoZGF0YSksIHBvcyk7XG4gIH1cbiAgcmV0dXJuIGxlblxufVxuXG5cbi8vUHJvdmlkZXM6IE1sRmFrZUZkX291dFxuLy9SZXF1aXJlczogTWxGYWtlRmlsZSwgY2FtbF9jcmVhdGVfYnl0ZXMsIGNhbWxfYmxpdF9ieXRlcywgY2FtbF9ieXRlc19vZl9hcnJheVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXNfZXJyb3JcbmZ1bmN0aW9uIE1sRmFrZUZkX291dChmZCxmbGFncykge1xuICBNbEZha2VGaWxlLmNhbGwodGhpcywgY2FtbF9jcmVhdGVfYnl0ZXMoMCkpO1xuICB0aGlzLmxvZyA9IChmdW5jdGlvbiAocykgeyByZXR1cm4gMCB9KTtcbiAgaWYoZmQgPT0gMSAmJiB0eXBlb2YgY29uc29sZS5sb2cgPT0gXCJmdW5jdGlvblwiKVxuICAgIHRoaXMubG9nID0gY29uc29sZS5sb2c7XG4gIGVsc2UgaWYoZmQgPT0gMiAmJiB0eXBlb2YgY29uc29sZS5lcnJvciA9PSBcImZ1bmN0aW9uXCIpXG4gICAgdGhpcy5sb2cgPSBjb25zb2xlLmVycm9yO1xuICBlbHNlIGlmKHR5cGVvZiBjb25zb2xlLmxvZyA9PSBcImZ1bmN0aW9uXCIpXG4gICAgdGhpcy5sb2cgPSBjb25zb2xlLmxvZ1xuICB0aGlzLmZsYWdzID0gZmxhZ3M7XG59XG5NbEZha2VGZF9vdXQucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMCB9XG5NbEZha2VGZF9vdXQucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKG9mZnNldCxidWYscG9zLGxlbikge1xuICBpZih0aGlzLmxvZykge1xuICAgIGlmKGxlbiA+IDBcbiAgICAgICAmJiBwb3MgPj0gMFxuICAgICAgICYmIHBvcytsZW4gPD0gYnVmLmxlbmd0aFxuICAgICAgICYmIGJ1Zltwb3MrbGVuLTFdID09IDEwKVxuICAgICAgbGVuIC0tO1xuICAgIC8vIERvIG5vdCBvdXRwdXQgdGhlIGxhc3QgXFxuIGlmIHByZXNlbnRcbiAgICAvLyBhcyBjb25zb2xlIGxvZ2dpbmcgZGlzcGxheSBhIG5ld2xpbmUgYXQgdGhlIGVuZFxuICAgIHZhciBzcmMgPSBjYW1sX2NyZWF0ZV9ieXRlcyhsZW4pO1xuICAgIGNhbWxfYmxpdF9ieXRlcyhjYW1sX2J5dGVzX29mX2FycmF5KGJ1ZiksIHBvcywgc3JjLCAwLCBsZW4pO1xuICAgIHRoaXMubG9nKHNyYy50b1V0ZjE2KCkpO1xuICAgIHJldHVybiAwO1xuICB9XG4gIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHRoaXMuZmQgICsgXCI6IGZpbGUgZGVzY3JpcHRvciBhbHJlYWR5IGNsb3NlZFwiKTtcbn1cbk1sRmFrZUZkX291dC5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIChvZmZzZXQsIGJ1ZiwgcG9zLCBsZW4pIHtcbiAgY2FtbF9yYWlzZV9zeXNfZXJyb3IodGhpcy5mZCAgKyBcIjogZmlsZSBkZXNjcmlwdG9yIGlzIHdyaXRlIG9ubHlcIik7XG59XG5NbEZha2VGZF9vdXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmxvZyA9IHVuZGVmaW5lZDtcbn1cblxuXG4vL1Byb3ZpZGVzOiBNbEZha2VGZFxuLy9SZXF1aXJlczogTWxGYWtlRmlsZVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXNfZXJyb3JcbmZ1bmN0aW9uIE1sRmFrZUZkKG5hbWUsIGZpbGUsZmxhZ3MpIHtcbiAgdGhpcy5maWxlID0gZmlsZTtcbiAgdGhpcy5uYW1lID0gbmFtZTtcbiAgdGhpcy5mbGFncyA9IGZsYWdzO1xufVxuXG5NbEZha2VGZC5wcm90b3R5cGUuZXJyX2Nsb3NlZCA9IGZ1bmN0aW9uICgpIHtcbiAgY2FtbF9yYWlzZV9zeXNfZXJyb3IodGhpcy5uYW1lICArIFwiOiBmaWxlIGRlc2NyaXB0b3IgYWxyZWFkeSBjbG9zZWRcIik7XG59XG5NbEZha2VGZC5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24oKSB7XG4gIGlmKHRoaXMuZmlsZSkgcmV0dXJuIHRoaXMuZmlsZS5sZW5ndGggKClcbiAgdGhpcy5lcnJfY2xvc2VkKCk7XG59XG5NbEZha2VGZC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAob2Zmc2V0LGJ1Zixwb3MsbGVuKSB7XG4gIGlmKHRoaXMuZmlsZSkgcmV0dXJuIHRoaXMuZmlsZS53cml0ZShvZmZzZXQsYnVmLHBvcyxsZW4pXG4gIHRoaXMuZXJyX2Nsb3NlZCgpO1xufVxuTWxGYWtlRmQucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAob2Zmc2V0LCBidWYsIHBvcywgbGVuKSB7XG4gIGlmKHRoaXMuZmlsZSkgcmV0dXJuIHRoaXMuZmlsZS5yZWFkKG9mZnNldCwgYnVmLCBwb3MsIGxlbilcbiAgdGhpcy5lcnJfY2xvc2VkKCk7XG59XG5NbEZha2VGZC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZmlsZSA9IHVuZGVmaW5lZDtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxMCBKw6lyw7RtZSBWb3VpbGxvblxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X29mZnNldFxudmFyIGNhbWxfaW50NjRfb2Zmc2V0ID0gTWF0aC5wb3coMiwgLTI0KTtcblxuLy9Qcm92aWRlczogTWxJbnQ2NFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZmZzZXQsIGNhbWxfcmFpc2VfemVyb19kaXZpZGVcbmZ1bmN0aW9uIE1sSW50NjQgKGxvLG1pLGhpKSB7XG4gIHRoaXMubG8gPSBsbyAmIDB4ZmZmZmZmO1xuICB0aGlzLm1pID0gbWkgJiAweGZmZmZmZjtcbiAgdGhpcy5oaSA9IGhpICYgMHhmZmZmO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUuY2FtbF9jdXN0b20gPSBcIl9qXCJcbk1sSW50NjQucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBuZXcgTWxJbnQ2NCh0aGlzLmxvLHRoaXMubWksdGhpcy5oaSk7XG59XG5cbk1sSW50NjQucHJvdG90eXBlLnVjb21wYXJlID0gZnVuY3Rpb24gKHgpIHtcbiAgaWYgKHRoaXMuaGkgPiB4LmhpKSByZXR1cm4gMTtcbiAgaWYgKHRoaXMuaGkgPCB4LmhpKSByZXR1cm4gLTE7XG4gIGlmICh0aGlzLm1pID4geC5taSkgcmV0dXJuIDE7XG4gIGlmICh0aGlzLm1pIDwgeC5taSkgcmV0dXJuIC0xO1xuICBpZiAodGhpcy5sbyA+IHgubG8pIHJldHVybiAxO1xuICBpZiAodGhpcy5sbyA8IHgubG8pIHJldHVybiAtMTtcbiAgcmV0dXJuIDA7XG59XG5NbEludDY0LnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gKHgpIHtcbiAgdmFyIGhpID0gdGhpcy5oaSA8PCAxNjtcbiAgdmFyIHhoaSA9IHguaGkgPDwgMTY7XG4gIGlmIChoaSA+IHhoaSkgcmV0dXJuIDE7XG4gIGlmIChoaSA8IHhoaSkgcmV0dXJuIC0xO1xuICBpZiAodGhpcy5taSA+IHgubWkpIHJldHVybiAxO1xuICBpZiAodGhpcy5taSA8IHgubWkpIHJldHVybiAtMTtcbiAgaWYgKHRoaXMubG8gPiB4LmxvKSByZXR1cm4gMTtcbiAgaWYgKHRoaXMubG8gPCB4LmxvKSByZXR1cm4gLTE7XG4gIHJldHVybiAwO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUubmVnID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbG8gPSAtIHRoaXMubG87XG4gIHZhciBtaSA9IC0gdGhpcy5taSArIChsbyA+PiAyNCk7XG4gIHZhciBoaSA9IC0gdGhpcy5oaSArIChtaSA+PiAyNCk7XG4gIHJldHVybiBuZXcgTWxJbnQ2NChsbywgbWksIGhpKTtcbn1cbk1sSW50NjQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICh4KSB7XG4gIHZhciBsbyA9IHRoaXMubG8gKyB4LmxvO1xuICB2YXIgbWkgPSB0aGlzLm1pICsgeC5taSArIChsbyA+PiAyNCk7XG4gIHZhciBoaSA9IHRoaXMuaGkgKyB4LmhpICsgKG1pID4+IDI0KTtcbiAgcmV0dXJuIG5ldyBNbEludDY0KGxvLCBtaSwgaGkpO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUuc3ViID0gZnVuY3Rpb24gKHgpIHtcbiAgdmFyIGxvID0gdGhpcy5sbyAtIHgubG87XG4gIHZhciBtaSA9IHRoaXMubWkgLSB4Lm1pICsgKGxvID4+IDI0KTtcbiAgdmFyIGhpID0gdGhpcy5oaSAtIHguaGkgKyAobWkgPj4gMjQpO1xuICByZXR1cm4gbmV3IE1sSW50NjQobG8sIG1pLCBoaSk7XG59XG5NbEludDY0LnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbiAoeCkge1xuICB2YXIgbG8gPSB0aGlzLmxvICogeC5sbztcbiAgdmFyIG1pID0gKChsbyAqIGNhbWxfaW50NjRfb2Zmc2V0KSB8IDApICsgdGhpcy5taSAqIHgubG8gKyB0aGlzLmxvICogeC5taTtcbiAgdmFyIGhpID0gKChtaSAqIGNhbWxfaW50NjRfb2Zmc2V0KSB8IDApICsgdGhpcy5oaSAqIHgubG8gKyB0aGlzLm1pICogeC5taSArIHRoaXMubG8gKiB4LmhpO1xuICByZXR1cm4gbmV3IE1sSW50NjQobG8sIG1pLCBoaSk7XG59XG5NbEludDY0LnByb3RvdHlwZS5pc1plcm8gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAodGhpcy5sb3x0aGlzLm1pfHRoaXMuaGkpID09IDA7XG59XG5NbEludDY0LnByb3RvdHlwZS5pc05lZyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICh0aGlzLmhpIDw8IDE2KSA8IDA7XG59XG5NbEludDY0LnByb3RvdHlwZS5hbmQgPSBmdW5jdGlvbiAoeCkge1xuICByZXR1cm4gbmV3IE1sSW50NjQodGhpcy5sbyAmIHgubG8sIHRoaXMubWkgJiB4Lm1pLCB0aGlzLmhpICYgeC5oaSk7XG59XG5NbEludDY0LnByb3RvdHlwZS5vciA9IGZ1bmN0aW9uICh4KSB7XG4gIHJldHVybiBuZXcgTWxJbnQ2NCh0aGlzLmxvfHgubG8sIHRoaXMubWl8eC5taSwgdGhpcy5oaXx4LmhpKTtcbn1cbk1sSW50NjQucHJvdG90eXBlLnhvciA9IGZ1bmN0aW9uICh4KSB7XG4gIHJldHVybiBuZXcgTWxJbnQ2NCh0aGlzLmxvXngubG8sIHRoaXMubWleeC5taSwgdGhpcy5oaV54LmhpKTtcbn1cbk1sSW50NjQucHJvdG90eXBlLnNoaWZ0X2xlZnQgPSBmdW5jdGlvbiAocykge1xuICBzID0gcyAmIDYzO1xuICBpZiAocyA9PSAwKSByZXR1cm4gdGhpcztcbiAgaWYgKHMgPCAyNCkge1xuICAgIHJldHVybiBuZXcgTWxJbnQ2NCAodGhpcy5sbyA8PCBzLFxuICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMubWkgPDwgcykgfCAodGhpcy5sbyA+PiAoMjQgLSBzKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAodGhpcy5oaSA8PCBzKSB8ICh0aGlzLm1pID4+ICgyNCAtIHMpKSk7XG4gIH1cbiAgaWYgKHMgPCA0OClcbiAgICByZXR1cm4gbmV3IE1sSW50NjQgKDAsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvIDw8IChzIC0gMjQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMubWkgPDwgKHMgLSAyNCkpIHwgKHRoaXMubG8gPj4gKDQ4IC0gcykpKTtcbiAgcmV0dXJuIG5ldyBNbEludDY0KDAsIDAsIHRoaXMubG8gPDwgKHMgLSA0OCkpXG59XG5NbEludDY0LnByb3RvdHlwZS5zaGlmdF9yaWdodF91bnNpZ25lZCA9IGZ1bmN0aW9uIChzKSB7XG4gIHMgPSBzICYgNjM7XG4gIGlmIChzID09IDApIHJldHVybiB0aGlzO1xuICBpZiAocyA8IDI0KVxuICAgIHJldHVybiBuZXcgTWxJbnQ2NCAoXG4gICAgICAodGhpcy5sbyA+PiBzKSB8ICh0aGlzLm1pIDw8ICgyNCAtIHMpKSxcbiAgICAgICh0aGlzLm1pID4+IHMpIHwgKHRoaXMuaGkgPDwgKDI0IC0gcykpLFxuICAgICAgKHRoaXMuaGkgPj4gcykpO1xuICBpZiAocyA8IDQ4KVxuICAgIHJldHVybiBuZXcgTWxJbnQ2NCAoXG4gICAgICAodGhpcy5taSA+PiAocyAtIDI0KSkgfCAodGhpcy5oaSA8PCAoNDggLSBzKSksXG4gICAgICAodGhpcy5oaSA+PiAocyAtIDI0KSksXG4gICAgICAwKTtcbiAgcmV0dXJuIG5ldyBNbEludDY0ICh0aGlzLmhpID4+IChzIC0gNDgpLCAwLCAwKTtcbn1cbk1sSW50NjQucHJvdG90eXBlLnNoaWZ0X3JpZ2h0ID0gZnVuY3Rpb24gKHMpIHtcbiAgcyA9IHMgJiA2MztcbiAgaWYgKHMgPT0gMCkgcmV0dXJuIHRoaXM7XG4gIHZhciBoID0gKHRoaXMuaGkgPDwgMTYpID4+IDE2O1xuICBpZiAocyA8IDI0KVxuICAgIHJldHVybiBuZXcgTWxJbnQ2NCAoXG4gICAgICAodGhpcy5sbyA+PiBzKSB8ICh0aGlzLm1pIDw8ICgyNCAtIHMpKSxcbiAgICAgICh0aGlzLm1pID4+IHMpIHwgKGggPDwgKDI0IC0gcykpLFxuICAgICAgKCh0aGlzLmhpIDw8IDE2KSA+PiBzKSA+Pj4gMTYpO1xuICB2YXIgc2lnbiA9ICh0aGlzLmhpIDw8IDE2KSA+PiAzMTtcbiAgaWYgKHMgPCA0OClcbiAgICByZXR1cm4gbmV3IE1sSW50NjQgKFxuICAgICAgKHRoaXMubWkgPj4gKHMgLSAyNCkpIHwgKHRoaXMuaGkgPDwgKDQ4IC0gcykpLFxuICAgICAgKHRoaXMuaGkgPDwgMTYpID4+IChzIC0gMjQpID4+IDE2LFxuICAgICAgc2lnbiAmIDB4ZmZmZik7XG4gIHJldHVybiBuZXcgTWxJbnQ2NCAoKHRoaXMuaGkgPDwgMTYpID4+IChzIC0gMzIpLCBzaWduLCBzaWduKTtcbn1cbk1sSW50NjQucHJvdG90eXBlLmxzbDEgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuaGkgPSAodGhpcy5oaSA8PCAxKSB8ICh0aGlzLm1pID4+IDIzKTtcbiAgdGhpcy5taSA9ICgodGhpcy5taSA8PCAxKSB8ICh0aGlzLmxvID4+IDIzKSkgJiAweGZmZmZmZjtcbiAgdGhpcy5sbyA9ICh0aGlzLmxvIDw8IDEpICYgMHhmZmZmZmY7XG59XG5NbEludDY0LnByb3RvdHlwZS5sc3IxID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmxvID0gKCh0aGlzLmxvID4+PiAxKSB8ICh0aGlzLm1pIDw8IDIzKSkgJiAweGZmZmZmZjtcbiAgdGhpcy5taSA9ICgodGhpcy5taSA+Pj4gMSkgfCAodGhpcy5oaSA8PCAyMykpICYgMHhmZmZmZmY7XG4gIHRoaXMuaGkgPSB0aGlzLmhpID4+PiAxO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUudWRpdm1vZCA9IGZ1bmN0aW9uICh4KSB7XG4gIHZhciBvZmZzZXQgPSAwO1xuICB2YXIgbW9kdWx1cyA9IHRoaXMuY29weSgpO1xuICB2YXIgZGl2aXNvciA9IHguY29weSgpO1xuICB2YXIgcXVvdGllbnQgPSBuZXcgTWxJbnQ2NCgwLDAsMCk7XG4gIHdoaWxlIChtb2R1bHVzLnVjb21wYXJlKGRpdmlzb3IpID4gMCkge1xuICAgIG9mZnNldCsrO1xuICAgIGRpdmlzb3IubHNsMSgpO1xuICB9XG4gIHdoaWxlIChvZmZzZXQgPj0gMCkge1xuICAgIG9mZnNldCAtLTtcbiAgICBxdW90aWVudC5sc2wxKCk7XG4gICAgaWYgKG1vZHVsdXMudWNvbXBhcmUoZGl2aXNvcikgPj0gMCkge1xuICAgICAgcXVvdGllbnQubG8gKys7XG4gICAgICBtb2R1bHVzID0gbW9kdWx1cy5zdWIoZGl2aXNvcik7XG4gICAgfVxuICAgIGRpdmlzb3IubHNyMSgpO1xuICB9XG4gIHJldHVybiB7IHF1b3RpZW50IDogcXVvdGllbnQsIG1vZHVsdXMgOiBtb2R1bHVzIH07XG59XG5NbEludDY0LnByb3RvdHlwZS5kaXYgPSBmdW5jdGlvbiAoeSlcbntcbiAgdmFyIHggPSB0aGlzO1xuICBpZiAoeS5pc1plcm8oKSkgY2FtbF9yYWlzZV96ZXJvX2RpdmlkZSAoKTtcbiAgdmFyIHNpZ24gPSB4LmhpIF4geS5oaTtcbiAgaWYgKHguaGkgJiAweDgwMDApIHggPSB4Lm5lZygpO1xuICBpZiAoeS5oaSAmIDB4ODAwMCkgeSA9IHkubmVnKCk7XG4gIHZhciBxID0geC51ZGl2bW9kKHkpLnF1b3RpZW50O1xuICBpZiAoc2lnbiAmIDB4ODAwMCkgcSA9IHEubmVnKCk7XG4gIHJldHVybiBxO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUubW9kID0gZnVuY3Rpb24gKHkpXG57XG4gIHZhciB4ID0gdGhpcztcbiAgaWYgKHkuaXNaZXJvKCkpIGNhbWxfcmFpc2VfemVyb19kaXZpZGUgKCk7XG4gIHZhciBzaWduID0geC5oaTtcbiAgaWYgKHguaGkgJiAweDgwMDApIHggPSB4Lm5lZygpO1xuICBpZiAoeS5oaSAmIDB4ODAwMCkgeSA9IHkubmVnKCk7XG4gIHZhciByID0geC51ZGl2bW9kKHkpLm1vZHVsdXM7XG4gIGlmIChzaWduICYgMHg4MDAwKSByID0gci5uZWcoKTtcbiAgcmV0dXJuIHI7XG59XG5NbEludDY0LnByb3RvdHlwZS50b0ludCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubG8gfCAodGhpcy5taSA8PCAyNCk7XG59XG5NbEludDY0LnByb3RvdHlwZS50b0Zsb2F0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gKCh0aGlzLmhpIDw8IDE2KSAqIE1hdGgucG93KDIsIDMyKSArIHRoaXMubWkgKiBNYXRoLnBvdygyLCAyNCkpICsgdGhpcy5sbztcbn1cbk1sSW50NjQucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBbdGhpcy5oaSA+PiA4LFxuICAgICAgICAgIHRoaXMuaGkgJiAweGZmLFxuICAgICAgICAgIHRoaXMubWkgPj4gMTYsXG4gICAgICAgICAgKHRoaXMubWkgPj4gOCkgJiAweGZmLFxuICAgICAgICAgIHRoaXMubWkgJiAweGZmLFxuICAgICAgICAgIHRoaXMubG8gPj4gMTYsXG4gICAgICAgICAgKHRoaXMubG8gPj4gOCkgJiAweGZmLFxuICAgICAgICAgIHRoaXMubG8gJiAweGZmXTtcbn1cbk1sSW50NjQucHJvdG90eXBlLmxvMzIgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmxvIHwgKCh0aGlzLm1pICYgMHhmZikgPDwgMjQpO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUuaGkzMiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICgodGhpcy5taSA+Pj4gOCkgJiAweGZmZmYpIHwgKHRoaXMuaGkgPDwgMTYpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3VsdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF91bHQoeCx5KSB7IHJldHVybiB4LnVjb21wYXJlKHkpIDwgMDsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2NvbXBhcmUgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfY29tcGFyZSh4LHksIHRvdGFsKSB7IHJldHVybiB4LmNvbXBhcmUoeSkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X25lZyBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9uZWcgKHgpIHsgcmV0dXJuIHgubmVnKCkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2FkZCBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9hZGQgKHgsIHkpIHsgcmV0dXJuIHguYWRkKHkpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9zdWIgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfc3ViICh4LCB5KSB7IHJldHVybiB4LnN1Yih5KSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfbXVsIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mZnNldFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9tdWwoeCx5KSB7IHJldHVybiB4Lm11bCh5KSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfaXNfemVybyBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9pc196ZXJvKHgpIHsgcmV0dXJuICt4LmlzWmVybygpOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfaXNfbmVnYXRpdmUgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfaXNfbmVnYXRpdmUoeCkgeyByZXR1cm4gK3guaXNOZWcoKTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2FuZCBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9hbmQgKHgsIHkpIHsgcmV0dXJuIHguYW5kKHkpOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfb3IgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfb3IgKHgsIHkpIHsgcmV0dXJuIHgub3IoeSk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF94b3IgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfeG9yICh4LCB5KSB7IHJldHVybiB4Lnhvcih5KSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfc2hpZnRfbGVmdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9zaGlmdF9sZWZ0ICh4LCBzKSB7IHJldHVybiB4LnNoaWZ0X2xlZnQocykgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0X3Vuc2lnbmVkIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0X3Vuc2lnbmVkICh4LCBzKSB7IHJldHVybiB4LnNoaWZ0X3JpZ2h0X3Vuc2lnbmVkKHMpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9zaGlmdF9yaWdodCBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9zaGlmdF9yaWdodCAoeCwgcykgeyByZXR1cm4geC5zaGlmdF9yaWdodChzKSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfZGl2IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2RpdiAoeCwgeSkgeyByZXR1cm4geC5kaXYoeSkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X21vZCBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9tb2QgKHgsIHkpIHsgcmV0dXJuIHgubW9kKHkpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9vZl9pbnQzMiBjb25zdFxuLy9SZXF1aXJlczogTWxJbnQ2NFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9vZl9pbnQzMiAoeCkge1xuICByZXR1cm4gbmV3IE1sSW50NjQoeCAmIDB4ZmZmZmZmLCAoeCA+PiAyNCkgJiAweGZmZmZmZiwgKHggPj4gMzEpICYgMHhmZmZmKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3RvX2ludDMyIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X3RvX2ludDMyICh4KSB7IHJldHVybiB4LnRvSW50KCkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3RvX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X3RvX2Zsb2F0ICh4KSB7IHJldHVybiB4LnRvRmxvYXQgKCkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X29mX2Zsb2F0IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mZnNldCwgTWxJbnQ2NFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9vZl9mbG9hdCAoeCkge1xuICBpZiAoeCA8IDApIHggPSBNYXRoLmNlaWwoeCk7XG4gIHJldHVybiBuZXcgTWxJbnQ2NChcbiAgICB4ICYgMHhmZmZmZmYsXG4gICAgTWF0aC5mbG9vcih4ICogY2FtbF9pbnQ2NF9vZmZzZXQpICYgMHhmZmZmZmYsXG4gICAgTWF0aC5mbG9vcih4ICogY2FtbF9pbnQ2NF9vZmZzZXQgKiBjYW1sX2ludDY0X29mZnNldCkgJiAweGZmZmYpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2Zvcm1hdCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9wYXJzZV9mb3JtYXQsIGNhbWxfZmluaXNoX2Zvcm1hdHRpbmdcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfaXNfbmVnYXRpdmUsIGNhbWxfaW50NjRfbmVnXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2ludDMyLCBjYW1sX2ludDY0X3RvX2ludDMyXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2lzX3plcm8sIGNhbWxfc3RyX3JlcGVhdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9mb3JtYXQgKGZtdCwgeCkge1xuICB2YXIgZiA9IGNhbWxfcGFyc2VfZm9ybWF0KGZtdCk7XG4gIGlmIChmLnNpZ25lZGNvbnYgJiYgY2FtbF9pbnQ2NF9pc19uZWdhdGl2ZSh4KSkge1xuICAgIGYuc2lnbiA9IC0xOyB4ID0gY2FtbF9pbnQ2NF9uZWcoeCk7XG4gIH1cbiAgdmFyIGJ1ZmZlciA9IFwiXCI7XG4gIHZhciB3YmFzZSA9IGNhbWxfaW50NjRfb2ZfaW50MzIoZi5iYXNlKTtcbiAgdmFyIGN2dGJsID0gXCIwMTIzNDU2Nzg5YWJjZGVmXCI7XG4gIGRvIHtcbiAgICB2YXIgcCA9IHgudWRpdm1vZCh3YmFzZSk7XG4gICAgeCA9IHAucXVvdGllbnQ7XG4gICAgYnVmZmVyID0gY3Z0YmwuY2hhckF0KGNhbWxfaW50NjRfdG9faW50MzIocC5tb2R1bHVzKSkgKyBidWZmZXI7XG4gIH0gd2hpbGUgKCEgY2FtbF9pbnQ2NF9pc196ZXJvKHgpKTtcbiAgaWYgKGYucHJlYyA+PSAwKSB7XG4gICAgZi5maWxsZXIgPSAnICc7XG4gICAgdmFyIG4gPSBmLnByZWMgLSBidWZmZXIubGVuZ3RoO1xuICAgIGlmIChuID4gMCkgYnVmZmVyID0gY2FtbF9zdHJfcmVwZWF0IChuLCAnMCcpICsgYnVmZmVyO1xuICB9XG4gIHJldHVybiBjYW1sX2ZpbmlzaF9mb3JtYXR0aW5nKGYsIGJ1ZmZlcik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfb2Zfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX3BhcnNlX3NpZ25fYW5kX2Jhc2UsIGNhbWxfZmFpbHdpdGgsIGNhbWxfcGFyc2VfZGlnaXRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfaW50MzIsIGNhbWxfaW50NjRfdWx0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2FkZCwgY2FtbF9pbnQ2NF9tdWwsIGNhbWxfaW50NjRfbmVnXG4vL1JlcXVpcmVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGgsY2FtbF9zdHJpbmdfdW5zYWZlX2dldCwgTWxJbnQ2NFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9vZl9zdHJpbmcocykge1xuICB2YXIgciA9IGNhbWxfcGFyc2Vfc2lnbl9hbmRfYmFzZSAocyk7XG4gIHZhciBpID0gclswXSwgc2lnbiA9IHJbMV0sIGJhc2UgPSByWzJdO1xuICB2YXIgYmFzZTY0ID0gY2FtbF9pbnQ2NF9vZl9pbnQzMihiYXNlKTtcbiAgdmFyIHRocmVzaG9sZCA9XG4gICAgICBuZXcgTWxJbnQ2NCgweGZmZmZmZiwgMHhmZmZmZmZmLCAweGZmZmYpLnVkaXZtb2QoYmFzZTY0KS5xdW90aWVudDtcbiAgdmFyIGMgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0KHMsIGkpO1xuICB2YXIgZCA9IGNhbWxfcGFyc2VfZGlnaXQoYyk7XG4gIGlmIChkIDwgMCB8fCBkID49IGJhc2UpIGNhbWxfZmFpbHdpdGgoXCJpbnRfb2Zfc3RyaW5nXCIpO1xuICB2YXIgcmVzID0gY2FtbF9pbnQ2NF9vZl9pbnQzMihkKTtcbiAgZm9yICg7Oykge1xuICAgIGkrKztcbiAgICBjID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldChzLCBpKTtcbiAgICBpZiAoYyA9PSA5NSkgY29udGludWU7XG4gICAgZCA9IGNhbWxfcGFyc2VfZGlnaXQoYyk7XG4gICAgaWYgKGQgPCAwIHx8IGQgPj0gYmFzZSkgYnJlYWs7XG4gICAgLyogRGV0ZWN0IG92ZXJmbG93IGluIG11bHRpcGxpY2F0aW9uIGJhc2UgKiByZXMgKi9cbiAgICBpZiAoY2FtbF9pbnQ2NF91bHQodGhyZXNob2xkLCByZXMpKSBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgICBkID0gY2FtbF9pbnQ2NF9vZl9pbnQzMihkKTtcbiAgICByZXMgPSBjYW1sX2ludDY0X2FkZChjYW1sX2ludDY0X211bChiYXNlNjQsIHJlcyksIGQpO1xuICAgIC8qIERldGVjdCBvdmVyZmxvdyBpbiBhZGRpdGlvbiAoYmFzZSAqIHJlcykgKyBkICovXG4gICAgaWYgKGNhbWxfaW50NjRfdWx0KHJlcywgZCkpIGNhbWxfZmFpbHdpdGgoXCJpbnRfb2Zfc3RyaW5nXCIpO1xuICB9XG4gIGlmIChpICE9IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSkgY2FtbF9mYWlsd2l0aChcImludF9vZl9zdHJpbmdcIik7XG4gIGlmIChiYXNlID09IDEwICYmIGNhbWxfaW50NjRfdWx0KG5ldyBNbEludDY0KDAsIDAsIDB4ODAwMCksIHJlcykpXG4gICAgY2FtbF9mYWlsd2l0aChcImludF9vZl9zdHJpbmdcIik7XG4gIGlmIChzaWduIDwgMCkgcmVzID0gY2FtbF9pbnQ2NF9uZWcocmVzKTtcbiAgcmV0dXJuIHJlcztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9jcmVhdGVfbG9fbWlfaGkgY29uc3Rcbi8vUmVxdWlyZXM6IE1sSW50NjRcbmZ1bmN0aW9uIGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpKGxvLCBtaSwgaGkpe1xuICByZXR1cm4gbmV3IE1sSW50NjQobG8sIG1pLCBoaSlcbn1cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfY3JlYXRlX2xvX2hpIGNvbnN0XG4vL1JlcXVpcmVzOiBNbEludDY0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2NyZWF0ZV9sb19oaShsbywgaGkpe1xuICByZXR1cm4gbmV3IE1sSW50NjQgKFxuICAgIGxvICYgMHhmZmZmZmYsXG4gICAgKChsbyA+Pj4gMjQpICYgMHhmZikgfCAoKGhpICYgMHhmZmZmKSA8PCA4KSxcbiAgICAoaGkgPj4+IDE2KSAmIDB4ZmZmZik7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2xvMzIgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfbG8zMih2KXsgcmV0dXJuIHYubG8zMigpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9oaTMyIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2hpMzIodil7IHJldHVybiB2LmhpMzIoKSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfb2ZfYnl0ZXMgY29uc3Rcbi8vUmVxdWlyZXM6IE1sSW50NjRcbmZ1bmN0aW9uIGNhbWxfaW50NjRfb2ZfYnl0ZXMoYSkge1xuICByZXR1cm4gbmV3IE1sSW50NjQoYVs3XSA8PCAwIHwgKGFbNl0gPDwgOCkgfCAoYVs1XSA8PCAxNiksXG4gICAgICAgICAgICAgICAgICAgICBhWzRdIDw8IDAgfCAoYVszXSA8PCA4KSB8IChhWzJdIDw8IDE2KSxcbiAgICAgICAgICAgICAgICAgICAgIGFbMV0gPDwgMCB8IChhWzBdIDw8IDgpKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfdG9fYnl0ZXMgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfdG9fYnl0ZXMoeCkgeyByZXR1cm4geC50b0FycmF5KCkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2hhc2ggY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfaGFzaCh2KXtcbiAgcmV0dXJuICh2LmxvMzIoKSkgXiAodi5oaTMyKCkpXG59XG4iLCJcbi8vUHJvdmlkZXM6IE1sTXV0ZXhcbmZ1bmN0aW9uIE1sTXV0ZXgoKSB7XG4gIHRoaXMubG9ja2VkID0gZmFsc2Vcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9tdXRleF9uZXdcbi8vUmVxdWlyZXM6IE1sTXV0ZXhcbmZ1bmN0aW9uIGNhbWxfbWxfbXV0ZXhfbmV3KHVuaXQpIHtcbiAgcmV0dXJuIG5ldyBNbE11dGV4KCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfbXV0ZXhfbG9ja1xuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9tbF9tdXRleF9sb2NrKHQpIHtcbiAgaWYodC5sb2NrZWQpXG4gICAgY2FtbF9mYWlsd2l0aChcIk11dGV4LmxvY2s6IG11dGV4IGFscmVhZHkgbG9ja2VkLiBDYW5ub3Qgd2FpdC5cIik7XG4gIGVsc2UgdC5sb2NrZWQgPSB0cnVlO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9tdXRleF90cnlfbG9ja1xuZnVuY3Rpb24gY2FtbF9tbF9tdXRleF90cnlfbG9jayh0KSB7XG4gIGlmKCF0LmxvY2tlZCkge1xuICAgIHQubG9ja2VkID0gdHJ1ZTtcbiAgICByZXR1cm4gMTtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9tdXRleF91bmxvY2tcbmZ1bmN0aW9uIGNhbWxfbWxfbXV0ZXhfdW5sb2NrKHQpIHtcbiAgdC5sb2NrZWQgPSBmYWxzZTtcbiAgcmV0dXJuIDA7XG59XG4iLCIvL1Byb3ZpZGVzOiBpbml0aWFsaXplX25hdFxuLy9SZXF1aXJlczogY2FtbF9jdXN0b21fb3BzXG4vL1JlcXVpcmVzOiBzZXJpYWxpemVfbmF0LCBkZXNlcmlhbGl6ZV9uYXQsIGNhbWxfaGFzaF9uYXRcbmZ1bmN0aW9uIGluaXRpYWxpemVfbmF0KCkge1xuICBjYW1sX2N1c3RvbV9vcHNbXCJfbmF0XCJdID1cbiAgICB7IGRlc2VyaWFsaXplIDogZGVzZXJpYWxpemVfbmF0LFxuICAgICAgc2VyaWFsaXplIDogc2VyaWFsaXplX25hdCxcbiAgICAgIGhhc2ggOiBjYW1sX2hhc2hfbmF0XG4gICAgfVxufVxuXG4vL1Byb3ZpZGVzOiBNbE5hdFxuZnVuY3Rpb24gTWxOYXQoeCl7XG4gIHRoaXMuZGF0YSA9IG5ldyBJbnQzMkFycmF5KHgpO1xuICAvLyBGb3IgbnVtIDwgMS41XG4gIC8vIGxlbmd0aF9uYXQgaXNuJ3QgZXh0ZXJuYWwsIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGUgT2JqLnNpemVcbiAgLy8gd29yayBvdXQgcmlnaHQuXG4gIC8vIFdlIGFkZCArMiB0byB0aGUgYXJyYXkgbGVuZ3RoOlxuICAvLyAtICsxIGZvciB0aGUgdGFnXG4gIC8vIC0gKzEgZm9yIHRoZSBjdXN0b21fb3BzIHNsb3RcbiAgdGhpcy5sZW5ndGggPSB0aGlzLmRhdGEubGVuZ3RoICsgMlxufVxuXG5NbE5hdC5wcm90b3R5cGUuY2FtbF9jdXN0b20gPSBcIl9uYXRcIjtcblxuLy9Qcm92aWRlczogY2FtbF9oYXNoX25hdFxuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9pbnQsIG51bV9kaWdpdHNfbmF0XG5mdW5jdGlvbiBjYW1sX2hhc2hfbmF0KHgpIHtcbiAgdmFyIGxlbiA9IG51bV9kaWdpdHNfbmF0KHgsIDAsIHguZGF0YS5sZW5ndGgpO1xuICB2YXIgaCA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgeC5kYXRhW2ldKTtcbiAgfVxuICByZXR1cm4gaDtcbn1cblxuLy9Qcm92aWRlczogbGVuZ3RoX25hdFxuZnVuY3Rpb24gbGVuZ3RoX25hdCh4KSB7XG4gIHJldHVybiB4LmRhdGEubGVuZ3RoO1xufVxuXG4vL1Byb3ZpZGVzOiBuYXRfb2ZfYXJyYXlcbi8vUmVxdWlyZXM6IE1sTmF0XG5mdW5jdGlvbiBuYXRfb2ZfYXJyYXkobCl7XG4gIHJldHVybiBuZXcgTWxOYXQobCk7XG59XG5cbi8vUHJvdmlkZXM6IGNyZWF0ZV9uYXRcbi8vUmVxdWlyZXM6IE1sTmF0XG5mdW5jdGlvbiBjcmVhdGVfbmF0KHNpemUpIHtcbiAgdmFyIGFyciA9IG5ldyBNbE5hdChzaXplKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgIGFyci5kYXRhW2ldID0gLTE7XG4gIH1cbiAgcmV0dXJuIGFycjtcbn1cblxuLy9Qcm92aWRlczogc2V0X3RvX3plcm9fbmF0XG5mdW5jdGlvbiBzZXRfdG9femVyb19uYXQobmF0LCBvZnMsIGxlbikge1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBuYXQuZGF0YVtvZnMraV0gPSAwO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBibGl0X25hdFxuZnVuY3Rpb24gYmxpdF9uYXQobmF0MSwgb2ZzMSwgbmF0Miwgb2ZzMiwgbGVuKSB7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIG5hdDEuZGF0YVtvZnMxK2ldID0gbmF0Mi5kYXRhW29mczIraV07XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IHNldF9kaWdpdF9uYXRcbmZ1bmN0aW9uIHNldF9kaWdpdF9uYXQobmF0LCBvZnMsIGRpZ2l0KSB7XG4gIG5hdC5kYXRhW29mc10gPSBkaWdpdDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IG50aF9kaWdpdF9uYXRcbmZ1bmN0aW9uIG50aF9kaWdpdF9uYXQobmF0LCBvZnMpIHtcbiAgcmV0dXJuIG5hdC5kYXRhW29mc107XG59XG5cbi8vUHJvdmlkZXM6IHNldF9kaWdpdF9uYXRfbmF0aXZlXG5mdW5jdGlvbiBzZXRfZGlnaXRfbmF0X25hdGl2ZShuYXQsIG9mcywgZGlnaXQpIHtcbiAgbmF0LmRhdGFbb2ZzXSA9IGRpZ2l0O1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogbnRoX2RpZ2l0X25hdF9uYXRpdmVcbmZ1bmN0aW9uIG50aF9kaWdpdF9uYXRfbmF0aXZlKG5hdCwgb2ZzKSB7XG4gIHJldHVybiBuYXQuZGF0YVtvZnNdO1xufVxuXG4vL1Byb3ZpZGVzOiBudW1fZGlnaXRzX25hdFxuZnVuY3Rpb24gbnVtX2RpZ2l0c19uYXQobmF0LCBvZnMsIGxlbikge1xuICBmb3IodmFyIGkgPSBsZW4gLSAxOyBpID49IDA7IGktLSkge1xuICAgIGlmKG5hdC5kYXRhW29mcytpXSAhPSAwKSByZXR1cm4gaSsxO1xuICB9XG4gIHJldHVybiAxOyAvLyAwIGNvdW50cyBhcyAxIGRpZ2l0XG59XG5cbi8vUHJvdmlkZXM6IG51bV9sZWFkaW5nX3plcm9fYml0c19pbl9kaWdpdFxuZnVuY3Rpb24gbnVtX2xlYWRpbmdfemVyb19iaXRzX2luX2RpZ2l0KG5hdCwgb2ZzKSB7XG4gIHZhciBhID0gbmF0LmRhdGFbb2ZzXTtcbiAgdmFyIGIgPSAwO1xuICBpZihhICYgMHhGRkZGMDAwMCkgeyBiICs9MTY7IGEgPj4+PTE2OyB9XG4gIGlmKGEgJiAweEZGMDApICAgICB7IGIgKz0gODsgYSA+Pj49IDg7IH1cbiAgaWYoYSAmIDB4RjApICAgICAgIHsgYiArPSA0OyBhID4+Pj0gNDsgfVxuICBpZihhICYgMTIpICAgICAgICAgeyBiICs9IDI7IGEgPj4+PSAyOyB9XG4gIGlmKGEgJiAyKSAgICAgICAgICB7IGIgKz0gMTsgYSA+Pj49IDE7IH1cbiAgaWYoYSAmIDEpICAgICAgICAgIHsgYiArPSAxOyB9XG4gIHJldHVybiAzMiAtIGI7XG59XG5cbi8vUHJvdmlkZXM6IGlzX2RpZ2l0X2ludFxuZnVuY3Rpb24gaXNfZGlnaXRfaW50KG5hdCwgb2ZzKSB7XG4gIGlmIChuYXQuZGF0YVtvZnNdID49IDApIHJldHVybiAxXG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBpc19kaWdpdF96ZXJvXG5mdW5jdGlvbiBpc19kaWdpdF96ZXJvKG5hdCwgb2ZzKSB7XG4gIGlmKG5hdC5kYXRhW29mc10gPT0gMCkgcmV0dXJuIDE7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBpc19kaWdpdF9vZGRcbmZ1bmN0aW9uIGlzX2RpZ2l0X29kZChuYXQsIG9mcykge1xuICBpZihuYXQuZGF0YVtvZnNdICYgMSkgcmV0dXJuIDE7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBpbmNyX25hdFxuZnVuY3Rpb24gaW5jcl9uYXQobmF0LCBvZnMsIGxlbiwgY2FycnlfaW4pIHtcbiAgdmFyIGNhcnJ5ID0gY2FycnlfaW47XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciB4ID0gKG5hdC5kYXRhW29mcytpXSA+Pj4gMCkgKyBjYXJyeTtcbiAgICBuYXQuZGF0YVtvZnMraV0gPSAoeCB8IDApO1xuICAgIGlmKHggPT0gKHggPj4+IDApKSB7XG4gICAgICBjYXJyeSA9IDA7XG4gICAgICBicmVhaztcbiAgICB9IGVsc2Uge1xuICAgICAgY2FycnkgPSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY2Fycnk7XG59XG5cbi8vIGxlbjEgPj0gbGVuMlxuLy9Qcm92aWRlczogYWRkX25hdFxuLy9SZXF1aXJlczogaW5jcl9uYXRcbmZ1bmN0aW9uIGFkZF9uYXQobmF0MSwgb2ZzMSwgbGVuMSwgbmF0Miwgb2ZzMiwgbGVuMiwgY2FycnlfaW4pIHtcbiAgdmFyIGNhcnJ5ID0gY2FycnlfaW47XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW4yOyBpKyspIHtcbiAgICB2YXIgeCA9IChuYXQxLmRhdGFbb2ZzMStpXSA+Pj4gMCkgKyAobmF0Mi5kYXRhW29mczIraV0gPj4+IDApICsgY2Fycnk7XG4gICAgbmF0MS5kYXRhW29mczEraV0gPSB4XG4gICAgaWYoeCA9PSAoeCA+Pj4gMCkpIHtcbiAgICAgIGNhcnJ5ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FycnkgPSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaW5jcl9uYXQobmF0MSwgb2ZzMStsZW4yLCBsZW4xLWxlbjIsIGNhcnJ5KTtcbn1cblxuLy9Qcm92aWRlczogY29tcGxlbWVudF9uYXRcbmZ1bmN0aW9uIGNvbXBsZW1lbnRfbmF0KG5hdCwgb2ZzLCBsZW4pIHtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgbmF0LmRhdGFbb2ZzK2ldID0gKC0xID4+PiAwKSAtIChuYXQuZGF0YVtvZnMraV0gPj4+IDApO1xuICB9XG59XG5cbi8vIG9jYW1sIGZsaXBzIGNhcnJ5X2luXG4vL1Byb3ZpZGVzOiBkZWNyX25hdFxuZnVuY3Rpb24gZGVjcl9uYXQobmF0LCBvZnMsIGxlbiwgY2FycnlfaW4pIHtcbiAgdmFyIGJvcnJvdyA9IChjYXJyeV9pbiA9PSAxKSA/IDAgOiAxO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgeCA9IChuYXQuZGF0YVtvZnMraV0gPj4+MCkgLSBib3Jyb3c7XG4gICAgbmF0LmRhdGFbb2ZzK2ldID0geDtcbiAgICBpZiAoeCA+PSAwKSB7XG4gICAgICBib3Jyb3cgPSAwO1xuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJvcnJvdyA9IDE7XG4gICAgfVxuICB9XG4gIHJldHVybiAoYm9ycm93ID09IDEpID8gMCA6IDE7XG59XG5cbi8vIG9jYW1sIGZsaXBzIGNhcnJ5X2luXG4vLyBsZW4xID49IGxlbjJcbi8vUHJvdmlkZXM6IHN1Yl9uYXRcbi8vUmVxdWlyZXM6IGRlY3JfbmF0XG5mdW5jdGlvbiBzdWJfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIGxlbjIsIGNhcnJ5X2luKSB7XG4gIHZhciBib3Jyb3cgPSAoY2FycnlfaW4gPT0gMSkgPyAwIDogMTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjI7IGkrKykge1xuICAgIHZhciB4ID0gKG5hdDEuZGF0YVtvZnMxK2ldID4+PiAwKSAtIChuYXQyLmRhdGFbb2ZzMitpXSA+Pj4gMCkgLSBib3Jyb3c7XG4gICAgbmF0MS5kYXRhW29mczEraV0gPSB4O1xuICAgIGlmICh4ID49IDApIHtcbiAgICAgIGJvcnJvdyA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJvcnJvdyA9IDE7XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWNyX25hdChuYXQxLCBvZnMxK2xlbjIsIGxlbjEtbGVuMiwgKGJvcnJvdz09MSk/MDoxKTtcbn1cblxuLy8gbmF0MSArPSBuYXQyICogbmF0M1tvZnMzXVxuLy8gbGVuMSA+PSBsZW4yXG4vL1Byb3ZpZGVzOiBtdWx0X2RpZ2l0X25hdFxuLy9SZXF1aXJlczogYWRkX25hdCwgbmF0X29mX2FycmF5XG5mdW5jdGlvbiBtdWx0X2RpZ2l0X25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBsZW4yLCBuYXQzLCBvZnMzKSB7XG4gIHZhciBjYXJyeSA9IDA7XG4gIHZhciBhID0gKG5hdDMuZGF0YVtvZnMzXSA+Pj4gMCk7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW4yOyBpKyspIHtcbiAgICB2YXIgeDEgPSAobmF0MS5kYXRhW29mczEraV0gPj4+IDApICsgKG5hdDIuZGF0YVtvZnMyK2ldID4+PiAwKSAqIChhICYgMHgwMDAwRkZGRikgKyBjYXJyeTtcbiAgICB2YXIgeDIgPSAobmF0Mi5kYXRhW29mczIraV0gPj4+IDApICogKGEgPj4+IDE2KTtcbiAgICBjYXJyeSA9IE1hdGguZmxvb3IoeDIvNjU1MzYpO1xuICAgIHZhciB4MyA9IHgxICsgKHgyICUgNjU1MzYpICogNjU1MzY7XG4gICAgbmF0MS5kYXRhW29mczEraV0gPSB4MztcbiAgICBjYXJyeSArPSBNYXRoLmZsb29yKHgzLzQyOTQ5NjcyOTYpO1xuICB9XG5cbiAgaWYobGVuMiA8IGxlbjEgJiYgY2FycnkpIHtcbiAgICByZXR1cm4gYWRkX25hdChuYXQxLCBvZnMxK2xlbjIsIGxlbjEtbGVuMiwgbmF0X29mX2FycmF5KFtjYXJyeV0pLCAwLCAxLCAwKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY2Fycnk7XG4gIH1cbn1cblxuLy8gbmF0MSArPSBuYXQyICogbmF0M1xuLy8gbGVuMSA+PSBsZW4yICsgbGVuMy5cbi8vUHJvdmlkZXM6IG11bHRfbmF0XG4vL1JlcXVpcmVzOiBtdWx0X2RpZ2l0X25hdFxuZnVuY3Rpb24gbXVsdF9uYXQobmF0MSwgb2ZzMSwgbGVuMSwgbmF0Miwgb2ZzMiwgbGVuMiwgbmF0Mywgb2ZzMywgbGVuMykge1xuICB2YXIgY2FycnkgPSAwO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuMzsgaSsrKSB7XG4gICAgY2FycnkgKz0gbXVsdF9kaWdpdF9uYXQobmF0MSwgb2ZzMStpLCBsZW4xLWksIG5hdDIsIG9mczIsIGxlbjIsIG5hdDMsIG9mczMraSk7XG4gIH1cbiAgcmV0dXJuIGNhcnJ5O1xufVxuXG4vLyBuYXQxID0gMiAqIG5hdDEgKyBuYXQyICogbmF0MlxuLy8gbGVuMSA+PSAyICogbGVuMlxuLy9Qcm92aWRlczogc3F1YXJlX25hdFxuLy9SZXF1aXJlczogbXVsdF9uYXQsIGFkZF9uYXRcbmZ1bmN0aW9uIHNxdWFyZV9uYXQobmF0MSwgb2ZzMSwgbGVuMSwgbmF0Miwgb2ZzMiwgbGVuMikge1xuICB2YXIgY2FycnkgPSAwO1xuICBjYXJyeSArPSBhZGRfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDEsIG9mczEsIGxlbjEsIDApO1xuICBjYXJyeSArPSBtdWx0X25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBsZW4yLCBuYXQyLCBvZnMyLCBsZW4yKTtcbiAgcmV0dXJuIGNhcnJ5O1xufVxuXG5cbi8vIDAgPD0gc2hpZnQgPCAzMlxuLy9Qcm92aWRlczogc2hpZnRfbGVmdF9uYXRcbmZ1bmN0aW9uIHNoaWZ0X2xlZnRfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIG5iaXRzKSB7XG4gIGlmKG5iaXRzID09IDApIHtcbiAgICBuYXQyLmRhdGFbb2ZzMl0gPSAwO1xuICAgIHJldHVybiAwO1xuICB9XG4gIHZhciB3cmFwID0gMDtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjE7IGkrKykge1xuICAgIHZhciBhID0gKG5hdDEuZGF0YVtvZnMxK2ldID4+PiAwKTtcbiAgICBuYXQxLmRhdGFbb2ZzMStpXSA9IChhIDw8IG5iaXRzKSB8IHdyYXA7XG4gICAgd3JhcCA9IGEgPj4+ICgzMiAtIG5iaXRzKTtcbiAgfVxuICBuYXQyLmRhdGFbb2ZzMl0gPSB3cmFwO1xuICByZXR1cm4gMDtcbn1cblxuLy8gQXNzdW1pbmcgYyA+IGEsIHJldHVybnMgW3F1b3RpZW50LCByZW1haW5kZXJdIG9mIChhPDwzMiArIGIpL2Ncbi8vUHJvdmlkZXM6IGRpdl9oZWxwZXJcbmZ1bmN0aW9uIGRpdl9oZWxwZXIoYSwgYiwgYykge1xuICB2YXIgeCA9IGEgKiA2NTUzNiArIChiPj4+MTYpO1xuICB2YXIgeSA9IE1hdGguZmxvb3IoeC9jKSAqIDY1NTM2O1xuICB2YXIgeiA9ICh4ICUgYykgKiA2NTUzNjtcbiAgdmFyIHcgPSB6ICsgKGIgJiAweDAwMDBGRkZGKTtcbiAgcmV0dXJuIFt5ICsgTWF0aC5mbG9vcih3L2MpLCB3ICUgY107XG59XG5cbi8vIG5hdDFbb2ZzMStsZW5dIDwgbmF0MltvZnMyXVxuLy9Qcm92aWRlczogZGl2X2RpZ2l0X25hdFxuLy9SZXF1aXJlczogZGl2X2hlbHBlclxuZnVuY3Rpb24gZGl2X2RpZ2l0X25hdChuYXRxLCBvZnNxLCBuYXRyLCBvZnNyLCBuYXQxLCBvZnMxLCBsZW4sIG5hdDIsIG9mczIpIHtcbiAgdmFyIHJlbSA9IChuYXQxLmRhdGFbb2ZzMStsZW4tMV0gPj4+MCk7XG4gIC8vIG5hdHFbb2ZzcStsZW4tMV0gaXMgZ3VhcmFudGVlZCB0byBiZSB6ZXJvIChkdWUgdG8gdGhlIE1TRCByZXF1aXJlbWVudCksXG4gIC8vIGFuZCBzaG91bGQgbm90IGJlIHdyaXR0ZW4gdG8uXG4gIGZvcih2YXIgaSA9IGxlbi0yOyBpID49IDA7IGktLSkge1xuICAgIHZhciB4ID0gZGl2X2hlbHBlcihyZW0sIChuYXQxLmRhdGFbb2ZzMStpXSA+Pj4gMCksIChuYXQyLmRhdGFbb2ZzMl0gPj4+IDApKTtcbiAgICBuYXRxLmRhdGFbb2ZzcStpXSA9IHhbMF07XG4gICAgcmVtID0geFsxXTtcbiAgfVxuICBuYXRyLmRhdGFbb2Zzcl0gPSByZW07XG4gIHJldHVybiAwO1xufVxuXG4vLyBuYXQxW25hdDI6XSA6PSBuYXQxIC8gbmF0MlxuLy8gbmF0MVs6bmF0Ml0gOj0gbmF0MSAlIG5hdDJcbi8vIGxlbjEgPiBsZW4yLCBuYXQyW29mczIrbGVuMi0xXSA+IG5hdDFbb2ZzMStsZW4xLTFdXG4vL1Byb3ZpZGVzOiBkaXZfbmF0XG4vL1JlcXVpcmVzOiBkaXZfZGlnaXRfbmF0LCBkaXZfaGVscGVyLCBudW1fbGVhZGluZ196ZXJvX2JpdHNfaW5fZGlnaXQsIHNoaWZ0X2xlZnRfbmF0LCBzaGlmdF9yaWdodF9uYXQsIGNyZWF0ZV9uYXQsIHNldF90b196ZXJvX25hdCwgbXVsdF9kaWdpdF9uYXQsIHN1Yl9uYXQsIGNvbXBhcmVfbmF0LCBuYXRfb2ZfYXJyYXlcbmZ1bmN0aW9uIGRpdl9uYXQobmF0MSwgb2ZzMSwgbGVuMSwgbmF0Miwgb2ZzMiwgbGVuMikge1xuICBpZihsZW4yID09IDEpIHtcbiAgICBkaXZfZGlnaXRfbmF0KG5hdDEsIG9mczErMSwgbmF0MSwgb2ZzMSwgbmF0MSwgb2ZzMSwgbGVuMSwgbmF0Miwgb2ZzMik7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICB2YXIgcyA9IG51bV9sZWFkaW5nX3plcm9fYml0c19pbl9kaWdpdChuYXQyLCBvZnMyK2xlbjItMSk7XG4gIHNoaWZ0X2xlZnRfbmF0KG5hdDIsIG9mczIsIGxlbjIsIG5hdF9vZl9hcnJheShbMF0pLCAwLCBzKTtcbiAgc2hpZnRfbGVmdF9uYXQobmF0MSwgb2ZzMSwgbGVuMSwgbmF0X29mX2FycmF5KFswXSksIDAsIHMpO1xuXG4gIHZhciBkID0gKG5hdDIuZGF0YVtvZnMyK2xlbjItMV0gPj4+IDApICsgMTtcbiAgdmFyIGEgPSBjcmVhdGVfbmF0KGxlbjIrMSk7XG4gIGZvciAodmFyIGkgPSBsZW4xIC0gMTsgaSA+PSBsZW4yOyBpLS0pIHtcbiAgICAvLyBEZWNlbnQgbG93ZXIgYm91bmQgb24gcXVvXG4gICAgdmFyIHF1byA9IGQgPT0gNDI5NDk2NzI5NiA/IChuYXQxLmRhdGFbb2ZzMStpXSA+Pj4gMCkgOiBkaXZfaGVscGVyKChuYXQxLmRhdGFbb2ZzMStpXSA+Pj4gMCksIChuYXQxLmRhdGFbb2ZzMStpLTFdID4+PjApLCBkKVswXTtcbiAgICBzZXRfdG9femVyb19uYXQoYSwgMCwgbGVuMisxKTtcbiAgICBtdWx0X2RpZ2l0X25hdChhLCAwLCBsZW4yKzEsIG5hdDIsIG9mczIsIGxlbjIsIG5hdF9vZl9hcnJheShbcXVvXSksIDApO1xuICAgIHN1Yl9uYXQobmF0MSwgb2ZzMStpLWxlbjIsIGxlbjIrMSwgYSwgMCwgbGVuMisxLCAxKTtcblxuICAgIHdoaWxlIChuYXQxLmRhdGFbb2ZzMStpXSAhPSAwIHx8IGNvbXBhcmVfbmF0KG5hdDEsIG9mczEraS1sZW4yLCBsZW4yLCBuYXQyLCBvZnMyLCBsZW4yKSA+PSAwKSB7XG4gICAgICBxdW8gPSBxdW8gKyAxO1xuICAgICAgc3ViX25hdChuYXQxLCBvZnMxK2ktbGVuMiwgbGVuMisxLCBuYXQyLCBvZnMyLCBsZW4yLCAxKTtcbiAgICB9XG5cbiAgICBuYXQxLmRhdGFbb2ZzMStpXSA9IHF1bztcbiAgfVxuXG4gIHNoaWZ0X3JpZ2h0X25hdChuYXQxLCBvZnMxLCBsZW4yLCBuYXRfb2ZfYXJyYXkoWzBdKSwgMCwgcyk7IC8vIHNoaWZ0IHJlbWFpbmRlclxuICBzaGlmdF9yaWdodF9uYXQobmF0Miwgb2ZzMiwgbGVuMiwgbmF0X29mX2FycmF5KFswXSksIDAsIHMpOyAvLyByZXN0b3JlXG4gIHJldHVybiAwO1xufVxuXG5cbi8vIDAgPD0gc2hpZnQgPCAzMlxuLy9Qcm92aWRlczogc2hpZnRfcmlnaHRfbmF0XG5mdW5jdGlvbiBzaGlmdF9yaWdodF9uYXQobmF0MSwgb2ZzMSwgbGVuMSwgbmF0Miwgb2ZzMiwgbmJpdHMpIHtcbiAgaWYobmJpdHMgPT0gMCkge1xuICAgIG5hdDIuZGF0YVtvZnMyXSA9IDA7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgdmFyIHdyYXAgPSAwO1xuICBmb3IodmFyIGkgPSBsZW4xLTE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIGEgPSBuYXQxLmRhdGFbb2ZzMStpXSA+Pj4gMDtcbiAgICBuYXQxLmRhdGFbb2ZzMStpXSA9IChhID4+PiBuYml0cykgfCB3cmFwO1xuICAgIHdyYXAgPSBhIDw8ICgzMiAtIG5iaXRzKTtcbiAgfVxuICBuYXQyLmRhdGFbb2ZzMl0gPSB3cmFwO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY29tcGFyZV9kaWdpdHNfbmF0XG5mdW5jdGlvbiBjb21wYXJlX2RpZ2l0c19uYXQobmF0MSwgb2ZzMSwgbmF0Miwgb2ZzMikge1xuICBpZihuYXQxLmRhdGFbb2ZzMV0gPiBuYXQyLmRhdGFbb2ZzMl0pIHJldHVybiAxO1xuICBpZihuYXQxLmRhdGFbb2ZzMV0gPCBuYXQyLmRhdGFbb2ZzMl0pIHJldHVybiAtMTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNvbXBhcmVfbmF0XG4vL1JlcXVpcmVzOiBudW1fZGlnaXRzX25hdFxuZnVuY3Rpb24gY29tcGFyZV9uYXQobmF0MSwgb2ZzMSwgbGVuMSwgbmF0Miwgb2ZzMiwgbGVuMikge1xuICB2YXIgYSA9IG51bV9kaWdpdHNfbmF0KG5hdDEsIG9mczEsIGxlbjEpO1xuICB2YXIgYiA9IG51bV9kaWdpdHNfbmF0KG5hdDIsIG9mczIsIGxlbjIpO1xuICBpZihhID4gYikgcmV0dXJuIDE7XG4gIGlmKGEgPCBiKSByZXR1cm4gLTE7XG4gIGZvcih2YXIgaSA9IGxlbjEgLSAxOyBpID49IDA7IGktLSkge1xuICAgIGlmICgobmF0MS5kYXRhW29mczEraV0gPj4+IDApID4gKG5hdDIuZGF0YVtvZnMyK2ldID4+PiAwKSkgcmV0dXJuIDE7XG4gICAgaWYgKChuYXQxLmRhdGFbb2ZzMStpXSA+Pj4gMCkgPCAobmF0Mi5kYXRhW29mczIraV0gPj4+IDApKSByZXR1cm4gLTE7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNvbXBhcmVfbmF0X3JlYWxcbi8vUmVxdWlyZXM6IGNvbXBhcmVfbmF0XG5mdW5jdGlvbiBjb21wYXJlX25hdF9yZWFsKG5hdDEsbmF0Mil7XG4gIHJldHVybiBjb21wYXJlX25hdChuYXQxLDAsbmF0MS5kYXRhLmxlbmd0aCxuYXQyLDAsbmF0Mi5kYXRhLmxlbmd0aCk7XG59XG5cbi8vUHJvdmlkZXM6IGxhbmRfZGlnaXRfbmF0XG5mdW5jdGlvbiBsYW5kX2RpZ2l0X25hdChuYXQxLCBvZnMxLCBuYXQyLCBvZnMyKSB7XG4gIG5hdDEuZGF0YVtvZnMxXSAmPSBuYXQyLmRhdGFbb2ZzMl07XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBsb3JfZGlnaXRfbmF0XG5mdW5jdGlvbiBsb3JfZGlnaXRfbmF0KG5hdDEsIG9mczEsIG5hdDIsIG9mczIpIHtcbiAgbmF0MS5kYXRhW29mczFdIHw9IG5hdDIuZGF0YVtvZnMyXTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGx4b3JfZGlnaXRfbmF0XG5mdW5jdGlvbiBseG9yX2RpZ2l0X25hdChuYXQxLCBvZnMxLCBuYXQyLCBvZnMyKSB7XG4gIG5hdDEuZGF0YVtvZnMxXSBePSBuYXQyLmRhdGFbb2ZzMl07XG4gIHJldHVybiAwO1xufVxuXG5cbi8vUHJvdmlkZXM6IHNlcmlhbGl6ZV9uYXRcbmZ1bmN0aW9uIHNlcmlhbGl6ZV9uYXQod3JpdGVyLCBuYXQsIHN6KXtcbiAgdmFyIGxlbiA9IG5hdC5kYXRhLmxlbmd0aDtcbiAgd3JpdGVyLndyaXRlKDMyLCBsZW4pO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspe1xuICAgIHdyaXRlci53cml0ZSgzMiwgbmF0LmRhdGFbaV0pO1xuICB9XG4gIHN6WzBdID0gbGVuICogNDtcbiAgc3pbMV0gPSBsZW4gKiA4O1xufVxuXG4vL1Byb3ZpZGVzOiBkZXNlcmlhbGl6ZV9uYXRcbi8vUmVxdWlyZXM6IE1sTmF0XG5mdW5jdGlvbiBkZXNlcmlhbGl6ZV9uYXQocmVhZGVyLCBzeil7XG4gIHZhciBsZW4gPSByZWFkZXIucmVhZDMycygpO1xuICB2YXIgbmF0ID0gbmV3IE1sTmF0KGxlbik7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKyl7XG4gICAgbmF0LmRhdGFbaV0gPSByZWFkZXIucmVhZDMycygpO1xuICB9XG4gIHN6WzBdID0gbGVuICogNDtcbiAgcmV0dXJuIG5hdDtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxNCBKw6lyw7RtZSBWb3VpbGxvbiwgSHVnbyBIZXV6YXJkXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUHJvdmlkZXM6IGZzX25vZGVfc3VwcG9ydGVkXG5mdW5jdGlvbiBmc19ub2RlX3N1cHBvcnRlZCAoKSB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIGdsb2JhbFRoaXMucHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICYmIHR5cGVvZiBnbG9iYWxUaGlzLnByb2Nlc3MudmVyc2lvbnMgIT09ICd1bmRlZmluZWQnXG4gICAgICAmJiB0eXBlb2YgZ2xvYmFsVGhpcy5wcm9jZXNzLnZlcnNpb25zLm5vZGUgIT09ICd1bmRlZmluZWQnKVxufVxuLy9Qcm92aWRlczogZnNfbm9kZV9zdXBwb3J0ZWRcbi8vSWY6IGJyb3dzZXJcbmZ1bmN0aW9uIGZzX25vZGVfc3VwcG9ydGVkICgpIHtcbiAgcmV0dXJuIGZhbHNlXG59XG5cblxuLy9Qcm92aWRlczogTWxOb2RlRGV2aWNlXG4vL1JlcXVpcmVzOiBNbE5vZGVGZCwgY2FtbF9yYWlzZV9zeXNfZXJyb3IsIGNhbWxfcmFpc2Vfd2l0aF9hcmdzXG4vL1JlcXVpcmVzOiBtYWtlX3VuaXhfZXJyX2FyZ3MsIGNhbWxfbmFtZWRfdmFsdWUsIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nXG5mdW5jdGlvbiBNbE5vZGVEZXZpY2Uocm9vdCkge1xuICB0aGlzLmZzID0gcmVxdWlyZSgnZnMnKTtcbiAgdGhpcy5yb290ID0gcm9vdDtcbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUubm0gPSBmdW5jdGlvbihuYW1lKSB7XG4gIHJldHVybiAodGhpcy5yb290ICsgbmFtZSk7XG59XG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLmV4aXN0cyA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gdGhpcy5mcy5leGlzdHNTeW5jKHRoaXMubm0obmFtZSkpPzE6MDtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUuaXNGaWxlID0gZnVuY3Rpb24obmFtZSkge1xuICB0cnkge1xuICAgIHJldHVybiB0aGlzLmZzLnN0YXRTeW5jKHRoaXMubm0obmFtZSkpLmlzRmlsZSgpPzE6MDtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoZXJyLnRvU3RyaW5nKCkpO1xuICB9XG59XG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLm1rZGlyID0gZnVuY3Rpb24obmFtZSwgbW9kZSwgcmFpc2VfdW5peCkge1xuICB0cnkge1xuICAgIHRoaXMuZnMubWtkaXJTeW5jKHRoaXMubm0obmFtZSkse21vZGU6bW9kZX0pO1xuICAgIHJldHVybiAwXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRoaXMucmFpc2Vfbm9kZWpzX2Vycm9yKGVyciwgcmFpc2VfdW5peCk7XG4gIH1cbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUucm1kaXIgPSBmdW5jdGlvbihuYW1lLCByYWlzZV91bml4KSB7XG4gIHRyeSB7XG4gICAgdGhpcy5mcy5ybWRpclN5bmModGhpcy5ubShuYW1lKSk7XG4gICAgcmV0dXJuIDBcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhpcy5yYWlzZV9ub2RlanNfZXJyb3IoZXJyLCByYWlzZV91bml4KTtcbiAgfVxufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5yZWFkZGlyID0gZnVuY3Rpb24obmFtZSwgcmFpc2VfdW5peCkge1xuICB0cnkge1xuICAgIHJldHVybiB0aGlzLmZzLnJlYWRkaXJTeW5jKHRoaXMubm0obmFtZSkpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aGlzLnJhaXNlX25vZGVqc19lcnJvcihlcnIsIHJhaXNlX3VuaXgpO1xuICB9XG59XG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLmlzX2RpciA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gdGhpcy5mcy5zdGF0U3luYyh0aGlzLm5tKG5hbWUpKS5pc0RpcmVjdG9yeSgpPzE6MDtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoZXJyLnRvU3RyaW5nKCkpO1xuICB9XG59XG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLnVubGluayA9IGZ1bmN0aW9uKG5hbWUsIHJhaXNlX3VuaXgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgYiA9IHRoaXMuZnMuZXhpc3RzU3luYyh0aGlzLm5tKG5hbWUpKT8xOjA7XG4gICAgdGhpcy5mcy51bmxpbmtTeW5jKHRoaXMubm0obmFtZSkpO1xuICAgIHJldHVybiBiO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aGlzLnJhaXNlX25vZGVqc19lcnJvcihlcnIsIHJhaXNlX3VuaXgpO1xuICB9XG59XG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbihuYW1lLCBmLCByYWlzZV91bml4KSB7XG4gIHZhciBjb25zdHMgPSByZXF1aXJlKCdjb25zdGFudHMnKTtcbiAgdmFyIHJlcyA9IDA7XG4gIGZvcih2YXIga2V5IGluIGYpe1xuICAgIHN3aXRjaChrZXkpe1xuICAgIGNhc2UgXCJyZG9ubHlcIiAgOiByZXMgfD0gY29uc3RzLk9fUkRPTkxZOyBicmVhaztcbiAgICBjYXNlIFwid3Jvbmx5XCIgIDogcmVzIHw9IGNvbnN0cy5PX1dST05MWTsgYnJlYWs7XG4gICAgY2FzZSBcImFwcGVuZFwiICA6XG4gICAgICByZXMgfD0gY29uc3RzLk9fV1JPTkxZIHwgY29uc3RzLk9fQVBQRU5EO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImNyZWF0ZVwiICAgOiByZXMgfD0gY29uc3RzLk9fQ1JFQVQ7ICAgIGJyZWFrO1xuICAgIGNhc2UgXCJ0cnVuY2F0ZVwiIDogcmVzIHw9IGNvbnN0cy5PX1RSVU5DOyAgICBicmVhaztcbiAgICBjYXNlIFwiZXhjbFwiICAgICA6IHJlcyB8PSBjb25zdHMuT19FWENMOyAgICAgYnJlYWs7XG4gICAgY2FzZSBcImJpbmFyeVwiICAgOiByZXMgfD0gY29uc3RzLk9fQklOQVJZOyAgIGJyZWFrO1xuICAgIGNhc2UgXCJ0ZXh0XCIgICAgIDogcmVzIHw9IGNvbnN0cy5PX1RFWFQ7ICAgICBicmVhaztcbiAgICBjYXNlIFwibm9uYmxvY2tcIiA6IHJlcyB8PSBjb25zdHMuT19OT05CTE9DSzsgYnJlYWs7XG4gICAgfVxuICB9XG4gIHRyeSB7XG4gICAgdmFyIGZkID0gdGhpcy5mcy5vcGVuU3luYyh0aGlzLm5tKG5hbWUpLCByZXMpO1xuICAgIHZhciBpc0NoYXJhY3RlckRldmljZSA9IHRoaXMuZnMubHN0YXRTeW5jKHRoaXMubm0obmFtZSkpLmlzQ2hhcmFjdGVyRGV2aWNlKCk7XG4gICAgZi5pc0NoYXJhY3RlckRldmljZSA9IGlzQ2hhcmFjdGVyRGV2aWNlO1xuICAgIHJldHVybiBuZXcgTWxOb2RlRmQoZmQsIGYpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aGlzLnJhaXNlX25vZGVqc19lcnJvcihlcnIsIHJhaXNlX3VuaXgpO1xuICB9XG59XG5cbk1sTm9kZURldmljZS5wcm90b3R5cGUucmVuYW1lID0gZnVuY3Rpb24obywgbiwgcmFpc2VfdW5peCkge1xuICB0cnkge1xuICAgIHRoaXMuZnMucmVuYW1lU3luYyh0aGlzLm5tKG8pLCB0aGlzLm5tKG4pKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhpcy5yYWlzZV9ub2RlanNfZXJyb3IoZXJyLCByYWlzZV91bml4KTtcbiAgfVxufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5zdGF0ID0gZnVuY3Rpb24obmFtZSwgcmFpc2VfdW5peCkge1xuICB0cnkge1xuICAgIHZhciBqc19zdGF0cyA9IHRoaXMuZnMuc3RhdFN5bmModGhpcy5ubShuYW1lKSk7XG4gICAgcmV0dXJuIHRoaXMuc3RhdHNfZnJvbV9qcyhqc19zdGF0cyk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRoaXMucmFpc2Vfbm9kZWpzX2Vycm9yKGVyciwgcmFpc2VfdW5peCk7XG4gIH1cbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUubHN0YXQgPSBmdW5jdGlvbihuYW1lLCByYWlzZV91bml4KSB7XG4gIHRyeSB7XG4gICAgdmFyIGpzX3N0YXRzID0gdGhpcy5mcy5sc3RhdFN5bmModGhpcy5ubShuYW1lKSk7XG4gICAgcmV0dXJuIHRoaXMuc3RhdHNfZnJvbV9qcyhqc19zdGF0cyk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRoaXMucmFpc2Vfbm9kZWpzX2Vycm9yKGVyciwgcmFpc2VfdW5peCk7XG4gIH1cbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUuc3ltbGluayA9IGZ1bmN0aW9uKHRvX2RpciwgdGFyZ2V0LCBwYXRoLCByYWlzZV91bml4KSB7XG4gIHRyeSB7XG4gICAgdGhpcy5mcy5zeW1saW5rU3luYyh0aGlzLm5tKHRhcmdldCksIHRoaXMubm0ocGF0aCksIHRvX2RpciA/ICdkaXInIDogJ2ZpbGUnKTtcbiAgICByZXR1cm4gMDtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhpcy5yYWlzZV9ub2RlanNfZXJyb3IoZXJyLCByYWlzZV91bml4KTtcbiAgfVxufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5yZWFkbGluayA9IGZ1bmN0aW9uKG5hbWUsIHJhaXNlX3VuaXgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgbGluayA9IHRoaXMuZnMucmVhZGxpbmtTeW5jKHRoaXMubm0obmFtZSksICd1dGY4Jyk7XG4gICAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKGxpbmspO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aGlzLnJhaXNlX25vZGVqc19lcnJvcihlcnIsIHJhaXNlX3VuaXgpO1xuICB9XG59XG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLm9wZW5kaXIgPSBmdW5jdGlvbihuYW1lLCByYWlzZV91bml4KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHRoaXMuZnMub3BlbmRpclN5bmModGhpcy5ubShuYW1lKSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRoaXMucmFpc2Vfbm9kZWpzX2Vycm9yKGVyciwgcmFpc2VfdW5peCk7XG4gIH1cbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUucmFpc2Vfbm9kZWpzX2Vycm9yID0gZnVuY3Rpb24oZXJyLCByYWlzZV91bml4KSB7XG4gIHZhciB1bml4X2Vycm9yID0gY2FtbF9uYW1lZF92YWx1ZShcIlVuaXguVW5peF9lcnJvclwiKTtcbiAgaWYgKHJhaXNlX3VuaXggJiYgdW5peF9lcnJvcikge1xuICAgIHZhciBhcmdzID0gbWFrZV91bml4X2Vycl9hcmdzKGVyci5jb2RlLCBlcnIuc3lzY2FsbCwgZXJyLnBhdGgsIGVyci5lcnJubyk7XG4gICAgY2FtbF9yYWlzZV93aXRoX2FyZ3ModW5peF9lcnJvciwgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoZXJyLnRvU3RyaW5nKCkpO1xuICB9XG59XG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLnN0YXRzX2Zyb21fanMgPSBmdW5jdGlvbihqc19zdGF0cykge1xuICAvKiA9PT1Vbml4LmZpbGVfa2luZD09PVxuICAgKiB0eXBlIGZpbGVfa2luZCA9XG4gICAqICAgICBTX1JFRyAgICAgICAgICAgICAgICAgICAgICAgKCoqIFJlZ3VsYXIgZmlsZSAqKVxuICAgKiAgIHwgU19ESVIgICAgICAgICAgICAgICAgICAgICAgICgqKiBEaXJlY3RvcnkgKilcbiAgICogICB8IFNfQ0hSICAgICAgICAgICAgICAgICAgICAgICAoKiogQ2hhcmFjdGVyIGRldmljZSAqKVxuICAgKiAgIHwgU19CTEsgICAgICAgICAgICAgICAgICAgICAgICgqKiBCbG9jayBkZXZpY2UgKilcbiAgICogICB8IFNfTE5LICAgICAgICAgICAgICAgICAgICAgICAoKiogU3ltYm9saWMgbGluayAqKVxuICAgKiAgIHwgU19GSUZPICAgICAgICAgICAgICAgICAgICAgICgqKiBOYW1lZCBwaXBlICopXG4gICAqICAgfCBTX1NPQ0sgICAgICAgICAgICAgICAgICAgICAgKCoqIFNvY2tldCAqKVxuICAgKi9cbiAgdmFyIGZpbGVfa2luZDtcbiAgaWYgKGpzX3N0YXRzLmlzRmlsZSgpKSB7XG4gICAgZmlsZV9raW5kID0gMDtcbiAgfSBlbHNlIGlmIChqc19zdGF0cy5pc0RpcmVjdG9yeSgpKSB7XG4gICAgZmlsZV9raW5kID0gMTtcbiAgfSBlbHNlIGlmIChqc19zdGF0cy5pc0NoYXJhY3RlckRldmljZSgpKSB7XG4gICAgZmlsZV9raW5kID0gMjtcbiAgfSBlbHNlIGlmIChqc19zdGF0cy5pc0Jsb2NrRGV2aWNlKCkpIHtcbiAgICBmaWxlX2tpbmQgPSAzO1xuICB9IGVsc2UgaWYgKGpzX3N0YXRzLmlzU3ltYm9saWNMaW5rKCkpIHtcbiAgICBmaWxlX2tpbmQgPSA0O1xuICB9IGVsc2UgaWYgKGpzX3N0YXRzLmlzRklGTygpKSB7XG4gICAgZmlsZV9raW5kID0gNTtcbiAgfSBlbHNlIGlmIChqc19zdGF0cy5pc1NvY2tldCgpKSB7XG4gICAgZmlsZV9raW5kID0gNjtcbiAgfVxuICAvKiA9PT1Vbml4LnN0YXRzPT09XG4gICAqIHR5cGUgc3RhdHMgPVxuICAgKiAgeyBzdF9kZXYgOiBpbnQ7ICAgICAgICAgICAgICAgKCoqIERldmljZSBudW1iZXIgKilcbiAgICogICAgc3RfaW5vIDogaW50OyAgICAgICAgICAgICAgICgqKiBJbm9kZSBudW1iZXIgKilcbiAgICogICAgc3Rfa2luZCA6IGZpbGVfa2luZDsgICAgICAgICgqKiBLaW5kIG9mIHRoZSBmaWxlICopXG4gICAqICAgIHN0X3Blcm0gOiBmaWxlX3Blcm07ICAgICAgICAoKiogQWNjZXNzIHJpZ2h0cyAqKVxuICAgKiAgICBzdF9ubGluayA6IGludDsgICAgICAgICAgICAgKCoqIE51bWJlciBvZiBsaW5rcyAqKVxuICAgKiAgICBzdF91aWQgOiBpbnQ7ICAgICAgICAgICAgICAgKCoqIFVzZXIgaWQgb2YgdGhlIG93bmVyICopXG4gICAqICAgIHN0X2dpZCA6IGludDsgICAgICAgICAgICAgICAoKiogR3JvdXAgSUQgb2YgdGhlIGZpbGUncyBncm91cCAqKVxuICAgKiAgICBzdF9yZGV2IDogaW50OyAgICAgICAgICAgICAgKCoqIERldmljZSBJRCAoaWYgc3BlY2lhbCBmaWxlKSAqKVxuICAgKiAgICBzdF9zaXplIDogaW50OyAgICAgICAgICAgICAgKCoqIFNpemUgaW4gYnl0ZXMgKilcbiAgICogICAgc3RfYXRpbWUgOiBmbG9hdDsgICAgICAgICAgICgqKiBMYXN0IGFjY2VzcyB0aW1lICopXG4gICAqICAgIHN0X210aW1lIDogZmxvYXQ7ICAgICAgICAgICAoKiogTGFzdCBtb2RpZmljYXRpb24gdGltZSAqKVxuICAgKiAgICBzdF9jdGltZSA6IGZsb2F0OyAgICAgICAgICAgKCoqIExhc3Qgc3RhdHVzIGNoYW5nZSB0aW1lICopXG4gICAqICB9XG4gICAqL1xuICByZXR1cm4gQkxPQ0soXG4gICAgMCxcbiAgICBqc19zdGF0cy5kZXYsXG4gICAganNfc3RhdHMuaW5vLFxuICAgIGZpbGVfa2luZCxcbiAgICBqc19zdGF0cy5tb2RlLFxuICAgIGpzX3N0YXRzLm5saW5rLFxuICAgIGpzX3N0YXRzLnVpZCxcbiAgICBqc19zdGF0cy5naWQsXG4gICAganNfc3RhdHMucmRldixcbiAgICBqc19zdGF0cy5zaXplLFxuICAgIGpzX3N0YXRzLmF0aW1lTXMsXG4gICAganNfc3RhdHMubXRpbWVNcyxcbiAgICBqc19zdGF0cy5jdGltZU1zXG4gICk7XG59XG5cbk1sTm9kZURldmljZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNbE5vZGVEZXZpY2VcblxuLy9Qcm92aWRlczogTWxOb2RlRGV2aWNlXG4vL0lmOiBicm93c2VyXG5mdW5jdGlvbiBNbE5vZGVEZXZpY2UoKSB7XG59XG5cbi8vUHJvdmlkZXM6IE1sTm9kZUZkXG4vL1JlcXVpcmVzOiBNbEZpbGUsIGNhbWxfdWludDhfYXJyYXlfb2Zfc3RyaW5nLCBjYW1sX3VpbnQ4X2FycmF5X29mX2J5dGVzLCBjYW1sX2J5dGVzX3NldCwgY2FtbF9yYWlzZV9zeXNfZXJyb3JcbmZ1bmN0aW9uIE1sTm9kZUZkKGZkLCBmbGFncyl7XG4gIHRoaXMuZnMgPSByZXF1aXJlKCdmcycpO1xuICB0aGlzLmZkID0gZmQ7XG4gIHRoaXMuZmxhZ3MgPSBmbGFncztcbn1cbk1sTm9kZUZkLnByb3RvdHlwZSA9IG5ldyBNbEZpbGUgKCk7XG5NbE5vZGVGZC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNbE5vZGVGZDtcblxuTWxOb2RlRmQucHJvdG90eXBlLnRydW5jYXRlID0gZnVuY3Rpb24obGVuKXtcbiAgdHJ5IHtcbiAgICB0aGlzLmZzLmZ0cnVuY2F0ZVN5bmModGhpcy5mZCxsZW58MCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKGVyci50b1N0cmluZygpKTtcbiAgfVxufVxuTWxOb2RlRmQucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gdGhpcy5mcy5mc3RhdFN5bmModGhpcy5mZCkuc2l6ZTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoZXJyLnRvU3RyaW5nKCkpO1xuICB9XG59XG5NbE5vZGVGZC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihvZmZzZXQsYnVmLGJ1Zl9vZmZzZXQsbGVuKXtcbiAgdHJ5IHtcbiAgICBpZih0aGlzLmZsYWdzLmlzQ2hhcmFjdGVyRGV2aWNlKVxuICAgICAgdGhpcy5mcy53cml0ZVN5bmModGhpcy5mZCwgYnVmLCBidWZfb2Zmc2V0LCBsZW4pO1xuICAgIGVsc2VcbiAgICAgIHRoaXMuZnMud3JpdGVTeW5jKHRoaXMuZmQsIGJ1ZiwgYnVmX29mZnNldCwgbGVuLCBvZmZzZXQpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihlcnIudG9TdHJpbmcoKSk7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5NbE5vZGVGZC5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uKG9mZnNldCxhLGJ1Zl9vZmZzZXQsbGVuKXtcbiAgdHJ5IHtcbiAgICBpZih0aGlzLmZsYWdzLmlzQ2hhcmFjdGVyRGV2aWNlKVxuICAgICAgdmFyIHJlYWQgPSB0aGlzLmZzLnJlYWRTeW5jKHRoaXMuZmQsIGEsIGJ1Zl9vZmZzZXQsIGxlbik7XG4gICAgZWxzZVxuICAgICAgdmFyIHJlYWQgPSB0aGlzLmZzLnJlYWRTeW5jKHRoaXMuZmQsIGEsIGJ1Zl9vZmZzZXQsIGxlbiwgb2Zmc2V0KTtcbiAgICByZXR1cm4gcmVhZDtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoZXJyLnRvU3RyaW5nKCkpO1xuICB9XG59XG5NbE5vZGVGZC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpe1xuICB0cnkge1xuICAgIHRoaXMuZnMuY2xvc2VTeW5jKHRoaXMuZmQpO1xuICAgIHJldHVybiAwXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKGVyci50b1N0cmluZygpKTtcbiAgfVxufVxuXG5cbi8vUHJvdmlkZXM6IE1sTm9kZUZkXG4vL0lmOiBicm93c2VyXG5mdW5jdGlvbiBNbE5vZGVGZCgpe1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX29wZW5fZm9yX25vZGVcbi8vUmVxdWlyZXM6IE1sTm9kZUZkXG5mdW5jdGlvbiBjYW1sX3N5c19vcGVuX2Zvcl9ub2RlKGZkLCBmbGFncyl7XG4gIGlmKGZsYWdzLm5hbWUpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIGZzID0gcmVxdWlyZShcImZzXCIpO1xuICAgICAgdmFyIGZkMiA9IGZzLm9wZW5TeW5jKGZsYWdzLm5hbWUsIFwicnNcIik7XG4gICAgICByZXR1cm4gbmV3IE1sTm9kZUZkKGZkMiwgZmxhZ3MpO1xuICAgIH0gY2F0Y2goZSkgeyAgfVxuICB9XG4gIHJldHVybiBuZXcgTWxOb2RlRmQoZmQsIGZsYWdzKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfb3Blbl9mb3Jfbm9kZVxuLy9JZjogYnJvd3NlclxuZnVuY3Rpb24gY2FtbF9zeXNfb3Blbl9mb3Jfbm9kZShmZCwgZmxhZ3Mpe1xuICByZXR1cm4gbnVsbDtcbn1cbiIsIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICAgIENvcHlyaWdodCAyMDIyIE9DYW1sUHJvICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICBBbGwgcmlnaHRzIHJlc2VydmVkLiBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSAgKi9cbi8qICBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlIHNwZWNpYWwgICAgICAgKi9cbi8qICBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgICAgICAgICAgKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXG5cbi8qIFV0aWxpdHkgZnVuY3Rpb25zICovXG5cbi8vUHJvdmlkZXM6IF9tbF9jYW52YXNfaW5pdGlhbGl6ZWRcbnZhciBfbWxfY2FudmFzX2luaXRpYWxpemVkID0gZmFsc2U7XG5cbi8vUHJvdmlkZXM6IF9tbF9jYW52YXNfZW5zdXJlX2luaXRpYWxpemVkXG4vL1JlcXVpcmVzOiBfbWxfY2FudmFzX2luaXRpYWxpemVkXG4vL1JlcXVpcmVzOiBjYW1sX25hbWVkX3ZhbHVlLCBjYW1sX3JhaXNlX2NvbnN0YW50XG5mdW5jdGlvbiBfbWxfY2FudmFzX2Vuc3VyZV9pbml0aWFsaXplZCgpIHtcbiAgaWYgKF9tbF9jYW52YXNfaW5pdGlhbGl6ZWQgPT0gZmFsc2UpIHtcbiAgICBjYW1sX3JhaXNlX2NvbnN0YW50KGNhbWxfbmFtZWRfdmFsdWUoXCJOb3RfaW5pdGlhbGl6ZWRcIikpO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IF9tbF9jYW52YXNfdmFsaWRfY2FudmFzX3NpemVcbmZ1bmN0aW9uIF9tbF9jYW52YXNfdmFsaWRfY2FudmFzX3NpemUod2lkdGgsIGhlaWdodCkge1xuICByZXR1cm4gMCA8IHdpZHRoICYmIHdpZHRoIDw9IDMyNzY3ICYmIDAgPCBoZWlnaHQgJiYgaGVpZ2h0IDw9IDMyNzY3O1xufVxuXG4vLyBQcm92aWRlczogX2ludGVybmFsX2NhbnZhc1xudmFyIF9pbnRlcm5hbF9jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuXG4vLyBQcm92aWRlczogX2ludGVybmFsX2N0eHRcbi8vIFJlcXVpcmVzOiBfaW50ZXJuYWxfY2FudmFzXG52YXIgX2ludGVybmFsX2N0eHQgPSBfaW50ZXJuYWxfY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcblxuXG5cbi8qIEpTIEV2ZW50IGhhbmRsZXJzICovXG5cbi8vUHJvdmlkZXM6IF9mb2N1c1xudmFyIF9mb2N1cyA9IG51bGw7XG5cbi8vUHJvdmlkZXM6IF9tb3ZlXG52YXIgX21vdmUgPSB7XG4gIG1vdmluZzogZmFsc2UsXG4gIHRhcmdldDogbnVsbCxcbiAgcHJldl94OiAwLFxuICBwcmV2X3k6IDBcbn1cblxuLy9Qcm92aWRlczogX3Jlc2l6ZVxuLy9SZXF1aXJlczogX3Jlc2l6ZV9oYW5kbGVyXG52YXIgX3Jlc2l6ZSA9IG5ldyB3aW5kb3cuUmVzaXplT2JzZXJ2ZXIoX3Jlc2l6ZV9oYW5kbGVyKTtcblxuLy9Qcm92aWRlczogX2V2ZW50X2NhbnZhc19zY2FsZVxuZnVuY3Rpb24gX2V2ZW50X2NhbnZhc19zY2FsZShlKSB7XG4gICAgcmV0dXJuIHsgc2NhbGVYIDogZS50YXJnZXQuY2FudmFzLndpZHRoIC8gZS50YXJnZXQuY2xpZW50V2lkdGgsXG4gICAgICAgICAgICAgc2NhbGVZIDogZS50YXJnZXQuY2FudmFzLmhlaWdodCAvIGUudGFyZ2V0LmNsaWVudEhlaWdodFxuICAgICAgICAgICB9XG59XG5cbi8vUHJvdmlkZXM6IF9tYWtlX2tleV9ldmVudFxuLy9SZXF1aXJlczogX2ZvY3VzLCBrZXluYW1lX3RvX2tleWNvZGUsIFZhbF9rZXlfY29kZSwgVmFsX2tleV9zdGF0ZSwgRVZFTlRfVEFHXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2Zsb2F0XG5mdW5jdGlvbiBfbWFrZV9rZXlfZXZlbnQoZSwgc3RhdGUpIHtcbiAgdmFyIGNoYXIgPSAoZS5rZXkubGVuZ3RoID09PSAxKSA/IGUua2V5LmNoYXJDb2RlQXQoMCkgOiAwO1xuICB2YXIgZmxhZ3MgPSBbMCwgZS5zaGlmdEtleSwgZS5hbHRLZXksIGUuY3RybEtleSwgZS5tZXRhS2V5LFxuICAgICAgICAgICAgICAgICAgZS5nZXRNb2RpZmllclN0YXRlKFwiQ2Fwc0xvY2tcIiksXG4gICAgICAgICAgICAgICAgICBlLmdldE1vZGlmaWVyU3RhdGUoXCJOdW1Mb2NrXCIpLFxuICAgICAgICAgICAgICAgICAgKGUua2V5ID09PSBcIkRlYWRcIildO1xuICB2YXIgZXZ0ID0gW0VWRU5UX1RBRy5LRVlfQUNUSU9OLFxuICAgICAgICAgICAgIFswLCBfZm9jdXMsIGNhbWxfaW50NjRfb2ZfZmxvYXQoZS50aW1lU3RhbXAgKiAxMDAwLjApLFxuICAgICAgICAgICAgICBWYWxfa2V5X2NvZGUoa2V5bmFtZV90b19rZXljb2RlKGUuY29kZSkpLFxuICAgICAgICAgICAgICBjaGFyLCBmbGFncywgVmFsX2tleV9zdGF0ZShzdGF0ZSldXTtcbiAgcmV0dXJuIGV2dDtcbn1cblxuLy9Qcm92aWRlczogX2tleV9kb3duX2hhbmRsZXJcbi8vUmVxdWlyZXM6IF9mb2N1cywgX21ha2Vfa2V5X2V2ZW50LCBfbWxfY2FudmFzX3Byb2Nlc3NfZXZlbnQsIEtFWV9TVEFURVxuZnVuY3Rpb24gX2tleV9kb3duX2hhbmRsZXIoZSkge1xuICBpZiAoX2ZvY3VzICE9PSBudWxsKSB7XG4gICAgdmFyIGV2dCA9IF9tYWtlX2tleV9ldmVudChlLCBLRVlfU1RBVEUuRE9XTik7XG4gICAgX21sX2NhbnZhc19wcm9jZXNzX2V2ZW50KGV2dCk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vL1Byb3ZpZGVzOiBfa2V5X3VwX2hhbmRsZXJcbi8vUmVxdWlyZXM6IF9mb2N1cywgX21ha2Vfa2V5X2V2ZW50LCBfbWxfY2FudmFzX3Byb2Nlc3NfZXZlbnQsIEtFWV9TVEFURVxuZnVuY3Rpb24gX2tleV91cF9oYW5kbGVyKGUpIHtcbiAgaWYgKF9mb2N1cyAhPT0gbnVsbCkge1xuICAgIHZhciBldnQgPSBfbWFrZV9rZXlfZXZlbnQoZSwgS0VZX1NUQVRFLlVQKTtcbiAgICBfbWxfY2FudmFzX3Byb2Nlc3NfZXZlbnQoZXZ0KTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vUHJvdmlkZXM6IF9oZWFkZXJfZG93bl9oYW5kbGVyXG4vL1JlcXVpcmVzOiBfZm9jdXMsIF9tb3ZlLCBtbF9jYW52YXNfY2xvc2UsIF9tbF9jYW52YXNfcHJvY2Vzc19ldmVudCwgRVZFTlRfVEFHXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2Zsb2F0XG5mdW5jdGlvbiBfaGVhZGVyX2Rvd25faGFuZGxlcihlKSB7XG4gIGlmIChlLnRhcmdldCAhPT0gbnVsbCkge1xuICAgIF9mb2N1cyA9IGUudGFyZ2V0LmNhbnZhcztcbiAgICBpZiAoKGUub2Zmc2V0WCA+PSBlLnRhcmdldC5jYW52YXMud2lkdGggLSAyMCkgJiZcbiAgICAgICAgKGUub2Zmc2V0WCA8PSBlLnRhcmdldC5jYW52YXMud2lkdGggLSAxMCkgJiZcbiAgICAgICAgKGUub2Zmc2V0WSA+PSAxMCkgJiYgKGUub2Zmc2V0WSA8PSAyMCkpIHtcbiAgICAgIHZhciBldnQgPSBbRVZFTlRfVEFHLkNBTlZBU19DTE9TRUQsXG4gICAgICAgICAgICAgICAgIFswLCBlLnRhcmdldC5jYW52YXMsXG4gICAgICAgICAgICAgICAgICBjYW1sX2ludDY0X29mX2Zsb2F0KGUudGltZVN0YW1wICogMTAwMC4wKV1dO1xuICAgICAgX21sX2NhbnZhc19wcm9jZXNzX2V2ZW50KGV2dCk7XG4gICAgICBtbF9jYW52YXNfY2xvc2UoZS50YXJnZXQuY2FudmFzKTtcbiAgICAgIF9mb2N1cyA9IG51bGw7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIF9tb3ZlLm1vdmluZyA9IHRydWU7XG4gICAgX21vdmUudGFyZ2V0ID0gZS50YXJnZXQuY2FudmFzLmZyYW1lO1xuICAgIF9tb3ZlLnByZXZfeCA9IGUucGFnZVg7XG4gICAgX21vdmUucHJldl95ID0gZS5wYWdlWTtcbiAgICBlLnRhcmdldC5jYW52YXMudGFyZ2V0Lmluc2VydEJlZm9yZShfbW92ZS50YXJnZXQsIG51bGwpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy9Qcm92aWRlczogX3N1cmZhY2VfZG93bl9oYW5kbGVyXG4vL1JlcXVpcmVzOiBfZm9jdXMsIF9tbF9jYW52YXNfcHJvY2Vzc19ldmVudCwgX2V2ZW50X2NhbnZhc19zY2FsZSwgRVZFTlRfVEFHXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2Zsb2F0XG5mdW5jdGlvbiBfc3VyZmFjZV9kb3duX2hhbmRsZXIoZSkge1xuICBpZiAoZS50YXJnZXQgIT09IG51bGwpIHtcbiAgICBfZm9jdXMgPSBlLnRhcmdldC5jYW52YXM7XG4gICAgZS50YXJnZXQuY2FudmFzLnRhcmdldC5pbnNlcnRCZWZvcmUoZS50YXJnZXQuY2FudmFzLmZyYW1lLCBudWxsKTtcbiAgICB2YXIgcyA9IF9ldmVudF9jYW52YXNfc2NhbGUoZSk7XG4gICAgdmFyIGV2dCA9IFtFVkVOVF9UQUcuQlVUVE9OX0FDVElPTixcbiAgICAgICAgICAgICAgIFswLCBlLnRhcmdldC5jYW52YXMsXG4gICAgICAgICAgICAgICAgY2FtbF9pbnQ2NF9vZl9mbG9hdChlLnRpbWVTdGFtcCAqIDEwMDAuMCksXG4gICAgICAgICAgICAgICAgWzAsIGUub2Zmc2V0WCpzLnNjYWxlWCwgZS5vZmZzZXRZKnMuc2NhbGVZXSwgZS5idXR0b24gKyAxLCAxXV07XG4gICAgX21sX2NhbnZhc19wcm9jZXNzX2V2ZW50KGV2dCk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vL1Byb3ZpZGVzOiBfdXBfaGFuZGxlclxuLy9SZXF1aXJlczogX21vdmUsIF9tbF9jYW52YXNfcHJvY2Vzc19ldmVudCwgX2V2ZW50X2NhbnZhc19zY2FsZSwgRVZFTlRfVEFHXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2Zsb2F0XG5mdW5jdGlvbiBfdXBfaGFuZGxlcihlKSB7XG4gIF9tb3ZlLm1vdmluZyA9IGZhbHNlO1xuICBpZiAoZS50YXJnZXQuY2FudmFzICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgcyA9IF9ldmVudF9jYW52YXNfc2NhbGUoZSk7XG4gICAgdmFyIGV2dCA9IFtFVkVOVF9UQUcuQlVUVE9OX0FDVElPTixcbiAgICAgICAgICAgICAgIFswLCBlLnRhcmdldC5jYW52YXMsXG4gICAgICAgICAgICAgICAgY2FtbF9pbnQ2NF9vZl9mbG9hdChlLnRpbWVTdGFtcCAqIDEwMDAuMCksXG4gICAgICAgICAgICAgICAgWzAsIGUub2Zmc2V0WCpzLnNjYWxlWCwgZS5vZmZzZXRZKnMuc2NhbGVZXSwgZS5idXR0b24gKyAxLCAwXV07XG4gICAgX21sX2NhbnZhc19wcm9jZXNzX2V2ZW50KGV2dCk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlOyAvLyA9IHByZXZlbnQgZGVmYXVsdCBiZWhhdmlvclxufVxuXG4vL1Byb3ZpZGVzOiBfbW92ZV9oYW5kbGVyXG4vL1JlcXVpcmVzOiBfbW92ZSwgX21sX2NhbnZhc19wcm9jZXNzX2V2ZW50LCBfZXZlbnRfY2FudmFzX3NjYWxlLCBFVkVOVF9UQUdcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfZmxvYXRcbmZ1bmN0aW9uIF9tb3ZlX2hhbmRsZXIoZSkge1xuICBpZiAoX21vdmUubW92aW5nKSB7XG4gICAgdmFyIG5ld194ID0gZS5wYWdlWDtcbiAgICB2YXIgbmV3X3kgPSBlLnBhZ2VZO1xuICAgIHZhciBkeCA9IG5ld194IC0gX21vdmUucHJldl94O1xuICAgIHZhciBkeSA9IG5ld195IC0gX21vdmUucHJldl95O1xuICAgIF9tb3ZlLnByZXZfeCA9IG5ld194O1xuICAgIF9tb3ZlLnByZXZfeSA9IG5ld195O1xuICAgIHZhciBjYW52YXMgPSBfbW92ZS50YXJnZXQuY2FudmFzO1xuICAgIGNhbnZhcy54ICs9IGR4O1xuICAgIGNhbnZhcy55ICs9IGR5O1xuICAgIF9tb3ZlLnRhcmdldC5zdHlsZS5sZWZ0ID0gY2FudmFzLnggKyBcInB4XCI7XG4gICAgX21vdmUudGFyZ2V0LnN0eWxlLnRvcCA9IGNhbnZhcy55ICsgXCJweFwiO1xuICB9IGVsc2UgaWYgKGUudGFyZ2V0LmNhbnZhcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIHMgPSBfZXZlbnRfY2FudmFzX3NjYWxlKGUpO1xuICAgIHZhciBldnQgPSBbRVZFTlRfVEFHLk1PVVNFX01PVkUsXG4gICAgICAgICAgICAgICBbMCwgZS50YXJnZXQuY2FudmFzLFxuICAgICAgICAgICAgICAgIGNhbWxfaW50NjRfb2ZfZmxvYXQoZS50aW1lU3RhbXAgKiAxMDAwLjApLFxuICAgICAgICAgICAgICAgIFswLCBlLm9mZnNldFgqcy5zY2FsZVgsIGUub2Zmc2V0WSpzLnNjYWxlWV1dXTtcbiAgICBfbWxfY2FudmFzX3Byb2Nlc3NfZXZlbnQoZXZ0KTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vUHJvdmlkZXM6IF9yZXNpemVfaGFuZGxlclxuLy9SZXF1aXJlczogX21sX2NhbnZhc19wcm9jZXNzX2V2ZW50LCBFVkVOVF9UQUdcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfZmxvYXRcbmZ1bmN0aW9uIF9yZXNpemVfaGFuZGxlcihlbnRyaWVzKSB7XG4gIGVudHJpZXMuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgIHZhciBldnQgPSBbRVZFTlRfVEFHLkNBTlZBU19SRVNJWkVELFxuICAgICAgICAgICAgICAgWzAsIGUudGFyZ2V0LmNhbnZhcyxcbiAgICAgICAgICAgICAgICBjYW1sX2ludDY0X29mX2Zsb2F0KGUudGltZVN0YW1wICogMTAwMC4wKSxcbiAgICAgICAgICAgICAgICBbMCwgZS50YXJnZXQuY2xpZW50V2lkdGgsIGUudGFyZ2V0LmNsaWVudEhlaWdodF1dXTtcbiAgICBfbWxfY2FudmFzX3Byb2Nlc3NfZXZlbnQoZXZ0KTtcbiAgfSk7XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy9Qcm92aWRlczogX2ZyYW1lX2hhbmRsZXJcbi8vUmVxdWlyZXM6IF9tbF9jYW52YXNfcHJvY2Vzc19ldmVudCwgRVZFTlRfVEFHXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2Zsb2F0XG5mdW5jdGlvbiBfZnJhbWVfaGFuZGxlcih0aW1lc3RhbXApIHtcbiAgdmFyIHN1cmZhY2VzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJjYW52YXNcIik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3VyZmFjZXMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgZXZ0ID0gW0VWRU5UX1RBRy5GUkFNRSxcbiAgICAgICAgICAgICAgIFswLCBzdXJmYWNlc1tpXS5jYW52YXMsXG4gICAgICAgICAgICAgICAgY2FtbF9pbnQ2NF9vZl9mbG9hdCh0aW1lc3RhbXAgKiAxMDAwLjApXV07XG4gICAgX21sX2NhbnZhc19wcm9jZXNzX2V2ZW50KGV2dCk7XG4gIH1cbiAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShfZnJhbWVfaGFuZGxlcik7XG59XG5cblxuXG4vKiBJbWFnZSBEYXRhIChha2EgUGl4bWFwcykgKi9cblxuLy9Qcm92aWRlczogX21sX2NhbnZhc19pbWFnZV9vZl9wbmdfZmlsZVxuLy9SZXF1aXJlczogY2FtbF9yZWFkX2ZpbGVfY29udGVudCwgY2FtbF9yYWlzZV93aXRoX3N0cmluZywgY2FtbF9uYW1lZF92YWx1ZVxuZnVuY3Rpb24gX21sX2NhbnZhc19pbWFnZV9vZl9wbmdfZmlsZShmaWxlbmFtZSkge1xuICB2YXIgZmlsZSA9IGNhbWxfcmVhZF9maWxlX2NvbnRlbnQoZmlsZW5hbWUpO1xuICBpZiAoZmlsZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBmYyA9IGNhbWxfcmVhZF9maWxlX2NvbnRlbnQoZmlsZW5hbWUpO1xuICAvLyBUZXN0IGZvciBtbEJ5dGVzIG9yIEpTLXN0cmluZ1xuICB2YXIgZGF0YSA9IHdpbmRvdy5idG9hKGZjLmMgPT09IHVuZGVmaW5lZCA/IGZjIDogZmMuYyk7XG4gIHZhciBpbWcgPSBuZXcgd2luZG93LkltYWdlKCk7XG4gIGltZy5sb2FkaW5nID0gJ2VhZ2VyJztcbiAgaW1nLmRlY29kaW5nID0gJ3N5bmMnO1xuICBpbWcuc3JjID0gJ2RhdGE6aW1hZ2UvcG5nO2Jhc2U2NCwnICsgZGF0YTtcbiAgcmV0dXJuIFtpbWcuZGVjb2RlKCksIGltZ107XG59XG5cbi8vUHJvdmlkZXM6IF9tbF9jYW52YXNfYmFfb2ZfaW1nXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2NyZWF0ZV91bnNhZmVcbmZ1bmN0aW9uIF9tbF9jYW52YXNfYmFfb2ZfaW1nKGltZykge1xuICB2YXIgc3VyZmFjZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gIHN1cmZhY2Uud2lkdGggPSBpbWcud2lkdGg7XG4gIHN1cmZhY2UuaGVpZ2h0ID0gaW1nLmhlaWdodDtcbiAgdmFyIGN0eHQgPSBzdXJmYWNlLmdldENvbnRleHQoXCIyZFwiKTtcbiAgY3R4dC5kcmF3SW1hZ2UoaW1nLCAwLCAwKTtcbiAgdmFyIGltYWdlID0gY3R4dC5nZXRJbWFnZURhdGEoMCwgMCwgaW1nLndpZHRoLCBpbWcuaGVpZ2h0KTtcbiAgdmFyIHN0YSA9IG5ldyB3aW5kb3cuVWludDhBcnJheShpbWFnZS5kYXRhLmJ1ZmZlcik7XG4gIHZhciBkdGEgPSBuZXcgd2luZG93LlVpbnQ4QXJyYXkoc3RhLmxlbmd0aCk7XG4gIC8vIENvbnZlcnQgZnJvbSBSR0JBIHRvIEJHUkFcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGEubGVuZ3RoOyBpICs9IDQpIHtcbiAgICBkdGFbaSswXSA9IHN0YVtpKzJdO1xuICAgIGR0YVtpKzFdID0gc3RhW2krMV07XG4gICAgZHRhW2krMl0gPSBzdGFbaSswXTtcbiAgICBkdGFbaSszXSA9IHN0YVtpKzNdO1xuICB9XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoMyAvKiBVaW50OEFycmF5ICovLCAwIC8qIGNfbGF5b3V0ICovLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtpbWcuaGVpZ2h0LCBpbWcud2lkdGgsIDRdLCBkdGEpO1xufVxuXG4vL1Byb3ZpZGVzOiBfbWxfY2FudmFzX3N1cmZhY2Vfb2ZfYmFcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZGltLCBjYW1sX2JhX3RvX3R5cGVkX2FycmF5XG5mdW5jdGlvbiBfbWxfY2FudmFzX3N1cmZhY2Vfb2ZfYmEoZGF0YSkge1xuICB2YXIgc3VyZmFjZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gIHN1cmZhY2Uud2lkdGggPSBjYW1sX2JhX2RpbShkYXRhLCAxKTtcbiAgc3VyZmFjZS5oZWlnaHQgPSBjYW1sX2JhX2RpbShkYXRhLCAwKTtcbiAgdmFyIGN0eHQgPSBzdXJmYWNlLmdldENvbnRleHQoXCIyZFwiKTtcbiAgdmFyIHN0YSA9IG5ldyB3aW5kb3cuVWludDhBcnJheShjYW1sX2JhX3RvX3R5cGVkX2FycmF5KGRhdGEpLmJ1ZmZlcik7XG4gIHZhciBkdGEgPSBuZXcgd2luZG93LlVpbnQ4Q2xhbXBlZEFycmF5KHN0YS5sZW5ndGgpO1xuICAvLyBDb252ZXJ0IGZyb20gQkdSQSB0byBSR0JBXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhLmxlbmd0aDsgaSArPSA0KSB7XG4gICAgZHRhW2krMF0gPSBzdGFbaSsyXTtcbiAgICBkdGFbaSsxXSA9IHN0YVtpKzFdO1xuICAgIGR0YVtpKzJdID0gc3RhW2krMF07XG4gICAgZHRhW2krM10gPSBzdGFbaSszXTtcbiAgfVxuICBpZiAod2luZG93LkltYWdlRGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGltYWdlID0gY3R4dC5jcmVhdGVJbWFnZURhdGEoc3VyZmFjZS53aWR0aCwgc3VyZmFjZS5oZWlnaHQpO1xuICAgIGltYWdlLmRhdGEuc2V0KGR0YSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGltYWdlID0gbmV3IHdpbmRvdy5JbWFnZURhdGEoZHRhLCBzdXJmYWNlLndpZHRoLCBzdXJmYWNlLmhlaWdodCk7XG4gIH1cbiAgY3R4dC5wdXRJbWFnZURhdGEoaW1hZ2UsIDAsIDApO1xuICByZXR1cm4gc3VyZmFjZTtcbn1cblxuLy9Qcm92aWRlczogbWxfY2FudmFzX2ltYWdlX2RhdGFfY3JlYXRlX2Zyb21fcG5nXG4vL1JlcXVpcmVzOiBfbWxfY2FudmFzX2Vuc3VyZV9pbml0aWFsaXplZCwgX21sX2NhbnZhc19pbWFnZV9vZl9wbmdfZmlsZSwgX21sX2NhbnZhc19iYV9vZl9pbWdcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcsIGNhbWxfbmFtZWRfdmFsdWVcbmZ1bmN0aW9uIG1sX2NhbnZhc19pbWFnZV9kYXRhX2NyZWF0ZV9mcm9tX3BuZyhmaWxlbmFtZSwgb25sb2FkKSB7XG4gIF9tbF9jYW52YXNfZW5zdXJlX2luaXRpYWxpemVkKCk7XG4gIHZhciBpbWcgPSBfbWxfY2FudmFzX2ltYWdlX29mX3BuZ19maWxlKGZpbGVuYW1lKTtcbiAgaWYgKGltZyA9PT0gbnVsbCkge1xuICAgIGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcoY2FtbF9uYW1lZF92YWx1ZShcIlJlYWRfcG5nX2ZhaWxlZFwiKSwgZmlsZW5hbWUpO1xuICAgIHJldHVybiAwO1xuICB9XG4gIGltZ1swXS50aGVuKGZ1bmN0aW9uIChfX2ltZykge1xuICAgIHZhciBiYSA9IF9tbF9jYW52YXNfYmFfb2ZfaW1nKGltZ1sxXSk7XG4gICAgb25sb2FkKGJhKTtcbiAgICByZXR1cm4gMDtcbiAgfSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBtbF9jYW52YXNfaW1hZ2VfZGF0YV9nZXRfc2l6ZVxuLy9SZXF1aXJlczogY2FtbF9iYV9kaW1cbmZ1bmN0aW9uIG1sX2NhbnZhc19pbWFnZV9kYXRhX2dldF9zaXplKGRhdGEpIHtcbiAgcmV0dXJuIFswLCBjYW1sX2JhX2RpbShkYXRhLCAxKSwgY2FtbF9iYV9kaW0oZGF0YSwgMCldO1xufVxuXG4vL1Byb3ZpZGVzOiBtbF9jYW52YXNfaW1hZ2VfZGF0YV9maWxsXG4vL1JlcXVpcmVzOiBjYW1sX2JhX3RvX3R5cGVkX2FycmF5XG5mdW5jdGlvbiBtbF9jYW52YXNfaW1hZ2VfZGF0YV9maWxsKGRhdGEsIGNvbG9yKSB7XG4gIHZhciB0YSA9IG5ldyB3aW5kb3cuVWludDMyQXJyYXkoY2FtbF9iYV90b190eXBlZF9hcnJheShkYXRhKS5idWZmZXIpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRhLmxlbmd0aDsgaSsrKSB7XG4gICAgdGFbaV0gPSBjb2xvcjtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogX21sX2NhbnZhc19hZGp1c3RfYmxpdF9pbmZvXG5mdW5jdGlvbiBfbWxfY2FudmFzX2FkanVzdF9ibGl0X2luZm8oZHdpZHRoLCBkaGVpZ2h0LCBkeCwgZHksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpZHRoLCBzaGVpZ2h0LCBzeCwgc3ksIHdpZHRoLCBoZWlnaHQpIHtcbiAgaWYgKGR4IDwgMCkgeyBzeCAtPSBkeDsgd2lkdGggICs9IGR4OyBkeCA9IDA7IH1cbiAgaWYgKGR5IDwgMCkgeyBzeSAtPSBkeTsgaGVpZ2h0ICs9IGR5OyBkeSA9IDA7IH1cbiAgaWYgKHN4IDwgMCkgeyBkeCAtPSBzeDsgd2lkdGggICs9IHN4OyBzeCA9IDA7IH1cbiAgaWYgKHN5IDwgMCkgeyBkeSAtPSBzeTsgaGVpZ2h0ICs9IHN5OyBzeSA9IDA7IH1cbiAgaWYgKGR4ICsgd2lkdGggID4gZHdpZHRoKSAgeyB3aWR0aCAgPSBkd2lkdGggIC0gZHg7IH1cbiAgaWYgKGR5ICsgaGVpZ2h0ID4gZGhlaWdodCkgeyBoZWlnaHQgPSBkaGVpZ2h0IC0gZHk7IH1cbiAgaWYgKHN4ICsgd2lkdGggID4gc3dpZHRoKSAgeyB3aWR0aCAgPSBzd2lkdGggIC0gc3g7IH1cbiAgaWYgKHN5ICsgaGVpZ2h0ID4gc2hlaWdodCkgeyBoZWlnaHQgPSBzaGVpZ2h0IC0gc3k7IH1cbiAgcmV0dXJuIFtkeCwgZHksIHN4LCBzeSwgd2lkdGgsIGhlaWdodF07XG59XG5cbi8vUHJvdmlkZXM6IG1sX2NhbnZhc19pbWFnZV9kYXRhX3N1YlxuLy9SZXF1aXJlczogX21sX2NhbnZhc192YWxpZF9jYW52YXNfc2l6ZSwgX21sX2NhbnZhc19hZGp1c3RfYmxpdF9pbmZvXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2RpbSwgY2FtbF9iYV90b190eXBlZF9hcnJheSwgY2FtbF9iYV9jcmVhdGVfdW5zYWZlLCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIG1sX2NhbnZhc19pbWFnZV9kYXRhX3N1YihzcmNfZGF0YSwgc3Bvcywgc2l6ZSkge1xuICB2YXIgZHdpZHRoID0gc2l6ZVsxXTtcbiAgdmFyIGRoZWlnaHQgPSBzaXplWzJdO1xuICBpZiAoIV9tbF9jYW52YXNfdmFsaWRfY2FudmFzX3NpemUoZHdpZHRoLCBkaGVpZ2h0KSkge1xuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkltYWdlRGF0YS5ibGl0OiBpbnZhbGlkIGRpbWVuc2lvbnNcIik7XG4gIH1cbiAgdmFyIHN3aWR0aCA9IGNhbWxfYmFfZGltKHNyY19kYXRhLCAxKTtcbiAgdmFyIHNoZWlnaHQgPSBjYW1sX2JhX2RpbShzcmNfZGF0YSwgMCk7XG4gIHZhciB0YSA9IG5ldyB3aW5kb3cuVWludDhBcnJheShkd2lkdGggKiBkaGVpZ2h0ICogNCk7XG4gIHZhciBkc3RfZGF0YSA9IGNhbWxfYmFfY3JlYXRlX3Vuc2FmZSgzIC8qIFVpbnQ4QXJyYXkgKi8sIDAgLyogY19sYXlvdXQgKi8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbZGhlaWdodCwgZHdpZHRoLCA0XSwgdGEpO1xuICB2YXIgYmxpdF9pbmZvID1cbiAgICBfbWxfY2FudmFzX2FkanVzdF9ibGl0X2luZm8oZHdpZHRoLCBkaGVpZ2h0LCAwLCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2lkdGgsIHNoZWlnaHQsIHNwb3NbMV0sIHNwb3NbMl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR3aWR0aCwgZGhlaWdodCk7XG4gIHZhciBkeCA9IGJsaXRfaW5mb1swXTtcbiAgdmFyIGR5ID0gYmxpdF9pbmZvWzFdO1xuICB2YXIgc3ggPSBibGl0X2luZm9bMl07XG4gIHZhciBzeSA9IGJsaXRfaW5mb1szXTtcbiAgdmFyIHdpZHRoID0gYmxpdF9pbmZvWzRdO1xuICB2YXIgaGVpZ2h0ID0gYmxpdF9pbmZvWzVdO1xuICBpZiAoKHdpZHRoID4gMCkgJiYgKGhlaWdodCA+IDApKSB7XG4gICAgdmFyIGR0YSA9IG5ldyB3aW5kb3cuVWludDMyQXJyYXkoY2FtbF9iYV90b190eXBlZF9hcnJheShkc3RfZGF0YSkuYnVmZmVyKTtcbiAgICB2YXIgc3RhID0gbmV3IHdpbmRvdy5VaW50MzJBcnJheShjYW1sX2JhX3RvX3R5cGVkX2FycmF5KHNyY19kYXRhKS5idWZmZXIpO1xuICAgIGZvciAodmFyIHkgPSAwOyB5IDwgaGVpZ2h0OyArK3kpIHtcbiAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgd2lkdGg7ICsreCkge1xuICAgICAgICBkdGFbKGR5ICsgeSkgKiBkd2lkdGggKyAoZHggKyB4KV0gPVxuICAgICAgICAgIHN0YVsoc3kgKyB5KSAqIHN3aWR0aCArIChzeCArIHgpXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRzdF9kYXRhO1xufVxuXG4vL1Byb3ZpZGVzOiBtbF9jYW52YXNfaW1hZ2VfZGF0YV9ibGl0XG4vL1JlcXVpcmVzOiBfbWxfY2FudmFzX3ZhbGlkX2NhbnZhc19zaXplLCBfbWxfY2FudmFzX2FkanVzdF9ibGl0X2luZm9cbi8vUmVxdWlyZXM6IGNhbWxfYmFfZGltLCBjYW1sX2JhX3RvX3R5cGVkX2FycmF5LCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIG1sX2NhbnZhc19pbWFnZV9kYXRhX2JsaXQoZHN0X2RhdGEsIGRwb3MsIHNyY19kYXRhLCBzcG9zLCBzaXplKSB7XG4gIHZhciB3aWR0aCA9IHNpemVbMV07XG4gIHZhciBoZWlnaHQgPSBzaXplWzJdO1xuICBpZiAoIV9tbF9jYW52YXNfdmFsaWRfY2FudmFzX3NpemUod2lkdGgsIGhlaWdodCkpIHtcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJJbWFnZURhdGEuYmxpdDogaW52YWxpZCBkaW1lbnNpb25zXCIpO1xuICB9XG4gIHZhciBkd2lkdGggPSBjYW1sX2JhX2RpbShkc3RfZGF0YSwgMSk7XG4gIHZhciBkaGVpZ2h0ID0gY2FtbF9iYV9kaW0oZHN0X2RhdGEsIDApO1xuICB2YXIgc3dpZHRoID0gY2FtbF9iYV9kaW0oc3JjX2RhdGEsIDEpO1xuICB2YXIgc2hlaWdodCA9IGNhbWxfYmFfZGltKHNyY19kYXRhLCAwKTtcbiAgdmFyIGJsaXRfaW5mbyA9XG4gICAgX21sX2NhbnZhc19hZGp1c3RfYmxpdF9pbmZvKGR3aWR0aCwgZGhlaWdodCwgZHBvc1sxXSwgZHBvc1syXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpZHRoLCBzaGVpZ2h0LCBzcG9zWzFdLCBzcG9zWzJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCwgaGVpZ2h0KTtcbiAgdmFyIGR4ID0gYmxpdF9pbmZvWzBdO1xuICB2YXIgZHkgPSBibGl0X2luZm9bMV07XG4gIHZhciBzeCA9IGJsaXRfaW5mb1syXTtcbiAgdmFyIHN5ID0gYmxpdF9pbmZvWzNdO1xuICB2YXIgd2lkdGggPSBibGl0X2luZm9bNF07XG4gIHZhciBoZWlnaHQgPSBibGl0X2luZm9bNV07XG4gIGlmICgod2lkdGggPiAwKSAmJiAoaGVpZ2h0ID4gMCkpIHtcbiAgICB2YXIgZHRhID0gbmV3IHdpbmRvdy5VaW50MzJBcnJheShjYW1sX2JhX3RvX3R5cGVkX2FycmF5KGRzdF9kYXRhKS5idWZmZXIpO1xuICAgIHZhciBzdGEgPSBuZXcgd2luZG93LlVpbnQzMkFycmF5KGNhbWxfYmFfdG9fdHlwZWRfYXJyYXkoc3JjX2RhdGEpLmJ1ZmZlcik7XG4gICAgZm9yICh2YXIgeSA9IDA7IHkgPCBoZWlnaHQ7ICsreSkge1xuICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCB3aWR0aDsgKyt4KSB7XG4gICAgICAgIGR0YVsoZHkgKyB5KSAqIGR3aWR0aCArIChkeCArIHgpXSA9XG4gICAgICAgICAgc3RhWyhzeSArIHkpICogc3dpZHRoICsgKHN4ICsgeCldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogbWxfY2FudmFzX2ltYWdlX2RhdGFfZ2V0X3BpeGVsXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2RpbSwgY2FtbF9iYV90b190eXBlZF9hcnJheVxuZnVuY3Rpb24gbWxfY2FudmFzX2ltYWdlX2RhdGFfZ2V0X3BpeGVsKGRhdGEsIHBvcykge1xuICB2YXIgdGEgPSBuZXcgd2luZG93LlVpbnQzMkFycmF5KGNhbWxfYmFfdG9fdHlwZWRfYXJyYXkoZGF0YSkuYnVmZmVyKTtcbiAgcmV0dXJuIHRhW3Bvc1syXSAqIGNhbWxfYmFfZGltKGRhdGEsIDEpICsgcG9zWzFdXVxufVxuXG4vL1Byb3ZpZGVzOiBtbF9jYW52YXNfaW1hZ2VfZGF0YV9wdXRfcGl4ZWxcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZGltLCBjYW1sX2JhX3RvX3R5cGVkX2FycmF5XG5mdW5jdGlvbiBtbF9jYW52YXNfaW1hZ2VfZGF0YV9wdXRfcGl4ZWwoZGF0YSwgcG9zLCBjb2xvcikge1xuICB2YXIgdGEgPSBuZXcgd2luZG93LlVpbnQzMkFycmF5KGNhbWxfYmFfdG9fdHlwZWRfYXJyYXkoZGF0YSkuYnVmZmVyKTtcbiAgdGFbcG9zWzJdICogY2FtbF9iYV9kaW0oZGF0YSwgMSkgKyBwb3NbMV1dID0gY29sb3I7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBtbF9jYW52YXNfaW1hZ2VfZGF0YV9pbXBvcnRfcG5nXG4vL1JlcXVpcmVzOiBfbWxfY2FudmFzX2Vuc3VyZV9pbml0aWFsaXplZCwgX21sX2NhbnZhc19zdXJmYWNlX29mX2JhLCBfbWxfY2FudmFzX2ltYWdlX29mX3BuZ19maWxlXG4vL1JlcXVpcmVzOiBjYW1sX2JhX3RvX3R5cGVkX2FycmF5LCBjYW1sX3JhaXNlX3dpdGhfc3RyaW5nLCBjYW1sX25hbWVkX3ZhbHVlXG5mdW5jdGlvbiBtbF9jYW52YXNfaW1hZ2VfZGF0YV9pbXBvcnRfcG5nKGRhdGEsIHBvcywgZmlsZW5hbWUsIG9ubG9hZCkge1xuICBfbWxfY2FudmFzX2Vuc3VyZV9pbml0aWFsaXplZCgpO1xuICB2YXIgaW1nID0gX21sX2NhbnZhc19pbWFnZV9vZl9wbmdfZmlsZShmaWxlbmFtZSk7XG4gIHZhciBzdXJmYWNlID0gX21sX2NhbnZhc19zdXJmYWNlX29mX2JhKGRhdGEpO1xuICBpZiAoKGltZyA9PT0gbnVsbCkgfHwgKHN1cmZhY2UgPT09IG51bGwpKSB7XG4gICAgY2FtbF9yYWlzZV93aXRoX3N0cmluZyhjYW1sX25hbWVkX3ZhbHVlKFwiUmVhZF9wbmdfZmFpbGVkXCIpLCBmaWxlbmFtZSk7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgaW1nWzBdLnRoZW4oZnVuY3Rpb24gKF9faW1nKSB7XG4gICAgdmFyIGN0eHQgPSBzdXJmYWNlLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICBjdHh0LmRyYXdJbWFnZShpbWdbMV0sIHBvc1sxXSwgcG9zWzJdKTtcbiAgICB2YXIgaW1hZ2UgPSBjdHh0LmdldEltYWdlRGF0YSgwLCAwLCBzdXJmYWNlLndpZHRoLCBzdXJmYWNlLmhlaWdodCk7XG4gICAgdmFyIHN0YSA9IG5ldyB3aW5kb3cuVWludDhBcnJheShpbWFnZS5kYXRhLmJ1ZmZlcik7XG4gICAgdmFyIGR0YSA9IGNhbWxfYmFfdG9fdHlwZWRfYXJyYXkoZGF0YSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGR0YVtpXSA9IHN0YVtpXTtcbiAgICB9XG4gICAgb25sb2FkKGRhdGEpO1xuICAgIHJldHVybiAwO1xuICB9KTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IG1sX2NhbnZhc19pbWFnZV9kYXRhX2V4cG9ydF9wbmdcbi8vUmVxdWlyZXM6IF9tbF9jYW52YXNfZW5zdXJlX2luaXRpYWxpemVkLCBfbWxfY2FudmFzX3N1cmZhY2Vfb2ZfYmFcbi8vUmVxdWlyZXM6IGNhbWxfY3JlYXRlX2ZpbGUsIGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcsIGNhbWxfbmFtZWRfdmFsdWVcbmZ1bmN0aW9uIG1sX2NhbnZhc19pbWFnZV9kYXRhX2V4cG9ydF9wbmcoZGF0YSwgZmlsZW5hbWUpIHtcbiAgX21sX2NhbnZhc19lbnN1cmVfaW5pdGlhbGl6ZWQoKTtcbiAgdHJ5IHtcbiAgICB2YXIgc3VyZmFjZSA9IF9tbF9jYW52YXNfc3VyZmFjZV9vZl9iYShkYXRhKTtcbiAgICBpZiAoc3VyZmFjZSAhPT0gbnVsbCkge1xuICAgICAgdmFyIGRhdGEgPSBzdXJmYWNlLnRvRGF0YVVSTChcImltYWdlL3BuZ1wiKS5zdWJzdHJpbmcoMjIpO1xuICAgICAgY2FtbF9jcmVhdGVfZmlsZShmaWxlbmFtZSwgd2luZG93LmF0b2IoZGF0YSkpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXhuKSB7XG4gICAgY2FtbF9yYWlzZV93aXRoX3N0cmluZyhjYW1sX25hbWVkX3ZhbHVlKFwiV3JpdGVfcG5nX2ZhaWxlZFwiKSwgZmlsZW5hbWUpO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG5cblxuLyogUGF0aDJEICovXG5cbi8vUHJvdmlkZXM6IG1sX2NhbnZhc19wYXRoX2NyZWF0ZVxuZnVuY3Rpb24gbWxfY2FudmFzX3BhdGhfY3JlYXRlKCkge1xuICByZXR1cm4gbmV3IHdpbmRvdy5QYXRoMkQoKTtcbn1cblxuLy9Qcm92aWRlczogbWxfY2FudmFzX3BhdGhfY2xvc2VcbmZ1bmN0aW9uIG1sX2NhbnZhc19wYXRoX2Nsb3NlKHBhdGgpIHtcbiAgcGF0aC5jbG9zZVBhdGgoKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IG1sX2NhbnZhc19wYXRoX21vdmVfdG9cbmZ1bmN0aW9uIG1sX2NhbnZhc19wYXRoX21vdmVfdG8ocGF0aCwgcCkge1xuICBwYXRoLm1vdmVUbyhwWzFdLCBwWzJdKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IG1sX2NhbnZhc19wYXRoX2xpbmVfdG9cbmZ1bmN0aW9uIG1sX2NhbnZhc19wYXRoX2xpbmVfdG8ocGF0aCwgcCkge1xuICBwYXRoLmxpbmVUbyhwWzFdLCBwWzJdKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IG1sX2NhbnZhc19wYXRoX2FyY1xuZnVuY3Rpb24gbWxfY2FudmFzX3BhdGhfYXJjKHBhdGgsIHAsIHJhZGl1cywgdGhldGExLCB0aGV0YTIsIGNjdykge1xuICBwYXRoLmFyYyhwWzFdLCBwWzJdLCByYWRpdXMsIHRoZXRhMSwgdGhldGEyLCBjY3cpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogbWxfY2FudmFzX3BhdGhfYXJjX3RvXG5mdW5jdGlvbiBtbF9jYW52YXNfcGF0aF9hcmNfdG8ocGF0aCwgcDEsIHAyLCByYWRpdXMpIHtcbiAgcGF0aC5hcmNUbyhwMVsxXSwgcDFbMl0sIHAyWzFdLCBwMlsyXSwgcmFkaXVzKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IG1sX2NhbnZhc19wYXRoX3F1YWRyYXRpY19jdXJ2ZV90b1xuZnVuY3Rpb24gbWxfY2FudmFzX3BhdGhfcXVhZHJhdGljX2N1cnZlX3RvKHBhdGgsIGNwLCBwKSB7XG4gIHBhdGgucXVhZHJhdGljQ3VydmVUbyhjcFsxXSwgY3BbMl0sIHBbMV0sIHBbMl0pO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlcyA6IG1sX2NhbnZhc19wYXRoX2Jlemllcl9jdXJ2ZV90b1xuZnVuY3Rpb24gbWxfY2FudmFzX3BhdGhfYmV6aWVyX2N1cnZlX3RvKHBhdGgsIGNwMSwgY3AyLCBwKSB7XG4gIHBhdGguYmV6aWVyQ3VydmVUbyhjcDFbMV0sIGNwMVsyXSwgY3AyWzFdLCBjcDJbMl0sIHBbMV0sIHBbMl0pO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogbWxfY2FudmFzX3BhdGhfcmVjdFxuZnVuY3Rpb24gbWxfY2FudmFzX3BhdGhfcmVjdChwYXRoLCBwb3MsIHNpemUpIHtcbiAgcGF0aC5yZWN0KHBvc1sxXSwgcG9zWzJdLCBzaXplWzFdLCBzaXplWzJdKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IG1sX2NhbnZhc19wYXRoX2VsbGlwc2VcbmZ1bmN0aW9uIG1sX2NhbnZhc19wYXRoX2VsbGlwc2UocGF0aCwgcCwgcmFkaXVzLCByb3RhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhldGExLCB0aGV0YTIsIGNjdykge1xuICBwYXRoLmVsbGlwc2UocFsxXSwgcFsyXSwgcmFkaXVzWzFdLCByYWRpdXNbMl0sXG4gICAgICAgICAgICAgICByb3RhdGlvbiwgdGhldGExLCB0aGV0YTIsIGNjdyk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBtbF9jYW52YXNfcGF0aF9hZGRcbmZ1bmN0aW9uIG1sX2NhbnZhc19wYXRoX2FkZChwYXRoMSwgcGF0aDIpIHtcbiAgcGF0aDEuYWRkUGF0aChwYXRoMik7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBtbF9jYW52YXNfcGF0aF9hZGRfdHJhbnNmb3JtZWRcbmZ1bmN0aW9uIG1sX2NhbnZhc19wYXRoX2FkZF90cmFuc2Zvcm1lZChwYXRoMSwgcGF0aDIsIHQpIHtcbiAgdmFyIG0gPSBuZXcgd2luZG93LkRPTU1hdHJpeChbWzFdLCB0WzJdLCB0WzNdLCB0WzRdLCB0WzVdLCB0WzZdXSk7XG4gIHBhdGgxLmFkZFBhdGgocGF0aDIsIG0pO1xuICByZXR1cm4gMDtcbn1cblxuXG5cbi8qIEdyYWRpZW50cyAqL1xuXG4vL1Byb3ZpZGVzOiBtbF9jYW52YXNfZ3JhZGllbnRfY3JlYXRlX2xpbmVhclxuLy9SZXF1aXJlcyA6IF9pbnRlcm5hbF9jdHh0XG5mdW5jdGlvbiBtbF9jYW52YXNfZ3JhZGllbnRfY3JlYXRlX2xpbmVhcihwb3MxLCBwb3MyKSB7XG4gIHJldHVybiBfaW50ZXJuYWxfY3R4dC5jcmVhdGVMaW5lYXJHcmFkaWVudChwb3MxWzFdLCBwb3MxWzJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zMlsxXSwgcG9zMlsyXSk7XG59XG5cbi8vUHJvdmlkZXM6IG1sX2NhbnZhc19ncmFkaWVudF9jcmVhdGVfcmFkaWFsXG4vL1JlcXVpcmVzIDogX2ludGVybmFsX2N0eHRcbmZ1bmN0aW9uIG1sX2NhbnZhc19ncmFkaWVudF9jcmVhdGVfcmFkaWFsKGNlbnRlcjEsIHJhZDEsIGNlbnRlcjIsIHJhZDIpIHtcbiAgcmV0dXJuIF9pbnRlcm5hbF9jdHh0LmNyZWF0ZVJhZGlhbEdyYWRpZW50KGNlbnRlcjFbMV0sIGNlbnRlcjFbMl0sIHJhZDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZW50ZXIyWzFdLCBjZW50ZXIyWzJdLCByYWQyKTtcbn1cblxuLy9Qcm92aWRlczogbWxfY2FudmFzX2dyYWRpZW50X2NyZWF0ZV9jb25pY1xuLy9SZXF1aXJlcyA6IF9pbnRlcm5hbF9jdHh0XG5mdW5jdGlvbiBtbF9jYW52YXNfZ3JhZGllbnRfY3JlYXRlX2NvbmljKGNlbnRlciwgYW5nbGUpIHtcbiAgcmV0dXJuIF9pbnRlcm5hbF9jdHh0LmNyZWF0ZUNvbmljR3JhZGllbnQoYW5nbGUsIGNlbnRlclsxXSwgY2VudGVyWzJdKTtcbn1cblxuLy9Qcm92aWRlczogbWxfY2FudmFzX2dyYWRpZW50X2FkZF9jb2xvcl9zdG9wXG4vL1JlcXVpcmVzOiBfY29sb3Jfb2ZfaW50XG5mdW5jdGlvbiBtbF9jYW52YXNfZ3JhZGllbnRfYWRkX2NvbG9yX3N0b3AoZ3JhZGllbnQsIGNvbG9yLCBwb3MpIHtcbiAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKHBvcywgX2NvbG9yX29mX2ludChjb2xvcikpO1xuICByZXR1cm4gMDtcbn1cblxuXG5cbi8qIFBhdHRlcm5zICovXG5cbi8vUHJvdmlkZXM6IG1sX2NhbnZhc19wYXR0ZXJuX2NyZWF0ZVxuLy9SZXF1aXJlcyA6IFJlcGVhdF92YWwsIF9tbF9jYW52YXNfc3VyZmFjZV9vZl9iYSwgX2ludGVybmFsX2N0eHRcbmZ1bmN0aW9uIG1sX2NhbnZhc19wYXR0ZXJuX2NyZWF0ZShpbWFnZSwgcmVwZWF0KSB7XG4gIHZhciBpbWdfY2FudiA9IF9tbF9jYW52YXNfc3VyZmFjZV9vZl9iYShpbWFnZSk7XG4gIHJldHVybiBfaW50ZXJuYWxfY3R4dC5jcmVhdGVQYXR0ZXJuKGltZ19jYW52LCBSZXBlYXRfdmFsKHJlcGVhdCkpO1xufVxuXG5cblxuLyogQ2FudmFzICovXG5cbi8qIENvbXBhcmlzb24gYW5kIGhhc2hpbmcgKi9cblxuLy8gUHJvdmlkZXM6IG1sX2NhbnZhc19oYXNoXG4vLyBSZXF1aXJlczogY2FtbF9uYW1lZF92YWx1ZVxuZnVuY3Rpb24gbWxfY2FudmFzX2hhc2goY2FudmFzKSB7XG4gIHZhciBoYXNoID0gY2FtbF9uYW1lZF92YWx1ZShcIkhhc2h0YmwuaGFzaFwiKTtcbiAgcmV0dXJuIGhhc2goY2FudmFzLmlkKTtcbn1cblxuLy8gUHJvdmlkZXM6IG1sX2NhbnZhc19jb21wYXJlXG5mdW5jdGlvbiBtbF9jYW52YXNfY29tcGFyZShjYW52YXMxLCBjYW52YXMyKSB7XG4gIGlmIChjYW52YXMxLmlkIDwgY2FudmFzMi5pZCkge1xuICAgIHJldHVybiAtMTtcbiAgfSBlbHNlIGlmIChjYW52YXMxLmlkID4gY2FudmFzMi5pZCkge1xuICAgIHJldHVybiAxO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAwO1xuICB9XG59XG5cblxuXG4vKiBDcmVhdGlvbiAqL1xuXG4vL1Byb3ZpZGVzOiBfbmV4dF9pZFxudmFyIF9uZXh0X2lkID0gMDtcblxuLy9Qcm92aWRlczogX21sX2NhbnZhc19kZWNvcmF0ZVxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIF9tbF9jYW52YXNfZGVjb3JhdGUoaGVhZGVyLCBtaW5pbWl6ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4aW1pemUsIGNsb3NlLCB0aXRsZSkge1xuICB2YXIgd2lkdGggPSBoZWFkZXIud2lkdGg7XG4gIHZhciBjdHh0ID0gaGVhZGVyLmdldENvbnRleHQoXCIyZFwiKTtcbiAgY3R4dC5maWxsU3R5bGUgPSBcIiM1ODU4NThcIjtcbiAgY3R4dC5maWxsUmVjdCgwLCAwLCB3aWR0aCwgMzApO1xuICBpZiAodGl0bGUgIT09IG51bGwpIHtcbiAgICBjdHh0LmZpbGxTdHlsZSA9IFwiI0YwRjBGMEYwXCI7XG4gICAgY3R4dC5mb250ID0gXCJib2xkIDE2cHggQXJpYWxcIjtcbiAgICBjdHh0LnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XG4gICAgY3R4dC5maWxsVGV4dChjYW1sX2pzc3RyaW5nX29mX3N0cmluZyh0aXRsZSksIHdpZHRoIC8gMiwgMjEpO1xuICB9XG4gIGN0eHQuc3Ryb2tlU3R5bGUgPSBcIiNGMEYwRjBGMFwiO1xuICBjdHh0LmxpbmVXaWR0aCA9IDIuMDtcbiAgaWYgKGNsb3NlID09IHRydWUpIHtcbiAgICBjdHh0LmJlZ2luUGF0aCgpO1xuICAgIGN0eHQubW92ZVRvKHdpZHRoIC0gMjAsIDEwKTtcbiAgICBjdHh0LmxpbmVUbyh3aWR0aCAtIDEwLCAyMCk7XG4gICAgY3R4dC5tb3ZlVG8od2lkdGggLSAyMCwgMjApO1xuICAgIGN0eHQubGluZVRvKHdpZHRoIC0gMTAsIDEwKTtcbiAgICBjdHh0LnN0cm9rZSgpO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IG1sX2NhbnZhc19jcmVhdGVfb25zY3JlZW5cbi8vUmVxdWlyZXM6IF9tbF9jYW52YXNfZW5zdXJlX2luaXRpYWxpemVkLCBfbWxfY2FudmFzX3ZhbGlkX2NhbnZhc19zaXplLCBfcmVzaXplLCBfbmV4dF9pZCwgX2hlYWRlcl9kb3duX2hhbmRsZXJcbi8vUmVxdWlyZXM6IF9zdXJmYWNlX2Rvd25faGFuZGxlciwgX3VwX2hhbmRsZXIsIF9tb3ZlX2hhbmRsZXIsIF9tbF9jYW52YXNfZGVjb3JhdGUsIE9wdGlvbmFsX2Jvb2xfdmFsLCBPcHRpb25hbF92YWxcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gbWxfY2FudmFzX2NyZWF0ZV9vbnNjcmVlbihhdXRvY29tbWl0LCBkZWNvcmF0ZWQsIHJlc2l6ZWFibGUsIG1pbmltaXplLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhpbWl6ZSwgY2xvc2UsIHRpdGxlLCB0YXJnZXQsIHBvcywgc2l6ZSkge1xuXG4gIF9tbF9jYW52YXNfZW5zdXJlX2luaXRpYWxpemVkKCk7XG5cbiAgdmFyIHdpZHRoID0gc2l6ZVsxXTtcbiAgdmFyIGhlaWdodCA9IHNpemVbMl07XG4gIGlmICghX21sX2NhbnZhc192YWxpZF9jYW52YXNfc2l6ZSh3aWR0aCwgaGVpZ2h0KSkge1xuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkNhbnZhcy5ibGl0OiBpbnZhbGlkIGRpbWVuc2lvbnNcIik7XG4gIH1cblxuICB2YXIgcG9zID0gT3B0aW9uYWxfdmFsKHBvcywgWzAsIDAsIDBdKTtcbiAgdmFyIHggPSBwb3NbMV07XG4gIHZhciB5ID0gcG9zWzJdO1xuXG4gIHZhciBhdXRvY29tbWl0ID0gT3B0aW9uYWxfYm9vbF92YWwoYXV0b2NvbW1pdCwgdHJ1ZSk7XG4gIHZhciBkZWNvcmF0ZWQgPSBmYWxzZTsgLy8gT3B0aW9uYWxfYm9vbF92YWwoZGVjb3JhdGVkLCB0cnVlKTtcbiAgdmFyIHJlc2l6ZWFibGUgPSBPcHRpb25hbF9ib29sX3ZhbChyZXNpemVhYmxlLCB0cnVlKTtcbiAgdmFyIG1pbmltaXplID0gT3B0aW9uYWxfYm9vbF92YWwobWluaW1pemUsIHRydWUpO1xuICB2YXIgbWF4aW1pemUgPSBPcHRpb25hbF9ib29sX3ZhbChtYXhpbWl6ZSwgdHJ1ZSk7XG4gIHZhciBjbG9zZSA9IE9wdGlvbmFsX2Jvb2xfdmFsKGNsb3NlLCB0cnVlKTtcbiAgdmFyIHRpdGxlID0gT3B0aW9uYWxfdmFsKHRpdGxlLCBudWxsKTtcbiAgdmFyIHRhcmdldCA9IE9wdGlvbmFsX3ZhbCh0YXJnZXQsIG51bGwpO1xuICB0YXJnZXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0YXJnZXQpO1xuICBpZih0YXJnZXQgPT0gbnVsbCkge1xuICAgIHRhcmdldCA9IGRvY3VtZW50LmJvZHk7XG4gIH1cblxuICB2YXIgaWQgPSArK19uZXh0X2lkO1xuXG4gIHZhciBjYW52YXMgPSB7XG4gICAgbmFtZTogdGl0bGUsXG4gICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgZnJhbWU6IG51bGwsXG4gICAgaGVhZGVyOiBudWxsLFxuICAgIHN1cmZhY2U6IG51bGwsXG4gICAgY3R4dDogbnVsbCxcbiAgICB4OiB4LCB5OiB5LFxuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICBpZDogaWQsXG4gICAgYXV0b2NvbW1pdDogYXV0b2NvbW1pdCxcbiAgICByZXNpemVhYmxlOiByZXNpemVhYmxlLFxuICAgIG1pbmltaXplOiBtaW5pbWl6ZSxcbiAgICBtYXhpbWl6ZTogbWF4aW1pemUsXG4gICAgY2xvc2U6IGNsb3NlXG4gIH07XG5cbiAgdmFyIGhlYWRlcl9oZWlnaHQgPSAoZGVjb3JhdGVkID09IHRydWUgPyAzMCA6IDApO1xuXG4gIHZhciBmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIGZyYW1lLmlkID0gXCJmXCIgKyBpZDtcbiAgaWYgKHJlc2l6ZWFibGUgPT0gdHJ1ZSkge1xuICAgIGZyYW1lLnN0eWxlLndpZHRoID0gXCIxMDAlXCI7XG4gICAgZnJhbWUuc3R5bGUuaGVpZ2h0ID0gXCIxMDAlXCI7XG4gIH0gZWxzZSB7XG4gICAgZnJhbWUuc3R5bGUud2lkdGggPSB3aWR0aCArIFwicHhcIjtcbiAgICBmcmFtZS5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyBoZWFkZXJfaGVpZ2h0ICsgXCJweFwiO1xuICB9XG4gIGZyYW1lLnN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiO1xuICBmcmFtZS5vbmNvbnRleHRtZW51ID0gZnVuY3Rpb24oKSB7IHJldHVybiBmYWxzZTsgfVxuICBmcmFtZS5jYW52YXMgPSBjYW52YXM7XG4gIGNhbnZhcy5mcmFtZSA9IGZyYW1lO1xuICB0YXJnZXQuYXBwZW5kQ2hpbGQoZnJhbWUpO1xuXG4gIHZhciBoZWFkZXIgPSBudWxsO1xuICBpZiAoZGVjb3JhdGVkID09PSB0cnVlKSB7XG4gICAgZnJhbWUuc3R5bGUuYm9yZGVyID0gXCIxcHggc29saWQgYmxhY2tcIjtcbiAgICBoZWFkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgIGhlYWRlci5pZCA9IFwiaFwiICsgaWQ7XG4gICAgaGVhZGVyLndpZHRoID0gd2lkdGg7XG4gICAgaGVhZGVyLmhlaWdodCA9IDMwO1xuICAgIF9tbF9jYW52YXNfZGVjb3JhdGUoaGVhZGVyLCBtaW5pbWl6ZSwgbWF4aW1pemUsIGNsb3NlLCB0aXRsZSk7XG4gICAgaGVhZGVyLm9ubW91c2Vkb3duID0gX2hlYWRlcl9kb3duX2hhbmRsZXI7XG4gICAgaGVhZGVyLmNhbnZhcyA9IGNhbnZhcztcbiAgICBjYW52YXMuaGVhZGVyID0gaGVhZGVyO1xuICAgIGZyYW1lLmFwcGVuZENoaWxkKGhlYWRlcik7XG4gIH1cblxuICB2YXIgc3VyZmFjZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gIHN1cmZhY2UuaWQgPSBcInNcIiArIGlkO1xuICBzdXJmYWNlLndpZHRoID0gd2lkdGg7XG4gIHN1cmZhY2UuaGVpZ2h0ID0gaGVpZ2h0O1xuICBzdXJmYWNlLm9ubW91c2Vkb3duID0gX3N1cmZhY2VfZG93bl9oYW5kbGVyO1xuICBzdXJmYWNlLmNhbnZhcyA9IGNhbnZhcztcbiAgY2FudmFzLnN1cmZhY2UgPSBzdXJmYWNlO1xuICBmcmFtZS5hcHBlbmRDaGlsZChzdXJmYWNlKTtcblxuICBpZiAocmVzaXplYWJsZSA9PT0gdHJ1ZSkge1xuICAgIHN1cmZhY2Uuc3R5bGUud2lkdGggPSBcIjEwMCVcIjtcbiAgICBzdXJmYWNlLnN0eWxlLmhlaWdodCA9IFwiMTAwJVwiO1xuICAgIF9yZXNpemUub2JzZXJ2ZShzdXJmYWNlKTtcbiAgfVxuXG4gIHZhciBjdHh0ID0gc3VyZmFjZS5nZXRDb250ZXh0KFwiMmRcIik7XG4gIGN0eHQuZ2xvYmFsQWxwaGEgPSAxLjA7XG4gIGN0eHQubGluZVdpZHRoID0gMS4wO1xuICBjdHh0LmZpbGxTdHlsZSA9IFwid2hpdGVcIjtcbiAgY3R4dC5zdHJva2VTdHlsZSA9IFwiYmxhY2tcIjtcbiAgY2FudmFzLmN0eHQgPSBjdHh0O1xuXG4gIC8vIE9uc2NyZWVuIGNhbnZhcyBhcmUgZmlsbGVkIHdpdGggd2hpdGUgYnkgZGVmYXVsdFxuICBjdHh0LmZpbGxSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuXG4gIHJldHVybiBjYW52YXM7XG59XG5cbi8vUHJvdmlkZXM6IG1sX2NhbnZhc19jcmVhdGVfb2Zmc2NyZWVuXG4vL1JlcXVpcmVzOiBfbWxfY2FudmFzX2Vuc3VyZV9pbml0aWFsaXplZCwgX21sX2NhbnZhc192YWxpZF9jYW52YXNfc2l6ZSwgX25leHRfaWRcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gbWxfY2FudmFzX2NyZWF0ZV9vZmZzY3JlZW4oc2l6ZSkge1xuXG4gIF9tbF9jYW52YXNfZW5zdXJlX2luaXRpYWxpemVkKCk7XG5cbiAgdmFyIHdpZHRoID0gc2l6ZVsxXTtcbiAgdmFyIGhlaWdodCA9IHNpemVbMl07XG5cbiAgaWYgKCFfbWxfY2FudmFzX3ZhbGlkX2NhbnZhc19zaXplKHdpZHRoLCBoZWlnaHQpKSB7XG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQ2FudmFzLmNyZWF0ZU9mZnNjcmVlbjogaW52YWxpZCBkaW1lbnNpb25zXCIpO1xuICB9XG5cbiAgdmFyIGlkID0gKytfbmV4dF9pZDtcblxuICB2YXIgY2FudmFzID0ge1xuICAgIG5hbWU6IG51bGwsXG4gICAgZnJhbWU6IG51bGwsXG4gICAgaGVhZGVyOiBudWxsLFxuICAgIHN1cmZhY2U6IHN1cmZhY2UsXG4gICAgY3R4dDogY3R4dCxcbiAgICB4OiAwLCB5OiAwLFxuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICBpZDogaWQsXG4gICAgYXV0b2NvbW1pdDogZmFsc2UsXG4gICAgcmVzaXplYWJsZTogZmFsc2UsXG4gICAgbWluaW1pemU6IGZhbHNlLFxuICAgIG1heGltaXplOiBmYWxzZSxcbiAgICBjbG9zZTogZmFsc2VcbiAgfTtcblxuICB2YXIgc3VyZmFjZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gIHN1cmZhY2UuaWQgPSBcInNcIiArIGlkO1xuICBzdXJmYWNlLndpZHRoID0gd2lkdGg7XG4gIHN1cmZhY2UuaGVpZ2h0ID0gaGVpZ2h0O1xuICBzdXJmYWNlLnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiXG4gIHN1cmZhY2UuY2FudmFzID0gY2FudmFzO1xuICBjYW52YXMuc3VyZmFjZSA9IHN1cmZhY2U7XG5cbiAgdmFyIGN0eHQgPSBzdXJmYWNlLmdldENvbnRleHQoXCIyZFwiKTtcbiAgY3R4dC5nbG9iYWxBbHBoYSA9IDEuMDtcbiAgY3R4dC5saW5lV2lkdGggPSAyLjA7XG4gIGN0eHQuZmlsbFN0eWxlID0gXCJ3aGl0ZVwiO1xuICBjdHh0LnN0cm9rZVN0eWxlID0gXCJibGFja1wiO1xuICBjYW52YXMuY3R4dCA9IGN0eHQ7XG5cbiAgcmV0dXJuIGNhbnZhcztcbn1cblxuLy9Qcm92aWRlczogbWxfY2FudmFzX2NyZWF0ZV9vZmZzY3JlZW5fZnJvbV9pbWFnZV9kYXRhXG4vL1JlcXVpcmVzOiBfbWxfY2FudmFzX2Vuc3VyZV9pbml0aWFsaXplZCwgbWxfY2FudmFzX2NyZWF0ZV9vZmZzY3JlZW5cbi8vUmVxdWlyZXM6IGNhbWxfYmFfdG9fdHlwZWRfYXJyYXksIGNhbWxfYmFfZGltXG5mdW5jdGlvbiBtbF9jYW52YXNfY3JlYXRlX29mZnNjcmVlbl9mcm9tX2ltYWdlX2RhdGEoZGF0YSkge1xuICBfbWxfY2FudmFzX2Vuc3VyZV9pbml0aWFsaXplZCgpO1xuICB2YXIgd2lkdGggPSBjYW1sX2JhX2RpbShkYXRhLCAxKTtcbiAgdmFyIGhlaWdodCA9IGNhbWxfYmFfZGltKGRhdGEsIDApO1xuICB2YXIgY2FudmFzID0gbWxfY2FudmFzX2NyZWF0ZV9vZmZzY3JlZW4oWzAsIHdpZHRoLCBoZWlnaHRdKVxuICBpZiAoY2FudmFzID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIHN0YSA9IG5ldyB3aW5kb3cuVWludDhBcnJheShjYW1sX2JhX3RvX3R5cGVkX2FycmF5KGRhdGEpLmJ1ZmZlcik7XG4gIHZhciBkdGEgPSBuZXcgd2luZG93LlVpbnQ4Q2xhbXBlZEFycmF5KHN0YS5sZW5ndGgpO1xuICAvLyBDb252ZXJ0IGZyb20gQkdSQSB0byBSR0JBXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhLmxlbmd0aDsgaSArPSA0KSB7XG4gICAgZHRhW2krMF0gPSBzdGFbaSsyXTtcbiAgICBkdGFbaSsxXSA9IHN0YVtpKzFdO1xuICAgIGR0YVtpKzJdID0gc3RhW2krMF07XG4gICAgZHRhW2krM10gPSBzdGFbaSszXTtcbiAgfVxuICBpZiAod2luZG93LkltYWdlRGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGltYWdlID0gY2FudmFzLmN0eHQuY3JlYXRlSW1hZ2VEYXRhKHdpZHRoLCBoZWlnaHQpO1xuICAgIGltYWdlLmRhdGEuc2V0KGR0YSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGltYWdlID0gbmV3IHdpbmRvdy5JbWFnZURhdGEoZHRhLCB3aWR0aCwgaGVpZ2h0KTtcbiAgfVxuICBjYW52YXMuY3R4dC5wdXRJbWFnZURhdGEoaW1hZ2UsIDAsIDApO1xuICByZXR1cm4gY2FudmFzO1xufVxuXG4vL1Byb3ZpZGVzOiBtbF9jYW52YXNfY3JlYXRlX29mZnNjcmVlbl9mcm9tX3BuZ1xuLy9SZXF1aXJlczogX21sX2NhbnZhc19lbnN1cmVfaW5pdGlhbGl6ZWQsIG1sX2NhbnZhc19jcmVhdGVfb2Zmc2NyZWVuLCBfbWxfY2FudmFzX2ltYWdlX29mX3BuZ19maWxlXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3dpdGhfc3RyaW5nLCBjYW1sX25hbWVkX3ZhbHVlXG5mdW5jdGlvbiBtbF9jYW52YXNfY3JlYXRlX29mZnNjcmVlbl9mcm9tX3BuZyhmaWxlbmFtZSwgb25sb2FkKSB7XG4gIF9tbF9jYW52YXNfZW5zdXJlX2luaXRpYWxpemVkKCk7XG4gIHZhciBpbWcgPSBfbWxfY2FudmFzX2ltYWdlX29mX3BuZ19maWxlKGZpbGVuYW1lKTtcbiAgaWYgKGltZyA9PT0gbnVsbCkge1xuICAgIGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcoY2FtbF9uYW1lZF92YWx1ZShcIlJlYWRfcG5nX2ZhaWxlZFwiKSwgZmlsZW5hbWUpO1xuICAgIHJldHVybiAwO1xuICB9XG4gIGltZ1swXS50aGVuKGZ1bmN0aW9uIChfX2ltZykge1xuICAgIHZhciBjYW52YXMgPSBtbF9jYW52YXNfY3JlYXRlX29mZnNjcmVlbihbMCwgaW1nWzFdLndpZHRoLCBpbWdbMV0uaGVpZ2h0XSlcbiAgICBpZiAoY2FudmFzID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgY2FudmFzLmN0eHQuZHJhd0ltYWdlKGltZ1sxXSwgMCwgMCk7XG4gICAgb25sb2FkKGNhbnZhcyk7XG4gICAgcmV0dXJuIDA7XG4gIH0pO1xuICByZXR1cm4gMDtcbn1cblxuXG5cbi8qIFZpc2liaWxpdHkgKi9cblxuLy8gUHJvdmlkZXM6IG1sX2NhbnZhc19zaG93XG4vLyBSZXF1aXJlczogX2ZvY3VzXG5mdW5jdGlvbiBtbF9jYW52YXNfc2hvdyhjYW52YXMpIHtcbiAgaWYgKGNhbnZhcy5mcmFtZSAhPT0gbnVsbCkge1xuICAgIF9mb2N1cyA9IGNhbnZhcztcbiAgICBjYW52YXMuZnJhbWUuc3R5bGUudmlzaWJpbGl0eSA9IFwidmlzaWJsZVwiO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vLyBQcm92aWRlczogbWxfY2FudmFzX2hpZGVcbi8vIFJlcXVpcmVzOiBfZm9jdXNcbmZ1bmN0aW9uIG1sX2NhbnZhc19oaWRlKGNhbnZhcykge1xuICBpZiAoY2FudmFzLmZyYW1lICE9PSBudWxsKSB7XG4gICAgaWYgKF9mb2N1cyA9PT0gY2FudmFzKSB7XG4gICAgICBfZm9jdXMgPSBudWxsO1xuICAgIH1cbiAgICBjYW52YXMuZnJhbWUuc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCI7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vIFByb3ZpZGVzOiBtbF9jYW52YXNfY2xvc2Vcbi8vIFJlcXVpcmVzOiBtbF9jYW52YXNfaGlkZVxuZnVuY3Rpb24gbWxfY2FudmFzX2Nsb3NlKGNhbnZhcykge1xuICBpZiAoY2FudmFzLmZyYW1lICE9PSBudWxsKSB7XG4gICAgbWxfY2FudmFzX2hpZGUoY2FudmFzKTtcbiAgICBjYW52YXMubmFtZSA9IG51bGw7XG4gICAgaWYgKGNhbnZhcy5zdXJmYWNlICE9IG51bGwpIHtcbiAgICAgIGNhbnZhcy5zdXJmYWNlLmNhbnZhcyA9IG51bGw7XG4gICAgICBpZiAoY2FudmFzLnN1cmZhY2UucGFyZW50Tm9kZSAhPT0gbnVsbCkge1xuICAgICAgICBjYW52YXMuc3VyZmFjZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNhbnZhcy5zdXJmYWNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNhbnZhcy5oZWFkZXIgIT0gbnVsbCkge1xuICAgICAgY2FudmFzLmhlYWRlci5jYW52YXMgPSBudWxsO1xuICAgICAgaWYgKGNhbnZhcy5oZWFkZXIucGFyZW50Tm9kZSAhPT0gbnVsbCkge1xuICAgICAgICBjYW52YXMuaGVhZGVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY2FudmFzLmhlYWRlcik7XG4gICAgICB9XG4gICAgICBjYW52YXMuaGVhZGVyID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGNhbnZhcy5mcmFtZSAhPT0gbnVsbCkge1xuICAgICAgY2FudmFzLmZyYW1lLmNhbnZhcyA9IG51bGw7XG4gICAgICBpZiAoY2FudmFzLmZyYW1lLnBhcmVudE5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgY2FudmFzLmZyYW1lLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY2FudmFzLmZyYW1lKTtcbiAgICAgIH1cbiAgICAgIGNhbnZhcy5mcmFtZSA9IG51bGw7XG4gICAgfVxuICB9XG4gIHJldHVybiAwO1xufVxuXG5cblxuLyogUmVuZGVyaW5nICovXG5cbi8vIFByb3ZpZGVzOiBtbF9jYW52YXNfY29tbWl0XG5mdW5jdGlvbiBtbF9jYW52YXNfY29tbWl0KGNhbnZhcykge1xuICByZXR1cm4gMDtcbn1cblxuXG5cbi8qIENvbmZpZ3VyYXRpb24gKi9cblxuLy8gUHJvdmlkZXM6IG1sX2NhbnZhc19nZXRfaWRcbmZ1bmN0aW9uIG1sX2NhbnZhc19nZXRfaWQoY2FudmFzKSB7XG4gIHJldHVybiBjYW52YXMuaWQ7XG59XG5cbi8vIFByb3ZpZGVzOiBtbF9jYW52YXNfZ2V0X3NpemVcbmZ1bmN0aW9uIG1sX2NhbnZhc19nZXRfc2l6ZShjYW52YXMpIHtcbiAgcmV0dXJuIFswLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHRdO1xufVxuXG4vLyBQcm92aWRlczogbWxfY2FudmFzX3NldF9zaXplXG4vLyBSZXF1aXJlczogX21sX2NhbnZhc192YWxpZF9jYW52YXNfc2l6ZSwgX21sX2NhbnZhc19kZWNvcmF0ZVxuLy8gUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gbWxfY2FudmFzX3NldF9zaXplKGNhbnZhcywgc2l6ZSkge1xuICB2YXIgd2lkdGggPSBzaXplWzFdO1xuICB2YXIgaGVpZ2h0ID0gc2l6ZVsyXTtcbiAgaWYgKCFfbWxfY2FudmFzX3ZhbGlkX2NhbnZhc19zaXplKHdpZHRoLCBoZWlnaHQpKSB7XG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQ2FudmFzLnNldFNpemU6IGludmFsaWQgZGltZW5zaW9uc1wiKTtcbiAgfVxuICB2YXIgaW1nID0gY2FudmFzLmN0eHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gIGlmIChjYW52YXMuaGVhZGVyICE9PSBudWxsKSB7XG4gICAgICBjYW52YXMuaGVhZGVyLndpZHRoID0gd2lkdGg7XG4gICAgICBfbWxfY2FudmFzX2RlY29yYXRlKGNhbnZhcy5oZWFkZXIsIGNhbnZhcy5taW5pbWl6ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FudmFzLm1heGltaXplLCBjYW52YXMuY2xvc2UsIGNhbnZhcy5uYW1lKTtcbiAgfVxuICBjYW52YXMuc3VyZmFjZS53aWR0aCA9IGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICBjYW52YXMuc3VyZmFjZS5oZWlnaHQgPSBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICBjYW52YXMuY3R4dC5maWxsUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgY2FudmFzLmN0eHQucHV0SW1hZ2VEYXRhKGltZywgMCwgMCk7XG4gIHJldHVybiAwO1xufVxuXG4vLyBQcm92aWRlczogbWxfY2FudmFzX2dldF9wb3NpdGlvblxuZnVuY3Rpb24gbWxfY2FudmFzX2dldF9wb3NpdGlvbihjYW52YXMpIHtcbiAgaWYgKGNhbnZhcy5mcmFtZSAhPT0gbnVsbCkge1xuICAgIHJldHVybiBbMCwgY2FudmFzLngsIGNhbnZhcy55XTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gWzAsIDAsIDBdO1xuICB9XG59XG5cbi8vIFByb3ZpZGVzOiBtbF9jYW52YXNfc2V0X3Bvc2l0aW9uXG5mdW5jdGlvbiBtbF9jYW52YXNfc2V0X3Bvc2l0aW9uKGNhbnZhcywgcG9zKSB7XG4gIGlmIChjYW52YXMuZnJhbWUgIT09IG51bGwpIHtcbiAgICB2YXIgeCA9IHBvc1sxXTtcbiAgICB2YXIgeSA9IHBvc1syXTtcbiAgICBjYW52YXMueCA9IHg7XG4gICAgY2FudmFzLnkgPSB5O1xuICAgIGNhbnZhcy5mcmFtZS5zdHlsZS5sZWZ0ID0geCArIFwicHhcIjtcbiAgICBjYW52YXMuZnJhbWUuc3R5bGUudG9wID0geSArIFwicHhcIjtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuXG5cbi8qIFRyYW5zZm9ybSAqL1xuXG4vLyBQcm92aWRlczogbWxfY2FudmFzX3NldF90cmFuc2Zvcm1cbmZ1bmN0aW9uIG1sX2NhbnZhc19zZXRfdHJhbnNmb3JtKGNhbnZhcywgdCkge1xuICBjYW52YXMuY3R4dC5zZXRUcmFuc2Zvcm0odFsxXSwgdFsyXSwgdFszXSwgdFs0XSwgdFs1XSwgdFs2XSk7XG4gIHJldHVybiAwO1xufVxuXG4vLyBQcm92aWRlczogbWxfY2FudmFzX3RyYW5zZm9ybVxuZnVuY3Rpb24gbWxfY2FudmFzX3RyYW5zZm9ybShjYW52YXMsIHQpIHtcbiAgY2FudmFzLmN0eHQudHJhbnNmb3JtKHRbMV0sIHRbMl0sIHRbM10sIHRbNF0sIHRbNV0sIHRbNl0pO1xuICByZXR1cm4gMDtcbn1cblxuLy8gUHJvdmlkZXM6IG1sX2NhbnZhc190cmFuc2xhdGVcbmZ1bmN0aW9uIG1sX2NhbnZhc190cmFuc2xhdGUoY2FudmFzLCB2ZWMpIHtcbiAgY2FudmFzLmN0eHQudHJhbnNsYXRlKHZlY1sxXSwgdmVjWzJdKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vIFByb3ZpZGVzOiBtbF9jYW52YXNfc2NhbGVcbmZ1bmN0aW9uIG1sX2NhbnZhc19zY2FsZShjYW52YXMsIHZlYykge1xuICBjYW52YXMuY3R4dC5zY2FsZSh2ZWNbMV0sIHZlY1syXSk7XG4gIHJldHVybiAwO1xufVxuXG4vLyBQcm92aWRlczogbWxfY2FudmFzX3NoZWFyXG5mdW5jdGlvbiBtbF9jYW52YXNfc2hlYXIoY2FudmFzLCB2ZWMpIHtcbiAgY2FudmFzLmN0eHQudHJhbnNmb3JtKDEuMCwgdmVjWzJdLCB2ZWNbMV0sIDEuMCwgMC4wLCAwLjApO1xuICByZXR1cm4gMDtcbn1cblxuLy8gUHJvdmlkZXM6IG1sX2NhbnZhc19yb3RhdGVcbmZ1bmN0aW9uIG1sX2NhbnZhc19yb3RhdGUoY2FudmFzLCB0aGV0YSkge1xuICBjYW52YXMuY3R4dC5yb3RhdGUodGhldGEpO1xuICByZXR1cm4gMDtcbn1cblxuXG5cbi8qIFN0YXRlICovXG5cbi8vIFByb3ZpZGVzOiBtbF9jYW52YXNfc2F2ZVxuZnVuY3Rpb24gbWxfY2FudmFzX3NhdmUoY2FudmFzKSB7XG4gIGNhbnZhcy5jdHh0LnNhdmUoKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vIFByb3ZpZGVzOiBtbF9jYW52YXNfcmVzdG9yZVxuZnVuY3Rpb24gbWxfY2FudmFzX3Jlc3RvcmUoY2FudmFzKSB7XG4gIGNhbnZhcy5jdHh0LnJlc3RvcmUoKTtcbiAgcmV0dXJuIDA7XG59XG5cblxuXG4vKiBTdHlsZSAvIGNvbmZpZyAqL1xuXG4vL1Byb3ZpZGVzOiBfY29sb3Jfb2ZfaW50XG5mdW5jdGlvbiBfY29sb3Jfb2ZfaW50KGkpIHtcbiAgdmFyIGEgPSAoKGkgJiAweEZGMDAwMDAwKSA+Pj4gMjQpO1xuICBpZiAoYSA9PSAyNTUpIHtcbiAgICByZXR1cm4gXCIjXCIgKyAoaSAmIDB4MDBGRkZGRkYpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCg2LCAnMCcpO1xuICB9XG4gIHZhciBiID0gaSAmIDB4MDAwMDAwRkY7XG4gIHZhciBnID0gKGkgJiAweDAwMDBGRjAwKSA+Pj4gODtcbiAgdmFyIHIgPSAoaSAmIDB4MDBGRjAwMDApID4+PiAxNjtcbiAgcmV0dXJuIFwicmdiYShcIiArIHIgKyBcIixcIiArIGcgKyBcIixcIiArIGIgKyBcIixcIiArIGEgLyAyNTUuMCArIFwiKVwiO1xufVxuXG4vL1Byb3ZpZGVzOiBfaW50X29mX2NvbG9yXG5mdW5jdGlvbiBfaW50X29mX2NvbG9yKGMpIHtcbiAgaWYgKGNbMF0gPT0gJyMnKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KGMuc3Vic3RyKDEsIGMubGVuZ3RoIC0gMSksIDE2KTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgcmdiYSA9IGMucmVwbGFjZSgvXnJnYmE/XFwofFxccyt8XFwpJC9nLCAnJykuc3BsaXQoJywnKTtcbiAgICB2YXIgciA9IHBhcnNlSW50KHJnYmFbMF0pO1xuICAgIHZhciBnID0gcGFyc2VJbnQocmdiYVsxXSk7XG4gICAgdmFyIGIgPSBwYXJzZUludChyZ2JhWzJdKTtcbiAgICB2YXIgYSA9IHBhcnNlRmxvYXQocmdiYVszXSkgKiAyNTU7XG4gICAgcmV0dXJuIGIgfCAoZyA8PCA4KSB8IChyIDw8IDE2KSB8IChhIDw8IDI0KTtcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBtbF9jYW52YXNfZ2V0X2xpbmVfd2lkdGhcbmZ1bmN0aW9uIG1sX2NhbnZhc19nZXRfbGluZV93aWR0aChjYW52YXMpIHtcbiAgcmV0dXJuIGNhbnZhcy5jdHh0LmxpbmVXaWR0aDtcbn1cblxuLy9Qcm92aWRlczogbWxfY2FudmFzX3NldF9saW5lX3dpZHRoXG5mdW5jdGlvbiBtbF9jYW52YXNfc2V0X2xpbmVfd2lkdGgoY2FudmFzLCB3aWR0aCkge1xuICBjYW52YXMuY3R4dC5saW5lV2lkdGggPSB3aWR0aDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IG1sX2NhbnZhc19nZXRfbGluZV9jYXBcbi8vUmVxdWlyZXM6IFZhbF9jYXBfdHlwZVxuZnVuY3Rpb24gbWxfY2FudmFzX2dldF9saW5lX2NhcChjYW52YXMpIHtcbiAgcmV0dXJuIFZhbF9jYXBfdHlwZShjYW52YXMubGluZUNhcCk7XG59XG5cbi8vUHJvdmlkZXM6IG1sX2NhbnZhc19zZXRfbGluZV9jYXBcbi8vUmVxdWlyZXM6IENhcF90eXBlX3ZhbFxuZnVuY3Rpb24gbWxfY2FudmFzX3NldF9saW5lX2NhcChjYW52YXMsIGNhcCkge1xuICBjYW52YXMuY3R4dC5saW5lQ2FwID0gQ2FwX3R5cGVfdmFsKGNhcCk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBtbF9jYW52YXNfZ2V0X2xpbmVfZGFzaF9vZmZzZXRcbmZ1bmN0aW9uIG1sX2NhbnZhc19nZXRfbGluZV9kYXNoX29mZnNldChjYW52YXMpIHtcbiAgcmV0dXJuIGNhbnZhcy5jdHh0LmxpbmVEYXNoT2Zmc2V0O1xufVxuXG4vL1Byb3ZpZGVzOiBtbF9jYW52YXNfc2V0X2xpbmVfZGFzaF9vZmZzZXRcbmZ1bmN0aW9uIG1sX2NhbnZhc19zZXRfbGluZV9kYXNoX29mZnNldChjYW52YXMsIG9mZnNldCkge1xuICBjYW52YXMuY3R4dC5saW5lRGFzaE9mZnNldCA9IG9mZnNldDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IG1sX2NhbnZhc19nZXRfbGluZV9kYXNoXG5mdW5jdGlvbiBtbF9jYW52YXNfZ2V0X2xpbmVfZGFzaChjYW52YXMpIHtcbiAgdmFyIGFyciA9IGNhbnZhcy5jdHh0LmdldExpbmVEYXNoKCk7XG4gIGFyci51bnNoaWZ0KDI1NCk7IC8vIERvdWJsZSBhcnJheSB0YWdcbiAgcmV0dXJuIGFycjtcbn1cblxuLy9Qcm92aWRlczogbWxfY2FudmFzX3NldF9saW5lX2Rhc2hcbmZ1bmN0aW9uIG1sX2NhbnZhc19zZXRfbGluZV9kYXNoKGNhbnZhcywgZGFzaCkge1xuICBkYXNoLnNoaWZ0KCk7XG4gIGNhbnZhcy5jdHh0LnNldExpbmVEYXNoKGRhc2gpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogbWxfY2FudmFzX2dldF9saW5lX2pvaW5cbi8vUmVxdWlyZXM6IFZhbF9qb2luX3R5cGVcbmZ1bmN0aW9uIG1sX2NhbnZhc19nZXRfbGluZV9qb2luKGNhbnZhcykge1xuICByZXR1cm4gVmFsX2pvaW5fdHlwZShjYW52YXMubGluZUpvaW4pO1xufVxuXG4vL1Byb3ZpZGVzOiBtbF9jYW52YXNfc2V0X2xpbmVfam9pblxuLy9SZXF1aXJlczogSm9pbl90eXBlX3ZhbFxuZnVuY3Rpb24gbWxfY2FudmFzX3NldF9saW5lX2pvaW4oY2FudmFzLCBqb2luKSB7XG4gIGNhbnZhcy5jdHh0LmxpbmVKb2luID0gSm9pbl90eXBlX3ZhbChqb2luKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IG1sX2NhbnZhc19nZXRfbWl0ZXJfbGltaXRcbmZ1bmN0aW9uIG1sX2NhbnZhc19nZXRfbWl0ZXJfbGltaXQoY2FudmFzKSB7XG4gIHJldHVybiBjYW52YXMuY3R4dC5taXRlckxpbWl0O1xufVxuXG4vL1Byb3ZpZGVzOiBtbF9jYW52YXNfc2V0X21pdGVyX2xpbWl0XG5mdW5jdGlvbiBtbF9jYW52YXNfc2V0X21pdGVyX2xpbWl0KGNhbnZhcywgbGltaXQpIHtcbiAgY2FudmFzLmN0eHQubWl0ZXJMaW1pdCA9IGxpbWl0O1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogbWxfY2FudmFzX2dldF9zdHJva2VfY29sb3Jcbi8vUmVxdWlyZXM6IF9pbnRfb2ZfY29sb3JcbmZ1bmN0aW9uIG1sX2NhbnZhc19nZXRfc3Ryb2tlX2NvbG9yKGNhbnZhcykge1xuICBpZiAodHlwZW9mKGNhbnZhcy5jdHh0LnN0cm9rZVN0eWxlKSA9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIF9pbnRfb2ZfY29sb3IoY2FudmFzLmN0eHQuc3Ryb2tlU3R5bGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAwO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IG1sX2NhbnZhc19zZXRfc3Ryb2tlX2NvbG9yXG4vL1JlcXVpcmVzOiBfY29sb3Jfb2ZfaW50XG5mdW5jdGlvbiBtbF9jYW52YXNfc2V0X3N0cm9rZV9jb2xvcihjYW52YXMsIGNvbG9yKSB7XG4gIGNhbnZhcy5jdHh0LnN0cm9rZVN0eWxlID0gX2NvbG9yX29mX2ludChjb2xvcik7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBtbF9jYW52YXNfc2V0X3N0cm9rZV9ncmFkaWVudFxuZnVuY3Rpb24gbWxfY2FudmFzX3NldF9zdHJva2VfZ3JhZGllbnQoY2FudmFzLCBncmFkKSB7XG4gIGNhbnZhcy5jdHh0LnN0cm9rZVN0eWxlID0gZ3JhZDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IG1sX2NhbnZhc19zZXRfc3Ryb2tlX3BhdHRlcm5cbmZ1bmN0aW9uIG1sX2NhbnZhc19zZXRfc3Ryb2tlX3BhdHRlcm4oY2FudmFzLCBwYXR0ZXJuKSB7XG4gIGNhbnZhcy5jdHh0LnN0cm9rZVN0eWxlID0gcGF0dGVybjtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IG1sX2NhbnZhc19zZXRfc3Ryb2tlX3N0eWxlXG4vL1JlcXVpcmVzOiBWYWxfZHJhd19zdHlsZVxuZnVuY3Rpb24gbWxfY2FudmFzX3NldF9zdHJva2Vfc3R5bGUoY2FudmFzLCBzdHlsZSkge1xuICBjYW52YXMuY3R4dC5zdHJva2VTdHlsZSA9IFZhbF9kcmF3X3N0eWxlKHN0eWxlKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IG1sX2NhbnZhc19nZXRfc3Ryb2tlX3N0eWxlXG4vL1JlcXVpcmVzOiBEcmF3X3N0eWxlX3ZhbFxuZnVuY3Rpb24gbWxfY2FudmFzX2dldF9zdHJva2Vfc3R5bGUoY2FudmFzKSB7XG4gIHJldHVybiBEcmF3X3N0eWxlX3ZhbChjYW52YXMuY3R4dC5zdHJva2VTdHlsZSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBtbF9jYW52YXNfZ2V0X2ZpbGxfY29sb3Jcbi8vUmVxdWlyZXM6IF9pbnRfb2ZfY29sb3JcbmZ1bmN0aW9uIG1sX2NhbnZhc19nZXRfZmlsbF9jb2xvcihjYW52YXMpIHtcbiAgaWYgKHR5cGVvZihjYW52YXMuY3R4dC5maWxsU3R5bGUpID09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gX2ludF9vZl9jb2xvcihjYW52YXMuY3R4dC5maWxsU3R5bGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAwO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IG1sX2NhbnZhc19zZXRfZmlsbF9jb2xvclxuLy9SZXF1aXJlczogX2NvbG9yX29mX2ludFxuZnVuY3Rpb24gbWxfY2FudmFzX3NldF9maWxsX2NvbG9yKGNhbnZhcywgY29sb3IpIHtcbiAgY2FudmFzLmN0eHQuZmlsbFN0eWxlID0gX2NvbG9yX29mX2ludChjb2xvcik7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBtbF9jYW52YXNfZ2V0X2dsb2JhbF9hbHBoYVxuZnVuY3Rpb24gbWxfY2FudmFzX2dldF9nbG9iYWxfYWxwaGEoY2FudmFzKSB7XG4gIHJldHVybiBjYW52YXMuY3R4dC5nbG9iYWxBbHBoYTtcbn1cblxuLy9Qcm92aWRlczogbWxfY2FudmFzX3NldF9nbG9iYWxfYWxwaGFcbmZ1bmN0aW9uIG1sX2NhbnZhc19zZXRfZ2xvYmFsX2FscGhhKGNhbnZhcywgZ2xvYmFsX2FscGhhKSB7XG4gIGNhbnZhcy5jdHh0Lmdsb2JhbEFscGhhID0gZ2xvYmFsX2FscGhhO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogbWxfY2FudmFzX3NldF9maWxsX2dyYWRpZW50XG5mdW5jdGlvbiBtbF9jYW52YXNfc2V0X2ZpbGxfZ3JhZGllbnQoY2FudmFzLCBncmFkKSB7XG4gIGNhbnZhcy5jdHh0LmZpbGxTdHlsZSA9IGdyYWQ7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBtbF9jYW52YXNfc2V0X2ZpbGxfcGF0dGVyblxuZnVuY3Rpb24gbWxfY2FudmFzX3NldF9maWxsX3BhdHRlcm4oY2FudmFzLCBwYXR0ZXJuKSB7XG4gIGNhbnZhcy5jdHh0LmZpbGxTdHlsZSA9IHBhdHRlcm47XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBtbF9jYW52YXNfc2V0X2ZpbGxfc3R5bGVcbi8vUmVxdWlyZXM6IFZhbF9kcmF3X3N0eWxlXG5mdW5jdGlvbiBtbF9jYW52YXNfc2V0X2ZpbGxfc3R5bGUoY2FudmFzLCBzdHlsZSkge1xuICBjYW52YXMuY3R4dC5maWxsU3R5bGUgPSBWYWxfZHJhd19zdHlsZShzdHlsZSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBtbF9jYW52YXNfZ2V0X2ZpbGxfc3R5bGVcbi8vUmVxdWlyZXM6IERyYXdfc3R5bGVfdmFsXG5mdW5jdGlvbiBtbF9jYW52YXNfZ2V0X2ZpbGxfc3R5bGUoY2FudmFzKSB7XG4gIHJldHVybiBEcmF3X3N0eWxlX3ZhbChjYW52YXMuY3R4dC5maWxsU3R5bGUpO1xufVxuXG4vL1Byb3ZpZGVzOiBtbF9jYW52YXNfZ2V0X2dsb2JhbF9jb21wb3NpdGVfb3BlcmF0aW9uXG4vL1JlcXVpcmVzOiBWYWxfY29tcG9wXG5mdW5jdGlvbiBtbF9jYW52YXNfZ2V0X2dsb2JhbF9jb21wb3NpdGVfb3BlcmF0aW9uKGNhbnZhcykge1xuICByZXR1cm4gVmFsX2NvbXBvcChjYW52YXMuY3R4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24pO1xufVxuXG4vL1Byb3ZpZGVzOiBtbF9jYW52YXNfc2V0X2dsb2JhbF9jb21wb3NpdGVfb3BlcmF0aW9uXG4vL1JlcXVpcmVzOiBDb21wb3BfdmFsXG5mdW5jdGlvbiBtbF9jYW52YXNfc2V0X2dsb2JhbF9jb21wb3NpdGVfb3BlcmF0aW9uKGNhbnZhcywgb3ApIHtcbiAgY2FudmFzLmN0eHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gQ29tcG9wX3ZhbChvcCk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBtbF9jYW52YXNfZ2V0X3NoYWRvd19jb2xvclxuLy9SZXF1aXJlczogX2ludF9vZl9jb2xvclxuZnVuY3Rpb24gbWxfY2FudmFzX2dldF9zaGFkb3dfY29sb3IoY2FudmFzKSB7XG4gIHJldHVybiBfaW50X29mX2NvbG9yKGNhbnZhcy5jdHh0LnNoYWRvd0NvbG9yKTtcbn1cblxuLy9Qcm92aWRlczogbWxfY2FudmFzX3NldF9zaGFkb3dfY29sb3Jcbi8vUmVxdWlyZXM6IF9jb2xvcl9vZl9pbnRcbmZ1bmN0aW9uIG1sX2NhbnZhc19zZXRfc2hhZG93X2NvbG9yKGNhbnZhcywgY29sb3IpIHtcbiAgY2FudmFzLmN0eHQuc2hhZG93Q29sb3IgPSBfY29sb3Jfb2ZfaW50KGNvbG9yKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IG1sX2NhbnZhc19nZXRfc2hhZG93X2JsdXJcbmZ1bmN0aW9uIG1sX2NhbnZhc19nZXRfc2hhZG93X2JsdXIoY2FudmFzKSB7XG4gIHJldHVybiBjYW52YXMuY3R4dC5zaGFkb3dCbHVyO1xufVxuXG4vL1Byb3ZpZGVzOiBtbF9jYW52YXNfc2V0X3NoYWRvd19ibHVyXG5mdW5jdGlvbiBtbF9jYW52YXNfc2V0X3NoYWRvd19ibHVyKGNhbnZhcywgYmx1cikge1xuICBjYW52YXMuY3R4dC5zaGFkb3dCbHVyID0gYmx1cjtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IG1sX2NhbnZhc19nZXRfc2hhZG93X29mZnNldFxuZnVuY3Rpb24gbWxfY2FudmFzX2dldF9zaGFkb3dfb2Zmc2V0KGNhbnZhcywgb2Zmc2V0KSB7XG4gIHJldHVybiBbMCwgY2FudmFzLmN0eHQuc2hhZG93T2Zmc2V0WCwgY2FudmFzLmN0eHQuc2hhZG93T2Zmc2V0WV07XG59XG5cbi8vUHJvdmlkZXM6IG1sX2NhbnZhc19zZXRfc2hhZG93X29mZnNldFxuZnVuY3Rpb24gbWxfY2FudmFzX3NldF9zaGFkb3dfb2Zmc2V0KGNhbnZhcywgb2Zmc2V0KSB7XG4gIGNhbnZhcy5jdHh0LnNoYWRvd09mZnNldFggPSBvZmZzZXRbMV07XG4gIGNhbnZhcy5jdHh0LnNoYWRvd09mZnNldFkgPSBvZmZzZXRbMl07XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBtbF9jYW52YXNfc2V0X2ZvbnRcbi8vUmVxdWlyZXM6IFNsYW50X3ZhbCwgY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIG1sX2NhbnZhc19zZXRfZm9udChjYW52YXMsIGZhbWlseSwgc2l6ZSwgc2xhbnQsIHdlaWdodCkge1xuICBjYW52YXMuY3R4dC5mb250ID1cbiAgICBTbGFudF92YWwoc2xhbnQpICsgXCIgXCIgKyB3ZWlnaHQgKyBcIiBcIiArIHNpemUgKyBcInB0IFwiICtcbiAgICAgICAgY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcoZmFtaWx5KTtcbiAgcmV0dXJuIDA7XG59XG5cblxuXG4vKiBQYXRocyAqL1xuXG4vL1Byb3ZpZGVzOiBtbF9jYW52YXNfY2xlYXJfcGF0aFxuZnVuY3Rpb24gbWxfY2FudmFzX2NsZWFyX3BhdGgoY2FudmFzKSB7XG4gIGNhbnZhcy5jdHh0LmJlZ2luUGF0aCgpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogbWxfY2FudmFzX2Nsb3NlX3BhdGhcbmZ1bmN0aW9uIG1sX2NhbnZhc19jbG9zZV9wYXRoKGNhbnZhcykge1xuICBjYW52YXMuY3R4dC5jbG9zZVBhdGgoKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IG1sX2NhbnZhc19tb3ZlX3RvXG5mdW5jdGlvbiBtbF9jYW52YXNfbW92ZV90byhjYW52YXMsIHApIHtcbiAgY2FudmFzLmN0eHQubW92ZVRvKHBbMV0sIHBbMl0pO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogbWxfY2FudmFzX2xpbmVfdG9cbmZ1bmN0aW9uIG1sX2NhbnZhc19saW5lX3RvKGNhbnZhcywgcCkge1xuICBjYW52YXMuY3R4dC5saW5lVG8ocFsxXSwgcFsyXSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBtbF9jYW52YXNfYXJjXG5mdW5jdGlvbiBtbF9jYW52YXNfYXJjKGNhbnZhcywgcCwgcmFkaXVzLCB0aGV0YTEsIHRoZXRhMiwgY2N3KSB7XG4gIGNhbnZhcy5jdHh0LmFyYyhwWzFdLCBwWzJdLCByYWRpdXMsIHRoZXRhMSwgdGhldGEyLCBjY3cpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogbWxfY2FudmFzX2FyY190b1xuZnVuY3Rpb24gbWxfY2FudmFzX2FyY190byhjYW52YXMsIHAxLCBwMiwgcmFkaXVzKSB7XG4gIGNhbnZhcy5jdHh0LmFyY1RvKHAxWzFdLCBwMVsyXSwgcDJbMV0sIHAyWzJdLCByYWRpdXMpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogbWxfY2FudmFzX3F1YWRyYXRpY19jdXJ2ZV90b1xuZnVuY3Rpb24gbWxfY2FudmFzX3F1YWRyYXRpY19jdXJ2ZV90byhjYW52YXMsIHAxLCBwMikge1xuICBjYW52YXMuY3R4dC5xdWFkcmF0aWNDdXJ2ZVRvKHAxWzFdLCBwMVsyXSwgcDJbMV0sIHAyWzJdKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IG1sX2NhbnZhc19iZXppZXJfY3VydmVfdG9cbmZ1bmN0aW9uIG1sX2NhbnZhc19iZXppZXJfY3VydmVfdG8oY2FudmFzLCBwMSwgcDIsIHAzKSB7XG4gIGNhbnZhcy5jdHh0LmJlemllckN1cnZlVG8ocDFbMV0sIHAxWzJdLCBwMlsxXSwgcDJbMl0sIHAzWzFdLCBwM1syXSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBtbF9jYW52YXNfcmVjdFxuZnVuY3Rpb24gbWxfY2FudmFzX3JlY3QoY2FudmFzLCBwb3MsIHNpemUpIHtcbiAgY2FudmFzLmN0eHQucmVjdChwb3NbMV0sIHBvc1syXSwgc2l6ZVsxXSwgc2l6ZVsyXSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBtbF9jYW52YXNfZWxsaXBzZVxuZnVuY3Rpb24gbWxfY2FudmFzX2VsbGlwc2UoY2FudmFzLCBwLCByYWRpdXMsIHJvdGF0aW9uLCB0aGV0YTEsIHRoZXRhMiwgY2N3KSB7XG4gIGNhbnZhcy5jdHh0LmVsbGlwc2UocFsxXSwgcFsyXSwgcmFkaXVzWzFdLCByYWRpdXNbMl0sXG4gICAgICAgICAgICAgICAgICAgICAgcm90YXRpb24sIHRoZXRhMSwgdGhldGEyLCBjY3cpO1xuICByZXR1cm4gMDtcbn1cblxuXG4vKiBQYXRoIHN0cm9raW5nL2ZpbGxpbmcgKi9cblxuLy9Qcm92aWRlczogbWxfY2FudmFzX2ZpbGxcbmZ1bmN0aW9uIG1sX2NhbnZhc19maWxsKGNhbnZhcywgbm9uemVybykge1xuICBpZiAobm9uemVybykge1xuICAgIGNhbnZhcy5jdHh0LmZpbGwoXCJub256ZXJvXCIpO1xuICB9IGVsc2Uge1xuICAgIGNhbnZhcy5jdHh0LmZpbGwoKTsgLy8gXCJldmVub2RkXCJcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogbWxfY2FudmFzX2ZpbGxfcGF0aFxuZnVuY3Rpb24gbWxfY2FudmFzX2ZpbGxfcGF0aChjYW52YXMsIHBhdGgsIG5vbnplcm8pIHtcbiAgaWYgKG5vbnplcm8pIHtcbiAgICBjYW52YXMuY3R4dC5maWxsKHBhdGgsIFwibm9uemVyb1wiKTtcbiAgfSBlbHNlIHtcbiAgICBjYW52YXMuY3R4dC5maWxsKHBhdGgpOyAvLyBcImV2ZW5vZGRcIlxuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBtbF9jYW52YXNfc3Ryb2tlXG5mdW5jdGlvbiBtbF9jYW52YXNfc3Ryb2tlKGNhbnZhcykge1xuICBjYW52YXMuY3R4dC5zdHJva2UoKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IG1sX2NhbnZhc19zdHJva2VfcGF0aFxuZnVuY3Rpb24gbWxfY2FudmFzX3N0cm9rZV9wYXRoKGNhbnZhcywgcGF0aCkge1xuICBjYW52YXMuY3R4dC5zdHJva2UocGF0aCk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBtbF9jYW52YXNfY2xpcFxuZnVuY3Rpb24gbWxfY2FudmFzX2NsaXAoY2FudmFzLCBub256ZXJvKSB7XG4gIGlmIChub256ZXJvKSB7XG4gICAgY2FudmFzLmN0eHQuY2xpcChcIm5vbnplcm9cIik7XG4gIH0gZWxzZSB7XG4gICAgY2FudmFzLmN0eHQuY2xpcCgpOyAvLyBcImV2ZW5vZGRcIlxuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBtbF9jYW52YXNfY2xpcF9wYXRoXG5mdW5jdGlvbiBtbF9jYW52YXNfY2xpcF9wYXRoKGNhbnZhcywgcGF0aCwgbm9uemVybykge1xuICBpZiAobm9uemVybykge1xuICAgIGNhbnZhcy5jdHh0LmNsaXAocGF0aCwgXCJub256ZXJvXCIpO1xuICB9IGVsc2Uge1xuICAgIGNhbnZhcy5jdHh0LmNsaXAocGF0aCk7IC8vIFwiZXZlbm9kZFwiXG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cblxuXG4vKiBJbW1lZGlhdGUgZHJhd2luZyAqL1xuXG4vL1Byb3ZpZGVzOiBtbF9jYW52YXNfZmlsbF9yZWN0XG5mdW5jdGlvbiBtbF9jYW52YXNfZmlsbF9yZWN0KGNhbnZhcywgcG9zLCBzaXplKSB7XG4gIGNhbnZhcy5jdHh0LmZpbGxSZWN0KHBvc1sxXSwgcG9zWzJdLCBzaXplWzFdLCBzaXplWzJdKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IG1sX2NhbnZhc19zdHJva2VfcmVjdFxuZnVuY3Rpb24gbWxfY2FudmFzX3N0cm9rZV9yZWN0KGNhbnZhcywgcG9zLCBzaXplKSB7XG4gIGNhbnZhcy5jdHh0LnN0cm9rZVJlY3QocG9zWzFdLCBwb3NbMl0sIHNpemVbMV0sIHNpemVbMl0pO1xuICByZXR1cm4gMDtcbn1cblxuXG4vL1Byb3ZpZGVzOiBtbF9jYW52YXNfZmlsbF90ZXh0XG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gbWxfY2FudmFzX2ZpbGxfdGV4dChjYW52YXMsIHRleHQsIHBvcykge1xuICBjYW52YXMuY3R4dC5maWxsVGV4dChjYW1sX2pzc3RyaW5nX29mX3N0cmluZyh0ZXh0KSwgcG9zWzFdLCBwb3NbMl0pO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogbWxfY2FudmFzX3N0cm9rZV90ZXh0XG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gbWxfY2FudmFzX3N0cm9rZV90ZXh0KGNhbnZhcywgdGV4dCwgcG9zKSB7XG4gIGNhbnZhcy5jdHh0LnN0cm9rZVRleHQoY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcodGV4dCksIHBvc1sxXSwgcG9zWzJdKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IG1sX2NhbnZhc19ibGl0XG4vL1JlcXVpcmVzOiBfbWxfY2FudmFzX3ZhbGlkX2NhbnZhc19zaXplXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIG1sX2NhbnZhc19ibGl0KGRzdF9jYW52YXMsIGRwb3MsIHNyY19jYW52YXMsIHNwb3MsIHNpemUpIHtcbiAgdmFyIHdpZHRoID0gc2l6ZVsxXTtcbiAgdmFyIGhlaWdodCA9IHNpemVbMl07XG4gIGlmICghX21sX2NhbnZhc192YWxpZF9jYW52YXNfc2l6ZSh3aWR0aCwgaGVpZ2h0KSkge1xuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkNhbnZhcy5ibGl0OiBpbnZhbGlkIGRpbWVuc2lvbnNcIik7XG4gIH1cbiAgZHN0X2NhbnZhcy5jdHh0LmRyYXdJbWFnZShzcmNfY2FudmFzLnN1cmZhY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Bvc1sxXSwgc3Bvc1syXSwgd2lkdGgsIGhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkcG9zWzFdLCBkcG9zWzJdLCB3aWR0aCwgaGVpZ2h0KTtcbiAgcmV0dXJuIDA7XG59XG5cblxuLyogRGlyZWN0IHBpeGVsIGFjY2VzcyAqL1xuXG4vL1Byb3ZpZGVzOiBtbF9jYW52YXNfZ2V0X3BpeGVsXG5mdW5jdGlvbiBtbF9jYW52YXNfZ2V0X3BpeGVsKGNhbnZhcywgcG9zKSB7XG4gIHZhciBpbWFnZSA9IGNhbnZhcy5jdHh0LmdldEltYWdlRGF0YShwb3NbMV0sIHBvc1syXSwgMSwgMSk7XG4gIHJldHVybiAoKGltYWdlLmRhdGFbM10gPDwgMjQpID4+PiAwKSB8XG4gICAgICAgICAgKGltYWdlLmRhdGFbMF0gPDwgMTYpIHxcbiAgICAgICAgICAoaW1hZ2UuZGF0YVsxXSA8PCA4KSB8XG4gICAgICAgICAgKGltYWdlLmRhdGFbMl0gPDwgMCk7XG59XG5cbi8vUHJvdmlkZXM6IG1sX2NhbnZhc19wdXRfcGl4ZWxcbmZ1bmN0aW9uIG1sX2NhbnZhc19wdXRfcGl4ZWwoY2FudmFzLCBwb3MsIGNvbG9yKSB7XG4gIHZhciBpbWFnZSA9IGNhbnZhcy5jdHh0LmNyZWF0ZUltYWdlRGF0YSgxLCAxKTtcbiAgaW1hZ2UuZGF0YVszXSA9IChjb2xvciAmIDB4RkYwMDAwMDApID4+PiAyNDsgLy8gQVxuICBpbWFnZS5kYXRhWzBdID0gKGNvbG9yICYgMHgwMEZGMDAwMCkgPj4+IDE2OyAvLyBSXG4gIGltYWdlLmRhdGFbMV0gPSAoY29sb3IgJiAweDAwMDBGRjAwKSA+Pj4gODsgLy8gR1xuICBpbWFnZS5kYXRhWzJdID0gKGNvbG9yICYgMHgwMDAwMDBGRikgPj4+IDA7IC8vIEJcbiAgY2FudmFzLmN0eHQucHV0SW1hZ2VEYXRhKGltYWdlLCBwb3NbMV0sIHBvc1syXSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBtbF9jYW52YXNfZ2V0X2ltYWdlX2RhdGFcbi8vUmVxdWlyZXM6IF9tbF9jYW52YXNfdmFsaWRfY2FudmFzX3NpemVcbi8vUmVxdWlyZXM6IGNhbWxfYmFfY3JlYXRlX3Vuc2FmZSwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBtbF9jYW52YXNfZ2V0X2ltYWdlX2RhdGEoY2FudmFzLCBwb3MsIHNpemUpIHtcbiAgdmFyIHdpZHRoID0gc2l6ZVsxXTtcbiAgdmFyIGhlaWdodCA9IHNpemVbMl07XG4gIGlmICghX21sX2NhbnZhc192YWxpZF9jYW52YXNfc2l6ZSh3aWR0aCwgaGVpZ2h0KSkge1xuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkNhbnZhcy5nZXRJbWFnZURhdGE6IGludmFsaWQgZGltZW5zaW9uc1wiKTtcbiAgfVxuICB2YXIgaW1hZ2UgPSBjYW52YXMuY3R4dC5nZXRJbWFnZURhdGEocG9zWzFdLCBwb3NbMl0sIHdpZHRoLCBoZWlnaHQpO1xuICB2YXIgc3RhID0gbmV3IHdpbmRvdy5VaW50OEFycmF5KGltYWdlLmRhdGEuYnVmZmVyKTtcbiAgdmFyIGR0YSA9IG5ldyB3aW5kb3cuVWludDhBcnJheShzdGEubGVuZ3RoKTtcbiAgLy8gQ29udmVydCBmcm9tIFJHTkEgdG8gQkdSQVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YS5sZW5ndGg7IGkgKz0gNCkge1xuICAgIGR0YVtpKzBdID0gc3RhW2krMl07XG4gICAgZHRhW2krMV0gPSBzdGFbaSsxXTtcbiAgICBkdGFbaSsyXSA9IHN0YVtpKzBdO1xuICAgIGR0YVtpKzNdID0gc3RhW2krM107XG4gIH1cbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZSgzIC8qIFVpbnQ4QXJyYXkgKi8sIDAgLyogY19sYXlvdXQgKi8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2hlaWdodCwgd2lkdGgsIDRdLCBkdGEpO1xufVxuXG4vL1Byb3ZpZGVzOiBtbF9jYW52YXNfcHV0X2ltYWdlX2RhdGFcbi8vUmVxdWlyZXM6IF9tbF9jYW52YXNfdmFsaWRfY2FudmFzX3NpemVcbi8vUmVxdWlyZXM6IGNhbWxfYmFfdG9fdHlwZWRfYXJyYXksIGNhbWxfYmFfZGltLCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIG1sX2NhbnZhc19wdXRfaW1hZ2VfZGF0YShjYW52YXMsIGRwb3MsIGRhdGEsIHNwb3MsIHNpemUpIHtcbiAgdmFyIHdpZHRoID0gc2l6ZVsxXTtcbiAgdmFyIGhlaWdodCA9IHNpemVbMl07XG4gIGlmICghX21sX2NhbnZhc192YWxpZF9jYW52YXNfc2l6ZSh3aWR0aCwgaGVpZ2h0KSkge1xuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkNhbnZhcy5wdXRJbWFnZURhdGE6IGludmFsaWQgZGltZW5zaW9uc1wiKTtcbiAgfVxuICB2YXIgc3RhID0gbmV3IHdpbmRvdy5VaW50OEFycmF5KGNhbWxfYmFfdG9fdHlwZWRfYXJyYXkoZGF0YSkuYnVmZmVyKTtcbiAgdmFyIGR0YSA9IG5ldyB3aW5kb3cuVWludDhDbGFtcGVkQXJyYXkoc3RhLmxlbmd0aCk7XG4gIC8vIENvbnZlcnQgZnJvbSBCR1JBIHRvIFJHQkFcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGEubGVuZ3RoOyBpICs9IDQpIHtcbiAgICBkdGFbaSswXSA9IHN0YVtpKzJdO1xuICAgIGR0YVtpKzFdID0gc3RhW2krMV07XG4gICAgZHRhW2krMl0gPSBzdGFbaSswXTtcbiAgICBkdGFbaSszXSA9IHN0YVtpKzNdO1xuICB9XG4gIGlmICh3aW5kb3cuSW1hZ2VEYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgaW1hZ2UgPVxuICAgICAgY2FudmFzLmN0eHQuY3JlYXRlSW1hZ2VEYXRhKGNhbWxfYmFfZGltKGRhdGEsIDEpLCBjYW1sX2JhX2RpbShkYXRhLCAwKSk7XG4gICAgaW1hZ2UuZGF0YS5zZXQoZHRhKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgaW1hZ2UgPVxuICAgICAgbmV3IHdpbmRvdy5JbWFnZURhdGEoZHRhLCBjYW1sX2JhX2RpbShkYXRhLCAxKSwgY2FtbF9iYV9kaW0oZGF0YSwgMCkpO1xuICB9XG4gIGNhbnZhcy5jdHh0LnB1dEltYWdlRGF0YShpbWFnZSwgZHBvc1sxXSwgZHBvc1syXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwb3NbMV0sIHNwb3NbMl0sIHdpZHRoLCBoZWlnaHQpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogbWxfY2FudmFzX2ltcG9ydF9wbmdcbi8vUmVxdWlyZXM6IF9tbF9jYW52YXNfaW1hZ2Vfb2ZfcG5nX2ZpbGVcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcsIGNhbWxfbmFtZWRfdmFsdWVcbmZ1bmN0aW9uIG1sX2NhbnZhc19pbXBvcnRfcG5nKGNhbnZhcywgcG9zLCBmaWxlbmFtZSwgb25sb2FkKSB7XG4gIC8vVE9ETzogY2hlY2sgcmVhZCBmYWlsdXJlXG4gIHZhciBpbWcgPSBfbWxfY2FudmFzX2ltYWdlX29mX3BuZ19maWxlKGZpbGVuYW1lKTtcbiAgaWYgKGltZyA9PT0gbnVsbCkge1xuICAgIGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcoY2FtbF9uYW1lZF92YWx1ZShcIlJlYWRfcG5nX2ZhaWxlZFwiKSwgZmlsZW5hbWUpO1xuICAgIHJldHVybiAwO1xuICB9XG4gIGltZ1swXS50aGVuKGZ1bmN0aW9uIChfX2ltZykge1xuICAgIGNhbnZhcy5jdHh0LmRyYXdJbWFnZShpbWdbMV0sIHBvc1sxXSwgcG9zWzJdKTtcbiAgICAvLyBpbWFnZSwgc3gsIHN5LCBzV2l0ZGgsIHNIZWlnaHQsIGR4LCBkeSwgZFdpZHRoLCBkSGVpZ2h0XG4gICAgb25sb2FkKGNhbnZhcyk7XG4gICAgcmV0dXJuIDA7XG4gIH0pO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogbWxfY2FudmFzX2V4cG9ydF9wbmdcbi8vUmVxdWlyZXM6IGNhbWxfY3JlYXRlX2ZpbGUsIGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcsIGNhbWxfbmFtZWRfdmFsdWVcbmZ1bmN0aW9uIG1sX2NhbnZhc19leHBvcnRfcG5nKGNhbnZhcywgZmlsZW5hbWUpIHtcbiAgdHJ5IHtcbiAgICB2YXIgZGF0YSA9IGNhbnZhcy5zdXJmYWNlLnRvRGF0YVVSTChcImltYWdlL3BuZ1wiKS5zdWJzdHJpbmcoMjIpO1xuICAgIGNhbWxfY3JlYXRlX2ZpbGUoZmlsZW5hbWUsIHdpbmRvdy5hdG9iKGRhdGEpKTtcbiAgfSBjYXRjaCAoZXhuKSB7XG4gICAgY2FtbF9yYWlzZV93aXRoX3N0cmluZyhjYW1sX25hbWVkX3ZhbHVlKFwiV3JpdGVfcG5nX2ZhaWxlZFwiKSwgZmlsZW5hbWUpO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG5cblxuLyogRXZlbnQgKi9cblxuLy9Qcm92aWRlczogbWxfY2FudmFzX2ludF9vZl9rZXlcbi8vUmVxdWlyZXM6IEtleV9jb2RlX3ZhbFxuZnVuY3Rpb24gbWxfY2FudmFzX2ludF9vZl9rZXkoa2V5Y29kZSkge1xuICByZXR1cm4gS2V5X2NvZGVfdmFsKGtleWNvZGUpO1xufVxuXG4vL1Byb3ZpZGVzOiBtbF9jYW52YXNfa2V5X29mX2ludFxuLy9SZXF1aXJlczogVmFsX2tleV9jb2RlXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIG1sX2NhbnZhc19rZXlfb2ZfaW50KGtleWNvZGUpIHtcbiAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwia2V5X29mX2ludDogaSBtdXN0IGJlIGluIHRoZSAwLTI1NSByYW5nZVwiKTtcbiAgcmV0dXJuIFZhbF9rZXlfY29kZShrZXljb2RlKTtcbn1cblxuXG5cbi8qIEJhY2tlbmQgKi9cblxuLy9Qcm92aWRlczogbWxfY2FudmFzX2luaXRcbi8vUmVxdWlyZXM6IF9rZXlfZG93bl9oYW5kbGVyLCBfa2V5X3VwX2hhbmRsZXIsIF91cF9oYW5kbGVyLCBfbW92ZV9oYW5kbGVyLCBfcmVzaXplX2hhbmRsZXIsIF9mcmFtZV9oYW5kbGVyXG4vL1JlcXVpcmVzOiBfbWxfY2FudmFzX2luaXRpYWxpemVkLCBjYW1sX2xpc3RfdG9fanNfYXJyYXlcbmZ1bmN0aW9uIG1sX2NhbnZhc19pbml0KCkge1xuICBpZiAoX21sX2NhbnZhc19pbml0aWFsaXplZCA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIF9rZXlfZG93bl9oYW5kbGVyLCB7cGFzc2l2ZTogdHJ1ZX0pO1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5dXBcIiwgX2tleV91cF9oYW5kbGVyLCB7cGFzc2l2ZTogdHJ1ZX0pO1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCBfdXBfaGFuZGxlciwge3Bhc3NpdmU6IHRydWV9KTtcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBfbW92ZV9oYW5kbGVyLCB7cGFzc2l2ZTogdHJ1ZX0pO1xuICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKF9mcmFtZV9oYW5kbGVyKTtcbiAgX21sX2NhbnZhc19pbml0aWFsaXplZCA9IHRydWU7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBfbWxfY2FudmFzX21sUHJvY2Vzc0V2ZW50XG52YXIgX21sX2NhbnZhc19tbFByb2Nlc3NFdmVudCA9IG51bGw7XG5cbi8vUHJvdmlkZXM6IF9tbF9jYW52YXNfbWxDb250aW51YXRpb25cbnZhciBfbWxfY2FudmFzX21sQ29udGludWF0aW9uID0gbnVsbDtcblxuLy9Qcm92aWRlczogX21sX2NhbnZhc19tbEV4Y2VwdGlvblxudmFyIF9tbF9jYW52YXNfbWxFeGNlcHRpb24gPSBudWxsO1xuXG4vL1Byb3ZpZGVzOiBfbWxfY2FudmFzX3Byb2Nlc3NfZXZlbnRcbi8vUmVxdWlyZXM6IF9tbF9jYW52YXNfbWxQcm9jZXNzRXZlbnQsIF9tbF9jYW52YXNfbWxFeGNlcHRpb24sIG1sX2NhbnZhc19zdG9wXG5mdW5jdGlvbiBfbWxfY2FudmFzX3Byb2Nlc3NfZXZlbnQobWxFdmVudCkge1xuICBpZiAoX21sX2NhbnZhc19tbFByb2Nlc3NFdmVudCA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB0cnkge1xuICAgIF9tbF9jYW52YXNfbWxQcm9jZXNzRXZlbnQobWxFdmVudCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGV4bikge1xuICAgIF9tbF9jYW52YXNfbWxFeGNlcHRpb24gPSBleG47XG4gICAgbWxfY2FudmFzX3N0b3AoKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLy9Qcm92aWRlczogbWxfY2FudmFzX3J1blxuLy9SZXF1aXJlczogX21sX2NhbnZhc19lbnN1cmVfaW5pdGlhbGl6ZWQsIF9tbF9jYW52YXNfbWxQcm9jZXNzRXZlbnQsIF9tbF9jYW52YXNfbWxDb250aW51YXRpb24sIF9tbF9jYW52YXNfbWxFeGNlcHRpb24sIF9tbF9jYW52YXNfZW5zdXJlX2luaXRpYWxpemVkXG5mdW5jdGlvbiBtbF9jYW52YXNfcnVuKG1sUHJvY2Vzc0V2ZW50LCBtbENvbnRpbnVhdGlvbikge1xuICBfbWxfY2FudmFzX2Vuc3VyZV9pbml0aWFsaXplZCgpO1xuICBpZiAoX21sX2NhbnZhc19tbFByb2Nlc3NFdmVudCAhPT0gbnVsbCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIF9tbF9jYW52YXNfbWxQcm9jZXNzRXZlbnQgPSBtbFByb2Nlc3NFdmVudDtcbiAgX21sX2NhbnZhc19tbENvbnRpbnVhdGlvbiA9IG1sQ29udGludWF0aW9uO1xuICBfbWxfY2FudmFzX21sRXhjZXB0aW9uID0gbnVsbDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IG1sX2NhbnZhc19zdG9wXG4vL1JlcXVpcmVzOiBfbWxfY2FudmFzX2Vuc3VyZV9pbml0aWFsaXplZCwgX21sX2NhbnZhc19tbFByb2Nlc3NFdmVudCwgX21sX2NhbnZhc19tbENvbnRpbnVhdGlvbiwgX21sX2NhbnZhc19tbEV4Y2VwdGlvbiwgX21sX2NhbnZhc19lbnN1cmVfaW5pdGlhbGl6ZWRcbmZ1bmN0aW9uIG1sX2NhbnZhc19zdG9wKCkge1xuICBfbWxfY2FudmFzX2Vuc3VyZV9pbml0aWFsaXplZCgpO1xuICBfbWxfY2FudmFzX21sUHJvY2Vzc0V2ZW50ID0gbnVsbDtcbiAgaWYgKF9tbF9jYW52YXNfbWxFeGNlcHRpb24gIT09IG51bGwpIHtcbiAgICB2YXIgZXhuID0gX21sX2NhbnZhc19tbEV4Y2VwdGlvbjtcbiAgICBfbWxfY2FudmFzX21sQ29udGludWF0aW9uID0gbnVsbDtcbiAgICBfbWxfY2FudmFzX21sRXhjZXB0aW9uID0gbnVsbDtcbiAgICB0aHJvdyAoZXhuKTtcbiAgfSBlbHNlIGlmIChfbWxfY2FudmFzX21sQ29udGludWF0aW9uICE9PSBudWxsKSB7XG4gICAgdHJ5IHtcbiAgICAgIF9tbF9jYW52YXNfbWxDb250aW51YXRpb24oKTtcbiAgICAgIF9tbF9jYW52YXNfbWxDb250aW51YXRpb24gPSBudWxsO1xuICAgIH0gY2F0Y2ggKGV4bikge1xuICAgICAgX21sX2NhbnZhc19tbENvbnRpbnVhdGlvbiA9IG51bGw7XG4gICAgICB0aHJvdyAoZXhuKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IG1sX2NhbnZhc19nZXRfY2FudmFzXG4vL1JlcXVpcmVzOiBfbWxfY2FudmFzX2Vuc3VyZV9pbml0aWFsaXplZFxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9ub3RfZm91bmRcbmZ1bmN0aW9uIG1sX2NhbnZhc19nZXRfY2FudmFzKGlkKSB7XG4gIF9tbF9jYW52YXNfZW5zdXJlX2luaXRpYWxpemVkKCk7XG4gIHZhciBzdXJmYWNlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzXCIgKyBpZCk7XG4gIGlmIChzdXJmYWNlID09PSBudWxsKSB7XG4gICAgY2FtbF9yYWlzZV9ub3RfZm91bmQoKTtcbiAgICByZXR1cm4gMDtcbiAgfVxuICByZXR1cm4gc3VyZmFjZS5jYW52YXM7XG59XG5cbi8vUHJvdmlkZXM6IG1sX2NhbnZhc19nZXRfY3VycmVudF90aW1lc3RhbXBcbi8vUmVxdWlyZXM6IF9tbF9jYW52YXNfZW5zdXJlX2luaXRpYWxpemVkXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2Zsb2F0XG5mdW5jdGlvbiBtbF9jYW52YXNfZ2V0X2N1cnJlbnRfdGltZXN0YW1wKCkge1xuICBfbWxfY2FudmFzX2Vuc3VyZV9pbml0aWFsaXplZCgpO1xuICB2YXIgZSA9IG5ldyB3aW5kb3cuRXZlbnQoXCJkdW1teVwiKTtcbiAgcmV0dXJuIGNhbWxfaW50NjRfb2ZfZmxvYXQoZS50aW1lU3RhbXAgKiAxMDAwLjApO1xufVxuIiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogICAgQ29weXJpZ2h0IDIwMjIgT0NhbWxQcm8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogIEFsbCByaWdodHMgcmVzZXJ2ZWQuIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlICAqL1xuLyogIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgc3BlY2lhbCAgICAgICAqL1xuLyogIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAgICAgICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vL1Byb3ZpZGVzOiBrZXluYW1lX3RvX2tleWNvZGVcbi8vUmVxdWlyZXM6IEtFWVxudmFyIGtuX3RvX2tjID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0Lk1hcChbXG4gIFtcIlwiLCAgICAgICAgICAgICAgICBLRVkuVU5ERUZJTkVEXSxcbiAgW1wiVW5pZGVudGlmaWVkXCIsICAgIEtFWS5VTkRFRklORURdLFxuXG4gIFtcIkVzY2FwZVwiLCAgICAgICAgICBLRVkuRVNDQVBFXSxcbiAgW1wiRjFcIiwgICAgICAgICAgICAgIEtFWS5GMV0sXG4gIFtcIkYyXCIsICAgICAgICAgICAgICBLRVkuRjJdLFxuICBbXCJGM1wiLCAgICAgICAgICAgICAgS0VZLkYzXSxcbiAgW1wiRjRcIiwgICAgICAgICAgICAgIEtFWS5GNF0sXG4gIFtcIkY1XCIsICAgICAgICAgICAgICBLRVkuRjVdLFxuICBbXCJGNlwiLCAgICAgICAgICAgICAgS0VZLkY2XSxcbiAgW1wiRjdcIiwgICAgICAgICAgICAgIEtFWS5GN10sXG4gIFtcIkY4XCIsICAgICAgICAgICAgICBLRVkuRjhdLFxuICBbXCJGOVwiLCAgICAgICAgICAgICAgS0VZLkY5XSxcbiAgW1wiRjEwXCIsICAgICAgICAgICAgIEtFWS5GMTBdLFxuICBbXCJGMTFcIiwgICAgICAgICAgICAgS0VZLkYxMV0sXG4gIFtcIkYxMlwiLCAgICAgICAgICAgICBLRVkuRjEyXSxcblxuICBbXCJQcmludFNjcmVlblwiLCAgICAgS0VZLlBSSU5UU0NSRUVOXSxcbiAgW1wiU2Nyb2xsTG9ja1wiLCAgICAgIEtFWS5TQ1JPTExMT0NLXSxcbiAgW1wiUGF1c2VcIiwgICAgICAgICAgIEtFWS5QQVVTRV0sXG5cbiAgW1wiQmFja3F1b3RlXCIsICAgICAgIEtFWS5HUkFWRV9USUxERV0sXG4gIFtcIkRpZ2l0MVwiLCAgICAgICAgICBLRVkuXzFfRVhDTEFNQVRJT05dLFxuICBbXCJEaWdpdDJcIiwgICAgICAgICAgS0VZLl8yX0FUXSxcbiAgW1wiRGlnaXQzXCIsICAgICAgICAgIEtFWS5fM19OVU1CRVJdLFxuICBbXCJEaWdpdDRcIiwgICAgICAgICAgS0VZLl80X0RPTExBUl0sXG4gIFtcIkRpZ2l0NVwiLCAgICAgICAgICBLRVkuXzVfUEVSQ0VOVF0sXG4gIFtcIkRpZ2l0NlwiLCAgICAgICAgICBLRVkuXzZfQ0FSRVRdLFxuICBbXCJEaWdpdDdcIiwgICAgICAgICAgS0VZLl83X0FNUEVSU0FORF0sXG4gIFtcIkRpZ2l0OFwiLCAgICAgICAgICBLRVkuXzhfQVNURVJJU0tdLFxuICBbXCJEaWdpdDlcIiwgICAgICAgICAgS0VZLl85X0xQQVJFTlRIRVNJU10sXG4gIFtcIkRpZ2l0MFwiLCAgICAgICAgICBLRVkuXzBfUlBBUkVOVEhFU0lTXSxcbiAgW1wiTWludXNcIiwgICAgICAgICAgIEtFWS5NSU5VU19VTkRFUlNDT1JFXSxcbiAgW1wiRXF1YWxcIiwgICAgICAgICAgIEtFWS5FUVVBTF9QTFVTXSxcbiAgW1wiSW50bFllblwiLCAgICAgICAgIEtFWS5JTlRFUk5BVElPTkFMM10sIC8qIHwgYW5kIFllbiBrZXkgbGVmdCAqL1xuICBbXCJCYWNrc3BhY2VcIiwgICAgICAgS0VZLkJBQ0tTUEFDRV0sXG5cbiAgW1wiVGFiXCIsICAgICAgICAgICAgIEtFWS5UQUJdLFxuICBbXCJLZXlRXCIsICAgICAgICAgICAgS0VZLlFdLFxuICBbXCJLZXlXXCIsICAgICAgICAgICAgS0VZLlddLFxuICBbXCJLZXlFXCIsICAgICAgICAgICAgS0VZLkVdLFxuICBbXCJLZXlSXCIsICAgICAgICAgICAgS0VZLlJdLFxuICBbXCJLZXlUXCIsICAgICAgICAgICAgS0VZLlRdLFxuICBbXCJLZXlZXCIsICAgICAgICAgICAgS0VZLlldLFxuICBbXCJLZXlVXCIsICAgICAgICAgICAgS0VZLlVdLFxuICBbXCJLZXlJXCIsICAgICAgICAgICAgS0VZLkldLFxuICBbXCJLZXlPXCIsICAgICAgICAgICAgS0VZLk9dLFxuICBbXCJLZXlQXCIsICAgICAgICAgICAgS0VZLlBdLFxuICBbXCJCcmFja2V0TGVmdFwiLCAgICAgS0VZLkxCUkFDS0VUX0NVUkxZXSxcbiAgW1wiQnJhY2tldFJpZ2h0XCIsICAgIEtFWS5SQlJBQ0tFVF9DVVJMWV0sXG4gIFtcIkJhY2tzbGFzaFwiLCAgICAgICBLRVkuQkFDS1NMQVNIX1BJUEVdLCAvKiBvciBLRVkuTk9OVVNfTlVNQkVSX1RJTERFICovXG5cbiAgW1wiQ2Fwc0xvY2tcIiwgICAgICAgIEtFWS5DQVBTTE9DS10sXG4gIFtcIktleUFcIiwgICAgICAgICAgICBLRVkuQV0sXG4gIFtcIktleVNcIiwgICAgICAgICAgICBLRVkuU10sXG4gIFtcIktleURcIiwgICAgICAgICAgICBLRVkuRF0sXG4gIFtcIktleUZcIiwgICAgICAgICAgICBLRVkuRl0sXG4gIFtcIktleUdcIiwgICAgICAgICAgICBLRVkuR10sXG4gIFtcIktleUhcIiwgICAgICAgICAgICBLRVkuSF0sXG4gIFtcIktleUpcIiwgICAgICAgICAgICBLRVkuSl0sXG4gIFtcIktleUtcIiwgICAgICAgICAgICBLRVkuS10sXG4gIFtcIktleUxcIiwgICAgICAgICAgICBLRVkuTF0sXG4gIFtcIlNlbWljb2xvblwiLCAgICAgICBLRVkuU0VNSUNPTE9OX0NPTE9OXSxcbiAgW1wiUXVvdGVcIiwgICAgICAgICAgIEtFWS5RVU9URV9ET1VCTEVRVU9URV0sXG4vL1tcIkJhY2tzbGFzaFwiLCAgICAgICBLRVkuTk9OVVNfTlVNQkVSX1RJTERFXSwgLyogb3IgS0VZLkJBQ0tTTEFTSF9QSVBFICovXG4gIFtcIkVudGVyXCIsICAgICAgICAgICBLRVkuUkVUVVJOXSxcblxuICBbXCJTaGlmdExlZnRcIiwgICAgICAgS0VZLkxTSElGVF0sXG4gIFtcIkludGxCYWNrc2xhc2hcIiwgICBLRVkuTk9OVVNfQkFDS1NMQVNIX1BJUEVdLFxuICBbXCJLZXlaXCIsICAgICAgICAgICAgS0VZLlpdLFxuICBbXCJLZXlYXCIsICAgICAgICAgICAgS0VZLlhdLFxuICBbXCJLZXlDXCIsICAgICAgICAgICAgS0VZLkNdLFxuICBbXCJLZXlWXCIsICAgICAgICAgICAgS0VZLlZdLFxuICBbXCJLZXlCXCIsICAgICAgICAgICAgS0VZLkJdLFxuICBbXCJLZXlOXCIsICAgICAgICAgICAgS0VZLk5dLFxuICBbXCJLZXlNXCIsICAgICAgICAgICAgS0VZLk1dLFxuICBbXCJDb21tYVwiLCAgICAgICAgICAgS0VZLkNPTU1BX0xFU1NdLFxuICBbXCJQZXJpb2RcIiwgICAgICAgICAgS0VZLlBFUklPRF9HUkVBVEVSXSxcbiAgW1wiU2xhc2hcIiwgICAgICAgICAgIEtFWS5TTEFTSF9RVUVTVElPTl0sXG4gIFtcIkludGxSb1wiLCAgICAgICAgICBLRVkuSU5URVJOQVRJT05BTDFdLCAvKiBfIGFuZCBcXCBrZXkgKi9cbiAgW1wiU2hpZnRSaWdodFwiLCAgICAgIEtFWS5SU0hJRlRdLFxuXG4gIFtcIkNvbnRyb2xMZWZ0XCIsICAgICBLRVkuTENPTlRST0xdLFxuICBbXCJNZXRhTGVmdFwiLCAgICAgICAgS0VZLkxNRVRBXSxcbiAgW1wiQWx0TGVmdFwiLCAgICAgICAgIEtFWS5MQUxUXSxcbiAgW1wiTm9uQ29udmVydFwiLCAgICAgIEtFWS5JTlRFUk5BVElPTkFMNV0sIC8qIE11aGVua2FuIGtleSBLQiAqL1xuICBbXCJMYW5nMlwiLCAgICAgICAgICAgS0VZLkxBTkcyXSwgLyogSGFuamEgLyBFaXN1IChNYWMpICovXG4gIFtcIlNwYWNlXCIsICAgICAgICAgICBLRVkuU1BBQ0VCQVJdLFxuICBbXCJMYW5nMVwiLCAgICAgICAgICAgS0VZLkxBTkcxXSwgLyogSGFuZ3VsTW9kZSAvIEthbmEgKE1hYykgKi9cbiAgW1wiQ29udmVydFwiLCAgICAgICAgIEtFWS5JTlRFUk5BVElPTkFMNF0sIC8qIEhlbmthbiBrZXkgKi9cbiAgW1wiS2FuYU1vZGVcIiwgICAgICAgIEtFWS5JTlRFUk5BVElPTkFMMl0sIC8qIEthdGFrYW5hL0hpcmFnYW5hIGtleSAqL1xuICBbXCJBbHRSaWdodFwiLCAgICAgICAgS0VZLlJBTFRdLFxuICBbXCJNZXRhUmlnaHRcIiwgICAgICAgS0VZLlJNRVRBXSxcbiAgW1wiQ29udGV4dE1lbnVcIiwgICAgIEtFWS5NRU5VXSxcbiAgW1wiQ29udHJvbFJpZ2h0XCIsICAgIEtFWS5SQ09OVFJPTF0sXG5cbiAgW1wiSGVscFwiLCAgICAgICAgICAgIEtFWS5IRUxQXSwgLyogb24gb2xkIE1hYyBrZXlib2FyZHMgKi9cbiAgW1wiSW5zZXJ0XCIsICAgICAgICAgIEtFWS5JTlNFUlRdLCAvKiBub3QgcHJlc2VudCBvbiBNYWMga2V5Ym9hcmRzICovXG4gIFtcIkhvbWVcIiwgICAgICAgICAgICBLRVkuSE9NRV0sXG4gIFtcIlBhZ2VVcFwiLCAgICAgICAgICBLRVkuUEFHRVVQXSxcbiAgW1wiRGVsZXRlXCIsICAgICAgICAgIEtFWS5ERUxFVEVGT1JXQVJEXSxcbiAgW1wiRW5kXCIsICAgICAgICAgICAgIEtFWS5FTkRdLFxuICBbXCJQYWdlRG93blwiLCAgICAgICAgS0VZLlBBR0VET1dOXSxcblxuICBbXCJBcnJvd1VwXCIsICAgICAgICAgS0VZLlVQQVJST1ddLFxuICBbXCJBcnJvd0xlZnRcIiwgICAgICAgS0VZLkxFRlRBUlJPV10sXG4gIFtcIkFycm93RG93blwiLCAgICAgICBLRVkuRE9XTkFSUk9XXSxcbiAgW1wiQXJyb3dSaWdodFwiLCAgICAgIEtFWS5SSUdIVEFSUk9XXSxcblxuICBbXCJOdW1wYWRMb2NrXCIsICAgICAgS0VZLlBBRF9OVU1MT0NLX0NMRUFSXSwgLyogTnVtTG9jayBpcyBDbGVhciBvbiBNYWMgKi9cbiAgW1wiTnVtcGFkRXF1YWxcIiwgICAgIEtFWS5QQURfRVFVQUxTXSwgLyogTWFjIG9ubHkgKi9cbiAgW1wiTnVtcGFkRGl2aWRlXCIsICAgIEtFWS5QQURfRElWSURFXSxcbiAgW1wiTnVtcGFkTXVsdGlwbHlcIiwgIEtFWS5QQURfTVVMVElQTFldLFxuICBbXCJOdW1wYWRTdWJ0cmFjdFwiLCAgS0VZLlBBRF9NSU5VU10sXG4gIFtcIk51bXBhZDdcIiwgICAgICAgICBLRVkuUEFEXzdfSE9NRV0sXG4gIFtcIk51bXBhZDhcIiwgICAgICAgICBLRVkuUEFEXzhfVVBBUlJPV10sXG4gIFtcIk51bXBhZDlcIiwgICAgICAgICBLRVkuUEFEXzlfUEFHRVVQXSxcbiAgW1wiTnVtcGFkQWRkXCIsICAgICAgIEtFWS5QQURfUExVU10sXG4gIFtcIk51bXBhZDRcIiwgICAgICAgICBLRVkuUEFEXzRfTEVGVEFSUk9XXSxcbiAgW1wiTnVtcGFkNVwiLCAgICAgICAgIEtFWS5QQURfNV0sXG4gIFtcIk51bXBhZDZcIiwgICAgICAgICBLRVkuUEFEXzZfUklHSFRBUlJPV10sXG4gIFtcIk51bXBhZENvbW1hXCIsICAgICBLRVkuUEFEX0NPTU1BXSwgLyogc3BlY2lmaWMgdG8gQnJhemlsaWFuIGtleWJvYXJkcyAqL1xuICBbXCJOdW1wYWQxXCIsICAgICAgICAgS0VZLlBBRF8xX0VORF0sXG4gIFtcIk51bXBhZDJcIiwgICAgICAgICBLRVkuUEFEXzJfRE9XTkFSUk9XXSxcbiAgW1wiTnVtcGFkM1wiLCAgICAgICAgIEtFWS5QQURfM19QQUdFRE9XTl0sXG4gIFtcIk51bXBhZDBcIiwgICAgICAgICBLRVkuUEFEXzBfSU5TRVJUXSxcbiAgW1wiTnVtcGFkRGVjaW1hbFwiLCAgIEtFWS5QQURfREVDSU1BTF9ERUxFVEVdLFxuLy9bXCI/Pz8/Pz9cIiwgICAgICAgICAgS0VZLklOVEVSTkFUSU9OQUw2XSwgLyogS2FubWEgKGNvbW1hKSAqL1xuICBbXCJOdW1wYWRFbnRlclwiLCAgICAgS0VZLlBBRF9FTlRFUl0sXG5cbiAgW1wiRjEzXCIsICAgICAgICAgICAgIEtFWS5GMTNdLFxuICBbXCJGMTRcIiwgICAgICAgICAgICAgS0VZLkYxNF0sIC8vIEZGOiBhbHNvIGhhcyBrZXkgPSBMYXVuY2hBcHBsaWNhdGlvbjZcbiAgW1wiRjE1XCIsICAgICAgICAgICAgIEtFWS5GMTVdLCAvLyBGRjogYWxzbyBoYXMga2V5ID0gTGF1bmNoQXBwbGljYXRpb243XG4gIFtcIkYxNlwiLCAgICAgICAgICAgICBLRVkuRjE2XSwgLy8gRkY6IGFsc28gaGFzIGtleSA9IExhdW5jaEFwcGxpY2F0aW9uOFxuICBbXCJGMTdcIiwgICAgICAgICAgICAgS0VZLkYxN10sIC8vIEZGOiBhbHNvIGhhcyBrZXkgPSBMYXVuY2hBcHBsaWNhdGlvbjlcbiAgW1wiRjE4XCIsICAgICAgICAgICAgIEtFWS5GMThdLCAvLyBGRjogYWxzbyBoYXMga2V5ID0gTGF1bmNoQXBwbGljYXRpb24xMFxuICBbXCJGMTlcIiwgICAgICAgICAgICAgS0VZLkYxOV0sXG4gIFtcIkYyMFwiLCAgICAgICAgICAgICBLRVkuRjIwXSxcbiAgW1wiRjIxXCIsICAgICAgICAgICAgIEtFWS5GMjFdLFxuICBbXCJGMjJcIiwgICAgICAgICAgICAgS0VZLkYyMl0sXG4gIFtcIkYyM1wiLCAgICAgICAgICAgICBLRVkuRjIzXSxcbiAgW1wiRjI0XCIsICAgICAgICAgICAgIEtFWS5GMjRdLFxuXG4gIFtcIkxhbmczXCIsICAgICAgICAgICBLRVkuTEFORzNdLCAvKiBLYXRha2FuYSBrZXkgKEphcGFuZXNlKSAqL1xuICBbXCJMYW5nNFwiLCAgICAgICAgICAgS0VZLkxBTkc0XSwgLyogSGlyYWdhbmEga2V5IChKYXBhbmVzZSkgKi9cbiAgW1wiTGFuZzVcIiwgICAgICAgICAgIEtFWS5MQU5HNV0sIC8qIFplbmtha3UvSGFua2FrdSBrZXkgKEphcGFuZXNlKSAqL1xuXG4gIFtcIkthdGFrYW5hXCIsICAgICAgICBLRVkuTEFORzNdLCAvKiBLYXRha2FuYSBrZXkgKEphcGFuZXNlKSAqL1xuICBbXCJIaXJhZ2FuYVwiLCAgICAgICAgS0VZLkxBTkc0XSwgLyogSGlyYWdhbmEga2V5IChKYXBhbmVzZSkgKi9cblxuICBbXCJBdWRpb1ZvbHVtZURvd25cIiwgS0VZLlZPTFVNRURPV05dLFxuICBbXCJBdWRpb1ZvbHVtZVVwXCIsICAgS0VZLlZPTFVNRVVQXSxcbiAgW1wiQXVkaW9Wb2x1bWVNdXRlXCIsIEtFWS5NVVRFXSxcblxuLy9bXCJMYXVuY2hBcHBsaWNhdGlvbjFcIiwgP10sIC8vIGtleSBvbmx5IChDaHJvbWUpXG4vL1tcIkxhdW5jaE15Q29tcHV0ZXJcIiwgICA/XSwgLy8ga2V5IG9ubHkgKEZpcmVmb3gpXG4vL1tcIk1lZGlhUmVjb3JkXCIsICAgICAgICA/XSwgLy8gb24gRkY6IGtleSBvbmx5LCBvbiBDaHJvbWU6IGJvdGhcbi8vW1wiQ2xvc2VcIiwgICAgICAgICAgICAgID9dLCAvLyBGRiBvbmx5LCBrZXkgb25seVxuXSk7XG5cbmZ1bmN0aW9uIGtleW5hbWVfdG9fa2V5Y29kZShrZXluYW1lKSB7XG4gIHJldHVybiBrbl90b19rYy5nZXQoa2V5bmFtZSk7XG59XG4iLCIvLy8vLy8vLy8gQklHU1RSSU5HXG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfYmlnc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2J5dGVzX2FyclxuZnVuY3Rpb24gY2FtbF9oYXNoX21peF9iaWdzdHJpbmcoaCwgYnMpIHtcbiAgcmV0dXJuIGNhbWxfaGFzaF9taXhfYnl0ZXNfYXJyKGgsYnMuZGF0YSk7XG59XG5cbi8vUHJvdmlkZXM6IGJpZ3N0cmluZ190b19hcnJheV9idWZmZXIgbXV0YWJsZVxuZnVuY3Rpb24gYmlnc3RyaW5nX3RvX2FycmF5X2J1ZmZlcihicykge1xuICByZXR1cm4gYnMuZGF0YS5idWZmZXJcbn1cblxuLy9Qcm92aWRlczogYmlnc3RyaW5nX3RvX3R5cGVkX2FycmF5IG11dGFibGVcbmZ1bmN0aW9uIGJpZ3N0cmluZ190b190eXBlZF9hcnJheShicykge1xuICByZXR1cm4gYnMuZGF0YVxufVxuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdfb2ZfYXJyYXlfYnVmZmVyIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfYmFfY3JlYXRlX3Vuc2FmZVxuZnVuY3Rpb24gYmlnc3RyaW5nX29mX2FycmF5X2J1ZmZlcihhYikge1xuICB2YXIgdGEgPSBuZXcgVWludDhBcnJheShhYik7XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoMTIsIDAsIFt0YS5sZW5ndGhdLCB0YSk7XG59XG5cbi8vUHJvdmlkZXM6IGJpZ3N0cmluZ19vZl90eXBlZF9hcnJheSBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2NyZWF0ZV91bnNhZmVcbmZ1bmN0aW9uIGJpZ3N0cmluZ19vZl90eXBlZF9hcnJheShiYSkge1xuICB2YXIgdGEgPSBuZXcgVWludDhBcnJheShiYS5idWZmZXIsIGJhLmJ5dGVPZmZzZXQsIGJhLmxlbmd0aCAqIGJhLkJZVEVTX1BFUl9FTEVNRU5UKTtcbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZSgxMiwgMCwgW3RhLmxlbmd0aF0sIHRhKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iaWdzdHJpbmdfbWVtY21wXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF8xXG5mdW5jdGlvbiBjYW1sX2JpZ3N0cmluZ19tZW1jbXAoczEsIHBvczEsIHMyLCBwb3MyLCBsZW4pe1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIGEgPSBjYW1sX2JhX2dldF8xKHMxLHBvczEgKyBpKTtcbiAgICB2YXIgYiA9IGNhbWxfYmFfZ2V0XzEoczIscG9zMiArIGkpO1xuICAgIGlmIChhIDwgYikgcmV0dXJuIC0xO1xuICAgIGlmIChhID4gYikgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYmFcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19iYShiYTEsIHBvczEsIGJhMiwgcG9zMiwgbGVuKXtcbiAgaWYoMTIgIT0gYmExLmtpbmQpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19iYToga2luZCBtaXNtYXRjaFwiKTtcbiAgaWYoMTIgIT0gYmEyLmtpbmQpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19iYToga2luZCBtaXNtYXRjaFwiKTtcbiAgaWYobGVuID09IDApIHJldHVybiAwO1xuICB2YXIgb2ZzMSA9IGJhMS5vZmZzZXQocG9zMSk7XG4gIHZhciBvZnMyID0gYmEyLm9mZnNldChwb3MyKTtcbiAgaWYob2ZzMSArIGxlbiA+IGJhMS5kYXRhLmxlbmd0aCl7XG4gICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB9XG4gIGlmKG9mczIgKyBsZW4gPiBiYTIuZGF0YS5sZW5ndGgpe1xuICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgfVxuICB2YXIgc2xpY2UgPSBiYTEuZGF0YS5zdWJhcnJheShvZnMxLG9mczErbGVuKTtcbiAgYmEyLmRhdGEuc2V0KHNsaWNlLHBvczIpO1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JpZ3N0cmluZ19ibGl0X3N0cmluZ190b19iYVxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2FycmF5X2JvdW5kX2Vycm9yLCBjYW1sX3VpbnQ4X2FycmF5X29mX3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoXG5mdW5jdGlvbiBjYW1sX2JpZ3N0cmluZ19ibGl0X3N0cmluZ190b19iYShzdHIxLCBwb3MxLCBiYTIsIHBvczIsIGxlbil7XG4gIGlmKDEyICE9IGJhMi5raW5kKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNhbWxfYmlnc3RyaW5nX2JsaXRfc3RyaW5nX3RvX2JhOiBraW5kIG1pc21hdGNoXCIpO1xuICBpZihsZW4gPT0gMCkgcmV0dXJuIDA7XG4gIHZhciBvZnMyID0gYmEyLm9mZnNldChwb3MyKTtcbiAgaWYocG9zMSArIGxlbiA+IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzdHIxKSkge1xuICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgfVxuICBpZihvZnMyICsgbGVuID4gYmEyLmRhdGEubGVuZ3RoKSB7XG4gICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB9XG4gIHZhciBzbGljZSA9IGNhbWxfdWludDhfYXJyYXlfb2Zfc3RyaW5nKHN0cjEpLnNsaWNlKHBvczEscG9zMSArIGxlbik7XG4gIGJhMi5kYXRhLnNldChzbGljZSxvZnMyKTtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iaWdzdHJpbmdfYmxpdF9ieXRlc190b19iYVxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2FycmF5X2JvdW5kX2Vycm9yLCBjYW1sX3VpbnQ4X2FycmF5X29mX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX21sX2J5dGVzX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9iaWdzdHJpbmdfYmxpdF9ieXRlc190b19iYShzdHIxLCBwb3MxLCBiYTIsIHBvczIsIGxlbil7XG4gIGlmKDEyICE9IGJhMi5raW5kKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNhbWxfYmlnc3RyaW5nX2JsaXRfc3RyaW5nX3RvX2JhOiBraW5kIG1pc21hdGNoXCIpO1xuICBpZihsZW4gPT0gMCkgcmV0dXJuIDA7XG4gIHZhciBvZnMyID0gYmEyLm9mZnNldChwb3MyKTtcbiAgaWYocG9zMSArIGxlbiA+IGNhbWxfbWxfYnl0ZXNfbGVuZ3RoKHN0cjEpKSB7XG4gICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB9XG4gIGlmKG9mczIgKyBsZW4gPiBiYTIuZGF0YS5sZW5ndGgpIHtcbiAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIH1cbiAgdmFyIHNsaWNlID0gY2FtbF91aW50OF9hcnJheV9vZl9ieXRlcyhzdHIxKS5zbGljZShwb3MxLHBvczEgKyBsZW4pO1xuICBiYTIuZGF0YS5zZXQoc2xpY2Usb2ZzMik7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9ibGl0X2J5dGVzLCBjYW1sX2J5dGVzX29mX2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX21sX2J5dGVzX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19ieXRlcyhiYTEsIHBvczEsIGJ5dGVzMiwgcG9zMiwgbGVuKXtcbiAgaWYoMTIgIT0gYmExLmtpbmQpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY2FtbF9iaWdzdHJpbmdfYmxpdF9zdHJpbmdfdG9fYmE6IGtpbmQgbWlzbWF0Y2hcIik7XG4gIGlmKGxlbiA9PSAwKSByZXR1cm4gMDtcbiAgdmFyIG9mczEgPSBiYTEub2Zmc2V0KHBvczEpO1xuICBpZihvZnMxICsgbGVuID4gYmExLmRhdGEubGVuZ3RoKXtcbiAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIH1cbiAgaWYocG9zMiArIGxlbiA+IGNhbWxfbWxfYnl0ZXNfbGVuZ3RoKGJ5dGVzMikpe1xuICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgfVxuICB2YXIgc2xpY2UgPSBiYTEuZGF0YS5zbGljZShvZnMxLCBvZnMxK2xlbik7XG4gIGNhbWxfYmxpdF9ieXRlcyhjYW1sX2J5dGVzX29mX2FycmF5KHNsaWNlKSwgMCwgYnl0ZXMyLCBwb3MyLCBsZW4pO1xuICByZXR1cm4gMFxufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwIErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWQ1X2NoYW5cbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX2VuZF9vZl9maWxlLCBjYW1sX21sX2lucHV0X2Jsb2NrXG4vL1JlcXVpcmVzOiBjYW1sX01ENUluaXQsIGNhbWxfTUQ1VXBkYXRlLCBjYW1sX01ENUZpbmFsXG5mdW5jdGlvbiBjYW1sX21kNV9jaGFuKGNoYW5pZCx0b3JlYWQpe1xuICB2YXIgY3R4ID0gY2FtbF9NRDVJbml0KCk7XG4gIHZhciBidWZmZXIgPSBuZXcgVWludDhBcnJheSg0MDk2KTtcbiAgaWYodG9yZWFkIDwgMCl7XG4gICAgd2hpbGUodHJ1ZSl7XG4gICAgICB2YXIgcmVhZCA9IGNhbWxfbWxfaW5wdXRfYmxvY2soY2hhbmlkLGJ1ZmZlciwwLGJ1ZmZlci5sZW5ndGgpO1xuICAgICAgaWYocmVhZCA9PSAwKSBicmVhaztcbiAgICAgIGNhbWxfTUQ1VXBkYXRlKGN0eCxidWZmZXIuc3ViYXJyYXkoMCwgcmVhZCksIHJlYWQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB3aGlsZSh0b3JlYWQgPiAwKSB7XG4gICAgICB2YXIgcmVhZCA9IGNhbWxfbWxfaW5wdXRfYmxvY2soY2hhbmlkLGJ1ZmZlciwwLCAodG9yZWFkID4gYnVmZmVyLmxlbmd0aCA/IGJ1ZmZlci5sZW5ndGggOiB0b3JlYWQpKTtcbiAgICAgIGlmKHJlYWQgPT0gMCkgY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZSgpO1xuICAgICAgY2FtbF9NRDVVcGRhdGUoY3R4LGJ1ZmZlci5zdWJhcnJheSgwLCByZWFkKSwgcmVhZCk7XG4gICAgICB0b3JlYWQgLT0gcmVhZFxuICAgIH1cbiAgfVxuICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfYXJyYXkoY2FtbF9NRDVGaW5hbChjdHgpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tZDVfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX29mX3N0cmluZywgY2FtbF9tZDVfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfbWQ1X3N0cmluZyhzLCBvZnMsIGxlbikge1xuICByZXR1cm4gY2FtbF9tZDVfYnl0ZXMoY2FtbF9ieXRlc19vZl9zdHJpbmcocyksb2ZzLGxlbik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfTUQ1VHJhbnNmb3JtXG52YXIgY2FtbF9NRDVUcmFuc2Zvcm0gPSAoZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBhZGQgKHgsIHkpIHsgcmV0dXJuICh4ICsgeSkgfCAwOyB9XG4gIGZ1bmN0aW9uIHh4KHEsYSxiLHgscyx0KSB7XG4gICAgYSA9IGFkZChhZGQoYSwgcSksIGFkZCh4LCB0KSk7XG4gICAgcmV0dXJuIGFkZCgoYSA8PCBzKSB8IChhID4+PiAoMzIgLSBzKSksIGIpO1xuICB9XG4gIGZ1bmN0aW9uIGZmKGEsYixjLGQseCxzLHQpIHtcbiAgICByZXR1cm4geHgoKGIgJiBjKSB8ICgofmIpICYgZCksIGEsIGIsIHgsIHMsIHQpO1xuICB9XG4gIGZ1bmN0aW9uIGdnKGEsYixjLGQseCxzLHQpIHtcbiAgICByZXR1cm4geHgoKGIgJiBkKSB8IChjICYgKH5kKSksIGEsIGIsIHgsIHMsIHQpO1xuICB9XG4gIGZ1bmN0aW9uIGhoKGEsYixjLGQseCxzLHQpIHsgcmV0dXJuIHh4KGIgXiBjIF4gZCwgYSwgYiwgeCwgcywgdCk7IH1cbiAgZnVuY3Rpb24gaWkoYSxiLGMsZCx4LHMsdCkgeyByZXR1cm4geHgoYyBeIChiIHwgKH5kKSksIGEsIGIsIHgsIHMsIHQpOyB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICh3LCBidWZmZXIpIHtcbiAgICB2YXIgYSA9IHdbMF0sIGIgPSB3WzFdLCBjID0gd1syXSwgZCA9IHdbM107XG5cbiAgICBhID0gZmYoYSwgYiwgYywgZCwgYnVmZmVyWyAwXSwgNywgMHhENzZBQTQ3OCk7XG4gICAgZCA9IGZmKGQsIGEsIGIsIGMsIGJ1ZmZlclsgMV0sIDEyLCAweEU4QzdCNzU2KTtcbiAgICBjID0gZmYoYywgZCwgYSwgYiwgYnVmZmVyWyAyXSwgMTcsIDB4MjQyMDcwREIpO1xuICAgIGIgPSBmZihiLCBjLCBkLCBhLCBidWZmZXJbIDNdLCAyMiwgMHhDMUJEQ0VFRSk7XG4gICAgYSA9IGZmKGEsIGIsIGMsIGQsIGJ1ZmZlclsgNF0sIDcsIDB4RjU3QzBGQUYpO1xuICAgIGQgPSBmZihkLCBhLCBiLCBjLCBidWZmZXJbIDVdLCAxMiwgMHg0Nzg3QzYyQSk7XG4gICAgYyA9IGZmKGMsIGQsIGEsIGIsIGJ1ZmZlclsgNl0sIDE3LCAweEE4MzA0NjEzKTtcbiAgICBiID0gZmYoYiwgYywgZCwgYSwgYnVmZmVyWyA3XSwgMjIsIDB4RkQ0Njk1MDEpO1xuICAgIGEgPSBmZihhLCBiLCBjLCBkLCBidWZmZXJbIDhdLCA3LCAweDY5ODA5OEQ4KTtcbiAgICBkID0gZmYoZCwgYSwgYiwgYywgYnVmZmVyWyA5XSwgMTIsIDB4OEI0NEY3QUYpO1xuICAgIGMgPSBmZihjLCBkLCBhLCBiLCBidWZmZXJbMTBdLCAxNywgMHhGRkZGNUJCMSk7XG4gICAgYiA9IGZmKGIsIGMsIGQsIGEsIGJ1ZmZlclsxMV0sIDIyLCAweDg5NUNEN0JFKTtcbiAgICBhID0gZmYoYSwgYiwgYywgZCwgYnVmZmVyWzEyXSwgNywgMHg2QjkwMTEyMik7XG4gICAgZCA9IGZmKGQsIGEsIGIsIGMsIGJ1ZmZlclsxM10sIDEyLCAweEZEOTg3MTkzKTtcbiAgICBjID0gZmYoYywgZCwgYSwgYiwgYnVmZmVyWzE0XSwgMTcsIDB4QTY3OTQzOEUpO1xuICAgIGIgPSBmZihiLCBjLCBkLCBhLCBidWZmZXJbMTVdLCAyMiwgMHg0OUI0MDgyMSk7XG5cbiAgICBhID0gZ2coYSwgYiwgYywgZCwgYnVmZmVyWyAxXSwgNSwgMHhGNjFFMjU2Mik7XG4gICAgZCA9IGdnKGQsIGEsIGIsIGMsIGJ1ZmZlclsgNl0sIDksIDB4QzA0MEIzNDApO1xuICAgIGMgPSBnZyhjLCBkLCBhLCBiLCBidWZmZXJbMTFdLCAxNCwgMHgyNjVFNUE1MSk7XG4gICAgYiA9IGdnKGIsIGMsIGQsIGEsIGJ1ZmZlclsgMF0sIDIwLCAweEU5QjZDN0FBKTtcbiAgICBhID0gZ2coYSwgYiwgYywgZCwgYnVmZmVyWyA1XSwgNSwgMHhENjJGMTA1RCk7XG4gICAgZCA9IGdnKGQsIGEsIGIsIGMsIGJ1ZmZlclsxMF0sIDksIDB4MDI0NDE0NTMpO1xuICAgIGMgPSBnZyhjLCBkLCBhLCBiLCBidWZmZXJbMTVdLCAxNCwgMHhEOEExRTY4MSk7XG4gICAgYiA9IGdnKGIsIGMsIGQsIGEsIGJ1ZmZlclsgNF0sIDIwLCAweEU3RDNGQkM4KTtcbiAgICBhID0gZ2coYSwgYiwgYywgZCwgYnVmZmVyWyA5XSwgNSwgMHgyMUUxQ0RFNik7XG4gICAgZCA9IGdnKGQsIGEsIGIsIGMsIGJ1ZmZlclsxNF0sIDksIDB4QzMzNzA3RDYpO1xuICAgIGMgPSBnZyhjLCBkLCBhLCBiLCBidWZmZXJbIDNdLCAxNCwgMHhGNEQ1MEQ4Nyk7XG4gICAgYiA9IGdnKGIsIGMsIGQsIGEsIGJ1ZmZlclsgOF0sIDIwLCAweDQ1NUExNEVEKTtcbiAgICBhID0gZ2coYSwgYiwgYywgZCwgYnVmZmVyWzEzXSwgNSwgMHhBOUUzRTkwNSk7XG4gICAgZCA9IGdnKGQsIGEsIGIsIGMsIGJ1ZmZlclsgMl0sIDksIDB4RkNFRkEzRjgpO1xuICAgIGMgPSBnZyhjLCBkLCBhLCBiLCBidWZmZXJbIDddLCAxNCwgMHg2NzZGMDJEOSk7XG4gICAgYiA9IGdnKGIsIGMsIGQsIGEsIGJ1ZmZlclsxMl0sIDIwLCAweDhEMkE0QzhBKTtcblxuICAgIGEgPSBoaChhLCBiLCBjLCBkLCBidWZmZXJbIDVdLCA0LCAweEZGRkEzOTQyKTtcbiAgICBkID0gaGgoZCwgYSwgYiwgYywgYnVmZmVyWyA4XSwgMTEsIDB4ODc3MUY2ODEpO1xuICAgIGMgPSBoaChjLCBkLCBhLCBiLCBidWZmZXJbMTFdLCAxNiwgMHg2RDlENjEyMik7XG4gICAgYiA9IGhoKGIsIGMsIGQsIGEsIGJ1ZmZlclsxNF0sIDIzLCAweEZERTUzODBDKTtcbiAgICBhID0gaGgoYSwgYiwgYywgZCwgYnVmZmVyWyAxXSwgNCwgMHhBNEJFRUE0NCk7XG4gICAgZCA9IGhoKGQsIGEsIGIsIGMsIGJ1ZmZlclsgNF0sIDExLCAweDRCREVDRkE5KTtcbiAgICBjID0gaGgoYywgZCwgYSwgYiwgYnVmZmVyWyA3XSwgMTYsIDB4RjZCQjRCNjApO1xuICAgIGIgPSBoaChiLCBjLCBkLCBhLCBidWZmZXJbMTBdLCAyMywgMHhCRUJGQkM3MCk7XG4gICAgYSA9IGhoKGEsIGIsIGMsIGQsIGJ1ZmZlclsxM10sIDQsIDB4Mjg5QjdFQzYpO1xuICAgIGQgPSBoaChkLCBhLCBiLCBjLCBidWZmZXJbIDBdLCAxMSwgMHhFQUExMjdGQSk7XG4gICAgYyA9IGhoKGMsIGQsIGEsIGIsIGJ1ZmZlclsgM10sIDE2LCAweEQ0RUYzMDg1KTtcbiAgICBiID0gaGgoYiwgYywgZCwgYSwgYnVmZmVyWyA2XSwgMjMsIDB4MDQ4ODFEMDUpO1xuICAgIGEgPSBoaChhLCBiLCBjLCBkLCBidWZmZXJbIDldLCA0LCAweEQ5RDREMDM5KTtcbiAgICBkID0gaGgoZCwgYSwgYiwgYywgYnVmZmVyWzEyXSwgMTEsIDB4RTZEQjk5RTUpO1xuICAgIGMgPSBoaChjLCBkLCBhLCBiLCBidWZmZXJbMTVdLCAxNiwgMHgxRkEyN0NGOCk7XG4gICAgYiA9IGhoKGIsIGMsIGQsIGEsIGJ1ZmZlclsgMl0sIDIzLCAweEM0QUM1NjY1KTtcblxuICAgIGEgPSBpaShhLCBiLCBjLCBkLCBidWZmZXJbIDBdLCA2LCAweEY0MjkyMjQ0KTtcbiAgICBkID0gaWkoZCwgYSwgYiwgYywgYnVmZmVyWyA3XSwgMTAsIDB4NDMyQUZGOTcpO1xuICAgIGMgPSBpaShjLCBkLCBhLCBiLCBidWZmZXJbMTRdLCAxNSwgMHhBQjk0MjNBNyk7XG4gICAgYiA9IGlpKGIsIGMsIGQsIGEsIGJ1ZmZlclsgNV0sIDIxLCAweEZDOTNBMDM5KTtcbiAgICBhID0gaWkoYSwgYiwgYywgZCwgYnVmZmVyWzEyXSwgNiwgMHg2NTVCNTlDMyk7XG4gICAgZCA9IGlpKGQsIGEsIGIsIGMsIGJ1ZmZlclsgM10sIDEwLCAweDhGMENDQzkyKTtcbiAgICBjID0gaWkoYywgZCwgYSwgYiwgYnVmZmVyWzEwXSwgMTUsIDB4RkZFRkY0N0QpO1xuICAgIGIgPSBpaShiLCBjLCBkLCBhLCBidWZmZXJbIDFdLCAyMSwgMHg4NTg0NUREMSk7XG4gICAgYSA9IGlpKGEsIGIsIGMsIGQsIGJ1ZmZlclsgOF0sIDYsIDB4NkZBODdFNEYpO1xuICAgIGQgPSBpaShkLCBhLCBiLCBjLCBidWZmZXJbMTVdLCAxMCwgMHhGRTJDRTZFMCk7XG4gICAgYyA9IGlpKGMsIGQsIGEsIGIsIGJ1ZmZlclsgNl0sIDE1LCAweEEzMDE0MzE0KTtcbiAgICBiID0gaWkoYiwgYywgZCwgYSwgYnVmZmVyWzEzXSwgMjEsIDB4NEUwODExQTEpO1xuICAgIGEgPSBpaShhLCBiLCBjLCBkLCBidWZmZXJbIDRdLCA2LCAweEY3NTM3RTgyKTtcbiAgICBkID0gaWkoZCwgYSwgYiwgYywgYnVmZmVyWzExXSwgMTAsIDB4QkQzQUYyMzUpO1xuICAgIGMgPSBpaShjLCBkLCBhLCBiLCBidWZmZXJbIDJdLCAxNSwgMHgyQUQ3RDJCQik7XG4gICAgYiA9IGlpKGIsIGMsIGQsIGEsIGJ1ZmZlclsgOV0sIDIxLCAweEVCODZEMzkxKTtcblxuICAgIHdbMF0gPSBhZGQoYSwgd1swXSk7XG4gICAgd1sxXSA9IGFkZChiLCB3WzFdKTtcbiAgICB3WzJdID0gYWRkKGMsIHdbMl0pO1xuICAgIHdbM10gPSBhZGQoZCwgd1szXSk7XG4gIH19KSgpXG5cbi8vUHJvdmlkZXM6IGNhbWxfTUQ1SW5pdFxuZnVuY3Rpb24gY2FtbF9NRDVJbml0KCkge1xuICB2YXIgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKDY0KTtcbiAgdmFyIGIzMiA9IG5ldyBVaW50MzJBcnJheShidWZmZXIpO1xuICB2YXIgYjggPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICByZXR1cm4ge2xlbjowLFxuICAgICAgICAgIHc6bmV3IFVpbnQzMkFycmF5KFsweDY3NDUyMzAxLCAweEVGQ0RBQjg5LCAweDk4QkFEQ0ZFLCAweDEwMzI1NDc2XSksXG4gICAgICAgICAgYjMyOmIzMixcbiAgICAgICAgICBiODpiOH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9NRDVVcGRhdGVcbi8vUmVxdWlyZXM6IGNhbWxfTUQ1VHJhbnNmb3JtXG5mdW5jdGlvbiBjYW1sX01ENVVwZGF0ZShjdHgsIGlucHV0LCBpbnB1dF9sZW4pe1xuICB2YXIgaW5fYnVmID0gY3R4LmxlbiAmIDB4M2Y7XG4gIHZhciBpbnB1dF9wb3MgPSAwO1xuICBjdHgubGVuICs9IGlucHV0X2xlbjtcbiAgaWYoaW5fYnVmKXtcbiAgICB2YXIgbWlzc2luZyA9IDY0IC0gaW5fYnVmO1xuICAgIGlmKGlucHV0X2xlbiA8IG1pc3NpbmcpIHtcbiAgICAgIGN0eC5iOC5zZXQoaW5wdXQuc3ViYXJyYXkoMCxpbnB1dF9sZW4pLGluX2J1Zik7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgY3R4LmI4LnNldChpbnB1dC5zdWJhcnJheSgwLG1pc3NpbmcpLGluX2J1Zik7XG4gICAgY2FtbF9NRDVUcmFuc2Zvcm0oY3R4LncsIGN0eC5iMzIpO1xuICAgIGlucHV0X2xlbiAtPSBtaXNzaW5nO1xuICAgIGlucHV0X3BvcyArPSBtaXNzaW5nO1xuICB9XG4gIHdoaWxlKGlucHV0X2xlbiA+PSA2NCl7XG4gICAgY3R4LmI4LnNldChpbnB1dC5zdWJhcnJheShpbnB1dF9wb3MsaW5wdXRfcG9zICsgNjQpLCAwKTtcbiAgICBjYW1sX01ENVRyYW5zZm9ybShjdHgudywgY3R4LmIzMik7XG4gICAgaW5wdXRfbGVuIC09IDY0O1xuICAgIGlucHV0X3BvcyArPSA2NDtcbiAgfVxuICBpZihpbnB1dF9sZW4pXG4gICAgY3R4LmI4LnNldChpbnB1dC5zdWJhcnJheShpbnB1dF9wb3MsaW5wdXRfcG9zICsgaW5wdXRfbGVuKSwgMCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfTUQ1RmluYWxcbi8vUmVxdWlyZXM6IGNhbWxfTUQ1VHJhbnNmb3JtXG5mdW5jdGlvbiBjYW1sX01ENUZpbmFsKGN0eCl7XG4gIHZhciBpbl9idWYgPSBjdHgubGVuICYgMHgzZjtcbiAgY3R4LmI4W2luX2J1Zl0gPSAweDgwO1xuICBpbl9idWYgKys7XG4gIGlmKGluX2J1ZiA+IDU2KSB7XG4gICAgZm9yKHZhciBqID0gaW5fYnVmOyBqIDwgNjQ7IGorKyl7XG4gICAgICBjdHguYjhbal0gPSAwO1xuICAgIH1cbiAgICBjYW1sX01ENVRyYW5zZm9ybShjdHgudywgY3R4LmIzMik7XG4gICAgZm9yKHZhciBqID0gMDsgaiA8IDU2OyBqKyspe1xuICAgICAgY3R4LmI4W2pdID0gMDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yKHZhciBqID0gaW5fYnVmOyBqIDwgNTY7IGorKyl7XG4gICAgICBjdHguYjhbal0gPSAwO1xuICAgIH1cbiAgfVxuICBjdHguYjMyWzE0XSA9IGN0eC5sZW4gPDwgMztcbiAgY3R4LmIzMlsxNV0gPSAoY3R4LmxlbiA+PiAyOSkgJiAweDFGRkZGRkZGO1xuICBjYW1sX01ENVRyYW5zZm9ybShjdHgudywgY3R4LmIzMik7XG4gIHZhciB0ID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKylcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IDQ7IGorKylcbiAgICAgIHRbaSAqIDQgKyBqXSA9IChjdHgud1tpXSA+PiAoOCAqIGopKSAmIDB4RkY7XG4gIHJldHVybiB0O1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWQ1X2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX3VpbnQ4X2FycmF5X29mX2J5dGVzLCBjYW1sX3N0cmluZ19vZl9hcnJheVxuLy9SZXF1aXJlczogY2FtbF9NRDVJbml0LCBjYW1sX01ENVVwZGF0ZSwgY2FtbF9NRDVGaW5hbFxuZnVuY3Rpb24gY2FtbF9tZDVfYnl0ZXMocywgb2ZzLCBsZW4pIHtcbiAgdmFyIGN0eCA9IGNhbWxfTUQ1SW5pdCgpO1xuICB2YXIgYSA9IGNhbWxfdWludDhfYXJyYXlfb2ZfYnl0ZXMocyk7XG4gIGNhbWxfTUQ1VXBkYXRlKGN0eCxhLnN1YmFycmF5KG9mcywgb2ZzICsgbGVuKSwgbGVuKTtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2FycmF5KGNhbWxfTUQ1RmluYWwoY3R4KSk7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczoganNvb19mbG9vcl9sb2cyXG52YXIgbG9nMl9vayA9IE1hdGgubG9nMiAmJiBNYXRoLmxvZzIoMS4xMjM1NTgyMDkyODg5NDc0RSszMDcpID09IDEwMjBcbmZ1bmN0aW9uIGpzb29fZmxvb3JfbG9nMih4KSB7XG4gIGlmKGxvZzJfb2spIHJldHVybiBNYXRoLmZsb29yKE1hdGgubG9nMih4KSlcbiAgdmFyIGkgPSAwO1xuICBpZiAoeCA9PSAwKSByZXR1cm4gLUluZmluaXR5O1xuICBpZih4Pj0xKSB7d2hpbGUgKHg+PTIpIHt4Lz0yOyBpKyt9IH1cbiAgZWxzZSB7d2hpbGUgKHggPCAxKSB7eCo9MjsgaS0tfSB9O1xuICByZXR1cm4gaTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0IGNvbnN0XG4vL1JlcXVpcmVzOiBqc29vX2Zsb29yX2xvZzIsIGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpXG5mdW5jdGlvbiBjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQgKHgpIHtcbiAgaWYgKCFpc0Zpbml0ZSh4KSkge1xuICAgIGlmIChpc05hTih4KSlcbiAgICAgIHJldHVybiBjYW1sX2ludDY0X2NyZWF0ZV9sb19taV9oaSgxLCAwLCAweDdmZjApO1xuICAgIGlmICh4ID4gMClcbiAgICAgIHJldHVybiBjYW1sX2ludDY0X2NyZWF0ZV9sb19taV9oaSgwLCAwLCAweDdmZjApXG4gICAgZWxzZVxuICAgICAgcmV0dXJuIGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpKDAsIDAsIDB4ZmZmMClcbiAgfVxuICB2YXIgc2lnbiA9ICh4PT0wICYmIDEveCA9PSAtSW5maW5pdHkpPzB4ODAwMDooeD49MCk/MDoweDgwMDA7XG4gIGlmIChzaWduKSB4ID0gLXg7XG4gIC8vIEludDY0LmJpdHNfb2ZfZmxvYXQgMS4xMjM1NTgyMDkyODg5NDc0RSszMDcgPSAweDdmYjAwMDAwMDAwMDAwMDBMXG4gIC8vIHVzaW5nIE1hdGguTE9HMkUqTWF0aC5sb2coeCkgaW4gcGxhY2Ugb2YgTWF0aC5sb2cyIHJlc3VsdCBpbiBwcmVjaXNpb24gbG9zdFxuICB2YXIgZXhwID0ganNvb19mbG9vcl9sb2cyKHgpICsgMTAyMztcbiAgaWYgKGV4cCA8PSAwKSB7XG4gICAgZXhwID0gMDtcbiAgICB4IC89IE1hdGgucG93KDIsLTEwMjYpO1xuICB9IGVsc2Uge1xuICAgIHggLz0gTWF0aC5wb3coMixleHAtMTAyNyk7XG4gICAgaWYgKHggPCAxNikge1xuICAgICAgeCAqPSAyOyBleHAgLT0xOyB9XG4gICAgaWYgKGV4cCA9PSAwKSB7XG4gICAgICB4IC89IDI7IH1cbiAgfVxuICB2YXIgayA9IE1hdGgucG93KDIsMjQpO1xuICB2YXIgcjMgPSB4fDA7XG4gIHggPSAoeCAtIHIzKSAqIGs7XG4gIHZhciByMiA9IHh8MDtcbiAgeCA9ICh4IC0gcjIpICogaztcbiAgdmFyIHIxID0geHwwO1xuICByMyA9IChyMyAmMHhmKSB8IHNpZ24gfCBleHAgPDwgNDtcbiAgcmV0dXJuIGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpKHIxLCByMiwgcjMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXQgY29uc3Rcbi8vUmVxdWlyZXM6IGpzb29fZmxvb3JfbG9nMlxuZnVuY3Rpb24gY2FtbF9pbnQzMl9iaXRzX29mX2Zsb2F0ICh4KSB7XG4gIHZhciBmbG9hdDMyYSA9IG5ldyBGbG9hdDMyQXJyYXkoMSk7XG4gIGZsb2F0MzJhWzBdID0geDtcbiAgdmFyIGludDMyYSA9IG5ldyBJbnQzMkFycmF5KGZsb2F0MzJhLmJ1ZmZlcik7XG4gIHJldHVybiBpbnQzMmFbMF0gfCAwO1xufVxuXG4vL0ZQIGxpdGVyYWxzIGNhbiBiZSB3cml0dGVuIHVzaW5nIHRoZSBoZXhhZGVjaW1hbFxuLy9ub3RhdGlvbiAweDxtYW50aXNzYSBpbiBoZXg+cDxleHBvbmVudD4gZnJvbSBJU08gQzk5LlxuLy9odHRwczovL2dpdGh1Yi5jb20vZGFua29nYWkvanMtaGV4ZmxvYXQvYmxvYi9tYXN0ZXIvaGV4ZmxvYXQuanNcbi8vUHJvdmlkZXM6IGNhbWxfaGV4c3RyaW5nX29mX2Zsb2F0IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZywgY2FtbF9zdHJfcmVwZWF0XG5mdW5jdGlvbiBjYW1sX2hleHN0cmluZ19vZl9mbG9hdCAoeCwgcHJlYywgc3R5bGUpIHtcbiAgaWYgKCFpc0Zpbml0ZSh4KSkge1xuICAgIGlmIChpc05hTih4KSkgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKFwibmFuXCIpO1xuICAgIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyAoKHggPiAwKT9cImluZmluaXR5XCI6XCItaW5maW5pdHlcIik7XG4gIH1cbiAgdmFyIHNpZ24gPSAoeD09MCAmJiAxL3ggPT0gLUluZmluaXR5KT8xOih4Pj0wKT8wOjE7XG4gIGlmKHNpZ24pIHggPSAteDtcbiAgdmFyIGV4cCA9IDA7XG4gIGlmICh4ID09IDApIHsgfVxuICBlbHNlIGlmICh4IDwgMSkge1xuICAgIHdoaWxlICh4IDwgMSAmJiBleHAgPiAtMTAyMikgIHsgeCAqPSAyOyBleHAtLSB9XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKHggPj0gMikgeyB4IC89IDI7IGV4cCsrIH1cbiAgfVxuICB2YXIgZXhwX3NpZ24gPSBleHAgPCAwID8gJycgOiAnKyc7XG4gIHZhciBzaWduX3N0ciA9ICcnO1xuICBpZiAoc2lnbikgc2lnbl9zdHIgPSAnLSdcbiAgZWxzZSB7XG4gICAgc3dpdGNoKHN0eWxlKXtcbiAgICBjYXNlIDQzIC8qICcrJyAqLzogc2lnbl9zdHIgPSAnKyc7IGJyZWFrO1xuICAgIGNhc2UgMzIgLyogJyAnICovOiBzaWduX3N0ciA9ICcgJzsgYnJlYWs7XG4gICAgZGVmYXVsdDogYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmIChwcmVjID49IDAgJiYgcHJlYyA8IDEzKSB7XG4gICAgLyogSWYgYSBwcmVjaXNpb24gaXMgZ2l2ZW4sIGFuZCBpcyBzbWFsbCwgcm91bmQgbWFudGlzc2EgYWNjb3JkaW5nbHkgKi9cbiAgICB2YXIgY3N0ID0gTWF0aC5wb3coMixwcmVjICogNCk7XG4gICAgeCA9IE1hdGgucm91bmQoeCAqIGNzdCkgLyBjc3Q7XG4gIH1cbiAgdmFyIHhfc3RyID0geC50b1N0cmluZygxNik7XG4gIGlmKHByZWMgPj0gMCl7XG4gICAgdmFyIGlkeCA9IHhfc3RyLmluZGV4T2YoJy4nKTtcbiAgICBpZihpZHg8MCkge1xuICAgICAgeF9zdHIgKz0gJy4nICsgY2FtbF9zdHJfcmVwZWF0KHByZWMsICcwJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIHNpemUgPSBpZHgrMStwcmVjO1xuICAgICAgaWYoeF9zdHIubGVuZ3RoIDwgc2l6ZSlcbiAgICAgICAgeF9zdHIgKz0gY2FtbF9zdHJfcmVwZWF0KHNpemUgLSB4X3N0ci5sZW5ndGgsICcwJyk7XG4gICAgICBlbHNlXG4gICAgICAgIHhfc3RyID0geF9zdHIuc3Vic3RyKDAsc2l6ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyAoc2lnbl9zdHIgKyAnMHgnICsgeF9zdHIgKyAncCcgKyBleHBfc2lnbiArIGV4cC50b1N0cmluZygxMCkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cyAoeCkge1xuICB2YXIgbG8gPSB4LmxvO1xuICB2YXIgbWkgPSB4Lm1pO1xuICB2YXIgaGkgPSB4LmhpO1xuICB2YXIgZXhwID0gKGhpICYgMHg3ZmZmKSA+PiA0O1xuICBpZiAoZXhwID09IDIwNDcpIHtcbiAgICBpZiAoKGxvfG1pfChoaSYweGYpKSA9PSAwKVxuICAgICAgcmV0dXJuIChoaSAmIDB4ODAwMCk/KC1JbmZpbml0eSk6SW5maW5pdHk7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIE5hTjtcbiAgfVxuICB2YXIgayA9IE1hdGgucG93KDIsLTI0KTtcbiAgdmFyIHJlcyA9IChsbyprK21pKSprKyhoaSYweGYpO1xuICBpZiAoZXhwID4gMCkge1xuICAgIHJlcyArPSAxNjtcbiAgICByZXMgKj0gTWF0aC5wb3coMixleHAtMTAyNyk7XG4gIH0gZWxzZVxuICAgIHJlcyAqPSBNYXRoLnBvdygyLC0xMDI2KTtcbiAgaWYgKGhpICYgMHg4MDAwKSByZXMgPSAtIHJlcztcbiAgcmV0dXJuIHJlcztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9uZXh0YWZ0ZXJfZmxvYXQgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cywgY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0LCBjYW1sX2ludDY0X2FkZCwgY2FtbF9pbnQ2NF9zdWIsY2FtbF9pbnQ2NF9vZl9pbnQzMlxuZnVuY3Rpb24gY2FtbF9uZXh0YWZ0ZXJfZmxvYXQgKHgseSkge1xuICBpZihpc05hTih4KSB8fCBpc05hTih5KSkgcmV0dXJuIE5hTjtcbiAgaWYoeD09eSkgcmV0dXJuIHk7XG4gIGlmKHg9PTApe1xuICAgIGlmKHkgPCAwKVxuICAgICAgcmV0dXJuIC1NYXRoLnBvdygyLCAtMTA3NClcbiAgICBlbHNlXG4gICAgICByZXR1cm4gTWF0aC5wb3coMiwgLTEwNzQpXG4gIH1cbiAgdmFyIGJpdHMgPSBjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQoeCk7XG4gIHZhciBvbmUgPSBjYW1sX2ludDY0X29mX2ludDMyKDEpO1xuICBpZiAoKHg8eSkgPT0gKHg+MCkpXG4gICAgYml0cyA9IGNhbWxfaW50NjRfYWRkKGJpdHMsIG9uZSlcbiAgZWxzZVxuICAgIGJpdHMgPSBjYW1sX2ludDY0X3N1YihiaXRzLCBvbmUpXG4gIHJldHVybiBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMoYml0cyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdHJ1bmNfZmxvYXRcbmZ1bmN0aW9uIGNhbWxfdHJ1bmNfZmxvYXQoeCl7XG4gIHJldHVybiBNYXRoLnRydW5jKHgpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDMyX2Zsb2F0X29mX2JpdHMgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50MzJfZmxvYXRfb2ZfYml0cyAoeCkge1xuICB2YXIgaW50MzJhID0gbmV3IEludDMyQXJyYXkoMSk7XG4gIGludDMyYVswXSA9IHg7XG4gIHZhciBmbG9hdDMyYSA9IG5ldyBGbG9hdDMyQXJyYXkoaW50MzJhLmJ1ZmZlcik7XG4gIHJldHVybiBmbG9hdDMyYVswXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jbGFzc2lmeV9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9jbGFzc2lmeV9mbG9hdCAoeCkge1xuICBpZiAoaXNGaW5pdGUgKHgpKSB7XG4gICAgaWYgKE1hdGguYWJzKHgpID49IDIuMjI1MDczODU4NTA3MjAxNGUtMzA4KSByZXR1cm4gMDtcbiAgICBpZiAoeCAhPSAwKSByZXR1cm4gMTtcbiAgICByZXR1cm4gMjtcbiAgfVxuICByZXR1cm4gaXNOYU4oeCk/NDozO1xufVxuLy9Qcm92aWRlczogY2FtbF9tb2RmX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX21vZGZfZmxvYXQgKHgpIHtcbiAgaWYgKGlzRmluaXRlICh4KSkge1xuICAgIHZhciBuZWcgPSAoMS94KSA8IDA7XG4gICAgeCA9IE1hdGguYWJzKHgpO1xuICAgIHZhciBpID0gTWF0aC5mbG9vciAoeCk7XG4gICAgdmFyIGYgPSB4IC0gaTtcbiAgICBpZiAobmVnKSB7IGkgPSAtaTsgZiA9IC1mOyB9XG4gICAgcmV0dXJuIFswLCBmLCBpXTtcbiAgfVxuICBpZiAoaXNOYU4gKHgpKSByZXR1cm4gWzAsIE5hTiwgTmFOXTtcbiAgcmV0dXJuIFswLCAxL3gsIHhdO1xufVxuLy9Qcm92aWRlczogY2FtbF9sZGV4cF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9sZGV4cF9mbG9hdCAoeCxleHApIHtcbiAgZXhwIHw9IDA7XG4gIGlmIChleHAgPiAxMDIzKSB7XG4gICAgZXhwIC09IDEwMjM7XG4gICAgeCAqPSBNYXRoLnBvdygyLCAxMDIzKTtcbiAgICBpZiAoZXhwID4gMTAyMykgeyAgLy8gaW4gY2FzZSB4IGlzIHN1Ym5vcm1hbFxuICAgICAgZXhwIC09IDEwMjM7XG4gICAgICB4ICo9IE1hdGgucG93KDIsIDEwMjMpO1xuICAgIH1cbiAgfVxuICBpZiAoZXhwIDwgLTEwMjMpIHtcbiAgICBleHAgKz0gMTAyMztcbiAgICB4ICo9IE1hdGgucG93KDIsIC0xMDIzKTtcbiAgfVxuICB4ICo9IE1hdGgucG93KDIsIGV4cCk7XG4gIHJldHVybiB4O1xufVxuLy9Qcm92aWRlczogY2FtbF9mcmV4cF9mbG9hdCBjb25zdFxuLy9SZXF1aXJlczoganNvb19mbG9vcl9sb2cyXG5mdW5jdGlvbiBjYW1sX2ZyZXhwX2Zsb2F0ICh4KSB7XG4gIGlmICgoeCA9PSAwKSB8fCAhaXNGaW5pdGUoeCkpIHJldHVybiBbMCwgeCwgMF07XG4gIHZhciBuZWcgPSB4IDwgMDtcbiAgaWYgKG5lZykgeCA9IC0geDtcbiAgdmFyIGV4cCA9IE1hdGgubWF4KC0xMDIzLCBqc29vX2Zsb29yX2xvZzIoeCkgKyAxKTtcbiAgeCAqPSBNYXRoLnBvdygyLC1leHApO1xuICB3aGlsZSAoeCA8IDAuNSkge1xuICAgIHggKj0gMjtcbiAgICBleHAtLTtcbiAgfVxuICB3aGlsZSAoeCA+PSAxKSB7XG4gICAgeCAqPSAwLjU7XG4gICAgZXhwKys7XG4gIH1cbiAgaWYgKG5lZykgeCA9IC0geDtcbiAgcmV0dXJuIFswLCB4LCBleHBdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2Zsb2F0X2NvbXBhcmUgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZmxvYXRfY29tcGFyZSAoeCwgeSkge1xuICBpZiAoeCA9PT0geSkgcmV0dXJuIDA7XG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xO1xuICBpZiAoeCA+IHkpIHJldHVybiAxO1xuICBpZiAoeCA9PT0geCkgcmV0dXJuIDE7XG4gIGlmICh5ID09PSB5KSByZXR1cm4gLTE7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvcHlzaWduX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2NvcHlzaWduX2Zsb2F0ICh4LCB5KSB7XG4gIGlmICh5ID09IDApIHkgPSAxIC8geTtcbiAgeCA9IE1hdGguYWJzKHgpO1xuICByZXR1cm4gKHkgPCAwKT8oLXgpOng7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc2lnbmJpdF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9zaWduYml0X2Zsb2F0KHgpIHtcbiAgaWYgKHggPT0gMCkgeCA9IDEgLyB4O1xuICByZXR1cm4gKHggPCAwKT8xOjA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXhwbTFfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZXhwbTFfZmxvYXQgKHgpIHsgcmV0dXJuIE1hdGguZXhwbTEoeCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfZXhwMl9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9leHAyX2Zsb2F0KHgpIHsgcmV0dXJuIE1hdGgucG93KDIsIHgpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2xvZzFwX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2xvZzFwX2Zsb2F0KHgpIHsgcmV0dXJuIE1hdGgubG9nMXAoeCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfbG9nMl9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9sb2cyX2Zsb2F0KHgpIHsgcmV0dXJuIE1hdGgubG9nMih4KTsgfVxuLy9Qcm92aWRlczogY2FtbF9oeXBvdF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9oeXBvdF9mbG9hdCAoeCwgeSkgeyByZXR1cm4gTWF0aC5oeXBvdCh4LCB5KTsgfVxuLy9Qcm92aWRlczogY2FtbF9sb2cxMF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9sb2cxMF9mbG9hdCAoeCkgeyByZXR1cm4gTWF0aC5sb2cxMCh4KTsgfVxuLy9Qcm92aWRlczogY2FtbF9jb3NoX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2Nvc2hfZmxvYXQgKHgpIHsgcmV0dXJuIE1hdGguY29zaCh4KTsgfVxuLy9Qcm92aWRlczogY2FtbF9hY29zaF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9hY29zaF9mbG9hdCAoeCkgeyByZXR1cm4gTWF0aC5hY29zaCh4KTsgfVxuLy9Qcm92aWRlczogY2FtbF9zaW5oX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX3NpbmhfZmxvYXQgKHgpIHsgcmV0dXJuIE1hdGguc2luaCh4KTsgfVxuLy9Qcm92aWRlczogY2FtbF9hc2luaF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9hc2luaF9mbG9hdCAoeCkgeyByZXR1cm4gTWF0aC5hc2luaCh4KTsgfVxuLy9Qcm92aWRlczogY2FtbF90YW5oX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX3RhbmhfZmxvYXQgKHgpIHsgcmV0dXJuIE1hdGgudGFuaCh4KTsgfVxuLy9Qcm92aWRlczogY2FtbF9hdGFuaF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9hdGFuaF9mbG9hdCAoeCkgeyByZXR1cm4gTWF0aC5hdGFuaCh4KTsgfVxuLy9Qcm92aWRlczogY2FtbF9yb3VuZF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9yb3VuZF9mbG9hdCAoeCkge1xuICBpZiAoeCA+PSAwKSB7XG4gICAgdmFyIHkgPSBNYXRoLmZsb29yKHgpO1xuICAgIHJldHVybiAoeCAtIHkgPj0gMC41KT8oeSArIDEpOnlcbiAgfSBlbHNlIHtcbiAgICB2YXIgeSA9IE1hdGguY2VpbCh4KTtcbiAgICByZXR1cm4gKHkgLSB4ID49IDAuNSk/KHkgLSAxKTp5XG4gIH1cbn1cbi8vUHJvdmlkZXM6IGNhbWxfY2JydF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9jYnJ0X2Zsb2F0ICh4KSB7IHJldHVybiBNYXRoLmNicnQoeCk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9lcmZfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZXJmX2Zsb2F0KHgpIHtcbiAgdmFyIGExID0gMC4yNTQ4Mjk1OTI7XG4gIHZhciBhMiA9IC0wLjI4NDQ5NjczNjtcbiAgdmFyIGEzID0gMS40MjE0MTM3NDE7XG4gIHZhciBhNCA9IC0xLjQ1MzE1MjAyNztcbiAgdmFyIGE1ID0gMS4wNjE0MDU0Mjk7XG4gIHZhciBwID0gMC4zMjc1OTExO1xuXG4gIHZhciBzaWduID0gMTtcbiAgaWYgKHggPCAwKSB7XG4gICAgc2lnbiA9IC0xO1xuICB9XG4gIHggPSBNYXRoLmFicyh4KTtcbiAgdmFyIHQgPSAxLjAgLyAoMS4wICsgcCAqIHgpO1xuICB2YXIgeSA9IDEuMCAtICgoKChhNSAqIHQgKyBhNCkgKiB0ICsgYTMpICogdCArIGEyKSAqIHQgKyBhMSkgKiB0ICogTWF0aC5leHAoLXggKiB4KTtcblxuICByZXR1cm4gc2lnbiAqIHk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXJmY19mbG9hdCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9lcmZfZmxvYXRcbmZ1bmN0aW9uIGNhbWxfZXJmY19mbG9hdCh4KSB7XG4gIHJldHVybiAxIC0gY2FtbF9lcmZfZmxvYXQoeCk7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9mbWFfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZm1hX2Zsb2F0KHgsIHksIHopIHtcbiAgdmFyIFNQTElUID0gTWF0aC5wb3coMiwgMjcpICsgMTtcbiAgdmFyIE1JTl9WQUxVRSA9IE1hdGgucG93KDIsIC0xMDIyKTtcbiAgdmFyIEVQU0lMT04gPSBNYXRoLnBvdygyLCAtNTIpO1xuICB2YXIgQyA9IDQxNjtcbiAgdmFyIEEgPSBNYXRoLnBvdygyLCArQyk7XG4gIHZhciBCID0gTWF0aC5wb3coMiwgLUMpO1xuXG4gIGZ1bmN0aW9uIG11bHRpcGx5IChhLCBiKSB7XG4gICAgdmFyIGF0ID0gU1BMSVQgKiBhO1xuICAgIHZhciBhaGkgPSBhdCAtIChhdCAtIGEpO1xuICAgIHZhciBhbG8gPSBhIC0gYWhpO1xuICAgIHZhciBidCA9IFNQTElUICogYjtcbiAgICB2YXIgYmhpID0gYnQgLSAoYnQgLSBiKTtcbiAgICB2YXIgYmxvID0gYiAtIGJoaTtcbiAgICB2YXIgcCA9IGEgKiBiO1xuICAgIHZhciBlID0gKChhaGkgKiBiaGkgLSBwKSArIGFoaSAqIGJsbyArIGFsbyAqIGJoaSkgKyBhbG8gKiBibG87XG4gICAgcmV0dXJuIHtcbiAgICAgIHA6IHAsXG4gICAgICBlOiBlXG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBhZGQgKGEsIGIpIHtcbiAgICB2YXIgcyA9IGEgKyBiO1xuICAgIHZhciB2ID0gcyAtIGE7XG4gICAgdmFyIGUgPSAoYSAtIChzIC0gdikpICsgKGIgLSB2KTtcbiAgICByZXR1cm4ge1xuICAgICAgczogcyxcbiAgICAgIGU6IGVcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIGFkanVzdCAoeCwgeSkge1xuICAgIHJldHVybiB4ICE9PSAwICYmIHkgIT09IDAgJiYgU1BMSVQgKiB4IC0gKFNQTElUICogeCAtIHgpID09PSB4ID8geCAqICgxICsgKHggPCAwID8gLTEgOiArMSkgKiAoeSA8IDAgPyAtMSA6ICsxKSAqIEVQU0lMT04pIDogeDtcbiAgfTtcblxuICBpZiAoeCA9PT0gMCB8fCB4ICE9PSB4IHx8IHggPT09ICsxIC8gMCB8fCB4ID09PSAtMSAvIDAgfHxcbiAgICAgIHkgPT09IDAgfHwgeSAhPT0geSB8fCB5ID09PSArMSAvIDAgfHwgeSA9PT0gLTEgLyAwKSB7XG4gICAgcmV0dXJuIHggKiB5ICsgejtcbiAgfVxuICBpZiAoeiA9PT0gMCkge1xuICAgIHJldHVybiB4ICogeTtcbiAgfVxuICBpZiAoeiAhPT0geiB8fCB6ID09PSArMSAvIDAgfHwgeiA9PT0gLTEgLyAwKSB7XG4gICAgcmV0dXJuIHo7XG4gIH1cblxuICB2YXIgc2NhbGUgPSAxO1xuICB3aGlsZSAoTWF0aC5hYnMoeCkgPiBBKSB7XG4gICAgc2NhbGUgKj0gQTtcbiAgICB4ICo9IEI7XG4gIH1cbiAgd2hpbGUgKE1hdGguYWJzKHkpID4gQSkge1xuICAgIHNjYWxlICo9IEE7XG4gICAgeSAqPSBCO1xuICB9XG4gIGlmIChzY2FsZSA9PT0gMSAvIDApIHtcbiAgICByZXR1cm4geCAqIHkgKiBzY2FsZTtcbiAgfVxuICB3aGlsZSAoTWF0aC5hYnMoeCkgPCBCKSB7XG4gICAgc2NhbGUgKj0gQjtcbiAgICB4ICo9IEE7XG4gIH1cbiAgd2hpbGUgKE1hdGguYWJzKHkpIDwgQikge1xuICAgIHNjYWxlICo9IEI7XG4gICAgeSAqPSBBO1xuICB9XG4gIGlmIChzY2FsZSA9PT0gMCkge1xuICAgIHJldHVybiB6O1xuICB9XG5cbiAgdmFyIHhzID0geDtcbiAgdmFyIHlzID0geTtcbiAgdmFyIHpzID0geiAvIHNjYWxlO1xuXG4gIGlmIChNYXRoLmFicyh6cykgPiBNYXRoLmFicyh4cyAqIHlzKSAqIDQgLyBFUFNJTE9OKSB7XG4gICAgcmV0dXJuIHo7XG4gIH1cbiAgaWYgKE1hdGguYWJzKHpzKSA8IE1hdGguYWJzKHhzICogeXMpICogRVBTSUxPTiAvIDQgKiBFUFNJTE9OIC8gNCkge1xuICAgIHpzID0gKHogPCAwID8gLTEgOiArMSkgKiBNSU5fVkFMVUU7XG4gIH1cblxuICB2YXIgeHkgPSBtdWx0aXBseSh4cywgeXMpO1xuICB2YXIgcyA9IGFkZCh4eS5wLCB6cyk7XG4gIHZhciB1ID0gYWRkKHh5LmUsIHMuZSk7XG4gIHZhciBpID0gYWRkKHMucywgdS5zKTtcblxuICB2YXIgZiA9IGkucyArIGFkanVzdChpLmUsIHUuZSk7XG4gIGlmIChmID09PSAwKSB7XG4gICAgcmV0dXJuIGY7XG4gIH1cblxuICB2YXIgZnMgPSBmICogc2NhbGU7XG4gIGlmIChNYXRoLmFicyhmcykgPiBNSU5fVkFMVUUpIHtcbiAgICByZXR1cm4gZnM7XG4gIH1cblxuICAvLyBJdCBpcyBwb3NzaWJsZSB0aGF0IHRoZXJlIHdhcyBleHRyYSByb3VuZGluZyBmb3IgYSBkZW5vcm1hbGl6ZWQgdmFsdWUuXG4gIHJldHVybiBmcyArIGFkanVzdChmIC0gZnMgLyBzY2FsZSwgaS5lKSAqIHNjYWxlO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2Zvcm1hdF9mbG9hdCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9wYXJzZV9mb3JtYXQsIGNhbWxfZmluaXNoX2Zvcm1hdHRpbmdcbmZ1bmN0aW9uIGNhbWxfZm9ybWF0X2Zsb2F0IChmbXQsIHgpIHtcbiAgZnVuY3Rpb24gdG9GaXhlZCh4LGRwKSB7XG4gICAgaWYgKE1hdGguYWJzKHgpIDwgMS4wKSB7XG4gICAgICByZXR1cm4geC50b0ZpeGVkKGRwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGUgPSBwYXJzZUludCh4LnRvU3RyaW5nKCkuc3BsaXQoJysnKVsxXSk7XG4gICAgICBpZiAoZSA+IDIwKSB7XG4gICAgICAgIGUgLT0gMjA7XG4gICAgICAgIHggLz0gTWF0aC5wb3coMTAsZSk7XG4gICAgICAgIHggKz0gKG5ldyBBcnJheShlKzEpKS5qb2luKCcwJyk7XG4gICAgICAgIGlmKGRwID4gMCkge1xuICAgICAgICAgIHggPSB4ICsgJy4nICsgKG5ldyBBcnJheShkcCsxKSkuam9pbignMCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4O1xuICAgICAgfVxuICAgICAgZWxzZSByZXR1cm4geC50b0ZpeGVkKGRwKVxuICAgIH1cbiAgfVxuICB2YXIgcywgZiA9IGNhbWxfcGFyc2VfZm9ybWF0KGZtdCk7XG4gIHZhciBwcmVjID0gKGYucHJlYyA8IDApPzY6Zi5wcmVjO1xuICBpZiAoeCA8IDAgfHwgKHggPT0gMCAmJiAxL3ggPT0gLUluZmluaXR5KSkgeyBmLnNpZ24gPSAtMTsgeCA9IC14OyB9XG4gIGlmIChpc05hTih4KSkgeyBzID0gXCJuYW5cIjsgZi5maWxsZXIgPSAnICc7IH1cbiAgZWxzZSBpZiAoIWlzRmluaXRlKHgpKSB7IHMgPSBcImluZlwiOyBmLmZpbGxlciA9ICcgJzsgfVxuICBlbHNlXG4gICAgc3dpdGNoIChmLmNvbnYpIHtcbiAgICBjYXNlICdlJzpcbiAgICAgIHZhciBzID0geC50b0V4cG9uZW50aWFsKHByZWMpO1xuICAgICAgLy8gZXhwb25lbnQgc2hvdWxkIGJlIGF0IGxlYXN0IHR3byBkaWdpdHNcbiAgICAgIHZhciBpID0gcy5sZW5ndGg7XG4gICAgICBpZiAocy5jaGFyQXQoaSAtIDMpID09ICdlJylcbiAgICAgICAgcyA9IHMuc2xpY2UgKDAsIGkgLSAxKSArICcwJyArIHMuc2xpY2UgKGkgLSAxKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2YnOlxuICAgICAgcyA9IHRvRml4ZWQoeCwgcHJlYyk7IGJyZWFrO1xuICAgIGNhc2UgJ2cnOlxuICAgICAgcHJlYyA9IHByZWM/cHJlYzoxO1xuICAgICAgcyA9IHgudG9FeHBvbmVudGlhbChwcmVjIC0gMSk7XG4gICAgICB2YXIgaiA9IHMuaW5kZXhPZignZScpO1xuICAgICAgdmFyIGV4cCA9ICtzLnNsaWNlKGogKyAxKTtcbiAgICAgIGlmIChleHAgPCAtNCB8fCB4ID49IDFlMjEgfHwgeC50b0ZpeGVkKDApLmxlbmd0aCA+IHByZWMpIHtcbiAgICAgICAgLy8gcmVtb3ZlIHRyYWlsaW5nIHplcm9lc1xuICAgICAgICB2YXIgaSA9IGogLSAxOyB3aGlsZSAocy5jaGFyQXQoaSkgPT0gJzAnKSBpLS07XG4gICAgICAgIGlmIChzLmNoYXJBdChpKSA9PSAnLicpIGktLTtcbiAgICAgICAgcyA9IHMuc2xpY2UoMCwgaSArIDEpICsgcy5zbGljZShqKTtcbiAgICAgICAgaSA9IHMubGVuZ3RoO1xuICAgICAgICBpZiAocy5jaGFyQXQoaSAtIDMpID09ICdlJylcbiAgICAgICAgICBzID0gcy5zbGljZSAoMCwgaSAtIDEpICsgJzAnICsgcy5zbGljZSAoaSAtIDEpO1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBwID0gcHJlYztcbiAgICAgICAgaWYgKGV4cCA8IDApIHsgcCAtPSBleHAgKyAxOyBzID0geC50b0ZpeGVkKHApOyB9XG4gICAgICAgIGVsc2Ugd2hpbGUgKHMgPSB4LnRvRml4ZWQocCksIHMubGVuZ3RoID4gcHJlYyArIDEpIHAtLTtcbiAgICAgICAgaWYgKHApIHtcbiAgICAgICAgICAvLyByZW1vdmUgdHJhaWxpbmcgemVyb2VzXG4gICAgICAgICAgdmFyIGkgPSBzLmxlbmd0aCAtIDE7IHdoaWxlIChzLmNoYXJBdChpKSA9PSAnMCcpIGktLTtcbiAgICAgICAgICBpZiAocy5jaGFyQXQoaSkgPT0gJy4nKSBpLS07XG4gICAgICAgICAgcyA9IHMuc2xpY2UoMCwgaSArIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gIHJldHVybiBjYW1sX2ZpbmlzaF9mb3JtYXR0aW5nKGYsIHMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2Zsb2F0X29mX3N0cmluZyAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoLCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2Zsb2F0X29mX3N0cmluZyhzKSB7XG4gIHZhciByZXM7XG4gIHMgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKHMpXG4gIHJlcyA9ICtzO1xuICBpZiAoKHMubGVuZ3RoID4gMCkgJiYgKHJlcyA9PT0gcmVzKSkgcmV0dXJuIHJlcztcbiAgcyA9IHMucmVwbGFjZSgvXy9nLFwiXCIpO1xuICByZXMgPSArcztcbiAgaWYgKCgocy5sZW5ndGggPiAwKSAmJiAocmVzID09PSByZXMpKSB8fCAvXlsrLV0/bmFuJC9pLnRlc3QocykpIHJldHVybiByZXM7XG4gIHZhciBtID0gL14gKihbKy1dPykweChbMC05YS1mXSspXFwuPyhbMC05YS1mXSopKHAoWystXT9bMC05XSspKT8vaS5leGVjKHMpO1xuICAvLyAgICAgICAgICAxICAgICAgICAyICAgICAgICAgICAgIDMgICAgICAgICAgIDVcbiAgaWYobSl7XG4gICAgdmFyIG0zID0gbVszXS5yZXBsYWNlKC8wKyQvLCcnKTtcbiAgICB2YXIgbWFudGlzc2EgPSBwYXJzZUludChtWzFdICsgbVsyXSArIG0zLCAxNik7XG4gICAgdmFyIGV4cG9uZW50ID0gKG1bNV18MCkgLSA0Km0zLmxlbmd0aDtcbiAgICByZXMgPSBtYW50aXNzYSAqIE1hdGgucG93KDIsIGV4cG9uZW50KTtcbiAgICByZXR1cm4gcmVzO1xuICB9XG4gIGlmKC9eXFwrP2luZihpbml0eSk/JC9pLnRlc3QocykpIHJldHVybiBJbmZpbml0eTtcbiAgaWYoL14taW5mKGluaXR5KT8kL2kudGVzdChzKSkgcmV0dXJuIC1JbmZpbml0eTtcbiAgY2FtbF9mYWlsd2l0aChcImZsb2F0X29mX3N0cmluZ1wiKTtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUHJvdmlkZXM6IGNhbWxfdXBkYXRlX2R1bW15XG5mdW5jdGlvbiBjYW1sX3VwZGF0ZV9kdW1teSAoeCwgeSkge1xuICBpZiggeS5mdW4gKSB7IHguZnVuID0geS5mdW47IHJldHVybiAwOyB9XG4gIGlmKCB0eXBlb2YgeT09PVwiZnVuY3Rpb25cIiApIHsgeC5mdW4gPSB5OyByZXR1cm4gMDsgfVxuICB2YXIgaSA9IHkubGVuZ3RoOyB3aGlsZSAoaS0tKSB4W2ldID0geVtpXTsgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYWxsb2NfZHVtbXlfaW5maXhcbi8vUmVxdWlyZXM6IGNhbWxfY2FsbF9nZW5cbmZ1bmN0aW9uIGNhbWxfYWxsb2NfZHVtbXlfaW5maXggKCkge1xuICByZXR1cm4gZnVuY3Rpb24gZiAoeCkgeyByZXR1cm4gY2FtbF9jYWxsX2dlbihmLmZ1biwgW3hdKSB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX2lzX2Jsb2NrIGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfb2JqX2lzX2Jsb2NrICh4KSB7IHJldHVybiArKHggaW5zdGFuY2VvZiBBcnJheSk7IH1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX29ial90YWdcbi8vUmVxdWlyZXM6IGNhbWxfaXNfbWxfYnl0ZXMsIGNhbWxfaXNfbWxfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX29ial90YWcgKHgpIHtcbiAgaWYgKCh4IGluc3RhbmNlb2YgQXJyYXkpICYmIHhbMF0gPT0gKHhbMF0gPj4+IDApKVxuICAgIHJldHVybiB4WzBdXG4gIGVsc2UgaWYgKGNhbWxfaXNfbWxfYnl0ZXMoeCkpXG4gICAgcmV0dXJuIDI1MlxuICBlbHNlIGlmIChjYW1sX2lzX21sX3N0cmluZyh4KSlcbiAgICByZXR1cm4gMjUyXG4gIGVsc2UgaWYgKCh4IGluc3RhbmNlb2YgRnVuY3Rpb24pIHx8IHR5cGVvZiB4ID09IFwiZnVuY3Rpb25cIilcbiAgICByZXR1cm4gMjQ3XG4gIGVsc2UgaWYgKHggJiYgeC5jYW1sX2N1c3RvbSlcbiAgICByZXR1cm4gMjU1XG4gIGVsc2VcbiAgICByZXR1cm4gMTAwMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29ial9zZXRfdGFnIChtdXRhYmxlLCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfb2JqX3NldF90YWcgKHgsIHRhZykgeyB4WzBdID0gdGFnOyByZXR1cm4gMDsgfVxuLy9Qcm92aWRlczogY2FtbF9vYmpfYmxvY2sgY29uc3QgKGNvbnN0LGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9vYmpfYmxvY2sgKHRhZywgc2l6ZSkge1xuICB2YXIgbyA9IG5ldyBBcnJheShzaXplKzEpO1xuICBvWzBdPXRhZztcbiAgZm9yICh2YXIgaSA9IDE7IGkgPD0gc2l6ZTsgaSsrKSBvW2ldID0gMDtcbiAgcmV0dXJuIG87XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX3dpdGhfdGFnXG5mdW5jdGlvbiBjYW1sX29ial93aXRoX3RhZyh0YWcseCkge1xuICB2YXIgbCA9IHgubGVuZ3RoO1xuICB2YXIgYSA9IG5ldyBBcnJheShsKTtcbiAgYVswXSA9IHRhZztcbiAgZm9yKHZhciBpID0gMTsgaSA8IGw7IGkrKyApIGFbaV0gPSB4W2ldO1xuICByZXR1cm4gYTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfZHVwIG11dGFibGUgKG11dGFibGUpXG5mdW5jdGlvbiBjYW1sX29ial9kdXAgKHgpIHtcbiAgdmFyIGwgPSB4Lmxlbmd0aDtcbiAgdmFyIGEgPSBuZXcgQXJyYXkobCk7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsOyBpKysgKSBhW2ldID0geFtpXTtcbiAgcmV0dXJuIGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX3RydW5jYXRlIChtdXRhYmxlLCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9vYmpfdHJ1bmNhdGUgKHgsIHMpIHtcbiAgaWYgKHM8PTAgfHwgcyArIDEgPiB4Lmxlbmd0aClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQgKFwiT2JqLnRydW5jYXRlXCIpO1xuICBpZiAoeC5sZW5ndGggIT0gcyArIDEpIHgubGVuZ3RoID0gcyArIDE7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29ial9tYWtlX2ZvcndhcmRcbmZ1bmN0aW9uIGNhbWxfb2JqX21ha2VfZm9yd2FyZCAoYix2KSB7XG4gIGJbMF09MjUwO1xuICBiWzFdPXY7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX2NvbXBhcmVfYW5kX3N3YXBcbmZ1bmN0aW9uIGNhbWxfb2JqX2NvbXBhcmVfYW5kX3N3YXAoeCxpLG9sZCxuKXtcbiAgaWYoeFtpKzFdID09IG9sZCkge1xuICAgIHhbaSsxXSA9IG47XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfaXNfc2hhcmVkXG5mdW5jdGlvbiBjYW1sX29ial9pc19zaGFyZWQoeCl7XG4gIHJldHVybiAxXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbGF6eV9tYWtlX2ZvcndhcmQgY29uc3QgKG11dGFibGUpXG5mdW5jdGlvbiBjYW1sX2xhenlfbWFrZV9mb3J3YXJkICh2KSB7IHJldHVybiBbMjUwLCB2XTsgfVxuXG4vLy8vLy8vLy8vLy8vIENhbWxpbnRlcm5hbE9PXG4vL1Byb3ZpZGVzOiBjYW1sX2dldF9wdWJsaWNfbWV0aG9kIGNvbnN0XG52YXIgY2FtbF9tZXRob2RfY2FjaGUgPSBbXTtcbmZ1bmN0aW9uIGNhbWxfZ2V0X3B1YmxpY19tZXRob2QgKG9iaiwgdGFnLCBjYWNoZWlkKSB7XG4gIHZhciBtZXRocyA9IG9ialsxXTtcbiAgdmFyIG9mcyA9IGNhbWxfbWV0aG9kX2NhY2hlW2NhY2hlaWRdO1xuICBpZiAob2ZzID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBNYWtlIHN1cmUgdGhlIGFycmF5IGlzIG5vdCBzcGFyc2VcbiAgICBmb3IgKHZhciBpID0gY2FtbF9tZXRob2RfY2FjaGUubGVuZ3RoOyBpIDwgY2FjaGVpZDsgaSsrKVxuICAgICAgY2FtbF9tZXRob2RfY2FjaGVbaV0gPSAwO1xuICB9IGVsc2UgaWYgKG1ldGhzW29mc10gPT09IHRhZykge1xuICAgIHJldHVybiBtZXRoc1tvZnMgLSAxXTtcbiAgfVxuICB2YXIgbGkgPSAzLCBoaSA9IG1ldGhzWzFdICogMiArIDEsIG1pO1xuICB3aGlsZSAobGkgPCBoaSkge1xuICAgIG1pID0gKChsaStoaSkgPj4gMSkgfCAxO1xuICAgIGlmICh0YWcgPCBtZXRoc1ttaSsxXSkgaGkgPSBtaS0yO1xuICAgIGVsc2UgbGkgPSBtaTtcbiAgfVxuICBjYW1sX21ldGhvZF9jYWNoZVtjYWNoZWlkXSA9IGxpICsgMTtcbiAgLyogcmV0dXJuIDAgaWYgdGFnIGlzIG5vdCB0aGVyZSAqL1xuICByZXR1cm4gKHRhZyA9PSBtZXRoc1tsaSsxXSA/IG1ldGhzW2xpXSA6IDApO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29vX2xhc3RfaWRcbnZhciBjYW1sX29vX2xhc3RfaWQgPSAwO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX3NldF9vb19pZFxuLy9SZXF1aXJlczogY2FtbF9vb19sYXN0X2lkXG5mdW5jdGlvbiBjYW1sX3NldF9vb19pZCAoYikge1xuICBiWzJdPWNhbWxfb29fbGFzdF9pZCsrO1xuICByZXR1cm4gYjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9mcmVzaF9vb19pZCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9vb19sYXN0X2lkXG5mdW5jdGlvbiBjYW1sX2ZyZXNoX29vX2lkKCkge1xuICByZXR1cm4gY2FtbF9vb19sYXN0X2lkKys7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX3Jhd19maWVsZFxuZnVuY3Rpb24gY2FtbF9vYmpfcmF3X2ZpZWxkKG8saSkgeyByZXR1cm4gb1tpKzFdIH1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfc2V0X3Jhd19maWVsZFxuZnVuY3Rpb24gY2FtbF9vYmpfc2V0X3Jhd19maWVsZChvLGksdikgeyByZXR1cm4gb1tpKzFdID0gdiB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX3JlYWNoYWJsZV93b3Jkc1xuZnVuY3Rpb24gY2FtbF9vYmpfcmVhY2hhYmxlX3dvcmRzKG8pIHsgcmV0dXJuIDA7IH1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfYWRkX29mZnNldFxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9vYmpfYWRkX29mZnNldCh2LG9mZnNldCkge1xuICBjYW1sX2ZhaWx3aXRoKFwiT2JqLmFkZF9vZmZzZXQgaXMgbm90IHN1cHBvcnRlZFwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfdXBkYXRlX3RhZ1xuZnVuY3Rpb24gY2FtbF9vYmpfdXBkYXRlX3RhZyhiLG8sbikge1xuICAgIGlmKGJbMF09PW8pIHsgYlswXSA9IG47IHJldHVybiAxIH1cbiAgICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2xhenlfdXBkYXRlX3RvX2ZvcmNpbmdcbi8vUmVxdWlyZXM6IGNhbWxfb2JqX3VwZGF0ZV90YWdcbmZ1bmN0aW9uIGNhbWxfbGF6eV91cGRhdGVfdG9fZm9yY2luZyhvKSB7XG4gIGlmICgobyBpbnN0YW5jZW9mIEFycmF5KSAmJiBvWzBdID09IChvWzBdID4+PiAwKSAmJlxuICAgICAgY2FtbF9vYmpfdXBkYXRlX3RhZyhvLCAyNDYsIDI0NCkpIHtcbiAgICByZXR1cm4gMDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gMTtcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2xhenlfdXBkYXRlX3RvX2ZvcndhcmRcbi8vUmVxdWlyZXM6IGNhbWxfb2JqX3VwZGF0ZV90YWdcbiAgZnVuY3Rpb24gY2FtbF9sYXp5X3VwZGF0ZV90b19mb3J3YXJkKG8pIHtcbiAgY2FtbF9vYmpfdXBkYXRlX3RhZyhvLDI0NCwyNTApO1xuICByZXR1cm4gMDsgLy8gdW5pdFxufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfbGF6eV9yZXNldF90b19sYXp5XG4vL1JlcXVpcmVzOiBjYW1sX29ial91cGRhdGVfdGFnXG5mdW5jdGlvbiBjYW1sX2xhenlfcmVzZXRfdG9fbGF6eShvKSB7XG4gIGNhbWxfb2JqX3VwZGF0ZV90YWcobywyNDQsMjQ2KTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbGF6eV9yZWFkX3Jlc3VsdFxuLy9SZXF1aXJlczogY2FtbF9vYmpfdGFnXG5mdW5jdGlvbiBjYW1sX2xhenlfcmVhZF9yZXN1bHQobykge1xuICByZXR1cm4gKGNhbWxfb2JqX3RhZyhvKSA9PSAyNTApP29bMV06bztcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lzX2NvbnRpbnVhdGlvbl90YWdcbi8vVmVyc2lvbjogPCA1XG5mdW5jdGlvbiBjYW1sX2lzX2NvbnRpbnVhdGlvbl90YWcodCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pc19jb250aW51YXRpb25fdGFnXG4vL1ZlcnNpb246ID49IDVcbmZ1bmN0aW9uIGNhbWxfaXNfY29udGludWF0aW9uX3RhZyh0KSB7XG4gIHJldHVybiAodCA9PSAyNDUpID8gMSA6IDA7XG59XG4iLCIvKlxuVG8gZGVhbCB3aXRoIGVmZmVjdHMsIHRoZSBleGVjdXRpb24gY29udGV4dCBpcyBpbnR1aXRpdmVseSBjb21wb3NlZCBvZlxuYSBzdGFjayBvZiBmaWJlcnMuIEVhY2ggZmliZXIgaGFzIGEgY3VycmVudCBsb3ctbGV2ZWwgY29udGludWF0aW9uXG4ob25lLWFyZ3VtZW50IEphdmFTY3JpcHQgZnVuY3Rpb24pLCBhIHN0YWNrIG9mIGV4Y2VwdGlvbiBoYW5kbGVycyBhbmRcbmEgdHJpcGxlIG9mIGhhbmRsZXJzLCB3aGljaCBhcmUgaW52b2tlZCB3aGVuIHRoZSBmaWJlciB0ZXJtaW5hdGVzXG4oZWl0aGVyIHdpdGggYSB2YWx1ZSBvciBhbiBleGNlcHRpb24pIG9yIHdoZW4gYW4gZWZmZWN0IGlzIHBlcmZvcm1lZC5cblRoZSBsb3ctbGV2ZWwgY29udGludWF0aW9uIG9mIHRoZSB0b3Btb3N0IGZpYmVyICh3aGljaCBpcyBjdXJyZW50bHlcbmV4ZWN1dGluZykgaXMgcGFzc2VkIGZyb20gZnVuY3Rpb24gdG8gZnVuY3Rpb24gYXMgYW4gYWRkaXRpb25hbFxuYXJndW1lbnQuIEl0cyBzdGFjayBvZiBleGNlcHRpb24gaGFuZGxlcnMgaXMgc3RvcmVkIGluXG5bY2FtbF9leG5fc3RhY2tdLiBFeGNlcHRpb24gaGFuZGxlcnMgYXJlIHB1c2hlZCBpbnRvIHRoaXMgc3RhY2sgd2hlblxuZW50ZXJpbmcgYSBbdHJ5IC4uLiB3aXRoIC4uLl0gYW5kIHBvcHBlZCBvbiBleGl0LiBUaGVuLCBoYW5kbGVycyBhbmRcbnRoZSByZW1haW5pbmcgZmliZXJzIGFyZSBzdG9yZWQgaW4gW2NhbWxfZmliZXJfc3RhY2tdLiBUbyBpbnN0YWxsIGFuXG5lZmZlY3QgaGFuZGxlciwgd2UgcHVzaCBhIG5ldyBmaWJlciBpbnRvIHRoZSBleGVjdXRpb24gY29udGV4dC5cblxuV2UgaGF2ZSBiYXNpY2FsbHkgdGhlIGZvbGxvd2luZyB0eXBlIGZvciByZWlmaWVkIGNvbnRpbnVhdGlvbnMgKHR5cGVcbltjb250aW51YXRpb25dIGluIG1vZHVsZSBbRWZmZWN0XSBvZiB0aGUgc3RhbmRhcmQgbGlicmFyeSk6XG5cbiAgdHlwZSAoJ2EsICdiKSBjb250aW51YXRpb24gPSAoJ2EsICdiKSBzdGFjayByZWZcblxuICBhbmQgKF8sIF8pIHN0YWNrID1cbiAgICAgIENvbnMgOiAoJ2IgLT4gdW5pdCkgKiAgICAgICAgICAgICAoKiBsb3ctbGV2ZWwgY29udGludWF0aW9uICopXG4gICAgICAgICAgICAgKGV4biAtPiB1bml0KSBsaXN0ICogICAgICAgKCogZXhjZXB0aW9uIGhhbmRsZXJzICopXG4gICAgICAgICAgICAgKCdiLCAnYykgaGFuZGxlciAqXG4gICAgICAgICAgICAgKCdhLCAnYikgc3RhY2tcbiAgICAgICAgICAgICAtPiAoJ2EsICdjKSBzdGFja1xuICAgIHwgRW1wdHkgOiAoJ2EsICdhKSBzdGFja1xuXG4gIGFuZCAoJ2EsJ2IpIGhhbmRsZXIgPSAgICgqIEFzIGluIG1vZHVsZSBFZmZlY3QgZnJvbSB0aGUgc3RhbmRhcmQgbGlicmFyeSAqKVxuICAgIHsgcmV0YzogJ2EgLT4gJ2I7XG4gICAgICBleG5jOiBleG4gLT4gJ2I7XG4gICAgICBlZmZjOiAnYy4nYyBFZmZlY3QudCAtPiAoKCdjLCdiKSBjb250aW51YXRpb24gLT4gJ2IpIG9wdGlvbiB9XG5cbkNvbnRpbnVhdGlvbnMgYXJlIG9uZS1zaG90LiBBIGNvbnRpbnVhdGlvbiBbcmVmIEVtcHR5XSBoYXMgYWxyZWFkeVxuYmVlbiByZXN1bWVkLlxuXG5BIGNvbnRpbnVhdGlvbiBpcyBiYXNpY2FsbHkgY29tcG9zZWQgb2YgYSBsaXN0IG9mIGZpYmVycywgd2hpY2ggZWFjaFxuaGFzIGl0cyBsb3ctbGV2ZWwgY29udGludWF0aW9uLCBpdHMgc3RhY2sgb2YgZXhjZXB0aW9uIGhhbmRsZXJzIGFuZCBhXG50cmlwbGUgb2YgaGFuZGxlcnMgdG8gZGVhbCB3aXRoIHdoZW4gdGhlIGZpYmVyIHRlcm1pbmF0ZXMgb3IgYW5cbmVmZmVjdCBpcyBwZXJmb3JtZWQuIFdoZW4gcmVzdW1pbmcgYSBjb250aW51YXRpb24sIHRoZSBpbm5lcm1vc3QgZmliZXJcbmlzIHJlc3VtZWQgZmlyc3QuXG5cblRoZSBoYW5kbGVycyBhcmUgQ1BTLXRyYW5zZm9ybWVkIGZ1bmN0aW9uczogdGhleSBhY3R1YWxseSB0YWtlIGFuXG5hZGRpdGlvbmFsIHBhcmFtZXRlciB3aGljaCBpcyB0aGUgY3VycmVudCBsb3ctbGV2ZWwgY29udGludWF0aW9uLlxuKi9cblxuLy9Qcm92aWRlczogY2FtbF9leG5fc3RhY2tcbi8vSWY6IGVmZmVjdHNcbi8vIFRoaXMgaXMgYW4gT0NhbWwgbGlzdCBvZiBleGNlcHRpb24gaGFuZGxlcnNcbnZhciBjYW1sX2V4bl9zdGFjayA9IDA7XG5cbi8vUHJvdmlkZXM6IGNhbWxfcHVzaF90cmFwXG4vL1JlcXVpcmVzOiBjYW1sX2V4bl9zdGFja1xuLy9JZjogZWZmZWN0c1xuZnVuY3Rpb24gY2FtbF9wdXNoX3RyYXAoaGFuZGxlcikge1xuICBjYW1sX2V4bl9zdGFjaz1bMCxoYW5kbGVyLGNhbWxfZXhuX3N0YWNrXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9wb3BfdHJhcFxuLy9SZXF1aXJlczogY2FtbF9leG5fc3RhY2tcbi8vSWY6IGVmZmVjdHNcbmZ1bmN0aW9uIGNhbWxfcG9wX3RyYXAoKSB7XG4gIGlmICghY2FtbF9leG5fc3RhY2spIHJldHVybiBmdW5jdGlvbih4KXt0aHJvdyB4O31cbiAgdmFyIGggPSBjYW1sX2V4bl9zdGFja1sxXTtcbiAgY2FtbF9leG5fc3RhY2s9Y2FtbF9leG5fc3RhY2tbMl07XG4gIHJldHVybiBoXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmliZXJfc3RhY2tcbi8vSWY6IGVmZmVjdHNcbi8vIFRoaXMgaGFzIHRoZSBzaGFwZSB7aCwgcjp7aywgeCwgZX19IHdoZXJlIGggaXMgYSB0cmlwbGUgb2YgaGFuZGxlcnNcbi8vIChzZWUgZWZmZWN0LmpzKSBhbmQgaywgeCBhbmQgZSBhcmUgdGhlIHNhdmVkIGNvbnRpbnVhdGlvbixcbi8vIGV4Y2VwdGlvbiBzdGFjayBhbmQgZmliZXIgc3RhY2sgb2YgdGhlIHBhcmVudCBmaWJlci5cbnZhciBjYW1sX2ZpYmVyX3N0YWNrO1xuXG4vL1Byb3ZpZGVzOmNhbWxfcmVzdW1lX3N0YWNrXG4vL1JlcXVpcmVzOiBjYW1sX25hbWVkX3ZhbHVlLCBjYW1sX3JhaXNlX2NvbnN0YW50LCBjYW1sX2V4bl9zdGFjaywgY2FtbF9maWJlcl9zdGFja1xuLy9JZjogZWZmZWN0c1xuZnVuY3Rpb24gY2FtbF9yZXN1bWVfc3RhY2soc3RhY2ssIGspIHtcbiAgaWYgKCFzdGFjaykgY2FtbF9yYWlzZV9jb25zdGFudFxuICAgICAgICAgICAgICAgICAoY2FtbF9uYW1lZF92YWx1ZShcIkVmZmVjdC5Db250aW51YXRpb25fYWxyZWFkeV9yZXN1bWVkXCIpKTtcbiAgLy8gVXBkYXRlIHRoZSBleGVjdXRpb24gY29udGV4dCB3aXRoIHRoZSBzdGFjayBvZiBmaWJlcnMgaW4gW3N0YWNrXSBpblxuICAvLyBvcmRlciB0byByZXN1bWUgdGhlIGNvbnRpbnVhdGlvblxuICBkbyB7XG4gICAgY2FtbF9maWJlcl9zdGFjayA9XG4gICAgICB7aDpzdGFja1szXSwgcjp7azprLCB4OmNhbWxfZXhuX3N0YWNrLCBlOmNhbWxfZmliZXJfc3RhY2t9fTtcbiAgICBrID0gc3RhY2tbMV07XG4gICAgY2FtbF9leG5fc3RhY2sgPSBzdGFja1syXTtcbiAgICBzdGFjayA9IHN0YWNrWzRdO1xuICB9IHdoaWxlIChzdGFjaylcbiAgcmV0dXJuIGs7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcG9wX2ZpYmVyXG4vL1JlcXVpcmVzOiBjYW1sX2V4bl9zdGFjaywgY2FtbF9maWJlcl9zdGFja1xuLy9JZjogZWZmZWN0c1xuZnVuY3Rpb24gY2FtbF9wb3BfZmliZXIoKSB7XG4gIC8vIE1vdmUgdG8gdGhlIHBhcmVudCBmaWJlciwgcmV0dXJuaW5nIHRoZSBwYXJlbnQncyBsb3ctbGV2ZWwgY29udGludWF0aW9uXG4gIHZhciByZW0gPSBjYW1sX2ZpYmVyX3N0YWNrLnI7XG4gIGNhbWxfZXhuX3N0YWNrID0gcmVtLng7XG4gIGNhbWxfZmliZXJfc3RhY2sgPSByZW0uZTtcbiAgcmV0dXJuIHJlbS5rO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3BlcmZvcm1fZWZmZWN0XG4vL1JlcXVpcmVzOiBjYW1sX3BvcF9maWJlciwgY2FtbF9zdGFja19jaGVja19kZXB0aCwgY2FtbF90cmFtcG9saW5lX3JldHVybiwgY2FtbF9leG5fc3RhY2ssIGNhbWxfZmliZXJfc3RhY2tcbi8vSWY6IGVmZmVjdHNcbmZ1bmN0aW9uIGNhbWxfcGVyZm9ybV9lZmZlY3QoZWZmLCBjb250LCBrMCkge1xuICAvLyBBbGxvY2F0ZSBhIGNvbnRpbnVhdGlvbiBpZiB3ZSBkb24ndCBhbHJlYWR5IGhhdmUgb25lXG4gIGlmICghY29udCkgY29udCA9IFsyNDUgLypjb250aW51YXRpb24qLywgMF07XG4gIC8vIEdldCBjdXJyZW50IGVmZmVjdCBoYW5kbGVyXG4gIHZhciBoYW5kbGVyID0gY2FtbF9maWJlcl9zdGFjay5oWzNdO1xuICAvLyBDb25zIHRoZSBjdXJyZW50IGZpYmVyIG9udG8gdGhlIGNvbnRpbnVhdGlvbjpcbiAgLy8gICBjb250IDo9IENvbnMgKGssIGV4bl9zdGFjaywgaGFuZGxlcnMsICFjb250KVxuICBjb250WzFdID0gWzAsazAsY2FtbF9leG5fc3RhY2ssY2FtbF9maWJlcl9zdGFjay5oLGNvbnRbMV1dO1xuICAvLyBNb3ZlIHRvIHBhcmVudCBmaWJlciBhbmQgZXhlY3V0ZSB0aGUgZWZmZWN0IGhhbmRsZXIgdGhlcmVcbiAgLy8gVGhlIGhhbmRsZXIgaXMgZGVmaW5lZCBpbiBTdGRsaWIuRWZmZWN0LCBzbyB3ZSBrbm93IHRoYXQgdGhlIGFyaXR5IG1hdGNoZXNcbiAgdmFyIGsxID0gY2FtbF9wb3BfZmliZXIoKTtcbiAgcmV0dXJuIGNhbWxfc3RhY2tfY2hlY2tfZGVwdGgoKT9oYW5kbGVyKGVmZixjb250LGsxLGsxKVxuICAgICAgICAgOmNhbWxfdHJhbXBvbGluZV9yZXR1cm4oaGFuZGxlcixbZWZmLGNvbnQsazEsazFdKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hbGxvY19zdGFja1xuLy9SZXF1aXJlczogY2FtbF9wb3BfZmliZXIsIGNhbWxfZmliZXJfc3RhY2ssIGNhbWxfY2FsbF9nZW4sIGNhbWxfc3RhY2tfY2hlY2tfZGVwdGgsIGNhbWxfdHJhbXBvbGluZV9yZXR1cm5cbi8vSWY6IGVmZmVjdHNcbmZ1bmN0aW9uIGNhbWxfYWxsb2Nfc3RhY2soaHYsIGh4LCBoZikge1xuICBmdW5jdGlvbiBjYWxsKGksIHgpIHtcbiAgICB2YXIgZj1jYW1sX2ZpYmVyX3N0YWNrLmhbaV07XG4gICAgdmFyIGFyZ3MgPSBbeCwgY2FtbF9wb3BfZmliZXIoKV07XG4gICAgcmV0dXJuIGNhbWxfc3RhY2tfY2hlY2tfZGVwdGgoKT9jYW1sX2NhbGxfZ2VuKGYsYXJncylcbiAgICAgICAgICAgOmNhbWxfdHJhbXBvbGluZV9yZXR1cm4oZixhcmdzKTtcbiAgfVxuICBmdW5jdGlvbiBodmFsKHgpIHtcbiAgICAvLyBDYWxsIFtodl0gaW4gdGhlIHBhcmVudCBmaWJlclxuICAgIHJldHVybiBjYWxsKDEsIHgpO1xuICB9XG4gIGZ1bmN0aW9uIGhleG4oZSkge1xuICAgIC8vIENhbGwgW2h4XSBpbiB0aGUgcGFyZW50IGZpYmVyXG4gICAgcmV0dXJuIGNhbGwoMiwgZSk7XG4gIH1cbiAgcmV0dXJuIFswLCBodmFsLCBbMCwgaGV4biwgMF0sIFswLCBodiwgaHgsIGhmXSwgMF07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYWxsb2Nfc3RhY2tcbi8vSWY6ICFlZmZlY3RzXG5mdW5jdGlvbiBjYW1sX2FsbG9jX3N0YWNrKGh2LCBoeCwgaGYpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY29udGludWF0aW9uX3VzZV9ub2V4Y1xuZnVuY3Rpb24gY2FtbF9jb250aW51YXRpb25fdXNlX25vZXhjKGNvbnQpIHtcbiAgdmFyIHN0YWNrPWNvbnRbMV07XG4gIGNvbnRbMV09MDtcbiAgcmV0dXJuIHN0YWNrO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvbnRpbnVhdGlvbl91c2VfYW5kX3VwZGF0ZV9oYW5kbGVyX25vZXhjXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnRpbnVhdGlvbl91c2Vfbm9leGNcbmZ1bmN0aW9uIGNhbWxfY29udGludWF0aW9uX3VzZV9hbmRfdXBkYXRlX2hhbmRsZXJfbm9leGMoY29udCwgaHZhbCwgaGV4biwgaGVmZikge1xuICB2YXIgc3RhY2sgPSBjYW1sX2NvbnRpbnVhdGlvbl91c2Vfbm9leGMoY29udCk7XG4gIHN0YWNrWzNdID0gWzAsIGh2YWwsIGhleG4sIGhlZmZdO1xuICByZXR1cm4gc3RhY2s7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2V0X2NvbnRpbnVhdGlvbl9jYWxsc3RhY2tcbmZ1bmN0aW9uIGNhbWxfZ2V0X2NvbnRpbnVhdGlvbl9jYWxsc3RhY2sgKCkgeyByZXR1cm4gWzBdOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfY29uZGl0aW9uX25ld1xuZnVuY3Rpb24gY2FtbF9tbF9jb25kaXRpb25fbmV3KHVuaXQpe1xuICAgIHJldHVybiB7Y29uZGl0aW9uOjF9O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2NvbmRpdGlvbl93YWl0XG5mdW5jdGlvbiBjYW1sX21sX2NvbmRpdGlvbl93YWl0KHQsbXV0ZXh0KXtcbiAgICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9jb25kaXRpb25fYnJvYWRjYXN0XG5mdW5jdGlvbiBjYW1sX21sX2NvbmRpdGlvbl9icm9hZGNhc3QodCl7XG4gICAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfY29uZGl0aW9uX3NpZ25hbFxuZnVuY3Rpb24gY2FtbF9tbF9jb25kaXRpb25fc2lnbmFsKHQpe1xuICAgIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBqc29vX2VmZmVjdF9ub3Rfc3VwcG9ydGVkXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG4vLyFJZjogZWZmZWN0c1xuZnVuY3Rpb24ganNvb19lZmZlY3Rfbm90X3N1cHBvcnRlZCgpe1xuICBjYW1sX2ZhaWx3aXRoKFwiRWZmZWN0IGhhbmRsZXJzIGFyZSBub3Qgc3VwcG9ydGVkXCIpO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8vLy8vLy8vLy8vLyBBcnJheVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X3N1YiBtdXRhYmxlXG5mdW5jdGlvbiBjYW1sX2FycmF5X3N1YiAoYSwgaSwgbGVuKSB7XG4gIHZhciBhMiA9IG5ldyBBcnJheShsZW4rMSk7XG4gIGEyWzBdPTA7XG4gIGZvcih2YXIgaTIgPSAxLCBpMT0gaSsxOyBpMiA8PSBsZW47IGkyKyssaTErKyApe1xuICAgIGEyW2kyXT1hW2kxXTtcbiAgfVxuICByZXR1cm4gYTI7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYXJyYXlfYXBwZW5kIG11dGFibGVcbmZ1bmN0aW9uIGNhbWxfYXJyYXlfYXBwZW5kKGExLCBhMikge1xuICB2YXIgbDEgPSBhMS5sZW5ndGgsIGwyID0gYTIubGVuZ3RoO1xuICB2YXIgbCA9IGwxK2wyLTFcbiAgdmFyIGEgPSBuZXcgQXJyYXkobCk7XG4gIGFbMF0gPSAwO1xuICB2YXIgaSA9IDEsaiA9IDE7XG4gIGZvcig7aTxsMTtpKyspIGFbaV09YTFbaV07XG4gIGZvcig7aTxsO2krKyxqKyspIGFbaV09YTJbal07XG4gIHJldHVybiBhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X2NvbmNhdCBtdXRhYmxlXG5mdW5jdGlvbiBjYW1sX2FycmF5X2NvbmNhdChsKSB7XG4gIHZhciBhID0gWzBdO1xuICB3aGlsZSAobCAhPT0gMCkge1xuICAgIHZhciBiID0gbFsxXTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGIubGVuZ3RoOyBpKyspIGEucHVzaChiW2ldKTtcbiAgICBsID0gbFsyXTtcbiAgfVxuICByZXR1cm4gYTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9ibGl0XG5mdW5jdGlvbiBjYW1sX2FycmF5X2JsaXQoYTEsIGkxLCBhMiwgaTIsIGxlbikge1xuICBpZiAoaTIgPD0gaTEpIHtcbiAgICBmb3IgKHZhciBqID0gMTsgaiA8PSBsZW47IGorKykgYTJbaTIgKyBqXSA9IGExW2kxICsgal07XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaiA9IGxlbjsgaiA+PSAxOyBqLS0pIGEyW2kyICsgal0gPSBhMVtpMSArIGpdO1xuICB9O1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9mbG9hdGFycmF5X2JsaXRcbmZ1bmN0aW9uIGNhbWxfZmxvYXRhcnJheV9ibGl0KGExLCBpMSwgYTIsIGkyLCBsZW4pIHtcbiAgaWYgKGkyIDw9IGkxKSB7XG4gICAgZm9yICh2YXIgaiA9IDE7IGogPD0gbGVuOyBqKyspIGEyW2kyICsgal0gPSBhMVtpMSArIGpdO1xuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGogPSBsZW47IGogPj0gMTsgai0tKSBhMltpMiArIGpdID0gYTFbaTEgKyBqXTtcbiAgfTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vLy8vLy8vLy8vLy8gUGVydmFzaXZlXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X3NldCAobXV0YWJsZSwgY29uc3QsIG11dGFibGUpXG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX2FycmF5X3NldCAoYXJyYXksIGluZGV4LCBuZXd2YWwpIHtcbiAgaWYgKChpbmRleCA8IDApIHx8IChpbmRleCA+PSBhcnJheS5sZW5ndGggLSAxKSkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICBhcnJheVtpbmRleCsxXT1uZXd2YWw7IHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X2dldCBtdXRhYmxlIChtdXRhYmxlLCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfYXJyYXlfZ2V0IChhcnJheSwgaW5kZXgpIHtcbiAgaWYgKChpbmRleCA8IDApIHx8IChpbmRleCA+PSBhcnJheS5sZW5ndGggLSAxKSkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICByZXR1cm4gYXJyYXlbaW5kZXgrMV07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYXJyYXlfZmlsbFxuZnVuY3Rpb24gY2FtbF9hcnJheV9maWxsKGFycmF5LCBvZnMsIGxlbiwgdil7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKyl7XG4gICAgYXJyYXlbb2ZzK2krMV0gPSB2O1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NoZWNrX2JvdW5kIChtdXRhYmxlLCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfY2hlY2tfYm91bmQgKGFycmF5LCBpbmRleCkge1xuICBpZiAoaW5kZXggPj4+IDAgPj0gYXJyYXkubGVuZ3RoIC0gMSkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICByZXR1cm4gYXJyYXk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWFrZV92ZWN0IGNvbnN0IChjb25zdCwgbXV0YWJsZSlcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfbWFrZV92ZWN0IChsZW4sIGluaXQpIHtcbiAgaWYgKGxlbiA8IDApIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGxlbiA9IGxlbiArIDEgfCAwO1xuICB2YXIgYiA9IG5ldyBBcnJheShsZW4pO1xuICBiWzBdPTA7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuOyBpKyspIGJbaV0gPSBpbml0O1xuICByZXR1cm4gYjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tYWtlX2Zsb2F0X3ZlY3QgY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9tYWtlX2Zsb2F0X3ZlY3QobGVuKXtcbiAgaWYgKGxlbiA8IDApIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGxlbiA9IGxlbiArIDEgfCAwO1xuICB2YXIgYiA9IG5ldyBBcnJheShsZW4pO1xuICBiWzBdPTI1NDtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBsZW47IGkrKykgYltpXSA9IDA7XG4gIHJldHVybiBiXG59XG4vL1Byb3ZpZGVzOiBjYW1sX2Zsb2F0YXJyYXlfY3JlYXRlIGNvbnN0IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfZmxvYXRhcnJheV9jcmVhdGUobGVuKXtcbiAgaWYgKGxlbiA8IDApIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGxlbiA9IGxlbiArIDEgfCAwO1xuICB2YXIgYiA9IG5ldyBBcnJheShsZW4pO1xuICBiWzBdPTI1NDtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBsZW47IGkrKykgYltpXSA9IDA7XG4gIHJldHVybiBiXG59XG4iLCIvL1Byb3ZpZGVzOiBjYW1sX2RvbWFpbl9kbHNcbnZhciBjYW1sX2RvbWFpbl9kbHMgPSBbMF07XG5cbi8vUHJvdmlkZXM6IGNhbWxfZG9tYWluX2Rsc19zZXRcbi8vUmVxdWlyZXM6IGNhbWxfZG9tYWluX2Rsc1xuZnVuY3Rpb24gY2FtbF9kb21haW5fZGxzX3NldChhKSB7XG4gIGNhbWxfZG9tYWluX2RscyA9IGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZG9tYWluX2Rsc19jb21wYXJlX2FuZF9zZXRcbi8vUmVxdWlyZXM6IGNhbWxfZG9tYWluX2Rsc1xuLy9WZXJzaW9uOiA+PSA1LjJcbmZ1bmN0aW9uIGNhbWxfZG9tYWluX2Rsc19jb21wYXJlX2FuZF9zZXQob2xkLG4pIHtcbiAgaWYoY2FtbF9kb21haW5fZGxzICE9PSBvbGQpIHJldHVybiAwXG4gIGNhbWxfZG9tYWluX2RscyA9IG47XG4gIHJldHVybiAxO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2RvbWFpbl9kbHNfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX2RvbWFpbl9kbHNcbmZ1bmN0aW9uIGNhbWxfZG9tYWluX2Rsc19nZXQodW5pdCkge1xuICByZXR1cm4gY2FtbF9kb21haW5fZGxzO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfYXRvbWljX2xvYWRcbmZ1bmN0aW9uIGNhbWxfYXRvbWljX2xvYWQocmVmKXtcbiAgcmV0dXJuIHJlZlsxXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hdG9taWNfY2FzXG5mdW5jdGlvbiBjYW1sX2F0b21pY19jYXMocmVmLG8sbikge1xuICBpZihyZWZbMV0gPT09IG8pe1xuICAgIHJlZlsxXSA9IG47XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYXRvbWljX2ZldGNoX2FkZFxuZnVuY3Rpb24gY2FtbF9hdG9taWNfZmV0Y2hfYWRkKHJlZiwgaSkge1xuICB2YXIgb2xkID0gcmVmWzFdO1xuICByZWZbMV0gKz0gaTtcbiAgcmV0dXJuIG9sZDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hdG9taWNfZXhjaGFuZ2VcbmZ1bmN0aW9uIGNhbWxfYXRvbWljX2V4Y2hhbmdlKHJlZiwgdikge1xuICB2YXIgciA9IHJlZlsxXTtcbiAgcmVmWzFdID0gdjtcbiAgcmV0dXJuIHI7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYXRvbWljX21ha2VfY29udGVuZGVkXG5mdW5jdGlvbiBjYW1sX2F0b21pY19tYWtlX2NvbnRlbmRlZChhKSB7XG4gIHJldHVybiBbMCwgYV1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9kb21haW5fdW5pcXVlX3Rva2VuXG4vL1ZlcnNpb246IDwgNS4yXG52YXIgY2FtbF9tbF9kb21haW5fdW5pcXVlX3Rva2VuXyA9IFswXVxuZnVuY3Rpb24gY2FtbF9tbF9kb21haW5fdW5pcXVlX3Rva2VuKHVuaXQpIHtcbiAgcmV0dXJuIGNhbWxfbWxfZG9tYWluX3VuaXF1ZV90b2tlbl9cbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2RvbWFpbl9zZXRfbmFtZVxuZnVuY3Rpb24gY2FtbF9tbF9kb21haW5fc2V0X25hbWUoX25hbWUpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmVjb21tZW5kZWRfZG9tYWluX2NvdW50XG5mdW5jdGlvbiBjYW1sX3JlY29tbWVuZGVkX2RvbWFpbl9jb3VudCh1bml0KSB7IHJldHVybiAxIH1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2RvbWFpbl9pZFxudmFyIGNhbWxfZG9tYWluX2lkID0gMDtcblxuLy9Qcm92aWRlczogY2FtbF9kb21haW5fc3Bhd25cbi8vUmVxdWlyZXM6IGNhbWxfbWxfbXV0ZXhfdW5sb2NrXG4vL1JlcXVpcmVzOiBjYW1sX2RvbWFpbl9pZFxuLy9SZXF1aXJlczogY2FtbF9jYWxsYmFja1xuLy9WZXJzaW9uOiA+PSA1LjJcbnZhciBjYW1sX2RvbWFpbl9sYXRlc3RfaWR4ID0gMVxuZnVuY3Rpb24gY2FtbF9kb21haW5fc3Bhd24oZix0ZXJtX3N5bmMpe1xuICAgIHZhciBpZCA9IGNhbWxfZG9tYWluX2xhdGVzdF9pZHgrKztcbiAgICB2YXIgb2xkID0gY2FtbF9kb21haW5faWQ7XG4gICAgY2FtbF9kb21haW5faWQgPSBpZDtcbiAgICB2YXIgcmVzID0gY2FtbF9jYWxsYmFjayhmLFswXSk7XG4gICAgY2FtbF9kb21haW5faWQgPSBvbGQ7XG4gICAgY2FtbF9tbF9tdXRleF91bmxvY2sodGVybV9zeW5jWzJdKTtcbiAgICAvL1RPRE86IGZpeCBleG4gY2FzZVxuICAgIHRlcm1fc3luY1sxXSA9IFswLCBbMCwgcmVzXV07XG4gICAgcmV0dXJuIGlkO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2RvbWFpbl9zcGF3blxuLy9SZXF1aXJlczogY2FtbF9tbF9tdXRleF91bmxvY2tcbi8vUmVxdWlyZXM6IGNhbWxfZG9tYWluX2lkXG4vL1JlcXVpcmVzOiBjYW1sX2NhbGxiYWNrXG4vL1ZlcnNpb246IDwgNS4yXG52YXIgY2FtbF9kb21haW5fbGF0ZXN0X2lkeCA9IDFcbmZ1bmN0aW9uIGNhbWxfZG9tYWluX3NwYXduKGYsbXV0ZXgpe1xuICAgIHZhciBpZCA9IGNhbWxfZG9tYWluX2xhdGVzdF9pZHgrKztcbiAgICB2YXIgb2xkID0gY2FtbF9kb21haW5faWQ7XG4gICAgY2FtbF9kb21haW5faWQgPSBpZDtcbiAgICB2YXIgcmVzID0gY2FtbF9jYWxsYmFjayhmLFswXSk7XG4gICAgY2FtbF9kb21haW5faWQgPSBvbGQ7XG4gICAgY2FtbF9tbF9tdXRleF91bmxvY2sobXV0ZXgpO1xuICAgIHJldHVybiBpZDtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2RvbWFpbl9pZFxuLy9SZXF1aXJlczogY2FtbF9kb21haW5faWRcbmZ1bmN0aW9uIGNhbWxfbWxfZG9tYWluX2lkKHVuaXQpe1xuICAgIHJldHVybiBjYW1sX2RvbWFpbl9pZDtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2RvbWFpbl9jcHVfcmVsYXhcbmZ1bmN0aW9uIGNhbWxfbWxfZG9tYWluX2NwdV9yZWxheCh1bml0KXtcbiAgICByZXR1cm4gMDtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUHJvdmlkZXM6IGNhbWxfZm9ybWF0X2ludCBjb25zdCAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9wYXJzZV9mb3JtYXQsIGNhbWxfZmluaXNoX2Zvcm1hdHRpbmcsIGNhbWxfc3RyX3JlcGVhdFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlcywgY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9mb3JtYXRfaW50KGZtdCwgaSkge1xuICBpZiAoY2FtbF9qc2J5dGVzX29mX3N0cmluZyhmbXQpID09IFwiJWRcIikgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoXCJcIitpKTtcbiAgdmFyIGYgPSBjYW1sX3BhcnNlX2Zvcm1hdChmbXQpO1xuICBpZiAoaSA8IDApIHsgaWYgKGYuc2lnbmVkY29udikgeyBmLnNpZ24gPSAtMTsgaSA9IC1pOyB9IGVsc2UgaSA+Pj49IDA7IH1cbiAgdmFyIHMgPSBpLnRvU3RyaW5nKGYuYmFzZSk7XG4gIGlmIChmLnByZWMgPj0gMCkge1xuICAgIGYuZmlsbGVyID0gJyAnO1xuICAgIHZhciBuID0gZi5wcmVjIC0gcy5sZW5ndGg7XG4gICAgaWYgKG4gPiAwKSBzID0gY2FtbF9zdHJfcmVwZWF0IChuLCAnMCcpICsgcztcbiAgfVxuICByZXR1cm4gY2FtbF9maW5pc2hfZm9ybWF0dGluZyhmLCBzKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9wYXJzZV9zaWduX2FuZF9iYXNlXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0LCBjYW1sX21sX3N0cmluZ19sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfcGFyc2Vfc2lnbl9hbmRfYmFzZSAocykge1xuICB2YXIgaSA9IDAsIGxlbiA9IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSwgYmFzZSA9IDEwLCBzaWduID0gMTtcbiAgaWYgKGxlbiA+IDApIHtcbiAgICBzd2l0Y2ggKGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQocyxpKSkge1xuICAgIGNhc2UgNDU6IGkrKzsgc2lnbiA9IC0xOyBicmVhaztcbiAgICBjYXNlIDQzOiBpKys7IHNpZ24gPSAxOyBicmVhaztcbiAgICB9XG4gIH1cbiAgaWYgKGkgKyAxIDwgbGVuICYmIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQocywgaSkgPT0gNDgpXG4gICAgc3dpdGNoIChjYW1sX3N0cmluZ191bnNhZmVfZ2V0KHMsIGkgKyAxKSkge1xuICAgIGNhc2UgMTIwOiBjYXNlIDg4OiBiYXNlID0gMTY7IGkgKz0gMjsgYnJlYWs7XG4gICAgY2FzZSAxMTE6IGNhc2UgNzk6IGJhc2UgPSAgODsgaSArPSAyOyBicmVhaztcbiAgICBjYXNlICA5ODogY2FzZSA2NjogYmFzZSA9ICAyOyBpICs9IDI7IGJyZWFrO1xuICAgIGNhc2UgMTE3OiBjYXNlIDg1OiBpICs9IDI7IGJyZWFrO1xuICAgIH1cbiAgcmV0dXJuIFtpLCBzaWduLCBiYXNlXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9wYXJzZV9kaWdpdFxuZnVuY3Rpb24gY2FtbF9wYXJzZV9kaWdpdChjKSB7XG4gIGlmIChjID49IDQ4ICYmIGMgPD0gNTcpICByZXR1cm4gYyAtIDQ4O1xuICBpZiAoYyA+PSA2NSAmJiBjIDw9IDkwKSAgcmV0dXJuIGMgLSA1NTtcbiAgaWYgKGMgPj0gOTcgJiYgYyA8PSAxMjIpIHJldHVybiBjIC0gODc7XG4gIHJldHVybiAtMTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnRfb2Zfc3RyaW5nIChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aCwgY2FtbF9zdHJpbmdfdW5zYWZlX2dldFxuLy9SZXF1aXJlczogY2FtbF9wYXJzZV9zaWduX2FuZF9iYXNlLCBjYW1sX3BhcnNlX2RpZ2l0LCBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2ludF9vZl9zdHJpbmcgKHMpIHtcbiAgdmFyIHIgPSBjYW1sX3BhcnNlX3NpZ25fYW5kX2Jhc2UgKHMpO1xuICB2YXIgaSA9IHJbMF0sIHNpZ24gPSByWzFdLCBiYXNlID0gclsyXTtcbiAgdmFyIGxlbiA9IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKTtcbiAgdmFyIHRocmVzaG9sZCA9IC0xID4+PiAwO1xuICB2YXIgYyA9IChpIDwgbGVuKT9jYW1sX3N0cmluZ191bnNhZmVfZ2V0KHMsIGkpOjA7XG4gIHZhciBkID0gY2FtbF9wYXJzZV9kaWdpdChjKTtcbiAgaWYgKGQgPCAwIHx8IGQgPj0gYmFzZSkgY2FtbF9mYWlsd2l0aChcImludF9vZl9zdHJpbmdcIik7XG4gIHZhciByZXMgPSBkO1xuICBmb3IgKGkrKztpPGxlbjtpKyspIHtcbiAgICBjID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldChzLCBpKTtcbiAgICBpZiAoYyA9PSA5NSkgY29udGludWU7XG4gICAgZCA9IGNhbWxfcGFyc2VfZGlnaXQoYyk7XG4gICAgaWYgKGQgPCAwIHx8IGQgPj0gYmFzZSkgYnJlYWs7XG4gICAgcmVzID0gYmFzZSAqIHJlcyArIGQ7XG4gICAgaWYgKHJlcyA+IHRocmVzaG9sZCkgY2FtbF9mYWlsd2l0aChcImludF9vZl9zdHJpbmdcIik7XG4gIH1cbiAgaWYgKGkgIT0gbGVuKSBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgLy8gRm9yIGJhc2UgZGlmZmVyZW50IGZyb20gMTAsIHdlIGV4cGVjdCBhbiB1bnNpZ25lZCByZXByZXNlbnRhdGlvbixcbiAgLy8gaGVuY2UgYW55IHZhbHVlIG9mICdyZXMnIChsZXNzIHRoYW4gJ3RocmVzaG9sZCcpIGlzIGFjY2VwdGFibGUuXG4gIC8vIEJ1dCB3ZSBoYXZlIHRvIGNvbnZlcnQgdGhlIHJlc3VsdCBiYWNrIHRvIGEgc2lnbmVkIGludGVnZXIuXG4gIHJlcyA9IHNpZ24gKiByZXM7XG4gIGlmICgoYmFzZSA9PSAxMCkgJiYgKChyZXMgfCAwKSAhPSByZXMpKVxuICAgIC8qIFNpZ25lZCByZXByZXNlbnRhdGlvbiBleHBlY3RlZCwgYWxsb3cgLTJeKG5iaXRzLTEpIHRvIDJeKG5iaXRzLTEpIC0gMSAqL1xuICAgIGNhbWxfZmFpbHdpdGgoXCJpbnRfb2Zfc3RyaW5nXCIpO1xuICByZXR1cm4gcmVzIHwgMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tdWwgY29uc3RcbmZ1bmN0aW9uIGNhbWxfbXVsKGEsYil7XG4gIHJldHVybiBNYXRoLmltdWwoYSxiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9kaXZcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2VfemVyb19kaXZpZGVcbmZ1bmN0aW9uIGNhbWxfZGl2KHgseSkge1xuICBpZiAoeSA9PSAwKSBjYW1sX3JhaXNlX3plcm9fZGl2aWRlICgpO1xuICByZXR1cm4gKHgveSl8MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tb2Rcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2VfemVyb19kaXZpZGVcbmZ1bmN0aW9uIGNhbWxfbW9kKHgseSkge1xuICBpZiAoeSA9PSAwKSBjYW1sX3JhaXNlX3plcm9fZGl2aWRlICgpO1xuICByZXR1cm4geCV5O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2Jzd2FwMTZcbmZ1bmN0aW9uIGNhbWxfYnN3YXAxNih4KSB7XG4gIHJldHVybiAoKCgoeCAmIDB4MDBGRikgPDwgOCkgfFxuICAgICAgICAgICAoKHggJiAweEZGMDApID4+IDgpKSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2ludDMyX2Jzd2FwXG5mdW5jdGlvbiBjYW1sX2ludDMyX2Jzd2FwKHgpIHtcbiAgcmV0dXJuICgoKHggJiAweDAwMDAwMEZGKSA8PCAyNCkgfFxuICAgICAgICAgICgoeCAmIDB4MDAwMEZGMDApIDw8IDgpIHxcbiAgICAgICAgICAoKHggJiAweDAwRkYwMDAwKSA+Pj4gOCkgfFxuICAgICAgICAgICgoeCAmIDB4RkYwMDAwMDApID4+PiAyNCkpO1xufVxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9ic3dhcFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF90b19ieXRlcywgY2FtbF9pbnQ2NF9vZl9ieXRlc1xuZnVuY3Rpb24gY2FtbF9pbnQ2NF9ic3dhcCh4KSB7XG4gIHZhciB5ID0gY2FtbF9pbnQ2NF90b19ieXRlcyh4KTtcbiAgcmV0dXJuIGNhbWxfaW50NjRfb2ZfYnl0ZXMoW3lbN10sIHlbNl0sIHlbNV0sIHlbNF0sIHlbM10sIHlbMl0sIHlbMV0sIHlbMF1dKTtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vLy8vLy8vLy8vLy8gSGFzaHRibFxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF91bml2X3BhcmFtIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfaXNfbWxfc3RyaW5nLCBjYW1sX2lzX21sX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX21sX2J5dGVzX2NvbnRlbnRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfdG9fYnl0ZXMsIGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCwgY2FtbF9jdXN0b21fb3BzXG4vL1JlcXVpcmVzOiBjYW1sX21sX2J5dGVzX2xlbmd0aCwgY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuLy9WZXJzaW9uOiA8IDQuMTJcbmZ1bmN0aW9uIGNhbWxfaGFzaF91bml2X3BhcmFtIChjb3VudCwgbGltaXQsIG9iaikge1xuICB2YXIgaGFzaF9hY2N1ID0gMDtcbiAgZnVuY3Rpb24gaGFzaF9hdXggKG9iaikge1xuICAgIGxpbWl0IC0tO1xuICAgIGlmIChjb3VudCA8IDAgfHwgbGltaXQgPCAwKSByZXR1cm47XG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIEFycmF5ICYmIG9ialswXSA9PT0gKG9ialswXXwwKSkge1xuICAgICAgc3dpdGNoIChvYmpbMF0pIHtcbiAgICAgIGNhc2UgMjQ4OlxuICAgICAgICAvLyBPYmplY3RcbiAgICAgICAgY291bnQgLS07XG4gICAgICAgIGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiA2NTU5OSArIG9ialsyXSkgfCAwO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjUwOlxuICAgICAgICAvLyBGb3J3YXJkXG4gICAgICAgIGxpbWl0Kys7IGhhc2hfYXV4KG9iaik7IGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY291bnQgLS07XG4gICAgICAgIGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiAxOSArIG9ialswXSkgfCAwO1xuICAgICAgICBmb3IgKHZhciBpID0gb2JqLmxlbmd0aCAtIDE7IGkgPiAwOyBpLS0pIGhhc2hfYXV4IChvYmpbaV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2FtbF9pc19tbF9ieXRlcyhvYmopKSB7XG4gICAgICBjb3VudCAtLTtcbiAgICAgIHZhciBjb250ZW50ID0gY2FtbF9tbF9ieXRlc19jb250ZW50KG9iaik7XG4gICAgICBpZih0eXBlb2YgY29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBmb3IgKHZhciBiID0gY29udGVudCwgbCA9IGIubGVuZ3RoLCBpID0gMDsgaSA8IGw7IGkrKylcbiAgICAgICAgICBoYXNoX2FjY3UgPSAoaGFzaF9hY2N1ICogMTkgKyBiLmNoYXJDb2RlQXQoaSkpIHwgMDtcbiAgICAgIH0gZWxzZSB7IC8qIEFSUkFZICovXG4gICAgICAgIGZvciAodmFyIGEgPSBjb250ZW50LCBsID0gYS5sZW5ndGgsIGkgPSAwOyBpIDwgbDsgaSsrKVxuICAgICAgICAgIGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiAxOSArIGFbaV0pIHwgMDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNhbWxfaXNfbWxfc3RyaW5nKG9iaikpIHtcbiAgICAgIHZhciBqc2J5dGVzID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhvYmopO1xuICAgICAgZm9yICh2YXIgYiA9IGpzYnl0ZXMsIGwgPSBqc2J5dGVzLmxlbmd0aCwgaSA9IDA7IGkgPCBsOyBpKyspXG4gICAgICAgIGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiAxOSArIGIuY2hhckNvZGVBdChpKSkgfCAwO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgZm9yICh2YXIgYiA9IG9iaiwgbCA9IG9iai5sZW5ndGgsIGkgPSAwOyBpIDwgbDsgaSsrKVxuICAgICAgICBoYXNoX2FjY3UgPSAoaGFzaF9hY2N1ICogMTkgKyBiLmNoYXJDb2RlQXQoaSkpIHwgMDtcbiAgICB9IGVsc2UgaWYgKG9iaiA9PT0gKG9ianwwKSkge1xuICAgICAgLy8gSW50ZWdlclxuICAgICAgY291bnQgLS07XG4gICAgICBoYXNoX2FjY3UgPSAoaGFzaF9hY2N1ICogNjU1OTkgKyBvYmopIHwgMDtcbiAgICB9IGVsc2UgaWYgKG9iaiA9PT0gK29iaikge1xuICAgICAgLy8gRmxvYXRcbiAgICAgIGNvdW50LS07XG4gICAgICB2YXIgcCA9IGNhbWxfaW50NjRfdG9fYnl0ZXMgKGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCAob2JqKSk7XG4gICAgICBmb3IgKHZhciBpID0gNzsgaSA+PSAwOyBpLS0pIGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiAxOSArIHBbaV0pIHwgMDtcbiAgICB9IGVsc2UgaWYob2JqICYmIG9iai5jYW1sX2N1c3RvbSkge1xuICAgICAgaWYoY2FtbF9jdXN0b21fb3BzW29iai5jYW1sX2N1c3RvbV0gJiYgY2FtbF9jdXN0b21fb3BzW29iai5jYW1sX2N1c3RvbV0uaGFzaCkge1xuICAgICAgICB2YXIgaCA9IGNhbWxfY3VzdG9tX29wc1tvYmouY2FtbF9jdXN0b21dLmhhc2gob2JqKSB8IDA7XG4gICAgICAgIGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiA2NTU5OSArIGgpIHwgMDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaGFzaF9hdXggKG9iaik7XG4gIHJldHVybiBoYXNoX2FjY3UgJiAweDNGRkZGRkZGO1xufVxuXG4vL2Z1bmN0aW9uIFJPVEwzMih4LG4pIHsgcmV0dXJuICgoeCA8PCBuKSB8ICh4ID4+PiAoMzItbikpKTsgfVxuLy9Qcm92aWRlczogY2FtbF9oYXNoX21peF9pbnRcbi8vUmVxdWlyZXM6IGNhbWxfbXVsXG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X2ludChoLGQpIHtcbiAgZCA9IGNhbWxfbXVsKGQsIDB4Y2M5ZTJkNTF8MCk7XG4gIGQgPSAoKGQgPDwgMTUpIHwgKGQgPj4+ICgzMi0xNSkpKTsgLy8gUk9UTDMyKGQsIDE1KTtcbiAgZCA9IGNhbWxfbXVsKGQsIDB4MWI4NzM1OTMpO1xuICBoIF49IGQ7XG4gIGggPSAoKGggPDwgMTMpIHwgKGggPj4+ICgzMi0xMykpKTsgICAvL1JPVEwzMihoLCAxMyk7XG4gIHJldHVybiAoKChoICsgKGggPDwgMikpfDApICsgKDB4ZTY1NDZiNjR8MCkpfDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfZmluYWxcbi8vUmVxdWlyZXM6IGNhbWxfbXVsXG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X2ZpbmFsKGgpIHtcbiAgaCBePSBoID4+PiAxNjtcbiAgaCA9IGNhbWxfbXVsIChoLCAweDg1ZWJjYTZifDApO1xuICBoIF49IGggPj4+IDEzO1xuICBoID0gY2FtbF9tdWwgKGgsIDB4YzJiMmFlMzV8MCk7XG4gIGggXj0gaCA+Pj4gMTY7XG4gIHJldHVybiBoO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbWl4X2Zsb2F0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQsIGNhbWxfaGFzaF9taXhfaW50NjRcbmZ1bmN0aW9uIGNhbWxfaGFzaF9taXhfZmxvYXQgKGgsIHYwKSB7XG4gIHJldHVybiBjYW1sX2hhc2hfbWl4X2ludDY0KGgsIGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCAodjApKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfaW50NjRcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfaW50XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2xvMzIsIGNhbWxfaW50NjRfaGkzMlxuZnVuY3Rpb24gY2FtbF9oYXNoX21peF9pbnQ2NCAoaCwgdikge1xuICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgY2FtbF9pbnQ2NF9sbzMyKHYpKTtcbiAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIGNhbWxfaW50NjRfaGkzMih2KSk7XG4gIHJldHVybiBoO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbWl4X2pzYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfaW50XG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X2pzYnl0ZXMoaCwgcykge1xuICB2YXIgbGVuID0gcy5sZW5ndGgsIGksIHc7XG4gIGZvciAoaSA9IDA7IGkgKyA0IDw9IGxlbjsgaSArPSA0KSB7XG4gICAgdyA9IHMuY2hhckNvZGVBdChpKVxuICAgICAgfCAocy5jaGFyQ29kZUF0KGkrMSkgPDwgOClcbiAgICAgIHwgKHMuY2hhckNvZGVBdChpKzIpIDw8IDE2KVxuICAgICAgfCAocy5jaGFyQ29kZUF0KGkrMykgPDwgMjQpO1xuICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCB3KTtcbiAgfVxuICB3ID0gMDtcbiAgc3dpdGNoIChsZW4gJiAzKSB7XG4gIGNhc2UgMzogdyAgPSBzLmNoYXJDb2RlQXQoaSsyKSA8PCAxNjtcbiAgY2FzZSAyOiB3IHw9IHMuY2hhckNvZGVBdChpKzEpIDw8IDg7XG4gIGNhc2UgMTpcbiAgICB3IHw9IHMuY2hhckNvZGVBdChpKTtcbiAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgdyk7XG4gIGRlZmF1bHQ6XG4gIH1cbiAgaCBePSBsZW47XG4gIHJldHVybiBoO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbWl4X2J5dGVzX2FyclxuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9pbnRcbmZ1bmN0aW9uIGNhbWxfaGFzaF9taXhfYnl0ZXNfYXJyKGgsIHMpIHtcbiAgdmFyIGxlbiA9IHMubGVuZ3RoLCBpLCB3O1xuICBmb3IgKGkgPSAwOyBpICsgNCA8PSBsZW47IGkgKz0gNCkge1xuICAgIHcgPSBzW2ldXG4gICAgICB8IChzW2krMV0gPDwgOClcbiAgICAgIHwgKHNbaSsyXSA8PCAxNilcbiAgICAgIHwgKHNbaSszXSA8PCAyNCk7XG4gICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHcpO1xuICB9XG4gIHcgPSAwO1xuICBzd2l0Y2ggKGxlbiAmIDMpIHtcbiAgY2FzZSAzOiB3ICA9IHNbaSsyXSA8PCAxNjtcbiAgY2FzZSAyOiB3IHw9IHNbaSsxXSA8PCA4O1xuICBjYXNlIDE6IHcgfD0gc1tpXTtcbiAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgdyk7XG4gIGRlZmF1bHQ6XG4gIH1cbiAgaCBePSBsZW47XG4gIHJldHVybiBoO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbWl4X2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX21sX2J5dGVzX2NvbnRlbnRcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfanNieXRlc1xuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9ieXRlc19hcnJcbmZ1bmN0aW9uIGNhbWxfaGFzaF9taXhfYnl0ZXMoaCwgdikge1xuICB2YXIgY29udGVudCA9IGNhbWxfbWxfYnl0ZXNfY29udGVudCh2KTtcbiAgaWYodHlwZW9mIGNvbnRlbnQgPT09IFwic3RyaW5nXCIpXG4gICAgcmV0dXJuIGNhbWxfaGFzaF9taXhfanNieXRlcyhoLCBjb250ZW50KVxuICBlbHNlIC8qIEFSUkFZICovXG4gICAgcmV0dXJuIGNhbWxfaGFzaF9taXhfYnl0ZXNfYXJyKGgsIGNvbnRlbnQpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbWl4X3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9qc2J5dGVzLCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X3N0cmluZyhoLCB2KSB7XG4gIHJldHVybiBjYW1sX2hhc2hfbWl4X2pzYnl0ZXMoaCwgY2FtbF9qc2J5dGVzX29mX3N0cmluZyh2KSk7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9oYXNoIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfaXNfbWxfc3RyaW5nLCBjYW1sX2lzX21sX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2ludCwgY2FtbF9oYXNoX21peF9maW5hbFxuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9mbG9hdCwgY2FtbF9oYXNoX21peF9zdHJpbmcsIGNhbWxfaGFzaF9taXhfYnl0ZXMsIGNhbWxfY3VzdG9tX29wc1xuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9qc2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2lzX2NvbnRpbnVhdGlvbl90YWdcbmZ1bmN0aW9uIGNhbWxfaGFzaCAoY291bnQsIGxpbWl0LCBzZWVkLCBvYmopIHtcbiAgdmFyIHF1ZXVlLCByZCwgd3IsIHN6LCBudW0sIGgsIHYsIGksIGxlbjtcbiAgc3ogPSBsaW1pdDtcbiAgaWYgKHN6IDwgMCB8fCBzeiA+IDI1Nikgc3ogPSAyNTY7XG4gIG51bSA9IGNvdW50O1xuICBoID0gc2VlZDtcbiAgcXVldWUgPSBbb2JqXTsgcmQgPSAwOyB3ciA9IDE7XG4gIHdoaWxlIChyZCA8IHdyICYmIG51bSA+IDApIHtcbiAgICB2ID0gcXVldWVbcmQrK107XG4gICAgaWYgKHYgJiYgdi5jYW1sX2N1c3RvbSl7XG4gICAgICBpZihjYW1sX2N1c3RvbV9vcHNbdi5jYW1sX2N1c3RvbV0gJiYgY2FtbF9jdXN0b21fb3BzW3YuY2FtbF9jdXN0b21dLmhhc2gpIHtcbiAgICAgICAgdmFyIGhoID0gY2FtbF9jdXN0b21fb3BzW3YuY2FtbF9jdXN0b21dLmhhc2godik7XG4gICAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludCAoaCwgaGgpO1xuICAgICAgICBudW0gLS07XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHYgaW5zdGFuY2VvZiBBcnJheSAmJiB2WzBdID09PSAodlswXXwwKSkge1xuICAgICAgc3dpdGNoICh2WzBdKSB7XG4gICAgICBjYXNlIDI0ODpcbiAgICAgICAgLy8gT2JqZWN0XG4gICAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCB2WzJdKTtcbiAgICAgICAgbnVtLS07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNTA6XG4gICAgICAgIC8vIEZvcndhcmRcbiAgICAgICAgcXVldWVbLS1yZF0gPSB2WzFdO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmKGNhbWxfaXNfY29udGludWF0aW9uX3RhZyh2WzBdKSkge1xuICAgICAgICAgIC8qIEFsbCBjb250aW51YXRpb25zIGhhc2ggdG8gdGhlIHNhbWUgdmFsdWUsXG4gICAgICAgICAgICAgc2luY2Ugd2UgaGF2ZSBubyBpZGVhIGhvdyB0byBkaXN0aW5ndWlzaCB0aGVtLiAqL1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0YWcgPSAoKHYubGVuZ3RoIC0gMSkgPDwgMTApIHwgdlswXTtcbiAgICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHRhZyk7XG4gICAgICAgIGZvciAoaSA9IDEsIGxlbiA9IHYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBpZiAod3IgPj0gc3opIGJyZWFrO1xuICAgICAgICAgIHF1ZXVlW3dyKytdID0gdltpXTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNhbWxfaXNfbWxfYnl0ZXModikpIHtcbiAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2J5dGVzKGgsdilcbiAgICAgIG51bS0tO1xuICAgIH0gZWxzZSBpZiAoY2FtbF9pc19tbF9zdHJpbmcodikpIHtcbiAgICAgIGggPSBjYW1sX2hhc2hfbWl4X3N0cmluZyhoLHYpXG4gICAgICBudW0tLTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBoID0gY2FtbF9oYXNoX21peF9qc2J5dGVzKGgsdilcbiAgICAgIG51bS0tO1xuICAgIH0gZWxzZSBpZiAodiA9PT0gKHZ8MCkpIHtcbiAgICAgIC8vIEludGVnZXJcbiAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCB2K3YrMSk7XG4gICAgICBudW0tLTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAvLyBGbG9hdFxuICAgICAgaCA9IGNhbWxfaGFzaF9taXhfZmxvYXQoaCx2KTtcbiAgICAgIG51bS0tO1xuICAgIH1cbiAgfVxuICBoID0gY2FtbF9oYXNoX21peF9maW5hbChoKTtcbiAgcmV0dXJuIGggJiAweDNGRkZGRkZGO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19oYXNoXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2ZpbmFsLCBjYW1sX2hhc2hfbWl4X3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfaGFzaChoLCB2KXtcbiAgdmFyIGggPSBjYW1sX2hhc2hfbWl4X3N0cmluZyhoLHYpO1xuICB2YXIgaCA9IGNhbWxfaGFzaF9taXhfZmluYWwoaCk7XG4gIHJldHVybiBoICYgMHgzRkZGRkZGRjtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxNCBKw6lyw7RtZSBWb3VpbGxvbiwgSHVnbyBIZXV6YXJkXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vLy8vLy8vLy8vLy8gSW9cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfZmRzXG52YXIgY2FtbF9zeXNfZmRzID0gbmV3IEFycmF5KDMpO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jbG9zZVxuLy9SZXF1aXJlczogY2FtbF9zeXNfZmRzXG5mdW5jdGlvbiBjYW1sX3N5c19jbG9zZShmZCkge1xuICB2YXIgZmlsZSA9IGNhbWxfc3lzX2Zkc1tmZF07XG4gIGlmKGZpbGUpIGZpbGUuY2xvc2UoKTtcbiAgZGVsZXRlIGNhbWxfc3lzX2Zkc1tmZF07XG4gIHJldHVybiAwO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX29wZW5cbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfc3lzX2Vycm9yXG4vL1JlcXVpcmVzOiBNbEZha2VGZF9vdXRcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlXG4vL1JlcXVpcmVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG4vL1JlcXVpcmVzOiBmc19ub2RlX3N1cHBvcnRlZFxuLy9SZXF1aXJlczogY2FtbF9zeXNfZmRzXG4vL1JlcXVpcmVzOiBjYW1sX3N5c19vcGVuX2Zvcl9ub2RlXG5mdW5jdGlvbiBjYW1sX3N5c19vcGVuX2ludGVybmFsKGZpbGUsaWR4KSB7XG4gIGlmKGlkeCA9PSB1bmRlZmluZWQpe1xuICAgIGlkeCA9IGNhbWxfc3lzX2Zkcy5sZW5ndGg7XG4gIH1cbiAgY2FtbF9zeXNfZmRzW2lkeF0gPSBmaWxlO1xuICByZXR1cm4gaWR4IHwgMDtcbn1cbmZ1bmN0aW9uIGNhbWxfc3lzX29wZW4gKG5hbWUsIGZsYWdzLCBfcGVybXMpIHtcbiAgdmFyIGYgPSB7fTtcbiAgd2hpbGUoZmxhZ3Mpe1xuICAgIHN3aXRjaChmbGFnc1sxXSl7XG4gICAgY2FzZSAwOiBmLnJkb25seSA9IDE7YnJlYWs7XG4gICAgY2FzZSAxOiBmLndyb25seSA9IDE7YnJlYWs7XG4gICAgY2FzZSAyOiBmLmFwcGVuZCA9IDE7YnJlYWs7XG4gICAgY2FzZSAzOiBmLmNyZWF0ZSA9IDE7YnJlYWs7XG4gICAgY2FzZSA0OiBmLnRydW5jYXRlID0gMTticmVhaztcbiAgICBjYXNlIDU6IGYuZXhjbCA9IDE7IGJyZWFrO1xuICAgIGNhc2UgNjogZi5iaW5hcnkgPSAxO2JyZWFrO1xuICAgIGNhc2UgNzogZi50ZXh0ID0gMTticmVhaztcbiAgICBjYXNlIDg6IGYubm9uYmxvY2sgPSAxO2JyZWFrO1xuICAgIH1cbiAgICBmbGFncz1mbGFnc1syXTtcbiAgfVxuICBpZihmLnJkb25seSAmJiBmLndyb25seSlcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKG5hbWUpICsgXCIgOiBmbGFncyBPcGVuX3Jkb25seSBhbmQgT3Blbl93cm9ubHkgYXJlIG5vdCBjb21wYXRpYmxlXCIpO1xuICBpZihmLnRleHQgJiYgZi5iaW5hcnkpXG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoY2FtbF9qc2J5dGVzX29mX3N0cmluZyhuYW1lKSArIFwiIDogZmxhZ3MgT3Blbl90ZXh0IGFuZCBPcGVuX2JpbmFyeSBhcmUgbm90IGNvbXBhdGlibGVcIik7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIHZhciBmaWxlID0gcm9vdC5kZXZpY2Uub3Blbihyb290LnJlc3QsZik7XG4gIHJldHVybiBjYW1sX3N5c19vcGVuX2ludGVybmFsIChmaWxlLCB1bmRlZmluZWQpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gZmlsZShmZCwgZmxhZ3MpIHtcbiAgICBpZihmc19ub2RlX3N1cHBvcnRlZCgpKSB7XG4gICAgICByZXR1cm4gY2FtbF9zeXNfb3Blbl9mb3Jfbm9kZShmZCwgZmxhZ3MpO1xuICAgIH1cbiAgICBlbHNlXG4gICAgICByZXR1cm4gbmV3IE1sRmFrZUZkX291dChmZCwgZmxhZ3MpXG4gIH1cbiAgY2FtbF9zeXNfb3Blbl9pbnRlcm5hbChmaWxlKDAse3Jkb25seToxLGFsdG5hbWU6XCIvZGV2L3N0ZGluXCIsaXNDaGFyYWN0ZXJEZXZpY2U6dHJ1ZX0pLCAwKTtcbiAgY2FtbF9zeXNfb3Blbl9pbnRlcm5hbChmaWxlKDEse2J1ZmZlcmVkOjIsd3Jvbmx5OjEsaXNDaGFyYWN0ZXJEZXZpY2U6dHJ1ZX0pLCAxKTtcbiAgY2FtbF9zeXNfb3Blbl9pbnRlcm5hbChmaWxlKDIse2J1ZmZlcmVkOjIsd3Jvbmx5OjEsaXNDaGFyYWN0ZXJEZXZpY2U6dHJ1ZX0pLCAyKTtcbn0pKClcblxuXG4vLyBvY2FtbCBDaGFubmVsc1xuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3NldF9jaGFubmVsX25hbWVcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbF9nZXRcbmZ1bmN0aW9uIGNhbWxfbWxfc2V0X2NoYW5uZWxfbmFtZShjaGFuaWQsIG5hbWUpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxfZ2V0KGNoYW5pZCk7XG4gIGNoYW4ubmFtZSA9IG5hbWU7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2NoYW5uZWxzXG52YXIgY2FtbF9tbF9jaGFubmVscyA9IG5ldyBBcnJheSgpO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2NoYW5uZWxfcmVkaXJlY3Rcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbF9nZXQsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfY2hhbm5lbF9yZWRpcmVjdCAoY2FwdHVyZWQsIGludG8pe1xuICB2YXIgdG9fcmVzdG9yZSA9IGNhbWxfbWxfY2hhbm5lbF9nZXQoY2FwdHVyZWQpO1xuICB2YXIgbmV3XyA9IGNhbWxfbWxfY2hhbm5lbF9nZXQoaW50byk7XG4gIGNhbWxfbWxfY2hhbm5lbHNbY2FwdHVyZWRdID0gbmV3XzsgLy8gWFhYXG4gIHJldHVybiB0b19yZXN0b3JlO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2NoYW5uZWxfcmVzdG9yZVxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9jaGFubmVsX3Jlc3RvcmUgKGNhcHR1cmVkLCB0b19yZXN0b3JlKXtcbiAgY2FtbF9tbF9jaGFubmVsc1tjYXB0dXJlZF0gPSB0b19yZXN0b3JlOyAvLyBYWFhcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfY2hhbm5lbF9nZXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfY2hhbm5lbF9nZXQoaWQpIHtcbiAgcmV0dXJuIGNhbWxfbWxfY2hhbm5lbHNbaWRdOyAvLyBYWFhcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9vdXRfY2hhbm5lbHNfbGlzdFxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9vdXRfY2hhbm5lbHNfbGlzdCAoKSB7XG4gIHZhciBsID0gMDtcbiAgZm9yKHZhciBjID0gMDsgYyA8IGNhbWxfbWxfY2hhbm5lbHMubGVuZ3RoOyBjKyspe1xuICAgIGlmKGNhbWxfbWxfY2hhbm5lbHNbY10gJiYgY2FtbF9tbF9jaGFubmVsc1tjXS5vcGVuZWQgJiYgY2FtbF9tbF9jaGFubmVsc1tjXS5vdXQpXG4gICAgICBsPVswLGNhbWxfbWxfY2hhbm5lbHNbY10uZmQsbF07XG4gIH1cbiAgcmV0dXJuIGw7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3Jfb3V0XG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxzLCBjYW1sX3N5c19mZHNcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfc3lzX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX3N5c19vcGVuXG5mdW5jdGlvbiBjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9vdXQgKGZkKSB7XG4gIHZhciBmaWxlID0gY2FtbF9zeXNfZmRzW2ZkXTtcbiAgaWYoZmlsZS5mbGFncy5yZG9ubHkpIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKFwiZmQgXCIrIGZkICsgXCIgaXMgcmVhZG9ubHlcIik7XG4gIHZhciBidWZmZXJlZCA9IChmaWxlLmZsYWdzLmJ1ZmZlcmVkICE9PSB1bmRlZmluZWQpID8gZmlsZS5mbGFncy5idWZmZXJlZCA6IDE7XG4gIHZhciBjaGFubmVsID0ge1xuICAgIGZpbGU6ZmlsZSxcbiAgICBvZmZzZXQ6ZmlsZS5mbGFncy5hcHBlbmQ/ZmlsZS5sZW5ndGgoKTowLFxuICAgIGZkOmZkLFxuICAgIG9wZW5lZDp0cnVlLFxuICAgIG91dDp0cnVlLFxuICAgIGJ1ZmZlcl9jdXJyOjAsXG4gICAgYnVmZmVyOm5ldyBVaW50OEFycmF5KDY1NTM2KSxcbiAgICBidWZmZXJlZDpidWZmZXJlZFxuICB9O1xuICBjYW1sX21sX2NoYW5uZWxzW2NoYW5uZWwuZmRdPWNoYW5uZWw7XG4gIHJldHVybiBjaGFubmVsLmZkO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9pblxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVscywgY2FtbF9zeXNfZmRzXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3N5c19lcnJvclxuLy9SZXF1aXJlczogY2FtbF9zeXNfb3BlblxuZnVuY3Rpb24gY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3JfaW4gKGZkKSAge1xuICB2YXIgZmlsZSA9IGNhbWxfc3lzX2Zkc1tmZF07XG4gIGlmKGZpbGUuZmxhZ3Mud3Jvbmx5KSBjYW1sX3JhaXNlX3N5c19lcnJvcihcImZkIFwiKyBmZCArIFwiIGlzIHdyaXRlb25seVwiKTtcbiAgdmFyIHJlZmlsbCA9IG51bGw7XG4gIHZhciBjaGFubmVsID0ge1xuICAgIGZpbGU6ZmlsZSxcbiAgICBvZmZzZXQ6ZmlsZS5mbGFncy5hcHBlbmQ/ZmlsZS5sZW5ndGgoKTowLFxuICAgIGZkOmZkLFxuICAgIG9wZW5lZDp0cnVlLFxuICAgIG91dDogZmFsc2UsXG4gICAgYnVmZmVyX2N1cnI6MCxcbiAgICBidWZmZXJfbWF4OjAsXG4gICAgYnVmZmVyOm5ldyBVaW50OEFycmF5KDY1NTM2KSxcbiAgICByZWZpbGw6cmVmaWxsXG4gIH07XG4gIGNhbWxfbWxfY2hhbm5lbHNbY2hhbm5lbC5mZF09Y2hhbm5lbDtcbiAgcmV0dXJuIGNoYW5uZWwuZmQ7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3JfaW5fd2l0aF9mbGFnc1xuLy9SZXF1aXJlczogY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3JfaW5cbi8vVmVyc2lvbjogPj0gNS4xXG5mdW5jdGlvbiBjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9pbl93aXRoX2ZsYWdzKGZkLCBmbGFncyl7XG4gIHJldHVybiBjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9pbihmZCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX291dF93aXRoX2ZsYWdzXG4vL1JlcXVpcmVzOiBjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9vdXRcbi8vVmVyc2lvbjogPj0gNS4xXG5mdW5jdGlvbiBjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9vdXRfd2l0aF9mbGFncyhmZCwgZmxhZ3Mpe1xuICByZXR1cm4gY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3Jfb3V0KGZkKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jaGFubmVsX2Rlc2NyaXB0b3Jcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbF9nZXRcbi8vQWxpYXM6IHdpbl9maWxlZGVzY3Jfb2ZfY2hhbm5lbFxuZnVuY3Rpb24gY2FtbF9jaGFubmVsX2Rlc2NyaXB0b3IoY2hhbmlkKXtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxfZ2V0KGNoYW5pZCk7XG4gIHJldHVybiBjaGFuLmZkO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3NldF9iaW5hcnlfbW9kZVxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVsX2dldFxuZnVuY3Rpb24gY2FtbF9tbF9zZXRfYmluYXJ5X21vZGUoY2hhbmlkLG1vZGUpe1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbF9nZXQoY2hhbmlkKTtcbiAgY2hhbi5maWxlLmZsYWdzLnRleHQgPSAhbW9kZVxuICBjaGFuLmZpbGUuZmxhZ3MuYmluYXJ5ID0gbW9kZVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9pc19iaW5hcnlfbW9kZVxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVsX2dldFxuLy9WZXJzaW9uOiA+PSA1LjJcbmZ1bmN0aW9uIGNhbWxfbWxfaXNfYmluYXJ5X21vZGUoY2hhbmlkKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsX2dldChjaGFuaWQpO1xuICByZXR1cm4gY2hhbi5maWxlLmZsYWdzLmJpbmFyeVxufVxuXG4vL0lucHV0IGZyb20gaW5fY2hhbm5lbFxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2Nsb3NlX2NoYW5uZWxcbi8vUmVxdWlyZXM6IGNhbWxfbWxfZmx1c2gsIGNhbWxfbWxfY2hhbm5lbF9nZXRcbi8vUmVxdWlyZXM6IGNhbWxfc3lzX2Nsb3NlXG5mdW5jdGlvbiBjYW1sX21sX2Nsb3NlX2NoYW5uZWwgKGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbF9nZXQoY2hhbmlkKTtcbiAgaWYoY2hhbi5vcGVuZWQpIHtcbiAgICBjaGFuLm9wZW5lZCA9IGZhbHNlO1xuICAgIGNhbWxfc3lzX2Nsb3NlKGNoYW4uZmQpO1xuICAgIGNoYW4uZmQgPSAtMTtcbiAgICBjaGFuLmJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KDApO1xuICAgIGNoYW4uYnVmZmVyX2N1cnIgPSAwO1xuICAgIGNoYW4uYnVmZmVyX21heCA9IDA7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfY2hhbm5lbF9zaXplXG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxfZ2V0XG5mdW5jdGlvbiBjYW1sX21sX2NoYW5uZWxfc2l6ZShjaGFuaWQpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxfZ2V0KGNoYW5pZCk7XG4gIHJldHVybiBjaGFuLmZpbGUubGVuZ3RoKCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfY2hhbm5lbF9zaXplXzY0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2Zsb2F0LGNhbWxfbWxfY2hhbm5lbF9nZXRcbmZ1bmN0aW9uIGNhbWxfbWxfY2hhbm5lbF9zaXplXzY0KGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbF9nZXQoY2hhbmlkKTtcbiAgcmV0dXJuIGNhbWxfaW50NjRfb2ZfZmxvYXQoY2hhbi5maWxlLmxlbmd0aCAoKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2V0X2NoYW5uZWxfb3V0cHV0XG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxfZ2V0XG5mdW5jdGlvbiBjYW1sX21sX3NldF9jaGFubmVsX291dHB1dChjaGFuaWQsZikge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbF9nZXQoY2hhbmlkKTtcbiAgY2hhbi5vdXRwdXQgPSAoZnVuY3Rpb24gKHMpIHtmKHMpfSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3NldF9jaGFubmVsX3JlZmlsbFxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVsX2dldFxuZnVuY3Rpb24gY2FtbF9tbF9zZXRfY2hhbm5lbF9yZWZpbGwoY2hhbmlkLGYpIHtcbiAgY2FtbF9tbF9jaGFubmVsX2dldChjaGFuaWQpLnJlZmlsbCA9IGY7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JlZmlsbFxuLy9SZXF1aXJlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoLCBjYW1sX3VpbnQ4X2FycmF5X29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9yZWZpbGwgKGNoYW4pIHtcbiAgaWYoY2hhbi5yZWZpbGwgIT0gbnVsbCl7XG4gICAgdmFyIHN0ciA9IGNoYW4ucmVmaWxsKCk7XG4gICAgdmFyIHN0cl9hID0gY2FtbF91aW50OF9hcnJheV9vZl9zdHJpbmcoc3RyKTtcbiAgICBpZiAoc3RyX2EubGVuZ3RoID09IDApIHtcbiAgICAgIGNoYW4ucmVmaWxsID0gbnVsbFxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmKGNoYW4uYnVmZmVyLmxlbmd0aCA8IGNoYW4uYnVmZmVyX21heCArIHN0cl9hLmxlbmd0aCl7XG4gICAgICAgIHZhciBiID0gbmV3IFVpbnQ4QXJyYXkoY2hhbi5idWZmZXJfbWF4ICsgc3RyX2EubGVuZ3RoKTtcbiAgICAgICAgYi5zZXQoY2hhbi5idWZmZXIpO1xuICAgICAgICBjaGFuLmJ1ZmZlciA9IGI7XG4gICAgICB9XG4gICAgICBjaGFuLmJ1ZmZlci5zZXQoc3RyX2EsY2hhbi5idWZmZXJfbWF4KTtcbiAgICAgIGNoYW4ub2Zmc2V0ICs9IHN0cl9hLmxlbmd0aDtcbiAgICAgIGNoYW4uYnVmZmVyX21heCArPSBzdHJfYS5sZW5ndGg7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBucmVhZCA9IGNoYW4uZmlsZS5yZWFkKGNoYW4ub2Zmc2V0LCBjaGFuLmJ1ZmZlciwgY2hhbi5idWZmZXJfbWF4LCBjaGFuLmJ1ZmZlci5sZW5ndGggLSBjaGFuLmJ1ZmZlcl9tYXgpO1xuICAgIGNoYW4ub2Zmc2V0ICs9IG5yZWFkO1xuICAgIGNoYW4uYnVmZmVyX21heCArPSBucmVhZDtcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2lucHV0XG4vL1JlcXVpcmVzOiBjYW1sX21sX2lucHV0X2Jsb2NrXG4vL1JlcXVpcmVzOiBjYW1sX3VpbnQ4X2FycmF5X29mX2J5dGVzXG5mdW5jdGlvbiBjYW1sX21sX2lucHV0IChjaGFuaWQsIGIsIGksIGwpIHtcbiAgdmFyIGJhID0gY2FtbF91aW50OF9hcnJheV9vZl9ieXRlcyhiKTtcbiAgcmV0dXJuIGNhbWxfbWxfaW5wdXRfYmxvY2soY2hhbmlkLCBiYSwgaSwgbClcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9pbnB1dF9iaWdhcnJheVxuLy9SZXF1aXJlczogY2FtbF9tbF9pbnB1dF9ibG9ja1xuLy9SZXF1aXJlczogY2FtbF9iYV90b190eXBlZF9hcnJheVxuZnVuY3Rpb24gY2FtbF9tbF9pbnB1dF9iaWdhcnJheSAoY2hhbmlkLCBiLCBpLCBsKSB7XG4gIHZhciBiYSA9IGNhbWxfYmFfdG9fdHlwZWRfYXJyYXkoYik7XG4gIHJldHVybiBjYW1sX21sX2lucHV0X2Jsb2NrKGNoYW5pZCwgYmEsIGksIGwpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfaW5wdXRfYmxvY2tcbi8vUmVxdWlyZXM6IGNhbWxfcmVmaWxsLCBjYW1sX21sX2NoYW5uZWxfZ2V0XG5mdW5jdGlvbiBjYW1sX21sX2lucHV0X2Jsb2NrIChjaGFuaWQsIGJhLCBpLCBsKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsX2dldChjaGFuaWQpO1xuICB2YXIgbiA9IGw7XG4gIHZhciBhdmFpbCA9IGNoYW4uYnVmZmVyX21heCAtIGNoYW4uYnVmZmVyX2N1cnI7XG4gIGlmKGwgPD0gYXZhaWwpIHtcbiAgICBiYS5zZXQoY2hhbi5idWZmZXIuc3ViYXJyYXkoY2hhbi5idWZmZXJfY3VycixjaGFuLmJ1ZmZlcl9jdXJyICsgbCksIGkpO1xuICAgIGNoYW4uYnVmZmVyX2N1cnIgKz0gbDtcbiAgfVxuICBlbHNlIGlmKGF2YWlsID4gMCkge1xuICAgIGJhLnNldChjaGFuLmJ1ZmZlci5zdWJhcnJheShjaGFuLmJ1ZmZlcl9jdXJyLGNoYW4uYnVmZmVyX2N1cnIgKyBhdmFpbCksIGkpO1xuICAgIGNoYW4uYnVmZmVyX2N1cnIgKz0gYXZhaWw7XG4gICAgbiA9IGF2YWlsO1xuICB9IGVsc2Uge1xuICAgIGNoYW4uYnVmZmVyX2N1cnIgPSAwO1xuICAgIGNoYW4uYnVmZmVyX21heCA9IDA7XG4gICAgY2FtbF9yZWZpbGwoY2hhbik7XG4gICAgdmFyIGF2YWlsID0gY2hhbi5idWZmZXJfbWF4IC0gY2hhbi5idWZmZXJfY3VycjtcbiAgICBpZihuID4gYXZhaWwpIG4gPSBhdmFpbDtcbiAgICBiYS5zZXQoY2hhbi5idWZmZXIuc3ViYXJyYXkoY2hhbi5idWZmZXJfY3VycixjaGFuLmJ1ZmZlcl9jdXJyICsgbiksIGkpO1xuICAgIGNoYW4uYnVmZmVyX2N1cnIgKz0gbjtcbiAgfVxuICByZXR1cm4gbiB8IDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW5wdXRfdmFsdWVcbi8vUmVxdWlyZXM6IGNhbWxfbWFyc2hhbF9kYXRhX3NpemUsIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9ieXRlcywgY2FtbF9jcmVhdGVfYnl0ZXMsIGNhbWxfbWxfY2hhbm5lbF9nZXQsIGNhbWxfYnl0ZXNfb2ZfYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfcmVmaWxsLCBjYW1sX2ZhaWx3aXRoLCBjYW1sX3JhaXNlX2VuZF9vZl9maWxlXG4vL1JlcXVpcmVzOiBjYW1sX21hcnNoYWxfaGVhZGVyX3NpemVcbmZ1bmN0aW9uIGNhbWxfaW5wdXRfdmFsdWUgKGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbF9nZXQoY2hhbmlkKTtcbiAgdmFyIGhlYWRlciA9IG5ldyBVaW50OEFycmF5KGNhbWxfbWFyc2hhbF9oZWFkZXJfc2l6ZSk7XG4gIGZ1bmN0aW9uIGJsb2NrKGJ1ZmZlciwgb2Zmc2V0LCBuKSB7XG4gICAgdmFyIHIgPSAwO1xuICAgIHdoaWxlKHIgPCBuKXtcbiAgICAgIGlmKGNoYW4uYnVmZmVyX2N1cnIgPj0gY2hhbi5idWZmZXJfbWF4KXtcbiAgICAgICAgY2hhbi5idWZmZXJfY3VyciA9IDA7XG4gICAgICAgIGNoYW4uYnVmZmVyX21heCA9IDA7XG4gICAgICAgIGNhbWxfcmVmaWxsKGNoYW4pO1xuICAgICAgfVxuICAgICAgaWYgKGNoYW4uYnVmZmVyX2N1cnIgPj0gY2hhbi5idWZmZXJfbWF4KVxuICAgICAgICBicmVhaztcbiAgICAgIGJ1ZmZlcltvZmZzZXQrcl0gPSBjaGFuLmJ1ZmZlcltjaGFuLmJ1ZmZlcl9jdXJyXTtcbiAgICAgIGNoYW4uYnVmZmVyX2N1cnIrKztcbiAgICAgIHIrKztcbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH1cbiAgdmFyIHIgPSBibG9jayhoZWFkZXIsIDAsIGNhbWxfbWFyc2hhbF9oZWFkZXJfc2l6ZSk7XG4gIGlmKHIgPT0gMClcbiAgICBjYW1sX3JhaXNlX2VuZF9vZl9maWxlKCk7XG4gIGVsc2UgaWYgKHIgPCBjYW1sX21hcnNoYWxfaGVhZGVyX3NpemUpXG4gICAgY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiB0cnVuY2F0ZWQgb2JqZWN0XCIpO1xuICB2YXIgbGVuID0gY2FtbF9tYXJzaGFsX2RhdGFfc2l6ZSAoY2FtbF9ieXRlc19vZl9hcnJheShoZWFkZXIpLCAwKTtcbiAgdmFyIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGxlbiArIGNhbWxfbWFyc2hhbF9oZWFkZXJfc2l6ZSk7XG4gIGJ1Zi5zZXQoaGVhZGVyLDApO1xuICB2YXIgciA9IGJsb2NrKGJ1ZiwgY2FtbF9tYXJzaGFsX2hlYWRlcl9zaXplLCBsZW4pXG4gIGlmKHIgPCBsZW4pXG4gICAgY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiB0cnVuY2F0ZWQgb2JqZWN0IFwiICsgciArIFwiICBcIiArIGxlbik7XG4gIHZhciBvZmZzZXQgPSBbMF07XG4gIHZhciByZXMgPSBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fYnl0ZXMoY2FtbF9ieXRlc19vZl9hcnJheShidWYpLCBvZmZzZXQpO1xuICBjaGFuLm9mZnNldCA9IGNoYW4ub2Zmc2V0ICsgb2Zmc2V0WzBdO1xuICByZXR1cm4gcmVzO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lucHV0X3ZhbHVlX3RvX291dHNpZGVfaGVhcFxuLy9SZXF1aXJlczogY2FtbF9pbnB1dF92YWx1ZVxuZnVuY3Rpb24gY2FtbF9pbnB1dF92YWx1ZV90b19vdXRzaWRlX2hlYXAoYykge1xuICByZXR1cm4gY2FtbF9pbnB1dF92YWx1ZShjKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9pbnB1dF9jaGFyXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX2VuZF9vZl9maWxlLCBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxfZ2V0LCBjYW1sX3JlZmlsbFxuZnVuY3Rpb24gY2FtbF9tbF9pbnB1dF9jaGFyIChjaGFuaWQpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxfZ2V0KGNoYW5pZCk7XG4gIGlmKGNoYW4uYnVmZmVyX2N1cnIgPj0gY2hhbi5idWZmZXJfbWF4KXtcbiAgICBjaGFuLmJ1ZmZlcl9jdXJyID0gMDtcbiAgICBjaGFuLmJ1ZmZlcl9tYXggPSAwO1xuICAgIGNhbWxfcmVmaWxsKGNoYW4pO1xuICB9XG4gIGlmIChjaGFuLmJ1ZmZlcl9jdXJyID49IGNoYW4uYnVmZmVyX21heClcbiAgICBjYW1sX3JhaXNlX2VuZF9vZl9maWxlKCk7XG4gIHZhciByZXMgPSBjaGFuLmJ1ZmZlcltjaGFuLmJ1ZmZlcl9jdXJyXTtcbiAgY2hhbi5idWZmZXJfY3VycisrO1xuICByZXR1cm4gcmVzO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2lucHV0X2ludFxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZVxuLy9SZXF1aXJlczogY2FtbF9tbF9pbnB1dF9jaGFyLCBjYW1sX21sX2NoYW5uZWxfZ2V0XG5mdW5jdGlvbiBjYW1sX21sX2lucHV0X2ludCAoY2hhbmlkKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsX2dldChjaGFuaWQpO1xuICB2YXIgcmVzID0gMDtcbiAgZm9yKHZhciBpID0gMDsgaSA8IDQ7IGkrKyl7XG4gICAgcmVzID0gKHJlcyA8PCA4KSArIGNhbWxfbWxfaW5wdXRfY2hhcihjaGFuaWQpIHwgMDtcbiAgfVxuICByZXR1cm4gcmVzIHwgMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zZWVrX2luXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3N5c19lcnJvciwgY2FtbF9tbF9jaGFubmVsX2dldFxuZnVuY3Rpb24gY2FtbF9zZWVrX2luKGNoYW5pZCwgcG9zKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsX2dldChjaGFuaWQpO1xuICBpZiAoY2hhbi5yZWZpbGwgIT0gbnVsbCkgY2FtbF9yYWlzZV9zeXNfZXJyb3IoXCJJbGxlZ2FsIHNlZWtcIik7XG4gIGlmKHBvcyA+PSBjaGFuLm9mZnNldCAtIGNoYW4uYnVmZmVyX21heFxuICAgICAmJiBwb3MgPD0gY2hhbi5vZmZzZXRcbiAgICAgJiYgY2hhbi5maWxlLmZsYWdzLmJpbmFyeSkge1xuICAgIGNoYW4uYnVmZmVyX2N1cnIgPSBjaGFuLmJ1ZmZlcl9tYXggLSAoY2hhbi5vZmZzZXQgLSBwb3MpO1xuICB9IGVsc2Uge1xuICAgIGNoYW4ub2Zmc2V0ID0gcG9zO1xuICAgIGNoYW4uYnVmZmVyX2N1cnIgPSAwO1xuICAgIGNoYW4uYnVmZmVyX21heCA9IDA7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2Vla19pblxuLy9SZXF1aXJlczogY2FtbF9zZWVrX2luXG5mdW5jdGlvbiBjYW1sX21sX3NlZWtfaW4oY2hhbmlkLHBvcyl7XG4gIHJldHVybiBjYW1sX3NlZWtfaW4oY2hhbmlkLHBvcyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2Vla19pbl82NFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF90b19mbG9hdCwgY2FtbF9zZWVrX2luXG5mdW5jdGlvbiBjYW1sX21sX3NlZWtfaW5fNjQoY2hhbmlkLHBvcyl7XG4gIHZhciBwb3MgPSBjYW1sX2ludDY0X3RvX2Zsb2F0KHBvcyk7XG4gIHJldHVybiBjYW1sX3NlZWtfaW4oY2hhbmlkLCBwb3MpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3Bvc19pblxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVsX2dldFxuZnVuY3Rpb24gY2FtbF9wb3NfaW4oY2hhbmlkKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsX2dldChjaGFuaWQpO1xuICByZXR1cm4gY2hhbi5vZmZzZXQgLSAoY2hhbi5idWZmZXJfbWF4IC0gY2hhbi5idWZmZXJfY3VycikgfCAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3Bvc19pblxuLy9SZXF1aXJlczogY2FtbF9wb3NfaW5cbmZ1bmN0aW9uIGNhbWxfbWxfcG9zX2luKGNoYW5pZCkge1xuICByZXR1cm4gY2FtbF9wb3NfaW4oY2hhbmlkKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9wb3NfaW5fNjRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfZmxvYXQsIGNhbWxfcG9zX2luXG5mdW5jdGlvbiBjYW1sX21sX3Bvc19pbl82NChjaGFuaWQpIHtcbiAgcmV0dXJuIGNhbWxfaW50NjRfb2ZfZmxvYXQoY2FtbF9wb3NfaW4oY2hhbmlkKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfaW5wdXRfc2Nhbl9saW5lXG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxfZ2V0LCBjYW1sX3JlZmlsbFxuZnVuY3Rpb24gY2FtbF9tbF9pbnB1dF9zY2FuX2xpbmUoY2hhbmlkKXtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxfZ2V0KGNoYW5pZCk7XG4gIHZhciBwID0gY2hhbi5idWZmZXJfY3VycjtcbiAgZG8ge1xuICAgIGlmKHAgPj0gY2hhbi5idWZmZXJfbWF4KSB7XG4gICAgICBpZihjaGFuLmJ1ZmZlcl9jdXJyID4gMCkge1xuICAgICAgICBjaGFuLmJ1ZmZlci5zZXQoY2hhbi5idWZmZXIuc3ViYXJyYXkoY2hhbi5idWZmZXJfY3VyciksMCk7XG4gICAgICAgIHAgLT0gY2hhbi5idWZmZXJfY3VycjtcbiAgICAgICAgY2hhbi5idWZmZXJfbWF4IC09IGNoYW4uYnVmZmVyX2N1cnI7XG4gICAgICAgIGNoYW4uYnVmZmVyX2N1cnIgPSAwO1xuICAgICAgfVxuICAgICAgaWYoY2hhbi5idWZmZXJfbWF4ID49IGNoYW4uYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gLShjaGFuLmJ1ZmZlcl9tYXgpIHwgMDtcbiAgICAgIH1cbiAgICAgIHZhciBwcmV2X21heCA9IGNoYW4uYnVmZmVyX21heDtcbiAgICAgIGNhbWxfcmVmaWxsIChjaGFuKTtcbiAgICAgIGlmKHByZXZfbWF4ID09IGNoYW4uYnVmZmVyX21heCkge1xuICAgICAgICByZXR1cm4gLShjaGFuLmJ1ZmZlcl9tYXgpIHwgMDtcbiAgICAgIH1cbiAgICB9XG4gIH0gd2hpbGUgKGNoYW4uYnVmZmVyW3ArK10gIT0gMTApO1xuICByZXR1cm4gKHAgLSBjaGFuLmJ1ZmZlcl9jdXJyKSB8IDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfZmx1c2hcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfc3lzX2Vycm9yLCBjYW1sX21sX2NoYW5uZWxfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX3N1YmFycmF5X3RvX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfbWxfZmx1c2ggKGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbF9nZXQoY2hhbmlkKTtcbiAgaWYoISBjaGFuLm9wZW5lZCkgY2FtbF9yYWlzZV9zeXNfZXJyb3IoXCJDYW5ub3QgZmx1c2ggYSBjbG9zZWQgY2hhbm5lbFwiKTtcbiAgaWYoIWNoYW4uYnVmZmVyIHx8IGNoYW4uYnVmZmVyX2N1cnIgPT0gMCkgcmV0dXJuIDA7XG4gIGlmKGNoYW4ub3V0cHV0KSB7XG4gICAgY2hhbi5vdXRwdXQoY2FtbF9zdWJhcnJheV90b19qc2J5dGVzKGNoYW4uYnVmZmVyLCAwLCBjaGFuLmJ1ZmZlcl9jdXJyKSk7XG4gIH0gZWxzZSB7XG4gICAgY2hhbi5maWxlLndyaXRlKGNoYW4ub2Zmc2V0LCBjaGFuLmJ1ZmZlciwgMCwgY2hhbi5idWZmZXJfY3Vycik7XG4gIH1cbiAgY2hhbi5vZmZzZXQgKz0gY2hhbi5idWZmZXJfY3VycjtcbiAgY2hhbi5idWZmZXJfY3VyciA9IDA7XG4gIHJldHVybiAwO1xufVxuXG4vL291dHB1dCB0byBvdXRfY2hhbm5lbFxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX291dHB1dF90YVxuLy9SZXF1aXJlczogY2FtbF9tbF9mbHVzaCxjYW1sX21sX2J5dGVzX2xlbmd0aFxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXNfZXJyb3IsIGNhbWxfbWxfY2hhbm5lbF9nZXRcbmZ1bmN0aW9uIGNhbWxfbWxfb3V0cHV0X3RhKGNoYW5pZCxidWZmZXIsb2Zmc2V0LGxlbikge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbF9nZXQoY2hhbmlkKTtcbiAgaWYoISBjaGFuLm9wZW5lZCkgY2FtbF9yYWlzZV9zeXNfZXJyb3IoXCJDYW5ub3Qgb3V0cHV0IHRvIGEgY2xvc2VkIGNoYW5uZWxcIik7XG4gIGJ1ZmZlciA9IGJ1ZmZlci5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gIGlmKGNoYW4uYnVmZmVyX2N1cnIgKyBidWZmZXIubGVuZ3RoID4gY2hhbi5idWZmZXIubGVuZ3RoKSB7XG4gICAgdmFyIGIgPSBuZXcgVWludDhBcnJheShjaGFuLmJ1ZmZlcl9jdXJyICsgYnVmZmVyLmxlbmd0aCk7XG4gICAgYi5zZXQoY2hhbi5idWZmZXIpO1xuICAgIGNoYW4uYnVmZmVyID0gYlxuICB9XG4gIHN3aXRjaChjaGFuLmJ1ZmZlcmVkKXtcbiAgY2FzZSAwOiAvLyBVbmJ1ZmZlcmVkXG4gICAgY2hhbi5idWZmZXIuc2V0KGJ1ZmZlciwgY2hhbi5idWZmZXJfY3Vycik7XG4gICAgY2hhbi5idWZmZXJfY3VyciArPSBidWZmZXIubGVuZ3RoO1xuICAgIGNhbWxfbWxfZmx1c2ggKGNoYW5pZCk7XG4gICAgYnJlYWtcbiAgY2FzZSAxOiAvLyBCdWZmZXJlZCAodGhlIGRlZmF1bHQpXG4gICAgY2hhbi5idWZmZXIuc2V0KGJ1ZmZlciwgY2hhbi5idWZmZXJfY3Vycik7XG4gICAgY2hhbi5idWZmZXJfY3VyciArPSBidWZmZXIubGVuZ3RoO1xuICAgIGlmKGNoYW4uYnVmZmVyX2N1cnIgPj0gY2hhbi5idWZmZXIubGVuZ3RoKVxuICAgICAgY2FtbF9tbF9mbHVzaCAoY2hhbmlkKTtcbiAgICBicmVhaztcbiAgY2FzZSAyOiAvLyBCdWZmZXJlZCAob25seSBmb3Igc3Rkb3V0IGFuZCBzdGRlcnIpXG4gICAgdmFyIGlkID0gYnVmZmVyLmxhc3RJbmRleE9mKDEwKVxuICAgIGlmKGlkIDwgMCkge1xuICAgICAgY2hhbi5idWZmZXIuc2V0KGJ1ZmZlciwgY2hhbi5idWZmZXJfY3Vycik7XG4gICAgICBjaGFuLmJ1ZmZlcl9jdXJyICs9IGJ1ZmZlci5sZW5ndGg7XG4gICAgICBpZihjaGFuLmJ1ZmZlcl9jdXJyID49IGNoYW4uYnVmZmVyLmxlbmd0aClcbiAgICAgICAgY2FtbF9tbF9mbHVzaCAoY2hhbmlkKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjaGFuLmJ1ZmZlci5zZXQoYnVmZmVyLnN1YmFycmF5KDAsIGlkICsgMSksIGNoYW4uYnVmZmVyX2N1cnIpO1xuICAgICAgY2hhbi5idWZmZXJfY3VyciArPSBpZCArIDE7XG4gICAgICBjYW1sX21sX2ZsdXNoIChjaGFuaWQpO1xuICAgICAgY2hhbi5idWZmZXIuc2V0KGJ1ZmZlci5zdWJhcnJheShpZCArIDEpLCBjaGFuLmJ1ZmZlcl9jdXJyKTtcbiAgICAgIGNoYW4uYnVmZmVyX2N1cnIgKz0gYnVmZmVyLmxlbmd0aCAtIGlkIC0gMTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfb3V0cHV0X2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX3VpbnQ4X2FycmF5X29mX2J5dGVzLCBjYW1sX21sX291dHB1dF90YVxuZnVuY3Rpb24gY2FtbF9tbF9vdXRwdXRfYnl0ZXMoY2hhbmlkLGJ1ZmZlcixvZmZzZXQsbGVuKSB7XG4gIHZhciBidWZmZXIgPSBjYW1sX3VpbnQ4X2FycmF5X29mX2J5dGVzKGJ1ZmZlcik7XG4gIHJldHVybiBjYW1sX21sX291dHB1dF90YShjaGFuaWQsYnVmZmVyLG9mZnNldCxsZW4pO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfb3V0cHV0X2JpZ2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX2JhX3RvX3R5cGVkX2FycmF5LCBjYW1sX21sX291dHB1dF90YVxuZnVuY3Rpb24gY2FtbF9tbF9vdXRwdXRfYmlnYXJyYXkoY2hhbmlkLGJ1ZmZlcixvZmZzZXQsbGVuKSB7XG4gIHZhciBidWZmZXIgPSBjYW1sX2JhX3RvX3R5cGVkX2FycmF5KGJ1ZmZlcik7XG4gIHJldHVybiBjYW1sX21sX291dHB1dF90YShjaGFuaWQsYnVmZmVyLG9mZnNldCxsZW4pO1xufVxuXG5cblxuLy9Qcm92aWRlczogY2FtbF9tbF9vdXRwdXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfb3V0cHV0X2J5dGVzLCBjYW1sX2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9tbF9vdXRwdXQoY2hhbmlkLGJ1ZmZlcixvZmZzZXQsbGVuKXtcbiAgcmV0dXJuIGNhbWxfbWxfb3V0cHV0X2J5dGVzKGNoYW5pZCxjYW1sX2J5dGVzX29mX3N0cmluZyhidWZmZXIpLG9mZnNldCxsZW4pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX291dHB1dF9jaGFyXG4vL1JlcXVpcmVzOiBjYW1sX21sX291dHB1dFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9tbF9vdXRwdXRfY2hhciAoY2hhbmlkLGMpIHtcbiAgdmFyIHMgPSBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKFN0cmluZy5mcm9tQ2hhckNvZGUoYykpO1xuICBjYW1sX21sX291dHB1dChjaGFuaWQscywwLDEpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vdXRwdXRfdmFsdWVcbi8vUmVxdWlyZXM6IGNhbWxfb3V0cHV0X3ZhbHVlX3RvX3N0cmluZywgY2FtbF9tbF9vdXRwdXQsY2FtbF9tbF9zdHJpbmdfbGVuZ3RoXG5mdW5jdGlvbiBjYW1sX291dHB1dF92YWx1ZSAoY2hhbmlkLHYsZmxhZ3MpIHtcbiAgdmFyIHMgPSBjYW1sX291dHB1dF92YWx1ZV90b19zdHJpbmcodiwgZmxhZ3MpO1xuICBjYW1sX21sX291dHB1dChjaGFuaWQscywwLGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSk7XG4gIHJldHVybiAwO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfc2Vla19vdXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbF9nZXQsIGNhbWxfbWxfZmx1c2hcbmZ1bmN0aW9uIGNhbWxfc2Vla19vdXQoY2hhbmlkLCBwb3Mpe1xuICBjYW1sX21sX2ZsdXNoKGNoYW5pZCk7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsX2dldChjaGFuaWQpO1xuICBjaGFuLm9mZnNldCA9IHBvcztcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2Vla19vdXRcbi8vUmVxdWlyZXM6IGNhbWxfc2Vla19vdXRcbmZ1bmN0aW9uIGNhbWxfbWxfc2Vla19vdXQoY2hhbmlkLHBvcyl7XG4gIHJldHVybiBjYW1sX3NlZWtfb3V0KGNoYW5pZCwgcG9zKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2Vla19vdXRfNjRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfdG9fZmxvYXQsIGNhbWxfc2Vla19vdXRcbmZ1bmN0aW9uIGNhbWxfbWxfc2Vla19vdXRfNjQoY2hhbmlkLHBvcyl7XG4gIHZhciBwb3MgPSBjYW1sX2ludDY0X3RvX2Zsb2F0KHBvcyk7XG4gIHJldHVybiBjYW1sX3NlZWtfb3V0KGNoYW5pZCwgcG9zKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9wb3Nfb3V0XG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxfZ2V0LCBjYW1sX21sX2ZsdXNoXG5mdW5jdGlvbiBjYW1sX3Bvc19vdXQoY2hhbmlkKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsX2dldChjaGFuaWQpO1xuICByZXR1cm4gY2hhbi5vZmZzZXQgKyBjaGFuLmJ1ZmZlcl9jdXJyXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfcG9zX291dFxuLy9SZXF1aXJlczogY2FtbF9wb3Nfb3V0XG5mdW5jdGlvbiBjYW1sX21sX3Bvc19vdXQoY2hhbmlkKSB7XG4gIHJldHVybiBjYW1sX3Bvc19vdXQoY2hhbmlkKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9wb3Nfb3V0XzY0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2Zsb2F0LCBjYW1sX3Bvc19vdXRcbmZ1bmN0aW9uIGNhbWxfbWxfcG9zX291dF82NChjaGFuaWQpIHtcbiAgcmV0dXJuIGNhbWxfaW50NjRfb2ZfZmxvYXQgKGNhbWxfcG9zX291dChjaGFuaWQpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9vdXRwdXRfaW50XG4vL1JlcXVpcmVzOiBjYW1sX21sX291dHB1dFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfYXJyYXlcbmZ1bmN0aW9uIGNhbWxfbWxfb3V0cHV0X2ludCAoY2hhbmlkLGkpIHtcbiAgdmFyIGFyciA9IFsoaT4+MjQpICYgMHhGRiwoaT4+MTYpICYgMHhGRiwoaT4+OCkgJiAweEZGLGkgJiAweEZGIF07XG4gIHZhciBzID0gY2FtbF9zdHJpbmdfb2ZfYXJyYXkoYXJyKTtcbiAgY2FtbF9tbF9vdXRwdXQoY2hhbmlkLHMsMCw0KTtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9pc19idWZmZXJlZFxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVsX2dldFxuZnVuY3Rpb24gY2FtbF9tbF9pc19idWZmZXJlZChjaGFuaWQpIHtcbiAgcmV0dXJuIGNhbWxfbWxfY2hhbm5lbF9nZXQoY2hhbmlkKS5idWZmZXJlZCA/IDEgOiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2V0X2J1ZmZlcmVkXG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxfZ2V0LCBjYW1sX21sX2ZsdXNoXG5mdW5jdGlvbiBjYW1sX21sX3NldF9idWZmZXJlZChjaGFuaWQsdikge1xuICBjYW1sX21sX2NoYW5uZWxfZ2V0KGNoYW5pZCkuYnVmZmVyZWQgPSB2O1xuICBpZighdikgY2FtbF9tbF9mbHVzaChjaGFuaWQpO1xuICByZXR1cm4gMFxufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogY2FtbF9jb21wYXJlX3ZhbF90YWdcbi8vUmVxdWlyZXM6IGNhbWxfaXNfbWxfc3RyaW5nLCBjYW1sX2lzX21sX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2NvbXBhcmVfdmFsX3RhZyhhKXtcbiAgaWYgKHR5cGVvZiBhID09PSBcIm51bWJlclwiKSByZXR1cm4gMTAwMDsgLy8gaW50X3RhZyAod2UgdXNlIGl0IGZvciBhbGwgbnVtYmVycylcbiAgZWxzZSBpZiAoY2FtbF9pc19tbF9ieXRlcyhhKSkgcmV0dXJuIDI1MjsgLy8gc3RyaW5nX3RhZ1xuICBlbHNlIGlmIChjYW1sX2lzX21sX3N0cmluZyhhKSkgcmV0dXJuIDEyNTI7IC8vIG9jYW1sIHN0cmluZyAoaWYgZGlmZmVyZW50IGZyb20gYnl0ZXMpXG4gIGVsc2UgaWYgKGEgaW5zdGFuY2VvZiBBcnJheSAmJiBhWzBdID09PSAoYVswXT4+PjApICYmIGFbMF0gPD0gMjU1KSB7XG4gICAgLy8gTG9vayBsaWtlIGFuIG9jYW1sIGJsb2NrXG4gICAgdmFyIHRhZyA9IGFbMF0gfCAwO1xuICAgIC8vIGlnbm9yZSBkb3VibGVfYXJyYXlfdGFnIGJlY2F1c2Ugd2UgY2Fubm90IGFjY3VyYXRlbHkgc2V0XG4gICAgLy8gdGhpcyB0YWcgd2hlbiB3ZSBjcmVhdGUgYW4gYXJyYXkgb2YgZmxvYXQuXG4gICAgcmV0dXJuICh0YWcgPT0gMjU0KT8wOnRhZ1xuICB9XG4gIGVsc2UgaWYgKGEgaW5zdGFuY2VvZiBTdHJpbmcpIHJldHVybiAxMjUyMDsgLy8gamF2YXNjcmlwdCBzdHJpbmcsIGxpa2Ugc3RyaW5nX3RhZyAoMjUyKVxuICBlbHNlIGlmICh0eXBlb2YgYSA9PSBcInN0cmluZ1wiKSByZXR1cm4gMTI1MjA7IC8vIGphdmFzY3JpcHQgc3RyaW5nLCBsaWtlIHN0cmluZ190YWcgKDI1MilcbiAgZWxzZSBpZiAoYSBpbnN0YW5jZW9mIE51bWJlcikgcmV0dXJuIDEwMDA7IC8vIGludF90YWcgKHdlIHVzZSBpdCBmb3IgYWxsIG51bWJlcnMpXG4gIGVsc2UgaWYgKGEgJiYgYS5jYW1sX2N1c3RvbSkgcmV0dXJuIDEyNTU7IC8vIGxpa2UgY3VzdG9tX3RhZyAoMjU1KVxuICBlbHNlIGlmIChhICYmIGEuY29tcGFyZSkgcmV0dXJuIDEyNTY7IC8vIGxpa2UgY3VzdG9tX3RhZyAoMjU1KVxuICBlbHNlIGlmICh0eXBlb2YgYSA9PSBcImZ1bmN0aW9uXCIpIHJldHVybiAxMjQ3OyAvLyBsaWtlIGNsb3N1cmVfdGFnICgyNDcpXG4gIGVsc2UgaWYgKHR5cGVvZiBhID09IFwic3ltYm9sXCIpIHJldHVybiAxMjUxO1xuICByZXR1cm4gMTAwMTsgLy9vdXRfb2ZfaGVhcF90YWdcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jb21wYXJlX3ZhbF9nZXRfY3VzdG9tXG4vL1JlcXVpcmVzOiBjYW1sX2N1c3RvbV9vcHNcbmZ1bmN0aW9uIGNhbWxfY29tcGFyZV92YWxfZ2V0X2N1c3RvbShhKXtcbiAgcmV0dXJuIGNhbWxfY3VzdG9tX29wc1thLmNhbWxfY3VzdG9tXSAmJiBjYW1sX2N1c3RvbV9vcHNbYS5jYW1sX2N1c3RvbV0uY29tcGFyZTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jb21wYXJlX3ZhbF9udW1iZXJfY3VzdG9tXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsX2dldF9jdXN0b21cbmZ1bmN0aW9uIGNhbWxfY29tcGFyZV92YWxfbnVtYmVyX2N1c3RvbShudW0sIGN1c3RvbSwgc3dhcCwgdG90YWwpIHtcbiAgdmFyIGNvbXAgPSBjYW1sX2NvbXBhcmVfdmFsX2dldF9jdXN0b20oY3VzdG9tKTtcbiAgaWYoY29tcCkge1xuICAgIHZhciB4ID0gKHN3YXAgPiAwKT9jb21wKGN1c3RvbSxudW0sdG90YWwpOmNvbXAobnVtLGN1c3RvbSx0b3RhbCk7XG4gICAgaWYodG90YWwgJiYgeCAhPSB4KSByZXR1cm4gc3dhcDsgLy8gdG90YWwgJiYgbmFuXG4gICAgaWYoK3ggIT0gK3gpIHJldHVybiAreDsgLy8gbmFuXG4gICAgaWYoKHggfCAwKSAhPSAwKSByZXR1cm4gKHggfCAwKTsgLy8gIW5hblxuICB9XG4gIHJldHVybiBzd2FwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY29tcGFyZV92YWwgKGNvbnN0LCBjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2ludF9jb21wYXJlLCBjYW1sX3N0cmluZ19jb21wYXJlLCBjYW1sX2J5dGVzX2NvbXBhcmVcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9jb21wYXJlX3ZhbF9nZXRfY3VzdG9tLCBjYW1sX2NvbXBhcmVfdmFsX3RhZ1xuLy9SZXF1aXJlczogY2FtbF9jb21wYXJlX3ZhbF9udW1iZXJfY3VzdG9tXG4vL1JlcXVpcmVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2lzX2NvbnRpbnVhdGlvbl90YWdcbmZ1bmN0aW9uIGNhbWxfY29tcGFyZV92YWwgKGEsIGIsIHRvdGFsKSB7XG4gIHZhciBzdGFjayA9IFtdO1xuICBmb3IoOzspIHtcbiAgICBpZiAoISh0b3RhbCAmJiBhID09PSBiKSkge1xuICAgICAgdmFyIHRhZ19hID0gY2FtbF9jb21wYXJlX3ZhbF90YWcoYSk7XG4gICAgICAvLyBmb3J3YXJkX3RhZyA/XG4gICAgICBpZih0YWdfYSA9PSAyNTApIHsgYSA9IGFbMV07IGNvbnRpbnVlIH1cblxuICAgICAgdmFyIHRhZ19iID0gY2FtbF9jb21wYXJlX3ZhbF90YWcoYik7XG4gICAgICAvLyBmb3J3YXJkX3RhZyA/XG4gICAgICBpZih0YWdfYiA9PSAyNTApIHsgYiA9IGJbMV07IGNvbnRpbnVlIH1cblxuICAgICAgLy8gdGFncyBhcmUgZGlmZmVyZW50XG4gICAgICBpZih0YWdfYSAhPT0gdGFnX2IpIHtcbiAgICAgICAgaWYodGFnX2EgPT0gMTAwMCkge1xuICAgICAgICAgIGlmKHRhZ19iID09IDEyNTUpIHsgLy9pbW1lZGlhdGUgY2FuIGNvbXBhcmUgYWdhaW5zdCBjdXN0b21cbiAgICAgICAgICAgIHJldHVybiBjYW1sX2NvbXBhcmVfdmFsX251bWJlcl9jdXN0b20oYSwgYiwgLTEsIHRvdGFsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIC0xXG4gICAgICAgIH1cbiAgICAgICAgaWYodGFnX2IgPT0gMTAwMCkge1xuICAgICAgICAgIGlmKHRhZ19hID09IDEyNTUpIHsgLy9pbW1lZGlhdGUgY2FuIGNvbXBhcmUgYWdhaW5zdCBjdXN0b21cbiAgICAgICAgICAgIHJldHVybiBjYW1sX2NvbXBhcmVfdmFsX251bWJlcl9jdXN0b20oYiwgYSwgMSwgdG90YWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gMVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAodGFnX2EgPCB0YWdfYik/LTE6MTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCh0YWdfYSl7XG4gICAgICAgIC8vIDI0NjogTGF6eV90YWcgaGFuZGxlZCBiZWxsb3dcbiAgICAgIGNhc2UgMjQ3OiAvLyBDbG9zdXJlX3RhZ1xuICAgICAgICAvLyBDYW5ub3QgaGFwcGVuXG4gICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNvbXBhcmU6IGZ1bmN0aW9uYWwgdmFsdWVcIik7XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIDI0ODogLy8gT2JqZWN0XG4gICAgICAgIHZhciB4ID0gY2FtbF9pbnRfY29tcGFyZShhWzJdLCBiWzJdKTtcbiAgICAgICAgaWYgKHggIT0gMCkgcmV0dXJuICh4IHwgMCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNDk6IC8vIEluZml4XG4gICAgICAgIC8vIENhbm5vdCBoYXBwZW5cbiAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY29tcGFyZTogZnVuY3Rpb25hbCB2YWx1ZVwiKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgMjUwOiAvLyBGb3J3YXJkIHRhZ1xuICAgICAgICAvLyBDYW5ub3QgaGFwcGVuLCBoYW5kbGVkIGFib3ZlXG4gICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImVxdWFsOiBnb3QgRm9yd2FyZF90YWcsIHNob3VsZCBub3QgaGFwcGVuXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjUxOiAvL0Fic3RyYWN0XG4gICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImVxdWFsOiBhYnN0cmFjdCB2YWx1ZVwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI1MjogLy8gT0NhbWwgYnl0ZXNcbiAgICAgICAgaWYgKGEgIT09IGIpIHtcbiAgICAgICAgICB2YXIgeCA9IGNhbWxfYnl0ZXNfY29tcGFyZShhLCBiKTtcbiAgICAgICAgICBpZiAoeCAhPSAwKSByZXR1cm4gKHggfCAwKTtcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI1MzogLy8gRG91YmxlX3RhZ1xuICAgICAgICAvLyBDYW5ub3QgaGFwcGVuXG4gICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImVxdWFsOiBnb3QgRG91YmxlX3RhZywgc2hvdWxkIG5vdCBoYXBwZW5cIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNTQ6IC8vIERvdWJsZV9hcnJheV90YWdcbiAgICAgICAgLy8gQ2Fubm90IGhhcHBlbiwgaGFuZGxlZCBhYm92ZVxuICAgICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJlcXVhbDogZ290IERvdWJsZV9hcnJheV90YWcsIHNob3VsZCBub3QgaGFwcGVuXCIpO1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSAyNTU6IC8vIEN1c3RvbV90YWdcbiAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiZXF1YWw6IGdvdCBDdXN0b21fdGFnLCBzaG91bGQgbm90IGhhcHBlblwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEyNDc6IC8vIEZ1bmN0aW9uXG4gICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNvbXBhcmU6IGZ1bmN0aW9uYWwgdmFsdWVcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxMjU1OiAvLyBDdXN0b21cbiAgICAgICAgdmFyIGNvbXAgPSBjYW1sX2NvbXBhcmVfdmFsX2dldF9jdXN0b20oYSk7XG4gICAgICAgIGlmKGNvbXAgIT0gY2FtbF9jb21wYXJlX3ZhbF9nZXRfY3VzdG9tKGIpKXtcbiAgICAgICAgICByZXR1cm4gKGEuY2FtbF9jdXN0b208Yi5jYW1sX2N1c3RvbSk/LTE6MTtcbiAgICAgICAgfVxuICAgICAgICBpZighY29tcClcbiAgICAgICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJjb21wYXJlOiBhYnN0cmFjdCB2YWx1ZVwiKTtcbiAgICAgICAgdmFyIHggPSBjb21wKGEsYix0b3RhbCk7XG4gICAgICAgIGlmKHggIT0geCl7IC8vIFByb3RlY3QgYWdhaW5zdCBpbnZhbGlkIFVOT1JERVJFRFxuICAgICAgICAgIHJldHVybiB0b3RhbD8tMTp4O1xuICAgICAgICB9XG4gICAgICAgIGlmKHggIT09ICh4fDApKXsgLy8gUHJvdGVjdCBhZ2FpbnN0IGludmFsaWQgcmV0dXJuIHZhbHVlXG4gICAgICAgICAgcmV0dXJuIC0xXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHggIT0gMCkgcmV0dXJuICh4IHwgMCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxMjU2OiAvLyBjb21wYXJlIGZ1bmN0aW9uXG4gICAgICAgIHZhciB4ID0gYS5jb21wYXJlKGIsdG90YWwpO1xuICAgICAgICBpZih4ICE9IHgpIHsgLy8gUHJvdGVjdCBhZ2FpbnN0IGludmFsaWQgVU5PUkRFUkVEXG4gICAgICAgICAgcmV0dXJuIHRvdGFsPy0xOng7XG4gICAgICAgIH1cbiAgICAgICAgaWYoeCAhPT0gKHh8MCkpeyAvLyBQcm90ZWN0IGFnYWluc3QgaW52YWxpZCByZXR1cm4gdmFsdWVcbiAgICAgICAgICByZXR1cm4gLTFcbiAgICAgICAgfVxuICAgICAgICBpZiAoeCAhPSAwKSByZXR1cm4gKHggfCAwKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEwMDA6IC8vIE51bWJlclxuICAgICAgICBhID0gK2E7XG4gICAgICAgIGIgPSArYjtcbiAgICAgICAgaWYgKGEgPCBiKSByZXR1cm4gLTE7XG4gICAgICAgIGlmIChhID4gYikgcmV0dXJuIDE7XG4gICAgICAgIGlmIChhICE9IGIpIHtcbiAgICAgICAgICBpZiAoIXRvdGFsKSByZXR1cm4gTmFOO1xuICAgICAgICAgIGlmIChhID09IGEpIHJldHVybiAxO1xuICAgICAgICAgIGlmIChiID09IGIpIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTAwMTogLy8gVGhlIHJlc3RcbiAgICAgICAgLy8gSGVyZSB3ZSBjYW4gYmUgaW4gdGhlIGZvbGxvd2luZyBjYXNlczpcbiAgICAgICAgLy8gMS4gSmF2YVNjcmlwdCBwcmltaXRpdmUgdHlwZXNcbiAgICAgICAgLy8gMi4gSmF2YVNjcmlwdCBvYmplY3QgdGhhdCBjYW4gYmUgY29lcmNlZCB0byBwcmltaXRpdmUgdHlwZXNcbiAgICAgICAgLy8gMy4gSmF2YVNjcmlwdCBvYmplY3QgdGhhbiBjYW5ub3QgYmUgY29lcmNlZCB0byBwcmltaXRpdmUgdHlwZXNcbiAgICAgICAgLy9cbiAgICAgICAgLy8gKDMpIHdpbGwgcmFpc2UgYSBbVHlwZUVycm9yXVxuICAgICAgICAvLyAoMikgd2lsbCBjb2VyY2UgdG8gcHJpbWl0aXZlIHR5cGVzIHVzaW5nIFt2YWx1ZU9mXSBvciBbdG9TdHJpbmddXG4gICAgICAgIC8vICgyKSBhbmQgKDMpLCBhZnRlciBldmVudHVhbCBjb2VyY2lvblxuICAgICAgICAvLyAtIGlmIGEgYW5kIGIgYXJlIHN0cmluZ3MsIGFwcGx5IGxleGljb2dyYXBoaWMgY29tcGFyaXNvblxuICAgICAgICAvLyAtIGlmIGEgb3IgYiBhcmUgbm90IHN0cmluZ3MsIGNvbnZlcnQgYSBhbmQgYiB0byBudW1iZXJcbiAgICAgICAgLy8gICBhbmQgYXBwbHkgc3RhbmRhcmQgY29tcGFyaXNvblxuICAgICAgICAvL1xuICAgICAgICAvLyBFeGNlcHRpb246IGAhPWAgd2lsbCBub3QgY29lcmNlL2NvbnZlcnQgaWYgYm90aCBhIGFuZCBiIGFyZSBvYmplY3RzXG4gICAgICAgIGlmIChhIDwgYikgcmV0dXJuIC0xO1xuICAgICAgICBpZiAoYSA+IGIpIHJldHVybiAxO1xuICAgICAgICBpZiAoYSAhPSBiKSB7XG4gICAgICAgICAgaWYgKCF0b3RhbCkgcmV0dXJuIE5hTjtcbiAgICAgICAgICBpZiAoYSA9PSBhKSByZXR1cm4gMTtcbiAgICAgICAgICBpZiAoYiA9PSBiKSByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEyNTE6IC8vIEphdmFTY3JpcHQgU3ltYm9sLCBubyBvcmRlcmluZy5cbiAgICAgICAgaWYoYSAhPT0gYikge1xuICAgICAgICAgIGlmICghdG90YWwpIHJldHVybiBOYU47XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEyNTI6IC8vIG9jYW1sIHN0cmluZ3NcbiAgICAgICAgdmFyIGEgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKGEpO1xuICAgICAgICB2YXIgYiA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcoYik7XG4gICAgICAgIGlmKGEgIT09IGIpIHtcbiAgICAgICAgICBpZihhIDwgYikgcmV0dXJuIC0xO1xuICAgICAgICAgIGlmKGEgPiBiKSByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTI1MjA6IC8vIGphdmFzY3JpcHQgc3RyaW5nc1xuICAgICAgICB2YXIgYSA9IGEudG9TdHJpbmcoKTtcbiAgICAgICAgdmFyIGIgPSBiLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmKGEgIT09IGIpIHtcbiAgICAgICAgICBpZihhIDwgYikgcmV0dXJuIC0xO1xuICAgICAgICAgIGlmKGEgPiBiKSByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjQ2OiAvLyBMYXp5X3RhZ1xuICAgICAgY2FzZSAyNTQ6IC8vIERvdWJsZV9hcnJheVxuICAgICAgZGVmYXVsdDogLy8gQmxvY2sgd2l0aCBvdGhlciB0YWdcbiAgICAgICAgaWYoY2FtbF9pc19jb250aW51YXRpb25fdGFnKHRhZ19hKSkge1xuICAgICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNvbXBhcmU6IGNvbnRpbnVhdGlvbiB2YWx1ZVwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpIHJldHVybiAoYS5sZW5ndGggPCBiLmxlbmd0aCk/LTE6MTtcbiAgICAgICAgaWYgKGEubGVuZ3RoID4gMSkgc3RhY2sucHVzaChhLCBiLCAxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzdGFjay5sZW5ndGggPT0gMCkgcmV0dXJuIDA7XG4gICAgdmFyIGkgPSBzdGFjay5wb3AoKTtcbiAgICBiID0gc3RhY2sucG9wKCk7XG4gICAgYSA9IHN0YWNrLnBvcCgpO1xuICAgIGlmIChpICsgMSA8IGEubGVuZ3RoKSBzdGFjay5wdXNoKGEsIGIsIGkgKyAxKTtcbiAgICBhID0gYVtpXTtcbiAgICBiID0gYltpXTtcbiAgfVxufVxuLy9Qcm92aWRlczogY2FtbF9jb21wYXJlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsXG5mdW5jdGlvbiBjYW1sX2NvbXBhcmUgKGEsIGIpIHsgcmV0dXJuIGNhbWxfY29tcGFyZV92YWwgKGEsIGIsIHRydWUpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2ludF9jb21wYXJlIG11dGFibGUgKGNvbnN0LCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfaW50X2NvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKGEgPCBiKSByZXR1cm4gKC0xKTsgaWYgKGEgPT0gYikgcmV0dXJuIDA7IHJldHVybiAxO1xufVxuLy9Qcm92aWRlczogY2FtbF9lcXVhbCBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsXG5mdW5jdGlvbiBjYW1sX2VxdWFsICh4LCB5KSB7IHJldHVybiArKGNhbWxfY29tcGFyZV92YWwoeCx5LGZhbHNlKSA9PSAwKTsgfVxuLy9Qcm92aWRlczogY2FtbF9ub3RlcXVhbCBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsXG5mdW5jdGlvbiBjYW1sX25vdGVxdWFsICh4LCB5KSB7IHJldHVybiArKGNhbWxfY29tcGFyZV92YWwoeCx5LGZhbHNlKSAhPSAwKTsgfVxuLy9Qcm92aWRlczogY2FtbF9ncmVhdGVyZXF1YWwgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jb21wYXJlX3ZhbFxuZnVuY3Rpb24gY2FtbF9ncmVhdGVyZXF1YWwgKHgsIHkpIHsgcmV0dXJuICsoY2FtbF9jb21wYXJlX3ZhbCh4LHksZmFsc2UpID49IDApOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2dyZWF0ZXJ0aGFuIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY29tcGFyZV92YWxcbmZ1bmN0aW9uIGNhbWxfZ3JlYXRlcnRoYW4gKHgsIHkpIHsgcmV0dXJuICsoY2FtbF9jb21wYXJlX3ZhbCh4LHksZmFsc2UpID4gMCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfbGVzc2VxdWFsIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY29tcGFyZV92YWxcbmZ1bmN0aW9uIGNhbWxfbGVzc2VxdWFsICh4LCB5KSB7IHJldHVybiArKGNhbWxfY29tcGFyZV92YWwoeCx5LGZhbHNlKSA8PSAwKTsgfVxuLy9Qcm92aWRlczogY2FtbF9sZXNzdGhhbiBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsXG5mdW5jdGlvbiBjYW1sX2xlc3N0aGFuICh4LCB5KSB7IHJldHVybiArKGNhbWxfY29tcGFyZV92YWwoeCx5LGZhbHNlKSA8IDApOyB9XG4iLCJcbi8vUHJvdmlkZXM6IGNhbWxfY3VzdG9tX2V2ZW50X2luZGV4XG52YXIgY2FtbF9jdXN0b21fZXZlbnRfaW5kZXggPSAwO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX3J1bnRpbWVfZXZlbnRzX3VzZXJfcmVnaXN0ZXJcbi8vUmVxdWlyZXM6IGNhbWxfY3VzdG9tX2V2ZW50X2luZGV4XG5mdW5jdGlvbiBjYW1sX3J1bnRpbWVfZXZlbnRzX3VzZXJfcmVnaXN0ZXIoZXZlbnRfbmFtZSwgZXZlbnRfdGFnLCBldmVudF90eXBlKSB7XG4gIGNhbWxfY3VzdG9tX2V2ZW50X2luZGV4ICs9IDE7XG4gIHJldHVybiBbMCwgY2FtbF9jdXN0b21fZXZlbnRfaW5kZXgsIGV2ZW50X25hbWUsIGV2ZW50X3R5cGUsIGV2ZW50X3RhZ107XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcnVudGltZV9ldmVudHNfdXNlcl93cml0ZVxuZnVuY3Rpb24gY2FtbF9ydW50aW1lX2V2ZW50c191c2VyX3dyaXRlKGV2ZW50LCBldmVudF9jb250ZW50KSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3J1bnRpbWVfZXZlbnRzX3VzZXJfcmVzb2x2ZVxuZnVuY3Rpb24gY2FtbF9ydW50aW1lX2V2ZW50c191c2VyX3Jlc29sdmUoKSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3J1bnRpbWVfZXZlbnRzX3N0YXJ0XG4vL0FsaWFzOiBjYW1sX3J1bnRpbWVfZXZlbnRzX3N0YXJ0XG5mdW5jdGlvbiBjYW1sX21sX3J1bnRpbWVfZXZlbnRzX3N0YXJ0KCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9ydW50aW1lX2V2ZW50c19wYXVzZVxuLy9BbGlhczogY2FtbF9ydW50aW1lX2V2ZW50c19wYXVzZVxuZnVuY3Rpb24gY2FtbF9tbF9ydW50aW1lX2V2ZW50c19wYXVzZSgpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfcnVudGltZV9ldmVudHNfYXJlX2FjdGl2ZVxuLy9WZXJzaW9uOiA+PSA1LjJcbmZ1bmN0aW9uIGNhbWxfbWxfcnVudGltZV9ldmVudHNfYXJlX2FjdGl2ZSgpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfcnVudGltZV9ldmVudHNfcmVzdW1lXG4vL0FsaWFzOiBjYW1sX3J1bnRpbWVfZXZlbnRzX3Jlc3VtZVxuZnVuY3Rpb24gY2FtbF9tbF9ydW50aW1lX2V2ZW50c19yZXN1bWUoKSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3J1bnRpbWVfZXZlbnRzX2NyZWF0ZV9jdXJzb3JcbmZ1bmN0aW9uIGNhbWxfcnVudGltZV9ldmVudHNfY3JlYXRlX2N1cnNvcih0YXJnZXQpIHtcbiAgcmV0dXJuIHt9O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3J1bnRpbWVfZXZlbnRzX2ZyZWVfY3Vyc29yXG5mdW5jdGlvbiBjYW1sX3J1bnRpbWVfZXZlbnRzX2ZyZWVfY3Vyc29yKGN1cnNvcikge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ydW50aW1lX2V2ZW50c19yZWFkX3BvbGxcbmZ1bmN0aW9uIGNhbWxfcnVudGltZV9ldmVudHNfcmVhZF9wb2xsKGN1cnNvciwgY2FsbGJhY2tzLCBudW0pIHtcbiAgcmV0dXJuIDA7XG59XG4iLCJcbi8vUHJvdmlkZXM6IHpzdGRfZGVjb21wcmVzc1xuLy9WZXJzaW9uOiA+PSA1LjFcbnZhciB6c3RkX2RlY29tcHJlc3MgPSAoZnVuY3Rpb24gKCkge1xuXCJ1c2Ugc3RyaWN0XCI7XG4vLyBhbGlhc2VzIGZvciBzaG9ydGVyIGNvbXByZXNzZWQgY29kZSAobW9zdCBtaW5pZmVycyBkb24ndCBkbyB0aGlzKVxudmFyIGFiID0gQXJyYXlCdWZmZXIsIHU4ID0gVWludDhBcnJheSwgdTE2ID0gVWludDE2QXJyYXksIGkxNiA9IEludDE2QXJyYXksIHUzMiA9IFVpbnQzMkFycmF5LCBpMzIgPSBJbnQzMkFycmF5O1xudmFyIHNsYyA9IGZ1bmN0aW9uICh2LCBzLCBlKSB7XG4gICAgaWYgKHU4LnByb3RvdHlwZS5zbGljZSlcbiAgICAgICAgcmV0dXJuIHU4LnByb3RvdHlwZS5zbGljZS5jYWxsKHYsIHMsIGUpO1xuICAgIGlmIChzID09IG51bGwgfHwgcyA8IDApXG4gICAgICAgIHMgPSAwO1xuICAgIGlmIChlID09IG51bGwgfHwgZSA+IHYubGVuZ3RoKVxuICAgICAgICBlID0gdi5sZW5ndGg7XG4gICAgdmFyIG4gPSBuZXcgdTgoZSAtIHMpO1xuICAgIG4uc2V0KHYuc3ViYXJyYXkocywgZSkpO1xuICAgIHJldHVybiBuO1xufTtcbnZhciBmaWxsID0gZnVuY3Rpb24gKHYsIG4sIHMsIGUpIHtcbiAgICBpZiAodTgucHJvdG90eXBlLmZpbGwpXG4gICAgICAgIHJldHVybiB1OC5wcm90b3R5cGUuZmlsbC5jYWxsKHYsIG4sIHMsIGUpO1xuICAgIGlmIChzID09IG51bGwgfHwgcyA8IDApXG4gICAgICAgIHMgPSAwO1xuICAgIGlmIChlID09IG51bGwgfHwgZSA+IHYubGVuZ3RoKVxuICAgICAgICBlID0gdi5sZW5ndGg7XG4gICAgZm9yICg7IHMgPCBlOyArK3MpXG4gICAgICAgIHZbc10gPSBuO1xuICAgIHJldHVybiB2O1xufTtcbnZhciBjcHcgPSBmdW5jdGlvbiAodiwgdCwgcywgZSkge1xuICAgIGlmICh1OC5wcm90b3R5cGUuY29weVdpdGhpbilcbiAgICAgICAgcmV0dXJuIHU4LnByb3RvdHlwZS5jb3B5V2l0aGluLmNhbGwodiwgdCwgcywgZSk7XG4gICAgaWYgKHMgPT0gbnVsbCB8fCBzIDwgMClcbiAgICAgICAgcyA9IDA7XG4gICAgaWYgKGUgPT0gbnVsbCB8fCBlID4gdi5sZW5ndGgpXG4gICAgICAgIGUgPSB2Lmxlbmd0aDtcbiAgICB3aGlsZSAocyA8IGUpIHtcbiAgICAgICAgdlt0KytdID0gdltzKytdO1xuICAgIH1cbn07XG4vKipcbiAqIENvZGVzIGZvciBlcnJvcnMgZ2VuZXJhdGVkIHdpdGhpbiB0aGlzIGxpYnJhcnlcbiAqL1xuLy8gZXJyb3IgY29kZXNcbnZhciBlYyA9IFtcbiAgICAnaW52YWxpZCB6c3RkIGRhdGEnLFxuICAgICd3aW5kb3cgc2l6ZSB0b28gbGFyZ2UgKD4yMDQ2TUIpJyxcbiAgICAnaW52YWxpZCBibG9jayB0eXBlJyxcbiAgICAnRlNFIGFjY3VyYWN5IHRvbyBoaWdoJyxcbiAgICAnbWF0Y2ggZGlzdGFuY2UgdG9vIGZhciBiYWNrJyxcbiAgICAndW5leHBlY3RlZCBFT0YnXG5dO1xuO1xudmFyIGVyciA9IGZ1bmN0aW9uIChpbmQsIG1zZywgbnQpIHtcbiAgICB2YXIgZSA9IG5ldyBFcnJvcihtc2cgfHwgZWNbaW5kXSk7XG4gICAgZS5jb2RlID0gaW5kO1xuICAgIGlmICghbnQpXG4gICAgICAgIHRocm93IGU7XG4gICAgcmV0dXJuIGU7XG59O1xudmFyIHJiID0gZnVuY3Rpb24gKGQsIGIsIG4pIHtcbiAgICB2YXIgaSA9IDAsIG8gPSAwO1xuICAgIGZvciAoOyBpIDwgbjsgKytpKVxuICAgICAgICBvIHw9IGRbYisrXSA8PCAoaSA8PCAzKTtcbiAgICByZXR1cm4gbztcbn07XG52YXIgYjQgPSBmdW5jdGlvbiAoZCwgYikgeyByZXR1cm4gKGRbYl0gfCAoZFtiICsgMV0gPDwgOCkgfCAoZFtiICsgMl0gPDwgMTYpIHwgKGRbYiArIDNdIDw8IDI0KSkgPj4+IDA7IH07XG4vLyByZWFkIFpzdGFuZGFyZCBmcmFtZSBoZWFkZXJcbnZhciByemZoID0gZnVuY3Rpb24gKGRhdCwgdykge1xuICAgIHZhciBuMyA9IGRhdFswXSB8IChkYXRbMV0gPDwgOCkgfCAoZGF0WzJdIDw8IDE2KTtcbiAgICBpZiAobjMgPT0gMHgyRkI1MjggJiYgZGF0WzNdID09IDI1Mykge1xuICAgICAgICAvLyBac3RhbmRhcmRcbiAgICAgICAgdmFyIGZsZyA9IGRhdFs0XTtcbiAgICAgICAgLy8gICAgc2luZ2xlIHNlZ21lbnQgICAgICAgY2hlY2tzdW0gICAgICAgICAgICAgZGljdCBmbGFnICAgICBmcmFtZSBjb250ZW50IGZsYWdcbiAgICAgICAgdmFyIHNzID0gKGZsZyA+PiA1KSAmIDEsIGNjID0gKGZsZyA+PiAyKSAmIDEsIGRmID0gZmxnICYgMywgZmNmID0gZmxnID4+IDY7XG4gICAgICAgIGlmIChmbGcgJiA4KVxuICAgICAgICAgICAgZXJyKDApO1xuICAgICAgICAvLyBieXRlXG4gICAgICAgIHZhciBidCA9IDYgLSBzcztcbiAgICAgICAgLy8gZGljdCBieXRlc1xuICAgICAgICB2YXIgZGIgPSBkZiA9PSAzID8gNCA6IGRmO1xuICAgICAgICAvLyBkaWN0aW9uYXJ5IGlkXG4gICAgICAgIHZhciBkaSA9IHJiKGRhdCwgYnQsIGRiKTtcbiAgICAgICAgYnQgKz0gZGI7XG4gICAgICAgIC8vIGZyYW1lIHNpemUgYnl0ZXNcbiAgICAgICAgdmFyIGZzYiA9IGZjZiA/ICgxIDw8IGZjZikgOiBzcztcbiAgICAgICAgLy8gZnJhbWUgc291cmNlIHNpemVcbiAgICAgICAgdmFyIGZzcyA9IHJiKGRhdCwgYnQsIGZzYikgKyAoKGZjZiA9PSAxKSAmJiAyNTYpO1xuICAgICAgICAvLyB3aW5kb3cgc2l6ZVxuICAgICAgICB2YXIgd3MgPSBmc3M7XG4gICAgICAgIGlmICghc3MpIHtcbiAgICAgICAgICAgIC8vIHdpbmRvdyBkZXNjcmlwdG9yXG4gICAgICAgICAgICB2YXIgd2IgPSAxIDw8ICgxMCArIChkYXRbNV0gPj4gMykpO1xuICAgICAgICAgICAgd3MgPSB3YiArICh3YiA+PiAzKSAqIChkYXRbNV0gJiA3KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAod3MgPiAyMTQ1Mzg2NDk2KVxuICAgICAgICAgICAgZXJyKDEpO1xuICAgICAgICB2YXIgYnVmID0gbmV3IHU4KCh3ID09IDEgPyAoZnNzIHx8IHdzKSA6IHcgPyAwIDogd3MpICsgMTIpO1xuICAgICAgICBidWZbMF0gPSAxLCBidWZbNF0gPSA0LCBidWZbOF0gPSA4O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYjogYnQgKyBmc2IsXG4gICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgbDogMCxcbiAgICAgICAgICAgIGQ6IGRpLFxuICAgICAgICAgICAgdzogKHcgJiYgdyAhPSAxKSA/IHcgOiBidWYuc3ViYXJyYXkoMTIpLFxuICAgICAgICAgICAgZTogd3MsXG4gICAgICAgICAgICBvOiBuZXcgaTMyKGJ1Zi5idWZmZXIsIDAsIDMpLFxuICAgICAgICAgICAgdTogZnNzLFxuICAgICAgICAgICAgYzogY2MsXG4gICAgICAgICAgICBtOiBNYXRoLm1pbigxMzEwNzIsIHdzKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmICgoKG4zID4+IDQpIHwgKGRhdFszXSA8PCAyMCkpID09IDB4MTg0RDJBNSkge1xuICAgICAgICAvLyBza2lwcGFibGVcbiAgICAgICAgcmV0dXJuIGI0KGRhdCwgNCkgKyA4O1xuICAgIH1cbiAgICBlcnIoMCk7XG59O1xuLy8gbW9zdCBzaWduaWZpY2FudCBiaXQgZm9yIG5vbnplcm9cbnZhciBtc2IgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgdmFyIGJpdHMgPSAwO1xuICAgIGZvciAoOyAoMSA8PCBiaXRzKSA8PSB2YWw7ICsrYml0cylcbiAgICAgICAgO1xuICAgIHJldHVybiBiaXRzIC0gMTtcbn07XG4vLyByZWFkIGZpbml0ZSBzdGF0ZSBlbnRyb3B5XG52YXIgcmZzZSA9IGZ1bmN0aW9uIChkYXQsIGJ0LCBtYWwpIHtcbiAgICAvLyB0YWJsZSBwb3NcbiAgICB2YXIgdHBvcyA9IChidCA8PCAzKSArIDQ7XG4gICAgLy8gYWNjdXJhY3kgbG9nXG4gICAgdmFyIGFsID0gKGRhdFtidF0gJiAxNSkgKyA1O1xuICAgIGlmIChhbCA+IG1hbClcbiAgICAgICAgZXJyKDMpO1xuICAgIC8vIHNpemVcbiAgICB2YXIgc3ogPSAxIDw8IGFsO1xuICAgIC8vIHByb2JhYmlsaXRpZXMgc3ltYm9scyAgcmVwZWF0ICAgaW5kZXggICBoaWdoIHRocmVzaG9sZFxuICAgIHZhciBwcm9icyA9IHN6LCBzeW0gPSAtMSwgcmUgPSAtMSwgaSA9IC0xLCBodCA9IHN6O1xuICAgIC8vIG9wdGltaXphdGlvbjogc2luZ2xlIGFsbG9jYXRpb24gaXMgbXVjaCBmYXN0ZXJcbiAgICB2YXIgYnVmID0gbmV3IGFiKDUxMiArIChzeiA8PCAyKSk7XG4gICAgdmFyIGZyZXEgPSBuZXcgaTE2KGJ1ZiwgMCwgMjU2KTtcbiAgICAvLyBzYW1lIHZpZXcgYXMgZnJlcVxuICAgIHZhciBkc3RhdGUgPSBuZXcgdTE2KGJ1ZiwgMCwgMjU2KTtcbiAgICB2YXIgbnN0YXRlID0gbmV3IHUxNihidWYsIDUxMiwgc3opO1xuICAgIHZhciBiYjEgPSA1MTIgKyAoc3ogPDwgMSk7XG4gICAgdmFyIHN5bXMgPSBuZXcgdTgoYnVmLCBiYjEsIHN6KTtcbiAgICB2YXIgbmJpdHMgPSBuZXcgdTgoYnVmLCBiYjEgKyBzeik7XG4gICAgd2hpbGUgKHN5bSA8IDI1NSAmJiBwcm9icyA+IDApIHtcbiAgICAgICAgdmFyIGJpdHMgPSBtc2IocHJvYnMgKyAxKTtcbiAgICAgICAgdmFyIGNidCA9IHRwb3MgPj4gMztcbiAgICAgICAgLy8gbWFza1xuICAgICAgICB2YXIgbXNrID0gKDEgPDwgKGJpdHMgKyAxKSkgLSAxO1xuICAgICAgICB2YXIgdmFsID0gKChkYXRbY2J0XSB8IChkYXRbY2J0ICsgMV0gPDwgOCkgfCAoZGF0W2NidCArIDJdIDw8IDE2KSkgPj4gKHRwb3MgJiA3KSkgJiBtc2s7XG4gICAgICAgIC8vIG1hc2sgKDEgZmV3ZXIgYml0KVxuICAgICAgICB2YXIgbXNrMWZiID0gKDEgPDwgYml0cykgLSAxO1xuICAgICAgICAvLyBtYXggc21hbGwgdmFsdWVcbiAgICAgICAgdmFyIG1zdiA9IG1zayAtIHByb2JzIC0gMTtcbiAgICAgICAgLy8gc21hbGwgdmFsdWVcbiAgICAgICAgdmFyIHN2YWwgPSB2YWwgJiBtc2sxZmI7XG4gICAgICAgIGlmIChzdmFsIDwgbXN2KVxuICAgICAgICAgICAgdHBvcyArPSBiaXRzLCB2YWwgPSBzdmFsO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRwb3MgKz0gYml0cyArIDE7XG4gICAgICAgICAgICBpZiAodmFsID4gbXNrMWZiKVxuICAgICAgICAgICAgICAgIHZhbCAtPSBtc3Y7XG4gICAgICAgIH1cbiAgICAgICAgZnJlcVsrK3N5bV0gPSAtLXZhbDtcbiAgICAgICAgaWYgKHZhbCA9PSAtMSkge1xuICAgICAgICAgICAgcHJvYnMgKz0gdmFsO1xuICAgICAgICAgICAgc3ltc1stLWh0XSA9IHN5bTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBwcm9icyAtPSB2YWw7XG4gICAgICAgIGlmICghdmFsKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgLy8gcmVwZWF0IGJ5dGVcbiAgICAgICAgICAgICAgICB2YXIgcmJ0ID0gdHBvcyA+PiAzO1xuICAgICAgICAgICAgICAgIHJlID0gKChkYXRbcmJ0XSB8IChkYXRbcmJ0ICsgMV0gPDwgOCkpID4+ICh0cG9zICYgNykpICYgMztcbiAgICAgICAgICAgICAgICB0cG9zICs9IDI7XG4gICAgICAgICAgICAgICAgc3ltICs9IHJlO1xuICAgICAgICAgICAgfSB3aGlsZSAocmUgPT0gMyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN5bSA+IDI1NSB8fCBwcm9icylcbiAgICAgICAgZXJyKDApO1xuICAgIHZhciBzeW1wb3MgPSAwO1xuICAgIC8vIHN5bSBzdGVwIChjb3ByaW1lIHdpdGggc3ogLSBmb3JtdWxhIGZyb20genN0ZCBzb3VyY2UpXG4gICAgdmFyIHNzdGVwID0gKHN6ID4+IDEpICsgKHN6ID4+IDMpICsgMztcbiAgICAvLyBzeW0gbWFza1xuICAgIHZhciBzbWFzayA9IHN6IC0gMTtcbiAgICBmb3IgKHZhciBzID0gMDsgcyA8PSBzeW07ICsrcykge1xuICAgICAgICB2YXIgc2YgPSBmcmVxW3NdO1xuICAgICAgICBpZiAoc2YgPCAxKSB7XG4gICAgICAgICAgICBkc3RhdGVbc10gPSAtc2Y7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGlzIGlzIHNwbGl0IGludG8gdHdvIGxvb3BzIGluIHpzdGQgdG8gYXZvaWQgYnJhbmNoaW5nLCBidXQgYXMgSlMgaXMgaGlnaGVyLWxldmVsIHRoYXQgaXMgdW5uZWNlc3NhcnlcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNmOyArK2kpIHtcbiAgICAgICAgICAgIHN5bXNbc3ltcG9zXSA9IHM7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgc3ltcG9zID0gKHN5bXBvcyArIHNzdGVwKSAmIHNtYXNrO1xuICAgICAgICAgICAgfSB3aGlsZSAoc3ltcG9zID49IGh0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBBZnRlciBzcHJlYWRpbmcgc3ltYm9scywgc2hvdWxkIGJlIHplcm8gYWdhaW5cbiAgICBpZiAoc3ltcG9zKVxuICAgICAgICBlcnIoMCk7XG4gICAgZm9yIChpID0gMDsgaSA8IHN6OyArK2kpIHtcbiAgICAgICAgLy8gbmV4dCBzdGF0ZVxuICAgICAgICB2YXIgbnMgPSBkc3RhdGVbc3ltc1tpXV0rKztcbiAgICAgICAgLy8gbnVtIGJpdHNcbiAgICAgICAgdmFyIG5iID0gbmJpdHNbaV0gPSBhbCAtIG1zYihucyk7XG4gICAgICAgIG5zdGF0ZVtpXSA9IChucyA8PCBuYikgLSBzejtcbiAgICB9XG4gICAgcmV0dXJuIFsodHBvcyArIDcpID4+IDMsIHtcbiAgICAgICAgICAgIGI6IGFsLFxuICAgICAgICAgICAgczogc3ltcyxcbiAgICAgICAgICAgIG46IG5iaXRzLFxuICAgICAgICAgICAgdDogbnN0YXRlXG4gICAgICAgIH1dO1xufTtcbi8vIHJlYWQgaHVmZm1hblxudmFyIHJodSA9IGZ1bmN0aW9uIChkYXQsIGJ0KSB7XG4gICAgLy8gIGluZGV4ICB3ZWlnaHQgY291bnRcbiAgICB2YXIgaSA9IDAsIHdjID0gLTE7XG4gICAgLy8gICAgYnVmZmVyICAgICAgICAgICAgIGhlYWRlciBieXRlXG4gICAgdmFyIGJ1ZiA9IG5ldyB1OCgyOTIpLCBoYiA9IGRhdFtidF07XG4gICAgLy8gaHVmZm1hbiB3ZWlnaHRzXG4gICAgdmFyIGh3ID0gYnVmLnN1YmFycmF5KDAsIDI1Nik7XG4gICAgLy8gcmFuayBjb3VudFxuICAgIHZhciByYyA9IGJ1Zi5zdWJhcnJheSgyNTYsIDI2OCk7XG4gICAgLy8gcmFuayBpbmRleFxuICAgIHZhciByaSA9IG5ldyB1MTYoYnVmLmJ1ZmZlciwgMjY4KTtcbiAgICAvLyBOT1RFOiBhdCB0aGlzIHBvaW50IGJ0IGlzIDEgbGVzcyB0aGFuIGV4cGVjdGVkXG4gICAgaWYgKGhiIDwgMTI4KSB7XG4gICAgICAgIC8vIGVuZCBieXRlLCBmc2UgZGVjb2RlIHRhYmxlXG4gICAgICAgIHZhciBfYSA9IHJmc2UoZGF0LCBidCArIDEsIDYpLCBlYnQgPSBfYVswXSwgZmR0ID0gX2FbMV07XG4gICAgICAgIGJ0ICs9IGhiO1xuICAgICAgICB2YXIgZXBvcyA9IGVidCA8PCAzO1xuICAgICAgICAvLyBsYXN0IGJ5dGVcbiAgICAgICAgdmFyIGxiID0gZGF0W2J0XTtcbiAgICAgICAgaWYgKCFsYilcbiAgICAgICAgICAgIGVycigwKTtcbiAgICAgICAgLy8gIHN0YXRlMSAgIHN0YXRlMiAgIHN0YXRlMSBiaXRzICAgc3RhdGUyIGJpdHNcbiAgICAgICAgdmFyIHN0MSA9IDAsIHN0MiA9IDAsIGJ0cjEgPSBmZHQuYiwgYnRyMiA9IGJ0cjE7XG4gICAgICAgIC8vIGZzZSBwb3NcbiAgICAgICAgLy8gcHJlLWluY3JlbWVudCB0byBhY2NvdW50IGZvciBvcmlnaW5hbCBkZWZpY2l0IG9mIDFcbiAgICAgICAgdmFyIGZwb3MgPSAoKytidCA8PCAzKSAtIDggKyBtc2IobGIpO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBmcG9zIC09IGJ0cjE7XG4gICAgICAgICAgICBpZiAoZnBvcyA8IGVwb3MpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB2YXIgY2J0ID0gZnBvcyA+PiAzO1xuICAgICAgICAgICAgc3QxICs9ICgoZGF0W2NidF0gfCAoZGF0W2NidCArIDFdIDw8IDgpKSA+PiAoZnBvcyAmIDcpKSAmICgoMSA8PCBidHIxKSAtIDEpO1xuICAgICAgICAgICAgaHdbKyt3Y10gPSBmZHQuc1tzdDFdO1xuICAgICAgICAgICAgZnBvcyAtPSBidHIyO1xuICAgICAgICAgICAgaWYgKGZwb3MgPCBlcG9zKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2J0ID0gZnBvcyA+PiAzO1xuICAgICAgICAgICAgc3QyICs9ICgoZGF0W2NidF0gfCAoZGF0W2NidCArIDFdIDw8IDgpKSA+PiAoZnBvcyAmIDcpKSAmICgoMSA8PCBidHIyKSAtIDEpO1xuICAgICAgICAgICAgaHdbKyt3Y10gPSBmZHQuc1tzdDJdO1xuICAgICAgICAgICAgYnRyMSA9IGZkdC5uW3N0MV07XG4gICAgICAgICAgICBzdDEgPSBmZHQudFtzdDFdO1xuICAgICAgICAgICAgYnRyMiA9IGZkdC5uW3N0Ml07XG4gICAgICAgICAgICBzdDIgPSBmZHQudFtzdDJdO1xuICAgICAgICB9XG4gICAgICAgIGlmICgrK3djID4gMjU1KVxuICAgICAgICAgICAgZXJyKDApO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgd2MgPSBoYiAtIDEyNztcbiAgICAgICAgZm9yICg7IGkgPCB3YzsgaSArPSAyKSB7XG4gICAgICAgICAgICB2YXIgYnl0ZSA9IGRhdFsrK2J0XTtcbiAgICAgICAgICAgIGh3W2ldID0gYnl0ZSA+PiA0O1xuICAgICAgICAgICAgaHdbaSArIDFdID0gYnl0ZSAmIDE1O1xuICAgICAgICB9XG4gICAgICAgICsrYnQ7XG4gICAgfVxuICAgIC8vIHdlaWdodCBleHBvbmVudGlhbCBzdW1cbiAgICB2YXIgd2VzID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgd2M7ICsraSkge1xuICAgICAgICB2YXIgd3QgPSBod1tpXTtcbiAgICAgICAgLy8gYml0cyBtdXN0IGJlIGF0IG1vc3QgMTEsIHNhbWUgYXMgd2VpZ2h0XG4gICAgICAgIGlmICh3dCA+IDExKVxuICAgICAgICAgICAgZXJyKDApO1xuICAgICAgICB3ZXMgKz0gd3QgJiYgKDEgPDwgKHd0IC0gMSkpO1xuICAgIH1cbiAgICAvLyBtYXggYml0c1xuICAgIHZhciBtYiA9IG1zYih3ZXMpICsgMTtcbiAgICAvLyB0YWJsZSBzaXplXG4gICAgdmFyIHRzID0gMSA8PCBtYjtcbiAgICAvLyByZW1haW5pbmcgc3VtXG4gICAgdmFyIHJlbSA9IHRzIC0gd2VzO1xuICAgIC8vIG11c3QgYmUgcG93ZXIgb2YgMlxuICAgIGlmIChyZW0gJiAocmVtIC0gMSkpXG4gICAgICAgIGVycigwKTtcbiAgICBod1t3YysrXSA9IG1zYihyZW0pICsgMTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgd2M7ICsraSkge1xuICAgICAgICB2YXIgd3QgPSBod1tpXTtcbiAgICAgICAgKytyY1tod1tpXSA9IHd0ICYmIChtYiArIDEgLSB3dCldO1xuICAgIH1cbiAgICAvLyBodWYgYnVmXG4gICAgdmFyIGhidWYgPSBuZXcgdTgodHMgPDwgMSk7XG4gICAgLy8gICAgc3ltYm9scyAgICAgICAgICAgICAgICAgICAgICBudW0gYml0c1xuICAgIHZhciBzeW1zID0gaGJ1Zi5zdWJhcnJheSgwLCB0cyksIG5iID0gaGJ1Zi5zdWJhcnJheSh0cyk7XG4gICAgcmlbbWJdID0gMDtcbiAgICBmb3IgKGkgPSBtYjsgaSA+IDA7IC0taSkge1xuICAgICAgICB2YXIgcHYgPSByaVtpXTtcbiAgICAgICAgZmlsbChuYiwgaSwgcHYsIHJpW2kgLSAxXSA9IHB2ICsgcmNbaV0gKiAoMSA8PCAobWIgLSBpKSkpO1xuICAgIH1cbiAgICBpZiAocmlbMF0gIT0gdHMpXG4gICAgICAgIGVycigwKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgd2M7ICsraSkge1xuICAgICAgICB2YXIgYml0cyA9IGh3W2ldO1xuICAgICAgICBpZiAoYml0cykge1xuICAgICAgICAgICAgdmFyIGNvZGUgPSByaVtiaXRzXTtcbiAgICAgICAgICAgIGZpbGwoc3ltcywgaSwgY29kZSwgcmlbYml0c10gPSBjb2RlICsgKDEgPDwgKG1iIC0gYml0cykpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW2J0LCB7XG4gICAgICAgICAgICBuOiBuYixcbiAgICAgICAgICAgIGI6IG1iLFxuICAgICAgICAgICAgczogc3ltc1xuICAgICAgICB9XTtcbn07XG4vLyBUYWJsZXMgZ2VuZXJhdGVkIHVzaW5nIHRoaXM6XG4vLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS8xMDFhcnJvd3ovYTk3OTQ1MmQ0MzU1OTkyY2JmOGYyNTdjYmZmYzllZGRcbi8vIGRlZmF1bHQgbGl0ZXJhbCBsZW5ndGggdGFibGVcbnZhciBkbGx0ID0gLyojX19QVVJFX18qLyByZnNlKC8qI19fUFVSRV9fKi8gbmV3IHU4KFtcbiAgICA4MSwgMTYsIDk5LCAxNDAsIDQ5LCAxOTgsIDI0LCA5OSwgMTIsIDMzLCAxOTYsIDI0LCA5OSwgMTAyLCAxMDIsIDEzNCwgNzAsIDE0NiwgNFxuXSksIDAsIDYpWzFdO1xuLy8gZGVmYXVsdCBtYXRjaCBsZW5ndGggdGFibGVcbnZhciBkbWx0ID0gLyojX19QVVJFX18qLyByZnNlKC8qI19fUFVSRV9fKi8gbmV3IHU4KFtcbiAgICAzMywgMjAsIDE5NiwgMjQsIDk5LCAxNDAsIDMzLCAxMzIsIDE2LCA2NiwgOCwgMzMsIDEzMiwgMTYsIDY2LCA4LCAzMywgNjgsIDY4LCA2OCwgNjgsIDY4LCA2OCwgNjgsIDY4LCAzNiwgOVxuXSksIDAsIDYpWzFdO1xuLy8gZGVmYXVsdCBvZmZzZXQgY29kZSB0YWJsZVxudmFyIGRvY3QgPSAvKiNfX1BVUkVfXyAqLyByZnNlKC8qI19fUFVSRV9fKi8gbmV3IHU4KFtcbiAgICAzMiwgMTMyLCAxNiwgNjYsIDEwMiwgNzAsIDY4LCA2OCwgNjgsIDY4LCAzNiwgNzMsIDJcbl0pLCAwLCA1KVsxXTtcbi8vIGJpdHMgdG8gYmFzZWxpbmVcbnZhciBiMmJsID0gZnVuY3Rpb24gKGIsIHMpIHtcbiAgICB2YXIgbGVuID0gYi5sZW5ndGgsIGJsID0gbmV3IGkzMihsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgYmxbaV0gPSBzO1xuICAgICAgICBzICs9IDEgPDwgYltpXTtcbiAgICB9XG4gICAgcmV0dXJuIGJsO1xufTtcbi8vIGxpdGVyYWwgbGVuZ3RoIGJpdHNcbnZhciBsbGIgPSAvKiNfX1BVUkVfXyAqLyBuZXcgdTgoKCAvKiNfX1BVUkVfXyAqL25ldyBpMzIoW1xuICAgIDAsIDAsIDAsIDAsIDE2ODQzMDA5LCA1MDUyODc3MCwgMTM0Njc4MDIwLCAyMDIwNTAwNTcsIDI2OTQyMjA5M1xuXSkpLmJ1ZmZlciwgMCwgMzYpO1xuLy8gbGl0ZXJhbCBsZW5ndGggYmFzZWxpbmVcbnZhciBsbGJsID0gLyojX19QVVJFX18gKi8gYjJibChsbGIsIDApO1xuLy8gbWF0Y2ggbGVuZ3RoIGJpdHNcbnZhciBtbGIgPSAvKiNfX1BVUkVfXyAqLyBuZXcgdTgoKCAvKiNfX1BVUkVfXyAqL25ldyBpMzIoW1xuICAgIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDE2ODQzMDA5LCA1MDUyODc3MCwgMTE3NzY5MjIwLCAxODUyMDcwNDgsIDI1MjU3OTA4NCwgMTZcbl0pKS5idWZmZXIsIDAsIDUzKTtcbi8vIG1hdGNoIGxlbmd0aCBiYXNlbGluZVxudmFyIG1sYmwgPSAvKiNfX1BVUkVfXyAqLyBiMmJsKG1sYiwgMyk7XG4vLyBkZWNvZGUgaHVmZm1hbiBzdHJlYW1cbnZhciBkaHUgPSBmdW5jdGlvbiAoZGF0LCBvdXQsIGh1KSB7XG4gICAgdmFyIGxlbiA9IGRhdC5sZW5ndGgsIHNzID0gb3V0Lmxlbmd0aCwgbGIgPSBkYXRbbGVuIC0gMV0sIG1zayA9ICgxIDw8IGh1LmIpIC0gMSwgZWIgPSAtaHUuYjtcbiAgICBpZiAoIWxiKVxuICAgICAgICBlcnIoMCk7XG4gICAgdmFyIHN0ID0gMCwgYnRyID0gaHUuYiwgcG9zID0gKGxlbiA8PCAzKSAtIDggKyBtc2IobGIpIC0gYnRyLCBpID0gLTE7XG4gICAgZm9yICg7IHBvcyA+IGViICYmIGkgPCBzczspIHtcbiAgICAgICAgdmFyIGNidCA9IHBvcyA+PiAzO1xuICAgICAgICB2YXIgdmFsID0gKGRhdFtjYnRdIHwgKGRhdFtjYnQgKyAxXSA8PCA4KSB8IChkYXRbY2J0ICsgMl0gPDwgMTYpKSA+PiAocG9zICYgNyk7XG4gICAgICAgIHN0ID0gKChzdCA8PCBidHIpIHwgdmFsKSAmIG1zaztcbiAgICAgICAgb3V0WysraV0gPSBodS5zW3N0XTtcbiAgICAgICAgcG9zIC09IChidHIgPSBodS5uW3N0XSk7XG4gICAgfVxuICAgIGlmIChwb3MgIT0gZWIgfHwgaSArIDEgIT0gc3MpXG4gICAgICAgIGVycigwKTtcbn07XG4vLyBkZWNvZGUgaHVmZm1hbiBzdHJlYW0gNHhcbi8vIFRPRE86IHVzZSB3b3JrZXJzIHRvIHBhcmFsbGVsaXplXG52YXIgZGh1NCA9IGZ1bmN0aW9uIChkYXQsIG91dCwgaHUpIHtcbiAgICB2YXIgYnQgPSA2O1xuICAgIHZhciBzcyA9IG91dC5sZW5ndGgsIHN6MSA9IChzcyArIDMpID4+IDIsIHN6MiA9IHN6MSA8PCAxLCBzejMgPSBzejEgKyBzejI7XG4gICAgZGh1KGRhdC5zdWJhcnJheShidCwgYnQgKz0gZGF0WzBdIHwgKGRhdFsxXSA8PCA4KSksIG91dC5zdWJhcnJheSgwLCBzejEpLCBodSk7XG4gICAgZGh1KGRhdC5zdWJhcnJheShidCwgYnQgKz0gZGF0WzJdIHwgKGRhdFszXSA8PCA4KSksIG91dC5zdWJhcnJheShzejEsIHN6MiksIGh1KTtcbiAgICBkaHUoZGF0LnN1YmFycmF5KGJ0LCBidCArPSBkYXRbNF0gfCAoZGF0WzVdIDw8IDgpKSwgb3V0LnN1YmFycmF5KHN6Miwgc3ozKSwgaHUpO1xuICAgIGRodShkYXQuc3ViYXJyYXkoYnQpLCBvdXQuc3ViYXJyYXkoc3ozKSwgaHUpO1xufTtcbi8vIHJlYWQgWnN0YW5kYXJkIGJsb2NrXG52YXIgcnpiID0gZnVuY3Rpb24gKGRhdCwgc3QsIG91dCkge1xuICAgIHZhciBfYTtcbiAgICB2YXIgYnQgPSBzdC5iO1xuICAgIC8vICAgIGJ5dGUgMCAgICAgICAgYmxvY2sgdHlwZVxuICAgIHZhciBiMCA9IGRhdFtidF0sIGJ0eXBlID0gKGIwID4+IDEpICYgMztcbiAgICBzdC5sID0gYjAgJiAxO1xuICAgIHZhciBzeiA9IChiMCA+PiAzKSB8IChkYXRbYnQgKyAxXSA8PCA1KSB8IChkYXRbYnQgKyAyXSA8PCAxMyk7XG4gICAgLy8gZW5kIGJ5dGUgZm9yIGJsb2NrXG4gICAgdmFyIGVidCA9IChidCArPSAzKSArIHN6O1xuICAgIGlmIChidHlwZSA9PSAxKSB7XG4gICAgICAgIGlmIChidCA+PSBkYXQubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBzdC5iID0gYnQgKyAxO1xuICAgICAgICBpZiAob3V0KSB7XG4gICAgICAgICAgICBmaWxsKG91dCwgZGF0W2J0XSwgc3QueSwgc3QueSArPSBzeik7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaWxsKG5ldyB1OChzeiksIGRhdFtidF0pO1xuICAgIH1cbiAgICBpZiAoZWJ0ID4gZGF0Lmxlbmd0aClcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmIChidHlwZSA9PSAwKSB7XG4gICAgICAgIHN0LmIgPSBlYnQ7XG4gICAgICAgIGlmIChvdXQpIHtcbiAgICAgICAgICAgIG91dC5zZXQoZGF0LnN1YmFycmF5KGJ0LCBlYnQpLCBzdC55KTtcbiAgICAgICAgICAgIHN0LnkgKz0gc3o7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzbGMoZGF0LCBidCwgZWJ0KTtcbiAgICB9XG4gICAgaWYgKGJ0eXBlID09IDIpIHtcbiAgICAgICAgLy8gICAgYnl0ZSAzICAgICAgICBsaXQgYnR5cGUgICAgIHNpemUgZm9ybWF0XG4gICAgICAgIHZhciBiMyA9IGRhdFtidF0sIGxidCA9IGIzICYgMywgc2YgPSAoYjMgPj4gMikgJiAzO1xuICAgICAgICAvLyBsaXQgc3JjIHNpemUgIGxpdCBjbXAgc3ogNCBzdHJlYW1zXG4gICAgICAgIHZhciBsc3MgPSBiMyA+PiA0LCBsY3MgPSAwLCBzNCA9IDA7XG4gICAgICAgIGlmIChsYnQgPCAyKSB7XG4gICAgICAgICAgICBpZiAoc2YgJiAxKVxuICAgICAgICAgICAgICAgIGxzcyB8PSAoZGF0WysrYnRdIDw8IDQpIHwgKChzZiAmIDIpICYmIChkYXRbKytidF0gPDwgMTIpKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBsc3MgPSBiMyA+PiAzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgczQgPSBzZjtcbiAgICAgICAgICAgIGlmIChzZiA8IDIpXG4gICAgICAgICAgICAgICAgbHNzIHw9ICgoZGF0WysrYnRdICYgNjMpIDw8IDQpLCBsY3MgPSAoZGF0W2J0XSA+PiA2KSB8IChkYXRbKytidF0gPDwgMik7XG4gICAgICAgICAgICBlbHNlIGlmIChzZiA9PSAyKVxuICAgICAgICAgICAgICAgIGxzcyB8PSAoZGF0WysrYnRdIDw8IDQpIHwgKChkYXRbKytidF0gJiAzKSA8PCAxMiksIGxjcyA9IChkYXRbYnRdID4+IDIpIHwgKGRhdFsrK2J0XSA8PCA2KTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBsc3MgfD0gKGRhdFsrK2J0XSA8PCA0KSB8ICgoZGF0WysrYnRdICYgNjMpIDw8IDEyKSwgbGNzID0gKGRhdFtidF0gPj4gNikgfCAoZGF0WysrYnRdIDw8IDIpIHwgKGRhdFsrK2J0XSA8PCAxMCk7XG4gICAgICAgIH1cbiAgICAgICAgKytidDtcbiAgICAgICAgLy8gYWRkIGxpdGVyYWxzIHRvIGVuZCAtIGNhbiBuZXZlciBvdmVybGFwIHdpdGggYmFja3JlZmVyZW5jZXMgYmVjYXVzZSB1bnVzZWQgbGl0ZXJhbHMgYWx3YXlzIGFwcGVuZGVkXG4gICAgICAgIHZhciBidWYgPSBvdXQgPyBvdXQuc3ViYXJyYXkoc3QueSwgc3QueSArIHN0Lm0pIDogbmV3IHU4KHN0Lm0pO1xuICAgICAgICAvLyBzdGFydGluZyBwb2ludCBmb3IgbGl0ZXJhbHNcbiAgICAgICAgdmFyIHNwbCA9IGJ1Zi5sZW5ndGggLSBsc3M7XG4gICAgICAgIGlmIChsYnQgPT0gMClcbiAgICAgICAgICAgIGJ1Zi5zZXQoZGF0LnN1YmFycmF5KGJ0LCBidCArPSBsc3MpLCBzcGwpO1xuICAgICAgICBlbHNlIGlmIChsYnQgPT0gMSlcbiAgICAgICAgICAgIGZpbGwoYnVmLCBkYXRbYnQrK10sIHNwbCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gaHVmZm1hbiB0YWJsZVxuICAgICAgICAgICAgdmFyIGh1ID0gc3QuaDtcbiAgICAgICAgICAgIGlmIChsYnQgPT0gMikge1xuICAgICAgICAgICAgICAgIHZhciBodWQgPSByaHUoZGF0LCBidCk7XG4gICAgICAgICAgICAgICAgLy8gc3VidHJhY3QgZGVzY3JpcHRpb24gbGVuZ3RoXG4gICAgICAgICAgICAgICAgbGNzICs9IGJ0IC0gKGJ0ID0gaHVkWzBdKTtcbiAgICAgICAgICAgICAgICBzdC5oID0gaHUgPSBodWRbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghaHUpXG4gICAgICAgICAgICAgICAgZXJyKDApO1xuICAgICAgICAgICAgKHM0ID8gZGh1NCA6IGRodSkoZGF0LnN1YmFycmF5KGJ0LCBidCArPSBsY3MpLCBidWYuc3ViYXJyYXkoc3BsKSwgaHUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG51bSBzZXF1ZW5jZXNcbiAgICAgICAgdmFyIG5zID0gZGF0W2J0KytdO1xuICAgICAgICBpZiAobnMpIHtcbiAgICAgICAgICAgIGlmIChucyA9PSAyNTUpXG4gICAgICAgICAgICAgICAgbnMgPSAoZGF0W2J0KytdIHwgKGRhdFtidCsrXSA8PCA4KSkgKyAweDdGMDA7XG4gICAgICAgICAgICBlbHNlIGlmIChucyA+IDEyNylcbiAgICAgICAgICAgICAgICBucyA9ICgobnMgLSAxMjgpIDw8IDgpIHwgZGF0W2J0KytdO1xuICAgICAgICAgICAgLy8gc3ltYm9sIGNvbXByZXNzaW9uIG1vZGVzXG4gICAgICAgICAgICB2YXIgc2NtID0gZGF0W2J0KytdO1xuICAgICAgICAgICAgaWYgKHNjbSAmIDMpXG4gICAgICAgICAgICAgICAgZXJyKDApO1xuICAgICAgICAgICAgdmFyIGR0cyA9IFtkbWx0LCBkb2N0LCBkbGx0XTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAyOyBpID4gLTE7IC0taSkge1xuICAgICAgICAgICAgICAgIHZhciBtZCA9IChzY20gPj4gKChpIDw8IDEpICsgMikpICYgMztcbiAgICAgICAgICAgICAgICBpZiAobWQgPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBybGUgYnVmXG4gICAgICAgICAgICAgICAgICAgIHZhciByYnVmID0gbmV3IHU4KFswLCAwLCBkYXRbYnQrK11dKTtcbiAgICAgICAgICAgICAgICAgICAgZHRzW2ldID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgczogcmJ1Zi5zdWJhcnJheSgyLCAzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG46IHJidWYuc3ViYXJyYXkoMCwgMSksXG4gICAgICAgICAgICAgICAgICAgICAgICB0OiBuZXcgdTE2KHJidWYuYnVmZmVyLCAwLCAxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGI6IDBcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobWQgPT0gMikge1xuICAgICAgICAgICAgICAgICAgICAvLyBhY2N1cmFjeSBsb2cgOCBmb3Igb2Zmc2V0cywgOSBmb3Igb3RoZXJzXG4gICAgICAgICAgICAgICAgICAgIF9hID0gcmZzZShkYXQsIGJ0LCA5IC0gKGkgJiAxKSksIGJ0ID0gX2FbMF0sIGR0c1tpXSA9IF9hWzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtZCA9PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc3QudClcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycigwKTtcbiAgICAgICAgICAgICAgICAgICAgZHRzW2ldID0gc3QudFtpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX2IgPSBzdC50ID0gZHRzLCBtbHQgPSBfYlswXSwgb2N0ID0gX2JbMV0sIGxsdCA9IF9iWzJdO1xuICAgICAgICAgICAgdmFyIGxiID0gZGF0W2VidCAtIDFdO1xuICAgICAgICAgICAgaWYgKCFsYilcbiAgICAgICAgICAgICAgICBlcnIoMCk7XG4gICAgICAgICAgICB2YXIgc3BvcyA9IChlYnQgPDwgMykgLSA4ICsgbXNiKGxiKSAtIGxsdC5iLCBjYnQgPSBzcG9zID4+IDMsIG91YnQgPSAwO1xuICAgICAgICAgICAgdmFyIGxzdCA9ICgoZGF0W2NidF0gfCAoZGF0W2NidCArIDFdIDw8IDgpKSA+PiAoc3BvcyAmIDcpKSAmICgoMSA8PCBsbHQuYikgLSAxKTtcbiAgICAgICAgICAgIGNidCA9IChzcG9zIC09IG9jdC5iKSA+PiAzO1xuICAgICAgICAgICAgdmFyIG9zdCA9ICgoZGF0W2NidF0gfCAoZGF0W2NidCArIDFdIDw8IDgpKSA+PiAoc3BvcyAmIDcpKSAmICgoMSA8PCBvY3QuYikgLSAxKTtcbiAgICAgICAgICAgIGNidCA9IChzcG9zIC09IG1sdC5iKSA+PiAzO1xuICAgICAgICAgICAgdmFyIG1zdCA9ICgoZGF0W2NidF0gfCAoZGF0W2NidCArIDFdIDw8IDgpKSA+PiAoc3BvcyAmIDcpKSAmICgoMSA8PCBtbHQuYikgLSAxKTtcbiAgICAgICAgICAgIGZvciAoKytuczsgLS1uczspIHtcbiAgICAgICAgICAgICAgICB2YXIgbGxjID0gbGx0LnNbbHN0XTtcbiAgICAgICAgICAgICAgICB2YXIgbGJ0ciA9IGxsdC5uW2xzdF07XG4gICAgICAgICAgICAgICAgdmFyIG1sYyA9IG1sdC5zW21zdF07XG4gICAgICAgICAgICAgICAgdmFyIG1idHIgPSBtbHQublttc3RdO1xuICAgICAgICAgICAgICAgIHZhciBvZmMgPSBvY3Quc1tvc3RdO1xuICAgICAgICAgICAgICAgIHZhciBvYnRyID0gb2N0Lm5bb3N0XTtcbiAgICAgICAgICAgICAgICBjYnQgPSAoc3BvcyAtPSBvZmMpID4+IDM7XG4gICAgICAgICAgICAgICAgdmFyIG9mcCA9IDEgPDwgb2ZjO1xuICAgICAgICAgICAgICAgIHZhciBvZmYgPSBvZnAgKyAoKChkYXRbY2J0XSB8IChkYXRbY2J0ICsgMV0gPDwgOCkgfCAoZGF0W2NidCArIDJdIDw8IDE2KSB8IChkYXRbY2J0ICsgM10gPDwgMjQpKSA+Pj4gKHNwb3MgJiA3KSkgJiAob2ZwIC0gMSkpO1xuICAgICAgICAgICAgICAgIGNidCA9IChzcG9zIC09IG1sYlttbGNdKSA+PiAzO1xuICAgICAgICAgICAgICAgIHZhciBtbCA9IG1sYmxbbWxjXSArICgoKGRhdFtjYnRdIHwgKGRhdFtjYnQgKyAxXSA8PCA4KSB8IChkYXRbY2J0ICsgMl0gPDwgMTYpKSA+PiAoc3BvcyAmIDcpKSAmICgoMSA8PCBtbGJbbWxjXSkgLSAxKSk7XG4gICAgICAgICAgICAgICAgY2J0ID0gKHNwb3MgLT0gbGxiW2xsY10pID4+IDM7XG4gICAgICAgICAgICAgICAgdmFyIGxsID0gbGxibFtsbGNdICsgKCgoZGF0W2NidF0gfCAoZGF0W2NidCArIDFdIDw8IDgpIHwgKGRhdFtjYnQgKyAyXSA8PCAxNikpID4+IChzcG9zICYgNykpICYgKCgxIDw8IGxsYltsbGNdKSAtIDEpKTtcbiAgICAgICAgICAgICAgICBjYnQgPSAoc3BvcyAtPSBsYnRyKSA+PiAzO1xuICAgICAgICAgICAgICAgIGxzdCA9IGxsdC50W2xzdF0gKyAoKChkYXRbY2J0XSB8IChkYXRbY2J0ICsgMV0gPDwgOCkpID4+IChzcG9zICYgNykpICYgKCgxIDw8IGxidHIpIC0gMSkpO1xuICAgICAgICAgICAgICAgIGNidCA9IChzcG9zIC09IG1idHIpID4+IDM7XG4gICAgICAgICAgICAgICAgbXN0ID0gbWx0LnRbbXN0XSArICgoKGRhdFtjYnRdIHwgKGRhdFtjYnQgKyAxXSA8PCA4KSkgPj4gKHNwb3MgJiA3KSkgJiAoKDEgPDwgbWJ0cikgLSAxKSk7XG4gICAgICAgICAgICAgICAgY2J0ID0gKHNwb3MgLT0gb2J0cikgPj4gMztcbiAgICAgICAgICAgICAgICBvc3QgPSBvY3QudFtvc3RdICsgKCgoZGF0W2NidF0gfCAoZGF0W2NidCArIDFdIDw8IDgpKSA+PiAoc3BvcyAmIDcpKSAmICgoMSA8PCBvYnRyKSAtIDEpKTtcbiAgICAgICAgICAgICAgICBpZiAob2ZmID4gMykge1xuICAgICAgICAgICAgICAgICAgICBzdC5vWzJdID0gc3Qub1sxXTtcbiAgICAgICAgICAgICAgICAgICAgc3Qub1sxXSA9IHN0Lm9bMF07XG4gICAgICAgICAgICAgICAgICAgIHN0Lm9bMF0gPSBvZmYgLT0gMztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpZHggPSBvZmYgLSAobGwgIT0gMCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZiA9IGlkeCA9PSAzID8gc3Qub1swXSAtIDEgOiBzdC5vW2lkeF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWR4ID4gMSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdC5vWzJdID0gc3Qub1sxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0Lm9bMV0gPSBzdC5vWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3Qub1swXSA9IG9mZjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBvZmYgPSBzdC5vWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxsOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmW291YnQgKyBpXSA9IGJ1ZltzcGwgKyBpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3VidCArPSBsbCwgc3BsICs9IGxsO1xuICAgICAgICAgICAgICAgIHZhciBzdGluID0gb3VidCAtIG9mZjtcbiAgICAgICAgICAgICAgICBpZiAoc3RpbiA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxlbiA9IC1zdGluO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYnMgPSBzdC5lICsgc3RpbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxlbiA+IG1sKVxuICAgICAgICAgICAgICAgICAgICAgICAgbGVuID0gbWw7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZltvdWJ0ICsgaV0gPSBzdC53W2JzICsgaV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb3VidCArPSBsZW4sIG1sIC09IGxlbiwgc3RpbiA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWw7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBidWZbb3VidCArIGldID0gYnVmW3N0aW4gKyBpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3VidCArPSBtbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvdWJ0ICE9IHNwbCkge1xuICAgICAgICAgICAgICAgIHdoaWxlIChzcGwgPCBidWYubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZltvdWJ0KytdID0gYnVmW3NwbCsrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgb3VidCA9IGJ1Zi5sZW5ndGg7XG4gICAgICAgICAgICBpZiAob3V0KVxuICAgICAgICAgICAgICAgIHN0LnkgKz0gb3VidDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBidWYgPSBzbGMoYnVmLCAwLCBvdWJ0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChvdXQpIHtcbiAgICAgICAgICAgICAgICBzdC55ICs9IGxzcztcbiAgICAgICAgICAgICAgICBpZiAoc3BsKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbHNzOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZltpXSA9IGJ1ZltzcGwgKyBpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNwbClcbiAgICAgICAgICAgICAgICBidWYgPSBzbGMoYnVmLCBzcGwpO1xuICAgICAgICB9XG4gICAgICAgIHN0LmIgPSBlYnQ7XG4gICAgICAgIHJldHVybiBidWY7XG4gICAgfVxuICAgIGVycigyKTtcbn07XG4vLyBjb25jYXRcbnZhciBjY3QgPSBmdW5jdGlvbiAoYnVmcywgb2wpIHtcbiAgICBpZiAoYnVmcy5sZW5ndGggPT0gMSlcbiAgICAgICAgcmV0dXJuIGJ1ZnNbMF07XG4gICAgdmFyIGJ1ZiA9IG5ldyB1OChvbCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGIgPSAwOyBpIDwgYnVmcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgY2hrID0gYnVmc1tpXTtcbiAgICAgICAgYnVmLnNldChjaGssIGIpO1xuICAgICAgICBiICs9IGNoay5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiBidWY7XG59O1xuLyoqXG4gKiBEZWNvbXByZXNzZXMgWnN0YW5kYXJkIGRhdGFcbiAqIEBwYXJhbSBkYXQgVGhlIGlucHV0IGRhdGFcbiAqIEBwYXJhbSBidWYgVGhlIG91dHB1dCBidWZmZXIuIElmIHVuc3BlY2lmaWVkLCB0aGUgZnVuY3Rpb24gd2lsbCBhbGxvY2F0ZVxuICogICAgICAgICAgICBleGFjdGx5IGVub3VnaCBtZW1vcnkgdG8gZml0IHRoZSBkZWNvbXByZXNzZWQgZGF0YS4gSWYgeW91clxuICogICAgICAgICAgICBkYXRhIGhhcyBtdWx0aXBsZSBmcmFtZXMgYW5kIHlvdSBrbm93IHRoZSBvdXRwdXQgc2l6ZSwgc3BlY2lmeWluZ1xuICogICAgICAgICAgICBpdCB3aWxsIHlpZWxkIGJldHRlciBwZXJmb3JtYW5jZS5cbiAqIEByZXR1cm5zIFRoZSBkZWNvbXByZXNzZWQgZGF0YVxuICovXG5yZXR1cm4gZnVuY3Rpb24gZGVjb21wcmVzcyhkYXQsIGJ1Zikge1xuICAgIHZhciBidCA9IDAsIGJ1ZnMgPSBbXSwgbmIgPSArIWJ1Ziwgb2wgPSAwO1xuICAgIGZvciAoOyBkYXQubGVuZ3RoOykge1xuICAgICAgICB2YXIgc3QgPSByemZoKGRhdCwgbmIgfHwgYnVmKTtcbiAgICAgICAgaWYgKHR5cGVvZiBzdCA9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgaWYgKG5iKSB7XG4gICAgICAgICAgICAgICAgYnVmID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoc3Qudy5sZW5ndGggPT0gc3QudSkge1xuICAgICAgICAgICAgICAgICAgICBidWZzLnB1c2goYnVmID0gc3Qudyk7XG4gICAgICAgICAgICAgICAgICAgIG9sICs9IHN0LnU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnVmcy5wdXNoKGJ1Zik7XG4gICAgICAgICAgICAgICAgc3QuZSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKDsgIXN0Lmw7KSB7XG4gICAgICAgICAgICAgICAgdmFyIGJsayA9IHJ6YihkYXQsIHN0LCBidWYpO1xuICAgICAgICAgICAgICAgIGlmICghYmxrKVxuICAgICAgICAgICAgICAgICAgICBlcnIoNSk7XG4gICAgICAgICAgICAgICAgaWYgKGJ1ZilcbiAgICAgICAgICAgICAgICAgICAgc3QuZSA9IHN0Lnk7XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZnMucHVzaChibGspO1xuICAgICAgICAgICAgICAgICAgICBvbCArPSBibGsubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBjcHcoc3QudywgMCwgYmxrLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIHN0Lncuc2V0KGJsaywgc3Qudy5sZW5ndGggLSBibGsubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidCA9IHN0LmIgKyAoc3QuYyAqIDQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGJ0ID0gc3Q7XG4gICAgICAgIGRhdCA9IGRhdC5zdWJhcnJheShidCk7XG4gICAgfVxuICAgIHJldHVybiBjY3QoYnVmcywgb2wpO1xufVxufSkgKClcblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2RlY29tcHJlc3NfaW5wdXRcbi8vVmVyc2lvbjogPCA1LjEuMFxudmFyIGNhbWxfZGVjb21wcmVzc19pbnB1dCA9IG51bGxcblxuLy9Qcm92aWRlczogY2FtbF9kZWNvbXByZXNzX2lucHV0XG4vL1ZlcnNpb246ID49IDUuMS4wXG4vL1ZlcnNpb246IDwgNS4xLjFcbi8vUmVxdWlyZXM6IHpzdGRfZGVjb21wcmVzc1xudmFyIGNhbWxfZGVjb21wcmVzc19pbnB1dCA9IHpzdGRfZGVjb21wcmVzcztcblxuLy9Qcm92aWRlczogY2FtbF9kZWNvbXByZXNzX2lucHV0XG4vL1ZlcnNpb246ID49IDUuMS4xXG4vL1ZlcnNpb246IDwgNS4yLjBcbnZhciBjYW1sX2RlY29tcHJlc3NfaW5wdXQgPSBudWxsXG5cbi8vUHJvdmlkZXM6IGNhbWxfZGVjb21wcmVzc19pbnB1dFxuLy9WZXJzaW9uOiA+PSA1LjJcbi8vUmVxdWlyZXM6IHpzdGRfZGVjb21wcmVzc1xudmFyIGNhbWxfZGVjb21wcmVzc19pbnB1dCA9IHpzdGRfZGVjb21wcmVzcztcblxuLy9Qcm92aWRlczogY2FtbF96c3RkX2luaXRpYWxpemVcbi8vUmVxdWlyZXM6IGNhbWxfZGVjb21wcmVzc19pbnB1dFxuLy9SZXF1aXJlczogenN0ZF9kZWNvbXByZXNzXG4vL1ZlcnNpb246ID49IDUuMS4xXG5mdW5jdGlvbiBjYW1sX3pzdGRfaW5pdGlhbGl6ZSh1bml0KSB7XG4gIGNhbWxfZGVjb21wcmVzc19pbnB1dCA9IHpzdGRfZGVjb21wcmVzcztcbiAgcmV0dXJuIDFcbn1cblxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwIErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vIFdlYWsgQVBJXG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9rZXlfb2Zmc2V0XG52YXIgY2FtbF9lcGhlX2tleV9vZmZzZXQgPSAzXG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9kYXRhX29mZnNldFxudmFyIGNhbWxfZXBoZV9kYXRhX29mZnNldCA9IDJcblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX3NldF9rZXlcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9lcGhlX2tleV9vZmZzZXRcbmZ1bmN0aW9uIGNhbWxfZXBoZV9zZXRfa2V5KHgsIGksIHYpIHtcbiAgaWYoaSA8IDAgfHwgY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpID49IHgubGVuZ3RoKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudCAoXCJXZWFrLnNldFwiKTtcbiAgaWYgKHYgaW5zdGFuY2VvZiBPYmplY3QgJiYgZ2xvYmFsVGhpcy5XZWFrUmVmKSB7XG4gICAgaWYoeFsxXS5yZWdpc3RlcikgeFsxXS5yZWdpc3Rlcih2LCB1bmRlZmluZWQsIHYpO1xuICAgIHhbY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpXSA9IG5ldyBnbG9iYWxUaGlzLldlYWtSZWYodik7XG4gIH1cbiAgZWxzZSB4W2NhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaV0gPSB2O1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfdW5zZXRfa2V5XG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfZXBoZV9rZXlfb2Zmc2V0XG5mdW5jdGlvbiBjYW1sX2VwaGVfdW5zZXRfa2V5KHgsIGkpIHtcbiAgaWYoaSA8IDAgfHwgY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpID49IHgubGVuZ3RoKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudCAoXCJXZWFrLnNldFwiKTtcbiAgaWYoZ2xvYmFsVGhpcy5XZWFrUmVmICYmIHhbY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpXSBpbnN0YW5jZW9mIGdsb2JhbFRoaXMuV2Vha1JlZiAmJiB4WzFdLnVucmVnaXN0ZXIpIHtcbiAgICB2YXIgb2xkID0geFtjYW1sX2VwaGVfa2V5X29mZnNldCArIGldLmRlcmVmKCk7XG4gICAgaWYob2xkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBjb3VudCA9IDBcbiAgICAgIGZvcih2YXIgaiA9IGNhbWxfZXBoZV9rZXlfb2Zmc2V0OyBqIDwgeC5sZW5ndGg7IGorKyl7XG4gICAgICAgIHZhciBrZXkgPSB4W2pdO1xuICAgICAgICBpZihrZXkgaW5zdGFuY2VvZiBnbG9iYWxUaGlzLldlYWtSZWYpe1xuICAgICAgICAgIGtleSA9IGtleS5kZXJlZigpXG4gICAgICAgICAgaWYoa2V5ID09PSBvbGQpIGNvdW50Kys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmKGNvdW50ID09IDEpIHhbMV0udW5yZWdpc3RlcihvbGQpO1xuICAgIH1cbiAgfVxuICB4W2NhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaV0gPSB1bmRlZmluZWQ7XG4gIHJldHVybiAwXG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2NyZWF0ZVxuLy9SZXF1aXJlczogY2FtbF93ZWFrX2NyZWF0ZSwgY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XG5mdW5jdGlvbiBjYW1sX2VwaGVfY3JlYXRlIChuKSB7XG4gIHZhciB4ID0gY2FtbF93ZWFrX2NyZWF0ZShuKTtcbiAgcmV0dXJuIHg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfd2Vha19jcmVhdGVcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9rZXlfb2Zmc2V0LCBjYW1sX2ludmFsaWRfYXJndW1lbnQsY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XG5mdW5jdGlvbiBjYW1sX3dlYWtfY3JlYXRlIChuKSB7XG4gIGlmIChuIDwgMCkgY2FtbF9pbnZhbGlkX2FyZ3VtZW50IChcIldlYWsuY3JlYXRlXCIpO1xuICB2YXIgeCA9IFsyNTEsXCJjYW1sX2VwaGVfbGlzdF9oZWFkXCJdO1xuICB4Lmxlbmd0aCA9IGNhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgbjtcbiAgcmV0dXJuIHg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfd2Vha19zZXRcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuLy9SZXF1aXJlczogY2FtbF9lcGhlX3NldF9rZXksIGNhbWxfZXBoZV91bnNldF9rZXlcbmZ1bmN0aW9uIGNhbWxfd2Vha19zZXQoeCwgaSwgdikge1xuICBpZih2ID09IDApIGNhbWxfZXBoZV91bnNldF9rZXkoeCxpKVxuICBlbHNlIGNhbWxfZXBoZV9zZXRfa2V5KHgsaSx2WzFdKVxuICByZXR1cm4gMDtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9nZXRfa2V5XG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfa2V5X29mZnNldCwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG4vL0FsaWFzOiBjYW1sX3dlYWtfZ2V0XG5mdW5jdGlvbiBjYW1sX2VwaGVfZ2V0X2tleSh4LCBpKSB7XG4gIGlmKGkgPCAwIHx8IGNhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaSA+PSB4Lmxlbmd0aClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQgKFwiV2Vhay5nZXRfa2V5XCIpO1xuICB2YXIgd2VhayA9IHhbY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpIF07XG4gIGlmKGdsb2JhbFRoaXMuV2Vha1JlZiAmJiB3ZWFrIGluc3RhbmNlb2YgZ2xvYmFsVGhpcy5XZWFrUmVmKSB3ZWFrID0gd2Vhay5kZXJlZigpO1xuICByZXR1cm4gKHdlYWs9PT11bmRlZmluZWQpPzA6WzAsIHdlYWtdO1xufVxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2dldF9rZXlfY29weVxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2dldF9rZXksY2FtbF9lcGhlX2tleV9vZmZzZXRcbi8vUmVxdWlyZXM6IGNhbWxfb2JqX2R1cCwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG4vL0FsaWFzOiBjYW1sX3dlYWtfZ2V0X2NvcHlcbmZ1bmN0aW9uIGNhbWxfZXBoZV9nZXRfa2V5X2NvcHkoeCwgaSkge1xuICBpZihpIDwgMCB8fCBjYW1sX2VwaGVfa2V5X29mZnNldCArIGkgPj0geC5sZW5ndGgpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50IChcIldlYWsuZ2V0X2NvcHlcIik7XG4gIHZhciB5ID0gY2FtbF9lcGhlX2dldF9rZXkoeCwgaSk7XG4gIGlmICh5ID09PSAwKSByZXR1cm4geTtcbiAgdmFyIHogPSB5WzFdO1xuICBpZiAoeiBpbnN0YW5jZW9mIEFycmF5KSByZXR1cm4gWzAsIGNhbWxfb2JqX2R1cCh6KV07XG4gIHJldHVybiB5O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfY2hlY2tfa2V5IG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9rZXlfb2Zmc2V0XG4vL0FsaWFzOiBjYW1sX3dlYWtfY2hlY2tcbmZ1bmN0aW9uIGNhbWxfZXBoZV9jaGVja19rZXkoeCwgaSkge1xuICB2YXIgd2VhayA9IHhbY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpXTtcbiAgaWYoZ2xvYmFsVGhpcy5XZWFrUmVmICYmIHdlYWsgaW5zdGFuY2VvZiBnbG9iYWxUaGlzLldlYWtSZWYpIHdlYWsgPSB3ZWFrLmRlcmVmKCk7XG4gIGlmKHdlYWs9PT11bmRlZmluZWQpXG4gICAgcmV0dXJuIDA7XG4gIGVsc2VcbiAgICByZXR1cm4gMTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2JsaXRfa2V5XG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JsaXRcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9rZXlfb2Zmc2V0XG4vL0FsaWFzOiBjYW1sX3dlYWtfYmxpdFxuZnVuY3Rpb24gY2FtbF9lcGhlX2JsaXRfa2V5KGExLCBpMSwgYTIsIGkyLCBsZW4pIHtcbiAgLy8gbWludXMgb25lIGJlY2F1c2UgY2FtbF9hcnJheV9ibGl0IHdvcmtzIG9uIG9jYW1sIGFycmF5XG4gIGNhbWxfYXJyYXlfYmxpdChhMSwgY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpMSAtIDEsXG4gICAgICAgICAgICAgICAgICBhMiwgY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpMiAtIDEsXG4gICAgICAgICAgICAgICAgICBsZW4pO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2JsaXRfZGF0YVxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2RhdGFfb2Zmc2V0LCBjYW1sX2VwaGVfc2V0X2RhdGEsIGNhbWxfZXBoZV91bnNldF9kYXRhXG5mdW5jdGlvbiBjYW1sX2VwaGVfYmxpdF9kYXRhKHNyYywgZHN0KXtcbiAgdmFyIG4gPSBzcmNbY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XTtcbiAgaWYobiA9PT0gdW5kZWZpbmVkKSBjYW1sX2VwaGVfdW5zZXRfZGF0YShkc3QpO1xuICBlbHNlIGNhbWxfZXBoZV9zZXRfZGF0YShkc3QsIG4pO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2dldF9kYXRhXG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfZGF0YV9vZmZzZXRcbmZ1bmN0aW9uIGNhbWxfZXBoZV9nZXRfZGF0YSh4KXtcbiAgaWYoeFtjYW1sX2VwaGVfZGF0YV9vZmZzZXRdID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIDA7XG4gIGVsc2VcbiAgICByZXR1cm4gWzAsIHhbY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XV07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9nZXRfZGF0YV9jb3B5XG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfZGF0YV9vZmZzZXRcbi8vUmVxdWlyZXM6IGNhbWxfb2JqX2R1cFxuZnVuY3Rpb24gY2FtbF9lcGhlX2dldF9kYXRhX2NvcHkoeCl7XG4gIGlmKHhbY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XSA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiAwO1xuICBlbHNlXG4gICAgcmV0dXJuIFswLCBjYW1sX29ial9kdXAoeFtjYW1sX2VwaGVfZGF0YV9vZmZzZXRdKV07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9zZXRfZGF0YVxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2RhdGFfb2Zmc2V0LCBjYW1sX2VwaGVfa2V5X29mZnNldCwgY2FtbF9lcGhlX3Vuc2V0X2RhdGFcbmZ1bmN0aW9uIGNhbWxfZXBoZV9zZXRfZGF0YSh4LCBkYXRhKXtcbiAgaWYoZ2xvYmFsVGhpcy5GaW5hbGl6YXRpb25SZWdpc3RyeSAmJiBnbG9iYWxUaGlzLldlYWtSZWYpIHtcbiAgICBpZighICh4WzFdIGluc3RhbmNlb2YgZ2xvYmFsVGhpcy5GaW5hbGl6YXRpb25SZWdpc3RyeSkpIHtcbiAgICAgIHhbMV0gPSBuZXcgZ2xvYmFsVGhpcy5GaW5hbGl6YXRpb25SZWdpc3RyeShmdW5jdGlvbiAoKSB7IGNhbWxfZXBoZV91bnNldF9kYXRhKHgpIH0pO1xuICAgICAgLy9yZWdpc3RlciBhbGwga2V5c1xuICAgICAgZm9yKHZhciBqID0gY2FtbF9lcGhlX2tleV9vZmZzZXQ7IGogPCB4Lmxlbmd0aDsgaisrKXtcbiAgICAgICAgdmFyIGtleSA9IHhbal07XG4gICAgICAgIGlmKGtleSBpbnN0YW5jZW9mIGdsb2JhbFRoaXMuV2Vha1JlZikge1xuICAgICAgICAgIGtleSA9IGtleS5kZXJlZigpO1xuICAgICAgICAgIGlmKGtleSkgeFsxXS5yZWdpc3RlcihrZXksIHVuZGVmaW5lZCwga2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICB4W2NhbWxfZXBoZV9kYXRhX29mZnNldF0gPSBkYXRhO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX3Vuc2V0X2RhdGFcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9kYXRhX29mZnNldCwgY2FtbF9lcGhlX2tleV9vZmZzZXRcbmZ1bmN0aW9uIGNhbWxfZXBoZV91bnNldF9kYXRhKHgpe1xuICBpZihnbG9iYWxUaGlzLkZpbmFsaXphdGlvblJlZ2lzdHJ5ICYmIGdsb2JhbFRoaXMuV2Vha1JlZikge1xuICAgIGlmKHhbMV0gaW5zdGFuY2VvZiBnbG9iYWxUaGlzLkZpbmFsaXphdGlvblJlZ2lzdHJ5KXtcbiAgICAgIC8vdW5yZWdpc3RlciBhbGwga2V5c1xuICAgICAgZm9yKHZhciBqID0gY2FtbF9lcGhlX2tleV9vZmZzZXQ7IGogPCB4Lmxlbmd0aDsgaisrKXtcbiAgICAgICAgdmFyIGtleSA9IHhbal07XG4gICAgICAgIGlmKGtleSBpbnN0YW5jZW9mIGdsb2JhbFRoaXMuV2Vha1JlZikge1xuICAgICAgICAgIGtleSA9IGtleS5kZXJlZigpO1xuICAgICAgICAgIGlmKGtleSkgeFsxXS51bnJlZ2lzdGVyKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgeFtjYW1sX2VwaGVfZGF0YV9vZmZzZXRdID0gdW5kZWZpbmVkO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2NoZWNrX2RhdGFcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9kYXRhX29mZnNldFxuZnVuY3Rpb24gY2FtbF9lcGhlX2NoZWNrX2RhdGEoeCl7XG4gIGlmKHhbY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XSA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiAwO1xuICBlbHNlXG4gICAgcmV0dXJuIDE7XG59XG4iLCJcblxuLy9Qcm92aWRlczogY2FtbF9nY19taW5vclxuZnVuY3Rpb24gY2FtbF9nY19taW5vcih1bml0KXtcbiAgLy9hdmFpbGFibGUgd2l0aCBbbm9kZSAtLWV4cG9zZS1nY11cbiAgaWYodHlwZW9mIGdsb2JhbFRoaXMuZ2MgPT0gJ2Z1bmN0aW9uJykgZ2xvYmFsVGhpcy5nYyh0cnVlKTtcbiAgcmV0dXJuIDBcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ2NfbWFqb3JcbmZ1bmN0aW9uIGNhbWxfZ2NfbWFqb3IodW5pdCl7XG4gIC8vYXZhaWxhYmxlIHdpdGggW25vZGUgLS1leHBvc2UtZ2NdXG4gIGlmKHR5cGVvZiBnbG9iYWxUaGlzLmdjID09ICdmdW5jdGlvbicpIGdsb2JhbFRoaXMuZ2MoKTtcbiAgcmV0dXJuIDBcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ2NfZnVsbF9tYWpvclxuZnVuY3Rpb24gY2FtbF9nY19mdWxsX21ham9yKHVuaXQpe1xuICAvL2F2YWlsYWJsZSB3aXRoIFtub2RlIC0tZXhwb3NlLWdjXVxuICBpZih0eXBlb2YgZ2xvYmFsVGhpcy5nYyA9PSAnZnVuY3Rpb24nKSBnbG9iYWxUaGlzLmdjKCk7XG4gIHJldHVybiAwXG59XG4vL1Byb3ZpZGVzOiBjYW1sX2djX2NvbXBhY3Rpb25cbmZ1bmN0aW9uIGNhbWxfZ2NfY29tcGFjdGlvbigpeyByZXR1cm4gMH1cbi8vUHJvdmlkZXM6IGNhbWxfZ2NfY291bnRlcnNcbmZ1bmN0aW9uIGNhbWxfZ2NfY291bnRlcnMoKSB7IHJldHVybiBbMjU0LDAsMCwwXSB9XG4vL1Byb3ZpZGVzOiBjYW1sX2djX3F1aWNrX3N0YXRcbi8vVmVyc2lvbjogPj0gNC4xMlxuZnVuY3Rpb24gY2FtbF9nY19xdWlja19zdGF0KCl7XG4gIHJldHVybiBbMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDBdXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2NfcXVpY2tfc3RhdFxuLy9WZXJzaW9uOiA8IDQuMTJcbmZ1bmN0aW9uIGNhbWxfZ2NfcXVpY2tfc3RhdCgpe1xuICByZXR1cm4gWzAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMF1cbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ2Nfc3RhdFxuLy9SZXF1aXJlczogY2FtbF9nY19xdWlja19zdGF0XG5mdW5jdGlvbiBjYW1sX2djX3N0YXQoKSB7XG4gIHJldHVybiBjYW1sX2djX3F1aWNrX3N0YXQoKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9nY19zZXRcbmZ1bmN0aW9uIGNhbWxfZ2Nfc2V0KF9jb250cm9sKSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2djX2dldFxuZnVuY3Rpb24gY2FtbF9nY19nZXQoKXtcbiAgcmV0dXJuIFswLDAsMCwwLDAsMCwwLDAsMCwwLDAsMF1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9tZW1wcm9mX3NldFxuZnVuY3Rpb24gY2FtbF9tZW1wcm9mX3NldChfY29udHJvbCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9maW5hbF9yZWdpc3RlciBjb25zdFxuZnVuY3Rpb24gY2FtbF9maW5hbF9yZWdpc3RlciAoKSB7IHJldHVybiAwOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmluYWxfcmVnaXN0ZXJfY2FsbGVkX3dpdGhvdXRfdmFsdWVcbnZhciBhbGxfZmluYWxpemVycyA9IG5ldyBnbG9iYWxUaGlzLlNldCgpXG5mdW5jdGlvbiBjYW1sX2ZpbmFsX3JlZ2lzdGVyX2NhbGxlZF93aXRob3V0X3ZhbHVlIChjYiwgYSkge1xuICBpZihnbG9iYWxUaGlzLkZpbmFsaXphdGlvblJlZ2lzdHJ5ICYmIGEgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICB2YXIgeCA9IG5ldyBnbG9iYWxUaGlzLkZpbmFsaXphdGlvblJlZ2lzdHJ5KGZ1bmN0aW9uICh4KXthbGxfZmluYWxpemVycy5kZWxldGUoeCk7IGNiKDApOyByZXR1cm47fSk7XG4gICAgeC5yZWdpc3RlcihhLHgpO1xuICAgIGFsbF9maW5hbGl6ZXJzLmFkZCh4KTtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9maW5hbF9yZWxlYXNlIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ZpbmFsX3JlbGVhc2UgKCkgeyByZXR1cm4gMDsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21lbXByb2Zfc3RhcnRcbmZ1bmN0aW9uIGNhbWxfbWVtcHJvZl9zdGFydChyYXRlLHN0YWNrX3NpemUsdHJhY2tlcil7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21lbXByb2Zfc3RvcFxuZnVuY3Rpb24gY2FtbF9tZW1wcm9mX3N0b3AodW5pdCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tZW1wcm9mX2Rpc2NhcmRcbmZ1bmN0aW9uIGNhbWxfbWVtcHJvZl9kaXNjYXJkKHQpIHsgcmV0dXJuIDAgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2V2ZW50bG9nX3Jlc3VtZVxuZnVuY3Rpb24gY2FtbF9ldmVudGxvZ19yZXN1bWUodW5pdCkgeyByZXR1cm4gMDsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2V2ZW50bG9nX3BhdXNlXG5mdW5jdGlvbiBjYW1sX2V2ZW50bG9nX3BhdXNlKHVuaXQpIHsgcmV0dXJuIDA7IH1cblxuLy9Qcm92aWRlczogY2FtbF9nY19odWdlX2ZhbGxiYWNrX2NvdW50XG5mdW5jdGlvbiBjYW1sX2djX2h1Z2VfZmFsbGJhY2tfY291bnQodW5pdCkgeyByZXR1cm4gMDsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2djX21ham9yX3NsaWNlXG5mdW5jdGlvbiBjYW1sX2djX21ham9yX3NsaWNlKHdvcmspIHsgcmV0dXJuIDA7IH1cblxuLy9Qcm92aWRlczogY2FtbF9nY19taW5vcl93b3Jkc1xuZnVuY3Rpb24gY2FtbF9nY19taW5vcl93b3Jkcyh1bml0KSB7IHJldHVybiAwOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2V0X21pbm9yX2ZyZWVcbmZ1bmN0aW9uIGNhbWxfZ2V0X21pbm9yX2ZyZWUodW5pdCkgeyByZXR1cm4gMDsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dldF9tYWpvcl9idWNrZXRcbmZ1bmN0aW9uIGNhbWxfZ2V0X21ham9yX2J1Y2tldChuKSB7IHJldHVybiAwOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2V0X21ham9yX2NyZWRpdFxuZnVuY3Rpb24gY2FtbF9nZXRfbWFqb3JfY3JlZGl0KG4pIHsgcmV0dXJuIDA7IH1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vLy8vLy8vLy8vLy8gRm9ybWF0XG5cbi8vUHJvdmlkZXM6IGNhbWxfcGFyc2VfZm9ybWF0XG4vL1JlcXVpcmVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nLCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfcGFyc2VfZm9ybWF0IChmbXQpIHtcbiAgZm10ID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhmbXQpO1xuICB2YXIgbGVuID0gZm10Lmxlbmd0aDtcbiAgaWYgKGxlbiA+IDMxKSBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJmb3JtYXRfaW50OiBmb3JtYXQgdG9vIGxvbmdcIik7XG4gIHZhciBmID1cbiAgICAgIHsganVzdGlmeTonKycsIHNpZ25zdHlsZTonLScsIGZpbGxlcjonICcsIGFsdGVybmF0ZTpmYWxzZSxcbiAgICAgICAgYmFzZTowLCBzaWduZWRjb252OmZhbHNlLCB3aWR0aDowLCB1cHBlcmNhc2U6ZmFsc2UsXG4gICAgICAgIHNpZ246MSwgcHJlYzotMSwgY29udjonZicgfTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBjID0gZm10LmNoYXJBdChpKTtcbiAgICBzd2l0Y2ggKGMpIHtcbiAgICBjYXNlICctJzpcbiAgICAgIGYuanVzdGlmeSA9ICctJzsgYnJlYWs7XG4gICAgY2FzZSAnKyc6IGNhc2UgJyAnOlxuICAgICAgZi5zaWduc3R5bGUgPSBjOyBicmVhaztcbiAgICBjYXNlICcwJzpcbiAgICAgIGYuZmlsbGVyID0gJzAnOyBicmVhaztcbiAgICBjYXNlICcjJzpcbiAgICAgIGYuYWx0ZXJuYXRlID0gdHJ1ZTsgYnJlYWs7XG4gICAgY2FzZSAnMSc6IGNhc2UgJzInOiBjYXNlICczJzogY2FzZSAnNCc6IGNhc2UgJzUnOlxuICAgIGNhc2UgJzYnOiBjYXNlICc3JzogY2FzZSAnOCc6IGNhc2UgJzknOlxuICAgICAgZi53aWR0aCA9IDA7XG4gICAgICB3aGlsZSAoYz1mbXQuY2hhckNvZGVBdChpKSAtIDQ4LCBjID49IDAgJiYgYyA8PSA5KSB7XG4gICAgICAgIGYud2lkdGggPSBmLndpZHRoICogMTAgKyBjOyBpKytcbiAgICAgIH1cbiAgICAgIGktLTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJy4nOlxuICAgICAgZi5wcmVjID0gMDtcbiAgICAgIGkrKztcbiAgICAgIHdoaWxlIChjPWZtdC5jaGFyQ29kZUF0KGkpIC0gNDgsIGMgPj0gMCAmJiBjIDw9IDkpIHtcbiAgICAgICAgZi5wcmVjID0gZi5wcmVjICogMTAgKyBjOyBpKytcbiAgICAgIH1cbiAgICAgIGktLTtcbiAgICBjYXNlICdkJzogY2FzZSAnaSc6XG4gICAgICBmLnNpZ25lZGNvbnYgPSB0cnVlOyAvKiBmYWxsdGhyb3VnaCAqL1xuICAgIGNhc2UgJ3UnOlxuICAgICAgZi5iYXNlID0gMTA7IGJyZWFrO1xuICAgIGNhc2UgJ3gnOlxuICAgICAgZi5iYXNlID0gMTY7IGJyZWFrO1xuICAgIGNhc2UgJ1gnOlxuICAgICAgZi5iYXNlID0gMTY7IGYudXBwZXJjYXNlID0gdHJ1ZTsgYnJlYWs7XG4gICAgY2FzZSAnbyc6XG4gICAgICBmLmJhc2UgPSA4OyBicmVhaztcbiAgICBjYXNlICdlJzogY2FzZSAnZic6IGNhc2UgJ2cnOlxuICAgICAgZi5zaWduZWRjb252ID0gdHJ1ZTsgZi5jb252ID0gYzsgYnJlYWs7XG4gICAgY2FzZSAnRSc6IGNhc2UgJ0YnOiBjYXNlICdHJzpcbiAgICAgIGYuc2lnbmVkY29udiA9IHRydWU7IGYudXBwZXJjYXNlID0gdHJ1ZTtcbiAgICAgIGYuY29udiA9IGMudG9Mb3dlckNhc2UgKCk7IGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9maW5pc2hfZm9ybWF0dGluZ1xuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9maW5pc2hfZm9ybWF0dGluZyhmLCByYXdidWZmZXIpIHtcbiAgaWYgKGYudXBwZXJjYXNlKSByYXdidWZmZXIgPSByYXdidWZmZXIudG9VcHBlckNhc2UoKTtcbiAgdmFyIGxlbiA9IHJhd2J1ZmZlci5sZW5ndGg7XG4gIC8qIEFkanVzdCBsZW4gdG8gcmVmbGVjdCBhZGRpdGlvbmFsIGNoYXJzIChzaWduLCBldGMpICovXG4gIGlmIChmLnNpZ25lZGNvbnYgJiYgKGYuc2lnbiA8IDAgfHwgZi5zaWduc3R5bGUgIT0gJy0nKSkgbGVuKys7XG4gIGlmIChmLmFsdGVybmF0ZSkge1xuICAgIGlmIChmLmJhc2UgPT0gOCkgbGVuICs9IDE7XG4gICAgaWYgKGYuYmFzZSA9PSAxNikgbGVuICs9IDI7XG4gIH1cbiAgLyogRG8gdGhlIGZvcm1hdHRpbmcgKi9cbiAgdmFyIGJ1ZmZlciA9IFwiXCI7XG4gIGlmIChmLmp1c3RpZnkgPT0gJysnICYmIGYuZmlsbGVyID09ICcgJylcbiAgICBmb3IgKHZhciBpID0gbGVuOyBpIDwgZi53aWR0aDsgaSsrKSBidWZmZXIgKz0gJyAnO1xuICBpZiAoZi5zaWduZWRjb252KSB7XG4gICAgaWYgKGYuc2lnbiA8IDApIGJ1ZmZlciArPSAnLSc7XG4gICAgZWxzZSBpZiAoZi5zaWduc3R5bGUgIT0gJy0nKSBidWZmZXIgKz0gZi5zaWduc3R5bGU7XG4gIH1cbiAgaWYgKGYuYWx0ZXJuYXRlICYmIGYuYmFzZSA9PSA4KSBidWZmZXIgKz0gJzAnO1xuICBpZiAoZi5hbHRlcm5hdGUgJiYgZi5iYXNlID09IDE2KSBidWZmZXIgKz0gZi51cHBlcmNhc2U/XCIwWFwiOlwiMHhcIjtcbiAgaWYgKGYuanVzdGlmeSA9PSAnKycgJiYgZi5maWxsZXIgPT0gJzAnKVxuICAgIGZvciAodmFyIGkgPSBsZW47IGkgPCBmLndpZHRoOyBpKyspIGJ1ZmZlciArPSAnMCc7XG4gIGJ1ZmZlciArPSByYXdidWZmZXI7XG4gIGlmIChmLmp1c3RpZnkgPT0gJy0nKVxuICAgIGZvciAodmFyIGkgPSBsZW47IGkgPCBmLndpZHRoOyBpKyspIGJ1ZmZlciArPSAnICc7XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKGJ1ZmZlcik7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTQgSHVnbyBIZXV6YXJkXG5cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3N0YXRlXG52YXIgY2FtbF9ncl9zdGF0ZTtcblxuLy9Qcm92aWRlczogY2FtbF9ncl9zdGF0ZV9nZXRcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVcbi8vUmVxdWlyZXM6IGNhbWxfbmFtZWRfdmFsdWUsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZVxuZnVuY3Rpb24gY2FtbF9ncl9zdGF0ZV9nZXQoKSB7XG4gIGlmKGNhbWxfZ3Jfc3RhdGUpIHtcbiAgICByZXR1cm4gY2FtbF9ncl9zdGF0ZTtcbiAgfVxuICB0aHJvdyBjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UoWzAsY2FtbF9uYW1lZF92YWx1ZShcIkdyYXBoaWNzLkdyYXBoaWNfZmFpbHVyZVwiKSwgY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhcIk5vdCBpbml0aWFsaXplZFwiKV0pO1xufVxuLy9Qcm92aWRlczogY2FtbF9ncl9zdGF0ZV9zZXRcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGUsY2FtbF9ncl9zdGF0ZV9pbml0XG5mdW5jdGlvbiBjYW1sX2dyX3N0YXRlX3NldChjdHgpIHtcbiAgY2FtbF9ncl9zdGF0ZT1jdHg7XG4gIGNhbWxfZ3Jfc3RhdGVfaW5pdCgpXG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX29wZW5fZ3JhcGhcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfY3JlYXRlXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX3NldFxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfZ3Jfb3Blbl9ncmFwaChpbmZvKXtcbiAgdmFyIGluZm8gPSBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhpbmZvKTtcbiAgZnVuY3Rpb24gZ2V0KG5hbWUpe1xuICAgIHZhciByZXMgPSBpbmZvLm1hdGNoKFwiKF58LCkgKlwiK25hbWUrXCIgKj0gKihbYS16QS1aMC05X10rKSAqKCx8JClcIik7XG4gICAgaWYocmVzKSByZXR1cm4gcmVzWzJdO1xuICB9XG4gIHZhciBzcGVjcyA9IFtdO1xuICBpZighKGluZm89PVwiXCIpKSBzcGVjcy5wdXNoKGluZm8pO1xuICB2YXIgdGFyZ2V0ID0gZ2V0KFwidGFyZ2V0XCIpO1xuICBpZighdGFyZ2V0KSB0YXJnZXQ9XCJcIjtcbiAgdmFyIHN0YXR1cyA9IGdldChcInN0YXR1c1wiKTtcbiAgaWYoIXN0YXR1cykgc3BlY3MucHVzaChcInN0YXR1cz0xXCIpXG5cbiAgdmFyIHcgPSBnZXQoXCJ3aWR0aFwiKTtcbiAgdyA9IHc/cGFyc2VJbnQodyk6MjAwO1xuICBzcGVjcy5wdXNoKFwid2lkdGg9XCIrdyk7XG5cbiAgdmFyIGggPSBnZXQoXCJoZWlnaHRcIik7XG4gIGggPSBoP3BhcnNlSW50KGgpOjIwMDtcbiAgc3BlY3MucHVzaChcImhlaWdodD1cIitoKTtcblxuICB2YXIgd2luID0gZ2xvYmFsVGhpcy5vcGVuKFwiYWJvdXQ6YmxhbmtcIix0YXJnZXQsc3BlY3Muam9pbihcIixcIikpO1xuICBpZighd2luKSB7Y2FtbF9mYWlsd2l0aChcIkdyYXBoaWNzLm9wZW5fZ3JhcGg6IGNhbm5vdCBvcGVuIHRoZSB3aW5kb3dcIil9XG4gIHZhciBkb2MgPSB3aW4uZG9jdW1lbnQ7XG4gIHZhciBjYW52YXMgPSBkb2MuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgY2FudmFzLndpZHRoID0gdztcbiAgY2FudmFzLmhlaWdodCA9IGg7XG4gIHZhciBjdHggPSBjYW1sX2dyX3N0YXRlX2NyZWF0ZShjYW52YXMsdyxoKTtcbiAgY3R4LnNldF90aXRsZSA9IGZ1bmN0aW9uICh0aXRsZSkge1xuICAgIGRvYy50aXRsZSA9IHRpdGxlO1xuICB9O1xuICBjYW1sX2dyX3N0YXRlX3NldChjdHgpO1xuICB2YXIgYm9keSA9IGRvYy5ib2R5O1xuICBib2R5LnN0eWxlLm1hcmdpbiA9IFwiMHB4XCI7XG4gIGJvZHkuYXBwZW5kQ2hpbGQoY2FudmFzKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc3RhdGVfaW5pdFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZVxuLy9SZXF1aXJlczogY2FtbF9ncl9zZXRfY29sb3IsY2FtbF9ncl9tb3ZldG8sY2FtbF9ncl9yZXNpemVfd2luZG93XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3NldF9saW5lX3dpZHRoLGNhbWxfZ3Jfc2V0X3RleHRfc2l6ZSxjYW1sX2dyX3NldF9mb250XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3NldF93aW5kb3dfdGl0bGVcbmZ1bmN0aW9uIGNhbWxfZ3Jfc3RhdGVfaW5pdCgpe1xuICBjYW1sX2dyX21vdmV0byhjYW1sX2dyX3N0YXRlLngsY2FtbF9ncl9zdGF0ZS55KTtcbiAgY2FtbF9ncl9yZXNpemVfd2luZG93KGNhbWxfZ3Jfc3RhdGUud2lkdGgsY2FtbF9ncl9zdGF0ZS5oZWlnaHQpO1xuICBjYW1sX2dyX3NldF9saW5lX3dpZHRoKGNhbWxfZ3Jfc3RhdGUubGluZV93aWR0aCk7XG4gIGNhbWxfZ3Jfc2V0X3RleHRfc2l6ZShjYW1sX2dyX3N0YXRlLnRleHRfc2l6ZSk7XG4gIGNhbWxfZ3Jfc2V0X2ZvbnQoY2FtbF9ncl9zdGF0ZS5mb250KTtcbiAgY2FtbF9ncl9zZXRfY29sb3IoY2FtbF9ncl9zdGF0ZS5jb2xvcik7XG4gIGNhbWxfZ3Jfc2V0X3dpbmRvd190aXRsZShjYW1sX2dyX3N0YXRlLnRpdGxlKTtcbiAgLy9jYW1sX2dyX3Jlc2l6ZV93aW5kb3cgbWlnaHQgcmVzZXQgc29tZSBjYW52YXMnIHByb3BlcnRpZXNcbiAgY2FtbF9ncl9zdGF0ZS5jb250ZXh0LnRleHRCYXNlbGluZSA9ICdib3R0b20nO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3N0YXRlX2NyZWF0ZVxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9ncl9zdGF0ZV9jcmVhdGUoY2FudmFzLHcsaCl7XG4gIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgcmV0dXJuIHtcbiAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgIGNhbnZhcyA6IGNhbnZhcyxcbiAgICB4IDogMCxcbiAgICB5IDogMCxcbiAgICB3aWR0aCA6IHcsXG4gICAgaGVpZ2h0IDogaCxcbiAgICBsaW5lX3dpZHRoIDogMSxcbiAgICBmb250IDogY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhcImZpeGVkXCIpLFxuICAgIHRleHRfc2l6ZSA6IDI2LFxuICAgIGNvbG9yIDogMHgwMDAwMDAsXG4gICAgdGl0bGUgOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKFwiXCIpXG4gIH07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfZG9jX29mX3N0YXRlXG5mdW5jdGlvbiBjYW1sX2dyX2RvY19vZl9zdGF0ZShzdGF0ZSkge1xuICBpZihzdGF0ZS5jYW52YXMub3duZXJEb2N1bWVudClcbiAgICByZXR1cm4gc3RhdGUuY2FudmFzLm93bmVyRG9jdW1lbnQ7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfY2xvc2VfZ3JhcGhcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2Nsb3NlX2dyYXBoKCl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy5jYW52YXMud2lkdGggPSAwO1xuICBzLmNhbnZhcy5oZWlnaHQgPSAwO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9zZXRfd2luZG93X3RpdGxlXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfZ3Jfc2V0X3dpbmRvd190aXRsZShuYW1lKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLnRpdGxlID0gbmFtZTtcbiAgdmFyIGpzbmFtZSA9IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKG5hbWUpO1xuICBpZihzLnNldF90aXRsZSkgcy5zZXRfdGl0bGUoanNuYW1lKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfcmVzaXplX3dpbmRvd1xuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfcmVzaXplX3dpbmRvdyh3LGgpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KClcbiAgcy53aWR0aCA9IHc7XG4gIHMuaGVpZ2h0ID0gaDtcbiAgcy5jYW52YXMud2lkdGggPSB3O1xuICBzLmNhbnZhcy5oZWlnaHQgPSBoO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9jbGVhcl9ncmFwaFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfY2xlYXJfZ3JhcGgoKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLmNhbnZhcy53aWR0aCA9IHMud2lkdGg7XG4gIHMuY2FudmFzLmhlaWdodCA9IHMuaGVpZ2h0O1xuICAvLyAgcy5jb250ZXh0LnN0cm9rZVJlY3QgKDAuLCAwLiwgcy53aWR0aCwgcy5oZWlnaHQpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9zaXplX3hcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX3NpemVfeCgpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHJldHVybiBzLndpZHRoO1xufVxuLy9Qcm92aWRlczogY2FtbF9ncl9zaXplX3lcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX3NpemVfeSgpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHJldHVybiBzLmhlaWdodDtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3NldF9jb2xvclxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3Jfc2V0X2NvbG9yKGNvbG9yKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBmdW5jdGlvbiBjb252ZXJ0KG51bWJlcikge1xuICAgIHZhciBzdHIgPSAnJyArIG51bWJlci50b1N0cmluZygxNik7XG4gICAgd2hpbGUgKHN0ci5sZW5ndGggPCAyKSBzdHIgPSAnMCcgKyBzdHI7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuICB2YXJcbiAgciA9IChjb2xvciA+PiAxNikgJiAweGZmLFxuICBnID0gKGNvbG9yID4+IDgpICAmIDB4ZmYsXG4gIGIgPSAoY29sb3IgPj4gMCkgICYgMHhmZjtcbiAgcy5jb2xvcj1jb2xvcjtcbiAgdmFyIGNfc3RyID0gJyMnICsgY29udmVydChyKSArIGNvbnZlcnQoZykgKyBjb252ZXJ0KGIpO1xuICBzLmNvbnRleHQuZmlsbFN0eWxlID0gICBjX3N0cjtcbiAgcy5jb250ZXh0LnN0cm9rZVN0eWxlID0gY19zdHI7XG4gIHJldHVybiAwO1xufVxuLy9Qcm92aWRlczogY2FtbF9ncl9wbG90XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9wbG90KHgseSl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgdmFyIGltPXMuY29udGV4dC5jcmVhdGVJbWFnZURhdGEoMSwxKTtcbiAgdmFyIGQgPSBpbS5kYXRhO1xuICB2YXIgY29sb3IgPSBzLmNvbG9yO1xuICBkWzBdID0gKGNvbG9yID4+IDE2KSAmIDB4ZmY7IC8vclxuICBkWzFdID0gKGNvbG9yID4+IDgpICAmIDB4ZmYsIC8vZ1xuICBkWzJdID0gKGNvbG9yID4+IDApICAmIDB4ZmY7IC8vYlxuICBkWzNdID0gMHhGRjsgLy9hXG4gIHMueD14O1xuICBzLnk9eTtcbiAgcy5jb250ZXh0LnB1dEltYWdlRGF0YShpbSx4LHMuaGVpZ2h0IC0geSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3BvaW50X2NvbG9yXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9wb2ludF9jb2xvcih4LHkpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHZhciBpbT1zLmNvbnRleHQuZ2V0SW1hZ2VEYXRhKHgscy5oZWlnaHQgLSB5LDEsMSk7XG4gIHZhciBkID0gaW0uZGF0YTtcbiAgcmV0dXJuIChkWzBdIDw8IDE2KSArIChkWzFdIDw8IDgpICsgZFsyXTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfbW92ZXRvXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9tb3ZldG8oeCx5KXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLng9eDtcbiAgcy55PXk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2N1cnJlbnRfeFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfY3VycmVudF94KCl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcmV0dXJuIHMueFxufVxuLy9Qcm92aWRlczogY2FtbF9ncl9jdXJyZW50X3lcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2N1cnJlbnRfeSgpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHJldHVybiBzLnlcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfbGluZXRvXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9saW5ldG8oeCx5KXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLmNvbnRleHQuYmVnaW5QYXRoKCk7XG4gIHMuY29udGV4dC5tb3ZlVG8ocy54LHMuaGVpZ2h0IC0gcy55KTtcbiAgcy5jb250ZXh0LmxpbmVUbyh4LHMuaGVpZ2h0IC0geSk7XG4gIHMuY29udGV4dC5zdHJva2UoKTtcbiAgcy54PXg7XG4gIHMueT15O1xuICByZXR1cm4gMDtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfZHJhd19yZWN0XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9kcmF3X3JlY3QoeCx5LHcsaCl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy5jb250ZXh0LnN0cm9rZVJlY3QoeCxzLmhlaWdodCAtIHksdywtaCk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2FyY19hdXhcbmZ1bmN0aW9uIGNhbWxfZ3JfYXJjX2F1eChjdHgsY3gsY3kscnkscngsYTEsYTIpe1xuICB3aGlsZShhMT5hMikgYTIrPTM2MDtcbiAgYTEgLz0gMTgwO1xuICBhMiAvPSAxODA7XG4gIHZhciByb3QgPSAwLHhQb3MseVBvcyx4UG9zX3ByZXYseVBvc19wcmV2O1xuICB2YXIgc3BhY2UgPSAyO1xuICB2YXIgbnVtID0gKCgoYTIgLSBhMSkgKiBNYXRoLlBJICogKChyeCtyeSkvMikpIC8gc3BhY2UpIHwgMDtcbiAgdmFyIGRlbHRhID0gKGEyIC0gYTEpICogTWF0aC5QSSAvIG51bTtcbiAgdmFyIGkgPSBhMSAqIE1hdGguUEk7XG4gIGZvciAodmFyIGo9MDtqPD1udW07aisrKXtcbiAgICB4UG9zID0gY3ggLSAocnggKiBNYXRoLnNpbihpKSkgKiBNYXRoLnNpbihyb3QgKiBNYXRoLlBJKSArIChyeSAqIE1hdGguY29zKGkpKSAqIE1hdGguY29zKHJvdCAqIE1hdGguUEkpO1xuICAgIHhQb3MgPSB4UG9zLnRvRml4ZWQoMik7XG4gICAgeVBvcyA9IGN5ICsgKHJ5ICogTWF0aC5jb3MoaSkpICogTWF0aC5zaW4ocm90ICogTWF0aC5QSSkgKyAocnggKiBNYXRoLnNpbihpKSkgKiBNYXRoLmNvcyhyb3QgKiBNYXRoLlBJKTtcbiAgICB5UG9zID0geVBvcy50b0ZpeGVkKDIpO1xuICAgIGlmIChqPT0wKSB7XG4gICAgICBjdHgubW92ZVRvKHhQb3MsIHlQb3MpO1xuICAgIH0gZWxzZSBpZiAoeFBvc19wcmV2IT14UG9zIHx8IHlQb3NfcHJldiE9eVBvcyl7XG4gICAgICBjdHgubGluZVRvKHhQb3MsIHlQb3MpO1xuICAgIH1cbiAgICB4UG9zX3ByZXY9eFBvcztcbiAgICB5UG9zX3ByZXY9eVBvcztcbiAgICBpLT0gZGVsdGE7Ly9jY3dcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2RyYXdfYXJjXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldCwgY2FtbF9ncl9hcmNfYXV4XG5mdW5jdGlvbiBjYW1sX2dyX2RyYXdfYXJjKHgseSxyeCxyeSxhMSxhMil7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy5jb250ZXh0LmJlZ2luUGF0aCgpO1xuICBjYW1sX2dyX2FyY19hdXgocy5jb250ZXh0LHgscy5oZWlnaHQgLSB5LHJ4LHJ5LGExLGEyKTtcbiAgcy5jb250ZXh0LnN0cm9rZSgpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9zZXRfbGluZV93aWR0aFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3Jfc2V0X2xpbmVfd2lkdGgodyl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy5saW5lX3dpZHRoID0gdztcbiAgcy5jb250ZXh0LmxpbmVXaWR0aCA9IHdcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfZmlsbF9yZWN0XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9maWxsX3JlY3QoeCx5LHcsaCl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy5jb250ZXh0LmZpbGxSZWN0KHgscy5oZWlnaHQgLSB5LHcsLWgpO1xuICByZXR1cm4gMDtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfZmlsbF9wb2x5XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9maWxsX3BvbHkoYXIpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMuY29udGV4dC5iZWdpblBhdGgoKTtcbiAgcy5jb250ZXh0Lm1vdmVUbyhhclsxXVsxXSxzLmhlaWdodCAtIGFyWzFdWzJdKTtcbiAgZm9yKHZhciBpID0gMjsgaSA8IGFyLmxlbmd0aDsgaSsrKVxuICAgIHMuY29udGV4dC5saW5lVG8oYXJbaV1bMV0scy5oZWlnaHQgLSBhcltpXVsyXSk7XG4gIHMuY29udGV4dC5saW5lVG8oYXJbMV1bMV0scy5oZWlnaHQgLSBhclsxXVsyXSk7XG4gIHMuY29udGV4dC5maWxsKCk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2ZpbGxfYXJjXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldCwgY2FtbF9ncl9hcmNfYXV4XG5mdW5jdGlvbiBjYW1sX2dyX2ZpbGxfYXJjKHgseSxyeCxyeSxhMSxhMil7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy5jb250ZXh0LmJlZ2luUGF0aCgpO1xuICBjYW1sX2dyX2FyY19hdXgocy5jb250ZXh0LHgscy5oZWlnaHQgLSB5LHJ4LHJ5LGExLGEyKTtcbiAgcy5jb250ZXh0LmZpbGwoKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfZHJhd19zdHJcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2RyYXdfc3RyKHN0cil7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgdmFyIG0gPSBzLmNvbnRleHQubWVhc3VyZVRleHQoc3RyKTtcbiAgdmFyIGR4ID0gbS53aWR0aDtcbiAgcy5jb250ZXh0LmZpbGxUZXh0KHN0cixzLngscy5oZWlnaHQgLSBzLnkpO1xuICBzLnggKz0gZHggfCAwO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9kcmF3X2NoYXJcbi8vUmVxdWlyZXM6IGNhbWxfZ3JfZHJhd19zdHJcbmZ1bmN0aW9uIGNhbWxfZ3JfZHJhd19jaGFyKGMpe1xuICBjYW1sX2dyX2RyYXdfc3RyKFN0cmluZy5mcm9tQ2hhckNvZGUoYykpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9kcmF3X3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9ncl9kcmF3X3N0clxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfZ3JfZHJhd19zdHJpbmcoc3RyKXtcbiAgY2FtbF9ncl9kcmF3X3N0cihjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhzdHIpKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc2V0X2ZvbnRcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9ncl9zZXRfZm9udChmKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLmZvbnQgPSBmO1xuICBzLmNvbnRleHQuZm9udCA9IHMudGV4dF9zaXplICsgXCJweCBcIiArIGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHMuZm9udCk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3NldF90ZXh0X3NpemVcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9ncl9zZXRfdGV4dF9zaXplKHNpemUpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMudGV4dF9zaXplID0gc2l6ZTtcbiAgcy5jb250ZXh0LmZvbnQgPSBzLnRleHRfc2l6ZSArIFwicHggXCIgKyBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhzLmZvbnQpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl90ZXh0X3NpemVcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9ncl90ZXh0X3NpemUodHh0KXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICB2YXIgdyA9IHMuY29udGV4dC5tZWFzdXJlVGV4dChjYW1sX2pzc3RyaW5nX29mX3N0cmluZyh0eHQpKS53aWR0aDtcbiAgcmV0dXJuIFswLHcscy50ZXh0X3NpemVdO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfbWFrZV9pbWFnZVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfbWFrZV9pbWFnZShhcnIpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHZhciBoID0gYXJyLmxlbmd0aCAtIDEgO1xuICB2YXIgdyA9IGFyclsxXS5sZW5ndGggLSAxO1xuICB2YXIgaW0gPSBzLmNvbnRleHQuY3JlYXRlSW1hZ2VEYXRhKHcsaCk7XG4gIGZvcih2YXIgaT0wO2k8aDtpKyspe1xuICAgIGZvcih2YXIgaj0wO2o8dztqKyspe1xuICAgICAgdmFyIGMgPSBhcnJbaSsxXVtqKzFdO1xuICAgICAgdmFyIG8gPSBpKih3KjQpICsgKGogKiA0KTtcbiAgICAgIGlmKGMgPT0gLTEpIHtcbiAgICAgICAgaW0uZGF0YVtvICsgMF0gPSAwO1xuICAgICAgICBpbS5kYXRhW28gKyAxXSA9IDA7XG4gICAgICAgIGltLmRhdGFbbyArIDJdID0gMDtcbiAgICAgICAgaW0uZGF0YVtvICsgM10gPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW0uZGF0YVtvICsgMF0gPSBjID4+IDE2ICYgMHhmZjtcbiAgICAgICAgaW0uZGF0YVtvICsgMV0gPSBjID4+ICA4ICYgMHhmZjtcbiAgICAgICAgaW0uZGF0YVtvICsgMl0gPSBjID4+ICAwICYgMFhmZjtcbiAgICAgICAgaW0uZGF0YVtvICsgM10gPSAweGZmO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gaW1cbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfZHVtcF9pbWFnZVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfZHVtcF9pbWFnZShpbSl7XG4gIHZhciBkYXRhID0gWzBdXG4gIGZvcih2YXIgaT0wOyBpPGltLmhlaWdodDtpKyspe1xuICAgIGRhdGFbaSsxXSA9IFswXVxuICAgIGZvcih2YXIgaj0wOyBqPGltLndpZHRoO2orKyl7XG4gICAgICB2YXIgbyA9IGkqKGltLndpZHRoKjQpICsgKGogKiA0KSxcbiAgICAgICAgICByID0gaW0uZGF0YVtvKzBdLFxuICAgICAgICAgIGcgPSBpbS5kYXRhW28rMV0sXG4gICAgICAgICAgYiA9IGltLmRhdGFbbysyXTtcbiAgICAgIGRhdGFbaSsxXVtqKzFdID0gKHIgPDwgMTYpICsgKGcgPDwgOCkgKyBiXG4gICAgfVxuICB9XG4gIHJldHVybiBkYXRhXG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2RyYXdfaW1hZ2Vcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2RyYXdfaW1hZ2UoaW0seCx5KXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBpZighaW0uaW1hZ2UpIHtcbiAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICBjYW52YXMud2lkdGggPSBzLndpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBzLmhlaWdodDtcbiAgICBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpLnB1dEltYWdlRGF0YShpbSwwLDApO1xuICAgIHZhciBpbWFnZSA9IG5ldyBnbG9iYWxUaGlzLkltYWdlKCk7XG4gICAgaW1hZ2Uub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcy5jb250ZXh0LmRyYXdJbWFnZShpbWFnZSx4LHMuaGVpZ2h0IC0gaW0uaGVpZ2h0IC0geSk7XG4gICAgICBpbS5pbWFnZSA9IGltYWdlO1xuICAgIH1cbiAgICBpbWFnZS5zcmMgPSBjYW52YXMudG9EYXRhVVJMKFwiaW1hZ2UvcG5nXCIpO1xuICB9IGVsc2Uge1xuICAgIHMuY29udGV4dC5kcmF3SW1hZ2UoaW0uaW1hZ2UseCxzLmhlaWdodCAtIGltLmhlaWdodCAtIHkpO1xuICB9XG4gIHJldHVybiAwO1xufVxuLy9Qcm92aWRlczogY2FtbF9ncl9jcmVhdGVfaW1hZ2Vcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2NyZWF0ZV9pbWFnZSh4LHkpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHJldHVybiBzLmNvbnRleHQuY3JlYXRlSW1hZ2VEYXRhKHgseSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2JsaXRfaW1hZ2Vcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2JsaXRfaW1hZ2UoaW0seCx5KXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICB2YXIgaW0yID0gcy5jb250ZXh0LmdldEltYWdlRGF0YSh4LHMuaGVpZ2h0IC0gaW0uaGVpZ2h0IC0geSxpbS53aWR0aCxpbS5oZWlnaHQpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGltMi5kYXRhLmxlbmd0aDsgaSs9NCl7XG4gICAgaW0uZGF0YVtpXSA9IGltMi5kYXRhW2ldO1xuICAgIGltLmRhdGFbaSsxXSA9IGltMi5kYXRhW2krMV07XG4gICAgaW0uZGF0YVtpKzJdID0gaW0yLmRhdGFbaSsyXTtcbiAgICBpbS5kYXRhW2krM10gPSBpbTIuZGF0YVtpKzNdO1xuICB9XG4gIHJldHVybiAwO1xufVxuLy9Qcm92aWRlczogY2FtbF9ncl9zaWdpb19oYW5kbGVyXG5mdW5jdGlvbiBjYW1sX2dyX3NpZ2lvX2hhbmRsZXIoKXtyZXR1cm4gMH1cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc2lnaW9fc2lnbmFsXG5mdW5jdGlvbiBjYW1sX2dyX3NpZ2lvX3NpZ25hbCgpe3JldHVybiAwfVxuLy9Qcm92aWRlczogY2FtbF9ncl93YWl0X2V2ZW50XG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2dyX3dhaXRfZXZlbnQoX2V2bCl7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX2dyX3dhaXRfZXZlbnQgbm90IEltcGxlbWVudGVkOiB1c2UgR3JhcGhpY3NfanMgaW5zdGVhZFwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9zeW5jaHJvbml6ZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9ncl9zeW5jaHJvbml6ZSAoKSB7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX2dyX3N5bmNocm9uaXplIG5vdCBJbXBsZW1lbnRlZFwiKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfcmVtZW1iZXJfbW9kZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9ncl9yZW1lbWJlcl9tb2RlICgpIHtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfZ3JfcmVtZW1iZXJfbW9kZSBub3QgSW1wbGVtZW50ZWRcIik7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2Rpc3BsYXlfbW9kZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9ncl9kaXNwbGF5X21vZGUoKSB7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX2dyX2Rpc3BsYXlfbW9kZSBub3QgSW1wbGVtZW50ZWRcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfd2luZG93X2lkXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2dyX3dpbmRvd19pZChhKSB7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX2dyX3dpbmRvd19pZCBub3QgSW1wbGVtZW50ZWRcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfb3Blbl9zdWJ3aW5kb3dcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfZ3Jfb3Blbl9zdWJ3aW5kb3coYSxiLGMsZCkge1xuICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9ncl9vcGVuX3N1YndpbmRvdyBub3QgSW1wbGVtZW50ZWRcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfY2xvc2Vfc3Vid2luZG93XG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2dyX2Nsb3NlX3N1YndpbmRvdyhhKSB7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX2dyX2Nsb3NlX3N1YndpbmRvdyBub3QgSW1wbGVtZW50ZWRcIik7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBsaWJyYXJ5XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwIErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vLy8vLy8vLy8vLy8gSnNsaWI6IGNvZGUgc3BlY2lmaWMgdG8gSnNfb2Zfb2NhbWxcblxuLy9Qcm92aWRlczogY2FtbF9qc19vbl9pZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9qc19vbl9pZSAoKSB7XG4gIHZhciB1YSA9XG4gICAgICAoZ2xvYmFsVGhpcy5uYXZpZ2F0b3ImJmdsb2JhbFRoaXMubmF2aWdhdG9yLnVzZXJBZ2VudClcbiAgICAgID9nbG9iYWxUaGlzLm5hdmlnYXRvci51c2VyQWdlbnQ6XCJcIjtcbiAgcmV0dXJuIHVhLmluZGV4T2YoXCJNU0lFXCIpICE9IC0xICYmIHVhLmluZGV4T2YoXCJPcGVyYVwiKSAhPSAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2h0bWxfZXNjYXBlIGNvbnN0IChjb25zdClcbnZhciBjYW1sX2pzX3JlZ2V4cHMgPSB7IGFtcDovJi9nLCBsdDovPC9nLCBxdW90Oi9cXFwiL2csIGFsbDovWyY8XFxcIl0vIH07XG5mdW5jdGlvbiBjYW1sX2pzX2h0bWxfZXNjYXBlIChzKSB7XG4gIGlmICghY2FtbF9qc19yZWdleHBzLmFsbC50ZXN0KHMpKSByZXR1cm4gcztcbiAgcmV0dXJuIHMucmVwbGFjZShjYW1sX2pzX3JlZ2V4cHMuYW1wLCBcIiZhbXA7XCIpXG4gICAgLnJlcGxhY2UoY2FtbF9qc19yZWdleHBzLmx0LCBcIiZsdDtcIilcbiAgICAucmVwbGFjZShjYW1sX2pzX3JlZ2V4cHMucXVvdCwgXCImcXVvdDtcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfaHRtbF9lbnRpdGllc1xuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9qc19odG1sX2VudGl0aWVzKHMpIHtcbiAgdmFyIGVudGl0eSA9IC9eJiM/WzAtOWEtekEtWl0rOyQvXG4gIGlmKHMubWF0Y2goZW50aXR5KSlcbiAge1xuICAgIHZhciBzdHIsIHRlbXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJyk7XG4gICAgdGVtcC5pbm5lckhUTUw9IHM7XG4gICAgc3RyPSB0ZW1wLnRleHRDb250ZW50IHx8IHRlbXAuaW5uZXJUZXh0O1xuICAgIHRlbXA9bnVsbDtcbiAgICByZXR1cm4gc3RyO1xuICB9XG4gIGVsc2Uge1xuICAgIGNhbWxfZmFpbHdpdGgoXCJJbnZhbGlkIGVudGl0eSBcIiArIHMpO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZ2V0X2NvbnNvbGUgY29uc3RcbmZ1bmN0aW9uIGNhbWxfanNfZ2V0X2NvbnNvbGUgKCkge1xuICB2YXIgYyA9IGNvbnNvbGU7XG4gIHZhciBtID0gW1wibG9nXCIsIFwiZGVidWdcIiwgXCJpbmZvXCIsIFwid2FyblwiLCBcImVycm9yXCIsIFwiYXNzZXJ0XCIsIFwiZGlyXCIsIFwiZGlyeG1sXCIsXG4gICAgICAgICAgIFwidHJhY2VcIiwgXCJncm91cFwiLCBcImdyb3VwQ29sbGFwc2VkXCIsIFwiZ3JvdXBFbmRcIiwgXCJ0aW1lXCIsIFwidGltZUVuZFwiXTtcbiAgZnVuY3Rpb24gZiAoKSB7fVxuICBmb3IgKHZhciBpID0gMDsgaSA8IG0ubGVuZ3RoOyBpKyspIGlmICghY1ttW2ldXSkgY1ttW2ldXT1mO1xuICByZXR1cm4gYztcbn1cblxuLy9Qcm92aWRlczogY2FtbF94bWxodHRwcmVxdWVzdF9jcmVhdGVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbi8vV2Vha2RlZlxuZnVuY3Rpb24gY2FtbF94bWxodHRwcmVxdWVzdF9jcmVhdGUodW5pdCl7XG4gIGlmKHR5cGVvZiBnbG9iYWxUaGlzLlhNTEh0dHBSZXF1ZXN0ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHRyeSB7IHJldHVybiBuZXcgZ2xvYmFsVGhpcy5YTUxIdHRwUmVxdWVzdCB9IGNhdGNoIChlKSB7IH07XG4gIH1cbiAgaWYodHlwZW9mIGdsb2JhbFRoaXMuYWN0aXZlWE9iamVjdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0cnkgeyByZXR1cm4gbmV3IGdsb2JhbFRoaXMuYWN0aXZlWE9iamVjdChcIk1zeG1sMi5YTUxIVFRQXCIpIH0gY2F0Y2goZSl7IH07XG4gICAgdHJ5IHsgcmV0dXJuIG5ldyBnbG9iYWxUaGlzLmFjdGl2ZVhPYmplY3QoXCJNc3htbDMuWE1MSFRUUFwiKSB9IGNhdGNoKGUpeyB9O1xuICAgIHRyeSB7IHJldHVybiBuZXcgZ2xvYmFsVGhpcy5hY3RpdmVYT2JqZWN0KFwiTWljcm9zb2Z0LlhNTEhUVFBcIikgfSBjYXRjaChlKXsgfTtcbiAgfVxuICBjYW1sX2ZhaWx3aXRoKFwiQ2Fubm90IGNyZWF0ZSBhIFhNTEh0dHBSZXF1ZXN0XCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2Vycm9yX29mX2V4Y2VwdGlvblxuZnVuY3Rpb24gY2FtbF9qc19lcnJvcl9vZl9leGNlcHRpb24oZXhuKSB7XG4gIGlmKGV4bi5qc19lcnJvcikgeyByZXR1cm4gZXhuLmpzX2Vycm9yOyB9XG4gIHJldHVybiBudWxsO1xufVxuIiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3RpdmUgQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAqL1xuLyogIGVuIEF1dG9tYXRpcXVlLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCAgICAqL1xuLyogIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlLCB3aXRoICAgICAqL1xuLyogIHRoZSBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiBmaWxlIC4uL0xJQ0VOU0UuICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vKiAkSWQ6IGxleGluZy5jIDYwNDUgMjAwNC0wMS0wMSAxNjo0Mjo0M1ogZG9saWdleiAkICovXG5cbi8qIFRoZSB0YWJsZS1kcml2ZW4gYXV0b21hdG9uIGZvciBsZXhlcnMgZ2VuZXJhdGVkIGJ5IGNhbWxsZXguICovXG5cbi8vUHJvdmlkZXM6IGNhbWxfbGV4X2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2xleF9hcnJheShzKSB7XG4gIHMgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKHMpO1xuICB2YXIgbCA9IHMubGVuZ3RoIC8gMjtcbiAgdmFyIGEgPSBuZXcgQXJyYXkobCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKVxuICAgIGFbaV0gPSAocy5jaGFyQ29kZUF0KDIgKiBpKSB8IChzLmNoYXJDb2RlQXQoMiAqIGkgKyAxKSA8PCA4KSkgPDwgMTYgPj4gMTY7XG4gIHJldHVybiBhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2xleF9lbmdpbmVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGgsIGNhbWxfbGV4X2FycmF5LCBjYW1sX3VpbnQ4X2FycmF5X29mX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2xleF9lbmdpbmUodGJsLCBzdGFydF9zdGF0ZSwgbGV4YnVmKSB7XG4gIHZhciBsZXhfYnVmZmVyID0gMjtcbiAgdmFyIGxleF9idWZmZXJfbGVuID0gMztcbiAgdmFyIGxleF9zdGFydF9wb3MgPSA1O1xuICB2YXIgbGV4X2N1cnJfcG9zID0gNjtcbiAgdmFyIGxleF9sYXN0X3BvcyA9IDc7XG4gIHZhciBsZXhfbGFzdF9hY3Rpb24gPSA4O1xuICB2YXIgbGV4X2VvZl9yZWFjaGVkID0gOTtcbiAgdmFyIGxleF9iYXNlID0gMTtcbiAgdmFyIGxleF9iYWNrdHJrID0gMjtcbiAgdmFyIGxleF9kZWZhdWx0ID0gMztcbiAgdmFyIGxleF90cmFucyA9IDQ7XG4gIHZhciBsZXhfY2hlY2sgPSA1O1xuXG4gIGlmICghdGJsLmxleF9kZWZhdWx0KSB7XG4gICAgdGJsLmxleF9iYXNlID0gICAgY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfYmFzZV0pO1xuICAgIHRibC5sZXhfYmFja3RyayA9IGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2JhY2t0cmtdKTtcbiAgICB0YmwubGV4X2NoZWNrID0gICBjYW1sX2xleF9hcnJheSAodGJsW2xleF9jaGVja10pO1xuICAgIHRibC5sZXhfdHJhbnMgPSAgIGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X3RyYW5zXSk7XG4gICAgdGJsLmxleF9kZWZhdWx0ID0gY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfZGVmYXVsdF0pO1xuICB9XG5cbiAgdmFyIGMsIHN0YXRlID0gc3RhcnRfc3RhdGU7XG5cbiAgdmFyIGJ1ZmZlciA9IGNhbWxfdWludDhfYXJyYXlfb2ZfYnl0ZXMobGV4YnVmW2xleF9idWZmZXJdKTtcblxuICBpZiAoc3RhdGUgPj0gMCkge1xuICAgIC8qIEZpcnN0IGVudHJ5ICovXG4gICAgbGV4YnVmW2xleF9sYXN0X3Bvc10gPSBsZXhidWZbbGV4X3N0YXJ0X3Bvc10gPSBsZXhidWZbbGV4X2N1cnJfcG9zXTtcbiAgICBsZXhidWZbbGV4X2xhc3RfYWN0aW9uXSA9IC0xO1xuICB9IGVsc2Uge1xuICAgIC8qIFJlZW50cnkgYWZ0ZXIgcmVmaWxsICovXG4gICAgc3RhdGUgPSAtc3RhdGUgLSAxO1xuICB9XG4gIGZvcig7Oykge1xuICAgIC8qIExvb2t1cCBiYXNlIGFkZHJlc3Mgb3IgYWN0aW9uIG51bWJlciBmb3IgY3VycmVudCBzdGF0ZSAqL1xuICAgIHZhciBiYXNlID0gdGJsLmxleF9iYXNlW3N0YXRlXTtcbiAgICBpZiAoYmFzZSA8IDApIHJldHVybiAtYmFzZS0xO1xuICAgIC8qIFNlZSBpZiBpdCdzIGEgYmFja3RyYWNrIHBvaW50ICovXG4gICAgdmFyIGJhY2t0cmsgPSB0YmwubGV4X2JhY2t0cmtbc3RhdGVdO1xuICAgIGlmIChiYWNrdHJrID49IDApIHtcbiAgICAgIGxleGJ1ZltsZXhfbGFzdF9wb3NdID0gbGV4YnVmW2xleF9jdXJyX3Bvc107XG4gICAgICBsZXhidWZbbGV4X2xhc3RfYWN0aW9uXSA9IGJhY2t0cms7XG4gICAgfVxuICAgIC8qIFNlZSBpZiB3ZSBuZWVkIGEgcmVmaWxsICovXG4gICAgaWYgKGxleGJ1ZltsZXhfY3Vycl9wb3NdID49IGxleGJ1ZltsZXhfYnVmZmVyX2xlbl0pe1xuICAgICAgaWYgKGxleGJ1ZltsZXhfZW9mX3JlYWNoZWRdID09IDApXG4gICAgICAgIHJldHVybiAtc3RhdGUgLSAxO1xuICAgICAgZWxzZVxuICAgICAgICBjID0gMjU2O1xuICAgIH1lbHNle1xuICAgICAgLyogUmVhZCBuZXh0IGlucHV0IGNoYXIgKi9cbiAgICAgIGMgPSBidWZmZXJbbGV4YnVmW2xleF9jdXJyX3Bvc11dO1xuICAgICAgbGV4YnVmW2xleF9jdXJyX3Bvc10gKys7XG4gICAgfVxuICAgIC8qIERldGVybWluZSBuZXh0IHN0YXRlICovXG4gICAgaWYgKHRibC5sZXhfY2hlY2tbYmFzZSArIGNdID09IHN0YXRlKVxuICAgICAgc3RhdGUgPSB0YmwubGV4X3RyYW5zW2Jhc2UgKyBjXTtcbiAgICBlbHNlXG4gICAgICBzdGF0ZSA9IHRibC5sZXhfZGVmYXVsdFtzdGF0ZV07XG4gICAgLyogSWYgbm8gdHJhbnNpdGlvbiBvbiB0aGlzIGNoYXIsIHJldHVybiB0byBsYXN0IGJhY2t0cmFjayBwb2ludCAqL1xuICAgIGlmIChzdGF0ZSA8IDApIHtcbiAgICAgIGxleGJ1ZltsZXhfY3Vycl9wb3NdID0gbGV4YnVmW2xleF9sYXN0X3Bvc107XG4gICAgICBpZiAobGV4YnVmW2xleF9sYXN0X2FjdGlvbl0gPT0gLTEpXG4gICAgICAgIGNhbWxfZmFpbHdpdGgoXCJsZXhpbmc6IGVtcHR5IHRva2VuXCIpO1xuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gbGV4YnVmW2xleF9sYXN0X2FjdGlvbl07XG4gICAgfWVsc2V7XG4gICAgICAvKiBFcmFzZSB0aGUgRU9GIGNvbmRpdGlvbiBvbmx5IGlmIHRoZSBFT0YgcHNldWRvLWNoYXJhY3RlciB3YXNcbiAgICAgICAgIGNvbnN1bWVkIGJ5IHRoZSBhdXRvbWF0b24gKGkuZS4gdGhlcmUgd2FzIG5vIGJhY2t0cmFjayBhYm92ZSlcbiAgICAgICovXG4gICAgICBpZiAoYyA9PSAyNTYpIGxleGJ1ZltsZXhfZW9mX3JlYWNoZWRdID0gMDtcbiAgICB9XG4gIH1cbn1cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyogTmV3IGxleGVyIGVuZ2luZSwgd2l0aCBtZW1vcnkgb2YgcG9zaXRpb25zICAqL1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vL1Byb3ZpZGVzOiBjYW1sX25ld19sZXhfZW5naW5lXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoLCBjYW1sX2xleF9hcnJheVxuLy9SZXF1aXJlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZywgY2FtbF91aW50OF9hcnJheV9vZl9ieXRlc1xuZnVuY3Rpb24gY2FtbF9sZXhfcnVuX21lbShzLCBpLCBtZW0sIGN1cnJfcG9zKSB7XG4gIGZvciAoOzspIHtcbiAgICB2YXIgZHN0ID0gcy5jaGFyQ29kZUF0KGkpOyBpKys7XG4gICAgaWYgKGRzdCA9PSAweGZmKSByZXR1cm47XG4gICAgdmFyIHNyYyA9IHMuY2hhckNvZGVBdChpKTsgaSsrO1xuICAgIGlmIChzcmMgPT0gMHhmZilcbiAgICAgIG1lbSBbZHN0ICsgMV0gPSBjdXJyX3BvcztcbiAgICBlbHNlXG4gICAgICBtZW0gW2RzdCArIDFdID0gbWVtIFtzcmMgKyAxXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYW1sX2xleF9ydW5fdGFnKHMsIGksIG1lbSkge1xuICBmb3IgKDs7KSB7XG4gICAgdmFyIGRzdCA9IHMuY2hhckNvZGVBdChpKTsgaSsrO1xuICAgIGlmIChkc3QgPT0gMHhmZikgcmV0dXJuIDtcbiAgICB2YXIgc3JjID0gcy5jaGFyQ29kZUF0KGkpOyBpKys7XG4gICAgaWYgKHNyYyA9PSAweGZmKVxuICAgICAgbWVtIFtkc3QgKyAxXSA9IC0xO1xuICAgIGVsc2VcbiAgICAgIG1lbSBbZHN0ICsgMV0gPSBtZW0gW3NyYyArIDFdO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbWxfbmV3X2xleF9lbmdpbmUodGJsLCBzdGFydF9zdGF0ZSwgbGV4YnVmKSB7XG4gIHZhciBsZXhfYnVmZmVyID0gMjtcbiAgdmFyIGxleF9idWZmZXJfbGVuID0gMztcbiAgdmFyIGxleF9zdGFydF9wb3MgPSA1O1xuICB2YXIgbGV4X2N1cnJfcG9zID0gNjtcbiAgdmFyIGxleF9sYXN0X3BvcyA9IDc7XG4gIHZhciBsZXhfbGFzdF9hY3Rpb24gPSA4O1xuICB2YXIgbGV4X2VvZl9yZWFjaGVkID0gOTtcbiAgdmFyIGxleF9tZW0gPSAxMDtcbiAgdmFyIGxleF9iYXNlID0gMTtcbiAgdmFyIGxleF9iYWNrdHJrID0gMjtcbiAgdmFyIGxleF9kZWZhdWx0ID0gMztcbiAgdmFyIGxleF90cmFucyA9IDQ7XG4gIHZhciBsZXhfY2hlY2sgPSA1O1xuICB2YXIgbGV4X2Jhc2VfY29kZSA9IDY7XG4gIHZhciBsZXhfYmFja3Rya19jb2RlID0gNztcbiAgdmFyIGxleF9kZWZhdWx0X2NvZGUgPSA4O1xuICB2YXIgbGV4X3RyYW5zX2NvZGUgPSA5O1xuICB2YXIgbGV4X2NoZWNrX2NvZGUgPSAxMDtcbiAgdmFyIGxleF9jb2RlID0gMTE7XG5cbiAgaWYgKCF0YmwubGV4X2RlZmF1bHQpIHtcbiAgICB0YmwubGV4X2Jhc2UgPSAgICBjYW1sX2xleF9hcnJheSAodGJsW2xleF9iYXNlXSk7XG4gICAgdGJsLmxleF9iYWNrdHJrID0gY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfYmFja3Rya10pO1xuICAgIHRibC5sZXhfY2hlY2sgPSAgIGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2NoZWNrXSk7XG4gICAgdGJsLmxleF90cmFucyA9ICAgY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfdHJhbnNdKTtcbiAgICB0YmwubGV4X2RlZmF1bHQgPSBjYW1sX2xleF9hcnJheSAodGJsW2xleF9kZWZhdWx0XSk7XG4gIH1cbiAgaWYgKCF0YmwubGV4X2RlZmF1bHRfY29kZSkge1xuICAgIHRibC5sZXhfYmFzZV9jb2RlID0gICAgY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfYmFzZV9jb2RlXSk7XG4gICAgdGJsLmxleF9iYWNrdHJrX2NvZGUgPSBjYW1sX2xleF9hcnJheSAodGJsW2xleF9iYWNrdHJrX2NvZGVdKTtcbiAgICB0YmwubGV4X2NoZWNrX2NvZGUgPSAgIGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2NoZWNrX2NvZGVdKTtcbiAgICB0YmwubGV4X3RyYW5zX2NvZGUgPSAgIGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X3RyYW5zX2NvZGVdKTtcbiAgICB0YmwubGV4X2RlZmF1bHRfY29kZSA9IGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2RlZmF1bHRfY29kZV0pO1xuICB9XG4gIGlmICh0YmwubGV4X2NvZGUgPT0gbnVsbCkgdGJsLmxleF9jb2RlID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyh0YmxbbGV4X2NvZGVdKTtcblxuICB2YXIgYywgc3RhdGUgPSBzdGFydF9zdGF0ZTtcblxuICB2YXIgYnVmZmVyID0gY2FtbF91aW50OF9hcnJheV9vZl9ieXRlcyhsZXhidWZbbGV4X2J1ZmZlcl0pO1xuXG4gIGlmIChzdGF0ZSA+PSAwKSB7XG4gICAgLyogRmlyc3QgZW50cnkgKi9cbiAgICBsZXhidWZbbGV4X2xhc3RfcG9zXSA9IGxleGJ1ZltsZXhfc3RhcnRfcG9zXSA9IGxleGJ1ZltsZXhfY3Vycl9wb3NdO1xuICAgIGxleGJ1ZltsZXhfbGFzdF9hY3Rpb25dID0gLTE7XG4gIH0gZWxzZSB7XG4gICAgLyogUmVlbnRyeSBhZnRlciByZWZpbGwgKi9cbiAgICBzdGF0ZSA9IC1zdGF0ZSAtIDE7XG4gIH1cbiAgZm9yKDs7KSB7XG4gICAgLyogTG9va3VwIGJhc2UgYWRkcmVzcyBvciBhY3Rpb24gbnVtYmVyIGZvciBjdXJyZW50IHN0YXRlICovXG4gICAgdmFyIGJhc2UgPSB0YmwubGV4X2Jhc2Vbc3RhdGVdO1xuICAgIGlmIChiYXNlIDwgMCkge1xuICAgICAgdmFyIHBjX29mZiA9IHRibC5sZXhfYmFzZV9jb2RlW3N0YXRlXTtcbiAgICAgIGNhbWxfbGV4X3J1bl90YWcodGJsLmxleF9jb2RlLCBwY19vZmYsIGxleGJ1ZltsZXhfbWVtXSk7XG4gICAgICByZXR1cm4gLWJhc2UtMTtcbiAgICB9XG4gICAgLyogU2VlIGlmIGl0J3MgYSBiYWNrdHJhY2sgcG9pbnQgKi9cbiAgICB2YXIgYmFja3RyayA9IHRibC5sZXhfYmFja3Rya1tzdGF0ZV07XG4gICAgaWYgKGJhY2t0cmsgPj0gMCkge1xuICAgICAgdmFyIHBjX29mZiA9IHRibC5sZXhfYmFja3Rya19jb2RlW3N0YXRlXTtcbiAgICAgIGNhbWxfbGV4X3J1bl90YWcodGJsLmxleF9jb2RlLCBwY19vZmYsIGxleGJ1ZltsZXhfbWVtXSk7XG4gICAgICBsZXhidWZbbGV4X2xhc3RfcG9zXSA9IGxleGJ1ZltsZXhfY3Vycl9wb3NdO1xuICAgICAgbGV4YnVmW2xleF9sYXN0X2FjdGlvbl0gPSBiYWNrdHJrO1xuICAgIH1cbiAgICAvKiBTZWUgaWYgd2UgbmVlZCBhIHJlZmlsbCAqL1xuICAgIGlmIChsZXhidWZbbGV4X2N1cnJfcG9zXSA+PSBsZXhidWZbbGV4X2J1ZmZlcl9sZW5dKXtcbiAgICAgIGlmIChsZXhidWZbbGV4X2VvZl9yZWFjaGVkXSA9PSAwKVxuICAgICAgICByZXR1cm4gLXN0YXRlIC0gMTtcbiAgICAgIGVsc2VcbiAgICAgICAgYyA9IDI1NjtcbiAgICB9ZWxzZXtcbiAgICAgIC8qIFJlYWQgbmV4dCBpbnB1dCBjaGFyICovXG4gICAgICBjID0gYnVmZmVyW2xleGJ1ZltsZXhfY3Vycl9wb3NdXTtcbiAgICAgIGxleGJ1ZltsZXhfY3Vycl9wb3NdICsrO1xuICAgIH1cbiAgICAvKiBEZXRlcm1pbmUgbmV4dCBzdGF0ZSAqL1xuICAgIHZhciBwc3RhdGUgPSBzdGF0ZSA7XG4gICAgaWYgKHRibC5sZXhfY2hlY2tbYmFzZSArIGNdID09IHN0YXRlKVxuICAgICAgc3RhdGUgPSB0YmwubGV4X3RyYW5zW2Jhc2UgKyBjXTtcbiAgICBlbHNlXG4gICAgICBzdGF0ZSA9IHRibC5sZXhfZGVmYXVsdFtzdGF0ZV07XG4gICAgLyogSWYgbm8gdHJhbnNpdGlvbiBvbiB0aGlzIGNoYXIsIHJldHVybiB0byBsYXN0IGJhY2t0cmFjayBwb2ludCAqL1xuICAgIGlmIChzdGF0ZSA8IDApIHtcbiAgICAgIGxleGJ1ZltsZXhfY3Vycl9wb3NdID0gbGV4YnVmW2xleF9sYXN0X3Bvc107XG4gICAgICBpZiAobGV4YnVmW2xleF9sYXN0X2FjdGlvbl0gPT0gLTEpXG4gICAgICAgIGNhbWxfZmFpbHdpdGgoXCJsZXhpbmc6IGVtcHR5IHRva2VuXCIpO1xuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gbGV4YnVmW2xleF9sYXN0X2FjdGlvbl07XG4gICAgfWVsc2V7XG4gICAgICAvKiBJZiBzb21lIHRyYW5zaXRpb24sIGdldCBhbmQgcGVyZm9ybSBtZW1vcnkgbW92ZXMgKi9cbiAgICAgIHZhciBiYXNlX2NvZGUgPSB0YmwubGV4X2Jhc2VfY29kZVtwc3RhdGVdLCBwY19vZmY7XG4gICAgICBpZiAodGJsLmxleF9jaGVja19jb2RlW2Jhc2VfY29kZSArIGNdID09IHBzdGF0ZSlcbiAgICAgICAgcGNfb2ZmID0gdGJsLmxleF90cmFuc19jb2RlW2Jhc2VfY29kZSArIGNdO1xuICAgICAgZWxzZVxuICAgICAgICBwY19vZmYgPSB0YmwubGV4X2RlZmF1bHRfY29kZVtwc3RhdGVdO1xuICAgICAgaWYgKHBjX29mZiA+IDApXG4gICAgICAgIGNhbWxfbGV4X3J1bl9tZW1cbiAgICAgICh0YmwubGV4X2NvZGUsIHBjX29mZiwgbGV4YnVmW2xleF9tZW1dLCBsZXhidWZbbGV4X2N1cnJfcG9zXSk7XG4gICAgICAvKiBFcmFzZSB0aGUgRU9GIGNvbmRpdGlvbiBvbmx5IGlmIHRoZSBFT0YgcHNldWRvLWNoYXJhY3RlciB3YXNcbiAgICAgICAgIGNvbnN1bWVkIGJ5IHRoZSBhdXRvbWF0b24gKGkuZS4gdGhlcmUgd2FzIG5vIGJhY2t0cmFjayBhYm92ZSlcbiAgICAgICovXG4gICAgICBpZiAoYyA9PSAyNTYpIGxleGJ1ZltsZXhfZW9mX3JlYWNoZWRdID0gMDtcbiAgICB9XG4gIH1cbn1cbiIsIlxuLy9Qcm92aWRlczogY2FtbF9seG1fbmV4dFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9zaGlmdF9sZWZ0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0X3Vuc2lnbmVkXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29yXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3hvclxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9hZGRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfbXVsXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF8xXG4vL1JlcXVpcmVzOiBjYW1sX2JhX3NldF8xXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9uZXdfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2x4bV9uZXh0KHYpIHtcbiAgZnVuY3Rpb24gc2hpZnRfbCh4LCBrKXtcbiAgICByZXR1cm4gY2FtbF9pbnQ2NF9zaGlmdF9sZWZ0KHgsayk7XG4gIH1cbiAgZnVuY3Rpb24gc2hpZnRfcih4LCBrKXtcbiAgICByZXR1cm4gY2FtbF9pbnQ2NF9zaGlmdF9yaWdodF91bnNpZ25lZCh4LGspO1xuICB9XG4gIGZ1bmN0aW9uIG9yKGEsIGIpe1xuICAgIHJldHVybiBjYW1sX2ludDY0X29yKGEsYik7XG4gIH1cbiAgZnVuY3Rpb24geG9yKGEsIGIpe1xuICAgIHJldHVybiBjYW1sX2ludDY0X3hvcihhLGIpO1xuICB9XG4gIGZ1bmN0aW9uIGFkZChhLCBiKXtcbiAgICByZXR1cm4gY2FtbF9pbnQ2NF9hZGQoYSxiKTtcbiAgfVxuICBmdW5jdGlvbiBtdWwoYSwgYil7XG4gICAgcmV0dXJuIGNhbWxfaW50NjRfbXVsKGEsYik7XG4gIH1cbiAgZnVuY3Rpb24gcm90bCh4LCBrKSB7XG4gICAgcmV0dXJuIG9yKHNoaWZ0X2woeCxrKSxzaGlmdF9yICh4LCA2NCAtIGspKTtcbiAgfVxuICBmdW5jdGlvbiBnZXQoYSwgaSkge1xuICAgIHJldHVybiBjYW1sX2JhX2dldF8xKGEsIGkpO1xuICB9XG4gIGZ1bmN0aW9uIHNldChhLCBpLCB4KSB7XG4gICAgcmV0dXJuIGNhbWxfYmFfc2V0XzEoYSwgaSwgeCk7XG4gIH1cbiAgdmFyIE0gPSBjYW1sX2ludDY0X29mX3N0cmluZyhjYW1sX25ld19zdHJpbmcoXCIweGQxMzQyNTQzZGU4MmVmOTVcIikpO1xuICB2YXIgZGFiYSA9IGNhbWxfaW50NjRfb2Zfc3RyaW5nKGNhbWxfbmV3X3N0cmluZyhcIjB4ZGFiYTBiNmViMDkzMjJlM1wiKSk7XG4gIHZhciB6LCBxMCwgcTE7XG4gIHZhciBzdCA9IHY7XG4gIHZhciBhID0gZ2V0KHN0LDApO1xuICB2YXIgcyA9IGdldChzdCwxKTtcbiAgdmFyIHgwID0gZ2V0KHN0LDIpO1xuICB2YXIgeDEgPSBnZXQoc3QsMyk7XG4gIC8qIENvbWJpbmluZyBvcGVyYXRpb24gKi9cbiAgeiA9IGFkZChzLCB4MCk7XG4gIC8qIE1peGluZyBmdW5jdGlvbiAqL1xuICB6ID0gbXVsKHhvcih6LHNoaWZ0X3IoeiwzMikpLCBkYWJhKTtcbiAgeiA9IG11bCh4b3IoeixzaGlmdF9yKHosMzIpKSwgZGFiYSk7XG4gIHogPSB4b3IoeixzaGlmdF9yKHosMzIpKTtcbiAgLyogTENHIHVwZGF0ZSAqL1xuICBzZXQoc3QsIDEsIGFkZCAobXVsKHMsTSksIGEpKTtcbiAgLyogWEJHIHVwZGF0ZSAqL1xuICB2YXIgcTAgPSB4MFxuICB2YXIgcTEgPSB4MVxuICBxMSA9IHhvcihxMSxxMCk7XG4gIHEwID0gcm90bChxMCwgMjQpO1xuICBxMCA9IHhvcih4b3IocTAsIHExKSwgKHNoaWZ0X2wocTEsMTYpKSk7XG4gIHExID0gcm90bChxMSwgMzcpO1xuICBzZXQoc3QsIDIsIHEwKTtcbiAgc2V0KHN0LCAzLCBxMSk7XG4gIC8qIFJldHVybiByZXN1bHQgKi9cbiAgcmV0dXJuIHo7XG59XG4iLCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdGl2ZSBDYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKiAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKiAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICovXG4vKiAgZW4gQXV0b21hdGlxdWUuICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkICAgICovXG4vKiAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UsIHdpdGggICAgICovXG4vKiAgdGhlIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIGZpbGUgLi4vTElDRU5TRS4gICAgICovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8qICRJZDogcGFyc2luZy5jIDg5ODMgMjAwOC0wOC0wNiAwOTozODoyNVogeGxlcm95ICQgKi9cblxuLyogVGhlIFBEQSBhdXRvbWF0b24gZm9yIHBhcnNlcnMgZ2VuZXJhdGVkIGJ5IGNhbWx5YWNjICovXG5cbi8qIFRoZSBwdXNoZG93biBhdXRvbWF0YSAqL1xuXG4vL1Byb3ZpZGVzOiBjYW1sX3BhcnNlcl90cmFjZVxudmFyIGNhbWxfcGFyc2VyX3RyYWNlID0gMDtcblxuLy9Qcm92aWRlczogY2FtbF9wYXJzZV9lbmdpbmVcbi8vUmVxdWlyZXM6IGNhbWxfbGV4X2FycmF5LCBjYW1sX3BhcnNlcl90cmFjZSxjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9tbF9vdXRwdXQsIGNhbWxfbWxfc3RyaW5nX2xlbmd0aCwgY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuLy9SZXF1aXJlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZywgTWxCeXRlc1xuZnVuY3Rpb24gY2FtbF9wYXJzZV9lbmdpbmUodGFibGVzLCBlbnYsIGNtZCwgYXJnKVxue1xuICB2YXIgRVJSQ09ERSA9IDI1NjtcblxuICAvL3ZhciBTVEFSVCA9IDA7XG4gIC8vdmFyIFRPS0VOX1JFQUQgPSAxO1xuICAvL3ZhciBTVEFDS1NfR1JPV05fMSA9IDI7XG4gIC8vdmFyIFNUQUNLU19HUk9XTl8yID0gMztcbiAgLy92YXIgU0VNQU5USUNfQUNUSU9OX0NPTVBVVEVEID0gNDtcbiAgLy92YXIgRVJST1JfREVURUNURUQgPSA1O1xuICB2YXIgbG9vcCA9IDY7XG4gIHZhciB0ZXN0c2hpZnQgPSA3O1xuICB2YXIgc2hpZnQgPSA4O1xuICB2YXIgc2hpZnRfcmVjb3ZlciA9IDk7XG4gIHZhciByZWR1Y2UgPSAxMDtcblxuICB2YXIgUkVBRF9UT0tFTiA9IDA7XG4gIHZhciBSQUlTRV9QQVJTRV9FUlJPUiA9IDE7XG4gIHZhciBHUk9XX1NUQUNLU18xID0gMjtcbiAgdmFyIEdST1dfU1RBQ0tTXzIgPSAzO1xuICB2YXIgQ09NUFVURV9TRU1BTlRJQ19BQ1RJT04gPSA0O1xuICB2YXIgQ0FMTF9FUlJPUl9GVU5DVElPTiA9IDU7XG5cbiAgdmFyIGVudl9zX3N0YWNrID0gMTtcbiAgdmFyIGVudl92X3N0YWNrID0gMjtcbiAgdmFyIGVudl9zeW1iX3N0YXJ0X3N0YWNrID0gMztcbiAgdmFyIGVudl9zeW1iX2VuZF9zdGFjayA9IDQ7XG4gIHZhciBlbnZfc3RhY2tzaXplID0gNTtcbiAgdmFyIGVudl9zdGFja2Jhc2UgPSA2O1xuICB2YXIgZW52X2N1cnJfY2hhciA9IDc7XG4gIHZhciBlbnZfbHZhbCA9IDg7XG4gIHZhciBlbnZfc3ltYl9zdGFydCA9IDk7XG4gIHZhciBlbnZfc3ltYl9lbmQgPSAxMDtcbiAgdmFyIGVudl9hc3AgPSAxMTtcbiAgdmFyIGVudl9ydWxlX2xlbiA9IDEyO1xuICB2YXIgZW52X3J1bGVfbnVtYmVyID0gMTM7XG4gIHZhciBlbnZfc3AgPSAxNDtcbiAgdmFyIGVudl9zdGF0ZSA9IDE1O1xuICB2YXIgZW52X2VycmZsYWcgPSAxNjtcblxuICAvLyB2YXIgX3RibF9hY3Rpb25zID0gMTtcbiAgdmFyIHRibF90cmFuc2xfY29uc3QgPSAyO1xuICB2YXIgdGJsX3RyYW5zbF9ibG9jayA9IDM7XG4gIHZhciB0YmxfbGhzID0gNDtcbiAgdmFyIHRibF9sZW4gPSA1O1xuICB2YXIgdGJsX2RlZnJlZCA9IDY7XG4gIHZhciB0YmxfZGdvdG8gPSA3O1xuICB2YXIgdGJsX3NpbmRleCA9IDg7XG4gIHZhciB0YmxfcmluZGV4ID0gOTtcbiAgdmFyIHRibF9naW5kZXggPSAxMDtcbiAgdmFyIHRibF90YWJsZXNpemUgPSAxMTtcbiAgdmFyIHRibF90YWJsZSA9IDEyO1xuICB2YXIgdGJsX2NoZWNrID0gMTM7XG4gIC8vIHZhciBfdGJsX2Vycm9yX2Z1bmN0aW9uID0gMTQ7XG4gIHZhciB0YmxfbmFtZXNfY29uc3QgPSAxNTtcbiAgdmFyIHRibF9uYW1lc19ibG9jayA9IDE2O1xuXG5cbiAgZnVuY3Rpb24gbG9nKHgpIHtcbiAgICB2YXIgcyA9IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoeCArIFwiXFxuXCIpO1xuICAgIGNhbWxfbWxfb3V0cHV0KDIsIHMsIDAsIGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSk7XG4gIH1cblxuICBmdW5jdGlvbiB0b2tlbl9uYW1lKG5hbWVzLCBudW1iZXIpXG4gIHtcbiAgICB2YXIgc3RyID0gY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcobmFtZXMpO1xuICAgIGlmIChzdHJbMF0gPT0gJ1xceDAwJylcbiAgICAgIHJldHVybiBcIjx1bmtub3duIHRva2VuPlwiO1xuICAgIHJldHVybiBzdHIuc3BsaXQoJ1xceDAwJylbbnVtYmVyXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByaW50X3Rva2VuKHN0YXRlLCB0b2spXG4gIHtcbiAgICB2YXIgdG9rZW4sIGtpbmQ7XG4gICAgaWYgKHRvayBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICB0b2tlbiA9IHRva2VuX25hbWUodGFibGVzW3RibF9uYW1lc19ibG9ja10sIHRva1swXSk7XG4gICAgICBpZiAodHlwZW9mIHRva1sxXSA9PSBcIm51bWJlclwiKVxuICAgICAgICBraW5kID0gXCJcIiArIHRva1sxXTtcbiAgICAgIGVsc2UgaWYgKHR5cGVvZiB0b2tbMV0gPT0gXCJzdHJpbmdcIilcbiAgICAgICAga2luZCA9IHRva1sxXVxuICAgICAgZWxzZSBpZiAodG9rWzFdIGluc3RhbmNlb2YgTWxCeXRlcylcbiAgICAgICAga2luZCA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcodG9rWzFdKVxuICAgICAgZWxzZVxuICAgICAgICBraW5kID0gXCJfXCJcbiAgICAgIGxvZyhcIlN0YXRlIFwiICsgc3RhdGUgKyBcIjogcmVhZCB0b2tlbiBcIiArIHRva2VuICsgXCIoXCIgKyBraW5kICsgXCIpXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0b2tlbiA9IHRva2VuX25hbWUodGFibGVzW3RibF9uYW1lc19jb25zdF0sIHRvayk7XG4gICAgICBsb2coXCJTdGF0ZSBcIiArIHN0YXRlICsgXCI6IHJlYWQgdG9rZW4gXCIgKyB0b2tlbik7XG4gICAgfVxuICB9XG5cbiAgaWYgKCF0YWJsZXMuZGdvdG8pIHtcbiAgICB0YWJsZXMuZGVmcmVkID0gY2FtbF9sZXhfYXJyYXkgKHRhYmxlc1t0YmxfZGVmcmVkXSk7XG4gICAgdGFibGVzLnNpbmRleCA9IGNhbWxfbGV4X2FycmF5ICh0YWJsZXNbdGJsX3NpbmRleF0pO1xuICAgIHRhYmxlcy5jaGVjayAgPSBjYW1sX2xleF9hcnJheSAodGFibGVzW3RibF9jaGVja10pO1xuICAgIHRhYmxlcy5yaW5kZXggPSBjYW1sX2xleF9hcnJheSAodGFibGVzW3RibF9yaW5kZXhdKTtcbiAgICB0YWJsZXMudGFibGUgID0gY2FtbF9sZXhfYXJyYXkgKHRhYmxlc1t0YmxfdGFibGVdKTtcbiAgICB0YWJsZXMubGVuICAgID0gY2FtbF9sZXhfYXJyYXkgKHRhYmxlc1t0YmxfbGVuXSk7XG4gICAgdGFibGVzLmxocyAgICA9IGNhbWxfbGV4X2FycmF5ICh0YWJsZXNbdGJsX2xoc10pO1xuICAgIHRhYmxlcy5naW5kZXggPSBjYW1sX2xleF9hcnJheSAodGFibGVzW3RibF9naW5kZXhdKTtcbiAgICB0YWJsZXMuZGdvdG8gID0gY2FtbF9sZXhfYXJyYXkgKHRhYmxlc1t0YmxfZGdvdG9dKTtcbiAgfVxuXG4gIHZhciByZXMgPSAwLCBuLCBuMSwgbjIsIHN0YXRlMTtcblxuICAvLyBSRVNUT1JFXG4gIHZhciBzcCA9IGVudltlbnZfc3BdO1xuICB2YXIgc3RhdGUgPSBlbnZbZW52X3N0YXRlXTtcbiAgdmFyIGVycmZsYWcgPSBlbnZbZW52X2VycmZsYWddO1xuXG4gIGV4aXQ6Zm9yICg7Oykge1xuICAgIG5leHQ6c3dpdGNoKGNtZCkge1xuICAgIGNhc2UgMDovL1NUQVJUOlxuICAgICAgc3RhdGUgPSAwO1xuICAgICAgZXJyZmxhZyA9IDA7XG4gICAgICAvLyBGYWxsIHRocm91Z2hcblxuICAgIGNhc2UgNjovL2xvb3A6XG4gICAgICBuID0gdGFibGVzLmRlZnJlZFtzdGF0ZV07XG4gICAgICBpZiAobiAhPSAwKSB7IGNtZCA9IHJlZHVjZTsgYnJlYWs7IH1cbiAgICAgIGlmIChlbnZbZW52X2N1cnJfY2hhcl0gPj0gMCkgeyBjbWQgPSB0ZXN0c2hpZnQ7IGJyZWFrOyB9XG4gICAgICByZXMgPSBSRUFEX1RPS0VOO1xuICAgICAgYnJlYWsgZXhpdDtcbiAgICAgIC8qIFRoZSBNTCBjb2RlIGNhbGxzIHRoZSBsZXhlciBhbmQgdXBkYXRlcyAqL1xuICAgICAgLyogc3ltYl9zdGFydCBhbmQgc3ltYl9lbmQgKi9cbiAgICBjYXNlIDE6Ly9UT0tFTl9SRUFEOlxuICAgICAgaWYgKGFyZyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIGVudltlbnZfY3Vycl9jaGFyXSA9IHRhYmxlc1t0YmxfdHJhbnNsX2Jsb2NrXVthcmdbMF0gKyAxXTtcbiAgICAgICAgZW52W2Vudl9sdmFsXSA9IGFyZ1sxXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVudltlbnZfY3Vycl9jaGFyXSA9IHRhYmxlc1t0YmxfdHJhbnNsX2NvbnN0XVthcmcgKyAxXTtcbiAgICAgICAgZW52W2Vudl9sdmFsXSA9IDA7XG4gICAgICB9XG4gICAgICBpZiAoY2FtbF9wYXJzZXJfdHJhY2UpIHByaW50X3Rva2VuIChzdGF0ZSwgYXJnKTtcbiAgICAgIC8vIEZhbGwgdGhyb3VnaFxuXG4gICAgY2FzZSA3Oi8vdGVzdHNoaWZ0OlxuICAgICAgbjEgPSB0YWJsZXMuc2luZGV4W3N0YXRlXTtcbiAgICAgIG4yID0gbjEgKyBlbnZbZW52X2N1cnJfY2hhcl07XG4gICAgICBpZiAobjEgIT0gMCAmJiBuMiA+PSAwICYmIG4yIDw9IHRhYmxlc1t0YmxfdGFibGVzaXplXSAmJlxuICAgICAgICAgIHRhYmxlcy5jaGVja1tuMl0gPT0gZW52W2Vudl9jdXJyX2NoYXJdKSB7XG4gICAgICAgIGNtZCA9IHNoaWZ0OyBicmVhaztcbiAgICAgIH1cbiAgICAgIG4xID0gdGFibGVzLnJpbmRleFtzdGF0ZV07XG4gICAgICBuMiA9IG4xICsgZW52W2Vudl9jdXJyX2NoYXJdO1xuICAgICAgaWYgKG4xICE9IDAgJiYgbjIgPj0gMCAmJiBuMiA8PSB0YWJsZXNbdGJsX3RhYmxlc2l6ZV0gJiZcbiAgICAgICAgICB0YWJsZXMuY2hlY2tbbjJdID09IGVudltlbnZfY3Vycl9jaGFyXSkge1xuICAgICAgICBuID0gdGFibGVzLnRhYmxlW24yXTtcbiAgICAgICAgY21kID0gcmVkdWNlOyBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChlcnJmbGFnIDw9IDApIHtcbiAgICAgICAgcmVzID0gQ0FMTF9FUlJPUl9GVU5DVElPTjtcbiAgICAgICAgYnJlYWsgZXhpdDtcbiAgICAgIH1cbiAgICAgIC8vIEZhbGwgdGhyb3VnaFxuICAgICAgLyogVGhlIE1MIGNvZGUgY2FsbHMgdGhlIGVycm9yIGZ1bmN0aW9uICovXG4gICAgY2FzZSA1Oi8vRVJST1JfREVURUNURUQ6XG4gICAgICBpZiAoZXJyZmxhZyA8IDMpIHtcbiAgICAgICAgZXJyZmxhZyA9IDM7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICBzdGF0ZTEgPSBlbnZbZW52X3Nfc3RhY2tdW3NwICsgMV07XG4gICAgICAgICAgbjEgPSB0YWJsZXMuc2luZGV4W3N0YXRlMV07XG4gICAgICAgICAgbjIgPSBuMSArIEVSUkNPREU7XG4gICAgICAgICAgaWYgKG4xICE9IDAgJiYgbjIgPj0gMCAmJiBuMiA8PSB0YWJsZXNbdGJsX3RhYmxlc2l6ZV0gJiZcbiAgICAgICAgICAgICAgdGFibGVzLmNoZWNrW24yXSA9PSBFUlJDT0RFKSB7XG4gICAgICAgICAgICBpZiAoY2FtbF9wYXJzZXJfdHJhY2UpXG4gICAgICAgICAgICAgIGxvZyhcIlJlY292ZXJpbmcgaW4gc3RhdGUgXCIgKyBzdGF0ZTEpO1xuICAgICAgICAgICAgY21kID0gc2hpZnRfcmVjb3ZlcjsgYnJlYWsgbmV4dDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGNhbWxfcGFyc2VyX3RyYWNlKVxuICAgICAgICAgICAgICBsb2coXCJEaXNjYXJkaW5nIHN0YXRlIFwiICsgc3RhdGUxKTtcbiAgICAgICAgICAgIGlmIChzcCA8PSBlbnZbZW52X3N0YWNrYmFzZV0pIHtcbiAgICAgICAgICAgICAgaWYgKGNhbWxfcGFyc2VyX3RyYWNlKVxuICAgICAgICAgICAgICAgIGxvZyhcIk5vIG1vcmUgc3RhdGVzIHRvIGRpc2NhcmRcIik7XG4gICAgICAgICAgICAgIHJldHVybiBSQUlTRV9QQVJTRV9FUlJPUjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIFRoZSBNTCBjb2RlIHJhaXNlcyBQYXJzZV9lcnJvciAqL1xuICAgICAgICAgICAgc3AtLTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChlbnZbZW52X2N1cnJfY2hhcl0gPT0gMClcbiAgICAgICAgICByZXR1cm4gUkFJU0VfUEFSU0VfRVJST1I7IC8qIFRoZSBNTCBjb2RlIHJhaXNlcyBQYXJzZV9lcnJvciAqL1xuICAgICAgICBpZiAoY2FtbF9wYXJzZXJfdHJhY2UpXG4gICAgICAgICAgbG9nKFwiRGlzY2FyZGluZyBsYXN0IHRva2VuIHJlYWRcIik7XG4gICAgICAgIGVudltlbnZfY3Vycl9jaGFyXSA9IC0xO1xuICAgICAgICBjbWQgPSBsb29wOyBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vIEZhbGwgdGhyb3VnaFxuICAgIGNhc2UgODovL3NoaWZ0OlxuICAgICAgZW52W2Vudl9jdXJyX2NoYXJdID0gLTE7XG4gICAgICBpZiAoZXJyZmxhZyA+IDApIGVycmZsYWctLTtcbiAgICAgIC8vIEZhbGwgdGhyb3VnaFxuICAgIGNhc2UgOTovL3NoaWZ0X3JlY292ZXI6XG4gICAgICBpZiAoY2FtbF9wYXJzZXJfdHJhY2UpXG4gICAgICAgIGxvZyhcIlN0YXRlIFwiICsgc3RhdGUgKyBcIjogc2hpZnQgdG8gc3RhdGUgXCIgKyB0YWJsZXMudGFibGVbbjJdKTtcbiAgICAgIHN0YXRlID0gdGFibGVzLnRhYmxlW24yXTtcbiAgICAgIHNwKys7XG4gICAgICBpZiAoc3AgPj0gZW52W2Vudl9zdGFja3NpemVdKSB7XG4gICAgICAgIHJlcyA9IEdST1dfU1RBQ0tTXzE7XG4gICAgICAgIGJyZWFrIGV4aXQ7XG4gICAgICB9XG4gICAgICAvLyBGYWxsIHRocm91Z2hcbiAgICAgIC8qIFRoZSBNTCBjb2RlIHJlc2l6ZXMgdGhlIHN0YWNrcyAqL1xuICAgIGNhc2UgMjovL1NUQUNLU19HUk9XTl8xOlxuICAgICAgZW52W2Vudl9zX3N0YWNrXVtzcCArIDFdID0gc3RhdGU7XG4gICAgICBlbnZbZW52X3Zfc3RhY2tdW3NwICsgMV0gPSBlbnZbZW52X2x2YWxdO1xuICAgICAgZW52W2Vudl9zeW1iX3N0YXJ0X3N0YWNrXVtzcCArIDFdID0gZW52W2Vudl9zeW1iX3N0YXJ0XTtcbiAgICAgIGVudltlbnZfc3ltYl9lbmRfc3RhY2tdW3NwICsgMV0gPSBlbnZbZW52X3N5bWJfZW5kXTtcbiAgICAgIGNtZCA9IGxvb3A7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgMTA6Ly9yZWR1Y2U6XG4gICAgICBpZiAoY2FtbF9wYXJzZXJfdHJhY2UpXG4gICAgICAgIGxvZyhcIlN0YXRlIFwiICsgc3RhdGUgKyBcIjogcmVkdWNlIGJ5IHJ1bGUgXCIgKyBuKTtcbiAgICAgIHZhciBtID0gdGFibGVzLmxlbltuXTtcbiAgICAgIGVudltlbnZfYXNwXSA9IHNwO1xuICAgICAgZW52W2Vudl9ydWxlX251bWJlcl0gPSBuO1xuICAgICAgZW52W2Vudl9ydWxlX2xlbl0gPSBtO1xuICAgICAgc3AgPSBzcCAtIG0gKyAxO1xuICAgICAgbSA9IHRhYmxlcy5saHNbbl07XG4gICAgICBzdGF0ZTEgPSBlbnZbZW52X3Nfc3RhY2tdW3NwXTtcbiAgICAgIG4xID0gdGFibGVzLmdpbmRleFttXTtcbiAgICAgIG4yID0gbjEgKyBzdGF0ZTE7XG4gICAgICBpZiAobjEgIT0gMCAmJiBuMiA+PSAwICYmIG4yIDw9IHRhYmxlc1t0YmxfdGFibGVzaXplXSAmJlxuICAgICAgICAgIHRhYmxlcy5jaGVja1tuMl0gPT0gc3RhdGUxKVxuICAgICAgICBzdGF0ZSA9IHRhYmxlcy50YWJsZVtuMl07XG4gICAgICBlbHNlXG4gICAgICAgIHN0YXRlID0gdGFibGVzLmRnb3RvW21dO1xuICAgICAgaWYgKHNwID49IGVudltlbnZfc3RhY2tzaXplXSkge1xuICAgICAgICByZXMgPSBHUk9XX1NUQUNLU18yO1xuICAgICAgICBicmVhayBleGl0O1xuICAgICAgfVxuICAgICAgLy8gRmFsbCB0aHJvdWdoXG4gICAgICAvKiBUaGUgTUwgY29kZSByZXNpemVzIHRoZSBzdGFja3MgKi9cbiAgICBjYXNlIDM6Ly9TVEFDS1NfR1JPV05fMjpcbiAgICAgIHJlcyA9IENPTVBVVEVfU0VNQU5USUNfQUNUSU9OO1xuICAgICAgYnJlYWsgZXhpdDtcbiAgICAgIC8qIFRoZSBNTCBjb2RlIGNhbGxzIHRoZSBzZW1hbnRpYyBhY3Rpb24gKi9cbiAgICBjYXNlIDQ6Ly9TRU1BTlRJQ19BQ1RJT05fQ09NUFVURUQ6XG4gICAgICBlbnZbZW52X3Nfc3RhY2tdW3NwICsgMV0gPSBzdGF0ZTtcbiAgICAgIGVudltlbnZfdl9zdGFja11bc3AgKyAxXSA9IGFyZztcbiAgICAgIHZhciBhc3AgPSBlbnZbZW52X2FzcF07XG4gICAgICBlbnZbZW52X3N5bWJfZW5kX3N0YWNrXVtzcCArIDFdID0gZW52W2Vudl9zeW1iX2VuZF9zdGFja11bYXNwICsgMV07XG4gICAgICBpZiAoc3AgPiBhc3ApIHtcbiAgICAgICAgLyogVGhpcyBpcyBhbiBlcHNpbG9uIHByb2R1Y3Rpb24uIFRha2Ugc3ltYl9zdGFydCBlcXVhbCB0byBzeW1iX2VuZC4gKi9cbiAgICAgICAgZW52W2Vudl9zeW1iX3N0YXJ0X3N0YWNrXVtzcCArIDFdID0gZW52W2Vudl9zeW1iX2VuZF9zdGFja11bYXNwICsgMV07XG4gICAgICB9XG4gICAgICBjbWQgPSBsb29wOyBicmVhaztcbiAgICAgIC8qIFNob3VsZCBub3QgaGFwcGVuICovXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBSQUlTRV9QQVJTRV9FUlJPUjtcbiAgICB9XG4gIH1cbiAgLy8gU0FWRVxuICBlbnZbZW52X3NwXSA9IHNwO1xuICBlbnZbZW52X3N0YXRlXSA9IHN0YXRlO1xuICBlbnZbZW52X2VycmZsYWddID0gZXJyZmxhZztcbiAgcmV0dXJuIHJlcztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zZXRfcGFyc2VyX3RyYWNlXG4vL1JlcXVpcmVzOiBjYW1sX3BhcnNlcl90cmFjZVxuZnVuY3Rpb24gY2FtbF9zZXRfcGFyc2VyX3RyYWNlKGJvb2wpIHtcbiAgdmFyIG9sZGZsYWcgPSBjYW1sX3BhcnNlcl90cmFjZTtcbiAgY2FtbF9wYXJzZXJfdHJhY2UgPSBib29sO1xuICByZXR1cm4gb2xkZmxhZztcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAyMCAtIEh1Z28gSGV1emFyZFxuLy8gQ29weXJpZ2h0IChDKSAyMDIwIC0gU2hhY2hhciBJdHpoYWt5XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vLyBCYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vb2NhbWwvb2NhbWwvYmxvYi80LjA3L290aGVybGlicy9zdHIvc3Ryc3R1YnMuY1xuLy8gQ29waWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2pzY29xL2pzY29xL2Jsb2IvdjguMTEvY29xLWpzL2pzX3N0dWIvc3RyLmpzXG5cbi8vUHJvdmlkZXM6IHJlX21hdGNoXG4vL1JlcXVpcmVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nLCBjYW1sX2pzX2Zyb21fYXJyYXksIGNhbWxfdWludDhfYXJyYXlfb2Zfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19nZXRcblxudmFyIHJlX21hdGNoID0gZnVuY3Rpb24oKXtcbiAgdmFyIHJlX3dvcmRfbGV0dGVycyA9IFtcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAgICAgICAvKiAweDAwLTB4MUY6IG5vbmUgKi9cbiAgICAweDAwLCAweDAwLCAweEZGLCAweDAzLCAgICAgICAvKiAweDIwLTB4M0Y6IGRpZ2l0cyAwLTkgKi9cbiAgICAweEZFLCAweEZGLCAweEZGLCAweDg3LCAgICAgICAvKiAweDQwLTB4NUY6IEEgdG8gWiwgXyAqL1xuICAgIDB4RkUsIDB4RkYsIDB4RkYsIDB4MDcsICAgICAgIC8qIDB4NjAtMHg3RjogYSB0byB6ICovXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgICAgICAgLyogMHg4MC0weDlGOiBub25lICovXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgICAgICAgLyogMHhBMC0weEJGOiBub25lICovXG4gICAgMHhGRiwgMHhGRiwgMHg3RiwgMHhGRiwgICAgICAgLyogMHhDMC0weERGOiBMYXRpbi0xIGFjY2VudGVkIHVwcGVyY2FzZSAqL1xuICAgIDB4RkYsIDB4RkYsIDB4N0YsIDB4RkYgICAgICAgIC8qIDB4RTAtMHhGRjogTGF0aW4tMSBhY2NlbnRlZCBsb3dlcmNhc2UgKi9cbiAgXTtcblxuICB2YXIgb3Bjb2RlcyA9IHtcbiAgICBDSEFSOiAwLCBDSEFSTk9STTogMSwgU1RSSU5HOiAyLCBTVFJJTkdOT1JNOiAzLCBDSEFSQ0xBU1M6IDQsXG4gICAgQk9MOiA1LCBFT0w6IDYsIFdPUkRCT1VOREFSWTogNyxcbiAgICBCRUdHUk9VUDogOCwgRU5ER1JPVVA6IDksIFJFRkdST1VQOiAxMCxcbiAgICBBQ0NFUFQ6IDExLFxuICAgIFNJTVBMRU9QVDogMTIsIFNJTVBMRVNUQVI6IDEzLCBTSU1QTEVQTFVTOiAxNCxcbiAgICBHT1RPOiAxNSwgUFVTSEJBQ0s6IDE2LCBTRVRNQVJLOiAxNyxcbiAgICBDSEVDS1BST0dSRVNTOiAxOFxuICB9O1xuXG4gIGZ1bmN0aW9uIGlzX3dvcmRfbGV0dGVyKGMpIHtcbiAgICByZXR1cm4gKHJlX3dvcmRfbGV0dGVyc1sgIChjID4+IDMpXSA+PiAoYyAmIDcpKSAmIDE7XG4gIH1cblxuICBmdW5jdGlvbiBpbl9iaXRzZXQocyxpKSB7XG4gICAgcmV0dXJuIChjYW1sX3N0cmluZ19nZXQocywoaSA+PiAzKSkgPj4gKGkgJiA3KSkgJiAxO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVfbWF0Y2hfaW1wbChyZSwgcywgcG9zLCBwYXJ0aWFsKSB7XG5cbiAgICB2YXIgcHJvZyAgICAgICAgICA9IGNhbWxfanNfZnJvbV9hcnJheShyZVsxXSksXG4gICAgICAgIGNwb29sICAgICAgICAgPSBjYW1sX2pzX2Zyb21fYXJyYXkocmVbMl0pLFxuICAgICAgICBub3JtdGFibGUgICAgID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhyZVszXSksXG4gICAgICAgIG51bWdyb3VwcyAgICAgPSByZVs0XSB8IDAsXG4gICAgICAgIG51bXJlZ2lzdGVycyAgPSByZVs1XSB8IDAsXG4gICAgICAgIHN0YXJ0Y2hhcnMgICAgPSByZVs2XSB8IDA7XG5cbiAgICB2YXIgcyA9IGNhbWxfdWludDhfYXJyYXlfb2Zfc3RyaW5nKHMpO1xuXG4gICAgdmFyIHBjID0gMCxcbiAgICAgICAgcXVpdCA9IGZhbHNlLFxuICAgICAgICBzdGFjayA9IFtdLFxuICAgICAgICBncm91cHMgPSBuZXcgQXJyYXkobnVtZ3JvdXBzKSxcbiAgICAgICAgcmVfcmVnaXN0ZXIgPSBuZXcgQXJyYXkobnVtcmVnaXN0ZXJzKTtcblxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspe1xuICAgICAgZ3JvdXBzW2ldID0ge3N0YXJ0OiAtMSwgZW5kOi0xfVxuICAgIH1cbiAgICBncm91cHNbMF0uc3RhcnQgPSBwb3M7XG5cbiAgICB2YXIgYmFja3RyYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCkge1xuICAgICAgICB2YXIgaXRlbSA9IHN0YWNrLnBvcCgpO1xuICAgICAgICBpZiAoaXRlbS51bmRvKSB7XG4gICAgICAgICAgaXRlbS51bmRvLm9ialtpdGVtLnVuZG8ucHJvcF0gPSBpdGVtLnVuZG8udmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZihpdGVtLnBvcykge1xuICAgICAgICAgIHBjID0gaXRlbS5wb3MucGM7XG4gICAgICAgICAgcG9zID0gaXRlbS5wb3MudHh0O1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcXVpdCA9IHRydWU7XG4gICAgfTtcblxuICAgIHZhciBwdXNoID0gZnVuY3Rpb24oaXRlbSkgeyBzdGFjay5wdXNoKGl0ZW0pOyB9O1xuXG4gICAgdmFyIGFjY2VwdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGdyb3Vwc1swXS5lbmQgPSBwb3M7XG4gICAgICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KDEgKyBncm91cHMubGVuZ3RoKjIpO1xuICAgICAgcmVzdWx0WzBdID0gMDsgLy8gdGFnXG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGcgPSBncm91cHNbaV07XG4gICAgICAgIGlmKGcuc3RhcnQgPCAwIHx8IGcuZW5kIDwgMCkge1xuICAgICAgICAgIGcuc3RhcnQgPSBnLmVuZCA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdFsyKmkgKyAxIF0gPSBnLnN0YXJ0O1xuICAgICAgICByZXN1bHRbMippICsgMSArIDEgXSA9IGcuZW5kO1xuICAgICAgfTtcbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9O1xuXG4gICAgdmFyIHByZWZpeF9tYXRjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmKHBhcnRpYWwpIHJldHVybiBhY2NlcHQgKCk7XG4gICAgICBlbHNlIGJhY2t0cmFjayAoKTtcbiAgICB9XG5cbiAgICAvKiBNYWluIERGQSBpbnRlcnByZXRlciBsb29wICovXG4gICAgd2hpbGUgKCFxdWl0KSB7XG4gICAgICB2YXIgb3AgPSBwcm9nW3BjXSAmIDB4ZmYsXG4gICAgICAgICAgc2FyZyA9IHByb2dbcGNdID4+IDgsXG4gICAgICAgICAgdWFyZyA9IHNhcmcgJiAweGZmLFxuICAgICAgICAgIGMgPSBzW3Bvc10sXG4gICAgICAgICAgZ3JvdXA7XG5cbiAgICAgIHBjKys7XG5cbiAgICAgIHN3aXRjaCAob3ApIHtcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5DSEFSOlxuICAgICAgICBpZihwb3MgPT09IHMubGVuZ3RoKSB7cHJlZml4X21hdGNoICgpOyBicmVha307XG4gICAgICAgIGlmIChjID09PSB1YXJnKSBwb3MrKztcbiAgICAgICAgZWxzZSBiYWNrdHJhY2soKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuQ0hBUk5PUk06XG4gICAgICAgIGlmKHBvcyA9PT0gcy5sZW5ndGgpIHtwcmVmaXhfbWF0Y2ggKCk7IGJyZWFrfTtcbiAgICAgICAgaWYgKG5vcm10YWJsZS5jaGFyQ29kZUF0KGMpID09PSB1YXJnKSBwb3MrKztcbiAgICAgICAgZWxzZSBiYWNrdHJhY2soKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuU1RSSU5HOlxuICAgICAgICBmb3IgKHZhciBhcmcgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKGNwb29sW3VhcmddKSwgaSA9IDA7IGkgPCBhcmcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZihwb3MgPT09IHMubGVuZ3RoKSB7cHJlZml4X21hdGNoICgpOyBicmVha307XG4gICAgICAgICAgaWYgKGMgPT09IGFyZy5jaGFyQ29kZUF0KGkpKVxuICAgICAgICAgICAgYyA9IHNbKytwb3NdO1xuICAgICAgICAgIGVsc2UgeyBiYWNrdHJhY2soKTsgYnJlYWs7IH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5TVFJJTkdOT1JNOlxuICAgICAgICBmb3IgKHZhciBhcmcgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKGNwb29sW3VhcmddKSwgaSA9IDA7IGkgPCBhcmcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZihwb3MgPT09IHMubGVuZ3RoKSB7cHJlZml4X21hdGNoICgpOyBicmVha307XG4gICAgICAgICAgaWYgKG5vcm10YWJsZS5jaGFyQ29kZUF0KGMpID09PSBhcmcuY2hhckNvZGVBdChpKSlcbiAgICAgICAgICAgIGMgPSBzWysrcG9zXTtcbiAgICAgICAgICBlbHNlIHsgYmFja3RyYWNrKCk7IGJyZWFrOyB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuQ0hBUkNMQVNTOlxuICAgICAgICBpZihwb3MgPT09IHMubGVuZ3RoKSB7cHJlZml4X21hdGNoICgpOyBicmVha307XG4gICAgICAgIGlmIChpbl9iaXRzZXQoY3Bvb2xbdWFyZ10sIGMpKSBwb3MrKztcbiAgICAgICAgZWxzZSBiYWNrdHJhY2soKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuQk9MOlxuICAgICAgICBpZihwb3MgPiAwICYmIHNbcG9zIC0gMV0gIT0gMTAgLyogXFxuICovKSB7YmFja3RyYWNrKCl9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLkVPTDpcbiAgICAgICAgaWYocG9zIDwgcy5sZW5ndGggJiYgc1twb3NdICE9IDEwIC8qIFxcbiAqLykge2JhY2t0cmFjaygpfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5XT1JEQk9VTkRBUlk6XG4gICAgICAgIGlmKHBvcyA9PSAwKSB7XG4gICAgICAgICAgaWYocG9zID09PSBzLmxlbmd0aCkge3ByZWZpeF9tYXRjaCAoKTsgYnJlYWt9O1xuICAgICAgICAgIGlmKGlzX3dvcmRfbGV0dGVyKHNbMF0pKSBicmVhaztcbiAgICAgICAgICBiYWNrdHJhY2soKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwb3MgPT09IHMubGVuZ3RoKSB7XG4gICAgICAgICAgaWYoaXNfd29yZF9sZXR0ZXIoc1twb3MgLSAxXSkpIGJyZWFrO1xuICAgICAgICAgIGJhY2t0cmFjayAoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpZihpc193b3JkX2xldHRlcihzW3BvcyAtIDFdKSAhPSBpc193b3JkX2xldHRlcihzW3Bvc10pKSBicmVhaztcbiAgICAgICAgICBiYWNrdHJhY2sgKCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuQkVHR1JPVVA6XG4gICAgICAgIGdyb3VwID0gZ3JvdXBzW3VhcmddO1xuICAgICAgICBwdXNoKHt1bmRvOiB7b2JqOmdyb3VwLFxuICAgICAgICAgICAgICAgICAgICAgcHJvcDonc3RhcnQnLFxuICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGdyb3VwLnN0YXJ0fX0pO1xuICAgICAgICBncm91cC5zdGFydCA9IHBvcztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuRU5ER1JPVVA6XG4gICAgICAgIGdyb3VwID0gZ3JvdXBzW3VhcmddO1xuICAgICAgICBwdXNoKHt1bmRvOiB7b2JqOiBncm91cCxcbiAgICAgICAgICAgICAgICAgICAgIHByb3A6J2VuZCcsXG4gICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZ3JvdXAuZW5kfX0pO1xuICAgICAgICBncm91cC5lbmQgPSBwb3M7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLlJFRkdST1VQOlxuICAgICAgICBncm91cCA9IGdyb3Vwc1t1YXJnXTtcbiAgICAgICAgaWYoZ3JvdXAuc3RhcnQgPCAwIHx8IGdyb3VwLmVuZCA8IDApIHtiYWNrdHJhY2sgKCk7IGJyZWFrfVxuICAgICAgICBmb3IgKHZhciBpID0gZ3JvdXAuc3RhcnQ7IGkgPCBncm91cC5lbmQ7IGkrKyl7XG4gICAgICAgICAgaWYocG9zID09PSBzLmxlbmd0aCkge3ByZWZpeF9tYXRjaCAoKTsgYnJlYWt9O1xuICAgICAgICAgIGlmKHNbaV0gIT0gc1twb3NdKSB7YmFja3RyYWNrICgpOyBicmVha31cbiAgICAgICAgICBwb3MrKztcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5TSU1QTEVPUFQ6XG4gICAgICAgIGlmIChpbl9iaXRzZXQoY3Bvb2xbdWFyZ10sIGMpKSBwb3MrKztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuU0lNUExFU1RBUjpcbiAgICAgICAgd2hpbGUgKGluX2JpdHNldChjcG9vbFt1YXJnXSwgYykpXG4gICAgICAgICAgYyA9IHNbKytwb3NdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5TSU1QTEVQTFVTOlxuICAgICAgICBpZihwb3MgPT09IHMubGVuZ3RoKSB7cHJlZml4X21hdGNoICgpOyBicmVha307XG4gICAgICAgIGlmIChpbl9iaXRzZXQoY3Bvb2xbdWFyZ10sIGMpKSB7XG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgYyA9IHNbKytwb3NdO1xuICAgICAgICAgIH0gd2hpbGUgKGluX2JpdHNldChjcG9vbFt1YXJnXSwgYykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgYmFja3RyYWNrKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLkFDQ0VQVDpcbiAgICAgICAgcmV0dXJuIGFjY2VwdCgpO1xuICAgICAgY2FzZSBvcGNvZGVzLkdPVE86XG4gICAgICAgIHBjID0gcGMgKyBzYXJnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5QVVNIQkFDSzpcbiAgICAgICAgcHVzaCh7cG9zOiB7cGM6IHBjICsgc2FyZywgdHh0OiBwb3N9fSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLlNFVE1BUks6XG4gICAgICAgIHB1c2goe3VuZG86IHtvYmo6cmVfcmVnaXN0ZXIsXG4gICAgICAgICAgICAgICAgICAgICBwcm9wOiB1YXJnLFxuICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHJlX3JlZ2lzdGVyW3VhcmddfX0pO1xuICAgICAgICByZV9yZWdpc3Rlclt1YXJnXSA9IHBvcztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuQ0hFQ0tQUk9HUkVTUzpcbiAgICAgICAgaWYgKHJlX3JlZ2lzdGVyW3VhcmddID09PSBwb3MpIGJhY2t0cmFjaygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYnl0ZWNvZGVcIik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG5cbiAgcmV0dXJuIHJlX21hdGNoX2ltcGw7XG59KCk7XG5cblxuLy9Qcm92aWRlczogcmVfc2VhcmNoX2ZvcndhcmRcbi8vUmVxdWlyZXM6IHJlX21hdGNoLCBjYW1sX21sX3N0cmluZ19sZW5ndGgsIGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gcmVfc2VhcmNoX2ZvcndhcmQocmUsIHMsIHBvcykge1xuICBpZihwb3MgPCAwIHx8IHBvcyA+IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSlcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJTdHIuc2VhcmNoX2ZvcndhcmRcIilcbiAgd2hpbGUgKHBvcyA8PSBjYW1sX21sX3N0cmluZ19sZW5ndGgocykpIHtcbiAgICB2YXIgcmVzID0gcmVfbWF0Y2gocmUsIHMsIHBvcywgMCk7XG4gICAgaWYgKHJlcykgcmV0dXJuIHJlcztcbiAgICBwb3MrKztcbiAgfVxuXG4gIHJldHVybiBbMF07ICAvKiBbfHxdIDogaW50IGFycmF5ICovXG59XG5cbi8vUHJvdmlkZXM6IHJlX3NlYXJjaF9iYWNrd2FyZFxuLy9SZXF1aXJlczogcmVfbWF0Y2gsIGNhbWxfbWxfc3RyaW5nX2xlbmd0aCwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiByZV9zZWFyY2hfYmFja3dhcmQocmUsIHMsIHBvcykge1xuICBpZihwb3MgPCAwIHx8IHBvcyA+IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSlcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJTdHIuc2VhcmNoX2JhY2t3YXJkXCIpXG4gIHdoaWxlIChwb3MgPj0gMCkge1xuICAgIHZhciByZXMgPSByZV9tYXRjaChyZSwgcywgcG9zLCAwKTtcbiAgICBpZiAocmVzKSByZXR1cm4gcmVzO1xuICAgIHBvcy0tO1xuICB9XG5cbiAgcmV0dXJuIFswXTsgIC8qIFt8fF0gOiBpbnQgYXJyYXkgKi9cbn1cblxuXG4vL1Byb3ZpZGVzOiByZV9zdHJpbmdfbWF0Y2hcbi8vUmVxdWlyZXM6IHJlX21hdGNoLCBjYW1sX21sX3N0cmluZ19sZW5ndGgsIGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gcmVfc3RyaW5nX21hdGNoKHJlLHMscG9zKXtcbiAgaWYocG9zIDwgMCB8fCBwb3MgPiBjYW1sX21sX3N0cmluZ19sZW5ndGgocykpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiU3RyLnN0cmluZ19tYXRjaFwiKVxuICB2YXIgcmVzID0gcmVfbWF0Y2gocmUsIHMsIHBvcywgMCk7XG4gIGlmIChyZXMpIHJldHVybiByZXM7XG4gIGVsc2UgcmV0dXJuIFswXTtcbn1cblxuLy9Qcm92aWRlczogcmVfcGFydGlhbF9tYXRjaFxuLy9SZXF1aXJlczogcmVfbWF0Y2gsIGNhbWxfbWxfc3RyaW5nX2xlbmd0aCwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiByZV9wYXJ0aWFsX21hdGNoKHJlLHMscG9zKXtcbiAgaWYocG9zIDwgMCB8fCBwb3MgPiBjYW1sX21sX3N0cmluZ19sZW5ndGgocykpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiU3RyLnBhcnRpYWxfbWF0Y2hcIilcbiAgdmFyIHJlcyA9IHJlX21hdGNoKHJlLCBzLCBwb3MsIDEpO1xuICBpZiAocmVzKSByZXR1cm4gcmVzO1xuICBlbHNlIHJldHVybiBbMF07XG59XG5cbi8vUHJvdmlkZXM6IHJlX3JlcGxhY2VtZW50X3RleHRcbi8vUmVxdWlyZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmcsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG4vLyBleHRlcm5hbCByZV9yZXBsYWNlbWVudF90ZXh0OiBzdHJpbmcgLT4gaW50IGFycmF5IC0+IHN0cmluZyAtPiBzdHJpbmdcbmZ1bmN0aW9uIHJlX3JlcGxhY2VtZW50X3RleHQocmVwbCxncm91cHMsb3JpZykge1xuICB2YXIgcmVwbCA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcocmVwbCk7XG4gIHZhciBsZW4gPSByZXBsLmxlbmd0aDtcbiAgdmFyIG9yaWcgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKG9yaWcpO1xuICB2YXIgcmVzID0gXCJcIjsgLy9yZXN1bHRcbiAgdmFyIG4gPSAwOyAvLyBjdXJyZW50IHBvc2l0aW9uXG4gIHZhciBjdXI7IC8vY3VycmVudCBjaGFyXG4gIHZhciBzdGFydCwgZW5kLCBjO1xuICB3aGlsZShuIDwgbGVuKXtcbiAgICBjdXIgPSByZXBsLmNoYXJBdChuKyspO1xuICAgIGlmKGN1ciAhPSAnXFxcXCcpe1xuICAgICAgcmVzICs9IGN1cjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpZihuID09IGxlbikgY2FtbF9mYWlsd2l0aChcIlN0ci5yZXBsYWNlOiBpbGxlZ2FsIGJhY2tzbGFzaCBzZXF1ZW5jZVwiKTtcbiAgICAgIGN1ciA9IHJlcGwuY2hhckF0KG4rKyk7XG4gICAgICBzd2l0Y2goY3VyKXtcbiAgICAgIGNhc2UgJ1xcXFwnOlxuICAgICAgICByZXMgKz0gY3VyO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzAnOiBjYXNlICcxJzogY2FzZSAnMic6IGNhc2UgJzMnOiBjYXNlICc0JzpcbiAgICAgIGNhc2UgJzUnOiBjYXNlICc2JzogY2FzZSAnNyc6IGNhc2UgJzgnOiBjYXNlICc5JzpcbiAgICAgICAgYyA9ICtjdXI7XG4gICAgICAgIGlmIChjKjIgPj0gZ3JvdXBzLmxlbmd0aCAtIDEgKVxuICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJTdHIucmVwbGFjZTogcmVmZXJlbmNlIHRvIHVubWF0Y2hlZCBncm91cFwiICk7XG4gICAgICAgIHN0YXJ0ID0gY2FtbF9hcnJheV9nZXQoZ3JvdXBzLGMqMik7XG4gICAgICAgIGVuZCA9IGNhbWxfYXJyYXlfZ2V0KGdyb3VwcywgYyoyICsxKTtcbiAgICAgICAgaWYgKHN0YXJ0ID09IC0xKVxuICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJTdHIucmVwbGFjZTogcmVmZXJlbmNlIHRvIHVubWF0Y2hlZCBncm91cFwiKTtcbiAgICAgICAgcmVzKz1vcmlnLnNsaWNlKHN0YXJ0LGVuZCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmVzICs9ICgnXFxcXCcgICsgY3VyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMocmVzKTsgfVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyX2luaXRpYWxpemVcbmZ1bmN0aW9uIGNhbWxfc3RyX2luaXRpYWxpemUodW5pdCkge1xuICByZXR1cm4gMDtcbn1cbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICBCZW5vaXQgVmF1Z29uLCBFTlNUQSAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMTQgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogUGFkZGluZyBwb3NpdGlvbi4gKilcbnR5cGUgcGFkdHkgPVxuICB8IExlZnQgICAoKiBUZXh0IGlzIGxlZnQganVzdGlmaWVkICgnLScgb3B0aW9uKS4gICAgICAgICAgICAgICAqKVxuICB8IFJpZ2h0ICAoKiBUZXh0IGlzIHJpZ2h0IGp1c3RpZmllZCAobm8gJy0nIG9wdGlvbikuICAgICAgICAgICAqKVxuICB8IFplcm9zICAoKiBUZXh0IGlzIHJpZ2h0IGp1c3RpZmllZCBieSB6ZXJvcyAoc2VlICcwJyBvcHRpb24pLiAqKVxuXG4oKioqKVxuXG4oKiBJbnRlZ2VyIGNvbnZlcnNpb24uICopXG50eXBlIGludF9jb252ID1cbiAgfCBJbnRfZCB8IEludF9wZCB8IEludF9zZCAgICAgICAgKCogICVkIHwgJStkIHwgJSBkICAqKVxuICB8IEludF9pIHwgSW50X3BpIHwgSW50X3NpICAgICAgICAoKiAgJWkgfCAlK2kgfCAlIGkgICopXG4gIHwgSW50X3ggfCBJbnRfQ3ggICAgICAgICAgICAgICAgICgqICAleCB8ICUjeCAgICAgICAgKilcbiAgfCBJbnRfWCB8IEludF9DWCAgICAgICAgICAgICAgICAgKCogICVYIHwgJSNYICAgICAgICAqKVxuICB8IEludF9vIHwgSW50X0NvICAgICAgICAgICAgICAgICAoKiAgJW8gfCAlI28gICAgICAgICopXG4gIHwgSW50X3UgICAgICAgICAgICAgICAgICAgICAgICAgICgqICAldSAgICAgICAgICAgICAgKilcbiAgfCBJbnRfQ2QgfCBJbnRfQ2kgfCBJbnRfQ3UgICAgICAgKCogICUjZCB8ICUjaSB8ICUjdSAqKVxuXG4oKiBGbG9hdCBjb252ZXJzaW9uLiAqKVxudHlwZSBmbG9hdF9mbGFnX2NvbnYgPVxuICB8IEZsb2F0X2ZsYWdfICAgICAgICAgICAgICAgICAgICAoKiAlW2ZlRWdHRmhIXSAqKVxuICB8IEZsb2F0X2ZsYWdfcCAgICAgICAgICAgICAgICAgICAoKiAlK1tmZUVnR0ZoSF0gKilcbiAgfCBGbG9hdF9mbGFnX3MgICAgICAgICAgICAgICAgICAgKCogJSBbZmVFZ0dGaEhdICopXG50eXBlIGZsb2F0X2tpbmRfY29udiA9XG4gIHwgRmxvYXRfZiAgICAgICAgICAgICAgICAgICAgICAgICgqICAlZiB8ICUrZiB8ICUgZiAgKilcbiAgfCBGbG9hdF9lICAgICAgICAgICAgICAgICAgICAgICAgKCogICVlIHwgJStlIHwgJSBlICAqKVxuICB8IEZsb2F0X0UgICAgICAgICAgICAgICAgICAgICAgICAoKiAgJUUgfCAlK0UgfCAlIEUgICopXG4gIHwgRmxvYXRfZyAgICAgICAgICAgICAgICAgICAgICAgICgqICAlZyB8ICUrZyB8ICUgZyAgKilcbiAgfCBGbG9hdF9HICAgICAgICAgICAgICAgICAgICAgICAgKCogICVHIHwgJStHIHwgJSBHICAqKVxuICB8IEZsb2F0X0YgICAgICAgICAgICAgICAgICAgICAgICAoKiAgJUYgfCAlK0YgfCAlIEYgICopXG4gIHwgRmxvYXRfaCAgICAgICAgICAgICAgICAgICAgICAgICgqICAlaCB8ICUraCB8ICUgaCAgKilcbiAgfCBGbG9hdF9IICAgICAgICAgICAgICAgICAgICAgICAgKCogICVIIHwgJStIIHwgJSBIICAqKVxuICB8IEZsb2F0X0NGICAgICAgICAgICAgICAgICAgICAgICAoKiAgJSNGfCAlKyNGfCAlICNGICopXG50eXBlIGZsb2F0X2NvbnYgPSBmbG9hdF9mbGFnX2NvbnYgKiBmbG9hdF9raW5kX2NvbnZcblxuKCoqKilcblxuKCogQ2hhciBzZXRzIChzZWUgJVsuLi5dKSBhcmUgYml0bWFwcyBpbXBsZW1lbnRlZCBhcyAzMi1jaGFyIHN0cmluZ3MuICopXG50eXBlIGNoYXJfc2V0ID0gc3RyaW5nXG5cbigqKiopXG5cbigqIENvdW50ZXIgdXNlZCBpbiBTY2FuZi4gKilcbnR5cGUgY291bnRlciA9XG4gIHwgTGluZV9jb3VudGVyICAgICAoKiAgJWwgICAgICAqKVxuICB8IENoYXJfY291bnRlciAgICAgKCogICVuICAgICAgKilcbiAgfCBUb2tlbl9jb3VudGVyICAgICgqICAlTiwgJUwgICopXG5cbigqKiopXG5cbigqIFBhZGRpbmcgb2Ygc3RyaW5ncyBhbmQgbnVtYmVycy4gKilcbnR5cGUgKCdhLCAnYikgcGFkZGluZyA9XG4gICgqIE5vIHBhZGRpbmcgKGV4OiBcIiVkXCIpICopXG4gIHwgTm9fcGFkZGluZyAgOiAoJ2EsICdhKSBwYWRkaW5nXG4gICgqIExpdGVyYWwgcGFkZGluZyAoZXg6IFwiJThkXCIpICopXG4gIHwgTGl0X3BhZGRpbmcgOiBwYWR0eSAqIGludCAtPiAoJ2EsICdhKSBwYWRkaW5nXG4gICgqIFBhZGRpbmcgYXMgZXh0cmEgYXJndW1lbnQgKGV4OiBcIiUqZFwiKSAqKVxuICB8IEFyZ19wYWRkaW5nIDogcGFkdHkgLT4gKGludCAtPiAnYSwgJ2EpIHBhZGRpbmdcblxuKCogU29tZSBmb3JtYXRzLCBzdWNoIGFzICVfZCxcbiAgIG9ubHkgYWNjZXB0IGFuIG9wdGlvbmFsIG51bWJlciBhcyBwYWRkaW5nIG9wdGlvbiAobm8gZXh0cmEgYXJndW1lbnQpICopXG50eXBlIHBhZF9vcHRpb24gPSBpbnQgb3B0aW9uXG5cbigqIFByZWNpc2lvbiBvZiBmbG9hdHMgYW5kICcwJy1wYWRkaW5nIG9mIGludGVnZXJzLiAqKVxudHlwZSAoJ2EsICdiKSBwcmVjaXNpb24gPVxuICAoKiBObyBwcmVjaXNpb24gKGV4OiBcIiVmXCIpICopXG4gIHwgTm9fcHJlY2lzaW9uIDogKCdhLCAnYSkgcHJlY2lzaW9uXG4gICgqIExpdGVyYWwgcHJlY2lzaW9uIChleDogXCIlLjNmXCIpICopXG4gIHwgTGl0X3ByZWNpc2lvbiA6IGludCAtPiAoJ2EsICdhKSBwcmVjaXNpb25cbiAgKCogUHJlY2lzaW9uIGFzIGV4dHJhIGFyZ3VtZW50IChleDogXCIlLipmXCIpICopXG4gIHwgQXJnX3ByZWNpc2lvbiA6IChpbnQgLT4gJ2EsICdhKSBwcmVjaXNpb25cblxuKCogU29tZSBmb3JtYXRzLCBzdWNoIGFzICVfZixcbiAgIG9ubHkgYWNjZXB0IGFuIG9wdGlvbmFsIG51bWJlciBhcyBwcmVjaXNpb24gb3B0aW9uIChubyBleHRyYSBhcmd1bWVudCkgKilcbnR5cGUgcHJlY19vcHRpb24gPSBpbnQgb3B0aW9uXG5cbigqIHNlZSB0aGUgQ3VzdG9tIGZvcm1hdCBjb21iaW5hdG9yICopXG50eXBlICgnYSwgJ2IsICdjKSBjdXN0b21fYXJpdHkgPVxuICB8IEN1c3RvbV96ZXJvIDogKCdhLCBzdHJpbmcsICdhKSBjdXN0b21fYXJpdHlcbiAgfCBDdXN0b21fc3VjYyA6ICgnYSwgJ2IsICdjKSBjdXN0b21fYXJpdHkgLT5cbiAgICAoJ2EsICd4IC0+ICdiLCAneCAtPiAnYykgY3VzdG9tX2FyaXR5XG5cbigqKiopXG5cbigqICAgICAgICBSZWxhdGlvbmFsIGZvcm1hdCB0eXBlc1xuXG5JbiB0aGUgZmlyc3QgZm9ybWF0K2dhZHRzIGltcGxlbWVudGF0aW9uLCB0aGUgdHlwZSBmb3IgJSguLiUpIGluIHRoZVxuZm10IEdBRFQgd2FzIGFzIGZvbGxvd3M6XG5cbnwgRm9ybWF0X3N1YnN0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJSguLi4lKSAqKVxuICAgIHBhZF9vcHRpb24gKiAoJ2QxLCAncTEsICdkMiwgJ3EyKSByZWFkZXJfbmJfdW5pZmllciAqXG4gICAgKCd4LCAnYiwgJ2MsICdkMSwgJ3ExLCAndSkgZm10dHkgKlxuICAgICgndSwgJ2IsICdjLCAncTEsICdlMSwgJ2YpIGZtdCAtPlxuICAgICAgKCgneCwgJ2IsICdjLCAnZDIsICdxMiwgJ3UpIGZvcm1hdDYgLT4gJ3gsICdiLCAnYywgJ2QxLCAnZTEsICdmKSBmbXRcblxuTm90aWNlIHRoYXQgdGhlICd1IHBhcmFtZXRlciBpbiAnZiBwb3NpdGlvbiBpbiB0aGUgZm9ybWF0IGFyZ3VtZW50XG4oKCd4LCAuLiwgJ3UpIGZvcm1hdDYgLT4gLi4pIGlzIGVxdWFsIHRvIHRoZSAndSBwYXJhbWV0ZXIgaW4gJ2FcbnBvc2l0aW9uIGluIHRoZSBmb3JtYXQgdGFpbCAoKCd1LCAuLiwgJ2YpIGZtdCkuIFRoaXMgbWVhbnMgdGhhdCB0aGVcbnR5cGUgb2YgdGhlIGV4cGVjdGVkIGZvcm1hdCBwYXJhbWV0ZXIgZGVwZW5kcyBvZiB3aGVyZSB0aGUgJSguLi4lKVxuYXJlIGluIHRoZSBmb3JtYXQgc3RyaW5nOlxuXG4gICMgUHJpbnRmLnByaW50ZiBcIiUoJSlcIlxuICAtIDogKHVuaXQsIG91dF9jaGFubmVsLCB1bml0LCAnX2EsICdfYSwgdW5pdClcbiAgICAgIENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljcy5mb3JtYXQ2IC0+IHVuaXRcbiAgPSA8ZnVuPlxuICAjIFByaW50Zi5wcmludGYgXCIlKCUpJWRcIlxuICAtIDogKGludCAtPiB1bml0LCBvdXRfY2hhbm5lbCwgdW5pdCwgJ19hLCAnX2EsIGludCAtPiB1bml0KVxuICAgICAgQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzLmZvcm1hdDYgLT4gaW50IC0+IHVuaXRcbiAgPSA8ZnVuPlxuXG5PbiB0aGUgY29udHJhcnksIHRoZSBsZWdhY3kgdHlwZXIgZ2l2ZXMgYSBjbGV2ZXIgdHlwZSB0aGF0IGRvZXMgbm90XG5kZXBlbmQgb24gdGhlIHBvc2l0aW9uIG9mICUoLi4lKSBpbiB0aGUgZm9ybWF0IHN0cmluZy4gRm9yIGV4YW1wbGUsXG4lKCUpIHdpbGwgaGF2ZSB0aGUgcG9seW1vcnBoaWMgdHlwZSAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSk6IGl0IGNhblxuYmUgY29uY2F0ZW5hdGVkIHRvIGFueSBmb3JtYXQgdHlwZSwgYW5kIG9ubHkgZW5mb3JjZXMgdGhlIGNvbnN0cmFpbnRcbnRoYXQgaXRzICdhIGFuZCAnZiBwYXJhbWV0ZXJzIGFyZSBlcXVhbCAobm8gZm9ybWF0IGFyZ3VtZW50cykgYW5kICdkXG5hbmQgJ2UgYXJlIGVxdWFsIChubyByZWFkZXIgYXJndW1lbnQpLlxuXG5UaGUgd2Vha2VuaW5nIG9mIHRoaXMgcGFyYW1ldGVyIHR5cGUgaW4gdGhlIEdBRFQgdmVyc2lvbiBicm9rZSB1c2VyXG5jb2RlIChpbiBmYWN0IGl0IGVzc2VudGlhbGx5IG1hZGUgJSguLi4lKSB1bnVzYWJsZSBleGNlcHQgYXQgdGhlIGxhc3RcbnBvc2l0aW9uIG9mIGEgZm9ybWF0KS4gSW4gcGFydGljdWxhciwgdGhlIGZvbGxvd2luZyB3b3VsZCBub3Qgd29ya1xuYW55bW9yZTpcblxuICBmdW4gc2VwIC0+XG4gICAgRm9ybWF0LnByaW50ZiBcImZvbyUoJSliYXIlKCUpYmF6XCIgc2VwIHNlcFxuXG5BcyB0aGUgdHlwZS1jaGVja2VyIHdvdWxkIHJlcXVpcmUgdHdvICppbmNvbXBhdGlibGUqIHR5cGVzIGZvciB0aGUgJSglKVxuaW4gZGlmZmVyZW50IHBvc2l0aW9ucy5cblxuVGhlIHNvbHV0aW9uIHRvIHJlZ2FpbiBhIGdlbmVyYWwgdHlwZSBmb3IgJSguLiUpIGlzIHRvIGdlbmVyYWxpemUgdGhpc1xudGVjaG5pcXVlLCBub3Qgb25seSBvbiB0aGUgJ2QsICdlIHBhcmFtZXRlcnMsIGJ1dCBvbiBhbGwgc2l4XG5wYXJhbWV0ZXJzIG9mIGEgZm9ybWF0OiB3ZSBpbnRyb2R1Y2UgYSBcInJlbGF0aW9uYWxcIiB0eXBlXG4gICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG53aG9zZSB2YWx1ZXMgYXJlIHByb29mcyB0aGF0ICgnYTEsIC4uLCAnZjEpIGFuZCAoJ2EyLCAuLiwgJ2YyKSBtb3JhbGx5XG5jb3JyZXNwb25kIHRvIHRoZSBzYW1lIGZvcm1hdCB0eXBlOiAnYTEgaXMgb2J0YWluZWQgZnJvbSAnZjEsJ2IxLCdjMVxuaW4gdGhlIGV4YWN0IHNhbWUgd2F5IHRoYXQgJ2EyIGlzIG9idGFpbmVkIGZyb20gJ2YyLCdiMiwnYzIsIGV0Yy5cblxuRm9yIGV4YW1wbGUsIHRoZSByZWxhdGlvbiBiZXR3ZWVuIHR3byBmb3JtYXQgdHlwZXMgYmVnaW5uaW5nIHdpdGggYSBDaGFyXG5wYXJhbWV0ZXIgaXMgYXMgZm9sbG93czpcblxufCBDaGFyX3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJWMgICopXG4gICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgIChjaGFyIC0+ICdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgIGNoYXIgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG5cbkluIHRoZSBnZW5lcmFsIGNhc2UsIHRoZSB0ZXJtIHN0cnVjdHVyZSBvZiBmbXR0eV9yZWwgaXMgKGFsbW9zdFsxXSlcbmlzb21vcnBoaWMgdG8gdGhlIGZtdHR5IG9mIHRoZSBwcmV2aW91cyBpbXBsZW1lbnRhdGlvbjogZXZlcnlcbmNvbnN0cnVjdG9yIGlzIHJlLXJlYWQgd2l0aCBhIGJpbmFyeSwgcmVsYXRpb25hbCB0eXBlLCBpbnN0ZWFkIG9mIHRoZVxucHJldmlvdXMgdW5hcnkgdHlwaW5nLiBmbXR0eSBjYW4gdGhlbiBiZSByZS1kZWZpbmVkIGFzIHRoZSBkaWFnb25hbCBvZlxuZm10dHlfcmVsOlxuXG4gIHR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdHR5ID1cbiAgICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZixcbiAgICAgICAgJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHlfcmVsXG5cbk9uY2Ugd2UgaGF2ZSB0aGlzIGZtdHR5X3JlbCB0eXBlIGluIHBsYWNlLCB3ZSBjYW4gZ2l2ZSB0aGUgbW9yZVxuZ2VuZXJhbCB0eXBlIHRvICUoLi4uJSk6XG5cbnwgRm9ybWF0X3N1YnN0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJSguLi4lKSAqKVxuICAgIHBhZF9vcHRpb24gKlxuICAgICgnZywgJ2gsICdpLCAnaiwgJ2ssICdsLFxuICAgICAnZzIsICdiLCAnYywgJ2oyLCAnZCwgJ2EpIGZtdHR5X3JlbCAqXG4gICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICgoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm9ybWF0NiAtPiAnZzIsICdiLCAnYywgJ2oyLCAnZSwgJ2YpIGZtdFxuXG5XZSBhY2NlcHQgYW55IGZvcm1hdCAoKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZvcm1hdDYpICh0aGlzIGlzXG5jb21wbGV0ZWx5IHVucmVsYXRlZCB0byB0aGUgdHlwZSBvZiB0aGUgY3VycmVudCBmb3JtYXQpLCBidXQgYWxzb1xucmVxdWlyZSBhIHByb29mIHRoYXQgdGhpcyBmb3JtYXQgaXMgaW4gcmVsYXRpb24gdG8gYW5vdGhlciBmb3JtYXQgdGhhdFxuaXMgY29uY2F0ZW5hYmxlIHRvIHRoZSBmb3JtYXQgdGFpbC4gV2hlbiBleGVjdXRpbmcgYSAlKC4uLiUpIGZvcm1hdFxuKGluIGNhbWxpbnRlcm5hbEZvcm1hdC5tbDptYWtlX3ByaW50ZiBvciBzY2FuZi5tbDptYWtlX3NjYW5mKSwgd2VcbnRyYW5zdHlwZSB0aGUgZm9ybWF0IGFsb25nIHRoaXMgcmVsYXRpb24gdXNpbmcgdGhlICdyZWNhc3QnIGZ1bmN0aW9uXG50byB0cmFuc3Bvc2UgYmV0d2VlbiByZWxhdGVkIGZvcm1hdCB0eXBlcy5cblxuICB2YWwgcmVjYXN0IDpcbiAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEpIGZtdFxuICAtPiAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICAtPiAoJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10XG5cbk5PVEUgWzFdOiB0aGUgdHlwaW5nIG9mIEZvcm1hdF9zdWJzdF90eSByZXF1aXJlcyBub3Qgb25lIGZvcm1hdCB0eXBlLCBidXRcbnR3bywgb25lIHRvIGVzdGFibGlzaCB0aGUgbGluayBiZXR3ZWVuIHRoZSBmb3JtYXQgYXJndW1lbnQgYW5kIHRoZVxuZmlyc3Qgc2l4IHBhcmFtZXRlcnMsIGFuZCB0aGUgb3RoZXIgZm9yIHRoZSBsaW5rIGJldHdlZW4gdGhlIGZvcm1hdFxuYXJndW1lbnQgYW5kIHRoZSBsYXN0IHNpeCBwYXJhbWV0ZXJzLlxuXG58IEZvcm1hdF9zdWJzdF90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlKC4uLiUpICopXG4gICAgKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wsXG4gICAgICdnMSwgJ2IxLCAnYzEsICdqMSwgJ2QxLCAnYTEpIGZtdHR5X3JlbCAqXG4gICAgKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wsXG4gICAgICdnMiwgJ2IyLCAnYzIsICdqMiwgJ2QyLCAnYTIpIGZtdHR5X3JlbCAqXG4gICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICgoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm9ybWF0NiAtPiAnZzEsICdiMSwgJ2MxLCAnajEsICdlMSwgJ2YxLFxuICAgICAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm9ybWF0NiAtPiAnZzIsICdiMiwgJ2MyLCAnajIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcblxuV2hlbiB3ZSBnZW5lcmF0ZSBhIGZvcm1hdCBBU1QsIHdlIGdlbmVyYXRlIGV4YWN0bHkgdGhlIHNhbWUgd2l0bmVzc1xuZm9yIGJvdGggcmVsYXRpb25zLCBhbmQgdGhlIHdpdG5lc3MtY29udmVyc2lvbiBmdW5jdGlvbnMgaW5cbmNhbWxpbnRlcm5hbEZvcm1hdCBkbyByZWx5IG9uIHRoaXMgaW52YXJpYW50LiBGb3IgZXhhbXBsZSwgdGhlXG5mdW5jdGlvbiB0aGF0IHByb3ZlcyB0aGF0IHRoZSByZWxhdGlvbiBpcyB0cmFuc2l0aXZlXG5cbiAgdmFsIHRyYW5zIDpcbiAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgLT4gKCdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIsXG4gICAgICAnYTMsICdiMywgJ2MzLCAnZDMsICdlMywgJ2YzKSBmbXR0eV9yZWxcbiAgLT4gKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAnYTMsICdiMywgJ2MzLCAnZDMsICdlMywgJ2YzKSBmbXR0eV9yZWxcblxuZG9lcyBhc3N1bWUgdGhhdCB0aGUgdHdvIGlucHV0cyBoYXZlIGV4YWN0bHkgdGhlIHNhbWUgdGVybSBzdHJ1Y3R1cmVcbihhbmQgaXMgb25seSBldmVyeSB1c2VkIGZvciBhcmd1bWVudCB3aXRuZXNzZXMgb2YgdGhlXG5Gb3JtYXRfc3Vic3RfdHkgY29uc3RydWN0b3IpLlxuKilcblxuKCogVHlwZSBvZiBhIGJsb2NrIHVzZWQgYnkgdGhlIEZvcm1hdCBwcmV0dHktcHJpbnRlci4gKilcbnR5cGUgYmxvY2tfdHlwZSA9XG4gIHwgUHBfaGJveCAgICgqIEhvcml6b250YWwgYmxvY2sgbm8gbGluZSBicmVha2luZyAqKVxuICB8IFBwX3Zib3ggICAoKiBWZXJ0aWNhbCBibG9jayBlYWNoIGJyZWFrIGxlYWRzIHRvIGEgbmV3IGxpbmUgKilcbiAgfCBQcF9odmJveCAgKCogSG9yaXpvbnRhbC12ZXJ0aWNhbCBibG9jazogc2FtZSBhcyB2Ym94LCBleGNlcHQgaWYgdGhpcyBibG9ja1xuICAgICAgICAgICAgICAgICBpcyBzbWFsbCBlbm91Z2ggdG8gZml0IG9uIGEgc2luZ2xlIGxpbmUgKilcbiAgfCBQcF9ob3Zib3ggKCogSG9yaXpvbnRhbCBvciBWZXJ0aWNhbCBibG9jazogYnJlYWtzIGxlYWQgdG8gbmV3IGxpbmVcbiAgICAgICAgICAgICAgICAgb25seSB3aGVuIG5lY2Vzc2FyeSB0byBwcmludCB0aGUgY29udGVudCBvZiB0aGUgYmxvY2sgKilcbiAgfCBQcF9ib3ggICAgKCogSG9yaXpvbnRhbCBvciBJbmRlbnQgYmxvY2s6IGJyZWFrcyBsZWFkIHRvIG5ldyBsaW5lXG4gICAgICAgICAgICAgICAgIG9ubHkgd2hlbiBuZWNlc3NhcnkgdG8gcHJpbnQgdGhlIGNvbnRlbnQgb2YgdGhlIGJsb2NrLCBvclxuICAgICAgICAgICAgICAgICB3aGVuIGl0IGxlYWRzIHRvIGEgbmV3IGluZGVudGF0aW9uIG9mIHRoZSBjdXJyZW50IGxpbmUgKilcbiAgfCBQcF9maXRzICAgKCogSW50ZXJuYWwgdXNhZ2U6IHdoZW4gYSBibG9jayBmaXRzIG9uIGEgc2luZ2xlIGxpbmUgKilcblxuKCogRm9ybWF0dGluZyBlbGVtZW50IHVzZWQgYnkgdGhlIEZvcm1hdCBwcmV0dHktcHJpbnRlci4gKilcbnR5cGUgZm9ybWF0dGluZ19saXQgPVxuICB8IENsb3NlX2JveCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBAXSAgICopXG4gIHwgQ2xvc2VfdGFnICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEB9ICAgKilcbiAgfCBCcmVhayBvZiBzdHJpbmcgKiBpbnQgKiBpbnQgICAgICAgICAgKCogQCwgfCBAICB8IEA7IHwgQDs8PiAqKVxuICB8IEZGbHVzaCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBAPyAgICopXG4gIHwgRm9yY2VfbmV3bGluZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEBcXG4gICopXG4gIHwgRmx1c2hfbmV3bGluZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEAuICAgKilcbiAgfCBNYWdpY19zaXplIG9mIHN0cmluZyAqIGludCAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQDxuPiAqKVxuICB8IEVzY2FwZWRfYXQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBAQCAgICopXG4gIHwgRXNjYXBlZF9wZXJjZW50ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEAlJSAgKilcbiAgfCBTY2FuX2luZGljIG9mIGNoYXIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQFggICAqKVxuXG4oKiBGb3JtYXR0aW5nIGVsZW1lbnQgdXNlZCBieSB0aGUgRm9ybWF0IHByZXR0eS1wcmludGVyLiAqKVxudHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0dGluZ19nZW4gPVxuICB8IE9wZW5fdGFnIDogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgLT4gICAgICAoKiBAeyAgICopXG4gICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdHRpbmdfZ2VuXG4gIHwgT3Blbl9ib3ggOiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiAtPiAgICAgICgqIEBbICAgKilcbiAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0dGluZ19nZW5cblxuKCoqKilcblxuKCogTGlzdCBvZiBmb3JtYXQgdHlwZSBlbGVtZW50cy4gKilcbigqIEluIHBhcnRpY3VsYXIgdXNlZCB0byByZXByZXNlbnQgJSguLi4lKSBhbmQgJXsuLi4lfSBjb250ZW50cy4gKilcbmFuZCAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHkgPVxuICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZixcbiAgICAgICdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdHR5X3JlbFxuYW5kICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgPVxuICB8IENoYXJfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlYyAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKGNoYXIgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICBjaGFyIC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICB8IFN0cmluZ190eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlcyAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKHN0cmluZyAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgIHN0cmluZyAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgfCBJbnRfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJWQgICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgIChpbnQgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICBpbnQgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG4gIHwgSW50MzJfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVsZCAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoaW50MzIgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICBpbnQzMiAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgfCBOYXRpdmVpbnRfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJW5kICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgIChuYXRpdmVpbnQgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICBuYXRpdmVpbnQgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG4gIHwgSW50NjRfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVMZCAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoaW50NjQgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICBpbnQ2NCAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgfCBGbG9hdF90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJWYgICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgIChmbG9hdCAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgIGZsb2F0IC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICB8IEJvb2xfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlQiAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKGJvb2wgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICBib29sIC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuXG4gIHwgRm9ybWF0X2FyZ190eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICV7Li4uJX0gKilcbiAgICAgICgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmbXR0eSAqXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgICgoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm9ybWF0NiAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmb3JtYXQ2IC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpXG4gICAgICAgICAgIGZtdHR5X3JlbFxuICB8IEZvcm1hdF9zdWJzdF90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlKC4uLiUpICopXG4gICAgICAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCxcbiAgICAgICAnZzEsICdiMSwgJ2MxLCAnajEsICdkMSwgJ2ExKSBmbXR0eV9yZWwgKlxuICAgICAgKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wsXG4gICAgICAgJ2cyLCAnYjIsICdjMiwgJ2oyLCAnZDIsICdhMikgZm10dHlfcmVsICpcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKCgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmb3JtYXQ2IC0+ICdnMSwgJ2IxLCAnYzEsICdqMSwgJ2UxLCAnZjEsXG4gICAgICAgKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZvcm1hdDYgLT4gJ2cyLCAnYjIsICdjMiwgJ2oyLCAnZTIsICdmMilcbiAgICAgICAgICAgZm10dHlfcmVsXG5cbiAgKCogUHJpbnRmIGFuZCBGb3JtYXQgc3BlY2lmaWMgY29uc3RydWN0b3JzLiAqKVxuICB8IEFscGhhX3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlYSAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKCgnYjEgLT4gJ3ggLT4gJ2MxKSAtPiAneCAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICgnYjIgLT4gJ3ggLT4gJ2MyKSAtPiAneCAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgfCBUaGV0YV90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJXQgICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgICgoJ2IxIC0+ICdjMSkgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAoJ2IyIC0+ICdjMikgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG4gIHwgQW55X3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBVc2VkIGZvciBjdXN0b20gZm9ybWF0cyAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoJ3ggLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAneCAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcblxuICAoKiBTY2FuZiBzcGVjaWZpYyBjb25zdHJ1Y3Rvci4gKilcbiAgfCBSZWFkZXJfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJXIgICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgICgneCAtPiAnYTEsICdiMSwgJ2MxLCAoJ2IxIC0+ICd4KSAtPiAnZDEsICdlMSwgJ2YxLFxuICAgICAgICd4IC0+ICdhMiwgJ2IyLCAnYzIsICgnYjIgLT4gJ3gpIC0+ICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICB8IElnbm9yZWRfcmVhZGVyX3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX3IgICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgICgnYTEsICdiMSwgJ2MxLCAoJ2IxIC0+ICd4KSAtPiAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICgnYjIgLT4gJ3gpIC0+ICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuXG4gIHwgRW5kX29mX2ZtdHR5IDpcbiAgICAgICgnZjEsICdiMSwgJ2MxLCAnZDEsICdkMSwgJ2YxLFxuICAgICAgICdmMiwgJ2IyLCAnYzIsICdkMiwgJ2QyLCAnZjIpIGZtdHR5X3JlbFxuXG4oKioqKVxuXG4oKiBMaXN0IG9mIGZvcm1hdCBlbGVtZW50cy4gKilcbmFuZCAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10ID1cbiAgfCBDaGFyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlYyAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoY2hhciAtPiAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBDYW1sX2NoYXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlQyAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoY2hhciAtPiAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBTdHJpbmcgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlcyAqKVxuICAgICAgKCd4LCBzdHJpbmcgLT4gJ2EpIHBhZGRpbmcgKiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgneCwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBDYW1sX3N0cmluZyA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlUyAqKVxuICAgICAgKCd4LCBzdHJpbmcgLT4gJ2EpIHBhZGRpbmcgKiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgneCwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBJbnQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlW2RpeFh1b10gKilcbiAgICAgIGludF9jb252ICogKCd4LCAneSkgcGFkZGluZyAqICgneSwgaW50IC0+ICdhKSBwcmVjaXNpb24gKlxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ3gsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgSW50MzIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJWxbZGl4WHVvXSAqKVxuICAgICAgaW50X2NvbnYgKiAoJ3gsICd5KSBwYWRkaW5nICogKCd5LCBpbnQzMiAtPiAnYSkgcHJlY2lzaW9uICpcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCd4LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IE5hdGl2ZWludCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVuW2RpeFh1b10gKilcbiAgICAgIGludF9jb252ICogKCd4LCAneSkgcGFkZGluZyAqICgneSwgbmF0aXZlaW50IC0+ICdhKSBwcmVjaXNpb24gKlxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ3gsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgSW50NjQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJUxbZGl4WHVvXSAqKVxuICAgICAgaW50X2NvbnYgKiAoJ3gsICd5KSBwYWRkaW5nICogKCd5LCBpbnQ2NCAtPiAnYSkgcHJlY2lzaW9uICpcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCd4LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IEZsb2F0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVbZmVFZ0dGaEhdICopXG4gICAgICBmbG9hdF9jb252ICogKCd4LCAneSkgcGFkZGluZyAqICgneSwgZmxvYXQgLT4gJ2EpIHByZWNpc2lvbiAqXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgneCwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBCb29sIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlW2JCXSAqKVxuICAgICAgKCd4LCBib29sIC0+ICdhKSBwYWRkaW5nICogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ3gsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgRmx1c2ggOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJSEgKilcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuXG4gIHwgU3RyaW5nX2xpdGVyYWwgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogYWJjICopXG4gICAgICBzdHJpbmcgKiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBDaGFyX2xpdGVyYWwgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiB4ICopXG4gICAgICBjaGFyICogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG5cbiAgfCBGb3JtYXRfYXJnIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAley4uLiV9ICopXG4gICAgICBwYWRfb3B0aW9uICogKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZtdHR5ICpcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmb3JtYXQ2IC0+ICdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IEZvcm1hdF9zdWJzdCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICUoLi4uJSkgKilcbiAgICAgIHBhZF9vcHRpb24gKlxuICAgICAgKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wsXG4gICAgICAgJ2cyLCAnYiwgJ2MsICdqMiwgJ2QsICdhKSBmbXR0eV9yZWwgKlxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgKCgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmb3JtYXQ2IC0+ICdnMiwgJ2IsICdjLCAnajIsICdlLCAnZikgZm10XG5cbiAgKCogUHJpbnRmIGFuZCBGb3JtYXQgc3BlY2lmaWMgY29uc3RydWN0b3IuICopXG4gIHwgQWxwaGEgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJWEgKilcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCgnYiAtPiAneCAtPiAnYykgLT4gJ3ggLT4gJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgVGhldGEgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJXQgKilcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCgnYiAtPiAnYykgLT4gJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG5cbiAgKCogRm9ybWF0IHNwZWNpZmljIGNvbnN0cnVjdG9yOiAqKVxuICB8IEZvcm1hdHRpbmdfbGl0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEBfICopXG4gICAgICBmb3JtYXR0aW5nX2xpdCAqICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IEZvcm1hdHRpbmdfZ2VuIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBAXyAqKVxuICAgICAgKCdhMSwgJ2IsICdjLCAnZDEsICdlMSwgJ2YxKSBmb3JtYXR0aW5nX2dlbiAqXG4gICAgICAoJ2YxLCAnYiwgJ2MsICdlMSwgJ2UyLCAnZjIpIGZtdCAtPiAoJ2ExLCAnYiwgJ2MsICdkMSwgJ2UyLCAnZjIpIGZtdFxuXG4gICgqIFNjYW5mIHNwZWNpZmljIGNvbnN0cnVjdG9yczogKilcbiAgfCBSZWFkZXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlciAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ3ggLT4gJ2EsICdiLCAnYywgKCdiIC0+ICd4KSAtPiAnZCwgJ2UsICdmKSBmbXRcbiAgfCBTY2FuX2NoYXJfc2V0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlWy4uLl0gKilcbiAgICAgIHBhZF9vcHRpb24gKiBjaGFyX3NldCAqICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKHN0cmluZyAtPiAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBTY2FuX2dldF9jb3VudGVyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlW25sTkxdICopXG4gICAgICBjb3VudGVyICogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoaW50IC0+ICdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IFNjYW5fbmV4dF9jaGFyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICUwYyAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgKGNoYXIgLT4gJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgSWdub3JlZF9wYXJhbSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV8gKilcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ3ksICd4KSBpZ25vcmVkICogKCd4LCAnYiwgJ2MsICd5LCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG5cbiAgKCogQ3VzdG9tIHByaW50aW5nIGZvcm1hdCAoUFIjNjQ1MiwgR1BSIzE0MClcblxuICAgICBXZSBpbmNsdWRlIGEgdHlwZSBDdXN0b20gb2YgXCJjdXN0b20gY29udmVydGVyc1wiLCB3aGVyZSBhblxuICAgICBhcmJpdHJhcnkgZnVuY3Rpb24gY2FuIGJlIHVzZWQgdG8gY29udmVydCBvbmUgb3IgbW9yZVxuICAgICBhcmd1bWVudHMuIFRoZXJlIGlzIG5vIHN5bnRheCBmb3IgY3VzdG9tIGNvbnZlcnRlcnMsIGl0IGlzIG9ubHlcbiAgICAgaW50ZW5kZWQgZm9yIGN1c3RvbSBwcm9jZXNzb3JzIHRoYXQgd2lzaCB0byByZWx5IG9uIHRoZVxuICAgICBzdGRsaWItZGVmaW5lZCBmb3JtYXQgR0FEVHMuXG5cbiAgICAgRm9yIGluc3RhbmNlIGEgcHJlLXByb2Nlc3NvciBjb3VsZCBjaG9vc2UgdG8gaW50ZXJwcmV0IHN0cmluZ3NcbiAgICAgcHJlZml4ZWQgd2l0aCBbXCIhXCJdIGFzIGZvcm1hdCBzdHJpbmdzIHdoZXJlIFsle3sgLi4uIH19XSBpc1xuICAgICBhIHNwZWNpYWwgZm9ybSB0byBwYXNzIGEgdG9fc3RyaW5nIGZ1bmN0aW9uLCBzbyB0aGF0IG9uZSBjb3VsZFxuICAgICB3cml0ZTpcblxuICAgICB7W1xuICAgICAgIHR5cGUgdCA9IHsgeCA6IGludDsgeSA6IGludCB9XG5cbiAgICAgICBsZXQgc3RyaW5nX29mX3QgdCA9IFByaW50Zi5zcHJpbnRmIFwieyB4ID0gJWQ7IHkgPSAlZCB9XCIgdC54IHQueVxuXG4gICAgICAgUHJpbnRmLnByaW50ZiAhXCJ0ID0gJXt7c3RyaW5nX29mX3R9fVwiIHsgeCA9IDQyOyB5ID0gNDIgfVxuICAgICBdfVxuICAqKVxuICB8IEN1c3RvbSA6XG4gICAgICAoJ2EsICd4LCAneSkgY3VzdG9tX2FyaXR5ICogKHVuaXQgLT4gJ3gpICogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgKCd5LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuXG4gICgqIGVuZCBvZiBhIGZvcm1hdCBzcGVjaWZpY2F0aW9uICopXG4gIHwgRW5kX29mX2Zvcm1hdCA6XG4gICAgICAgICgnZiwgJ2IsICdjLCAnZSwgJ2UsICdmKSBmbXRcblxuKCoqKilcblxuKCogVHlwZSBmb3IgaWdub3JlZCBwYXJhbWV0ZXJzIChzZWUgXCIlX1wiKS4gKilcbmFuZCAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgaWdub3JlZCA9XG4gIHwgSWdub3JlZF9jaGFyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9jICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfY2FtbF9jaGFyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfQyAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX3N0cmluZyA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX3MgKilcbiAgICAgIHBhZF9vcHRpb24gLT4gKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX2NhbWxfc3RyaW5nIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX1MgKilcbiAgICAgIHBhZF9vcHRpb24gLT4gKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX2ludCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX2QgKilcbiAgICAgIGludF9jb252ICogcGFkX29wdGlvbiAtPiAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfaW50MzIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfbGQgKilcbiAgICAgIGludF9jb252ICogcGFkX29wdGlvbiAtPiAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfbmF0aXZlaW50IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfbmQgKilcbiAgICAgIGludF9jb252ICogcGFkX29wdGlvbiAtPiAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfaW50NjQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfTGQgKilcbiAgICAgIGludF9jb252ICogcGFkX29wdGlvbiAtPiAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfZmxvYXQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfZiAqKVxuICAgICAgcGFkX29wdGlvbiAqIHByZWNfb3B0aW9uIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9ib29sIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9CICopXG4gICAgICBwYWRfb3B0aW9uIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9mb3JtYXRfYXJnIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV97Li4uJX0gKilcbiAgICAgIHBhZF9vcHRpb24gKiAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm10dHkgLT5cbiAgICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX2Zvcm1hdF9zdWJzdCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlXyguLi4lKSAqKVxuICAgICAgcGFkX29wdGlvbiAqICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXR0eSAtPlxuICAgICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgaWdub3JlZFxuICB8IElnbm9yZWRfcmVhZGVyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfciAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICgnYiAtPiAneCkgLT4gJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfc2Nhbl9jaGFyX3NldCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfWy4uLl0gKilcbiAgICAgIHBhZF9vcHRpb24gKiBjaGFyX3NldCAtPiAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfc2Nhbl9nZXRfY291bnRlciA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfW25sTkxdICopXG4gICAgICBjb3VudGVyIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9zY2FuX25leHRfY2hhciA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV8wYyAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcblxuYW5kICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2ID1cbiAgRm9ybWF0IG9mICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgKiBzdHJpbmdcblxubGV0IHJlYyBlcmFzZV9yZWwgOiB0eXBlIGEgYiBjIGQgZSBmIGcgaCBpIGogayBsIC5cbiAgKGEsIGIsIGMsIGQsIGUsIGYsXG4gICBnLCBoLCBpLCBqLCBrLCBsKSBmbXR0eV9yZWwgLT4gKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5XG49IGZ1bmN0aW9uXG4gIHwgQ2hhcl90eSByZXN0IC0+XG4gICAgQ2hhcl90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgU3RyaW5nX3R5IHJlc3QgLT5cbiAgICBTdHJpbmdfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IEludF90eSByZXN0IC0+XG4gICAgSW50X3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBJbnQzMl90eSByZXN0IC0+XG4gICAgSW50MzJfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IEludDY0X3R5IHJlc3QgLT5cbiAgICBJbnQ2NF90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgTmF0aXZlaW50X3R5IHJlc3QgLT5cbiAgICBOYXRpdmVpbnRfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IEZsb2F0X3R5IHJlc3QgLT5cbiAgICBGbG9hdF90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgQm9vbF90eSByZXN0IC0+XG4gICAgQm9vbF90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgRm9ybWF0X2FyZ190eSAodHksIHJlc3QpIC0+XG4gICAgRm9ybWF0X2FyZ190eSAodHksIGVyYXNlX3JlbCByZXN0KVxuICB8IEZvcm1hdF9zdWJzdF90eSAodHkxLCBfdHkyLCByZXN0KSAtPlxuICAgIEZvcm1hdF9zdWJzdF90eSAodHkxLCB0eTEsIGVyYXNlX3JlbCByZXN0KVxuICB8IEFscGhhX3R5IHJlc3QgLT5cbiAgICBBbHBoYV90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgVGhldGFfdHkgcmVzdCAtPlxuICAgIFRoZXRhX3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBBbnlfdHkgcmVzdCAtPlxuICAgIEFueV90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgUmVhZGVyX3R5IHJlc3QgLT5cbiAgICBSZWFkZXJfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IElnbm9yZWRfcmVhZGVyX3R5IHJlc3QgLT5cbiAgICBJZ25vcmVkX3JlYWRlcl90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgRW5kX29mX2ZtdHR5IC0+IEVuZF9vZl9mbXR0eVxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICgqIEZvcm1hdCB0eXBlIGNvbmNhdGVuYXRpb24gKilcblxuKCogQ29uY2F0ZW5hdGUgdHdvIGZvcm1hdCB0eXBlcy4gKilcbigqIFVzZWQgYnk6XG4gICAqIHJlYWRlcl9uYl91bmlmaWVyX29mX2ZtdHR5IHRvIGNvdW50IHJlYWRlcnMgaW4gYW4gZm10dHksXG4gICAqIFNjYW5mLnRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgdG8gZXh0cmFjdCByZWFkZXJzIGluc2lkZSAlKC4uLiUpLFxuICAgKiBDYW1saW50ZXJuYWxGb3JtYXQuZm10dHlfb2ZfaWdub3JlZF9mb3JtYXQgdG8gZXh0cmFjdCBmb3JtYXQgdHlwZS4gKilcblxuKCpcbmxldCByZWMgY29uY2F0X2ZtdHR5IDogdHlwZSBhIGIgYyBkIGUgZiBnIGggLlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSAtPlxuICAgIChmLCBiLCBjLCBlLCBnLCBoKSBmbXR0eSAtPlxuICAgIChhLCBiLCBjLCBkLCBnLCBoKSBmbXR0eSA9XG4qKVxubGV0IHJlYyBjb25jYXRfZm10dHkgOlxuICB0eXBlIGExIGIxIGMxIGQxIGUxIGYxXG4gICAgICAgYTIgYjIgYzIgZDIgZTIgZjJcbiAgICAgICBnMSBqMSBnMiBqMlxuICAuXG4gICAgKGcxLCBiMSwgYzEsIGoxLCBkMSwgYTEsXG4gICAgIGcyLCBiMiwgYzIsIGoyLCBkMiwgYTIpIGZtdHR5X3JlbCAtPlxuICAgIChhMSwgYjEsIGMxLCBkMSwgZTEsIGYxLFxuICAgICBhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXR0eV9yZWwgLT5cbiAgICAoZzEsIGIxLCBjMSwgajEsIGUxLCBmMSxcbiAgICAgZzIsIGIyLCBjMiwgajIsIGUyLCBmMikgZm10dHlfcmVsID1cbmZ1biBmbXR0eTEgZm10dHkyIC0+IG1hdGNoIGZtdHR5MSB3aXRoXG4gIHwgQ2hhcl90eSByZXN0IC0+XG4gICAgQ2hhcl90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IFN0cmluZ190eSByZXN0IC0+XG4gICAgU3RyaW5nX3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgSW50X3R5IHJlc3QgLT5cbiAgICBJbnRfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBJbnQzMl90eSByZXN0IC0+XG4gICAgSW50MzJfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBOYXRpdmVpbnRfdHkgcmVzdCAtPlxuICAgIE5hdGl2ZWludF90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IEludDY0X3R5IHJlc3QgLT5cbiAgICBJbnQ2NF90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IEZsb2F0X3R5IHJlc3QgLT5cbiAgICBGbG9hdF90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IEJvb2xfdHkgcmVzdCAtPlxuICAgIEJvb2xfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBBbHBoYV90eSByZXN0IC0+XG4gICAgQWxwaGFfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBUaGV0YV90eSByZXN0IC0+XG4gICAgVGhldGFfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBBbnlfdHkgcmVzdCAtPlxuICAgIEFueV90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IFJlYWRlcl90eSByZXN0IC0+XG4gICAgUmVhZGVyX3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgcmVzdCAtPlxuICAgIElnbm9yZWRfcmVhZGVyX3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgRm9ybWF0X2FyZ190eSAodHksIHJlc3QpIC0+XG4gICAgRm9ybWF0X2FyZ190eSAodHksIGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBGb3JtYXRfc3Vic3RfdHkgKHR5MSwgdHkyLCByZXN0KSAtPlxuICAgIEZvcm1hdF9zdWJzdF90eSAodHkxLCB0eTIsIGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBFbmRfb2ZfZm10dHkgLT4gZm10dHkyXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBGb3JtYXQgY29uY2F0ZW5hdGlvbiAqKVxuXG4oKiBDb25jYXRlbmF0ZSB0d28gZm9ybWF0cy4gKilcbmxldCByZWMgY29uY2F0X2ZtdCA6IHR5cGUgYSBiIGMgZCBlIGYgZyBoIC5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+XG4gICAgKGYsIGIsIGMsIGUsIGcsIGgpIGZtdCAtPlxuICAgIChhLCBiLCBjLCBkLCBnLCBoKSBmbXQgPVxuZnVuIGZtdDEgZm10MiAtPiBtYXRjaCBmbXQxIHdpdGhcbiAgfCBTdHJpbmcgKHBhZCwgcmVzdCkgLT5cbiAgICBTdHJpbmcgKHBhZCwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgQ2FtbF9zdHJpbmcgKHBhZCwgcmVzdCkgLT5cbiAgICBDYW1sX3N0cmluZyAocGFkLCBjb25jYXRfZm10IHJlc3QgZm10MilcblxuICB8IEludCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBJbnQgKGljb252LCBwYWQsIHByZWMsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IEludDMyIChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIEludDMyIChpY29udiwgcGFkLCBwcmVjLCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBOYXRpdmVpbnQgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgTmF0aXZlaW50IChpY29udiwgcGFkLCBwcmVjLCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBJbnQ2NCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBJbnQ2NCAoaWNvbnYsIHBhZCwgcHJlYywgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgRmxvYXQgKGZjb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgRmxvYXQgKGZjb252LCBwYWQsIHByZWMsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuXG4gIHwgQ2hhciAocmVzdCkgLT5cbiAgICBDaGFyIChjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBDYW1sX2NoYXIgcmVzdCAtPlxuICAgIENhbWxfY2hhciAoY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgQm9vbCAocGFkLCByZXN0KSAtPlxuICAgIEJvb2wgKHBhZCwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgQWxwaGEgcmVzdCAtPlxuICAgIEFscGhhIChjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBUaGV0YSByZXN0IC0+XG4gICAgVGhldGEgKGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IEN1c3RvbSAoYXJpdHksIGYsIHJlc3QpIC0+XG4gICAgQ3VzdG9tIChhcml0eSwgZiwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgUmVhZGVyIHJlc3QgLT5cbiAgICBSZWFkZXIgKGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IEZsdXNoIHJlc3QgLT5cbiAgICBGbHVzaCAoY29uY2F0X2ZtdCByZXN0IGZtdDIpXG5cbiAgfCBTdHJpbmdfbGl0ZXJhbCAoc3RyLCByZXN0KSAtPlxuICAgIFN0cmluZ19saXRlcmFsIChzdHIsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IENoYXJfbGl0ZXJhbCAoY2hyLCByZXN0KSAtPlxuICAgIENoYXJfbGl0ZXJhbCAgIChjaHIsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuXG4gIHwgRm9ybWF0X2FyZyAocGFkLCBmbXR0eSwgcmVzdCkgLT5cbiAgICBGb3JtYXRfYXJnICAgKHBhZCwgZm10dHksIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IEZvcm1hdF9zdWJzdCAocGFkLCBmbXR0eSwgcmVzdCkgLT5cbiAgICBGb3JtYXRfc3Vic3QgKHBhZCwgZm10dHksIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuXG4gIHwgU2Nhbl9jaGFyX3NldCAod2lkdGhfb3B0LCBjaGFyX3NldCwgcmVzdCkgLT5cbiAgICBTY2FuX2NoYXJfc2V0ICh3aWR0aF9vcHQsIGNoYXJfc2V0LCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBTY2FuX2dldF9jb3VudGVyIChjb3VudGVyLCByZXN0KSAtPlxuICAgIFNjYW5fZ2V0X2NvdW50ZXIgKGNvdW50ZXIsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IFNjYW5fbmV4dF9jaGFyIChyZXN0KSAtPlxuICAgIFNjYW5fbmV4dF9jaGFyIChjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBJZ25vcmVkX3BhcmFtIChpZ24sIHJlc3QpIC0+XG4gICAgSWdub3JlZF9wYXJhbSAoaWduLCBjb25jYXRfZm10IHJlc3QgZm10MilcblxuICB8IEZvcm1hdHRpbmdfbGl0IChmbXRpbmdfbGl0LCByZXN0KSAtPlxuICAgIEZvcm1hdHRpbmdfbGl0IChmbXRpbmdfbGl0LCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBGb3JtYXR0aW5nX2dlbiAoZm10aW5nX2dlbiwgcmVzdCkgLT5cbiAgICBGb3JtYXR0aW5nX2dlbiAoZm10aW5nX2dlbiwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG5cbiAgfCBFbmRfb2ZfZm9ybWF0IC0+XG4gICAgZm10MlxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgR2FicmllbCBTY2hlcmVyLCBwcm9qZXQgUGFydG91dCwgSU5SSUEgUGFyaXMtU2FjbGF5ICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAyMCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBDYW1saW50ZXJuYWxBdG9taWMgaXMgYSBkZXBlbmRlbmN5IG9mIFN0ZGxpYiwgc28gaXQgaXMgY29tcGlsZWQgd2l0aFxuICAgLW5vcGVydmFzaXZlcy4gKilcbmV4dGVybmFsICggPT0gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVlcVwiXG5leHRlcm5hbCAoICsgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlYWRkaW50XCJcbmV4dGVybmFsIGlnbm9yZSA6ICdhIC0+IHVuaXQgPSBcIiVpZ25vcmVcIlxuXG4oKiBXZSBhcmUgbm90IHJldXNpbmcgKCdhIHJlZikgZGlyZWN0bHkgdG8gbWFrZSBpdCBlYXNpZXIgdG8gcmVhc29uXG4gICBhYm91dCBhdG9taWNpdHkgaWYgd2Ugd2lzaCB0bzogZXZlbiBpbiBhIHNlcXVlbnRpYWwgaW1wbGVtZW50YXRpb24sXG4gICBzaWduYWxzIGFuZCBvdGhlciBhc3luY2hyb25vdXMgY2FsbGJhY2tzIG1pZ2h0IGJyZWFrIGF0b21pY2l0eS4gKilcbnR5cGUgJ2EgdCA9IHttdXRhYmxlIHY6ICdhfVxuXG5sZXQgbWFrZSB2ID0ge3Z9XG5sZXQgZ2V0IHIgPSByLnZcbmxldCBzZXQgciB2ID0gci52IDwtIHZcblxuKCogVGhlIGZvbGxvd2luZyBmdW5jdGlvbnMgYXJlIHNldCB0byBuZXZlciBiZSBpbmxpbmVkOiBGbGFtYmRhIGlzXG4gICBhbGxvd2VkIHRvIG1vdmUgc3Vycm91bmRpbmcgY29kZSBpbnNpZGUgdGhlIGNyaXRpY2FsIHNlY3Rpb24sXG4gICBpbmNsdWRpbmcgYWxsb2NhdGlvbnMuICopXG5cbmxldFtAaW5saW5lIG5ldmVyXSBleGNoYW5nZSByIHYgPVxuICAoKiBCRUdJTiBBVE9NSUMgKilcbiAgbGV0IGN1ciA9IHIudiBpblxuICByLnYgPC0gdjtcbiAgKCogRU5EIEFUT01JQyAqKVxuICBjdXJcblxubGV0W0BpbmxpbmUgbmV2ZXJdIGNvbXBhcmVfYW5kX3NldCByIHNlZW4gdiA9XG4gICgqIEJFR0lOIEFUT01JQyAqKVxuICBsZXQgY3VyID0gci52IGluXG4gIGlmIGN1ciA9PSBzZWVuIHRoZW4gKFxuICAgIHIudiA8LSB2O1xuICAgICgqIEVORCBBVE9NSUMgKilcbiAgICB0cnVlXG4gICkgZWxzZVxuICAgIGZhbHNlXG5cbmxldFtAaW5saW5lIG5ldmVyXSBmZXRjaF9hbmRfYWRkIHIgbiA9XG4gICgqIEJFR0lOIEFUT01JQyAqKVxuICBsZXQgY3VyID0gci52IGluXG4gIHIudiA8LSAoY3VyICsgbik7XG4gICgqIEVORCBBVE9NSUMgKilcbiAgY3VyXG5cbmxldCBpbmNyIHIgPSBpZ25vcmUgKGZldGNoX2FuZF9hZGQgciAxKVxubGV0IGRlY3IgciA9IGlnbm9yZSAoZmV0Y2hfYW5kX2FkZCByICgtMSkpXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIEV4Y2VwdGlvbnMgKilcblxuZXh0ZXJuYWwgcmVnaXN0ZXJfbmFtZWRfdmFsdWUgOiBzdHJpbmcgLT4gJ2EgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfcmVnaXN0ZXJfbmFtZWRfdmFsdWVcIlxuXG5sZXQgKCkgPVxuICAoKiBmb3IgcnVudGltZS9mYWlsX25hdC5jICopXG4gIHJlZ2lzdGVyX25hbWVkX3ZhbHVlIFwiUGVydmFzaXZlcy5hcnJheV9ib3VuZF9lcnJvclwiXG4gICAgKEludmFsaWRfYXJndW1lbnQgXCJpbmRleCBvdXQgb2YgYm91bmRzXCIpXG5cbmV4dGVybmFsIHJhaXNlIDogZXhuIC0+ICdhID0gXCIlcmFpc2VcIlxuZXh0ZXJuYWwgcmFpc2Vfbm90cmFjZSA6IGV4biAtPiAnYSA9IFwiJXJhaXNlX25vdHJhY2VcIlxuXG5sZXQgZmFpbHdpdGggcyA9IHJhaXNlKEZhaWx1cmUgcylcbmxldCBpbnZhbGlkX2FyZyBzID0gcmFpc2UoSW52YWxpZF9hcmd1bWVudCBzKVxuXG5leGNlcHRpb24gRXhpdFxuZXhjZXB0aW9uIE1hdGNoX2ZhaWx1cmUgPSBNYXRjaF9mYWlsdXJlXG5leGNlcHRpb24gQXNzZXJ0X2ZhaWx1cmUgPSBBc3NlcnRfZmFpbHVyZVxuZXhjZXB0aW9uIEludmFsaWRfYXJndW1lbnQgPSBJbnZhbGlkX2FyZ3VtZW50XG5leGNlcHRpb24gRmFpbHVyZSA9IEZhaWx1cmVcbmV4Y2VwdGlvbiBOb3RfZm91bmQgPSBOb3RfZm91bmRcbmV4Y2VwdGlvbiBPdXRfb2ZfbWVtb3J5ID0gT3V0X29mX21lbW9yeVxuZXhjZXB0aW9uIFN0YWNrX292ZXJmbG93ID0gU3RhY2tfb3ZlcmZsb3dcbmV4Y2VwdGlvbiBTeXNfZXJyb3IgPSBTeXNfZXJyb3JcbmV4Y2VwdGlvbiBFbmRfb2ZfZmlsZSA9IEVuZF9vZl9maWxlXG5leGNlcHRpb24gRGl2aXNpb25fYnlfemVybyA9IERpdmlzaW9uX2J5X3plcm9cbmV4Y2VwdGlvbiBTeXNfYmxvY2tlZF9pbyA9IFN5c19ibG9ja2VkX2lvXG5leGNlcHRpb24gVW5kZWZpbmVkX3JlY3Vyc2l2ZV9tb2R1bGUgPSBVbmRlZmluZWRfcmVjdXJzaXZlX21vZHVsZVxuXG4oKiBDb21wb3NpdGlvbiBvcGVyYXRvcnMgKilcblxuZXh0ZXJuYWwgKCB8PiApIDogJ2EgLT4gKCdhIC0+ICdiKSAtPiAnYiA9IFwiJXJldmFwcGx5XCJcbmV4dGVybmFsICggQEAgKSA6ICgnYSAtPiAnYikgLT4gJ2EgLT4gJ2IgPSBcIiVhcHBseVwiXG5cbigqIERlYnVnZ2luZyAqKVxuXG5leHRlcm5hbCBfX0xPQ19fIDogc3RyaW5nID0gXCIlbG9jX0xPQ1wiXG5leHRlcm5hbCBfX0ZJTEVfXyA6IHN0cmluZyA9IFwiJWxvY19GSUxFXCJcbmV4dGVybmFsIF9fTElORV9fIDogaW50ID0gXCIlbG9jX0xJTkVcIlxuZXh0ZXJuYWwgX19NT0RVTEVfXyA6IHN0cmluZyA9IFwiJWxvY19NT0RVTEVcIlxuZXh0ZXJuYWwgX19QT1NfXyA6IHN0cmluZyAqIGludCAqIGludCAqIGludCA9IFwiJWxvY19QT1NcIlxuZXh0ZXJuYWwgX19GVU5DVElPTl9fIDogc3RyaW5nID0gXCIlbG9jX0ZVTkNUSU9OXCJcblxuZXh0ZXJuYWwgX19MT0NfT0ZfXyA6ICdhIC0+IHN0cmluZyAqICdhID0gXCIlbG9jX0xPQ1wiXG5leHRlcm5hbCBfX0xJTkVfT0ZfXyA6ICdhIC0+IGludCAqICdhID0gXCIlbG9jX0xJTkVcIlxuZXh0ZXJuYWwgX19QT1NfT0ZfXyA6ICdhIC0+IChzdHJpbmcgKiBpbnQgKiBpbnQgKiBpbnQpICogJ2EgPSBcIiVsb2NfUE9TXCJcblxuKCogQ29tcGFyaXNvbnMgKilcblxuZXh0ZXJuYWwgKCA9ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlZXF1YWxcIlxuZXh0ZXJuYWwgKCA8PiApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJW5vdGVxdWFsXCJcbmV4dGVybmFsICggPCApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWxlc3N0aGFuXCJcbmV4dGVybmFsICggPiApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWdyZWF0ZXJ0aGFuXCJcbmV4dGVybmFsICggPD0gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVsZXNzZXF1YWxcIlxuZXh0ZXJuYWwgKCA+PSApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWdyZWF0ZXJlcXVhbFwiXG5leHRlcm5hbCBjb21wYXJlIDogJ2EgLT4gJ2EgLT4gaW50ID0gXCIlY29tcGFyZVwiXG5cbmxldCBtaW4geCB5ID0gaWYgeCA8PSB5IHRoZW4geCBlbHNlIHlcbmxldCBtYXggeCB5ID0gaWYgeCA+PSB5IHRoZW4geCBlbHNlIHlcblxuZXh0ZXJuYWwgKCA9PSApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWVxXCJcbmV4dGVybmFsICggIT0gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVub3RlcVwiXG5cbigqIEJvb2xlYW4gb3BlcmF0aW9ucyAqKVxuXG5leHRlcm5hbCBub3QgOiBib29sIC0+IGJvb2wgPSBcIiVib29sbm90XCJcbmV4dGVybmFsICggJiApIDogYm9vbCAtPiBib29sIC0+IGJvb2wgPSBcIiVzZXF1YW5kXCJcbmV4dGVybmFsICggJiYgKSA6IGJvb2wgLT4gYm9vbCAtPiBib29sID0gXCIlc2VxdWFuZFwiXG5leHRlcm5hbCAoIG9yICkgOiBib29sIC0+IGJvb2wgLT4gYm9vbCA9IFwiJXNlcXVvclwiXG5leHRlcm5hbCAoIHx8ICkgOiBib29sIC0+IGJvb2wgLT4gYm9vbCA9IFwiJXNlcXVvclwiXG5cbigqIEludGVnZXIgb3BlcmF0aW9ucyAqKVxuXG5leHRlcm5hbCAoIH4tICkgOiBpbnQgLT4gaW50ID0gXCIlbmVnaW50XCJcbmV4dGVybmFsICggfisgKSA6IGludCAtPiBpbnQgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCBzdWNjIDogaW50IC0+IGludCA9IFwiJXN1Y2NpbnRcIlxuZXh0ZXJuYWwgcHJlZCA6IGludCAtPiBpbnQgPSBcIiVwcmVkaW50XCJcbmV4dGVybmFsICggKyApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVhZGRpbnRcIlxuZXh0ZXJuYWwgKCAtICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJXN1YmludFwiXG5leHRlcm5hbCAoICogKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlbXVsaW50XCJcbmV4dGVybmFsICggLyApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVkaXZpbnRcIlxuZXh0ZXJuYWwgKCBtb2QgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlbW9kaW50XCJcblxubGV0IGFicyB4ID0gaWYgeCA+PSAwIHRoZW4geCBlbHNlIC14XG5cbmV4dGVybmFsICggbGFuZCApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVhbmRpbnRcIlxuZXh0ZXJuYWwgKCBsb3IgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlb3JpbnRcIlxuZXh0ZXJuYWwgKCBseG9yICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJXhvcmludFwiXG5cbmxldCBsbm90IHggPSB4IGx4b3IgKC0xKVxuXG5leHRlcm5hbCAoIGxzbCApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVsc2xpbnRcIlxuZXh0ZXJuYWwgKCBsc3IgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlbHNyaW50XCJcbmV4dGVybmFsICggYXNyICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWFzcmludFwiXG5cbmxldCBtYXhfaW50ID0gKC0xKSBsc3IgMVxubGV0IG1pbl9pbnQgPSBtYXhfaW50ICsgMVxuXG4oKiBGbG9hdGluZy1wb2ludCBvcGVyYXRpb25zICopXG5cbmV4dGVybmFsICggfi0uICkgOiBmbG9hdCAtPiBmbG9hdCA9IFwiJW5lZ2Zsb2F0XCJcbmV4dGVybmFsICggfisuICkgOiBmbG9hdCAtPiBmbG9hdCA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsICggKy4gKSA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCIlYWRkZmxvYXRcIlxuZXh0ZXJuYWwgKCAtLiApIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcIiVzdWJmbG9hdFwiXG5leHRlcm5hbCAoICouICkgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiJW11bGZsb2F0XCJcbmV4dGVybmFsICggLy4gKSA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCIlZGl2ZmxvYXRcIlxuZXh0ZXJuYWwgKCAqKiApIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfcG93ZXJfZmxvYXRcIiBcInBvd1wiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBleHAgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9leHBfZmxvYXRcIiBcImV4cFwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBleHBtMSA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2V4cG0xX2Zsb2F0XCIgXCJjYW1sX2V4cG0xXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGFjb3MgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hY29zX2Zsb2F0XCIgXCJhY29zXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGFzaW4gOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hc2luX2Zsb2F0XCIgXCJhc2luXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGF0YW4gOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hdGFuX2Zsb2F0XCIgXCJhdGFuXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGF0YW4yIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYXRhbjJfZmxvYXRcIiBcImF0YW4yXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGh5cG90IDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXRcbiAgICAgICAgICAgICAgID0gXCJjYW1sX2h5cG90X2Zsb2F0XCIgXCJjYW1sX2h5cG90XCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGNvcyA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Nvc19mbG9hdFwiIFwiY29zXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGNvc2ggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9jb3NoX2Zsb2F0XCIgXCJjb3NoXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGFjb3NoIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYWNvc2hfZmxvYXRcIiBcImNhbWxfYWNvc2hcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgbG9nIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfbG9nX2Zsb2F0XCIgXCJsb2dcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgbG9nMTAgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9sb2cxMF9mbG9hdFwiIFwibG9nMTBcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgbG9nMXAgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9sb2cxcF9mbG9hdFwiIFwiY2FtbF9sb2cxcFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBzaW4gOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9zaW5fZmxvYXRcIiBcInNpblwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBzaW5oIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfc2luaF9mbG9hdFwiIFwic2luaFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBhc2luaCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2FzaW5oX2Zsb2F0XCIgXCJjYW1sX2FzaW5oXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHNxcnQgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9zcXJ0X2Zsb2F0XCIgXCJzcXJ0XCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHRhbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3Rhbl9mbG9hdFwiIFwidGFuXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHRhbmggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF90YW5oX2Zsb2F0XCIgXCJ0YW5oXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGF0YW5oIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYXRhbmhfZmxvYXRcIiBcImNhbWxfYXRhbmhcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgY2VpbCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2NlaWxfZmxvYXRcIiBcImNlaWxcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZmxvb3IgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9mbG9vcl9mbG9hdFwiIFwiZmxvb3JcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYWJzX2Zsb2F0IDogZmxvYXQgLT4gZmxvYXQgPSBcIiVhYnNmbG9hdFwiXG5leHRlcm5hbCBjb3B5c2lnbiA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0XG4gICAgICAgICAgICAgICAgICA9IFwiY2FtbF9jb3B5c2lnbl9mbG9hdFwiIFwiY2FtbF9jb3B5c2lnblwiXG4gICAgICAgICAgICAgICAgICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgbW9kX2Zsb2F0IDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfZm1vZF9mbG9hdFwiIFwiZm1vZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBmcmV4cCA6IGZsb2F0IC0+IGZsb2F0ICogaW50ID0gXCJjYW1sX2ZyZXhwX2Zsb2F0XCJcbmV4dGVybmFsIGxkZXhwIDogKGZsb2F0IFtAdW5ib3hlZF0pIC0+IChpbnQgW0B1bnRhZ2dlZF0pIC0+IChmbG9hdCBbQHVuYm94ZWRdKSA9XG4gIFwiY2FtbF9sZGV4cF9mbG9hdFwiIFwiY2FtbF9sZGV4cF9mbG9hdF91bmJveGVkXCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIG1vZGYgOiBmbG9hdCAtPiBmbG9hdCAqIGZsb2F0ID0gXCJjYW1sX21vZGZfZmxvYXRcIlxuZXh0ZXJuYWwgZmxvYXQgOiBpbnQgLT4gZmxvYXQgPSBcIiVmbG9hdG9maW50XCJcbmV4dGVybmFsIGZsb2F0X29mX2ludCA6IGludCAtPiBmbG9hdCA9IFwiJWZsb2F0b2ZpbnRcIlxuZXh0ZXJuYWwgdHJ1bmNhdGUgOiBmbG9hdCAtPiBpbnQgPSBcIiVpbnRvZmZsb2F0XCJcbmV4dGVybmFsIGludF9vZl9mbG9hdCA6IGZsb2F0IC0+IGludCA9IFwiJWludG9mZmxvYXRcIlxuZXh0ZXJuYWwgZmxvYXRfb2ZfYml0cyA6IGludDY0IC0+IGZsb2F0XG4gID0gXCJjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHNcIiBcImNhbWxfaW50NjRfZmxvYXRfb2ZfYml0c191bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmxldCBpbmZpbml0eSA9XG4gIGZsb2F0X29mX2JpdHMgMHg3Rl9GMF8wMF8wMF8wMF8wMF8wMF8wMExcbmxldCBuZWdfaW5maW5pdHkgPVxuICBmbG9hdF9vZl9iaXRzIDB4RkZfRjBfMDBfMDBfMDBfMDBfMDBfMDBMXG5sZXQgbmFuID1cbiAgZmxvYXRfb2ZfYml0cyAweDdGX0YwXzAwXzAwXzAwXzAwXzAwXzAxTFxubGV0IG1heF9mbG9hdCA9XG4gIGZsb2F0X29mX2JpdHMgMHg3Rl9FRl9GRl9GRl9GRl9GRl9GRl9GRkxcbmxldCBtaW5fZmxvYXQgPVxuICBmbG9hdF9vZl9iaXRzIDB4MDBfMTBfMDBfMDBfMDBfMDBfMDBfMDBMXG5sZXQgZXBzaWxvbl9mbG9hdCA9XG4gIGZsb2F0X29mX2JpdHMgMHgzQ19CMF8wMF8wMF8wMF8wMF8wMF8wMExcblxudHlwZSBmcGNsYXNzID1cbiAgICBGUF9ub3JtYWxcbiAgfCBGUF9zdWJub3JtYWxcbiAgfCBGUF96ZXJvXG4gIHwgRlBfaW5maW5pdGVcbiAgfCBGUF9uYW5cbmV4dGVybmFsIGNsYXNzaWZ5X2Zsb2F0IDogKGZsb2F0IFtAdW5ib3hlZF0pIC0+IGZwY2xhc3MgPVxuICBcImNhbWxfY2xhc3NpZnlfZmxvYXRcIiBcImNhbWxfY2xhc3NpZnlfZmxvYXRfdW5ib3hlZFwiIFtAQG5vYWxsb2NdXG5cbigqIFN0cmluZyBhbmQgYnl0ZSBzZXF1ZW5jZSBvcGVyYXRpb25zIC0tIG1vcmUgaW4gbW9kdWxlcyBTdHJpbmcgYW5kIEJ5dGVzICopXG5cbmV4dGVybmFsIHN0cmluZ19sZW5ndGggOiBzdHJpbmcgLT4gaW50ID0gXCIlc3RyaW5nX2xlbmd0aFwiXG5leHRlcm5hbCBieXRlc19sZW5ndGggOiBieXRlcyAtPiBpbnQgPSBcIiVieXRlc19sZW5ndGhcIlxuZXh0ZXJuYWwgYnl0ZXNfY3JlYXRlIDogaW50IC0+IGJ5dGVzID0gXCJjYW1sX2NyZWF0ZV9ieXRlc1wiXG5leHRlcm5hbCBzdHJpbmdfYmxpdCA6IHN0cmluZyAtPiBpbnQgLT4gYnl0ZXMgLT4gaW50IC0+IGludCAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9ibGl0X3N0cmluZ1wiIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBieXRlc19ibGl0IDogYnl0ZXMgLT4gaW50IC0+IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfYmxpdF9ieXRlc1wiIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBieXRlc191bnNhZmVfdG9fc3RyaW5nIDogYnl0ZXMgLT4gc3RyaW5nID0gXCIlYnl0ZXNfdG9fc3RyaW5nXCJcblxubGV0ICggXiApIHMxIHMyID1cbiAgbGV0IGwxID0gc3RyaW5nX2xlbmd0aCBzMSBhbmQgbDIgPSBzdHJpbmdfbGVuZ3RoIHMyIGluXG4gIGxldCBzID0gYnl0ZXNfY3JlYXRlIChsMSArIGwyKSBpblxuICBzdHJpbmdfYmxpdCBzMSAwIHMgMCBsMTtcbiAgc3RyaW5nX2JsaXQgczIgMCBzIGwxIGwyO1xuICBieXRlc191bnNhZmVfdG9fc3RyaW5nIHNcblxuKCogQ2hhcmFjdGVyIG9wZXJhdGlvbnMgLS0gbW9yZSBpbiBtb2R1bGUgQ2hhciAqKVxuXG5leHRlcm5hbCBpbnRfb2ZfY2hhciA6IGNoYXIgLT4gaW50ID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgdW5zYWZlX2NoYXJfb2ZfaW50IDogaW50IC0+IGNoYXIgPSBcIiVpZGVudGl0eVwiXG5sZXQgY2hhcl9vZl9pbnQgbiA9XG4gIGlmIG4gPCAwIHx8IG4gPiAyNTUgdGhlbiBpbnZhbGlkX2FyZyBcImNoYXJfb2ZfaW50XCIgZWxzZSB1bnNhZmVfY2hhcl9vZl9pbnQgblxuXG4oKiBVbml0IG9wZXJhdGlvbnMgKilcblxuZXh0ZXJuYWwgaWdub3JlIDogJ2EgLT4gdW5pdCA9IFwiJWlnbm9yZVwiXG5cbigqIFBhaXIgb3BlcmF0aW9ucyAqKVxuXG5leHRlcm5hbCBmc3QgOiAnYSAqICdiIC0+ICdhID0gXCIlZmllbGQwXCJcbmV4dGVybmFsIHNuZCA6ICdhICogJ2IgLT4gJ2IgPSBcIiVmaWVsZDFcIlxuXG4oKiBSZWZlcmVuY2VzICopXG5cbnR5cGUgJ2EgcmVmID0geyBtdXRhYmxlIGNvbnRlbnRzIDogJ2EgfVxuZXh0ZXJuYWwgcmVmIDogJ2EgLT4gJ2EgcmVmID0gXCIlbWFrZW11dGFibGVcIlxuZXh0ZXJuYWwgKCAhICkgOiAnYSByZWYgLT4gJ2EgPSBcIiVmaWVsZDBcIlxuZXh0ZXJuYWwgKCA6PSApIDogJ2EgcmVmIC0+ICdhIC0+IHVuaXQgPSBcIiVzZXRmaWVsZDBcIlxuZXh0ZXJuYWwgaW5jciA6IGludCByZWYgLT4gdW5pdCA9IFwiJWluY3JcIlxuZXh0ZXJuYWwgZGVjciA6IGludCByZWYgLT4gdW5pdCA9IFwiJWRlY3JcIlxuXG4oKiBSZXN1bHQgdHlwZSAqKVxuXG50eXBlICgnYSwnYikgcmVzdWx0ID0gT2sgb2YgJ2EgfCBFcnJvciBvZiAnYlxuXG4oKiBTdHJpbmcgY29udmVyc2lvbiBmdW5jdGlvbnMgKilcblxuZXh0ZXJuYWwgZm9ybWF0X2ludCA6IHN0cmluZyAtPiBpbnQgLT4gc3RyaW5nID0gXCJjYW1sX2Zvcm1hdF9pbnRcIlxuZXh0ZXJuYWwgZm9ybWF0X2Zsb2F0IDogc3RyaW5nIC0+IGZsb2F0IC0+IHN0cmluZyA9IFwiY2FtbF9mb3JtYXRfZmxvYXRcIlxuXG5sZXQgc3RyaW5nX29mX2Jvb2wgYiA9XG4gIGlmIGIgdGhlbiBcInRydWVcIiBlbHNlIFwiZmFsc2VcIlxubGV0IGJvb2xfb2Zfc3RyaW5nID0gZnVuY3Rpb25cbiAgfCBcInRydWVcIiAtPiB0cnVlXG4gIHwgXCJmYWxzZVwiIC0+IGZhbHNlXG4gIHwgXyAtPiBpbnZhbGlkX2FyZyBcImJvb2xfb2Zfc3RyaW5nXCJcblxubGV0IGJvb2xfb2Zfc3RyaW5nX29wdCA9IGZ1bmN0aW9uXG4gIHwgXCJ0cnVlXCIgLT4gU29tZSB0cnVlXG4gIHwgXCJmYWxzZVwiIC0+IFNvbWUgZmFsc2VcbiAgfCBfIC0+IE5vbmVcblxubGV0IHN0cmluZ19vZl9pbnQgbiA9XG4gIGZvcm1hdF9pbnQgXCIlZFwiIG5cblxuZXh0ZXJuYWwgaW50X29mX3N0cmluZyA6IHN0cmluZyAtPiBpbnQgPSBcImNhbWxfaW50X29mX3N0cmluZ1wiXG5cbmxldCBpbnRfb2Zfc3RyaW5nX29wdCBzID1cbiAgKCogVE9ETzogcHJvdmlkZSB0aGlzIGRpcmVjdGx5IGFzIGEgbm9uLXJhaXNpbmcgcHJpbWl0aXZlLiAqKVxuICB0cnkgU29tZSAoaW50X29mX3N0cmluZyBzKVxuICB3aXRoIEZhaWx1cmUgXyAtPiBOb25lXG5cbmV4dGVybmFsIHN0cmluZ19nZXQgOiBzdHJpbmcgLT4gaW50IC0+IGNoYXIgPSBcIiVzdHJpbmdfc2FmZV9nZXRcIlxuXG5sZXQgdmFsaWRfZmxvYXRfbGV4ZW0gcyA9XG4gIGxldCBsID0gc3RyaW5nX2xlbmd0aCBzIGluXG4gIGxldCByZWMgbG9vcCBpID1cbiAgICBpZiBpID49IGwgdGhlbiBzIF4gXCIuXCIgZWxzZVxuICAgIG1hdGNoIHN0cmluZ19nZXQgcyBpIHdpdGhcbiAgICB8ICcwJyAuLiAnOScgfCAnLScgLT4gbG9vcCAoaSArIDEpXG4gICAgfCBfIC0+IHNcbiAgaW5cbiAgbG9vcCAwXG5cbmxldCBzdHJpbmdfb2ZfZmxvYXQgZiA9IHZhbGlkX2Zsb2F0X2xleGVtIChmb3JtYXRfZmxvYXQgXCIlLjEyZ1wiIGYpXG5cbmV4dGVybmFsIGZsb2F0X29mX3N0cmluZyA6IHN0cmluZyAtPiBmbG9hdCA9IFwiY2FtbF9mbG9hdF9vZl9zdHJpbmdcIlxuXG5sZXQgZmxvYXRfb2Zfc3RyaW5nX29wdCBzID1cbiAgKCogVE9ETzogcHJvdmlkZSB0aGlzIGRpcmVjdGx5IGFzIGEgbm9uLXJhaXNpbmcgcHJpbWl0aXZlLiAqKVxuICB0cnkgU29tZSAoZmxvYXRfb2Zfc3RyaW5nIHMpXG4gIHdpdGggRmFpbHVyZSBfIC0+IE5vbmVcblxuKCogTGlzdCBvcGVyYXRpb25zIC0tIG1vcmUgaW4gbW9kdWxlIExpc3QgKilcblxubGV0IHJlYyAoIEAgKSBsMSBsMiA9XG4gIG1hdGNoIGwxIHdpdGhcbiAgICBbXSAtPiBsMlxuICB8IGhkIDo6IHRsIC0+IGhkIDo6ICh0bCBAIGwyKVxuXG4oKiBJL08gb3BlcmF0aW9ucyAqKVxuXG50eXBlIGluX2NoYW5uZWxcbnR5cGUgb3V0X2NoYW5uZWxcblxuZXh0ZXJuYWwgb3Blbl9kZXNjcmlwdG9yX291dCA6IGludCAtPiBvdXRfY2hhbm5lbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3Jfb3V0XCJcbmV4dGVybmFsIG9wZW5fZGVzY3JpcHRvcl9pbiA6IGludCAtPiBpbl9jaGFubmVsID0gXCJjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9pblwiXG5cbmxldCBzdGRpbiA9IG9wZW5fZGVzY3JpcHRvcl9pbiAwXG5sZXQgc3Rkb3V0ID0gb3Blbl9kZXNjcmlwdG9yX291dCAxXG5sZXQgc3RkZXJyID0gb3Blbl9kZXNjcmlwdG9yX291dCAyXG5cbigqIEdlbmVyYWwgb3V0cHV0IGZ1bmN0aW9ucyAqKVxuXG50eXBlIG9wZW5fZmxhZyA9XG4gICAgT3Blbl9yZG9ubHkgfCBPcGVuX3dyb25seSB8IE9wZW5fYXBwZW5kXG4gIHwgT3Blbl9jcmVhdCB8IE9wZW5fdHJ1bmMgfCBPcGVuX2V4Y2xcbiAgfCBPcGVuX2JpbmFyeSB8IE9wZW5fdGV4dCB8IE9wZW5fbm9uYmxvY2tcblxuZXh0ZXJuYWwgb3Blbl9kZXNjIDogc3RyaW5nIC0+IG9wZW5fZmxhZyBsaXN0IC0+IGludCAtPiBpbnQgPSBcImNhbWxfc3lzX29wZW5cIlxuXG5leHRlcm5hbCBzZXRfb3V0X2NoYW5uZWxfbmFtZTogb3V0X2NoYW5uZWwgLT4gc3RyaW5nIC0+IHVuaXQgPVxuICBcImNhbWxfbWxfc2V0X2NoYW5uZWxfbmFtZVwiXG5cbmxldCBvcGVuX291dF9nZW4gbW9kZSBwZXJtIG5hbWUgPVxuICBsZXQgYyA9IG9wZW5fZGVzY3JpcHRvcl9vdXQob3Blbl9kZXNjIG5hbWUgbW9kZSBwZXJtKSBpblxuICBzZXRfb3V0X2NoYW5uZWxfbmFtZSBjIG5hbWU7XG4gIGNcblxubGV0IG9wZW5fb3V0IG5hbWUgPVxuICBvcGVuX291dF9nZW4gW09wZW5fd3Jvbmx5OyBPcGVuX2NyZWF0OyBPcGVuX3RydW5jOyBPcGVuX3RleHRdIDBvNjY2IG5hbWVcblxubGV0IG9wZW5fb3V0X2JpbiBuYW1lID1cbiAgb3Blbl9vdXRfZ2VuIFtPcGVuX3dyb25seTsgT3Blbl9jcmVhdDsgT3Blbl90cnVuYzsgT3Blbl9iaW5hcnldIDBvNjY2IG5hbWVcblxuZXh0ZXJuYWwgZmx1c2ggOiBvdXRfY2hhbm5lbCAtPiB1bml0ID0gXCJjYW1sX21sX2ZsdXNoXCJcblxuZXh0ZXJuYWwgb3V0X2NoYW5uZWxzX2xpc3QgOiB1bml0IC0+IG91dF9jaGFubmVsIGxpc3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX21sX291dF9jaGFubmVsc19saXN0XCJcblxubGV0IGZsdXNoX2FsbCAoKSA9XG4gIGxldCByZWMgaXRlciA9IGZ1bmN0aW9uXG4gICAgICBbXSAtPiAoKVxuICAgIHwgYTo6bCAtPlxuICAgICAgICBiZWdpbiB0cnlcbiAgICAgICAgICAgIGZsdXNoIGFcbiAgICAgICAgd2l0aCBTeXNfZXJyb3IgXyAtPlxuICAgICAgICAgICgpICgqIGlnbm9yZSBjaGFubmVscyBjbG9zZWQgZHVyaW5nIGEgcHJlY2VkaW5nIGZsdXNoLiAqKVxuICAgICAgICBlbmQ7XG4gICAgICAgIGl0ZXIgbFxuICBpbiBpdGVyIChvdXRfY2hhbm5lbHNfbGlzdCAoKSlcblxuZXh0ZXJuYWwgdW5zYWZlX291dHB1dCA6IG91dF9jaGFubmVsIC0+IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9tbF9vdXRwdXRfYnl0ZXNcIlxuZXh0ZXJuYWwgdW5zYWZlX291dHB1dF9zdHJpbmcgOiBvdXRfY2hhbm5lbCAtPiBzdHJpbmcgLT4gaW50IC0+IGludCAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9tbF9vdXRwdXRcIlxuXG5leHRlcm5hbCBvdXRwdXRfY2hhciA6IG91dF9jaGFubmVsIC0+IGNoYXIgLT4gdW5pdCA9IFwiY2FtbF9tbF9vdXRwdXRfY2hhclwiXG5cbmxldCBvdXRwdXRfYnl0ZXMgb2MgcyA9XG4gIHVuc2FmZV9vdXRwdXQgb2MgcyAwIChieXRlc19sZW5ndGggcylcblxubGV0IG91dHB1dF9zdHJpbmcgb2MgcyA9XG4gIHVuc2FmZV9vdXRwdXRfc3RyaW5nIG9jIHMgMCAoc3RyaW5nX2xlbmd0aCBzKVxuXG5sZXQgb3V0cHV0IG9jIHMgb2ZzIGxlbiA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBieXRlc19sZW5ndGggcyAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwib3V0cHV0XCJcbiAgZWxzZSB1bnNhZmVfb3V0cHV0IG9jIHMgb2ZzIGxlblxuXG5sZXQgb3V0cHV0X3N1YnN0cmluZyBvYyBzIG9mcyBsZW4gPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gc3RyaW5nX2xlbmd0aCBzIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJvdXRwdXRfc3Vic3RyaW5nXCJcbiAgZWxzZSB1bnNhZmVfb3V0cHV0X3N0cmluZyBvYyBzIG9mcyBsZW5cblxuZXh0ZXJuYWwgb3V0cHV0X2J5dGUgOiBvdXRfY2hhbm5lbCAtPiBpbnQgLT4gdW5pdCA9IFwiY2FtbF9tbF9vdXRwdXRfY2hhclwiXG5leHRlcm5hbCBvdXRwdXRfYmluYXJ5X2ludCA6IG91dF9jaGFubmVsIC0+IGludCAtPiB1bml0ID0gXCJjYW1sX21sX291dHB1dF9pbnRcIlxuXG5leHRlcm5hbCBtYXJzaGFsX3RvX2NoYW5uZWwgOiBvdXRfY2hhbm5lbCAtPiAnYSAtPiB1bml0IGxpc3QgLT4gdW5pdFxuICAgICA9IFwiY2FtbF9vdXRwdXRfdmFsdWVcIlxubGV0IG91dHB1dF92YWx1ZSBjaGFuIHYgPSBtYXJzaGFsX3RvX2NoYW5uZWwgY2hhbiB2IFtdXG5cbmV4dGVybmFsIHNlZWtfb3V0IDogb3V0X2NoYW5uZWwgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfbWxfc2Vla19vdXRcIlxuZXh0ZXJuYWwgcG9zX291dCA6IG91dF9jaGFubmVsIC0+IGludCA9IFwiY2FtbF9tbF9wb3Nfb3V0XCJcbmV4dGVybmFsIG91dF9jaGFubmVsX2xlbmd0aCA6IG91dF9jaGFubmVsIC0+IGludCA9IFwiY2FtbF9tbF9jaGFubmVsX3NpemVcIlxuZXh0ZXJuYWwgY2xvc2Vfb3V0X2NoYW5uZWwgOiBvdXRfY2hhbm5lbCAtPiB1bml0ID0gXCJjYW1sX21sX2Nsb3NlX2NoYW5uZWxcIlxubGV0IGNsb3NlX291dCBvYyA9IGZsdXNoIG9jOyBjbG9zZV9vdXRfY2hhbm5lbCBvY1xubGV0IGNsb3NlX291dF9ub2VyciBvYyA9XG4gICh0cnkgZmx1c2ggb2Mgd2l0aCBfIC0+ICgpKTtcbiAgKHRyeSBjbG9zZV9vdXRfY2hhbm5lbCBvYyB3aXRoIF8gLT4gKCkpXG5leHRlcm5hbCBzZXRfYmluYXJ5X21vZGVfb3V0IDogb3V0X2NoYW5uZWwgLT4gYm9vbCAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX21sX3NldF9iaW5hcnlfbW9kZVwiXG5cbigqIEdlbmVyYWwgaW5wdXQgZnVuY3Rpb25zICopXG5cbmV4dGVybmFsIHNldF9pbl9jaGFubmVsX25hbWU6IGluX2NoYW5uZWwgLT4gc3RyaW5nIC0+IHVuaXQgPVxuICBcImNhbWxfbWxfc2V0X2NoYW5uZWxfbmFtZVwiXG5cbmxldCBvcGVuX2luX2dlbiBtb2RlIHBlcm0gbmFtZSA9XG4gIGxldCBjID0gb3Blbl9kZXNjcmlwdG9yX2luKG9wZW5fZGVzYyBuYW1lIG1vZGUgcGVybSkgaW5cbiAgc2V0X2luX2NoYW5uZWxfbmFtZSBjIG5hbWU7XG4gIGNcblxubGV0IG9wZW5faW4gbmFtZSA9XG4gIG9wZW5faW5fZ2VuIFtPcGVuX3Jkb25seTsgT3Blbl90ZXh0XSAwIG5hbWVcblxubGV0IG9wZW5faW5fYmluIG5hbWUgPVxuICBvcGVuX2luX2dlbiBbT3Blbl9yZG9ubHk7IE9wZW5fYmluYXJ5XSAwIG5hbWVcblxuZXh0ZXJuYWwgaW5wdXRfY2hhciA6IGluX2NoYW5uZWwgLT4gY2hhciA9IFwiY2FtbF9tbF9pbnB1dF9jaGFyXCJcblxuZXh0ZXJuYWwgdW5zYWZlX2lucHV0IDogaW5fY2hhbm5lbCAtPiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IGludFxuICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX21sX2lucHV0XCJcblxubGV0IGlucHV0IGljIHMgb2ZzIGxlbiA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBieXRlc19sZW5ndGggcyAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiaW5wdXRcIlxuICBlbHNlIHVuc2FmZV9pbnB1dCBpYyBzIG9mcyBsZW5cblxubGV0IHJlYyB1bnNhZmVfcmVhbGx5X2lucHV0IGljIHMgb2ZzIGxlbiA9XG4gIGlmIGxlbiA8PSAwIHRoZW4gKCkgZWxzZSBiZWdpblxuICAgIGxldCByID0gdW5zYWZlX2lucHV0IGljIHMgb2ZzIGxlbiBpblxuICAgIGlmIHIgPSAwXG4gICAgdGhlbiByYWlzZSBFbmRfb2ZfZmlsZVxuICAgIGVsc2UgdW5zYWZlX3JlYWxseV9pbnB1dCBpYyBzIChvZnMgKyByKSAobGVuIC0gcilcbiAgZW5kXG5cbmxldCByZWFsbHlfaW5wdXQgaWMgcyBvZnMgbGVuID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IGJ5dGVzX2xlbmd0aCBzIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJyZWFsbHlfaW5wdXRcIlxuICBlbHNlIHVuc2FmZV9yZWFsbHlfaW5wdXQgaWMgcyBvZnMgbGVuXG5cbmxldCByZWFsbHlfaW5wdXRfc3RyaW5nIGljIGxlbiA9XG4gIGxldCBzID0gYnl0ZXNfY3JlYXRlIGxlbiBpblxuICByZWFsbHlfaW5wdXQgaWMgcyAwIGxlbjtcbiAgYnl0ZXNfdW5zYWZlX3RvX3N0cmluZyBzXG5cbmV4dGVybmFsIGlucHV0X3NjYW5fbGluZSA6IGluX2NoYW5uZWwgLT4gaW50ID0gXCJjYW1sX21sX2lucHV0X3NjYW5fbGluZVwiXG5cbmxldCBpbnB1dF9saW5lIGNoYW4gPVxuICBsZXQgcmVjIGJ1aWxkX3Jlc3VsdCBidWYgcG9zID0gZnVuY3Rpb25cbiAgICBbXSAtPiBidWZcbiAgfCBoZCA6OiB0bCAtPlxuICAgICAgbGV0IGxlbiA9IGJ5dGVzX2xlbmd0aCBoZCBpblxuICAgICAgYnl0ZXNfYmxpdCBoZCAwIGJ1ZiAocG9zIC0gbGVuKSBsZW47XG4gICAgICBidWlsZF9yZXN1bHQgYnVmIChwb3MgLSBsZW4pIHRsIGluXG4gIGxldCByZWMgc2NhbiBhY2N1IGxlbiA9XG4gICAgbGV0IG4gPSBpbnB1dF9zY2FuX2xpbmUgY2hhbiBpblxuICAgIGlmIG4gPSAwIHRoZW4gYmVnaW4gICAgICAgICAgICAgICAgICAgKCogbiA9IDA6IHdlIGFyZSBhdCBFT0YgKilcbiAgICAgIG1hdGNoIGFjY3Ugd2l0aFxuICAgICAgICBbXSAtPiByYWlzZSBFbmRfb2ZfZmlsZVxuICAgICAgfCBfICAtPiBidWlsZF9yZXN1bHQgKGJ5dGVzX2NyZWF0ZSBsZW4pIGxlbiBhY2N1XG4gICAgZW5kIGVsc2UgaWYgbiA+IDAgdGhlbiBiZWdpbiAgICAgICAgICAoKiBuID4gMDogbmV3bGluZSBmb3VuZCBpbiBidWZmZXIgKilcbiAgICAgIGxldCByZXMgPSBieXRlc19jcmVhdGUgKG4gLSAxKSBpblxuICAgICAgaWdub3JlICh1bnNhZmVfaW5wdXQgY2hhbiByZXMgMCAobiAtIDEpKTtcbiAgICAgIGlnbm9yZSAoaW5wdXRfY2hhciBjaGFuKTsgICAgICAgICAgICgqIHNraXAgdGhlIG5ld2xpbmUgKilcbiAgICAgIG1hdGNoIGFjY3Ugd2l0aFxuICAgICAgICBbXSAtPiByZXNcbiAgICAgIHwgIF8gLT4gbGV0IGxlbiA9IGxlbiArIG4gLSAxIGluXG4gICAgICAgICAgICAgIGJ1aWxkX3Jlc3VsdCAoYnl0ZXNfY3JlYXRlIGxlbikgbGVuIChyZXMgOjogYWNjdSlcbiAgICBlbmQgZWxzZSBiZWdpbiAgICAgICAgICAgICAgICAgICAgICAgICgqIG4gPCAwOiBuZXdsaW5lIG5vdCBmb3VuZCAqKVxuICAgICAgbGV0IGJlZyA9IGJ5dGVzX2NyZWF0ZSAoLW4pIGluXG4gICAgICBpZ25vcmUodW5zYWZlX2lucHV0IGNoYW4gYmVnIDAgKC1uKSk7XG4gICAgICBzY2FuIChiZWcgOjogYWNjdSkgKGxlbiAtIG4pXG4gICAgZW5kXG4gIGluIGJ5dGVzX3Vuc2FmZV90b19zdHJpbmcgKHNjYW4gW10gMClcblxuZXh0ZXJuYWwgaW5wdXRfYnl0ZSA6IGluX2NoYW5uZWwgLT4gaW50ID0gXCJjYW1sX21sX2lucHV0X2NoYXJcIlxuZXh0ZXJuYWwgaW5wdXRfYmluYXJ5X2ludCA6IGluX2NoYW5uZWwgLT4gaW50ID0gXCJjYW1sX21sX2lucHV0X2ludFwiXG5leHRlcm5hbCBpbnB1dF92YWx1ZSA6IGluX2NoYW5uZWwgLT4gJ2EgPSBcImNhbWxfaW5wdXRfdmFsdWVcIlxuZXh0ZXJuYWwgc2Vla19pbiA6IGluX2NoYW5uZWwgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfbWxfc2Vla19pblwiXG5leHRlcm5hbCBwb3NfaW4gOiBpbl9jaGFubmVsIC0+IGludCA9IFwiY2FtbF9tbF9wb3NfaW5cIlxuZXh0ZXJuYWwgaW5fY2hhbm5lbF9sZW5ndGggOiBpbl9jaGFubmVsIC0+IGludCA9IFwiY2FtbF9tbF9jaGFubmVsX3NpemVcIlxuZXh0ZXJuYWwgY2xvc2VfaW4gOiBpbl9jaGFubmVsIC0+IHVuaXQgPSBcImNhbWxfbWxfY2xvc2VfY2hhbm5lbFwiXG5sZXQgY2xvc2VfaW5fbm9lcnIgaWMgPSAodHJ5IGNsb3NlX2luIGljIHdpdGggXyAtPiAoKSlcbmV4dGVybmFsIHNldF9iaW5hcnlfbW9kZV9pbiA6IGluX2NoYW5uZWwgLT4gYm9vbCAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfbWxfc2V0X2JpbmFyeV9tb2RlXCJcblxuKCogT3V0cHV0IGZ1bmN0aW9ucyBvbiBzdGFuZGFyZCBvdXRwdXQgKilcblxubGV0IHByaW50X2NoYXIgYyA9IG91dHB1dF9jaGFyIHN0ZG91dCBjXG5sZXQgcHJpbnRfc3RyaW5nIHMgPSBvdXRwdXRfc3RyaW5nIHN0ZG91dCBzXG5sZXQgcHJpbnRfYnl0ZXMgcyA9IG91dHB1dF9ieXRlcyBzdGRvdXQgc1xubGV0IHByaW50X2ludCBpID0gb3V0cHV0X3N0cmluZyBzdGRvdXQgKHN0cmluZ19vZl9pbnQgaSlcbmxldCBwcmludF9mbG9hdCBmID0gb3V0cHV0X3N0cmluZyBzdGRvdXQgKHN0cmluZ19vZl9mbG9hdCBmKVxubGV0IHByaW50X2VuZGxpbmUgcyA9XG4gIG91dHB1dF9zdHJpbmcgc3Rkb3V0IHM7IG91dHB1dF9jaGFyIHN0ZG91dCAnXFxuJzsgZmx1c2ggc3Rkb3V0XG5sZXQgcHJpbnRfbmV3bGluZSAoKSA9IG91dHB1dF9jaGFyIHN0ZG91dCAnXFxuJzsgZmx1c2ggc3Rkb3V0XG5cbigqIE91dHB1dCBmdW5jdGlvbnMgb24gc3RhbmRhcmQgZXJyb3IgKilcblxubGV0IHByZXJyX2NoYXIgYyA9IG91dHB1dF9jaGFyIHN0ZGVyciBjXG5sZXQgcHJlcnJfc3RyaW5nIHMgPSBvdXRwdXRfc3RyaW5nIHN0ZGVyciBzXG5sZXQgcHJlcnJfYnl0ZXMgcyA9IG91dHB1dF9ieXRlcyBzdGRlcnIgc1xubGV0IHByZXJyX2ludCBpID0gb3V0cHV0X3N0cmluZyBzdGRlcnIgKHN0cmluZ19vZl9pbnQgaSlcbmxldCBwcmVycl9mbG9hdCBmID0gb3V0cHV0X3N0cmluZyBzdGRlcnIgKHN0cmluZ19vZl9mbG9hdCBmKVxubGV0IHByZXJyX2VuZGxpbmUgcyA9XG4gIG91dHB1dF9zdHJpbmcgc3RkZXJyIHM7IG91dHB1dF9jaGFyIHN0ZGVyciAnXFxuJzsgZmx1c2ggc3RkZXJyXG5sZXQgcHJlcnJfbmV3bGluZSAoKSA9IG91dHB1dF9jaGFyIHN0ZGVyciAnXFxuJzsgZmx1c2ggc3RkZXJyXG5cbigqIElucHV0IGZ1bmN0aW9ucyBvbiBzdGFuZGFyZCBpbnB1dCAqKVxuXG5sZXQgcmVhZF9saW5lICgpID0gZmx1c2ggc3Rkb3V0OyBpbnB1dF9saW5lIHN0ZGluXG5sZXQgcmVhZF9pbnQgKCkgPSBpbnRfb2Zfc3RyaW5nKHJlYWRfbGluZSgpKVxubGV0IHJlYWRfaW50X29wdCAoKSA9IGludF9vZl9zdHJpbmdfb3B0KHJlYWRfbGluZSgpKVxubGV0IHJlYWRfZmxvYXQgKCkgPSBmbG9hdF9vZl9zdHJpbmcocmVhZF9saW5lKCkpXG5sZXQgcmVhZF9mbG9hdF9vcHQgKCkgPSBmbG9hdF9vZl9zdHJpbmdfb3B0KHJlYWRfbGluZSgpKVxuXG4oKiBPcGVyYXRpb25zIG9uIGxhcmdlIGZpbGVzICopXG5cbm1vZHVsZSBMYXJnZUZpbGUgPVxuICBzdHJ1Y3RcbiAgICBleHRlcm5hbCBzZWVrX291dCA6IG91dF9jaGFubmVsIC0+IGludDY0IC0+IHVuaXQgPSBcImNhbWxfbWxfc2Vla19vdXRfNjRcIlxuICAgIGV4dGVybmFsIHBvc19vdXQgOiBvdXRfY2hhbm5lbCAtPiBpbnQ2NCA9IFwiY2FtbF9tbF9wb3Nfb3V0XzY0XCJcbiAgICBleHRlcm5hbCBvdXRfY2hhbm5lbF9sZW5ndGggOiBvdXRfY2hhbm5lbCAtPiBpbnQ2NFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9tbF9jaGFubmVsX3NpemVfNjRcIlxuICAgIGV4dGVybmFsIHNlZWtfaW4gOiBpbl9jaGFubmVsIC0+IGludDY0IC0+IHVuaXQgPSBcImNhbWxfbWxfc2Vla19pbl82NFwiXG4gICAgZXh0ZXJuYWwgcG9zX2luIDogaW5fY2hhbm5lbCAtPiBpbnQ2NCA9IFwiY2FtbF9tbF9wb3NfaW5fNjRcIlxuICAgIGV4dGVybmFsIGluX2NoYW5uZWxfbGVuZ3RoIDogaW5fY2hhbm5lbCAtPiBpbnQ2NCA9IFwiY2FtbF9tbF9jaGFubmVsX3NpemVfNjRcIlxuICBlbmRcblxuKCogRm9ybWF0cyAqKVxuXG50eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2XG4gICA9ICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3MuZm9ybWF0NlxuICAgPSBGb3JtYXQgb2YgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljcy5mbXRcbiAgICAgICAgICAgICAgICogc3RyaW5nXG5cbnR5cGUgKCdhLCAnYiwgJ2MsICdkKSBmb3JtYXQ0ID0gKCdhLCAnYiwgJ2MsICdjLCAnYywgJ2QpIGZvcm1hdDZcblxudHlwZSAoJ2EsICdiLCAnYykgZm9ybWF0ID0gKCdhLCAnYiwgJ2MsICdjKSBmb3JtYXQ0XG5cbmxldCBzdHJpbmdfb2ZfZm9ybWF0IChGb3JtYXQgKF9mbXQsIHN0cikpID0gc3RyXG5cbmV4dGVybmFsIGZvcm1hdF9vZl9zdHJpbmcgOlxuICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2IC0+XG4gKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgPSBcIiVpZGVudGl0eVwiXG5cbmxldCAoIF5eICkgKEZvcm1hdCAoZm10MSwgc3RyMSkpIChGb3JtYXQgKGZtdDIsIHN0cjIpKSA9XG4gIEZvcm1hdCAoQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzLmNvbmNhdF9mbXQgZm10MSBmbXQyLFxuICAgICAgICAgIHN0cjEgXiBcIiUsXCIgXiBzdHIyKVxuXG4oKiBNaXNjZWxsYW5lb3VzICopXG5cbmV4dGVybmFsIHN5c19leGl0IDogaW50IC0+ICdhID0gXCJjYW1sX3N5c19leGl0XCJcblxubGV0IGV4aXRfZnVuY3Rpb24gPSBDYW1saW50ZXJuYWxBdG9taWMubWFrZSBmbHVzaF9hbGxcblxubGV0IHJlYyBhdF9leGl0IGYgPVxuICBsZXQgbW9kdWxlIEF0b21pYyA9IENhbWxpbnRlcm5hbEF0b21pYyBpblxuICAoKiBNUFIjNzI1MywgTVBSIzc3OTY6IG1ha2Ugc3VyZSBcImZcIiBpcyBleGVjdXRlZCBvbmx5IG9uY2UgKilcbiAgbGV0IGZfeWV0X3RvX3J1biA9IEF0b21pYy5tYWtlIHRydWUgaW5cbiAgbGV0IG9sZF9leGl0ID0gQXRvbWljLmdldCBleGl0X2Z1bmN0aW9uIGluXG4gIGxldCBuZXdfZXhpdCAoKSA9XG4gICAgaWYgQXRvbWljLmNvbXBhcmVfYW5kX3NldCBmX3lldF90b19ydW4gdHJ1ZSBmYWxzZSB0aGVuIGYgKCkgO1xuICAgIG9sZF9leGl0ICgpXG4gIGluXG4gIGxldCBzdWNjZXNzID0gQXRvbWljLmNvbXBhcmVfYW5kX3NldCBleGl0X2Z1bmN0aW9uIG9sZF9leGl0IG5ld19leGl0IGluXG4gIGlmIG5vdCBzdWNjZXNzIHRoZW4gYXRfZXhpdCBmXG5cbmxldCBkb19hdF9leGl0ICgpID0gKENhbWxpbnRlcm5hbEF0b21pYy5nZXQgZXhpdF9mdW5jdGlvbikgKClcblxubGV0IGV4aXQgcmV0Y29kZSA9XG4gIGRvX2F0X2V4aXQgKCk7XG4gIHN5c19leGl0IHJldGNvZGVcblxubGV0IF8gPSByZWdpc3Rlcl9uYW1lZF92YWx1ZSBcIlBlcnZhc2l2ZXMuZG9fYXRfZXhpdFwiIGRvX2F0X2V4aXRcblxuZXh0ZXJuYWwgbWFqb3IgOiB1bml0IC0+IHVuaXQgPSBcImNhbWxfZ2NfbWFqb3JcIlxuZXh0ZXJuYWwgbmFrZWRfcG9pbnRlcnNfY2hlY2tlZCA6IHVuaXQgLT4gYm9vbFxuICA9IFwiY2FtbF9zeXNfY29uc3RfbmFrZWRfcG9pbnRlcnNfY2hlY2tlZFwiXG5sZXQgKCkgPSBpZiBuYWtlZF9wb2ludGVyc19jaGVja2VkICgpIHRoZW4gYXRfZXhpdCBtYWpvclxuXG4oKk1PRFVMRV9BTElBU0VTKilcbm1vZHVsZSBBcmcgICAgICAgICAgPSBBcmdcbm1vZHVsZSBBcnJheSAgICAgICAgPSBBcnJheVxubW9kdWxlIEFycmF5TGFiZWxzICA9IEFycmF5TGFiZWxzXG5tb2R1bGUgQXRvbWljICAgICAgID0gQXRvbWljXG5tb2R1bGUgQmlnYXJyYXkgICAgID0gQmlnYXJyYXlcbm1vZHVsZSBCb29sICAgICAgICAgPSBCb29sXG5tb2R1bGUgQnVmZmVyICAgICAgID0gQnVmZmVyXG5tb2R1bGUgQnl0ZXMgICAgICAgID0gQnl0ZXNcbm1vZHVsZSBCeXRlc0xhYmVscyAgPSBCeXRlc0xhYmVsc1xubW9kdWxlIENhbGxiYWNrICAgICA9IENhbGxiYWNrXG5tb2R1bGUgQ2hhciAgICAgICAgID0gQ2hhclxubW9kdWxlIENvbXBsZXggICAgICA9IENvbXBsZXhcbm1vZHVsZSBEaWdlc3QgICAgICAgPSBEaWdlc3Rcbm1vZHVsZSBFaXRoZXIgICAgICAgPSBFaXRoZXJcbm1vZHVsZSBFcGhlbWVyb24gICAgPSBFcGhlbWVyb25cbm1vZHVsZSBGaWxlbmFtZSAgICAgPSBGaWxlbmFtZVxubW9kdWxlIEZsb2F0ICAgICAgICA9IEZsb2F0XG5tb2R1bGUgRm9ybWF0ICAgICAgID0gRm9ybWF0XG5tb2R1bGUgRnVuICAgICAgICAgID0gRnVuXG5tb2R1bGUgR2MgICAgICAgICAgID0gR2Ncbm1vZHVsZSBHZW5sZXggICAgICAgPSBHZW5sZXhcbm1vZHVsZSBIYXNodGJsICAgICAgPSBIYXNodGJsXG5tb2R1bGUgSW5fY2hhbm5lbCAgID0gSW5fY2hhbm5lbFxubW9kdWxlIEludCAgICAgICAgICA9IEludFxubW9kdWxlIEludDMyICAgICAgICA9IEludDMyXG5tb2R1bGUgSW50NjQgICAgICAgID0gSW50NjRcbm1vZHVsZSBMYXp5ICAgICAgICAgPSBMYXp5XG5tb2R1bGUgTGV4aW5nICAgICAgID0gTGV4aW5nXG5tb2R1bGUgTGlzdCAgICAgICAgID0gTGlzdFxubW9kdWxlIExpc3RMYWJlbHMgICA9IExpc3RMYWJlbHNcbm1vZHVsZSBNYXAgICAgICAgICAgPSBNYXBcbm1vZHVsZSBNYXJzaGFsICAgICAgPSBNYXJzaGFsXG5tb2R1bGUgTW9yZUxhYmVscyAgID0gTW9yZUxhYmVsc1xubW9kdWxlIE5hdGl2ZWludCAgICA9IE5hdGl2ZWludFxubW9kdWxlIE9iaiAgICAgICAgICA9IE9ialxubW9kdWxlIE9vICAgICAgICAgICA9IE9vXG5tb2R1bGUgT3B0aW9uICAgICAgID0gT3B0aW9uXG5tb2R1bGUgT3V0X2NoYW5uZWwgID0gT3V0X2NoYW5uZWxcbm1vZHVsZSBQYXJzaW5nICAgICAgPSBQYXJzaW5nXG5tb2R1bGUgUGVydmFzaXZlcyAgID0gUGVydmFzaXZlc1xubW9kdWxlIFByaW50ZXhjICAgICA9IFByaW50ZXhjXG5tb2R1bGUgUHJpbnRmICAgICAgID0gUHJpbnRmXG5tb2R1bGUgUXVldWUgICAgICAgID0gUXVldWVcbm1vZHVsZSBSYW5kb20gICAgICAgPSBSYW5kb21cbm1vZHVsZSBSZXN1bHQgICAgICAgPSBSZXN1bHRcbm1vZHVsZSBTY2FuZiAgICAgICAgPSBTY2FuZlxubW9kdWxlIFNlcSAgICAgICAgICA9IFNlcVxubW9kdWxlIFNldCAgICAgICAgICA9IFNldFxubW9kdWxlIFN0YWNrICAgICAgICA9IFN0YWNrXG5tb2R1bGUgU3RkTGFiZWxzICAgID0gU3RkTGFiZWxzXG5tb2R1bGUgU3RyZWFtICAgICAgID0gU3RyZWFtXG5tb2R1bGUgU3RyaW5nICAgICAgID0gU3RyaW5nXG5tb2R1bGUgU3RyaW5nTGFiZWxzID0gU3RyaW5nTGFiZWxzXG5tb2R1bGUgU3lzICAgICAgICAgID0gU3lzXG5tb2R1bGUgVWNoYXIgICAgICAgID0gVWNoYXJcbm1vZHVsZSBVbml0ICAgICAgICAgPSBVbml0XG5tb2R1bGUgV2VhayAgICAgICAgID0gV2Vha1xuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgSmVyZW1pZSBEaW1pbm8sIEphbmUgU3RyZWV0IEV1cm9wZSAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxNyBKYW5lIFN0cmVldCBHcm91cCBMTEMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiogQGRlcHJlY2F0ZWQgVXNlIHshU3RkbGlifSAqKVxuXG5leHRlcm5hbCByYWlzZSA6IGV4biAtPiAnYSA9IFwiJXJhaXNlXCJcbmV4dGVybmFsIHJhaXNlX25vdHJhY2UgOiBleG4gLT4gJ2EgPSBcIiVyYWlzZV9ub3RyYWNlXCJcbmxldCBpbnZhbGlkX2FyZyA9IGludmFsaWRfYXJnXG5sZXQgZmFpbHdpdGggPSBmYWlsd2l0aFxuZXhjZXB0aW9uIEV4aXRcbmV4dGVybmFsICggPSApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWVxdWFsXCJcbmV4dGVybmFsICggPD4gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVub3RlcXVhbFwiXG5leHRlcm5hbCAoIDwgKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVsZXNzdGhhblwiXG5leHRlcm5hbCAoID4gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVncmVhdGVydGhhblwiXG5leHRlcm5hbCAoIDw9ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlbGVzc2VxdWFsXCJcbmV4dGVybmFsICggPj0gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVncmVhdGVyZXF1YWxcIlxuZXh0ZXJuYWwgY29tcGFyZSA6ICdhIC0+ICdhIC0+IGludCA9IFwiJWNvbXBhcmVcIlxubGV0IG1pbiA9IG1pblxubGV0IG1heCA9IG1heFxuZXh0ZXJuYWwgKCA9PSApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWVxXCJcbmV4dGVybmFsICggIT0gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVub3RlcVwiXG5leHRlcm5hbCBub3QgOiBib29sIC0+IGJvb2wgPSBcIiVib29sbm90XCJcbmV4dGVybmFsICggJiYgKSA6IGJvb2wgLT4gYm9vbCAtPiBib29sID0gXCIlc2VxdWFuZFwiXG5leHRlcm5hbCAoICYgKSA6IGJvb2wgLT4gYm9vbCAtPiBib29sID0gXCIlc2VxdWFuZFwiXG4gIFtAQG9jYW1sLmRlcHJlY2F0ZWQgXCJVc2UgKCYmKSBpbnN0ZWFkLlwiXVxuZXh0ZXJuYWwgKCB8fCApIDogYm9vbCAtPiBib29sIC0+IGJvb2wgPSBcIiVzZXF1b3JcIlxuZXh0ZXJuYWwgKCBvciApIDogYm9vbCAtPiBib29sIC0+IGJvb2wgPSBcIiVzZXF1b3JcIlxuICBbQEBvY2FtbC5kZXByZWNhdGVkIFwiVXNlICh8fCkgaW5zdGVhZC5cIl1cbmV4dGVybmFsIF9fTE9DX18gOiBzdHJpbmcgPSBcIiVsb2NfTE9DXCJcbmV4dGVybmFsIF9fRklMRV9fIDogc3RyaW5nID0gXCIlbG9jX0ZJTEVcIlxuZXh0ZXJuYWwgX19MSU5FX18gOiBpbnQgPSBcIiVsb2NfTElORVwiXG5leHRlcm5hbCBfX01PRFVMRV9fIDogc3RyaW5nID0gXCIlbG9jX01PRFVMRVwiXG5leHRlcm5hbCBfX1BPU19fIDogc3RyaW5nICogaW50ICogaW50ICogaW50ID0gXCIlbG9jX1BPU1wiXG5leHRlcm5hbCBfX0xPQ19PRl9fIDogJ2EgLT4gc3RyaW5nICogJ2EgPSBcIiVsb2NfTE9DXCJcbmV4dGVybmFsIF9fTElORV9PRl9fIDogJ2EgLT4gaW50ICogJ2EgPSBcIiVsb2NfTElORVwiXG5leHRlcm5hbCBfX1BPU19PRl9fIDogJ2EgLT4gKHN0cmluZyAqIGludCAqIGludCAqIGludCkgKiAnYSA9IFwiJWxvY19QT1NcIlxuZXh0ZXJuYWwgKCB8PiApIDogJ2EgLT4gKCdhIC0+ICdiKSAtPiAnYiA9IFwiJXJldmFwcGx5XCJcbmV4dGVybmFsICggQEAgKSA6ICgnYSAtPiAnYikgLT4gJ2EgLT4gJ2IgPSBcIiVhcHBseVwiXG5leHRlcm5hbCAoIH4tICkgOiBpbnQgLT4gaW50ID0gXCIlbmVnaW50XCJcbmV4dGVybmFsICggfisgKSA6IGludCAtPiBpbnQgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCBzdWNjIDogaW50IC0+IGludCA9IFwiJXN1Y2NpbnRcIlxuZXh0ZXJuYWwgcHJlZCA6IGludCAtPiBpbnQgPSBcIiVwcmVkaW50XCJcbmV4dGVybmFsICggKyApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVhZGRpbnRcIlxuZXh0ZXJuYWwgKCAtICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJXN1YmludFwiXG5leHRlcm5hbCAoICogKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlbXVsaW50XCJcbmV4dGVybmFsICggLyApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVkaXZpbnRcIlxuZXh0ZXJuYWwgKCBtb2QgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlbW9kaW50XCJcbmxldCBhYnMgPSBhYnNcbmxldCBtYXhfaW50ID0gbWF4X2ludFxubGV0IG1pbl9pbnQgPSBtaW5faW50XG5leHRlcm5hbCAoIGxhbmQgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlYW5kaW50XCJcbmV4dGVybmFsICggbG9yICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJW9yaW50XCJcbmV4dGVybmFsICggbHhvciApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiV4b3JpbnRcIlxubGV0IGxub3QgPSBsbm90XG5leHRlcm5hbCAoIGxzbCApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVsc2xpbnRcIlxuZXh0ZXJuYWwgKCBsc3IgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlbHNyaW50XCJcbmV4dGVybmFsICggYXNyICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWFzcmludFwiXG5leHRlcm5hbCAoIH4tLiApIDogZmxvYXQgLT4gZmxvYXQgPSBcIiVuZWdmbG9hdFwiXG5leHRlcm5hbCAoIH4rLiApIDogZmxvYXQgLT4gZmxvYXQgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCAoICsuICkgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiJWFkZGZsb2F0XCJcbmV4dGVybmFsICggLS4gKSA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCIlc3ViZmxvYXRcIlxuZXh0ZXJuYWwgKCAqLiApIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcIiVtdWxmbG9hdFwiXG5leHRlcm5hbCAoIC8uICkgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiJWRpdmZsb2F0XCJcbmV4dGVybmFsICggKiogKSA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3Bvd2VyX2Zsb2F0XCIgXCJwb3dcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgc3FydCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3NxcnRfZmxvYXRcIiBcInNxcnRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZXhwIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfZXhwX2Zsb2F0XCIgXCJleHBcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgbG9nIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfbG9nX2Zsb2F0XCIgXCJsb2dcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgbG9nMTAgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9sb2cxMF9mbG9hdFwiIFwibG9nMTBcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZXhwbTEgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9leHBtMV9mbG9hdFwiIFwiY2FtbF9leHBtMVwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBsb2cxcCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2xvZzFwX2Zsb2F0XCIgXCJjYW1sX2xvZzFwXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGNvcyA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Nvc19mbG9hdFwiIFwiY29zXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHNpbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3Npbl9mbG9hdFwiIFwic2luXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHRhbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3Rhbl9mbG9hdFwiIFwidGFuXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGFjb3MgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hY29zX2Zsb2F0XCIgXCJhY29zXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGFzaW4gOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hc2luX2Zsb2F0XCIgXCJhc2luXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGF0YW4gOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hdGFuX2Zsb2F0XCIgXCJhdGFuXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGF0YW4yIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYXRhbjJfZmxvYXRcIiBcImF0YW4yXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGh5cG90IDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfaHlwb3RfZmxvYXRcIiBcImNhbWxfaHlwb3RcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgY29zaCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Nvc2hfZmxvYXRcIiBcImNvc2hcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgc2luaCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3NpbmhfZmxvYXRcIiBcInNpbmhcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdGFuaCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3RhbmhfZmxvYXRcIiBcInRhbmhcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgY2VpbCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2NlaWxfZmxvYXRcIiBcImNlaWxcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZmxvb3IgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9mbG9vcl9mbG9hdFwiIFwiZmxvb3JcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYWJzX2Zsb2F0IDogZmxvYXQgLT4gZmxvYXQgPSBcIiVhYnNmbG9hdFwiXG5leHRlcm5hbCBjb3B5c2lnbiA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0XG4gICAgICAgICAgICAgICAgICA9IFwiY2FtbF9jb3B5c2lnbl9mbG9hdFwiIFwiY2FtbF9jb3B5c2lnblwiXG4gICAgICAgICAgICAgICAgICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgbW9kX2Zsb2F0IDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfZm1vZF9mbG9hdFwiIFwiZm1vZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBmcmV4cCA6IGZsb2F0IC0+IGZsb2F0ICogaW50ID0gXCJjYW1sX2ZyZXhwX2Zsb2F0XCJcbmV4dGVybmFsIGxkZXhwIDogKGZsb2F0IFtAdW5ib3hlZF0pIC0+IChpbnQgW0B1bnRhZ2dlZF0pIC0+IChmbG9hdCBbQHVuYm94ZWRdKSA9XG4gIFwiY2FtbF9sZGV4cF9mbG9hdFwiIFwiY2FtbF9sZGV4cF9mbG9hdF91bmJveGVkXCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIG1vZGYgOiBmbG9hdCAtPiBmbG9hdCAqIGZsb2F0ID0gXCJjYW1sX21vZGZfZmxvYXRcIlxuZXh0ZXJuYWwgZmxvYXQgOiBpbnQgLT4gZmxvYXQgPSBcIiVmbG9hdG9maW50XCJcbmV4dGVybmFsIGZsb2F0X29mX2ludCA6IGludCAtPiBmbG9hdCA9IFwiJWZsb2F0b2ZpbnRcIlxuZXh0ZXJuYWwgdHJ1bmNhdGUgOiBmbG9hdCAtPiBpbnQgPSBcIiVpbnRvZmZsb2F0XCJcbmV4dGVybmFsIGludF9vZl9mbG9hdCA6IGZsb2F0IC0+IGludCA9IFwiJWludG9mZmxvYXRcIlxubGV0IGluZmluaXR5ID0gaW5maW5pdHlcbmxldCBuZWdfaW5maW5pdHkgPSBuZWdfaW5maW5pdHlcbmxldCBuYW4gPSBuYW5cbmxldCBtYXhfZmxvYXQgPSBtYXhfZmxvYXRcbmxldCBtaW5fZmxvYXQgPSBtaW5fZmxvYXRcbmxldCBlcHNpbG9uX2Zsb2F0ID0gZXBzaWxvbl9mbG9hdFxudHlwZSBub25yZWMgZnBjbGFzcyA9IGZwY2xhc3MgPVxuICAgIEZQX25vcm1hbFxuICB8IEZQX3N1Ym5vcm1hbFxuICB8IEZQX3plcm9cbiAgfCBGUF9pbmZpbml0ZVxuICB8IEZQX25hblxuZXh0ZXJuYWwgY2xhc3NpZnlfZmxvYXQgOiAoZmxvYXQgW0B1bmJveGVkXSkgLT4gZnBjbGFzcyA9XG4gIFwiY2FtbF9jbGFzc2lmeV9mbG9hdFwiIFwiY2FtbF9jbGFzc2lmeV9mbG9hdF91bmJveGVkXCIgW0BAbm9hbGxvY11cbmxldCAoIF4gKSA9ICggXiApXG5leHRlcm5hbCBpbnRfb2ZfY2hhciA6IGNoYXIgLT4gaW50ID0gXCIlaWRlbnRpdHlcIlxubGV0IGNoYXJfb2ZfaW50ID0gY2hhcl9vZl9pbnRcbmV4dGVybmFsIGlnbm9yZSA6ICdhIC0+IHVuaXQgPSBcIiVpZ25vcmVcIlxubGV0IHN0cmluZ19vZl9ib29sID0gc3RyaW5nX29mX2Jvb2xcbmxldCBib29sX29mX3N0cmluZyA9IGJvb2xfb2Zfc3RyaW5nXG5sZXQgYm9vbF9vZl9zdHJpbmdfb3B0ID0gYm9vbF9vZl9zdHJpbmdfb3B0XG5sZXQgc3RyaW5nX29mX2ludCA9IHN0cmluZ19vZl9pbnRcbmV4dGVybmFsIGludF9vZl9zdHJpbmcgOiBzdHJpbmcgLT4gaW50ID0gXCJjYW1sX2ludF9vZl9zdHJpbmdcIlxubGV0IGludF9vZl9zdHJpbmdfb3B0ID0gaW50X29mX3N0cmluZ19vcHRcbmxldCBzdHJpbmdfb2ZfZmxvYXQgPSBzdHJpbmdfb2ZfZmxvYXRcbmV4dGVybmFsIGZsb2F0X29mX3N0cmluZyA6IHN0cmluZyAtPiBmbG9hdCA9IFwiY2FtbF9mbG9hdF9vZl9zdHJpbmdcIlxubGV0IGZsb2F0X29mX3N0cmluZ19vcHQgPSBmbG9hdF9vZl9zdHJpbmdfb3B0XG5leHRlcm5hbCBmc3QgOiAnYSAqICdiIC0+ICdhID0gXCIlZmllbGQwXCJcbmV4dGVybmFsIHNuZCA6ICdhICogJ2IgLT4gJ2IgPSBcIiVmaWVsZDFcIlxubGV0ICggQCApICA9ICggQCApXG50eXBlIG5vbnJlYyBpbl9jaGFubmVsID0gaW5fY2hhbm5lbFxudHlwZSBub25yZWMgb3V0X2NoYW5uZWwgPSBvdXRfY2hhbm5lbFxubGV0IHN0ZGluID0gc3RkaW5cbmxldCBzdGRvdXQgPSBzdGRvdXRcbmxldCBzdGRlcnIgPSBzdGRlcnJcbmxldCBwcmludF9jaGFyID0gcHJpbnRfY2hhclxubGV0IHByaW50X3N0cmluZyA9IHByaW50X3N0cmluZ1xubGV0IHByaW50X2J5dGVzID0gcHJpbnRfYnl0ZXNcbmxldCBwcmludF9pbnQgPSBwcmludF9pbnRcbmxldCBwcmludF9mbG9hdCA9IHByaW50X2Zsb2F0XG5sZXQgcHJpbnRfZW5kbGluZSA9IHByaW50X2VuZGxpbmVcbmxldCBwcmludF9uZXdsaW5lID0gcHJpbnRfbmV3bGluZVxubGV0IHByZXJyX2NoYXIgPSBwcmVycl9jaGFyXG5sZXQgcHJlcnJfc3RyaW5nID0gcHJlcnJfc3RyaW5nXG5sZXQgcHJlcnJfYnl0ZXMgPSBwcmVycl9ieXRlc1xubGV0IHByZXJyX2ludCA9IHByZXJyX2ludFxubGV0IHByZXJyX2Zsb2F0ID0gcHJlcnJfZmxvYXRcbmxldCBwcmVycl9lbmRsaW5lID0gcHJlcnJfZW5kbGluZVxubGV0IHByZXJyX25ld2xpbmUgPSBwcmVycl9uZXdsaW5lXG5sZXQgcmVhZF9saW5lID0gcmVhZF9saW5lXG5sZXQgcmVhZF9pbnQgPSByZWFkX2ludFxubGV0IHJlYWRfaW50X29wdCA9IHJlYWRfaW50X29wdFxubGV0IHJlYWRfZmxvYXQgPSByZWFkX2Zsb2F0XG5sZXQgcmVhZF9mbG9hdF9vcHQgPSByZWFkX2Zsb2F0X29wdFxudHlwZSBub25yZWMgb3Blbl9mbGFnID0gb3Blbl9mbGFnID1cbiAgICBPcGVuX3Jkb25seVxuICB8IE9wZW5fd3Jvbmx5XG4gIHwgT3Blbl9hcHBlbmRcbiAgfCBPcGVuX2NyZWF0XG4gIHwgT3Blbl90cnVuY1xuICB8IE9wZW5fZXhjbFxuICB8IE9wZW5fYmluYXJ5XG4gIHwgT3Blbl90ZXh0XG4gIHwgT3Blbl9ub25ibG9ja1xubGV0IG9wZW5fb3V0ID0gb3Blbl9vdXRcbmxldCBvcGVuX291dF9iaW4gPSBvcGVuX291dF9iaW5cbmxldCBvcGVuX291dF9nZW4gPSBvcGVuX291dF9nZW5cbmxldCBmbHVzaCA9IGZsdXNoXG5sZXQgZmx1c2hfYWxsID0gZmx1c2hfYWxsXG5sZXQgb3V0cHV0X2NoYXIgPSBvdXRwdXRfY2hhclxubGV0IG91dHB1dF9zdHJpbmcgPSBvdXRwdXRfc3RyaW5nXG5sZXQgb3V0cHV0X2J5dGVzID0gb3V0cHV0X2J5dGVzXG5sZXQgb3V0cHV0ID0gb3V0cHV0XG5sZXQgb3V0cHV0X3N1YnN0cmluZyA9IG91dHB1dF9zdWJzdHJpbmdcbmxldCBvdXRwdXRfYnl0ZSA9IG91dHB1dF9ieXRlXG5sZXQgb3V0cHV0X2JpbmFyeV9pbnQgPSBvdXRwdXRfYmluYXJ5X2ludFxubGV0IG91dHB1dF92YWx1ZSA9IG91dHB1dF92YWx1ZVxubGV0IHNlZWtfb3V0ID0gc2Vla19vdXRcbmxldCBwb3Nfb3V0ID0gcG9zX291dFxubGV0IG91dF9jaGFubmVsX2xlbmd0aCA9IG91dF9jaGFubmVsX2xlbmd0aFxubGV0IGNsb3NlX291dCA9IGNsb3NlX291dFxubGV0IGNsb3NlX291dF9ub2VyciA9IGNsb3NlX291dF9ub2VyclxubGV0IHNldF9iaW5hcnlfbW9kZV9vdXQgPSBzZXRfYmluYXJ5X21vZGVfb3V0XG5sZXQgb3Blbl9pbiA9IG9wZW5faW5cbmxldCBvcGVuX2luX2JpbiA9IG9wZW5faW5fYmluXG5sZXQgb3Blbl9pbl9nZW4gPSBvcGVuX2luX2dlblxubGV0IGlucHV0X2NoYXIgPSBpbnB1dF9jaGFyXG5sZXQgaW5wdXRfbGluZSA9IGlucHV0X2xpbmVcbmxldCBpbnB1dCA9IGlucHV0XG5sZXQgcmVhbGx5X2lucHV0ID0gcmVhbGx5X2lucHV0XG5sZXQgcmVhbGx5X2lucHV0X3N0cmluZyA9IHJlYWxseV9pbnB1dF9zdHJpbmdcbmxldCBpbnB1dF9ieXRlID0gaW5wdXRfYnl0ZVxubGV0IGlucHV0X2JpbmFyeV9pbnQgPSBpbnB1dF9iaW5hcnlfaW50XG5sZXQgaW5wdXRfdmFsdWUgPSBpbnB1dF92YWx1ZVxubGV0IHNlZWtfaW4gPSBzZWVrX2luXG5sZXQgcG9zX2luID0gcG9zX2luXG5sZXQgaW5fY2hhbm5lbF9sZW5ndGggPSBpbl9jaGFubmVsX2xlbmd0aFxubGV0IGNsb3NlX2luID0gY2xvc2VfaW5cbmxldCBjbG9zZV9pbl9ub2VyciA9IGNsb3NlX2luX25vZXJyXG5sZXQgc2V0X2JpbmFyeV9tb2RlX2luID0gc2V0X2JpbmFyeV9tb2RlX2luXG5tb2R1bGUgTGFyZ2VGaWxlID0gTGFyZ2VGaWxlXG50eXBlIG5vbnJlYyAnYSByZWYgPSAnYSByZWYgPSB7IG11dGFibGUgY29udGVudHMgOiAnYSB9XG5leHRlcm5hbCByZWYgOiAnYSAtPiAnYSByZWYgPSBcIiVtYWtlbXV0YWJsZVwiXG5leHRlcm5hbCAoICEgKSA6ICdhIHJlZiAtPiAnYSA9IFwiJWZpZWxkMFwiXG5leHRlcm5hbCAoIDo9ICkgOiAnYSByZWYgLT4gJ2EgLT4gdW5pdCA9IFwiJXNldGZpZWxkMFwiXG5leHRlcm5hbCBpbmNyIDogaW50IHJlZiAtPiB1bml0ID0gXCIlaW5jclwiXG5leHRlcm5hbCBkZWNyIDogaW50IHJlZiAtPiB1bml0ID0gXCIlZGVjclwiXG50eXBlIG5vbnJlYyAoJ2EsJ2IpIHJlc3VsdCA9ICgnYSwnYikgcmVzdWx0ID0gT2sgb2YgJ2EgfCBFcnJvciBvZiAnYlxudHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiA9XG4gICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3MuZm9ybWF0NlxudHlwZSAoJ2EsICdiLCAnYywgJ2QpIGZvcm1hdDQgPSAoJ2EsICdiLCAnYywgJ2MsICdjLCAnZCkgZm9ybWF0NlxudHlwZSAoJ2EsICdiLCAnYykgZm9ybWF0ID0gKCdhLCAnYiwgJ2MsICdjKSBmb3JtYXQ0XG5sZXQgc3RyaW5nX29mX2Zvcm1hdCA9IHN0cmluZ19vZl9mb3JtYXRcbmV4dGVybmFsIGZvcm1hdF9vZl9zdHJpbmcgOlxuICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiAtPlxuICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiA9IFwiJWlkZW50aXR5XCJcbmxldCAoIF5eICkgPSAoIF5eIClcbmxldCBleGl0ID0gZXhpdFxubGV0IGF0X2V4aXQgPSBhdF9leGl0XG5sZXQgdmFsaWRfZmxvYXRfbGV4ZW0gPSB2YWxpZF9mbG9hdF9sZXhlbVxubGV0IGRvX2F0X2V4aXQgPSBkb19hdF9leGl0XG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgIEdhYnJpZWwgU2NoZXJlciwgcHJvamV0IFBhcnNpZmFsLCBJTlJJQSBTYWNsYXkgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE5IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUgKCdhLCAnYikgdCA9IExlZnQgb2YgJ2EgfCBSaWdodCBvZiAnYlxuXG5sZXQgbGVmdCB2ID0gTGVmdCB2XG5sZXQgcmlnaHQgdiA9IFJpZ2h0IHZcblxubGV0IGlzX2xlZnQgPSBmdW5jdGlvblxufCBMZWZ0IF8gLT4gdHJ1ZVxufCBSaWdodCBfIC0+IGZhbHNlXG5cbmxldCBpc19yaWdodCA9IGZ1bmN0aW9uXG58IExlZnQgXyAtPiBmYWxzZVxufCBSaWdodCBfIC0+IHRydWVcblxubGV0IGZpbmRfbGVmdCA9IGZ1bmN0aW9uXG58IExlZnQgdiAtPiBTb21lIHZcbnwgUmlnaHQgXyAtPiBOb25lXG5cbmxldCBmaW5kX3JpZ2h0ID0gZnVuY3Rpb25cbnwgTGVmdCBfIC0+IE5vbmVcbnwgUmlnaHQgdiAtPiBTb21lIHZcblxubGV0IG1hcF9sZWZ0IGYgPSBmdW5jdGlvblxufCBMZWZ0IHYgLT4gTGVmdCAoZiB2KVxufCBSaWdodCBfIGFzIGUgLT4gZVxuXG5sZXQgbWFwX3JpZ2h0IGYgPSBmdW5jdGlvblxufCBMZWZ0IF8gYXMgZSAtPiBlXG58IFJpZ2h0IHYgLT4gUmlnaHQgKGYgdilcblxubGV0IG1hcCB+bGVmdCB+cmlnaHQgPSBmdW5jdGlvblxufCBMZWZ0IHYgLT4gTGVmdCAobGVmdCB2KVxufCBSaWdodCB2IC0+IFJpZ2h0IChyaWdodCB2KVxuXG5sZXQgZm9sZCB+bGVmdCB+cmlnaHQgPSBmdW5jdGlvblxufCBMZWZ0IHYgLT4gbGVmdCB2XG58IFJpZ2h0IHYgLT4gcmlnaHQgdlxuXG5sZXQgaXRlciA9IGZvbGRcblxubGV0IGZvcl9hbGwgPSBmb2xkXG5cbmxldCBlcXVhbCB+bGVmdCB+cmlnaHQgZTEgZTIgPSBtYXRjaCBlMSwgZTIgd2l0aFxufCBMZWZ0IHYxLCBMZWZ0IHYyIC0+IGxlZnQgdjEgdjJcbnwgUmlnaHQgdjEsIFJpZ2h0IHYyIC0+IHJpZ2h0IHYxIHYyXG58IExlZnQgXywgUmlnaHQgXyB8IFJpZ2h0IF8sIExlZnQgXyAtPiBmYWxzZVxuXG5sZXQgY29tcGFyZSB+bGVmdCB+cmlnaHQgZTEgZTIgPSBtYXRjaCBlMSwgZTIgd2l0aFxufCBMZWZ0IHYxLCBMZWZ0IHYyIC0+IGxlZnQgdjEgdjJcbnwgUmlnaHQgdjEsIFJpZ2h0IHYyIC0+IHJpZ2h0IHYxIHYyXG58IExlZnQgXywgUmlnaHQgXyAtPiAoLTEpXG58IFJpZ2h0IF8sIExlZnQgXyAtPiAxXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIE9wZXJhdGlvbnMgb24gaW50ZXJuYWwgcmVwcmVzZW50YXRpb25zIG9mIHZhbHVlcyAqKVxuXG50eXBlIHRcblxudHlwZSByYXdfZGF0YSA9IG5hdGl2ZWludFxuXG5leHRlcm5hbCByZXByIDogJ2EgLT4gdCA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIG9iaiA6IHQgLT4gJ2EgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCBtYWdpYyA6ICdhIC0+ICdiID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgaXNfaW50IDogdCAtPiBib29sID0gXCIlb2JqX2lzX2ludFwiXG5sZXQgW0BpbmxpbmUgYWx3YXlzXSBpc19ibG9jayBhID0gbm90IChpc19pbnQgYSlcbmV4dGVybmFsIHRhZyA6IHQgLT4gaW50ID0gXCJjYW1sX29ial90YWdcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgc2V0X3RhZyA6IHQgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfb2JqX3NldF90YWdcIlxuZXh0ZXJuYWwgc2l6ZSA6IHQgLT4gaW50ID0gXCIlb2JqX3NpemVcIlxuZXh0ZXJuYWwgcmVhY2hhYmxlX3dvcmRzIDogdCAtPiBpbnQgPSBcImNhbWxfb2JqX3JlYWNoYWJsZV93b3Jkc1wiXG5leHRlcm5hbCBmaWVsZCA6IHQgLT4gaW50IC0+IHQgPSBcIiVvYmpfZmllbGRcIlxuZXh0ZXJuYWwgc2V0X2ZpZWxkIDogdCAtPiBpbnQgLT4gdCAtPiB1bml0ID0gXCIlb2JqX3NldF9maWVsZFwiXG5leHRlcm5hbCBmbG9hdGFycmF5X2dldCA6IGZsb2F0YXJyYXkgLT4gaW50IC0+IGZsb2F0ID0gXCJjYW1sX2Zsb2F0YXJyYXlfZ2V0XCJcbmV4dGVybmFsIGZsb2F0YXJyYXlfc2V0IDpcbiAgICBmbG9hdGFycmF5IC0+IGludCAtPiBmbG9hdCAtPiB1bml0ID0gXCJjYW1sX2Zsb2F0YXJyYXlfc2V0XCJcbmxldCBbQGlubGluZSBhbHdheXNdIGRvdWJsZV9maWVsZCB4IGkgPSBmbG9hdGFycmF5X2dldCAob2JqIHggOiBmbG9hdGFycmF5KSBpXG5sZXQgW0BpbmxpbmUgYWx3YXlzXSBzZXRfZG91YmxlX2ZpZWxkIHggaSB2ID1cbiAgZmxvYXRhcnJheV9zZXQgKG9iaiB4IDogZmxvYXRhcnJheSkgaSB2XG5leHRlcm5hbCByYXdfZmllbGQgOiB0IC0+IGludCAtPiByYXdfZGF0YSA9IFwiY2FtbF9vYmpfcmF3X2ZpZWxkXCJcbmV4dGVybmFsIHNldF9yYXdfZmllbGQgOiB0IC0+IGludCAtPiByYXdfZGF0YSAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9vYmpfc2V0X3Jhd19maWVsZFwiXG5cbmV4dGVybmFsIG5ld19ibG9jayA6IGludCAtPiBpbnQgLT4gdCA9IFwiY2FtbF9vYmpfYmxvY2tcIlxuZXh0ZXJuYWwgZHVwIDogdCAtPiB0ID0gXCJjYW1sX29ial9kdXBcIlxuZXh0ZXJuYWwgdHJ1bmNhdGUgOiB0IC0+IGludCAtPiB1bml0ID0gXCJjYW1sX29ial90cnVuY2F0ZVwiXG5leHRlcm5hbCBhZGRfb2Zmc2V0IDogdCAtPiBJbnQzMi50IC0+IHQgPSBcImNhbWxfb2JqX2FkZF9vZmZzZXRcIlxuZXh0ZXJuYWwgd2l0aF90YWcgOiBpbnQgLT4gdCAtPiB0ID0gXCJjYW1sX29ial93aXRoX3RhZ1wiXG5cbmxldCBmaXJzdF9ub25fY29uc3RhbnRfY29uc3RydWN0b3JfdGFnID0gMFxubGV0IGxhc3Rfbm9uX2NvbnN0YW50X2NvbnN0cnVjdG9yX3RhZyA9IDI0NVxuXG5sZXQgbGF6eV90YWcgPSAyNDZcbmxldCBjbG9zdXJlX3RhZyA9IDI0N1xubGV0IG9iamVjdF90YWcgPSAyNDhcbmxldCBpbmZpeF90YWcgPSAyNDlcbmxldCBmb3J3YXJkX3RhZyA9IDI1MFxuXG5sZXQgbm9fc2Nhbl90YWcgPSAyNTFcblxubGV0IGFic3RyYWN0X3RhZyA9IDI1MVxubGV0IHN0cmluZ190YWcgPSAyNTJcbmxldCBkb3VibGVfdGFnID0gMjUzXG5sZXQgZG91YmxlX2FycmF5X3RhZyA9IDI1NFxubGV0IGN1c3RvbV90YWcgPSAyNTVcbmxldCBmaW5hbF90YWcgPSBjdXN0b21fdGFnXG5cblxubGV0IGludF90YWcgPSAxMDAwXG5sZXQgb3V0X29mX2hlYXBfdGFnID0gMTAwMVxubGV0IHVuYWxpZ25lZF90YWcgPSAxMDAyXG5cbm1vZHVsZSBDbG9zdXJlID0gc3RydWN0XG4gIHR5cGUgaW5mbyA9IHtcbiAgICBhcml0eTogaW50O1xuICAgIHN0YXJ0X2VudjogaW50O1xuICB9XG5cbiAgbGV0IGluZm9fb2ZfcmF3IChpbmZvIDogbmF0aXZlaW50KSA9XG4gICAgbGV0IG9wZW4gTmF0aXZlaW50IGluXG4gICAgbGV0IGFyaXR5ID1cbiAgICAgICgqIHNpZ25lZDogbmVnYXRpdmUgZm9yIHR1cGxlZCBmdW5jdGlvbnMgKilcbiAgICAgIGlmIFN5cy53b3JkX3NpemUgPSA2NCB0aGVuXG4gICAgICAgIHRvX2ludCAoc2hpZnRfcmlnaHQgaW5mbyA1NilcbiAgICAgIGVsc2VcbiAgICAgICAgdG9faW50IChzaGlmdF9yaWdodCBpbmZvIDI0KVxuICAgIGluXG4gICAgbGV0IHN0YXJ0X2VudiA9XG4gICAgICAoKiBzdGFydF9lbnYgaXMgdW5zaWduZWQsIGJ1dCB3ZSBrbm93IGl0IGNhbiBhbHdheXMgZml0IGFuIE9DYW1sXG4gICAgICAgICBpbnRlZ2VyIHNvIHdlIHVzZSBbdG9faW50XSBpbnN0ZWFkIG9mIFt1bnNpZ25lZF90b19pbnRdLiAqKVxuICAgICAgdG9faW50IChzaGlmdF9yaWdodF9sb2dpY2FsIChzaGlmdF9sZWZ0IGluZm8gOCkgOSkgaW5cbiAgICB7IGFyaXR5OyBzdGFydF9lbnYgfVxuXG4gICgqIG5vdGU6IHdlIGV4cGVjdCBhIGNsb3N1cmUsIG5vdCBhbiBpbmZpeCBwb2ludGVyICopXG4gIGxldCBpbmZvIChvYmogOiB0KSA9XG4gICAgYXNzZXJ0ICh0YWcgb2JqID0gY2xvc3VyZV90YWcpO1xuICAgIGluZm9fb2ZfcmF3IChyYXdfZmllbGQgb2JqIDEpXG5lbmRcblxubW9kdWxlIEV4dGVuc2lvbl9jb25zdHJ1Y3RvciA9XG5zdHJ1Y3RcbiAgdHlwZSB0ID0gZXh0ZW5zaW9uX2NvbnN0cnVjdG9yXG4gIGxldCBvZl92YWwgeCA9XG4gICAgbGV0IHggPSByZXByIHggaW5cbiAgICBsZXQgc2xvdCA9XG4gICAgICBpZiAoaXNfYmxvY2sgeCkgJiYgKHRhZyB4KSA8PiBvYmplY3RfdGFnICYmIChzaXplIHgpID49IDEgdGhlbiBmaWVsZCB4IDBcbiAgICAgIGVsc2UgeFxuICAgIGluXG4gICAgbGV0IG5hbWUgPVxuICAgICAgaWYgKGlzX2Jsb2NrIHNsb3QpICYmICh0YWcgc2xvdCkgPSBvYmplY3RfdGFnIHRoZW4gZmllbGQgc2xvdCAwXG4gICAgICBlbHNlIGludmFsaWRfYXJnIFwiT2JqLmV4dGVuc2lvbl9jb25zdHJ1Y3RvclwiXG4gICAgaW5cbiAgICAgIGlmICh0YWcgbmFtZSkgPSBzdHJpbmdfdGFnIHRoZW4gKG9iaiBzbG90IDogdClcbiAgICAgIGVsc2UgaW52YWxpZF9hcmcgXCJPYmouZXh0ZW5zaW9uX2NvbnN0cnVjdG9yXCJcblxuICBsZXQgW0BpbmxpbmUgYWx3YXlzXSBuYW1lIChzbG90IDogdCkgPVxuICAgIChvYmogKGZpZWxkIChyZXByIHNsb3QpIDApIDogc3RyaW5nKVxuXG4gIGxldCBbQGlubGluZSBhbHdheXNdIGlkIChzbG90IDogdCkgPVxuICAgIChvYmogKGZpZWxkIChyZXByIHNsb3QpIDEpIDogaW50KVxuZW5kXG5cbmxldCBleHRlbnNpb25fY29uc3RydWN0b3IgPSBFeHRlbnNpb25fY29uc3RydWN0b3Iub2ZfdmFsXG5sZXQgZXh0ZW5zaW9uX25hbWUgPSBFeHRlbnNpb25fY29uc3RydWN0b3IubmFtZVxubGV0IGV4dGVuc2lvbl9pZCA9IEV4dGVuc2lvbl9jb25zdHJ1Y3Rvci5pZFxuXG5tb2R1bGUgRXBoZW1lcm9uID0gc3RydWN0XG4gIHR5cGUgb2JqX3QgPSB0XG5cbiAgdHlwZSB0ICgqKiBlcGhlbWVyb24gKilcblxuICAgKCoqIFRvIGNoYW5nZSBpbiBzeW5jIHdpdGggd2Vhay5oICopXG4gIGxldCBhZGRpdGlvbmFsX3ZhbHVlcyA9IDJcbiAgbGV0IG1heF9lcGhlX2xlbmd0aCA9IFN5cy5tYXhfYXJyYXlfbGVuZ3RoIC0gYWRkaXRpb25hbF92YWx1ZXNcblxuICBleHRlcm5hbCBjcmVhdGUgOiBpbnQgLT4gdCA9IFwiY2FtbF9lcGhlX2NyZWF0ZVwiOztcbiAgbGV0IGNyZWF0ZSBsID1cbiAgICBpZiBub3QgKDAgPD0gbCAmJiBsIDw9IG1heF9lcGhlX2xlbmd0aCkgdGhlblxuICAgICAgaW52YWxpZF9hcmcgXCJPYmouRXBoZW1lcm9uLmNyZWF0ZVwiO1xuICAgIGNyZWF0ZSBsXG5cbiAgbGV0IGxlbmd0aCB4ID0gc2l6ZShyZXByIHgpIC0gYWRkaXRpb25hbF92YWx1ZXNcblxuICBsZXQgcmFpc2VfaWZfaW52YWxpZF9vZmZzZXQgZSBvIG1zZyA9XG4gICAgaWYgbm90ICgwIDw9IG8gJiYgbyA8IGxlbmd0aCBlKSB0aGVuXG4gICAgICBpbnZhbGlkX2FyZyBtc2dcblxuICBleHRlcm5hbCBnZXRfa2V5OiB0IC0+IGludCAtPiBvYmpfdCBvcHRpb24gPSBcImNhbWxfZXBoZV9nZXRfa2V5XCJcbiAgbGV0IGdldF9rZXkgZSBvID1cbiAgICByYWlzZV9pZl9pbnZhbGlkX29mZnNldCBlIG8gXCJPYmouRXBoZW1lcm9uLmdldF9rZXlcIjtcbiAgICBnZXRfa2V5IGUgb1xuXG4gIGV4dGVybmFsIGdldF9rZXlfY29weTogdCAtPiBpbnQgLT4gb2JqX3Qgb3B0aW9uID0gXCJjYW1sX2VwaGVfZ2V0X2tleV9jb3B5XCJcbiAgbGV0IGdldF9rZXlfY29weSBlIG8gPVxuICAgIHJhaXNlX2lmX2ludmFsaWRfb2Zmc2V0IGUgbyBcIk9iai5FcGhlbWVyb24uZ2V0X2tleV9jb3B5XCI7XG4gICAgZ2V0X2tleV9jb3B5IGUgb1xuXG4gIGV4dGVybmFsIHNldF9rZXk6IHQgLT4gaW50IC0+IG9ial90IC0+IHVuaXQgPSBcImNhbWxfZXBoZV9zZXRfa2V5XCJcbiAgbGV0IHNldF9rZXkgZSBvIHggPVxuICAgIHJhaXNlX2lmX2ludmFsaWRfb2Zmc2V0IGUgbyBcIk9iai5FcGhlbWVyb24uc2V0X2tleVwiO1xuICAgIHNldF9rZXkgZSBvIHhcblxuICBleHRlcm5hbCB1bnNldF9rZXk6IHQgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfZXBoZV91bnNldF9rZXlcIlxuICBsZXQgdW5zZXRfa2V5IGUgbyA9XG4gICAgcmFpc2VfaWZfaW52YWxpZF9vZmZzZXQgZSBvIFwiT2JqLkVwaGVtZXJvbi51bnNldF9rZXlcIjtcbiAgICB1bnNldF9rZXkgZSBvXG5cbiAgZXh0ZXJuYWwgY2hlY2tfa2V5OiB0IC0+IGludCAtPiBib29sID0gXCJjYW1sX2VwaGVfY2hlY2tfa2V5XCJcbiAgbGV0IGNoZWNrX2tleSBlIG8gPVxuICAgIHJhaXNlX2lmX2ludmFsaWRfb2Zmc2V0IGUgbyBcIk9iai5FcGhlbWVyb24uY2hlY2tfa2V5XCI7XG4gICAgY2hlY2tfa2V5IGUgb1xuXG4gIGV4dGVybmFsIGJsaXRfa2V5IDogdCAtPiBpbnQgLT4gdCAtPiBpbnQgLT4gaW50IC0+IHVuaXRcbiAgICA9IFwiY2FtbF9lcGhlX2JsaXRfa2V5XCJcblxuICBsZXQgYmxpdF9rZXkgZTEgbzEgZTIgbzIgbCA9XG4gICAgaWYgbCA8IDAgfHwgbzEgPCAwIHx8IG8xID4gbGVuZ3RoIGUxIC0gbFxuICAgICAgIHx8IG8yIDwgMCB8fCBvMiA+IGxlbmd0aCBlMiAtIGxcbiAgICB0aGVuIGludmFsaWRfYXJnIFwiT2JqLkVwaGVtZXJvbi5ibGl0X2tleVwiXG4gICAgZWxzZSBpZiBsIDw+IDAgdGhlbiBibGl0X2tleSBlMSBvMSBlMiBvMiBsXG5cbiAgZXh0ZXJuYWwgZ2V0X2RhdGE6IHQgLT4gb2JqX3Qgb3B0aW9uID0gXCJjYW1sX2VwaGVfZ2V0X2RhdGFcIlxuICBleHRlcm5hbCBnZXRfZGF0YV9jb3B5OiB0IC0+IG9ial90IG9wdGlvbiA9IFwiY2FtbF9lcGhlX2dldF9kYXRhX2NvcHlcIlxuICBleHRlcm5hbCBzZXRfZGF0YTogdCAtPiBvYmpfdCAtPiB1bml0ID0gXCJjYW1sX2VwaGVfc2V0X2RhdGFcIlxuICBleHRlcm5hbCB1bnNldF9kYXRhOiB0IC0+IHVuaXQgPSBcImNhbWxfZXBoZV91bnNldF9kYXRhXCJcbiAgZXh0ZXJuYWwgY2hlY2tfZGF0YTogdCAtPiBib29sID0gXCJjYW1sX2VwaGVfY2hlY2tfZGF0YVwiXG4gIGV4dGVybmFsIGJsaXRfZGF0YSA6IHQgLT4gdCAtPiB1bml0ID0gXCJjYW1sX2VwaGVfYmxpdF9kYXRhXCJcblxuZW5kXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBEYW1pZW4gRG9saWdleiwgcHJvamV0IFBhcmEsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk3IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIEludGVybmFscyBvZiBmb3JjaW5nIGxhenkgdmFsdWVzLiAqKVxuXG50eXBlICdhIHQgPSAnYSBsYXp5X3RcblxuZXhjZXB0aW9uIFVuZGVmaW5lZFxuXG5sZXQgcmFpc2VfdW5kZWZpbmVkID0gT2JqLnJlcHIgKGZ1biAoKSAtPiByYWlzZSBVbmRlZmluZWQpXG5cbmV4dGVybmFsIG1ha2VfZm9yd2FyZCA6IE9iai50IC0+IE9iai50IC0+IHVuaXQgPSBcImNhbWxfb2JqX21ha2VfZm9yd2FyZFwiXG5cbigqIEFzc3VtZSBbYmxrXSBpcyBhIGJsb2NrIHdpdGggdGFnIGxhenkgKilcbmxldCBmb3JjZV9sYXp5X2Jsb2NrIChibGsgOiAnYXJnIGxhenlfdCkgPVxuICBsZXQgY2xvc3VyZSA9IChPYmoub2JqIChPYmouZmllbGQgKE9iai5yZXByIGJsaykgMCkgOiB1bml0IC0+ICdhcmcpIGluXG4gIE9iai5zZXRfZmllbGQgKE9iai5yZXByIGJsaykgMCByYWlzZV91bmRlZmluZWQ7XG4gIHRyeVxuICAgIGxldCByZXN1bHQgPSBjbG9zdXJlICgpIGluXG4gICAgbWFrZV9mb3J3YXJkIChPYmoucmVwciBibGspIChPYmoucmVwciByZXN1bHQpO1xuICAgIHJlc3VsdFxuICB3aXRoIGUgLT5cbiAgICBPYmouc2V0X2ZpZWxkIChPYmoucmVwciBibGspIDAgKE9iai5yZXByIChmdW4gKCkgLT4gcmFpc2UgZSkpO1xuICAgIHJhaXNlIGVcblxuXG4oKiBBc3N1bWUgW2Jsa10gaXMgYSBibG9jayB3aXRoIHRhZyBsYXp5ICopXG5sZXQgZm9yY2VfdmFsX2xhenlfYmxvY2sgKGJsayA6ICdhcmcgbGF6eV90KSA9XG4gIGxldCBjbG9zdXJlID0gKE9iai5vYmogKE9iai5maWVsZCAoT2JqLnJlcHIgYmxrKSAwKSA6IHVuaXQgLT4gJ2FyZykgaW5cbiAgT2JqLnNldF9maWVsZCAoT2JqLnJlcHIgYmxrKSAwIHJhaXNlX3VuZGVmaW5lZDtcbiAgbGV0IHJlc3VsdCA9IGNsb3N1cmUgKCkgaW5cbiAgbWFrZV9mb3J3YXJkIChPYmoucmVwciBibGspIChPYmoucmVwciByZXN1bHQpO1xuICByZXN1bHRcblxuXG4oKiBbZm9yY2VdIGlzIG5vdCB1c2VkLCBzaW5jZSBbTGF6eS5mb3JjZV0gaXMgZGVjbGFyZWQgYXMgYSBwcmltaXRpdmVcbiAgIHdob3NlIGNvZGUgaW5saW5lcyB0aGUgdGFnIHRlc3RzIG9mIGl0cyBhcmd1bWVudCwgZXhjZXB0IHdoZW4gYWZsXG4gICBpbnN0cnVtZW50YXRpb24gaXMgdHVybmVkIG9uLiAqKVxuXG5sZXQgZm9yY2UgKGx6diA6ICdhcmcgbGF6eV90KSA9XG4gICgqIFVzaW5nIFtTeXMub3BhcXVlX2lkZW50aXR5XSBwcmV2ZW50cyB0d28gcG90ZW50aWFsIHByb2JsZW1zOlxuICAgICAtIElmIHRoZSB2YWx1ZSBpcyBrbm93biB0byBoYXZlIEZvcndhcmRfdGFnLCB0aGVuIGl0cyB0YWcgY291bGQgaGF2ZVxuICAgICAgIGNoYW5nZWQgZHVyaW5nIEdDLCBzbyB0aGF0IGluZm9ybWF0aW9uIG11c3QgYmUgZm9yZ290dGVuIChzZWUgR1BSIzcxM1xuICAgICAgIGFuZCBpc3N1ZSAjNzMwMSlcbiAgICAgLSBJZiB0aGUgdmFsdWUgaXMga25vd24gdG8gYmUgaW1tdXRhYmxlLCB0aGVuIGlmIHRoZSBjb21waWxlclxuICAgICAgIGNhbm5vdCBwcm92ZSB0aGF0IHRoZSBsYXN0IGJyYW5jaCBpcyBub3QgdGFrZW4gaXQgd2lsbCBpc3N1ZSBhXG4gICAgICAgd2FybmluZyA1OSAobW9kaWZpY2F0aW9uIG9mIGFuIGltbXV0YWJsZSB2YWx1ZSkgKilcbiAgbGV0IGx6diA9IFN5cy5vcGFxdWVfaWRlbnRpdHkgbHp2IGluXG4gIGxldCB4ID0gT2JqLnJlcHIgbHp2IGluXG4gIGxldCB0ID0gT2JqLnRhZyB4IGluXG4gIGlmIHQgPSBPYmouZm9yd2FyZF90YWcgdGhlbiAoT2JqLm9iaiAoT2JqLmZpZWxkIHggMCkgOiAnYXJnKSBlbHNlXG4gIGlmIHQgPD4gT2JqLmxhenlfdGFnIHRoZW4gKE9iai5vYmogeCA6ICdhcmcpXG4gIGVsc2UgZm9yY2VfbGF6eV9ibG9jayBsenZcblxuXG5sZXQgZm9yY2VfdmFsIChsenYgOiAnYXJnIGxhenlfdCkgPVxuICBsZXQgeCA9IE9iai5yZXByIGx6diBpblxuICBsZXQgdCA9IE9iai50YWcgeCBpblxuICBpZiB0ID0gT2JqLmZvcndhcmRfdGFnIHRoZW4gKE9iai5vYmogKE9iai5maWVsZCB4IDApIDogJ2FyZykgZWxzZVxuICBpZiB0IDw+IE9iai5sYXp5X3RhZyB0aGVuIChPYmoub2JqIHggOiAnYXJnKVxuICBlbHNlIGZvcmNlX3ZhbF9sYXp5X2Jsb2NrIGx6dlxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgRGFtaWVuIERvbGlnZXosIHByb2pldCBQYXJhLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NyBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBNb2R1bGUgW0xhenldOiBkZWZlcnJlZCBjb21wdXRhdGlvbnMgKilcblxuXG4oKlxuICAgV0FSTklORzogc29tZSBwdXJwbGUgbWFnaWMgaXMgZ29pbmcgb24gaGVyZS4gIERvIG5vdCB0YWtlIHRoaXMgZmlsZVxuICAgYXMgYW4gZXhhbXBsZSBvZiBob3cgdG8gcHJvZ3JhbSBpbiBPQ2FtbC5cbiopXG5cblxuKCogV2UgbWFrZSB1c2Ugb2YgdHdvIHNwZWNpYWwgdGFncyBwcm92aWRlZCBieSB0aGUgcnVudGltZTpcbiAgIFtsYXp5X3RhZ10gYW5kIFtmb3J3YXJkX3RhZ10uXG5cbiAgIEEgdmFsdWUgb2YgdHlwZSBbJ2EgTGF6eS50XSBjYW4gYmUgb25lIG9mIHRocmVlIHRoaW5nczpcbiAgIDEuIEEgYmxvY2sgb2Ygc2l6ZSAxIHdpdGggdGFnIFtsYXp5X3RhZ10uICBJdHMgZmllbGQgaXMgYSBjbG9zdXJlIG9mXG4gICAgICB0eXBlIFt1bml0IC0+ICdhXSB0aGF0IGNvbXB1dGVzIHRoZSB2YWx1ZS5cbiAgIDIuIEEgYmxvY2sgb2Ygc2l6ZSAxIHdpdGggdGFnIFtmb3J3YXJkX3RhZ10uICBJdHMgZmllbGQgaXMgdGhlIHZhbHVlXG4gICAgICBvZiB0eXBlIFsnYV0gdGhhdCB3YXMgY29tcHV0ZWQuXG4gICAzLiBBbnl0aGluZyBlbHNlIGV4Y2VwdCBhIGZsb2F0LiAgVGhpcyBoYXMgdHlwZSBbJ2FdIGFuZCBpcyB0aGUgdmFsdWVcbiAgICAgIHRoYXQgd2FzIGNvbXB1dGVkLlxuICAgRXhjZXB0aW9ucyBhcmUgc3RvcmVkIGluIGZvcm1hdCAoMSkuXG4gICBUaGUgR0Mgd2lsbCBtYWdpY2FsbHkgY2hhbmdlIHRoaW5ncyBmcm9tICgyKSB0byAoMykgYWNjb3JkaW5nIHRvIGl0c1xuICAgZmFuY3kuXG5cbiAgIElmIE9DYW1sIHdhcyBjb25maWd1cmVkIHdpdGggdGhlIC1mbGF0LWZsb2F0LWFycmF5IG9wdGlvbiAod2hpY2ggaXNcbiAgIGN1cnJlbnRseSB0aGUgZGVmYXVsdCksIHRoZSBmb2xsb3dpbmcgaXMgYWxzbyB0cnVlOlxuICAgV2UgY2Fubm90IHVzZSByZXByZXNlbnRhdGlvbiAoMykgZm9yIGEgW2Zsb2F0IExhenkudF0gYmVjYXVzZVxuICAgW2NhbWxfbWFrZV9hcnJheV0gYXNzdW1lcyB0aGF0IG9ubHkgYSBbZmxvYXRdIHZhbHVlIGNhbiBoYXZlIHRhZ1xuICAgW0RvdWJsZV90YWddLlxuXG4gICBXZSBoYXZlIHRvIHVzZSB0aGUgYnVpbHQtaW4gdHlwZSBjb25zdHJ1Y3RvciBbbGF6eV90XSB0b1xuICAgbGV0IHRoZSBjb21waWxlciBpbXBsZW1lbnQgdGhlIHNwZWNpYWwgdHlwaW5nIGFuZCBjb21waWxhdGlvblxuICAgcnVsZXMgZm9yIHRoZSBbbGF6eV0ga2V5d29yZC5cbiopXG5cbnR5cGUgJ2EgdCA9ICdhIENhbWxpbnRlcm5hbExhenkudFxuXG5leGNlcHRpb24gVW5kZWZpbmVkID0gQ2FtbGludGVybmFsTGF6eS5VbmRlZmluZWRcblxuZXh0ZXJuYWwgbWFrZV9mb3J3YXJkIDogJ2EgLT4gJ2EgbGF6eV90ID0gXCJjYW1sX2xhenlfbWFrZV9mb3J3YXJkXCJcblxuZXh0ZXJuYWwgZm9yY2UgOiAnYSB0IC0+ICdhID0gXCIlbGF6eV9mb3JjZVwiXG5cblxubGV0IGZvcmNlX3ZhbCA9IENhbWxpbnRlcm5hbExhenkuZm9yY2VfdmFsXG5cbmxldCBmcm9tX2Z1biAoZiA6IHVuaXQgLT4gJ2FyZykgPVxuICBsZXQgeCA9IE9iai5uZXdfYmxvY2sgT2JqLmxhenlfdGFnIDEgaW5cbiAgT2JqLnNldF9maWVsZCB4IDAgKE9iai5yZXByIGYpO1xuICAoT2JqLm9iaiB4IDogJ2FyZyB0KVxuXG5sZXQgZnJvbV92YWwgKHYgOiAnYXJnKSA9XG4gIGxldCB0ID0gT2JqLnRhZyAoT2JqLnJlcHIgdikgaW5cbiAgaWYgdCA9IE9iai5mb3J3YXJkX3RhZyB8fCB0ID0gT2JqLmxhenlfdGFnIHx8IHQgPSBPYmouZG91YmxlX3RhZyB0aGVuIGJlZ2luXG4gICAgbWFrZV9mb3J3YXJkIHZcbiAgZW5kIGVsc2UgYmVnaW5cbiAgICAoT2JqLm1hZ2ljIHYgOiAnYXJnIHQpXG4gIGVuZFxuXG5cbmxldCBpc192YWwgKGwgOiAnYXJnIHQpID0gT2JqLnRhZyAoT2JqLnJlcHIgbCkgPD4gT2JqLmxhenlfdGFnXG5cbmxldCBsYXp5X2Zyb21fZnVuID0gZnJvbV9mdW5cblxubGV0IGxhenlfZnJvbV92YWwgPSBmcm9tX3ZhbFxuXG5sZXQgbGF6eV9pc192YWwgPSBpc192YWxcblxuXG5sZXQgbWFwIGYgeCA9XG4gIGxhenkgKGYgKGZvcmNlIHgpKVxuXG5sZXQgbWFwX3ZhbCBmIHggPVxuICBpZiBpc192YWwgeFxuICB0aGVuIGxhenlfZnJvbV92YWwgKGYgKGZvcmNlIHgpKVxuICBlbHNlIGxhenkgKGYgKGZvcmNlIHgpKVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgIFNpbW9uIENydWFuZXMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxNyBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBNb2R1bGUgW1NlcV06IGZ1bmN0aW9uYWwgaXRlcmF0b3JzICopXG5cbnR5cGUgKydhIG5vZGUgPVxuICB8IE5pbFxuICB8IENvbnMgb2YgJ2EgKiAnYSB0XG5cbmFuZCAnYSB0ID0gdW5pdCAtPiAnYSBub2RlXG5cbmxldCBlbXB0eSAoKSA9IE5pbFxuXG5sZXQgcmV0dXJuIHggKCkgPSBDb25zICh4LCBlbXB0eSlcblxubGV0IGNvbnMgeCBuZXh0ICgpID0gQ29ucyAoeCwgbmV4dClcblxubGV0IHJlYyBhcHBlbmQgc2VxMSBzZXEyICgpID1cbiAgbWF0Y2ggc2VxMSgpIHdpdGhcbiAgfCBOaWwgLT4gc2VxMigpXG4gIHwgQ29ucyAoeCwgbmV4dCkgLT4gQ29ucyAoeCwgYXBwZW5kIG5leHQgc2VxMilcblxubGV0IHJlYyBtYXAgZiBzZXEgKCkgPSBtYXRjaCBzZXEoKSB3aXRoXG4gIHwgTmlsIC0+IE5pbFxuICB8IENvbnMgKHgsIG5leHQpIC0+IENvbnMgKGYgeCwgbWFwIGYgbmV4dClcblxubGV0IHJlYyBmaWx0ZXJfbWFwIGYgc2VxICgpID0gbWF0Y2ggc2VxKCkgd2l0aFxuICB8IE5pbCAtPiBOaWxcbiAgfCBDb25zICh4LCBuZXh0KSAtPlxuICAgICAgbWF0Y2ggZiB4IHdpdGhcbiAgICAgICAgfCBOb25lIC0+IGZpbHRlcl9tYXAgZiBuZXh0ICgpXG4gICAgICAgIHwgU29tZSB5IC0+IENvbnMgKHksIGZpbHRlcl9tYXAgZiBuZXh0KVxuXG5sZXQgcmVjIGZpbHRlciBmIHNlcSAoKSA9IG1hdGNoIHNlcSgpIHdpdGhcbiAgfCBOaWwgLT4gTmlsXG4gIHwgQ29ucyAoeCwgbmV4dCkgLT5cbiAgICAgIGlmIGYgeFxuICAgICAgdGhlbiBDb25zICh4LCBmaWx0ZXIgZiBuZXh0KVxuICAgICAgZWxzZSBmaWx0ZXIgZiBuZXh0ICgpXG5cbmxldCByZWMgY29uY2F0IHNlcSAoKSA9IG1hdGNoIHNlcSAoKSB3aXRoXG4gIHwgTmlsIC0+IE5pbFxuICB8IENvbnMgKHgsIG5leHQpIC0+XG4gICAgIGFwcGVuZCB4IChjb25jYXQgbmV4dCkgKClcblxubGV0IHJlYyBmbGF0X21hcCBmIHNlcSAoKSA9IG1hdGNoIHNlcSAoKSB3aXRoXG4gIHwgTmlsIC0+IE5pbFxuICB8IENvbnMgKHgsIG5leHQpIC0+XG4gICAgYXBwZW5kIChmIHgpIChmbGF0X21hcCBmIG5leHQpICgpXG5cbmxldCBjb25jYXRfbWFwID0gZmxhdF9tYXBcblxubGV0IHJlYyBmb2xkX2xlZnQgZiBhY2Mgc2VxID1cbiAgbWF0Y2ggc2VxICgpIHdpdGhcbiAgICB8IE5pbCAtPiBhY2NcbiAgICB8IENvbnMgKHgsIG5leHQpIC0+XG4gICAgICAgIGxldCBhY2MgPSBmIGFjYyB4IGluXG4gICAgICAgIGZvbGRfbGVmdCBmIGFjYyBuZXh0XG5cbmxldCByZWMgaXRlciBmIHNlcSA9XG4gIG1hdGNoIHNlcSAoKSB3aXRoXG4gICAgfCBOaWwgLT4gKClcbiAgICB8IENvbnMgKHgsIG5leHQpIC0+XG4gICAgICAgIGYgeDtcbiAgICAgICAgaXRlciBmIG5leHRcblxubGV0IHJlYyB1bmZvbGQgZiB1ICgpID1cbiAgbWF0Y2ggZiB1IHdpdGhcbiAgfCBOb25lIC0+IE5pbFxuICB8IFNvbWUgKHgsIHUnKSAtPiBDb25zICh4LCB1bmZvbGQgZiB1JylcblxubGV0IGlzX2VtcHR5IHhzID1cbiAgbWF0Y2ggeHMoKSB3aXRoXG4gIHwgTmlsIC0+XG4gICAgICB0cnVlXG4gIHwgQ29ucyAoXywgXykgLT5cbiAgICAgIGZhbHNlXG5cbmxldCB1bmNvbnMgeHMgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgIFNvbWUgKHgsIHhzKVxuICB8IE5pbCAtPlxuICAgICAgTm9uZVxuXG5cblxubGV0IHJlYyBsZW5ndGhfYXV4IGFjY3UgeHMgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIGFjY3VcbiAgfCBDb25zIChfLCB4cykgLT5cbiAgICAgIGxlbmd0aF9hdXggKGFjY3UgKyAxKSB4c1xuXG5sZXRbQGlubGluZV0gbGVuZ3RoIHhzID1cbiAgbGVuZ3RoX2F1eCAwIHhzXG5cbmxldCByZWMgaXRlcmlfYXV4IGYgaSB4cyA9XG4gIG1hdGNoIHhzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgKClcbiAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgIGYgaSB4O1xuICAgICAgaXRlcmlfYXV4IGYgKGkrMSkgeHNcblxubGV0W0BpbmxpbmVdIGl0ZXJpIGYgeHMgPVxuICBpdGVyaV9hdXggZiAwIHhzXG5cbmxldCByZWMgZm9sZF9sZWZ0aV9hdXggZiBhY2N1IGkgeHMgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIGFjY3VcbiAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgIGxldCBhY2N1ID0gZiBhY2N1IGkgeCBpblxuICAgICAgZm9sZF9sZWZ0aV9hdXggZiBhY2N1IChpKzEpIHhzXG5cbmxldFtAaW5saW5lXSBmb2xkX2xlZnRpIGYgYWNjdSB4cyA9XG4gIGZvbGRfbGVmdGlfYXV4IGYgYWNjdSAwIHhzXG5cbmxldCByZWMgZm9yX2FsbCBwIHhzID1cbiAgbWF0Y2ggeHMoKSB3aXRoXG4gIHwgTmlsIC0+XG4gICAgICB0cnVlXG4gIHwgQ29ucyAoeCwgeHMpIC0+XG4gICAgICBwIHggJiYgZm9yX2FsbCBwIHhzXG5cbmxldCByZWMgZXhpc3RzIHAgeHMgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIGZhbHNlXG4gIHwgQ29ucyAoeCwgeHMpIC0+XG4gICAgICBwIHggfHwgZXhpc3RzIHAgeHNcblxubGV0IHJlYyBmaW5kIHAgeHMgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIE5vbmVcbiAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgIGlmIHAgeCB0aGVuIFNvbWUgeCBlbHNlIGZpbmQgcCB4c1xuXG5sZXQgcmVjIGZpbmRfbWFwIGYgeHMgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIE5vbmVcbiAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgIG1hdGNoIGYgeCB3aXRoXG4gICAgICB8IE5vbmUgLT5cbiAgICAgICAgICBmaW5kX21hcCBmIHhzXG4gICAgICB8IFNvbWUgXyBhcyByZXN1bHQgLT5cbiAgICAgICAgICByZXN1bHRcblxuKCogW2l0ZXIyXSwgW2ZvbGRfbGVmdDJdLCBbZm9yX2FsbDJdLCBbZXhpc3RzMl0sIFttYXAyXSwgW3ppcF0gd29yayBhbHNvIGluXG4gICB0aGUgY2FzZSB3aGVyZSB0aGUgdHdvIHNlcXVlbmNlcyBoYXZlIGRpZmZlcmVudCBsZW5ndGhzLiBUaGV5IHN0b3AgYXMgc29vblxuICAgYXMgb25lIHNlcXVlbmNlIGlzIGV4aGF1c3RlZC4gVGhlaXIgYmVoYXZpb3IgaXMgc2xpZ2h0bHkgYXN5bW1ldHJpYzogd2hlblxuICAgW3hzXSBpcyBlbXB0eSwgdGhleSBkbyBub3QgZm9yY2UgW3lzXTsgaG93ZXZlciwgd2hlbiBbeXNdIGlzIGVtcHR5LCBbeHNdIGlzXG4gICBmb3JjZWQsIGV2ZW4gdGhvdWdoIHRoZSByZXN1bHQgb2YgdGhlIGZ1bmN0aW9uIGFwcGxpY2F0aW9uIFt4cygpXSB0dXJucyBvdXRcbiAgIHRvIGJlIHVzZWxlc3MuICopXG5cbmxldCByZWMgaXRlcjIgZiB4cyB5cyA9XG4gIG1hdGNoIHhzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgKClcbiAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgIG1hdGNoIHlzKCkgd2l0aFxuICAgICAgfCBOaWwgLT5cbiAgICAgICAgICAoKVxuICAgICAgfCBDb25zICh5LCB5cykgLT5cbiAgICAgICAgICBmIHggeTtcbiAgICAgICAgICBpdGVyMiBmIHhzIHlzXG5cbmxldCByZWMgZm9sZF9sZWZ0MiBmIGFjY3UgeHMgeXMgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIGFjY3VcbiAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgIG1hdGNoIHlzKCkgd2l0aFxuICAgICAgfCBOaWwgLT5cbiAgICAgICAgICBhY2N1XG4gICAgICB8IENvbnMgKHksIHlzKSAtPlxuICAgICAgICAgIGxldCBhY2N1ID0gZiBhY2N1IHggeSBpblxuICAgICAgICAgIGZvbGRfbGVmdDIgZiBhY2N1IHhzIHlzXG5cbmxldCByZWMgZm9yX2FsbDIgZiB4cyB5cyA9XG4gIG1hdGNoIHhzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgdHJ1ZVxuICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgbWF0Y2ggeXMoKSB3aXRoXG4gICAgICB8IE5pbCAtPlxuICAgICAgICAgIHRydWVcbiAgICAgIHwgQ29ucyAoeSwgeXMpIC0+XG4gICAgICAgICAgZiB4IHkgJiYgZm9yX2FsbDIgZiB4cyB5c1xuXG5sZXQgcmVjIGV4aXN0czIgZiB4cyB5cyA9XG4gIG1hdGNoIHhzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgZmFsc2VcbiAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgIG1hdGNoIHlzKCkgd2l0aFxuICAgICAgfCBOaWwgLT5cbiAgICAgICAgICBmYWxzZVxuICAgICAgfCBDb25zICh5LCB5cykgLT5cbiAgICAgICAgICBmIHggeSB8fCBleGlzdHMyIGYgeHMgeXNcblxubGV0IHJlYyBlcXVhbCBlcSB4cyB5cyA9XG4gIG1hdGNoIHhzKCksIHlzKCkgd2l0aFxuICB8IE5pbCwgTmlsIC0+XG4gICAgICB0cnVlXG4gIHwgQ29ucyAoeCwgeHMpLCBDb25zICh5LCB5cykgLT5cbiAgICAgIGVxIHggeSAmJiBlcXVhbCBlcSB4cyB5c1xuICB8IE5pbCwgQ29ucyAoXywgXylcbiAgfCBDb25zIChfLCBfKSwgTmlsIC0+XG4gICAgICBmYWxzZVxuXG5sZXQgcmVjIGNvbXBhcmUgY21wIHhzIHlzID1cbiAgbWF0Y2ggeHMoKSwgeXMoKSB3aXRoXG4gIHwgTmlsLCBOaWwgLT5cbiAgICAgIDBcbiAgfCBDb25zICh4LCB4cyksIENvbnMgKHksIHlzKSAtPlxuICAgICAgbGV0IGMgPSBjbXAgeCB5IGluXG4gICAgICBpZiBjIDw+IDAgdGhlbiBjIGVsc2UgY29tcGFyZSBjbXAgeHMgeXNcbiAgfCBOaWwsIENvbnMgKF8sIF8pIC0+XG4gICAgICAtMVxuICB8IENvbnMgKF8sIF8pLCBOaWwgLT5cbiAgICAgICsxXG5cblxuXG4oKiBbaW5pdF9hdXggZiBpIGpdIGlzIHRoZSBzZXF1ZW5jZSBbZiBpLCAuLi4sIGYgKGotMSldLiAqKVxuXG5sZXQgcmVjIGluaXRfYXV4IGYgaSBqICgpID1cbiAgaWYgaSA8IGogdGhlbiBiZWdpblxuICAgIENvbnMgKGYgaSwgaW5pdF9hdXggZiAoaSArIDEpIGopXG4gIGVuZFxuICBlbHNlXG4gICAgTmlsXG5cbmxldCBpbml0IG4gZiA9XG4gIGlmIG4gPCAwIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIlNlcS5pbml0XCJcbiAgZWxzZVxuICAgIGluaXRfYXV4IGYgMCBuXG5cbmxldCByZWMgcmVwZWF0IHggKCkgPVxuICBDb25zICh4LCByZXBlYXQgeClcblxubGV0IHJlYyBmb3JldmVyIGYgKCkgPVxuICBDb25zIChmKCksIGZvcmV2ZXIgZilcblxuKCogVGhpcyBwcmVsaW1pbmFyeSBkZWZpbml0aW9uIG9mIFtjeWNsZV0gcmVxdWlyZXMgdGhlIHNlcXVlbmNlIFt4c11cbiAgIHRvIGJlIG5vbmVtcHR5LiBBcHBseWluZyBpdCB0byBhbiBlbXB0eSBzZXF1ZW5jZSB3b3VsZCBwcm9kdWNlIGFcbiAgIHNlcXVlbmNlIHRoYXQgZGl2ZXJnZXMgd2hlbiBpdCBpcyBmb3JjZWQuICopXG5cbmxldCByZWMgY3ljbGVfbm9uZW1wdHkgeHMgKCkgPVxuICBhcHBlbmQgeHMgKGN5Y2xlX25vbmVtcHR5IHhzKSAoKVxuXG4oKiBbY3ljbGUgeHNdIGNoZWNrcyB3aGV0aGVyIFt4c10gaXMgZW1wdHkgYW5kLCBpZiBzbywgcmV0dXJucyBhbiBlbXB0eVxuICAgc2VxdWVuY2UuIE90aGVyd2lzZSwgW2N5Y2xlIHhzXSBwcm9kdWNlcyBvbmUgY29weSBvZiBbeHNdIGZvbGxvd2VkXG4gICB3aXRoIHRoZSBpbmZpbml0ZSBzZXF1ZW5jZSBbY3ljbGVfbm9uZW1wdHkgeHNdLiBUaHVzLCB0aGUgbm9uZW1wdGluZXNzXG4gICBjaGVjayBpcyBwZXJmb3JtZWQganVzdCBvbmNlLiAqKVxuXG5sZXQgY3ljbGUgeHMgKCkgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIE5pbFxuICB8IENvbnMgKHgsIHhzJykgLT5cbiAgICAgIENvbnMgKHgsIGFwcGVuZCB4cycgKGN5Y2xlX25vbmVtcHR5IHhzKSlcblxuKCogW2l0ZXJhdGUxIGYgeF0gaXMgdGhlIHNlcXVlbmNlIFtmIHgsIGYgKGYgeCksIC4uLl0uXG4gICBJdCBpcyBlcXVpdmFsZW50IHRvIFt0YWlsIChpdGVyYXRlIGYgeCldLlxuICAgW2l0ZXJhdGUxXSBpcyB1c2VkIGFzIGEgYnVpbGRpbmcgYmxvY2sgaW4gdGhlIGRlZmluaXRpb24gb2YgW2l0ZXJhdGVdLiAqKVxuXG5sZXQgcmVjIGl0ZXJhdGUxIGYgeCAoKSA9XG4gIGxldCB5ID0gZiB4IGluXG4gIENvbnMgKHksIGl0ZXJhdGUxIGYgeSlcblxuKCogW2l0ZXJhdGUgZiB4XSBpcyB0aGUgc2VxdWVuY2UgW3gsIGYgeCwgLi4uXS4gKilcblxuKCogVGhlIHJlYXNvbiB3aHkgd2UgZ2l2ZSB0aGlzIHNsaWdodGx5IGluZGlyZWN0IGRlZmluaXRpb24gb2YgW2l0ZXJhdGVdLFxuICAgYXMgb3Bwb3NlZCB0byB0aGUgbW9yZSBuYWl2ZSBkZWZpbml0aW9uIHRoYXQgbWF5IGNvbWUgdG8gbWluZCwgaXMgdGhhdFxuICAgd2UgYXJlIGNhcmVmdWwgdG8gYXZvaWQgZXZhbHVhdGluZyBbZiB4XSB1bnRpbCB0aGlzIGZ1bmN0aW9uIGNhbGwgaXNcbiAgIGFjdHVhbGx5IG5lY2Vzc2FyeS4gVGhlIG5haXZlIGRlZmluaXRpb24gKG5vdCBzaG93biBoZXJlKSBjb21wdXRlcyB0aGVcbiAgIHNlY29uZCBhcmd1bWVudCBvZiB0aGUgc2VxdWVuY2UsIFtmIHhdLCB3aGVuIHRoZSBmaXJzdCBhcmd1bWVudCBpc1xuICAgcmVxdWVzdGVkIGJ5IHRoZSB1c2VyLiAqKVxuXG5sZXQgaXRlcmF0ZSBmIHggPVxuICBjb25zIHggKGl0ZXJhdGUxIGYgeClcblxuXG5cbmxldCByZWMgbWFwaV9hdXggZiBpIHhzICgpID1cbiAgbWF0Y2ggeHMoKSB3aXRoXG4gIHwgTmlsIC0+XG4gICAgICBOaWxcbiAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgIENvbnMgKGYgaSB4LCBtYXBpX2F1eCBmIChpKzEpIHhzKVxuXG5sZXRbQGlubGluZV0gbWFwaSBmIHhzID1cbiAgbWFwaV9hdXggZiAwIHhzXG5cbigqIFt0YWlsX3NjYW4gZiBzIHhzXSBpcyBlcXVpdmFsZW50IHRvIFt0YWlsIChzY2FuIGYgcyB4cyldLlxuICAgW3RhaWxfc2Nhbl0gaXMgdXNlZCBhcyBhIGJ1aWxkaW5nIGJsb2NrIGluIHRoZSBkZWZpbml0aW9uIG9mIFtzY2FuXS4gKilcblxuKCogVGhpcyBzbGlnaHRseSBpbmRpcmVjdCBkZWZpbml0aW9uIG9mIFtzY2FuXSBpcyBtZWFudCB0byBhdm9pZCBjb21wdXRpbmdcbiAgIGVsZW1lbnRzIHRvbyBlYXJseTsgc2VlIHRoZSBhYm92ZSBjb21tZW50IGFib3V0IFtpdGVyYXRlMV0gYW5kIFtpdGVyYXRlXS4gKilcblxubGV0IHJlYyB0YWlsX3NjYW4gZiBzIHhzICgpID1cbiAgbWF0Y2ggeHMoKSB3aXRoXG4gIHwgTmlsIC0+XG4gICAgICBOaWxcbiAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgIGxldCBzID0gZiBzIHggaW5cbiAgICAgIENvbnMgKHMsIHRhaWxfc2NhbiBmIHMgeHMpXG5cbmxldCBzY2FuIGYgcyB4cyA9XG4gIGNvbnMgcyAodGFpbF9zY2FuIGYgcyB4cylcblxuKCogW3Rha2VdIGlzIGRlZmluZWQgaW4gc3VjaCBhIHdheSB0aGF0IFt0YWtlIDAgeHNdIHJldHVybnMgW2VtcHR5XVxuICAgaW1tZWRpYXRlbHksIHdpdGhvdXQgYWxsb2NhdGluZyBhbnkgbWVtb3J5LiAqKVxuXG5sZXQgcmVjIHRha2VfYXV4IG4geHMgPVxuICBpZiBuID0gMCB0aGVuXG4gICAgZW1wdHlcbiAgZWxzZVxuICAgIGZ1biAoKSAtPlxuICAgICAgbWF0Y2ggeHMoKSB3aXRoXG4gICAgICB8IE5pbCAtPlxuICAgICAgICAgIE5pbFxuICAgICAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgICAgICBDb25zICh4LCB0YWtlX2F1eCAobi0xKSB4cylcblxubGV0IHRha2UgbiB4cyA9XG4gIGlmIG4gPCAwIHRoZW4gaW52YWxpZF9hcmcgXCJTZXEudGFrZVwiO1xuICB0YWtlX2F1eCBuIHhzXG5cbigqIFtmb3JjZV9kcm9wIG4geHNdIGlzIGVxdWl2YWxlbnQgdG8gW2Ryb3AgbiB4cyAoKV0uXG4gICBbZm9yY2VfZHJvcCBuIHhzXSByZXF1aXJlcyBbbiA+IDBdLlxuICAgW2ZvcmNlX2Ryb3BdIGlzIHVzZWQgYXMgYSBidWlsZGluZyBibG9jayBpbiB0aGUgZGVmaW5pdGlvbiBvZiBbZHJvcF0uICopXG5cbmxldCByZWMgZm9yY2VfZHJvcCBuIHhzID1cbiAgbWF0Y2ggeHMoKSB3aXRoXG4gIHwgTmlsIC0+XG4gICAgICBOaWxcbiAgfCBDb25zIChfLCB4cykgLT5cbiAgICAgIGxldCBuID0gbiAtIDEgaW5cbiAgICAgIGlmIG4gPSAwIHRoZW5cbiAgICAgICAgeHMoKVxuICAgICAgZWxzZVxuICAgICAgICBmb3JjZV9kcm9wIG4geHNcblxuKCogW2Ryb3BdIGlzIGRlZmluZWQgaW4gc3VjaCBhIHdheSB0aGF0IFtkcm9wIDAgeHNdIHJldHVybnMgW3hzXSBpbW1lZGlhdGVseSxcbiAgIHdpdGhvdXQgYWxsb2NhdGluZyBhbnkgbWVtb3J5LiAqKVxuXG5sZXQgZHJvcCBuIHhzID1cbiAgaWYgbiA8IDAgdGhlbiBpbnZhbGlkX2FyZyBcIlNlcS5kcm9wXCJcbiAgZWxzZSBpZiBuID0gMCB0aGVuXG4gICAgeHNcbiAgZWxzZVxuICAgIGZ1biAoKSAtPlxuICAgICAgZm9yY2VfZHJvcCBuIHhzXG5cbmxldCByZWMgdGFrZV93aGlsZSBwIHhzICgpID1cbiAgbWF0Y2ggeHMoKSB3aXRoXG4gIHwgTmlsIC0+XG4gICAgICBOaWxcbiAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgIGlmIHAgeCB0aGVuIENvbnMgKHgsIHRha2Vfd2hpbGUgcCB4cykgZWxzZSBOaWxcblxubGV0IHJlYyBkcm9wX3doaWxlIHAgeHMgKCkgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIE5pbFxuICB8IENvbnMgKHgsIHhzKSBhcyBub2RlIC0+XG4gICAgICBpZiBwIHggdGhlbiBkcm9wX3doaWxlIHAgeHMgKCkgZWxzZSBub2RlXG5cbmxldCByZWMgZ3JvdXAgZXEgeHMgKCkgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIE5pbFxuICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgQ29ucyAoY29ucyB4ICh0YWtlX3doaWxlIChlcSB4KSB4cyksIGdyb3VwIGVxIChkcm9wX3doaWxlIChlcSB4KSB4cykpXG5cbmV4Y2VwdGlvbiBGb3JjZWRfdHdpY2VcblxubW9kdWxlIFN1c3BlbnNpb24gPSBzdHJ1Y3RcblxuICB0eXBlICdhIHN1c3BlbnNpb24gPVxuICAgIHVuaXQgLT4gJ2FcblxuICAoKiBDb252ZXJzaW9ucy4gKilcblxuICBsZXQgdG9fbGF6eSA6ICdhIHN1c3BlbnNpb24gLT4gJ2EgTGF6eS50ID1cbiAgICBMYXp5LmZyb21fZnVuXG4gICAgKCogZnVuIHMgLT4gbGF6eSAocygpKSAqKVxuXG4gIGxldCBmcm9tX2xhenkgKHMgOiAnYSBMYXp5LnQpIDogJ2Egc3VzcGVuc2lvbiA9XG4gICAgZnVuICgpIC0+IExhenkuZm9yY2Ugc1xuXG4gICgqIFttZW1vaXplXSB0dXJucyBhbiBhcmJpdHJhcnkgc3VzcGVuc2lvbiBpbnRvIGEgcGVyc2lzdGVudCBzdXNwZW5zaW9uLiAqKVxuXG4gIGxldCBtZW1vaXplIChzIDogJ2Egc3VzcGVuc2lvbikgOiAnYSBzdXNwZW5zaW9uID1cbiAgICBmcm9tX2xhenkgKHRvX2xhenkgcylcblxuICAoKiBbZmFpbHVyZV0gaXMgYSBzdXNwZW5zaW9uIHRoYXQgZmFpbHMgd2hlbiBmb3JjZWQuICopXG5cbiAgbGV0IGZhaWx1cmUgOiBfIHN1c3BlbnNpb24gPVxuICAgIGZ1biAoKSAtPlxuICAgICAgKCogQSBzdXNwZW5zaW9uIGNyZWF0ZWQgYnkgW29uY2VdIGhhcyBiZWVuIGZvcmNlZCB0d2ljZS4gKilcbiAgICAgIHJhaXNlIEZvcmNlZF90d2ljZVxuXG4gICgqIElmIFtmXSBpcyBhIHN1c3BlbnNpb24sIHRoZW4gW29uY2UgZl0gaXMgYSBzdXNwZW5zaW9uIHRoYXQgY2FuIGJlIGZvcmNlZFxuICAgICBhdCBtb3N0IG9uY2UuIElmIGl0IGlzIGZvcmNlZCBtb3JlIHRoYW4gb25jZSwgdGhlbiBbRm9yY2VkX3R3aWNlXSBpc1xuICAgICByYWlzZWQuICopXG5cbiAgbGV0IG9uY2UgKGYgOiAnYSBzdXNwZW5zaW9uKSA6ICdhIHN1c3BlbnNpb24gPVxuICAgIGxldCBhY3Rpb24gPSBDYW1saW50ZXJuYWxBdG9taWMubWFrZSBmIGluXG4gICAgZnVuICgpIC0+XG4gICAgICAoKiBHZXQgdGhlIGZ1bmN0aW9uIGN1cnJlbnRseSBzdG9yZWQgaW4gW2FjdGlvbl0sIGFuZCB3cml0ZSB0aGVcbiAgICAgICAgIGZ1bmN0aW9uIFtmYWlsdXJlXSBpbiBpdHMgcGxhY2UsIHNvIHRoZSBuZXh0IGFjY2VzcyB3aWxsIHJlc3VsdFxuICAgICAgICAgaW4gYSBjYWxsIHRvIFtmYWlsdXJlKCldLiAqKVxuICAgICAgbGV0IGYgPSBDYW1saW50ZXJuYWxBdG9taWMuZXhjaGFuZ2UgYWN0aW9uIGZhaWx1cmUgaW5cbiAgICAgIGYoKVxuXG5lbmQgKCogU3VzcGVuc2lvbiAqKVxuXG5sZXQgcmVjIG1lbW9pemUgeHMgPVxuICBTdXNwZW5zaW9uLm1lbW9pemUgKGZ1biAoKSAtPlxuICAgIG1hdGNoIHhzKCkgd2l0aFxuICAgIHwgTmlsIC0+XG4gICAgICAgIE5pbFxuICAgIHwgQ29ucyAoeCwgeHMpIC0+XG4gICAgICAgIENvbnMgKHgsIG1lbW9pemUgeHMpXG4gIClcblxubGV0IHJlYyBvbmNlIHhzID1cbiAgU3VzcGVuc2lvbi5vbmNlIChmdW4gKCkgLT5cbiAgICBtYXRjaCB4cygpIHdpdGhcbiAgICB8IE5pbCAtPlxuICAgICAgICBOaWxcbiAgICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgICBDb25zICh4LCBvbmNlIHhzKVxuICApXG5cblxubGV0IHJlYyB6aXAgeHMgeXMgKCkgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIE5pbFxuICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgbWF0Y2ggeXMoKSB3aXRoXG4gICAgICB8IE5pbCAtPlxuICAgICAgICAgIE5pbFxuICAgICAgfCBDb25zICh5LCB5cykgLT5cbiAgICAgICAgICBDb25zICgoeCwgeSksIHppcCB4cyB5cylcblxubGV0IHJlYyBtYXAyIGYgeHMgeXMgKCkgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIE5pbFxuICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgbWF0Y2ggeXMoKSB3aXRoXG4gICAgICB8IE5pbCAtPlxuICAgICAgICAgIE5pbFxuICAgICAgfCBDb25zICh5LCB5cykgLT5cbiAgICAgICAgICBDb25zIChmIHggeSwgbWFwMiBmIHhzIHlzKVxuXG5sZXQgcmVjIGludGVybGVhdmUgeHMgeXMgKCkgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIHlzKClcbiAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgIENvbnMgKHgsIGludGVybGVhdmUgeXMgeHMpXG5cbigqIFtzb3J0ZWRfbWVyZ2UxbCBjbXAgeCB4cyB5c10gaXMgZXF1aXZhbGVudCB0b1xuICAgICBbc29ydGVkX21lcmdlIGNtcCAoY29ucyB4IHhzKSB5c10uXG5cbiAgIFtzb3J0ZWRfbWVyZ2UxciBjbXAgeHMgeSB5c10gaXMgZXF1aXZhbGVudCB0b1xuICAgICBbc29ydGVkX21lcmdlIGNtcCB4cyAoY29ucyB5IHlzKV0uXG5cbiAgIFtzb3J0ZWRfbWVyZ2UxIGNtcCB4IHhzIHkgeXNdIGlzIGVxdWl2YWxlbnQgdG9cbiAgICAgW3NvcnRlZF9tZXJnZSBjbXAgKGNvbnMgeCB4cykgKGNvbnMgeSB5cyldLlxuXG4gICBUaGVzZSB0aHJlZSBmdW5jdGlvbnMgYXJlIHVzZWQgYXMgYnVpbGRpbmcgYmxvY2tzIGluIHRoZSBkZWZpbml0aW9uXG4gICBvZiBbc29ydGVkX21lcmdlXS4gKilcblxubGV0IHJlYyBzb3J0ZWRfbWVyZ2UxbCBjbXAgeCB4cyB5cyAoKSA9XG4gIG1hdGNoIHlzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgQ29ucyAoeCwgeHMpXG4gIHwgQ29ucyAoeSwgeXMpIC0+XG4gICAgICBzb3J0ZWRfbWVyZ2UxIGNtcCB4IHhzIHkgeXNcblxuYW5kIHNvcnRlZF9tZXJnZTFyIGNtcCB4cyB5IHlzICgpID1cbiAgbWF0Y2ggeHMoKSB3aXRoXG4gIHwgTmlsIC0+XG4gICAgICBDb25zICh5LCB5cylcbiAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgIHNvcnRlZF9tZXJnZTEgY21wIHggeHMgeSB5c1xuXG5hbmQgc29ydGVkX21lcmdlMSBjbXAgeCB4cyB5IHlzID1cbiAgaWYgY21wIHggeSA8PSAwIHRoZW5cbiAgICBDb25zICh4LCBzb3J0ZWRfbWVyZ2UxciBjbXAgeHMgeSB5cylcbiAgZWxzZVxuICAgIENvbnMgKHksIHNvcnRlZF9tZXJnZTFsIGNtcCB4IHhzIHlzKVxuXG5sZXQgc29ydGVkX21lcmdlIGNtcCB4cyB5cyAoKSA9XG4gIG1hdGNoIHhzKCksIHlzKCkgd2l0aFxuICAgIHwgTmlsLCBOaWwgLT5cbiAgICAgICAgTmlsXG4gICAgfCBOaWwsIGNcbiAgICB8IGMsIE5pbCAtPlxuICAgICAgICBjXG4gICAgfCBDb25zICh4LCB4cyksIENvbnMgKHksIHlzKSAtPlxuICAgICAgICBzb3J0ZWRfbWVyZ2UxIGNtcCB4IHhzIHkgeXNcblxuXG5sZXQgcmVjIG1hcF9mc3QgeHlzICgpID1cbiAgbWF0Y2ggeHlzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgTmlsXG4gIHwgQ29ucyAoKHgsIF8pLCB4eXMpIC0+XG4gICAgICBDb25zICh4LCBtYXBfZnN0IHh5cylcblxubGV0IHJlYyBtYXBfc25kIHh5cyAoKSA9XG4gIG1hdGNoIHh5cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIE5pbFxuICB8IENvbnMgKChfLCB5KSwgeHlzKSAtPlxuICAgICAgQ29ucyAoeSwgbWFwX3NuZCB4eXMpXG5cbmxldCB1bnppcCB4eXMgPVxuICBtYXBfZnN0IHh5cywgbWFwX3NuZCB4eXNcblxubGV0IHNwbGl0ID1cbiAgdW56aXBcblxuKCogW2ZpbHRlcl9tYXBfZmluZF9sZWZ0X21hcCBmIHhzXSBpcyBlcXVpdmFsZW50IHRvXG4gICBbZmlsdGVyX21hcCBFaXRoZXIuZmluZF9sZWZ0IChtYXAgZiB4cyldLiAqKVxuXG5sZXQgcmVjIGZpbHRlcl9tYXBfZmluZF9sZWZ0X21hcCBmIHhzICgpID1cbiAgbWF0Y2ggeHMoKSB3aXRoXG4gIHwgTmlsIC0+XG4gICAgICBOaWxcbiAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgIG1hdGNoIGYgeCB3aXRoXG4gICAgICB8IEVpdGhlci5MZWZ0IHkgLT5cbiAgICAgICAgICBDb25zICh5LCBmaWx0ZXJfbWFwX2ZpbmRfbGVmdF9tYXAgZiB4cylcbiAgICAgIHwgRWl0aGVyLlJpZ2h0IF8gLT5cbiAgICAgICAgICBmaWx0ZXJfbWFwX2ZpbmRfbGVmdF9tYXAgZiB4cyAoKVxuXG5sZXQgcmVjIGZpbHRlcl9tYXBfZmluZF9yaWdodF9tYXAgZiB4cyAoKSA9XG4gIG1hdGNoIHhzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgTmlsXG4gIHwgQ29ucyAoeCwgeHMpIC0+XG4gICAgICBtYXRjaCBmIHggd2l0aFxuICAgICAgfCBFaXRoZXIuTGVmdCBfIC0+XG4gICAgICAgICAgZmlsdGVyX21hcF9maW5kX3JpZ2h0X21hcCBmIHhzICgpXG4gICAgICB8IEVpdGhlci5SaWdodCB6IC0+XG4gICAgICAgICAgQ29ucyAoeiwgZmlsdGVyX21hcF9maW5kX3JpZ2h0X21hcCBmIHhzKVxuXG5sZXQgcGFydGl0aW9uX21hcCBmIHhzID1cbiAgZmlsdGVyX21hcF9maW5kX2xlZnRfbWFwIGYgeHMsXG4gIGZpbHRlcl9tYXBfZmluZF9yaWdodF9tYXAgZiB4c1xuXG5sZXQgcGFydGl0aW9uIHAgeHMgPVxuICBmaWx0ZXIgcCB4cywgZmlsdGVyIChmdW4geCAtPiBub3QgKHAgeCkpIHhzXG5cbigqIElmIFt4c3NdIGlzIGEgbWF0cml4IChhIHNlcXVlbmNlIG9mIHJvd3MpLCB0aGVuIFtwZWVsIHhzc10gaXMgYSBwYWlyIG9mXG4gICB0aGUgZmlyc3QgY29sdW1uIChhIHNlcXVlbmNlIG9mIGVsZW1lbnRzKSBhbmQgb2YgdGhlIHJlbWFpbmRlciBvZiB0aGVcbiAgIG1hdHJpeCAoYSBzZXF1ZW5jZSBvZiBzaG9ydGVyIHJvd3MpLiBUaGVzZSB0d28gc2VxdWVuY2VzIGhhdmUgdGhlIHNhbWVcbiAgIGxlbmd0aC4gVGhlIHJvd3Mgb2YgdGhlIG1hdHJpeCBbeHNzXSBhcmUgbm90IHJlcXVpcmVkIHRvIGhhdmUgdGhlIHNhbWVcbiAgIGxlbmd0aC4gQW4gZW1wdHkgcm93IGlzIGlnbm9yZWQuICopXG5cbigqIEJlY2F1c2UgW3BlZWxdIHVzZXMgW3VuemlwXSwgaXRzIGFyZ3VtZW50IG11c3QgYmUgcGVyc2lzdGVudC4gVGhlIHNhbWVcbiAgIHJlbWFyayBhcHBsaWVzIHRvIFt0cmFuc3Bvc2VdLCBbZGlhZ29uYWxzXSwgW3Byb2R1Y3RdLCBldGMuICopXG5cbmxldCBwZWVsIHhzcyA9XG4gIHVuemlwIChmaWx0ZXJfbWFwIHVuY29ucyB4c3MpXG5cbmxldCByZWMgdHJhbnNwb3NlIHhzcyAoKSA9XG4gIGxldCBoZWFkcywgdGFpbHMgPSBwZWVsIHhzcyBpblxuICBpZiBpc19lbXB0eSBoZWFkcyB0aGVuIGJlZ2luXG4gICAgYXNzZXJ0IChpc19lbXB0eSB0YWlscyk7XG4gICAgTmlsXG4gIGVuZFxuICBlbHNlXG4gICAgQ29ucyAoaGVhZHMsIHRyYW5zcG9zZSB0YWlscylcblxuKCogVGhlIGludGVybmFsIGZ1bmN0aW9uIFtkaWFnb25hbHNdIHRha2VzIGFuIGV4dHJhIGFyZ3VtZW50LCBbcmVtYWluZGVyc10sXG4gICB3aGljaCBjb250YWlucyB0aGUgcmVtYWluZGVycyBvZiB0aGUgcm93cyB0aGF0IGhhdmUgYWxyZWFkeSBiZWVuXG4gICBkaXNjb3ZlcmVkLiAqKVxuXG5sZXQgcmVjIGRpYWdvbmFscyByZW1haW5kZXJzIHhzcyAoKSA9XG4gIG1hdGNoIHhzcygpIHdpdGhcbiAgfCBDb25zICh4cywgeHNzKSAtPlxuICAgICAgYmVnaW4gbWF0Y2ggeHMoKSB3aXRoXG4gICAgICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgICAgICgqIFdlIGRpc2NvdmVyIGEgbmV3IG5vbmVtcHR5IHJvdyBbeCA6OiB4c10uIFRodXMsIHRoZSBuZXh0IGRpYWdvbmFsXG4gICAgICAgICAgICAgaXMgW3ggOjogaGVhZHNdOiB0aGlzIGRpYWdvbmFsIGJlZ2lucyB3aXRoIFt4XSBhbmQgY29udGludWVzIHdpdGhcbiAgICAgICAgICAgICB0aGUgZmlyc3QgZWxlbWVudCBvZiBldmVyeSByb3cgaW4gW3JlbWFpbmRlcnNdLiBJbiB0aGUgcmVjdXJzaXZlXG4gICAgICAgICAgICAgY2FsbCwgdGhlIGFyZ3VtZW50IFtyZW1haW5kZXJzXSBpcyBpbnN0YW50aWF0ZWQgd2l0aCBbeHMgOjpcbiAgICAgICAgICAgICB0YWlsc10sIHdoaWNoIG1lYW5zIHRoYXQgd2UgaGF2ZSBvbmUgbW9yZSByZW1haW5pbmcgcm93LCBbeHNdLFxuICAgICAgICAgICAgIGFuZCB0aGF0IHdlIGtlZXAgdGhlIHRhaWxzIG9mIHRoZSBwcmUtZXhpc3RpbmcgcmVtYWluaW5nIHJvd3MuICopXG4gICAgICAgICAgbGV0IGhlYWRzLCB0YWlscyA9IHBlZWwgcmVtYWluZGVycyBpblxuICAgICAgICAgIENvbnMgKGNvbnMgeCBoZWFkcywgZGlhZ29uYWxzIChjb25zIHhzIHRhaWxzKSB4c3MpXG4gICAgICB8IE5pbCAtPlxuICAgICAgICAgICgqIFdlIGRpc2NvdmVyIGEgbmV3IGVtcHR5IHJvdy4gSW4gdGhpcyBjYXNlLCB0aGUgbmV3IGRpYWdvbmFsIGlzXG4gICAgICAgICAgICAganVzdCBbaGVhZHNdLCBhbmQgW3JlbWFpbmRlcnNdIGlzIGluc3RhbnRpYXRlZCB3aXRoIGp1c3QgW3RhaWxzXSxcbiAgICAgICAgICAgICBhcyB3ZSBkbyBub3QgaGF2ZSBvbmUgbW9yZSByZW1haW5pbmcgcm93LiAqKVxuICAgICAgICAgIGxldCBoZWFkcywgdGFpbHMgPSBwZWVsIHJlbWFpbmRlcnMgaW5cbiAgICAgICAgICBDb25zIChoZWFkcywgZGlhZ29uYWxzIHRhaWxzIHhzcylcbiAgICAgIGVuZFxuICB8IE5pbCAtPlxuICAgICAgKCogVGhlcmUgYXJlIG5vIG1vcmUgcm93cyB0byBiZSBkaXNjb3ZlcmVkLiBUaGVyZSByZW1haW5zIHRvIGV4aGF1c3RcbiAgICAgICAgIHRoZSByZW1haW5pbmcgcm93cy4gKilcbiAgICAgIHRyYW5zcG9zZSByZW1haW5kZXJzICgpXG5cbigqIElmIFt4c3NdIGlzIGEgbWF0cml4IChhIHNlcXVlbmNlIG9mIHJvd3MpLCB0aGVuIFtkaWFnb25hbHMgeHNzXSBpc1xuICAgdGhlIHNlcXVlbmNlIG9mIGl0cyBkaWFnb25hbHMuXG5cbiAgIFRoZSBmaXJzdCBkaWFnb25hbCBjb250YWlucyBqdXN0IHRoZSBmaXJzdCBlbGVtZW50IG9mIHRoZVxuICAgZmlyc3Qgcm93LiBUaGUgc2Vjb25kIGRpYWdvbmFsIGNvbnRhaW5zIHRoZSBmaXJzdCBlbGVtZW50IG9mIHRoZVxuICAgc2Vjb25kIHJvdyBhbmQgdGhlIHNlY29uZCBlbGVtZW50IG9mIHRoZSBmaXJzdCByb3c7IGFuZCBzbyBvbi5cbiAgIFRoaXMga2luZCBvZiBkaWFnb25hbCBpcyBpbiBmYWN0IHNvbWV0aW1lcyBrbm93biBhcyBhbiBhbnRpZGlhZ29uYWwuXG5cbiAgIC0gRXZlcnkgZGlhZ29uYWwgaXMgYSBmaW5pdGUgc2VxdWVuY2UuXG4gICAtIFRoZSByb3dzIG9mIHRoZSBtYXRyaXggW3hzc10gYXJlIG5vdCByZXF1aXJlZCB0byBoYXZlIHRoZSBzYW1lIGxlbmd0aC5cbiAgIC0gVGhlIG1hdHJpeCBbeHNzXSBpcyBub3QgcmVxdWlyZWQgdG8gYmUgZmluaXRlIChpbiBlaXRoZXIgZGlyZWN0aW9uKS5cbiAgIC0gVGhlIG1hdHJpeCBbeHNzXSBtdXN0IGJlIHBlcnNpc3RlbnQuICopXG5cbmxldCBkaWFnb25hbHMgeHNzID1cbiAgZGlhZ29uYWxzIGVtcHR5IHhzc1xuXG5sZXQgbWFwX3Byb2R1Y3QgZiB4cyB5cyA9XG4gIGNvbmNhdCAoZGlhZ29uYWxzIChcbiAgICBtYXAgKGZ1biB4IC0+XG4gICAgICBtYXAgKGZ1biB5IC0+XG4gICAgICAgIGYgeCB5XG4gICAgICApIHlzXG4gICAgKSB4c1xuICApKVxuXG5sZXQgcHJvZHVjdCB4cyB5cyA9XG4gIG1hcF9wcm9kdWN0IChmdW4geCB5IC0+ICh4LCB5KSkgeHMgeXNcblxubGV0IG9mX2Rpc3BlbnNlciBpdCA9XG4gIGxldCByZWMgYyAoKSA9XG4gICAgbWF0Y2ggaXQoKSB3aXRoXG4gICAgfCBOb25lIC0+XG4gICAgICAgIE5pbFxuICAgIHwgU29tZSB4IC0+XG4gICAgICAgIENvbnMgKHgsIGMpXG4gIGluXG4gIGNcblxubGV0IHRvX2Rpc3BlbnNlciB4cyA9XG4gIGxldCBzID0gcmVmIHhzIGluXG4gIGZ1biAoKSAtPlxuICAgIG1hdGNoICghcykoKSB3aXRoXG4gICAgfCBOaWwgLT5cbiAgICAgICAgTm9uZVxuICAgIHwgQ29ucyAoeCwgeHMpIC0+XG4gICAgICAgIHMgOj0geHM7XG4gICAgICAgIFNvbWUgeFxuXG5cblxubGV0IHJlYyBpbnRzIGkgKCkgPVxuICBDb25zIChpLCBpbnRzIChpICsgMSkpXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgT0NhbWwgcHJvZ3JhbW1lcnMgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE4IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUgJ2EgdCA9ICdhIG9wdGlvbiA9IE5vbmUgfCBTb21lIG9mICdhXG5cbmxldCBub25lID0gTm9uZVxubGV0IHNvbWUgdiA9IFNvbWUgdlxubGV0IHZhbHVlIG8gfmRlZmF1bHQgPSBtYXRjaCBvIHdpdGggU29tZSB2IC0+IHYgfCBOb25lIC0+IGRlZmF1bHRcbmxldCBnZXQgPSBmdW5jdGlvbiBTb21lIHYgLT4gdiB8IE5vbmUgLT4gaW52YWxpZF9hcmcgXCJvcHRpb24gaXMgTm9uZVwiXG5sZXQgYmluZCBvIGYgPSBtYXRjaCBvIHdpdGggTm9uZSAtPiBOb25lIHwgU29tZSB2IC0+IGYgdlxubGV0IGpvaW4gPSBmdW5jdGlvbiBTb21lIG8gLT4gbyB8IE5vbmUgLT4gTm9uZVxubGV0IG1hcCBmIG8gPSBtYXRjaCBvIHdpdGggTm9uZSAtPiBOb25lIHwgU29tZSB2IC0+IFNvbWUgKGYgdilcbmxldCBmb2xkIH5ub25lIH5zb21lID0gZnVuY3Rpb24gU29tZSB2IC0+IHNvbWUgdiB8IE5vbmUgLT4gbm9uZVxubGV0IGl0ZXIgZiA9IGZ1bmN0aW9uIFNvbWUgdiAtPiBmIHYgfCBOb25lIC0+ICgpXG5sZXQgaXNfbm9uZSA9IGZ1bmN0aW9uIE5vbmUgLT4gdHJ1ZSB8IFNvbWUgXyAtPiBmYWxzZVxubGV0IGlzX3NvbWUgPSBmdW5jdGlvbiBOb25lIC0+IGZhbHNlIHwgU29tZSBfIC0+IHRydWVcblxubGV0IGVxdWFsIGVxIG8wIG8xID0gbWF0Y2ggbzAsIG8xIHdpdGhcbnwgU29tZSB2MCwgU29tZSB2MSAtPiBlcSB2MCB2MVxufCBOb25lLCBOb25lIC0+IHRydWVcbnwgXyAtPiBmYWxzZVxuXG5sZXQgY29tcGFyZSBjbXAgbzAgbzEgPSBtYXRjaCBvMCwgbzEgd2l0aFxufCBTb21lIHYwLCBTb21lIHYxIC0+IGNtcCB2MCB2MVxufCBOb25lLCBOb25lIC0+IDBcbnwgTm9uZSwgU29tZSBfIC0+IC0xXG58IFNvbWUgXywgTm9uZSAtPiAxXG5cbmxldCB0b19yZXN1bHQgfm5vbmUgPSBmdW5jdGlvbiBOb25lIC0+IEVycm9yIG5vbmUgfCBTb21lIHYgLT4gT2sgdlxubGV0IHRvX2xpc3QgPSBmdW5jdGlvbiBOb25lIC0+IFtdIHwgU29tZSB2IC0+IFt2XVxubGV0IHRvX3NlcSA9IGZ1bmN0aW9uIE5vbmUgLT4gU2VxLmVtcHR5IHwgU29tZSB2IC0+IFNlcS5yZXR1cm4gdlxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgVGhlIE9DYW1sIHByb2dyYW1tZXJzICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxOCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlICgnYSwgJ2UpIHQgPSAoJ2EsICdlKSByZXN1bHQgPSBPayBvZiAnYSB8IEVycm9yIG9mICdlXG5cbmxldCBvayB2ID0gT2sgdlxubGV0IGVycm9yIGUgPSBFcnJvciBlXG5sZXQgdmFsdWUgciB+ZGVmYXVsdCA9IG1hdGNoIHIgd2l0aCBPayB2IC0+IHYgfCBFcnJvciBfIC0+IGRlZmF1bHRcbmxldCBnZXRfb2sgPSBmdW5jdGlvbiBPayB2IC0+IHYgfCBFcnJvciBfIC0+IGludmFsaWRfYXJnIFwicmVzdWx0IGlzIEVycm9yIF9cIlxubGV0IGdldF9lcnJvciA9IGZ1bmN0aW9uIEVycm9yIGUgLT4gZSB8IE9rIF8gLT4gaW52YWxpZF9hcmcgXCJyZXN1bHQgaXMgT2sgX1wiXG5sZXQgYmluZCByIGYgPSBtYXRjaCByIHdpdGggT2sgdiAtPiBmIHYgfCBFcnJvciBfIGFzIGUgLT4gZVxubGV0IGpvaW4gPSBmdW5jdGlvbiBPayByIC0+IHIgfCBFcnJvciBfIGFzIGUgLT4gZVxubGV0IG1hcCBmID0gZnVuY3Rpb24gT2sgdiAtPiBPayAoZiB2KSB8IEVycm9yIF8gYXMgZSAtPiBlXG5sZXQgbWFwX2Vycm9yIGYgPSBmdW5jdGlvbiBFcnJvciBlIC0+IEVycm9yIChmIGUpIHwgT2sgXyBhcyB2IC0+IHZcbmxldCBmb2xkIH5vayB+ZXJyb3IgPSBmdW5jdGlvbiBPayB2IC0+IG9rIHYgfCBFcnJvciBlIC0+IGVycm9yIGVcbmxldCBpdGVyIGYgPSBmdW5jdGlvbiBPayB2IC0+IGYgdiB8IEVycm9yIF8gLT4gKClcbmxldCBpdGVyX2Vycm9yIGYgPSBmdW5jdGlvbiBFcnJvciBlIC0+IGYgZSB8IE9rIF8gLT4gKClcbmxldCBpc19vayA9IGZ1bmN0aW9uIE9rIF8gLT4gdHJ1ZSB8IEVycm9yIF8gLT4gZmFsc2VcbmxldCBpc19lcnJvciA9IGZ1bmN0aW9uIEVycm9yIF8gLT4gdHJ1ZSB8IE9rIF8gLT4gZmFsc2VcblxubGV0IGVxdWFsIH5vayB+ZXJyb3IgcjAgcjEgPSBtYXRjaCByMCwgcjEgd2l0aFxufCBPayB2MCwgT2sgdjEgLT4gb2sgdjAgdjFcbnwgRXJyb3IgZTAsIEVycm9yIGUxIC0+IGVycm9yIGUwIGUxXG58IF8sIF8gLT4gZmFsc2VcblxubGV0IGNvbXBhcmUgfm9rIH5lcnJvciByMCByMSA9IG1hdGNoIHIwLCByMSB3aXRoXG58IE9rIHYwLCBPayB2MSAtPiBvayB2MCB2MVxufCBFcnJvciBlMCwgRXJyb3IgZTEgLT4gZXJyb3IgZTAgZTFcbnwgT2sgXywgRXJyb3IgXyAtPiAtMVxufCBFcnJvciBfLCBPayBfIC0+IDFcblxubGV0IHRvX29wdGlvbiA9IGZ1bmN0aW9uIE9rIHYgLT4gU29tZSB2IHwgRXJyb3IgXyAtPiBOb25lXG5sZXQgdG9fbGlzdCA9IGZ1bmN0aW9uIE9rIHYgLT4gW3ZdIHwgRXJyb3IgXyAtPiBbXVxubGV0IHRvX3NlcSA9IGZ1bmN0aW9uIE9rIHYgLT4gU2VxLnJldHVybiB2IHwgRXJyb3IgXyAtPiBTZXEuZW1wdHlcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBPQ2FtbCBwcm9ncmFtbWVycyAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMTggSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxudHlwZSB0ID0gYm9vbCA9IGZhbHNlIHwgdHJ1ZVxuXG5leHRlcm5hbCBub3QgOiBib29sIC0+IGJvb2wgPSBcIiVib29sbm90XCJcbmV4dGVybmFsICggJiYgKSA6IGJvb2wgLT4gYm9vbCAtPiBib29sID0gXCIlc2VxdWFuZFwiXG5leHRlcm5hbCAoIHx8ICkgOiBib29sIC0+IGJvb2wgLT4gYm9vbCA9IFwiJXNlcXVvclwiXG5sZXQgZXF1YWwgOiBib29sIC0+IGJvb2wgLT4gYm9vbCA9ICggPSApXG5sZXQgY29tcGFyZSA6IGJvb2wgLT4gYm9vbCAtPiBpbnQgPSBTdGRsaWIuY29tcGFyZVxuZXh0ZXJuYWwgdG9faW50IDogYm9vbCAtPiBpbnQgPSBcIiVpZGVudGl0eVwiXG5sZXQgdG9fZmxvYXQgPSBmdW5jdGlvbiBmYWxzZSAtPiAwLiB8IHRydWUgLT4gMS5cblxuKCpcbmxldCBvZl9zdHJpbmcgPSBmdW5jdGlvblxufCBcImZhbHNlXCIgLT4gU29tZSBmYWxzZVxufCBcInRydWVcIiAtPiBTb21lIHRydWVcbnwgXyAtPiBOb25lXG4qKVxuXG5sZXQgdG9fc3RyaW5nID0gZnVuY3Rpb24gZmFsc2UgLT4gXCJmYWxzZVwiIHwgdHJ1ZSAtPiBcInRydWVcIlxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBDaGFyYWN0ZXIgb3BlcmF0aW9ucyAqKVxuXG5leHRlcm5hbCBjb2RlOiBjaGFyIC0+IGludCA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIHVuc2FmZV9jaHI6IGludCAtPiBjaGFyID0gXCIlaWRlbnRpdHlcIlxuXG5sZXQgY2hyIG4gPVxuICBpZiBuIDwgMCB8fCBuID4gMjU1IHRoZW4gaW52YWxpZF9hcmcgXCJDaGFyLmNoclwiIGVsc2UgdW5zYWZlX2NociBuXG5cbmV4dGVybmFsIGJ5dGVzX2NyZWF0ZTogaW50IC0+IGJ5dGVzID0gXCJjYW1sX2NyZWF0ZV9ieXRlc1wiXG5leHRlcm5hbCBieXRlc191bnNhZmVfc2V0IDogYnl0ZXMgLT4gaW50IC0+IGNoYXIgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcIiVieXRlc191bnNhZmVfc2V0XCJcbmV4dGVybmFsIHVuc2FmZV90b19zdHJpbmcgOiBieXRlcyAtPiBzdHJpbmcgPSBcIiVieXRlc190b19zdHJpbmdcIlxuXG5sZXQgZXNjYXBlZCA9IGZ1bmN0aW9uXG4gIHwgJ1xcJycgLT4gXCJcXFxcJ1wiXG4gIHwgJ1xcXFwnIC0+IFwiXFxcXFxcXFxcIlxuICB8ICdcXG4nIC0+IFwiXFxcXG5cIlxuICB8ICdcXHQnIC0+IFwiXFxcXHRcIlxuICB8ICdcXHInIC0+IFwiXFxcXHJcIlxuICB8ICdcXGInIC0+IFwiXFxcXGJcIlxuICB8ICcgJyAuLiAnficgYXMgYyAtPlxuICAgICAgbGV0IHMgPSBieXRlc19jcmVhdGUgMSBpblxuICAgICAgYnl0ZXNfdW5zYWZlX3NldCBzIDAgYztcbiAgICAgIHVuc2FmZV90b19zdHJpbmcgc1xuICB8IGMgLT5cbiAgICAgIGxldCBuID0gY29kZSBjIGluXG4gICAgICBsZXQgcyA9IGJ5dGVzX2NyZWF0ZSA0IGluXG4gICAgICBieXRlc191bnNhZmVfc2V0IHMgMCAnXFxcXCc7XG4gICAgICBieXRlc191bnNhZmVfc2V0IHMgMSAodW5zYWZlX2NociAoNDggKyBuIC8gMTAwKSk7XG4gICAgICBieXRlc191bnNhZmVfc2V0IHMgMiAodW5zYWZlX2NociAoNDggKyAobiAvIDEwKSBtb2QgMTApKTtcbiAgICAgIGJ5dGVzX3Vuc2FmZV9zZXQgcyAzICh1bnNhZmVfY2hyICg0OCArIG4gbW9kIDEwKSk7XG4gICAgICB1bnNhZmVfdG9fc3RyaW5nIHNcblxubGV0IGxvd2VyY2FzZSA9IGZ1bmN0aW9uXG4gIHwgJ0EnIC4uICdaJ1xuICB8ICdcXDE5MicgLi4gJ1xcMjE0J1xuICB8ICdcXDIxNicgLi4gJ1xcMjIyJyBhcyBjIC0+XG4gICAgdW5zYWZlX2Nocihjb2RlIGMgKyAzMilcbiAgfCBjIC0+IGNcblxubGV0IHVwcGVyY2FzZSA9IGZ1bmN0aW9uXG4gIHwgJ2EnIC4uICd6J1xuICB8ICdcXDIyNCcgLi4gJ1xcMjQ2J1xuICB8ICdcXDI0OCcgLi4gJ1xcMjU0JyBhcyBjIC0+XG4gICAgdW5zYWZlX2Nocihjb2RlIGMgLSAzMilcbiAgfCBjIC0+IGNcblxubGV0IGxvd2VyY2FzZV9hc2NpaSA9IGZ1bmN0aW9uXG4gIHwgJ0EnIC4uICdaJyBhcyBjIC0+IHVuc2FmZV9jaHIoY29kZSBjICsgMzIpXG4gIHwgYyAtPiBjXG5cbmxldCB1cHBlcmNhc2VfYXNjaWkgPSBmdW5jdGlvblxuICB8ICdhJyAuLiAneicgYXMgYyAtPiB1bnNhZmVfY2hyKGNvZGUgYyAtIDMyKVxuICB8IGMgLT4gY1xuXG50eXBlIHQgPSBjaGFyXG5cbmxldCBjb21wYXJlIGMxIGMyID0gY29kZSBjMSAtIGNvZGUgYzJcbmxldCBlcXVhbCAoYzE6IHQpIChjMjogdCkgPSBjb21wYXJlIGMxIGMyID0gMFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICBEYW5pZWwgQy4gQnVlbnpsaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxNCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5leHRlcm5hbCBmb3JtYXRfaW50IDogc3RyaW5nIC0+IGludCAtPiBzdHJpbmcgPSBcImNhbWxfZm9ybWF0X2ludFwiXG5cbmxldCBlcnJfbm9fcHJlZCA9IFwiVSswMDAwIGhhcyBubyBwcmVkZWNlc3NvclwiXG5sZXQgZXJyX25vX3N1Y2MgPSBcIlUrMTBGRkZGIGhhcyBubyBzdWNjZXNzb3JcIlxubGV0IGVycl9ub3Rfc3YgaSA9IGZvcm1hdF9pbnQgXCIlWFwiIGkgXiBcIiBpcyBub3QgYW4gVW5pY29kZSBzY2FsYXIgdmFsdWVcIlxubGV0IGVycl9ub3RfbGF0aW4xIHUgPSBcIlUrXCIgXiBmb3JtYXRfaW50IFwiJTA0WFwiIHUgXiBcIiBpcyBub3QgYSBsYXRpbjEgY2hhcmFjdGVyXCJcblxudHlwZSB0ID0gaW50XG5cbmxldCBtaW4gPSAweDAwMDBcbmxldCBtYXggPSAweDEwRkZGRlxubGV0IGxvX2JvdW5kID0gMHhEN0ZGXG5sZXQgaGlfYm91bmQgPSAweEUwMDBcblxubGV0IGJvbSA9IDB4RkVGRlxubGV0IHJlcCA9IDB4RkZGRFxuXG5sZXQgc3VjYyB1ID1cbiAgaWYgdSA9IGxvX2JvdW5kIHRoZW4gaGlfYm91bmQgZWxzZVxuICBpZiB1ID0gbWF4IHRoZW4gaW52YWxpZF9hcmcgZXJyX25vX3N1Y2MgZWxzZVxuICB1ICsgMVxuXG5sZXQgcHJlZCB1ID1cbiAgaWYgdSA9IGhpX2JvdW5kIHRoZW4gbG9fYm91bmQgZWxzZVxuICBpZiB1ID0gbWluIHRoZW4gaW52YWxpZF9hcmcgZXJyX25vX3ByZWQgZWxzZVxuICB1IC0gMVxuXG5sZXQgaXNfdmFsaWQgaSA9IChtaW4gPD0gaSAmJiBpIDw9IGxvX2JvdW5kKSB8fCAoaGlfYm91bmQgPD0gaSAmJiBpIDw9IG1heClcbmxldCBvZl9pbnQgaSA9IGlmIGlzX3ZhbGlkIGkgdGhlbiBpIGVsc2UgaW52YWxpZF9hcmcgKGVycl9ub3Rfc3YgaSlcbmV4dGVybmFsIHVuc2FmZV9vZl9pbnQgOiBpbnQgLT4gdCA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIHRvX2ludCA6IHQgLT4gaW50ID0gXCIlaWRlbnRpdHlcIlxuXG5sZXQgaXNfY2hhciB1ID0gdSA8IDI1NlxubGV0IG9mX2NoYXIgYyA9IENoYXIuY29kZSBjXG5sZXQgdG9fY2hhciB1ID1cbiAgaWYgdSA+IDI1NSB0aGVuIGludmFsaWRfYXJnIChlcnJfbm90X2xhdGluMSB1KSBlbHNlXG4gIENoYXIudW5zYWZlX2NociB1XG5cbmxldCB1bnNhZmVfdG9fY2hhciA9IENoYXIudW5zYWZlX2NoclxuXG5sZXQgZXF1YWwgOiBpbnQgLT4gaW50IC0+IGJvb2wgPSAoID0gKVxubGV0IGNvbXBhcmUgOiBpbnQgLT4gaW50IC0+IGludCA9IFN0ZGxpYi5jb21wYXJlXG5sZXQgaGFzaCA9IHRvX2ludFxuXG4oKiBVVEYgY29kZWNzIHRvb2xzICopXG5cbnR5cGUgdXRmX2RlY29kZSA9IGludFxuKCogVGhpcyBpcyBhbiBpbnQgWzB4RFVVVVVVVV0gZGVjb21wb3NlZCBhcyBmb2xsb3dzOlxuICAgLSBbRF0gaXMgZm91ciBiaXRzIGZvciBkZWNvZGUgaW5mb3JtYXRpb24sIHRoZSBoaWdoZXN0IGJpdCBpcyBzZXQgaWYgdGhlXG4gICAgIGRlY29kZSBpcyB2YWxpZC4gVGhlIHRocmVlIGxvd2VyIGJpdHMgaW5kaWNhdGUgdGhlIG51bWJlciBvZiBlbGVtZW50c1xuICAgICBmcm9tIHRoZSBzb3VyY2UgdGhhdCB3ZXJlIGNvbnN1bWVkIGJ5IHRoZSBkZWNvZGUuXG4gICAtIFtVVVVVVVVdIGlzIHRoZSBkZWNvZGVkIFVuaWNvZGUgY2hhcmFjdGVyIG9yIHRoZSBVbmljb2RlIHJlcGxhY2VtZW50XG4gICAgIGNoYXJhY3RlciBVK0ZGRkQgaWYgZm9yIGludmFsaWQgZGVjb2Rlcy4gKilcblxubGV0IHZhbGlkX2JpdCA9IDI3XG5sZXQgZGVjb2RlX2JpdHMgPSAyNFxuXG5sZXRbQGlubGluZV0gdXRmX2RlY29kZV9pc192YWxpZCBkID0gKGQgbHNyIHZhbGlkX2JpdCkgPSAxXG5sZXRbQGlubGluZV0gdXRmX2RlY29kZV9sZW5ndGggZCA9IChkIGxzciBkZWNvZGVfYml0cykgbGFuZCAwYjExMVxubGV0W0BpbmxpbmVdIHV0Zl9kZWNvZGVfdWNoYXIgZCA9IHVuc2FmZV9vZl9pbnQgKGQgbGFuZCAweEZGRkZGRilcbmxldFtAaW5saW5lXSB1dGZfZGVjb2RlIG4gdSA9ICgoOCBsb3IgbikgbHNsIGRlY29kZV9iaXRzKSBsb3IgKHRvX2ludCB1KVxubGV0W0BpbmxpbmVdIHV0Zl9kZWNvZGVfaW52YWxpZCBuID0gKG4gbHNsIGRlY29kZV9iaXRzKSBsb3IgcmVwXG5cbmxldCB1dGZfOF9ieXRlX2xlbmd0aCB1ID0gbWF0Y2ggdG9faW50IHUgd2l0aFxufCB1IHdoZW4gdSA8IDAgLT4gYXNzZXJ0IGZhbHNlXG58IHUgd2hlbiB1IDw9IDB4MDA3RiAtPiAxXG58IHUgd2hlbiB1IDw9IDB4MDdGRiAtPiAyXG58IHUgd2hlbiB1IDw9IDB4RkZGRiAtPiAzXG58IHUgd2hlbiB1IDw9IDB4MTBGRkZGIC0+IDRcbnwgXyAtPiBhc3NlcnQgZmFsc2VcblxubGV0IHV0Zl8xNl9ieXRlX2xlbmd0aCB1ID0gbWF0Y2ggdG9faW50IHUgd2l0aFxufCB1IHdoZW4gdSA8IDAgLT4gYXNzZXJ0IGZhbHNlXG58IHUgd2hlbiB1IDw9IDB4RkZGRiAtPiAyXG58IHUgd2hlbiB1IDw9IDB4MTBGRkZGIC0+IDRcbnwgXyAtPiBhc3NlcnQgZmFsc2VcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogQW4gYWxpYXMgZm9yIHRoZSB0eXBlIG9mIGxpc3RzLiAqKVxudHlwZSAnYSB0ID0gJ2EgbGlzdCA9IFtdIHwgKDo6KSBvZiAnYSAqICdhIGxpc3RcblxuKCogTGlzdCBvcGVyYXRpb25zICopXG5cbmxldCByZWMgbGVuZ3RoX2F1eCBsZW4gPSBmdW5jdGlvblxuICAgIFtdIC0+IGxlblxuICB8IF86OmwgLT4gbGVuZ3RoX2F1eCAobGVuICsgMSkgbFxuXG5sZXQgbGVuZ3RoIGwgPSBsZW5ndGhfYXV4IDAgbFxuXG5sZXQgY29ucyBhIGwgPSBhOjpsXG5cbmxldCBoZCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gZmFpbHdpdGggXCJoZFwiXG4gIHwgYTo6XyAtPiBhXG5cbmxldCB0bCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gZmFpbHdpdGggXCJ0bFwiXG4gIHwgXzo6bCAtPiBsXG5cbmxldCBudGggbCBuID1cbiAgaWYgbiA8IDAgdGhlbiBpbnZhbGlkX2FyZyBcIkxpc3QubnRoXCIgZWxzZVxuICBsZXQgcmVjIG50aF9hdXggbCBuID1cbiAgICBtYXRjaCBsIHdpdGhcbiAgICB8IFtdIC0+IGZhaWx3aXRoIFwibnRoXCJcbiAgICB8IGE6OmwgLT4gaWYgbiA9IDAgdGhlbiBhIGVsc2UgbnRoX2F1eCBsIChuLTEpXG4gIGluIG50aF9hdXggbCBuXG5cbmxldCBudGhfb3B0IGwgbiA9XG4gIGlmIG4gPCAwIHRoZW4gaW52YWxpZF9hcmcgXCJMaXN0Lm50aFwiIGVsc2VcbiAgbGV0IHJlYyBudGhfYXV4IGwgbiA9XG4gICAgbWF0Y2ggbCB3aXRoXG4gICAgfCBbXSAtPiBOb25lXG4gICAgfCBhOjpsIC0+IGlmIG4gPSAwIHRoZW4gU29tZSBhIGVsc2UgbnRoX2F1eCBsIChuLTEpXG4gIGluIG50aF9hdXggbCBuXG5cbmxldCBhcHBlbmQgPSAoQClcblxubGV0IHJlYyByZXZfYXBwZW5kIGwxIGwyID1cbiAgbWF0Y2ggbDEgd2l0aFxuICAgIFtdIC0+IGwyXG4gIHwgYSA6OiBsIC0+IHJldl9hcHBlbmQgbCAoYSA6OiBsMilcblxubGV0IHJldiBsID0gcmV2X2FwcGVuZCBsIFtdXG5cbmxldCByZWMgaW5pdF90YWlscmVjX2F1eCBhY2MgaSBuIGYgPVxuICBpZiBpID49IG4gdGhlbiBhY2NcbiAgZWxzZSBpbml0X3RhaWxyZWNfYXV4IChmIGkgOjogYWNjKSAoaSsxKSBuIGZcblxubGV0IHJlYyBpbml0X2F1eCBpIG4gZiA9XG4gIGlmIGkgPj0gbiB0aGVuIFtdXG4gIGVsc2VcbiAgICBsZXQgciA9IGYgaSBpblxuICAgIHIgOjogaW5pdF9hdXggKGkrMSkgbiBmXG5cbmxldCByZXZfaW5pdF90aHJlc2hvbGQgPVxuICBtYXRjaCBTeXMuYmFja2VuZF90eXBlIHdpdGhcbiAgfCBTeXMuTmF0aXZlIHwgU3lzLkJ5dGVjb2RlIC0+IDEwXzAwMFxuICAoKiBXZSBkb24ndCBrbm93IHRoZSBzaXplIG9mIHRoZSBzdGFjaywgYmV0dGVyIGJlIHNhZmUgYW5kIGFzc3VtZSBpdCdzXG4gICAgIHNtYWxsLiAqKVxuICB8IFN5cy5PdGhlciBfIC0+IDUwXG5cbmxldCBpbml0IGxlbiBmID1cbiAgaWYgbGVuIDwgMCB0aGVuIGludmFsaWRfYXJnIFwiTGlzdC5pbml0XCIgZWxzZVxuICBpZiBsZW4gPiByZXZfaW5pdF90aHJlc2hvbGQgdGhlbiByZXYgKGluaXRfdGFpbHJlY19hdXggW10gMCBsZW4gZilcbiAgZWxzZSBpbml0X2F1eCAwIGxlbiBmXG5cbmxldCByZWMgZmxhdHRlbiA9IGZ1bmN0aW9uXG4gICAgW10gLT4gW11cbiAgfCBsOjpyIC0+IGwgQCBmbGF0dGVuIHJcblxubGV0IGNvbmNhdCA9IGZsYXR0ZW5cblxubGV0IHJlYyBtYXAgZiA9IGZ1bmN0aW9uXG4gICAgW10gLT4gW11cbiAgfCBhOjpsIC0+IGxldCByID0gZiBhIGluIHIgOjogbWFwIGYgbFxuXG5sZXQgcmVjIG1hcGkgaSBmID0gZnVuY3Rpb25cbiAgICBbXSAtPiBbXVxuICB8IGE6OmwgLT4gbGV0IHIgPSBmIGkgYSBpbiByIDo6IG1hcGkgKGkgKyAxKSBmIGxcblxubGV0IG1hcGkgZiBsID0gbWFwaSAwIGYgbFxuXG5sZXQgcmV2X21hcCBmIGwgPVxuICBsZXQgcmVjIHJtYXBfZiBhY2N1ID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IGFjY3VcbiAgICB8IGE6OmwgLT4gcm1hcF9mIChmIGEgOjogYWNjdSkgbFxuICBpblxuICBybWFwX2YgW10gbFxuXG5cbmxldCByZWMgaXRlciBmID0gZnVuY3Rpb25cbiAgICBbXSAtPiAoKVxuICB8IGE6OmwgLT4gZiBhOyBpdGVyIGYgbFxuXG5sZXQgcmVjIGl0ZXJpIGkgZiA9IGZ1bmN0aW9uXG4gICAgW10gLT4gKClcbiAgfCBhOjpsIC0+IGYgaSBhOyBpdGVyaSAoaSArIDEpIGYgbFxuXG5sZXQgaXRlcmkgZiBsID0gaXRlcmkgMCBmIGxcblxubGV0IHJlYyBmb2xkX2xlZnQgZiBhY2N1IGwgPVxuICBtYXRjaCBsIHdpdGhcbiAgICBbXSAtPiBhY2N1XG4gIHwgYTo6bCAtPiBmb2xkX2xlZnQgZiAoZiBhY2N1IGEpIGxcblxubGV0IHJlYyBmb2xkX3JpZ2h0IGYgbCBhY2N1ID1cbiAgbWF0Y2ggbCB3aXRoXG4gICAgW10gLT4gYWNjdVxuICB8IGE6OmwgLT4gZiBhIChmb2xkX3JpZ2h0IGYgbCBhY2N1KVxuXG5sZXQgcmVjIG1hcDIgZiBsMSBsMiA9XG4gIG1hdGNoIChsMSwgbDIpIHdpdGhcbiAgICAoW10sIFtdKSAtPiBbXVxuICB8IChhMTo6bDEsIGEyOjpsMikgLT4gbGV0IHIgPSBmIGExIGEyIGluIHIgOjogbWFwMiBmIGwxIGwyXG4gIHwgKF8sIF8pIC0+IGludmFsaWRfYXJnIFwiTGlzdC5tYXAyXCJcblxubGV0IHJldl9tYXAyIGYgbDEgbDIgPVxuICBsZXQgcmVjIHJtYXAyX2YgYWNjdSBsMSBsMiA9XG4gICAgbWF0Y2ggKGwxLCBsMikgd2l0aFxuICAgIHwgKFtdLCBbXSkgLT4gYWNjdVxuICAgIHwgKGExOjpsMSwgYTI6OmwyKSAtPiBybWFwMl9mIChmIGExIGEyIDo6IGFjY3UpIGwxIGwyXG4gICAgfCAoXywgXykgLT4gaW52YWxpZF9hcmcgXCJMaXN0LnJldl9tYXAyXCJcbiAgaW5cbiAgcm1hcDJfZiBbXSBsMSBsMlxuXG5cbmxldCByZWMgaXRlcjIgZiBsMSBsMiA9XG4gIG1hdGNoIChsMSwgbDIpIHdpdGhcbiAgICAoW10sIFtdKSAtPiAoKVxuICB8IChhMTo6bDEsIGEyOjpsMikgLT4gZiBhMSBhMjsgaXRlcjIgZiBsMSBsMlxuICB8IChfLCBfKSAtPiBpbnZhbGlkX2FyZyBcIkxpc3QuaXRlcjJcIlxuXG5sZXQgcmVjIGZvbGRfbGVmdDIgZiBhY2N1IGwxIGwyID1cbiAgbWF0Y2ggKGwxLCBsMikgd2l0aFxuICAgIChbXSwgW10pIC0+IGFjY3VcbiAgfCAoYTE6OmwxLCBhMjo6bDIpIC0+IGZvbGRfbGVmdDIgZiAoZiBhY2N1IGExIGEyKSBsMSBsMlxuICB8IChfLCBfKSAtPiBpbnZhbGlkX2FyZyBcIkxpc3QuZm9sZF9sZWZ0MlwiXG5cbmxldCByZWMgZm9sZF9yaWdodDIgZiBsMSBsMiBhY2N1ID1cbiAgbWF0Y2ggKGwxLCBsMikgd2l0aFxuICAgIChbXSwgW10pIC0+IGFjY3VcbiAgfCAoYTE6OmwxLCBhMjo6bDIpIC0+IGYgYTEgYTIgKGZvbGRfcmlnaHQyIGYgbDEgbDIgYWNjdSlcbiAgfCAoXywgXykgLT4gaW52YWxpZF9hcmcgXCJMaXN0LmZvbGRfcmlnaHQyXCJcblxubGV0IHJlYyBmb3JfYWxsIHAgPSBmdW5jdGlvblxuICAgIFtdIC0+IHRydWVcbiAgfCBhOjpsIC0+IHAgYSAmJiBmb3JfYWxsIHAgbFxuXG5sZXQgcmVjIGV4aXN0cyBwID0gZnVuY3Rpb25cbiAgICBbXSAtPiBmYWxzZVxuICB8IGE6OmwgLT4gcCBhIHx8IGV4aXN0cyBwIGxcblxubGV0IHJlYyBmb3JfYWxsMiBwIGwxIGwyID1cbiAgbWF0Y2ggKGwxLCBsMikgd2l0aFxuICAgIChbXSwgW10pIC0+IHRydWVcbiAgfCAoYTE6OmwxLCBhMjo6bDIpIC0+IHAgYTEgYTIgJiYgZm9yX2FsbDIgcCBsMSBsMlxuICB8IChfLCBfKSAtPiBpbnZhbGlkX2FyZyBcIkxpc3QuZm9yX2FsbDJcIlxuXG5sZXQgcmVjIGV4aXN0czIgcCBsMSBsMiA9XG4gIG1hdGNoIChsMSwgbDIpIHdpdGhcbiAgICAoW10sIFtdKSAtPiBmYWxzZVxuICB8IChhMTo6bDEsIGEyOjpsMikgLT4gcCBhMSBhMiB8fCBleGlzdHMyIHAgbDEgbDJcbiAgfCAoXywgXykgLT4gaW52YWxpZF9hcmcgXCJMaXN0LmV4aXN0czJcIlxuXG5sZXQgcmVjIG1lbSB4ID0gZnVuY3Rpb25cbiAgICBbXSAtPiBmYWxzZVxuICB8IGE6OmwgLT4gY29tcGFyZSBhIHggPSAwIHx8IG1lbSB4IGxcblxubGV0IHJlYyBtZW1xIHggPSBmdW5jdGlvblxuICAgIFtdIC0+IGZhbHNlXG4gIHwgYTo6bCAtPiBhID09IHggfHwgbWVtcSB4IGxcblxubGV0IHJlYyBhc3NvYyB4ID0gZnVuY3Rpb25cbiAgICBbXSAtPiByYWlzZSBOb3RfZm91bmRcbiAgfCAoYSxiKTo6bCAtPiBpZiBjb21wYXJlIGEgeCA9IDAgdGhlbiBiIGVsc2UgYXNzb2MgeCBsXG5cbmxldCByZWMgYXNzb2Nfb3B0IHggPSBmdW5jdGlvblxuICAgIFtdIC0+IE5vbmVcbiAgfCAoYSxiKTo6bCAtPiBpZiBjb21wYXJlIGEgeCA9IDAgdGhlbiBTb21lIGIgZWxzZSBhc3NvY19vcHQgeCBsXG5cbmxldCByZWMgYXNzcSB4ID0gZnVuY3Rpb25cbiAgICBbXSAtPiByYWlzZSBOb3RfZm91bmRcbiAgfCAoYSxiKTo6bCAtPiBpZiBhID09IHggdGhlbiBiIGVsc2UgYXNzcSB4IGxcblxubGV0IHJlYyBhc3NxX29wdCB4ID0gZnVuY3Rpb25cbiAgICBbXSAtPiBOb25lXG4gIHwgKGEsYik6OmwgLT4gaWYgYSA9PSB4IHRoZW4gU29tZSBiIGVsc2UgYXNzcV9vcHQgeCBsXG5cbmxldCByZWMgbWVtX2Fzc29jIHggPSBmdW5jdGlvblxuICB8IFtdIC0+IGZhbHNlXG4gIHwgKGEsIF8pIDo6IGwgLT4gY29tcGFyZSBhIHggPSAwIHx8IG1lbV9hc3NvYyB4IGxcblxubGV0IHJlYyBtZW1fYXNzcSB4ID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBmYWxzZVxuICB8IChhLCBfKSA6OiBsIC0+IGEgPT0geCB8fCBtZW1fYXNzcSB4IGxcblxubGV0IHJlYyByZW1vdmVfYXNzb2MgeCA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gW11cbiAgfCAoYSwgXyBhcyBwYWlyKSA6OiBsIC0+XG4gICAgICBpZiBjb21wYXJlIGEgeCA9IDAgdGhlbiBsIGVsc2UgcGFpciA6OiByZW1vdmVfYXNzb2MgeCBsXG5cbmxldCByZWMgcmVtb3ZlX2Fzc3EgeCA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gW11cbiAgfCAoYSwgXyBhcyBwYWlyKSA6OiBsIC0+IGlmIGEgPT0geCB0aGVuIGwgZWxzZSBwYWlyIDo6IHJlbW92ZV9hc3NxIHggbFxuXG5sZXQgcmVjIGZpbmQgcCA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gcmFpc2UgTm90X2ZvdW5kXG4gIHwgeCA6OiBsIC0+IGlmIHAgeCB0aGVuIHggZWxzZSBmaW5kIHAgbFxuXG5sZXQgcmVjIGZpbmRfb3B0IHAgPSBmdW5jdGlvblxuICB8IFtdIC0+IE5vbmVcbiAgfCB4IDo6IGwgLT4gaWYgcCB4IHRoZW4gU29tZSB4IGVsc2UgZmluZF9vcHQgcCBsXG5cbmxldCByZWMgZmluZF9tYXAgZiA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gTm9uZVxuICB8IHggOjogbCAtPlxuICAgICBiZWdpbiBtYXRjaCBmIHggd2l0aFxuICAgICAgIHwgU29tZSBfIGFzIHJlc3VsdCAtPiByZXN1bHRcbiAgICAgICB8IE5vbmUgLT4gZmluZF9tYXAgZiBsXG4gICAgIGVuZFxuXG5sZXQgZmluZF9hbGwgcCA9XG4gIGxldCByZWMgZmluZCBhY2N1ID0gZnVuY3Rpb25cbiAgfCBbXSAtPiByZXYgYWNjdVxuICB8IHggOjogbCAtPiBpZiBwIHggdGhlbiBmaW5kICh4IDo6IGFjY3UpIGwgZWxzZSBmaW5kIGFjY3UgbCBpblxuICBmaW5kIFtdXG5cbmxldCBmaWx0ZXIgPSBmaW5kX2FsbFxuXG5sZXQgZmlsdGVyaSBwIGwgPVxuICBsZXQgcmVjIGF1eCBpIGFjYyA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gcmV2IGFjY1xuICB8IHg6OmwgLT4gYXV4IChpICsgMSkgKGlmIHAgaSB4IHRoZW4geDo6YWNjIGVsc2UgYWNjKSBsXG4gIGluXG4gIGF1eCAwIFtdIGxcblxubGV0IGZpbHRlcl9tYXAgZiA9XG4gIGxldCByZWMgYXV4IGFjY3UgPSBmdW5jdGlvblxuICAgIHwgW10gLT4gcmV2IGFjY3VcbiAgICB8IHggOjogbCAtPlxuICAgICAgICBtYXRjaCBmIHggd2l0aFxuICAgICAgICB8IE5vbmUgLT4gYXV4IGFjY3UgbFxuICAgICAgICB8IFNvbWUgdiAtPiBhdXggKHYgOjogYWNjdSkgbFxuICBpblxuICBhdXggW11cblxubGV0IGNvbmNhdF9tYXAgZiBsID1cbiAgbGV0IHJlYyBhdXggZiBhY2MgPSBmdW5jdGlvblxuICAgIHwgW10gLT4gcmV2IGFjY1xuICAgIHwgeCA6OiBsIC0+XG4gICAgICAgbGV0IHhzID0gZiB4IGluXG4gICAgICAgYXV4IGYgKHJldl9hcHBlbmQgeHMgYWNjKSBsXG4gIGluIGF1eCBmIFtdIGxcblxubGV0IGZvbGRfbGVmdF9tYXAgZiBhY2N1IGwgPVxuICBsZXQgcmVjIGF1eCBhY2N1IGxfYWNjdSA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiBhY2N1LCByZXYgbF9hY2N1XG4gICAgfCB4IDo6IGwgLT5cbiAgICAgICAgbGV0IGFjY3UsIHggPSBmIGFjY3UgeCBpblxuICAgICAgICBhdXggYWNjdSAoeCA6OiBsX2FjY3UpIGwgaW5cbiAgYXV4IGFjY3UgW10gbFxuXG5sZXQgcGFydGl0aW9uIHAgbCA9XG4gIGxldCByZWMgcGFydCB5ZXMgbm8gPSBmdW5jdGlvblxuICB8IFtdIC0+IChyZXYgeWVzLCByZXYgbm8pXG4gIHwgeCA6OiBsIC0+IGlmIHAgeCB0aGVuIHBhcnQgKHggOjogeWVzKSBubyBsIGVsc2UgcGFydCB5ZXMgKHggOjogbm8pIGwgaW5cbiAgcGFydCBbXSBbXSBsXG5cbmxldCBwYXJ0aXRpb25fbWFwIHAgbCA9XG4gIGxldCByZWMgcGFydCBsZWZ0IHJpZ2h0ID0gZnVuY3Rpb25cbiAgfCBbXSAtPiAocmV2IGxlZnQsIHJldiByaWdodClcbiAgfCB4IDo6IGwgLT5cbiAgICAgYmVnaW4gbWF0Y2ggcCB4IHdpdGhcbiAgICAgICB8IEVpdGhlci5MZWZ0IHYgLT4gcGFydCAodiA6OiBsZWZ0KSByaWdodCBsXG4gICAgICAgfCBFaXRoZXIuUmlnaHQgdiAtPiBwYXJ0IGxlZnQgKHYgOjogcmlnaHQpIGxcbiAgICAgZW5kXG4gIGluXG4gIHBhcnQgW10gW10gbFxuXG5sZXQgcmVjIHNwbGl0ID0gZnVuY3Rpb25cbiAgICBbXSAtPiAoW10sIFtdKVxuICB8ICh4LHkpOjpsIC0+XG4gICAgICBsZXQgKHJ4LCByeSkgPSBzcGxpdCBsIGluICh4OjpyeCwgeTo6cnkpXG5cbmxldCByZWMgY29tYmluZSBsMSBsMiA9XG4gIG1hdGNoIChsMSwgbDIpIHdpdGhcbiAgICAoW10sIFtdKSAtPiBbXVxuICB8IChhMTo6bDEsIGEyOjpsMikgLT4gKGExLCBhMikgOjogY29tYmluZSBsMSBsMlxuICB8IChfLCBfKSAtPiBpbnZhbGlkX2FyZyBcIkxpc3QuY29tYmluZVwiXG5cbigqKiBzb3J0aW5nICopXG5cbmxldCByZWMgbWVyZ2UgY21wIGwxIGwyID1cbiAgbWF0Y2ggbDEsIGwyIHdpdGhcbiAgfCBbXSwgbDIgLT4gbDJcbiAgfCBsMSwgW10gLT4gbDFcbiAgfCBoMSA6OiB0MSwgaDIgOjogdDIgLT5cbiAgICAgIGlmIGNtcCBoMSBoMiA8PSAwXG4gICAgICB0aGVuIGgxIDo6IG1lcmdlIGNtcCB0MSBsMlxuICAgICAgZWxzZSBoMiA6OiBtZXJnZSBjbXAgbDEgdDJcblxuXG5sZXQgc3RhYmxlX3NvcnQgY21wIGwgPVxuICBsZXQgcmVjIHJldl9tZXJnZSBsMSBsMiBhY2N1ID1cbiAgICBtYXRjaCBsMSwgbDIgd2l0aFxuICAgIHwgW10sIGwyIC0+IHJldl9hcHBlbmQgbDIgYWNjdVxuICAgIHwgbDEsIFtdIC0+IHJldl9hcHBlbmQgbDEgYWNjdVxuICAgIHwgaDE6OnQxLCBoMjo6dDIgLT5cbiAgICAgICAgaWYgY21wIGgxIGgyIDw9IDBcbiAgICAgICAgdGhlbiByZXZfbWVyZ2UgdDEgbDIgKGgxOjphY2N1KVxuICAgICAgICBlbHNlIHJldl9tZXJnZSBsMSB0MiAoaDI6OmFjY3UpXG4gIGluXG4gIGxldCByZWMgcmV2X21lcmdlX3JldiBsMSBsMiBhY2N1ID1cbiAgICBtYXRjaCBsMSwgbDIgd2l0aFxuICAgIHwgW10sIGwyIC0+IHJldl9hcHBlbmQgbDIgYWNjdVxuICAgIHwgbDEsIFtdIC0+IHJldl9hcHBlbmQgbDEgYWNjdVxuICAgIHwgaDE6OnQxLCBoMjo6dDIgLT5cbiAgICAgICAgaWYgY21wIGgxIGgyID4gMFxuICAgICAgICB0aGVuIHJldl9tZXJnZV9yZXYgdDEgbDIgKGgxOjphY2N1KVxuICAgICAgICBlbHNlIHJldl9tZXJnZV9yZXYgbDEgdDIgKGgyOjphY2N1KVxuICBpblxuICBsZXQgcmVjIHNvcnQgbiBsID1cbiAgICBtYXRjaCBuLCBsIHdpdGhcbiAgICB8IDIsIHgxIDo6IHgyIDo6IHRsIC0+XG4gICAgICAgIGxldCBzID0gaWYgY21wIHgxIHgyIDw9IDAgdGhlbiBbeDE7IHgyXSBlbHNlIFt4MjsgeDFdIGluXG4gICAgICAgIChzLCB0bClcbiAgICB8IDMsIHgxIDo6IHgyIDo6IHgzIDo6IHRsIC0+XG4gICAgICAgIGxldCBzID1cbiAgICAgICAgICBpZiBjbXAgeDEgeDIgPD0gMCB0aGVuXG4gICAgICAgICAgICBpZiBjbXAgeDIgeDMgPD0gMCB0aGVuIFt4MTsgeDI7IHgzXVxuICAgICAgICAgICAgZWxzZSBpZiBjbXAgeDEgeDMgPD0gMCB0aGVuIFt4MTsgeDM7IHgyXVxuICAgICAgICAgICAgZWxzZSBbeDM7IHgxOyB4Ml1cbiAgICAgICAgICBlbHNlIGlmIGNtcCB4MSB4MyA8PSAwIHRoZW4gW3gyOyB4MTsgeDNdXG4gICAgICAgICAgZWxzZSBpZiBjbXAgeDIgeDMgPD0gMCB0aGVuIFt4MjsgeDM7IHgxXVxuICAgICAgICAgIGVsc2UgW3gzOyB4MjsgeDFdXG4gICAgICAgIGluXG4gICAgICAgIChzLCB0bClcbiAgICB8IG4sIGwgLT5cbiAgICAgICAgbGV0IG4xID0gbiBhc3IgMSBpblxuICAgICAgICBsZXQgbjIgPSBuIC0gbjEgaW5cbiAgICAgICAgbGV0IHMxLCBsMiA9IHJldl9zb3J0IG4xIGwgaW5cbiAgICAgICAgbGV0IHMyLCB0bCA9IHJldl9zb3J0IG4yIGwyIGluXG4gICAgICAgIChyZXZfbWVyZ2VfcmV2IHMxIHMyIFtdLCB0bClcbiAgYW5kIHJldl9zb3J0IG4gbCA9XG4gICAgbWF0Y2ggbiwgbCB3aXRoXG4gICAgfCAyLCB4MSA6OiB4MiA6OiB0bCAtPlxuICAgICAgICBsZXQgcyA9IGlmIGNtcCB4MSB4MiA+IDAgdGhlbiBbeDE7IHgyXSBlbHNlIFt4MjsgeDFdIGluXG4gICAgICAgIChzLCB0bClcbiAgICB8IDMsIHgxIDo6IHgyIDo6IHgzIDo6IHRsIC0+XG4gICAgICAgIGxldCBzID1cbiAgICAgICAgICBpZiBjbXAgeDEgeDIgPiAwIHRoZW5cbiAgICAgICAgICAgIGlmIGNtcCB4MiB4MyA+IDAgdGhlbiBbeDE7IHgyOyB4M11cbiAgICAgICAgICAgIGVsc2UgaWYgY21wIHgxIHgzID4gMCB0aGVuIFt4MTsgeDM7IHgyXVxuICAgICAgICAgICAgZWxzZSBbeDM7IHgxOyB4Ml1cbiAgICAgICAgICBlbHNlIGlmIGNtcCB4MSB4MyA+IDAgdGhlbiBbeDI7IHgxOyB4M11cbiAgICAgICAgICBlbHNlIGlmIGNtcCB4MiB4MyA+IDAgdGhlbiBbeDI7IHgzOyB4MV1cbiAgICAgICAgICBlbHNlIFt4MzsgeDI7IHgxXVxuICAgICAgICBpblxuICAgICAgICAocywgdGwpXG4gICAgfCBuLCBsIC0+XG4gICAgICAgIGxldCBuMSA9IG4gYXNyIDEgaW5cbiAgICAgICAgbGV0IG4yID0gbiAtIG4xIGluXG4gICAgICAgIGxldCBzMSwgbDIgPSBzb3J0IG4xIGwgaW5cbiAgICAgICAgbGV0IHMyLCB0bCA9IHNvcnQgbjIgbDIgaW5cbiAgICAgICAgKHJldl9tZXJnZSBzMSBzMiBbXSwgdGwpXG4gIGluXG4gIGxldCBsZW4gPSBsZW5ndGggbCBpblxuICBpZiBsZW4gPCAyIHRoZW4gbCBlbHNlIGZzdCAoc29ydCBsZW4gbClcblxuXG5sZXQgc29ydCA9IHN0YWJsZV9zb3J0XG5sZXQgZmFzdF9zb3J0ID0gc3RhYmxlX3NvcnRcblxuKCogTm90ZTogb24gYSBsaXN0IG9mIGxlbmd0aCBiZXR3ZWVuIGFib3V0IDEwMDAwMCAoZGVwZW5kaW5nIG9uIHRoZSBtaW5vclxuICAgaGVhcCBzaXplIGFuZCB0aGUgdHlwZSBvZiB0aGUgbGlzdCkgYW5kIFN5cy5tYXhfYXJyYXlfc2l6ZSwgaXQgaXNcbiAgIGFjdHVhbGx5IGZhc3RlciB0byB1c2UgdGhlIGZvbGxvd2luZywgYnV0IGl0IG1pZ2h0IGFsc28gdXNlIG1vcmUgbWVtb3J5XG4gICBiZWNhdXNlIHRoZSBhcmd1bWVudCBsaXN0IGNhbm5vdCBiZSBkZWFsbG9jYXRlZCBpbmNyZW1lbnRhbGx5LlxuXG4gICBBbHNvLCB0aGVyZSBzZWVtcyB0byBiZSBhIGJ1ZyBpbiB0aGlzIGNvZGUgb3IgaW4gdGhlXG4gICBpbXBsZW1lbnRhdGlvbiBvZiBvYmpfdHJ1bmNhdGUuXG5cbmV4dGVybmFsIG9ial90cnVuY2F0ZSA6ICdhIGFycmF5IC0+IGludCAtPiB1bml0ID0gXCJjYW1sX29ial90cnVuY2F0ZVwiXG5cbmxldCBhcnJheV90b19saXN0X2luX3BsYWNlIGEgPVxuICBsZXQgbCA9IEFycmF5Lmxlbmd0aCBhIGluXG4gIGxldCByZWMgbG9vcCBhY2N1IG4gcCA9XG4gICAgaWYgcCA8PSAwIHRoZW4gYWNjdSBlbHNlIGJlZ2luXG4gICAgICBpZiBwID0gbiB0aGVuIGJlZ2luXG4gICAgICAgIG9ial90cnVuY2F0ZSBhIHA7XG4gICAgICAgIGxvb3AgKGEuKHAtMSkgOjogYWNjdSkgKG4tMTAwMCkgKHAtMSlcbiAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgIGxvb3AgKGEuKHAtMSkgOjogYWNjdSkgbiAocC0xKVxuICAgICAgZW5kXG4gICAgZW5kXG4gIGluXG4gIGxvb3AgW10gKGwtMTAwMCkgbFxuXG5cbmxldCBzdGFibGVfc29ydCBjbXAgbCA9XG4gIGxldCBhID0gQXJyYXkub2ZfbGlzdCBsIGluXG4gIEFycmF5LnN0YWJsZV9zb3J0IGNtcCBhO1xuICBhcnJheV90b19saXN0X2luX3BsYWNlIGFcblxuKilcblxuXG4oKiogc29ydGluZyArIHJlbW92aW5nIGR1cGxpY2F0ZXMgKilcblxubGV0IHNvcnRfdW5pcSBjbXAgbCA9XG4gIGxldCByZWMgcmV2X21lcmdlIGwxIGwyIGFjY3UgPVxuICAgIG1hdGNoIGwxLCBsMiB3aXRoXG4gICAgfCBbXSwgbDIgLT4gcmV2X2FwcGVuZCBsMiBhY2N1XG4gICAgfCBsMSwgW10gLT4gcmV2X2FwcGVuZCBsMSBhY2N1XG4gICAgfCBoMTo6dDEsIGgyOjp0MiAtPlxuICAgICAgICBsZXQgYyA9IGNtcCBoMSBoMiBpblxuICAgICAgICBpZiBjID0gMCB0aGVuIHJldl9tZXJnZSB0MSB0MiAoaDE6OmFjY3UpXG4gICAgICAgIGVsc2UgaWYgYyA8IDBcbiAgICAgICAgdGhlbiByZXZfbWVyZ2UgdDEgbDIgKGgxOjphY2N1KVxuICAgICAgICBlbHNlIHJldl9tZXJnZSBsMSB0MiAoaDI6OmFjY3UpXG4gIGluXG4gIGxldCByZWMgcmV2X21lcmdlX3JldiBsMSBsMiBhY2N1ID1cbiAgICBtYXRjaCBsMSwgbDIgd2l0aFxuICAgIHwgW10sIGwyIC0+IHJldl9hcHBlbmQgbDIgYWNjdVxuICAgIHwgbDEsIFtdIC0+IHJldl9hcHBlbmQgbDEgYWNjdVxuICAgIHwgaDE6OnQxLCBoMjo6dDIgLT5cbiAgICAgICAgbGV0IGMgPSBjbXAgaDEgaDIgaW5cbiAgICAgICAgaWYgYyA9IDAgdGhlbiByZXZfbWVyZ2VfcmV2IHQxIHQyIChoMTo6YWNjdSlcbiAgICAgICAgZWxzZSBpZiBjID4gMFxuICAgICAgICB0aGVuIHJldl9tZXJnZV9yZXYgdDEgbDIgKGgxOjphY2N1KVxuICAgICAgICBlbHNlIHJldl9tZXJnZV9yZXYgbDEgdDIgKGgyOjphY2N1KVxuICBpblxuICBsZXQgcmVjIHNvcnQgbiBsID1cbiAgICBtYXRjaCBuLCBsIHdpdGhcbiAgICB8IDIsIHgxIDo6IHgyIDo6IHRsIC0+XG4gICAgICAgIGxldCBzID1cbiAgICAgICAgICBsZXQgYyA9IGNtcCB4MSB4MiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gxXSBlbHNlIGlmIGMgPCAwIHRoZW4gW3gxOyB4Ml0gZWxzZSBbeDI7IHgxXVxuICAgICAgICBpblxuICAgICAgICAocywgdGwpXG4gICAgfCAzLCB4MSA6OiB4MiA6OiB4MyA6OiB0bCAtPlxuICAgICAgICBsZXQgcyA9XG4gICAgICAgICAgbGV0IGMgPSBjbXAgeDEgeDIgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuXG4gICAgICAgICAgICBsZXQgYyA9IGNtcCB4MiB4MyBpblxuICAgICAgICAgICAgaWYgYyA9IDAgdGhlbiBbeDJdIGVsc2UgaWYgYyA8IDAgdGhlbiBbeDI7IHgzXSBlbHNlIFt4MzsgeDJdXG4gICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuXG4gICAgICAgICAgICBsZXQgYyA9IGNtcCB4MiB4MyBpblxuICAgICAgICAgICAgaWYgYyA9IDAgdGhlbiBbeDE7IHgyXVxuICAgICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuIFt4MTsgeDI7IHgzXVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBsZXQgYyA9IGNtcCB4MSB4MyBpblxuICAgICAgICAgICAgICBpZiBjID0gMCB0aGVuIFt4MTsgeDJdXG4gICAgICAgICAgICAgIGVsc2UgaWYgYyA8IDAgdGhlbiBbeDE7IHgzOyB4Ml1cbiAgICAgICAgICAgICAgZWxzZSBbeDM7IHgxOyB4Ml1cbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsZXQgYyA9IGNtcCB4MSB4MyBpblxuICAgICAgICAgICAgaWYgYyA9IDAgdGhlbiBbeDI7IHgxXVxuICAgICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuIFt4MjsgeDE7IHgzXVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBsZXQgYyA9IGNtcCB4MiB4MyBpblxuICAgICAgICAgICAgICBpZiBjID0gMCB0aGVuIFt4MjsgeDFdXG4gICAgICAgICAgICAgIGVsc2UgaWYgYyA8IDAgdGhlbiBbeDI7IHgzOyB4MV1cbiAgICAgICAgICAgICAgZWxzZSBbeDM7IHgyOyB4MV1cbiAgICAgICAgaW5cbiAgICAgICAgKHMsIHRsKVxuICAgIHwgbiwgbCAtPlxuICAgICAgICBsZXQgbjEgPSBuIGFzciAxIGluXG4gICAgICAgIGxldCBuMiA9IG4gLSBuMSBpblxuICAgICAgICBsZXQgczEsIGwyID0gcmV2X3NvcnQgbjEgbCBpblxuICAgICAgICBsZXQgczIsIHRsID0gcmV2X3NvcnQgbjIgbDIgaW5cbiAgICAgICAgKHJldl9tZXJnZV9yZXYgczEgczIgW10sIHRsKVxuICBhbmQgcmV2X3NvcnQgbiBsID1cbiAgICBtYXRjaCBuLCBsIHdpdGhcbiAgICB8IDIsIHgxIDo6IHgyIDo6IHRsIC0+XG4gICAgICAgIGxldCBzID1cbiAgICAgICAgICBsZXQgYyA9IGNtcCB4MSB4MiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gxXSBlbHNlIGlmIGMgPiAwIHRoZW4gW3gxOyB4Ml0gZWxzZSBbeDI7IHgxXVxuICAgICAgICBpblxuICAgICAgICAocywgdGwpXG4gICAgfCAzLCB4MSA6OiB4MiA6OiB4MyA6OiB0bCAtPlxuICAgICAgICBsZXQgcyA9XG4gICAgICAgICAgbGV0IGMgPSBjbXAgeDEgeDIgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuXG4gICAgICAgICAgICBsZXQgYyA9IGNtcCB4MiB4MyBpblxuICAgICAgICAgICAgaWYgYyA9IDAgdGhlbiBbeDJdIGVsc2UgaWYgYyA+IDAgdGhlbiBbeDI7IHgzXSBlbHNlIFt4MzsgeDJdXG4gICAgICAgICAgZWxzZSBpZiBjID4gMCB0aGVuXG4gICAgICAgICAgICBsZXQgYyA9IGNtcCB4MiB4MyBpblxuICAgICAgICAgICAgaWYgYyA9IDAgdGhlbiBbeDE7IHgyXVxuICAgICAgICAgICAgZWxzZSBpZiBjID4gMCB0aGVuIFt4MTsgeDI7IHgzXVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBsZXQgYyA9IGNtcCB4MSB4MyBpblxuICAgICAgICAgICAgICBpZiBjID0gMCB0aGVuIFt4MTsgeDJdXG4gICAgICAgICAgICAgIGVsc2UgaWYgYyA+IDAgdGhlbiBbeDE7IHgzOyB4Ml1cbiAgICAgICAgICAgICAgZWxzZSBbeDM7IHgxOyB4Ml1cbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsZXQgYyA9IGNtcCB4MSB4MyBpblxuICAgICAgICAgICAgaWYgYyA9IDAgdGhlbiBbeDI7IHgxXVxuICAgICAgICAgICAgZWxzZSBpZiBjID4gMCB0aGVuIFt4MjsgeDE7IHgzXVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBsZXQgYyA9IGNtcCB4MiB4MyBpblxuICAgICAgICAgICAgICBpZiBjID0gMCB0aGVuIFt4MjsgeDFdXG4gICAgICAgICAgICAgIGVsc2UgaWYgYyA+IDAgdGhlbiBbeDI7IHgzOyB4MV1cbiAgICAgICAgICAgICAgZWxzZSBbeDM7IHgyOyB4MV1cbiAgICAgICAgaW5cbiAgICAgICAgKHMsIHRsKVxuICAgIHwgbiwgbCAtPlxuICAgICAgICBsZXQgbjEgPSBuIGFzciAxIGluXG4gICAgICAgIGxldCBuMiA9IG4gLSBuMSBpblxuICAgICAgICBsZXQgczEsIGwyID0gc29ydCBuMSBsIGluXG4gICAgICAgIGxldCBzMiwgdGwgPSBzb3J0IG4yIGwyIGluXG4gICAgICAgIChyZXZfbWVyZ2UgczEgczIgW10sIHRsKVxuICBpblxuICBsZXQgbGVuID0gbGVuZ3RoIGwgaW5cbiAgaWYgbGVuIDwgMiB0aGVuIGwgZWxzZSBmc3QgKHNvcnQgbGVuIGwpXG5cblxubGV0IHJlYyBjb21wYXJlX2xlbmd0aHMgbDEgbDIgPVxuICBtYXRjaCBsMSwgbDIgd2l0aFxuICB8IFtdLCBbXSAtPiAwXG4gIHwgW10sIF8gLT4gLTFcbiAgfCBfLCBbXSAtPiAxXG4gIHwgXyA6OiBsMSwgXyA6OiBsMiAtPiBjb21wYXJlX2xlbmd0aHMgbDEgbDJcbjs7XG5cbmxldCByZWMgY29tcGFyZV9sZW5ndGhfd2l0aCBsIG4gPVxuICBtYXRjaCBsIHdpdGhcbiAgfCBbXSAtPlxuICAgIGlmIG4gPSAwIHRoZW4gMCBlbHNlXG4gICAgICBpZiBuID4gMCB0aGVuIC0xIGVsc2UgMVxuICB8IF8gOjogbCAtPlxuICAgIGlmIG4gPD0gMCB0aGVuIDEgZWxzZVxuICAgICAgY29tcGFyZV9sZW5ndGhfd2l0aCBsIChuLTEpXG47O1xuXG4oKiogezEgQ29tcGFyaXNvbn0gKilcblxuKCogTm90ZTogd2UgYXJlICpub3QqIHNob3J0Y3V0dGluZyB0aGUgbGlzdCBieSB1c2luZ1xuICAgW0xpc3QuY29tcGFyZV9sZW5ndGhzXSBmaXJzdDsgdGhpcyBtYXkgYmUgc2xvd2VyIG9uIGxvbmcgbGlzdHNcbiAgIGltbWVkaWF0ZWx5IHN0YXJ0IHdpdGggZGlzdGluY3QgZWxlbWVudHMuIEl0IGlzIGFsc28gaW5jb3JyZWN0IGZvclxuICAgW2NvbXBhcmVdIGJlbG93LCBhbmQgaXQgaXMgYmV0dGVyIChwcmluY2lwbGUgb2YgbGVhc3Qgc3VycHJpc2UpIHRvXG4gICB1c2UgdGhlIHNhbWUgYXBwcm9hY2ggZm9yIGJvdGggZnVuY3Rpb25zLiAqKVxubGV0IHJlYyBlcXVhbCBlcSBsMSBsMiA9XG4gIG1hdGNoIGwxLCBsMiB3aXRoXG4gIHwgW10sIFtdIC0+IHRydWVcbiAgfCBbXSwgXzo6XyB8IF86Ol8sIFtdIC0+IGZhbHNlXG4gIHwgYTE6OmwxLCBhMjo6bDIgLT4gZXEgYTEgYTIgJiYgZXF1YWwgZXEgbDEgbDJcblxubGV0IHJlYyBjb21wYXJlIGNtcCBsMSBsMiA9XG4gIG1hdGNoIGwxLCBsMiB3aXRoXG4gIHwgW10sIFtdIC0+IDBcbiAgfCBbXSwgXzo6XyAtPiAtMVxuICB8IF86Ol8sIFtdIC0+IDFcbiAgfCBhMTo6bDEsIGEyOjpsMiAtPlxuICAgIGxldCBjID0gY21wIGExIGEyIGluXG4gICAgaWYgYyA8PiAwIHRoZW4gY1xuICAgIGVsc2UgY29tcGFyZSBjbXAgbDEgbDJcblxuKCoqIHsxIEl0ZXJhdG9yc30gKilcblxubGV0IHRvX3NlcSBsID1cbiAgbGV0IHJlYyBhdXggbCAoKSA9IG1hdGNoIGwgd2l0aFxuICAgIHwgW10gLT4gU2VxLk5pbFxuICAgIHwgeCA6OiB0YWlsIC0+IFNlcS5Db25zICh4LCBhdXggdGFpbClcbiAgaW5cbiAgYXV4IGxcblxubGV0IG9mX3NlcSBzZXEgPVxuICBsZXQgcmVjIGRpcmVjdCBkZXB0aCBzZXEgOiBfIGxpc3QgPVxuICAgIGlmIGRlcHRoPTBcbiAgICB0aGVuXG4gICAgICBTZXEuZm9sZF9sZWZ0IChmdW4gYWNjIHggLT4geDo6YWNjKSBbXSBzZXFcbiAgICAgIHw+IHJldiAoKiB0YWlscmVjICopXG4gICAgZWxzZSBtYXRjaCBzZXEoKSB3aXRoXG4gICAgICB8IFNlcS5OaWwgLT4gW11cbiAgICAgIHwgU2VxLkNvbnMgKHgsIG5leHQpIC0+IHggOjogZGlyZWN0IChkZXB0aC0xKSBuZXh0XG4gIGluXG4gIGRpcmVjdCA1MDAgc2VxXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgT0NhbWwgcHJvZ3JhbW1lcnMgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE4IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUgdCA9IGludFxuXG5sZXQgemVybyA9IDBcbmxldCBvbmUgPSAxXG5sZXQgbWludXNfb25lID0gLTFcbmV4dGVybmFsIG5lZyA6IGludCAtPiBpbnQgPSBcIiVuZWdpbnRcIlxuZXh0ZXJuYWwgYWRkIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVhZGRpbnRcIlxuZXh0ZXJuYWwgc3ViIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVzdWJpbnRcIlxuZXh0ZXJuYWwgbXVsIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVtdWxpbnRcIlxuZXh0ZXJuYWwgZGl2IDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVkaXZpbnRcIlxuZXh0ZXJuYWwgcmVtIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVtb2RpbnRcIlxuZXh0ZXJuYWwgc3VjYyA6IGludCAtPiBpbnQgPSBcIiVzdWNjaW50XCJcbmV4dGVybmFsIHByZWQgOiBpbnQgLT4gaW50ID0gXCIlcHJlZGludFwiXG5sZXQgYWJzIHggPSBpZiB4ID49IDAgdGhlbiB4IGVsc2UgLXhcbmxldCBtYXhfaW50ID0gKC0xKSBsc3IgMVxubGV0IG1pbl9pbnQgPSBtYXhfaW50ICsgMVxuZXh0ZXJuYWwgbG9nYW5kIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVhbmRpbnRcIlxuZXh0ZXJuYWwgbG9nb3IgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJW9yaW50XCJcbmV4dGVybmFsIGxvZ3hvciA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIleG9yaW50XCJcbmxldCBsb2dub3QgeCA9IGxvZ3hvciB4ICgtMSlcbmV4dGVybmFsIHNoaWZ0X2xlZnQgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWxzbGludFwiXG5leHRlcm5hbCBzaGlmdF9yaWdodCA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlYXNyaW50XCJcbmV4dGVybmFsIHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWxzcmludFwiXG5sZXQgZXF1YWwgOiBpbnQgLT4gaW50IC0+IGJvb2wgPSAoID0gKVxubGV0IGNvbXBhcmUgOiBpbnQgLT4gaW50IC0+IGludCA9IFN0ZGxpYi5jb21wYXJlXG5sZXQgbWluIHggeSA6IHQgPSBpZiB4IDw9IHkgdGhlbiB4IGVsc2UgeVxubGV0IG1heCB4IHkgOiB0ID0gaWYgeCA+PSB5IHRoZW4geCBlbHNlIHlcbmV4dGVybmFsIHRvX2Zsb2F0IDogaW50IC0+IGZsb2F0ID0gXCIlZmxvYXRvZmludFwiXG5leHRlcm5hbCBvZl9mbG9hdCA6IGZsb2F0IC0+IGludCA9IFwiJWludG9mZmxvYXRcIlxuXG4oKlxuZXh0ZXJuYWwgaW50X29mX3N0cmluZyA6IHN0cmluZyAtPiBpbnQgPSBcImNhbWxfaW50X29mX3N0cmluZ1wiXG5sZXQgb2Zfc3RyaW5nIHMgPSB0cnkgU29tZSAoaW50X29mX3N0cmluZyBzKSB3aXRoIEZhaWx1cmUgXyAtPiBOb25lXG4qKVxuXG5leHRlcm5hbCBmb3JtYXRfaW50IDogc3RyaW5nIC0+IGludCAtPiBzdHJpbmcgPSBcImNhbWxfZm9ybWF0X2ludFwiXG5sZXQgdG9fc3RyaW5nIHggPSBmb3JtYXRfaW50IFwiJWRcIiB4XG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIEJ5dGUgc2VxdWVuY2Ugb3BlcmF0aW9ucyAqKVxuXG4oKiBXQVJOSU5HOiBTb21lIGZ1bmN0aW9ucyBpbiB0aGlzIGZpbGUgYXJlIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sIGZvclxuICAgZWZmaWNpZW5jeSByZWFzb25zLiBXaGVuIHlvdSBtb2RpZnkgdGhlIG9uZSBpbiB0aGlzIGZpbGUgeW91IG5lZWQgdG9cbiAgIG1vZGlmeSBpdHMgZHVwbGljYXRlIGluIHN0cmluZy5tbC5cbiAgIFRoZXNlIGZ1bmN0aW9ucyBoYXZlIGEgXCJkdXBsaWNhdGVkXCIgY29tbWVudCBhYm92ZSB0aGVpciBkZWZpbml0aW9uLlxuKilcblxuZXh0ZXJuYWwgbGVuZ3RoIDogYnl0ZXMgLT4gaW50ID0gXCIlYnl0ZXNfbGVuZ3RoXCJcbmV4dGVybmFsIHN0cmluZ19sZW5ndGggOiBzdHJpbmcgLT4gaW50ID0gXCIlc3RyaW5nX2xlbmd0aFwiXG5leHRlcm5hbCBnZXQgOiBieXRlcyAtPiBpbnQgLT4gY2hhciA9IFwiJWJ5dGVzX3NhZmVfZ2V0XCJcbmV4dGVybmFsIHNldCA6IGJ5dGVzIC0+IGludCAtPiBjaGFyIC0+IHVuaXQgPSBcIiVieXRlc19zYWZlX3NldFwiXG5leHRlcm5hbCBjcmVhdGUgOiBpbnQgLT4gYnl0ZXMgPSBcImNhbWxfY3JlYXRlX2J5dGVzXCJcbmV4dGVybmFsIHVuc2FmZV9nZXQgOiBieXRlcyAtPiBpbnQgLT4gY2hhciA9IFwiJWJ5dGVzX3Vuc2FmZV9nZXRcIlxuZXh0ZXJuYWwgdW5zYWZlX3NldCA6IGJ5dGVzIC0+IGludCAtPiBjaGFyIC0+IHVuaXQgPSBcIiVieXRlc191bnNhZmVfc2V0XCJcbmV4dGVybmFsIHVuc2FmZV9maWxsIDogYnl0ZXMgLT4gaW50IC0+IGludCAtPiBjaGFyIC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX2ZpbGxfYnl0ZXNcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdW5zYWZlX3RvX3N0cmluZyA6IGJ5dGVzIC0+IHN0cmluZyA9IFwiJWJ5dGVzX3RvX3N0cmluZ1wiXG5leHRlcm5hbCB1bnNhZmVfb2Zfc3RyaW5nIDogc3RyaW5nIC0+IGJ5dGVzID0gXCIlYnl0ZXNfb2Zfc3RyaW5nXCJcblxuZXh0ZXJuYWwgdW5zYWZlX2JsaXQgOiBieXRlcyAtPiBpbnQgLT4gYnl0ZXMgLT4gaW50IC0+IGludCAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9ibGl0X2J5dGVzXCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIHVuc2FmZV9ibGl0X3N0cmluZyA6IHN0cmluZyAtPiBpbnQgLT4gYnl0ZXMgLT4gaW50IC0+IGludCAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9ibGl0X3N0cmluZ1wiIFtAQG5vYWxsb2NdXG5cbmxldCBtYWtlIG4gYyA9XG4gIGxldCBzID0gY3JlYXRlIG4gaW5cbiAgdW5zYWZlX2ZpbGwgcyAwIG4gYztcbiAgc1xuXG5sZXQgaW5pdCBuIGYgPVxuICBsZXQgcyA9IGNyZWF0ZSBuIGluXG4gIGZvciBpID0gMCB0byBuIC0gMSBkb1xuICAgIHVuc2FmZV9zZXQgcyBpIChmIGkpXG4gIGRvbmU7XG4gIHNcblxubGV0IGVtcHR5ID0gY3JlYXRlIDBcblxubGV0IGNvcHkgcyA9XG4gIGxldCBsZW4gPSBsZW5ndGggcyBpblxuICBsZXQgciA9IGNyZWF0ZSBsZW4gaW5cbiAgdW5zYWZlX2JsaXQgcyAwIHIgMCBsZW47XG4gIHJcblxubGV0IHRvX3N0cmluZyBiID0gdW5zYWZlX3RvX3N0cmluZyAoY29weSBiKVxubGV0IG9mX3N0cmluZyBzID0gY29weSAodW5zYWZlX29mX3N0cmluZyBzKVxuXG5sZXQgc3ViIHMgb2ZzIGxlbiA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBsZW5ndGggcyAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiU3RyaW5nLnN1YiAvIEJ5dGVzLnN1YlwiXG4gIGVsc2UgYmVnaW5cbiAgICBsZXQgciA9IGNyZWF0ZSBsZW4gaW5cbiAgICB1bnNhZmVfYmxpdCBzIG9mcyByIDAgbGVuO1xuICAgIHJcbiAgZW5kXG5cbmxldCBzdWJfc3RyaW5nIGIgb2ZzIGxlbiA9IHVuc2FmZV90b19zdHJpbmcgKHN1YiBiIG9mcyBsZW4pXG5cbigqIGFkZGl0aW9uIHdpdGggYW4gb3ZlcmZsb3cgY2hlY2sgKilcbmxldCAoKyspIGEgYiA9XG4gIGxldCBjID0gYSArIGIgaW5cbiAgbWF0Y2ggYSA8IDAsIGIgPCAwLCBjIDwgMCB3aXRoXG4gIHwgdHJ1ZSAsIHRydWUgLCBmYWxzZVxuICB8IGZhbHNlLCBmYWxzZSwgdHJ1ZSAgLT4gaW52YWxpZF9hcmcgXCJCeXRlcy5leHRlbmRcIiAoKiBvdmVyZmxvdyAqKVxuICB8IF8gLT4gY1xuXG5sZXQgZXh0ZW5kIHMgbGVmdCByaWdodCA9XG4gIGxldCBsZW4gPSBsZW5ndGggcyArKyBsZWZ0ICsrIHJpZ2h0IGluXG4gIGxldCByID0gY3JlYXRlIGxlbiBpblxuICBsZXQgKHNyY29mZiwgZHN0b2ZmKSA9IGlmIGxlZnQgPCAwIHRoZW4gLWxlZnQsIDAgZWxzZSAwLCBsZWZ0IGluXG4gIGxldCBjcHlsZW4gPSBJbnQubWluIChsZW5ndGggcyAtIHNyY29mZikgKGxlbiAtIGRzdG9mZikgaW5cbiAgaWYgY3B5bGVuID4gMCB0aGVuIHVuc2FmZV9ibGl0IHMgc3Jjb2ZmIHIgZHN0b2ZmIGNweWxlbjtcbiAgclxuXG5sZXQgZmlsbCBzIG9mcyBsZW4gYyA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBsZW5ndGggcyAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiU3RyaW5nLmZpbGwgLyBCeXRlcy5maWxsXCJcbiAgZWxzZSB1bnNhZmVfZmlsbCBzIG9mcyBsZW4gY1xuXG5sZXQgYmxpdCBzMSBvZnMxIHMyIG9mczIgbGVuID1cbiAgaWYgbGVuIDwgMCB8fCBvZnMxIDwgMCB8fCBvZnMxID4gbGVuZ3RoIHMxIC0gbGVuXG4gICAgICAgICAgICAgfHwgb2ZzMiA8IDAgfHwgb2ZzMiA+IGxlbmd0aCBzMiAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiQnl0ZXMuYmxpdFwiXG4gIGVsc2UgdW5zYWZlX2JsaXQgczEgb2ZzMSBzMiBvZnMyIGxlblxuXG5sZXQgYmxpdF9zdHJpbmcgczEgb2ZzMSBzMiBvZnMyIGxlbiA9XG4gIGlmIGxlbiA8IDAgfHwgb2ZzMSA8IDAgfHwgb2ZzMSA+IHN0cmluZ19sZW5ndGggczEgLSBsZW5cbiAgICAgICAgICAgICB8fCBvZnMyIDwgMCB8fCBvZnMyID4gbGVuZ3RoIHMyIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJTdHJpbmcuYmxpdCAvIEJ5dGVzLmJsaXRfc3RyaW5nXCJcbiAgZWxzZSB1bnNhZmVfYmxpdF9zdHJpbmcgczEgb2ZzMSBzMiBvZnMyIGxlblxuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IGl0ZXIgZiBhID1cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCBhIC0gMSBkbyBmKHVuc2FmZV9nZXQgYSBpKSBkb25lXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgaXRlcmkgZiBhID1cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCBhIC0gMSBkbyBmIGkgKHVuc2FmZV9nZXQgYSBpKSBkb25lXG5cbmxldCBlbnN1cmVfZ2UgKHg6aW50KSB5ID0gaWYgeCA+PSB5IHRoZW4geCBlbHNlIGludmFsaWRfYXJnIFwiQnl0ZXMuY29uY2F0XCJcblxubGV0IHJlYyBzdW1fbGVuZ3RocyBhY2Mgc2VwbGVuID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBhY2NcbiAgfCBoZCA6OiBbXSAtPiBsZW5ndGggaGQgKyBhY2NcbiAgfCBoZCA6OiB0bCAtPiBzdW1fbGVuZ3RocyAoZW5zdXJlX2dlIChsZW5ndGggaGQgKyBzZXBsZW4gKyBhY2MpIGFjYykgc2VwbGVuIHRsXG5cbmxldCByZWMgdW5zYWZlX2JsaXRzIGRzdCBwb3Mgc2VwIHNlcGxlbiA9IGZ1bmN0aW9uXG4gICAgW10gLT4gZHN0XG4gIHwgaGQgOjogW10gLT5cbiAgICB1bnNhZmVfYmxpdCBoZCAwIGRzdCBwb3MgKGxlbmd0aCBoZCk7IGRzdFxuICB8IGhkIDo6IHRsIC0+XG4gICAgdW5zYWZlX2JsaXQgaGQgMCBkc3QgcG9zIChsZW5ndGggaGQpO1xuICAgIHVuc2FmZV9ibGl0IHNlcCAwIGRzdCAocG9zICsgbGVuZ3RoIGhkKSBzZXBsZW47XG4gICAgdW5zYWZlX2JsaXRzIGRzdCAocG9zICsgbGVuZ3RoIGhkICsgc2VwbGVuKSBzZXAgc2VwbGVuIHRsXG5cbmxldCBjb25jYXQgc2VwID0gZnVuY3Rpb25cbiAgICBbXSAtPiBlbXB0eVxuICB8IGwgLT4gbGV0IHNlcGxlbiA9IGxlbmd0aCBzZXAgaW5cbiAgICAgICAgICB1bnNhZmVfYmxpdHNcbiAgICAgICAgICAgIChjcmVhdGUgKHN1bV9sZW5ndGhzIDAgc2VwbGVuIGwpKVxuICAgICAgICAgICAgMCBzZXAgc2VwbGVuIGxcblxubGV0IGNhdCBzMSBzMiA9XG4gIGxldCBsMSA9IGxlbmd0aCBzMSBpblxuICBsZXQgbDIgPSBsZW5ndGggczIgaW5cbiAgbGV0IHIgPSBjcmVhdGUgKGwxICsgbDIpIGluXG4gIHVuc2FmZV9ibGl0IHMxIDAgciAwIGwxO1xuICB1bnNhZmVfYmxpdCBzMiAwIHIgbDEgbDI7XG4gIHJcblxuXG5leHRlcm5hbCBjaGFyX2NvZGU6IGNoYXIgLT4gaW50ID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgY2hhcl9jaHI6IGludCAtPiBjaGFyID0gXCIlaWRlbnRpdHlcIlxuXG5sZXQgaXNfc3BhY2UgPSBmdW5jdGlvblxuICB8ICcgJyB8ICdcXDAxMicgfCAnXFxuJyB8ICdcXHInIHwgJ1xcdCcgLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2VcblxubGV0IHRyaW0gcyA9XG4gIGxldCBsZW4gPSBsZW5ndGggcyBpblxuICBsZXQgaSA9IHJlZiAwIGluXG4gIHdoaWxlICFpIDwgbGVuICYmIGlzX3NwYWNlICh1bnNhZmVfZ2V0IHMgIWkpIGRvXG4gICAgaW5jciBpXG4gIGRvbmU7XG4gIGxldCBqID0gcmVmIChsZW4gLSAxKSBpblxuICB3aGlsZSAhaiA+PSAhaSAmJiBpc19zcGFjZSAodW5zYWZlX2dldCBzICFqKSBkb1xuICAgIGRlY3IgalxuICBkb25lO1xuICBpZiAhaiA+PSAhaSB0aGVuXG4gICAgc3ViIHMgIWkgKCFqIC0gIWkgKyAxKVxuICBlbHNlXG4gICAgZW1wdHlcblxubGV0IGVzY2FwZWQgcyA9XG4gIGxldCBuID0gcmVmIDAgaW5cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCBzIC0gMSBkb1xuICAgIG4gOj0gIW4gK1xuICAgICAgKG1hdGNoIHVuc2FmZV9nZXQgcyBpIHdpdGhcbiAgICAgICB8ICdcXFwiJyB8ICdcXFxcJyB8ICdcXG4nIHwgJ1xcdCcgfCAnXFxyJyB8ICdcXGInIC0+IDJcbiAgICAgICB8ICcgJyAuLiAnficgLT4gMVxuICAgICAgIHwgXyAtPiA0KVxuICBkb25lO1xuICBpZiAhbiA9IGxlbmd0aCBzIHRoZW4gY29weSBzIGVsc2UgYmVnaW5cbiAgICBsZXQgcycgPSBjcmVhdGUgIW4gaW5cbiAgICBuIDo9IDA7XG4gICAgZm9yIGkgPSAwIHRvIGxlbmd0aCBzIC0gMSBkb1xuICAgICAgYmVnaW4gbWF0Y2ggdW5zYWZlX2dldCBzIGkgd2l0aFxuICAgICAgfCAoJ1xcXCInIHwgJ1xcXFwnKSBhcyBjIC0+XG4gICAgICAgICAgdW5zYWZlX3NldCBzJyAhbiAnXFxcXCc7IGluY3IgbjsgdW5zYWZlX3NldCBzJyAhbiBjXG4gICAgICB8ICdcXG4nIC0+XG4gICAgICAgICAgdW5zYWZlX3NldCBzJyAhbiAnXFxcXCc7IGluY3IgbjsgdW5zYWZlX3NldCBzJyAhbiAnbidcbiAgICAgIHwgJ1xcdCcgLT5cbiAgICAgICAgICB1bnNhZmVfc2V0IHMnICFuICdcXFxcJzsgaW5jciBuOyB1bnNhZmVfc2V0IHMnICFuICd0J1xuICAgICAgfCAnXFxyJyAtPlxuICAgICAgICAgIHVuc2FmZV9zZXQgcycgIW4gJ1xcXFwnOyBpbmNyIG47IHVuc2FmZV9zZXQgcycgIW4gJ3InXG4gICAgICB8ICdcXGInIC0+XG4gICAgICAgICAgdW5zYWZlX3NldCBzJyAhbiAnXFxcXCc7IGluY3IgbjsgdW5zYWZlX3NldCBzJyAhbiAnYidcbiAgICAgIHwgKCcgJyAuLiAnficpIGFzIGMgLT4gdW5zYWZlX3NldCBzJyAhbiBjXG4gICAgICB8IGMgLT5cbiAgICAgICAgICBsZXQgYSA9IGNoYXJfY29kZSBjIGluXG4gICAgICAgICAgdW5zYWZlX3NldCBzJyAhbiAnXFxcXCc7XG4gICAgICAgICAgaW5jciBuO1xuICAgICAgICAgIHVuc2FmZV9zZXQgcycgIW4gKGNoYXJfY2hyICg0OCArIGEgLyAxMDApKTtcbiAgICAgICAgICBpbmNyIG47XG4gICAgICAgICAgdW5zYWZlX3NldCBzJyAhbiAoY2hhcl9jaHIgKDQ4ICsgKGEgLyAxMCkgbW9kIDEwKSk7XG4gICAgICAgICAgaW5jciBuO1xuICAgICAgICAgIHVuc2FmZV9zZXQgcycgIW4gKGNoYXJfY2hyICg0OCArIGEgbW9kIDEwKSk7XG4gICAgICBlbmQ7XG4gICAgICBpbmNyIG5cbiAgICBkb25lO1xuICAgIHMnXG4gIGVuZFxuXG5sZXQgbWFwIGYgcyA9XG4gIGxldCBsID0gbGVuZ3RoIHMgaW5cbiAgaWYgbCA9IDAgdGhlbiBzIGVsc2UgYmVnaW5cbiAgICBsZXQgciA9IGNyZWF0ZSBsIGluXG4gICAgZm9yIGkgPSAwIHRvIGwgLSAxIGRvIHVuc2FmZV9zZXQgciBpIChmICh1bnNhZmVfZ2V0IHMgaSkpIGRvbmU7XG4gICAgclxuICBlbmRcblxubGV0IG1hcGkgZiBzID1cbiAgbGV0IGwgPSBsZW5ndGggcyBpblxuICBpZiBsID0gMCB0aGVuIHMgZWxzZSBiZWdpblxuICAgIGxldCByID0gY3JlYXRlIGwgaW5cbiAgICBmb3IgaSA9IDAgdG8gbCAtIDEgZG8gdW5zYWZlX3NldCByIGkgKGYgaSAodW5zYWZlX2dldCBzIGkpKSBkb25lO1xuICAgIHJcbiAgZW5kXG5cbmxldCBmb2xkX2xlZnQgZiB4IGEgPVxuICBsZXQgciA9IHJlZiB4IGluXG4gIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG9cbiAgICByIDo9IGYgIXIgKHVuc2FmZV9nZXQgYSBpKVxuICBkb25lO1xuICAhclxuXG5sZXQgZm9sZF9yaWdodCBmIGEgeCA9XG4gIGxldCByID0gcmVmIHggaW5cbiAgZm9yIGkgPSBsZW5ndGggYSAtIDEgZG93bnRvIDAgZG9cbiAgICByIDo9IGYgKHVuc2FmZV9nZXQgYSBpKSAhclxuICBkb25lO1xuICAhclxuXG5sZXQgZXhpc3RzIHAgcyA9XG4gIGxldCBuID0gbGVuZ3RoIHMgaW5cbiAgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPSBuIHRoZW4gZmFsc2VcbiAgICBlbHNlIGlmIHAgKHVuc2FmZV9nZXQgcyBpKSB0aGVuIHRydWVcbiAgICBlbHNlIGxvb3AgKHN1Y2MgaSkgaW5cbiAgbG9vcCAwXG5cbmxldCBmb3JfYWxsIHAgcyA9XG4gIGxldCBuID0gbGVuZ3RoIHMgaW5cbiAgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPSBuIHRoZW4gdHJ1ZVxuICAgIGVsc2UgaWYgcCAodW5zYWZlX2dldCBzIGkpIHRoZW4gbG9vcCAoc3VjYyBpKVxuICAgIGVsc2UgZmFsc2UgaW5cbiAgbG9vcCAwXG5cbmxldCB1cHBlcmNhc2VfYXNjaWkgcyA9IG1hcCBDaGFyLnVwcGVyY2FzZV9hc2NpaSBzXG5sZXQgbG93ZXJjYXNlX2FzY2lpIHMgPSBtYXAgQ2hhci5sb3dlcmNhc2VfYXNjaWkgc1xuXG5sZXQgYXBwbHkxIGYgcyA9XG4gIGlmIGxlbmd0aCBzID0gMCB0aGVuIHMgZWxzZSBiZWdpblxuICAgIGxldCByID0gY29weSBzIGluXG4gICAgdW5zYWZlX3NldCByIDAgKGYodW5zYWZlX2dldCBzIDApKTtcbiAgICByXG4gIGVuZFxuXG5sZXQgY2FwaXRhbGl6ZV9hc2NpaSBzID0gYXBwbHkxIENoYXIudXBwZXJjYXNlX2FzY2lpIHNcbmxldCB1bmNhcGl0YWxpemVfYXNjaWkgcyA9IGFwcGx5MSBDaGFyLmxvd2VyY2FzZV9hc2NpaSBzXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgc3RhcnRzX3dpdGggfnByZWZpeCBzID1cbiAgbGV0IGxlbl9zID0gbGVuZ3RoIHNcbiAgYW5kIGxlbl9wcmUgPSBsZW5ndGggcHJlZml4IGluXG4gIGxldCByZWMgYXV4IGkgPVxuICAgIGlmIGkgPSBsZW5fcHJlIHRoZW4gdHJ1ZVxuICAgIGVsc2UgaWYgdW5zYWZlX2dldCBzIGkgPD4gdW5zYWZlX2dldCBwcmVmaXggaSB0aGVuIGZhbHNlXG4gICAgZWxzZSBhdXggKGkgKyAxKVxuICBpbiBsZW5fcyA+PSBsZW5fcHJlICYmIGF1eCAwXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgZW5kc193aXRoIH5zdWZmaXggcyA9XG4gIGxldCBsZW5fcyA9IGxlbmd0aCBzXG4gIGFuZCBsZW5fc3VmID0gbGVuZ3RoIHN1ZmZpeCBpblxuICBsZXQgZGlmZiA9IGxlbl9zIC0gbGVuX3N1ZiBpblxuICBsZXQgcmVjIGF1eCBpID1cbiAgICBpZiBpID0gbGVuX3N1ZiB0aGVuIHRydWVcbiAgICBlbHNlIGlmIHVuc2FmZV9nZXQgcyAoZGlmZiArIGkpIDw+IHVuc2FmZV9nZXQgc3VmZml4IGkgdGhlbiBmYWxzZVxuICAgIGVsc2UgYXV4IChpICsgMSlcbiAgaW4gZGlmZiA+PSAwICYmIGF1eCAwXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgcmVjIGluZGV4X3JlYyBzIGxpbSBpIGMgPVxuICBpZiBpID49IGxpbSB0aGVuIHJhaXNlIE5vdF9mb3VuZCBlbHNlXG4gIGlmIHVuc2FmZV9nZXQgcyBpID0gYyB0aGVuIGkgZWxzZSBpbmRleF9yZWMgcyBsaW0gKGkgKyAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgaW5kZXggcyBjID0gaW5kZXhfcmVjIHMgKGxlbmd0aCBzKSAwIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCByZWMgaW5kZXhfcmVjX29wdCBzIGxpbSBpIGMgPVxuICBpZiBpID49IGxpbSB0aGVuIE5vbmUgZWxzZVxuICBpZiB1bnNhZmVfZ2V0IHMgaSA9IGMgdGhlbiBTb21lIGkgZWxzZSBpbmRleF9yZWNfb3B0IHMgbGltIChpICsgMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IGluZGV4X29wdCBzIGMgPSBpbmRleF9yZWNfb3B0IHMgKGxlbmd0aCBzKSAwIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCBpbmRleF9mcm9tIHMgaSBjID1cbiAgbGV0IGwgPSBsZW5ndGggcyBpblxuICBpZiBpIDwgMCB8fCBpID4gbCB0aGVuIGludmFsaWRfYXJnIFwiU3RyaW5nLmluZGV4X2Zyb20gLyBCeXRlcy5pbmRleF9mcm9tXCIgZWxzZVxuICBpbmRleF9yZWMgcyBsIGkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IGluZGV4X2Zyb21fb3B0IHMgaSBjID1cbiAgbGV0IGwgPSBsZW5ndGggcyBpblxuICBpZiBpIDwgMCB8fCBpID4gbCB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJTdHJpbmcuaW5kZXhfZnJvbV9vcHQgLyBCeXRlcy5pbmRleF9mcm9tX29wdFwiXG4gIGVsc2VcbiAgICBpbmRleF9yZWNfb3B0IHMgbCBpIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCByZWMgcmluZGV4X3JlYyBzIGkgYyA9XG4gIGlmIGkgPCAwIHRoZW4gcmFpc2UgTm90X2ZvdW5kIGVsc2VcbiAgaWYgdW5zYWZlX2dldCBzIGkgPSBjIHRoZW4gaSBlbHNlIHJpbmRleF9yZWMgcyAoaSAtIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCByaW5kZXggcyBjID0gcmluZGV4X3JlYyBzIChsZW5ndGggcyAtIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCByaW5kZXhfZnJvbSBzIGkgYyA9XG4gIGlmIGkgPCAtMSB8fCBpID49IGxlbmd0aCBzIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIlN0cmluZy5yaW5kZXhfZnJvbSAvIEJ5dGVzLnJpbmRleF9mcm9tXCJcbiAgZWxzZVxuICAgIHJpbmRleF9yZWMgcyBpIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCByZWMgcmluZGV4X3JlY19vcHQgcyBpIGMgPVxuICBpZiBpIDwgMCB0aGVuIE5vbmUgZWxzZVxuICBpZiB1bnNhZmVfZ2V0IHMgaSA9IGMgdGhlbiBTb21lIGkgZWxzZSByaW5kZXhfcmVjX29wdCBzIChpIC0gMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IHJpbmRleF9vcHQgcyBjID0gcmluZGV4X3JlY19vcHQgcyAobGVuZ3RoIHMgLSAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgcmluZGV4X2Zyb21fb3B0IHMgaSBjID1cbiAgaWYgaSA8IC0xIHx8IGkgPj0gbGVuZ3RoIHMgdGhlblxuICAgIGludmFsaWRfYXJnIFwiU3RyaW5nLnJpbmRleF9mcm9tX29wdCAvIEJ5dGVzLnJpbmRleF9mcm9tX29wdFwiXG4gIGVsc2VcbiAgICByaW5kZXhfcmVjX29wdCBzIGkgY1xuXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgY29udGFpbnNfZnJvbSBzIGkgYyA9XG4gIGxldCBsID0gbGVuZ3RoIHMgaW5cbiAgaWYgaSA8IDAgfHwgaSA+IGwgdGhlblxuICAgIGludmFsaWRfYXJnIFwiU3RyaW5nLmNvbnRhaW5zX2Zyb20gLyBCeXRlcy5jb250YWluc19mcm9tXCJcbiAgZWxzZVxuICAgIHRyeSBpZ25vcmUgKGluZGV4X3JlYyBzIGwgaSBjKTsgdHJ1ZSB3aXRoIE5vdF9mb3VuZCAtPiBmYWxzZVxuXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgY29udGFpbnMgcyBjID0gY29udGFpbnNfZnJvbSBzIDAgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IHJjb250YWluc19mcm9tIHMgaSBjID1cbiAgaWYgaSA8IDAgfHwgaSA+PSBsZW5ndGggcyB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJTdHJpbmcucmNvbnRhaW5zX2Zyb20gLyBCeXRlcy5yY29udGFpbnNfZnJvbVwiXG4gIGVsc2VcbiAgICB0cnkgaWdub3JlIChyaW5kZXhfcmVjIHMgaSBjKTsgdHJ1ZSB3aXRoIE5vdF9mb3VuZCAtPiBmYWxzZVxuXG5cbnR5cGUgdCA9IGJ5dGVzXG5cbmxldCBjb21wYXJlICh4OiB0KSAoeTogdCkgPSBTdGRsaWIuY29tcGFyZSB4IHlcbmV4dGVybmFsIGVxdWFsIDogdCAtPiB0IC0+IGJvb2wgPSBcImNhbWxfYnl0ZXNfZXF1YWxcIiBbQEBub2FsbG9jXVxuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IHNwbGl0X29uX2NoYXIgc2VwIHMgPVxuICBsZXQgciA9IHJlZiBbXSBpblxuICBsZXQgaiA9IHJlZiAobGVuZ3RoIHMpIGluXG4gIGZvciBpID0gbGVuZ3RoIHMgLSAxIGRvd250byAwIGRvXG4gICAgaWYgdW5zYWZlX2dldCBzIGkgPSBzZXAgdGhlbiBiZWdpblxuICAgICAgciA6PSBzdWIgcyAoaSArIDEpICghaiAtIGkgLSAxKSA6OiAhcjtcbiAgICAgIGogOj0gaVxuICAgIGVuZFxuICBkb25lO1xuICBzdWIgcyAwICFqIDo6ICFyXG5cbigqIERlcHJlY2F0ZWQgZnVuY3Rpb25zIGltcGxlbWVudGVkIHZpYSBvdGhlciBkZXByZWNhdGVkIGZ1bmN0aW9ucyAqKVxuW0BAQG9jYW1sLndhcm5pbmcgXCItM1wiXVxubGV0IHVwcGVyY2FzZSBzID0gbWFwIENoYXIudXBwZXJjYXNlIHNcbmxldCBsb3dlcmNhc2UgcyA9IG1hcCBDaGFyLmxvd2VyY2FzZSBzXG5cbmxldCBjYXBpdGFsaXplIHMgPSBhcHBseTEgQ2hhci51cHBlcmNhc2Ugc1xubGV0IHVuY2FwaXRhbGl6ZSBzID0gYXBwbHkxIENoYXIubG93ZXJjYXNlIHNcblxuKCoqIHsxIEl0ZXJhdG9yc30gKilcblxubGV0IHRvX3NlcSBzID1cbiAgbGV0IHJlYyBhdXggaSAoKSA9XG4gICAgaWYgaSA9IGxlbmd0aCBzIHRoZW4gU2VxLk5pbFxuICAgIGVsc2VcbiAgICAgIGxldCB4ID0gZ2V0IHMgaSBpblxuICAgICAgU2VxLkNvbnMgKHgsIGF1eCAoaSsxKSlcbiAgaW5cbiAgYXV4IDBcblxubGV0IHRvX3NlcWkgcyA9XG4gIGxldCByZWMgYXV4IGkgKCkgPVxuICAgIGlmIGkgPSBsZW5ndGggcyB0aGVuIFNlcS5OaWxcbiAgICBlbHNlXG4gICAgICBsZXQgeCA9IGdldCBzIGkgaW5cbiAgICAgIFNlcS5Db25zICgoaSx4KSwgYXV4IChpKzEpKVxuICBpblxuICBhdXggMFxuXG5sZXQgb2Zfc2VxIGkgPVxuICBsZXQgbiA9IHJlZiAwIGluXG4gIGxldCBidWYgPSByZWYgKG1ha2UgMjU2ICdcXDAwMCcpIGluXG4gIGxldCByZXNpemUgKCkgPVxuICAgICgqIHJlc2l6ZSAqKVxuICAgIGxldCBuZXdfbGVuID0gSW50Lm1pbiAoMiAqIGxlbmd0aCAhYnVmKSBTeXMubWF4X3N0cmluZ19sZW5ndGggaW5cbiAgICBpZiBsZW5ndGggIWJ1ZiA9IG5ld19sZW4gdGhlbiBmYWlsd2l0aCBcIkJ5dGVzLm9mX3NlcTogY2Fubm90IGdyb3cgYnl0ZXNcIjtcbiAgICBsZXQgbmV3X2J1ZiA9IG1ha2UgbmV3X2xlbiAnXFwwMDAnIGluXG4gICAgYmxpdCAhYnVmIDAgbmV3X2J1ZiAwICFuO1xuICAgIGJ1ZiA6PSBuZXdfYnVmXG4gIGluXG4gIFNlcS5pdGVyXG4gICAgKGZ1biBjIC0+XG4gICAgICAgaWYgIW4gPSBsZW5ndGggIWJ1ZiB0aGVuIHJlc2l6ZSgpO1xuICAgICAgIHNldCAhYnVmICFuIGM7XG4gICAgICAgaW5jciBuKVxuICAgIGk7XG4gIHN1YiAhYnVmIDAgIW5cblxuKCoqIHs2IEJpbmFyeSBlbmNvZGluZy9kZWNvZGluZyBvZiBpbnRlZ2Vyc30gKilcblxuKCogVGhlIGdldF8gZnVuY3Rpb25zIGFyZSBhbGwgZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcblxuZXh0ZXJuYWwgdW5zYWZlX2dldF91aW50OCA6IGJ5dGVzIC0+IGludCAtPiBpbnQgPSBcIiVieXRlc191bnNhZmVfZ2V0XCJcbmV4dGVybmFsIHVuc2FmZV9nZXRfdWludDE2X25lIDogYnl0ZXMgLT4gaW50IC0+IGludCA9IFwiJWNhbWxfYnl0ZXNfZ2V0MTZ1XCJcbmV4dGVybmFsIGdldF91aW50OCA6IGJ5dGVzIC0+IGludCAtPiBpbnQgPSBcIiVieXRlc19zYWZlX2dldFwiXG5leHRlcm5hbCBnZXRfdWludDE2X25lIDogYnl0ZXMgLT4gaW50IC0+IGludCA9IFwiJWNhbWxfYnl0ZXNfZ2V0MTZcIlxuZXh0ZXJuYWwgZ2V0X2ludDMyX25lIDogYnl0ZXMgLT4gaW50IC0+IGludDMyID0gXCIlY2FtbF9ieXRlc19nZXQzMlwiXG5leHRlcm5hbCBnZXRfaW50NjRfbmUgOiBieXRlcyAtPiBpbnQgLT4gaW50NjQgPSBcIiVjYW1sX2J5dGVzX2dldDY0XCJcblxuZXh0ZXJuYWwgdW5zYWZlX3NldF91aW50OCA6IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gdW5pdCA9IFwiJWJ5dGVzX3Vuc2FmZV9zZXRcIlxuZXh0ZXJuYWwgdW5zYWZlX3NldF91aW50MTZfbmUgOiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gXCIlY2FtbF9ieXRlc19zZXQxNnVcIlxuZXh0ZXJuYWwgc2V0X2ludDggOiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IHVuaXQgPSBcIiVieXRlc19zYWZlX3NldFwiXG5leHRlcm5hbCBzZXRfaW50MTZfbmUgOiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IHVuaXQgPSBcIiVjYW1sX2J5dGVzX3NldDE2XCJcbmV4dGVybmFsIHNldF9pbnQzMl9uZSA6IGJ5dGVzIC0+IGludCAtPiBpbnQzMiAtPiB1bml0ID0gXCIlY2FtbF9ieXRlc19zZXQzMlwiXG5leHRlcm5hbCBzZXRfaW50NjRfbmUgOiBieXRlcyAtPiBpbnQgLT4gaW50NjQgLT4gdW5pdCA9IFwiJWNhbWxfYnl0ZXNfc2V0NjRcIlxuZXh0ZXJuYWwgc3dhcDE2IDogaW50IC0+IGludCA9IFwiJWJzd2FwMTZcIlxuZXh0ZXJuYWwgc3dhcDMyIDogaW50MzIgLT4gaW50MzIgPSBcIiVic3dhcF9pbnQzMlwiXG5leHRlcm5hbCBzd2FwNjQgOiBpbnQ2NCAtPiBpbnQ2NCA9IFwiJWJzd2FwX2ludDY0XCJcblxubGV0IHVuc2FmZV9nZXRfdWludDE2X2xlIGIgaSA9XG4gIGlmIFN5cy5iaWdfZW5kaWFuXG4gIHRoZW4gc3dhcDE2ICh1bnNhZmVfZ2V0X3VpbnQxNl9uZSBiIGkpXG4gIGVsc2UgdW5zYWZlX2dldF91aW50MTZfbmUgYiBpXG5cbmxldCB1bnNhZmVfZ2V0X3VpbnQxNl9iZSBiIGkgPVxuICBpZiBTeXMuYmlnX2VuZGlhblxuICB0aGVuIHVuc2FmZV9nZXRfdWludDE2X25lIGIgaVxuICBlbHNlIHN3YXAxNiAodW5zYWZlX2dldF91aW50MTZfbmUgYiBpKVxuXG5sZXQgZ2V0X2ludDggYiBpID1cbiAgKChnZXRfdWludDggYiBpKSBsc2wgKFN5cy5pbnRfc2l6ZSAtIDgpKSBhc3IgKFN5cy5pbnRfc2l6ZSAtIDgpXG5cbmxldCBnZXRfdWludDE2X2xlIGIgaSA9XG4gIGlmIFN5cy5iaWdfZW5kaWFuIHRoZW4gc3dhcDE2IChnZXRfdWludDE2X25lIGIgaSlcbiAgZWxzZSBnZXRfdWludDE2X25lIGIgaVxuXG5sZXQgZ2V0X3VpbnQxNl9iZSBiIGkgPVxuICBpZiBub3QgU3lzLmJpZ19lbmRpYW4gdGhlbiBzd2FwMTYgKGdldF91aW50MTZfbmUgYiBpKVxuICBlbHNlIGdldF91aW50MTZfbmUgYiBpXG5cbmxldCBnZXRfaW50MTZfbmUgYiBpID1cbiAgKChnZXRfdWludDE2X25lIGIgaSkgbHNsIChTeXMuaW50X3NpemUgLSAxNikpIGFzciAoU3lzLmludF9zaXplIC0gMTYpXG5cbmxldCBnZXRfaW50MTZfbGUgYiBpID1cbiAgKChnZXRfdWludDE2X2xlIGIgaSkgbHNsIChTeXMuaW50X3NpemUgLSAxNikpIGFzciAoU3lzLmludF9zaXplIC0gMTYpXG5cbmxldCBnZXRfaW50MTZfYmUgYiBpID1cbiAgKChnZXRfdWludDE2X2JlIGIgaSkgbHNsIChTeXMuaW50X3NpemUgLSAxNikpIGFzciAoU3lzLmludF9zaXplIC0gMTYpXG5cbmxldCBnZXRfaW50MzJfbGUgYiBpID1cbiAgaWYgU3lzLmJpZ19lbmRpYW4gdGhlbiBzd2FwMzIgKGdldF9pbnQzMl9uZSBiIGkpXG4gIGVsc2UgZ2V0X2ludDMyX25lIGIgaVxuXG5sZXQgZ2V0X2ludDMyX2JlIGIgaSA9XG4gIGlmIG5vdCBTeXMuYmlnX2VuZGlhbiB0aGVuIHN3YXAzMiAoZ2V0X2ludDMyX25lIGIgaSlcbiAgZWxzZSBnZXRfaW50MzJfbmUgYiBpXG5cbmxldCBnZXRfaW50NjRfbGUgYiBpID1cbiAgaWYgU3lzLmJpZ19lbmRpYW4gdGhlbiBzd2FwNjQgKGdldF9pbnQ2NF9uZSBiIGkpXG4gIGVsc2UgZ2V0X2ludDY0X25lIGIgaVxuXG5sZXQgZ2V0X2ludDY0X2JlIGIgaSA9XG4gIGlmIG5vdCBTeXMuYmlnX2VuZGlhbiB0aGVuIHN3YXA2NCAoZ2V0X2ludDY0X25lIGIgaSlcbiAgZWxzZSBnZXRfaW50NjRfbmUgYiBpXG5cbmxldCB1bnNhZmVfc2V0X3VpbnQxNl9sZSBiIGkgeCA9XG4gIGlmIFN5cy5iaWdfZW5kaWFuXG4gIHRoZW4gdW5zYWZlX3NldF91aW50MTZfbmUgYiBpIChzd2FwMTYgeClcbiAgZWxzZSB1bnNhZmVfc2V0X3VpbnQxNl9uZSBiIGkgeFxuXG5sZXQgdW5zYWZlX3NldF91aW50MTZfYmUgYiBpIHggPVxuICBpZiBTeXMuYmlnX2VuZGlhblxuICB0aGVuIHVuc2FmZV9zZXRfdWludDE2X25lIGIgaSB4IGVsc2VcbiAgdW5zYWZlX3NldF91aW50MTZfbmUgYiBpIChzd2FwMTYgeClcblxubGV0IHNldF9pbnQxNl9sZSBiIGkgeCA9XG4gIGlmIFN5cy5iaWdfZW5kaWFuIHRoZW4gc2V0X2ludDE2X25lIGIgaSAoc3dhcDE2IHgpXG4gIGVsc2Ugc2V0X2ludDE2X25lIGIgaSB4XG5cbmxldCBzZXRfaW50MTZfYmUgYiBpIHggPVxuICBpZiBub3QgU3lzLmJpZ19lbmRpYW4gdGhlbiBzZXRfaW50MTZfbmUgYiBpIChzd2FwMTYgeClcbiAgZWxzZSBzZXRfaW50MTZfbmUgYiBpIHhcblxubGV0IHNldF9pbnQzMl9sZSBiIGkgeCA9XG4gIGlmIFN5cy5iaWdfZW5kaWFuIHRoZW4gc2V0X2ludDMyX25lIGIgaSAoc3dhcDMyIHgpXG4gIGVsc2Ugc2V0X2ludDMyX25lIGIgaSB4XG5cbmxldCBzZXRfaW50MzJfYmUgYiBpIHggPVxuICBpZiBub3QgU3lzLmJpZ19lbmRpYW4gdGhlbiBzZXRfaW50MzJfbmUgYiBpIChzd2FwMzIgeClcbiAgZWxzZSBzZXRfaW50MzJfbmUgYiBpIHhcblxubGV0IHNldF9pbnQ2NF9sZSBiIGkgeCA9XG4gIGlmIFN5cy5iaWdfZW5kaWFuIHRoZW4gc2V0X2ludDY0X25lIGIgaSAoc3dhcDY0IHgpXG4gIGVsc2Ugc2V0X2ludDY0X25lIGIgaSB4XG5cbmxldCBzZXRfaW50NjRfYmUgYiBpIHggPVxuICBpZiBub3QgU3lzLmJpZ19lbmRpYW4gdGhlbiBzZXRfaW50NjRfbmUgYiBpIChzd2FwNjQgeClcbiAgZWxzZSBzZXRfaW50NjRfbmUgYiBpIHhcblxubGV0IHNldF91aW50OCA9IHNldF9pbnQ4XG5sZXQgc2V0X3VpbnQxNl9uZSA9IHNldF9pbnQxNl9uZVxubGV0IHNldF91aW50MTZfYmUgPSBzZXRfaW50MTZfYmVcbmxldCBzZXRfdWludDE2X2xlID0gc2V0X2ludDE2X2xlXG5cbigqIFVURiBjb2RlY3MgYW5kIHZhbGlkYXRpb25zICopXG5cbmxldCBkZWNfaW52YWxpZCA9IFVjaGFyLnV0Zl9kZWNvZGVfaW52YWxpZFxubGV0W0BpbmxpbmVdIGRlY19yZXQgbiB1ID0gVWNoYXIudXRmX2RlY29kZSBuIChVY2hhci51bnNhZmVfb2ZfaW50IHUpXG5cbigqIEluIGNhc2Ugb2YgZGVjb2RpbmcgZXJyb3IsIGlmIHdlIGVycm9yIG9uIHRoZSBmaXJzdCBieXRlLCB3ZVxuICAgY29uc3VtZSB0aGUgYnl0ZSwgb3RoZXJ3aXNlIHdlIGNvbnN1bWUgdGhlIFtuXSBieXRlcyBwcmVjZWVkaW5nXG4gICB0aGUgZXJyb3JpbmcgYnl0ZS5cblxuICAgVGhpcyBtZWFucyB0aGF0IGlmIGEgY2xpZW50IHVzZXMgZGVjb2RlcyB3aXRob3V0IGNhcmluZyBhYm91dFxuICAgdmFsaWRpdHkgaXQgbmF0dXJhbGx5IHJlcGxhY2UgYm9ndXMgZGF0YSB3aXRoIFVjaGFyLnJlcCBhY2NvcmRpbmdcbiAgIHRvIHRoZSBXSEFUV0cgRW5jb2Rpbmcgc3RhbmRhcmQuIE90aGVyIHNjaGVtZXMgYXJlIHBvc3NpYmxlIGJ5XG4gICBjb25zdWx0aW5nIHRoZSBudW1iZXIgb2YgdXNlZCBieXRlcyBvbiBpbnZhbGlkIGRlY29kZXMuIEZvciBtb3JlXG4gICBkZXRhaWxzIHNlZSBodHRwczovL2hzaXZvbmVuLmZpL2Jyb2tlbi11dGYtOC9cblxuICAgRm9yIHRoaXMgcmVhc29uIGluIFtnZXRfdXRmXzhfdWNoYXJdIHdlIGdyYWR1YWxseSBjaGVjayB0aGUgbmV4dFxuICAgYnl0ZSBpcyBhdmFpbGFibGUgcmF0aGVyIHRoYW4gZG9pbmcgaXQgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlXG4gICBmaXJzdCBieXRlLiBDb250cmFzdCB3aXRoIFtpc192YWxpZF91dGZfOF0uICopXG5cbigqIFVURi04ICopXG5cbmxldFtAaW5saW5lXSBub3RfaW5feDgwX3RvX3hCRiBiID0gYiBsc3IgNiA8PiAwYjEwXG5sZXRbQGlubGluZV0gbm90X2luX3hBMF90b194QkYgYiA9IGIgbHNyIDUgPD4gMGIxMDFcbmxldFtAaW5saW5lXSBub3RfaW5feDgwX3RvX3g5RiBiID0gYiBsc3IgNSA8PiAwYjEwMFxubGV0W0BpbmxpbmVdIG5vdF9pbl94OTBfdG9feEJGIGIgPSBiIDwgMHg5MCB8fCAweEJGIDwgYlxubGV0W0BpbmxpbmVdIG5vdF9pbl94ODBfdG9feDhGIGIgPSBiIGxzciA0IDw+IDB4OFxuXG5sZXRbQGlubGluZV0gdXRmXzhfdWNoYXJfMiBiMCBiMSA9XG4gICgoYjAgbGFuZCAweDFGKSBsc2wgNikgbG9yXG4gICgoYjEgbGFuZCAweDNGKSlcblxubGV0W0BpbmxpbmVdIHV0Zl84X3VjaGFyXzMgYjAgYjEgYjIgPVxuICAoKGIwIGxhbmQgMHgwRikgbHNsIDEyKSBsb3JcbiAgKChiMSBsYW5kIDB4M0YpIGxzbCA2KSBsb3JcbiAgKChiMiBsYW5kIDB4M0YpKVxuXG5sZXRbQGlubGluZV0gdXRmXzhfdWNoYXJfNCBiMCBiMSBiMiBiMyA9XG4gICgoYjAgbGFuZCAweDA3KSBsc2wgMTgpIGxvclxuICAoKGIxIGxhbmQgMHgzRikgbHNsIDEyKSBsb3JcbiAgKChiMiBsYW5kIDB4M0YpIGxzbCA2KSBsb3JcbiAgKChiMyBsYW5kIDB4M0YpKVxuXG5sZXQgZ2V0X3V0Zl84X3VjaGFyIGIgaSA9XG4gIGxldCBiMCA9IGdldF91aW50OCBiIGkgaW4gKCogcmFpc2VzIGlmIFtpXSBpcyBub3QgYSB2YWxpZCBpbmRleC4gKilcbiAgbGV0IGdldCA9IHVuc2FmZV9nZXRfdWludDggaW5cbiAgbGV0IG1heCA9IGxlbmd0aCBiIC0gMSBpblxuICBtYXRjaCBDaGFyLnVuc2FmZV9jaHIgYjAgd2l0aCAoKiBTZWUgVGhlIFVuaWNvZGUgU3RhbmRhcmQsIFRhYmxlIDMuNyAqKVxuICB8ICdcXHgwMCcgLi4gJ1xceDdGJyAtPiBkZWNfcmV0IDEgYjBcbiAgfCAnXFx4QzInIC4uICdcXHhERicgLT5cbiAgICAgIGxldCBpID0gaSArIDEgaW4gaWYgaSA+IG1heCB0aGVuIGRlY19pbnZhbGlkIDEgZWxzZVxuICAgICAgbGV0IGIxID0gZ2V0IGIgaSBpbiBpZiBub3RfaW5feDgwX3RvX3hCRiBiMSB0aGVuIGRlY19pbnZhbGlkIDEgZWxzZVxuICAgICAgZGVjX3JldCAyICh1dGZfOF91Y2hhcl8yIGIwIGIxKVxuICB8ICdcXHhFMCcgLT5cbiAgICAgIGxldCBpID0gaSArIDEgaW4gaWYgaSA+IG1heCB0aGVuIGRlY19pbnZhbGlkIDEgZWxzZVxuICAgICAgbGV0IGIxID0gZ2V0IGIgaSBpbiBpZiBub3RfaW5feEEwX3RvX3hCRiBiMSB0aGVuIGRlY19pbnZhbGlkIDEgZWxzZVxuICAgICAgbGV0IGkgPSBpICsgMSBpbiBpZiBpID4gbWF4IHRoZW4gZGVjX2ludmFsaWQgMiBlbHNlXG4gICAgICBsZXQgYjIgPSBnZXQgYiBpIGluIGlmIG5vdF9pbl94ODBfdG9feEJGIGIyIHRoZW4gZGVjX2ludmFsaWQgMiBlbHNlXG4gICAgICBkZWNfcmV0IDMgKHV0Zl84X3VjaGFyXzMgYjAgYjEgYjIpXG4gIHwgJ1xceEUxJyAuLiAnXFx4RUMnIHwgJ1xceEVFJyAuLiAnXFx4RUYnIC0+XG4gICAgICBsZXQgaSA9IGkgKyAxIGluIGlmIGkgPiBtYXggdGhlbiBkZWNfaW52YWxpZCAxIGVsc2VcbiAgICAgIGxldCBiMSA9IGdldCBiIGkgaW4gaWYgbm90X2luX3g4MF90b194QkYgYjEgdGhlbiBkZWNfaW52YWxpZCAxIGVsc2VcbiAgICAgIGxldCBpID0gaSArIDEgaW4gaWYgaSA+IG1heCB0aGVuIGRlY19pbnZhbGlkIDIgZWxzZVxuICAgICAgbGV0IGIyID0gZ2V0IGIgaSBpbiBpZiBub3RfaW5feDgwX3RvX3hCRiBiMiB0aGVuIGRlY19pbnZhbGlkIDIgZWxzZVxuICAgICAgZGVjX3JldCAzICh1dGZfOF91Y2hhcl8zIGIwIGIxIGIyKVxuICB8ICdcXHhFRCcgLT5cbiAgICAgIGxldCBpID0gaSArIDEgaW4gaWYgaSA+IG1heCB0aGVuIGRlY19pbnZhbGlkIDEgZWxzZVxuICAgICAgbGV0IGIxID0gZ2V0IGIgaSBpbiBpZiBub3RfaW5feDgwX3RvX3g5RiBiMSB0aGVuIGRlY19pbnZhbGlkIDEgZWxzZVxuICAgICAgbGV0IGkgPSBpICsgMSBpbiBpZiBpID4gbWF4IHRoZW4gZGVjX2ludmFsaWQgMiBlbHNlXG4gICAgICBsZXQgYjIgPSBnZXQgYiBpIGluIGlmIG5vdF9pbl94ODBfdG9feEJGIGIyIHRoZW4gZGVjX2ludmFsaWQgMiBlbHNlXG4gICAgICBkZWNfcmV0IDMgKHV0Zl84X3VjaGFyXzMgYjAgYjEgYjIpXG4gIHwgJ1xceEYwJyAtPlxuICAgICAgbGV0IGkgPSBpICsgMSBpbiBpZiBpID4gbWF4IHRoZW4gZGVjX2ludmFsaWQgMSBlbHNlXG4gICAgICBsZXQgYjEgPSBnZXQgYiBpIGluIGlmIG5vdF9pbl94OTBfdG9feEJGIGIxIHRoZW4gZGVjX2ludmFsaWQgMSBlbHNlXG4gICAgICBsZXQgaSA9IGkgKyAxIGluIGlmIGkgPiBtYXggdGhlbiBkZWNfaW52YWxpZCAyIGVsc2VcbiAgICAgIGxldCBiMiA9IGdldCBiIGkgaW4gaWYgbm90X2luX3g4MF90b194QkYgYjIgdGhlbiBkZWNfaW52YWxpZCAyIGVsc2VcbiAgICAgIGxldCBpID0gaSArIDEgaW4gaWYgaSA+IG1heCB0aGVuIGRlY19pbnZhbGlkIDMgZWxzZVxuICAgICAgbGV0IGIzID0gZ2V0IGIgaSBpbiBpZiBub3RfaW5feDgwX3RvX3hCRiBiMyB0aGVuIGRlY19pbnZhbGlkIDMgZWxzZVxuICAgICAgZGVjX3JldCA0ICh1dGZfOF91Y2hhcl80IGIwIGIxIGIyIGIzKVxuICB8ICdcXHhGMScgLi4gJ1xceEYzJyAtPlxuICAgICAgbGV0IGkgPSBpICsgMSBpbiBpZiBpID4gbWF4IHRoZW4gZGVjX2ludmFsaWQgMSBlbHNlXG4gICAgICBsZXQgYjEgPSBnZXQgYiBpIGluIGlmIG5vdF9pbl94ODBfdG9feEJGIGIxIHRoZW4gZGVjX2ludmFsaWQgMSBlbHNlXG4gICAgICBsZXQgaSA9IGkgKyAxIGluIGlmIGkgPiBtYXggdGhlbiBkZWNfaW52YWxpZCAyIGVsc2VcbiAgICAgIGxldCBiMiA9IGdldCBiIGkgaW4gaWYgbm90X2luX3g4MF90b194QkYgYjIgdGhlbiBkZWNfaW52YWxpZCAyIGVsc2VcbiAgICAgIGxldCBpID0gaSArIDEgaW4gaWYgaSA+IG1heCB0aGVuIGRlY19pbnZhbGlkIDMgZWxzZVxuICAgICAgbGV0IGIzID0gZ2V0IGIgaSBpbiBpZiBub3RfaW5feDgwX3RvX3hCRiBiMyB0aGVuIGRlY19pbnZhbGlkIDMgZWxzZVxuICAgICAgZGVjX3JldCA0ICh1dGZfOF91Y2hhcl80IGIwIGIxIGIyIGIzKVxuICB8ICdcXHhGNCcgLT5cbiAgICAgIGxldCBpID0gaSArIDEgaW4gaWYgaSA+IG1heCB0aGVuIGRlY19pbnZhbGlkIDEgZWxzZVxuICAgICAgbGV0IGIxID0gZ2V0IGIgaSBpbiBpZiBub3RfaW5feDgwX3RvX3g4RiBiMSB0aGVuIGRlY19pbnZhbGlkIDEgZWxzZVxuICAgICAgbGV0IGkgPSBpICsgMSBpbiBpZiBpID4gbWF4IHRoZW4gZGVjX2ludmFsaWQgMiBlbHNlXG4gICAgICBsZXQgYjIgPSBnZXQgYiBpIGluIGlmIG5vdF9pbl94ODBfdG9feEJGIGIyIHRoZW4gZGVjX2ludmFsaWQgMiBlbHNlXG4gICAgICBsZXQgaSA9IGkgKyAxIGluIGlmIGkgPiBtYXggdGhlbiBkZWNfaW52YWxpZCAzIGVsc2VcbiAgICAgIGxldCBiMyA9IGdldCBiIGkgaW4gaWYgbm90X2luX3g4MF90b194QkYgYjMgdGhlbiBkZWNfaW52YWxpZCAzIGVsc2VcbiAgICAgIGRlY19yZXQgNCAodXRmXzhfdWNoYXJfNCBiMCBiMSBiMiBiMylcbiAgfCBfIC0+IGRlY19pbnZhbGlkIDFcblxubGV0IHNldF91dGZfOF91Y2hhciBiIGkgdSA9XG4gIGxldCBzZXQgPSB1bnNhZmVfc2V0X3VpbnQ4IGluXG4gIGxldCBtYXggPSBsZW5ndGggYiAtIDEgaW5cbiAgbWF0Y2ggVWNoYXIudG9faW50IHUgd2l0aFxuICB8IHUgd2hlbiB1IDwgMCAtPiBhc3NlcnQgZmFsc2VcbiAgfCB1IHdoZW4gdSA8PSAweDAwN0YgLT5cbiAgICAgIHNldF91aW50OCBiIGkgdTtcbiAgICAgIDFcbiAgfCB1IHdoZW4gdSA8PSAweDA3RkYgLT5cbiAgICAgIGxldCBsYXN0ID0gaSArIDEgaW5cbiAgICAgIGlmIGxhc3QgPiBtYXggdGhlbiAwIGVsc2VcbiAgICAgIChzZXRfdWludDggYiBpICgweEMwIGxvciAodSBsc3IgNikpO1xuICAgICAgIHNldCBiIGxhc3QgKDB4ODAgbG9yICh1IGxhbmQgMHgzRikpO1xuICAgICAgIDIpXG4gIHwgdSB3aGVuIHUgPD0gMHhGRkZGIC0+XG4gICAgICBsZXQgbGFzdCA9IGkgKyAyIGluXG4gICAgICBpZiBsYXN0ID4gbWF4IHRoZW4gMCBlbHNlXG4gICAgICAoc2V0X3VpbnQ4IGIgaSAoMHhFMCBsb3IgKHUgbHNyIDEyKSk7XG4gICAgICAgc2V0IGIgKGkgKyAxKSAoMHg4MCBsb3IgKCh1IGxzciA2KSBsYW5kIDB4M0YpKTtcbiAgICAgICBzZXQgYiBsYXN0ICgweDgwIGxvciAodSBsYW5kIDB4M0YpKTtcbiAgICAgICAzKVxuICB8IHUgd2hlbiB1IDw9IDB4MTBGRkZGIC0+XG4gICAgICBsZXQgbGFzdCA9IGkgKyAzIGluXG4gICAgICBpZiBsYXN0ID4gbWF4IHRoZW4gMCBlbHNlXG4gICAgICAoc2V0X3VpbnQ4IGIgaSAoMHhGMCBsb3IgKHUgbHNyIDE4KSk7XG4gICAgICAgc2V0IGIgKGkgKyAxKSAoMHg4MCBsb3IgKCh1IGxzciAxMikgbGFuZCAweDNGKSk7XG4gICAgICAgc2V0IGIgKGkgKyAyKSAoMHg4MCBsb3IgKCh1IGxzciA2KSBsYW5kIDB4M0YpKTtcbiAgICAgICBzZXQgYiBsYXN0ICgweDgwIGxvciAodSBsYW5kIDB4M0YpKTtcbiAgICAgICA0KVxuICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbmxldCBpc192YWxpZF91dGZfOCBiID1cbiAgbGV0IHJlYyBsb29wIG1heCBiIGkgPVxuICAgIGlmIGkgPiBtYXggdGhlbiB0cnVlIGVsc2VcbiAgICBsZXQgZ2V0ID0gdW5zYWZlX2dldF91aW50OCBpblxuICAgIG1hdGNoIENoYXIudW5zYWZlX2NociAoZ2V0IGIgaSkgd2l0aFxuICAgIHwgJ1xceDAwJyAuLiAnXFx4N0YnIC0+IGxvb3AgbWF4IGIgKGkgKyAxKVxuICAgIHwgJ1xceEMyJyAuLiAnXFx4REYnIC0+XG4gICAgICAgIGxldCBsYXN0ID0gaSArIDEgaW5cbiAgICAgICAgaWYgbGFzdCA+IG1heFxuICAgICAgICB8fCBub3RfaW5feDgwX3RvX3hCRiAoZ2V0IGIgbGFzdClcbiAgICAgICAgdGhlbiBmYWxzZVxuICAgICAgICBlbHNlIGxvb3AgbWF4IGIgKGxhc3QgKyAxKVxuICAgIHwgJ1xceEUwJyAtPlxuICAgICAgICBsZXQgbGFzdCA9IGkgKyAyIGluXG4gICAgICAgIGlmIGxhc3QgPiBtYXhcbiAgICAgICAgfHwgbm90X2luX3hBMF90b194QkYgKGdldCBiIChpICsgMSkpXG4gICAgICAgIHx8IG5vdF9pbl94ODBfdG9feEJGIChnZXQgYiBsYXN0KVxuICAgICAgICB0aGVuIGZhbHNlXG4gICAgICAgIGVsc2UgbG9vcCBtYXggYiAobGFzdCArIDEpXG4gICAgfCAnXFx4RTEnIC4uICdcXHhFQycgfCAnXFx4RUUnIC4uICdcXHhFRicgLT5cbiAgICAgICAgbGV0IGxhc3QgPSBpICsgMiBpblxuICAgICAgICBpZiBsYXN0ID4gbWF4XG4gICAgICAgIHx8IG5vdF9pbl94ODBfdG9feEJGIChnZXQgYiAoaSArIDEpKVxuICAgICAgICB8fCBub3RfaW5feDgwX3RvX3hCRiAoZ2V0IGIgbGFzdClcbiAgICAgICAgdGhlbiBmYWxzZVxuICAgICAgICBlbHNlIGxvb3AgbWF4IGIgKGxhc3QgKyAxKVxuICAgIHwgJ1xceEVEJyAtPlxuICAgICAgICBsZXQgbGFzdCA9IGkgKyAyIGluXG4gICAgICAgIGlmIGxhc3QgPiBtYXhcbiAgICAgICAgfHwgbm90X2luX3g4MF90b194OUYgKGdldCBiIChpICsgMSkpXG4gICAgICAgIHx8IG5vdF9pbl94ODBfdG9feEJGIChnZXQgYiBsYXN0KVxuICAgICAgICB0aGVuIGZhbHNlXG4gICAgICAgIGVsc2UgbG9vcCBtYXggYiAobGFzdCArIDEpXG4gICAgfCAnXFx4RjAnIC0+XG4gICAgICAgIGxldCBsYXN0ID0gaSArIDMgaW5cbiAgICAgICAgaWYgbGFzdCA+IG1heFxuICAgICAgICB8fCBub3RfaW5feDkwX3RvX3hCRiAoZ2V0IGIgKGkgKyAxKSlcbiAgICAgICAgfHwgbm90X2luX3g4MF90b194QkYgKGdldCBiIChpICsgMikpXG4gICAgICAgIHx8IG5vdF9pbl94ODBfdG9feEJGIChnZXQgYiBsYXN0KVxuICAgICAgICB0aGVuIGZhbHNlXG4gICAgICAgIGVsc2UgbG9vcCBtYXggYiAobGFzdCArIDEpXG4gICAgfCAnXFx4RjEnIC4uICdcXHhGMycgLT5cbiAgICAgICAgbGV0IGxhc3QgPSBpICsgMyBpblxuICAgICAgICBpZiBsYXN0ID4gbWF4XG4gICAgICAgIHx8IG5vdF9pbl94ODBfdG9feEJGIChnZXQgYiAoaSArIDEpKVxuICAgICAgICB8fCBub3RfaW5feDgwX3RvX3hCRiAoZ2V0IGIgKGkgKyAyKSlcbiAgICAgICAgfHwgbm90X2luX3g4MF90b194QkYgKGdldCBiIGxhc3QpXG4gICAgICAgIHRoZW4gZmFsc2VcbiAgICAgICAgZWxzZSBsb29wIG1heCBiIChsYXN0ICsgMSlcbiAgICB8ICdcXHhGNCcgLT5cbiAgICAgICAgbGV0IGxhc3QgPSBpICsgMyBpblxuICAgICAgICBpZiBsYXN0ID4gbWF4XG4gICAgICAgIHx8IG5vdF9pbl94ODBfdG9feDhGIChnZXQgYiAoaSArIDEpKVxuICAgICAgICB8fCBub3RfaW5feDgwX3RvX3hCRiAoZ2V0IGIgKGkgKyAyKSlcbiAgICAgICAgfHwgbm90X2luX3g4MF90b194QkYgKGdldCBiIGxhc3QpXG4gICAgICAgIHRoZW4gZmFsc2VcbiAgICAgICAgZWxzZSBsb29wIG1heCBiIChsYXN0ICsgMSlcbiAgICB8IF8gLT4gZmFsc2VcbiAgaW5cbiAgbG9vcCAobGVuZ3RoIGIgLSAxKSBiIDBcblxuKCogVVRGLTE2QkUgKilcblxubGV0IGdldF91dGZfMTZiZV91Y2hhciBiIGkgPVxuICBsZXQgZ2V0ID0gdW5zYWZlX2dldF91aW50MTZfYmUgaW5cbiAgbGV0IG1heCA9IGxlbmd0aCBiIC0gMSBpblxuICBpZiBpIDwgMCB8fCBpID4gbWF4IHRoZW4gaW52YWxpZF9hcmcgXCJpbmRleCBvdXQgb2YgYm91bmRzXCIgZWxzZVxuICBpZiBpID0gbWF4IHRoZW4gZGVjX2ludmFsaWQgMSBlbHNlXG4gIG1hdGNoIGdldCBiIGkgd2l0aFxuICB8IHUgd2hlbiB1IDwgMHhEODAwIHx8IHUgPiAweERGRkYgLT4gZGVjX3JldCAyIHVcbiAgfCB1IHdoZW4gdSA+IDB4REJGRiAtPiBkZWNfaW52YWxpZCAyXG4gIHwgaGkgLT4gKCogY29tYmluZSBbaGldIHdpdGggYSBsb3cgc3Vycm9nYXRlICopXG4gICAgICBsZXQgbGFzdCA9IGkgKyAzIGluXG4gICAgICBpZiBsYXN0ID4gbWF4IHRoZW4gZGVjX2ludmFsaWQgKG1heCAtIGkgKyAxKSBlbHNlXG4gICAgICBtYXRjaCBnZXQgYiAoaSArIDIpIHdpdGhcbiAgICAgIHwgdSB3aGVuIHUgPCAweERDMDAgfHwgdSA+IDB4REZGRiAtPiBkZWNfaW52YWxpZCAyICgqIHJldHJ5IGhlcmUgKilcbiAgICAgIHwgbG8gLT5cbiAgICAgICAgICBsZXQgdSA9ICgoKGhpIGxhbmQgMHgzRkYpIGxzbCAxMCkgbG9yIChsbyBsYW5kIDB4M0ZGKSkgKyAweDEwMDAwIGluXG4gICAgICAgICAgZGVjX3JldCA0IHVcblxubGV0IHNldF91dGZfMTZiZV91Y2hhciBiIGkgdSA9XG4gIGxldCBzZXQgPSB1bnNhZmVfc2V0X3VpbnQxNl9iZSBpblxuICBsZXQgbWF4ID0gbGVuZ3RoIGIgLSAxIGluXG4gIGlmIGkgPCAwIHx8IGkgPiBtYXggdGhlbiBpbnZhbGlkX2FyZyBcImluZGV4IG91dCBvZiBib3VuZHNcIiBlbHNlXG4gIG1hdGNoIFVjaGFyLnRvX2ludCB1IHdpdGhcbiAgfCB1IHdoZW4gdSA8IDAgLT4gYXNzZXJ0IGZhbHNlXG4gIHwgdSB3aGVuIHUgPD0gMHhGRkZGIC0+XG4gICAgICBsZXQgbGFzdCA9IGkgKyAxIGluXG4gICAgICBpZiBsYXN0ID4gbWF4IHRoZW4gMCBlbHNlIChzZXQgYiBpIHU7IDIpXG4gIHwgdSB3aGVuIHUgPD0gMHgxMEZGRkYgLT5cbiAgICAgIGxldCBsYXN0ID0gaSArIDMgaW5cbiAgICAgIGlmIGxhc3QgPiBtYXggdGhlbiAwIGVsc2VcbiAgICAgIGxldCB1JyA9IHUgLSAweDEwMDAwIGluXG4gICAgICBsZXQgaGkgPSAoMHhEODAwIGxvciAodScgbHNyIDEwKSkgaW5cbiAgICAgIGxldCBsbyA9ICgweERDMDAgbG9yICh1JyBsYW5kIDB4M0ZGKSkgaW5cbiAgICAgIHNldCBiIGkgaGk7IHNldCBiIChpICsgMikgbG87IDRcbiAgfCBfIC0+IGFzc2VydCBmYWxzZVxuXG5sZXQgaXNfdmFsaWRfdXRmXzE2YmUgYiA9XG4gIGxldCByZWMgbG9vcCBtYXggYiBpID1cbiAgICBsZXQgZ2V0ID0gdW5zYWZlX2dldF91aW50MTZfYmUgaW5cbiAgICBpZiBpID4gbWF4IHRoZW4gdHJ1ZSBlbHNlXG4gICAgaWYgaSA9IG1heCB0aGVuIGZhbHNlIGVsc2VcbiAgICBtYXRjaCBnZXQgYiBpIHdpdGhcbiAgICB8IHUgd2hlbiB1IDwgMHhEODAwIHx8IHUgPiAweERGRkYgLT4gbG9vcCBtYXggYiAoaSArIDIpXG4gICAgfCB1IHdoZW4gdSA+IDB4REJGRiAtPiBmYWxzZVxuICAgIHwgX2hpIC0+XG4gICAgICAgIGxldCBsYXN0ID0gaSArIDMgaW5cbiAgICAgICAgaWYgbGFzdCA+IG1heCB0aGVuIGZhbHNlIGVsc2VcbiAgICAgICAgbWF0Y2ggZ2V0IGIgKGkgKyAyKSB3aXRoXG4gICAgICAgIHwgdSB3aGVuIHUgPCAweERDMDAgfHwgdSA+IDB4REZGRiAtPiBmYWxzZVxuICAgICAgICB8IF9sbyAtPiBsb29wIG1heCBiIChpICsgNClcbiAgaW5cbiAgbG9vcCAobGVuZ3RoIGIgLSAxKSBiIDBcblxuKCogVVRGLTE2TEUgKilcblxubGV0IGdldF91dGZfMTZsZV91Y2hhciBiIGkgPVxuICBsZXQgZ2V0ID0gdW5zYWZlX2dldF91aW50MTZfbGUgaW5cbiAgbGV0IG1heCA9IGxlbmd0aCBiIC0gMSBpblxuICBpZiBpIDwgMCB8fCBpID4gbWF4IHRoZW4gaW52YWxpZF9hcmcgXCJpbmRleCBvdXQgb2YgYm91bmRzXCIgZWxzZVxuICBpZiBpID0gbWF4IHRoZW4gZGVjX2ludmFsaWQgMSBlbHNlXG4gIG1hdGNoIGdldCBiIGkgd2l0aFxuICB8IHUgd2hlbiB1IDwgMHhEODAwIHx8IHUgPiAweERGRkYgLT4gZGVjX3JldCAyIHVcbiAgfCB1IHdoZW4gdSA+IDB4REJGRiAtPiBkZWNfaW52YWxpZCAyXG4gIHwgaGkgLT4gKCogY29tYmluZSBbaGldIHdpdGggYSBsb3cgc3Vycm9nYXRlICopXG4gICAgICBsZXQgbGFzdCA9IGkgKyAzIGluXG4gICAgICBpZiBsYXN0ID4gbWF4IHRoZW4gZGVjX2ludmFsaWQgKG1heCAtIGkgKyAxKSBlbHNlXG4gICAgICBtYXRjaCBnZXQgYiAoaSArIDIpIHdpdGhcbiAgICAgIHwgdSB3aGVuIHUgPCAweERDMDAgfHwgdSA+IDB4REZGRiAtPiBkZWNfaW52YWxpZCAyICgqIHJldHJ5IGhlcmUgKilcbiAgICAgIHwgbG8gLT5cbiAgICAgICAgICBsZXQgdSA9ICgoKGhpIGxhbmQgMHgzRkYpIGxzbCAxMCkgbG9yIChsbyBsYW5kIDB4M0ZGKSkgKyAweDEwMDAwIGluXG4gICAgICAgICAgZGVjX3JldCA0IHVcblxubGV0IHNldF91dGZfMTZsZV91Y2hhciBiIGkgdSA9XG4gIGxldCBzZXQgPSB1bnNhZmVfc2V0X3VpbnQxNl9sZSBpblxuICBsZXQgbWF4ID0gbGVuZ3RoIGIgLSAxIGluXG4gIGlmIGkgPCAwIHx8IGkgPiBtYXggdGhlbiBpbnZhbGlkX2FyZyBcImluZGV4IG91dCBvZiBib3VuZHNcIiBlbHNlXG4gIG1hdGNoIFVjaGFyLnRvX2ludCB1IHdpdGhcbiAgfCB1IHdoZW4gdSA8IDAgLT4gYXNzZXJ0IGZhbHNlXG4gIHwgdSB3aGVuIHUgPD0gMHhGRkZGIC0+XG4gICAgICBsZXQgbGFzdCA9IGkgKyAxIGluXG4gICAgICBpZiBsYXN0ID4gbWF4IHRoZW4gMCBlbHNlIChzZXQgYiBpIHU7IDIpXG4gIHwgdSB3aGVuIHUgPD0gMHgxMEZGRkYgLT5cbiAgICAgIGxldCBsYXN0ID0gaSArIDMgaW5cbiAgICAgIGlmIGxhc3QgPiBtYXggdGhlbiAwIGVsc2VcbiAgICAgIGxldCB1JyA9IHUgLSAweDEwMDAwIGluXG4gICAgICBsZXQgaGkgPSAoMHhEODAwIGxvciAodScgbHNyIDEwKSkgaW5cbiAgICAgIGxldCBsbyA9ICgweERDMDAgbG9yICh1JyBsYW5kIDB4M0ZGKSkgaW5cbiAgICAgIHNldCBiIGkgaGk7IHNldCBiIChpICsgMikgbG87IDRcbiAgfCBfIC0+IGFzc2VydCBmYWxzZVxuXG5sZXQgaXNfdmFsaWRfdXRmXzE2bGUgYiA9XG4gIGxldCByZWMgbG9vcCBtYXggYiBpID1cbiAgICBsZXQgZ2V0ID0gdW5zYWZlX2dldF91aW50MTZfbGUgaW5cbiAgICBpZiBpID4gbWF4IHRoZW4gdHJ1ZSBlbHNlXG4gICAgaWYgaSA9IG1heCB0aGVuIGZhbHNlIGVsc2VcbiAgICBtYXRjaCBnZXQgYiBpIHdpdGhcbiAgICB8IHUgd2hlbiB1IDwgMHhEODAwIHx8IHUgPiAweERGRkYgLT4gbG9vcCBtYXggYiAoaSArIDIpXG4gICAgfCB1IHdoZW4gdSA+IDB4REJGRiAtPiBmYWxzZVxuICAgIHwgX2hpIC0+XG4gICAgICAgIGxldCBsYXN0ID0gaSArIDMgaW5cbiAgICAgICAgaWYgbGFzdCA+IG1heCB0aGVuIGZhbHNlIGVsc2VcbiAgICAgICAgbWF0Y2ggZ2V0IGIgKGkgKyAyKSB3aXRoXG4gICAgICAgIHwgdSB3aGVuIHUgPCAweERDMDAgfHwgdSA+IDB4REZGRiAtPiBmYWxzZVxuICAgICAgICB8IF9sbyAtPiBsb29wIG1heCBiIChpICsgNClcbiAgaW5cbiAgbG9vcCAobGVuZ3RoIGIgLSAxKSBiIDBcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICBEYW1pZW4gRG9saWdleiwgcHJvamV0IEdhbGxpdW0sIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMTQgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogU3RyaW5nIG9wZXJhdGlvbnMsIGJhc2VkIG9uIGJ5dGUgc2VxdWVuY2Ugb3BlcmF0aW9ucyAqKVxuXG4oKiBXQVJOSU5HOiBTb21lIGZ1bmN0aW9ucyBpbiB0aGlzIGZpbGUgYXJlIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgZm9yXG4gICBlZmZpY2llbmN5IHJlYXNvbnMuIFdoZW4geW91IG1vZGlmeSB0aGUgb25lIGluIHRoaXMgZmlsZSB5b3UgbmVlZCB0b1xuICAgbW9kaWZ5IGl0cyBkdXBsaWNhdGUgaW4gYnl0ZXMubWwuXG4gICBUaGVzZSBmdW5jdGlvbnMgaGF2ZSBhIFwiZHVwbGljYXRlZFwiIGNvbW1lbnQgYWJvdmUgdGhlaXIgZGVmaW5pdGlvbi5cbiopXG5cbmV4dGVybmFsIGxlbmd0aCA6IHN0cmluZyAtPiBpbnQgPSBcIiVzdHJpbmdfbGVuZ3RoXCJcbmV4dGVybmFsIGdldCA6IHN0cmluZyAtPiBpbnQgLT4gY2hhciA9IFwiJXN0cmluZ19zYWZlX2dldFwiXG5leHRlcm5hbCBzZXQgOiBieXRlcyAtPiBpbnQgLT4gY2hhciAtPiB1bml0ID0gXCIlc3RyaW5nX3NhZmVfc2V0XCJcbmV4dGVybmFsIGNyZWF0ZSA6IGludCAtPiBieXRlcyA9IFwiY2FtbF9jcmVhdGVfc3RyaW5nXCJcbmV4dGVybmFsIHVuc2FmZV9nZXQgOiBzdHJpbmcgLT4gaW50IC0+IGNoYXIgPSBcIiVzdHJpbmdfdW5zYWZlX2dldFwiXG5leHRlcm5hbCB1bnNhZmVfc2V0IDogYnl0ZXMgLT4gaW50IC0+IGNoYXIgLT4gdW5pdCA9IFwiJXN0cmluZ191bnNhZmVfc2V0XCJcbmV4dGVybmFsIHVuc2FmZV9ibGl0IDogc3RyaW5nIC0+IGludCAtPiAgYnl0ZXMgLT4gaW50IC0+IGludCAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9ibGl0X3N0cmluZ1wiIFtAQG5vYWxsb2NdXG5leHRlcm5hbCB1bnNhZmVfZmlsbCA6IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gY2hhciAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9maWxsX3N0cmluZ1wiIFtAQG5vYWxsb2NdXG5cbm1vZHVsZSBCID0gQnl0ZXNcblxubGV0IGJ0cyA9IEIudW5zYWZlX3RvX3N0cmluZ1xubGV0IGJvcyA9IEIudW5zYWZlX29mX3N0cmluZ1xuXG5sZXQgbWFrZSBuIGMgPVxuICBCLm1ha2UgbiBjIHw+IGJ0c1xubGV0IGluaXQgbiBmID1cbiAgQi5pbml0IG4gZiB8PiBidHNcbmxldCBlbXB0eSA9IFwiXCJcbmxldCBjb3B5IHMgPVxuICBCLmNvcHkgKGJvcyBzKSB8PiBidHNcbmxldCBvZl9ieXRlcyA9IEIudG9fc3RyaW5nXG5sZXQgdG9fYnl0ZXMgPSBCLm9mX3N0cmluZ1xubGV0IHN1YiBzIG9mcyBsZW4gPVxuICBCLnN1YiAoYm9zIHMpIG9mcyBsZW4gfD4gYnRzXG5sZXQgZmlsbCA9XG4gIEIuZmlsbFxubGV0IGJsaXQgPVxuICBCLmJsaXRfc3RyaW5nXG5cbmxldCBlbnN1cmVfZ2UgKHg6aW50KSB5ID0gaWYgeCA+PSB5IHRoZW4geCBlbHNlIGludmFsaWRfYXJnIFwiU3RyaW5nLmNvbmNhdFwiXG5cbmxldCByZWMgc3VtX2xlbmd0aHMgYWNjIHNlcGxlbiA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gYWNjXG4gIHwgaGQgOjogW10gLT4gbGVuZ3RoIGhkICsgYWNjXG4gIHwgaGQgOjogdGwgLT4gc3VtX2xlbmd0aHMgKGVuc3VyZV9nZSAobGVuZ3RoIGhkICsgc2VwbGVuICsgYWNjKSBhY2MpIHNlcGxlbiB0bFxuXG5sZXQgcmVjIHVuc2FmZV9ibGl0cyBkc3QgcG9zIHNlcCBzZXBsZW4gPSBmdW5jdGlvblxuICAgIFtdIC0+IGRzdFxuICB8IGhkIDo6IFtdIC0+XG4gICAgdW5zYWZlX2JsaXQgaGQgMCBkc3QgcG9zIChsZW5ndGggaGQpOyBkc3RcbiAgfCBoZCA6OiB0bCAtPlxuICAgIHVuc2FmZV9ibGl0IGhkIDAgZHN0IHBvcyAobGVuZ3RoIGhkKTtcbiAgICB1bnNhZmVfYmxpdCBzZXAgMCBkc3QgKHBvcyArIGxlbmd0aCBoZCkgc2VwbGVuO1xuICAgIHVuc2FmZV9ibGl0cyBkc3QgKHBvcyArIGxlbmd0aCBoZCArIHNlcGxlbikgc2VwIHNlcGxlbiB0bFxuXG5sZXQgY29uY2F0IHNlcCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gXCJcIlxuICB8IGwgLT4gbGV0IHNlcGxlbiA9IGxlbmd0aCBzZXAgaW4gYnRzIEBAXG4gICAgICAgICAgdW5zYWZlX2JsaXRzXG4gICAgICAgICAgICAoQi5jcmVhdGUgKHN1bV9sZW5ndGhzIDAgc2VwbGVuIGwpKVxuICAgICAgICAgICAgMCBzZXAgc2VwbGVuIGxcblxubGV0IGNhdCA9ICggXiApXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCBpdGVyIGYgcyA9XG4gIGZvciBpID0gMCB0byBsZW5ndGggcyAtIDEgZG8gZiAodW5zYWZlX2dldCBzIGkpIGRvbmVcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IGl0ZXJpIGYgcyA9XG4gIGZvciBpID0gMCB0byBsZW5ndGggcyAtIDEgZG8gZiBpICh1bnNhZmVfZ2V0IHMgaSkgZG9uZVxuXG5sZXQgbWFwIGYgcyA9XG4gIEIubWFwIGYgKGJvcyBzKSB8PiBidHNcbmxldCBtYXBpIGYgcyA9XG4gIEIubWFwaSBmIChib3MgcykgfD4gYnRzXG5sZXQgZm9sZF9yaWdodCBmIHggYSA9XG4gIEIuZm9sZF9yaWdodCBmIChib3MgeCkgYVxubGV0IGZvbGRfbGVmdCBmIGEgeCA9XG4gIEIuZm9sZF9sZWZ0IGYgYSAoYm9zIHgpXG5sZXQgZXhpc3RzIGYgcyA9XG4gIEIuZXhpc3RzIGYgKGJvcyBzKVxubGV0IGZvcl9hbGwgZiBzID1cbiAgQi5mb3JfYWxsIGYgKGJvcyBzKVxuXG4oKiBCZXdhcmU6IHdlIGNhbm5vdCB1c2UgQi50cmltIG9yIEIuZXNjYXBlIGJlY2F1c2UgdGhleSBhbHdheXMgbWFrZSBhXG4gICBjb3B5LCBidXQgU3RyaW5nLm1saSBzcGVsbHMgb3V0IHNvbWUgY2FzZXMgd2hlcmUgd2UgYXJlIG5vdCBhbGxvd2VkXG4gICB0byBtYWtlIGEgY29weS4gKilcblxubGV0IGlzX3NwYWNlID0gZnVuY3Rpb25cbiAgfCAnICcgfCAnXFwwMTInIHwgJ1xcbicgfCAnXFxyJyB8ICdcXHQnIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG5cbmxldCB0cmltIHMgPVxuICBpZiBzID0gXCJcIiB0aGVuIHNcbiAgZWxzZSBpZiBpc19zcGFjZSAodW5zYWZlX2dldCBzIDApIHx8IGlzX3NwYWNlICh1bnNhZmVfZ2V0IHMgKGxlbmd0aCBzIC0gMSkpXG4gICAgdGhlbiBidHMgKEIudHJpbSAoYm9zIHMpKVxuICBlbHNlIHNcblxubGV0IGVzY2FwZWQgcyA9XG4gIGxldCByZWMgZXNjYXBlX2lmX25lZWRlZCBzIG4gaSA9XG4gICAgaWYgaSA+PSBuIHRoZW4gcyBlbHNlXG4gICAgICBtYXRjaCB1bnNhZmVfZ2V0IHMgaSB3aXRoXG4gICAgICB8ICdcXFwiJyB8ICdcXFxcJyB8ICdcXDAwMCcuLidcXDAzMScgfCAnXFwxMjcnLi4gJ1xcMjU1JyAtPlxuICAgICAgICAgIGJ0cyAoQi5lc2NhcGVkIChib3MgcykpXG4gICAgICB8IF8gLT4gZXNjYXBlX2lmX25lZWRlZCBzIG4gKGkrMSlcbiAgaW5cbiAgZXNjYXBlX2lmX25lZWRlZCBzIChsZW5ndGggcykgMFxuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgcmVjIGluZGV4X3JlYyBzIGxpbSBpIGMgPVxuICBpZiBpID49IGxpbSB0aGVuIHJhaXNlIE5vdF9mb3VuZCBlbHNlXG4gIGlmIHVuc2FmZV9nZXQgcyBpID0gYyB0aGVuIGkgZWxzZSBpbmRleF9yZWMgcyBsaW0gKGkgKyAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCBpbmRleCBzIGMgPSBpbmRleF9yZWMgcyAobGVuZ3RoIHMpIDAgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgcmVjIGluZGV4X3JlY19vcHQgcyBsaW0gaSBjID1cbiAgaWYgaSA+PSBsaW0gdGhlbiBOb25lIGVsc2VcbiAgaWYgdW5zYWZlX2dldCBzIGkgPSBjIHRoZW4gU29tZSBpIGVsc2UgaW5kZXhfcmVjX29wdCBzIGxpbSAoaSArIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IGluZGV4X29wdCBzIGMgPSBpbmRleF9yZWNfb3B0IHMgKGxlbmd0aCBzKSAwIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IGluZGV4X2Zyb20gcyBpIGMgPVxuICBsZXQgbCA9IGxlbmd0aCBzIGluXG4gIGlmIGkgPCAwIHx8IGkgPiBsIHRoZW4gaW52YWxpZF9hcmcgXCJTdHJpbmcuaW5kZXhfZnJvbSAvIEJ5dGVzLmluZGV4X2Zyb21cIiBlbHNlXG4gICAgaW5kZXhfcmVjIHMgbCBpIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IGluZGV4X2Zyb21fb3B0IHMgaSBjID1cbiAgbGV0IGwgPSBsZW5ndGggcyBpblxuICBpZiBpIDwgMCB8fCBpID4gbCB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJTdHJpbmcuaW5kZXhfZnJvbV9vcHQgLyBCeXRlcy5pbmRleF9mcm9tX29wdFwiXG4gIGVsc2VcbiAgICBpbmRleF9yZWNfb3B0IHMgbCBpIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IHJlYyByaW5kZXhfcmVjIHMgaSBjID1cbiAgaWYgaSA8IDAgdGhlbiByYWlzZSBOb3RfZm91bmQgZWxzZVxuICBpZiB1bnNhZmVfZ2V0IHMgaSA9IGMgdGhlbiBpIGVsc2UgcmluZGV4X3JlYyBzIChpIC0gMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgcmluZGV4IHMgYyA9IHJpbmRleF9yZWMgcyAobGVuZ3RoIHMgLSAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCByaW5kZXhfZnJvbSBzIGkgYyA9XG4gIGlmIGkgPCAtMSB8fCBpID49IGxlbmd0aCBzIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIlN0cmluZy5yaW5kZXhfZnJvbSAvIEJ5dGVzLnJpbmRleF9mcm9tXCJcbiAgZWxzZVxuICAgIHJpbmRleF9yZWMgcyBpIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IHJlYyByaW5kZXhfcmVjX29wdCBzIGkgYyA9XG4gIGlmIGkgPCAwIHRoZW4gTm9uZSBlbHNlXG4gIGlmIHVuc2FmZV9nZXQgcyBpID0gYyB0aGVuIFNvbWUgaSBlbHNlIHJpbmRleF9yZWNfb3B0IHMgKGkgLSAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCByaW5kZXhfb3B0IHMgYyA9IHJpbmRleF9yZWNfb3B0IHMgKGxlbmd0aCBzIC0gMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgcmluZGV4X2Zyb21fb3B0IHMgaSBjID1cbiAgaWYgaSA8IC0xIHx8IGkgPj0gbGVuZ3RoIHMgdGhlblxuICAgIGludmFsaWRfYXJnIFwiU3RyaW5nLnJpbmRleF9mcm9tX29wdCAvIEJ5dGVzLnJpbmRleF9mcm9tX29wdFwiXG4gIGVsc2VcbiAgICByaW5kZXhfcmVjX29wdCBzIGkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgY29udGFpbnNfZnJvbSBzIGkgYyA9XG4gIGxldCBsID0gbGVuZ3RoIHMgaW5cbiAgaWYgaSA8IDAgfHwgaSA+IGwgdGhlblxuICAgIGludmFsaWRfYXJnIFwiU3RyaW5nLmNvbnRhaW5zX2Zyb20gLyBCeXRlcy5jb250YWluc19mcm9tXCJcbiAgZWxzZVxuICAgIHRyeSBpZ25vcmUgKGluZGV4X3JlYyBzIGwgaSBjKTsgdHJ1ZSB3aXRoIE5vdF9mb3VuZCAtPiBmYWxzZVxuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgY29udGFpbnMgcyBjID0gY29udGFpbnNfZnJvbSBzIDAgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgcmNvbnRhaW5zX2Zyb20gcyBpIGMgPVxuICBpZiBpIDwgMCB8fCBpID49IGxlbmd0aCBzIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIlN0cmluZy5yY29udGFpbnNfZnJvbSAvIEJ5dGVzLnJjb250YWluc19mcm9tXCJcbiAgZWxzZVxuICAgIHRyeSBpZ25vcmUgKHJpbmRleF9yZWMgcyBpIGMpOyB0cnVlIHdpdGggTm90X2ZvdW5kIC0+IGZhbHNlXG5cbmxldCB1cHBlcmNhc2VfYXNjaWkgcyA9XG4gIEIudXBwZXJjYXNlX2FzY2lpIChib3MgcykgfD4gYnRzXG5sZXQgbG93ZXJjYXNlX2FzY2lpIHMgPVxuICBCLmxvd2VyY2FzZV9hc2NpaSAoYm9zIHMpIHw+IGJ0c1xubGV0IGNhcGl0YWxpemVfYXNjaWkgcyA9XG4gIEIuY2FwaXRhbGl6ZV9hc2NpaSAoYm9zIHMpIHw+IGJ0c1xubGV0IHVuY2FwaXRhbGl6ZV9hc2NpaSBzID1cbiAgQi51bmNhcGl0YWxpemVfYXNjaWkgKGJvcyBzKSB8PiBidHNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IHN0YXJ0c193aXRoIH5wcmVmaXggcyA9XG4gIGxldCBsZW5fcyA9IGxlbmd0aCBzXG4gIGFuZCBsZW5fcHJlID0gbGVuZ3RoIHByZWZpeCBpblxuICBsZXQgcmVjIGF1eCBpID1cbiAgICBpZiBpID0gbGVuX3ByZSB0aGVuIHRydWVcbiAgICBlbHNlIGlmIHVuc2FmZV9nZXQgcyBpIDw+IHVuc2FmZV9nZXQgcHJlZml4IGkgdGhlbiBmYWxzZVxuICAgIGVsc2UgYXV4IChpICsgMSlcbiAgaW4gbGVuX3MgPj0gbGVuX3ByZSAmJiBhdXggMFxuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgZW5kc193aXRoIH5zdWZmaXggcyA9XG4gIGxldCBsZW5fcyA9IGxlbmd0aCBzXG4gIGFuZCBsZW5fc3VmID0gbGVuZ3RoIHN1ZmZpeCBpblxuICBsZXQgZGlmZiA9IGxlbl9zIC0gbGVuX3N1ZiBpblxuICBsZXQgcmVjIGF1eCBpID1cbiAgICBpZiBpID0gbGVuX3N1ZiB0aGVuIHRydWVcbiAgICBlbHNlIGlmIHVuc2FmZV9nZXQgcyAoZGlmZiArIGkpIDw+IHVuc2FmZV9nZXQgc3VmZml4IGkgdGhlbiBmYWxzZVxuICAgIGVsc2UgYXV4IChpICsgMSlcbiAgaW4gZGlmZiA+PSAwICYmIGF1eCAwXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCBzcGxpdF9vbl9jaGFyIHNlcCBzID1cbiAgbGV0IHIgPSByZWYgW10gaW5cbiAgbGV0IGogPSByZWYgKGxlbmd0aCBzKSBpblxuICBmb3IgaSA9IGxlbmd0aCBzIC0gMSBkb3dudG8gMCBkb1xuICAgIGlmIHVuc2FmZV9nZXQgcyBpID0gc2VwIHRoZW4gYmVnaW5cbiAgICAgIHIgOj0gc3ViIHMgKGkgKyAxKSAoIWogLSBpIC0gMSkgOjogIXI7XG4gICAgICBqIDo9IGlcbiAgICBlbmRcbiAgZG9uZTtcbiAgc3ViIHMgMCAhaiA6OiAhclxuXG4oKiBEZXByZWNhdGVkIGZ1bmN0aW9ucyBpbXBsZW1lbnRlZCB2aWEgb3RoZXIgZGVwcmVjYXRlZCBmdW5jdGlvbnMgKilcbltAQEBvY2FtbC53YXJuaW5nIFwiLTNcIl1cbmxldCB1cHBlcmNhc2UgcyA9XG4gIEIudXBwZXJjYXNlIChib3MgcykgfD4gYnRzXG5sZXQgbG93ZXJjYXNlIHMgPVxuICBCLmxvd2VyY2FzZSAoYm9zIHMpIHw+IGJ0c1xubGV0IGNhcGl0YWxpemUgcyA9XG4gIEIuY2FwaXRhbGl6ZSAoYm9zIHMpIHw+IGJ0c1xubGV0IHVuY2FwaXRhbGl6ZSBzID1cbiAgQi51bmNhcGl0YWxpemUgKGJvcyBzKSB8PiBidHNcblxudHlwZSB0ID0gc3RyaW5nXG5cbmxldCBjb21wYXJlICh4OiB0KSAoeTogdCkgPSBTdGRsaWIuY29tcGFyZSB4IHlcbmV4dGVybmFsIGVxdWFsIDogc3RyaW5nIC0+IHN0cmluZyAtPiBib29sID0gXCJjYW1sX3N0cmluZ19lcXVhbFwiIFtAQG5vYWxsb2NdXG5cbigqKiB7MSBJdGVyYXRvcnN9ICopXG5cbmxldCB0b19zZXEgcyA9IGJvcyBzIHw+IEIudG9fc2VxXG5cbmxldCB0b19zZXFpIHMgPSBib3MgcyB8PiBCLnRvX3NlcWlcblxubGV0IG9mX3NlcSBnID0gQi5vZl9zZXEgZyB8PiBidHNcblxuKCogVVRGIGRlY29kZXJzIGFuZCB2YWxpZGF0b3JzICopXG5cbmxldCBnZXRfdXRmXzhfdWNoYXIgcyBpID0gQi5nZXRfdXRmXzhfdWNoYXIgKGJvcyBzKSBpXG5sZXQgaXNfdmFsaWRfdXRmXzggcyA9IEIuaXNfdmFsaWRfdXRmXzggKGJvcyBzKVxuXG5sZXQgZ2V0X3V0Zl8xNmJlX3VjaGFyIHMgaSA9IEIuZ2V0X3V0Zl8xNmJlX3VjaGFyIChib3MgcykgaVxubGV0IGlzX3ZhbGlkX3V0Zl8xNmJlIHMgPSBCLmlzX3ZhbGlkX3V0Zl8xNmJlIChib3MgcylcblxubGV0IGdldF91dGZfMTZsZV91Y2hhciBzIGkgPSBCLmdldF91dGZfMTZsZV91Y2hhciAoYm9zIHMpIGlcbmxldCBpc192YWxpZF91dGZfMTZsZSBzID0gQi5pc192YWxpZF91dGZfMTZsZSAoYm9zIHMpXG5cbigqKiB7NiBCaW5hcnkgZW5jb2RpbmcvZGVjb2Rpbmcgb2YgaW50ZWdlcnN9ICopXG5cbmV4dGVybmFsIGdldF91aW50OCA6IHN0cmluZyAtPiBpbnQgLT4gaW50ID0gXCIlc3RyaW5nX3NhZmVfZ2V0XCJcbmV4dGVybmFsIGdldF91aW50MTZfbmUgOiBzdHJpbmcgLT4gaW50IC0+IGludCA9IFwiJWNhbWxfc3RyaW5nX2dldDE2XCJcbmV4dGVybmFsIGdldF9pbnQzMl9uZSA6IHN0cmluZyAtPiBpbnQgLT4gaW50MzIgPSBcIiVjYW1sX3N0cmluZ19nZXQzMlwiXG5leHRlcm5hbCBnZXRfaW50NjRfbmUgOiBzdHJpbmcgLT4gaW50IC0+IGludDY0ID0gXCIlY2FtbF9zdHJpbmdfZ2V0NjRcIlxuXG5sZXQgZ2V0X2ludDggcyBpID0gQi5nZXRfaW50OCAoYm9zIHMpIGlcbmxldCBnZXRfdWludDE2X2xlIHMgaSA9IEIuZ2V0X3VpbnQxNl9sZSAoYm9zIHMpIGlcbmxldCBnZXRfdWludDE2X2JlIHMgaSA9IEIuZ2V0X3VpbnQxNl9iZSAoYm9zIHMpIGlcbmxldCBnZXRfaW50MTZfbmUgcyBpID0gQi5nZXRfaW50MTZfbmUgKGJvcyBzKSBpXG5sZXQgZ2V0X2ludDE2X2xlIHMgaSA9IEIuZ2V0X2ludDE2X2xlIChib3MgcykgaVxubGV0IGdldF9pbnQxNl9iZSBzIGkgPSBCLmdldF9pbnQxNl9iZSAoYm9zIHMpIGlcbmxldCBnZXRfaW50MzJfbGUgcyBpID0gQi5nZXRfaW50MzJfbGUgKGJvcyBzKSBpXG5sZXQgZ2V0X2ludDMyX2JlIHMgaSA9IEIuZ2V0X2ludDMyX2JlIChib3MgcykgaVxubGV0IGdldF9pbnQ2NF9sZSBzIGkgPSBCLmdldF9pbnQ2NF9sZSAoYm9zIHMpIGlcbmxldCBnZXRfaW50NjRfYmUgcyBpID0gQi5nZXRfaW50NjRfYmUgKGJvcyBzKSBpXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgT0NhbWwgcHJvZ3JhbW1lcnMgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE4IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUgdCA9IHVuaXQgPSAoKVxuXG5sZXQgZXF1YWwgKCkgKCkgPSB0cnVlXG5sZXQgY29tcGFyZSAoKSAoKSA9IDBcbmxldCB0b19zdHJpbmcgKCkgPSBcIigpXCJcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTcgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxudHlwZSBleHRlcm5fZmxhZ3MgPVxuICAgIE5vX3NoYXJpbmdcbiAgfCBDbG9zdXJlc1xuICB8IENvbXBhdF8zMlxuKCogbm90ZTogdGhpcyB0eXBlIGRlZmluaXRpb24gaXMgdXNlZCBpbiAncnVudGltZS9kZWJ1Z2dlci5jJyAqKVxuXG5leHRlcm5hbCB0b19jaGFubmVsOiBvdXRfY2hhbm5lbCAtPiAnYSAtPiBleHRlcm5fZmxhZ3MgbGlzdCAtPiB1bml0XG4gICAgPSBcImNhbWxfb3V0cHV0X3ZhbHVlXCJcbmV4dGVybmFsIHRvX2J5dGVzOiAnYSAtPiBleHRlcm5fZmxhZ3MgbGlzdCAtPiBieXRlc1xuICAgID0gXCJjYW1sX291dHB1dF92YWx1ZV90b19ieXRlc1wiXG5leHRlcm5hbCB0b19zdHJpbmc6ICdhIC0+IGV4dGVybl9mbGFncyBsaXN0IC0+IHN0cmluZ1xuICAgID0gXCJjYW1sX291dHB1dF92YWx1ZV90b19zdHJpbmdcIlxuZXh0ZXJuYWwgdG9fYnVmZmVyX3Vuc2FmZTpcbiAgICAgIGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gJ2EgLT4gZXh0ZXJuX2ZsYWdzIGxpc3QgLT4gaW50XG4gICAgPSBcImNhbWxfb3V0cHV0X3ZhbHVlX3RvX2J1ZmZlclwiXG5cbmxldCB0b19idWZmZXIgYnVmZiBvZnMgbGVuIHYgZmxhZ3MgPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gQnl0ZXMubGVuZ3RoIGJ1ZmYgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIk1hcnNoYWwudG9fYnVmZmVyOiBzdWJzdHJpbmcgb3V0IG9mIGJvdW5kc1wiXG4gIGVsc2UgdG9fYnVmZmVyX3Vuc2FmZSBidWZmIG9mcyBsZW4gdiBmbGFnc1xuXG4oKiBUaGUgZnVuY3Rpb25zIGJlbG93IHVzZSBieXRlIHNlcXVlbmNlcyBhcyBpbnB1dCwgbmV2ZXIgdXNpbmcgYW55XG4gICBtdXRhdGlvbi4gSXQgbWFrZXMgc2Vuc2UgdG8gdXNlIG5vbi1tdXRhdGVkIFtieXRlc10gcmF0aGVyIHRoYW5cbiAgIFtzdHJpbmddLCBiZWNhdXNlIHdlIHJlYWxseSB3b3JrIHdpdGggc2VxdWVuY2VzIG9mIGJ5dGVzLCBub3RcbiAgIGEgdGV4dCByZXByZXNlbnRhdGlvbi5cbiopXG5cbmV4dGVybmFsIGZyb21fY2hhbm5lbDogaW5fY2hhbm5lbCAtPiAnYSA9IFwiY2FtbF9pbnB1dF92YWx1ZVwiXG5leHRlcm5hbCBmcm9tX2J5dGVzX3Vuc2FmZTogYnl0ZXMgLT4gaW50IC0+ICdhID0gXCJjYW1sX2lucHV0X3ZhbHVlX2Zyb21fYnl0ZXNcIlxuZXh0ZXJuYWwgZGF0YV9zaXplX3Vuc2FmZTogYnl0ZXMgLT4gaW50IC0+IGludCA9IFwiY2FtbF9tYXJzaGFsX2RhdGFfc2l6ZVwiXG5cbmxldCBoZWFkZXJfc2l6ZSA9IDIwXG5sZXQgZGF0YV9zaXplIGJ1ZmYgb2ZzID1cbiAgaWYgb2ZzIDwgMCB8fCBvZnMgPiBCeXRlcy5sZW5ndGggYnVmZiAtIGhlYWRlcl9zaXplXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJNYXJzaGFsLmRhdGFfc2l6ZVwiXG4gIGVsc2UgZGF0YV9zaXplX3Vuc2FmZSBidWZmIG9mc1xubGV0IHRvdGFsX3NpemUgYnVmZiBvZnMgPSBoZWFkZXJfc2l6ZSArIGRhdGFfc2l6ZSBidWZmIG9mc1xuXG5sZXQgZnJvbV9ieXRlcyBidWZmIG9mcyA9XG4gIGlmIG9mcyA8IDAgfHwgb2ZzID4gQnl0ZXMubGVuZ3RoIGJ1ZmYgLSBoZWFkZXJfc2l6ZVxuICB0aGVuIGludmFsaWRfYXJnIFwiTWFyc2hhbC5mcm9tX2J5dGVzXCJcbiAgZWxzZSBiZWdpblxuICAgIGxldCBsZW4gPSBkYXRhX3NpemVfdW5zYWZlIGJ1ZmYgb2ZzIGluXG4gICAgaWYgb2ZzID4gQnl0ZXMubGVuZ3RoIGJ1ZmYgLSAoaGVhZGVyX3NpemUgKyBsZW4pXG4gICAgdGhlbiBpbnZhbGlkX2FyZyBcIk1hcnNoYWwuZnJvbV9ieXRlc1wiXG4gICAgZWxzZSBmcm9tX2J5dGVzX3Vuc2FmZSBidWZmIG9mc1xuICBlbmRcblxubGV0IGZyb21fc3RyaW5nIGJ1ZmYgb2ZzID1cbiAgKCogQnl0ZXMudW5zYWZlX29mX3N0cmluZyBpcyBzYWZlIGhlcmUsIGFzIHRoZSBwcm9kdWNlZCBieXRlXG4gICAgIHNlcXVlbmNlIGlzIG5ldmVyIG11dGF0ZWQgKilcbiAgZnJvbV9ieXRlcyAoQnl0ZXMudW5zYWZlX29mX3N0cmluZyBidWZmKSBvZnNcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogQW4gYWxpYXMgZm9yIHRoZSB0eXBlIG9mIGFycmF5cy4gKilcbnR5cGUgJ2EgdCA9ICdhIGFycmF5XG5cbigqIEFycmF5IG9wZXJhdGlvbnMgKilcblxuZXh0ZXJuYWwgbGVuZ3RoIDogJ2EgYXJyYXkgLT4gaW50ID0gXCIlYXJyYXlfbGVuZ3RoXCJcbmV4dGVybmFsIGdldDogJ2EgYXJyYXkgLT4gaW50IC0+ICdhID0gXCIlYXJyYXlfc2FmZV9nZXRcIlxuZXh0ZXJuYWwgc2V0OiAnYSBhcnJheSAtPiBpbnQgLT4gJ2EgLT4gdW5pdCA9IFwiJWFycmF5X3NhZmVfc2V0XCJcbmV4dGVybmFsIHVuc2FmZV9nZXQ6ICdhIGFycmF5IC0+IGludCAtPiAnYSA9IFwiJWFycmF5X3Vuc2FmZV9nZXRcIlxuZXh0ZXJuYWwgdW5zYWZlX3NldDogJ2EgYXJyYXkgLT4gaW50IC0+ICdhIC0+IHVuaXQgPSBcIiVhcnJheV91bnNhZmVfc2V0XCJcbmV4dGVybmFsIG1ha2U6IGludCAtPiAnYSAtPiAnYSBhcnJheSA9IFwiY2FtbF9tYWtlX3ZlY3RcIlxuZXh0ZXJuYWwgY3JlYXRlOiBpbnQgLT4gJ2EgLT4gJ2EgYXJyYXkgPSBcImNhbWxfbWFrZV92ZWN0XCJcbmV4dGVybmFsIHVuc2FmZV9zdWIgOiAnYSBhcnJheSAtPiBpbnQgLT4gaW50IC0+ICdhIGFycmF5ID0gXCJjYW1sX2FycmF5X3N1YlwiXG5leHRlcm5hbCBhcHBlbmRfcHJpbSA6ICdhIGFycmF5IC0+ICdhIGFycmF5IC0+ICdhIGFycmF5ID0gXCJjYW1sX2FycmF5X2FwcGVuZFwiXG5leHRlcm5hbCBjb25jYXQgOiAnYSBhcnJheSBsaXN0IC0+ICdhIGFycmF5ID0gXCJjYW1sX2FycmF5X2NvbmNhdFwiXG5leHRlcm5hbCB1bnNhZmVfYmxpdCA6XG4gICdhIGFycmF5IC0+IGludCAtPiAnYSBhcnJheSAtPiBpbnQgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfYXJyYXlfYmxpdFwiXG5leHRlcm5hbCB1bnNhZmVfZmlsbCA6XG4gICdhIGFycmF5IC0+IGludCAtPiBpbnQgLT4gJ2EgLT4gdW5pdCA9IFwiY2FtbF9hcnJheV9maWxsXCJcbmV4dGVybmFsIGNyZWF0ZV9mbG9hdDogaW50IC0+IGZsb2F0IGFycmF5ID0gXCJjYW1sX21ha2VfZmxvYXRfdmVjdFwiXG5sZXQgbWFrZV9mbG9hdCA9IGNyZWF0ZV9mbG9hdFxuXG5tb2R1bGUgRmxvYXRhcnJheSA9IHN0cnVjdFxuICBleHRlcm5hbCBjcmVhdGUgOiBpbnQgLT4gZmxvYXRhcnJheSA9IFwiY2FtbF9mbG9hdGFycmF5X2NyZWF0ZVwiXG4gIGV4dGVybmFsIGxlbmd0aCA6IGZsb2F0YXJyYXkgLT4gaW50ID0gXCIlZmxvYXRhcnJheV9sZW5ndGhcIlxuICBleHRlcm5hbCBnZXQgOiBmbG9hdGFycmF5IC0+IGludCAtPiBmbG9hdCA9IFwiJWZsb2F0YXJyYXlfc2FmZV9nZXRcIlxuICBleHRlcm5hbCBzZXQgOiBmbG9hdGFycmF5IC0+IGludCAtPiBmbG9hdCAtPiB1bml0ID0gXCIlZmxvYXRhcnJheV9zYWZlX3NldFwiXG4gIGV4dGVybmFsIHVuc2FmZV9nZXQgOiBmbG9hdGFycmF5IC0+IGludCAtPiBmbG9hdCA9IFwiJWZsb2F0YXJyYXlfdW5zYWZlX2dldFwiXG4gIGV4dGVybmFsIHVuc2FmZV9zZXQgOiBmbG9hdGFycmF5IC0+IGludCAtPiBmbG9hdCAtPiB1bml0XG4gICAgICA9IFwiJWZsb2F0YXJyYXlfdW5zYWZlX3NldFwiXG5lbmRcblxubGV0IGluaXQgbCBmID1cbiAgaWYgbCA9IDAgdGhlbiBbfHxdIGVsc2VcbiAgaWYgbCA8IDAgdGhlbiBpbnZhbGlkX2FyZyBcIkFycmF5LmluaXRcIlxuICAoKiBTZWUgIzY1NzUuIFdlIGNvdWxkIGFsc28gY2hlY2sgZm9yIG1heGltdW0gYXJyYXkgc2l6ZSwgYnV0IHRoaXMgZGVwZW5kc1xuICAgICBvbiB3aGV0aGVyIHdlIGNyZWF0ZSBhIGZsb2F0IGFycmF5IG9yIGEgcmVndWxhciBvbmUuLi4gKilcbiAgZWxzZVxuICAgbGV0IHJlcyA9IGNyZWF0ZSBsIChmIDApIGluXG4gICBmb3IgaSA9IDEgdG8gcHJlZCBsIGRvXG4gICAgIHVuc2FmZV9zZXQgcmVzIGkgKGYgaSlcbiAgIGRvbmU7XG4gICByZXNcblxubGV0IG1ha2VfbWF0cml4IHN4IHN5IGluaXQgPVxuICBsZXQgcmVzID0gY3JlYXRlIHN4IFt8fF0gaW5cbiAgZm9yIHggPSAwIHRvIHByZWQgc3ggZG9cbiAgICB1bnNhZmVfc2V0IHJlcyB4IChjcmVhdGUgc3kgaW5pdClcbiAgZG9uZTtcbiAgcmVzXG5cbmxldCBjcmVhdGVfbWF0cml4ID0gbWFrZV9tYXRyaXhcblxubGV0IGNvcHkgYSA9XG4gIGxldCBsID0gbGVuZ3RoIGEgaW4gaWYgbCA9IDAgdGhlbiBbfHxdIGVsc2UgdW5zYWZlX3N1YiBhIDAgbFxuXG5sZXQgYXBwZW5kIGExIGEyID1cbiAgbGV0IGwxID0gbGVuZ3RoIGExIGluXG4gIGlmIGwxID0gMCB0aGVuIGNvcHkgYTJcbiAgZWxzZSBpZiBsZW5ndGggYTIgPSAwIHRoZW4gdW5zYWZlX3N1YiBhMSAwIGwxXG4gIGVsc2UgYXBwZW5kX3ByaW0gYTEgYTJcblxubGV0IHN1YiBhIG9mcyBsZW4gPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gbGVuZ3RoIGEgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIkFycmF5LnN1YlwiXG4gIGVsc2UgdW5zYWZlX3N1YiBhIG9mcyBsZW5cblxubGV0IGZpbGwgYSBvZnMgbGVuIHYgPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gbGVuZ3RoIGEgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIkFycmF5LmZpbGxcIlxuICBlbHNlIHVuc2FmZV9maWxsIGEgb2ZzIGxlbiB2XG5cbmxldCBibGl0IGExIG9mczEgYTIgb2ZzMiBsZW4gPVxuICBpZiBsZW4gPCAwIHx8IG9mczEgPCAwIHx8IG9mczEgPiBsZW5ndGggYTEgLSBsZW5cbiAgICAgICAgICAgICB8fCBvZnMyIDwgMCB8fCBvZnMyID4gbGVuZ3RoIGEyIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJBcnJheS5ibGl0XCJcbiAgZWxzZSB1bnNhZmVfYmxpdCBhMSBvZnMxIGEyIG9mczIgbGVuXG5cbmxldCBpdGVyIGYgYSA9XG4gIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG8gZih1bnNhZmVfZ2V0IGEgaSkgZG9uZVxuXG5sZXQgaXRlcjIgZiBhIGIgPVxuICBpZiBsZW5ndGggYSA8PiBsZW5ndGggYiB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJBcnJheS5pdGVyMjogYXJyYXlzIG11c3QgaGF2ZSB0aGUgc2FtZSBsZW5ndGhcIlxuICBlbHNlXG4gICAgZm9yIGkgPSAwIHRvIGxlbmd0aCBhIC0gMSBkbyBmICh1bnNhZmVfZ2V0IGEgaSkgKHVuc2FmZV9nZXQgYiBpKSBkb25lXG5cbmxldCBtYXAgZiBhID1cbiAgbGV0IGwgPSBsZW5ndGggYSBpblxuICBpZiBsID0gMCB0aGVuIFt8fF0gZWxzZSBiZWdpblxuICAgIGxldCByID0gY3JlYXRlIGwgKGYodW5zYWZlX2dldCBhIDApKSBpblxuICAgIGZvciBpID0gMSB0byBsIC0gMSBkb1xuICAgICAgdW5zYWZlX3NldCByIGkgKGYodW5zYWZlX2dldCBhIGkpKVxuICAgIGRvbmU7XG4gICAgclxuICBlbmRcblxubGV0IG1hcDIgZiBhIGIgPVxuICBsZXQgbGEgPSBsZW5ndGggYSBpblxuICBsZXQgbGIgPSBsZW5ndGggYiBpblxuICBpZiBsYSA8PiBsYiB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJBcnJheS5tYXAyOiBhcnJheXMgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aFwiXG4gIGVsc2UgYmVnaW5cbiAgICBpZiBsYSA9IDAgdGhlbiBbfHxdIGVsc2UgYmVnaW5cbiAgICAgIGxldCByID0gY3JlYXRlIGxhIChmICh1bnNhZmVfZ2V0IGEgMCkgKHVuc2FmZV9nZXQgYiAwKSkgaW5cbiAgICAgIGZvciBpID0gMSB0byBsYSAtIDEgZG9cbiAgICAgICAgdW5zYWZlX3NldCByIGkgKGYgKHVuc2FmZV9nZXQgYSBpKSAodW5zYWZlX2dldCBiIGkpKVxuICAgICAgZG9uZTtcbiAgICAgIHJcbiAgICBlbmRcbiAgZW5kXG5cbmxldCBpdGVyaSBmIGEgPVxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvIGYgaSAodW5zYWZlX2dldCBhIGkpIGRvbmVcblxubGV0IG1hcGkgZiBhID1cbiAgbGV0IGwgPSBsZW5ndGggYSBpblxuICBpZiBsID0gMCB0aGVuIFt8fF0gZWxzZSBiZWdpblxuICAgIGxldCByID0gY3JlYXRlIGwgKGYgMCAodW5zYWZlX2dldCBhIDApKSBpblxuICAgIGZvciBpID0gMSB0byBsIC0gMSBkb1xuICAgICAgdW5zYWZlX3NldCByIGkgKGYgaSAodW5zYWZlX2dldCBhIGkpKVxuICAgIGRvbmU7XG4gICAgclxuICBlbmRcblxubGV0IHRvX2xpc3QgYSA9XG4gIGxldCByZWMgdG9saXN0IGkgcmVzID1cbiAgICBpZiBpIDwgMCB0aGVuIHJlcyBlbHNlIHRvbGlzdCAoaSAtIDEpICh1bnNhZmVfZ2V0IGEgaSA6OiByZXMpIGluXG4gIHRvbGlzdCAobGVuZ3RoIGEgLSAxKSBbXVxuXG4oKiBDYW5ub3QgdXNlIExpc3QubGVuZ3RoIGhlcmUgYmVjYXVzZSB0aGUgTGlzdCBtb2R1bGUgZGVwZW5kcyBvbiBBcnJheS4gKilcbmxldCByZWMgbGlzdF9sZW5ndGggYWNjdSA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gYWNjdVxuICB8IF86OnQgLT4gbGlzdF9sZW5ndGggKHN1Y2MgYWNjdSkgdFxuXG5sZXQgb2ZfbGlzdCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gW3x8XVxuICB8IGhkOjp0bCBhcyBsIC0+XG4gICAgICBsZXQgYSA9IGNyZWF0ZSAobGlzdF9sZW5ndGggMCBsKSBoZCBpblxuICAgICAgbGV0IHJlYyBmaWxsIGkgPSBmdW5jdGlvblxuICAgICAgICAgIFtdIC0+IGFcbiAgICAgICAgfCBoZDo6dGwgLT4gdW5zYWZlX3NldCBhIGkgaGQ7IGZpbGwgKGkrMSkgdGwgaW5cbiAgICAgIGZpbGwgMSB0bFxuXG5sZXQgZm9sZF9sZWZ0IGYgeCBhID1cbiAgbGV0IHIgPSByZWYgeCBpblxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvXG4gICAgciA6PSBmICFyICh1bnNhZmVfZ2V0IGEgaSlcbiAgZG9uZTtcbiAgIXJcblxubGV0IGZvbGRfbGVmdF9tYXAgZiBhY2MgaW5wdXRfYXJyYXkgPVxuICBsZXQgbGVuID0gbGVuZ3RoIGlucHV0X2FycmF5IGluXG4gIGlmIGxlbiA9IDAgdGhlbiAoYWNjLCBbfHxdKSBlbHNlIGJlZ2luXG4gICAgbGV0IGFjYywgZWx0ID0gZiBhY2MgKHVuc2FmZV9nZXQgaW5wdXRfYXJyYXkgMCkgaW5cbiAgICBsZXQgb3V0cHV0X2FycmF5ID0gY3JlYXRlIGxlbiBlbHQgaW5cbiAgICBsZXQgYWNjID0gcmVmIGFjYyBpblxuICAgIGZvciBpID0gMSB0byBsZW4gLSAxIGRvXG4gICAgICBsZXQgYWNjJywgZWx0ID0gZiAhYWNjICh1bnNhZmVfZ2V0IGlucHV0X2FycmF5IGkpIGluXG4gICAgICBhY2MgOj0gYWNjJztcbiAgICAgIHVuc2FmZV9zZXQgb3V0cHV0X2FycmF5IGkgZWx0O1xuICAgIGRvbmU7XG4gICAgIWFjYywgb3V0cHV0X2FycmF5XG4gIGVuZFxuXG5sZXQgZm9sZF9yaWdodCBmIGEgeCA9XG4gIGxldCByID0gcmVmIHggaW5cbiAgZm9yIGkgPSBsZW5ndGggYSAtIDEgZG93bnRvIDAgZG9cbiAgICByIDo9IGYgKHVuc2FmZV9nZXQgYSBpKSAhclxuICBkb25lO1xuICAhclxuXG5sZXQgZXhpc3RzIHAgYSA9XG4gIGxldCBuID0gbGVuZ3RoIGEgaW5cbiAgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPSBuIHRoZW4gZmFsc2VcbiAgICBlbHNlIGlmIHAgKHVuc2FmZV9nZXQgYSBpKSB0aGVuIHRydWVcbiAgICBlbHNlIGxvb3AgKHN1Y2MgaSkgaW5cbiAgbG9vcCAwXG5cbmxldCBmb3JfYWxsIHAgYSA9XG4gIGxldCBuID0gbGVuZ3RoIGEgaW5cbiAgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPSBuIHRoZW4gdHJ1ZVxuICAgIGVsc2UgaWYgcCAodW5zYWZlX2dldCBhIGkpIHRoZW4gbG9vcCAoc3VjYyBpKVxuICAgIGVsc2UgZmFsc2UgaW5cbiAgbG9vcCAwXG5cbmxldCBmb3JfYWxsMiBwIGwxIGwyID1cbiAgbGV0IG4xID0gbGVuZ3RoIGwxXG4gIGFuZCBuMiA9IGxlbmd0aCBsMiBpblxuICBpZiBuMSA8PiBuMiB0aGVuIGludmFsaWRfYXJnIFwiQXJyYXkuZm9yX2FsbDJcIlxuICBlbHNlIGxldCByZWMgbG9vcCBpID1cbiAgICBpZiBpID0gbjEgdGhlbiB0cnVlXG4gICAgZWxzZSBpZiBwICh1bnNhZmVfZ2V0IGwxIGkpICh1bnNhZmVfZ2V0IGwyIGkpIHRoZW4gbG9vcCAoc3VjYyBpKVxuICAgIGVsc2UgZmFsc2UgaW5cbiAgbG9vcCAwXG5cbmxldCBleGlzdHMyIHAgbDEgbDIgPVxuICBsZXQgbjEgPSBsZW5ndGggbDFcbiAgYW5kIG4yID0gbGVuZ3RoIGwyIGluXG4gIGlmIG4xIDw+IG4yIHRoZW4gaW52YWxpZF9hcmcgXCJBcnJheS5leGlzdHMyXCJcbiAgZWxzZSBsZXQgcmVjIGxvb3AgaSA9XG4gICAgaWYgaSA9IG4xIHRoZW4gZmFsc2VcbiAgICBlbHNlIGlmIHAgKHVuc2FmZV9nZXQgbDEgaSkgKHVuc2FmZV9nZXQgbDIgaSkgdGhlbiB0cnVlXG4gICAgZWxzZSBsb29wIChzdWNjIGkpIGluXG4gIGxvb3AgMFxuXG5sZXQgbWVtIHggYSA9XG4gIGxldCBuID0gbGVuZ3RoIGEgaW5cbiAgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPSBuIHRoZW4gZmFsc2VcbiAgICBlbHNlIGlmIGNvbXBhcmUgKHVuc2FmZV9nZXQgYSBpKSB4ID0gMCB0aGVuIHRydWVcbiAgICBlbHNlIGxvb3AgKHN1Y2MgaSkgaW5cbiAgbG9vcCAwXG5cbmxldCBtZW1xIHggYSA9XG4gIGxldCBuID0gbGVuZ3RoIGEgaW5cbiAgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPSBuIHRoZW4gZmFsc2VcbiAgICBlbHNlIGlmIHggPT0gKHVuc2FmZV9nZXQgYSBpKSB0aGVuIHRydWVcbiAgICBlbHNlIGxvb3AgKHN1Y2MgaSkgaW5cbiAgbG9vcCAwXG5cbmxldCBmaW5kX29wdCBwIGEgPVxuICBsZXQgbiA9IGxlbmd0aCBhIGluXG4gIGxldCByZWMgbG9vcCBpID1cbiAgICBpZiBpID0gbiB0aGVuIE5vbmVcbiAgICBlbHNlXG4gICAgICBsZXQgeCA9IHVuc2FmZV9nZXQgYSBpIGluXG4gICAgICBpZiBwIHggdGhlbiBTb21lIHhcbiAgICAgIGVsc2UgbG9vcCAoc3VjYyBpKVxuICBpblxuICBsb29wIDBcblxubGV0IGZpbmRfbWFwIGYgYSA9XG4gIGxldCBuID0gbGVuZ3RoIGEgaW5cbiAgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPSBuIHRoZW4gTm9uZVxuICAgIGVsc2VcbiAgICAgIG1hdGNoIGYgKHVuc2FmZV9nZXQgYSBpKSB3aXRoXG4gICAgICB8IE5vbmUgLT4gbG9vcCAoc3VjYyBpKVxuICAgICAgfCBTb21lIF8gYXMgciAtPiByXG4gIGluXG4gIGxvb3AgMFxuXG5sZXQgc3BsaXQgeCA9XG4gIGlmIHggPSBbfHxdIHRoZW4gW3x8XSwgW3x8XVxuICBlbHNlIGJlZ2luXG4gICAgbGV0IGEwLCBiMCA9IHVuc2FmZV9nZXQgeCAwIGluXG4gICAgbGV0IG4gPSBsZW5ndGggeCBpblxuICAgIGxldCBhID0gY3JlYXRlIG4gYTAgaW5cbiAgICBsZXQgYiA9IGNyZWF0ZSBuIGIwIGluXG4gICAgZm9yIGkgPSAxIHRvIG4gLSAxIGRvXG4gICAgICBsZXQgYWksIGJpID0gdW5zYWZlX2dldCB4IGkgaW5cbiAgICAgIHVuc2FmZV9zZXQgYSBpIGFpO1xuICAgICAgdW5zYWZlX3NldCBiIGkgYmlcbiAgICBkb25lO1xuICAgIGEsIGJcbiAgZW5kXG5cbmxldCBjb21iaW5lIGEgYiA9XG4gIGxldCBuYSA9IGxlbmd0aCBhIGluXG4gIGxldCBuYiA9IGxlbmd0aCBiIGluXG4gIGlmIG5hIDw+IG5iIHRoZW4gaW52YWxpZF9hcmcgXCJBcnJheS5jb21iaW5lXCI7XG4gIGlmIG5hID0gMCB0aGVuIFt8fF1cbiAgZWxzZSBiZWdpblxuICAgIGxldCB4ID0gY3JlYXRlIG5hICh1bnNhZmVfZ2V0IGEgMCwgdW5zYWZlX2dldCBiIDApIGluXG4gICAgZm9yIGkgPSAxIHRvIG5hIC0gMSBkb1xuICAgICAgdW5zYWZlX3NldCB4IGkgKHVuc2FmZV9nZXQgYSBpLCB1bnNhZmVfZ2V0IGIgaSlcbiAgICBkb25lO1xuICAgIHhcbiAgZW5kXG5cbmV4Y2VwdGlvbiBCb3R0b20gb2YgaW50XG5sZXQgc29ydCBjbXAgYSA9XG4gIGxldCBtYXhzb24gbCBpID1cbiAgICBsZXQgaTMxID0gaStpK2krMSBpblxuICAgIGxldCB4ID0gcmVmIGkzMSBpblxuICAgIGlmIGkzMSsyIDwgbCB0aGVuIGJlZ2luXG4gICAgICBpZiBjbXAgKGdldCBhIGkzMSkgKGdldCBhIChpMzErMSkpIDwgMCB0aGVuIHggOj0gaTMxKzE7XG4gICAgICBpZiBjbXAgKGdldCBhICF4KSAoZ2V0IGEgKGkzMSsyKSkgPCAwIHRoZW4geCA6PSBpMzErMjtcbiAgICAgICF4XG4gICAgZW5kIGVsc2VcbiAgICAgIGlmIGkzMSsxIDwgbCAmJiBjbXAgKGdldCBhIGkzMSkgKGdldCBhIChpMzErMSkpIDwgMFxuICAgICAgdGhlbiBpMzErMVxuICAgICAgZWxzZSBpZiBpMzEgPCBsIHRoZW4gaTMxIGVsc2UgcmFpc2UgKEJvdHRvbSBpKVxuICBpblxuICBsZXQgcmVjIHRyaWNrbGVkb3duIGwgaSBlID1cbiAgICBsZXQgaiA9IG1heHNvbiBsIGkgaW5cbiAgICBpZiBjbXAgKGdldCBhIGopIGUgPiAwIHRoZW4gYmVnaW5cbiAgICAgIHNldCBhIGkgKGdldCBhIGopO1xuICAgICAgdHJpY2tsZWRvd24gbCBqIGU7XG4gICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgIHNldCBhIGkgZTtcbiAgICBlbmQ7XG4gIGluXG4gIGxldCB0cmlja2xlIGwgaSBlID0gdHJ5IHRyaWNrbGVkb3duIGwgaSBlIHdpdGggQm90dG9tIGkgLT4gc2V0IGEgaSBlIGluXG4gIGxldCByZWMgYnViYmxlZG93biBsIGkgPVxuICAgIGxldCBqID0gbWF4c29uIGwgaSBpblxuICAgIHNldCBhIGkgKGdldCBhIGopO1xuICAgIGJ1YmJsZWRvd24gbCBqXG4gIGluXG4gIGxldCBidWJibGUgbCBpID0gdHJ5IGJ1YmJsZWRvd24gbCBpIHdpdGggQm90dG9tIGkgLT4gaSBpblxuICBsZXQgcmVjIHRyaWNrbGV1cCBpIGUgPVxuICAgIGxldCBmYXRoZXIgPSAoaSAtIDEpIC8gMyBpblxuICAgIGFzc2VydCAoaSA8PiBmYXRoZXIpO1xuICAgIGlmIGNtcCAoZ2V0IGEgZmF0aGVyKSBlIDwgMCB0aGVuIGJlZ2luXG4gICAgICBzZXQgYSBpIChnZXQgYSBmYXRoZXIpO1xuICAgICAgaWYgZmF0aGVyID4gMCB0aGVuIHRyaWNrbGV1cCBmYXRoZXIgZSBlbHNlIHNldCBhIDAgZTtcbiAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgc2V0IGEgaSBlO1xuICAgIGVuZDtcbiAgaW5cbiAgbGV0IGwgPSBsZW5ndGggYSBpblxuICBmb3IgaSA9IChsICsgMSkgLyAzIC0gMSBkb3dudG8gMCBkbyB0cmlja2xlIGwgaSAoZ2V0IGEgaSk7IGRvbmU7XG4gIGZvciBpID0gbCAtIDEgZG93bnRvIDIgZG9cbiAgICBsZXQgZSA9IChnZXQgYSBpKSBpblxuICAgIHNldCBhIGkgKGdldCBhIDApO1xuICAgIHRyaWNrbGV1cCAoYnViYmxlIGkgMCkgZTtcbiAgZG9uZTtcbiAgaWYgbCA+IDEgdGhlbiAobGV0IGUgPSAoZ2V0IGEgMSkgaW4gc2V0IGEgMSAoZ2V0IGEgMCk7IHNldCBhIDAgZSlcblxuXG5sZXQgY3V0b2ZmID0gNVxubGV0IHN0YWJsZV9zb3J0IGNtcCBhID1cbiAgbGV0IG1lcmdlIHNyYzFvZnMgc3JjMWxlbiBzcmMyIHNyYzJvZnMgc3JjMmxlbiBkc3QgZHN0b2ZzID1cbiAgICBsZXQgc3JjMXIgPSBzcmMxb2ZzICsgc3JjMWxlbiBhbmQgc3JjMnIgPSBzcmMyb2ZzICsgc3JjMmxlbiBpblxuICAgIGxldCByZWMgbG9vcCBpMSBzMSBpMiBzMiBkID1cbiAgICAgIGlmIGNtcCBzMSBzMiA8PSAwIHRoZW4gYmVnaW5cbiAgICAgICAgc2V0IGRzdCBkIHMxO1xuICAgICAgICBsZXQgaTEgPSBpMSArIDEgaW5cbiAgICAgICAgaWYgaTEgPCBzcmMxciB0aGVuXG4gICAgICAgICAgbG9vcCBpMSAoZ2V0IGEgaTEpIGkyIHMyIChkICsgMSlcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGJsaXQgc3JjMiBpMiBkc3QgKGQgKyAxKSAoc3JjMnIgLSBpMilcbiAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgIHNldCBkc3QgZCBzMjtcbiAgICAgICAgbGV0IGkyID0gaTIgKyAxIGluXG4gICAgICAgIGlmIGkyIDwgc3JjMnIgdGhlblxuICAgICAgICAgIGxvb3AgaTEgczEgaTIgKGdldCBzcmMyIGkyKSAoZCArIDEpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBibGl0IGEgaTEgZHN0IChkICsgMSkgKHNyYzFyIC0gaTEpXG4gICAgICBlbmRcbiAgICBpbiBsb29wIHNyYzFvZnMgKGdldCBhIHNyYzFvZnMpIHNyYzJvZnMgKGdldCBzcmMyIHNyYzJvZnMpIGRzdG9mcztcbiAgaW5cbiAgbGV0IGlzb3J0dG8gc3Jjb2ZzIGRzdCBkc3RvZnMgbGVuID1cbiAgICBmb3IgaSA9IDAgdG8gbGVuIC0gMSBkb1xuICAgICAgbGV0IGUgPSAoZ2V0IGEgKHNyY29mcyArIGkpKSBpblxuICAgICAgbGV0IGogPSByZWYgKGRzdG9mcyArIGkgLSAxKSBpblxuICAgICAgd2hpbGUgKCFqID49IGRzdG9mcyAmJiBjbXAgKGdldCBkc3QgIWopIGUgPiAwKSBkb1xuICAgICAgICBzZXQgZHN0ICghaiArIDEpIChnZXQgZHN0ICFqKTtcbiAgICAgICAgZGVjciBqO1xuICAgICAgZG9uZTtcbiAgICAgIHNldCBkc3QgKCFqICsgMSkgZTtcbiAgICBkb25lO1xuICBpblxuICBsZXQgcmVjIHNvcnR0byBzcmNvZnMgZHN0IGRzdG9mcyBsZW4gPVxuICAgIGlmIGxlbiA8PSBjdXRvZmYgdGhlbiBpc29ydHRvIHNyY29mcyBkc3QgZHN0b2ZzIGxlbiBlbHNlIGJlZ2luXG4gICAgICBsZXQgbDEgPSBsZW4gLyAyIGluXG4gICAgICBsZXQgbDIgPSBsZW4gLSBsMSBpblxuICAgICAgc29ydHRvIChzcmNvZnMgKyBsMSkgZHN0IChkc3RvZnMgKyBsMSkgbDI7XG4gICAgICBzb3J0dG8gc3Jjb2ZzIGEgKHNyY29mcyArIGwyKSBsMTtcbiAgICAgIG1lcmdlIChzcmNvZnMgKyBsMikgbDEgZHN0IChkc3RvZnMgKyBsMSkgbDIgZHN0IGRzdG9mcztcbiAgICBlbmQ7XG4gIGluXG4gIGxldCBsID0gbGVuZ3RoIGEgaW5cbiAgaWYgbCA8PSBjdXRvZmYgdGhlbiBpc29ydHRvIDAgYSAwIGwgZWxzZSBiZWdpblxuICAgIGxldCBsMSA9IGwgLyAyIGluXG4gICAgbGV0IGwyID0gbCAtIGwxIGluXG4gICAgbGV0IHQgPSBtYWtlIGwyIChnZXQgYSAwKSBpblxuICAgIHNvcnR0byBsMSB0IDAgbDI7XG4gICAgc29ydHRvIDAgYSBsMiBsMTtcbiAgICBtZXJnZSBsMiBsMSB0IDAgbDIgYSAwO1xuICBlbmRcblxuXG5sZXQgZmFzdF9zb3J0ID0gc3RhYmxlX3NvcnRcblxuKCoqIHsxIEl0ZXJhdG9yc30gKilcblxubGV0IHRvX3NlcSBhID1cbiAgbGV0IHJlYyBhdXggaSAoKSA9XG4gICAgaWYgaSA8IGxlbmd0aCBhXG4gICAgdGhlblxuICAgICAgbGV0IHggPSB1bnNhZmVfZ2V0IGEgaSBpblxuICAgICAgU2VxLkNvbnMgKHgsIGF1eCAoaSsxKSlcbiAgICBlbHNlIFNlcS5OaWxcbiAgaW5cbiAgYXV4IDBcblxubGV0IHRvX3NlcWkgYSA9XG4gIGxldCByZWMgYXV4IGkgKCkgPVxuICAgIGlmIGkgPCBsZW5ndGggYVxuICAgIHRoZW5cbiAgICAgIGxldCB4ID0gdW5zYWZlX2dldCBhIGkgaW5cbiAgICAgIFNlcS5Db25zICgoaSx4KSwgYXV4IChpKzEpKVxuICAgIGVsc2UgU2VxLk5pbFxuICBpblxuICBhdXggMFxuXG5sZXQgb2ZfcmV2X2xpc3QgPSBmdW5jdGlvblxuICAgIFtdIC0+IFt8fF1cbiAgfCBoZDo6dGwgYXMgbCAtPlxuICAgICAgbGV0IGxlbiA9IGxpc3RfbGVuZ3RoIDAgbCBpblxuICAgICAgbGV0IGEgPSBjcmVhdGUgbGVuIGhkIGluXG4gICAgICBsZXQgcmVjIGZpbGwgaSA9IGZ1bmN0aW9uXG4gICAgICAgICAgW10gLT4gYVxuICAgICAgICB8IGhkOjp0bCAtPiB1bnNhZmVfc2V0IGEgaSBoZDsgZmlsbCAoaS0xKSB0bFxuICAgICAgaW5cbiAgICAgIGZpbGwgKGxlbi0yKSB0bFxuXG5sZXQgb2Zfc2VxIGkgPVxuICBsZXQgbCA9IFNlcS5mb2xkX2xlZnQgKGZ1biBhY2MgeCAtPiB4OjphY2MpIFtdIGkgaW5cbiAgb2ZfcmV2X2xpc3QgbFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICBOaWNvbGFzIE9qZWRhIEJhciwgTGV4aUZpICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxOCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5leHRlcm5hbCBuZWcgOiBmbG9hdCAtPiBmbG9hdCA9IFwiJW5lZ2Zsb2F0XCJcbmV4dGVybmFsIGFkZCA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCIlYWRkZmxvYXRcIlxuZXh0ZXJuYWwgc3ViIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcIiVzdWJmbG9hdFwiXG5leHRlcm5hbCBtdWwgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiJW11bGZsb2F0XCJcbmV4dGVybmFsIGRpdiA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCIlZGl2ZmxvYXRcIlxuZXh0ZXJuYWwgcmVtIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfZm1vZF9mbG9hdFwiIFwiZm1vZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBmbWEgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9mbWFfZmxvYXRcIiBcImNhbWxfZm1hXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGFicyA6IGZsb2F0IC0+IGZsb2F0ID0gXCIlYWJzZmxvYXRcIlxuXG5sZXQgemVybyA9IDAuXG5sZXQgb25lID0gMS5cbmxldCBtaW51c19vbmUgPSAtMS5cbmxldCBpbmZpbml0eSA9IFN0ZGxpYi5pbmZpbml0eVxubGV0IG5lZ19pbmZpbml0eSA9IFN0ZGxpYi5uZWdfaW5maW5pdHlcbmxldCBuYW4gPSBTdGRsaWIubmFuXG5sZXQgaXNfZmluaXRlICh4OiBmbG9hdCkgPSB4IC0uIHggPSAwLlxubGV0IGlzX2luZmluaXRlICh4OiBmbG9hdCkgPSAxLiAvLiB4ID0gMC5cbmxldCBpc19uYW4gKHg6IGZsb2F0KSA9IHggPD4geFxuXG5sZXQgcGkgPSAweDEuOTIxZmI1NDQ0MmQxOHArMVxubGV0IG1heF9mbG9hdCA9IFN0ZGxpYi5tYXhfZmxvYXRcbmxldCBtaW5fZmxvYXQgPSBTdGRsaWIubWluX2Zsb2F0XG5sZXQgZXBzaWxvbiA9IFN0ZGxpYi5lcHNpbG9uX2Zsb2F0XG5leHRlcm5hbCBvZl9pbnQgOiBpbnQgLT4gZmxvYXQgPSBcIiVmbG9hdG9maW50XCJcbmV4dGVybmFsIHRvX2ludCA6IGZsb2F0IC0+IGludCA9IFwiJWludG9mZmxvYXRcIlxuZXh0ZXJuYWwgb2Zfc3RyaW5nIDogc3RyaW5nIC0+IGZsb2F0ID0gXCJjYW1sX2Zsb2F0X29mX3N0cmluZ1wiXG5sZXQgb2Zfc3RyaW5nX29wdCA9IFN0ZGxpYi5mbG9hdF9vZl9zdHJpbmdfb3B0XG5sZXQgdG9fc3RyaW5nID0gU3RkbGliLnN0cmluZ19vZl9mbG9hdFxudHlwZSBmcGNsYXNzID0gU3RkbGliLmZwY2xhc3MgPVxuICAgIEZQX25vcm1hbFxuICB8IEZQX3N1Ym5vcm1hbFxuICB8IEZQX3plcm9cbiAgfCBGUF9pbmZpbml0ZVxuICB8IEZQX25hblxuZXh0ZXJuYWwgY2xhc3NpZnlfZmxvYXQgOiAoZmxvYXQgW0B1bmJveGVkXSkgLT4gZnBjbGFzcyA9XG4gIFwiY2FtbF9jbGFzc2lmeV9mbG9hdFwiIFwiY2FtbF9jbGFzc2lmeV9mbG9hdF91bmJveGVkXCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIHBvdyA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3Bvd2VyX2Zsb2F0XCIgXCJwb3dcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgc3FydCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3NxcnRfZmxvYXRcIiBcInNxcnRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgY2JydCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2NicnRfZmxvYXRcIiBcImNhbWxfY2JydFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBleHAgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9leHBfZmxvYXRcIiBcImV4cFwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBleHAyIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfZXhwMl9mbG9hdFwiIFwiY2FtbF9leHAyXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGxvZyA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2xvZ19mbG9hdFwiIFwibG9nXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGxvZzEwIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfbG9nMTBfZmxvYXRcIiBcImxvZzEwXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGxvZzIgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9sb2cyX2Zsb2F0XCIgXCJjYW1sX2xvZzJcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZXhwbTEgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9leHBtMV9mbG9hdFwiIFwiY2FtbF9leHBtMVwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBsb2cxcCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2xvZzFwX2Zsb2F0XCIgXCJjYW1sX2xvZzFwXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGNvcyA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Nvc19mbG9hdFwiIFwiY29zXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHNpbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3Npbl9mbG9hdFwiIFwic2luXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHRhbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3Rhbl9mbG9hdFwiIFwidGFuXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGFjb3MgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hY29zX2Zsb2F0XCIgXCJhY29zXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGFzaW4gOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hc2luX2Zsb2F0XCIgXCJhc2luXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGF0YW4gOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hdGFuX2Zsb2F0XCIgXCJhdGFuXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGF0YW4yIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYXRhbjJfZmxvYXRcIiBcImF0YW4yXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGh5cG90IDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXRcbiAgICAgICAgICAgICAgID0gXCJjYW1sX2h5cG90X2Zsb2F0XCIgXCJjYW1sX2h5cG90XCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGNvc2ggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9jb3NoX2Zsb2F0XCIgXCJjb3NoXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHNpbmggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9zaW5oX2Zsb2F0XCIgXCJzaW5oXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHRhbmggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF90YW5oX2Zsb2F0XCIgXCJ0YW5oXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGFjb3NoIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYWNvc2hfZmxvYXRcIiBcImNhbWxfYWNvc2hcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYXNpbmggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hc2luaF9mbG9hdFwiIFwiY2FtbF9hc2luaFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBhdGFuaCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2F0YW5oX2Zsb2F0XCIgXCJjYW1sX2F0YW5oXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGVyZiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2VyZl9mbG9hdFwiIFwiY2FtbF9lcmZcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZXJmYyA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2VyZmNfZmxvYXRcIiBcImNhbWxfZXJmY1wiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCB0cnVuYyA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3RydW5jX2Zsb2F0XCIgXCJjYW1sX3RydW5jXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHJvdW5kIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfcm91bmRfZmxvYXRcIiBcImNhbWxfcm91bmRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgY2VpbCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2NlaWxfZmxvYXRcIiBcImNlaWxcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZmxvb3IgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9mbG9vcl9mbG9hdFwiIFwiZmxvb3JcIlxuW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cblxubGV0IGlzX2ludGVnZXIgeCA9IHggPSB0cnVuYyB4ICYmIGlzX2Zpbml0ZSB4XG5cbmV4dGVybmFsIG5leHRfYWZ0ZXIgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdFxuICA9IFwiY2FtbF9uZXh0YWZ0ZXJfZmxvYXRcIiBcImNhbWxfbmV4dGFmdGVyXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cblxubGV0IHN1Y2MgeCA9IG5leHRfYWZ0ZXIgeCBpbmZpbml0eVxubGV0IHByZWQgeCA9IG5leHRfYWZ0ZXIgeCBuZWdfaW5maW5pdHlcblxuZXh0ZXJuYWwgY29weV9zaWduIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXRcbiAgICAgICAgICAgICAgICAgID0gXCJjYW1sX2NvcHlzaWduX2Zsb2F0XCIgXCJjYW1sX2NvcHlzaWduXCJcbiAgICAgICAgICAgICAgICAgIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBzaWduX2JpdCA6IChmbG9hdCBbQHVuYm94ZWRdKSAtPiBib29sXG4gID0gXCJjYW1sX3NpZ25iaXRfZmxvYXRcIiBcImNhbWxfc2lnbmJpdFwiIFtAQG5vYWxsb2NdXG5cbmV4dGVybmFsIGZyZXhwIDogZmxvYXQgLT4gZmxvYXQgKiBpbnQgPSBcImNhbWxfZnJleHBfZmxvYXRcIlxuZXh0ZXJuYWwgbGRleHAgOiAoZmxvYXQgW0B1bmJveGVkXSkgLT4gKGludCBbQHVudGFnZ2VkXSkgLT4gKGZsb2F0IFtAdW5ib3hlZF0pID1cbiAgXCJjYW1sX2xkZXhwX2Zsb2F0XCIgXCJjYW1sX2xkZXhwX2Zsb2F0X3VuYm94ZWRcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgbW9kZiA6IGZsb2F0IC0+IGZsb2F0ICogZmxvYXQgPSBcImNhbWxfbW9kZl9mbG9hdFwiXG50eXBlIHQgPSBmbG9hdFxuZXh0ZXJuYWwgY29tcGFyZSA6IGZsb2F0IC0+IGZsb2F0IC0+IGludCA9IFwiJWNvbXBhcmVcIlxubGV0IGVxdWFsIHggeSA9IGNvbXBhcmUgeCB5ID0gMFxuXG5sZXRbQGlubGluZV0gbWluICh4OiBmbG9hdCkgKHk6IGZsb2F0KSA9XG4gIGlmIHkgPiB4IHx8IChub3Qoc2lnbl9iaXQgeSkgJiYgc2lnbl9iaXQgeCkgdGhlblxuICAgIGlmIGlzX25hbiB5IHRoZW4geSBlbHNlIHhcbiAgZWxzZSBpZiBpc19uYW4geCB0aGVuIHggZWxzZSB5XG5cbmxldFtAaW5saW5lXSBtYXggKHg6IGZsb2F0KSAoeTogZmxvYXQpID1cbiAgaWYgeSA+IHggfHwgKG5vdChzaWduX2JpdCB5KSAmJiBzaWduX2JpdCB4KSB0aGVuXG4gICAgaWYgaXNfbmFuIHggdGhlbiB4IGVsc2UgeVxuICBlbHNlIGlmIGlzX25hbiB5IHRoZW4geSBlbHNlIHhcblxubGV0W0BpbmxpbmVdIG1pbl9tYXggKHg6IGZsb2F0KSAoeTogZmxvYXQpID1cbiAgaWYgaXNfbmFuIHggfHwgaXNfbmFuIHkgdGhlbiAobmFuLCBuYW4pXG4gIGVsc2UgaWYgeSA+IHggfHwgKG5vdChzaWduX2JpdCB5KSAmJiBzaWduX2JpdCB4KSB0aGVuICh4LCB5KSBlbHNlICh5LCB4KVxuXG5sZXRbQGlubGluZV0gbWluX251bSAoeDogZmxvYXQpICh5OiBmbG9hdCkgPVxuICBpZiB5ID4geCB8fCAobm90KHNpZ25fYml0IHkpICYmIHNpZ25fYml0IHgpIHRoZW5cbiAgICBpZiBpc19uYW4geCB0aGVuIHkgZWxzZSB4XG4gIGVsc2UgaWYgaXNfbmFuIHkgdGhlbiB4IGVsc2UgeVxuXG5sZXRbQGlubGluZV0gbWF4X251bSAoeDogZmxvYXQpICh5OiBmbG9hdCkgPVxuICBpZiB5ID4geCB8fCAobm90KHNpZ25fYml0IHkpICYmIHNpZ25fYml0IHgpIHRoZW5cbiAgICBpZiBpc19uYW4geSB0aGVuIHggZWxzZSB5XG4gIGVsc2UgaWYgaXNfbmFuIHggdGhlbiB5IGVsc2UgeFxuXG5sZXRbQGlubGluZV0gbWluX21heF9udW0gKHg6IGZsb2F0KSAoeTogZmxvYXQpID1cbiAgaWYgaXNfbmFuIHggdGhlbiAoeSx5KVxuICBlbHNlIGlmIGlzX25hbiB5IHRoZW4gKHgseClcbiAgZWxzZSBpZiB5ID4geCB8fCAobm90KHNpZ25fYml0IHkpICYmIHNpZ25fYml0IHgpIHRoZW4gKHgseSkgZWxzZSAoeSx4KVxuXG5leHRlcm5hbCBzZWVkZWRfaGFzaF9wYXJhbSA6IGludCAtPiBpbnQgLT4gaW50IC0+IGZsb2F0IC0+IGludFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfaGFzaFwiIFtAQG5vYWxsb2NdXG5sZXQgaGFzaCB4ID0gc2VlZGVkX2hhc2hfcGFyYW0gMTAgMTAwIDAgeFxuXG5tb2R1bGUgQXJyYXkgPSBzdHJ1Y3RcblxuICB0eXBlIHQgPSBmbG9hdGFycmF5XG5cbiAgZXh0ZXJuYWwgbGVuZ3RoIDogdCAtPiBpbnQgPSBcIiVmbG9hdGFycmF5X2xlbmd0aFwiXG4gIGV4dGVybmFsIGdldCA6IHQgLT4gaW50IC0+IGZsb2F0ID0gXCIlZmxvYXRhcnJheV9zYWZlX2dldFwiXG4gIGV4dGVybmFsIHNldCA6IHQgLT4gaW50IC0+IGZsb2F0IC0+IHVuaXQgPSBcIiVmbG9hdGFycmF5X3NhZmVfc2V0XCJcbiAgZXh0ZXJuYWwgY3JlYXRlIDogaW50IC0+IHQgPSBcImNhbWxfZmxvYXRhcnJheV9jcmVhdGVcIlxuICBleHRlcm5hbCB1bnNhZmVfZ2V0IDogdCAtPiBpbnQgLT4gZmxvYXQgPSBcIiVmbG9hdGFycmF5X3Vuc2FmZV9nZXRcIlxuICBleHRlcm5hbCB1bnNhZmVfc2V0IDogdCAtPiBpbnQgLT4gZmxvYXQgLT4gdW5pdCA9IFwiJWZsb2F0YXJyYXlfdW5zYWZlX3NldFwiXG5cbiAgbGV0IHVuc2FmZV9maWxsIGEgb2ZzIGxlbiB2ID1cbiAgICBmb3IgaSA9IG9mcyB0byBvZnMgKyBsZW4gLSAxIGRvIHVuc2FmZV9zZXQgYSBpIHYgZG9uZVxuXG4gIGV4dGVybmFsIHVuc2FmZV9ibGl0OiB0IC0+IGludCAtPiB0IC0+IGludCAtPiBpbnQgLT4gdW5pdCA9XG4gICAgXCJjYW1sX2Zsb2F0YXJyYXlfYmxpdFwiIFtAQG5vYWxsb2NdXG5cbiAgbGV0IGNoZWNrIGEgb2ZzIGxlbiBtc2cgPVxuICAgIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgKyBsZW4gPCAwIHx8IG9mcyArIGxlbiA+IGxlbmd0aCBhIHRoZW5cbiAgICAgIGludmFsaWRfYXJnIG1zZ1xuXG4gIGxldCBtYWtlIG4gdiA9XG4gICAgbGV0IHJlc3VsdCA9IGNyZWF0ZSBuIGluXG4gICAgdW5zYWZlX2ZpbGwgcmVzdWx0IDAgbiB2O1xuICAgIHJlc3VsdFxuXG4gIGxldCBpbml0IGwgZiA9XG4gICAgaWYgbCA8IDAgdGhlbiBpbnZhbGlkX2FyZyBcIkZsb2F0LkFycmF5LmluaXRcIlxuICAgIGVsc2VcbiAgICAgIGxldCByZXMgPSBjcmVhdGUgbCBpblxuICAgICAgZm9yIGkgPSAwIHRvIGwgLSAxIGRvXG4gICAgICAgIHVuc2FmZV9zZXQgcmVzIGkgKGYgaSlcbiAgICAgIGRvbmU7XG4gICAgICByZXNcblxuICBsZXQgYXBwZW5kIGExIGEyID1cbiAgICBsZXQgbDEgPSBsZW5ndGggYTEgaW5cbiAgICBsZXQgbDIgPSBsZW5ndGggYTIgaW5cbiAgICBsZXQgcmVzdWx0ID0gY3JlYXRlIChsMSArIGwyKSBpblxuICAgIHVuc2FmZV9ibGl0IGExIDAgcmVzdWx0IDAgbDE7XG4gICAgdW5zYWZlX2JsaXQgYTIgMCByZXN1bHQgbDEgbDI7XG4gICAgcmVzdWx0XG5cbiAgKCogbmV4dCAzIGZ1bmN0aW9uczogbW9kaWZpZWQgY29weSBvZiBjb2RlIGZyb20gc3RyaW5nLm1sICopXG4gIGxldCBlbnN1cmVfZ2UgKHg6aW50KSB5ID1cbiAgICBpZiB4ID49IHkgdGhlbiB4IGVsc2UgaW52YWxpZF9hcmcgXCJGbG9hdC5BcnJheS5jb25jYXRcIlxuXG4gIGxldCByZWMgc3VtX2xlbmd0aHMgYWNjID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IGFjY1xuICAgIHwgaGQgOjogdGwgLT4gc3VtX2xlbmd0aHMgKGVuc3VyZV9nZSAobGVuZ3RoIGhkICsgYWNjKSBhY2MpIHRsXG5cbiAgbGV0IGNvbmNhdCBsID1cbiAgICBsZXQgbGVuID0gc3VtX2xlbmd0aHMgMCBsIGluXG4gICAgbGV0IHJlc3VsdCA9IGNyZWF0ZSBsZW4gaW5cbiAgICBsZXQgcmVjIGxvb3AgbCBpID1cbiAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgfCBbXSAtPiBhc3NlcnQgKGkgPSBsZW4pXG4gICAgICB8IGhkIDo6IHRsIC0+XG4gICAgICAgIGxldCBobGVuID0gbGVuZ3RoIGhkIGluXG4gICAgICAgIHVuc2FmZV9ibGl0IGhkIDAgcmVzdWx0IGkgaGxlbjtcbiAgICAgICAgbG9vcCB0bCAoaSArIGhsZW4pXG4gICAgaW5cbiAgICBsb29wIGwgMDtcbiAgICByZXN1bHRcblxuICBsZXQgc3ViIGEgb2ZzIGxlbiA9XG4gICAgY2hlY2sgYSBvZnMgbGVuIFwiRmxvYXQuQXJyYXkuc3ViXCI7XG4gICAgbGV0IHJlc3VsdCA9IGNyZWF0ZSBsZW4gaW5cbiAgICB1bnNhZmVfYmxpdCBhIG9mcyByZXN1bHQgMCBsZW47XG4gICAgcmVzdWx0XG5cbiAgbGV0IGNvcHkgYSA9XG4gICAgbGV0IGwgPSBsZW5ndGggYSBpblxuICAgIGxldCByZXN1bHQgPSBjcmVhdGUgbCBpblxuICAgIHVuc2FmZV9ibGl0IGEgMCByZXN1bHQgMCBsO1xuICAgIHJlc3VsdFxuXG4gIGxldCBmaWxsIGEgb2ZzIGxlbiB2ID1cbiAgICBjaGVjayBhIG9mcyBsZW4gXCJGbG9hdC5BcnJheS5maWxsXCI7XG4gICAgdW5zYWZlX2ZpbGwgYSBvZnMgbGVuIHZcblxuICBsZXQgYmxpdCBzcmMgc29mcyBkc3QgZG9mcyBsZW4gPVxuICAgIGNoZWNrIHNyYyBzb2ZzIGxlbiBcIkZsb2F0LmFycmF5LmJsaXRcIjtcbiAgICBjaGVjayBkc3QgZG9mcyBsZW4gXCJGbG9hdC5hcnJheS5ibGl0XCI7XG4gICAgdW5zYWZlX2JsaXQgc3JjIHNvZnMgZHN0IGRvZnMgbGVuXG5cbiAgbGV0IHRvX2xpc3QgYSA9XG4gICAgTGlzdC5pbml0IChsZW5ndGggYSkgKHVuc2FmZV9nZXQgYSlcblxuICBsZXQgb2ZfbGlzdCBsID1cbiAgICBsZXQgcmVzdWx0ID0gY3JlYXRlIChMaXN0Lmxlbmd0aCBsKSBpblxuICAgIGxldCByZWMgZmlsbCBpIGwgPVxuICAgICAgbWF0Y2ggbCB3aXRoXG4gICAgICB8IFtdIC0+IHJlc3VsdFxuICAgICAgfCBoIDo6IHQgLT4gdW5zYWZlX3NldCByZXN1bHQgaSBoOyBmaWxsIChpICsgMSkgdFxuICAgIGluXG4gICAgZmlsbCAwIGxcblxuICAoKiBkdXBsaWNhdGVkIGZyb20gYXJyYXkubWwgKilcbiAgbGV0IGl0ZXIgZiBhID1cbiAgICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvIGYgKHVuc2FmZV9nZXQgYSBpKSBkb25lXG5cbiAgKCogZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sICopXG4gIGxldCBpdGVyMiBmIGEgYiA9XG4gICAgaWYgbGVuZ3RoIGEgPD4gbGVuZ3RoIGIgdGhlblxuICAgICAgaW52YWxpZF9hcmcgXCJGbG9hdC5BcnJheS5pdGVyMjogYXJyYXlzIG11c3QgaGF2ZSB0aGUgc2FtZSBsZW5ndGhcIlxuICAgIGVsc2VcbiAgICAgIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG8gZiAodW5zYWZlX2dldCBhIGkpICh1bnNhZmVfZ2V0IGIgaSkgZG9uZVxuXG4gIGxldCBtYXAgZiBhID1cbiAgICBsZXQgbCA9IGxlbmd0aCBhIGluXG4gICAgbGV0IHIgPSBjcmVhdGUgbCBpblxuICAgIGZvciBpID0gMCB0byBsIC0gMSBkb1xuICAgICAgdW5zYWZlX3NldCByIGkgKGYgKHVuc2FmZV9nZXQgYSBpKSlcbiAgICBkb25lO1xuICAgIHJcblxuICBsZXQgbWFwMiBmIGEgYiA9XG4gICAgbGV0IGxhID0gbGVuZ3RoIGEgaW5cbiAgICBsZXQgbGIgPSBsZW5ndGggYiBpblxuICAgIGlmIGxhIDw+IGxiIHRoZW5cbiAgICAgIGludmFsaWRfYXJnIFwiRmxvYXQuQXJyYXkubWFwMjogYXJyYXlzIG11c3QgaGF2ZSB0aGUgc2FtZSBsZW5ndGhcIlxuICAgIGVsc2UgYmVnaW5cbiAgICAgIGxldCByID0gY3JlYXRlIGxhIGluXG4gICAgICBmb3IgaSA9IDAgdG8gbGEgLSAxIGRvXG4gICAgICAgIHVuc2FmZV9zZXQgciBpIChmICh1bnNhZmVfZ2V0IGEgaSkgKHVuc2FmZV9nZXQgYiBpKSlcbiAgICAgIGRvbmU7XG4gICAgICByXG4gICAgZW5kXG5cbiAgKCogZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sICopXG4gIGxldCBpdGVyaSBmIGEgPVxuICAgIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG8gZiBpICh1bnNhZmVfZ2V0IGEgaSkgZG9uZVxuXG4gIGxldCBtYXBpIGYgYSA9XG4gICAgbGV0IGwgPSBsZW5ndGggYSBpblxuICAgIGxldCByID0gY3JlYXRlIGwgaW5cbiAgICBmb3IgaSA9IDAgdG8gbCAtIDEgZG9cbiAgICAgIHVuc2FmZV9zZXQgciBpIChmIGkgKHVuc2FmZV9nZXQgYSBpKSlcbiAgICBkb25lO1xuICAgIHJcblxuICAoKiBkdXBsaWNhdGVkIGZyb20gYXJyYXkubWwgKilcbiAgbGV0IGZvbGRfbGVmdCBmIHggYSA9XG4gICAgbGV0IHIgPSByZWYgeCBpblxuICAgIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG9cbiAgICAgIHIgOj0gZiAhciAodW5zYWZlX2dldCBhIGkpXG4gICAgZG9uZTtcbiAgICAhclxuXG4gICgqIGR1cGxpY2F0ZWQgZnJvbSBhcnJheS5tbCAqKVxuICBsZXQgZm9sZF9yaWdodCBmIGEgeCA9XG4gICAgbGV0IHIgPSByZWYgeCBpblxuICAgIGZvciBpID0gbGVuZ3RoIGEgLSAxIGRvd250byAwIGRvXG4gICAgICByIDo9IGYgKHVuc2FmZV9nZXQgYSBpKSAhclxuICAgIGRvbmU7XG4gICAgIXJcblxuICAoKiBkdXBsaWNhdGVkIGZyb20gYXJyYXkubWwgKilcbiAgbGV0IGV4aXN0cyBwIGEgPVxuICAgIGxldCBuID0gbGVuZ3RoIGEgaW5cbiAgICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgICBpZiBpID0gbiB0aGVuIGZhbHNlXG4gICAgICBlbHNlIGlmIHAgKHVuc2FmZV9nZXQgYSBpKSB0aGVuIHRydWVcbiAgICAgIGVsc2UgbG9vcCAoaSArIDEpIGluXG4gICAgbG9vcCAwXG5cbiAgKCogZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sICopXG4gIGxldCBmb3JfYWxsIHAgYSA9XG4gICAgbGV0IG4gPSBsZW5ndGggYSBpblxuICAgIGxldCByZWMgbG9vcCBpID1cbiAgICAgIGlmIGkgPSBuIHRoZW4gdHJ1ZVxuICAgICAgZWxzZSBpZiBwICh1bnNhZmVfZ2V0IGEgaSkgdGhlbiBsb29wIChpICsgMSlcbiAgICAgIGVsc2UgZmFsc2UgaW5cbiAgICBsb29wIDBcblxuICAoKiBkdXBsaWNhdGVkIGZyb20gYXJyYXkubWwgKilcbiAgbGV0IG1lbSB4IGEgPVxuICAgIGxldCBuID0gbGVuZ3RoIGEgaW5cbiAgICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgICBpZiBpID0gbiB0aGVuIGZhbHNlXG4gICAgICBlbHNlIGlmIGNvbXBhcmUgKHVuc2FmZV9nZXQgYSBpKSB4ID0gMCB0aGVuIHRydWVcbiAgICAgIGVsc2UgbG9vcCAoaSArIDEpXG4gICAgaW5cbiAgICBsb29wIDBcblxuICAoKiBtb3N0bHkgZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sLCBidXQgc2xpZ2h0bHkgZGlmZmVyZW50ICopXG4gIGxldCBtZW1faWVlZSB4IGEgPVxuICAgIGxldCBuID0gbGVuZ3RoIGEgaW5cbiAgICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgICBpZiBpID0gbiB0aGVuIGZhbHNlXG4gICAgICBlbHNlIGlmIHggPSAodW5zYWZlX2dldCBhIGkpIHRoZW4gdHJ1ZVxuICAgICAgZWxzZSBsb29wIChpICsgMSlcbiAgICBpblxuICAgIGxvb3AgMFxuXG4gICgqIGR1cGxpY2F0ZWQgZnJvbSBhcnJheS5tbCAqKVxuICBleGNlcHRpb24gQm90dG9tIG9mIGludFxuICBsZXQgc29ydCBjbXAgYSA9XG4gICAgbGV0IG1heHNvbiBsIGkgPVxuICAgICAgbGV0IGkzMSA9IGkraStpKzEgaW5cbiAgICAgIGxldCB4ID0gcmVmIGkzMSBpblxuICAgICAgaWYgaTMxKzIgPCBsIHRoZW4gYmVnaW5cbiAgICAgICAgaWYgY21wIChnZXQgYSBpMzEpIChnZXQgYSAoaTMxKzEpKSA8IDAgdGhlbiB4IDo9IGkzMSsxO1xuICAgICAgICBpZiBjbXAgKGdldCBhICF4KSAoZ2V0IGEgKGkzMSsyKSkgPCAwIHRoZW4geCA6PSBpMzErMjtcbiAgICAgICAgIXhcbiAgICAgIGVuZCBlbHNlXG4gICAgICAgIGlmIGkzMSsxIDwgbCAmJiBjbXAgKGdldCBhIGkzMSkgKGdldCBhIChpMzErMSkpIDwgMFxuICAgICAgICB0aGVuIGkzMSsxXG4gICAgICAgIGVsc2UgaWYgaTMxIDwgbCB0aGVuIGkzMSBlbHNlIHJhaXNlIChCb3R0b20gaSlcbiAgICBpblxuICAgIGxldCByZWMgdHJpY2tsZWRvd24gbCBpIGUgPVxuICAgICAgbGV0IGogPSBtYXhzb24gbCBpIGluXG4gICAgICBpZiBjbXAgKGdldCBhIGopIGUgPiAwIHRoZW4gYmVnaW5cbiAgICAgICAgc2V0IGEgaSAoZ2V0IGEgaik7XG4gICAgICAgIHRyaWNrbGVkb3duIGwgaiBlO1xuICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgc2V0IGEgaSBlO1xuICAgICAgZW5kO1xuICAgIGluXG4gICAgbGV0IHRyaWNrbGUgbCBpIGUgPSB0cnkgdHJpY2tsZWRvd24gbCBpIGUgd2l0aCBCb3R0b20gaSAtPiBzZXQgYSBpIGUgaW5cbiAgICBsZXQgcmVjIGJ1YmJsZWRvd24gbCBpID1cbiAgICAgIGxldCBqID0gbWF4c29uIGwgaSBpblxuICAgICAgc2V0IGEgaSAoZ2V0IGEgaik7XG4gICAgICBidWJibGVkb3duIGwgalxuICAgIGluXG4gICAgbGV0IGJ1YmJsZSBsIGkgPSB0cnkgYnViYmxlZG93biBsIGkgd2l0aCBCb3R0b20gaSAtPiBpIGluXG4gICAgbGV0IHJlYyB0cmlja2xldXAgaSBlID1cbiAgICAgIGxldCBmYXRoZXIgPSAoaSAtIDEpIC8gMyBpblxuICAgICAgYXNzZXJ0IChpIDw+IGZhdGhlcik7XG4gICAgICBpZiBjbXAgKGdldCBhIGZhdGhlcikgZSA8IDAgdGhlbiBiZWdpblxuICAgICAgICBzZXQgYSBpIChnZXQgYSBmYXRoZXIpO1xuICAgICAgICBpZiBmYXRoZXIgPiAwIHRoZW4gdHJpY2tsZXVwIGZhdGhlciBlIGVsc2Ugc2V0IGEgMCBlO1xuICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgc2V0IGEgaSBlO1xuICAgICAgZW5kO1xuICAgIGluXG4gICAgbGV0IGwgPSBsZW5ndGggYSBpblxuICAgIGZvciBpID0gKGwgKyAxKSAvIDMgLSAxIGRvd250byAwIGRvIHRyaWNrbGUgbCBpIChnZXQgYSBpKTsgZG9uZTtcbiAgICBmb3IgaSA9IGwgLSAxIGRvd250byAyIGRvXG4gICAgICBsZXQgZSA9IChnZXQgYSBpKSBpblxuICAgICAgc2V0IGEgaSAoZ2V0IGEgMCk7XG4gICAgICB0cmlja2xldXAgKGJ1YmJsZSBpIDApIGU7XG4gICAgZG9uZTtcbiAgICBpZiBsID4gMSB0aGVuIChsZXQgZSA9IChnZXQgYSAxKSBpbiBzZXQgYSAxIChnZXQgYSAwKTsgc2V0IGEgMCBlKVxuXG4gICgqIGR1cGxpY2F0ZWQgZnJvbSBhcnJheS5tbCwgZXhjZXB0IGZvciB0aGUgY2FsbCB0byBbY3JlYXRlXSAqKVxuICBsZXQgY3V0b2ZmID0gNVxuICBsZXQgc3RhYmxlX3NvcnQgY21wIGEgPVxuICAgIGxldCBtZXJnZSBzcmMxb2ZzIHNyYzFsZW4gc3JjMiBzcmMyb2ZzIHNyYzJsZW4gZHN0IGRzdG9mcyA9XG4gICAgICBsZXQgc3JjMXIgPSBzcmMxb2ZzICsgc3JjMWxlbiBhbmQgc3JjMnIgPSBzcmMyb2ZzICsgc3JjMmxlbiBpblxuICAgICAgbGV0IHJlYyBsb29wIGkxIHMxIGkyIHMyIGQgPVxuICAgICAgICBpZiBjbXAgczEgczIgPD0gMCB0aGVuIGJlZ2luXG4gICAgICAgICAgc2V0IGRzdCBkIHMxO1xuICAgICAgICAgIGxldCBpMSA9IGkxICsgMSBpblxuICAgICAgICAgIGlmIGkxIDwgc3JjMXIgdGhlblxuICAgICAgICAgICAgbG9vcCBpMSAoZ2V0IGEgaTEpIGkyIHMyIChkICsgMSlcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBibGl0IHNyYzIgaTIgZHN0IChkICsgMSkgKHNyYzJyIC0gaTIpXG4gICAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgICAgc2V0IGRzdCBkIHMyO1xuICAgICAgICAgIGxldCBpMiA9IGkyICsgMSBpblxuICAgICAgICAgIGlmIGkyIDwgc3JjMnIgdGhlblxuICAgICAgICAgICAgbG9vcCBpMSBzMSBpMiAoZ2V0IHNyYzIgaTIpIChkICsgMSlcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBibGl0IGEgaTEgZHN0IChkICsgMSkgKHNyYzFyIC0gaTEpXG4gICAgICAgIGVuZFxuICAgICAgaW4gbG9vcCBzcmMxb2ZzIChnZXQgYSBzcmMxb2ZzKSBzcmMyb2ZzIChnZXQgc3JjMiBzcmMyb2ZzKSBkc3RvZnM7XG4gICAgaW5cbiAgICBsZXQgaXNvcnR0byBzcmNvZnMgZHN0IGRzdG9mcyBsZW4gPVxuICAgICAgZm9yIGkgPSAwIHRvIGxlbiAtIDEgZG9cbiAgICAgICAgbGV0IGUgPSAoZ2V0IGEgKHNyY29mcyArIGkpKSBpblxuICAgICAgICBsZXQgaiA9IHJlZiAoZHN0b2ZzICsgaSAtIDEpIGluXG4gICAgICAgIHdoaWxlICghaiA+PSBkc3RvZnMgJiYgY21wIChnZXQgZHN0ICFqKSBlID4gMCkgZG9cbiAgICAgICAgICBzZXQgZHN0ICghaiArIDEpIChnZXQgZHN0ICFqKTtcbiAgICAgICAgICBkZWNyIGo7XG4gICAgICAgIGRvbmU7XG4gICAgICAgIHNldCBkc3QgKCFqICsgMSkgZTtcbiAgICAgIGRvbmU7XG4gICAgaW5cbiAgICBsZXQgcmVjIHNvcnR0byBzcmNvZnMgZHN0IGRzdG9mcyBsZW4gPVxuICAgICAgaWYgbGVuIDw9IGN1dG9mZiB0aGVuIGlzb3J0dG8gc3Jjb2ZzIGRzdCBkc3RvZnMgbGVuIGVsc2UgYmVnaW5cbiAgICAgICAgbGV0IGwxID0gbGVuIC8gMiBpblxuICAgICAgICBsZXQgbDIgPSBsZW4gLSBsMSBpblxuICAgICAgICBzb3J0dG8gKHNyY29mcyArIGwxKSBkc3QgKGRzdG9mcyArIGwxKSBsMjtcbiAgICAgICAgc29ydHRvIHNyY29mcyBhIChzcmNvZnMgKyBsMikgbDE7XG4gICAgICAgIG1lcmdlIChzcmNvZnMgKyBsMikgbDEgZHN0IChkc3RvZnMgKyBsMSkgbDIgZHN0IGRzdG9mcztcbiAgICAgIGVuZDtcbiAgICBpblxuICAgIGxldCBsID0gbGVuZ3RoIGEgaW5cbiAgICBpZiBsIDw9IGN1dG9mZiB0aGVuIGlzb3J0dG8gMCBhIDAgbCBlbHNlIGJlZ2luXG4gICAgICBsZXQgbDEgPSBsIC8gMiBpblxuICAgICAgbGV0IGwyID0gbCAtIGwxIGluXG4gICAgICBsZXQgdCA9IGNyZWF0ZSBsMiBpblxuICAgICAgc29ydHRvIGwxIHQgMCBsMjtcbiAgICAgIHNvcnR0byAwIGEgbDIgbDE7XG4gICAgICBtZXJnZSBsMiBsMSB0IDAgbDIgYSAwO1xuICAgIGVuZFxuXG4gIGxldCBmYXN0X3NvcnQgPSBzdGFibGVfc29ydFxuXG4gICgqIGR1cGxpY2F0ZWQgZnJvbSBhcnJheS5tbCAqKVxuICBsZXQgdG9fc2VxIGEgPVxuICAgIGxldCByZWMgYXV4IGkgKCkgPVxuICAgICAgaWYgaSA8IGxlbmd0aCBhXG4gICAgICB0aGVuXG4gICAgICAgIGxldCB4ID0gdW5zYWZlX2dldCBhIGkgaW5cbiAgICAgICAgU2VxLkNvbnMgKHgsIGF1eCAoaSsxKSlcbiAgICAgIGVsc2UgU2VxLk5pbFxuICAgIGluXG4gICAgYXV4IDBcblxuICAoKiBkdXBsaWNhdGVkIGZyb20gYXJyYXkubWwgKilcbiAgbGV0IHRvX3NlcWkgYSA9XG4gICAgbGV0IHJlYyBhdXggaSAoKSA9XG4gICAgICBpZiBpIDwgbGVuZ3RoIGFcbiAgICAgIHRoZW5cbiAgICAgICAgbGV0IHggPSB1bnNhZmVfZ2V0IGEgaSBpblxuICAgICAgICBTZXEuQ29ucyAoKGkseCksIGF1eCAoaSsxKSlcbiAgICAgIGVsc2UgU2VxLk5pbFxuICAgIGluXG4gICAgYXV4IDBcblxuICAoKiBtb3N0bHkgZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sICopXG4gIGxldCBvZl9yZXZfbGlzdCBsID1cbiAgICBsZXQgbGVuID0gTGlzdC5sZW5ndGggbCBpblxuICAgIGxldCBhID0gY3JlYXRlIGxlbiBpblxuICAgIGxldCByZWMgZmlsbCBpID0gZnVuY3Rpb25cbiAgICAgICAgW10gLT4gYVxuICAgICAgfCBoZDo6dGwgLT4gdW5zYWZlX3NldCBhIGkgaGQ7IGZpbGwgKGktMSkgdGxcbiAgICBpblxuICAgIGZpbGwgKGxlbi0xKSBsXG5cbiAgKCogZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sICopXG4gIGxldCBvZl9zZXEgaSA9XG4gICAgbGV0IGwgPSBTZXEuZm9sZF9sZWZ0IChmdW4gYWNjIHggLT4geDo6YWNjKSBbXSBpIGluXG4gICAgb2ZfcmV2X2xpc3QgbFxuXG5cbiAgbGV0IG1hcF90b19hcnJheSBmIGEgPVxuICAgIGxldCBsID0gbGVuZ3RoIGEgaW5cbiAgICBpZiBsID0gMCB0aGVuIFt8IHxdIGVsc2UgYmVnaW5cbiAgICAgIGxldCByID0gQXJyYXkubWFrZSBsIChmICh1bnNhZmVfZ2V0IGEgMCkpIGluXG4gICAgICBmb3IgaSA9IDEgdG8gbCAtIDEgZG9cbiAgICAgICAgQXJyYXkudW5zYWZlX3NldCByIGkgKGYgKHVuc2FmZV9nZXQgYSBpKSlcbiAgICAgIGRvbmU7XG4gICAgICByXG4gICAgZW5kXG5cbiAgbGV0IG1hcF9mcm9tX2FycmF5IGYgYSA9XG4gICAgbGV0IGwgPSBBcnJheS5sZW5ndGggYSBpblxuICAgIGxldCByID0gY3JlYXRlIGwgaW5cbiAgICBmb3IgaSA9IDAgdG8gbCAtIDEgZG9cbiAgICAgIHVuc2FmZV9zZXQgciBpIChmIChBcnJheS51bnNhZmVfZ2V0IGEgaSkpXG4gICAgZG9uZTtcbiAgICByXG5cbmVuZFxuXG5tb2R1bGUgQXJyYXlMYWJlbHMgPSBBcnJheVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBNb2R1bGUgW0ludDMyXTogMzItYml0IGludGVnZXJzICopXG5cbmV4dGVybmFsIG5lZyA6IGludDMyIC0+IGludDMyID0gXCIlaW50MzJfbmVnXCJcbmV4dGVybmFsIGFkZCA6IGludDMyIC0+IGludDMyIC0+IGludDMyID0gXCIlaW50MzJfYWRkXCJcbmV4dGVybmFsIHN1YiA6IGludDMyIC0+IGludDMyIC0+IGludDMyID0gXCIlaW50MzJfc3ViXCJcbmV4dGVybmFsIG11bCA6IGludDMyIC0+IGludDMyIC0+IGludDMyID0gXCIlaW50MzJfbXVsXCJcbmV4dGVybmFsIGRpdiA6IGludDMyIC0+IGludDMyIC0+IGludDMyID0gXCIlaW50MzJfZGl2XCJcbmV4dGVybmFsIHJlbSA6IGludDMyIC0+IGludDMyIC0+IGludDMyID0gXCIlaW50MzJfbW9kXCJcbmV4dGVybmFsIGxvZ2FuZCA6IGludDMyIC0+IGludDMyIC0+IGludDMyID0gXCIlaW50MzJfYW5kXCJcbmV4dGVybmFsIGxvZ29yIDogaW50MzIgLT4gaW50MzIgLT4gaW50MzIgPSBcIiVpbnQzMl9vclwiXG5leHRlcm5hbCBsb2d4b3IgOiBpbnQzMiAtPiBpbnQzMiAtPiBpbnQzMiA9IFwiJWludDMyX3hvclwiXG5leHRlcm5hbCBzaGlmdF9sZWZ0IDogaW50MzIgLT4gaW50IC0+IGludDMyID0gXCIlaW50MzJfbHNsXCJcbmV4dGVybmFsIHNoaWZ0X3JpZ2h0IDogaW50MzIgLT4gaW50IC0+IGludDMyID0gXCIlaW50MzJfYXNyXCJcbmV4dGVybmFsIHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgOiBpbnQzMiAtPiBpbnQgLT4gaW50MzIgPSBcIiVpbnQzMl9sc3JcIlxuZXh0ZXJuYWwgb2ZfaW50IDogaW50IC0+IGludDMyID0gXCIlaW50MzJfb2ZfaW50XCJcbmV4dGVybmFsIHRvX2ludCA6IGludDMyIC0+IGludCA9IFwiJWludDMyX3RvX2ludFwiXG5leHRlcm5hbCBvZl9mbG9hdCA6IGZsb2F0IC0+IGludDMyXG4gID0gXCJjYW1sX2ludDMyX29mX2Zsb2F0XCIgXCJjYW1sX2ludDMyX29mX2Zsb2F0X3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdG9fZmxvYXQgOiBpbnQzMiAtPiBmbG9hdFxuICA9IFwiY2FtbF9pbnQzMl90b19mbG9hdFwiIFwiY2FtbF9pbnQzMl90b19mbG9hdF91bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGJpdHNfb2ZfZmxvYXQgOiBmbG9hdCAtPiBpbnQzMlxuICA9IFwiY2FtbF9pbnQzMl9iaXRzX29mX2Zsb2F0XCIgXCJjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXRfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBmbG9hdF9vZl9iaXRzIDogaW50MzIgLT4gZmxvYXRcbiAgPSBcImNhbWxfaW50MzJfZmxvYXRfb2ZfYml0c1wiIFwiY2FtbF9pbnQzMl9mbG9hdF9vZl9iaXRzX3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuXG5sZXQgemVybyA9IDBsXG5sZXQgb25lID0gMWxcbmxldCBtaW51c19vbmUgPSAtMWxcbmxldCBzdWNjIG4gPSBhZGQgbiAxbFxubGV0IHByZWQgbiA9IHN1YiBuIDFsXG5sZXQgYWJzIG4gPSBpZiBuID49IDBsIHRoZW4gbiBlbHNlIG5lZyBuXG5sZXQgbWluX2ludCA9IDB4ODAwMDAwMDBsXG5sZXQgbWF4X2ludCA9IDB4N0ZGRkZGRkZsXG5sZXQgbG9nbm90IG4gPSBsb2d4b3IgbiAoLTFsKVxuXG5sZXQgdW5zaWduZWRfdG9faW50ID1cbiAgbWF0Y2ggU3lzLndvcmRfc2l6ZSB3aXRoXG4gIHwgMzIgLT5cbiAgICAgIGxldCBtYXhfaW50ID0gb2ZfaW50IFN0ZGxpYi5tYXhfaW50IGluXG4gICAgICBmdW4gbiAtPlxuICAgICAgICBpZiBjb21wYXJlIHplcm8gbiA8PSAwICYmIGNvbXBhcmUgbiBtYXhfaW50IDw9IDAgdGhlblxuICAgICAgICAgIFNvbWUgKHRvX2ludCBuKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgTm9uZVxuICB8IDY0IC0+XG4gICAgICAoKiBTbyB0aGF0IGl0IGNvbXBpbGVzIGluIDMyLWJpdCAqKVxuICAgICAgbGV0IG1hc2sgPSAweEZGRkYgbHNsIDE2IGxvciAweEZGRkYgaW5cbiAgICAgIGZ1biBuIC0+IFNvbWUgKHRvX2ludCBuIGxhbmQgbWFzaylcbiAgfCBfIC0+XG4gICAgICBhc3NlcnQgZmFsc2VcblxuZXh0ZXJuYWwgZm9ybWF0IDogc3RyaW5nIC0+IGludDMyIC0+IHN0cmluZyA9IFwiY2FtbF9pbnQzMl9mb3JtYXRcIlxubGV0IHRvX3N0cmluZyBuID0gZm9ybWF0IFwiJWRcIiBuXG5cbmV4dGVybmFsIG9mX3N0cmluZyA6IHN0cmluZyAtPiBpbnQzMiA9IFwiY2FtbF9pbnQzMl9vZl9zdHJpbmdcIlxuXG5sZXQgb2Zfc3RyaW5nX29wdCBzID1cbiAgKCogVE9ETzogZXhwb3NlIGEgbm9uLXJhaXNpbmcgcHJpbWl0aXZlIGRpcmVjdGx5LiAqKVxuICB0cnkgU29tZSAob2Zfc3RyaW5nIHMpXG4gIHdpdGggRmFpbHVyZSBfIC0+IE5vbmVcblxudHlwZSB0ID0gaW50MzJcblxubGV0IGNvbXBhcmUgKHg6IHQpICh5OiB0KSA9IFN0ZGxpYi5jb21wYXJlIHggeVxubGV0IGVxdWFsICh4OiB0KSAoeTogdCkgPSBjb21wYXJlIHggeSA9IDBcblxubGV0IHVuc2lnbmVkX2NvbXBhcmUgbiBtID1cbiAgY29tcGFyZSAoc3ViIG4gbWluX2ludCkgKHN1YiBtIG1pbl9pbnQpXG5cbmxldCBtaW4geCB5IDogdCA9IGlmIHggPD0geSB0aGVuIHggZWxzZSB5XG5sZXQgbWF4IHggeSA6IHQgPSBpZiB4ID49IHkgdGhlbiB4IGVsc2UgeVxuXG4oKiBVbnNpZ25lZCBkaXZpc2lvbiBmcm9tIHNpZ25lZCBkaXZpc2lvbiBvZiB0aGUgc2FtZVxuICAgYml0bmVzcy4gU2VlIFdhcnJlbiBKci4sIEhlbnJ5IFMuICgyMDEzKS4gSGFja2VyJ3MgRGVsaWdodCAoMiBlZC4pLCBTZWMgOS0zLlxuKilcbmxldCB1bnNpZ25lZF9kaXYgbiBkID1cbiAgaWYgZCA8IHplcm8gdGhlblxuICAgIGlmIHVuc2lnbmVkX2NvbXBhcmUgbiBkIDwgMCB0aGVuIHplcm8gZWxzZSBvbmVcbiAgZWxzZVxuICAgIGxldCBxID0gc2hpZnRfbGVmdCAoZGl2IChzaGlmdF9yaWdodF9sb2dpY2FsIG4gMSkgZCkgMSBpblxuICAgIGxldCByID0gc3ViIG4gKG11bCBxIGQpIGluXG4gICAgaWYgdW5zaWduZWRfY29tcGFyZSByIGQgPj0gMCB0aGVuIHN1Y2MgcSBlbHNlIHFcblxubGV0IHVuc2lnbmVkX3JlbSBuIGQgPVxuICBzdWIgbiAobXVsICh1bnNpZ25lZF9kaXYgbiBkKSBkKVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBNb2R1bGUgW0ludDY0XTogNjQtYml0IGludGVnZXJzICopXG5cbmV4dGVybmFsIG5lZyA6IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfbmVnXCJcbmV4dGVybmFsIGFkZCA6IGludDY0IC0+IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfYWRkXCJcbmV4dGVybmFsIHN1YiA6IGludDY0IC0+IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfc3ViXCJcbmV4dGVybmFsIG11bCA6IGludDY0IC0+IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfbXVsXCJcbmV4dGVybmFsIGRpdiA6IGludDY0IC0+IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfZGl2XCJcbmV4dGVybmFsIHJlbSA6IGludDY0IC0+IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfbW9kXCJcbmV4dGVybmFsIGxvZ2FuZCA6IGludDY0IC0+IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfYW5kXCJcbmV4dGVybmFsIGxvZ29yIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9vclwiXG5leHRlcm5hbCBsb2d4b3IgOiBpbnQ2NCAtPiBpbnQ2NCAtPiBpbnQ2NCA9IFwiJWludDY0X3hvclwiXG5leHRlcm5hbCBzaGlmdF9sZWZ0IDogaW50NjQgLT4gaW50IC0+IGludDY0ID0gXCIlaW50NjRfbHNsXCJcbmV4dGVybmFsIHNoaWZ0X3JpZ2h0IDogaW50NjQgLT4gaW50IC0+IGludDY0ID0gXCIlaW50NjRfYXNyXCJcbmV4dGVybmFsIHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgOiBpbnQ2NCAtPiBpbnQgLT4gaW50NjQgPSBcIiVpbnQ2NF9sc3JcIlxuZXh0ZXJuYWwgb2ZfaW50IDogaW50IC0+IGludDY0ID0gXCIlaW50NjRfb2ZfaW50XCJcbmV4dGVybmFsIHRvX2ludCA6IGludDY0IC0+IGludCA9IFwiJWludDY0X3RvX2ludFwiXG5leHRlcm5hbCBvZl9mbG9hdCA6IGZsb2F0IC0+IGludDY0XG4gID0gXCJjYW1sX2ludDY0X29mX2Zsb2F0XCIgXCJjYW1sX2ludDY0X29mX2Zsb2F0X3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdG9fZmxvYXQgOiBpbnQ2NCAtPiBmbG9hdFxuICA9IFwiY2FtbF9pbnQ2NF90b19mbG9hdFwiIFwiY2FtbF9pbnQ2NF90b19mbG9hdF91bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIG9mX2ludDMyIDogaW50MzIgLT4gaW50NjQgPSBcIiVpbnQ2NF9vZl9pbnQzMlwiXG5leHRlcm5hbCB0b19pbnQzMiA6IGludDY0IC0+IGludDMyID0gXCIlaW50NjRfdG9faW50MzJcIlxuZXh0ZXJuYWwgb2ZfbmF0aXZlaW50IDogbmF0aXZlaW50IC0+IGludDY0ID0gXCIlaW50NjRfb2ZfbmF0aXZlaW50XCJcbmV4dGVybmFsIHRvX25hdGl2ZWludCA6IGludDY0IC0+IG5hdGl2ZWludCA9IFwiJWludDY0X3RvX25hdGl2ZWludFwiXG5cbmxldCB6ZXJvID0gMExcbmxldCBvbmUgPSAxTFxubGV0IG1pbnVzX29uZSA9IC0xTFxubGV0IHN1Y2MgbiA9IGFkZCBuIDFMXG5sZXQgcHJlZCBuID0gc3ViIG4gMUxcbmxldCBhYnMgbiA9IGlmIG4gPj0gMEwgdGhlbiBuIGVsc2UgbmVnIG5cbmxldCBtaW5faW50ID0gMHg4MDAwMDAwMDAwMDAwMDAwTFxubGV0IG1heF9pbnQgPSAweDdGRkZGRkZGRkZGRkZGRkZMXG5sZXQgbG9nbm90IG4gPSBsb2d4b3IgbiAoLTFMKVxuXG5sZXQgdW5zaWduZWRfdG9faW50ID1cbiAgbGV0IG1heF9pbnQgPSBvZl9pbnQgU3RkbGliLm1heF9pbnQgaW5cbiAgZnVuIG4gLT5cbiAgICBpZiBjb21wYXJlIHplcm8gbiA8PSAwICYmIGNvbXBhcmUgbiBtYXhfaW50IDw9IDAgdGhlblxuICAgICAgU29tZSAodG9faW50IG4pXG4gICAgZWxzZVxuICAgICAgTm9uZVxuXG5leHRlcm5hbCBmb3JtYXQgOiBzdHJpbmcgLT4gaW50NjQgLT4gc3RyaW5nID0gXCJjYW1sX2ludDY0X2Zvcm1hdFwiXG5sZXQgdG9fc3RyaW5nIG4gPSBmb3JtYXQgXCIlZFwiIG5cblxuZXh0ZXJuYWwgb2Zfc3RyaW5nIDogc3RyaW5nIC0+IGludDY0ID0gXCJjYW1sX2ludDY0X29mX3N0cmluZ1wiXG5cbmxldCBvZl9zdHJpbmdfb3B0IHMgPVxuICAoKiBUT0RPOiBleHBvc2UgYSBub24tcmFpc2luZyBwcmltaXRpdmUgZGlyZWN0bHkuICopXG4gIHRyeSBTb21lIChvZl9zdHJpbmcgcylcbiAgd2l0aCBGYWlsdXJlIF8gLT4gTm9uZVxuXG5cblxuZXh0ZXJuYWwgYml0c19vZl9mbG9hdCA6IGZsb2F0IC0+IGludDY0XG4gID0gXCJjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXRcIiBcImNhbWxfaW50NjRfYml0c19vZl9mbG9hdF91bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGZsb2F0X29mX2JpdHMgOiBpbnQ2NCAtPiBmbG9hdFxuICA9IFwiY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzXCIgXCJjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHNfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5cbnR5cGUgdCA9IGludDY0XG5cbmxldCBjb21wYXJlICh4OiB0KSAoeTogdCkgPSBTdGRsaWIuY29tcGFyZSB4IHlcbmxldCBlcXVhbCAoeDogdCkgKHk6IHQpID0gY29tcGFyZSB4IHkgPSAwXG5cbmxldCB1bnNpZ25lZF9jb21wYXJlIG4gbSA9XG4gIGNvbXBhcmUgKHN1YiBuIG1pbl9pbnQpIChzdWIgbSBtaW5faW50KVxuXG5sZXQgbWluIHggeSA6IHQgPSBpZiB4IDw9IHkgdGhlbiB4IGVsc2UgeVxubGV0IG1heCB4IHkgOiB0ID0gaWYgeCA+PSB5IHRoZW4geCBlbHNlIHlcblxuKCogVW5zaWduZWQgZGl2aXNpb24gZnJvbSBzaWduZWQgZGl2aXNpb24gb2YgdGhlIHNhbWVcbiAgIGJpdG5lc3MuIFNlZSBXYXJyZW4gSnIuLCBIZW5yeSBTLiAoMjAxMykuIEhhY2tlcidzIERlbGlnaHQgKDIgZWQuKSwgU2VjIDktMy5cbiopXG5sZXQgdW5zaWduZWRfZGl2IG4gZCA9XG4gIGlmIGQgPCB6ZXJvIHRoZW5cbiAgICBpZiB1bnNpZ25lZF9jb21wYXJlIG4gZCA8IDAgdGhlbiB6ZXJvIGVsc2Ugb25lXG4gIGVsc2VcbiAgICBsZXQgcSA9IHNoaWZ0X2xlZnQgKGRpdiAoc2hpZnRfcmlnaHRfbG9naWNhbCBuIDEpIGQpIDEgaW5cbiAgICBsZXQgciA9IHN1YiBuIChtdWwgcSBkKSBpblxuICAgIGlmIHVuc2lnbmVkX2NvbXBhcmUgciBkID49IDAgdGhlbiBzdWNjIHEgZWxzZSBxXG5cbmxldCB1bnNpZ25lZF9yZW0gbiBkID1cbiAgc3ViIG4gKG11bCAodW5zaWduZWRfZGl2IG4gZCkgZClcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogTW9kdWxlIFtOYXRpdmVpbnRdOiBwcm9jZXNzb3ItbmF0aXZlIGludGVnZXJzICopXG5cbmV4dGVybmFsIG5lZzogbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9uZWdcIlxuZXh0ZXJuYWwgYWRkOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9hZGRcIlxuZXh0ZXJuYWwgc3ViOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9zdWJcIlxuZXh0ZXJuYWwgbXVsOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9tdWxcIlxuZXh0ZXJuYWwgZGl2OiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9kaXZcIlxuZXh0ZXJuYWwgcmVtOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9tb2RcIlxuZXh0ZXJuYWwgbG9nYW5kOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9hbmRcIlxuZXh0ZXJuYWwgbG9nb3I6IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X29yXCJcbmV4dGVybmFsIGxvZ3hvcjogbmF0aXZlaW50IC0+IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfeG9yXCJcbmV4dGVybmFsIHNoaWZ0X2xlZnQ6IG5hdGl2ZWludCAtPiBpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X2xzbFwiXG5leHRlcm5hbCBzaGlmdF9yaWdodDogbmF0aXZlaW50IC0+IGludCAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfYXNyXCJcbmV4dGVybmFsIHNoaWZ0X3JpZ2h0X2xvZ2ljYWw6IG5hdGl2ZWludCAtPiBpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X2xzclwiXG5leHRlcm5hbCBvZl9pbnQ6IGludCAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfb2ZfaW50XCJcbmV4dGVybmFsIHRvX2ludDogbmF0aXZlaW50IC0+IGludCA9IFwiJW5hdGl2ZWludF90b19pbnRcIlxuZXh0ZXJuYWwgb2ZfZmxvYXQgOiBmbG9hdCAtPiBuYXRpdmVpbnRcbiAgPSBcImNhbWxfbmF0aXZlaW50X29mX2Zsb2F0XCIgXCJjYW1sX25hdGl2ZWludF9vZl9mbG9hdF91bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHRvX2Zsb2F0IDogbmF0aXZlaW50IC0+IGZsb2F0XG4gID0gXCJjYW1sX25hdGl2ZWludF90b19mbG9hdFwiIFwiY2FtbF9uYXRpdmVpbnRfdG9fZmxvYXRfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBvZl9pbnQzMjogaW50MzIgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X29mX2ludDMyXCJcbmV4dGVybmFsIHRvX2ludDMyOiBuYXRpdmVpbnQgLT4gaW50MzIgPSBcIiVuYXRpdmVpbnRfdG9faW50MzJcIlxuXG5sZXQgemVybyA9IDBuXG5sZXQgb25lID0gMW5cbmxldCBtaW51c19vbmUgPSAtMW5cbmxldCBzdWNjIG4gPSBhZGQgbiAxblxubGV0IHByZWQgbiA9IHN1YiBuIDFuXG5sZXQgYWJzIG4gPSBpZiBuID49IDBuIHRoZW4gbiBlbHNlIG5lZyBuXG5sZXQgc2l6ZSA9IFN5cy53b3JkX3NpemVcbmxldCBtaW5faW50ID0gc2hpZnRfbGVmdCAxbiAoc2l6ZSAtIDEpXG5sZXQgbWF4X2ludCA9IHN1YiBtaW5faW50IDFuXG5sZXQgbG9nbm90IG4gPSBsb2d4b3IgbiAoLTFuKVxuXG5sZXQgdW5zaWduZWRfdG9faW50ID1cbiAgbGV0IG1heF9pbnQgPSBvZl9pbnQgU3RkbGliLm1heF9pbnQgaW5cbiAgZnVuIG4gLT5cbiAgICBpZiBjb21wYXJlIHplcm8gbiA8PSAwICYmIGNvbXBhcmUgbiBtYXhfaW50IDw9IDAgdGhlblxuICAgICAgU29tZSAodG9faW50IG4pXG4gICAgZWxzZVxuICAgICAgTm9uZVxuXG5leHRlcm5hbCBmb3JtYXQgOiBzdHJpbmcgLT4gbmF0aXZlaW50IC0+IHN0cmluZyA9IFwiY2FtbF9uYXRpdmVpbnRfZm9ybWF0XCJcbmxldCB0b19zdHJpbmcgbiA9IGZvcm1hdCBcIiVkXCIgblxuXG5leHRlcm5hbCBvZl9zdHJpbmc6IHN0cmluZyAtPiBuYXRpdmVpbnQgPSBcImNhbWxfbmF0aXZlaW50X29mX3N0cmluZ1wiXG5cbmxldCBvZl9zdHJpbmdfb3B0IHMgPVxuICAoKiBUT0RPOiBleHBvc2UgYSBub24tcmFpc2luZyBwcmltaXRpdmUgZGlyZWN0bHkuICopXG4gIHRyeSBTb21lIChvZl9zdHJpbmcgcylcbiAgd2l0aCBGYWlsdXJlIF8gLT4gTm9uZVxuXG50eXBlIHQgPSBuYXRpdmVpbnRcblxubGV0IGNvbXBhcmUgKHg6IHQpICh5OiB0KSA9IFN0ZGxpYi5jb21wYXJlIHggeVxubGV0IGVxdWFsICh4OiB0KSAoeTogdCkgPSBjb21wYXJlIHggeSA9IDBcblxubGV0IHVuc2lnbmVkX2NvbXBhcmUgbiBtID1cbiAgY29tcGFyZSAoc3ViIG4gbWluX2ludCkgKHN1YiBtIG1pbl9pbnQpXG5cbmxldCBtaW4geCB5IDogdCA9IGlmIHggPD0geSB0aGVuIHggZWxzZSB5XG5sZXQgbWF4IHggeSA6IHQgPSBpZiB4ID49IHkgdGhlbiB4IGVsc2UgeVxuXG4oKiBVbnNpZ25lZCBkaXZpc2lvbiBmcm9tIHNpZ25lZCBkaXZpc2lvbiBvZiB0aGUgc2FtZVxuICAgYml0bmVzcy4gU2VlIFdhcnJlbiBKci4sIEhlbnJ5IFMuICgyMDEzKS4gSGFja2VyJ3MgRGVsaWdodCAoMiBlZC4pLCBTZWMgOS0zLlxuKilcbmxldCB1bnNpZ25lZF9kaXYgbiBkID1cbiAgaWYgZCA8IHplcm8gdGhlblxuICAgIGlmIHVuc2lnbmVkX2NvbXBhcmUgbiBkIDwgMCB0aGVuIHplcm8gZWxzZSBvbmVcbiAgZWxzZVxuICAgIGxldCBxID0gc2hpZnRfbGVmdCAoZGl2IChzaGlmdF9yaWdodF9sb2dpY2FsIG4gMSkgZCkgMSBpblxuICAgIGxldCByID0gc3ViIG4gKG11bCBxIGQpIGluXG4gICAgaWYgdW5zaWduZWRfY29tcGFyZSByIGQgPj0gMCB0aGVuIHN1Y2MgcSBlbHNlIHFcblxubGV0IHVuc2lnbmVkX3JlbSBuIGQgPVxuICBzdWIgbiAobXVsICh1bnNpZ25lZF9kaXYgbiBkKSBkKVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBUaGUgcnVuLXRpbWUgbGlicmFyeSBmb3IgbGV4ZXJzIGdlbmVyYXRlZCBieSBjYW1sbGV4ICopXG5cbnR5cGUgcG9zaXRpb24gPSB7XG4gIHBvc19mbmFtZSA6IHN0cmluZztcbiAgcG9zX2xudW0gOiBpbnQ7XG4gIHBvc19ib2wgOiBpbnQ7XG4gIHBvc19jbnVtIDogaW50O1xufVxuXG5sZXQgZHVtbXlfcG9zID0ge1xuICBwb3NfZm5hbWUgPSBcIlwiO1xuICBwb3NfbG51bSA9IDA7XG4gIHBvc19ib2wgPSAwO1xuICBwb3NfY251bSA9IC0xO1xufVxuXG50eXBlIGxleGJ1ZiA9XG4gIHsgcmVmaWxsX2J1ZmYgOiBsZXhidWYgLT4gdW5pdDtcbiAgICBtdXRhYmxlIGxleF9idWZmZXIgOiBieXRlcztcbiAgICBtdXRhYmxlIGxleF9idWZmZXJfbGVuIDogaW50O1xuICAgIG11dGFibGUgbGV4X2Fic19wb3MgOiBpbnQ7XG4gICAgbXV0YWJsZSBsZXhfc3RhcnRfcG9zIDogaW50O1xuICAgIG11dGFibGUgbGV4X2N1cnJfcG9zIDogaW50O1xuICAgIG11dGFibGUgbGV4X2xhc3RfcG9zIDogaW50O1xuICAgIG11dGFibGUgbGV4X2xhc3RfYWN0aW9uIDogaW50O1xuICAgIG11dGFibGUgbGV4X2VvZl9yZWFjaGVkIDogYm9vbDtcbiAgICBtdXRhYmxlIGxleF9tZW0gOiBpbnQgYXJyYXk7XG4gICAgbXV0YWJsZSBsZXhfc3RhcnRfcCA6IHBvc2l0aW9uO1xuICAgIG11dGFibGUgbGV4X2N1cnJfcCA6IHBvc2l0aW9uO1xuICB9XG5cbnR5cGUgbGV4X3RhYmxlcyA9XG4gIHsgbGV4X2Jhc2U6IHN0cmluZztcbiAgICBsZXhfYmFja3Ryazogc3RyaW5nO1xuICAgIGxleF9kZWZhdWx0OiBzdHJpbmc7XG4gICAgbGV4X3RyYW5zOiBzdHJpbmc7XG4gICAgbGV4X2NoZWNrOiBzdHJpbmc7XG4gICAgbGV4X2Jhc2VfY29kZSA6IHN0cmluZztcbiAgICBsZXhfYmFja3Rya19jb2RlIDogc3RyaW5nO1xuICAgIGxleF9kZWZhdWx0X2NvZGUgOiBzdHJpbmc7XG4gICAgbGV4X3RyYW5zX2NvZGUgOiBzdHJpbmc7XG4gICAgbGV4X2NoZWNrX2NvZGUgOiBzdHJpbmc7XG4gICAgbGV4X2NvZGU6IHN0cmluZzt9XG5cbmV4dGVybmFsIGNfZW5naW5lIDogbGV4X3RhYmxlcyAtPiBpbnQgLT4gbGV4YnVmIC0+IGludCA9IFwiY2FtbF9sZXhfZW5naW5lXCJcbmV4dGVybmFsIGNfbmV3X2VuZ2luZSA6IGxleF90YWJsZXMgLT4gaW50IC0+IGxleGJ1ZiAtPiBpbnRcbiAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9uZXdfbGV4X2VuZ2luZVwiXG5cbmxldCBlbmdpbmUgdGJsIHN0YXRlIGJ1ZiA9XG4gIGxldCByZXN1bHQgPSBjX2VuZ2luZSB0Ymwgc3RhdGUgYnVmIGluXG4gIGlmIHJlc3VsdCA+PSAwICYmIGJ1Zi5sZXhfY3Vycl9wICE9IGR1bW15X3BvcyB0aGVuIGJlZ2luXG4gICAgYnVmLmxleF9zdGFydF9wIDwtIGJ1Zi5sZXhfY3Vycl9wO1xuICAgIGJ1Zi5sZXhfY3Vycl9wIDwtIHtidWYubGV4X2N1cnJfcFxuICAgICAgICAgICAgICAgICAgICAgICB3aXRoIHBvc19jbnVtID0gYnVmLmxleF9hYnNfcG9zICsgYnVmLmxleF9jdXJyX3Bvc307XG4gIGVuZDtcbiAgcmVzdWx0XG5cblxubGV0IG5ld19lbmdpbmUgdGJsIHN0YXRlIGJ1ZiA9XG4gIGxldCByZXN1bHQgPSBjX25ld19lbmdpbmUgdGJsIHN0YXRlIGJ1ZiBpblxuICBpZiByZXN1bHQgPj0gMCAmJiBidWYubGV4X2N1cnJfcCAhPSBkdW1teV9wb3MgdGhlbiBiZWdpblxuICAgIGJ1Zi5sZXhfc3RhcnRfcCA8LSBidWYubGV4X2N1cnJfcDtcbiAgICBidWYubGV4X2N1cnJfcCA8LSB7YnVmLmxleF9jdXJyX3BcbiAgICAgICAgICAgICAgICAgICAgICAgd2l0aCBwb3NfY251bSA9IGJ1Zi5sZXhfYWJzX3BvcyArIGJ1Zi5sZXhfY3Vycl9wb3N9O1xuICBlbmQ7XG4gIHJlc3VsdFxuXG5sZXQgbGV4X3JlZmlsbCByZWFkX2Z1biBhdXhfYnVmZmVyIGxleGJ1ZiA9XG4gIGxldCByZWFkID1cbiAgICByZWFkX2Z1biBhdXhfYnVmZmVyIChCeXRlcy5sZW5ndGggYXV4X2J1ZmZlcikgaW5cbiAgbGV0IG4gPVxuICAgIGlmIHJlYWQgPiAwXG4gICAgdGhlbiByZWFkXG4gICAgZWxzZSAobGV4YnVmLmxleF9lb2ZfcmVhY2hlZCA8LSB0cnVlOyAwKSBpblxuICAoKiBDdXJyZW50IHN0YXRlIG9mIHRoZSBidWZmZXI6XG4gICAgICAgIDwtLS0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLT5cbiAgICAgICAgfCAganVuayB8ICAgICAgdmFsaWQgZGF0YSAgICAgfCAgIGp1bmsgICAgfFxuICAgICAgICBeICAgICAgIF4gICAgICAgICAgICAgICAgICAgICBeICAgICAgICAgICBeXG4gICAgICAgIDAgICAgc3RhcnRfcG9zICAgICAgICAgICAgIGJ1ZmZlcl9lbmQgICAgQnl0ZXMubGVuZ3RoIGJ1ZmZlclxuICAqKVxuICBpZiBsZXhidWYubGV4X2J1ZmZlcl9sZW4gKyBuID4gQnl0ZXMubGVuZ3RoIGxleGJ1Zi5sZXhfYnVmZmVyIHRoZW4gYmVnaW5cbiAgICAoKiBUaGVyZSBpcyBub3QgZW5vdWdoIHNwYWNlIGF0IHRoZSBlbmQgb2YgdGhlIGJ1ZmZlciAqKVxuICAgIGlmIGxleGJ1Zi5sZXhfYnVmZmVyX2xlbiAtIGxleGJ1Zi5sZXhfc3RhcnRfcG9zICsgblxuICAgICAgIDw9IEJ5dGVzLmxlbmd0aCBsZXhidWYubGV4X2J1ZmZlclxuICAgIHRoZW4gYmVnaW5cbiAgICAgICgqIEJ1dCB0aGVyZSBpcyBlbm91Z2ggc3BhY2UgaWYgd2UgcmVjbGFpbSB0aGUganVuayBhdCB0aGUgYmVnaW5uaW5nXG4gICAgICAgICBvZiB0aGUgYnVmZmVyICopXG4gICAgICBCeXRlcy5ibGl0IGxleGJ1Zi5sZXhfYnVmZmVyIGxleGJ1Zi5sZXhfc3RhcnRfcG9zXG4gICAgICAgICAgICAgICAgICBsZXhidWYubGV4X2J1ZmZlciAwXG4gICAgICAgICAgICAgICAgICAobGV4YnVmLmxleF9idWZmZXJfbGVuIC0gbGV4YnVmLmxleF9zdGFydF9wb3MpXG4gICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICgqIFdlIG11c3QgZ3JvdyB0aGUgYnVmZmVyLiAgRG91YmxpbmcgaXRzIHNpemUgd2lsbCBwcm92aWRlIGVub3VnaFxuICAgICAgICAgc3BhY2Ugc2luY2UgbiA8PSBTdHJpbmcubGVuZ3RoIGF1eF9idWZmZXIgPD0gU3RyaW5nLmxlbmd0aCBidWZmZXIuXG4gICAgICAgICBXYXRjaCBvdXQgZm9yIHN0cmluZyBsZW5ndGggb3ZlcmZsb3csIHRob3VnaC4gKilcbiAgICAgIGxldCBuZXdsZW4gPVxuICAgICAgICBJbnQubWluICgyICogQnl0ZXMubGVuZ3RoIGxleGJ1Zi5sZXhfYnVmZmVyKSBTeXMubWF4X3N0cmluZ19sZW5ndGggaW5cbiAgICAgIGlmIGxleGJ1Zi5sZXhfYnVmZmVyX2xlbiAtIGxleGJ1Zi5sZXhfc3RhcnRfcG9zICsgbiA+IG5ld2xlblxuICAgICAgdGhlbiBmYWlsd2l0aCBcIkxleGluZy5sZXhfcmVmaWxsOiBjYW5ub3QgZ3JvdyBidWZmZXJcIjtcbiAgICAgIGxldCBuZXdidWYgPSBCeXRlcy5jcmVhdGUgbmV3bGVuIGluXG4gICAgICAoKiBDb3B5IHRoZSB2YWxpZCBkYXRhIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIG5ldyBidWZmZXIgKilcbiAgICAgIEJ5dGVzLmJsaXQgbGV4YnVmLmxleF9idWZmZXIgbGV4YnVmLmxleF9zdGFydF9wb3NcbiAgICAgICAgICAgICAgICAgIG5ld2J1ZiAwXG4gICAgICAgICAgICAgICAgICAobGV4YnVmLmxleF9idWZmZXJfbGVuIC0gbGV4YnVmLmxleF9zdGFydF9wb3MpO1xuICAgICAgbGV4YnVmLmxleF9idWZmZXIgPC0gbmV3YnVmXG4gICAgZW5kO1xuICAgICgqIFJlYWxsb2NhdGlvbiBvciBub3QsIHdlIGhhdmUgc2hpZnRlZCB0aGUgZGF0YSBsZWZ0IGJ5XG4gICAgICAgc3RhcnRfcG9zIGNoYXJhY3RlcnM7IHVwZGF0ZSB0aGUgcG9zaXRpb25zICopXG4gICAgbGV0IHMgPSBsZXhidWYubGV4X3N0YXJ0X3BvcyBpblxuICAgIGxleGJ1Zi5sZXhfYWJzX3BvcyA8LSBsZXhidWYubGV4X2Fic19wb3MgKyBzO1xuICAgIGxleGJ1Zi5sZXhfY3Vycl9wb3MgPC0gbGV4YnVmLmxleF9jdXJyX3BvcyAtIHM7XG4gICAgbGV4YnVmLmxleF9zdGFydF9wb3MgPC0gMDtcbiAgICBsZXhidWYubGV4X2xhc3RfcG9zIDwtIGxleGJ1Zi5sZXhfbGFzdF9wb3MgLSBzO1xuICAgIGxleGJ1Zi5sZXhfYnVmZmVyX2xlbiA8LSBsZXhidWYubGV4X2J1ZmZlcl9sZW4gLSBzIDtcbiAgICBsZXQgdCA9IGxleGJ1Zi5sZXhfbWVtIGluXG4gICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCB0LTEgZG9cbiAgICAgIGxldCB2ID0gdC4oaSkgaW5cbiAgICAgIGlmIHYgPj0gMCB0aGVuXG4gICAgICAgIHQuKGkpIDwtIHYtc1xuICAgIGRvbmVcbiAgZW5kO1xuICAoKiBUaGVyZSBpcyBub3cgZW5vdWdoIHNwYWNlIGF0IHRoZSBlbmQgb2YgdGhlIGJ1ZmZlciAqKVxuICBCeXRlcy5ibGl0IGF1eF9idWZmZXIgMCBsZXhidWYubGV4X2J1ZmZlciBsZXhidWYubGV4X2J1ZmZlcl9sZW4gbjtcbiAgbGV4YnVmLmxleF9idWZmZXJfbGVuIDwtIGxleGJ1Zi5sZXhfYnVmZmVyX2xlbiArIG5cblxubGV0IHplcm9fcG9zID0ge1xuICBwb3NfZm5hbWUgPSBcIlwiO1xuICBwb3NfbG51bSA9IDE7XG4gIHBvc19ib2wgPSAwO1xuICBwb3NfY251bSA9IDA7XG59XG5cbmxldCBmcm9tX2Z1bmN0aW9uID8od2l0aF9wb3NpdGlvbnMgPSB0cnVlKSBmID1cbiAgeyByZWZpbGxfYnVmZiA9IGxleF9yZWZpbGwgZiAoQnl0ZXMuY3JlYXRlIDUxMik7XG4gICAgbGV4X2J1ZmZlciA9IEJ5dGVzLmNyZWF0ZSAxMDI0O1xuICAgIGxleF9idWZmZXJfbGVuID0gMDtcbiAgICBsZXhfYWJzX3BvcyA9IDA7XG4gICAgbGV4X3N0YXJ0X3BvcyA9IDA7XG4gICAgbGV4X2N1cnJfcG9zID0gMDtcbiAgICBsZXhfbGFzdF9wb3MgPSAwO1xuICAgIGxleF9sYXN0X2FjdGlvbiA9IDA7XG4gICAgbGV4X21lbSA9IFt8fF07XG4gICAgbGV4X2VvZl9yZWFjaGVkID0gZmFsc2U7XG4gICAgbGV4X3N0YXJ0X3AgPSBpZiB3aXRoX3Bvc2l0aW9ucyB0aGVuIHplcm9fcG9zIGVsc2UgZHVtbXlfcG9zO1xuICAgIGxleF9jdXJyX3AgPSBpZiB3aXRoX3Bvc2l0aW9ucyB0aGVuIHplcm9fcG9zIGVsc2UgZHVtbXlfcG9zO1xuICB9XG5cbmxldCBmcm9tX2NoYW5uZWwgP3dpdGhfcG9zaXRpb25zIGljID1cbiAgZnJvbV9mdW5jdGlvbiA/d2l0aF9wb3NpdGlvbnMgKGZ1biBidWYgbiAtPiBpbnB1dCBpYyBidWYgMCBuKVxuXG5sZXQgZnJvbV9zdHJpbmcgPyh3aXRoX3Bvc2l0aW9ucyA9IHRydWUpIHMgPVxuICB7IHJlZmlsbF9idWZmID0gKGZ1biBsZXhidWYgLT4gbGV4YnVmLmxleF9lb2ZfcmVhY2hlZCA8LSB0cnVlKTtcbiAgICBsZXhfYnVmZmVyID0gQnl0ZXMub2Zfc3RyaW5nIHM7ICgqIGhhdmUgdG8gbWFrZSBhIGNvcHkgZm9yIGNvbXBhdGliaWxpdHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpdGggdW5zYWZlLXN0cmluZyBtb2RlICopXG4gICAgbGV4X2J1ZmZlcl9sZW4gPSBTdHJpbmcubGVuZ3RoIHM7XG4gICAgbGV4X2Fic19wb3MgPSAwO1xuICAgIGxleF9zdGFydF9wb3MgPSAwO1xuICAgIGxleF9jdXJyX3BvcyA9IDA7XG4gICAgbGV4X2xhc3RfcG9zID0gMDtcbiAgICBsZXhfbGFzdF9hY3Rpb24gPSAwO1xuICAgIGxleF9tZW0gPSBbfHxdO1xuICAgIGxleF9lb2ZfcmVhY2hlZCA9IHRydWU7XG4gICAgbGV4X3N0YXJ0X3AgPSBpZiB3aXRoX3Bvc2l0aW9ucyB0aGVuIHplcm9fcG9zIGVsc2UgZHVtbXlfcG9zO1xuICAgIGxleF9jdXJyX3AgPSBpZiB3aXRoX3Bvc2l0aW9ucyB0aGVuIHplcm9fcG9zIGVsc2UgZHVtbXlfcG9zO1xuICB9XG5cbmxldCBzZXRfcG9zaXRpb24gbGV4YnVmIHBvc2l0aW9uID1cbiAgbGV4YnVmLmxleF9jdXJyX3AgIDwtIHtwb3NpdGlvbiB3aXRoIHBvc19mbmFtZSA9IGxleGJ1Zi5sZXhfY3Vycl9wLnBvc19mbmFtZX07XG4gIGxleGJ1Zi5sZXhfYWJzX3BvcyA8LSBwb3NpdGlvbi5wb3NfY251bVxuXG5sZXQgc2V0X2ZpbGVuYW1lIGxleGJ1ZiBmbmFtZSA9XG4gIGxleGJ1Zi5sZXhfY3Vycl9wIDwtIHtsZXhidWYubGV4X2N1cnJfcCB3aXRoIHBvc19mbmFtZSA9IGZuYW1lfVxuXG5sZXQgd2l0aF9wb3NpdGlvbnMgbGV4YnVmID0gbGV4YnVmLmxleF9jdXJyX3AgIT0gZHVtbXlfcG9zXG5cbmxldCBsZXhlbWUgbGV4YnVmID1cbiAgbGV0IGxlbiA9IGxleGJ1Zi5sZXhfY3Vycl9wb3MgLSBsZXhidWYubGV4X3N0YXJ0X3BvcyBpblxuICBCeXRlcy5zdWJfc3RyaW5nIGxleGJ1Zi5sZXhfYnVmZmVyIGxleGJ1Zi5sZXhfc3RhcnRfcG9zIGxlblxuXG5sZXQgc3ViX2xleGVtZSBsZXhidWYgaTEgaTIgPVxuICBsZXQgbGVuID0gaTItaTEgaW5cbiAgQnl0ZXMuc3ViX3N0cmluZyBsZXhidWYubGV4X2J1ZmZlciBpMSBsZW5cblxubGV0IHN1Yl9sZXhlbWVfb3B0IGxleGJ1ZiBpMSBpMiA9XG4gIGlmIGkxID49IDAgdGhlbiBiZWdpblxuICAgIGxldCBsZW4gPSBpMi1pMSBpblxuICAgIFNvbWUgKEJ5dGVzLnN1Yl9zdHJpbmcgbGV4YnVmLmxleF9idWZmZXIgaTEgbGVuKVxuICBlbmQgZWxzZSBiZWdpblxuICAgIE5vbmVcbiAgZW5kXG5cbmxldCBzdWJfbGV4ZW1lX2NoYXIgbGV4YnVmIGkgPSBCeXRlcy5nZXQgbGV4YnVmLmxleF9idWZmZXIgaVxuXG5sZXQgc3ViX2xleGVtZV9jaGFyX29wdCBsZXhidWYgaSA9XG4gIGlmIGkgPj0gMCB0aGVuXG4gICAgU29tZSAoQnl0ZXMuZ2V0IGxleGJ1Zi5sZXhfYnVmZmVyIGkpXG4gIGVsc2VcbiAgICBOb25lXG5cblxubGV0IGxleGVtZV9jaGFyIGxleGJ1ZiBpID1cbiAgQnl0ZXMuZ2V0IGxleGJ1Zi5sZXhfYnVmZmVyIChsZXhidWYubGV4X3N0YXJ0X3BvcyArIGkpXG5cbmxldCBsZXhlbWVfc3RhcnQgbGV4YnVmID0gbGV4YnVmLmxleF9zdGFydF9wLnBvc19jbnVtXG5sZXQgbGV4ZW1lX2VuZCBsZXhidWYgPSBsZXhidWYubGV4X2N1cnJfcC5wb3NfY251bVxuXG5sZXQgbGV4ZW1lX3N0YXJ0X3AgbGV4YnVmID0gbGV4YnVmLmxleF9zdGFydF9wXG5sZXQgbGV4ZW1lX2VuZF9wIGxleGJ1ZiA9IGxleGJ1Zi5sZXhfY3Vycl9wXG5cbmxldCBuZXdfbGluZSBsZXhidWYgPVxuICBsZXQgbGNwID0gbGV4YnVmLmxleF9jdXJyX3AgaW5cbiAgaWYgbGNwICE9IGR1bW15X3BvcyB0aGVuXG4gICAgbGV4YnVmLmxleF9jdXJyX3AgPC1cbiAgICAgIHsgbGNwIHdpdGhcbiAgICAgICAgcG9zX2xudW0gPSBsY3AucG9zX2xudW0gKyAxO1xuICAgICAgICBwb3NfYm9sID0gbGNwLnBvc19jbnVtO1xuICAgICAgfVxuXG5cblxuKCogRGlzY2FyZCBkYXRhIGxlZnQgaW4gbGV4ZXIgYnVmZmVyLiAqKVxuXG5sZXQgZmx1c2hfaW5wdXQgbGIgPVxuICBsYi5sZXhfY3Vycl9wb3MgPC0gMDtcbiAgbGIubGV4X2Fic19wb3MgPC0gMDtcbiAgbGV0IGxjcCA9IGxiLmxleF9jdXJyX3AgaW5cbiAgaWYgbGNwICE9IGR1bW15X3BvcyB0aGVuXG4gICAgbGIubGV4X2N1cnJfcCA8LSB7emVyb19wb3Mgd2l0aCBwb3NfZm5hbWUgPSBsY3AucG9zX2ZuYW1lfTtcbiAgbGIubGV4X2J1ZmZlcl9sZW4gPC0gMDtcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogVGhlIHBhcnNpbmcgZW5naW5lICopXG5cbm9wZW4gTGV4aW5nXG5cbigqIEludGVybmFsIGludGVyZmFjZSB0byB0aGUgcGFyc2luZyBlbmdpbmUgKilcblxudHlwZSBwYXJzZXJfZW52ID1cbiAgeyBtdXRhYmxlIHNfc3RhY2sgOiBpbnQgYXJyYXk7ICAgICAgICAoKiBTdGF0ZXMgKilcbiAgICBtdXRhYmxlIHZfc3RhY2sgOiBPYmoudCBhcnJheTsgICAgICAoKiBTZW1hbnRpYyBhdHRyaWJ1dGVzICopXG4gICAgbXV0YWJsZSBzeW1iX3N0YXJ0X3N0YWNrIDogcG9zaXRpb24gYXJyYXk7ICgqIFN0YXJ0IHBvc2l0aW9ucyAqKVxuICAgIG11dGFibGUgc3ltYl9lbmRfc3RhY2sgOiBwb3NpdGlvbiBhcnJheTsgICAoKiBFbmQgcG9zaXRpb25zICopXG4gICAgbXV0YWJsZSBzdGFja3NpemUgOiBpbnQ7ICAgICAgICAgICAgKCogU2l6ZSBvZiB0aGUgc3RhY2tzICopXG4gICAgbXV0YWJsZSBzdGFja2Jhc2UgOiBpbnQ7ICAgICAgICAgICAgKCogQmFzZSBzcCBmb3IgY3VycmVudCBwYXJzZSAqKVxuICAgIG11dGFibGUgY3Vycl9jaGFyIDogaW50OyAgICAgICAgICAgICgqIExhc3QgdG9rZW4gcmVhZCAqKVxuICAgIG11dGFibGUgbHZhbCA6IE9iai50OyAgICAgICAgICAgICAgICgqIEl0cyBzZW1hbnRpYyBhdHRyaWJ1dGUgKilcbiAgICBtdXRhYmxlIHN5bWJfc3RhcnQgOiBwb3NpdGlvbjsgICAgICAoKiBTdGFydCBwb3MuIG9mIHRoZSBjdXJyZW50IHN5bWJvbCopXG4gICAgbXV0YWJsZSBzeW1iX2VuZCA6IHBvc2l0aW9uOyAgICAgICAgKCogRW5kIHBvcy4gb2YgdGhlIGN1cnJlbnQgc3ltYm9sICopXG4gICAgbXV0YWJsZSBhc3AgOiBpbnQ7ICAgICAgICAgICAgICAgICAgKCogVGhlIHN0YWNrIHBvaW50ZXIgZm9yIGF0dHJpYnV0ZXMgKilcbiAgICBtdXRhYmxlIHJ1bGVfbGVuIDogaW50OyAgICAgICAgICAgICAoKiBOdW1iZXIgb2YgcmhzIGl0ZW1zIGluIHRoZSBydWxlICopXG4gICAgbXV0YWJsZSBydWxlX251bWJlciA6IGludDsgICAgICAgICAgKCogUnVsZSBudW1iZXIgdG8gcmVkdWNlIGJ5ICopXG4gICAgbXV0YWJsZSBzcCA6IGludDsgICAgICAgICAgICAgICAgICAgKCogU2F2ZWQgc3AgZm9yIHBhcnNlX2VuZ2luZSAqKVxuICAgIG11dGFibGUgc3RhdGUgOiBpbnQ7ICAgICAgICAgICAgICAgICgqIFNhdmVkIHN0YXRlIGZvciBwYXJzZV9lbmdpbmUgKilcbiAgICBtdXRhYmxlIGVycmZsYWcgOiBpbnQgfSAgICAgICAgICAgICAoKiBTYXZlZCBlcnJvciBmbGFnIGZvciBwYXJzZV9lbmdpbmUgKilcbltAQHdhcm5pbmcgXCItdW51c2VkLWZpZWxkXCJdXG5cbnR5cGUgcGFyc2VfdGFibGVzID1cbiAgeyBhY3Rpb25zIDogKHBhcnNlcl9lbnYgLT4gT2JqLnQpIGFycmF5O1xuICAgIHRyYW5zbF9jb25zdCA6IGludCBhcnJheTtcbiAgICB0cmFuc2xfYmxvY2sgOiBpbnQgYXJyYXk7XG4gICAgbGhzIDogc3RyaW5nO1xuICAgIGxlbiA6IHN0cmluZztcbiAgICBkZWZyZWQgOiBzdHJpbmc7XG4gICAgZGdvdG8gOiBzdHJpbmc7XG4gICAgc2luZGV4IDogc3RyaW5nO1xuICAgIHJpbmRleCA6IHN0cmluZztcbiAgICBnaW5kZXggOiBzdHJpbmc7XG4gICAgdGFibGVzaXplIDogaW50O1xuICAgIHRhYmxlIDogc3RyaW5nO1xuICAgIGNoZWNrIDogc3RyaW5nO1xuICAgIGVycm9yX2Z1bmN0aW9uIDogc3RyaW5nIC0+IHVuaXQ7XG4gICAgbmFtZXNfY29uc3QgOiBzdHJpbmc7XG4gICAgbmFtZXNfYmxvY2sgOiBzdHJpbmcgfVxuXG5leGNlcHRpb24gWVlleGl0IG9mIE9iai50XG5leGNlcHRpb24gUGFyc2VfZXJyb3JcblxudHlwZSBwYXJzZXJfaW5wdXQgPVxuICAgIFN0YXJ0XG4gIHwgVG9rZW5fcmVhZFxuICB8IFN0YWNrc19ncm93bl8xXG4gIHwgU3RhY2tzX2dyb3duXzJcbiAgfCBTZW1hbnRpY19hY3Rpb25fY29tcHV0ZWRcbiAgfCBFcnJvcl9kZXRlY3RlZFxuXG50eXBlIHBhcnNlcl9vdXRwdXQgPVxuICAgIFJlYWRfdG9rZW5cbiAgfCBSYWlzZV9wYXJzZV9lcnJvclxuICB8IEdyb3dfc3RhY2tzXzFcbiAgfCBHcm93X3N0YWNrc18yXG4gIHwgQ29tcHV0ZV9zZW1hbnRpY19hY3Rpb25cbiAgfCBDYWxsX2Vycm9yX2Z1bmN0aW9uXG5cbigqIHRvIGF2b2lkIHdhcm5pbmdzICopXG5sZXQgXyA9IFtSZWFkX3Rva2VuOyBSYWlzZV9wYXJzZV9lcnJvcjsgR3Jvd19zdGFja3NfMTsgR3Jvd19zdGFja3NfMjtcbiAgICAgICAgIENvbXB1dGVfc2VtYW50aWNfYWN0aW9uOyBDYWxsX2Vycm9yX2Z1bmN0aW9uXVxuXG5leHRlcm5hbCBwYXJzZV9lbmdpbmUgOlxuICAgIHBhcnNlX3RhYmxlcyAtPiBwYXJzZXJfZW52IC0+IHBhcnNlcl9pbnB1dCAtPiBPYmoudCAtPiBwYXJzZXJfb3V0cHV0XG4gICAgPSBcImNhbWxfcGFyc2VfZW5naW5lXCJcblxuZXh0ZXJuYWwgc2V0X3RyYWNlOiBib29sIC0+IGJvb2xcbiAgICA9IFwiY2FtbF9zZXRfcGFyc2VyX3RyYWNlXCJcblxubGV0IGVudiA9XG4gIHsgc19zdGFjayA9IEFycmF5Lm1ha2UgMTAwIDA7XG4gICAgdl9zdGFjayA9IEFycmF5Lm1ha2UgMTAwIChPYmoucmVwciAoKSk7XG4gICAgc3ltYl9zdGFydF9zdGFjayA9IEFycmF5Lm1ha2UgMTAwIGR1bW15X3BvcztcbiAgICBzeW1iX2VuZF9zdGFjayA9IEFycmF5Lm1ha2UgMTAwIGR1bW15X3BvcztcbiAgICBzdGFja3NpemUgPSAxMDA7XG4gICAgc3RhY2tiYXNlID0gMDtcbiAgICBjdXJyX2NoYXIgPSAwO1xuICAgIGx2YWwgPSBPYmoucmVwciAoKTtcbiAgICBzeW1iX3N0YXJ0ID0gZHVtbXlfcG9zO1xuICAgIHN5bWJfZW5kID0gZHVtbXlfcG9zO1xuICAgIGFzcCA9IDA7XG4gICAgcnVsZV9sZW4gPSAwO1xuICAgIHJ1bGVfbnVtYmVyID0gMDtcbiAgICBzcCA9IDA7XG4gICAgc3RhdGUgPSAwO1xuICAgIGVycmZsYWcgPSAwIH1cblxubGV0IGdyb3dfc3RhY2tzKCkgPVxuICBsZXQgb2xkc2l6ZSA9IGVudi5zdGFja3NpemUgaW5cbiAgbGV0IG5ld3NpemUgPSBvbGRzaXplICogMiBpblxuICBsZXQgbmV3X3MgPSBBcnJheS5tYWtlIG5ld3NpemUgMFxuICBhbmQgbmV3X3YgPSBBcnJheS5tYWtlIG5ld3NpemUgKE9iai5yZXByICgpKVxuICBhbmQgbmV3X3N0YXJ0ID0gQXJyYXkubWFrZSBuZXdzaXplIGR1bW15X3Bvc1xuICBhbmQgbmV3X2VuZCA9IEFycmF5Lm1ha2UgbmV3c2l6ZSBkdW1teV9wb3MgaW5cbiAgICBBcnJheS5ibGl0IGVudi5zX3N0YWNrIDAgbmV3X3MgMCBvbGRzaXplO1xuICAgIGVudi5zX3N0YWNrIDwtIG5ld19zO1xuICAgIEFycmF5LmJsaXQgZW52LnZfc3RhY2sgMCBuZXdfdiAwIG9sZHNpemU7XG4gICAgZW52LnZfc3RhY2sgPC0gbmV3X3Y7XG4gICAgQXJyYXkuYmxpdCBlbnYuc3ltYl9zdGFydF9zdGFjayAwIG5ld19zdGFydCAwIG9sZHNpemU7XG4gICAgZW52LnN5bWJfc3RhcnRfc3RhY2sgPC0gbmV3X3N0YXJ0O1xuICAgIEFycmF5LmJsaXQgZW52LnN5bWJfZW5kX3N0YWNrIDAgbmV3X2VuZCAwIG9sZHNpemU7XG4gICAgZW52LnN5bWJfZW5kX3N0YWNrIDwtIG5ld19lbmQ7XG4gICAgZW52LnN0YWNrc2l6ZSA8LSBuZXdzaXplXG5cbmxldCBjbGVhcl9wYXJzZXIoKSA9XG4gIEFycmF5LmZpbGwgZW52LnZfc3RhY2sgMCBlbnYuc3RhY2tzaXplIChPYmoucmVwciAoKSk7XG4gIGVudi5sdmFsIDwtIE9iai5yZXByICgpXG5cbmxldCBjdXJyZW50X2xvb2thaGVhZF9mdW4gPSByZWYgKGZ1biAoXyA6IE9iai50KSAtPiBmYWxzZSlcblxubGV0IHl5cGFyc2UgdGFibGVzIHN0YXJ0IGxleGVyIGxleGJ1ZiA9XG4gIGxldCByZWMgbG9vcCBjbWQgYXJnID1cbiAgICBtYXRjaCBwYXJzZV9lbmdpbmUgdGFibGVzIGVudiBjbWQgYXJnIHdpdGhcbiAgICAgIFJlYWRfdG9rZW4gLT5cbiAgICAgICAgbGV0IHQgPSBPYmoucmVwcihsZXhlciBsZXhidWYpIGluXG4gICAgICAgIGVudi5zeW1iX3N0YXJ0IDwtIGxleGJ1Zi5sZXhfc3RhcnRfcDtcbiAgICAgICAgZW52LnN5bWJfZW5kIDwtIGxleGJ1Zi5sZXhfY3Vycl9wO1xuICAgICAgICBsb29wIFRva2VuX3JlYWQgdFxuICAgIHwgUmFpc2VfcGFyc2VfZXJyb3IgLT5cbiAgICAgICAgcmFpc2UgUGFyc2VfZXJyb3JcbiAgICB8IENvbXB1dGVfc2VtYW50aWNfYWN0aW9uIC0+XG4gICAgICAgIGxldCAoYWN0aW9uLCB2YWx1ZSkgPVxuICAgICAgICAgIHRyeVxuICAgICAgICAgICAgKFNlbWFudGljX2FjdGlvbl9jb21wdXRlZCwgdGFibGVzLmFjdGlvbnMuKGVudi5ydWxlX251bWJlcikgZW52KVxuICAgICAgICAgIHdpdGggUGFyc2VfZXJyb3IgLT5cbiAgICAgICAgICAgIChFcnJvcl9kZXRlY3RlZCwgT2JqLnJlcHIgKCkpIGluXG4gICAgICAgIGxvb3AgYWN0aW9uIHZhbHVlXG4gICAgfCBHcm93X3N0YWNrc18xIC0+XG4gICAgICAgIGdyb3dfc3RhY2tzKCk7IGxvb3AgU3RhY2tzX2dyb3duXzEgKE9iai5yZXByICgpKVxuICAgIHwgR3Jvd19zdGFja3NfMiAtPlxuICAgICAgICBncm93X3N0YWNrcygpOyBsb29wIFN0YWNrc19ncm93bl8yIChPYmoucmVwciAoKSlcbiAgICB8IENhbGxfZXJyb3JfZnVuY3Rpb24gLT5cbiAgICAgICAgdGFibGVzLmVycm9yX2Z1bmN0aW9uIFwic3ludGF4IGVycm9yXCI7XG4gICAgICAgIGxvb3AgRXJyb3JfZGV0ZWN0ZWQgKE9iai5yZXByICgpKSBpblxuICBsZXQgaW5pdF9hc3AgPSBlbnYuYXNwXG4gIGFuZCBpbml0X3NwID0gZW52LnNwXG4gIGFuZCBpbml0X3N0YWNrYmFzZSA9IGVudi5zdGFja2Jhc2VcbiAgYW5kIGluaXRfc3RhdGUgPSBlbnYuc3RhdGVcbiAgYW5kIGluaXRfY3Vycl9jaGFyID0gZW52LmN1cnJfY2hhclxuICBhbmQgaW5pdF9sdmFsID0gZW52Lmx2YWxcbiAgYW5kIGluaXRfZXJyZmxhZyA9IGVudi5lcnJmbGFnIGluXG4gIGVudi5zdGFja2Jhc2UgPC0gZW52LnNwICsgMTtcbiAgZW52LmN1cnJfY2hhciA8LSBzdGFydDtcbiAgZW52LnN5bWJfZW5kIDwtIGxleGJ1Zi5sZXhfY3Vycl9wO1xuICB0cnlcbiAgICBsb29wIFN0YXJ0IChPYmoucmVwciAoKSlcbiAgd2l0aCBleG4gLT5cbiAgICBsZXQgY3Vycl9jaGFyID0gZW52LmN1cnJfY2hhciBpblxuICAgIGVudi5hc3AgPC0gaW5pdF9hc3A7XG4gICAgZW52LnNwIDwtIGluaXRfc3A7XG4gICAgZW52LnN0YWNrYmFzZSA8LSBpbml0X3N0YWNrYmFzZTtcbiAgICBlbnYuc3RhdGUgPC0gaW5pdF9zdGF0ZTtcbiAgICBlbnYuY3Vycl9jaGFyIDwtIGluaXRfY3Vycl9jaGFyO1xuICAgIGVudi5sdmFsIDwtIGluaXRfbHZhbDtcbiAgICBlbnYuZXJyZmxhZyA8LSBpbml0X2VycmZsYWc7XG4gICAgbWF0Y2ggZXhuIHdpdGhcbiAgICAgIFlZZXhpdCB2IC0+XG4gICAgICAgIE9iai5tYWdpYyB2XG4gICAgfCBfIC0+XG4gICAgICAgIGN1cnJlbnRfbG9va2FoZWFkX2Z1biA6PVxuICAgICAgICAgIChmdW4gdG9rIC0+XG4gICAgICAgICAgICBpZiBPYmouaXNfYmxvY2sgdG9rXG4gICAgICAgICAgICB0aGVuIHRhYmxlcy50cmFuc2xfYmxvY2suKE9iai50YWcgdG9rKSA9IGN1cnJfY2hhclxuICAgICAgICAgICAgZWxzZSB0YWJsZXMudHJhbnNsX2NvbnN0LihPYmoubWFnaWMgdG9rKSA9IGN1cnJfY2hhcik7XG4gICAgICAgIHJhaXNlIGV4blxuXG5sZXQgcGVla192YWwgZW52IG4gPVxuICBPYmoubWFnaWMgZW52LnZfc3RhY2suKGVudi5hc3AgLSBuKVxuXG5sZXQgc3ltYm9sX3N0YXJ0X3BvcyAoKSA9XG4gIGxldCByZWMgbG9vcCBpID1cbiAgICBpZiBpIDw9IDAgdGhlbiBlbnYuc3ltYl9lbmRfc3RhY2suKGVudi5hc3ApXG4gICAgZWxzZSBiZWdpblxuICAgICAgbGV0IHN0ID0gZW52LnN5bWJfc3RhcnRfc3RhY2suKGVudi5hc3AgLSBpICsgMSkgaW5cbiAgICAgIGxldCBlbiA9IGVudi5zeW1iX2VuZF9zdGFjay4oZW52LmFzcCAtIGkgKyAxKSBpblxuICAgICAgaWYgc3QgPD4gZW4gdGhlbiBzdCBlbHNlIGxvb3AgKGkgLSAxKVxuICAgIGVuZFxuICBpblxuICBsb29wIGVudi5ydWxlX2xlblxuXG5sZXQgc3ltYm9sX2VuZF9wb3MgKCkgPSBlbnYuc3ltYl9lbmRfc3RhY2suKGVudi5hc3ApXG5sZXQgcmhzX3N0YXJ0X3BvcyBuID0gZW52LnN5bWJfc3RhcnRfc3RhY2suKGVudi5hc3AgLSAoZW52LnJ1bGVfbGVuIC0gbikpXG5sZXQgcmhzX2VuZF9wb3MgbiA9IGVudi5zeW1iX2VuZF9zdGFjay4oZW52LmFzcCAtIChlbnYucnVsZV9sZW4gLSBuKSlcblxubGV0IHN5bWJvbF9zdGFydCAoKSA9IChzeW1ib2xfc3RhcnRfcG9zICgpKS5wb3NfY251bVxubGV0IHN5bWJvbF9lbmQgKCkgPSAoc3ltYm9sX2VuZF9wb3MgKCkpLnBvc19jbnVtXG5sZXQgcmhzX3N0YXJ0IG4gPSAocmhzX3N0YXJ0X3BvcyBuKS5wb3NfY251bVxubGV0IHJoc19lbmQgbiA9IChyaHNfZW5kX3BvcyBuKS5wb3NfY251bVxuXG5sZXQgaXNfY3VycmVudF9sb29rYWhlYWQgdG9rID1cbiAgKCFjdXJyZW50X2xvb2thaGVhZF9mdW4pKE9iai5yZXByIHRvaylcblxubGV0IHBhcnNlX2Vycm9yIChfIDogc3RyaW5nKSA9ICgpXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIFNldHMgb3ZlciBvcmRlcmVkIHR5cGVzICopXG5cbm1vZHVsZSB0eXBlIE9yZGVyZWRUeXBlID1cbiAgc2lnXG4gICAgdHlwZSB0XG4gICAgdmFsIGNvbXBhcmU6IHQgLT4gdCAtPiBpbnRcbiAgZW5kXG5cbm1vZHVsZSB0eXBlIFMgPVxuICBzaWdcbiAgICB0eXBlIGVsdFxuICAgIHR5cGUgdFxuICAgIHZhbCBlbXB0eTogdFxuICAgIHZhbCBpc19lbXB0eTogdCAtPiBib29sXG4gICAgdmFsIG1lbTogZWx0IC0+IHQgLT4gYm9vbFxuICAgIHZhbCBhZGQ6IGVsdCAtPiB0IC0+IHRcbiAgICB2YWwgc2luZ2xldG9uOiBlbHQgLT4gdFxuICAgIHZhbCByZW1vdmU6IGVsdCAtPiB0IC0+IHRcbiAgICB2YWwgdW5pb246IHQgLT4gdCAtPiB0XG4gICAgdmFsIGludGVyOiB0IC0+IHQgLT4gdFxuICAgIHZhbCBkaXNqb2ludDogdCAtPiB0IC0+IGJvb2xcbiAgICB2YWwgZGlmZjogdCAtPiB0IC0+IHRcbiAgICB2YWwgY29tcGFyZTogdCAtPiB0IC0+IGludFxuICAgIHZhbCBlcXVhbDogdCAtPiB0IC0+IGJvb2xcbiAgICB2YWwgc3Vic2V0OiB0IC0+IHQgLT4gYm9vbFxuICAgIHZhbCBpdGVyOiAoZWx0IC0+IHVuaXQpIC0+IHQgLT4gdW5pdFxuICAgIHZhbCBtYXA6IChlbHQgLT4gZWx0KSAtPiB0IC0+IHRcbiAgICB2YWwgZm9sZDogKGVsdCAtPiAnYSAtPiAnYSkgLT4gdCAtPiAnYSAtPiAnYVxuICAgIHZhbCBmb3JfYWxsOiAoZWx0IC0+IGJvb2wpIC0+IHQgLT4gYm9vbFxuICAgIHZhbCBleGlzdHM6IChlbHQgLT4gYm9vbCkgLT4gdCAtPiBib29sXG4gICAgdmFsIGZpbHRlcjogKGVsdCAtPiBib29sKSAtPiB0IC0+IHRcbiAgICB2YWwgZmlsdGVyX21hcDogKGVsdCAtPiBlbHQgb3B0aW9uKSAtPiB0IC0+IHRcbiAgICB2YWwgcGFydGl0aW9uOiAoZWx0IC0+IGJvb2wpIC0+IHQgLT4gdCAqIHRcbiAgICB2YWwgY2FyZGluYWw6IHQgLT4gaW50XG4gICAgdmFsIGVsZW1lbnRzOiB0IC0+IGVsdCBsaXN0XG4gICAgdmFsIG1pbl9lbHQ6IHQgLT4gZWx0XG4gICAgdmFsIG1pbl9lbHRfb3B0OiB0IC0+IGVsdCBvcHRpb25cbiAgICB2YWwgbWF4X2VsdDogdCAtPiBlbHRcbiAgICB2YWwgbWF4X2VsdF9vcHQ6IHQgLT4gZWx0IG9wdGlvblxuICAgIHZhbCBjaG9vc2U6IHQgLT4gZWx0XG4gICAgdmFsIGNob29zZV9vcHQ6IHQgLT4gZWx0IG9wdGlvblxuICAgIHZhbCBzcGxpdDogZWx0IC0+IHQgLT4gdCAqIGJvb2wgKiB0XG4gICAgdmFsIGZpbmQ6IGVsdCAtPiB0IC0+IGVsdFxuICAgIHZhbCBmaW5kX29wdDogZWx0IC0+IHQgLT4gZWx0IG9wdGlvblxuICAgIHZhbCBmaW5kX2ZpcnN0OiAoZWx0IC0+IGJvb2wpIC0+IHQgLT4gZWx0XG4gICAgdmFsIGZpbmRfZmlyc3Rfb3B0OiAoZWx0IC0+IGJvb2wpIC0+IHQgLT4gZWx0IG9wdGlvblxuICAgIHZhbCBmaW5kX2xhc3Q6IChlbHQgLT4gYm9vbCkgLT4gdCAtPiBlbHRcbiAgICB2YWwgZmluZF9sYXN0X29wdDogKGVsdCAtPiBib29sKSAtPiB0IC0+IGVsdCBvcHRpb25cbiAgICB2YWwgb2ZfbGlzdDogZWx0IGxpc3QgLT4gdFxuICAgIHZhbCB0b19zZXFfZnJvbSA6IGVsdCAtPiB0IC0+IGVsdCBTZXEudFxuICAgIHZhbCB0b19zZXEgOiB0IC0+IGVsdCBTZXEudFxuICAgIHZhbCB0b19yZXZfc2VxIDogdCAtPiBlbHQgU2VxLnRcbiAgICB2YWwgYWRkX3NlcSA6IGVsdCBTZXEudCAtPiB0IC0+IHRcbiAgICB2YWwgb2Zfc2VxIDogZWx0IFNlcS50IC0+IHRcbiAgZW5kXG5cbm1vZHVsZSBNYWtlKE9yZDogT3JkZXJlZFR5cGUpID1cbiAgc3RydWN0XG4gICAgdHlwZSBlbHQgPSBPcmQudFxuICAgIHR5cGUgdCA9IEVtcHR5IHwgTm9kZSBvZiB7bDp0OyB2OmVsdDsgcjp0OyBoOmludH1cblxuICAgICgqIFNldHMgYXJlIHJlcHJlc2VudGVkIGJ5IGJhbGFuY2VkIGJpbmFyeSB0cmVlcyAodGhlIGhlaWdodHMgb2YgdGhlXG4gICAgICAgY2hpbGRyZW4gZGlmZmVyIGJ5IGF0IG1vc3QgMiAqKVxuXG4gICAgbGV0IGhlaWdodCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IDBcbiAgICAgIHwgTm9kZSB7aH0gLT4gaFxuXG4gICAgKCogQ3JlYXRlcyBhIG5ldyBub2RlIHdpdGggbGVmdCBzb24gbCwgdmFsdWUgdiBhbmQgcmlnaHQgc29uIHIuXG4gICAgICAgV2UgbXVzdCBoYXZlIGFsbCBlbGVtZW50cyBvZiBsIDwgdiA8IGFsbCBlbGVtZW50cyBvZiByLlxuICAgICAgIGwgYW5kIHIgbXVzdCBiZSBiYWxhbmNlZCBhbmQgfCBoZWlnaHQgbCAtIGhlaWdodCByIHwgPD0gMi5cbiAgICAgICBJbmxpbmUgZXhwYW5zaW9uIG9mIGhlaWdodCBmb3IgYmV0dGVyIHNwZWVkLiAqKVxuXG4gICAgbGV0IGNyZWF0ZSBsIHYgciA9XG4gICAgICBsZXQgaGwgPSBtYXRjaCBsIHdpdGggRW1wdHkgLT4gMCB8IE5vZGUge2h9IC0+IGggaW5cbiAgICAgIGxldCBociA9IG1hdGNoIHIgd2l0aCBFbXB0eSAtPiAwIHwgTm9kZSB7aH0gLT4gaCBpblxuICAgICAgTm9kZXtsOyB2OyByOyBoPShpZiBobCA+PSBociB0aGVuIGhsICsgMSBlbHNlIGhyICsgMSl9XG5cbiAgICAoKiBTYW1lIGFzIGNyZWF0ZSwgYnV0IHBlcmZvcm1zIG9uZSBzdGVwIG9mIHJlYmFsYW5jaW5nIGlmIG5lY2Vzc2FyeS5cbiAgICAgICBBc3N1bWVzIGwgYW5kIHIgYmFsYW5jZWQgYW5kIHwgaGVpZ2h0IGwgLSBoZWlnaHQgciB8IDw9IDMuXG4gICAgICAgSW5saW5lIGV4cGFuc2lvbiBvZiBjcmVhdGUgZm9yIGJldHRlciBzcGVlZCBpbiB0aGUgbW9zdCBmcmVxdWVudCBjYXNlXG4gICAgICAgd2hlcmUgbm8gcmViYWxhbmNpbmcgaXMgcmVxdWlyZWQuICopXG5cbiAgICBsZXQgYmFsIGwgdiByID1cbiAgICAgIGxldCBobCA9IG1hdGNoIGwgd2l0aCBFbXB0eSAtPiAwIHwgTm9kZSB7aH0gLT4gaCBpblxuICAgICAgbGV0IGhyID0gbWF0Y2ggciB3aXRoIEVtcHR5IC0+IDAgfCBOb2RlIHtofSAtPiBoIGluXG4gICAgICBpZiBobCA+IGhyICsgMiB0aGVuIGJlZ2luXG4gICAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgICAgIEVtcHR5IC0+IGludmFsaWRfYXJnIFwiU2V0LmJhbFwiXG4gICAgICAgIHwgTm9kZXtsPWxsOyB2PWx2OyByPWxyfSAtPlxuICAgICAgICAgICAgaWYgaGVpZ2h0IGxsID49IGhlaWdodCBsciB0aGVuXG4gICAgICAgICAgICAgIGNyZWF0ZSBsbCBsdiAoY3JlYXRlIGxyIHYgcilcbiAgICAgICAgICAgIGVsc2UgYmVnaW5cbiAgICAgICAgICAgICAgbWF0Y2ggbHIgd2l0aFxuICAgICAgICAgICAgICAgIEVtcHR5IC0+IGludmFsaWRfYXJnIFwiU2V0LmJhbFwiXG4gICAgICAgICAgICAgIHwgTm9kZXtsPWxybDsgdj1scnY7IHI9bHJyfS0+XG4gICAgICAgICAgICAgICAgICBjcmVhdGUgKGNyZWF0ZSBsbCBsdiBscmwpIGxydiAoY3JlYXRlIGxyciB2IHIpXG4gICAgICAgICAgICBlbmRcbiAgICAgIGVuZCBlbHNlIGlmIGhyID4gaGwgKyAyIHRoZW4gYmVnaW5cbiAgICAgICAgbWF0Y2ggciB3aXRoXG4gICAgICAgICAgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJTZXQuYmFsXCJcbiAgICAgICAgfCBOb2Rle2w9cmw7IHY9cnY7IHI9cnJ9IC0+XG4gICAgICAgICAgICBpZiBoZWlnaHQgcnIgPj0gaGVpZ2h0IHJsIHRoZW5cbiAgICAgICAgICAgICAgY3JlYXRlIChjcmVhdGUgbCB2IHJsKSBydiByclxuICAgICAgICAgICAgZWxzZSBiZWdpblxuICAgICAgICAgICAgICBtYXRjaCBybCB3aXRoXG4gICAgICAgICAgICAgICAgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJTZXQuYmFsXCJcbiAgICAgICAgICAgICAgfCBOb2Rle2w9cmxsOyB2PXJsdjsgcj1ybHJ9IC0+XG4gICAgICAgICAgICAgICAgICBjcmVhdGUgKGNyZWF0ZSBsIHYgcmxsKSBybHYgKGNyZWF0ZSBybHIgcnYgcnIpXG4gICAgICAgICAgICBlbmRcbiAgICAgIGVuZCBlbHNlXG4gICAgICAgIE5vZGV7bDsgdjsgcjsgaD0oaWYgaGwgPj0gaHIgdGhlbiBobCArIDEgZWxzZSBociArIDEpfVxuXG4gICAgKCogSW5zZXJ0aW9uIG9mIG9uZSBlbGVtZW50ICopXG5cbiAgICBsZXQgcmVjIGFkZCB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gTm9kZXtsPUVtcHR5OyB2PXg7IHI9RW1wdHk7IGg9MX1cbiAgICAgIHwgTm9kZXtsOyB2OyByfSBhcyB0IC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuIHQgZWxzZVxuICAgICAgICAgIGlmIGMgPCAwIHRoZW5cbiAgICAgICAgICAgIGxldCBsbCA9IGFkZCB4IGwgaW5cbiAgICAgICAgICAgIGlmIGwgPT0gbGwgdGhlbiB0IGVsc2UgYmFsIGxsIHYgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxldCByciA9IGFkZCB4IHIgaW5cbiAgICAgICAgICAgIGlmIHIgPT0gcnIgdGhlbiB0IGVsc2UgYmFsIGwgdiByclxuXG4gICAgbGV0IHNpbmdsZXRvbiB4ID0gTm9kZXtsPUVtcHR5OyB2PXg7IHI9RW1wdHk7IGg9MX1cblxuICAgICgqIEJld2FyZTogdGhvc2UgdHdvIGZ1bmN0aW9ucyBhc3N1bWUgdGhhdCB0aGUgYWRkZWQgdiBpcyAqc3RyaWN0bHkqXG4gICAgICAgc21hbGxlciAob3IgYmlnZ2VyKSB0aGFuIGFsbCB0aGUgcHJlc2VudCBlbGVtZW50cyBpbiB0aGUgdHJlZTsgaXRcbiAgICAgICBkb2VzIG5vdCB0ZXN0IGZvciBlcXVhbGl0eSB3aXRoIHRoZSBjdXJyZW50IG1pbiAob3IgbWF4KSBlbGVtZW50LlxuICAgICAgIEluZGVlZCwgdGhleSBhcmUgb25seSB1c2VkIGR1cmluZyB0aGUgXCJqb2luXCIgb3BlcmF0aW9uIHdoaWNoXG4gICAgICAgcmVzcGVjdHMgdGhpcyBwcmVjb25kaXRpb24uXG4gICAgKilcblxuICAgIGxldCByZWMgYWRkX21pbl9lbGVtZW50IHggPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiBzaW5nbGV0b24geFxuICAgICAgfCBOb2RlIHtsOyB2OyByfSAtPlxuICAgICAgICBiYWwgKGFkZF9taW5fZWxlbWVudCB4IGwpIHYgclxuXG4gICAgbGV0IHJlYyBhZGRfbWF4X2VsZW1lbnQgeCA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+IHNpbmdsZXRvbiB4XG4gICAgICB8IE5vZGUge2w7IHY7IHJ9IC0+XG4gICAgICAgIGJhbCBsIHYgKGFkZF9tYXhfZWxlbWVudCB4IHIpXG5cbiAgICAoKiBTYW1lIGFzIGNyZWF0ZSBhbmQgYmFsLCBidXQgbm8gYXNzdW1wdGlvbnMgYXJlIG1hZGUgb24gdGhlXG4gICAgICAgcmVsYXRpdmUgaGVpZ2h0cyBvZiBsIGFuZCByLiAqKVxuXG4gICAgbGV0IHJlYyBqb2luIGwgdiByID1cbiAgICAgIG1hdGNoIChsLCByKSB3aXRoXG4gICAgICAgIChFbXB0eSwgXykgLT4gYWRkX21pbl9lbGVtZW50IHYgclxuICAgICAgfCAoXywgRW1wdHkpIC0+IGFkZF9tYXhfZWxlbWVudCB2IGxcbiAgICAgIHwgKE5vZGV7bD1sbDsgdj1sdjsgcj1scjsgaD1saH0sIE5vZGV7bD1ybDsgdj1ydjsgcj1ycjsgaD1yaH0pIC0+XG4gICAgICAgICAgaWYgbGggPiByaCArIDIgdGhlbiBiYWwgbGwgbHYgKGpvaW4gbHIgdiByKSBlbHNlXG4gICAgICAgICAgaWYgcmggPiBsaCArIDIgdGhlbiBiYWwgKGpvaW4gbCB2IHJsKSBydiByciBlbHNlXG4gICAgICAgICAgY3JlYXRlIGwgdiByXG5cbiAgICAoKiBTbWFsbGVzdCBhbmQgZ3JlYXRlc3QgZWxlbWVudCBvZiBhIHNldCAqKVxuXG4gICAgbGV0IHJlYyBtaW5fZWx0ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IE5vZGV7bD1FbXB0eTsgdn0gLT4gdlxuICAgICAgfCBOb2Rle2x9IC0+IG1pbl9lbHQgbFxuXG4gICAgbGV0IHJlYyBtaW5fZWx0X29wdCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IE5vbmVcbiAgICAgIHwgTm9kZXtsPUVtcHR5OyB2fSAtPiBTb21lIHZcbiAgICAgIHwgTm9kZXtsfSAtPiBtaW5fZWx0X29wdCBsXG5cbiAgICBsZXQgcmVjIG1heF9lbHQgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgTm9kZXt2OyByPUVtcHR5fSAtPiB2XG4gICAgICB8IE5vZGV7cn0gLT4gbWF4X2VsdCByXG5cbiAgICBsZXQgcmVjIG1heF9lbHRfb3B0ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gTm9uZVxuICAgICAgfCBOb2Rle3Y7IHI9RW1wdHl9IC0+IFNvbWUgdlxuICAgICAgfCBOb2Rle3J9IC0+IG1heF9lbHRfb3B0IHJcblxuICAgICgqIFJlbW92ZSB0aGUgc21hbGxlc3QgZWxlbWVudCBvZiB0aGUgZ2l2ZW4gc2V0ICopXG5cbiAgICBsZXQgcmVjIHJlbW92ZV9taW5fZWx0ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJTZXQucmVtb3ZlX21pbl9lbHRcIlxuICAgICAgfCBOb2Rle2w9RW1wdHk7IHJ9IC0+IHJcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPiBiYWwgKHJlbW92ZV9taW5fZWx0IGwpIHYgclxuXG4gICAgKCogTWVyZ2UgdHdvIHRyZWVzIGwgYW5kIHIgaW50byBvbmUuXG4gICAgICAgQWxsIGVsZW1lbnRzIG9mIGwgbXVzdCBwcmVjZWRlIHRoZSBlbGVtZW50cyBvZiByLlxuICAgICAgIEFzc3VtZSB8IGhlaWdodCBsIC0gaGVpZ2h0IHIgfCA8PSAyLiAqKVxuXG4gICAgbGV0IG1lcmdlIHQxIHQyID1cbiAgICAgIG1hdGNoICh0MSwgdDIpIHdpdGhcbiAgICAgICAgKEVtcHR5LCB0KSAtPiB0XG4gICAgICB8ICh0LCBFbXB0eSkgLT4gdFxuICAgICAgfCAoXywgXykgLT4gYmFsIHQxIChtaW5fZWx0IHQyKSAocmVtb3ZlX21pbl9lbHQgdDIpXG5cbiAgICAoKiBNZXJnZSB0d28gdHJlZXMgbCBhbmQgciBpbnRvIG9uZS5cbiAgICAgICBBbGwgZWxlbWVudHMgb2YgbCBtdXN0IHByZWNlZGUgdGhlIGVsZW1lbnRzIG9mIHIuXG4gICAgICAgTm8gYXNzdW1wdGlvbiBvbiB0aGUgaGVpZ2h0cyBvZiBsIGFuZCByLiAqKVxuXG4gICAgbGV0IGNvbmNhdCB0MSB0MiA9XG4gICAgICBtYXRjaCAodDEsIHQyKSB3aXRoXG4gICAgICAgIChFbXB0eSwgdCkgLT4gdFxuICAgICAgfCAodCwgRW1wdHkpIC0+IHRcbiAgICAgIHwgKF8sIF8pIC0+IGpvaW4gdDEgKG1pbl9lbHQgdDIpIChyZW1vdmVfbWluX2VsdCB0MilcblxuICAgICgqIFNwbGl0dGluZy4gIHNwbGl0IHggcyByZXR1cm5zIGEgdHJpcGxlIChsLCBwcmVzZW50LCByKSB3aGVyZVxuICAgICAgICAtIGwgaXMgdGhlIHNldCBvZiBlbGVtZW50cyBvZiBzIHRoYXQgYXJlIDwgeFxuICAgICAgICAtIHIgaXMgdGhlIHNldCBvZiBlbGVtZW50cyBvZiBzIHRoYXQgYXJlID4geFxuICAgICAgICAtIHByZXNlbnQgaXMgZmFsc2UgaWYgcyBjb250YWlucyBubyBlbGVtZW50IGVxdWFsIHRvIHgsXG4gICAgICAgICAgb3IgdHJ1ZSBpZiBzIGNvbnRhaW5zIGFuIGVsZW1lbnQgZXF1YWwgdG8geC4gKilcblxuICAgIGxldCByZWMgc3BsaXQgeCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgKEVtcHR5LCBmYWxzZSwgRW1wdHkpXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gKGwsIHRydWUsIHIpXG4gICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuXG4gICAgICAgICAgICBsZXQgKGxsLCBwcmVzLCBybCkgPSBzcGxpdCB4IGwgaW4gKGxsLCBwcmVzLCBqb2luIHJsIHYgcilcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsZXQgKGxyLCBwcmVzLCBycikgPSBzcGxpdCB4IHIgaW4gKGpvaW4gbCB2IGxyLCBwcmVzLCBycilcblxuICAgICgqIEltcGxlbWVudGF0aW9uIG9mIHRoZSBzZXQgb3BlcmF0aW9ucyAqKVxuXG4gICAgbGV0IGVtcHR5ID0gRW1wdHlcblxuICAgIGxldCBpc19lbXB0eSA9IGZ1bmN0aW9uIEVtcHR5IC0+IHRydWUgfCBfIC0+IGZhbHNlXG5cbiAgICBsZXQgcmVjIG1lbSB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gZmFsc2VcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgYyA9IDAgfHwgbWVtIHggKGlmIGMgPCAwIHRoZW4gbCBlbHNlIHIpXG5cbiAgICBsZXQgcmVjIHJlbW92ZSB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gRW1wdHlcbiAgICAgIHwgKE5vZGV7bDsgdjsgcn0gYXMgdCkgLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gbWVyZ2UgbCByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgaWYgYyA8IDAgdGhlblxuICAgICAgICAgICAgICBsZXQgbGwgPSByZW1vdmUgeCBsIGluXG4gICAgICAgICAgICAgIGlmIGwgPT0gbGwgdGhlbiB0XG4gICAgICAgICAgICAgIGVsc2UgYmFsIGxsIHYgclxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBsZXQgcnIgPSByZW1vdmUgeCByIGluXG4gICAgICAgICAgICAgIGlmIHIgPT0gcnIgdGhlbiB0XG4gICAgICAgICAgICAgIGVsc2UgYmFsIGwgdiByclxuXG4gICAgbGV0IHJlYyB1bmlvbiBzMSBzMiA9XG4gICAgICBtYXRjaCAoczEsIHMyKSB3aXRoXG4gICAgICAgIChFbXB0eSwgdDIpIC0+IHQyXG4gICAgICB8ICh0MSwgRW1wdHkpIC0+IHQxXG4gICAgICB8IChOb2Rle2w9bDE7IHY9djE7IHI9cjE7IGg9aDF9LCBOb2Rle2w9bDI7IHY9djI7IHI9cjI7IGg9aDJ9KSAtPlxuICAgICAgICAgIGlmIGgxID49IGgyIHRoZW5cbiAgICAgICAgICAgIGlmIGgyID0gMSB0aGVuIGFkZCB2MiBzMSBlbHNlIGJlZ2luXG4gICAgICAgICAgICAgIGxldCAobDIsIF8sIHIyKSA9IHNwbGl0IHYxIHMyIGluXG4gICAgICAgICAgICAgIGpvaW4gKHVuaW9uIGwxIGwyKSB2MSAodW5pb24gcjEgcjIpXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBpZiBoMSA9IDEgdGhlbiBhZGQgdjEgczIgZWxzZSBiZWdpblxuICAgICAgICAgICAgICBsZXQgKGwxLCBfLCByMSkgPSBzcGxpdCB2MiBzMSBpblxuICAgICAgICAgICAgICBqb2luICh1bmlvbiBsMSBsMikgdjIgKHVuaW9uIHIxIHIyKVxuICAgICAgICAgICAgZW5kXG5cbiAgICBsZXQgcmVjIGludGVyIHMxIHMyID1cbiAgICAgIG1hdGNoIChzMSwgczIpIHdpdGhcbiAgICAgICAgKEVtcHR5LCBfKSAtPiBFbXB0eVxuICAgICAgfCAoXywgRW1wdHkpIC0+IEVtcHR5XG4gICAgICB8IChOb2Rle2w9bDE7IHY9djE7IHI9cjF9LCB0MikgLT5cbiAgICAgICAgICBtYXRjaCBzcGxpdCB2MSB0MiB3aXRoXG4gICAgICAgICAgICAobDIsIGZhbHNlLCByMikgLT5cbiAgICAgICAgICAgICAgY29uY2F0IChpbnRlciBsMSBsMikgKGludGVyIHIxIHIyKVxuICAgICAgICAgIHwgKGwyLCB0cnVlLCByMikgLT5cbiAgICAgICAgICAgICAgam9pbiAoaW50ZXIgbDEgbDIpIHYxIChpbnRlciByMSByMilcblxuICAgICgqIFNhbWUgYXMgc3BsaXQsIGJ1dCBjb21wdXRlIHRoZSBsZWZ0IGFuZCByaWdodCBzdWJ0cmVlc1xuICAgICAgIG9ubHkgaWYgdGhlIHBpdm90IGVsZW1lbnQgaXMgbm90IGluIHRoZSBzZXQuICBUaGUgcmlnaHQgc3VidHJlZVxuICAgICAgIGlzIGNvbXB1dGVkIG9uIGRlbWFuZC4gKilcblxuICAgIHR5cGUgc3BsaXRfYmlzID1cbiAgICAgIHwgRm91bmRcbiAgICAgIHwgTm90Rm91bmQgb2YgdCAqICh1bml0IC0+IHQpXG5cbiAgICBsZXQgcmVjIHNwbGl0X2JpcyB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBOb3RGb3VuZCAoRW1wdHksIChmdW4gKCkgLT4gRW1wdHkpKVxuICAgICAgfCBOb2Rle2w7IHY7IHI7IF99IC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuIEZvdW5kXG4gICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuXG4gICAgICAgICAgICBtYXRjaCBzcGxpdF9iaXMgeCBsIHdpdGhcbiAgICAgICAgICAgIHwgRm91bmQgLT4gRm91bmRcbiAgICAgICAgICAgIHwgTm90Rm91bmQgKGxsLCBybCkgLT4gTm90Rm91bmQgKGxsLCAoZnVuICgpIC0+IGpvaW4gKHJsICgpKSB2IHIpKVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIG1hdGNoIHNwbGl0X2JpcyB4IHIgd2l0aFxuICAgICAgICAgICAgfCBGb3VuZCAtPiBGb3VuZFxuICAgICAgICAgICAgfCBOb3RGb3VuZCAobHIsIHJyKSAtPiBOb3RGb3VuZCAoam9pbiBsIHYgbHIsIHJyKVxuXG4gICAgbGV0IHJlYyBkaXNqb2ludCBzMSBzMiA9XG4gICAgICBtYXRjaCAoczEsIHMyKSB3aXRoXG4gICAgICAgIChFbXB0eSwgXykgfCAoXywgRW1wdHkpIC0+IHRydWVcbiAgICAgIHwgKE5vZGV7bD1sMTsgdj12MTsgcj1yMX0sIHQyKSAtPlxuICAgICAgICAgIGlmIHMxID09IHMyIHRoZW4gZmFsc2VcbiAgICAgICAgICBlbHNlIG1hdGNoIHNwbGl0X2JpcyB2MSB0MiB3aXRoXG4gICAgICAgICAgICAgIE5vdEZvdW5kKGwyLCByMikgLT4gZGlzam9pbnQgbDEgbDIgJiYgZGlzam9pbnQgcjEgKHIyICgpKVxuICAgICAgICAgICAgfCBGb3VuZCAtPiBmYWxzZVxuXG4gICAgbGV0IHJlYyBkaWZmIHMxIHMyID1cbiAgICAgIG1hdGNoIChzMSwgczIpIHdpdGhcbiAgICAgICAgKEVtcHR5LCBfKSAtPiBFbXB0eVxuICAgICAgfCAodDEsIEVtcHR5KSAtPiB0MVxuICAgICAgfCAoTm9kZXtsPWwxOyB2PXYxOyByPXIxfSwgdDIpIC0+XG4gICAgICAgICAgbWF0Y2ggc3BsaXQgdjEgdDIgd2l0aFxuICAgICAgICAgICAgKGwyLCBmYWxzZSwgcjIpIC0+XG4gICAgICAgICAgICAgIGpvaW4gKGRpZmYgbDEgbDIpIHYxIChkaWZmIHIxIHIyKVxuICAgICAgICAgIHwgKGwyLCB0cnVlLCByMikgLT5cbiAgICAgICAgICAgICAgY29uY2F0IChkaWZmIGwxIGwyKSAoZGlmZiByMSByMilcblxuICAgIHR5cGUgZW51bWVyYXRpb24gPSBFbmQgfCBNb3JlIG9mIGVsdCAqIHQgKiBlbnVtZXJhdGlvblxuXG4gICAgbGV0IHJlYyBjb25zX2VudW0gcyBlID1cbiAgICAgIG1hdGNoIHMgd2l0aFxuICAgICAgICBFbXB0eSAtPiBlXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT4gY29uc19lbnVtIGwgKE1vcmUodiwgciwgZSkpXG5cbiAgICBsZXQgcmVjIGNvbXBhcmVfYXV4IGUxIGUyID1cbiAgICAgICAgbWF0Y2ggKGUxLCBlMikgd2l0aFxuICAgICAgICAoRW5kLCBFbmQpIC0+IDBcbiAgICAgIHwgKEVuZCwgXykgIC0+IC0xXG4gICAgICB8IChfLCBFbmQpIC0+IDFcbiAgICAgIHwgKE1vcmUodjEsIHIxLCBlMSksIE1vcmUodjIsIHIyLCBlMikpIC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB2MSB2MiBpblxuICAgICAgICAgIGlmIGMgPD4gMFxuICAgICAgICAgIHRoZW4gY1xuICAgICAgICAgIGVsc2UgY29tcGFyZV9hdXggKGNvbnNfZW51bSByMSBlMSkgKGNvbnNfZW51bSByMiBlMilcblxuICAgIGxldCBjb21wYXJlIHMxIHMyID1cbiAgICAgIGNvbXBhcmVfYXV4IChjb25zX2VudW0gczEgRW5kKSAoY29uc19lbnVtIHMyIEVuZClcblxuICAgIGxldCBlcXVhbCBzMSBzMiA9XG4gICAgICBjb21wYXJlIHMxIHMyID0gMFxuXG4gICAgbGV0IHJlYyBzdWJzZXQgczEgczIgPVxuICAgICAgbWF0Y2ggKHMxLCBzMikgd2l0aFxuICAgICAgICBFbXB0eSwgXyAtPlxuICAgICAgICAgIHRydWVcbiAgICAgIHwgXywgRW1wdHkgLT5cbiAgICAgICAgICBmYWxzZVxuICAgICAgfCBOb2RlIHtsPWwxOyB2PXYxOyByPXIxfSwgKE5vZGUge2w9bDI7IHY9djI7IHI9cjJ9IGFzIHQyKSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgdjEgdjIgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuXG4gICAgICAgICAgICBzdWJzZXQgbDEgbDIgJiYgc3Vic2V0IHIxIHIyXG4gICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuXG4gICAgICAgICAgICBzdWJzZXQgKE5vZGUge2w9bDE7IHY9djE7IHI9RW1wdHk7IGg9MH0pIGwyICYmIHN1YnNldCByMSB0MlxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHN1YnNldCAoTm9kZSB7bD1FbXB0eTsgdj12MTsgcj1yMTsgaD0wfSkgcjIgJiYgc3Vic2V0IGwxIHQyXG5cbiAgICBsZXQgcmVjIGl0ZXIgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+ICgpXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT4gaXRlciBmIGw7IGYgdjsgaXRlciBmIHJcblxuICAgIGxldCByZWMgZm9sZCBmIHMgYWNjdSA9XG4gICAgICBtYXRjaCBzIHdpdGhcbiAgICAgICAgRW1wdHkgLT4gYWNjdVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+IGZvbGQgZiByIChmIHYgKGZvbGQgZiBsIGFjY3UpKVxuXG4gICAgbGV0IHJlYyBmb3JfYWxsIHAgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiB0cnVlXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT4gcCB2ICYmIGZvcl9hbGwgcCBsICYmIGZvcl9hbGwgcCByXG5cbiAgICBsZXQgcmVjIGV4aXN0cyBwID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gZmFsc2VcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPiBwIHYgfHwgZXhpc3RzIHAgbCB8fCBleGlzdHMgcCByXG5cbiAgICBsZXQgcmVjIGZpbHRlciBwID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gRW1wdHlcbiAgICAgIHwgKE5vZGV7bDsgdjsgcn0pIGFzIHQgLT5cbiAgICAgICAgICAoKiBjYWxsIFtwXSBpbiB0aGUgZXhwZWN0ZWQgbGVmdC10by1yaWdodCBvcmRlciAqKVxuICAgICAgICAgIGxldCBsJyA9IGZpbHRlciBwIGwgaW5cbiAgICAgICAgICBsZXQgcHYgPSBwIHYgaW5cbiAgICAgICAgICBsZXQgcicgPSBmaWx0ZXIgcCByIGluXG4gICAgICAgICAgaWYgcHYgdGhlblxuICAgICAgICAgICAgaWYgbD09bCcgJiYgcj09cicgdGhlbiB0IGVsc2Ugam9pbiBsJyB2IHInXG4gICAgICAgICAgZWxzZSBjb25jYXQgbCcgcidcblxuICAgIGxldCByZWMgcGFydGl0aW9uIHAgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiAoRW1wdHksIEVtcHR5KVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgKCogY2FsbCBbcF0gaW4gdGhlIGV4cGVjdGVkIGxlZnQtdG8tcmlnaHQgb3JkZXIgKilcbiAgICAgICAgICBsZXQgKGx0LCBsZikgPSBwYXJ0aXRpb24gcCBsIGluXG4gICAgICAgICAgbGV0IHB2ID0gcCB2IGluXG4gICAgICAgICAgbGV0IChydCwgcmYpID0gcGFydGl0aW9uIHAgciBpblxuICAgICAgICAgIGlmIHB2XG4gICAgICAgICAgdGhlbiAoam9pbiBsdCB2IHJ0LCBjb25jYXQgbGYgcmYpXG4gICAgICAgICAgZWxzZSAoY29uY2F0IGx0IHJ0LCBqb2luIGxmIHYgcmYpXG5cbiAgICBsZXQgcmVjIGNhcmRpbmFsID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gMFxuICAgICAgfCBOb2Rle2w7IHJ9IC0+IGNhcmRpbmFsIGwgKyAxICsgY2FyZGluYWwgclxuXG4gICAgbGV0IHJlYyBlbGVtZW50c19hdXggYWNjdSA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IGFjY3VcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPiBlbGVtZW50c19hdXggKHYgOjogZWxlbWVudHNfYXV4IGFjY3UgcikgbFxuXG4gICAgbGV0IGVsZW1lbnRzIHMgPVxuICAgICAgZWxlbWVudHNfYXV4IFtdIHNcblxuICAgIGxldCBjaG9vc2UgPSBtaW5fZWx0XG5cbiAgICBsZXQgY2hvb3NlX29wdCA9IG1pbl9lbHRfb3B0XG5cbiAgICBsZXQgcmVjIGZpbmQgeCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuIHZcbiAgICAgICAgICBlbHNlIGZpbmQgeCAoaWYgYyA8IDAgdGhlbiBsIGVsc2UgcilcblxuICAgIGxldCByZWMgZmluZF9maXJzdF9hdXggdjAgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgdjBcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X2F1eCB2IGYgbFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfZmlyc3RfYXV4IHYwIGYgclxuXG4gICAgbGV0IHJlYyBmaW5kX2ZpcnN0IGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfZmlyc3RfYXV4IHYgZiBsXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9maXJzdCBmIHJcblxuICAgIGxldCByZWMgZmluZF9maXJzdF9vcHRfYXV4IHYwIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIFNvbWUgdjBcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X29wdF9hdXggdiBmIGxcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X29wdF9hdXggdjAgZiByXG5cbiAgICBsZXQgcmVjIGZpbmRfZmlyc3Rfb3B0IGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIE5vbmVcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X29wdF9hdXggdiBmIGxcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X29wdCBmIHJcblxuICAgIGxldCByZWMgZmluZF9sYXN0X2F1eCB2MCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICB2MFxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfbGFzdF9hdXggdiBmIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2xhc3RfYXV4IHYwIGYgbFxuXG4gICAgbGV0IHJlYyBmaW5kX2xhc3QgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9sYXN0X2F1eCB2IGYgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfbGFzdCBmIGxcblxuICAgIGxldCByZWMgZmluZF9sYXN0X29wdF9hdXggdjAgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgU29tZSB2MFxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfbGFzdF9vcHRfYXV4IHYgZiByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9sYXN0X29wdF9hdXggdjAgZiBsXG5cbiAgICBsZXQgcmVjIGZpbmRfbGFzdF9vcHQgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgTm9uZVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfbGFzdF9vcHRfYXV4IHYgZiByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9sYXN0X29wdCBmIGxcblxuICAgIGxldCByZWMgZmluZF9vcHQgeCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IE5vbmVcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiBTb21lIHZcbiAgICAgICAgICBlbHNlIGZpbmRfb3B0IHggKGlmIGMgPCAwIHRoZW4gbCBlbHNlIHIpXG5cbiAgICBsZXQgdHJ5X2pvaW4gbCB2IHIgPVxuICAgICAgKCogW2pvaW4gbCB2IHJdIGNhbiBvbmx5IGJlIGNhbGxlZCB3aGVuIChlbGVtZW50cyBvZiBsIDwgdiA8XG4gICAgICAgICBlbGVtZW50cyBvZiByKTsgdXNlIFt0cnlfam9pbiBsIHYgcl0gd2hlbiB0aGlzIHByb3BlcnR5IG1heVxuICAgICAgICAgbm90IGhvbGQsIGJ1dCB5b3UgaG9wZSBpdCBkb2VzIGhvbGQgaW4gdGhlIGNvbW1vbiBjYXNlICopXG4gICAgICBpZiAobCA9IEVtcHR5IHx8IE9yZC5jb21wYXJlIChtYXhfZWx0IGwpIHYgPCAwKVxuICAgICAgJiYgKHIgPSBFbXB0eSB8fCBPcmQuY29tcGFyZSB2IChtaW5fZWx0IHIpIDwgMClcbiAgICAgIHRoZW4gam9pbiBsIHYgclxuICAgICAgZWxzZSB1bmlvbiBsIChhZGQgdiByKVxuXG4gICAgbGV0IHJlYyBtYXAgZiA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+IEVtcHR5XG4gICAgICB8IE5vZGV7bDsgdjsgcn0gYXMgdCAtPlxuICAgICAgICAgKCogZW5mb3JjZSBsZWZ0LXRvLXJpZ2h0IGV2YWx1YXRpb24gb3JkZXIgKilcbiAgICAgICAgIGxldCBsJyA9IG1hcCBmIGwgaW5cbiAgICAgICAgIGxldCB2JyA9IGYgdiBpblxuICAgICAgICAgbGV0IHInID0gbWFwIGYgciBpblxuICAgICAgICAgaWYgbCA9PSBsJyAmJiB2ID09IHYnICYmIHIgPT0gcicgdGhlbiB0XG4gICAgICAgICBlbHNlIHRyeV9qb2luIGwnIHYnIHInXG5cbiAgICBsZXQgdHJ5X2NvbmNhdCB0MSB0MiA9XG4gICAgICBtYXRjaCAodDEsIHQyKSB3aXRoXG4gICAgICAgIChFbXB0eSwgdCkgLT4gdFxuICAgICAgfCAodCwgRW1wdHkpIC0+IHRcbiAgICAgIHwgKF8sIF8pIC0+IHRyeV9qb2luIHQxIChtaW5fZWx0IHQyKSAocmVtb3ZlX21pbl9lbHQgdDIpXG5cbiAgICBsZXQgcmVjIGZpbHRlcl9tYXAgZiA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+IEVtcHR5XG4gICAgICB8IE5vZGV7bDsgdjsgcn0gYXMgdCAtPlxuICAgICAgICAgKCogZW5mb3JjZSBsZWZ0LXRvLXJpZ2h0IGV2YWx1YXRpb24gb3JkZXIgKilcbiAgICAgICAgIGxldCBsJyA9IGZpbHRlcl9tYXAgZiBsIGluXG4gICAgICAgICBsZXQgdicgPSBmIHYgaW5cbiAgICAgICAgIGxldCByJyA9IGZpbHRlcl9tYXAgZiByIGluXG4gICAgICAgICBiZWdpbiBtYXRjaCB2JyB3aXRoXG4gICAgICAgICAgIHwgU29tZSB2JyAtPlxuICAgICAgICAgICAgICBpZiBsID09IGwnICYmIHYgPT0gdicgJiYgciA9PSByJyB0aGVuIHRcbiAgICAgICAgICAgICAgZWxzZSB0cnlfam9pbiBsJyB2JyByJ1xuICAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgICAgdHJ5X2NvbmNhdCBsJyByJ1xuICAgICAgICAgZW5kXG5cbiAgICBsZXQgb2Zfc29ydGVkX2xpc3QgbCA9XG4gICAgICBsZXQgcmVjIHN1YiBuIGwgPVxuICAgICAgICBtYXRjaCBuLCBsIHdpdGhcbiAgICAgICAgfCAwLCBsIC0+IEVtcHR5LCBsXG4gICAgICAgIHwgMSwgeDAgOjogbCAtPiBOb2RlIHtsPUVtcHR5OyB2PXgwOyByPUVtcHR5OyBoPTF9LCBsXG4gICAgICAgIHwgMiwgeDAgOjogeDEgOjogbCAtPlxuICAgICAgICAgICAgTm9kZXtsPU5vZGV7bD1FbXB0eTsgdj14MDsgcj1FbXB0eTsgaD0xfTsgdj14MTsgcj1FbXB0eTsgaD0yfSwgbFxuICAgICAgICB8IDMsIHgwIDo6IHgxIDo6IHgyIDo6IGwgLT5cbiAgICAgICAgICAgIE5vZGV7bD1Ob2Rle2w9RW1wdHk7IHY9eDA7IHI9RW1wdHk7IGg9MX07IHY9eDE7XG4gICAgICAgICAgICAgICAgIHI9Tm9kZXtsPUVtcHR5OyB2PXgyOyByPUVtcHR5OyBoPTF9OyBoPTJ9LCBsXG4gICAgICAgIHwgbiwgbCAtPlxuICAgICAgICAgIGxldCBubCA9IG4gLyAyIGluXG4gICAgICAgICAgbGV0IGxlZnQsIGwgPSBzdWIgbmwgbCBpblxuICAgICAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgICAgIHwgW10gLT4gYXNzZXJ0IGZhbHNlXG4gICAgICAgICAgfCBtaWQgOjogbCAtPlxuICAgICAgICAgICAgbGV0IHJpZ2h0LCBsID0gc3ViIChuIC0gbmwgLSAxKSBsIGluXG4gICAgICAgICAgICBjcmVhdGUgbGVmdCBtaWQgcmlnaHQsIGxcbiAgICAgIGluXG4gICAgICBmc3QgKHN1YiAoTGlzdC5sZW5ndGggbCkgbClcblxuICAgIGxldCBvZl9saXN0IGwgPVxuICAgICAgbWF0Y2ggbCB3aXRoXG4gICAgICB8IFtdIC0+IGVtcHR5XG4gICAgICB8IFt4MF0gLT4gc2luZ2xldG9uIHgwXG4gICAgICB8IFt4MDsgeDFdIC0+IGFkZCB4MSAoc2luZ2xldG9uIHgwKVxuICAgICAgfCBbeDA7IHgxOyB4Ml0gLT4gYWRkIHgyIChhZGQgeDEgKHNpbmdsZXRvbiB4MCkpXG4gICAgICB8IFt4MDsgeDE7IHgyOyB4M10gLT4gYWRkIHgzIChhZGQgeDIgKGFkZCB4MSAoc2luZ2xldG9uIHgwKSkpXG4gICAgICB8IFt4MDsgeDE7IHgyOyB4MzsgeDRdIC0+IGFkZCB4NCAoYWRkIHgzIChhZGQgeDIgKGFkZCB4MSAoc2luZ2xldG9uIHgwKSkpKVxuICAgICAgfCBfIC0+IG9mX3NvcnRlZF9saXN0IChMaXN0LnNvcnRfdW5pcSBPcmQuY29tcGFyZSBsKVxuXG4gICAgbGV0IGFkZF9zZXEgaSBtID1cbiAgICAgIFNlcS5mb2xkX2xlZnQgKGZ1biBzIHggLT4gYWRkIHggcykgbSBpXG5cbiAgICBsZXQgb2Zfc2VxIGkgPSBhZGRfc2VxIGkgZW1wdHlcblxuICAgIGxldCByZWMgc2VxX29mX2VudW1fIGMgKCkgPSBtYXRjaCBjIHdpdGhcbiAgICAgIHwgRW5kIC0+IFNlcS5OaWxcbiAgICAgIHwgTW9yZSAoeCwgdCwgcmVzdCkgLT4gU2VxLkNvbnMgKHgsIHNlcV9vZl9lbnVtXyAoY29uc19lbnVtIHQgcmVzdCkpXG5cbiAgICBsZXQgdG9fc2VxIGMgPSBzZXFfb2ZfZW51bV8gKGNvbnNfZW51bSBjIEVuZClcblxuICAgIGxldCByZWMgc25vY19lbnVtIHMgZSA9XG4gICAgICBtYXRjaCBzIHdpdGhcbiAgICAgICAgRW1wdHkgLT4gZVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+IHNub2NfZW51bSByIChNb3JlKHYsIGwsIGUpKVxuXG4gICAgbGV0IHJlYyByZXZfc2VxX29mX2VudW1fIGMgKCkgPSBtYXRjaCBjIHdpdGhcbiAgICAgIHwgRW5kIC0+IFNlcS5OaWxcbiAgICAgIHwgTW9yZSAoeCwgdCwgcmVzdCkgLT4gU2VxLkNvbnMgKHgsIHJldl9zZXFfb2ZfZW51bV8gKHNub2NfZW51bSB0IHJlc3QpKVxuXG4gICAgbGV0IHRvX3Jldl9zZXEgYyA9IHJldl9zZXFfb2ZfZW51bV8gKHNub2NfZW51bSBjIEVuZClcblxuICAgIGxldCB0b19zZXFfZnJvbSBsb3cgcyA9XG4gICAgICBsZXQgcmVjIGF1eCBsb3cgcyBjID0gbWF0Y2ggcyB3aXRoXG4gICAgICAgIHwgRW1wdHkgLT4gY1xuICAgICAgICB8IE5vZGUge2w7IHI7IHY7IF99IC0+XG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBPcmQuY29tcGFyZSB2IGxvdyB3aXRoXG4gICAgICAgICAgICAgIHwgMCAtPiBNb3JlICh2LCByLCBjKVxuICAgICAgICAgICAgICB8IG4gd2hlbiBuPDAgLT4gYXV4IGxvdyByIGNcbiAgICAgICAgICAgICAgfCBfIC0+IGF1eCBsb3cgbCAoTW9yZSAodiwgciwgYykpXG4gICAgICAgICAgICBlbmRcbiAgICAgIGluXG4gICAgICBzZXFfb2ZfZW51bV8gKGF1eCBsb3cgcyBFbmQpXG4gIGVuZFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5tb2R1bGUgdHlwZSBPcmRlcmVkVHlwZSA9XG4gIHNpZ1xuICAgIHR5cGUgdFxuICAgIHZhbCBjb21wYXJlOiB0IC0+IHQgLT4gaW50XG4gIGVuZFxuXG5tb2R1bGUgdHlwZSBTID1cbiAgc2lnXG4gICAgdHlwZSBrZXlcbiAgICB0eXBlICErJ2EgdFxuICAgIHZhbCBlbXB0eTogJ2EgdFxuICAgIHZhbCBpc19lbXB0eTogJ2EgdCAtPiBib29sXG4gICAgdmFsIG1lbTogIGtleSAtPiAnYSB0IC0+IGJvb2xcbiAgICB2YWwgYWRkOiBrZXkgLT4gJ2EgLT4gJ2EgdCAtPiAnYSB0XG4gICAgdmFsIHVwZGF0ZToga2V5IC0+ICgnYSBvcHRpb24gLT4gJ2Egb3B0aW9uKSAtPiAnYSB0IC0+ICdhIHRcbiAgICB2YWwgc2luZ2xldG9uOiBrZXkgLT4gJ2EgLT4gJ2EgdFxuICAgIHZhbCByZW1vdmU6IGtleSAtPiAnYSB0IC0+ICdhIHRcbiAgICB2YWwgbWVyZ2U6XG4gICAgICAgICAgKGtleSAtPiAnYSBvcHRpb24gLT4gJ2Igb3B0aW9uIC0+ICdjIG9wdGlvbikgLT4gJ2EgdCAtPiAnYiB0IC0+ICdjIHRcbiAgICB2YWwgdW5pb246IChrZXkgLT4gJ2EgLT4gJ2EgLT4gJ2Egb3B0aW9uKSAtPiAnYSB0IC0+ICdhIHQgLT4gJ2EgdFxuICAgIHZhbCBjb21wYXJlOiAoJ2EgLT4gJ2EgLT4gaW50KSAtPiAnYSB0IC0+ICdhIHQgLT4gaW50XG4gICAgdmFsIGVxdWFsOiAoJ2EgLT4gJ2EgLT4gYm9vbCkgLT4gJ2EgdCAtPiAnYSB0IC0+IGJvb2xcbiAgICB2YWwgaXRlcjogKGtleSAtPiAnYSAtPiB1bml0KSAtPiAnYSB0IC0+IHVuaXRcbiAgICB2YWwgZm9sZDogKGtleSAtPiAnYSAtPiAnYiAtPiAnYikgLT4gJ2EgdCAtPiAnYiAtPiAnYlxuICAgIHZhbCBmb3JfYWxsOiAoa2V5IC0+ICdhIC0+IGJvb2wpIC0+ICdhIHQgLT4gYm9vbFxuICAgIHZhbCBleGlzdHM6IChrZXkgLT4gJ2EgLT4gYm9vbCkgLT4gJ2EgdCAtPiBib29sXG4gICAgdmFsIGZpbHRlcjogKGtleSAtPiAnYSAtPiBib29sKSAtPiAnYSB0IC0+ICdhIHRcbiAgICB2YWwgZmlsdGVyX21hcDogKGtleSAtPiAnYSAtPiAnYiBvcHRpb24pIC0+ICdhIHQgLT4gJ2IgdFxuICAgIHZhbCBwYXJ0aXRpb246IChrZXkgLT4gJ2EgLT4gYm9vbCkgLT4gJ2EgdCAtPiAnYSB0ICogJ2EgdFxuICAgIHZhbCBjYXJkaW5hbDogJ2EgdCAtPiBpbnRcbiAgICB2YWwgYmluZGluZ3M6ICdhIHQgLT4gKGtleSAqICdhKSBsaXN0XG4gICAgdmFsIG1pbl9iaW5kaW5nOiAnYSB0IC0+IChrZXkgKiAnYSlcbiAgICB2YWwgbWluX2JpbmRpbmdfb3B0OiAnYSB0IC0+IChrZXkgKiAnYSkgb3B0aW9uXG4gICAgdmFsIG1heF9iaW5kaW5nOiAnYSB0IC0+IChrZXkgKiAnYSlcbiAgICB2YWwgbWF4X2JpbmRpbmdfb3B0OiAnYSB0IC0+IChrZXkgKiAnYSkgb3B0aW9uXG4gICAgdmFsIGNob29zZTogJ2EgdCAtPiAoa2V5ICogJ2EpXG4gICAgdmFsIGNob29zZV9vcHQ6ICdhIHQgLT4gKGtleSAqICdhKSBvcHRpb25cbiAgICB2YWwgc3BsaXQ6IGtleSAtPiAnYSB0IC0+ICdhIHQgKiAnYSBvcHRpb24gKiAnYSB0XG4gICAgdmFsIGZpbmQ6IGtleSAtPiAnYSB0IC0+ICdhXG4gICAgdmFsIGZpbmRfb3B0OiBrZXkgLT4gJ2EgdCAtPiAnYSBvcHRpb25cbiAgICB2YWwgZmluZF9maXJzdDogKGtleSAtPiBib29sKSAtPiAnYSB0IC0+IGtleSAqICdhXG4gICAgdmFsIGZpbmRfZmlyc3Rfb3B0OiAoa2V5IC0+IGJvb2wpIC0+ICdhIHQgLT4gKGtleSAqICdhKSBvcHRpb25cbiAgICB2YWwgZmluZF9sYXN0OiAoa2V5IC0+IGJvb2wpIC0+ICdhIHQgLT4ga2V5ICogJ2FcbiAgICB2YWwgZmluZF9sYXN0X29wdDogKGtleSAtPiBib29sKSAtPiAnYSB0IC0+IChrZXkgKiAnYSkgb3B0aW9uXG4gICAgdmFsIG1hcDogKCdhIC0+ICdiKSAtPiAnYSB0IC0+ICdiIHRcbiAgICB2YWwgbWFwaTogKGtleSAtPiAnYSAtPiAnYikgLT4gJ2EgdCAtPiAnYiB0XG4gICAgdmFsIHRvX3NlcSA6ICdhIHQgLT4gKGtleSAqICdhKSBTZXEudFxuICAgIHZhbCB0b19yZXZfc2VxIDogJ2EgdCAtPiAoa2V5ICogJ2EpIFNlcS50XG4gICAgdmFsIHRvX3NlcV9mcm9tIDoga2V5IC0+ICdhIHQgLT4gKGtleSAqICdhKSBTZXEudFxuICAgIHZhbCBhZGRfc2VxIDogKGtleSAqICdhKSBTZXEudCAtPiAnYSB0IC0+ICdhIHRcbiAgICB2YWwgb2Zfc2VxIDogKGtleSAqICdhKSBTZXEudCAtPiAnYSB0XG4gIGVuZFxuXG5tb2R1bGUgTWFrZShPcmQ6IE9yZGVyZWRUeXBlKSA9IHN0cnVjdFxuXG4gICAgdHlwZSBrZXkgPSBPcmQudFxuXG4gICAgdHlwZSAnYSB0ID1cbiAgICAgICAgRW1wdHlcbiAgICAgIHwgTm9kZSBvZiB7bDonYSB0OyB2OmtleTsgZDonYTsgcjonYSB0OyBoOmludH1cblxuICAgIGxldCBoZWlnaHQgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiAwXG4gICAgICB8IE5vZGUge2h9IC0+IGhcblxuICAgIGxldCBjcmVhdGUgbCB4IGQgciA9XG4gICAgICBsZXQgaGwgPSBoZWlnaHQgbCBhbmQgaHIgPSBoZWlnaHQgciBpblxuICAgICAgTm9kZXtsOyB2PXg7IGQ7IHI7IGg9KGlmIGhsID49IGhyIHRoZW4gaGwgKyAxIGVsc2UgaHIgKyAxKX1cblxuICAgIGxldCBzaW5nbGV0b24geCBkID0gTm9kZXtsPUVtcHR5OyB2PXg7IGQ7IHI9RW1wdHk7IGg9MX1cblxuICAgIGxldCBiYWwgbCB4IGQgciA9XG4gICAgICBsZXQgaGwgPSBtYXRjaCBsIHdpdGggRW1wdHkgLT4gMCB8IE5vZGUge2h9IC0+IGggaW5cbiAgICAgIGxldCBociA9IG1hdGNoIHIgd2l0aCBFbXB0eSAtPiAwIHwgTm9kZSB7aH0gLT4gaCBpblxuICAgICAgaWYgaGwgPiBociArIDIgdGhlbiBiZWdpblxuICAgICAgICBtYXRjaCBsIHdpdGhcbiAgICAgICAgICBFbXB0eSAtPiBpbnZhbGlkX2FyZyBcIk1hcC5iYWxcIlxuICAgICAgICB8IE5vZGV7bD1sbDsgdj1sdjsgZD1sZDsgcj1scn0gLT5cbiAgICAgICAgICAgIGlmIGhlaWdodCBsbCA+PSBoZWlnaHQgbHIgdGhlblxuICAgICAgICAgICAgICBjcmVhdGUgbGwgbHYgbGQgKGNyZWF0ZSBsciB4IGQgcilcbiAgICAgICAgICAgIGVsc2UgYmVnaW5cbiAgICAgICAgICAgICAgbWF0Y2ggbHIgd2l0aFxuICAgICAgICAgICAgICAgIEVtcHR5IC0+IGludmFsaWRfYXJnIFwiTWFwLmJhbFwiXG4gICAgICAgICAgICAgIHwgTm9kZXtsPWxybDsgdj1scnY7IGQ9bHJkOyByPWxycn0tPlxuICAgICAgICAgICAgICAgICAgY3JlYXRlIChjcmVhdGUgbGwgbHYgbGQgbHJsKSBscnYgbHJkIChjcmVhdGUgbHJyIHggZCByKVxuICAgICAgICAgICAgZW5kXG4gICAgICBlbmQgZWxzZSBpZiBociA+IGhsICsgMiB0aGVuIGJlZ2luXG4gICAgICAgIG1hdGNoIHIgd2l0aFxuICAgICAgICAgIEVtcHR5IC0+IGludmFsaWRfYXJnIFwiTWFwLmJhbFwiXG4gICAgICAgIHwgTm9kZXtsPXJsOyB2PXJ2OyBkPXJkOyByPXJyfSAtPlxuICAgICAgICAgICAgaWYgaGVpZ2h0IHJyID49IGhlaWdodCBybCB0aGVuXG4gICAgICAgICAgICAgIGNyZWF0ZSAoY3JlYXRlIGwgeCBkIHJsKSBydiByZCByclxuICAgICAgICAgICAgZWxzZSBiZWdpblxuICAgICAgICAgICAgICBtYXRjaCBybCB3aXRoXG4gICAgICAgICAgICAgICAgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJNYXAuYmFsXCJcbiAgICAgICAgICAgICAgfCBOb2Rle2w9cmxsOyB2PXJsdjsgZD1ybGQ7IHI9cmxyfSAtPlxuICAgICAgICAgICAgICAgICAgY3JlYXRlIChjcmVhdGUgbCB4IGQgcmxsKSBybHYgcmxkIChjcmVhdGUgcmxyIHJ2IHJkIHJyKVxuICAgICAgICAgICAgZW5kXG4gICAgICBlbmQgZWxzZVxuICAgICAgICBOb2Rle2w7IHY9eDsgZDsgcjsgaD0oaWYgaGwgPj0gaHIgdGhlbiBobCArIDEgZWxzZSBociArIDEpfVxuXG4gICAgbGV0IGVtcHR5ID0gRW1wdHlcblxuICAgIGxldCBpc19lbXB0eSA9IGZ1bmN0aW9uIEVtcHR5IC0+IHRydWUgfCBfIC0+IGZhbHNlXG5cbiAgICBsZXQgcmVjIGFkZCB4IGRhdGEgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIE5vZGV7bD1FbXB0eTsgdj14OyBkPWRhdGE7IHI9RW1wdHk7IGg9MX1cbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcjsgaH0gYXMgbSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlblxuICAgICAgICAgICAgaWYgZCA9PSBkYXRhIHRoZW4gbSBlbHNlIE5vZGV7bDsgdj14OyBkPWRhdGE7IHI7IGh9XG4gICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuXG4gICAgICAgICAgICBsZXQgbGwgPSBhZGQgeCBkYXRhIGwgaW5cbiAgICAgICAgICAgIGlmIGwgPT0gbGwgdGhlbiBtIGVsc2UgYmFsIGxsIHYgZCByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbGV0IHJyID0gYWRkIHggZGF0YSByIGluXG4gICAgICAgICAgICBpZiByID09IHJyIHRoZW4gbSBlbHNlIGJhbCBsIHYgZCByclxuXG4gICAgbGV0IHJlYyBmaW5kIHggPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiBkXG4gICAgICAgICAgZWxzZSBmaW5kIHggKGlmIGMgPCAwIHRoZW4gbCBlbHNlIHIpXG5cbiAgICBsZXQgcmVjIGZpbmRfZmlyc3RfYXV4IHYwIGQwIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgICh2MCwgZDApXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfZmlyc3RfYXV4IHYgZCBmIGxcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X2F1eCB2MCBkMCBmIHJcblxuICAgIGxldCByZWMgZmluZF9maXJzdCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9maXJzdF9hdXggdiBkIGYgbFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfZmlyc3QgZiByXG5cbiAgICBsZXQgcmVjIGZpbmRfZmlyc3Rfb3B0X2F1eCB2MCBkMCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBTb21lICh2MCwgZDApXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfZmlyc3Rfb3B0X2F1eCB2IGQgZiBsXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9maXJzdF9vcHRfYXV4IHYwIGQwIGYgclxuXG4gICAgbGV0IHJlYyBmaW5kX2ZpcnN0X29wdCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBOb25lXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfZmlyc3Rfb3B0X2F1eCB2IGQgZiBsXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9maXJzdF9vcHQgZiByXG5cbiAgICBsZXQgcmVjIGZpbmRfbGFzdF9hdXggdjAgZDAgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgKHYwLCBkMClcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9sYXN0X2F1eCB2IGQgZiByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9sYXN0X2F1eCB2MCBkMCBmIGxcblxuICAgIGxldCByZWMgZmluZF9sYXN0IGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2xhc3RfYXV4IHYgZCBmIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2xhc3QgZiBsXG5cbiAgICBsZXQgcmVjIGZpbmRfbGFzdF9vcHRfYXV4IHYwIGQwIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIFNvbWUgKHYwLCBkMClcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9sYXN0X29wdF9hdXggdiBkIGYgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfbGFzdF9vcHRfYXV4IHYwIGQwIGYgbFxuXG4gICAgbGV0IHJlYyBmaW5kX2xhc3Rfb3B0IGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIE5vbmVcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9sYXN0X29wdF9hdXggdiBkIGYgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfbGFzdF9vcHQgZiBsXG5cbiAgICBsZXQgcmVjIGZpbmRfb3B0IHggPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIE5vbmVcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gU29tZSBkXG4gICAgICAgICAgZWxzZSBmaW5kX29wdCB4IChpZiBjIDwgMCB0aGVuIGwgZWxzZSByKVxuXG4gICAgbGV0IHJlYyBtZW0geCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgZmFsc2VcbiAgICAgIHwgTm9kZSB7bDsgdjsgcn0gLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGMgPSAwIHx8IG1lbSB4IChpZiBjIDwgMCB0aGVuIGwgZWxzZSByKVxuXG4gICAgbGV0IHJlYyBtaW5fYmluZGluZyA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBOb2RlIHtsPUVtcHR5OyB2OyBkfSAtPiAodiwgZClcbiAgICAgIHwgTm9kZSB7bH0gLT4gbWluX2JpbmRpbmcgbFxuXG4gICAgbGV0IHJlYyBtaW5fYmluZGluZ19vcHQgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBOb25lXG4gICAgICB8IE5vZGUge2w9RW1wdHk7IHY7IGR9IC0+IFNvbWUgKHYsIGQpXG4gICAgICB8IE5vZGUge2x9LT4gbWluX2JpbmRpbmdfb3B0IGxcblxuICAgIGxldCByZWMgbWF4X2JpbmRpbmcgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgTm9kZSB7djsgZDsgcj1FbXB0eX0gLT4gKHYsIGQpXG4gICAgICB8IE5vZGUge3J9IC0+IG1heF9iaW5kaW5nIHJcblxuICAgIGxldCByZWMgbWF4X2JpbmRpbmdfb3B0ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gTm9uZVxuICAgICAgfCBOb2RlIHt2OyBkOyByPUVtcHR5fSAtPiBTb21lICh2LCBkKVxuICAgICAgfCBOb2RlIHtyfSAtPiBtYXhfYmluZGluZ19vcHQgclxuXG4gICAgbGV0IHJlYyByZW1vdmVfbWluX2JpbmRpbmcgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBpbnZhbGlkX2FyZyBcIk1hcC5yZW1vdmVfbWluX2VsdFwiXG4gICAgICB8IE5vZGUge2w9RW1wdHk7IHJ9IC0+IHJcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT4gYmFsIChyZW1vdmVfbWluX2JpbmRpbmcgbCkgdiBkIHJcblxuICAgIGxldCBtZXJnZSB0MSB0MiA9XG4gICAgICBtYXRjaCAodDEsIHQyKSB3aXRoXG4gICAgICAgIChFbXB0eSwgdCkgLT4gdFxuICAgICAgfCAodCwgRW1wdHkpIC0+IHRcbiAgICAgIHwgKF8sIF8pIC0+XG4gICAgICAgICAgbGV0ICh4LCBkKSA9IG1pbl9iaW5kaW5nIHQyIGluXG4gICAgICAgICAgYmFsIHQxIHggZCAocmVtb3ZlX21pbl9iaW5kaW5nIHQyKVxuXG4gICAgbGV0IHJlYyByZW1vdmUgeCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgRW1wdHlcbiAgICAgIHwgKE5vZGUge2w7IHY7IGQ7IHJ9IGFzIG0pIC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuIG1lcmdlIGwgclxuICAgICAgICAgIGVsc2UgaWYgYyA8IDAgdGhlblxuICAgICAgICAgICAgbGV0IGxsID0gcmVtb3ZlIHggbCBpbiBpZiBsID09IGxsIHRoZW4gbSBlbHNlIGJhbCBsbCB2IGQgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxldCByciA9IHJlbW92ZSB4IHIgaW4gaWYgciA9PSByciB0aGVuIG0gZWxzZSBiYWwgbCB2IGQgcnJcblxuICAgIGxldCByZWMgdXBkYXRlIHggZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgYmVnaW4gbWF0Y2ggZiBOb25lIHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gRW1wdHlcbiAgICAgICAgICB8IFNvbWUgZGF0YSAtPiBOb2Rle2w9RW1wdHk7IHY9eDsgZD1kYXRhOyByPUVtcHR5OyBoPTF9XG4gICAgICAgICAgZW5kXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHI7IGh9IGFzIG0gLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gYmVnaW5cbiAgICAgICAgICAgIG1hdGNoIGYgKFNvbWUgZCkgd2l0aFxuICAgICAgICAgICAgfCBOb25lIC0+IG1lcmdlIGwgclxuICAgICAgICAgICAgfCBTb21lIGRhdGEgLT5cbiAgICAgICAgICAgICAgICBpZiBkID09IGRhdGEgdGhlbiBtIGVsc2UgTm9kZXtsOyB2PXg7IGQ9ZGF0YTsgcjsgaH1cbiAgICAgICAgICBlbmQgZWxzZSBpZiBjIDwgMCB0aGVuXG4gICAgICAgICAgICBsZXQgbGwgPSB1cGRhdGUgeCBmIGwgaW5cbiAgICAgICAgICAgIGlmIGwgPT0gbGwgdGhlbiBtIGVsc2UgYmFsIGxsIHYgZCByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbGV0IHJyID0gdXBkYXRlIHggZiByIGluXG4gICAgICAgICAgICBpZiByID09IHJyIHRoZW4gbSBlbHNlIGJhbCBsIHYgZCByclxuXG4gICAgbGV0IHJlYyBpdGVyIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiAoKVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGl0ZXIgZiBsOyBmIHYgZDsgaXRlciBmIHJcblxuICAgIGxldCByZWMgbWFwIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIEVtcHR5XG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHI7IGh9IC0+XG4gICAgICAgICAgbGV0IGwnID0gbWFwIGYgbCBpblxuICAgICAgICAgIGxldCBkJyA9IGYgZCBpblxuICAgICAgICAgIGxldCByJyA9IG1hcCBmIHIgaW5cbiAgICAgICAgICBOb2Rle2w9bCc7IHY7IGQ9ZCc7IHI9cic7IGh9XG5cbiAgICBsZXQgcmVjIG1hcGkgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgRW1wdHlcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcjsgaH0gLT5cbiAgICAgICAgICBsZXQgbCcgPSBtYXBpIGYgbCBpblxuICAgICAgICAgIGxldCBkJyA9IGYgdiBkIGluXG4gICAgICAgICAgbGV0IHInID0gbWFwaSBmIHIgaW5cbiAgICAgICAgICBOb2Rle2w9bCc7IHY7IGQ9ZCc7IHI9cic7IGh9XG5cbiAgICBsZXQgcmVjIGZvbGQgZiBtIGFjY3UgPVxuICAgICAgbWF0Y2ggbSB3aXRoXG4gICAgICAgIEVtcHR5IC0+IGFjY3VcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBmb2xkIGYgciAoZiB2IGQgKGZvbGQgZiBsIGFjY3UpKVxuXG4gICAgbGV0IHJlYyBmb3JfYWxsIHAgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiB0cnVlXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+IHAgdiBkICYmIGZvcl9hbGwgcCBsICYmIGZvcl9hbGwgcCByXG5cbiAgICBsZXQgcmVjIGV4aXN0cyBwID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gZmFsc2VcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT4gcCB2IGQgfHwgZXhpc3RzIHAgbCB8fCBleGlzdHMgcCByXG5cbiAgICAoKiBCZXdhcmU6IHRob3NlIHR3byBmdW5jdGlvbnMgYXNzdW1lIHRoYXQgdGhlIGFkZGVkIGsgaXMgKnN0cmljdGx5KlxuICAgICAgIHNtYWxsZXIgKG9yIGJpZ2dlcikgdGhhbiBhbGwgdGhlIHByZXNlbnQga2V5cyBpbiB0aGUgdHJlZTsgaXRcbiAgICAgICBkb2VzIG5vdCB0ZXN0IGZvciBlcXVhbGl0eSB3aXRoIHRoZSBjdXJyZW50IG1pbiAob3IgbWF4KSBrZXkuXG5cbiAgICAgICBJbmRlZWQsIHRoZXkgYXJlIG9ubHkgdXNlZCBkdXJpbmcgdGhlIFwiam9pblwiIG9wZXJhdGlvbiB3aGljaFxuICAgICAgIHJlc3BlY3RzIHRoaXMgcHJlY29uZGl0aW9uLlxuICAgICopXG5cbiAgICBsZXQgcmVjIGFkZF9taW5fYmluZGluZyBrIHggPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiBzaW5nbGV0b24gayB4XG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgIGJhbCAoYWRkX21pbl9iaW5kaW5nIGsgeCBsKSB2IGQgclxuXG4gICAgbGV0IHJlYyBhZGRfbWF4X2JpbmRpbmcgayB4ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT4gc2luZ2xldG9uIGsgeFxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICBiYWwgbCB2IGQgKGFkZF9tYXhfYmluZGluZyBrIHggcilcblxuICAgICgqIFNhbWUgYXMgY3JlYXRlIGFuZCBiYWwsIGJ1dCBubyBhc3N1bXB0aW9ucyBhcmUgbWFkZSBvbiB0aGVcbiAgICAgICByZWxhdGl2ZSBoZWlnaHRzIG9mIGwgYW5kIHIuICopXG5cbiAgICBsZXQgcmVjIGpvaW4gbCB2IGQgciA9XG4gICAgICBtYXRjaCAobCwgcikgd2l0aFxuICAgICAgICAoRW1wdHksIF8pIC0+IGFkZF9taW5fYmluZGluZyB2IGQgclxuICAgICAgfCAoXywgRW1wdHkpIC0+IGFkZF9tYXhfYmluZGluZyB2IGQgbFxuICAgICAgfCAoTm9kZXtsPWxsOyB2PWx2OyBkPWxkOyByPWxyOyBoPWxofSxcbiAgICAgICAgIE5vZGV7bD1ybDsgdj1ydjsgZD1yZDsgcj1ycjsgaD1yaH0pIC0+XG4gICAgICAgICAgaWYgbGggPiByaCArIDIgdGhlbiBiYWwgbGwgbHYgbGQgKGpvaW4gbHIgdiBkIHIpIGVsc2VcbiAgICAgICAgICBpZiByaCA+IGxoICsgMiB0aGVuIGJhbCAoam9pbiBsIHYgZCBybCkgcnYgcmQgcnIgZWxzZVxuICAgICAgICAgIGNyZWF0ZSBsIHYgZCByXG5cbiAgICAoKiBNZXJnZSB0d28gdHJlZXMgbCBhbmQgciBpbnRvIG9uZS5cbiAgICAgICBBbGwgZWxlbWVudHMgb2YgbCBtdXN0IHByZWNlZGUgdGhlIGVsZW1lbnRzIG9mIHIuXG4gICAgICAgTm8gYXNzdW1wdGlvbiBvbiB0aGUgaGVpZ2h0cyBvZiBsIGFuZCByLiAqKVxuXG4gICAgbGV0IGNvbmNhdCB0MSB0MiA9XG4gICAgICBtYXRjaCAodDEsIHQyKSB3aXRoXG4gICAgICAgIChFbXB0eSwgdCkgLT4gdFxuICAgICAgfCAodCwgRW1wdHkpIC0+IHRcbiAgICAgIHwgKF8sIF8pIC0+XG4gICAgICAgICAgbGV0ICh4LCBkKSA9IG1pbl9iaW5kaW5nIHQyIGluXG4gICAgICAgICAgam9pbiB0MSB4IGQgKHJlbW92ZV9taW5fYmluZGluZyB0MilcblxuICAgIGxldCBjb25jYXRfb3Jfam9pbiB0MSB2IGQgdDIgPVxuICAgICAgbWF0Y2ggZCB3aXRoXG4gICAgICB8IFNvbWUgZCAtPiBqb2luIHQxIHYgZCB0MlxuICAgICAgfCBOb25lIC0+IGNvbmNhdCB0MSB0MlxuXG4gICAgbGV0IHJlYyBzcGxpdCB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICAoRW1wdHksIE5vbmUsIEVtcHR5KVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiAobCwgU29tZSBkLCByKVxuICAgICAgICAgIGVsc2UgaWYgYyA8IDAgdGhlblxuICAgICAgICAgICAgbGV0IChsbCwgcHJlcywgcmwpID0gc3BsaXQgeCBsIGluIChsbCwgcHJlcywgam9pbiBybCB2IGQgcilcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsZXQgKGxyLCBwcmVzLCBycikgPSBzcGxpdCB4IHIgaW4gKGpvaW4gbCB2IGQgbHIsIHByZXMsIHJyKVxuXG4gICAgbGV0IHJlYyBtZXJnZSBmIHMxIHMyID1cbiAgICAgIG1hdGNoIChzMSwgczIpIHdpdGhcbiAgICAgICAgKEVtcHR5LCBFbXB0eSkgLT4gRW1wdHlcbiAgICAgIHwgKE5vZGUge2w9bDE7IHY9djE7IGQ9ZDE7IHI9cjE7IGg9aDF9LCBfKSB3aGVuIGgxID49IGhlaWdodCBzMiAtPlxuICAgICAgICAgIGxldCAobDIsIGQyLCByMikgPSBzcGxpdCB2MSBzMiBpblxuICAgICAgICAgIGNvbmNhdF9vcl9qb2luIChtZXJnZSBmIGwxIGwyKSB2MSAoZiB2MSAoU29tZSBkMSkgZDIpIChtZXJnZSBmIHIxIHIyKVxuICAgICAgfCAoXywgTm9kZSB7bD1sMjsgdj12MjsgZD1kMjsgcj1yMn0pIC0+XG4gICAgICAgICAgbGV0IChsMSwgZDEsIHIxKSA9IHNwbGl0IHYyIHMxIGluXG4gICAgICAgICAgY29uY2F0X29yX2pvaW4gKG1lcmdlIGYgbDEgbDIpIHYyIChmIHYyIGQxIChTb21lIGQyKSkgKG1lcmdlIGYgcjEgcjIpXG4gICAgICB8IF8gLT5cbiAgICAgICAgICBhc3NlcnQgZmFsc2VcblxuICAgIGxldCByZWMgdW5pb24gZiBzMSBzMiA9XG4gICAgICBtYXRjaCAoczEsIHMyKSB3aXRoXG4gICAgICB8IChFbXB0eSwgcykgfCAocywgRW1wdHkpIC0+IHNcbiAgICAgIHwgKE5vZGUge2w9bDE7IHY9djE7IGQ9ZDE7IHI9cjE7IGg9aDF9LFxuICAgICAgICAgTm9kZSB7bD1sMjsgdj12MjsgZD1kMjsgcj1yMjsgaD1oMn0pIC0+XG4gICAgICAgICAgaWYgaDEgPj0gaDIgdGhlblxuICAgICAgICAgICAgbGV0IChsMiwgZDIsIHIyKSA9IHNwbGl0IHYxIHMyIGluXG4gICAgICAgICAgICBsZXQgbCA9IHVuaW9uIGYgbDEgbDIgYW5kIHIgPSB1bmlvbiBmIHIxIHIyIGluXG4gICAgICAgICAgICBtYXRjaCBkMiB3aXRoXG4gICAgICAgICAgICB8IE5vbmUgLT4gam9pbiBsIHYxIGQxIHJcbiAgICAgICAgICAgIHwgU29tZSBkMiAtPiBjb25jYXRfb3Jfam9pbiBsIHYxIChmIHYxIGQxIGQyKSByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbGV0IChsMSwgZDEsIHIxKSA9IHNwbGl0IHYyIHMxIGluXG4gICAgICAgICAgICBsZXQgbCA9IHVuaW9uIGYgbDEgbDIgYW5kIHIgPSB1bmlvbiBmIHIxIHIyIGluXG4gICAgICAgICAgICBtYXRjaCBkMSB3aXRoXG4gICAgICAgICAgICB8IE5vbmUgLT4gam9pbiBsIHYyIGQyIHJcbiAgICAgICAgICAgIHwgU29tZSBkMSAtPiBjb25jYXRfb3Jfam9pbiBsIHYyIChmIHYyIGQxIGQyKSByXG5cbiAgICBsZXQgcmVjIGZpbHRlciBwID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gRW1wdHlcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gYXMgbSAtPlxuICAgICAgICAgICgqIGNhbGwgW3BdIGluIHRoZSBleHBlY3RlZCBsZWZ0LXRvLXJpZ2h0IG9yZGVyICopXG4gICAgICAgICAgbGV0IGwnID0gZmlsdGVyIHAgbCBpblxuICAgICAgICAgIGxldCBwdmQgPSBwIHYgZCBpblxuICAgICAgICAgIGxldCByJyA9IGZpbHRlciBwIHIgaW5cbiAgICAgICAgICBpZiBwdmQgdGhlbiBpZiBsPT1sJyAmJiByPT1yJyB0aGVuIG0gZWxzZSBqb2luIGwnIHYgZCByJ1xuICAgICAgICAgIGVsc2UgY29uY2F0IGwnIHInXG5cbiAgICBsZXQgcmVjIGZpbHRlcl9tYXAgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IEVtcHR5XG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgKCogY2FsbCBbZl0gaW4gdGhlIGV4cGVjdGVkIGxlZnQtdG8tcmlnaHQgb3JkZXIgKilcbiAgICAgICAgICBsZXQgbCcgPSBmaWx0ZXJfbWFwIGYgbCBpblxuICAgICAgICAgIGxldCBmdmQgPSBmIHYgZCBpblxuICAgICAgICAgIGxldCByJyA9IGZpbHRlcl9tYXAgZiByIGluXG4gICAgICAgICAgYmVnaW4gbWF0Y2ggZnZkIHdpdGhcbiAgICAgICAgICAgIHwgU29tZSBkJyAtPiBqb2luIGwnIHYgZCcgcidcbiAgICAgICAgICAgIHwgTm9uZSAtPiBjb25jYXQgbCcgcidcbiAgICAgICAgICBlbmRcblxuICAgIGxldCByZWMgcGFydGl0aW9uIHAgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiAoRW1wdHksIEVtcHR5KVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgICgqIGNhbGwgW3BdIGluIHRoZSBleHBlY3RlZCBsZWZ0LXRvLXJpZ2h0IG9yZGVyICopXG4gICAgICAgICAgbGV0IChsdCwgbGYpID0gcGFydGl0aW9uIHAgbCBpblxuICAgICAgICAgIGxldCBwdmQgPSBwIHYgZCBpblxuICAgICAgICAgIGxldCAocnQsIHJmKSA9IHBhcnRpdGlvbiBwIHIgaW5cbiAgICAgICAgICBpZiBwdmRcbiAgICAgICAgICB0aGVuIChqb2luIGx0IHYgZCBydCwgY29uY2F0IGxmIHJmKVxuICAgICAgICAgIGVsc2UgKGNvbmNhdCBsdCBydCwgam9pbiBsZiB2IGQgcmYpXG5cbiAgICB0eXBlICdhIGVudW1lcmF0aW9uID0gRW5kIHwgTW9yZSBvZiBrZXkgKiAnYSAqICdhIHQgKiAnYSBlbnVtZXJhdGlvblxuXG4gICAgbGV0IHJlYyBjb25zX2VudW0gbSBlID1cbiAgICAgIG1hdGNoIG0gd2l0aFxuICAgICAgICBFbXB0eSAtPiBlXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+IGNvbnNfZW51bSBsIChNb3JlKHYsIGQsIHIsIGUpKVxuXG4gICAgbGV0IGNvbXBhcmUgY21wIG0xIG0yID1cbiAgICAgIGxldCByZWMgY29tcGFyZV9hdXggZTEgZTIgPVxuICAgICAgICAgIG1hdGNoIChlMSwgZTIpIHdpdGhcbiAgICAgICAgICAoRW5kLCBFbmQpIC0+IDBcbiAgICAgICAgfCAoRW5kLCBfKSAgLT4gLTFcbiAgICAgICAgfCAoXywgRW5kKSAtPiAxXG4gICAgICAgIHwgKE1vcmUodjEsIGQxLCByMSwgZTEpLCBNb3JlKHYyLCBkMiwgcjIsIGUyKSkgLT5cbiAgICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgdjEgdjIgaW5cbiAgICAgICAgICAgIGlmIGMgPD4gMCB0aGVuIGMgZWxzZVxuICAgICAgICAgICAgbGV0IGMgPSBjbXAgZDEgZDIgaW5cbiAgICAgICAgICAgIGlmIGMgPD4gMCB0aGVuIGMgZWxzZVxuICAgICAgICAgICAgY29tcGFyZV9hdXggKGNvbnNfZW51bSByMSBlMSkgKGNvbnNfZW51bSByMiBlMilcbiAgICAgIGluIGNvbXBhcmVfYXV4IChjb25zX2VudW0gbTEgRW5kKSAoY29uc19lbnVtIG0yIEVuZClcblxuICAgIGxldCBlcXVhbCBjbXAgbTEgbTIgPVxuICAgICAgbGV0IHJlYyBlcXVhbF9hdXggZTEgZTIgPVxuICAgICAgICAgIG1hdGNoIChlMSwgZTIpIHdpdGhcbiAgICAgICAgICAoRW5kLCBFbmQpIC0+IHRydWVcbiAgICAgICAgfCAoRW5kLCBfKSAgLT4gZmFsc2VcbiAgICAgICAgfCAoXywgRW5kKSAtPiBmYWxzZVxuICAgICAgICB8IChNb3JlKHYxLCBkMSwgcjEsIGUxKSwgTW9yZSh2MiwgZDIsIHIyLCBlMikpIC0+XG4gICAgICAgICAgICBPcmQuY29tcGFyZSB2MSB2MiA9IDAgJiYgY21wIGQxIGQyICYmXG4gICAgICAgICAgICBlcXVhbF9hdXggKGNvbnNfZW51bSByMSBlMSkgKGNvbnNfZW51bSByMiBlMilcbiAgICAgIGluIGVxdWFsX2F1eCAoY29uc19lbnVtIG0xIEVuZCkgKGNvbnNfZW51bSBtMiBFbmQpXG5cbiAgICBsZXQgcmVjIGNhcmRpbmFsID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gMFxuICAgICAgfCBOb2RlIHtsOyByfSAtPiBjYXJkaW5hbCBsICsgMSArIGNhcmRpbmFsIHJcblxuICAgIGxldCByZWMgYmluZGluZ3NfYXV4IGFjY3UgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBhY2N1XG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+IGJpbmRpbmdzX2F1eCAoKHYsIGQpIDo6IGJpbmRpbmdzX2F1eCBhY2N1IHIpIGxcblxuICAgIGxldCBiaW5kaW5ncyBzID1cbiAgICAgIGJpbmRpbmdzX2F1eCBbXSBzXG5cbiAgICBsZXQgY2hvb3NlID0gbWluX2JpbmRpbmdcblxuICAgIGxldCBjaG9vc2Vfb3B0ID0gbWluX2JpbmRpbmdfb3B0XG5cbiAgICBsZXQgYWRkX3NlcSBpIG0gPVxuICAgICAgU2VxLmZvbGRfbGVmdCAoZnVuIG0gKGssdikgLT4gYWRkIGsgdiBtKSBtIGlcblxuICAgIGxldCBvZl9zZXEgaSA9IGFkZF9zZXEgaSBlbXB0eVxuXG4gICAgbGV0IHJlYyBzZXFfb2ZfZW51bV8gYyAoKSA9IG1hdGNoIGMgd2l0aFxuICAgICAgfCBFbmQgLT4gU2VxLk5pbFxuICAgICAgfCBNb3JlIChrLHYsdCxyZXN0KSAtPiBTZXEuQ29ucyAoKGssdiksIHNlcV9vZl9lbnVtXyAoY29uc19lbnVtIHQgcmVzdCkpXG5cbiAgICBsZXQgdG9fc2VxIG0gPVxuICAgICAgc2VxX29mX2VudW1fIChjb25zX2VudW0gbSBFbmQpXG5cbiAgICBsZXQgcmVjIHNub2NfZW51bSBzIGUgPVxuICAgICAgbWF0Y2ggcyB3aXRoXG4gICAgICAgIEVtcHR5IC0+IGVcbiAgICAgIHwgTm9kZXtsOyB2OyBkOyByfSAtPiBzbm9jX2VudW0gciAoTW9yZSh2LCBkLCBsLCBlKSlcblxuICAgIGxldCByZWMgcmV2X3NlcV9vZl9lbnVtXyBjICgpID0gbWF0Y2ggYyB3aXRoXG4gICAgICB8IEVuZCAtPiBTZXEuTmlsXG4gICAgICB8IE1vcmUgKGssdix0LHJlc3QpIC0+XG4gICAgICAgICAgU2VxLkNvbnMgKChrLHYpLCByZXZfc2VxX29mX2VudW1fIChzbm9jX2VudW0gdCByZXN0KSlcblxuICAgIGxldCB0b19yZXZfc2VxIGMgPVxuICAgICAgcmV2X3NlcV9vZl9lbnVtXyAoc25vY19lbnVtIGMgRW5kKVxuXG4gICAgbGV0IHRvX3NlcV9mcm9tIGxvdyBtID1cbiAgICAgIGxldCByZWMgYXV4IGxvdyBtIGMgPSBtYXRjaCBtIHdpdGhcbiAgICAgICAgfCBFbXB0eSAtPiBjXG4gICAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcjsgX30gLT5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIE9yZC5jb21wYXJlIHYgbG93IHdpdGhcbiAgICAgICAgICAgICAgfCAwIC0+IE1vcmUgKHYsIGQsIHIsIGMpXG4gICAgICAgICAgICAgIHwgbiB3aGVuIG48MCAtPiBhdXggbG93IHIgY1xuICAgICAgICAgICAgICB8IF8gLT4gYXV4IGxvdyBsIChNb3JlICh2LCBkLCByLCBjKSlcbiAgICAgICAgICAgIGVuZFxuICAgICAgaW5cbiAgICAgIHNlcV9vZl9lbnVtXyAoYXV4IGxvdyBtIEVuZClcbmVuZFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlICdhIHQgPSB7IG11dGFibGUgYyA6ICdhIGxpc3Q7IG11dGFibGUgbGVuIDogaW50OyB9XG5cbmV4Y2VwdGlvbiBFbXB0eVxuXG5sZXQgY3JlYXRlICgpID0geyBjID0gW107IGxlbiA9IDA7IH1cblxubGV0IGNsZWFyIHMgPSBzLmMgPC0gW107IHMubGVuIDwtIDBcblxubGV0IGNvcHkgcyA9IHsgYyA9IHMuYzsgbGVuID0gcy5sZW47IH1cblxubGV0IHB1c2ggeCBzID0gcy5jIDwtIHggOjogcy5jOyBzLmxlbiA8LSBzLmxlbiArIDFcblxubGV0IHBvcCBzID1cbiAgbWF0Y2ggcy5jIHdpdGhcbiAgfCBoZDo6dGwgLT4gcy5jIDwtIHRsOyBzLmxlbiA8LSBzLmxlbiAtIDE7IGhkXG4gIHwgW10gICAgIC0+IHJhaXNlIEVtcHR5XG5cbmxldCBwb3Bfb3B0IHMgPVxuICBtYXRjaCBzLmMgd2l0aFxuICB8IGhkOjp0bCAtPiBzLmMgPC0gdGw7IHMubGVuIDwtIHMubGVuIC0gMTsgU29tZSBoZFxuICB8IFtdICAgICAtPiBOb25lXG5cbmxldCB0b3AgcyA9XG4gIG1hdGNoIHMuYyB3aXRoXG4gIHwgaGQ6Ol8gLT4gaGRcbiAgfCBbXSAgICAtPiByYWlzZSBFbXB0eVxuXG5sZXQgdG9wX29wdCBzID1cbiAgbWF0Y2ggcy5jIHdpdGhcbiAgfCBoZDo6XyAtPiBTb21lIGhkXG4gIHwgW10gICAgLT4gTm9uZVxuXG5sZXQgaXNfZW1wdHkgcyA9IChzLmMgPSBbXSlcblxubGV0IGxlbmd0aCBzID0gcy5sZW5cblxubGV0IGl0ZXIgZiBzID0gTGlzdC5pdGVyIGYgcy5jXG5cbmxldCBmb2xkIGYgYWNjIHMgPSBMaXN0LmZvbGRfbGVmdCBmIGFjYyBzLmNcblxuKCoqIHsxIEl0ZXJhdG9yc30gKilcblxubGV0IHRvX3NlcSBzID0gTGlzdC50b19zZXEgcy5jXG5cbmxldCBhZGRfc2VxIHEgaSA9IFNlcS5pdGVyIChmdW4geCAtPiBwdXNoIHggcSkgaVxuXG5sZXQgb2Zfc2VxIGcgPVxuICBsZXQgcyA9IGNyZWF0ZSgpIGluXG4gIGFkZF9zZXEgcyBnO1xuICBzXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgIEZyYW5jb2lzIFBvdHRpZXIsIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgIEplcmVtaWUgRGltaW5vLCBKYW5lIFN0cmVldCBFdXJvcGUgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDAyIEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbmV4Y2VwdGlvbiBFbXB0eVxuXG50eXBlICdhIGNlbGwgPVxuICB8IE5pbFxuICB8IENvbnMgb2YgeyBjb250ZW50OiAnYTsgbXV0YWJsZSBuZXh0OiAnYSBjZWxsIH1cblxudHlwZSAnYSB0ID0ge1xuICBtdXRhYmxlIGxlbmd0aDogaW50O1xuICBtdXRhYmxlIGZpcnN0OiAnYSBjZWxsO1xuICBtdXRhYmxlIGxhc3Q6ICdhIGNlbGxcbn1cblxubGV0IGNyZWF0ZSAoKSA9IHtcbiAgbGVuZ3RoID0gMDtcbiAgZmlyc3QgPSBOaWw7XG4gIGxhc3QgPSBOaWxcbn1cblxubGV0IGNsZWFyIHEgPVxuICBxLmxlbmd0aCA8LSAwO1xuICBxLmZpcnN0IDwtIE5pbDtcbiAgcS5sYXN0IDwtIE5pbFxuXG5sZXQgYWRkIHggcSA9XG4gIGxldCBjZWxsID0gQ29ucyB7XG4gICAgY29udGVudCA9IHg7XG4gICAgbmV4dCA9IE5pbFxuICB9IGluXG4gIG1hdGNoIHEubGFzdCB3aXRoXG4gIHwgTmlsIC0+XG4gICAgcS5sZW5ndGggPC0gMTtcbiAgICBxLmZpcnN0IDwtIGNlbGw7XG4gICAgcS5sYXN0IDwtIGNlbGxcbiAgfCBDb25zIGxhc3QgLT5cbiAgICBxLmxlbmd0aCA8LSBxLmxlbmd0aCArIDE7XG4gICAgbGFzdC5uZXh0IDwtIGNlbGw7XG4gICAgcS5sYXN0IDwtIGNlbGxcblxubGV0IHB1c2ggPVxuICBhZGRcblxubGV0IHBlZWsgcSA9XG4gIG1hdGNoIHEuZmlyc3Qgd2l0aFxuICB8IE5pbCAtPiByYWlzZSBFbXB0eVxuICB8IENvbnMgeyBjb250ZW50IH0gLT4gY29udGVudFxuXG5sZXQgcGVla19vcHQgcSA9XG4gIG1hdGNoIHEuZmlyc3Qgd2l0aFxuICB8IE5pbCAtPiBOb25lXG4gIHwgQ29ucyB7IGNvbnRlbnQgfSAtPiBTb21lIGNvbnRlbnRcblxubGV0IHRvcCA9XG4gIHBlZWtcblxubGV0IHRha2UgcSA9XG4gIG1hdGNoIHEuZmlyc3Qgd2l0aFxuICB8IE5pbCAtPiByYWlzZSBFbXB0eVxuICB8IENvbnMgeyBjb250ZW50OyBuZXh0ID0gTmlsIH0gLT5cbiAgICBjbGVhciBxO1xuICAgIGNvbnRlbnRcbiAgfCBDb25zIHsgY29udGVudDsgbmV4dCB9IC0+XG4gICAgcS5sZW5ndGggPC0gcS5sZW5ndGggLSAxO1xuICAgIHEuZmlyc3QgPC0gbmV4dDtcbiAgICBjb250ZW50XG5cbmxldCB0YWtlX29wdCBxID1cbiAgbWF0Y2ggcS5maXJzdCB3aXRoXG4gIHwgTmlsIC0+IE5vbmVcbiAgfCBDb25zIHsgY29udGVudDsgbmV4dCA9IE5pbCB9IC0+XG4gICAgY2xlYXIgcTtcbiAgICBTb21lIGNvbnRlbnRcbiAgfCBDb25zIHsgY29udGVudDsgbmV4dCB9IC0+XG4gICAgcS5sZW5ndGggPC0gcS5sZW5ndGggLSAxO1xuICAgIHEuZmlyc3QgPC0gbmV4dDtcbiAgICBTb21lIGNvbnRlbnRcblxubGV0IHBvcCA9XG4gIHRha2VcblxubGV0IGNvcHkgPVxuICBsZXQgcmVjIGNvcHkgcV9yZXMgcHJldiBjZWxsID1cbiAgICBtYXRjaCBjZWxsIHdpdGhcbiAgICB8IE5pbCAtPiBxX3Jlcy5sYXN0IDwtIHByZXY7IHFfcmVzXG4gICAgfCBDb25zIHsgY29udGVudDsgbmV4dCB9IC0+XG4gICAgICBsZXQgcmVzID0gQ29ucyB7IGNvbnRlbnQ7IG5leHQgPSBOaWwgfSBpblxuICAgICAgYmVnaW4gbWF0Y2ggcHJldiB3aXRoXG4gICAgICB8IE5pbCAtPiBxX3Jlcy5maXJzdCA8LSByZXNcbiAgICAgIHwgQ29ucyBwIC0+IHAubmV4dCA8LSByZXNcbiAgICAgIGVuZDtcbiAgICAgIGNvcHkgcV9yZXMgcmVzIG5leHRcbiAgaW5cbiAgZnVuIHEgLT4gY29weSB7IGxlbmd0aCA9IHEubGVuZ3RoOyBmaXJzdCA9IE5pbDsgbGFzdCA9IE5pbCB9IE5pbCBxLmZpcnN0XG5cbmxldCBpc19lbXB0eSBxID1cbiAgcS5sZW5ndGggPSAwXG5cbmxldCBsZW5ndGggcSA9XG4gIHEubGVuZ3RoXG5cbmxldCBpdGVyID1cbiAgbGV0IHJlYyBpdGVyIGYgY2VsbCA9XG4gICAgbWF0Y2ggY2VsbCB3aXRoXG4gICAgfCBOaWwgLT4gKClcbiAgICB8IENvbnMgeyBjb250ZW50OyBuZXh0IH0gLT5cbiAgICAgIGYgY29udGVudDtcbiAgICAgIGl0ZXIgZiBuZXh0XG4gIGluXG4gIGZ1biBmIHEgLT4gaXRlciBmIHEuZmlyc3RcblxubGV0IGZvbGQgPVxuICBsZXQgcmVjIGZvbGQgZiBhY2N1IGNlbGwgPVxuICAgIG1hdGNoIGNlbGwgd2l0aFxuICAgIHwgTmlsIC0+IGFjY3VcbiAgICB8IENvbnMgeyBjb250ZW50OyBuZXh0IH0gLT5cbiAgICAgIGxldCBhY2N1ID0gZiBhY2N1IGNvbnRlbnQgaW5cbiAgICAgIGZvbGQgZiBhY2N1IG5leHRcbiAgaW5cbiAgZnVuIGYgYWNjdSBxIC0+IGZvbGQgZiBhY2N1IHEuZmlyc3RcblxubGV0IHRyYW5zZmVyIHExIHEyID1cbiAgaWYgcTEubGVuZ3RoID4gMCB0aGVuXG4gICAgbWF0Y2ggcTIubGFzdCB3aXRoXG4gICAgfCBOaWwgLT5cbiAgICAgIHEyLmxlbmd0aCA8LSBxMS5sZW5ndGg7XG4gICAgICBxMi5maXJzdCA8LSBxMS5maXJzdDtcbiAgICAgIHEyLmxhc3QgPC0gcTEubGFzdDtcbiAgICAgIGNsZWFyIHExXG4gICAgfCBDb25zIGxhc3QgLT5cbiAgICAgIHEyLmxlbmd0aCA8LSBxMi5sZW5ndGggKyBxMS5sZW5ndGg7XG4gICAgICBsYXN0Lm5leHQgPC0gcTEuZmlyc3Q7XG4gICAgICBxMi5sYXN0IDwtIHExLmxhc3Q7XG4gICAgICBjbGVhciBxMVxuXG4oKiogezEgSXRlcmF0b3JzfSAqKVxuXG5sZXQgdG9fc2VxIHEgPVxuICBsZXQgcmVjIGF1eCBjICgpID0gbWF0Y2ggYyB3aXRoXG4gICAgfCBOaWwgLT4gU2VxLk5pbFxuICAgIHwgQ29ucyB7IGNvbnRlbnQ9eDsgbmV4dDsgfSAtPiBTZXEuQ29ucyAoeCwgYXV4IG5leHQpXG4gIGluXG4gIGF1eCBxLmZpcnN0XG5cbmxldCBhZGRfc2VxIHEgaSA9IFNlcS5pdGVyIChmdW4geCAtPiBwdXNoIHggcSkgaVxuXG5sZXQgb2Zfc2VxIGcgPVxuICBsZXQgcSA9IGNyZWF0ZSgpIGluXG4gIGFkZF9zZXEgcSBnO1xuICBxXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgIERhbmllbCBkZSBSYXVnbGF1ZHJlLCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk3IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUgJ2EgdCA9ICdhIGNlbGwgb3B0aW9uXG5hbmQgJ2EgY2VsbCA9IHsgbXV0YWJsZSBjb3VudCA6IGludDsgbXV0YWJsZSBkYXRhIDogJ2EgZGF0YSB9XG5hbmQgJ2EgZGF0YSA9XG4gICAgU2VtcHR5XG4gIHwgU2NvbnMgb2YgJ2EgKiAnYSBkYXRhXG4gIHwgU2FwcCBvZiAnYSBkYXRhICogJ2EgZGF0YVxuICB8IFNsYXp5IG9mICdhIGRhdGEgTGF6eS50XG4gIHwgU2dlbiBvZiAnYSBnZW5cbiAgfCBTYnVmZmlvIDogYnVmZmlvIC0+IGNoYXIgZGF0YVxuYW5kICdhIGdlbiA9IHsgbXV0YWJsZSBjdXJyIDogJ2Egb3B0aW9uIG9wdGlvbjsgZnVuYyA6IGludCAtPiAnYSBvcHRpb24gfVxuYW5kIGJ1ZmZpbyA9XG4gIHsgaWMgOiBpbl9jaGFubmVsOyBidWZmIDogYnl0ZXM7IG11dGFibGUgbGVuIDogaW50OyBtdXRhYmxlIGluZCA6IGludCB9XG5cbmV4Y2VwdGlvbiBGYWlsdXJlXG5leGNlcHRpb24gRXJyb3Igb2Ygc3RyaW5nXG5cbmxldCBjb3VudCA9IGZ1bmN0aW9uXG4gIHwgTm9uZSAtPiAwXG4gIHwgU29tZSB7IGNvdW50IH0gLT4gY291bnRcbmxldCBkYXRhID0gZnVuY3Rpb25cbiAgfCBOb25lIC0+IFNlbXB0eVxuICB8IFNvbWUgeyBkYXRhIH0gLT4gZGF0YVxuXG5sZXQgZmlsbF9idWZmIGIgPVxuICBiLmxlbiA8LSBpbnB1dCBiLmljIGIuYnVmZiAwIChCeXRlcy5sZW5ndGggYi5idWZmKTsgYi5pbmQgPC0gMFxuXG5cbmxldCByZWMgZ2V0X2RhdGEgOiB0eXBlIHYuIGludCAtPiB2IGRhdGEgLT4gdiBkYXRhID0gZnVuIGNvdW50IGQgLT4gbWF0Y2ggZCB3aXRoXG4gKCogUmV0dXJucyBlaXRoZXIgU2VtcHR5IG9yIFNjb25zKGEsIF8pIGV2ZW4gd2hlbiBkIGlzIGEgZ2VuZXJhdG9yXG4gICAgb3IgYSBidWZmZXIuIEluIHRob3NlIGNhc2VzLCB0aGUgaXRlbSBhIGlzIHNlZW4gYXMgZXh0cmFjdGVkIGZyb21cbiB0aGUgZ2VuZXJhdG9yL2J1ZmZlci5cbiBUaGUgY291bnQgcGFyYW1ldGVyIGlzIHVzZWQgZm9yIGNhbGxpbmcgYFNnZW4tZnVuY3Rpb25zJy4gICopXG4gICBTZW1wdHkgfCBTY29ucyAoXywgXykgLT4gZFxuIHwgU2FwcCAoZDEsIGQyKSAtPlxuICAgICBiZWdpbiBtYXRjaCBnZXRfZGF0YSBjb3VudCBkMSB3aXRoXG4gICAgICAgU2NvbnMgKGEsIGQxMSkgLT4gU2NvbnMgKGEsIFNhcHAgKGQxMSwgZDIpKVxuICAgICB8IFNlbXB0eSAtPiBnZXRfZGF0YSBjb3VudCBkMlxuICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG4gICAgIGVuZFxuIHwgU2dlbiB7Y3VyciA9IFNvbWUgTm9uZX0gLT4gU2VtcHR5XG4gfCBTZ2VuICh7Y3VyciA9IFNvbWUoU29tZSBhKX0gYXMgZykgLT5cbiAgICAgZy5jdXJyIDwtIE5vbmU7IFNjb25zKGEsIGQpXG4gfCBTZ2VuIGcgLT5cbiAgICAgYmVnaW4gbWF0Y2ggZy5mdW5jIGNvdW50IHdpdGhcbiAgICAgICBOb25lIC0+IGcuY3VyciA8LSBTb21lKE5vbmUpOyBTZW1wdHlcbiAgICAgfCBTb21lIGEgLT4gU2NvbnMoYSwgZClcbiAgICAgICAgICgqIFdhcm5pbmc6IGFueW9uZSB1c2luZyBnIHRoaW5rcyB0aGF0IGFuIGl0ZW0gaGFzIGJlZW4gcmVhZCAqKVxuICAgICBlbmRcbiB8IFNidWZmaW8gYiAtPlxuICAgICBpZiBiLmluZCA+PSBiLmxlbiB0aGVuIGZpbGxfYnVmZiBiO1xuICAgICBpZiBiLmxlbiA9PSAwIHRoZW4gU2VtcHR5IGVsc2VcbiAgICAgICBsZXQgciA9IEJ5dGVzLnVuc2FmZV9nZXQgYi5idWZmIGIuaW5kIGluXG4gICAgICAgKCogV2FybmluZzogYW55b25lIHVzaW5nIGcgdGhpbmtzIHRoYXQgYW4gaXRlbSBoYXMgYmVlbiByZWFkICopXG4gICAgICAgYi5pbmQgPC0gc3VjYyBiLmluZDsgU2NvbnMociwgZClcbiB8IFNsYXp5IGYgLT4gZ2V0X2RhdGEgY291bnQgKExhenkuZm9yY2UgZilcblxuXG5sZXQgcmVjIHBlZWtfZGF0YSA6IHR5cGUgdi4gdiBjZWxsIC0+IHYgb3B0aW9uID0gZnVuIHMgLT5cbiAoKiBjb25zdWx0IHRoZSBmaXJzdCBpdGVtIG9mIHMgKilcbiBtYXRjaCBzLmRhdGEgd2l0aFxuICAgU2VtcHR5IC0+IE5vbmVcbiB8IFNjb25zIChhLCBfKSAtPiBTb21lIGFcbiB8IFNhcHAgKF8sIF8pIC0+XG4gICAgIGJlZ2luIG1hdGNoIGdldF9kYXRhIHMuY291bnQgcy5kYXRhIHdpdGhcbiAgICAgICBTY29ucyhhLCBfKSBhcyBkIC0+IHMuZGF0YSA8LSBkOyBTb21lIGFcbiAgICAgfCBTZW1wdHkgLT4gTm9uZVxuICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG4gICAgIGVuZFxuIHwgU2xhenkgZiAtPiBzLmRhdGEgPC0gKExhenkuZm9yY2UgZik7IHBlZWtfZGF0YSBzXG4gfCBTZ2VuIHtjdXJyID0gU29tZSBhfSAtPiBhXG4gfCBTZ2VuIGcgLT4gbGV0IHggPSBnLmZ1bmMgcy5jb3VudCBpbiBnLmN1cnIgPC0gU29tZSB4OyB4XG4gfCBTYnVmZmlvIGIgLT5cbiAgICAgaWYgYi5pbmQgPj0gYi5sZW4gdGhlbiBmaWxsX2J1ZmYgYjtcbiAgICAgaWYgYi5sZW4gPT0gMCB0aGVuIGJlZ2luIHMuZGF0YSA8LSBTZW1wdHk7IE5vbmUgZW5kXG4gICAgIGVsc2UgU29tZSAoQnl0ZXMudW5zYWZlX2dldCBiLmJ1ZmYgYi5pbmQpXG5cblxubGV0IHBlZWsgPSBmdW5jdGlvblxuICB8IE5vbmUgLT4gTm9uZVxuICB8IFNvbWUgcyAtPiBwZWVrX2RhdGEgc1xuXG5cbmxldCByZWMganVua19kYXRhIDogdHlwZSB2LiB2IGNlbGwgLT4gdW5pdCA9IGZ1biBzIC0+XG4gIG1hdGNoIHMuZGF0YSB3aXRoXG4gICAgU2NvbnMgKF8sIGQpIC0+IHMuY291bnQgPC0gKHN1Y2Mgcy5jb3VudCk7IHMuZGF0YSA8LSBkXG4gIHwgU2dlbiAoe2N1cnIgPSBTb21lIF99IGFzIGcpIC0+IHMuY291bnQgPC0gKHN1Y2Mgcy5jb3VudCk7IGcuY3VyciA8LSBOb25lXG4gIHwgU2J1ZmZpbyBiIC0+XG4gICAgICBpZiBiLmluZCA+PSBiLmxlbiB0aGVuIGZpbGxfYnVmZiBiO1xuICAgICAgaWYgYi5sZW4gPT0gMCB0aGVuIHMuZGF0YSA8LSBTZW1wdHlcbiAgICAgIGVsc2UgKHMuY291bnQgPC0gKHN1Y2Mgcy5jb3VudCk7IGIuaW5kIDwtIHN1Y2MgYi5pbmQpXG4gIHwgXyAtPlxuICAgICAgbWF0Y2ggcGVla19kYXRhIHMgd2l0aFxuICAgICAgICBOb25lIC0+ICgpXG4gICAgICB8IFNvbWUgXyAtPiBqdW5rX2RhdGEgc1xuXG5cbmxldCBqdW5rID0gZnVuY3Rpb25cbiAgfCBOb25lIC0+ICgpXG4gIHwgU29tZSBkYXRhIC0+IGp1bmtfZGF0YSBkYXRhXG5cbmxldCByZWMgbmdldF9kYXRhIG4gcyA9XG4gIGlmIG4gPD0gMCB0aGVuIFtdLCBzLmRhdGEsIDBcbiAgZWxzZVxuICAgIG1hdGNoIHBlZWtfZGF0YSBzIHdpdGhcbiAgICAgIFNvbWUgYSAtPlxuICAgICAgICBqdW5rX2RhdGEgcztcbiAgICAgICAgbGV0IChhbCwgZCwgaykgPSBuZ2V0X2RhdGEgKHByZWQgbikgcyBpbiBhIDo6IGFsLCBTY29ucyAoYSwgZCksIHN1Y2Mga1xuICAgIHwgTm9uZSAtPiBbXSwgcy5kYXRhLCAwXG5cblxubGV0IG5wZWVrX2RhdGEgbiBzID1cbiAgbGV0IChhbCwgZCwgbGVuKSA9IG5nZXRfZGF0YSBuIHMgaW5cbiAgcy5jb3VudCA8LSAocy5jb3VudCAtIGxlbik7XG4gIHMuZGF0YSA8LSBkO1xuICBhbFxuXG5cbmxldCBucGVlayBuID0gZnVuY3Rpb25cbiAgfCBOb25lIC0+IFtdXG4gIHwgU29tZSBkIC0+IG5wZWVrX2RhdGEgbiBkXG5cbmxldCBuZXh0IHMgPVxuICBtYXRjaCBwZWVrIHMgd2l0aFxuICAgIFNvbWUgYSAtPiBqdW5rIHM7IGFcbiAgfCBOb25lIC0+IHJhaXNlIEZhaWx1cmVcblxuXG5sZXQgZW1wdHkgcyA9XG4gIG1hdGNoIHBlZWsgcyB3aXRoXG4gICAgU29tZSBfIC0+IHJhaXNlIEZhaWx1cmVcbiAgfCBOb25lIC0+ICgpXG5cblxubGV0IGl0ZXIgZiBzdHJtID1cbiAgbGV0IHJlYyBkb19yZWMgKCkgPVxuICAgIG1hdGNoIHBlZWsgc3RybSB3aXRoXG4gICAgICBTb21lIGEgLT4ganVuayBzdHJtOyBpZ25vcmUoZiBhKTsgZG9fcmVjICgpXG4gICAgfCBOb25lIC0+ICgpXG4gIGluXG4gIGRvX3JlYyAoKVxuXG5cbigqIFN0cmVhbSBidWlsZGluZyBmdW5jdGlvbnMgKilcblxubGV0IGZyb20gZiA9IFNvbWUge2NvdW50ID0gMDsgZGF0YSA9IFNnZW4ge2N1cnIgPSBOb25lOyBmdW5jID0gZn19XG5cbmxldCBvZl9saXN0IGwgPVxuICBTb21lIHtjb3VudCA9IDA7IGRhdGEgPSBMaXN0LmZvbGRfcmlnaHQgKGZ1biB4IGwgLT4gU2NvbnMgKHgsIGwpKSBsIFNlbXB0eX1cblxuXG5sZXQgb2Zfc3RyaW5nIHMgPVxuICBsZXQgY291bnQgPSByZWYgMCBpblxuICBmcm9tIChmdW4gXyAtPlxuICAgICgqIFdlIGNhbm5vdCB1c2UgdGhlIGluZGV4IHBhc3NlZCBieSB0aGUgW2Zyb21dIGZ1bmN0aW9uIGRpcmVjdGx5XG4gICAgICAgYmVjYXVzZSBpdCByZXR1cm5zIHRoZSBjdXJyZW50IHN0cmVhbSBjb3VudCwgd2l0aCBhYnNvbHV0ZWx5IG5vXG4gICAgICAgZ3VhcmFudGVlIHRoYXQgaXQgd2lsbCBzdGFydCBmcm9tIDAuIEZvciBleGFtcGxlLCBpbiB0aGUgY2FzZVxuICAgICAgIG9mIFtTdHJlYW0uaWNvbnMgJ2MnIChTdHJlYW0uZnJvbV9zdHJpbmcgXCJhYlwiKV0sIHRoZSBmaXJzdFxuICAgICAgIGFjY2VzcyB0byB0aGUgc3RyaW5nIHdpbGwgYmUgbWFkZSB3aXRoIGNvdW50IFsxXSBhbHJlYWR5LlxuICAgICopXG4gICAgbGV0IGMgPSAhY291bnQgaW5cbiAgICBpZiBjIDwgU3RyaW5nLmxlbmd0aCBzXG4gICAgdGhlbiAoaW5jciBjb3VudDsgU29tZSBzLltjXSlcbiAgICBlbHNlIE5vbmUpXG5cblxubGV0IG9mX2J5dGVzIHMgPVxuICBsZXQgY291bnQgPSByZWYgMCBpblxuICBmcm9tIChmdW4gXyAtPlxuICAgIGxldCBjID0gIWNvdW50IGluXG4gICAgaWYgYyA8IEJ5dGVzLmxlbmd0aCBzXG4gICAgdGhlbiAoaW5jciBjb3VudDsgU29tZSAoQnl0ZXMuZ2V0IHMgYykpXG4gICAgZWxzZSBOb25lKVxuXG5cbmxldCBvZl9jaGFubmVsIGljID1cbiAgU29tZSB7Y291bnQgPSAwO1xuICAgICAgICBkYXRhID0gU2J1ZmZpbyB7aWMgPSBpYzsgYnVmZiA9IEJ5dGVzLmNyZWF0ZSA0MDk2OyBsZW4gPSAwOyBpbmQgPSAwfX1cblxuXG4oKiBTdHJlYW0gZXhwcmVzc2lvbnMgYnVpbGRlcnMgKilcblxubGV0IGlhcHAgaSBzID0gU29tZSB7Y291bnQgPSAwOyBkYXRhID0gU2FwcCAoZGF0YSBpLCBkYXRhIHMpfVxubGV0IGljb25zIGkgcyA9IFNvbWUge2NvdW50ID0gMDsgZGF0YSA9IFNjb25zIChpLCBkYXRhIHMpfVxubGV0IGlzaW5nIGkgPSBTb21lIHtjb3VudCA9IDA7IGRhdGEgPSBTY29ucyAoaSwgU2VtcHR5KX1cblxubGV0IGxhcHAgZiBzID1cbiAgU29tZSB7Y291bnQgPSAwOyBkYXRhID0gU2xhenkgKGxhenkoU2FwcCAoZGF0YSAoZiAoKSksIGRhdGEgcykpKX1cblxubGV0IGxjb25zIGYgcyA9IFNvbWUge2NvdW50ID0gMDsgZGF0YSA9IFNsYXp5IChsYXp5KFNjb25zIChmICgpLCBkYXRhIHMpKSl9XG5sZXQgbHNpbmcgZiA9IFNvbWUge2NvdW50ID0gMDsgZGF0YSA9IFNsYXp5IChsYXp5KFNjb25zIChmICgpLCBTZW1wdHkpKSl9XG5cbmxldCBzZW1wdHkgPSBOb25lXG5sZXQgc2xhenkgZiA9IFNvbWUge2NvdW50ID0gMDsgZGF0YSA9IFNsYXp5IChsYXp5KGRhdGEgKGYgKCkpKSl9XG5cbigqIEZvciBkZWJ1Z2dpbmcgdXNlICopXG5cbmxldCByZWMgZHVtcCA6IHR5cGUgdi4gKHYgLT4gdW5pdCkgLT4gdiB0IC0+IHVuaXQgPSBmdW4gZiBzIC0+XG4gIHByaW50X3N0cmluZyBcIntjb3VudCA9IFwiO1xuICBwcmludF9pbnQgKGNvdW50IHMpO1xuICBwcmludF9zdHJpbmcgXCI7IGRhdGEgPSBcIjtcbiAgZHVtcF9kYXRhIGYgKGRhdGEgcyk7XG4gIHByaW50X3N0cmluZyBcIn1cIjtcbiAgcHJpbnRfbmV3bGluZSAoKVxuYW5kIGR1bXBfZGF0YSA6IHR5cGUgdi4gKHYgLT4gdW5pdCkgLT4gdiBkYXRhIC0+IHVuaXQgPSBmdW4gZiAtPlxuICBmdW5jdGlvblxuICAgIFNlbXB0eSAtPiBwcmludF9zdHJpbmcgXCJTZW1wdHlcIlxuICB8IFNjb25zIChhLCBkKSAtPlxuICAgICAgcHJpbnRfc3RyaW5nIFwiU2NvbnMgKFwiO1xuICAgICAgZiBhO1xuICAgICAgcHJpbnRfc3RyaW5nIFwiLCBcIjtcbiAgICAgIGR1bXBfZGF0YSBmIGQ7XG4gICAgICBwcmludF9zdHJpbmcgXCIpXCJcbiAgfCBTYXBwIChkMSwgZDIpIC0+XG4gICAgICBwcmludF9zdHJpbmcgXCJTYXBwIChcIjtcbiAgICAgIGR1bXBfZGF0YSBmIGQxO1xuICAgICAgcHJpbnRfc3RyaW5nIFwiLCBcIjtcbiAgICAgIGR1bXBfZGF0YSBmIGQyO1xuICAgICAgcHJpbnRfc3RyaW5nIFwiKVwiXG4gIHwgU2xhenkgXyAtPiBwcmludF9zdHJpbmcgXCJTbGF6eVwiXG4gIHwgU2dlbiBfIC0+IHByaW50X3N0cmluZyBcIlNnZW5cIlxuICB8IFNidWZmaW8gXyAtPiBwcmludF9zdHJpbmcgXCJTYnVmZmlvXCJcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgIFBpZXJyZSBXZWlzIGFuZCBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTkgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogRXh0ZW5zaWJsZSBidWZmZXJzICopXG5cbnR5cGUgdCA9XG4ge211dGFibGUgYnVmZmVyIDogYnl0ZXM7XG4gIG11dGFibGUgcG9zaXRpb24gOiBpbnQ7XG4gIG11dGFibGUgbGVuZ3RoIDogaW50O1xuICBpbml0aWFsX2J1ZmZlciA6IGJ5dGVzfVxuKCogSW52YXJpYW50czogYWxsIHBhcnRzIG9mIHRoZSBjb2RlIHByZXNlcnZlIHRoZSBpbnZhcmlhbnRzIHRoYXQ6XG4gICAtIFswIDw9IGIucG9zaXRpb24gPD0gYi5sZW5ndGhdXG4gICAtIFtiLmxlbmd0aCA9IEJ5dGVzLmxlbmd0aCBiLmJ1ZmZlcl1cblxuICAgTm90ZSBpbiBwYXJ0aWN1bGFyIHRoYXQgW2IucG9zaXRpb24gPSBiLmxlbmd0aF0gaXMgbGVnYWwsXG4gICBpdCBtZWFucyB0aGF0IHRoZSBidWZmZXIgaXMgZnVsbCBhbmQgd2lsbCBoYXZlIHRvIGJlIGV4dGVuZGVkXG4gICBiZWZvcmUgYW55IGZ1cnRoZXIgYWRkaXRpb24uICopXG5cbmxldCBjcmVhdGUgbiA9XG4gbGV0IG4gPSBpZiBuIDwgMSB0aGVuIDEgZWxzZSBuIGluXG4gbGV0IG4gPSBpZiBuID4gU3lzLm1heF9zdHJpbmdfbGVuZ3RoIHRoZW4gU3lzLm1heF9zdHJpbmdfbGVuZ3RoIGVsc2UgbiBpblxuIGxldCBzID0gQnl0ZXMuY3JlYXRlIG4gaW5cbiB7YnVmZmVyID0gczsgcG9zaXRpb24gPSAwOyBsZW5ndGggPSBuOyBpbml0aWFsX2J1ZmZlciA9IHN9XG5cbmxldCBjb250ZW50cyBiID0gQnl0ZXMuc3ViX3N0cmluZyBiLmJ1ZmZlciAwIGIucG9zaXRpb25cbmxldCB0b19ieXRlcyBiID0gQnl0ZXMuc3ViIGIuYnVmZmVyIDAgYi5wb3NpdGlvblxuXG5sZXQgc3ViIGIgb2ZzIGxlbiA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBiLnBvc2l0aW9uIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJCdWZmZXIuc3ViXCJcbiAgZWxzZSBCeXRlcy5zdWJfc3RyaW5nIGIuYnVmZmVyIG9mcyBsZW5cblxuXG5sZXQgYmxpdCBzcmMgc3Jjb2ZmIGRzdCBkc3RvZmYgbGVuID1cbiAgaWYgbGVuIDwgMCB8fCBzcmNvZmYgPCAwIHx8IHNyY29mZiA+IHNyYy5wb3NpdGlvbiAtIGxlblxuICAgICAgICAgICAgIHx8IGRzdG9mZiA8IDAgfHwgZHN0b2ZmID4gKEJ5dGVzLmxlbmd0aCBkc3QpIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJCdWZmZXIuYmxpdFwiXG4gIGVsc2VcbiAgICBCeXRlcy51bnNhZmVfYmxpdCBzcmMuYnVmZmVyIHNyY29mZiBkc3QgZHN0b2ZmIGxlblxuXG5cbmxldCBudGggYiBvZnMgPVxuICBpZiBvZnMgPCAwIHx8IG9mcyA+PSBiLnBvc2l0aW9uIHRoZW5cbiAgIGludmFsaWRfYXJnIFwiQnVmZmVyLm50aFwiXG4gIGVsc2UgQnl0ZXMudW5zYWZlX2dldCBiLmJ1ZmZlciBvZnNcblxuXG5sZXQgbGVuZ3RoIGIgPSBiLnBvc2l0aW9uXG5cbmxldCBjbGVhciBiID0gYi5wb3NpdGlvbiA8LSAwXG5cbmxldCByZXNldCBiID1cbiAgYi5wb3NpdGlvbiA8LSAwO1xuICBiLmJ1ZmZlciA8LSBiLmluaXRpYWxfYnVmZmVyO1xuICBiLmxlbmd0aCA8LSBCeXRlcy5sZW5ndGggYi5idWZmZXJcblxuKCogW3Jlc2l6ZSBiIG1vcmVdIGVuc3VyZXMgdGhhdCBbYi5wb3NpdGlvbiArIG1vcmUgPD0gYi5sZW5ndGhdIGhvbGRzXG4gICBieSBkeW5hbWljYWxseSBleHRlbmRpbmcgW2IuYnVmZmVyXSBpZiBuZWNlc3NhcnkgLS0gYW5kIHRodXNcbiAgIGluY3JlYXNpbmcgW2IubGVuZ3RoXS5cblxuICAgSW4gcGFydGljdWxhciwgYWZ0ZXIgW3Jlc2l6ZSBiIG1vcmVdIGlzIGNhbGxlZCwgYSBkaXJlY3QgYWNjZXNzIG9mXG4gICBzaXplIFttb3JlXSBhdCBbYi5wb3NpdGlvbl0gd2lsbCBhbHdheXMgYmUgaW4tYm91bmRzLCBzbyB0aGF0XG4gICAodW5zYWZlX3tnZXQsc2V0fSkgbWF5IGJlIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxuKilcbmxldCByZXNpemUgYiBtb3JlID1cbiAgbGV0IG9sZF9wb3MgPSBiLnBvc2l0aW9uIGluXG4gIGxldCBvbGRfbGVuID0gYi5sZW5ndGggaW5cbiAgbGV0IG5ld19sZW4gPSByZWYgb2xkX2xlbiBpblxuICB3aGlsZSBvbGRfcG9zICsgbW9yZSA+ICFuZXdfbGVuIGRvIG5ld19sZW4gOj0gMiAqICFuZXdfbGVuIGRvbmU7XG4gIGlmICFuZXdfbGVuID4gU3lzLm1heF9zdHJpbmdfbGVuZ3RoIHRoZW4gYmVnaW5cbiAgICBpZiBvbGRfcG9zICsgbW9yZSA8PSBTeXMubWF4X3N0cmluZ19sZW5ndGhcbiAgICB0aGVuIG5ld19sZW4gOj0gU3lzLm1heF9zdHJpbmdfbGVuZ3RoXG4gICAgZWxzZSBmYWlsd2l0aCBcIkJ1ZmZlci5hZGQ6IGNhbm5vdCBncm93IGJ1ZmZlclwiXG4gIGVuZDtcbiAgbGV0IG5ld19idWZmZXIgPSBCeXRlcy5jcmVhdGUgIW5ld19sZW4gaW5cbiAgKCogUFIjNjE0ODogbGV0J3Mga2VlcCB1c2luZyBbYmxpdF0gcmF0aGVyIHRoYW4gW3Vuc2FmZV9ibGl0XSBpblxuICAgICB0aGlzIHRyaWNreSBmdW5jdGlvbiB0aGF0IGlzIHNsb3cgYW55d2F5LiAqKVxuICBCeXRlcy5ibGl0IGIuYnVmZmVyIDAgbmV3X2J1ZmZlciAwIGIucG9zaXRpb247XG4gIGIuYnVmZmVyIDwtIG5ld19idWZmZXI7XG4gIGIubGVuZ3RoIDwtICFuZXdfbGVuO1xuICBhc3NlcnQgKGIucG9zaXRpb24gKyBtb3JlIDw9IGIubGVuZ3RoKTtcbiAgYXNzZXJ0IChvbGRfcG9zICsgbW9yZSA8PSBiLmxlbmd0aCk7XG4gICgpXG4gICgqIE5vdGU6IHRoZXJlIGFyZSB2YXJpb3VzIHNpdHVhdGlvbnMgKHByZWVtcHRpdmUgdGhyZWFkcywgc2lnbmFscyBhbmRcbiAgICAgZ2MgZmluYWxpemVycykgd2hlcmUgT0NhbWwgY29kZSBtYXkgYmUgcnVuIGFzeW5jaHJvbm91c2x5OyBpblxuICAgICBwYXJ0aWN1bGFyLCB0aGVyZSBtYXkgYmUgYSByYWNlIHdpdGggYW5vdGhlciB1c2VyIG9mIFtiXSwgY2hhbmdpbmdcbiAgICAgaXRzIG11dGFibGUgZmllbGRzIGluIHRoZSBtaWRkbGUgb2YgdGhlIFtyZXNpemVdIGNhbGwuIFRoZSBCdWZmZXJcbiAgICAgbW9kdWxlIGRvZXMgbm90IHByb3ZpZGUgYW55IGNvcnJlY3RuZXNzIGd1YXJhbnRlZSBpZiB0aGF0IGhhcHBlbnMsXG4gICAgIGJ1dCB3ZSBtdXN0IHN0aWxsIGVuc3VyZSB0aGF0IHRoZSBkYXRhc3RydWN0dXJlIGludmFyaWFudHMgaG9sZCBmb3JcbiAgICAgbWVtb3J5LXNhZmV0eSAtLSBhcyB3ZSBwbGFuIHRvIHVzZSBbdW5zYWZlX3tnZXQsc2V0fV0uXG5cbiAgICAgVGhlcmUgYXJlIHR3byBwb3RlbnRpYWwgYWxsb2NhdGlvbiBwb2ludHMgaW4gdGhpcyBmdW5jdGlvbixcbiAgICAgW3JlZl0gYW5kIFtCeXRlcy5jcmVhdGVdLCBidXQgYWxsIHJlYWRzIGFuZCB3cml0ZXMgdG8gdGhlIGZpZWxkc1xuICAgICBvZiBbYl0gaGFwcGVuIGJlZm9yZSBib3RoIG9mIHRoZW0gb3IgYWZ0ZXIgYm90aCBvZiB0aGVtLlxuXG4gICAgIFdlIHRoZXJlZm9yZSBhc3N1bWUgdGhhdCBbYi5wb3NpdGlvbl0gbWF5IGNoYW5nZSBhdCB0aGVzZSBhbGxvY2F0aW9ucyxcbiAgICAgYW5kIGNoZWNrIHRoYXQgdGhlIFtiLnBvc2l0aW9uICsgbW9yZSA8PSBiLmxlbmd0aF0gcG9zdGNvbmRpdGlvblxuICAgICBob2xkcyBmb3IgYm90aCB2YWx1ZXMgb2YgW2IucG9zaXRpb25dLCBiZWZvcmUgb3IgYWZ0ZXIgdGhlIGZ1bmN0aW9uXG4gICAgIGlzIGNhbGxlZC4gTW9yZSBwcmVjaXNlbHksIHRoZSBmb2xsb3dpbmcgaW52YXJpYW50cyBtdXN0IGhvbGQgaWYgdGhlXG4gICAgIGZ1bmN0aW9uIHJldHVybnMgY29ycmVjdGx5LCBpbiBhZGRpdGlvbiB0byB0aGUgdXN1YWwgYnVmZmVyIGludmFyaWFudHM6XG4gICAgIC0gW29sZChiLnBvc2l0aW9uKSArIG1vcmUgPD0gbmV3KGIubGVuZ3RoKV1cbiAgICAgLSBbbmV3KGIucG9zaXRpb24pICsgbW9yZSA8PSBuZXcoYi5sZW5ndGgpXVxuICAgICAtIFtvbGQoYi5sZW5ndGgpIDw9IG5ldyhiLmxlbmd0aCldXG5cbiAgICAgTm90ZTogW2IucG9zaXRpb24gKyBtb3JlIDw9IG9sZChiLmxlbmd0aCldIGRvZXMgKm5vdCpcbiAgICAgaG9sZCBpbiBnZW5lcmFsLCBhcyBpdCBpcyBwcmVjaXNlbHkgdGhlIGNhc2Ugd2hlcmUgeW91IG5lZWRcbiAgICAgdG8gY2FsbCBbcmVzaXplXSB0byBpbmNyZWFzZSBbYi5sZW5ndGhdLlxuXG4gICAgIE5vdGU6IFthc3NlcnRdIGFib3ZlIGRvZXMgbm90IG1lYW4gdGhhdCB3ZSBrbm93IHRoZSBjb25kaXRpb25zXG4gICAgIGFsd2F5cyBob2xkLCBidXQgdGhhdCB0aGUgZnVuY3Rpb24gbWF5IHJldHVybiBjb3JyZWN0bHlcbiAgICAgb25seSBpZiB0aGV5IGhvbGQuXG5cbiAgICAgTm90ZTogdGhlIG90aGVyIGZ1bmN0aW9ucyBpbiB0aGlzIG1vZHVsZSBkb2VzIG5vdCBuZWVkXG4gICAgIHRvIGJlIGNoZWNrZWQgd2l0aCB0aGlzIGxldmVsIG9mIHNjcnV0aW55LCBnaXZlbiB0aGF0IHRoZXlcbiAgICAgcmVhZC93cml0ZSB0aGUgYnVmZmVyIGltbWVkaWF0ZWx5IGFmdGVyIGNoZWNraW5nIHRoYXRcbiAgICAgW2IucG9zaXRpb24gKyBtb3JlIDw9IGIubGVuZ3RoXSBob2xkIG9yIGNhbGxpbmcgW3Jlc2l6ZV0uXG4gICopXG5cbmxldCBhZGRfY2hhciBiIGMgPVxuICBsZXQgcG9zID0gYi5wb3NpdGlvbiBpblxuICBpZiBwb3MgPj0gYi5sZW5ndGggdGhlbiByZXNpemUgYiAxO1xuICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIHBvcyBjO1xuICBiLnBvc2l0aW9uIDwtIHBvcyArIDFcblxubGV0IHVjaGFyX3V0Zl84X2J5dGVfbGVuZ3RoX21heCA9IDRcbmxldCB1Y2hhcl91dGZfMTZfYnl0ZV9sZW5ndGhfbWF4ID0gNFxuXG5sZXQgcmVjIGFkZF91dGZfOF91Y2hhciBiIHUgPVxuICBsZXQgcG9zID0gYi5wb3NpdGlvbiBpblxuICBpZiBwb3MgPj0gYi5sZW5ndGggdGhlbiByZXNpemUgYiB1Y2hhcl91dGZfOF9ieXRlX2xlbmd0aF9tYXg7XG4gIGxldCBuID0gQnl0ZXMuc2V0X3V0Zl84X3VjaGFyIGIuYnVmZmVyIHBvcyB1IGluXG4gIGlmIG4gPSAwXG4gIHRoZW4gKHJlc2l6ZSBiIHVjaGFyX3V0Zl84X2J5dGVfbGVuZ3RoX21heDsgYWRkX3V0Zl84X3VjaGFyIGIgdSlcbiAgZWxzZSAoYi5wb3NpdGlvbiA8LSBwb3MgKyBuKVxuXG5sZXQgcmVjIGFkZF91dGZfMTZiZV91Y2hhciBiIHUgPVxuICBsZXQgcG9zID0gYi5wb3NpdGlvbiBpblxuICBpZiBwb3MgPj0gYi5sZW5ndGggdGhlbiByZXNpemUgYiB1Y2hhcl91dGZfMTZfYnl0ZV9sZW5ndGhfbWF4O1xuICBsZXQgbiA9IEJ5dGVzLnNldF91dGZfMTZiZV91Y2hhciBiLmJ1ZmZlciBwb3MgdSBpblxuICBpZiBuID0gMFxuICB0aGVuIChyZXNpemUgYiB1Y2hhcl91dGZfMTZfYnl0ZV9sZW5ndGhfbWF4OyBhZGRfdXRmXzE2YmVfdWNoYXIgYiB1KVxuICBlbHNlIChiLnBvc2l0aW9uIDwtIHBvcyArIG4pXG5cbmxldCByZWMgYWRkX3V0Zl8xNmxlX3VjaGFyIGIgdSA9XG4gIGxldCBwb3MgPSBiLnBvc2l0aW9uIGluXG4gIGlmIHBvcyA+PSBiLmxlbmd0aCB0aGVuIHJlc2l6ZSBiIHVjaGFyX3V0Zl8xNl9ieXRlX2xlbmd0aF9tYXg7XG4gIGxldCBuID0gQnl0ZXMuc2V0X3V0Zl8xNmxlX3VjaGFyIGIuYnVmZmVyIHBvcyB1IGluXG4gIGlmIG4gPSAwXG4gIHRoZW4gKHJlc2l6ZSBiIHVjaGFyX3V0Zl8xNl9ieXRlX2xlbmd0aF9tYXg7IGFkZF91dGZfMTZsZV91Y2hhciBiIHUpXG4gIGVsc2UgKGIucG9zaXRpb24gPC0gcG9zICsgbilcblxubGV0IGFkZF9zdWJzdHJpbmcgYiBzIG9mZnNldCBsZW4gPVxuICBpZiBvZmZzZXQgPCAwIHx8IGxlbiA8IDAgfHwgb2Zmc2V0ID4gU3RyaW5nLmxlbmd0aCBzIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJCdWZmZXIuYWRkX3N1YnN0cmluZy9hZGRfc3ViYnl0ZXNcIjtcbiAgbGV0IG5ld19wb3NpdGlvbiA9IGIucG9zaXRpb24gKyBsZW4gaW5cbiAgaWYgbmV3X3Bvc2l0aW9uID4gYi5sZW5ndGggdGhlbiByZXNpemUgYiBsZW47XG4gIEJ5dGVzLnVuc2FmZV9ibGl0X3N0cmluZyBzIG9mZnNldCBiLmJ1ZmZlciBiLnBvc2l0aW9uIGxlbjtcbiAgYi5wb3NpdGlvbiA8LSBuZXdfcG9zaXRpb25cblxubGV0IGFkZF9zdWJieXRlcyBiIHMgb2Zmc2V0IGxlbiA9XG4gIGFkZF9zdWJzdHJpbmcgYiAoQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBzKSBvZmZzZXQgbGVuXG5cbmxldCBhZGRfc3RyaW5nIGIgcyA9XG4gIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgbGV0IG5ld19wb3NpdGlvbiA9IGIucG9zaXRpb24gKyBsZW4gaW5cbiAgaWYgbmV3X3Bvc2l0aW9uID4gYi5sZW5ndGggdGhlbiByZXNpemUgYiBsZW47XG4gIEJ5dGVzLnVuc2FmZV9ibGl0X3N0cmluZyBzIDAgYi5idWZmZXIgYi5wb3NpdGlvbiBsZW47XG4gIGIucG9zaXRpb24gPC0gbmV3X3Bvc2l0aW9uXG5cbmxldCBhZGRfYnl0ZXMgYiBzID0gYWRkX3N0cmluZyBiIChCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHMpXG5cbmxldCBhZGRfYnVmZmVyIGIgYnMgPVxuICBhZGRfc3ViYnl0ZXMgYiBicy5idWZmZXIgMCBicy5wb3NpdGlvblxuXG4oKiB0aGlzIChwcml2YXRlKSBmdW5jdGlvbiBjb3VsZCBtb3ZlIGludG8gdGhlIHN0YW5kYXJkIGxpYnJhcnkgKilcbmxldCByZWFsbHlfaW5wdXRfdXBfdG8gaWMgYnVmIG9mcyBsZW4gPVxuICBsZXQgcmVjIGxvb3AgaWMgYnVmIH5hbHJlYWR5X3JlYWQgfm9mcyB+dG9fcmVhZCA9XG4gICAgaWYgdG9fcmVhZCA9IDAgdGhlbiBhbHJlYWR5X3JlYWRcbiAgICBlbHNlIGJlZ2luXG4gICAgICBsZXQgciA9IGlucHV0IGljIGJ1ZiBvZnMgdG9fcmVhZCBpblxuICAgICAgaWYgciA9IDAgdGhlbiBhbHJlYWR5X3JlYWRcbiAgICAgIGVsc2UgYmVnaW5cbiAgICAgICAgbGV0IGFscmVhZHlfcmVhZCA9IGFscmVhZHlfcmVhZCArIHIgaW5cbiAgICAgICAgbGV0IG9mcyA9IG9mcyArIHIgaW5cbiAgICAgICAgbGV0IHRvX3JlYWQgPSB0b19yZWFkIC0gciBpblxuICAgICAgICBsb29wIGljIGJ1ZiB+YWxyZWFkeV9yZWFkIH5vZnMgfnRvX3JlYWRcbiAgICAgIGVuZFxuICAgIGVuZFxuICBpbiBsb29wIGljIGJ1ZiB+YWxyZWFkeV9yZWFkOjAgfm9mcyB+dG9fcmVhZDpsZW5cblxuXG5sZXQgdW5zYWZlX2FkZF9jaGFubmVsX3VwX3RvIGIgaWMgbGVuID1cbiAgaWYgYi5wb3NpdGlvbiArIGxlbiA+IGIubGVuZ3RoIHRoZW4gcmVzaXplIGIgbGVuO1xuICBsZXQgbiA9IHJlYWxseV9pbnB1dF91cF90byBpYyBiLmJ1ZmZlciBiLnBvc2l0aW9uIGxlbiBpblxuICAoKiBUaGUgYXNzZXJ0aW9uIGJlbG93IG1heSBmYWlsIGluIHdlaXJkIHNjZW5hcmlvIHdoZXJlXG4gICAgIHRocmVhZGVkL2ZpbmFsaXplciBjb2RlLCBydW4gYXN5bmNocm9ub3VzbHkgZHVyaW5nIHRoZVxuICAgICBbcmVhbGx5X2lucHV0X3VwX3RvXSBjYWxsLCByYWNlcyBvbiB0aGUgYnVmZmVyOyB3ZSBkb24ndCBlbnN1cmVcbiAgICAgY29ycmVjdG5lc3MgaW4gdGhpcyBjYXNlLCBidXQgbmVlZCB0byBwcmVzZXJ2ZSB0aGUgaW52YXJpYW50cyBmb3JcbiAgICAgbWVtb3J5LXNhZmV0eSAoc2VlIGRpc2N1c3Npb24gb2YgW3Jlc2l6ZV0pLiAqKVxuICBhc3NlcnQgKGIucG9zaXRpb24gKyBuIDw9IGIubGVuZ3RoKTtcbiAgYi5wb3NpdGlvbiA8LSBiLnBvc2l0aW9uICsgbjtcbiAgblxuXG5sZXQgYWRkX2NoYW5uZWwgYiBpYyBsZW4gPVxuICBpZiBsZW4gPCAwIHx8IGxlbiA+IFN5cy5tYXhfc3RyaW5nX2xlbmd0aCB0aGVuICAgKCogUFIjNTAwNCAqKVxuICAgIGludmFsaWRfYXJnIFwiQnVmZmVyLmFkZF9jaGFubmVsXCI7XG4gIGxldCBuID0gdW5zYWZlX2FkZF9jaGFubmVsX3VwX3RvIGIgaWMgbGVuIGluXG4gICgqIEl0IGlzIGludGVudGlvbmFsIHRoYXQgYSBjb25zdW1lciBjYXRjaGluZyBFbmRfb2ZfZmlsZVxuICAgICB3aWxsIHNlZSB0aGUgZGF0YSB3cml0dGVuIChzZWUgIzY3MTksICM3MTM2KS4gKilcbiAgaWYgbiA8IGxlbiB0aGVuIHJhaXNlIEVuZF9vZl9maWxlO1xuICAoKVxuXG5sZXQgb3V0cHV0X2J1ZmZlciBvYyBiID1cbiAgb3V0cHV0IG9jIGIuYnVmZmVyIDAgYi5wb3NpdGlvblxuXG5sZXQgY2xvc2luZyA9IGZ1bmN0aW9uXG4gIHwgJygnIC0+ICcpJ1xuICB8ICd7JyAtPiAnfSdcbiAgfCBfIC0+IGFzc2VydCBmYWxzZVxuXG4oKiBvcGVuaW5nIGFuZCBjbG9zaW5nOiBvcGVuIGFuZCBjbG9zZSBjaGFyYWN0ZXJzLCB0eXBpY2FsbHkgKCBhbmQgKVxuICAgazogYmFsYW5jZSBvZiBvcGVuaW5nIGFuZCBjbG9zaW5nIGNoYXJzXG4gICBzOiB0aGUgc3RyaW5nIHdoZXJlIHdlIGFyZSBzZWFyY2hpbmdcbiAgIHN0YXJ0OiB0aGUgaW5kZXggd2hlcmUgd2Ugc3RhcnQgdGhlIHNlYXJjaC4gKilcbmxldCBhZHZhbmNlX3RvX2Nsb3Npbmcgb3BlbmluZyBjbG9zaW5nIGsgcyBzdGFydCA9XG4gIGxldCByZWMgYWR2YW5jZSBrIGkgbGltID1cbiAgICBpZiBpID49IGxpbSB0aGVuIHJhaXNlIE5vdF9mb3VuZCBlbHNlXG4gICAgaWYgcy5baV0gPSBvcGVuaW5nIHRoZW4gYWR2YW5jZSAoayArIDEpIChpICsgMSkgbGltIGVsc2VcbiAgICBpZiBzLltpXSA9IGNsb3NpbmcgdGhlblxuICAgICAgaWYgayA9IDAgdGhlbiBpIGVsc2UgYWR2YW5jZSAoayAtIDEpIChpICsgMSkgbGltXG4gICAgZWxzZSBhZHZhbmNlIGsgKGkgKyAxKSBsaW0gaW5cbiAgYWR2YW5jZSBrIHN0YXJ0IChTdHJpbmcubGVuZ3RoIHMpXG5cbmxldCBhZHZhbmNlX3RvX25vbl9hbHBoYSBzIHN0YXJ0ID1cbiAgbGV0IHJlYyBhZHZhbmNlIGkgbGltID1cbiAgICBpZiBpID49IGxpbSB0aGVuIGxpbSBlbHNlXG4gICAgbWF0Y2ggcy5baV0gd2l0aFxuICAgIHwgJ2EnIC4uICd6JyB8ICdBJyAuLiAnWicgfCAnMCcgLi4gJzknIHwgJ18nIC0+IGFkdmFuY2UgKGkgKyAxKSBsaW1cbiAgICB8IF8gLT4gaSBpblxuICBhZHZhbmNlIHN0YXJ0IChTdHJpbmcubGVuZ3RoIHMpXG5cbigqIFdlIGFyZSBqdXN0IGF0IHRoZSBiZWdpbm5pbmcgb2YgYW4gaWRlbnQgaW4gcywgc3RhcnRpbmcgYXQgc3RhcnQuICopXG5sZXQgZmluZF9pZGVudCBzIHN0YXJ0IGxpbSA9XG4gIGlmIHN0YXJ0ID49IGxpbSB0aGVuIHJhaXNlIE5vdF9mb3VuZCBlbHNlXG4gIG1hdGNoIHMuW3N0YXJ0XSB3aXRoXG4gICgqIFBhcmVudGhlc2l6ZWQgaWRlbnQgPyAqKVxuICB8ICcoJyB8ICd7JyBhcyBjIC0+XG4gICAgIGxldCBuZXdfc3RhcnQgPSBzdGFydCArIDEgaW5cbiAgICAgbGV0IHN0b3AgPSBhZHZhbmNlX3RvX2Nsb3NpbmcgYyAoY2xvc2luZyBjKSAwIHMgbmV3X3N0YXJ0IGluXG4gICAgIFN0cmluZy5zdWIgcyBuZXdfc3RhcnQgKHN0b3AgLSBzdGFydCAtIDEpLCBzdG9wICsgMVxuICAoKiBSZWd1bGFyIGlkZW50ICopXG4gIHwgXyAtPlxuICAgICBsZXQgc3RvcCA9IGFkdmFuY2VfdG9fbm9uX2FscGhhIHMgKHN0YXJ0ICsgMSkgaW5cbiAgICAgU3RyaW5nLnN1YiBzIHN0YXJ0IChzdG9wIC0gc3RhcnQpLCBzdG9wXG5cbigqIFN1YnN0aXR1dGUgJGlkZW50LCAkKGlkZW50KSwgb3IgJHtpZGVudH0gaW4gcyxcbiAgICBhY2NvcmRpbmcgdG8gdGhlIGZ1bmN0aW9uIG1hcHBpbmcgZi4gKilcbmxldCBhZGRfc3Vic3RpdHV0ZSBiIGYgcyA9XG4gIGxldCBsaW0gPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgbGV0IHJlYyBzdWJzdCBwcmV2aW91cyBpID1cbiAgICBpZiBpIDwgbGltIHRoZW4gYmVnaW5cbiAgICAgIG1hdGNoIHMuW2ldIHdpdGhcbiAgICAgIHwgJyQnIGFzIGN1cnJlbnQgd2hlbiBwcmV2aW91cyA9ICdcXFxcJyAtPlxuICAgICAgICAgYWRkX2NoYXIgYiBjdXJyZW50O1xuICAgICAgICAgc3Vic3QgJyAnIChpICsgMSlcbiAgICAgIHwgJyQnIC0+XG4gICAgICAgICBsZXQgaiA9IGkgKyAxIGluXG4gICAgICAgICBsZXQgaWRlbnQsIG5leHRfaSA9IGZpbmRfaWRlbnQgcyBqIGxpbSBpblxuICAgICAgICAgYWRkX3N0cmluZyBiIChmIGlkZW50KTtcbiAgICAgICAgIHN1YnN0ICcgJyBuZXh0X2lcbiAgICAgIHwgY3VycmVudCB3aGVuIHByZXZpb3VzID09ICdcXFxcJyAtPlxuICAgICAgICAgYWRkX2NoYXIgYiAnXFxcXCc7XG4gICAgICAgICBhZGRfY2hhciBiIGN1cnJlbnQ7XG4gICAgICAgICBzdWJzdCAnICcgKGkgKyAxKVxuICAgICAgfCAnXFxcXCcgYXMgY3VycmVudCAtPlxuICAgICAgICAgc3Vic3QgY3VycmVudCAoaSArIDEpXG4gICAgICB8IGN1cnJlbnQgLT5cbiAgICAgICAgIGFkZF9jaGFyIGIgY3VycmVudDtcbiAgICAgICAgIHN1YnN0IGN1cnJlbnQgKGkgKyAxKVxuICAgIGVuZCBlbHNlXG4gICAgaWYgcHJldmlvdXMgPSAnXFxcXCcgdGhlbiBhZGRfY2hhciBiIHByZXZpb3VzIGluXG4gIHN1YnN0ICcgJyAwXG5cbmxldCB0cnVuY2F0ZSBiIGxlbiA9XG4gICAgaWYgbGVuIDwgMCB8fCBsZW4gPiBsZW5ndGggYiB0aGVuXG4gICAgICBpbnZhbGlkX2FyZyBcIkJ1ZmZlci50cnVuY2F0ZVwiXG4gICAgZWxzZVxuICAgICAgYi5wb3NpdGlvbiA8LSBsZW5cblxuKCoqIHsxIEl0ZXJhdG9yc30gKilcblxubGV0IHRvX3NlcSBiID1cbiAgbGV0IHJlYyBhdXggaSAoKSA9XG4gICAgKCogTm90ZSB0aGF0IGIucG9zaXRpb24gaXMgbm90IGEgY29uc3RhbnQgYW5kIGNhbm5vdCBiZSBsaWZ0ZWQgb3V0IG9mIGF1eCAqKVxuICAgIGlmIGkgPj0gYi5wb3NpdGlvbiB0aGVuIFNlcS5OaWxcbiAgICBlbHNlXG4gICAgICBsZXQgeCA9IEJ5dGVzLnVuc2FmZV9nZXQgYi5idWZmZXIgaSBpblxuICAgICAgU2VxLkNvbnMgKHgsIGF1eCAoaSsxKSlcbiAgaW5cbiAgYXV4IDBcblxubGV0IHRvX3NlcWkgYiA9XG4gIGxldCByZWMgYXV4IGkgKCkgPVxuICAgICgqIE5vdGUgdGhhdCBiLnBvc2l0aW9uIGlzIG5vdCBhIGNvbnN0YW50IGFuZCBjYW5ub3QgYmUgbGlmdGVkIG91dCBvZiBhdXggKilcbiAgICBpZiBpID49IGIucG9zaXRpb24gdGhlbiBTZXEuTmlsXG4gICAgZWxzZVxuICAgICAgbGV0IHggPSBCeXRlcy51bnNhZmVfZ2V0IGIuYnVmZmVyIGkgaW5cbiAgICAgIFNlcS5Db25zICgoaSx4KSwgYXV4IChpKzEpKVxuICBpblxuICBhdXggMFxuXG5sZXQgYWRkX3NlcSBiIHNlcSA9IFNlcS5pdGVyIChhZGRfY2hhciBiKSBzZXFcblxubGV0IG9mX3NlcSBpID1cbiAgbGV0IGIgPSBjcmVhdGUgMzIgaW5cbiAgYWRkX3NlcSBiIGk7XG4gIGJcblxuKCoqIHs2IEJpbmFyeSBlbmNvZGluZyBvZiBpbnRlZ2Vyc30gKilcblxuZXh0ZXJuYWwgdW5zYWZlX3NldF9pbnQ4IDogYnl0ZXMgLT4gaW50IC0+IGludCAtPiB1bml0ID0gXCIlYnl0ZXNfdW5zYWZlX3NldFwiXG5leHRlcm5hbCB1bnNhZmVfc2V0X2ludDE2IDogYnl0ZXMgLT4gaW50IC0+IGludCAtPiB1bml0ID0gXCIlY2FtbF9ieXRlc19zZXQxNnVcIlxuZXh0ZXJuYWwgdW5zYWZlX3NldF9pbnQzMiA6IGJ5dGVzIC0+IGludCAtPiBpbnQzMiAtPiB1bml0ID0gXCIlY2FtbF9ieXRlc19zZXQzMnVcIlxuZXh0ZXJuYWwgdW5zYWZlX3NldF9pbnQ2NCA6IGJ5dGVzIC0+IGludCAtPiBpbnQ2NCAtPiB1bml0ID0gXCIlY2FtbF9ieXRlc19zZXQ2NHVcIlxuZXh0ZXJuYWwgc3dhcDE2IDogaW50IC0+IGludCA9IFwiJWJzd2FwMTZcIlxuZXh0ZXJuYWwgc3dhcDMyIDogaW50MzIgLT4gaW50MzIgPSBcIiVic3dhcF9pbnQzMlwiXG5leHRlcm5hbCBzd2FwNjQgOiBpbnQ2NCAtPiBpbnQ2NCA9IFwiJWJzd2FwX2ludDY0XCJcblxuXG5sZXQgYWRkX2ludDggYiB4ID1cbiAgbGV0IG5ld19wb3NpdGlvbiA9IGIucG9zaXRpb24gKyAxIGluXG4gIGlmIG5ld19wb3NpdGlvbiA+IGIubGVuZ3RoIHRoZW4gcmVzaXplIGIgMTtcbiAgdW5zYWZlX3NldF9pbnQ4IGIuYnVmZmVyIGIucG9zaXRpb24geDtcbiAgYi5wb3NpdGlvbiA8LSBuZXdfcG9zaXRpb25cblxubGV0IGFkZF9pbnQxNl9uZSBiIHggPVxuICBsZXQgbmV3X3Bvc2l0aW9uID0gYi5wb3NpdGlvbiArIDIgaW5cbiAgaWYgbmV3X3Bvc2l0aW9uID4gYi5sZW5ndGggdGhlbiByZXNpemUgYiAyO1xuICB1bnNhZmVfc2V0X2ludDE2IGIuYnVmZmVyIGIucG9zaXRpb24geDtcbiAgYi5wb3NpdGlvbiA8LSBuZXdfcG9zaXRpb25cblxubGV0IGFkZF9pbnQzMl9uZSBiIHggPVxuICBsZXQgbmV3X3Bvc2l0aW9uID0gYi5wb3NpdGlvbiArIDQgaW5cbiAgaWYgbmV3X3Bvc2l0aW9uID4gYi5sZW5ndGggdGhlbiByZXNpemUgYiA0O1xuICB1bnNhZmVfc2V0X2ludDMyIGIuYnVmZmVyIGIucG9zaXRpb24geDtcbiAgYi5wb3NpdGlvbiA8LSBuZXdfcG9zaXRpb25cblxubGV0IGFkZF9pbnQ2NF9uZSBiIHggPVxuICBsZXQgbmV3X3Bvc2l0aW9uID0gYi5wb3NpdGlvbiArIDggaW5cbiAgaWYgbmV3X3Bvc2l0aW9uID4gYi5sZW5ndGggdGhlbiByZXNpemUgYiA4O1xuICB1bnNhZmVfc2V0X2ludDY0IGIuYnVmZmVyIGIucG9zaXRpb24geDtcbiAgYi5wb3NpdGlvbiA8LSBuZXdfcG9zaXRpb25cblxubGV0IGFkZF9pbnQxNl9sZSBiIHggPVxuICBhZGRfaW50MTZfbmUgYiAoaWYgU3lzLmJpZ19lbmRpYW4gdGhlbiBzd2FwMTYgeCBlbHNlIHgpXG5cbmxldCBhZGRfaW50MTZfYmUgYiB4ID1cbiAgYWRkX2ludDE2X25lIGIgKGlmIFN5cy5iaWdfZW5kaWFuIHRoZW4geCBlbHNlIHN3YXAxNiB4KVxuXG5sZXQgYWRkX2ludDMyX2xlIGIgeCA9XG4gIGFkZF9pbnQzMl9uZSBiIChpZiBTeXMuYmlnX2VuZGlhbiB0aGVuIHN3YXAzMiB4IGVsc2UgeClcblxubGV0IGFkZF9pbnQzMl9iZSBiIHggPVxuICBhZGRfaW50MzJfbmUgYiAoaWYgU3lzLmJpZ19lbmRpYW4gdGhlbiB4IGVsc2Ugc3dhcDMyIHgpXG5cbmxldCBhZGRfaW50NjRfbGUgYiB4ID1cbiAgYWRkX2ludDY0X25lIGIgKGlmIFN5cy5iaWdfZW5kaWFuIHRoZW4gc3dhcDY0IHggZWxzZSB4KVxuXG5sZXQgYWRkX2ludDY0X2JlIGIgeCA9XG4gIGFkZF9pbnQ2NF9uZSBiIChpZiBTeXMuYmlnX2VuZGlhbiB0aGVuIHggZWxzZSBzd2FwNjQgeClcblxubGV0IGFkZF91aW50OCA9IGFkZF9pbnQ4XG5sZXQgYWRkX3VpbnQxNl9uZSA9IGFkZF9pbnQxNl9uZVxubGV0IGFkZF91aW50MTZfbGUgPSBhZGRfaW50MTZfbGVcbmxldCBhZGRfdWludDE2X2JlID0gYWRkX2ludDE2X2JlXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgQmVub2l0IFZhdWdvbiwgRU5TVEEgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE0IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbm9wZW4gQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICgqIFRvb2xzIHRvIG1hbmlwdWxhdGUgc2Nhbm5pbmcgc2V0IG9mIGNoYXJzIChzZWUgJVsuLi5dKSAqKVxuXG50eXBlIG11dGFibGVfY2hhcl9zZXQgPSBieXRlc1xuXG4oKiBDcmVhdGUgYSBmcmVzaCwgZW1wdHksIG11dGFibGUgY2hhciBzZXQuICopXG5sZXQgY3JlYXRlX2NoYXJfc2V0ICgpID0gQnl0ZXMubWFrZSAzMiAnXFwwMDAnXG5cbigqIEFkZCBhIGNoYXIgaW4gYSBtdXRhYmxlIGNoYXIgc2V0LiAqKVxubGV0IGFkZF9pbl9jaGFyX3NldCBjaGFyX3NldCBjID1cbiAgbGV0IGluZCA9IGludF9vZl9jaGFyIGMgaW5cbiAgbGV0IHN0cl9pbmQgPSBpbmQgbHNyIDMgYW5kIG1hc2sgPSAxIGxzbCAoaW5kIGxhbmQgMGIxMTEpIGluXG4gIEJ5dGVzLnNldCBjaGFyX3NldCBzdHJfaW5kXG4gICAgKGNoYXJfb2ZfaW50IChpbnRfb2ZfY2hhciAoQnl0ZXMuZ2V0IGNoYXJfc2V0IHN0cl9pbmQpIGxvciBtYXNrKSlcblxubGV0IGZyZWV6ZV9jaGFyX3NldCBjaGFyX3NldCA9XG4gIEJ5dGVzLnRvX3N0cmluZyBjaGFyX3NldFxuXG4oKiBDb21wdXRlIHRoZSBjb21wbGVtZW50IG9mIGEgY2hhciBzZXQuICopXG5sZXQgcmV2X2NoYXJfc2V0IGNoYXJfc2V0ID1cbiAgbGV0IGNoYXJfc2V0JyA9IGNyZWF0ZV9jaGFyX3NldCAoKSBpblxuICBmb3IgaSA9IDAgdG8gMzEgZG9cbiAgICBCeXRlcy5zZXQgY2hhcl9zZXQnIGlcbiAgICAgIChjaGFyX29mX2ludCAoaW50X29mX2NoYXIgKFN0cmluZy5nZXQgY2hhcl9zZXQgaSkgbHhvciAweEZGKSk7XG4gIGRvbmU7XG4gIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgY2hhcl9zZXQnXG5cbigqIFJldHVybiB0cnVlIGlmIGEgYGMnIGlzIGluIGBjaGFyX3NldCcuICopXG5sZXQgaXNfaW5fY2hhcl9zZXQgY2hhcl9zZXQgYyA9XG4gIGxldCBpbmQgPSBpbnRfb2ZfY2hhciBjIGluXG4gIGxldCBzdHJfaW5kID0gaW5kIGxzciAzIGFuZCBtYXNrID0gMSBsc2wgKGluZCBsYW5kIDBiMTExKSBpblxuICAoaW50X29mX2NoYXIgKFN0cmluZy5nZXQgY2hhcl9zZXQgc3RyX2luZCkgbGFuZCBtYXNrKSA8PiAwXG5cblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAoKiBJZ25vcmVkIHBhcmFtIGNvbnZlcnNpb24gKilcblxuKCogR0FEVCB1c2VkIHRvIGFic3RyYWN0IGFuIGV4aXN0ZW50aWFsIHR5cGUgcGFyYW1ldGVyLiAqKVxuKCogU2VlIHBhcmFtX2Zvcm1hdF9vZl9pZ25vcmVkX2Zvcm1hdC4gKilcbnR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIHBhcmFtX2Zvcm1hdF9lYmIgPSBQYXJhbV9mb3JtYXRfRUJCIDpcbiAgICAoJ3ggLT4gJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIHBhcmFtX2Zvcm1hdF9lYmJcblxuKCogQ29tcHV0ZSBhIHBhZGRpbmcgYXNzb2NpYXRlZCB0byBhIHBhZF9vcHRpb24gKHNlZSBcIiVfNDJkXCIpLiAqKVxubGV0IHBhZF9vZl9wYWRfb3B0IHBhZF9vcHQgPSBtYXRjaCBwYWRfb3B0IHdpdGhcbiAgfCBOb25lIC0+IE5vX3BhZGRpbmdcbiAgfCBTb21lIHdpZHRoIC0+IExpdF9wYWRkaW5nIChSaWdodCwgd2lkdGgpXG5cbigqIENvbXB1dGUgYSBwcmVjaXNpb24gYXNzb2NpYXRlZCB0byBhIHByZWNfb3B0aW9uIChzZWUgXCIlXy40MmZcIikuICopXG5sZXQgcHJlY19vZl9wcmVjX29wdCBwcmVjX29wdCA9IG1hdGNoIHByZWNfb3B0IHdpdGhcbiAgfCBOb25lIC0+IE5vX3ByZWNpc2lvblxuICB8IFNvbWUgbmRlYyAtPiBMaXRfcHJlY2lzaW9uIG5kZWNcblxuKCogVHVybiBhbiBpZ25vcmVkIHBhcmFtIGludG8gaXRzIGVxdWl2YWxlbnQgbm90LWlnbm9yZWQgZm9ybWF0IG5vZGUuICopXG4oKiBVc2VkIGZvciBmb3JtYXQgcHJldHR5LXByaW50aW5nIGFuZCBTY2FuZi4gKilcbmxldCBwYXJhbV9mb3JtYXRfb2ZfaWdub3JlZF9mb3JtYXQgOiB0eXBlIGEgYiBjIGQgZSBmIHggeSAuXG4gICAgKGEsIGIsIGMsIGQsIHksIHgpIGlnbm9yZWQgLT4gKHgsIGIsIGMsIHksIGUsIGYpIGZtdCAtPlxuICAgICAgKGEsIGIsIGMsIGQsIGUsIGYpIHBhcmFtX2Zvcm1hdF9lYmIgPVxuZnVuIGlnbiBmbXQgLT4gbWF0Y2ggaWduIHdpdGhcbiAgfCBJZ25vcmVkX2NoYXIgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChDaGFyIGZtdClcbiAgfCBJZ25vcmVkX2NhbWxfY2hhciAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkIgKENhbWxfY2hhciBmbXQpXG4gIHwgSWdub3JlZF9zdHJpbmcgcGFkX29wdCAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkIgKFN0cmluZyAocGFkX29mX3BhZF9vcHQgcGFkX29wdCwgZm10KSlcbiAgfCBJZ25vcmVkX2NhbWxfc3RyaW5nIHBhZF9vcHQgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChDYW1sX3N0cmluZyAocGFkX29mX3BhZF9vcHQgcGFkX29wdCwgZm10KSlcbiAgfCBJZ25vcmVkX2ludCAoaWNvbnYsIHBhZF9vcHQpIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQiAoSW50IChpY29udiwgcGFkX29mX3BhZF9vcHQgcGFkX29wdCwgTm9fcHJlY2lzaW9uLCBmbXQpKVxuICB8IElnbm9yZWRfaW50MzIgKGljb252LCBwYWRfb3B0KSAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkJcbiAgICAgIChJbnQzMiAoaWNvbnYsIHBhZF9vZl9wYWRfb3B0IHBhZF9vcHQsIE5vX3ByZWNpc2lvbiwgZm10KSlcbiAgfCBJZ25vcmVkX25hdGl2ZWludCAoaWNvbnYsIHBhZF9vcHQpIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQlxuICAgICAgKE5hdGl2ZWludCAoaWNvbnYsIHBhZF9vZl9wYWRfb3B0IHBhZF9vcHQsIE5vX3ByZWNpc2lvbiwgZm10KSlcbiAgfCBJZ25vcmVkX2ludDY0IChpY29udiwgcGFkX29wdCkgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCXG4gICAgICAoSW50NjQgKGljb252LCBwYWRfb2ZfcGFkX29wdCBwYWRfb3B0LCBOb19wcmVjaXNpb24sIGZtdCkpXG4gIHwgSWdub3JlZF9mbG9hdCAocGFkX29wdCwgcHJlY19vcHQpIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQlxuICAgICAgKEZsb2F0ICgoRmxvYXRfZmxhZ18sIEZsb2F0X2YpLFxuICAgICAgICAgICAgICBwYWRfb2ZfcGFkX29wdCBwYWRfb3B0LCBwcmVjX29mX3ByZWNfb3B0IHByZWNfb3B0LCBmbXQpKVxuICB8IElnbm9yZWRfYm9vbCBwYWRfb3B0IC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQiAoQm9vbCAocGFkX29mX3BhZF9vcHQgcGFkX29wdCwgZm10KSlcbiAgfCBJZ25vcmVkX2Zvcm1hdF9hcmcgKHBhZF9vcHQsIGZtdHR5KSAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkIgKEZvcm1hdF9hcmcgKHBhZF9vcHQsIGZtdHR5LCBmbXQpKVxuICB8IElnbm9yZWRfZm9ybWF0X3N1YnN0IChwYWRfb3B0LCBmbXR0eSkgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCXG4gICAgICAoRm9ybWF0X3N1YnN0IChwYWRfb3B0LCBmbXR0eSwgZm10KSlcbiAgfCBJZ25vcmVkX3JlYWRlciAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkIgKFJlYWRlciBmbXQpXG4gIHwgSWdub3JlZF9zY2FuX2NoYXJfc2V0ICh3aWR0aF9vcHQsIGNoYXJfc2V0KSAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkIgKFNjYW5fY2hhcl9zZXQgKHdpZHRoX29wdCwgY2hhcl9zZXQsIGZtdCkpXG4gIHwgSWdub3JlZF9zY2FuX2dldF9jb3VudGVyIGNvdW50ZXIgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChTY2FuX2dldF9jb3VudGVyIChjb3VudGVyLCBmbXQpKVxuICB8IElnbm9yZWRfc2Nhbl9uZXh0X2NoYXIgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChTY2FuX25leHRfY2hhciBmbXQpXG5cblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIFR5cGVzICopXG5cbnR5cGUgKCdiLCAnYykgYWNjX2Zvcm1hdHRpbmdfZ2VuID1cbiAgfCBBY2Nfb3Blbl90YWcgb2YgKCdiLCAnYykgYWNjXG4gIHwgQWNjX29wZW5fYm94IG9mICgnYiwgJ2MpIGFjY1xuXG4oKiBSZXZlcnNlZCBsaXN0IG9mIHByaW50aW5nIGF0b21zLiAqKVxuKCogVXNlZCB0byBhY2N1bXVsYXRlIHByaW50ZiBhcmd1bWVudHMuICopXG5hbmQgKCdiLCAnYykgYWNjID1cbiAgfCBBY2NfZm9ybWF0dGluZ19saXQgb2YgKCdiLCAnYykgYWNjICogZm9ybWF0dGluZ19saXRcbiAgICAgICgqIFNwZWNpYWwgZm10dGluZyAoYm94KSAqKVxuICB8IEFjY19mb3JtYXR0aW5nX2dlbiBvZiAoJ2IsICdjKSBhY2MgKiAoJ2IsICdjKSBhY2NfZm9ybWF0dGluZ19nZW5cbiAgICAgICgqIFNwZWNpYWwgZm10dGluZyAoYm94KSAqKVxuICB8IEFjY19zdHJpbmdfbGl0ZXJhbCBvZiAoJ2IsICdjKSBhY2MgKiBzdHJpbmcgICAgICgqIExpdGVyYWwgc3RyaW5nICopXG4gIHwgQWNjX2NoYXJfbGl0ZXJhbCAgIG9mICgnYiwgJ2MpIGFjYyAqIGNoYXIgICAgICAgKCogTGl0ZXJhbCBjaGFyICopXG4gIHwgQWNjX2RhdGFfc3RyaW5nICAgIG9mICgnYiwgJ2MpIGFjYyAqIHN0cmluZyAgICAgKCogR2VuZXJhdGVkIHN0cmluZyAqKVxuICB8IEFjY19kYXRhX2NoYXIgICAgICBvZiAoJ2IsICdjKSBhY2MgKiBjaGFyICAgICAgICgqIEdlbmVyYXRlZCBjaGFyICopXG4gIHwgQWNjX2RlbGF5ICAgICAgICAgIG9mICgnYiwgJ2MpIGFjYyAqICgnYiAtPiAnYylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIERlbGF5ZWQgcHJpbnRpbmcgKCVhLCAldCkgKilcbiAgfCBBY2NfZmx1c2ggICAgICAgICAgb2YgKCdiLCAnYykgYWNjICAgICAgICAgICAgICAoKiBGbHVzaCAqKVxuICB8IEFjY19pbnZhbGlkX2FyZyAgICBvZiAoJ2IsICdjKSBhY2MgKiBzdHJpbmdcbiAgICAgICgqIFJhaXNlIEludmFsaWRfYXJndW1lbnQgbXNnICopXG4gIHwgRW5kX29mX2FjY1xuXG4oKiBMaXN0IG9mIGhldGVyb2dlbmVvdXMgdmFsdWVzLiAqKVxuKCogVXNlZCB0byBhY2N1bXVsYXRlIHNjYW5mIGNhbGxiYWNrIGFyZ3VtZW50cy4gKilcbnR5cGUgKCdhLCAnYikgaGV0ZXJfbGlzdCA9XG4gIHwgQ29ucyA6ICdjICogKCdhLCAnYikgaGV0ZXJfbGlzdCAtPiAoJ2MgLT4gJ2EsICdiKSBoZXRlcl9saXN0XG4gIHwgTmlsIDogKCdiLCAnYikgaGV0ZXJfbGlzdFxuXG4oKiBFeGlzdGVudGlhbCBCbGFjayBCb3hlcy4gKilcbigqIFVzZWQgdG8gYWJzdHJhY3Qgc29tZSBleGlzdGVudGlhbCB0eXBlIHBhcmFtZXRlcnMuICopXG5cbigqIEdBRFQgdHlwZSBhc3NvY2lhdGluZyBhIHBhZGRpbmcgYW5kIGFuIGZtdHR5LiAqKVxuKCogU2VlIHRoZSB0eXBlX3BhZGRpbmcgZnVuY3Rpb24uICopXG50eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBwYWRkaW5nX2ZtdHR5X2ViYiA9IFBhZGRpbmdfZm10dHlfRUJCIDpcbiAgICAgKCd4LCAneSkgcGFkZGluZyAqICgneSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXR0eSAtPlxuICAgICAoJ3gsICdiLCAnYywgJ2QsICdlLCAnZikgcGFkZGluZ19mbXR0eV9lYmJcblxuKCogR0FEVCB0eXBlIGFzc29jaWF0aW5nIGEgcGFkZGluZywgYSBwcmVjaXNpb24gYW5kIGFuIGZtdHR5LiAqKVxuKCogU2VlIHRoZSB0eXBlX3BhZHByZWMgZnVuY3Rpb24uICopXG50eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBwYWRwcmVjX2ZtdHR5X2ViYiA9IFBhZHByZWNfZm10dHlfRUJCIDpcbiAgICAgKCd4LCAneSkgcGFkZGluZyAqICgneSwgJ3opIHByZWNpc2lvbiAqICgneiwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXR0eSAtPlxuICAgICAoJ3gsICdiLCAnYywgJ2QsICdlLCAnZikgcGFkcHJlY19mbXR0eV9lYmJcblxuKCogR0FEVCB0eXBlIGFzc29jaWF0aW5nIGEgcGFkZGluZyBhbmQgYW4gZm10LiAqKVxuKCogU2VlIG1ha2VfcGFkZGluZ19mbXRfZWJiIGFuZCBwYXJzZV9mb3JtYXQgZnVuY3Rpb25zLiAqKVxudHlwZSAoJ2EsICdiLCAnYywgJ2UsICdmKSBwYWRkaW5nX2ZtdF9lYmIgPSBQYWRkaW5nX2ZtdF9FQkIgOlxuICAgICAoXywgJ3ggLT4gJ2EpIHBhZGRpbmcgKlxuICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICgneCwgJ2IsICdjLCAnZSwgJ2YpIHBhZGRpbmdfZm10X2ViYlxuXG4oKiBHQURUIHR5cGUgYXNzb2NpYXRpbmcgYSBwcmVjaXNpb24gYW5kIGFuIGZtdC4gKilcbigqIFNlZSBtYWtlX3ByZWNpc2lvbl9mbXRfZWJiIGFuZCBwYXJzZV9mb3JtYXQgZnVuY3Rpb25zLiAqKVxudHlwZSAoJ2EsICdiLCAnYywgJ2UsICdmKSBwcmVjaXNpb25fZm10X2ViYiA9IFByZWNpc2lvbl9mbXRfRUJCIDpcbiAgICAgKF8sICd4IC0+ICdhKSBwcmVjaXNpb24gKlxuICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICgneCwgJ2IsICdjLCAnZSwgJ2YpIHByZWNpc2lvbl9mbXRfZWJiXG5cbigqIEdBRFQgdHlwZSBhc3NvY2lhdGluZyBhIHBhZGRpbmcsIGEgcHJlY2lzaW9uIGFuZCBhbiBmbXQuICopXG4oKiBTZWUgbWFrZV9wYWRwcmVjX2ZtdF9lYmIgYW5kIHBhcnNlX2Zvcm1hdCBmdW5jdGlvbnMuICopXG50eXBlICgncCwgJ2IsICdjLCAnZSwgJ2YpIHBhZHByZWNfZm10X2ViYiA9IFBhZHByZWNfZm10X0VCQiA6XG4gICAgICgneCwgJ3kpIHBhZGRpbmcgKiAoJ3ksICdwIC0+ICdhKSBwcmVjaXNpb24gKlxuICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICgncCwgJ2IsICdjLCAnZSwgJ2YpIHBhZHByZWNfZm10X2ViYlxuXG4oKiBBYnN0cmFjdCB0aGUgJ2EgYW5kICdkIHBhcmFtZXRlcnMgb2YgYW4gZm10LiAqKVxuKCogT3V0cHV0IHR5cGUgb2YgdGhlIGZvcm1hdCBwYXJzaW5nIGZ1bmN0aW9uLiAqKVxudHlwZSAoJ2IsICdjLCAnZSwgJ2YpIGZtdF9lYmIgPSBGbXRfRUJCIDpcbiAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAoJ2IsICdjLCAnZSwgJ2YpIGZtdF9lYmJcblxuKCogR0FEVCB0eXBlIGFzc29jaWF0aW5nIGFuIGZtdHR5IGFuZCBhbiBmbXQuICopXG4oKiBTZWUgdGhlIHR5cGVfZm9ybWF0X2dlbiBmdW5jdGlvbi4gKilcbnR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdF9mbXR0eV9lYmIgPSBGbXRfZm10dHlfRUJCIDpcbiAgICAgKCdhLCAnYiwgJ2MsICdkLCAneSwgJ3gpIGZtdCAqXG4gICAgICgneCwgJ2IsICdjLCAneSwgJ2UsICdmKSBmbXR0eSAtPlxuICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10X2ZtdHR5X2ViYlxuXG4oKiBHQURUIHR5cGUgYXNzb2NpYXRpbmcgYW4gZm10dHkgYW5kIGFuIGZtdC4gKilcbigqIFNlZSB0aGUgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gZnVuY3Rpb24uICopXG50eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXR0eV9mbXRfZWJiID0gRm10dHlfZm10X0VCQiA6XG4gICAgICgnYSwgJ2IsICdjLCAnZCwgJ3ksICd4KSBmbXR0eSAqXG4gICAgICgneCwgJ2IsICdjLCAneSwgJ2UsICdmKSBmbXRfZm10dHlfZWJiIC0+XG4gICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXR0eV9mbXRfZWJiXG5cbigqIEFic3RyYWN0IGFsbCBmbXR0eSB0eXBlIHBhcmFtZXRlcnMuICopXG4oKiBVc2VkIHRvIGNvbXBhcmUgZm9ybWF0IHR5cGVzLiAqKVxudHlwZSBmbXR0eV9lYmIgPSBGbXR0eV9FQkIgOiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHkgLT4gZm10dHlfZWJiXG5cbigqIEFic3RyYWN0IGFsbCBwYWRkaW5nIHR5cGUgcGFyYW1ldGVycy4gKilcbigqIFVzZWQgdG8gY29tcGFyZSBwYWRkaW5ncy4gKilcbnR5cGUgcGFkZGluZ19lYmIgPSBQYWRkaW5nX0VCQiA6ICgnYSwgJ2IpIHBhZGRpbmcgLT4gcGFkZGluZ19lYmJcblxuKCogQWJzdHJhY3QgYWxsIHByZWNpc2lvbiB0eXBlIHBhcmFtZXRlcnMuICopXG4oKiBVc2VkIHRvIGNvbXBhcmUgcHJlY2lzaW9ucy4gKilcbnR5cGUgcHJlY2lzaW9uX2ViYiA9IFByZWNpc2lvbl9FQkIgOiAoJ2EsICdiKSBwcmVjaXNpb24gLT4gcHJlY2lzaW9uX2ViYlxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIENvbnN0YW50cyAqKVxuXG4oKiBEZWZhdWx0IHByZWNpc2lvbiBmb3IgZmxvYXQgcHJpbnRpbmcuICopXG5sZXQgZGVmYXVsdF9mbG9hdF9wcmVjaXNpb24gZmNvbnYgPVxuICBtYXRjaCBzbmQgZmNvbnYgd2l0aFxuICB8IEZsb2F0X2YgfCBGbG9hdF9lIHwgRmxvYXRfRSB8IEZsb2F0X2cgfCBGbG9hdF9HIHwgRmxvYXRfaCB8IEZsb2F0X0hcbiAgfCBGbG9hdF9DRiAtPiAtNlxuICAoKiBGb3IgJWggJUggYW5kICUjRiBmb3JtYXRzLCBhIG5lZ2F0aXZlIHByZWNpc2lvbiBtZWFucyBcImFzIG1hbnkgZGlnaXRzIGFzXG4gICAgIG5lY2Vzc2FyeVwiLiAgRm9yIHRoZSBvdGhlciBGUCBmb3JtYXRzLCB3ZSB0YWtlIHRoZSBhYnNvbHV0ZSB2YWx1ZVxuICAgICBvZiB0aGUgcHJlY2lzaW9uLCBoZW5jZSA2IGRpZ2l0cyBieSBkZWZhdWx0LiAqKVxuICB8IEZsb2F0X0YgLT4gMTJcbiAgKCogRGVmYXVsdCBwcmVjaXNpb24gZm9yIE9DYW1sIGZsb2F0IHByaW50aW5nICglRikuICopXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogRXh0ZXJuYWxzICopXG5cbmV4dGVybmFsIGZvcm1hdF9mbG9hdDogc3RyaW5nIC0+IGZsb2F0IC0+IHN0cmluZ1xuICA9IFwiY2FtbF9mb3JtYXRfZmxvYXRcIlxuZXh0ZXJuYWwgZm9ybWF0X2ludDogc3RyaW5nIC0+IGludCAtPiBzdHJpbmdcbiAgPSBcImNhbWxfZm9ybWF0X2ludFwiXG5leHRlcm5hbCBmb3JtYXRfaW50MzI6IHN0cmluZyAtPiBpbnQzMiAtPiBzdHJpbmdcbiAgPSBcImNhbWxfaW50MzJfZm9ybWF0XCJcbmV4dGVybmFsIGZvcm1hdF9uYXRpdmVpbnQ6IHN0cmluZyAtPiBuYXRpdmVpbnQgLT4gc3RyaW5nXG4gID0gXCJjYW1sX25hdGl2ZWludF9mb3JtYXRcIlxuZXh0ZXJuYWwgZm9ybWF0X2ludDY0OiBzdHJpbmcgLT4gaW50NjQgLT4gc3RyaW5nXG4gID0gXCJjYW1sX2ludDY0X2Zvcm1hdFwiXG5leHRlcm5hbCBoZXhzdHJpbmdfb2ZfZmxvYXQ6IGZsb2F0IC0+IGludCAtPiBjaGFyIC0+IHN0cmluZ1xuICA9IFwiY2FtbF9oZXhzdHJpbmdfb2ZfZmxvYXRcIlxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgKCogVG9vbHMgdG8gcHJldHR5LXByaW50IGZvcm1hdHMgKilcblxuKCogVHlwZSBvZiBleHRlbnNpYmxlIGNoYXJhY3RlciBidWZmZXJzLiAqKVxudHlwZSBidWZmZXIgPSB7XG4gIG11dGFibGUgaW5kIDogaW50O1xuICBtdXRhYmxlIGJ5dGVzIDogYnl0ZXM7XG59XG5cbigqIENyZWF0ZSBhIGZyZXNoIGJ1ZmZlci4gKilcbmxldCBidWZmZXJfY3JlYXRlIGluaXRfc2l6ZSA9IHsgaW5kID0gMDsgYnl0ZXMgPSBCeXRlcy5jcmVhdGUgaW5pdF9zaXplIH1cblxuKCogQ2hlY2sgc2l6ZSBvZiB0aGUgYnVmZmVyIGFuZCBncm93IGl0IGlmIG5lZWRlZC4gKilcbmxldCBidWZmZXJfY2hlY2tfc2l6ZSBidWYgb3ZlcmhlYWQgPVxuICBsZXQgbGVuID0gQnl0ZXMubGVuZ3RoIGJ1Zi5ieXRlcyBpblxuICBsZXQgbWluX2xlbiA9IGJ1Zi5pbmQgKyBvdmVyaGVhZCBpblxuICBpZiBtaW5fbGVuID4gbGVuIHRoZW4gKFxuICAgIGxldCBuZXdfbGVuID0gSW50Lm1heCAobGVuICogMikgbWluX2xlbiBpblxuICAgIGxldCBuZXdfc3RyID0gQnl0ZXMuY3JlYXRlIG5ld19sZW4gaW5cbiAgICBCeXRlcy5ibGl0IGJ1Zi5ieXRlcyAwIG5ld19zdHIgMCBsZW47XG4gICAgYnVmLmJ5dGVzIDwtIG5ld19zdHI7XG4gIClcblxuKCogQWRkIHRoZSBjaGFyYWN0ZXIgYGMnIHRvIHRoZSBidWZmZXIgYGJ1ZicuICopXG5sZXQgYnVmZmVyX2FkZF9jaGFyIGJ1ZiBjID1cbiAgYnVmZmVyX2NoZWNrX3NpemUgYnVmIDE7XG4gIEJ5dGVzLnNldCBidWYuYnl0ZXMgYnVmLmluZCBjO1xuICBidWYuaW5kIDwtIGJ1Zi5pbmQgKyAxXG5cbigqIEFkZCB0aGUgc3RyaW5nIGBzJyB0byB0aGUgYnVmZmVyIGBidWYnLiAqKVxubGV0IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBzID1cbiAgbGV0IHN0cl9sZW4gPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgYnVmZmVyX2NoZWNrX3NpemUgYnVmIHN0cl9sZW47XG4gIFN0cmluZy5ibGl0IHMgMCBidWYuYnl0ZXMgYnVmLmluZCBzdHJfbGVuO1xuICBidWYuaW5kIDwtIGJ1Zi5pbmQgKyBzdHJfbGVuXG5cbigqIEdldCB0aGUgY29udGVudCBvZiB0aGUgYnVmZmVyLiAqKVxubGV0IGJ1ZmZlcl9jb250ZW50cyBidWYgPVxuICBCeXRlcy5zdWJfc3RyaW5nIGJ1Zi5ieXRlcyAwIGJ1Zi5pbmRcblxuKCoqKilcblxuKCogQ29udmVydCBhbiBpbnRlZ2VyIGNvbnZlcnNpb24gdG8gY2hhci4gKilcbmxldCBjaGFyX29mX2ljb252IGljb252ID0gbWF0Y2ggaWNvbnYgd2l0aFxuICB8IEludF9kIHwgSW50X3BkIHwgSW50X3NkIHwgSW50X0NkIC0+ICdkJyB8IEludF9pIHwgSW50X3BpIHwgSW50X3NpXG4gIHwgSW50X0NpIC0+ICdpJyB8IEludF94IHwgSW50X0N4IC0+ICd4JyB8IEludF9YIHwgSW50X0NYIC0+ICdYJyB8IEludF9vXG4gIHwgSW50X0NvIC0+ICdvJyB8IEludF91IHwgSW50X0N1IC0+ICd1J1xuXG4oKiBDb252ZXJ0IGEgZmxvYXQgY29udmVyc2lvbiB0byBjaGFyLiAqKVxuKCogYGNGJyB3aWxsIGJlICdGJyBmb3IgZGlzcGxheWluZyBmb3JtYXQgYW5kICdnJyB0byBjYWxsIGxpYmMgcHJpbnRmICopXG5sZXQgY2hhcl9vZl9mY29udiA/KGNGPSdGJykgZmNvbnYgPSBtYXRjaCBzbmQgZmNvbnYgd2l0aFxuICB8IEZsb2F0X2YgLT4gJ2YnIHwgRmxvYXRfZSAtPiAnZSdcbiAgfCBGbG9hdF9FIC0+ICdFJyB8IEZsb2F0X2cgLT4gJ2cnXG4gIHwgRmxvYXRfRyAtPiAnRycgfCBGbG9hdF9GIC0+IGNGXG4gIHwgRmxvYXRfaCAtPiAnaCcgfCBGbG9hdF9IIC0+ICdIJ1xuICB8IEZsb2F0X0NGIC0+ICdGJ1xuXG5cbigqIENvbnZlcnQgYSBzY2FubmluZyBjb3VudGVyIHRvIGNoYXIuICopXG5sZXQgY2hhcl9vZl9jb3VudGVyIGNvdW50ZXIgPSBtYXRjaCBjb3VudGVyIHdpdGhcbiAgfCBMaW5lX2NvdW50ZXIgIC0+ICdsJ1xuICB8IENoYXJfY291bnRlciAgLT4gJ24nXG4gIHwgVG9rZW5fY291bnRlciAtPiAnTidcblxuKCoqKilcblxuKCogUHJpbnQgYSBjaGFyX3NldCBpbiBhIGJ1ZmZlciB3aXRoIHRoZSBPQ2FtbCBmb3JtYXQgbGV4aWNhbCBjb252ZW50aW9uLiAqKVxubGV0IGJwcmludF9jaGFyX3NldCBidWYgY2hhcl9zZXQgPVxuICBsZXQgcmVjIHByaW50X3N0YXJ0IHNldCA9XG4gICAgbGV0IGlzX2Fsb25lIGMgPVxuICAgICAgbGV0IGJlZm9yZSwgYWZ0ZXIgPSBDaGFyLihjaHIgKGNvZGUgYyAtIDEpLCBjaHIgKGNvZGUgYyArIDEpKSBpblxuICAgICAgaXNfaW5fY2hhcl9zZXQgc2V0IGNcbiAgICAgICYmIG5vdCAoaXNfaW5fY2hhcl9zZXQgc2V0IGJlZm9yZSAmJiBpc19pbl9jaGFyX3NldCBzZXQgYWZ0ZXIpIGluXG4gICAgaWYgaXNfYWxvbmUgJ10nIHRoZW4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnXSc7XG4gICAgcHJpbnRfb3V0IHNldCAxO1xuICAgIGlmIGlzX2Fsb25lICctJyB0aGVuIGJ1ZmZlcl9hZGRfY2hhciBidWYgJy0nO1xuICBhbmQgcHJpbnRfb3V0IHNldCBpID1cbiAgICBpZiBpIDwgMjU2IHRoZW5cbiAgICAgIGlmIGlzX2luX2NoYXJfc2V0IHNldCAoY2hhcl9vZl9pbnQgaSkgdGhlbiBwcmludF9maXJzdCBzZXQgaVxuICAgICAgZWxzZSBwcmludF9vdXQgc2V0IChpICsgMSlcbiAgYW5kIHByaW50X2ZpcnN0IHNldCBpID1cbiAgICBtYXRjaCBjaGFyX29mX2ludCBpIHdpdGhcbiAgICB8ICdcXDI1NScgLT4gcHJpbnRfY2hhciBidWYgMjU1O1xuICAgIHwgJ10nIHwgJy0nIC0+IHByaW50X291dCBzZXQgKGkgKyAxKTtcbiAgICB8IF8gLT4gcHJpbnRfc2Vjb25kIHNldCAoaSArIDEpO1xuICBhbmQgcHJpbnRfc2Vjb25kIHNldCBpID1cbiAgICBpZiBpc19pbl9jaGFyX3NldCBzZXQgKGNoYXJfb2ZfaW50IGkpIHRoZW5cbiAgICAgIG1hdGNoIGNoYXJfb2ZfaW50IGkgd2l0aFxuICAgICAgfCAnXFwyNTUnIC0+XG4gICAgICAgIHByaW50X2NoYXIgYnVmIDI1NDtcbiAgICAgICAgcHJpbnRfY2hhciBidWYgMjU1O1xuICAgICAgfCAnXScgfCAnLScgd2hlbiBub3QgKGlzX2luX2NoYXJfc2V0IHNldCAoY2hhcl9vZl9pbnQgKGkgKyAxKSkpIC0+XG4gICAgICAgIHByaW50X2NoYXIgYnVmIChpIC0gMSk7XG4gICAgICAgIHByaW50X291dCBzZXQgKGkgKyAxKTtcbiAgICAgIHwgXyB3aGVuIG5vdCAoaXNfaW5fY2hhcl9zZXQgc2V0IChjaGFyX29mX2ludCAoaSArIDEpKSkgLT5cbiAgICAgICAgcHJpbnRfY2hhciBidWYgKGkgLSAxKTtcbiAgICAgICAgcHJpbnRfY2hhciBidWYgaTtcbiAgICAgICAgcHJpbnRfb3V0IHNldCAoaSArIDIpO1xuICAgICAgfCBfIC0+XG4gICAgICAgIHByaW50X2luIHNldCAoaSAtIDEpIChpICsgMik7XG4gICAgZWxzZSAoXG4gICAgICBwcmludF9jaGFyIGJ1ZiAoaSAtIDEpO1xuICAgICAgcHJpbnRfb3V0IHNldCAoaSArIDEpO1xuICAgIClcbiAgYW5kIHByaW50X2luIHNldCBpIGogPVxuICAgIGlmIGogPSAyNTYgfHwgbm90IChpc19pbl9jaGFyX3NldCBzZXQgKGNoYXJfb2ZfaW50IGopKSB0aGVuIChcbiAgICAgIHByaW50X2NoYXIgYnVmIGk7XG4gICAgICBwcmludF9jaGFyIGJ1ZiAoaW50X29mX2NoYXIgJy0nKTtcbiAgICAgIHByaW50X2NoYXIgYnVmIChqIC0gMSk7XG4gICAgICBpZiBqIDwgMjU2IHRoZW4gcHJpbnRfb3V0IHNldCAoaiArIDEpO1xuICAgICkgZWxzZVxuICAgICAgcHJpbnRfaW4gc2V0IGkgKGogKyAxKTtcbiAgYW5kIHByaW50X2NoYXIgYnVmIGkgPSBtYXRjaCBjaGFyX29mX2ludCBpIHdpdGhcbiAgICB8ICclJyAtPiBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7XG4gICAgfCAnQCcgLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJ0AnO1xuICAgIHwgYyAgIC0+IGJ1ZmZlcl9hZGRfY2hhciBidWYgYztcbiAgaW5cbiAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnWyc7XG4gIHByaW50X3N0YXJ0IChcbiAgICBpZiBpc19pbl9jaGFyX3NldCBjaGFyX3NldCAnXFwwMDAnXG4gICAgdGhlbiAoIGJ1ZmZlcl9hZGRfY2hhciBidWYgJ14nOyByZXZfY2hhcl9zZXQgY2hhcl9zZXQgKVxuICAgIGVsc2UgY2hhcl9zZXRcbiAgKTtcbiAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnXSdcblxuKCoqKilcblxuKCogUHJpbnQgYSBwYWR0eSBpbiBhIGJ1ZmZlciB3aXRoIHRoZSBmb3JtYXQtbGlrZSBzeW50YXguICopXG5sZXQgYnByaW50X3BhZHR5IGJ1ZiBwYWR0eSA9IG1hdGNoIHBhZHR5IHdpdGhcbiAgfCBMZWZ0ICAtPiBidWZmZXJfYWRkX2NoYXIgYnVmICctJ1xuICB8IFJpZ2h0IC0+ICgpXG4gIHwgWmVyb3MgLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnMCdcblxuKCogUHJpbnQgdGhlICdfJyBvZiBhbiBpZ25vcmVkIGZsYWcgaWYgbmVlZGVkLiAqKVxubGV0IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnID1cbiAgaWYgaWduX2ZsYWcgdGhlbiBidWZmZXJfYWRkX2NoYXIgYnVmICdfJ1xuXG4oKioqKVxuXG5sZXQgYnByaW50X3BhZF9vcHQgYnVmIHBhZF9vcHQgPSBtYXRjaCBwYWRfb3B0IHdpdGhcbiAgfCBOb25lIC0+ICgpXG4gIHwgU29tZSB3aWR0aCAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgKEludC50b19zdHJpbmcgd2lkdGgpXG5cbigqKiopXG5cbigqIFByaW50IHBhZGRpbmcgaW4gYSBidWZmZXIgd2l0aCB0aGUgZm9ybWF0LWxpa2Ugc3ludGF4LiAqKVxubGV0IGJwcmludF9wYWRkaW5nIDogdHlwZSBhIGIgLiBidWZmZXIgLT4gKGEsIGIpIHBhZGRpbmcgLT4gdW5pdCA9XG5mdW4gYnVmIHBhZCAtPiBtYXRjaCBwYWQgd2l0aFxuICB8IE5vX3BhZGRpbmcgLT4gKClcbiAgfCBMaXRfcGFkZGluZyAocGFkdHksIG4pIC0+XG4gICAgYnByaW50X3BhZHR5IGJ1ZiBwYWR0eTtcbiAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgKEludC50b19zdHJpbmcgbik7XG4gIHwgQXJnX3BhZGRpbmcgcGFkdHkgLT5cbiAgICBicHJpbnRfcGFkdHkgYnVmIHBhZHR5O1xuICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyonXG5cbigqIFByaW50IHByZWNpc2lvbiBpbiBhIGJ1ZmZlciB3aXRoIHRoZSBmb3JtYXQtbGlrZSBzeW50YXguICopXG5sZXQgYnByaW50X3ByZWNpc2lvbiA6IHR5cGUgYSBiIC4gYnVmZmVyIC0+IChhLCBiKSBwcmVjaXNpb24gLT4gdW5pdCA9XG4gIGZ1biBidWYgcHJlYyAtPiBtYXRjaCBwcmVjIHdpdGhcbiAgfCBOb19wcmVjaXNpb24gLT4gKClcbiAgfCBMaXRfcHJlY2lzaW9uIG4gLT5cbiAgICBidWZmZXJfYWRkX2NoYXIgYnVmICcuJztcbiAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgKEludC50b19zdHJpbmcgbik7XG4gIHwgQXJnX3ByZWNpc2lvbiAtPlxuICAgIGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIi4qXCJcblxuKCoqKilcblxuKCogUHJpbnQgdGhlIG9wdGlvbmFsICcrJywgJyAnIG9yICcjJyBhc3NvY2lhdGVkIHRvIGFuIGludCBjb252ZXJzaW9uLiAqKVxubGV0IGJwcmludF9pY29udl9mbGFnIGJ1ZiBpY29udiA9IG1hdGNoIGljb252IHdpdGhcbiAgfCBJbnRfcGQgfCBJbnRfcGkgLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnKydcbiAgfCBJbnRfc2QgfCBJbnRfc2kgLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnICdcbiAgfCBJbnRfQ3ggfCBJbnRfQ1ggfCBJbnRfQ28gfCBJbnRfQ2QgfCBJbnRfQ2kgfCBJbnRfQ3UgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyMnXG4gIHwgSW50X2QgfCBJbnRfaSB8IEludF94IHwgSW50X1ggfCBJbnRfbyB8IEludF91IC0+ICgpXG5cbigqIFByaW50IGFuIGNvbXBsZXRlIGludCBmb3JtYXQgaW4gYSBidWZmZXIgKGV4OiBcIiUzLipkXCIpLiAqKVxubGV0IGJwcmludF9pbnRfZm10IGJ1ZiBpZ25fZmxhZyBpY29udiBwYWQgcHJlYyA9XG4gIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnO1xuICBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgYnByaW50X2ljb252X2ZsYWcgYnVmIGljb252O1xuICBicHJpbnRfcGFkZGluZyBidWYgcGFkO1xuICBicHJpbnRfcHJlY2lzaW9uIGJ1ZiBwcmVjO1xuICBidWZmZXJfYWRkX2NoYXIgYnVmIChjaGFyX29mX2ljb252IGljb252KVxuXG4oKiBQcmludCBhIGNvbXBsZXRlIGludDMyLCBuYXRpdmVpbnQgb3IgaW50NjQgZm9ybWF0IGluIGEgYnVmZmVyLiAqKVxubGV0IGJwcmludF9hbHRpbnRfZm10IGJ1ZiBpZ25fZmxhZyBpY29udiBwYWQgcHJlYyBjID1cbiAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7XG4gIGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICBicHJpbnRfaWNvbnZfZmxhZyBidWYgaWNvbnY7XG4gIGJwcmludF9wYWRkaW5nIGJ1ZiBwYWQ7XG4gIGJwcmludF9wcmVjaXNpb24gYnVmIHByZWM7XG4gIGJ1ZmZlcl9hZGRfY2hhciBidWYgYztcbiAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAoY2hhcl9vZl9pY29udiBpY29udilcblxuKCoqKilcblxuKCogUHJpbnQgdGhlIG9wdGlvbmFsICcrJywgJyAnIGFuZC9vciAnIycgYXNzb2NpYXRlZCB0byBhIGZsb2F0IGNvbnZlcnNpb24uICopXG5sZXQgYnByaW50X2Zjb252X2ZsYWcgYnVmIGZjb252ID1cbiAgYmVnaW4gbWF0Y2ggZnN0IGZjb252IHdpdGhcbiAgfCBGbG9hdF9mbGFnX3AgLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnKydcbiAgfCBGbG9hdF9mbGFnX3MgLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnICdcbiAgfCBGbG9hdF9mbGFnXyAtPiAoKSBlbmQ7XG4gIG1hdGNoIHNuZCBmY29udiB3aXRoXG4gIHwgRmxvYXRfQ0YgLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnIydcbiAgfCBGbG9hdF9mIHwgRmxvYXRfZSB8IEZsb2F0X0UgfCBGbG9hdF9nIHwgRmxvYXRfR1xuICB8IEZsb2F0X0YgfCBGbG9hdF9oIHwgRmxvYXRfSCAtPiAoKVxuXG4oKiBQcmludCBhIGNvbXBsZXRlIGZsb2F0IGZvcm1hdCBpbiBhIGJ1ZmZlciAoZXg6IFwiJSsqLjNmXCIpLiAqKVxubGV0IGJwcmludF9mbG9hdF9mbXQgYnVmIGlnbl9mbGFnIGZjb252IHBhZCBwcmVjID1cbiAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7XG4gIGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICBicHJpbnRfZmNvbnZfZmxhZyBidWYgZmNvbnY7XG4gIGJwcmludF9wYWRkaW5nIGJ1ZiBwYWQ7XG4gIGJwcmludF9wcmVjaXNpb24gYnVmIHByZWM7XG4gIGJ1ZmZlcl9hZGRfY2hhciBidWYgKGNoYXJfb2ZfZmNvbnYgZmNvbnYpXG5cbigqIENvbXB1dGUgdGhlIGxpdGVyYWwgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgRm9ybWF0dGluZ19saXQuICopXG4oKiBVc2VkIGJ5IFByaW50ZiBhbmQgU2NhbmYgd2hlcmUgZm9ybWF0dGluZyBpcyBub3QgaW50ZXJwcmV0ZWQuICopXG5sZXQgc3RyaW5nX29mX2Zvcm1hdHRpbmdfbGl0IGZvcm1hdHRpbmdfbGl0ID0gbWF0Y2ggZm9ybWF0dGluZ19saXQgd2l0aFxuICB8IENsb3NlX2JveCAgICAgICAgICAgIC0+IFwiQF1cIlxuICB8IENsb3NlX3RhZyAgICAgICAgICAgIC0+IFwiQH1cIlxuICB8IEJyZWFrIChzdHIsIF8sIF8pICAgIC0+IHN0clxuICB8IEZGbHVzaCAgICAgICAgICAgICAgIC0+IFwiQD9cIlxuICB8IEZvcmNlX25ld2xpbmUgICAgICAgIC0+IFwiQFxcblwiXG4gIHwgRmx1c2hfbmV3bGluZSAgICAgICAgLT4gXCJALlwiXG4gIHwgTWFnaWNfc2l6ZSAoc3RyLCBfKSAgLT4gc3RyXG4gIHwgRXNjYXBlZF9hdCAgICAgICAgICAgLT4gXCJAQFwiXG4gIHwgRXNjYXBlZF9wZXJjZW50ICAgICAgLT4gXCJAJVwiXG4gIHwgU2Nhbl9pbmRpYyBjIC0+IFwiQFwiIF4gKFN0cmluZy5tYWtlIDEgYylcblxuKCoqKilcblxuKCogUHJpbnQgYSBsaXRlcmFsIGNoYXIgaW4gYSBidWZmZXIsIGVzY2FwZSAnJScgYnkgXCIlJVwiLiAqKVxubGV0IGJwcmludF9jaGFyX2xpdGVyYWwgYnVmIGNociA9IG1hdGNoIGNociB3aXRoXG4gIHwgJyUnIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiUlXCJcbiAgfCBfIC0+IGJ1ZmZlcl9hZGRfY2hhciBidWYgY2hyXG5cbigqIFByaW50IGEgbGl0ZXJhbCBzdHJpbmcgaW4gYSBidWZmZXIsIGVzY2FwZSBhbGwgJyUnIGJ5IFwiJSVcIi4gKilcbmxldCBicHJpbnRfc3RyaW5nX2xpdGVyYWwgYnVmIHN0ciA9XG4gIGZvciBpID0gMCB0byBTdHJpbmcubGVuZ3RoIHN0ciAtIDEgZG9cbiAgICBicHJpbnRfY2hhcl9saXRlcmFsIGJ1ZiBzdHIuW2ldXG4gIGRvbmVcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKCogRm9ybWF0IHByZXR0eS1wcmludGluZyAqKVxuXG4oKiBQcmludCBhIGNvbXBsZXRlIGZvcm1hdCB0eXBlIChhbiBmbXR0eSkgaW4gYSBidWZmZXIuICopXG5sZXQgcmVjIGJwcmludF9mbXR0eSA6IHR5cGUgYSBiIGMgZCBlIGYgZyBoIGkgaiBrIGwgLlxuICAgIGJ1ZmZlciAtPiAoYSwgYiwgYywgZCwgZSwgZiwgZywgaCwgaSwgaiwgaywgbCkgZm10dHlfcmVsIC0+IHVuaXQgPVxuZnVuIGJ1ZiBmbXR0eSAtPiBtYXRjaCBmbXR0eSB3aXRoXG4gIHwgQ2hhcl90eSByZXN0ICAgICAgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJWNcIjsgIGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBTdHJpbmdfdHkgcmVzdCAgICAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlc1wiOyAgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IEludF90eSByZXN0ICAgICAgIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiVpXCI7ICBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgSW50MzJfdHkgcmVzdCAgICAgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJWxpXCI7IGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBOYXRpdmVpbnRfdHkgcmVzdCAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlbmlcIjsgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IEludDY0X3R5IHJlc3QgICAgIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiVMaVwiOyBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgRmxvYXRfdHkgcmVzdCAgICAgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJWZcIjsgIGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBCb29sX3R5IHJlc3QgICAgICAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlQlwiOyAgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IEFscGhhX3R5IHJlc3QgICAgIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiVhXCI7ICBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgVGhldGFfdHkgcmVzdCAgICAgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJXRcIjsgIGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBBbnlfdHkgcmVzdCAgICAgICAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlP1wiOyAgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IFJlYWRlcl90eSByZXN0ICAgIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiVyXCI7ICBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG5cbiAgfCBJZ25vcmVkX3JlYWRlcl90eSByZXN0IC0+XG4gICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJV9yXCI7XG4gICAgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuXG4gIHwgRm9ybWF0X2FyZ190eSAoc3ViX2ZtdHR5LCByZXN0KSAtPlxuICAgIGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiV7XCI7IGJwcmludF9mbXR0eSBidWYgc3ViX2ZtdHR5O1xuICAgIGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiV9XCI7IGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBGb3JtYXRfc3Vic3RfdHkgKHN1Yl9mbXR0eSwgXywgcmVzdCkgLT5cbiAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlKFwiOyBicHJpbnRfZm10dHkgYnVmIHN1Yl9mbXR0eTtcbiAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlKVwiOyBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG5cbiAgfCBFbmRfb2ZfZm10dHkgLT4gKClcblxuKCoqKilcblxubGV0IHJlYyBpbnRfb2ZfY3VzdG9tX2FyaXR5IDogdHlwZSBhIGIgYyAuXG4gIChhLCBiLCBjKSBjdXN0b21fYXJpdHkgLT4gaW50ID1cbiAgZnVuY3Rpb25cbiAgfCBDdXN0b21femVybyAtPiAwXG4gIHwgQ3VzdG9tX3N1Y2MgeCAtPiAxICsgaW50X29mX2N1c3RvbV9hcml0eSB4XG5cbigqIFByaW50IGEgY29tcGxldGUgZm9ybWF0IGluIGEgYnVmZmVyLiAqKVxubGV0IGJwcmludF9mbXQgYnVmIGZtdCA9XG4gIGxldCByZWMgZm10aXRlciA6IHR5cGUgYSBiIGMgZCBlIGYgLlxuICAgICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPiBib29sIC0+IHVuaXQgPVxuICBmdW4gZm10IGlnbl9mbGFnIC0+IG1hdGNoIGZtdCB3aXRoXG4gICAgfCBTdHJpbmcgKHBhZCwgcmVzdCkgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJwcmludF9wYWRkaW5nIGJ1ZiBwYWQ7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJ3MnO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgQ2FtbF9zdHJpbmcgKHBhZCwgcmVzdCkgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJwcmludF9wYWRkaW5nIGJ1ZiBwYWQ7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJ1MnO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuXG4gICAgfCBJbnQgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgICBicHJpbnRfaW50X2ZtdCBidWYgaWduX2ZsYWcgaWNvbnYgcGFkIHByZWM7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBJbnQzMiAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICAgIGJwcmludF9hbHRpbnRfZm10IGJ1ZiBpZ25fZmxhZyBpY29udiBwYWQgcHJlYyAnbCc7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBOYXRpdmVpbnQgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgICBicHJpbnRfYWx0aW50X2ZtdCBidWYgaWduX2ZsYWcgaWNvbnYgcGFkIHByZWMgJ24nO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgSW50NjQgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgICBicHJpbnRfYWx0aW50X2ZtdCBidWYgaWduX2ZsYWcgaWNvbnYgcGFkIHByZWMgJ0wnO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgRmxvYXQgKGZjb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgICBicHJpbnRfZmxvYXRfZm10IGJ1ZiBpZ25fZmxhZyBmY29udiBwYWQgcHJlYztcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcblxuICAgIHwgQ2hhciByZXN0IC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICdjJzsgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgQ2FtbF9jaGFyIHJlc3QgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJ0MnOyBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBCb29sIChwYWQsIHJlc3QpIC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBicHJpbnRfcGFkZGluZyBidWYgcGFkOyBidWZmZXJfYWRkX2NoYXIgYnVmICdCJztcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IEFscGhhIHJlc3QgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJ2EnOyBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBUaGV0YSByZXN0IC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICd0JzsgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgQ3VzdG9tIChhcml0eSwgXywgcmVzdCkgLT5cbiAgICAgIGZvciBfaSA9IDEgdG8gaW50X29mX2N1c3RvbV9hcml0eSBhcml0eSBkb1xuICAgICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJz8nO1xuICAgICAgZG9uZTtcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IFJlYWRlciByZXN0IC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICdyJzsgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgRmx1c2ggcmVzdCAtPlxuICAgICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJSFcIjtcbiAgICAgIGZtdGl0ZXIgcmVzdCBpZ25fZmxhZztcblxuICAgIHwgU3RyaW5nX2xpdGVyYWwgKHN0ciwgcmVzdCkgLT5cbiAgICAgIGJwcmludF9zdHJpbmdfbGl0ZXJhbCBidWYgc3RyO1xuICAgICAgZm10aXRlciByZXN0IGlnbl9mbGFnO1xuICAgIHwgQ2hhcl9saXRlcmFsIChjaHIsIHJlc3QpIC0+XG4gICAgICBicHJpbnRfY2hhcl9saXRlcmFsIGJ1ZiBjaHI7XG4gICAgICBmbXRpdGVyIHJlc3QgaWduX2ZsYWc7XG5cbiAgICB8IEZvcm1hdF9hcmcgKHBhZF9vcHQsIGZtdHR5LCByZXN0KSAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnByaW50X3BhZF9vcHQgYnVmIHBhZF9vcHQ7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJ3snO1xuICAgICAgYnByaW50X2ZtdHR5IGJ1ZiBmbXR0eTsgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJ30nO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgRm9ybWF0X3N1YnN0IChwYWRfb3B0LCBmbXR0eSwgcmVzdCkgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJwcmludF9wYWRfb3B0IGJ1ZiBwYWRfb3B0OyBidWZmZXJfYWRkX2NoYXIgYnVmICcoJztcbiAgICAgIGJwcmludF9mbXR0eSBidWYgZm10dHk7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBidWZmZXJfYWRkX2NoYXIgYnVmICcpJztcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcblxuICAgIHwgU2Nhbl9jaGFyX3NldCAod2lkdGhfb3B0LCBjaGFyX3NldCwgcmVzdCkgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJwcmludF9wYWRfb3B0IGJ1ZiB3aWR0aF9vcHQ7IGJwcmludF9jaGFyX3NldCBidWYgY2hhcl9zZXQ7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBTY2FuX2dldF9jb3VudGVyIChjb3VudGVyLCByZXN0KSAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAoY2hhcl9vZl9jb3VudGVyIGNvdW50ZXIpO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgU2Nhbl9uZXh0X2NoYXIgcmVzdCAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnByaW50X3N0cmluZ19saXRlcmFsIGJ1ZiBcIjBjXCI7IGZtdGl0ZXIgcmVzdCBmYWxzZTtcblxuICAgIHwgSWdub3JlZF9wYXJhbSAoaWduLCByZXN0KSAtPlxuICAgICAgbGV0IFBhcmFtX2Zvcm1hdF9FQkIgZm10JyA9IHBhcmFtX2Zvcm1hdF9vZl9pZ25vcmVkX2Zvcm1hdCBpZ24gcmVzdCBpblxuICAgICAgZm10aXRlciBmbXQnIHRydWU7XG5cbiAgICB8IEZvcm1hdHRpbmdfbGl0IChmbXRpbmdfbGl0LCByZXN0KSAtPlxuICAgICAgYnByaW50X3N0cmluZ19saXRlcmFsIGJ1ZiAoc3RyaW5nX29mX2Zvcm1hdHRpbmdfbGl0IGZtdGluZ19saXQpO1xuICAgICAgZm10aXRlciByZXN0IGlnbl9mbGFnO1xuICAgIHwgRm9ybWF0dGluZ19nZW4gKGZtdGluZ19nZW4sIHJlc3QpIC0+XG4gICAgICBiZWdpbiBtYXRjaCBmbXRpbmdfZ2VuIHdpdGhcbiAgICAgIHwgT3Blbl90YWcgKEZvcm1hdCAoXywgc3RyKSkgLT5cbiAgICAgICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiQHtcIjsgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIHN0clxuICAgICAgfCBPcGVuX2JveCAoRm9ybWF0IChfLCBzdHIpKSAtPlxuICAgICAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgXCJAW1wiOyBidWZmZXJfYWRkX3N0cmluZyBidWYgc3RyXG4gICAgICBlbmQ7XG4gICAgICBmbXRpdGVyIHJlc3QgaWduX2ZsYWc7XG5cbiAgICB8IEVuZF9vZl9mb3JtYXQgLT4gKClcblxuICBpbiBmbXRpdGVyIGZtdCBmYWxzZVxuXG4oKioqKVxuXG4oKiBDb252ZXJ0IGEgZm9ybWF0IHRvIHN0cmluZy4gKilcbmxldCBzdHJpbmdfb2ZfZm10IGZtdCA9XG4gIGxldCBidWYgPSBidWZmZXJfY3JlYXRlIDE2IGluXG4gIGJwcmludF9mbXQgYnVmIGZtdDtcbiAgYnVmZmVyX2NvbnRlbnRzIGJ1ZlxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBUeXBlIGV4dHJhY3Rpb24gKilcblxudHlwZSAoXywgXykgZXEgPSBSZWZsIDogKCdhLCAnYSkgZXFcblxuKCogSW52YXJpYW50OiB0aGlzIGZ1bmN0aW9uIGlzIHRoZSBpZGVudGl0eSBvbiB2YWx1ZXMuXG5cbiAgIEluIHBhcnRpY3VsYXIsIGlmICh0eTEsIHR5MikgaGF2ZSBlcXVhbCB2YWx1ZXMsIHRoZW5cbiAgICh0cmFucyAoc3ltbSB0eTEpIHR5MikgcmVzcGVjdHMgdGhlICd0cmFucycgcHJlY29uZGl0aW9uLiAqKVxubGV0IHJlYyBzeW1tIDogdHlwZSBhMSBiMSBjMSBkMSBlMSBmMSBhMiBiMiBjMiBkMiBlMiBmMiAuXG4gICAoYTEsIGIxLCBjMSwgZDEsIGUxLCBmMSxcbiAgICBhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXR0eV9yZWxcbi0+IChhMiwgYjIsIGMyLCBkMiwgZTIsIGYyLFxuICAgIGExLCBiMSwgYzEsIGQxLCBlMSwgZjEpIGZtdHR5X3JlbFxuPSBmdW5jdGlvblxuICB8IENoYXJfdHkgcmVzdCAtPiBDaGFyX3R5IChzeW1tIHJlc3QpXG4gIHwgSW50X3R5IHJlc3QgLT4gSW50X3R5IChzeW1tIHJlc3QpXG4gIHwgSW50MzJfdHkgcmVzdCAtPiBJbnQzMl90eSAoc3ltbSByZXN0KVxuICB8IEludDY0X3R5IHJlc3QgLT4gSW50NjRfdHkgKHN5bW0gcmVzdClcbiAgfCBOYXRpdmVpbnRfdHkgcmVzdCAtPiBOYXRpdmVpbnRfdHkgKHN5bW0gcmVzdClcbiAgfCBGbG9hdF90eSByZXN0IC0+IEZsb2F0X3R5IChzeW1tIHJlc3QpXG4gIHwgQm9vbF90eSByZXN0IC0+IEJvb2xfdHkgKHN5bW0gcmVzdClcbiAgfCBTdHJpbmdfdHkgcmVzdCAtPiBTdHJpbmdfdHkgKHN5bW0gcmVzdClcbiAgfCBUaGV0YV90eSByZXN0IC0+IFRoZXRhX3R5IChzeW1tIHJlc3QpXG4gIHwgQWxwaGFfdHkgcmVzdCAtPiBBbHBoYV90eSAoc3ltbSByZXN0KVxuICB8IEFueV90eSByZXN0IC0+IEFueV90eSAoc3ltbSByZXN0KVxuICB8IFJlYWRlcl90eSByZXN0IC0+IFJlYWRlcl90eSAoc3ltbSByZXN0KVxuICB8IElnbm9yZWRfcmVhZGVyX3R5IHJlc3QgLT4gSWdub3JlZF9yZWFkZXJfdHkgKHN5bW0gcmVzdClcbiAgfCBGb3JtYXRfYXJnX3R5ICh0eSwgcmVzdCkgLT5cbiAgICBGb3JtYXRfYXJnX3R5ICh0eSwgc3ltbSByZXN0KVxuICB8IEZvcm1hdF9zdWJzdF90eSAodHkxLCB0eTIsIHJlc3QpIC0+XG4gICAgRm9ybWF0X3N1YnN0X3R5ICh0eTIsIHR5MSwgc3ltbSByZXN0KVxuICB8IEVuZF9vZl9mbXR0eSAtPiBFbmRfb2ZfZm10dHlcblxubGV0IHJlYyBmbXR0eV9yZWxfZGV0IDogdHlwZSBhMSBiIGMgZDEgZTEgZjEgYTIgZDIgZTIgZjIgLlxuICAoYTEsIGIsIGMsIGQxLCBlMSwgZjEsXG4gICBhMiwgYiwgYywgZDIsIGUyLCBmMikgZm10dHlfcmVsIC0+XG4gICAgKChmMSwgZjIpIGVxIC0+IChhMSwgYTIpIGVxKVxuICAqICgoYTEsIGEyKSBlcSAtPiAoZjEsIGYyKSBlcSlcbiAgKiAoKGUxLCBlMikgZXEgLT4gKGQxLCBkMikgZXEpXG4gICogKChkMSwgZDIpIGVxIC0+IChlMSwgZTIpIGVxKVxuPSBmdW5jdGlvblxuICB8IEVuZF9vZl9mbXR0eSAtPlxuICAgIChmdW4gUmVmbCAtPiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBSZWZsKVxuICB8IENoYXJfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcbiAgfCBTdHJpbmdfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcbiAgfCBJbnRfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcbiAgfCBJbnQzMl90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuICB8IEludDY0X3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG4gIHwgTmF0aXZlaW50X3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG4gIHwgRmxvYXRfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcbiAgfCBCb29sX3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG5cbiAgfCBUaGV0YV90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuICB8IEFscGhhX3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG4gIHwgQW55X3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG4gIHwgUmVhZGVyX3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZWQgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBkZSBSZWZsIGluIFJlZmwpXG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBlZCBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGRlIFJlZmwgaW4gUmVmbClcbiAgfCBGb3JtYXRfYXJnX3R5IChfdHksIHJlc3QpIC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuICB8IEZvcm1hdF9zdWJzdF90eSAodHkxLCB0eTIsIHJlc3QpIC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgbGV0IHR5ID0gdHJhbnMgKHN5bW0gdHkxKSB0eTIgaW5cbiAgICBsZXQgYWcsIGdhLCBkaiwgamQgPSBmbXR0eV9yZWxfZGV0IHR5IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBsZXQgUmVmbCA9IGFnIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZ2EgUmVmbCBpbiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZWQgUmVmbCBpbiBsZXQgUmVmbCA9IGRqIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gamQgUmVmbCBpbiBsZXQgUmVmbCA9IGRlIFJlZmwgaW4gUmVmbClcblxuKCogUHJlY29uZGl0aW9uOiB3ZSBhc3N1bWUgdGhhdCB0aGUgdHdvIGZtdHR5X3JlbCBhcmd1bWVudHMgaGF2ZSBlcXVhbFxuICAgdmFsdWVzIChhdCBwb3NzaWJseSBkaXN0aW5jdCB0eXBlcyk7IHRoaXMgaW52YXJpYW50IGNvbWVzIGZyb20gdGhlIHdheVxuICAgZm10dHlfcmVsIHdpdG5lc3NlcyBhcmUgcHJvZHVjZWQgYnkgdGhlIHR5cGUtY2hlY2tlclxuXG4gICBUaGUgY29kZSBiZWxvdyB1c2VzIChhc3NlcnQgZmFsc2UpIHdoZW4gdGhpcyBhc3N1bXB0aW9uIGlzIGJyb2tlbi4gVGhlXG4gICBjb2RlIHBhdHRlcm4gaXMgdGhlIGZvbGxvd2luZzpcblxuICAgICB8IEZvbyB4LCBGb28geSAtPlxuICAgICAgICgqIGNhc2Ugd2hlcmUgaW5kZWVkIGJvdGggdmFsdWVzXG4gICAgICAgICAgc3RhcnQgd2l0aCBjb25zdHJ1Y3RvciBGb28gKilcbiAgICAgfCBGb28gXywgX1xuICAgICB8IF8sIEZvbyBfIC0+XG4gICAgICAgKCogZGlmZmVyZW50IGhlYWQgY29uc3RydWN0b3JzOiBicm9rZW4gcHJlY29uZGl0aW9uICopXG4gICAgICAgYXNzZXJ0IGZhbHNlXG4qKVxuYW5kIHRyYW5zIDogdHlwZVxuICBhMSBiMSBjMSBkMSBlMSBmMVxuICBhMiBiMiBjMiBkMiBlMiBmMlxuICBhMyBiMyBjMyBkMyBlMyBmM1xuLlxuICAgKGExLCBiMSwgYzEsIGQxLCBlMSwgZjEsXG4gICAgYTIsIGIyLCBjMiwgZDIsIGUyLCBmMikgZm10dHlfcmVsXG4tPiAoYTIsIGIyLCBjMiwgZDIsIGUyLCBmMixcbiAgICBhMywgYjMsIGMzLCBkMywgZTMsIGYzKSBmbXR0eV9yZWxcbi0+IChhMSwgYjEsIGMxLCBkMSwgZTEsIGYxLFxuICAgIGEzLCBiMywgYzMsIGQzLCBlMywgZjMpIGZtdHR5X3JlbFxuPSBmdW4gdHkxIHR5MiAtPiBtYXRjaCB0eTEsIHR5MiB3aXRoXG4gIHwgQ2hhcl90eSByZXN0MSwgQ2hhcl90eSByZXN0MiAtPiBDaGFyX3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBTdHJpbmdfdHkgcmVzdDEsIFN0cmluZ190eSByZXN0MiAtPiBTdHJpbmdfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IEJvb2xfdHkgcmVzdDEsIEJvb2xfdHkgcmVzdDIgLT4gQm9vbF90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgSW50X3R5IHJlc3QxLCBJbnRfdHkgcmVzdDIgLT4gSW50X3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBJbnQzMl90eSByZXN0MSwgSW50MzJfdHkgcmVzdDIgLT4gSW50MzJfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IEludDY0X3R5IHJlc3QxLCBJbnQ2NF90eSByZXN0MiAtPiBJbnQ2NF90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgTmF0aXZlaW50X3R5IHJlc3QxLCBOYXRpdmVpbnRfdHkgcmVzdDIgLT4gTmF0aXZlaW50X3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBGbG9hdF90eSByZXN0MSwgRmxvYXRfdHkgcmVzdDIgLT4gRmxvYXRfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuXG4gIHwgQWxwaGFfdHkgcmVzdDEsIEFscGhhX3R5IHJlc3QyIC0+IEFscGhhX3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBBbHBoYV90eSBfLCBfIC0+IGFzc2VydCBmYWxzZVxuICB8IF8sIEFscGhhX3R5IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiAgfCBUaGV0YV90eSByZXN0MSwgVGhldGFfdHkgcmVzdDIgLT4gVGhldGFfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IFRoZXRhX3R5IF8sIF8gLT4gYXNzZXJ0IGZhbHNlXG4gIHwgXywgVGhldGFfdHkgXyAtPiBhc3NlcnQgZmFsc2VcblxuICB8IEFueV90eSByZXN0MSwgQW55X3R5IHJlc3QyIC0+IEFueV90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgQW55X3R5IF8sIF8gLT4gYXNzZXJ0IGZhbHNlXG4gIHwgXywgQW55X3R5IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiAgfCBSZWFkZXJfdHkgcmVzdDEsIFJlYWRlcl90eSByZXN0MiAtPiBSZWFkZXJfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IFJlYWRlcl90eSBfLCBfIC0+IGFzc2VydCBmYWxzZVxuICB8IF8sIFJlYWRlcl90eSBfIC0+IGFzc2VydCBmYWxzZVxuXG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgcmVzdDEsIElnbm9yZWRfcmVhZGVyX3R5IHJlc3QyIC0+XG4gICAgSWdub3JlZF9yZWFkZXJfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IElnbm9yZWRfcmVhZGVyX3R5IF8sIF8gLT4gYXNzZXJ0IGZhbHNlXG4gIHwgXywgSWdub3JlZF9yZWFkZXJfdHkgXyAtPiBhc3NlcnQgZmFsc2VcblxuICB8IEZvcm1hdF9hcmdfdHkgKHR5MSwgcmVzdDEpLCBGb3JtYXRfYXJnX3R5ICh0eTIsIHJlc3QyKSAtPlxuICAgIEZvcm1hdF9hcmdfdHkgKHRyYW5zIHR5MSB0eTIsIHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IEZvcm1hdF9hcmdfdHkgXywgXyAtPiBhc3NlcnQgZmFsc2VcbiAgfCBfLCBGb3JtYXRfYXJnX3R5IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiAgfCBGb3JtYXRfc3Vic3RfdHkgKHR5MTEsIHR5MTIsIHJlc3QxKSxcbiAgICBGb3JtYXRfc3Vic3RfdHkgKHR5MjEsIHR5MjIsIHJlc3QyKSAtPlxuICAgIGxldCB0eSA9IHRyYW5zIChzeW1tIHR5MTIpIHR5MjEgaW5cbiAgICBsZXQgXywgZjIsIF8sIGY0ID0gZm10dHlfcmVsX2RldCB0eSBpblxuICAgIGxldCBSZWZsID0gZjIgUmVmbCBpblxuICAgIGxldCBSZWZsID0gZjQgUmVmbCBpblxuICAgIEZvcm1hdF9zdWJzdF90eSAodHkxMSwgdHkyMiwgdHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgRm9ybWF0X3N1YnN0X3R5IF8sIF8gLT4gYXNzZXJ0IGZhbHNlXG4gIHwgXywgRm9ybWF0X3N1YnN0X3R5IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiAgfCBFbmRfb2ZfZm10dHksIEVuZF9vZl9mbXR0eSAtPiBFbmRfb2ZfZm10dHlcbiAgfCBFbmRfb2ZfZm10dHksIF8gLT4gYXNzZXJ0IGZhbHNlXG4gIHwgXywgRW5kX29mX2ZtdHR5IC0+IGFzc2VydCBmYWxzZVxuXG5sZXQgcmVjIGZtdHR5X29mX2Zvcm1hdHRpbmdfZ2VuIDogdHlwZSBhIGIgYyBkIGUgZiAuXG4gIChhLCBiLCBjLCBkLCBlLCBmKSBmb3JtYXR0aW5nX2dlbiAtPlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSA9XG5mdW4gZm9ybWF0dGluZ19nZW4gLT4gbWF0Y2ggZm9ybWF0dGluZ19nZW4gd2l0aFxuICB8IE9wZW5fdGFnIChGb3JtYXQgKGZtdCwgXykpIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBPcGVuX2JveCAoRm9ybWF0IChmbXQsIF8pKSAtPiBmbXR0eV9vZl9mbXQgZm10XG5cbigqIEV4dHJhY3QgdGhlIHR5cGUgcmVwcmVzZW50YXRpb24gKGFuIGZtdHR5KSBvZiBhIGZvcm1hdC4gKilcbmFuZCBmbXR0eV9vZl9mbXQgOiB0eXBlIGEgYiBjIGQgZSBmIC5cbiAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10dHkgPVxuZnVuIGZtdHR5IC0+IG1hdGNoIGZtdHR5IHdpdGhcbiAgfCBTdHJpbmcgKHBhZCwgcmVzdCkgLT5cbiAgICBmbXR0eV9vZl9wYWRkaW5nX2ZtdHR5IHBhZCAoU3RyaW5nX3R5IChmbXR0eV9vZl9mbXQgcmVzdCkpXG4gIHwgQ2FtbF9zdHJpbmcgKHBhZCwgcmVzdCkgLT5cbiAgICBmbXR0eV9vZl9wYWRkaW5nX2ZtdHR5IHBhZCAoU3RyaW5nX3R5IChmbXR0eV9vZl9mbXQgcmVzdCkpXG5cbiAgfCBJbnQgKF8sIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBsZXQgdHlfcmVzdCA9IGZtdHR5X29mX2ZtdCByZXN0IGluXG4gICAgbGV0IHByZWNfdHkgPSBmbXR0eV9vZl9wcmVjaXNpb25fZm10dHkgcHJlYyAoSW50X3R5IHR5X3Jlc3QpIGluXG4gICAgZm10dHlfb2ZfcGFkZGluZ19mbXR0eSBwYWQgcHJlY190eVxuICB8IEludDMyIChfLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbGV0IHR5X3Jlc3QgPSBmbXR0eV9vZl9mbXQgcmVzdCBpblxuICAgIGxldCBwcmVjX3R5ID0gZm10dHlfb2ZfcHJlY2lzaW9uX2ZtdHR5IHByZWMgKEludDMyX3R5IHR5X3Jlc3QpIGluXG4gICAgZm10dHlfb2ZfcGFkZGluZ19mbXR0eSBwYWQgcHJlY190eVxuICB8IE5hdGl2ZWludCAoXywgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIGxldCB0eV9yZXN0ID0gZm10dHlfb2ZfZm10IHJlc3QgaW5cbiAgICBsZXQgcHJlY190eSA9IGZtdHR5X29mX3ByZWNpc2lvbl9mbXR0eSBwcmVjIChOYXRpdmVpbnRfdHkgdHlfcmVzdCkgaW5cbiAgICBmbXR0eV9vZl9wYWRkaW5nX2ZtdHR5IHBhZCBwcmVjX3R5XG4gIHwgSW50NjQgKF8sIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBsZXQgdHlfcmVzdCA9IGZtdHR5X29mX2ZtdCByZXN0IGluXG4gICAgbGV0IHByZWNfdHkgPSBmbXR0eV9vZl9wcmVjaXNpb25fZm10dHkgcHJlYyAoSW50NjRfdHkgdHlfcmVzdCkgaW5cbiAgICBmbXR0eV9vZl9wYWRkaW5nX2ZtdHR5IHBhZCBwcmVjX3R5XG4gIHwgRmxvYXQgKF8sIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBsZXQgdHlfcmVzdCA9IGZtdHR5X29mX2ZtdCByZXN0IGluXG4gICAgbGV0IHByZWNfdHkgPSBmbXR0eV9vZl9wcmVjaXNpb25fZm10dHkgcHJlYyAoRmxvYXRfdHkgdHlfcmVzdCkgaW5cbiAgICBmbXR0eV9vZl9wYWRkaW5nX2ZtdHR5IHBhZCBwcmVjX3R5XG5cbiAgfCBDaGFyIHJlc3QgICAgICAgICAgICAgICAgICAtPiBDaGFyX3R5IChmbXR0eV9vZl9mbXQgcmVzdClcbiAgfCBDYW1sX2NoYXIgcmVzdCAgICAgICAgICAgICAtPiBDaGFyX3R5IChmbXR0eV9vZl9mbXQgcmVzdClcbiAgfCBCb29sIChwYWQsIHJlc3QpICAgICAgICAgICAtPlxuICAgICAgZm10dHlfb2ZfcGFkZGluZ19mbXR0eSBwYWQgKEJvb2xfdHkgKGZtdHR5X29mX2ZtdCByZXN0KSlcbiAgfCBBbHBoYSByZXN0ICAgICAgICAgICAgICAgICAtPiBBbHBoYV90eSAoZm10dHlfb2ZfZm10IHJlc3QpXG4gIHwgVGhldGEgcmVzdCAgICAgICAgICAgICAgICAgLT4gVGhldGFfdHkgKGZtdHR5X29mX2ZtdCByZXN0KVxuICB8IEN1c3RvbSAoYXJpdHksIF8sIHJlc3QpICAgIC0+IGZtdHR5X29mX2N1c3RvbSBhcml0eSAoZm10dHlfb2ZfZm10IHJlc3QpXG4gIHwgUmVhZGVyIHJlc3QgICAgICAgICAgICAgICAgLT4gUmVhZGVyX3R5IChmbXR0eV9vZl9mbXQgcmVzdClcblxuICB8IEZvcm1hdF9hcmcgKF8sIHR5LCByZXN0KSAtPlxuICAgIEZvcm1hdF9hcmdfdHkgKHR5LCBmbXR0eV9vZl9mbXQgcmVzdClcbiAgfCBGb3JtYXRfc3Vic3QgKF8sIHR5LCByZXN0KSAtPlxuICAgIEZvcm1hdF9zdWJzdF90eSAodHksIHR5LCBmbXR0eV9vZl9mbXQgcmVzdClcblxuICB8IEZsdXNoIHJlc3QgICAgICAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCByZXN0XG4gIHwgU3RyaW5nX2xpdGVyYWwgKF8sIHJlc3QpICAgLT4gZm10dHlfb2ZfZm10IHJlc3RcbiAgfCBDaGFyX2xpdGVyYWwgKF8sIHJlc3QpICAgICAtPiBmbXR0eV9vZl9mbXQgcmVzdFxuXG4gIHwgU2Nhbl9jaGFyX3NldCAoXywgXywgcmVzdCkgLT4gU3RyaW5nX3R5IChmbXR0eV9vZl9mbXQgcmVzdClcbiAgfCBTY2FuX2dldF9jb3VudGVyIChfLCByZXN0KSAtPiBJbnRfdHkgKGZtdHR5X29mX2ZtdCByZXN0KVxuICB8IFNjYW5fbmV4dF9jaGFyIHJlc3QgICAgICAgIC0+IENoYXJfdHkgKGZtdHR5X29mX2ZtdCByZXN0KVxuICB8IElnbm9yZWRfcGFyYW0gKGlnbiwgcmVzdCkgIC0+IGZtdHR5X29mX2lnbm9yZWRfZm9ybWF0IGlnbiByZXN0XG4gIHwgRm9ybWF0dGluZ19saXQgKF8sIHJlc3QpICAgLT4gZm10dHlfb2ZfZm10IHJlc3RcbiAgfCBGb3JtYXR0aW5nX2dlbiAoZm10aW5nX2dlbiwgcmVzdCkgIC0+XG4gICAgY29uY2F0X2ZtdHR5IChmbXR0eV9vZl9mb3JtYXR0aW5nX2dlbiBmbXRpbmdfZ2VuKSAoZm10dHlfb2ZfZm10IHJlc3QpXG5cbiAgfCBFbmRfb2ZfZm9ybWF0ICAgICAgICAgICAgICAtPiBFbmRfb2ZfZm10dHlcblxuYW5kIGZtdHR5X29mX2N1c3RvbSA6IHR5cGUgeCB5IGEgYiBjIGQgZSBmIC5cbiAgKGEsIHgsIHkpIGN1c3RvbV9hcml0eSAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10dHkgLT5cbiAgKHksIGIsIGMsIGQsIGUsIGYpIGZtdHR5ID1cbmZ1biBhcml0eSBmbXR0eSAtPiBtYXRjaCBhcml0eSB3aXRoXG4gIHwgQ3VzdG9tX3plcm8gLT4gZm10dHlcbiAgfCBDdXN0b21fc3VjYyBhcml0eSAtPiBBbnlfdHkgKGZtdHR5X29mX2N1c3RvbSBhcml0eSBmbXR0eSlcblxuKCogRXh0cmFjdCB0aGUgZm10dHkgb2YgYW4gaWdub3JlZCBwYXJhbWV0ZXIgZm9sbG93ZWQgYnkgdGhlIHJlc3Qgb2ZcbiAgIHRoZSBmb3JtYXQuICopXG5hbmQgZm10dHlfb2ZfaWdub3JlZF9mb3JtYXQgOiB0eXBlIHggeSBhIGIgYyBkIGUgZiAuXG4gICAgKGEsIGIsIGMsIGQsIHksIHgpIGlnbm9yZWQgLT5cbiAgICAoeCwgYiwgYywgeSwgZSwgZikgZm10IC0+XG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5ID1cbmZ1biBpZ24gZm10IC0+IG1hdGNoIGlnbiB3aXRoXG4gIHwgSWdub3JlZF9jaGFyICAgICAgICAgICAgICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9jYW1sX2NoYXIgICAgICAgICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9zdHJpbmcgXyAgICAgICAgICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9jYW1sX3N0cmluZyBfICAgICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9pbnQgKF8sIF8pICAgICAgICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9pbnQzMiAoXywgXykgICAgICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9uYXRpdmVpbnQgKF8sIF8pICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9pbnQ2NCAoXywgXykgICAgICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9mbG9hdCAoXywgXykgICAgICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9ib29sIF8gICAgICAgICAgICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9mb3JtYXRfYXJnIF8gICAgICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9mb3JtYXRfc3Vic3QgKF8sIGZtdHR5KSAtPiBjb25jYXRfZm10dHkgZm10dHkgKGZtdHR5X29mX2ZtdCBmbXQpXG4gIHwgSWdub3JlZF9yZWFkZXIgICAgICAgICAgICAgICAgICAtPiBJZ25vcmVkX3JlYWRlcl90eSAoZm10dHlfb2ZfZm10IGZtdClcbiAgfCBJZ25vcmVkX3NjYW5fY2hhcl9zZXQgXyAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX3NjYW5fZ2V0X2NvdW50ZXIgXyAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX3NjYW5fbmV4dF9jaGFyICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcblxuKCogQWRkIGFuIEludF90eSBub2RlIGlmIHBhZGRpbmcgaXMgdGFrZW4gYXMgYW4gZXh0cmEgYXJndW1lbnQgKGV4OiBcIiUqc1wiKS4gKilcbmFuZCBmbXR0eV9vZl9wYWRkaW5nX2ZtdHR5IDogdHlwZSB4IGEgYiBjIGQgZSBmIC5cbiAgICAoeCwgYSkgcGFkZGluZyAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10dHkgLT4gKHgsIGIsIGMsIGQsIGUsIGYpIGZtdHR5ID1cbiAgZnVuIHBhZCBmbXR0eSAtPiBtYXRjaCBwYWQgd2l0aFxuICAgIHwgTm9fcGFkZGluZyAgICAtPiBmbXR0eVxuICAgIHwgTGl0X3BhZGRpbmcgXyAtPiBmbXR0eVxuICAgIHwgQXJnX3BhZGRpbmcgXyAtPiBJbnRfdHkgZm10dHlcblxuKCogQWRkIGFuIEludF90eSBub2RlIGlmIHByZWNpc2lvbiBpcyB0YWtlbiBhcyBhbiBleHRyYSBhcmd1bWVudCAoZXg6IFwiJS4qZlwiKS4qKVxuYW5kIGZtdHR5X29mX3ByZWNpc2lvbl9mbXR0eSA6IHR5cGUgeCBhIGIgYyBkIGUgZiAuXG4gICAgKHgsIGEpIHByZWNpc2lvbiAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10dHkgLT4gKHgsIGIsIGMsIGQsIGUsIGYpIGZtdHR5ID1cbiAgZnVuIHByZWMgZm10dHkgLT4gbWF0Y2ggcHJlYyB3aXRoXG4gICAgfCBOb19wcmVjaXNpb24gICAgLT4gZm10dHlcbiAgICB8IExpdF9wcmVjaXNpb24gXyAtPiBmbXR0eVxuICAgIHwgQXJnX3ByZWNpc2lvbiAgIC0+IEludF90eSBmbXR0eVxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEZvcm1hdCB0eXBpbmcgKilcblxuKCogRXhjZXB0aW9uIHJhaXNlZCB3aGVuIGEgZm9ybWF0IGRvZXMgbm90IG1hdGNoIGEgZ2l2ZW4gZm9ybWF0IHR5cGUuICopXG5leGNlcHRpb24gVHlwZV9taXNtYXRjaFxuXG4oKiBUeXBlIGEgcGFkZGluZy4gKilcbigqIFRha2UgYW4gSW50X3R5IGZyb20gdGhlIGZtdHR5IGlmIHRoZSBpbnRlZ2VyIHNob3VsZCBiZSBrZXB0IGFzIGFyZ3VtZW50LiAqKVxuKCogUmFpc2UgVHlwZV9taXNtYXRjaCBpbiBjYXNlIG9mIHR5cGUgbWlzbWF0Y2guICopXG5sZXQgdHlwZV9wYWRkaW5nIDogdHlwZSBhIGIgYyBkIGUgZiB4IHkgLlxuICAgICh4LCB5KSBwYWRkaW5nIC0+IChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSAtPlxuICAgICAgKGEsIGIsIGMsIGQsIGUsIGYpIHBhZGRpbmdfZm10dHlfZWJiID1cbmZ1biBwYWQgZm10dHkgLT4gbWF0Y2ggcGFkLCBmbXR0eSB3aXRoXG4gIHwgTm9fcGFkZGluZywgXyAtPiBQYWRkaW5nX2ZtdHR5X0VCQiAoTm9fcGFkZGluZywgZm10dHkpXG4gIHwgTGl0X3BhZGRpbmcgKHBhZHR5LCB3KSwgXyAtPiBQYWRkaW5nX2ZtdHR5X0VCQiAoTGl0X3BhZGRpbmcgKHBhZHR5LHcpLGZtdHR5KVxuICB8IEFyZ19wYWRkaW5nIHBhZHR5LCBJbnRfdHkgcmVzdCAtPiBQYWRkaW5nX2ZtdHR5X0VCQiAoQXJnX3BhZGRpbmcgcGFkdHkscmVzdClcbiAgfCBfIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcblxuKCogQ29udmVydCBhICh1cGFkZGluZywgdXByZWNpc2lvbikgdG8gYSAocGFkZGluZywgcHJlY2lzaW9uKS4gKilcbigqIFRha2Ugb25lIG9yIHR3byBJbnRfdHkgZnJvbSB0aGUgZm10dHkgaWYgbmVlZGVkLiAqKVxuKCogUmFpc2UgVHlwZV9taXNtYXRjaCBpbiBjYXNlIG9mIHR5cGUgbWlzbWF0Y2guICopXG5sZXQgdHlwZV9wYWRwcmVjIDogdHlwZSBhIGIgYyBkIGUgZiB4IHkgeiAuXG4gICh4LCB5KSBwYWRkaW5nIC0+ICh5LCB6KSBwcmVjaXNpb24gLT4gKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5IC0+XG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIHBhZHByZWNfZm10dHlfZWJiID1cbmZ1biBwYWQgcHJlYyBmbXR0eSAtPiBtYXRjaCBwcmVjLCB0eXBlX3BhZGRpbmcgcGFkIGZtdHR5IHdpdGhcbiAgfCBOb19wcmVjaXNpb24sIFBhZGRpbmdfZm10dHlfRUJCIChwYWQsIHJlc3QpIC0+XG4gICAgUGFkcHJlY19mbXR0eV9FQkIgKHBhZCwgTm9fcHJlY2lzaW9uLCByZXN0KVxuICB8IExpdF9wcmVjaXNpb24gcCwgUGFkZGluZ19mbXR0eV9FQkIgKHBhZCwgcmVzdCkgLT5cbiAgICBQYWRwcmVjX2ZtdHR5X0VCQiAocGFkLCBMaXRfcHJlY2lzaW9uIHAsIHJlc3QpXG4gIHwgQXJnX3ByZWNpc2lvbiwgUGFkZGluZ19mbXR0eV9FQkIgKHBhZCwgSW50X3R5IHJlc3QpIC0+XG4gICAgUGFkcHJlY19mbXR0eV9FQkIgKHBhZCwgQXJnX3ByZWNpc2lvbiwgcmVzdClcbiAgfCBfLCBQYWRkaW5nX2ZtdHR5X0VCQiAoXywgXykgLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuXG4oKiBUeXBlIGEgZm9ybWF0IGFjY29yZGluZyB0byBhbiBmbXR0eS4gKilcbigqIElmIHR5cGluZyBzdWNjZWVkLCBnZW5lcmF0ZSBhIGNvcHkgb2YgdGhlIGZvcm1hdCB3aXRoIHRoZSBzYW1lXG4gICAgdHlwZSBwYXJhbWV0ZXJzIGFzIHRoZSBmbXR0eS4gKilcbigqIFJhaXNlIFtGYWlsdXJlXSB3aXRoIGFuIGVycm9yIG1lc3NhZ2UgaW4gY2FzZSBvZiB0eXBlIG1pc21hdGNoLiAqKVxubGV0IHJlYyB0eXBlX2Zvcm1hdCA6XG4gIHR5cGUgYTEgYjEgYzEgZDEgZTEgZjFcbiAgICAgICBhMiBiMiBjMiBkMiBlMiBmMiAgLlxuICAgICAoYTEsIGIxLCBjMSwgZDEsIGUxLCBmMSkgZm10XG4gIC0+IChhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXR0eVxuICAtPiAoYTIsIGIyLCBjMiwgZDIsIGUyLCBmMikgZm10XG49IGZ1biBmbXQgZm10dHkgLT4gbWF0Y2ggdHlwZV9mb3JtYXRfZ2VuIGZtdCBmbXR0eSB3aXRoXG4gIHwgRm10X2ZtdHR5X0VCQiAoZm10JywgRW5kX29mX2ZtdHR5KSAtPiBmbXQnXG4gIHwgXyAtPiByYWlzZSBUeXBlX21pc21hdGNoXG5cbmFuZCB0eXBlX2Zvcm1hdF9nZW4gOlxuICB0eXBlIGExIGIxIGMxIGQxIGUxIGYxXG4gICAgICAgYTIgYjIgYzIgZDIgZTIgZjIgIC5cbiAgICAgKGExLCBiMSwgYzEsIGQxLCBlMSwgZjEpIGZtdFxuICAtPiAoYTIsIGIyLCBjMiwgZDIsIGUyLCBmMikgZm10dHlcbiAgLT4gKGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIpIGZtdF9mbXR0eV9lYmJcbj0gZnVuIGZtdCBmbXR0eSAtPiBtYXRjaCBmbXQsIGZtdHR5IHdpdGhcbiAgfCBDaGFyIGZtdF9yZXN0LCBDaGFyX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoQ2hhciBmbXQnLCBmbXR0eScpXG4gIHwgQ2FtbF9jaGFyIGZtdF9yZXN0LCBDaGFyX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoQ2FtbF9jaGFyIGZtdCcsIGZtdHR5JylcbiAgfCBTdHJpbmcgKHBhZCwgZm10X3Jlc3QpLCBfIC0+IChcbiAgICBtYXRjaCB0eXBlX3BhZGRpbmcgcGFkIGZtdHR5IHdpdGhcbiAgICB8IFBhZGRpbmdfZm10dHlfRUJCIChwYWQsIFN0cmluZ190eSBmbXR0eV9yZXN0KSAtPlxuICAgICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgICAgRm10X2ZtdHR5X0VCQiAoU3RyaW5nIChwYWQsIGZtdCcpLCBmbXR0eScpXG4gICAgfCBQYWRkaW5nX2ZtdHR5X0VCQiAoXywgXykgLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuICApXG4gIHwgQ2FtbF9zdHJpbmcgKHBhZCwgZm10X3Jlc3QpLCBfIC0+IChcbiAgICBtYXRjaCB0eXBlX3BhZGRpbmcgcGFkIGZtdHR5IHdpdGhcbiAgICB8IFBhZGRpbmdfZm10dHlfRUJCIChwYWQsIFN0cmluZ190eSBmbXR0eV9yZXN0KSAtPlxuICAgICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgICAgRm10X2ZtdHR5X0VCQiAoQ2FtbF9zdHJpbmcgKHBhZCwgZm10JyksIGZtdHR5JylcbiAgICB8IFBhZGRpbmdfZm10dHlfRUJCIChfLCBfKSAtPiByYWlzZSBUeXBlX21pc21hdGNoXG4gIClcbiAgfCBJbnQgKGljb252LCBwYWQsIHByZWMsIGZtdF9yZXN0KSwgXyAtPiAoXG4gICAgbWF0Y2ggdHlwZV9wYWRwcmVjIHBhZCBwcmVjIGZtdHR5IHdpdGhcbiAgICB8IFBhZHByZWNfZm10dHlfRUJCIChwYWQsIHByZWMsIEludF90eSBmbXR0eV9yZXN0KSAtPlxuICAgICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgICAgRm10X2ZtdHR5X0VCQiAoSW50IChpY29udiwgcGFkLCBwcmVjLCBmbXQnKSwgZm10dHknKVxuICAgIHwgUGFkcHJlY19mbXR0eV9FQkIgKF8sIF8sIF8pIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcbiAgKVxuICB8IEludDMyIChpY29udiwgcGFkLCBwcmVjLCBmbXRfcmVzdCksIF8gLT4gKFxuICAgIG1hdGNoIHR5cGVfcGFkcHJlYyBwYWQgcHJlYyBmbXR0eSB3aXRoXG4gICAgfCBQYWRwcmVjX2ZtdHR5X0VCQiAocGFkLCBwcmVjLCBJbnQzMl90eSBmbXR0eV9yZXN0KSAtPlxuICAgICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgICAgRm10X2ZtdHR5X0VCQiAoSW50MzIgKGljb252LCBwYWQsIHByZWMsIGZtdCcpLCBmbXR0eScpXG4gICAgfCBQYWRwcmVjX2ZtdHR5X0VCQiAoXywgXywgXykgLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuICApXG4gIHwgTmF0aXZlaW50IChpY29udiwgcGFkLCBwcmVjLCBmbXRfcmVzdCksIF8gLT4gKFxuICAgIG1hdGNoIHR5cGVfcGFkcHJlYyBwYWQgcHJlYyBmbXR0eSB3aXRoXG4gICAgfCBQYWRwcmVjX2ZtdHR5X0VCQiAocGFkLCBwcmVjLCBOYXRpdmVpbnRfdHkgZm10dHlfcmVzdCkgLT5cbiAgICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICAgIEZtdF9mbXR0eV9FQkIgKE5hdGl2ZWludCAoaWNvbnYsIHBhZCwgcHJlYywgZm10JyksIGZtdHR5JylcbiAgICB8IFBhZHByZWNfZm10dHlfRUJCIChfLCBfLCBfKSAtPiByYWlzZSBUeXBlX21pc21hdGNoXG4gIClcbiAgfCBJbnQ2NCAoaWNvbnYsIHBhZCwgcHJlYywgZm10X3Jlc3QpLCBfIC0+IChcbiAgICBtYXRjaCB0eXBlX3BhZHByZWMgcGFkIHByZWMgZm10dHkgd2l0aFxuICAgIHwgUGFkcHJlY19mbXR0eV9FQkIgKHBhZCwgcHJlYywgSW50NjRfdHkgZm10dHlfcmVzdCkgLT5cbiAgICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICAgIEZtdF9mbXR0eV9FQkIgKEludDY0IChpY29udiwgcGFkLCBwcmVjLCBmbXQnKSwgZm10dHknKVxuICAgIHwgUGFkcHJlY19mbXR0eV9FQkIgKF8sIF8sIF8pIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcbiAgKVxuICB8IEZsb2F0IChmY29udiwgcGFkLCBwcmVjLCBmbXRfcmVzdCksIF8gLT4gKFxuICAgIG1hdGNoIHR5cGVfcGFkcHJlYyBwYWQgcHJlYyBmbXR0eSB3aXRoXG4gICAgfCBQYWRwcmVjX2ZtdHR5X0VCQiAocGFkLCBwcmVjLCBGbG9hdF90eSBmbXR0eV9yZXN0KSAtPlxuICAgICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgICAgRm10X2ZtdHR5X0VCQiAoRmxvYXQgKGZjb252LCBwYWQsIHByZWMsIGZtdCcpLCBmbXR0eScpXG4gICAgfCBQYWRwcmVjX2ZtdHR5X0VCQiAoXywgXywgXykgLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuICApXG4gIHwgQm9vbCAocGFkLCBmbXRfcmVzdCksIF8gLT4gKFxuICAgIG1hdGNoIHR5cGVfcGFkZGluZyBwYWQgZm10dHkgd2l0aFxuICAgIHwgUGFkZGluZ19mbXR0eV9FQkIgKHBhZCwgQm9vbF90eSBmbXR0eV9yZXN0KSAtPlxuICAgICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgICAgRm10X2ZtdHR5X0VCQiAoQm9vbCAocGFkLCBmbXQnKSwgZm10dHknKVxuICAgIHwgUGFkZGluZ19mbXR0eV9FQkIgKF8sIF8pIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcbiAgKVxuICB8IEZsdXNoIGZtdF9yZXN0LCBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKEZsdXNoIGZtdCcsIGZtdHR5JylcblxuICB8IFN0cmluZ19saXRlcmFsIChzdHIsIGZtdF9yZXN0KSwgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChTdHJpbmdfbGl0ZXJhbCAoc3RyLCBmbXQnKSwgZm10dHknKVxuICB8IENoYXJfbGl0ZXJhbCAoY2hyLCBmbXRfcmVzdCksIGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoQ2hhcl9saXRlcmFsIChjaHIsIGZtdCcpLCBmbXR0eScpXG5cbiAgfCBGb3JtYXRfYXJnIChwYWRfb3B0LCBzdWJfZm10dHksIGZtdF9yZXN0KSxcbiAgICBGb3JtYXRfYXJnX3R5IChzdWJfZm10dHknLCBmbXR0eV9yZXN0KSAtPlxuICAgIGlmIEZtdHR5X0VCQiBzdWJfZm10dHkgPD4gRm10dHlfRUJCIHN1Yl9mbXR0eScgdGhlbiByYWlzZSBUeXBlX21pc21hdGNoO1xuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChGb3JtYXRfYXJnIChwYWRfb3B0LCBzdWJfZm10dHknLCBmbXQnKSwgZm10dHknKVxuICB8IEZvcm1hdF9zdWJzdCAocGFkX29wdCwgc3ViX2ZtdHR5LCBmbXRfcmVzdCksXG4gICAgRm9ybWF0X3N1YnN0X3R5IChzdWJfZm10dHkxLCBfc3ViX2ZtdHR5MiwgZm10dHlfcmVzdCkgLT5cbiAgICBpZiBGbXR0eV9FQkIgKGVyYXNlX3JlbCBzdWJfZm10dHkpIDw+IEZtdHR5X0VCQiAoZXJhc2VfcmVsIHN1Yl9mbXR0eTEpIHRoZW5cbiAgICAgIHJhaXNlIFR5cGVfbWlzbWF0Y2g7XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPVxuICAgICAgdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IChlcmFzZV9yZWwgZm10dHlfcmVzdClcbiAgICBpblxuICAgIEZtdF9mbXR0eV9FQkIgKEZvcm1hdF9zdWJzdCAocGFkX29wdCwgc3ViX2ZtdHR5MSwgZm10JyksIGZtdHR5JylcbiAgKCogUHJpbnRmIGFuZCBGb3JtYXQgc3BlY2lmaWMgY29uc3RydWN0b3JzOiAqKVxuICB8IEFscGhhIGZtdF9yZXN0LCBBbHBoYV90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKEFscGhhIGZtdCcsIGZtdHR5JylcbiAgfCBUaGV0YSBmbXRfcmVzdCwgVGhldGFfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChUaGV0YSBmbXQnLCBmbXR0eScpXG5cbiAgKCogRm9ybWF0IHNwZWNpZmljIGNvbnN0cnVjdG9yczogKilcbiAgfCBGb3JtYXR0aW5nX2xpdCAoZm9ybWF0dGluZ19saXQsIGZtdF9yZXN0KSwgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChGb3JtYXR0aW5nX2xpdCAoZm9ybWF0dGluZ19saXQsIGZtdCcpLCBmbXR0eScpXG4gIHwgRm9ybWF0dGluZ19nZW4gKGZvcm1hdHRpbmdfZ2VuLCBmbXRfcmVzdCksIGZtdHR5X3Jlc3QgLT5cbiAgICB0eXBlX2Zvcm1hdHRpbmdfZ2VuIGZvcm1hdHRpbmdfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3RcblxuICAoKiBTY2FuZiBzcGVjaWZpYyBjb25zdHJ1Y3RvcnM6ICopXG4gIHwgUmVhZGVyIGZtdF9yZXN0LCBSZWFkZXJfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChSZWFkZXIgZm10JywgZm10dHknKVxuICB8IFNjYW5fY2hhcl9zZXQgKHdpZHRoX29wdCwgY2hhcl9zZXQsIGZtdF9yZXN0KSwgU3RyaW5nX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoU2Nhbl9jaGFyX3NldCAod2lkdGhfb3B0LCBjaGFyX3NldCwgZm10JyksIGZtdHR5JylcbiAgfCBTY2FuX2dldF9jb3VudGVyIChjb3VudGVyLCBmbXRfcmVzdCksIEludF90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKFNjYW5fZ2V0X2NvdW50ZXIgKGNvdW50ZXIsIGZtdCcpLCBmbXR0eScpXG4gIHwgSWdub3JlZF9wYXJhbSAoaWduLCByZXN0KSwgZm10dHlfcmVzdCAtPlxuICAgIHR5cGVfaWdub3JlZF9wYXJhbSBpZ24gcmVzdCBmbXR0eV9yZXN0XG5cbiAgfCBFbmRfb2ZfZm9ybWF0LCBmbXR0eV9yZXN0IC0+IEZtdF9mbXR0eV9FQkIgKEVuZF9vZl9mb3JtYXQsIGZtdHR5X3Jlc3QpXG5cbiAgfCBfIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcblxuYW5kIHR5cGVfZm9ybWF0dGluZ19nZW4gOiB0eXBlIGExIGEzIGIxIGIzIGMxIGMzIGQxIGQzIGUxIGUyIGUzIGYxIGYyIGYzIC5cbiAgICAoYTEsIGIxLCBjMSwgZDEsIGUxLCBmMSkgZm9ybWF0dGluZ19nZW4gLT5cbiAgICAoZjEsIGIxLCBjMSwgZTEsIGUyLCBmMikgZm10IC0+XG4gICAgKGEzLCBiMywgYzMsIGQzLCBlMywgZjMpIGZtdHR5IC0+XG4gICAgKGEzLCBiMywgYzMsIGQzLCBlMywgZjMpIGZtdF9mbXR0eV9lYmIgPVxuZnVuIGZvcm1hdHRpbmdfZ2VuIGZtdDAgZm10dHkwIC0+IG1hdGNoIGZvcm1hdHRpbmdfZ2VuIHdpdGhcbiAgfCBPcGVuX3RhZyAoRm9ybWF0IChmbXQxLCBzdHIpKSAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQyLCBmbXR0eTIpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdDEgZm10dHkwIGluXG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdDMsIGZtdHR5MykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10MCBmbXR0eTIgaW5cbiAgICBGbXRfZm10dHlfRUJCIChGb3JtYXR0aW5nX2dlbiAoT3Blbl90YWcgKEZvcm1hdCAoZm10Miwgc3RyKSksIGZtdDMpLCBmbXR0eTMpXG4gIHwgT3Blbl9ib3ggKEZvcm1hdCAoZm10MSwgc3RyKSkgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10MiwgZm10dHkyKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXQxIGZtdHR5MCBpblxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQzLCBmbXR0eTMpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdDAgZm10dHkyIGluXG4gICAgRm10X2ZtdHR5X0VCQiAoRm9ybWF0dGluZ19nZW4gKE9wZW5fYm94IChGb3JtYXQgKGZtdDIsIHN0cikpLCBmbXQzKSwgZm10dHkzKVxuXG4oKiBUeXBlIGFuIElnbm9yZWRfcGFyYW0gbm9kZSBhY2NvcmRpbmcgdG8gYW4gZm10dHkuICopXG5hbmQgdHlwZV9pZ25vcmVkX3BhcmFtIDogdHlwZSBwIHEgeCB5IHogdCB1IHYgYSBiIGMgZCBlIGYgLlxuICAgICh4LCB5LCB6LCB0LCBxLCBwKSBpZ25vcmVkIC0+XG4gICAgKHAsIHksIHosIHEsIHUsIHYpIGZtdCAtPlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSAtPlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXRfZm10dHlfZWJiID1cbmZ1biBpZ24gZm10IGZtdHR5IC0+IG1hdGNoIGlnbiB3aXRoXG4gIHwgSWdub3JlZF9jaGFyICAgICAgICAgICAgICAgYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9jYW1sX2NoYXIgICAgICAgICAgYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9zdHJpbmcgXyAgICAgICAgICAgYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9jYW1sX3N0cmluZyBfICAgICAgYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9pbnQgXyAgICAgICAgICAgICAgYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9pbnQzMiBfICAgICAgICAgICAgYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9uYXRpdmVpbnQgXyAgICAgICAgYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9pbnQ2NCBfICAgICAgICAgICAgYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9mbG9hdCBfICAgICAgICAgICAgYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9ib29sIF8gICAgICAgICAgICAgYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9zY2FuX2NoYXJfc2V0IF8gICAgYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9zY2FuX2dldF9jb3VudGVyIF8gYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9zY2FuX25leHRfY2hhciAgICAgYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9mb3JtYXRfYXJnIChwYWRfb3B0LCBzdWJfZm10dHkpIC0+XG4gICAgdHlwZV9pZ25vcmVkX3BhcmFtX29uZSAoSWdub3JlZF9mb3JtYXRfYXJnIChwYWRfb3B0LCBzdWJfZm10dHkpKSBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX2Zvcm1hdF9zdWJzdCAocGFkX29wdCwgc3ViX2ZtdHR5KSAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHknLCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHkgZm10IGZtdHR5IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoSWdub3JlZF9wYXJhbSAoSWdub3JlZF9mb3JtYXRfc3Vic3QgKHBhZF9vcHQsIHN1Yl9mbXR0eScpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZtdCcpLFxuICAgICAgICAgICAgICAgICAgIGZtdHR5JylcbiAgfCBJZ25vcmVkX3JlYWRlciAtPiAoXG4gICAgbWF0Y2ggZm10dHkgd2l0aFxuICAgIHwgSWdub3JlZF9yZWFkZXJfdHkgZm10dHlfcmVzdCAtPlxuICAgICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10IGZtdHR5X3Jlc3QgaW5cbiAgICAgIEZtdF9mbXR0eV9FQkIgKElnbm9yZWRfcGFyYW0gKElnbm9yZWRfcmVhZGVyLCBmbXQnKSwgZm10dHknKVxuICAgIHwgXyAtPiByYWlzZSBUeXBlX21pc21hdGNoXG4gIClcblxuYW5kIHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgOiB0eXBlIGExIGEyIGIxIGIyIGMxIGMyIGQxIGQyIGUxIGUyIGYxIGYyIC5cbiAgICAoYTIsIGIyLCBjMiwgZDIsIGQyLCBhMikgaWdub3JlZCAtPlxuICAgIChhMSwgYjEsIGMxLCBkMSwgZTEsIGYxKSBmbXQgLT5cbiAgICAoYTIsIGIyLCBjMiwgZDIsIGUyLCBmMikgZm10dHkgLT5cbiAgICAoYTIsIGIyLCBjMiwgZDIsIGUyLCBmMikgZm10X2ZtdHR5X2ViYlxuPSBmdW4gaWduIGZtdCBmbXR0eSAtPlxuICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXQgZm10dHkgaW5cbiAgRm10X2ZtdHR5X0VCQiAoSWdub3JlZF9wYXJhbSAoaWduLCBmbXQnKSwgZm10dHknKVxuXG4oKiBUeXBpbmcgb2YgdGhlIGNvbXBsZXggY2FzZTogXCIlXyguLi4lKVwiLiAqKVxuYW5kIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIDogdHlwZSB3IHggeSB6IHAgcyB0IHUgYSBiIGMgZCBlIGYgLlxuICAgICh3LCB4LCB5LCB6LCBzLCBwKSBmbXR0eSAtPlxuICAgIChwLCB4LCB5LCBzLCB0LCB1KSBmbXQgLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10dHkgLT4gKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5X2ZtdF9lYmIgPVxuZnVuIHN1Yl9mbXR0eSBmbXQgZm10dHkgLT4gbWF0Y2ggc3ViX2ZtdHR5LCBmbXR0eSB3aXRoXG4gIHwgQ2hhcl90eSBzdWJfZm10dHlfcmVzdCwgQ2hhcl90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChDaGFyX3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcbiAgfCBTdHJpbmdfdHkgc3ViX2ZtdHR5X3Jlc3QsIFN0cmluZ190eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChTdHJpbmdfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuICB8IEludF90eSBzdWJfZm10dHlfcmVzdCwgSW50X3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKEludF90eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG4gIHwgSW50MzJfdHkgc3ViX2ZtdHR5X3Jlc3QsIEludDMyX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKEludDMyX3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcbiAgfCBOYXRpdmVpbnRfdHkgc3ViX2ZtdHR5X3Jlc3QsIE5hdGl2ZWludF90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChOYXRpdmVpbnRfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuICB8IEludDY0X3R5IHN1Yl9mbXR0eV9yZXN0LCBJbnQ2NF90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChJbnQ2NF90eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG4gIHwgRmxvYXRfdHkgc3ViX2ZtdHR5X3Jlc3QsIEZsb2F0X3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKEZsb2F0X3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcbiAgfCBCb29sX3R5IHN1Yl9mbXR0eV9yZXN0LCBCb29sX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKEJvb2xfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuICB8IEFscGhhX3R5IHN1Yl9mbXR0eV9yZXN0LCBBbHBoYV90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChBbHBoYV90eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG4gIHwgVGhldGFfdHkgc3ViX2ZtdHR5X3Jlc3QsIFRoZXRhX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKFRoZXRhX3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcbiAgfCBSZWFkZXJfdHkgc3ViX2ZtdHR5X3Jlc3QsIFJlYWRlcl90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChSZWFkZXJfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuICB8IElnbm9yZWRfcmVhZGVyX3R5IHN1Yl9mbXR0eV9yZXN0LCBJZ25vcmVkX3JlYWRlcl90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChJZ25vcmVkX3JlYWRlcl90eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG5cbiAgfCBGb3JtYXRfYXJnX3R5IChzdWIyX2ZtdHR5LCBzdWJfZm10dHlfcmVzdCksXG4gICAgRm9ybWF0X2FyZ190eSAoc3ViMl9mbXR0eScsIGZtdHR5X3Jlc3QpIC0+XG4gICAgaWYgRm10dHlfRUJCIHN1YjJfZm10dHkgPD4gRm10dHlfRUJCIHN1YjJfZm10dHknIHRoZW4gcmFpc2UgVHlwZV9taXNtYXRjaDtcbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKEZvcm1hdF9hcmdfdHkgKHN1YjJfZm10dHknLCBzdWJfZm10dHlfcmVzdCcpLCBmbXQnKVxuICB8IEZvcm1hdF9zdWJzdF90eSAoc3ViMV9mbXR0eSwgIHN1YjJfZm10dHksICBzdWJfZm10dHlfcmVzdCksXG4gICAgRm9ybWF0X3N1YnN0X3R5IChzdWIxX2ZtdHR5Jywgc3ViMl9mbXR0eScsIGZtdHR5X3Jlc3QpIC0+XG4gICAgKCogVE9ETyBkZWZpbmUgRm10dHlfcmVsX0VCQiB0byByZW1vdmUgdGhvc2UgZXJhc2VfcmVsICopXG4gICAgaWYgRm10dHlfRUJCIChlcmFzZV9yZWwgc3ViMV9mbXR0eSkgPD4gRm10dHlfRUJCIChlcmFzZV9yZWwgc3ViMV9mbXR0eScpXG4gICAgdGhlbiByYWlzZSBUeXBlX21pc21hdGNoO1xuICAgIGlmIEZtdHR5X0VCQiAoZXJhc2VfcmVsIHN1YjJfZm10dHkpIDw+IEZtdHR5X0VCQiAoZXJhc2VfcmVsIHN1YjJfZm10dHknKVxuICAgIHRoZW4gcmFpc2UgVHlwZV9taXNtYXRjaDtcbiAgICBsZXQgc3ViX2ZtdHR5JyA9IHRyYW5zIChzeW1tIHN1YjFfZm10dHknKSBzdWIyX2ZtdHR5JyBpblxuICAgIGxldCBfLCBmMiwgXywgZjQgPSBmbXR0eV9yZWxfZGV0IHN1Yl9mbXR0eScgaW5cbiAgICBsZXQgUmVmbCA9IGYyIFJlZmwgaW5cbiAgICBsZXQgUmVmbCA9IGY0IFJlZmwgaW5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiAoZXJhc2VfcmVsIHN1Yl9mbXR0eV9yZXN0KSBmbXQgZm10dHlfcmVzdFxuICAgIGluXG4gICAgRm10dHlfZm10X0VCQiAoRm9ybWF0X3N1YnN0X3R5IChzdWIxX2ZtdHR5Jywgc3ViMl9mbXR0eScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1tIHN1Yl9mbXR0eV9yZXN0JyksXG4gICAgICAgICAgICAgICAgICAgZm10JylcbiAgfCBFbmRfb2ZfZm10dHksIGZtdHR5IC0+XG4gICAgRm10dHlfZm10X0VCQiAoRW5kX29mX2ZtdHR5LCB0eXBlX2Zvcm1hdF9nZW4gZm10IGZtdHR5KVxuICB8IF8gLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuXG4oKiBUaGlzIGltcGxlbWVudGF0aW9uIG9mIGByZWNhc3RgIGlzIGEgYml0IGRpc2FwcG9pbnRpbmcuIFRoZVxuICAgaW52YXJpYW50IHByb3ZpZGVkIGJ5IHRoZSB0eXBlIGFyZSB2ZXJ5IHN0cm9uZzogdGhlIGlucHV0IGZvcm1hdCdzXG4gICB0eXBlIGlzIGluIHJlbGF0aW9uIHRvIHRoZSBvdXRwdXQgdHlwZSdzIGFzIHdpdG5lc3NlZCBieSB0aGVcbiAgIGZtdHR5X3JlbCBhcmd1bWVudC4gT25lIHdvdWxkIGF0IGZpcnN0IGV4cGVjdCB0aGlzIGZ1bmN0aW9uIHRvIGJlXG4gICB0b3RhbCwgYW5kIGltcGxlbWVudGFibGUgYnkgZXhoYXVzdGl2ZSBwYXR0ZXJuIG1hdGNoaW5nLiBJbnN0ZWFkLFxuICAgd2UgcmV1c2UgdGhlIGhpZ2hseSBwYXJ0aWFsIGFuZCBtdWNoIGxlc3Mgd2VsbC1kZWZpbmVkIGZ1bmN0aW9uXG4gICBgdHlwZV9mb3JtYXRgIHRoYXQgaGFzIGxvc3QgYWxsIGtub3dsZWRnZSBvZiB0aGUgY29ycmVzcG9uZGVuY2VcbiAgIGJldHdlZW4gdGhlIGFyZ3VtZW50J3MgdHlwZXMuXG5cbiAgIEJlc2lkZXMgdGhlIGZhY3QgdGhhdCB0aGlzIGZ1bmN0aW9uIHJldXNlcyBhIGxvdCBvZiB0aGVcbiAgIGB0eXBlX2Zvcm1hdGAgbG9naWMgKGVnLjogc2VlaW5nIEludF90eSBpbiB0aGUgZm10dHkgcGFyYW1ldGVyIGRvZXNcbiAgIG5vdCBsZXQgeW91IG1hdGNoIG9uIEludCBvbmx5LCBhcyB5b3UgbWF5IGluIGZhY3QgaGF2ZSBGbG9hdFxuICAgKEFyZ19wYWRkaW5nLCAuLi4pIChcIiUuKmRcIikgYmVnaW5uaW5nIHdpdGggYW4gSW50X3R5KSwgaXQgaXMgYWxzb1xuICAgYSBwYXJ0aWFsIGZ1bmN0aW9uLCBiZWNhdXNlIHRoZSB0eXBpbmcgaW5mb3JtYXRpb24gaW4gYSBmb3JtYXQgaXNcbiAgIG5vdCBxdWl0ZSBlbm91Z2ggdG8gcmVjb25zdHJ1Y3QgaXQgdW5hbWJpZ3VvdXNseS4gRm9yIGV4YW1wbGUsIHRoZVxuICAgZm9ybWF0IHR5cGVzIG9mIFwiJWQlX3JcIiBhbmQgXCIlX3IlZFwiIGhhdmUgdGhlIHNhbWUgZm9ybWF0NlxuICAgcGFyYW1ldGVycywgYnV0IHRoZXkgYXJlIG5vdCBhdCBhbGwgZXhjaGFuZ2VhYmxlLCBhbmQgcHV0dGluZyBvbmVcbiAgIGluIHBsYWNlIG9mIHRoZSBvdGhlciBtdXN0IHJlc3VsdCBpbiBhIGR5bmFtaWMgZmFpbHVyZS5cblxuICAgR2l2ZW4gdGhhdDpcbiAgIC0gd2UnZCBoYXZlIHRvIGR1cGxpY2F0ZSBhIGxvdCBvZiBub24tdHJpdmlhbCB0eXBpbmcgbG9naWMgZnJvbSB0eXBlX2Zvcm1hdFxuICAgLSB0aGlzIHdvdWxkbid0IGV2ZW4gZWxpbWluYXRlIChhbGwpIHRoZSBkeW5hbWljIGZhaWx1cmVzXG4gICB3ZSBkZWNpZGVkIHRvIGp1c3QgcmV1c2UgdHlwZV9mb3JtYXQgZGlyZWN0bHkgZm9yIG5vdy5cbiopXG5sZXQgcmVjYXN0IDpcbiAgdHlwZSBhMSBiMSBjMSBkMSBlMSBmMVxuICAgICAgIGEyIGIyIGMyIGQyIGUyIGYyXG4gIC5cbiAgICAgKGExLCBiMSwgYzEsIGQxLCBlMSwgZjEpIGZtdFxuICAtPiAoYTEsIGIxLCBjMSwgZDEsIGUxLCBmMSxcbiAgICAgIGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIpIGZtdHR5X3JlbFxuICAtPiAoYTIsIGIyLCBjMiwgZDIsIGUyLCBmMikgZm10XG49IGZ1biBmbXQgZm10dHkgLT5cbiAgdHlwZV9mb3JtYXQgZm10IChlcmFzZV9yZWwgKHN5bW0gZm10dHkpKVxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBQcmludGluZyB0b29scyAqKVxuXG4oKiBBZGQgcGFkZGluZyBzcGFjZXMgYXJvdW5kIGEgc3RyaW5nLiAqKVxubGV0IGZpeF9wYWRkaW5nIHBhZHR5IHdpZHRoIHN0ciA9XG4gIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHN0ciBpblxuICBsZXQgd2lkdGgsIHBhZHR5ID1cbiAgICBhYnMgd2lkdGgsXG4gICAgKCogd2hpbGUgbGl0ZXJhbCBwYWRkaW5nIHdpZHRocyBhcmUgYWx3YXlzIG5vbi1uZWdhdGl2ZSxcbiAgICAgICBkeW5hbWljYWxseS1zZXQgd2lkdGhzIChBcmdfcGFkZGluZywgZWcuICUqZCkgbWF5IGJlIG5lZ2F0aXZlO1xuICAgICAgIHdlIGludGVycHJldCB0aG9zZSBhcyBzcGVjaWZ5aW5nIGEgcGFkZGluZy10by10aGUtbGVmdDsgdGhpc1xuICAgICAgIG1lYW5zIHRoYXQgJzAnIG1heSBnZXQgZHJvcHBlZCBldmVuIGlmIGl0IHdhcyBleHBsaWNpdGx5IHNldCxcbiAgICAgICBidXQ6XG4gICAgICAgLSB0aGlzIGlzIHdoYXQgdGhlIGxlZ2FjeSBpbXBsZW1lbnRhdGlvbiBkb2VzLCBhbmRcbiAgICAgICAgIHdlIHByZXNlcnZlIGNvbXBhdGliaWxpdHkgaWYgcG9zc2libGVcbiAgICAgICAtIHdlIGNvdWxkIG9ubHkgc2lnbmFsIHRoaXMgaXNzdWUgYnkgZmFpbGluZyBhdCBydW50aW1lLFxuICAgICAgICAgd2hpY2ggaXMgbm90IHZlcnkgbmljZS4uLiAqKVxuICAgIGlmIHdpZHRoIDwgMCB0aGVuIExlZnQgZWxzZSBwYWR0eSBpblxuICBpZiB3aWR0aCA8PSBsZW4gdGhlbiBzdHIgZWxzZVxuICAgIGxldCByZXMgPSBCeXRlcy5tYWtlIHdpZHRoIChpZiBwYWR0eSA9IFplcm9zIHRoZW4gJzAnIGVsc2UgJyAnKSBpblxuICAgIGJlZ2luIG1hdGNoIHBhZHR5IHdpdGhcbiAgICB8IExlZnQgIC0+IFN0cmluZy5ibGl0IHN0ciAwIHJlcyAwIGxlblxuICAgIHwgUmlnaHQgLT4gU3RyaW5nLmJsaXQgc3RyIDAgcmVzICh3aWR0aCAtIGxlbikgbGVuXG4gICAgfCBaZXJvcyB3aGVuIGxlbiA+IDAgJiYgKHN0ci5bMF0gPSAnKycgfHwgc3RyLlswXSA9ICctJyB8fCBzdHIuWzBdID0gJyAnKSAtPlxuICAgICAgQnl0ZXMuc2V0IHJlcyAwIHN0ci5bMF07XG4gICAgICBTdHJpbmcuYmxpdCBzdHIgMSByZXMgKHdpZHRoIC0gbGVuICsgMSkgKGxlbiAtIDEpXG4gICAgfCBaZXJvcyB3aGVuIGxlbiA+IDEgJiYgc3RyLlswXSA9ICcwJyAmJiAoc3RyLlsxXSA9ICd4JyB8fCBzdHIuWzFdID0gJ1gnKSAtPlxuICAgICAgQnl0ZXMuc2V0IHJlcyAxIHN0ci5bMV07XG4gICAgICBTdHJpbmcuYmxpdCBzdHIgMiByZXMgKHdpZHRoIC0gbGVuICsgMikgKGxlbiAtIDIpXG4gICAgfCBaZXJvcyAtPlxuICAgICAgU3RyaW5nLmJsaXQgc3RyIDAgcmVzICh3aWR0aCAtIGxlbikgbGVuXG4gICAgZW5kO1xuICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcmVzXG5cbigqIEFkZCAnMCcgcGFkZGluZyB0byBpbnQsIGludDMyLCBuYXRpdmVpbnQgb3IgaW50NjQgc3RyaW5nIHJlcHJlc2VudGF0aW9uLiAqKVxubGV0IGZpeF9pbnRfcHJlY2lzaW9uIHByZWMgc3RyID1cbiAgbGV0IHByZWMgPSBhYnMgcHJlYyBpblxuICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzdHIgaW5cbiAgbWF0Y2ggc3RyLlswXSB3aXRoXG4gIHwgKCcrJyB8ICctJyB8ICcgJykgYXMgYyB3aGVuIHByZWMgKyAxID4gbGVuIC0+XG4gICAgbGV0IHJlcyA9IEJ5dGVzLm1ha2UgKHByZWMgKyAxKSAnMCcgaW5cbiAgICBCeXRlcy5zZXQgcmVzIDAgYztcbiAgICBTdHJpbmcuYmxpdCBzdHIgMSByZXMgKHByZWMgLSBsZW4gKyAyKSAobGVuIC0gMSk7XG4gICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyByZXNcbiAgfCAnMCcgd2hlbiBwcmVjICsgMiA+IGxlbiAmJiBsZW4gPiAxICYmIChzdHIuWzFdID0gJ3gnIHx8IHN0ci5bMV0gPSAnWCcpIC0+XG4gICAgbGV0IHJlcyA9IEJ5dGVzLm1ha2UgKHByZWMgKyAyKSAnMCcgaW5cbiAgICBCeXRlcy5zZXQgcmVzIDEgc3RyLlsxXTtcbiAgICBTdHJpbmcuYmxpdCBzdHIgMiByZXMgKHByZWMgLSBsZW4gKyA0KSAobGVuIC0gMik7XG4gICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyByZXNcbiAgfCAnMCcgLi4gJzknIHwgJ2EnIC4uICdmJyB8ICdBJyAuLiAnRicgd2hlbiBwcmVjID4gbGVuIC0+XG4gICAgbGV0IHJlcyA9IEJ5dGVzLm1ha2UgcHJlYyAnMCcgaW5cbiAgICBTdHJpbmcuYmxpdCBzdHIgMCByZXMgKHByZWMgLSBsZW4pIGxlbjtcbiAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHJlc1xuICB8IF8gLT5cbiAgICBzdHJcblxuKCogRXNjYXBlIGEgc3RyaW5nIGFjY29yZGluZyB0byB0aGUgT0NhbWwgbGV4aW5nIGNvbnZlbnRpb24uICopXG5sZXQgc3RyaW5nX3RvX2NhbWxfc3RyaW5nIHN0ciA9XG4gIGxldCBzdHIgPSBTdHJpbmcuZXNjYXBlZCBzdHIgaW5cbiAgbGV0IGwgPSBTdHJpbmcubGVuZ3RoIHN0ciBpblxuICBsZXQgcmVzID0gQnl0ZXMubWFrZSAobCArIDIpICdcXFwiJyBpblxuICBTdHJpbmcudW5zYWZlX2JsaXQgc3RyIDAgcmVzIDEgbDtcbiAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyByZXNcblxuKCogR2VuZXJhdGUgdGhlIGZvcm1hdF9pbnQvaW50MzIvbmF0aXZlaW50L2ludDY0IGZpcnN0IGFyZ3VtZW50XG4gICBmcm9tIGFuIGludF9jb252LiAqKVxubGV0IGZvcm1hdF9vZl9pY29udiA9IGZ1bmN0aW9uXG4gIHwgSW50X2QgfCBJbnRfQ2QgLT4gXCIlZFwiIHwgSW50X3BkIC0+IFwiJStkXCIgfCBJbnRfc2QgLT4gXCIlIGRcIlxuICB8IEludF9pIHwgSW50X0NpIC0+IFwiJWlcIiB8IEludF9waSAtPiBcIiUraVwiIHwgSW50X3NpIC0+IFwiJSBpXCJcbiAgfCBJbnRfeCAtPiBcIiV4XCIgfCBJbnRfQ3ggLT4gXCIlI3hcIlxuICB8IEludF9YIC0+IFwiJVhcIiB8IEludF9DWCAtPiBcIiUjWFwiXG4gIHwgSW50X28gLT4gXCIlb1wiIHwgSW50X0NvIC0+IFwiJSNvXCJcbiAgfCBJbnRfdSB8IEludF9DdSAtPiBcIiV1XCJcblxubGV0IGZvcm1hdF9vZl9pY29udkwgPSBmdW5jdGlvblxuICB8IEludF9kIHwgSW50X0NkIC0+IFwiJUxkXCIgfCBJbnRfcGQgLT4gXCIlK0xkXCIgfCBJbnRfc2QgLT4gXCIlIExkXCJcbiAgfCBJbnRfaSB8IEludF9DaSAtPiBcIiVMaVwiIHwgSW50X3BpIC0+IFwiJStMaVwiIHwgSW50X3NpIC0+IFwiJSBMaVwiXG4gIHwgSW50X3ggLT4gXCIlTHhcIiB8IEludF9DeCAtPiBcIiUjTHhcIlxuICB8IEludF9YIC0+IFwiJUxYXCIgfCBJbnRfQ1ggLT4gXCIlI0xYXCJcbiAgfCBJbnRfbyAtPiBcIiVMb1wiIHwgSW50X0NvIC0+IFwiJSNMb1wiXG4gIHwgSW50X3UgfCBJbnRfQ3UgLT4gXCIlTHVcIlxuXG5sZXQgZm9ybWF0X29mX2ljb252bCA9IGZ1bmN0aW9uXG4gIHwgSW50X2QgfCBJbnRfQ2QgLT4gXCIlbGRcIiB8IEludF9wZCAtPiBcIiUrbGRcIiB8IEludF9zZCAtPiBcIiUgbGRcIlxuICB8IEludF9pIHwgSW50X0NpIC0+IFwiJWxpXCIgfCBJbnRfcGkgLT4gXCIlK2xpXCIgfCBJbnRfc2kgLT4gXCIlIGxpXCJcbiAgfCBJbnRfeCAtPiBcIiVseFwiIHwgSW50X0N4IC0+IFwiJSNseFwiXG4gIHwgSW50X1ggLT4gXCIlbFhcIiB8IEludF9DWCAtPiBcIiUjbFhcIlxuICB8IEludF9vIC0+IFwiJWxvXCIgfCBJbnRfQ28gLT4gXCIlI2xvXCJcbiAgfCBJbnRfdSB8IEludF9DdSAtPiBcIiVsdVwiXG5cbmxldCBmb3JtYXRfb2ZfaWNvbnZuID0gZnVuY3Rpb25cbiAgfCBJbnRfZCB8IEludF9DZCAtPiBcIiVuZFwiIHwgSW50X3BkIC0+IFwiJStuZFwiIHwgSW50X3NkIC0+IFwiJSBuZFwiXG4gIHwgSW50X2kgfCBJbnRfQ2kgLT4gXCIlbmlcIiB8IEludF9waSAtPiBcIiUrbmlcIiB8IEludF9zaSAtPiBcIiUgbmlcIlxuICB8IEludF94IC0+IFwiJW54XCIgfCBJbnRfQ3ggLT4gXCIlI254XCJcbiAgfCBJbnRfWCAtPiBcIiVuWFwiIHwgSW50X0NYIC0+IFwiJSNuWFwiXG4gIHwgSW50X28gLT4gXCIlbm9cIiB8IEludF9DbyAtPiBcIiUjbm9cIlxuICB8IEludF91IHwgSW50X0N1IC0+IFwiJW51XCJcblxuKCogR2VuZXJhdGUgdGhlIGZvcm1hdF9mbG9hdCBmaXJzdCBhcmd1bWVudCBmcm9tIGEgZmxvYXRfY29udi4gKilcbmxldCBmb3JtYXRfb2ZfZmNvbnYgZmNvbnYgcHJlYyA9XG4gICAgbGV0IHByZWMgPSBhYnMgcHJlYyBpblxuICAgIGxldCBzeW1iID0gY2hhcl9vZl9mY29udiB+Y0Y6J2cnIGZjb252IGluXG4gICAgbGV0IGJ1ZiA9IGJ1ZmZlcl9jcmVhdGUgMTYgaW5cbiAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJztcbiAgICBicHJpbnRfZmNvbnZfZmxhZyBidWYgZmNvbnY7XG4gICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnLic7XG4gICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIChJbnQudG9fc3RyaW5nIHByZWMpO1xuICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgc3ltYjtcbiAgICBidWZmZXJfY29udGVudHMgYnVmXG5cbmxldCB0cmFuc2Zvcm1faW50X2FsdCBpY29udiBzID1cbiAgbWF0Y2ggaWNvbnYgd2l0aFxuICB8IEludF9DZCB8IEludF9DaSB8IEludF9DdSAtPlxuICAgIGxldCBkaWdpdHMgPVxuICAgICAgbGV0IG4gPSByZWYgMCBpblxuICAgICAgZm9yIGkgPSAwIHRvIFN0cmluZy5sZW5ndGggcyAtIDEgZG9cbiAgICAgICAgbWF0Y2ggU3RyaW5nLnVuc2FmZV9nZXQgcyBpIHdpdGhcbiAgICAgICAgfCAnMCcuLic5JyAtPiBpbmNyIG5cbiAgICAgICAgfCBfIC0+ICgpXG4gICAgICBkb25lO1xuICAgICAgIW5cbiAgICBpblxuICAgIGxldCBidWYgPSBCeXRlcy5jcmVhdGUgKFN0cmluZy5sZW5ndGggcyArIChkaWdpdHMgLSAxKSAvIDMpIGluXG4gICAgbGV0IHBvcyA9IHJlZiAwIGluXG4gICAgbGV0IHB1dCBjID0gQnl0ZXMuc2V0IGJ1ZiAhcG9zIGM7IGluY3IgcG9zIGluXG4gICAgbGV0IGxlZnQgPSByZWYgKChkaWdpdHMgLSAxKSBtb2QgMyArIDEpIGluXG4gICAgZm9yIGkgPSAwIHRvIFN0cmluZy5sZW5ndGggcyAtIDEgZG9cbiAgICAgIG1hdGNoIFN0cmluZy51bnNhZmVfZ2V0IHMgaSB3aXRoXG4gICAgICB8ICcwJy4uJzknIGFzIGMgLT5cbiAgICAgICAgICBpZiAhbGVmdCA9IDAgdGhlbiAocHV0ICdfJzsgbGVmdCA6PSAzKTsgZGVjciBsZWZ0OyBwdXQgY1xuICAgICAgfCBjIC0+IHB1dCBjXG4gICAgZG9uZTtcbiAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIGJ1ZlxuICB8IF8gLT4gc1xuXG4oKiBDb252ZXJ0IGFuIGludGVnZXIgdG8gYSBzdHJpbmcgYWNjb3JkaW5nIHRvIGEgY29udmVyc2lvbi4gKilcbmxldCBjb252ZXJ0X2ludCBpY29udiBuID1cbiAgdHJhbnNmb3JtX2ludF9hbHQgaWNvbnYgKGZvcm1hdF9pbnQgKGZvcm1hdF9vZl9pY29udiBpY29udikgbilcbmxldCBjb252ZXJ0X2ludDMyIGljb252IG4gPVxuICB0cmFuc2Zvcm1faW50X2FsdCBpY29udiAoZm9ybWF0X2ludDMyIChmb3JtYXRfb2ZfaWNvbnZsIGljb252KSBuKVxubGV0IGNvbnZlcnRfbmF0aXZlaW50IGljb252IG4gPVxuICB0cmFuc2Zvcm1faW50X2FsdCBpY29udiAoZm9ybWF0X25hdGl2ZWludCAoZm9ybWF0X29mX2ljb252biBpY29udikgbilcbmxldCBjb252ZXJ0X2ludDY0IGljb252IG4gPVxuICB0cmFuc2Zvcm1faW50X2FsdCBpY29udiAoZm9ybWF0X2ludDY0IChmb3JtYXRfb2ZfaWNvbnZMIGljb252KSBuKVxuXG4oKiBDb252ZXJ0IGEgZmxvYXQgdG8gc3RyaW5nLiAqKVxuKCogRml4IHNwZWNpYWwgY2FzZSBvZiBcIk9DYW1sIGZsb2F0IGZvcm1hdFwiLiAqKVxubGV0IGNvbnZlcnRfZmxvYXQgZmNvbnYgcHJlYyB4ID1cbiAgbGV0IGhleCAoKSA9XG4gICAgbGV0IHNpZ24gPVxuICAgICAgbWF0Y2ggZnN0IGZjb252IHdpdGhcbiAgICAgIHwgRmxvYXRfZmxhZ19wIC0+ICcrJ1xuICAgICAgfCBGbG9hdF9mbGFnX3MgLT4gJyAnXG4gICAgICB8IF8gLT4gJy0nIGluXG4gICAgaGV4c3RyaW5nX29mX2Zsb2F0IHggcHJlYyBzaWduIGluXG4gIGxldCBhZGRfZG90X2lmX25lZWRlZCBzdHIgPVxuICAgIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHN0ciBpblxuICAgIGxldCByZWMgaXNfdmFsaWQgaSA9XG4gICAgICBpZiBpID0gbGVuIHRoZW4gZmFsc2UgZWxzZVxuICAgICAgICBtYXRjaCBzdHIuW2ldIHdpdGhcbiAgICAgICAgfCAnLicgfCAnZScgfCAnRScgLT4gdHJ1ZVxuICAgICAgICB8IF8gLT4gaXNfdmFsaWQgKGkgKyAxKSBpblxuICAgIGlmIGlzX3ZhbGlkIDAgdGhlbiBzdHIgZWxzZSBzdHIgXiBcIi5cIiBpblxuICBsZXQgY2FtbF9zcGVjaWFsX3ZhbCBzdHIgPSBtYXRjaCBjbGFzc2lmeV9mbG9hdCB4IHdpdGhcbiAgICB8IEZQX25vcm1hbCB8IEZQX3N1Ym5vcm1hbCB8IEZQX3plcm8gLT4gc3RyXG4gICAgfCBGUF9pbmZpbml0ZSAtPiBpZiB4IDwgMC4wIHRoZW4gXCJuZWdfaW5maW5pdHlcIiBlbHNlIFwiaW5maW5pdHlcIlxuICAgIHwgRlBfbmFuIC0+IFwibmFuXCIgaW5cbiAgbWF0Y2ggc25kIGZjb252IHdpdGhcbiAgfCBGbG9hdF9oIC0+IGhleCAoKVxuICB8IEZsb2F0X0ggLT4gU3RyaW5nLnVwcGVyY2FzZV9hc2NpaSAoaGV4ICgpKVxuICB8IEZsb2F0X0NGIC0+IGNhbWxfc3BlY2lhbF92YWwgKGhleCAoKSlcbiAgfCBGbG9hdF9GIC0+XG4gICAgbGV0IHN0ciA9IGZvcm1hdF9mbG9hdCAoZm9ybWF0X29mX2Zjb252IGZjb252IHByZWMpIHggaW5cbiAgICBjYW1sX3NwZWNpYWxfdmFsIChhZGRfZG90X2lmX25lZWRlZCBzdHIpXG4gIHwgRmxvYXRfZiB8IEZsb2F0X2UgfCBGbG9hdF9FIHwgRmxvYXRfZyB8IEZsb2F0X0cgLT5cbiAgICBmb3JtYXRfZmxvYXQgKGZvcm1hdF9vZl9mY29udiBmY29udiBwcmVjKSB4XG5cbigqIENvbnZlcnQgYSBjaGFyIHRvIGEgc3RyaW5nIGFjY29yZGluZyB0byB0aGUgT0NhbWwgbGV4aWNhbCBjb252ZW50aW9uLiAqKVxubGV0IGZvcm1hdF9jYW1sX2NoYXIgYyA9XG4gIGxldCBzdHIgPSBDaGFyLmVzY2FwZWQgYyBpblxuICBsZXQgbCA9IFN0cmluZy5sZW5ndGggc3RyIGluXG4gIGxldCByZXMgPSBCeXRlcy5tYWtlIChsICsgMikgJ1xcJycgaW5cbiAgU3RyaW5nLnVuc2FmZV9ibGl0IHN0ciAwIHJlcyAxIGw7XG4gIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcmVzXG5cbigqIENvbnZlcnQgYSBmb3JtYXQgdHlwZSB0byBzdHJpbmcgKilcbmxldCBzdHJpbmdfb2ZfZm10dHkgZm10dHkgPVxuICBsZXQgYnVmID0gYnVmZmVyX2NyZWF0ZSAxNiBpblxuICBicHJpbnRfZm10dHkgYnVmIGZtdHR5O1xuICBidWZmZXJfY29udGVudHMgYnVmXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAoKiBHZW5lcmljIHByaW50aW5nIGZ1bmN0aW9uICopXG5cbigqIE1ha2UgYSBnZW5lcmljIHByaW50aW5nIGZ1bmN0aW9uLiAqKVxuKCogVXNlZCB0byBnZW5lcmF0ZSBQcmludGYgYW5kIEZvcm1hdCBwcmludGluZyBmdW5jdGlvbnMuICopXG4oKiBQYXJhbWV0ZXJzOlxuICAgICBrOiBhIGNvbnRpbnVhdGlvbiBmaW5hbGx5IGFwcGxpZWQgdG8gdGhlIG91dHB1dCBzdHJlYW0gYW5kIHRoZSBhY2N1bXVsYXRvci5cbiAgICAgbzogdGhlIG91dHB1dCBzdHJlYW0gKHNlZSBrLCAlYSBhbmQgJXQpLlxuICAgICBhY2M6IHJldiBsaXN0IG9mIHByaW50aW5nIGVudGl0aWVzIChzdHJpbmcsIGNoYXIsIGZsdXNoLCBmb3JtYXR0aW5nLCAuLi4pLlxuICAgICBmbXQ6IHRoZSBmb3JtYXQuICopXG5sZXQgcmVjIG1ha2VfcHJpbnRmIDogdHlwZSBhIGIgYyBkIGUgZiAuXG4gICAgKChiLCBjKSBhY2MgLT4gZikgLT4gKGIsIGMpIGFjYyAtPlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT4gYSA9XG5mdW4gayBhY2MgZm10IC0+IG1hdGNoIGZtdCB3aXRoXG4gIHwgQ2hhciByZXN0IC0+XG4gICAgZnVuIGMgLT5cbiAgICAgIGxldCBuZXdfYWNjID0gQWNjX2RhdGFfY2hhciAoYWNjLCBjKSBpblxuICAgICAgbWFrZV9wcmludGYgayBuZXdfYWNjIHJlc3RcbiAgfCBDYW1sX2NoYXIgcmVzdCAtPlxuICAgIGZ1biBjIC0+XG4gICAgICBsZXQgbmV3X2FjYyA9IEFjY19kYXRhX3N0cmluZyAoYWNjLCBmb3JtYXRfY2FtbF9jaGFyIGMpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG5ld19hY2MgcmVzdFxuICB8IFN0cmluZyAocGFkLCByZXN0KSAtPlxuICAgIG1ha2VfcGFkZGluZyBrIGFjYyByZXN0IHBhZCAoZnVuIHN0ciAtPiBzdHIpXG4gIHwgQ2FtbF9zdHJpbmcgKHBhZCwgcmVzdCkgLT5cbiAgICBtYWtlX3BhZGRpbmcgayBhY2MgcmVzdCBwYWQgc3RyaW5nX3RvX2NhbWxfc3RyaW5nXG4gIHwgSW50IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIG1ha2VfaW50X3BhZGRpbmdfcHJlY2lzaW9uIGsgYWNjIHJlc3QgcGFkIHByZWMgY29udmVydF9pbnQgaWNvbnZcbiAgfCBJbnQzMiAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBtYWtlX2ludF9wYWRkaW5nX3ByZWNpc2lvbiBrIGFjYyByZXN0IHBhZCBwcmVjIGNvbnZlcnRfaW50MzIgaWNvbnZcbiAgfCBOYXRpdmVpbnQgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbWFrZV9pbnRfcGFkZGluZ19wcmVjaXNpb24gayBhY2MgcmVzdCBwYWQgcHJlYyBjb252ZXJ0X25hdGl2ZWludCBpY29udlxuICB8IEludDY0IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIG1ha2VfaW50X3BhZGRpbmdfcHJlY2lzaW9uIGsgYWNjIHJlc3QgcGFkIHByZWMgY29udmVydF9pbnQ2NCBpY29udlxuICB8IEZsb2F0IChmY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIG1ha2VfZmxvYXRfcGFkZGluZ19wcmVjaXNpb24gayBhY2MgcmVzdCBwYWQgcHJlYyBmY29udlxuICB8IEJvb2wgKHBhZCwgcmVzdCkgLT5cbiAgICBtYWtlX3BhZGRpbmcgayBhY2MgcmVzdCBwYWQgc3RyaW5nX29mX2Jvb2xcbiAgfCBBbHBoYSByZXN0IC0+XG4gICAgZnVuIGYgeCAtPiBtYWtlX3ByaW50ZiBrIChBY2NfZGVsYXkgKGFjYywgZnVuIG8gLT4gZiBvIHgpKSByZXN0XG4gIHwgVGhldGEgcmVzdCAtPlxuICAgIGZ1biBmIC0+IG1ha2VfcHJpbnRmIGsgKEFjY19kZWxheSAoYWNjLCBmKSkgcmVzdFxuICB8IEN1c3RvbSAoYXJpdHksIGYsIHJlc3QpIC0+XG4gICAgbWFrZV9jdXN0b20gayBhY2MgcmVzdCBhcml0eSAoZiAoKSlcbiAgfCBSZWFkZXIgXyAtPlxuICAgICgqIFRoaXMgY2FzZSBpcyBpbXBvc3NpYmxlLCBieSB0eXBpbmcgb2YgZm9ybWF0cy4gKilcbiAgICAoKiBJbmRlZWQsIHNpbmNlIHByaW50ZiBhbmQgY28uIHRha2UgYSBmb3JtYXQ0IGFzIGFyZ3VtZW50LCB0aGUgJ2QgYW5kICdlXG4gICAgICAgdHlwZSBwYXJhbWV0ZXJzIG9mIGZtdCBhcmUgb2J2aW91c2x5IGVxdWFscy4gVGhlIFJlYWRlciBpcyB0aGVcbiAgICAgICBvbmx5IGNvbnN0cnVjdG9yIHdoaWNoIHRvdWNoICdkIGFuZCAnZSB0eXBlIHBhcmFtZXRlcnMgb2YgdGhlIGZvcm1hdFxuICAgICAgIHR5cGUsIGl0IGFkZHMgYW4gKC0+KSB0byB0aGUgJ2QgcGFyYW1ldGVycy4gQ29uc2VxdWVudGx5LCBhIGZvcm1hdDRcbiAgICAgICBjYW5ub3QgY29udGFpbiBhIFJlYWRlciBub2RlLCBleGNlcHQgaW4gdGhlIHN1Yi1mb3JtYXQgYXNzb2NpYXRlZCB0b1xuICAgICAgIGFuICV7Li4uJX0uIEl0J3Mgbm90IGEgcHJvYmxlbSBiZWNhdXNlIG1ha2VfcHJpbnRmIGRvIG5vdCBjYWxsXG4gICAgICAgaXRzZWxmIHJlY3Vyc2l2ZWx5IG9uIHRoZSBzdWItZm9ybWF0IGFzc29jaWF0ZWQgdG8gJXsuLi4lfS4gKilcbiAgICBhc3NlcnQgZmFsc2VcbiAgfCBGbHVzaCByZXN0IC0+XG4gICAgbWFrZV9wcmludGYgayAoQWNjX2ZsdXNoIGFjYykgcmVzdFxuXG4gIHwgU3RyaW5nX2xpdGVyYWwgKHN0ciwgcmVzdCkgLT5cbiAgICBtYWtlX3ByaW50ZiBrIChBY2Nfc3RyaW5nX2xpdGVyYWwgKGFjYywgc3RyKSkgcmVzdFxuICB8IENoYXJfbGl0ZXJhbCAoY2hyLCByZXN0KSAtPlxuICAgIG1ha2VfcHJpbnRmIGsgKEFjY19jaGFyX2xpdGVyYWwgKGFjYywgY2hyKSkgcmVzdFxuXG4gIHwgRm9ybWF0X2FyZyAoXywgc3ViX2ZtdHR5LCByZXN0KSAtPlxuICAgIGxldCB0eSA9IHN0cmluZ19vZl9mbXR0eSBzdWJfZm10dHkgaW5cbiAgICAoZnVuIHN0ciAtPlxuICAgICAgaWdub3JlIHN0cjtcbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCB0eSkpIHJlc3QpXG4gIHwgRm9ybWF0X3N1YnN0IChfLCBmbXR0eSwgcmVzdCkgLT5cbiAgICBmdW4gKEZvcm1hdCAoZm10LCBfKSkgLT4gbWFrZV9wcmludGYgayBhY2NcbiAgICAgIChjb25jYXRfZm10IChyZWNhc3QgZm10IGZtdHR5KSByZXN0KVxuXG4gIHwgU2Nhbl9jaGFyX3NldCAoXywgXywgcmVzdCkgLT5cbiAgICBsZXQgbmV3X2FjYyA9IEFjY19pbnZhbGlkX2FyZyAoYWNjLCBcIlByaW50ZjogYmFkIGNvbnZlcnNpb24gJVtcIikgaW5cbiAgICBmdW4gXyAtPiBtYWtlX3ByaW50ZiBrIG5ld19hY2MgcmVzdFxuICB8IFNjYW5fZ2V0X2NvdW50ZXIgKF8sIHJlc3QpIC0+XG4gICAgKCogVGhpcyBjYXNlIHNob3VsZCBiZSByZWZ1c2VkIGZvciBQcmludGYuICopXG4gICAgKCogQWNjZXB0ZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkuICopXG4gICAgKCogSW50ZXJwcmV0ICVsLCAlbiBhbmQgJUwgYXMgJXUuICopXG4gICAgZnVuIG4gLT5cbiAgICAgIGxldCBuZXdfYWNjID0gQWNjX2RhdGFfc3RyaW5nIChhY2MsIGZvcm1hdF9pbnQgXCIldVwiIG4pIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG5ld19hY2MgcmVzdFxuICB8IFNjYW5fbmV4dF9jaGFyIHJlc3QgLT5cbiAgICBmdW4gYyAtPlxuICAgICAgbGV0IG5ld19hY2MgPSBBY2NfZGF0YV9jaGFyIChhY2MsIGMpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG5ld19hY2MgcmVzdFxuICB8IElnbm9yZWRfcGFyYW0gKGlnbiwgcmVzdCkgLT5cbiAgICBtYWtlX2lnbm9yZWRfcGFyYW0gayBhY2MgaWduIHJlc3RcblxuICB8IEZvcm1hdHRpbmdfbGl0IChmbXRpbmdfbGl0LCByZXN0KSAtPlxuICAgIG1ha2VfcHJpbnRmIGsgKEFjY19mb3JtYXR0aW5nX2xpdCAoYWNjLCBmbXRpbmdfbGl0KSkgcmVzdFxuICB8IEZvcm1hdHRpbmdfZ2VuIChPcGVuX3RhZyAoRm9ybWF0IChmbXQnLCBfKSksIHJlc3QpIC0+XG4gICAgbGV0IGsnIGthY2MgPVxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2Zvcm1hdHRpbmdfZ2VuIChhY2MsIEFjY19vcGVuX3RhZyBrYWNjKSkgcmVzdCBpblxuICAgIG1ha2VfcHJpbnRmIGsnIEVuZF9vZl9hY2MgZm10J1xuICB8IEZvcm1hdHRpbmdfZ2VuIChPcGVuX2JveCAoRm9ybWF0IChmbXQnLCBfKSksIHJlc3QpIC0+XG4gICAgbGV0IGsnIGthY2MgPVxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2Zvcm1hdHRpbmdfZ2VuIChhY2MsIEFjY19vcGVuX2JveCBrYWNjKSkgcmVzdCBpblxuICAgIG1ha2VfcHJpbnRmIGsnIEVuZF9vZl9hY2MgZm10J1xuXG4gIHwgRW5kX29mX2Zvcm1hdCAtPlxuICAgIGsgYWNjXG5cbigqIERlbGF5IHRoZSBlcnJvciAoSW52YWxpZF9hcmd1bWVudCBcIlByaW50ZjogYmFkIGNvbnZlcnNpb24gJV9cIikuICopXG4oKiBHZW5lcmF0ZSBmdW5jdGlvbnMgdG8gdGFrZSByZW1haW5pbmcgYXJndW1lbnRzIChhZnRlciB0aGUgXCIlX1wiKS4gKilcbmFuZCBtYWtlX2lnbm9yZWRfcGFyYW0gOiB0eXBlIHggeSBhIGIgYyBkIGUgZiAuXG4gICAgKChiLCBjKSBhY2MgLT4gZikgLT4gKGIsIGMpIGFjYyAtPlxuICAgIChhLCBiLCBjLCBkLCB5LCB4KSBpZ25vcmVkIC0+XG4gICAgKHgsIGIsIGMsIHksIGUsIGYpIGZtdCAtPiBhID1cbmZ1biBrIGFjYyBpZ24gZm10IC0+IG1hdGNoIGlnbiB3aXRoXG4gIHwgSWdub3JlZF9jaGFyICAgICAgICAgICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuICB8IElnbm9yZWRfY2FtbF9jaGFyICAgICAgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcbiAgfCBJZ25vcmVkX3N0cmluZyBfICAgICAgICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG4gIHwgSWdub3JlZF9jYW1sX3N0cmluZyBfICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuICB8IElnbm9yZWRfaW50IChfLCBfKSAgICAgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcbiAgfCBJZ25vcmVkX2ludDMyIChfLCBfKSAgICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG4gIHwgSWdub3JlZF9uYXRpdmVpbnQgKF8sIF8pICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuICB8IElnbm9yZWRfaW50NjQgKF8sIF8pICAgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcbiAgfCBJZ25vcmVkX2Zsb2F0IChfLCBfKSAgICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG4gIHwgSWdub3JlZF9ib29sIF8gICAgICAgICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuICB8IElnbm9yZWRfZm9ybWF0X2FyZyBfICAgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcbiAgfCBJZ25vcmVkX2Zvcm1hdF9zdWJzdCAoXywgZm10dHkpIC0+IG1ha2VfZnJvbV9mbXR0eSBrIGFjYyBmbXR0eSBmbXRcbiAgfCBJZ25vcmVkX3JlYWRlciAgICAgICAgICAgICAgICAgIC0+IGFzc2VydCBmYWxzZVxuICB8IElnbm9yZWRfc2Nhbl9jaGFyX3NldCBfICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcbiAgfCBJZ25vcmVkX3NjYW5fZ2V0X2NvdW50ZXIgXyAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG4gIHwgSWdub3JlZF9zY2FuX25leHRfY2hhciAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuXG5cbigqIFNwZWNpYWwgY2FzZSBvZiBwcmludGYgXCIlXyhcIi4gKilcbmFuZCBtYWtlX2Zyb21fZm10dHkgOiB0eXBlIHggeSBhIGIgYyBkIGUgZiAuXG4gICAgKChiLCBjKSBhY2MgLT4gZikgLT4gKGIsIGMpIGFjYyAtPlxuICAgIChhLCBiLCBjLCBkLCB5LCB4KSBmbXR0eSAtPlxuICAgICh4LCBiLCBjLCB5LCBlLCBmKSBmbXQgLT4gYSA9XG5mdW4gayBhY2MgZm10dHkgZm10IC0+IG1hdGNoIGZtdHR5IHdpdGhcbiAgfCBDaGFyX3R5IHJlc3QgICAgICAgICAgICAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgcmVzdCBmbXRcbiAgfCBTdHJpbmdfdHkgcmVzdCAgICAgICAgICAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgcmVzdCBmbXRcbiAgfCBJbnRfdHkgcmVzdCAgICAgICAgICAgICAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgcmVzdCBmbXRcbiAgfCBJbnQzMl90eSByZXN0ICAgICAgICAgICAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgcmVzdCBmbXRcbiAgfCBOYXRpdmVpbnRfdHkgcmVzdCAgICAgICAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgcmVzdCBmbXRcbiAgfCBJbnQ2NF90eSByZXN0ICAgICAgICAgICAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgcmVzdCBmbXRcbiAgfCBGbG9hdF90eSByZXN0ICAgICAgICAgICAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgcmVzdCBmbXRcbiAgfCBCb29sX3R5IHJlc3QgICAgICAgICAgICAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgcmVzdCBmbXRcbiAgfCBBbHBoYV90eSByZXN0ICAgICAgICAgICAtPiBmdW4gXyBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIGFjYyByZXN0IGZtdFxuICB8IFRoZXRhX3R5IHJlc3QgICAgICAgICAgIC0+IGZ1biBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIGFjYyByZXN0IGZtdFxuICB8IEFueV90eSByZXN0ICAgICAgICAgICAgIC0+IGZ1biBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIGFjYyByZXN0IGZtdFxuICB8IFJlYWRlcl90eSBfICAgICAgICAgICAgIC0+IGFzc2VydCBmYWxzZVxuICB8IElnbm9yZWRfcmVhZGVyX3R5IF8gICAgIC0+IGFzc2VydCBmYWxzZVxuICB8IEZvcm1hdF9hcmdfdHkgKF8sIHJlc3QpIC0+IGZ1biBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIGFjYyByZXN0IGZtdFxuICB8IEVuZF9vZl9mbXR0eSAgICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG4gIHwgRm9ybWF0X3N1YnN0X3R5ICh0eTEsIHR5MiwgcmVzdCkgLT5cbiAgICBsZXQgdHkgPSB0cmFucyAoc3ltbSB0eTEpIHR5MiBpblxuICAgIGZ1biBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIGFjYyAoY29uY2F0X2ZtdHR5IHR5IHJlc3QpIGZtdFxuXG4oKiBJbnNlcnQgYW4gQWNjX2ludmFsaWRfYXJnIGluIHRoZSBhY2N1bXVsYXRvciBhbmQgY29udGludWUgdG8gZ2VuZXJhdGVcbiAgIGNsb3N1cmVzIHRvIGdldCB0aGUgcmVtYWluaW5nIGFyZ3VtZW50cy4gKilcbmFuZCBtYWtlX2ludmFsaWRfYXJnIDogdHlwZSBhIGIgYyBkIGUgZiAuXG4gICAgKChiLCBjKSBhY2MgLT4gZikgLT4gKGIsIGMpIGFjYyAtPlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT4gYSA9XG5mdW4gayBhY2MgZm10IC0+XG4gIG1ha2VfcHJpbnRmIGsgKEFjY19pbnZhbGlkX2FyZyAoYWNjLCBcIlByaW50ZjogYmFkIGNvbnZlcnNpb24gJV9cIikpIGZtdFxuXG4oKiBGaXggcGFkZGluZywgdGFrZSBpdCBhcyBhbiBleHRyYSBpbnRlZ2VyIGFyZ3VtZW50IGlmIG5lZWRlZC4gKilcbmFuZCBtYWtlX3BhZGRpbmcgOiB0eXBlIHggeiBhIGIgYyBkIGUgZiAuXG4gICAgKChiLCBjKSBhY2MgLT4gZikgLT4gKGIsIGMpIGFjYyAtPlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT5cbiAgICAoeCwgeiAtPiBhKSBwYWRkaW5nIC0+ICh6IC0+IHN0cmluZykgLT4geCA9XG4gIGZ1biBrIGFjYyBmbXQgcGFkIHRyYW5zIC0+IG1hdGNoIHBhZCB3aXRoXG4gIHwgTm9fcGFkZGluZyAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBsZXQgbmV3X2FjYyA9IEFjY19kYXRhX3N0cmluZyAoYWNjLCB0cmFucyB4KSBpblxuICAgICAgbWFrZV9wcmludGYgayBuZXdfYWNjIGZtdFxuICB8IExpdF9wYWRkaW5nIChwYWR0eSwgd2lkdGgpIC0+XG4gICAgZnVuIHggLT5cbiAgICAgIGxldCBuZXdfYWNjID0gQWNjX2RhdGFfc3RyaW5nIChhY2MsIGZpeF9wYWRkaW5nIHBhZHR5IHdpZHRoICh0cmFucyB4KSkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgbmV3X2FjYyBmbXRcbiAgfCBBcmdfcGFkZGluZyBwYWR0eSAtPlxuICAgIGZ1biB3IHggLT5cbiAgICAgIGxldCBuZXdfYWNjID0gQWNjX2RhdGFfc3RyaW5nIChhY2MsIGZpeF9wYWRkaW5nIHBhZHR5IHcgKHRyYW5zIHgpKSBpblxuICAgICAgbWFrZV9wcmludGYgayBuZXdfYWNjIGZtdFxuXG4oKiBGaXggcGFkZGluZyBhbmQgcHJlY2lzaW9uIGZvciBpbnQsIGludDMyLCBuYXRpdmVpbnQgb3IgaW50NjQuICopXG4oKiBUYWtlIG9uZSBvciB0d28gZXh0cmEgaW50ZWdlciBhcmd1bWVudHMgaWYgbmVlZGVkLiAqKVxuYW5kIG1ha2VfaW50X3BhZGRpbmdfcHJlY2lzaW9uIDogdHlwZSB4IHkgeiBhIGIgYyBkIGUgZiAuXG4gICAgKChiLCBjKSBhY2MgLT4gZikgLT4gKGIsIGMpIGFjYyAtPlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT5cbiAgICAoeCwgeSkgcGFkZGluZyAtPiAoeSwgeiAtPiBhKSBwcmVjaXNpb24gLT4gKGludF9jb252IC0+IHogLT4gc3RyaW5nKSAtPlxuICAgIGludF9jb252IC0+IHggPVxuICBmdW4gayBhY2MgZm10IHBhZCBwcmVjIHRyYW5zIGljb252IC0+IG1hdGNoIHBhZCwgcHJlYyB3aXRoXG4gIHwgTm9fcGFkZGluZywgTm9fcHJlY2lzaW9uIC0+XG4gICAgZnVuIHggLT5cbiAgICAgIGxldCBzdHIgPSB0cmFucyBpY29udiB4IGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgTm9fcGFkZGluZywgTGl0X3ByZWNpc2lvbiBwIC0+XG4gICAgZnVuIHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfaW50X3ByZWNpc2lvbiBwICh0cmFucyBpY29udiB4KSBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IE5vX3BhZGRpbmcsIEFyZ19wcmVjaXNpb24gLT5cbiAgICBmdW4gcCB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X2ludF9wcmVjaXNpb24gcCAodHJhbnMgaWNvbnYgeCkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBMaXRfcGFkZGluZyAocGFkdHksIHcpLCBOb19wcmVjaXNpb24gLT5cbiAgICBmdW4geCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgKHRyYW5zIGljb252IHgpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgTGl0X3BhZGRpbmcgKHBhZHR5LCB3KSwgTGl0X3ByZWNpc2lvbiBwIC0+XG4gICAgZnVuIHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfcGFkZGluZyBwYWR0eSB3IChmaXhfaW50X3ByZWNpc2lvbiBwICh0cmFucyBpY29udiB4KSkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBMaXRfcGFkZGluZyAocGFkdHksIHcpLCBBcmdfcHJlY2lzaW9uIC0+XG4gICAgZnVuIHAgeCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgKGZpeF9pbnRfcHJlY2lzaW9uIHAgKHRyYW5zIGljb252IHgpKSBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IEFyZ19wYWRkaW5nIHBhZHR5LCBOb19wcmVjaXNpb24gLT5cbiAgICBmdW4gdyB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X3BhZGRpbmcgcGFkdHkgdyAodHJhbnMgaWNvbnYgeCkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBBcmdfcGFkZGluZyBwYWR0eSwgTGl0X3ByZWNpc2lvbiBwIC0+XG4gICAgZnVuIHcgeCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgKGZpeF9pbnRfcHJlY2lzaW9uIHAgKHRyYW5zIGljb252IHgpKSBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IEFyZ19wYWRkaW5nIHBhZHR5LCBBcmdfcHJlY2lzaW9uIC0+XG4gICAgZnVuIHcgcCB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X3BhZGRpbmcgcGFkdHkgdyAoZml4X2ludF9wcmVjaXNpb24gcCAodHJhbnMgaWNvbnYgeCkpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG5cbigqIENvbnZlcnQgYSBmbG9hdCwgZml4IHBhZGRpbmcgYW5kIHByZWNpc2lvbiBpZiBuZWVkZWQuICopXG4oKiBUYWtlIHRoZSBmbG9hdCBhcmd1bWVudCBhbmQgb25lIG9yIHR3byBleHRyYSBpbnRlZ2VyIGFyZ3VtZW50cyBpZiBuZWVkZWQuICopXG5hbmQgbWFrZV9mbG9hdF9wYWRkaW5nX3ByZWNpc2lvbiA6IHR5cGUgeCB5IGEgYiBjIGQgZSBmIC5cbiAgICAoKGIsIGMpIGFjYyAtPiBmKSAtPiAoYiwgYykgYWNjIC0+XG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPlxuICAgICh4LCB5KSBwYWRkaW5nIC0+ICh5LCBmbG9hdCAtPiBhKSBwcmVjaXNpb24gLT4gZmxvYXRfY29udiAtPiB4ID1cbiAgZnVuIGsgYWNjIGZtdCBwYWQgcHJlYyBmY29udiAtPiBtYXRjaCBwYWQsIHByZWMgd2l0aFxuICB8IE5vX3BhZGRpbmcsIE5vX3ByZWNpc2lvbiAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBsZXQgc3RyID0gY29udmVydF9mbG9hdCBmY29udiAoZGVmYXVsdF9mbG9hdF9wcmVjaXNpb24gZmNvbnYpIHggaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBOb19wYWRkaW5nLCBMaXRfcHJlY2lzaW9uIHAgLT5cbiAgICBmdW4geCAtPlxuICAgICAgbGV0IHN0ciA9IGNvbnZlcnRfZmxvYXQgZmNvbnYgcCB4IGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgTm9fcGFkZGluZywgQXJnX3ByZWNpc2lvbiAtPlxuICAgIGZ1biBwIHggLT5cbiAgICAgIGxldCBzdHIgPSBjb252ZXJ0X2Zsb2F0IGZjb252IHAgeCBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IExpdF9wYWRkaW5nIChwYWR0eSwgdyksIE5vX3ByZWNpc2lvbiAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBsZXQgc3RyID0gY29udmVydF9mbG9hdCBmY29udiAoZGVmYXVsdF9mbG9hdF9wcmVjaXNpb24gZmNvbnYpIHggaW5cbiAgICAgIGxldCBzdHInID0gZml4X3BhZGRpbmcgcGFkdHkgdyBzdHIgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHInKSkgZm10XG4gIHwgTGl0X3BhZGRpbmcgKHBhZHR5LCB3KSwgTGl0X3ByZWNpc2lvbiBwIC0+XG4gICAgZnVuIHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfcGFkZGluZyBwYWR0eSB3IChjb252ZXJ0X2Zsb2F0IGZjb252IHAgeCkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBMaXRfcGFkZGluZyAocGFkdHksIHcpLCBBcmdfcHJlY2lzaW9uIC0+XG4gICAgZnVuIHAgeCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgKGNvbnZlcnRfZmxvYXQgZmNvbnYgcCB4KSBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IEFyZ19wYWRkaW5nIHBhZHR5LCBOb19wcmVjaXNpb24gLT5cbiAgICBmdW4gdyB4IC0+XG4gICAgICBsZXQgc3RyID0gY29udmVydF9mbG9hdCBmY29udiAoZGVmYXVsdF9mbG9hdF9wcmVjaXNpb24gZmNvbnYpIHggaW5cbiAgICAgIGxldCBzdHInID0gZml4X3BhZGRpbmcgcGFkdHkgdyBzdHIgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHInKSkgZm10XG4gIHwgQXJnX3BhZGRpbmcgcGFkdHksIExpdF9wcmVjaXNpb24gcCAtPlxuICAgIGZ1biB3IHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfcGFkZGluZyBwYWR0eSB3IChjb252ZXJ0X2Zsb2F0IGZjb252IHAgeCkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBBcmdfcGFkZGluZyBwYWR0eSwgQXJnX3ByZWNpc2lvbiAtPlxuICAgIGZ1biB3IHAgeCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgKGNvbnZlcnRfZmxvYXQgZmNvbnYgcCB4KSBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuYW5kIG1ha2VfY3VzdG9tIDogdHlwZSB4IHkgYSBiIGMgZCBlIGYgLlxuICAoKGIsIGMpIGFjYyAtPiBmKSAtPiAoYiwgYykgYWNjIC0+XG4gIChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT5cbiAgKGEsIHgsIHkpIGN1c3RvbV9hcml0eSAtPiB4IC0+IHkgPVxuICBmdW4gayBhY2MgcmVzdCBhcml0eSBmIC0+IG1hdGNoIGFyaXR5IHdpdGhcbiAgfCBDdXN0b21femVybyAtPiBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgZikpIHJlc3RcbiAgfCBDdXN0b21fc3VjYyBhcml0eSAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBtYWtlX2N1c3RvbSBrIGFjYyByZXN0IGFyaXR5IChmIHgpXG5cbmxldCBjb25zdCB4IF8gPSB4XG5cbmxldCByZWMgbWFrZV9pcHJpbnRmIDogdHlwZSBhIGIgYyBkIGUgZiBzdGF0ZS5cbiAgKHN0YXRlIC0+IGYpIC0+IHN0YXRlIC0+IChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT4gYSA9XG4gIGZ1biBrIG8gZm10IC0+IG1hdGNoIGZtdCB3aXRoXG4gICAgfCBDaGFyIHJlc3QgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IENhbWxfY2hhciByZXN0IC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBTdHJpbmcgKE5vX3BhZGRpbmcsIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBTdHJpbmcgKExpdF9wYWRkaW5nIF8sIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBTdHJpbmcgKEFyZ19wYWRkaW5nIF8sIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KSlcbiAgICB8IENhbWxfc3RyaW5nIChOb19wYWRkaW5nLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgQ2FtbF9zdHJpbmcgKExpdF9wYWRkaW5nIF8sIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBDYW1sX3N0cmluZyAoQXJnX3BhZGRpbmcgXywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpKVxuICAgIHwgSW50IChfLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgICAgIGZuX29mX3BhZGRpbmdfcHJlY2lzaW9uIGsgbyByZXN0IHBhZCBwcmVjXG4gICAgfCBJbnQzMiAoXywgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgICAgICBmbl9vZl9wYWRkaW5nX3ByZWNpc2lvbiBrIG8gcmVzdCBwYWQgcHJlY1xuICAgIHwgTmF0aXZlaW50IChfLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgICAgIGZuX29mX3BhZGRpbmdfcHJlY2lzaW9uIGsgbyByZXN0IHBhZCBwcmVjXG4gICAgfCBJbnQ2NCAoXywgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgICAgICBmbl9vZl9wYWRkaW5nX3ByZWNpc2lvbiBrIG8gcmVzdCBwYWQgcHJlY1xuICAgIHwgRmxvYXQgKF8sIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICAgICAgZm5fb2ZfcGFkZGluZ19wcmVjaXNpb24gayBvIHJlc3QgcGFkIHByZWNcbiAgICB8IEJvb2wgKE5vX3BhZGRpbmcsIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBCb29sIChMaXRfcGFkZGluZyBfLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgQm9vbCAoQXJnX3BhZGRpbmcgXywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpKVxuICAgIHwgQWxwaGEgcmVzdCAtPlxuICAgICAgICBjb25zdCAoY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdCkpXG4gICAgfCBUaGV0YSByZXN0IC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBDdXN0b20gKGFyaXR5LCBfLCByZXN0KSAtPlxuICAgICAgICBmbl9vZl9jdXN0b21fYXJpdHkgayBvIHJlc3QgYXJpdHlcbiAgICB8IFJlYWRlciBfIC0+XG4gICAgICAgICgqIFRoaXMgY2FzZSBpcyBpbXBvc3NpYmxlLCBieSB0eXBpbmcgb2YgZm9ybWF0cy4gIFNlZSB0aGVcbiAgICAgICAgICAgbm90ZSBpbiB0aGUgY29ycmVzcG9uZGluZyBjYXNlIGZvciBtYWtlX3ByaW50Zi4gKilcbiAgICAgICAgYXNzZXJ0IGZhbHNlXG4gICAgfCBGbHVzaCByZXN0IC0+XG4gICAgICAgIG1ha2VfaXByaW50ZiBrIG8gcmVzdFxuICAgIHwgU3RyaW5nX2xpdGVyYWwgKF8sIHJlc3QpIC0+XG4gICAgICAgIG1ha2VfaXByaW50ZiBrIG8gcmVzdFxuICAgIHwgQ2hhcl9saXRlcmFsIChfLCByZXN0KSAtPlxuICAgICAgICBtYWtlX2lwcmludGYgayBvIHJlc3RcbiAgICB8IEZvcm1hdF9hcmcgKF8sIF8sIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBGb3JtYXRfc3Vic3QgKF8sIGZtdHR5LCByZXN0KSAtPlxuICAgICAgICBmdW4gKEZvcm1hdCAoZm10LCBfKSkgLT5cbiAgICAgICAgICBtYWtlX2lwcmludGYgayBvXG4gICAgICAgICAgICAoY29uY2F0X2ZtdCAocmVjYXN0IGZtdCBmbXR0eSkgcmVzdClcbiAgICB8IFNjYW5fY2hhcl9zZXQgKF8sIF8sIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBTY2FuX2dldF9jb3VudGVyIChfLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgU2Nhbl9uZXh0X2NoYXIgcmVzdCAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgSWdub3JlZF9wYXJhbSAoaWduLCByZXN0KSAtPlxuICAgICAgICBtYWtlX2lnbm9yZWRfcGFyYW0gKGZ1biBfIC0+IGsgbykgKEVuZF9vZl9hY2MpIGlnbiByZXN0XG4gICAgfCBGb3JtYXR0aW5nX2xpdCAoXywgcmVzdCkgLT5cbiAgICAgICAgbWFrZV9pcHJpbnRmIGsgbyByZXN0XG4gICAgfCBGb3JtYXR0aW5nX2dlbiAoT3Blbl90YWcgKEZvcm1hdCAoZm10JywgXykpLCByZXN0KSAtPlxuICAgICAgICBtYWtlX2lwcmludGYgKGZ1biBrb2MgLT4gbWFrZV9pcHJpbnRmIGsga29jIHJlc3QpIG8gZm10J1xuICAgIHwgRm9ybWF0dGluZ19nZW4gKE9wZW5fYm94IChGb3JtYXQgKGZtdCcsIF8pKSwgcmVzdCkgLT5cbiAgICAgICAgbWFrZV9pcHJpbnRmIChmdW4ga29jIC0+IG1ha2VfaXByaW50ZiBrIGtvYyByZXN0KSBvIGZtdCdcbiAgICB8IEVuZF9vZl9mb3JtYXQgLT5cbiAgICAgICAgayBvXG5hbmQgZm5fb2ZfcGFkZGluZ19wcmVjaXNpb24gOlxuICB0eXBlIHggeSB6IGEgYiBjIGQgZSBmIHN0YXRlLlxuICAoc3RhdGUgLT4gZikgLT4gc3RhdGUgLT4gKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPlxuICAoeCwgeSkgcGFkZGluZyAtPiAoeSwgeiAtPiBhKSBwcmVjaXNpb24gLT4geCA9XG4gIGZ1biBrIG8gZm10IHBhZCBwcmVjIC0+IG1hdGNoIHBhZCwgcHJlYyB3aXRoXG4gICAgfCBOb19wYWRkaW5nICAgLCBOb19wcmVjaXNpb24gICAgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gZm10KVxuICAgIHwgTm9fcGFkZGluZyAgICwgTGl0X3ByZWNpc2lvbiBfIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIGZtdClcbiAgICB8IE5vX3BhZGRpbmcgICAsIEFyZ19wcmVjaXNpb24gICAtPlxuICAgICAgICBjb25zdCAoY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gZm10KSlcbiAgICB8IExpdF9wYWRkaW5nIF8sIE5vX3ByZWNpc2lvbiAgICAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyBmbXQpXG4gICAgfCBMaXRfcGFkZGluZyBfLCBMaXRfcHJlY2lzaW9uIF8gLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gZm10KVxuICAgIHwgTGl0X3BhZGRpbmcgXywgQXJnX3ByZWNpc2lvbiAgIC0+XG4gICAgICAgIGNvbnN0IChjb25zdCAobWFrZV9pcHJpbnRmIGsgbyBmbXQpKVxuICAgIHwgQXJnX3BhZGRpbmcgXywgTm9fcHJlY2lzaW9uICAgIC0+XG4gICAgICAgIGNvbnN0IChjb25zdCAobWFrZV9pcHJpbnRmIGsgbyBmbXQpKVxuICAgIHwgQXJnX3BhZGRpbmcgXywgTGl0X3ByZWNpc2lvbiBfIC0+XG4gICAgICAgIGNvbnN0IChjb25zdCAobWFrZV9pcHJpbnRmIGsgbyBmbXQpKVxuICAgIHwgQXJnX3BhZGRpbmcgXywgQXJnX3ByZWNpc2lvbiAgIC0+XG4gICAgICAgIGNvbnN0IChjb25zdCAoY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gZm10KSkpXG5hbmQgZm5fb2ZfY3VzdG9tX2FyaXR5IDogdHlwZSB4IHkgYSBiIGMgZCBlIGYgc3RhdGUuXG4gIChzdGF0ZSAtPiBmKSAtPlxuICBzdGF0ZSAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+IChhLCB4LCB5KSBjdXN0b21fYXJpdHkgLT4geSA9XG4gIGZ1biBrIG8gZm10IC0+IGZ1bmN0aW9uXG4gICAgfCBDdXN0b21femVybyAtPlxuICAgICAgICBtYWtlX2lwcmludGYgayBvIGZtdFxuICAgIHwgQ3VzdG9tX3N1Y2MgYXJpdHkgLT5cbiAgICAgICAgY29uc3QgKGZuX29mX2N1c3RvbV9hcml0eSBrIG8gZm10IGFyaXR5KVxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBDb250aW51YXRpb25zIGZvciBtYWtlX3ByaW50ZiAqKVxuXG4oKiBSZWN1cnNpdmVseSBvdXRwdXQgYW4gXCJhY2N1bXVsYXRvclwiIGNvbnRhaW5pbmcgYSByZXZlcnNlZCBsaXN0IG9mXG4gICBwcmludGluZyBlbnRpdGllcyAoc3RyaW5nLCBjaGFyLCBmbHVzLCAuLi4pIGluIGFuIG91dHB1dF9zdHJlYW0uICopXG4oKiBVc2VkIGFzIGEgY29udGludWF0aW9uIG9mIG1ha2VfcHJpbnRmLiAqKVxubGV0IHJlYyBvdXRwdXRfYWNjIG8gYWNjID0gbWF0Y2ggYWNjIHdpdGhcbiAgfCBBY2NfZm9ybWF0dGluZ19saXQgKHAsIGZtdGluZ19saXQpIC0+XG4gICAgbGV0IHMgPSBzdHJpbmdfb2ZfZm9ybWF0dGluZ19saXQgZm10aW5nX2xpdCBpblxuICAgIG91dHB1dF9hY2MgbyBwOyBvdXRwdXRfc3RyaW5nIG8gcztcbiAgfCBBY2NfZm9ybWF0dGluZ19nZW4gKHAsIEFjY19vcGVuX3RhZyBhY2MnKSAtPlxuICAgIG91dHB1dF9hY2MgbyBwOyBvdXRwdXRfc3RyaW5nIG8gXCJAe1wiOyBvdXRwdXRfYWNjIG8gYWNjJztcbiAgfCBBY2NfZm9ybWF0dGluZ19nZW4gKHAsIEFjY19vcGVuX2JveCBhY2MnKSAtPlxuICAgIG91dHB1dF9hY2MgbyBwOyBvdXRwdXRfc3RyaW5nIG8gXCJAW1wiOyBvdXRwdXRfYWNjIG8gYWNjJztcbiAgfCBBY2Nfc3RyaW5nX2xpdGVyYWwgKHAsIHMpXG4gIHwgQWNjX2RhdGFfc3RyaW5nIChwLCBzKSAgIC0+IG91dHB1dF9hY2MgbyBwOyBvdXRwdXRfc3RyaW5nIG8gc1xuICB8IEFjY19jaGFyX2xpdGVyYWwgKHAsIGMpXG4gIHwgQWNjX2RhdGFfY2hhciAocCwgYykgICAgIC0+IG91dHB1dF9hY2MgbyBwOyBvdXRwdXRfY2hhciBvIGNcbiAgfCBBY2NfZGVsYXkgKHAsIGYpICAgICAgICAgLT4gb3V0cHV0X2FjYyBvIHA7IGYgb1xuICB8IEFjY19mbHVzaCBwICAgICAgICAgICAgICAtPiBvdXRwdXRfYWNjIG8gcDsgZmx1c2ggb1xuICB8IEFjY19pbnZhbGlkX2FyZyAocCwgbXNnKSAtPiBvdXRwdXRfYWNjIG8gcDsgaW52YWxpZF9hcmcgbXNnO1xuICB8IEVuZF9vZl9hY2MgICAgICAgICAgICAgICAtPiAoKVxuXG4oKiBSZWN1cnNpdmVseSBvdXRwdXQgYW4gXCJhY2N1bXVsYXRvclwiIGNvbnRhaW5pbmcgYSByZXZlcnNlZCBsaXN0IG9mXG4gICBwcmludGluZyBlbnRpdGllcyAoc3RyaW5nLCBjaGFyLCBmbHVzLCAuLi4pIGluIGEgYnVmZmVyLiAqKVxuKCogVXNlZCBhcyBhIGNvbnRpbnVhdGlvbiBvZiBtYWtlX3ByaW50Zi4gKilcbmxldCByZWMgYnVmcHV0X2FjYyBiIGFjYyA9IG1hdGNoIGFjYyB3aXRoXG4gIHwgQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBmbXRpbmdfbGl0KSAtPlxuICAgIGxldCBzID0gc3RyaW5nX29mX2Zvcm1hdHRpbmdfbGl0IGZtdGluZ19saXQgaW5cbiAgICBidWZwdXRfYWNjIGIgcDsgQnVmZmVyLmFkZF9zdHJpbmcgYiBzO1xuICB8IEFjY19mb3JtYXR0aW5nX2dlbiAocCwgQWNjX29wZW5fdGFnIGFjYycpIC0+XG4gICAgYnVmcHV0X2FjYyBiIHA7IEJ1ZmZlci5hZGRfc3RyaW5nIGIgXCJAe1wiOyBidWZwdXRfYWNjIGIgYWNjJztcbiAgfCBBY2NfZm9ybWF0dGluZ19nZW4gKHAsIEFjY19vcGVuX2JveCBhY2MnKSAtPlxuICAgIGJ1ZnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX3N0cmluZyBiIFwiQFtcIjsgYnVmcHV0X2FjYyBiIGFjYyc7XG4gIHwgQWNjX3N0cmluZ19saXRlcmFsIChwLCBzKVxuICB8IEFjY19kYXRhX3N0cmluZyAocCwgcykgICAtPiBidWZwdXRfYWNjIGIgcDsgQnVmZmVyLmFkZF9zdHJpbmcgYiBzXG4gIHwgQWNjX2NoYXJfbGl0ZXJhbCAocCwgYylcbiAgfCBBY2NfZGF0YV9jaGFyIChwLCBjKSAgICAgLT4gYnVmcHV0X2FjYyBiIHA7IEJ1ZmZlci5hZGRfY2hhciBiIGNcbiAgfCBBY2NfZGVsYXkgKHAsIGYpICAgICAgICAgLT4gYnVmcHV0X2FjYyBiIHA7IGYgYlxuICB8IEFjY19mbHVzaCBwICAgICAgICAgICAgICAtPiBidWZwdXRfYWNjIGIgcDtcbiAgfCBBY2NfaW52YWxpZF9hcmcgKHAsIG1zZykgLT4gYnVmcHV0X2FjYyBiIHA7IGludmFsaWRfYXJnIG1zZztcbiAgfCBFbmRfb2ZfYWNjICAgICAgICAgICAgICAgLT4gKClcblxuKCogUmVjdXJzaXZlbHkgb3V0cHV0IGFuIFwiYWNjdW11bGF0b3JcIiBjb250YWluaW5nIGEgcmV2ZXJzZWQgbGlzdCBvZlxuICAgcHJpbnRpbmcgZW50aXRpZXMgKHN0cmluZywgY2hhciwgZmx1cywgLi4uKSBpbiBhIGJ1ZmZlci4gKilcbigqIERpZmZlciBmcm9tIGJ1ZnB1dF9hY2MgYnkgdGhlIGludGVycHJldGF0aW9uIG9mICVhIGFuZCAldC4gKilcbigqIFVzZWQgYXMgYSBjb250aW51YXRpb24gb2YgbWFrZV9wcmludGYuICopXG5sZXQgcmVjIHN0cnB1dF9hY2MgYiBhY2MgPSBtYXRjaCBhY2Mgd2l0aFxuICB8IEFjY19mb3JtYXR0aW5nX2xpdCAocCwgZm10aW5nX2xpdCkgLT5cbiAgICBsZXQgcyA9IHN0cmluZ19vZl9mb3JtYXR0aW5nX2xpdCBmbXRpbmdfbGl0IGluXG4gICAgc3RycHV0X2FjYyBiIHA7IEJ1ZmZlci5hZGRfc3RyaW5nIGIgcztcbiAgfCBBY2NfZm9ybWF0dGluZ19nZW4gKHAsIEFjY19vcGVuX3RhZyBhY2MnKSAtPlxuICAgIHN0cnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX3N0cmluZyBiIFwiQHtcIjsgc3RycHV0X2FjYyBiIGFjYyc7XG4gIHwgQWNjX2Zvcm1hdHRpbmdfZ2VuIChwLCBBY2Nfb3Blbl9ib3ggYWNjJykgLT5cbiAgICBzdHJwdXRfYWNjIGIgcDsgQnVmZmVyLmFkZF9zdHJpbmcgYiBcIkBbXCI7IHN0cnB1dF9hY2MgYiBhY2MnO1xuICB8IEFjY19zdHJpbmdfbGl0ZXJhbCAocCwgcylcbiAgfCBBY2NfZGF0YV9zdHJpbmcgKHAsIHMpICAgLT4gc3RycHV0X2FjYyBiIHA7IEJ1ZmZlci5hZGRfc3RyaW5nIGIgc1xuICB8IEFjY19jaGFyX2xpdGVyYWwgKHAsIGMpXG4gIHwgQWNjX2RhdGFfY2hhciAocCwgYykgICAgIC0+IHN0cnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX2NoYXIgYiBjXG4gIHwgQWNjX2RlbGF5IChwLCBmKSAgICAgICAgIC0+IHN0cnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX3N0cmluZyBiIChmICgpKVxuICB8IEFjY19mbHVzaCBwICAgICAgICAgICAgICAtPiBzdHJwdXRfYWNjIGIgcDtcbiAgfCBBY2NfaW52YWxpZF9hcmcgKHAsIG1zZykgLT4gc3RycHV0X2FjYyBiIHA7IGludmFsaWRfYXJnIG1zZztcbiAgfCBFbmRfb2ZfYWNjICAgICAgICAgICAgICAgLT4gKClcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKCogRXJyb3IgbWFuYWdlbWVudCAqKVxuXG4oKiBSYWlzZSBbRmFpbHVyZV0gd2l0aCBhIHByZXR0eS1wcmludGVkIGVycm9yIG1lc3NhZ2UuICopXG5sZXQgZmFpbHdpdGhfbWVzc2FnZSAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIGxldCBidWYgPSBCdWZmZXIuY3JlYXRlIDI1NiBpblxuICBsZXQgayBhY2MgPSBzdHJwdXRfYWNjIGJ1ZiBhY2M7IGZhaWx3aXRoIChCdWZmZXIuY29udGVudHMgYnVmKSBpblxuICBtYWtlX3ByaW50ZiBrIEVuZF9vZl9hY2MgZm10XG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogRm9ybWF0dGluZyB0b29scyAqKVxuXG4oKiBDb252ZXJ0IGEgc3RyaW5nIHRvIGFuIG9wZW4gYmxvY2sgZGVzY3JpcHRpb24gKGluZGVudCwgYmxvY2tfdHlwZSkgKilcbmxldCBvcGVuX2JveF9vZl9zdHJpbmcgc3RyID1cbiAgaWYgc3RyID0gXCJcIiB0aGVuICgwLCBQcF9ib3gpIGVsc2VcbiAgICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzdHIgaW5cbiAgICBsZXQgaW52YWxpZF9ib3ggKCkgPSBmYWlsd2l0aF9tZXNzYWdlIFwiaW52YWxpZCBib3ggZGVzY3JpcHRpb24gJVNcIiBzdHIgaW5cbiAgICBsZXQgcmVjIHBhcnNlX3NwYWNlcyBpID1cbiAgICAgIGlmIGkgPSBsZW4gdGhlbiBpIGVsc2VcbiAgICAgICAgbWF0Y2ggc3RyLltpXSB3aXRoXG4gICAgICAgIHwgJyAnIHwgJ1xcdCcgLT4gcGFyc2Vfc3BhY2VzIChpICsgMSlcbiAgICAgICAgfCBfIC0+IGlcbiAgICBhbmQgcGFyc2VfbHdvcmQgaSBqID1cbiAgICAgIGlmIGogPSBsZW4gdGhlbiBqIGVsc2VcbiAgICAgICAgbWF0Y2ggc3RyLltqXSB3aXRoXG4gICAgICAgIHwgJ2EnIC4uICd6JyAtPiBwYXJzZV9sd29yZCBpIChqICsgMSlcbiAgICAgICAgfCBfIC0+IGpcbiAgICBhbmQgcGFyc2VfaW50IGkgaiA9XG4gICAgICBpZiBqID0gbGVuIHRoZW4gaiBlbHNlXG4gICAgICAgIG1hdGNoIHN0ci5bal0gd2l0aFxuICAgICAgICB8ICcwJyAuLiAnOScgfCAnLScgLT4gcGFyc2VfaW50IGkgKGogKyAxKVxuICAgICAgICB8IF8gLT4gaiBpblxuICAgIGxldCB3c3RhcnQgPSBwYXJzZV9zcGFjZXMgMCBpblxuICAgIGxldCB3ZW5kID0gcGFyc2VfbHdvcmQgd3N0YXJ0IHdzdGFydCBpblxuICAgIGxldCBib3hfbmFtZSA9IFN0cmluZy5zdWIgc3RyIHdzdGFydCAod2VuZCAtIHdzdGFydCkgaW5cbiAgICBsZXQgbnN0YXJ0ID0gcGFyc2Vfc3BhY2VzIHdlbmQgaW5cbiAgICBsZXQgbmVuZCA9IHBhcnNlX2ludCBuc3RhcnQgbnN0YXJ0IGluXG4gICAgbGV0IGluZGVudCA9XG4gICAgICBpZiBuc3RhcnQgPSBuZW5kIHRoZW4gMCBlbHNlXG4gICAgICAgIHRyeSBpbnRfb2Zfc3RyaW5nIChTdHJpbmcuc3ViIHN0ciBuc3RhcnQgKG5lbmQgLSBuc3RhcnQpKVxuICAgICAgICB3aXRoIEZhaWx1cmUgXyAtPiBpbnZhbGlkX2JveCAoKSBpblxuICAgIGxldCBleHBfZW5kID0gcGFyc2Vfc3BhY2VzIG5lbmQgaW5cbiAgICBpZiBleHBfZW5kIDw+IGxlbiB0aGVuIGludmFsaWRfYm94ICgpO1xuICAgIGxldCBib3hfdHlwZSA9IG1hdGNoIGJveF9uYW1lIHdpdGhcbiAgICAgIHwgXCJcIiB8IFwiYlwiIC0+IFBwX2JveFxuICAgICAgfCBcImhcIiAgICAgIC0+IFBwX2hib3hcbiAgICAgIHwgXCJ2XCIgICAgICAtPiBQcF92Ym94XG4gICAgICB8IFwiaHZcIiAgICAgLT4gUHBfaHZib3hcbiAgICAgIHwgXCJob3ZcIiAgICAtPiBQcF9ob3Zib3hcbiAgICAgIHwgXyAgICAgICAgLT4gaW52YWxpZF9ib3ggKCkgaW5cbiAgICAoaW5kZW50LCBib3hfdHlwZSlcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBQYXJzaW5nIHRvb2xzICopXG5cbigqIENyZWF0ZSBhIHBhZGRpbmdfZm10X2ViYiBmcm9tIGEgcGFkZGluZyBhbmQgYSBmb3JtYXQuICopXG4oKiBDb3B5IHRoZSBwYWRkaW5nIHRvIGRpc2pvaW4gdGhlIHR5cGUgcGFyYW1ldGVycyBvZiBhcmd1bWVudCBhbmQgcmVzdWx0LiAqKVxubGV0IG1ha2VfcGFkZGluZ19mbXRfZWJiIDogdHlwZSB4IHkgLlxuICAgICh4LCB5KSBwYWRkaW5nIC0+IChfLCBfLCBfLCBfLCBfLCBfKSBmbXQgLT5cbiAgICAgIChfLCBfLCBfLCBfLCBfKSBwYWRkaW5nX2ZtdF9lYmIgPVxuZnVuIHBhZCBmbXQgLT4gbWF0Y2ggcGFkIHdpdGhcbiAgfCBOb19wYWRkaW5nICAgICAgICAgLT4gUGFkZGluZ19mbXRfRUJCIChOb19wYWRkaW5nLCBmbXQpXG4gIHwgTGl0X3BhZGRpbmcgKHMsIHcpIC0+IFBhZGRpbmdfZm10X0VCQiAoTGl0X3BhZGRpbmcgKHMsIHcpLCBmbXQpXG4gIHwgQXJnX3BhZGRpbmcgcyAgICAgIC0+IFBhZGRpbmdfZm10X0VCQiAoQXJnX3BhZGRpbmcgcywgZm10KVxuXG4oKiBDcmVhdGUgYSBwcmVjaXNpb25fZm10X2ViYiBmcm9tIGEgcHJlY2lzaW9uIGFuZCBhIGZvcm1hdC4gKilcbigqIENvcHkgdGhlIHByZWNpc2lvbiB0byBkaXNqb2luIHRoZSB0eXBlIHBhcmFtZXRlcnMgb2YgYXJndW1lbnQgYW5kIHJlc3VsdC4gKilcbmxldCBtYWtlX3ByZWNpc2lvbl9mbXRfZWJiIDogdHlwZSB4IHkgLlxuICAgICh4LCB5KSBwcmVjaXNpb24gLT4gKF8sIF8sIF8sIF8sIF8sIF8pIGZtdCAtPlxuICAgICAgKF8sIF8sIF8sIF8sIF8pIHByZWNpc2lvbl9mbXRfZWJiID1cbmZ1biBwcmVjIGZtdCAtPiBtYXRjaCBwcmVjIHdpdGhcbiAgfCBOb19wcmVjaXNpb24gICAgLT4gUHJlY2lzaW9uX2ZtdF9FQkIgKE5vX3ByZWNpc2lvbiwgZm10KVxuICB8IExpdF9wcmVjaXNpb24gcCAtPiBQcmVjaXNpb25fZm10X0VCQiAoTGl0X3ByZWNpc2lvbiBwLCBmbXQpXG4gIHwgQXJnX3ByZWNpc2lvbiAgIC0+IFByZWNpc2lvbl9mbXRfRUJCIChBcmdfcHJlY2lzaW9uLCBmbXQpXG5cbigqIENyZWF0ZSBhIHBhZHByZWNfZm10X2ViYiBmcm9tIGEgcGFkZGluZywgYSBwcmVjaXNpb24gYW5kIGEgZm9ybWF0LiAqKVxuKCogQ29weSB0aGUgcGFkZGluZyBhbmQgdGhlIHByZWNpc2lvbiB0byBkaXNqb2luIHR5cGUgcGFyYW1ldGVycyBvZiBhcmd1bWVudHNcbiAgIGFuZCByZXN1bHQuICopXG5sZXQgbWFrZV9wYWRwcmVjX2ZtdF9lYmIgOiB0eXBlIHggeSB6IHQgLlxuICAgICh4LCB5KSBwYWRkaW5nIC0+ICh6LCB0KSBwcmVjaXNpb24gLT5cbiAgICAoXywgXywgXywgXywgXywgXykgZm10IC0+XG4gICAgKF8sIF8sIF8sIF8sIF8pIHBhZHByZWNfZm10X2ViYiA9XG5mdW4gcGFkIHByZWMgZm10IC0+XG4gIGxldCBQcmVjaXNpb25fZm10X0VCQiAocHJlYywgZm10JykgPSBtYWtlX3ByZWNpc2lvbl9mbXRfZWJiIHByZWMgZm10IGluXG4gIG1hdGNoIHBhZCB3aXRoXG4gIHwgTm9fcGFkZGluZyAgICAgICAgIC0+IFBhZHByZWNfZm10X0VCQiAoTm9fcGFkZGluZywgcHJlYywgZm10JylcbiAgfCBMaXRfcGFkZGluZyAocywgdykgLT4gUGFkcHJlY19mbXRfRUJCIChMaXRfcGFkZGluZyAocywgdyksIHByZWMsIGZtdCcpXG4gIHwgQXJnX3BhZGRpbmcgcyAgICAgIC0+IFBhZHByZWNfZm10X0VCQiAoQXJnX3BhZGRpbmcgcywgcHJlYywgZm10JylcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogRm9ybWF0IHBhcnNpbmcgKilcblxuKCogUGFyc2UgYSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZm9ybWF0IGFuZCBjcmVhdGUgYSBmbXRfZWJiLiAqKVxuKCogUmFpc2UgW0ZhaWx1cmVdIGluIGNhc2Ugb2YgaW52YWxpZCBmb3JtYXQuICopXG5sZXQgZm10X2ViYl9vZl9zdHJpbmcgP2xlZ2FjeV9iZWhhdmlvciBzdHIgPVxuICAoKiBQYXJhbWV0ZXJzIG5hbWluZyBjb252ZW50aW9uOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4gICgqICAgLSBsaXRfc3RhcnQ6IHN0YXJ0IG9mIHRoZSBsaXRlcmFsIHNlcXVlbmNlLiAgICAgICAgICAgICAgICAgICAgKilcbiAgKCogICAtIHN0cl9pbmQ6IGN1cnJlbnQgaW5kZXggaW4gdGhlIHN0cmluZy4gICAgICAgICAgICAgICAgICAgICAgICAqKVxuICAoKiAgIC0gZW5kX2luZDogZW5kIG9mIHRoZSBjdXJyZW50IChzdWItKWZvcm1hdC4gICAgICAgICAgICAgICAgICAgICopXG4gICgqICAgLSBwY3RfaW5kOiBpbmRleCBvZiB0aGUgJyUnIGluIHRoZSBjdXJyZW50IG1pY3JvLWZvcm1hdC4gICAgICAgKilcbiAgKCogICAtIHplcm86ICBpcyB0aGUgJzAnIGZsYWcgZGVmaW5lZCBpbiB0aGUgY3VycmVudCBtaWNyby1mb3JtYXQuICAqKVxuICAoKiAgIC0gbWludXM6IGlzIHRoZSAnLScgZmxhZyBkZWZpbmVkIGluIHRoZSBjdXJyZW50IG1pY3JvLWZvcm1hdC4gICopXG4gICgqICAgLSBwbHVzOiAgaXMgdGhlICcrJyBmbGFnIGRlZmluZWQgaW4gdGhlIGN1cnJlbnQgbWljcm8tZm9ybWF0LiAgKilcbiAgKCogICAtIGhhc2g6ICBpcyB0aGUgJyMnIGZsYWcgZGVmaW5lZCBpbiB0aGUgY3VycmVudCBtaWNyby1mb3JtYXQuICAqKVxuICAoKiAgIC0gc3BhY2U6IGlzIHRoZSAnICcgZmxhZyBkZWZpbmVkIGluIHRoZSBjdXJyZW50IG1pY3JvLWZvcm1hdC4gICopXG4gICgqICAgLSBpZ246ICAgaXMgdGhlICdfJyBmbGFnIGRlZmluZWQgaW4gdGhlIGN1cnJlbnQgbWljcm8tZm9ybWF0LiAgKilcbiAgKCogICAtIHBhZDogcGFkZGluZyBvZiB0aGUgY3VycmVudCBtaWNyby1mb3JtYXQuICAgICAgICAgICAgICAgICAgICAqKVxuICAoKiAgIC0gcHJlYzogcHJlY2lzaW9uIG9mIHRoZSBjdXJyZW50IG1pY3JvLWZvcm1hdC4gICAgICAgICAgICAgICAgICopXG4gICgqICAgLSBzeW1iOiBjaGFyIHJlcHJlc2VudGluZyB0aGUgY29udmVyc2lvbiAoJ2MnLCAncycsICdkJywgLi4uKS4gKilcbiAgKCogICAtIGNoYXJfc2V0OiBzZXQgb2YgY2hhcmFjdGVycyBhcyBiaXRtYXAgKHNlZSBzY2FuZiAlWy4uLl0pLiAgICAqKVxuXG4gIGxldCBsZWdhY3lfYmVoYXZpb3IgPSBtYXRjaCBsZWdhY3lfYmVoYXZpb3Igd2l0aFxuICAgIHwgU29tZSBmbGFnIC0+IGZsYWdcbiAgICB8IE5vbmUgLT4gdHJ1ZVxuICAoKiAgV2hlbiB0aGlzIGZsYWcgaXMgZW5hYmxlZCwgdGhlIGZvcm1hdCBwYXJzZXIgdHJpZXMgdG8gYmVoYXZlIGFzXG4gICAgICB0aGUgPDQuMDIgaW1wbGVtZW50YXRpb25zLCBpbiBwYXJ0aWN1bGFyIGl0IGlnbm9yZXMgbW9zdCBiZW5pbmVcbiAgICAgIG5vbnNlbnNpY2FsIGZvcm1hdC4gV2hlbiB0aGUgZmxhZyBpcyBkaXNhYmxlZCwgaXQgd2lsbCByZWplY3QgYW55XG4gICAgICBmb3JtYXQgdGhhdCBpcyBub3QgYWNjZXB0ZWQgYnkgdGhlIHNwZWNpZmljYXRpb24uXG5cbiAgICAgIEEgdHlwaWNhbCBleGFtcGxlIHdvdWxkIGJlIFwiJSsgZFwiOiBzcGVjaWZ5aW5nIGJvdGggJysnIChpZiB0aGVcbiAgICAgIG51bWJlciBpcyBwb3NpdGl2ZSwgcGFkIHdpdGggYSAnKycgdG8gZ2V0IHRoZSBzYW1lIHdpZHRoIGFzXG4gICAgICBuZWdhdGl2ZSBudW1iZXJzKSBhbmQgJyAnIChpZiB0aGUgbnVtYmVyIGlzIHBvc2l0aXZlLCBwYWQgd2l0aFxuICAgICAgYSBzcGFjZSkgZG9lcyBub3QgbWFrZSBzZW5zZSwgYnV0IHRoZSBsZWdhY3kgKDwgNC4wMilcbiAgICAgIGltcGxlbWVudGF0aW9uIHdhcyBoYXBweSB0byBqdXN0IGlnbm9yZSB0aGUgc3BhY2UuXG4gICopXG4gIGluXG5cbiAgKCogUmFpc2UgW0ZhaWx1cmVdIHdpdGggYSBmcmllbmRseSBlcnJvciBtZXNzYWdlLiAqKVxuICBsZXQgaW52YWxpZF9mb3JtYXRfbWVzc2FnZSBzdHJfaW5kIG1zZyA9XG4gICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgXCJpbnZhbGlkIGZvcm1hdCAlUzogYXQgY2hhcmFjdGVyIG51bWJlciAlZCwgJXNcIlxuICAgICAgc3RyIHN0cl9pbmQgbXNnXG4gIGluXG5cbiAgKCogVXNlZCB3aGVuIHRoZSBlbmQgb2YgdGhlIGZvcm1hdCAob3IgdGhlIGN1cnJlbnQgc3ViLWZvcm1hdCkgd2FzIGVuY291bnRlcmVkXG4gICAgICB1bmV4cGVjdGVkbHkuICopXG4gIGxldCB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZCA9XG4gICAgaW52YWxpZF9mb3JtYXRfbWVzc2FnZSBlbmRfaW5kXG4gICAgICBcInVuZXhwZWN0ZWQgZW5kIG9mIGZvcm1hdFwiXG4gIGluXG5cbiAgKCogVXNlZCBmb3IgJTBjOiBubyBvdGhlciB3aWR0aHMgYXJlIGltcGxlbWVudGVkICopXG4gIGxldCBpbnZhbGlkX25vbm51bGxfY2hhcl93aWR0aCBzdHJfaW5kID1cbiAgICBpbnZhbGlkX2Zvcm1hdF9tZXNzYWdlIHN0cl9pbmRcbiAgICAgIFwibm9uLXplcm8gd2lkdGhzIGFyZSB1bnN1cHBvcnRlZCBmb3IgJWMgY29udmVyc2lvbnNcIlxuICBpblxuICAoKiBSYWlzZSBbRmFpbHVyZV0gd2l0aCBhIGZyaWVuZGx5IGVycm9yIG1lc3NhZ2UgYWJvdXQgYW4gb3B0aW9uIGRlcGVuZGVuY3lcbiAgICAgcHJvYmxlbS4gKilcbiAgbGV0IGludmFsaWRfZm9ybWF0X3dpdGhvdXQgc3RyX2luZCBjIHMgPVxuICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgIFwiaW52YWxpZCBmb3JtYXQgJVM6IGF0IGNoYXJhY3RlciBudW1iZXIgJWQsICclYycgd2l0aG91dCAlc1wiXG4gICAgICBzdHIgc3RyX2luZCBjIHNcbiAgaW5cblxuICAoKiBSYWlzZSBbRmFpbHVyZV0gd2l0aCBhIGZyaWVuZGx5IGVycm9yIG1lc3NhZ2UgYWJvdXQgYW4gdW5leHBlY3RlZFxuICAgICBjaGFyYWN0ZXIuICopXG4gIGxldCBleHBlY3RlZF9jaGFyYWN0ZXIgc3RyX2luZCBleHBlY3RlZCByZWFkID1cbiAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgIFwiaW52YWxpZCBmb3JtYXQgJVM6IGF0IGNoYXJhY3RlciBudW1iZXIgJWQsICVzIGV4cGVjdGVkLCByZWFkICVDXCJcbiAgICAgIHN0ciBzdHJfaW5kIGV4cGVjdGVkIHJlYWRcbiAgaW5cblxuICAoKiBQYXJzZSB0aGUgc3RyaW5nIGZyb20gYmVnX2luZCAoaW5jbHVkZWQpIHRvIGVuZF9pbmQgKGV4Y2x1ZGVkKS4gKilcbiAgbGV0IHJlYyBwYXJzZSA6IHR5cGUgZSBmIC4gaW50IC0+IGludCAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBiZWdfaW5kIGVuZF9pbmQgLT4gcGFyc2VfbGl0ZXJhbCBiZWdfaW5kIGJlZ19pbmQgZW5kX2luZFxuXG4gICgqIFJlYWQgbGl0ZXJhbCBjaGFyYWN0ZXJzIHVwIHRvICclJyBvciAnQCcgc3BlY2lhbCBjaGFyYWN0ZXJzLiAqKVxuICBhbmQgcGFyc2VfbGl0ZXJhbCA6IHR5cGUgZSBmIC4gaW50IC0+IGludCAtPiBpbnQgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gbGl0X3N0YXJ0IHN0cl9pbmQgZW5kX2luZCAtPlxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gYWRkX2xpdGVyYWwgbGl0X3N0YXJ0IHN0cl9pbmQgRW5kX29mX2Zvcm1hdCBlbHNlXG4gICAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICAgIHwgJyUnIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2VfZm9ybWF0IHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgICBhZGRfbGl0ZXJhbCBsaXRfc3RhcnQgc3RyX2luZCBmbXRfcmVzdFxuICAgICAgfCAnQCcgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZV9hZnRlcl9hdCAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgYWRkX2xpdGVyYWwgbGl0X3N0YXJ0IHN0cl9pbmQgZm10X3Jlc3RcbiAgICAgIHwgXyAtPlxuICAgICAgICBwYXJzZV9saXRlcmFsIGxpdF9zdGFydCAoc3RyX2luZCArIDEpIGVuZF9pbmRcblxuICAoKiBQYXJzZSBhIGZvcm1hdCBhZnRlciAnJScgKilcbiAgYW5kIHBhcnNlX2Zvcm1hdCA6IHR5cGUgZSBmIC4gaW50IC0+IGludCAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBwY3RfaW5kIGVuZF9pbmQgLT4gcGFyc2VfaWduIHBjdF9pbmQgKHBjdF9pbmQgKyAxKSBlbmRfaW5kXG5cbiAgYW5kIHBhcnNlX2lnbiA6IHR5cGUgZSBmIC4gaW50IC0+IGludCAtPiBpbnQgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgLT5cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgICAgfCAnXycgLT4gcGFyc2VfZmxhZ3MgcGN0X2luZCAoc3RyX2luZCsxKSBlbmRfaW5kIHRydWVcbiAgICAgIHwgXyAtPiBwYXJzZV9mbGFncyBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCBmYWxzZVxuXG4gIGFuZCBwYXJzZV9mbGFncyA6IHR5cGUgZSBmIC4gaW50IC0+IGludCAtPiBpbnQgLT4gYm9vbCAtPiAoXywgXywgZSwgZikgZm10X2ViYlxuICA9XG4gIGZ1biBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCBpZ24gLT5cbiAgICBsZXQgemVybyA9IHJlZiBmYWxzZSBhbmQgbWludXMgPSByZWYgZmFsc2VcbiAgICBhbmQgcGx1cyA9IHJlZiBmYWxzZSBhbmQgc3BhY2UgPSByZWYgZmFsc2VcbiAgICBhbmQgaGFzaCA9IHJlZiBmYWxzZSBpblxuICAgIGxldCBzZXRfZmxhZyBzdHJfaW5kIGZsYWcgPVxuICAgICAgKCogaW4gbGVnYWN5IG1vZGUsIGR1cGxpY2F0ZSBmbGFncyBhcmUgYWNjZXB0ZWQgKilcbiAgICAgIGlmICFmbGFnICYmIG5vdCBsZWdhY3lfYmVoYXZpb3IgdGhlblxuICAgICAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICAgICAgXCJpbnZhbGlkIGZvcm1hdCAlUzogYXQgY2hhcmFjdGVyIG51bWJlciAlZCwgZHVwbGljYXRlIGZsYWcgJUNcIlxuICAgICAgICAgIHN0ciBzdHJfaW5kIHN0ci5bc3RyX2luZF07XG4gICAgICBmbGFnIDo9IHRydWU7XG4gICAgaW5cbiAgICBsZXQgcmVjIHJlYWRfZmxhZ3Mgc3RyX2luZCA9XG4gICAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgYmVnaW4gbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgICB8ICcwJyAtPiBzZXRfZmxhZyBzdHJfaW5kIHplcm87ICByZWFkX2ZsYWdzIChzdHJfaW5kICsgMSlcbiAgICAgIHwgJy0nIC0+IHNldF9mbGFnIHN0cl9pbmQgbWludXM7IHJlYWRfZmxhZ3MgKHN0cl9pbmQgKyAxKVxuICAgICAgfCAnKycgLT4gc2V0X2ZsYWcgc3RyX2luZCBwbHVzOyAgcmVhZF9mbGFncyAoc3RyX2luZCArIDEpXG4gICAgICB8ICcjJyAtPiBzZXRfZmxhZyBzdHJfaW5kIGhhc2g7IHJlYWRfZmxhZ3MgKHN0cl9pbmQgKyAxKVxuICAgICAgfCAnICcgLT4gc2V0X2ZsYWcgc3RyX2luZCBzcGFjZTsgcmVhZF9mbGFncyAoc3RyX2luZCArIDEpXG4gICAgICB8IF8gLT5cbiAgICAgICAgcGFyc2VfcGFkZGluZyBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZFxuICAgICAgICAgICF6ZXJvICFtaW51cyAhcGx1cyAhaGFzaCAhc3BhY2UgaWduXG4gICAgICBlbmRcbiAgICBpblxuICAgIHJlYWRfZmxhZ3Mgc3RyX2luZFxuXG4gICgqIFRyeSB0byByZWFkIGEgZGlnaXRhbCBvciBhICcqJyBwYWRkaW5nLiAqKVxuICBhbmQgcGFyc2VfcGFkZGluZyA6IHR5cGUgZSBmIC5cbiAgICAgIGludCAtPiBpbnQgLT4gaW50IC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+XG4gICAgICAgIChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIHplcm8gbWludXMgcGx1cyBoYXNoIHNwYWNlIGlnbiAtPlxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgbGV0IHBhZHR5ID0gbWF0Y2ggemVybywgbWludXMgd2l0aFxuICAgICAgfCBmYWxzZSwgZmFsc2UgLT4gUmlnaHRcbiAgICAgIHwgZmFsc2UsIHRydWUgIC0+IExlZnRcbiAgICAgIHwgIHRydWUsIGZhbHNlIC0+IFplcm9zXG4gICAgICB8ICB0cnVlLCB0cnVlICAtPlxuICAgICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiBMZWZ0XG4gICAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kICctJyBcIjBcIiBpblxuICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgIHwgJzAnIC4uICc5JyAtPlxuICAgICAgbGV0IG5ld19pbmQsIHdpZHRoID0gcGFyc2VfcG9zaXRpdmUgc3RyX2luZCBlbmRfaW5kIDAgaW5cbiAgICAgIHBhcnNlX2FmdGVyX3BhZGRpbmcgcGN0X2luZCBuZXdfaW5kIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlIGlnblxuICAgICAgICAoTGl0X3BhZGRpbmcgKHBhZHR5LCB3aWR0aCkpXG4gICAgfCAnKicgLT5cbiAgICAgIHBhcnNlX2FmdGVyX3BhZGRpbmcgcGN0X2luZCAoc3RyX2luZCArIDEpIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlXG4gICAgICAgIGlnbiAoQXJnX3BhZGRpbmcgcGFkdHkpXG4gICAgfCBfIC0+XG4gICAgICBiZWdpbiBtYXRjaCBwYWR0eSB3aXRoXG4gICAgICB8IExlZnQgIC0+XG4gICAgICAgIGlmIG5vdCBsZWdhY3lfYmVoYXZpb3IgdGhlblxuICAgICAgICAgIGludmFsaWRfZm9ybWF0X3dpdGhvdXQgKHN0cl9pbmQgLSAxKSAnLScgXCJwYWRkaW5nXCI7XG4gICAgICAgIHBhcnNlX2FmdGVyX3BhZGRpbmcgcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlIGlnblxuICAgICAgICAgIE5vX3BhZGRpbmdcbiAgICAgIHwgWmVyb3MgLT5cbiAgICAgICAgICgqIGEgJzAnIHBhZGRpbmcgaW5kaWNhdGlvbiBub3QgZm9sbG93ZWQgYnkgYW55dGhpbmcgc2hvdWxkXG4gICAgICAgICAgIGJlIGludGVycHJldGVkIGFzIGEgUmlnaHQgcGFkZGluZyBvZiB3aWR0aCAwLiBUaGlzIGlzIHVzZWRcbiAgICAgICAgICAgYnkgc2Nhbm5pbmcgY29udmVyc2lvbnMgJTBzIGFuZCAlMGMgKilcbiAgICAgICAgcGFyc2VfYWZ0ZXJfcGFkZGluZyBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2UgaWduXG4gICAgICAgICAgKExpdF9wYWRkaW5nIChSaWdodCwgMCkpXG4gICAgICB8IFJpZ2h0IC0+XG4gICAgICAgIHBhcnNlX2FmdGVyX3BhZGRpbmcgcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlIGlnblxuICAgICAgICAgIE5vX3BhZGRpbmdcbiAgICAgIGVuZFxuXG4gICgqIElzIHByZWNpc2lvbiBkZWZpbmVkPyAqKVxuICBhbmQgcGFyc2VfYWZ0ZXJfcGFkZGluZyA6IHR5cGUgeCBlIGYgLlxuICAgICAgaW50IC0+IGludCAtPiBpbnQgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+XG4gICAgICAgICh4LCBfKSBwYWRkaW5nIC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZSBpZ24gcGFkIC0+XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICB8ICcuJyAtPlxuICAgICAgcGFyc2VfcHJlY2lzaW9uIHBjdF9pbmQgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZSBpZ25cbiAgICAgICAgcGFkXG4gICAgfCBzeW1iIC0+XG4gICAgICBwYXJzZV9jb252ZXJzaW9uIHBjdF9pbmQgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIHBsdXMgaGFzaCBzcGFjZSBpZ24gcGFkXG4gICAgICAgIE5vX3ByZWNpc2lvbiBwYWQgc3ltYlxuXG4gICgqIFJlYWQgdGhlIGRpZ2l0YWwgb3IgJyonIHByZWNpc2lvbi4gKilcbiAgYW5kIHBhcnNlX3ByZWNpc2lvbiA6IHR5cGUgeCBlIGYgLlxuICAgICAgaW50IC0+IGludCAtPiBpbnQgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+XG4gICAgICAgICh4LCBfKSBwYWRkaW5nIC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZSBpZ24gcGFkIC0+XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICBsZXQgcGFyc2VfbGl0ZXJhbCBtaW51cyBzdHJfaW5kID1cbiAgICAgIGxldCBuZXdfaW5kLCBwcmVjID0gcGFyc2VfcG9zaXRpdmUgc3RyX2luZCBlbmRfaW5kIDAgaW5cbiAgICAgIHBhcnNlX2FmdGVyX3ByZWNpc2lvbiBwY3RfaW5kIG5ld19pbmQgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2UgaWduXG4gICAgICAgIHBhZCAoTGl0X3ByZWNpc2lvbiBwcmVjKSBpblxuICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgIHwgJzAnIC4uICc5JyAtPiBwYXJzZV9saXRlcmFsIG1pbnVzIHN0cl9pbmRcbiAgICB8ICgnKycgfCAnLScpIGFzIHN5bWIgd2hlbiBsZWdhY3lfYmVoYXZpb3IgLT5cbiAgICAgICgqIExlZ2FjeSBtb2RlIHdvdWxkIGFjY2VwdCBhbmQgaWdub3JlICcrJyBvciAnLScgYmVmb3JlIHRoZVxuICAgICAgICAgaW50ZWdlciBkZXNjcmliaW5nIHRoZSBkZXNpcmVkIHByZWNpc2lvbjsgbm90ZSB0aGF0IHRoaXNcbiAgICAgICAgIGNhbm5vdCBoYXBwZW4gZm9yIHBhZGRpbmcgd2lkdGgsIGFzICcrJyBhbmQgJy0nIGFscmVhZHkgaGF2ZVxuICAgICAgICAgYSBzZW1hbnRpY3MgdGhlcmUuXG5cbiAgICAgICAgIFRoYXQgc2FpZCwgdGhlIGlkZWEgKHN1cHBvcnRlZCBieSB0aGlzIHR3ZWFrKSB0aGF0IHdpZHRoIGFuZFxuICAgICAgICAgcHJlY2lzaW9uIGxpdGVyYWxzIGFyZSBcImludGVnZXIgbGl0ZXJhbHNcIiBpbiB0aGUgT0NhbWwgc2Vuc2UgaXNcbiAgICAgICAgIHN0aWxsIGJsYXRhbnRseSB3cm9uZywgYXMgMTIzXzQ1NiBvciAweEZGIGFyZSByZWplY3RlZC4gKilcbiAgICAgIHBhcnNlX2xpdGVyYWwgKG1pbnVzIHx8IHN5bWIgPSAnLScpIChzdHJfaW5kICsgMSlcbiAgICB8ICcqJyAtPlxuICAgICAgcGFyc2VfYWZ0ZXJfcHJlY2lzaW9uIHBjdF9pbmQgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZVxuICAgICAgICBpZ24gcGFkIEFyZ19wcmVjaXNpb25cbiAgICB8IF8gLT5cbiAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuXG4gICAgICAgICgqIG5vdGUgdGhhdCBsZWdhY3kgaW1wbGVtZW50YXRpb24gZGlkIG5vdCBpZ25vcmUgJy4nIHdpdGhvdXRcbiAgICAgICAgICAgYSBudW1iZXIgKGFzIGl0IGRvZXMgZm9yIHBhZGRpbmcgaW5kaWNhdGlvbnMpLCBidXRcbiAgICAgICAgICAgaW50ZXJwcmV0cyBpdCBhcyAnLjAnICopXG4gICAgICAgIHBhcnNlX2FmdGVyX3ByZWNpc2lvbiBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2UgaWduXG4gICAgICAgICAgcGFkIChMaXRfcHJlY2lzaW9uIDApXG4gICAgICBlbHNlXG4gICAgICAgIGludmFsaWRfZm9ybWF0X3dpdGhvdXQgKHN0cl9pbmQgLSAxKSAnLicgXCJwcmVjaXNpb25cIlxuXG4gICgqIFRyeSB0byByZWFkIHRoZSBjb252ZXJzaW9uLiAqKVxuICBhbmQgcGFyc2VfYWZ0ZXJfcHJlY2lzaW9uIDogdHlwZSB4IHkgeiB0IGUgZiAuXG4gICAgICBpbnQgLT4gaW50IC0+IGludCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT5cbiAgICAgICAgKHgsIHkpIHBhZGRpbmcgLT4gKHosIHQpIHByZWNpc2lvbiAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2UgaWduIHBhZCBwcmVjIC0+XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICBsZXQgcGFyc2VfY29udiAodHlwZSB1KSAodHlwZSB2KSAocGFkcHJlYyA6ICh1LCB2KSBwYWRkaW5nKSA9XG4gICAgICBwYXJzZV9jb252ZXJzaW9uIHBjdF9pbmQgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIHBsdXMgaGFzaCBzcGFjZSBpZ24gcGFkXG4gICAgICAgIHByZWMgcGFkcHJlYyBzdHIuW3N0cl9pbmRdIGluXG4gICAgKCogaW4gbGVnYWN5IG1vZGUsIHNvbWUgZm9ybWF0cyAoJXMgYW5kICVTKSBhY2NlcHQgYSB3ZWlyZCBtaXggb2ZcbiAgICAgICBwYWRkaW5nIGFuZCBwcmVjaXNpb24sIHdoaWNoIGlzIG1lcmdlZCBhcyBhIHNpbmdsZSBwYWRkaW5nXG4gICAgICAgaW5mb3JtYXRpb24uIEZvciBleGFtcGxlLCBpbiAlLjEwcyB0aGUgcHJlY2lzaW9uIGlzIGltcGxpY2l0bHlcbiAgICAgICB1bmRlcnN0b29kIGFzIHBhZGRpbmcgJTEwcywgYnV0IHRoZSBsZWZ0LXBhZGRpbmcgY29tcG9uZW50IG1heVxuICAgICAgIGJlIHNwZWNpZmllZCBlaXRoZXIgYXMgYSBsZWZ0IHBhZGRpbmcgb3IgYSBuZWdhdGl2ZSBwcmVjaXNpb246XG4gICAgICAgJS0uM3MgYW5kICUuLTNzIGFyZSBlcXVpdmFsZW50IHRvICUtM3MgKilcbiAgICBtYXRjaCBwYWQgd2l0aFxuICAgIHwgTm9fcGFkZGluZyAtPiAoXG4gICAgICBtYXRjaCBtaW51cywgcHJlYyB3aXRoXG4gICAgICAgIHwgXywgTm9fcHJlY2lzaW9uIC0+IHBhcnNlX2NvbnYgTm9fcGFkZGluZ1xuICAgICAgICB8IGZhbHNlLCBMaXRfcHJlY2lzaW9uIG4gLT4gcGFyc2VfY29udiAoTGl0X3BhZGRpbmcgKFJpZ2h0LCBuKSlcbiAgICAgICAgfCB0cnVlLCBMaXRfcHJlY2lzaW9uIG4gLT4gcGFyc2VfY29udiAoTGl0X3BhZGRpbmcgKExlZnQsIG4pKVxuICAgICAgICB8IGZhbHNlLCBBcmdfcHJlY2lzaW9uIC0+IHBhcnNlX2NvbnYgKEFyZ19wYWRkaW5nIFJpZ2h0KVxuICAgICAgICB8IHRydWUsIEFyZ19wcmVjaXNpb24gLT4gcGFyc2VfY29udiAoQXJnX3BhZGRpbmcgTGVmdClcbiAgICApXG4gICAgfCBwYWQgLT4gcGFyc2VfY29udiBwYWRcblxuICAoKiBDYXNlIGFuYWx5c2lzIG9uIGNvbnZlcnNpb24uICopXG4gIGFuZCBwYXJzZV9jb252ZXJzaW9uIDogdHlwZSB4IHkgeiB0IHUgdiBlIGYgLlxuICAgICAgaW50IC0+IGludCAtPiBpbnQgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiAoeCwgeSkgcGFkZGluZyAtPlxuICAgICAgICAoeiwgdCkgcHJlY2lzaW9uIC0+ICh1LCB2KSBwYWRkaW5nIC0+IGNoYXIgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgcGx1cyBoYXNoIHNwYWNlIGlnbiBwYWQgcHJlYyBwYWRwcmVjIHN5bWIgLT5cbiAgICAoKiBGbGFncyB1c2VkIHRvIGNoZWNrIG9wdGlvbiB1c2FnZXMvY29tcGF0aWJpbGl0aWVzLiAqKVxuICAgIGxldCBwbHVzX3VzZWQgID0gcmVmIGZhbHNlIGFuZCBoYXNoX3VzZWQgPSByZWYgZmFsc2VcbiAgICBhbmQgc3BhY2VfdXNlZCA9IHJlZiBmYWxzZSBhbmQgaWduX3VzZWQgICA9IHJlZiBmYWxzZVxuICAgIGFuZCBwYWRfdXNlZCAgID0gcmVmIGZhbHNlIGFuZCBwcmVjX3VzZWQgID0gcmVmIGZhbHNlIGluXG5cbiAgICAoKiBBY2Nlc3MgdG8gb3B0aW9ucywgdXBkYXRlIGZsYWdzLiAqKVxuICAgIGxldCBnZXRfcGx1cyAgICAoKSA9IHBsdXNfdXNlZCAgOj0gdHJ1ZTsgcGx1c1xuICAgIGFuZCBnZXRfaGFzaCAgICgpID0gaGFzaF91c2VkIDo9IHRydWU7IGhhc2hcbiAgICBhbmQgZ2V0X3NwYWNlICAgKCkgPSBzcGFjZV91c2VkIDo9IHRydWU7IHNwYWNlXG4gICAgYW5kIGdldF9pZ24gICAgICgpID0gaWduX3VzZWQgICA6PSB0cnVlOyBpZ25cbiAgICBhbmQgZ2V0X3BhZCAgICAgKCkgPSBwYWRfdXNlZCAgIDo9IHRydWU7IHBhZFxuICAgIGFuZCBnZXRfcHJlYyAgICAoKSA9IHByZWNfdXNlZCAgOj0gdHJ1ZTsgcHJlY1xuICAgIGFuZCBnZXRfcGFkcHJlYyAoKSA9IHBhZF91c2VkICAgOj0gdHJ1ZTsgcGFkcHJlYyBpblxuXG4gICAgbGV0IGdldF9pbnRfcGFkICgpIDogKHgseSkgcGFkZGluZyA9XG4gICAgICAoKiAlNS4zZCBpcyBhY2NlcHRlZCBhbmQgbWVhbmluZ2Z1bDogcGFkIHRvIGxlbmd0aCA1IHdpdGhcbiAgICAgICAgIHNwYWNlcywgYnV0IGZpcnN0IHBhZCB3aXRoIHplcm9zIHVwdG8gbGVuZ3RoIDMgKDAtcGFkZGluZ1xuICAgICAgICAgaXMgdGhlIGludGVycHJldGF0aW9uIG9mIFwicHJlY2lzaW9uXCIgZm9yIGludGVnZXIgZm9ybWF0cykuXG5cbiAgICAgICAgICUwNS4zZCBpcyByZWR1bmRhbnQ6IHBhZCB0byBsZW5ndGggNSAqd2l0aCB6ZXJvcyosIGJ1dFxuICAgICAgICAgZmlyc3QgcGFkIHdpdGggemVyb3MuLi4gVG8gYWRkIGluc3VsdCB0byB0aGUgaW5qdXJ5LCB0aGVcbiAgICAgICAgIGxlZ2FjeSBpbXBsZW1lbnRhdGlvbiBpZ25vcmVzIHRoZSAwLXBhZGRpbmcgaW5kaWNhdGlvbiBhbmRcbiAgICAgICAgIGRvZXMgdGhlIDUgcGFkZGluZyB3aXRoIHNwYWNlcyBpbnN0ZWFkLiBXZSByZXVzZSB0aGlzXG4gICAgICAgICBpbnRlcnByZXRhdGlvbiBmb3IgY29tcGF0aWJpbGl0eSwgYnV0IHN0YXRpY2FsbHkgcmVqZWN0IHRoaXNcbiAgICAgICAgIGZvcm1hdCB3aGVuIHRoZSBsZWdhY3kgbW9kZSBpcyBkaXNhYmxlZCwgdG8gcHJvdGVjdCBzdHJpY3RcbiAgICAgICAgIHVzZXJzIGZyb20gdGhpcyBjb3JuZXIgY2FzZS4gKilcbiAgICAgICBtYXRjaCBnZXRfcGFkICgpLCBnZXRfcHJlYyAoKSB3aXRoXG4gICAgICAgICB8IHBhZCwgTm9fcHJlY2lzaW9uIC0+IHBhZFxuICAgICAgICAgfCBOb19wYWRkaW5nLCBfICAgICAtPiBOb19wYWRkaW5nXG4gICAgICAgICB8IExpdF9wYWRkaW5nIChaZXJvcywgbiksIF8gLT5cbiAgICAgICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW4gTGl0X3BhZGRpbmcgKFJpZ2h0LCBuKVxuICAgICAgICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCAnMCcgXCJwcmVjaXNpb25cIlxuICAgICAgICAgfCBBcmdfcGFkZGluZyBaZXJvcywgXyAtPlxuICAgICAgICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiBBcmdfcGFkZGluZyBSaWdodFxuICAgICAgICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCAnMCcgXCJwcmVjaXNpb25cIlxuICAgICAgICAgfCBMaXRfcGFkZGluZyBfIGFzIHBhZCwgXyAtPiBwYWRcbiAgICAgICAgIHwgQXJnX3BhZGRpbmcgXyBhcyBwYWQsIF8gLT4gcGFkIGluXG5cbiAgICAoKiBDaGVjayB0aGF0IHBhZHR5IDw+IFplcm9zLiAqKVxuICAgIGxldCBjaGVja19ub18wIHN5bWIgKHR5cGUgYSBiKSAocGFkIDogKGEsIGIpIHBhZGRpbmcpIDogKGEsYikgcGFkZGluZyA9XG4gICAgICBtYXRjaCBwYWQgd2l0aFxuICAgICAgfCBOb19wYWRkaW5nIC0+IHBhZFxuICAgICAgfCBMaXRfcGFkZGluZyAoKExlZnQgfCBSaWdodCksIF8pIC0+IHBhZFxuICAgICAgfCBBcmdfcGFkZGluZyAoTGVmdCB8IFJpZ2h0KSAtPiBwYWRcbiAgICAgIHwgTGl0X3BhZGRpbmcgKFplcm9zLCB3aWR0aCkgLT5cbiAgICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW4gTGl0X3BhZGRpbmcgKFJpZ2h0LCB3aWR0aClcbiAgICAgICAgZWxzZSBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgc3ltYiBcIjBcIlxuICAgICAgfCBBcmdfcGFkZGluZyBaZXJvcyAtPlxuICAgICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiBBcmdfcGFkZGluZyBSaWdodFxuICAgICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiMFwiXG4gICAgaW5cblxuICAgICgqIEdldCBwYWRkaW5nIGFzIGEgcGFkX29wdGlvbiAoc2VlIFwiJV9cIiwgXCIle1wiLCBcIiUoXCIgYW5kIFwiJVtcIikuXG4gICAgICAgKG5vIG5lZWQgZm9yIGxlZ2FjeSBtb2RlIHR3ZWFraW5nLCB0aG9zZSB3ZXJlIHJlamVjdGVkIGJ5IHRoZVxuICAgICAgIGxlZ2FjeSBwYXJzZXIgYXMgd2VsbCkgKilcbiAgICBsZXQgb3B0X29mX3BhZCBjICh0eXBlIGEpICh0eXBlIGIpIChwYWQgOiAoYSwgYikgcGFkZGluZykgPSBtYXRjaCBwYWQgd2l0aFxuICAgICAgfCBOb19wYWRkaW5nIC0+IE5vbmVcbiAgICAgIHwgTGl0X3BhZGRpbmcgKFJpZ2h0LCB3aWR0aCkgLT4gU29tZSB3aWR0aFxuICAgICAgfCBMaXRfcGFkZGluZyAoWmVyb3MsIHdpZHRoKSAtPlxuICAgICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiBTb21lIHdpZHRoXG4gICAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIGMgXCInMCdcIlxuICAgICAgfCBMaXRfcGFkZGluZyAoTGVmdCwgd2lkdGgpIC0+XG4gICAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuIFNvbWUgd2lkdGhcbiAgICAgICAgZWxzZSBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgYyBcIictJ1wiXG4gICAgICB8IEFyZ19wYWRkaW5nIF8gLT4gaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIGMgXCInKidcIlxuICAgIGluXG4gICAgbGV0IGdldF9wYWRfb3B0IGMgPSBvcHRfb2ZfcGFkIGMgKGdldF9wYWQgKCkpIGluXG4gICAgbGV0IGdldF9wYWRwcmVjX29wdCBjID0gb3B0X29mX3BhZCBjIChnZXRfcGFkcHJlYyAoKSkgaW5cblxuICAgICgqIEdldCBwcmVjaXNpb24gYXMgYSBwcmVjX29wdGlvbiAoc2VlIFwiJV9mXCIpLlxuICAgICAgIChubyBuZWVkIGZvciBsZWdhY3kgbW9kZSB0d2Vha2luZywgdGhvc2Ugd2VyZSByZWplY3RlZCBieSB0aGVcbiAgICAgICBsZWdhY3kgcGFyc2VyIGFzIHdlbGwpICopXG4gICAgbGV0IGdldF9wcmVjX29wdCAoKSA9IG1hdGNoIGdldF9wcmVjICgpIHdpdGhcbiAgICAgIHwgTm9fcHJlY2lzaW9uICAgICAgIC0+IE5vbmVcbiAgICAgIHwgTGl0X3ByZWNpc2lvbiBuZGVjIC0+IFNvbWUgbmRlY1xuICAgICAgfCBBcmdfcHJlY2lzaW9uICAgICAgLT4gaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kICdfJyBcIicqJ1wiXG4gICAgaW5cblxuICAgIGxldCBmbXRfcmVzdWx0ID0gbWF0Y2ggc3ltYiB3aXRoXG4gICAgfCAnLCcgLT5cbiAgICAgIHBhcnNlIHN0cl9pbmQgZW5kX2luZFxuICAgIHwgJ2MnIC0+XG4gICAgICBsZXQgY2hhcl9mb3JtYXQgZm10X3Jlc3QgPSAoKiAlYyAqKVxuICAgICAgICBpZiBnZXRfaWduICgpXG4gICAgICAgIHRoZW4gRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoSWdub3JlZF9jaGFyLCBmbXRfcmVzdCkpXG4gICAgICAgIGVsc2UgRm10X0VCQiAoQ2hhciBmbXRfcmVzdClcbiAgICAgIGluXG4gICAgICBsZXQgc2Nhbl9mb3JtYXQgZm10X3Jlc3QgPSAoKiAlMGMgKilcbiAgICAgICAgaWYgZ2V0X2lnbiAoKVxuICAgICAgICB0aGVuIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKElnbm9yZWRfc2Nhbl9uZXh0X2NoYXIsIGZtdF9yZXN0KSlcbiAgICAgICAgZWxzZSBGbXRfRUJCIChTY2FuX25leHRfY2hhciBmbXRfcmVzdClcbiAgICAgIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgYmVnaW4gbWF0Y2ggZ2V0X3BhZF9vcHQgJ2MnIHdpdGhcbiAgICAgICAgfCBOb25lIC0+IGNoYXJfZm9ybWF0IGZtdF9yZXN0XG4gICAgICAgIHwgU29tZSAwIC0+IHNjYW5fZm9ybWF0IGZtdF9yZXN0XG4gICAgICAgIHwgU29tZSBfbiAtPlxuICAgICAgICAgICBpZiBub3QgbGVnYWN5X2JlaGF2aW9yXG4gICAgICAgICAgIHRoZW4gaW52YWxpZF9ub25udWxsX2NoYXJfd2lkdGggc3RyX2luZFxuICAgICAgICAgICBlbHNlICgqIGxlZ2FjeSBpZ25vcmVzICVjIHdpZHRocyAqKSBjaGFyX2Zvcm1hdCBmbXRfcmVzdFxuICAgICAgZW5kXG4gICAgfCAnQycgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW4gRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoSWdub3JlZF9jYW1sX2NoYXIsZm10X3Jlc3QpKVxuICAgICAgZWxzZSBGbXRfRUJCIChDYW1sX2NoYXIgZm10X3Jlc3QpXG4gICAgfCAncycgLT5cbiAgICAgIGxldCBwYWQgPSBjaGVja19ub18wIHN5bWIgKGdldF9wYWRwcmVjICgpKSBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfc3RyaW5nIChnZXRfcGFkcHJlY19vcHQgJ18nKSBpblxuICAgICAgICBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChpZ25vcmVkLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlXG4gICAgICAgIGxldCBQYWRkaW5nX2ZtdF9FQkIgKHBhZCcsIGZtdF9yZXN0JykgPVxuICAgICAgICAgIG1ha2VfcGFkZGluZ19mbXRfZWJiIHBhZCBmbXRfcmVzdCBpblxuICAgICAgICBGbXRfRUJCIChTdHJpbmcgKHBhZCcsIGZtdF9yZXN0JykpXG4gICAgfCAnUycgLT5cbiAgICAgIGxldCBwYWQgPSBjaGVja19ub18wIHN5bWIgKGdldF9wYWRwcmVjICgpKSBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfY2FtbF9zdHJpbmcgKGdldF9wYWRwcmVjX29wdCAnXycpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IFBhZGRpbmdfZm10X0VCQiAocGFkJywgZm10X3Jlc3QnKSA9XG4gICAgICAgICAgbWFrZV9wYWRkaW5nX2ZtdF9lYmIgcGFkIGZtdF9yZXN0IGluXG4gICAgICAgIEZtdF9FQkIgKENhbWxfc3RyaW5nIChwYWQnLCBmbXRfcmVzdCcpKVxuICAgIHwgJ2QnIHwgJ2knIHwgJ3gnIHwgJ1gnIHwgJ28nIHwgJ3UnIC0+XG4gICAgICBsZXQgaWNvbnYgPSBjb21wdXRlX2ludF9jb252IHBjdF9pbmQgc3RyX2luZCAoZ2V0X3BsdXMgKCkpIChnZXRfaGFzaCAoKSlcbiAgICAgICAgKGdldF9zcGFjZSAoKSkgc3ltYiBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfaW50IChpY29udiwgZ2V0X3BhZF9vcHQgJ18nKSBpblxuICAgICAgICBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChpZ25vcmVkLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlXG4gICAgICAgIGxldCBQYWRwcmVjX2ZtdF9FQkIgKHBhZCcsIHByZWMnLCBmbXRfcmVzdCcpID1cbiAgICAgICAgICBtYWtlX3BhZHByZWNfZm10X2ViYiAoZ2V0X2ludF9wYWQgKCkpIChnZXRfcHJlYyAoKSkgZm10X3Jlc3QgaW5cbiAgICAgICAgRm10X0VCQiAoSW50IChpY29udiwgcGFkJywgcHJlYycsIGZtdF9yZXN0JykpXG4gICAgfCAnTicgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBsZXQgY291bnRlciA9IFRva2VuX2NvdW50ZXIgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfc2Nhbl9nZXRfY291bnRlciBjb3VudGVyIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgRm10X0VCQiAoU2Nhbl9nZXRfY291bnRlciAoY291bnRlciwgZm10X3Jlc3QpKVxuICAgIHwgJ2wnIHwgJ24nIHwgJ0wnIHdoZW4gc3RyX2luZD1lbmRfaW5kIHx8IG5vdCAoaXNfaW50X2Jhc2Ugc3RyLltzdHJfaW5kXSkgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBsZXQgY291bnRlciA9IGNvdW50ZXJfb2ZfY2hhciBzeW1iIGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBJZ25vcmVkX3NjYW5fZ2V0X2NvdW50ZXIgY291bnRlciBpblxuICAgICAgICBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChpZ25vcmVkLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlXG4gICAgICAgIEZtdF9FQkIgKFNjYW5fZ2V0X2NvdW50ZXIgKGNvdW50ZXIsIGZtdF9yZXN0KSlcbiAgICB8ICdsJyAtPlxuICAgICAgbGV0IGljb252ID1cbiAgICAgICAgY29tcHV0ZV9pbnRfY29udiBwY3RfaW5kIChzdHJfaW5kICsgMSkgKGdldF9wbHVzICgpKSAoZ2V0X2hhc2ggKCkpXG4gICAgICAgICAgKGdldF9zcGFjZSAoKSkgc3RyLltzdHJfaW5kXSBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfaW50MzIgKGljb252LCBnZXRfcGFkX29wdCAnXycpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IFBhZHByZWNfZm10X0VCQiAocGFkJywgcHJlYycsIGZtdF9yZXN0JykgPVxuICAgICAgICAgIG1ha2VfcGFkcHJlY19mbXRfZWJiIChnZXRfaW50X3BhZCAoKSkgKGdldF9wcmVjICgpKSBmbXRfcmVzdCBpblxuICAgICAgICBGbXRfRUJCIChJbnQzMiAoaWNvbnYsIHBhZCcsIHByZWMnLCBmbXRfcmVzdCcpKVxuICAgIHwgJ24nIC0+XG4gICAgICBsZXQgaWNvbnYgPVxuICAgICAgICBjb21wdXRlX2ludF9jb252IHBjdF9pbmQgKHN0cl9pbmQgKyAxKSAoZ2V0X3BsdXMgKCkpXG4gICAgICAgICAgKGdldF9oYXNoICgpKSAoZ2V0X3NwYWNlICgpKSBzdHIuW3N0cl9pbmRdIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9uYXRpdmVpbnQgKGljb252LCBnZXRfcGFkX29wdCAnXycpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IFBhZHByZWNfZm10X0VCQiAocGFkJywgcHJlYycsIGZtdF9yZXN0JykgPVxuICAgICAgICAgIG1ha2VfcGFkcHJlY19mbXRfZWJiIChnZXRfaW50X3BhZCAoKSkgKGdldF9wcmVjICgpKSBmbXRfcmVzdCBpblxuICAgICAgICBGbXRfRUJCIChOYXRpdmVpbnQgKGljb252LCBwYWQnLCBwcmVjJywgZm10X3Jlc3QnKSlcbiAgICB8ICdMJyAtPlxuICAgICAgbGV0IGljb252ID1cbiAgICAgICAgY29tcHV0ZV9pbnRfY29udiBwY3RfaW5kIChzdHJfaW5kICsgMSkgKGdldF9wbHVzICgpKSAoZ2V0X2hhc2ggKCkpXG4gICAgICAgICAgKGdldF9zcGFjZSAoKSkgc3RyLltzdHJfaW5kXSBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfaW50NjQgKGljb252LCBnZXRfcGFkX29wdCAnXycpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IFBhZHByZWNfZm10X0VCQiAocGFkJywgcHJlYycsIGZtdF9yZXN0JykgPVxuICAgICAgICAgIG1ha2VfcGFkcHJlY19mbXRfZWJiIChnZXRfaW50X3BhZCAoKSkgKGdldF9wcmVjICgpKSBmbXRfcmVzdCBpblxuICAgICAgICBGbXRfRUJCIChJbnQ2NCAoaWNvbnYsIHBhZCcsIHByZWMnLCBmbXRfcmVzdCcpKVxuICAgIHwgJ2YnIHwgJ2UnIHwgJ0UnIHwgJ2cnIHwgJ0cnIHwgJ0YnIHwgJ2gnIHwgJ0gnIC0+XG4gICAgICBsZXQgZmNvbnYgPVxuICAgICAgICBjb21wdXRlX2Zsb2F0X2NvbnYgcGN0X2luZCBzdHJfaW5kXG4gICAgICAgICAgKGdldF9wbHVzICgpKSAoZ2V0X2hhc2ggKCkpIChnZXRfc3BhY2UgKCkpIHN5bWIgaW5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBJZ25vcmVkX2Zsb2F0IChnZXRfcGFkX29wdCAnXycsIGdldF9wcmVjX29wdCAoKSkgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBsZXQgUGFkcHJlY19mbXRfRUJCIChwYWQnLCBwcmVjJywgZm10X3Jlc3QnKSA9XG4gICAgICAgICAgbWFrZV9wYWRwcmVjX2ZtdF9lYmIgKGdldF9wYWQgKCkpIChnZXRfcHJlYyAoKSkgZm10X3Jlc3QgaW5cbiAgICAgICAgRm10X0VCQiAoRmxvYXQgKGZjb252LCBwYWQnLCBwcmVjJywgZm10X3Jlc3QnKSlcbiAgICB8ICdiJyB8ICdCJyAtPlxuICAgICAgbGV0IHBhZCA9IGNoZWNrX25vXzAgc3ltYiAoZ2V0X3BhZHByZWMgKCkpIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9ib29sIChnZXRfcGFkcHJlY19vcHQgJ18nKSBpblxuICAgICAgICBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChpZ25vcmVkLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlXG4gICAgICAgIGxldCBQYWRkaW5nX2ZtdF9FQkIgKHBhZCcsIGZtdF9yZXN0JykgPVxuICAgICAgICAgIG1ha2VfcGFkZGluZ19mbXRfZWJiIHBhZCBmbXRfcmVzdCBpblxuICAgICAgICBGbXRfRUJCIChCb29sIChwYWQnLCBmbXRfcmVzdCcpKVxuICAgIHwgJ2EnIC0+XG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgRm10X0VCQiAoQWxwaGEgZm10X3Jlc3QpXG4gICAgfCAndCcgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBGbXRfRUJCIChUaGV0YSBmbXRfcmVzdClcbiAgICB8ICdyJyAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlbiBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChJZ25vcmVkX3JlYWRlciwgZm10X3Jlc3QpKVxuICAgICAgZWxzZSBGbXRfRUJCIChSZWFkZXIgZm10X3Jlc3QpXG4gICAgfCAnIScgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBGbXRfRUJCIChGbHVzaCBmbXRfcmVzdClcbiAgICB8ICgnJScgfCAnQCcpIGFzIGMgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBGbXRfRUJCIChDaGFyX2xpdGVyYWwgKGMsIGZtdF9yZXN0KSlcbiAgICB8ICd7JyAtPlxuICAgICAgbGV0IHN1Yl9lbmQgPSBzZWFyY2hfc3ViZm9ybWF0X2VuZCBzdHJfaW5kIGVuZF9pbmQgJ30nIGluXG4gICAgICBsZXQgRm10X0VCQiBzdWJfZm10ID0gcGFyc2Ugc3RyX2luZCBzdWJfZW5kIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdWJfZW5kICsgMikgZW5kX2luZCBpblxuICAgICAgbGV0IHN1Yl9mbXR0eSA9IGZtdHR5X29mX2ZtdCBzdWJfZm10IGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBJZ25vcmVkX2Zvcm1hdF9hcmcgKGdldF9wYWRfb3B0ICdfJywgc3ViX2ZtdHR5KSBpblxuICAgICAgICBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChpZ25vcmVkLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdF9hcmcgKGdldF9wYWRfb3B0ICd7Jywgc3ViX2ZtdHR5LCBmbXRfcmVzdCkpXG4gICAgfCAnKCcgLT5cbiAgICAgIGxldCBzdWJfZW5kID0gc2VhcmNoX3N1YmZvcm1hdF9lbmQgc3RyX2luZCBlbmRfaW5kICcpJyBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3ViX2VuZCArIDIpIGVuZF9pbmQgaW5cbiAgICAgIGxldCBGbXRfRUJCIHN1Yl9mbXQgPSBwYXJzZSBzdHJfaW5kIHN1Yl9lbmQgaW5cbiAgICAgIGxldCBzdWJfZm10dHkgPSBmbXR0eV9vZl9mbXQgc3ViX2ZtdCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9mb3JtYXRfc3Vic3QgKGdldF9wYWRfb3B0ICdfJywgc3ViX2ZtdHR5KSBpblxuICAgICAgICBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChpZ25vcmVkLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdF9zdWJzdCAoZ2V0X3BhZF9vcHQgJygnLCBzdWJfZm10dHksIGZtdF9yZXN0KSlcbiAgICB8ICdbJyAtPlxuICAgICAgbGV0IG5leHRfaW5kLCBjaGFyX3NldCA9IHBhcnNlX2NoYXJfc2V0IHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBuZXh0X2luZCBlbmRfaW5kIGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBJZ25vcmVkX3NjYW5fY2hhcl9zZXQgKGdldF9wYWRfb3B0ICdfJywgY2hhcl9zZXQpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgRm10X0VCQiAoU2Nhbl9jaGFyX3NldCAoZ2V0X3BhZF9vcHQgJ1snLCBjaGFyX3NldCwgZm10X3Jlc3QpKVxuICAgIHwgJy0nIHwgJysnIHwgJyMnIHwgJyAnIHwgJ18nIC0+XG4gICAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICAgIFwiaW52YWxpZCBmb3JtYXQgJVM6IGF0IGNoYXJhY3RlciBudW1iZXIgJWQsIFxcXG4gICAgICAgICBmbGFnICVDIGlzIG9ubHkgYWxsb3dlZCBhZnRlciB0aGUgJyUlJywgYmVmb3JlIHBhZGRpbmcgYW5kIHByZWNpc2lvblwiXG4gICAgICAgIHN0ciBwY3RfaW5kIHN5bWJcbiAgICB8IF8gLT5cbiAgICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgICAgXCJpbnZhbGlkIGZvcm1hdCAlUzogYXQgY2hhcmFjdGVyIG51bWJlciAlZCwgXFxcbiAgICAgICAgIGludmFsaWQgY29udmVyc2lvbiBcXFwiJSUlY1xcXCJcIiBzdHIgKHN0cl9pbmQgLSAxKSBzeW1iXG4gICAgaW5cbiAgICAoKiBDaGVjayBmb3IgdW51c2VkIG9wdGlvbnMsIGFuZCByZWplY3QgdGhlbSBhcyBpbmNvbXBhdGlibGUuXG5cbiAgICAgICBTdWNoIGNoZWNrcyBuZWVkIHRvIGJlIGRpc2FibGVkIGluIGxlZ2FjeSBtb2RlLCBhcyB0aGUgbGVnYWN5XG4gICAgICAgcGFyc2VyIHNpbGVudGx5IGlnbm9yZWQgaW5jb21wYXRpYmxlIGZsYWdzLiAqKVxuICAgIGlmIG5vdCBsZWdhY3lfYmVoYXZpb3IgdGhlbiBiZWdpblxuICAgIGlmIG5vdCAhcGx1c191c2VkICYmIHBsdXMgdGhlblxuICAgICAgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIHN5bWIgXCInKydcIjtcbiAgICBpZiBub3QgIWhhc2hfdXNlZCAmJiBoYXNoIHRoZW5cbiAgICAgIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiJyMnXCI7XG4gICAgaWYgbm90ICFzcGFjZV91c2VkICYmIHNwYWNlIHRoZW5cbiAgICAgIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiJyAnXCI7XG4gICAgaWYgbm90ICFwYWRfdXNlZCAgJiYgUGFkZGluZ19FQkIgcGFkIDw+IFBhZGRpbmdfRUJCIE5vX3BhZGRpbmcgdGhlblxuICAgICAgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIHN5bWIgXCJgcGFkZGluZydcIjtcbiAgICBpZiBub3QgIXByZWNfdXNlZCAmJiBQcmVjaXNpb25fRUJCIHByZWMgPD4gUHJlY2lzaW9uX0VCQiBOb19wcmVjaXNpb24gdGhlblxuICAgICAgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIChpZiBpZ24gdGhlbiAnXycgZWxzZSBzeW1iKVxuICAgICAgICBcImBwcmVjaXNpb24nXCI7XG4gICAgaWYgaWduICYmIHBsdXMgdGhlbiBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgJ18nIFwiJysnXCI7XG4gICAgZW5kO1xuICAgICgqIHRoaXMgbGFzdCB0ZXN0IG11c3Qgbm90IGJlIGRpc2FibGVkIGluIGxlZ2FjeSBtb2RlLFxuICAgICAgIGFzIGlnbm9yaW5nIGl0IHdvdWxkIHR5cGljYWxseSByZXN1bHQgaW4gYSBkaWZmZXJlbnQgdHlwaW5nXG4gICAgICAgdGhhbiB3aGF0IHRoZSBsZWdhY3kgcGFyc2VyIHVzZWQgKilcbiAgICBpZiBub3QgIWlnbl91c2VkICYmIGlnbiB0aGVuXG4gICAgICBiZWdpbiBtYXRjaCBzeW1iIHdpdGhcbiAgICAgICAgKCogYXJndW1lbnQtbGVzcyBmb3JtYXRzIGNhbiBzYWZlbHkgYmUgaWdub3JlZCBpbiBsZWdhY3kgbW9kZSAqKVxuICAgICAgICB8ICgnQCcgfCAnJScgfCAnIScgfCAnLCcpIHdoZW4gbGVnYWN5X2JlaGF2aW9yIC0+ICgpXG4gICAgICAgIHwgXyAtPlxuICAgICAgICAgIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiJ18nXCJcbiAgICAgIGVuZDtcbiAgICBmbXRfcmVzdWx0XG5cbiAgKCogUGFyc2UgZm9ybWF0dGluZyBpbmZvcm1hdGlvbiAoYWZ0ZXIgJ0AnKS4gKilcbiAgYW5kIHBhcnNlX2FmdGVyX2F0IDogdHlwZSBlIGYgLiBpbnQgLT4gaW50IC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIHN0cl9pbmQgZW5kX2luZCAtPlxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gRm10X0VCQiAoQ2hhcl9saXRlcmFsICgnQCcsIEVuZF9vZl9mb3JtYXQpKVxuICAgIGVsc2VcbiAgICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgICAgfCAnWycgLT5cbiAgICAgICAgcGFyc2VfdGFnIGZhbHNlIChzdHJfaW5kICsgMSkgZW5kX2luZFxuICAgICAgfCAnXScgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKENsb3NlX2JveCwgZm10X3Jlc3QpKVxuICAgICAgfCAneycgLT5cbiAgICAgICAgcGFyc2VfdGFnIHRydWUgKHN0cl9pbmQgKyAxKSBlbmRfaW5kXG4gICAgICB8ICd9JyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoQ2xvc2VfdGFnLCBmbXRfcmVzdCkpXG4gICAgICB8ICcsJyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoQnJlYWsgKFwiQCxcIiwgMCwgMCksIGZtdF9yZXN0KSlcbiAgICAgIHwgJyAnIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChCcmVhayAoXCJAIFwiLCAxLCAwKSwgZm10X3Jlc3QpKVxuICAgICAgfCAnOycgLT5cbiAgICAgICAgcGFyc2VfZ29vZF9icmVhayAoc3RyX2luZCArIDEpIGVuZF9pbmRcbiAgICAgIHwgJz8nIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChGRmx1c2gsIGZtdF9yZXN0KSlcbiAgICAgIHwgJ1xcbicgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKEZvcmNlX25ld2xpbmUsIGZtdF9yZXN0KSlcbiAgICAgIHwgJy4nIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChGbHVzaF9uZXdsaW5lLCBmbXRfcmVzdCkpXG4gICAgICB8ICc8JyAtPlxuICAgICAgICBwYXJzZV9tYWdpY19zaXplIChzdHJfaW5kICsgMSkgZW5kX2luZFxuICAgICAgfCAnQCcgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKEVzY2FwZWRfYXQsIGZtdF9yZXN0KSlcbiAgICAgIHwgJyUnIHdoZW4gc3RyX2luZCArIDEgPCBlbmRfaW5kICYmIHN0ci5bc3RyX2luZCArIDFdID0gJyUnIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAyKSBlbmRfaW5kIGluXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChFc2NhcGVkX3BlcmNlbnQsIGZtdF9yZXN0KSlcbiAgICAgIHwgJyUnIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICAgIEZtdF9FQkIgKENoYXJfbGl0ZXJhbCAoJ0AnLCBmbXRfcmVzdCkpXG4gICAgICB8IGMgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKFNjYW5faW5kaWMgYywgZm10X3Jlc3QpKVxuXG4gICgqIFRyeSB0byByZWFkIHRoZSBvcHRpb25hbCA8bmFtZT4gYWZ0ZXIgXCJAe1wiIG9yIFwiQFtcIi4gKilcbiAgYW5kIHBhcnNlX3RhZyA6IHR5cGUgZSBmIC4gYm9vbCAtPiBpbnQgLT4gaW50IC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIGlzX29wZW5fdGFnIHN0cl9pbmQgZW5kX2luZCAtPlxuICAgIHRyeVxuICAgICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiByYWlzZSBOb3RfZm91bmQ7XG4gICAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICAgIHwgJzwnIC0+XG4gICAgICAgIGxldCBpbmQgPSBTdHJpbmcuaW5kZXhfZnJvbSBzdHIgKHN0cl9pbmQgKyAxKSAnPicgaW5cbiAgICAgICAgaWYgaW5kID49IGVuZF9pbmQgdGhlbiByYWlzZSBOb3RfZm91bmQ7XG4gICAgICAgIGxldCBzdWJfc3RyID0gU3RyaW5nLnN1YiBzdHIgc3RyX2luZCAoaW5kIC0gc3RyX2luZCArIDEpIGluXG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKGluZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgbGV0IEZtdF9FQkIgc3ViX2ZtdCA9IHBhcnNlIHN0cl9pbmQgKGluZCArIDEpIGluXG4gICAgICAgIGxldCBzdWJfZm9ybWF0ID0gRm9ybWF0IChzdWJfZm10LCBzdWJfc3RyKSBpblxuICAgICAgICBsZXQgZm9ybWF0dGluZyA9XG4gICAgICAgICAgaWYgaXNfb3Blbl90YWcgdGhlbiBPcGVuX3RhZyBzdWJfZm9ybWF0IGVsc2UgT3Blbl9ib3ggc3ViX2Zvcm1hdCBpblxuICAgICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2dlbiAoZm9ybWF0dGluZywgZm10X3Jlc3QpKVxuICAgICAgfCBfIC0+XG4gICAgICAgIHJhaXNlIE5vdF9mb3VuZFxuICAgIHdpdGggTm90X2ZvdW5kIC0+XG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgbGV0IHN1Yl9mb3JtYXQgPSBGb3JtYXQgKEVuZF9vZl9mb3JtYXQsIFwiXCIpIGluXG4gICAgICBsZXQgZm9ybWF0dGluZyA9XG4gICAgICAgIGlmIGlzX29wZW5fdGFnIHRoZW4gT3Blbl90YWcgc3ViX2Zvcm1hdCBlbHNlIE9wZW5fYm94IHN1Yl9mb3JtYXQgaW5cbiAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfZ2VuIChmb3JtYXR0aW5nLCBmbXRfcmVzdCkpXG5cbiAgKCogVHJ5IHRvIHJlYWQgdGhlIG9wdGlvbmFsIDx3aWR0aCBvZmZzZXQ+IGFmdGVyIFwiQDtcIi4gKilcbiAgYW5kIHBhcnNlX2dvb2RfYnJlYWsgOiB0eXBlIGUgZiAuIGludCAtPiBpbnQgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gc3RyX2luZCBlbmRfaW5kIC0+XG4gICAgbGV0IG5leHRfaW5kLCBmb3JtYXR0aW5nX2xpdCA9XG4gICAgICB0cnlcbiAgICAgICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgfHwgc3RyLltzdHJfaW5kXSA8PiAnPCcgdGhlbiByYWlzZSBOb3RfZm91bmQ7XG4gICAgICAgIGxldCBzdHJfaW5kXzEgPSBwYXJzZV9zcGFjZXMgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICAgIG1hdGNoIHN0ci5bc3RyX2luZF8xXSB3aXRoXG4gICAgICAgIHwgJzAnIC4uICc5JyB8ICctJyAtPiAoXG4gICAgICAgICAgbGV0IHN0cl9pbmRfMiwgd2lkdGggPSBwYXJzZV9pbnRlZ2VyIHN0cl9pbmRfMSBlbmRfaW5kIGluXG4gICAgICAgICAgICBsZXQgc3RyX2luZF8zID0gcGFyc2Vfc3BhY2VzIHN0cl9pbmRfMiBlbmRfaW5kIGluXG4gICAgICAgICAgICBtYXRjaCBzdHIuW3N0cl9pbmRfM10gd2l0aFxuICAgICAgICAgICAgICB8ICc+JyAtPlxuICAgICAgICAgICAgICAgIGxldCBzID0gU3RyaW5nLnN1YiBzdHIgKHN0cl9pbmQtMikgKHN0cl9pbmRfMy1zdHJfaW5kKzMpIGluXG4gICAgICAgICAgICAgICAgc3RyX2luZF8zICsgMSwgQnJlYWsgKHMsIHdpZHRoLCAwKVxuICAgICAgICAgICAgICB8ICcwJyAuLiAnOScgfCAnLScgLT5cbiAgICAgICAgICAgICAgICBsZXQgc3RyX2luZF80LCBvZmZzZXQgPSBwYXJzZV9pbnRlZ2VyIHN0cl9pbmRfMyBlbmRfaW5kIGluXG4gICAgICAgICAgICAgICAgbGV0IHN0cl9pbmRfNSA9IHBhcnNlX3NwYWNlcyBzdHJfaW5kXzQgZW5kX2luZCBpblxuICAgICAgICAgICAgICAgIGlmIHN0ci5bc3RyX2luZF81XSA8PiAnPicgdGhlbiByYWlzZSBOb3RfZm91bmQ7XG4gICAgICAgICAgICAgICAgbGV0IHMgPSBTdHJpbmcuc3ViIHN0ciAoc3RyX2luZC0yKSAoc3RyX2luZF81LXN0cl9pbmQrMykgaW5cbiAgICAgICAgICAgICAgICBzdHJfaW5kXzUgKyAxLCBCcmVhayAocywgd2lkdGgsIG9mZnNldClcbiAgICAgICAgICAgICAgfCBfIC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgICApXG4gICAgICAgIHwgXyAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgIHdpdGggTm90X2ZvdW5kIHwgRmFpbHVyZSBfIC0+XG4gICAgICAgIHN0cl9pbmQsIEJyZWFrIChcIkA7XCIsIDEsIDApXG4gICAgaW5cbiAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIG5leHRfaW5kIGVuZF9pbmQgaW5cbiAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoZm9ybWF0dGluZ19saXQsIGZtdF9yZXN0KSlcblxuICAoKiBQYXJzZSB0aGUgc2l6ZSBpbiBhIDxuPi4gKilcbiAgYW5kIHBhcnNlX21hZ2ljX3NpemUgOiB0eXBlIGUgZiAuIGludCAtPiBpbnQgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gc3RyX2luZCBlbmRfaW5kIC0+XG4gICAgbWF0Y2hcbiAgICAgIHRyeVxuICAgICAgICBsZXQgc3RyX2luZF8xID0gcGFyc2Vfc3BhY2VzIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgICBtYXRjaCBzdHIuW3N0cl9pbmRfMV0gd2l0aFxuICAgICAgICB8ICcwJyAuLiAnOScgfCAnLScgLT5cbiAgICAgICAgICBsZXQgc3RyX2luZF8yLCBzaXplID0gcGFyc2VfaW50ZWdlciBzdHJfaW5kXzEgZW5kX2luZCBpblxuICAgICAgICAgIGxldCBzdHJfaW5kXzMgPSBwYXJzZV9zcGFjZXMgc3RyX2luZF8yIGVuZF9pbmQgaW5cbiAgICAgICAgICBpZiBzdHIuW3N0cl9pbmRfM10gPD4gJz4nIHRoZW4gcmFpc2UgTm90X2ZvdW5kO1xuICAgICAgICAgIGxldCBzID0gU3RyaW5nLnN1YiBzdHIgKHN0cl9pbmQgLSAyKSAoc3RyX2luZF8zIC0gc3RyX2luZCArIDMpIGluXG4gICAgICAgICAgU29tZSAoc3RyX2luZF8zICsgMSwgTWFnaWNfc2l6ZSAocywgc2l6ZSkpXG4gICAgICAgIHwgXyAtPiBOb25lXG4gICAgICB3aXRoIE5vdF9mb3VuZCB8IEZhaWx1cmUgXyAtPlxuICAgICAgICBOb25lXG4gICAgd2l0aFxuICAgIHwgU29tZSAobmV4dF9pbmQsIGZvcm1hdHRpbmdfbGl0KSAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBuZXh0X2luZCBlbmRfaW5kIGluXG4gICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoZm9ybWF0dGluZ19saXQsIGZtdF9yZXN0KSlcbiAgICB8IE5vbmUgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoU2Nhbl9pbmRpYyAnPCcsIGZtdF9yZXN0KSlcblxuICAoKiBQYXJzZSBhbmQgY29uc3RydWN0IGEgY2hhciBzZXQuICopXG4gIGFuZCBwYXJzZV9jaGFyX3NldCBzdHJfaW5kIGVuZF9pbmQgPVxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG5cbiAgICBsZXQgY2hhcl9zZXQgPSBjcmVhdGVfY2hhcl9zZXQgKCkgaW5cbiAgICBsZXQgYWRkX2NoYXIgYyA9XG4gICAgICBhZGRfaW5fY2hhcl9zZXQgY2hhcl9zZXQgYztcbiAgICBpblxuICAgIGxldCBhZGRfcmFuZ2UgYyBjJyA9XG4gICAgICBmb3IgaSA9IGludF9vZl9jaGFyIGMgdG8gaW50X29mX2NoYXIgYycgZG9cbiAgICAgICAgYWRkX2luX2NoYXJfc2V0IGNoYXJfc2V0IChjaGFyX29mX2ludCBpKTtcbiAgICAgIGRvbmU7XG4gICAgaW5cblxuICAgIGxldCBmYWlsX3NpbmdsZV9wZXJjZW50IHN0cl9pbmQgPVxuICAgICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgICBcImludmFsaWQgZm9ybWF0ICVTOiAnJSUnIGFsb25lIGlzIG5vdCBhY2NlcHRlZCBpbiBjaGFyYWN0ZXIgc2V0cywgXFxcbiAgICAgICAgIHVzZSAlJSUlIGluc3RlYWQgYXQgcG9zaXRpb24gJWQuXCIgc3RyIHN0cl9pbmRcbiAgICBpblxuXG4gICAgKCogUGFyc2UgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBhIGNoYXIgc2V0LiAqKVxuICAgIGxldCByZWMgcGFyc2VfY2hhcl9zZXRfc3RhcnQgc3RyX2luZCBlbmRfaW5kID1cbiAgICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgICBsZXQgYyA9IHN0ci5bc3RyX2luZF0gaW5cbiAgICAgIHBhcnNlX2NoYXJfc2V0X2FmdGVyX2NoYXIgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGNcblxuICAgICgqIFBhcnNlIHRoZSBjb250ZW50IG9mIGEgY2hhciBzZXQgdW50aWwgdGhlIGZpcnN0ICddJy4gKilcbiAgICBhbmQgcGFyc2VfY2hhcl9zZXRfY29udGVudCBzdHJfaW5kIGVuZF9pbmQgPVxuICAgICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgICAgfCAnXScgLT5cbiAgICAgICAgc3RyX2luZCArIDFcbiAgICAgIHwgJy0nIC0+XG4gICAgICAgIGFkZF9jaGFyICctJztcbiAgICAgICAgcGFyc2VfY2hhcl9zZXRfY29udGVudCAoc3RyX2luZCArIDEpIGVuZF9pbmRcbiAgICAgIHwgYyAtPlxuICAgICAgICBwYXJzZV9jaGFyX3NldF9hZnRlcl9jaGFyIChzdHJfaW5kICsgMSkgZW5kX2luZCBjXG5cbiAgICAoKiBUZXN0IGZvciByYW5nZSBpbiBjaGFyIHNldC4gKilcbiAgICBhbmQgcGFyc2VfY2hhcl9zZXRfYWZ0ZXJfY2hhciBzdHJfaW5kIGVuZF9pbmQgYyA9XG4gICAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgICB8ICddJyAtPlxuICAgICAgICBhZGRfY2hhciBjO1xuICAgICAgICBzdHJfaW5kICsgMVxuICAgICAgfCAnLScgLT5cbiAgICAgICAgcGFyc2VfY2hhcl9zZXRfYWZ0ZXJfbWludXMgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGNcbiAgICAgIHwgKCclJyB8ICdAJykgYXMgYycgd2hlbiBjID0gJyUnIC0+XG4gICAgICAgIGFkZF9jaGFyIGMnO1xuICAgICAgICBwYXJzZV9jaGFyX3NldF9jb250ZW50IChzdHJfaW5kICsgMSkgZW5kX2luZFxuICAgICAgfCBjJyAtPlxuICAgICAgICBpZiBjID0gJyUnIHRoZW4gZmFpbF9zaW5nbGVfcGVyY2VudCBzdHJfaW5kO1xuICAgICAgICAoKiBub3RlIHRoYXQgJ0AnIGFsb25lIGlzIGFjY2VwdGVkLCBhcyBkb25lIGJ5IHRoZSBsZWdhY3lcbiAgICAgICAgICAgaW1wbGVtZW50YXRpb247IHRoZSBkb2N1bWVudGF0aW9uIHNwZWNpZmljYWxseSByZXF1aXJlcyAlQFxuICAgICAgICAgICBzbyB3ZSBjb3VsZCB3YXJuIG9uIHRoYXQgKilcbiAgICAgICAgYWRkX2NoYXIgYztcbiAgICAgICAgcGFyc2VfY2hhcl9zZXRfYWZ0ZXJfY2hhciAoc3RyX2luZCArIDEpIGVuZF9pbmQgYydcblxuICAgICgqIE1hbmFnZSByYW5nZSBpbiBjaGFyIHNldCAoZXhjZXB0IGlmIHRoZSAnLScgdGhlIGxhc3QgY2hhciBiZWZvcmUgJ10nKSAqKVxuICAgIGFuZCBwYXJzZV9jaGFyX3NldF9hZnRlcl9taW51cyBzdHJfaW5kIGVuZF9pbmQgYyA9XG4gICAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgICB8ICddJyAtPlxuICAgICAgICBhZGRfY2hhciBjO1xuICAgICAgICBhZGRfY2hhciAnLSc7XG4gICAgICAgIHN0cl9pbmQgKyAxXG4gICAgICB8ICclJyAtPlxuICAgICAgICBpZiBzdHJfaW5kICsgMSA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICAgICAgYmVnaW4gbWF0Y2ggc3RyLltzdHJfaW5kICsgMV0gd2l0aFxuICAgICAgICAgIHwgKCclJyB8ICdAJykgYXMgYycgLT5cbiAgICAgICAgICAgIGFkZF9yYW5nZSBjIGMnO1xuICAgICAgICAgICAgcGFyc2VfY2hhcl9zZXRfY29udGVudCAoc3RyX2luZCArIDIpIGVuZF9pbmRcbiAgICAgICAgICB8IF8gLT4gZmFpbF9zaW5nbGVfcGVyY2VudCBzdHJfaW5kXG4gICAgICAgIGVuZFxuICAgICAgfCBjJyAtPlxuICAgICAgICBhZGRfcmFuZ2UgYyBjJztcbiAgICAgICAgcGFyc2VfY2hhcl9zZXRfY29udGVudCAoc3RyX2luZCArIDEpIGVuZF9pbmRcbiAgICBpblxuICAgIGxldCBzdHJfaW5kLCByZXZlcnNlID1cbiAgICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICAgICAgfCAnXicgLT4gc3RyX2luZCArIDEsIHRydWVcbiAgICAgICAgfCBfIC0+IHN0cl9pbmQsIGZhbHNlIGluXG4gICAgbGV0IG5leHRfaW5kID0gcGFyc2VfY2hhcl9zZXRfc3RhcnQgc3RyX2luZCBlbmRfaW5kIGluXG4gICAgbGV0IGNoYXJfc2V0ID0gZnJlZXplX2NoYXJfc2V0IGNoYXJfc2V0IGluXG4gICAgbmV4dF9pbmQsIChpZiByZXZlcnNlIHRoZW4gcmV2X2NoYXJfc2V0IGNoYXJfc2V0IGVsc2UgY2hhcl9zZXQpXG5cbiAgKCogQ29uc3VtZSBhbGwgbmV4dCBzcGFjZXMsIHJhaXNlIGFuIEZhaWx1cmUgaWYgZW5kX2luZCBpcyByZWFjaGVkLiAqKVxuICBhbmQgcGFyc2Vfc3BhY2VzIHN0cl9pbmQgZW5kX2luZCA9XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICBpZiBzdHIuW3N0cl9pbmRdID0gJyAnIHRoZW4gcGFyc2Vfc3BhY2VzIChzdHJfaW5kICsgMSkgZW5kX2luZCBlbHNlIHN0cl9pbmRcblxuICAoKiBSZWFkIGEgcG9zaXRpdmUgaW50ZWdlciBmcm9tIHRoZSBzdHJpbmcsIHJhaXNlIGEgRmFpbHVyZSBpZiBlbmRfaW5kIGlzXG4gICAgIHJlYWNoZWQuICopXG4gIGFuZCBwYXJzZV9wb3NpdGl2ZSBzdHJfaW5kIGVuZF9pbmQgYWNjID1cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgIHwgJzAnIC4uICc5JyBhcyBjIC0+XG4gICAgICBsZXQgbmV3X2FjYyA9IGFjYyAqIDEwICsgKGludF9vZl9jaGFyIGMgLSBpbnRfb2ZfY2hhciAnMCcpIGluXG4gICAgICBpZiBuZXdfYWNjID4gU3lzLm1heF9zdHJpbmdfbGVuZ3RoIHRoZW5cbiAgICAgICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgICAgIFwiaW52YWxpZCBmb3JtYXQgJVM6IGludGVnZXIgJWQgaXMgZ3JlYXRlciB0aGFuIHRoZSBsaW1pdCAlZFwiXG4gICAgICAgICAgc3RyIG5ld19hY2MgU3lzLm1heF9zdHJpbmdfbGVuZ3RoXG4gICAgICBlbHNlXG4gICAgICAgIHBhcnNlX3Bvc2l0aXZlIChzdHJfaW5kICsgMSkgZW5kX2luZCBuZXdfYWNjXG4gICAgfCBfIC0+IHN0cl9pbmQsIGFjY1xuXG4gICgqIFJlYWQgYSBwb3NpdGl2ZSBvciBuZWdhdGl2ZSBpbnRlZ2VyIGZyb20gdGhlIHN0cmluZywgcmFpc2UgYSBGYWlsdXJlXG4gICAgIGlmIGVuZF9pbmQgaXMgcmVhY2hlZC4gKilcbiAgYW5kIHBhcnNlX2ludGVnZXIgc3RyX2luZCBlbmRfaW5kID1cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgIHwgJzAnIC4uICc5JyAtPiBwYXJzZV9wb3NpdGl2ZSBzdHJfaW5kIGVuZF9pbmQgMFxuICAgIHwgJy0nIC0+IChcbiAgICAgIGlmIHN0cl9pbmQgKyAxID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgbWF0Y2ggc3RyLltzdHJfaW5kICsgMV0gd2l0aFxuICAgICAgfCAnMCcgLi4gJzknIC0+XG4gICAgICAgIGxldCBuZXh0X2luZCwgbiA9IHBhcnNlX3Bvc2l0aXZlIChzdHJfaW5kICsgMSkgZW5kX2luZCAwIGluXG4gICAgICAgIG5leHRfaW5kLCAtblxuICAgICAgfCBjIC0+XG4gICAgICAgIGV4cGVjdGVkX2NoYXJhY3RlciAoc3RyX2luZCArIDEpIFwiZGlnaXRcIiBjXG4gICAgKVxuICAgIHwgXyAtPiBhc3NlcnQgZmFsc2VcblxuICAoKiBBZGQgYSBsaXRlcmFsIHRvIGEgZm9ybWF0IGZyb20gYSBsaXRlcmFsIGNoYXJhY3RlciBzdWItc2VxdWVuY2UuICopXG4gIGFuZCBhZGRfbGl0ZXJhbCA6IHR5cGUgYSBkIGUgZiAuXG4gICAgICBpbnQgLT4gaW50IC0+IChhLCBfLCBfLCBkLCBlLCBmKSBmbXQgLT5cbiAgICAgIChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIGxpdF9zdGFydCBzdHJfaW5kIGZtdCAtPiBtYXRjaCBzdHJfaW5kIC0gbGl0X3N0YXJ0IHdpdGhcbiAgICB8IDAgICAgLT4gRm10X0VCQiBmbXRcbiAgICB8IDEgICAgLT4gRm10X0VCQiAoQ2hhcl9saXRlcmFsIChzdHIuW2xpdF9zdGFydF0sIGZtdCkpXG4gICAgfCBzaXplIC0+IEZtdF9FQkIgKFN0cmluZ19saXRlcmFsIChTdHJpbmcuc3ViIHN0ciBsaXRfc3RhcnQgc2l6ZSwgZm10KSlcblxuICAoKiBTZWFyY2ggdGhlIGVuZCBvZiB0aGUgY3VycmVudCBzdWItZm9ybWF0XG4gICAgIChpLmUuIHRoZSBjb3JyZXNwb25kaW5nIFwiJX1cIiBvciBcIiUpXCIpICopXG4gIGFuZCBzZWFyY2hfc3ViZm9ybWF0X2VuZCBzdHJfaW5kIGVuZF9pbmQgYyA9XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlblxuICAgICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgICBcImludmFsaWQgZm9ybWF0ICVTOiB1bmNsb3NlZCBzdWItZm9ybWF0LCBcXFxuICAgICAgICAgZXhwZWN0ZWQgXFxcIiUlJWNcXFwiIGF0IGNoYXJhY3RlciBudW1iZXIgJWRcIiBzdHIgYyBlbmRfaW5kO1xuICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgIHwgJyUnIC0+XG4gICAgICBpZiBzdHJfaW5kICsgMSA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICAgIGlmIHN0ci5bc3RyX2luZCArIDFdID0gYyB0aGVuICgqIEVuZCBvZiBmb3JtYXQgZm91bmQgKikgc3RyX2luZCBlbHNlXG4gICAgICAgIGJlZ2luIG1hdGNoIHN0ci5bc3RyX2luZCArIDFdIHdpdGhcbiAgICAgICAgfCAnXycgLT5cbiAgICAgICAgICAoKiBTZWFyY2ggZm9yIFwiJV8oXCIgb3IgXCIlX3tcIi4gKilcbiAgICAgICAgICBpZiBzdHJfaW5kICsgMiA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICAgICAgICBiZWdpbiBtYXRjaCBzdHIuW3N0cl9pbmQgKyAyXSB3aXRoXG4gICAgICAgICAgfCAneycgLT5cbiAgICAgICAgICAgIGxldCBzdWJfZW5kID0gc2VhcmNoX3N1YmZvcm1hdF9lbmQgKHN0cl9pbmQgKyAzKSBlbmRfaW5kICd9JyBpblxuICAgICAgICAgICAgc2VhcmNoX3N1YmZvcm1hdF9lbmQgKHN1Yl9lbmQgKyAyKSBlbmRfaW5kIGNcbiAgICAgICAgICB8ICcoJyAtPlxuICAgICAgICAgICAgbGV0IHN1Yl9lbmQgPSBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3RyX2luZCArIDMpIGVuZF9pbmQgJyknIGluXG4gICAgICAgICAgICBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3ViX2VuZCArIDIpIGVuZF9pbmQgY1xuICAgICAgICAgIHwgXyAtPiBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3RyX2luZCArIDMpIGVuZF9pbmQgY1xuICAgICAgICAgIGVuZFxuICAgICAgICB8ICd7JyAtPlxuICAgICAgICAgICgqICV7Li4uJX0gc3ViLWZvcm1hdCBmb3VuZC4gKilcbiAgICAgICAgICBsZXQgc3ViX2VuZCA9IHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdHJfaW5kICsgMikgZW5kX2luZCAnfScgaW5cbiAgICAgICAgICBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3ViX2VuZCArIDIpIGVuZF9pbmQgY1xuICAgICAgICB8ICcoJyAtPlxuICAgICAgICAgICgqICUoLi4uJSkgc3ViLWZvcm1hdCBmb3VuZC4gKilcbiAgICAgICAgICBsZXQgc3ViX2VuZCA9IHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdHJfaW5kICsgMikgZW5kX2luZCAnKScgaW5cbiAgICAgICAgICBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3ViX2VuZCArIDIpIGVuZF9pbmQgY1xuICAgICAgICB8ICd9JyAtPlxuICAgICAgICAgICgqIEVycm9yOiAlKC4uLiV9LiAqKVxuICAgICAgICAgIGV4cGVjdGVkX2NoYXJhY3RlciAoc3RyX2luZCArIDEpIFwiY2hhcmFjdGVyICcpJ1wiICd9J1xuICAgICAgICB8ICcpJyAtPlxuICAgICAgICAgICgqIEVycm9yOiAley4uLiUpLiAqKVxuICAgICAgICAgIGV4cGVjdGVkX2NoYXJhY3RlciAoc3RyX2luZCArIDEpIFwiY2hhcmFjdGVyICd9J1wiICcpJ1xuICAgICAgICB8IF8gLT5cbiAgICAgICAgICBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3RyX2luZCArIDIpIGVuZF9pbmQgY1xuICAgICAgICBlbmRcbiAgICB8IF8gLT4gc2VhcmNoX3N1YmZvcm1hdF9lbmQgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGNcblxuICAoKiBDaGVjayBpZiBzeW1iIGlzIGEgdmFsaWQgaW50IGNvbnZlcnNpb24gYWZ0ZXIgXCIlbFwiLCBcIiVuXCIgb3IgXCIlTFwiICopXG4gIGFuZCBpc19pbnRfYmFzZSBzeW1iID0gbWF0Y2ggc3ltYiB3aXRoXG4gICAgfCAnZCcgfCAnaScgfCAneCcgfCAnWCcgfCAnbycgfCAndScgLT4gdHJ1ZVxuICAgIHwgXyAtPiBmYWxzZVxuXG4gICgqIENvbnZlcnQgYSBjaGFyIChsLCBuIG9yIEwpIHRvIGl0cyBhc3NvY2lhdGVkIGNvdW50ZXIuICopXG4gIGFuZCBjb3VudGVyX29mX2NoYXIgc3ltYiA9IG1hdGNoIHN5bWIgd2l0aFxuICAgIHwgJ2wnIC0+IExpbmVfY291bnRlciAgfCAnbicgLT4gQ2hhcl9jb3VudGVyXG4gICAgfCAnTCcgLT4gVG9rZW5fY291bnRlciB8IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiAgKCogQ29udmVydCAocGx1cywgc3ltYikgdG8gaXRzIGFzc29jaWF0ZWQgaW50X2NvbnYuICopXG4gIGFuZCBjb21wdXRlX2ludF9jb252IHBjdF9pbmQgc3RyX2luZCBwbHVzIGhhc2ggc3BhY2Ugc3ltYiA9XG4gICAgbWF0Y2ggcGx1cywgaGFzaCwgc3BhY2UsIHN5bWIgd2l0aFxuICAgIHwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgJ2QnIC0+IEludF9kICB8IGZhbHNlLCBmYWxzZSwgZmFsc2UsICdpJyAtPiBJbnRfaVxuICAgIHwgZmFsc2UsIGZhbHNlLCAgdHJ1ZSwgJ2QnIC0+IEludF9zZCB8IGZhbHNlLCBmYWxzZSwgIHRydWUsICdpJyAtPiBJbnRfc2lcbiAgICB8ICB0cnVlLCBmYWxzZSwgZmFsc2UsICdkJyAtPiBJbnRfcGQgfCAgdHJ1ZSwgZmFsc2UsIGZhbHNlLCAnaScgLT4gSW50X3BpXG4gICAgfCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAneCcgLT4gSW50X3ggIHwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgJ1gnIC0+IEludF9YXG4gICAgfCBmYWxzZSwgIHRydWUsIGZhbHNlLCAneCcgLT4gSW50X0N4IHwgZmFsc2UsICB0cnVlLCBmYWxzZSwgJ1gnIC0+IEludF9DWFxuICAgIHwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgJ28nIC0+IEludF9vXG4gICAgfCBmYWxzZSwgIHRydWUsIGZhbHNlLCAnbycgLT4gSW50X0NvXG4gICAgfCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAndScgLT4gSW50X3VcbiAgICB8IGZhbHNlLCAgdHJ1ZSwgZmFsc2UsICdkJyAtPiBJbnRfQ2RcbiAgICB8IGZhbHNlLCAgdHJ1ZSwgZmFsc2UsICdpJyAtPiBJbnRfQ2lcbiAgICB8IGZhbHNlLCAgdHJ1ZSwgZmFsc2UsICd1JyAtPiBJbnRfQ3VcbiAgICB8IF8sIHRydWUsIF8sICd4JyB3aGVuIGxlZ2FjeV9iZWhhdmlvciAtPiBJbnRfQ3hcbiAgICB8IF8sIHRydWUsIF8sICdYJyB3aGVuIGxlZ2FjeV9iZWhhdmlvciAtPiBJbnRfQ1hcbiAgICB8IF8sIHRydWUsIF8sICdvJyB3aGVuIGxlZ2FjeV9iZWhhdmlvciAtPiBJbnRfQ29cbiAgICB8IF8sIHRydWUsIF8sICgnZCcgfCAnaScgfCAndScpIC0+XG4gICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiAoKiBpZ25vcmUgKilcbiAgICAgICAgY29tcHV0ZV9pbnRfY29udiBwY3RfaW5kIHN0cl9pbmQgcGx1cyBmYWxzZSBzcGFjZSBzeW1iXG4gICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiJyMnXCJcbiAgICB8IHRydWUsIF8sIHRydWUsIF8gLT5cbiAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuXG4gICAgICAgICgqIHBsdXMgYW5kIHNwYWNlOiBsZWdhY3kgaW1wbGVtZW50YXRpb24gcHJlZmVycyBwbHVzICopXG4gICAgICAgIGNvbXB1dGVfaW50X2NvbnYgcGN0X2luZCBzdHJfaW5kIHBsdXMgaGFzaCBmYWxzZSBzeW1iXG4gICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCAnICcgXCInKydcIlxuICAgIHwgZmFsc2UsIF8sIHRydWUsIF8gICAgLT5cbiAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuICgqIGlnbm9yZSAqKVxuICAgICAgICBjb21wdXRlX2ludF9jb252IHBjdF9pbmQgc3RyX2luZCBwbHVzIGhhc2ggZmFsc2Ugc3ltYlxuICAgICAgZWxzZSBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgc3ltYiBcIicgJ1wiXG4gICAgfCB0cnVlLCBfLCBmYWxzZSwgXyAgICAtPlxuICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW4gKCogaWdub3JlICopXG4gICAgICAgIGNvbXB1dGVfaW50X2NvbnYgcGN0X2luZCBzdHJfaW5kIGZhbHNlIGhhc2ggc3BhY2Ugc3ltYlxuICAgICAgZWxzZSBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgc3ltYiBcIicrJ1wiXG4gICAgfCBmYWxzZSwgXywgZmFsc2UsIF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiAgKCogQ29udmVydCAocGx1cywgc3BhY2UsIHN5bWIpIHRvIGl0cyBhc3NvY2lhdGVkIGZsb2F0X2NvbnYuICopXG4gIGFuZCBjb21wdXRlX2Zsb2F0X2NvbnYgcGN0X2luZCBzdHJfaW5kIHBsdXMgaGFzaCBzcGFjZSBzeW1iID1cbiAgICBsZXQgZmxhZyA9IG1hdGNoIHBsdXMsIHNwYWNlIHdpdGhcbiAgICB8IGZhbHNlLCBmYWxzZSAtPiBGbG9hdF9mbGFnX1xuICAgIHwgZmFsc2UsICB0cnVlIC0+IEZsb2F0X2ZsYWdfc1xuICAgIHwgIHRydWUsIGZhbHNlIC0+IEZsb2F0X2ZsYWdfcFxuICAgIHwgIHRydWUsICB0cnVlIC0+XG4gICAgICAoKiBwbHVzIGFuZCBzcGFjZTogbGVnYWN5IGltcGxlbWVudGF0aW9uIHByZWZlcnMgcGx1cyAqKVxuICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW4gRmxvYXRfZmxhZ19wXG4gICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCAnICcgXCInKydcIiBpblxuICAgIGxldCBraW5kID0gbWF0Y2ggaGFzaCwgc3ltYiB3aXRoXG4gICAgfCBfLCAnZicgLT4gRmxvYXRfZlxuICAgIHwgXywgJ2UnIC0+IEZsb2F0X2VcbiAgICB8IF8sICdFJyAtPiBGbG9hdF9FXG4gICAgfCBfLCAnZycgLT4gRmxvYXRfZ1xuICAgIHwgXywgJ0cnIC0+IEZsb2F0X0dcbiAgICB8IF8sICdoJyAtPiBGbG9hdF9oXG4gICAgfCBfLCAnSCcgLT4gRmxvYXRfSFxuICAgIHwgZmFsc2UsICdGJyAtPiBGbG9hdF9GXG4gICAgfCB0cnVlLCAnRicgLT4gRmxvYXRfQ0ZcbiAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlIGluXG4gICAgZmxhZywga2luZFxuXG4gICgqIFJhaXNlIFtGYWlsdXJlXSB3aXRoIGEgZnJpZW5kbHkgZXJyb3IgbWVzc2FnZSBhYm91dCBpbmNvbXBhdGlibGUgb3B0aW9ucy4qKVxuICBhbmQgaW5jb21wYXRpYmxlX2ZsYWcgOiB0eXBlIGEgLiBpbnQgLT4gaW50IC0+IGNoYXIgLT4gc3RyaW5nIC0+IGEgPVxuICAgIGZ1biBwY3RfaW5kIHN0cl9pbmQgc3ltYiBvcHRpb24gLT5cbiAgICAgIGxldCBzdWJmbXQgPSBTdHJpbmcuc3ViIHN0ciBwY3RfaW5kIChzdHJfaW5kIC0gcGN0X2luZCkgaW5cbiAgICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgICAgXCJpbnZhbGlkIGZvcm1hdCAlUzogYXQgY2hhcmFjdGVyIG51bWJlciAlZCwgXFxcbiAgICAgICAgICVzIGlzIGluY29tcGF0aWJsZSB3aXRoICclYycgaW4gc3ViLWZvcm1hdCAlU1wiXG4gICAgICAgIHN0ciBwY3RfaW5kIG9wdGlvbiBzeW1iIHN1YmZtdFxuXG4gIGluIHBhcnNlIDAgKFN0cmluZy5sZW5ndGggc3RyKVxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgKCogR3VhcmRlZCBzdHJpbmcgdG8gZm9ybWF0IGNvbnZlcnNpb25zICopXG5cbigqIENvbnZlcnQgYSBzdHJpbmcgdG8gYSBmb3JtYXQgYWNjb3JkaW5nIHRvIGFuIGZtdHR5LiAqKVxuKCogUmFpc2UgW0ZhaWx1cmVdIHdpdGggYW4gZXJyb3IgbWVzc2FnZSBpbiBjYXNlIG9mIHR5cGUgbWlzbWF0Y2guICopXG5sZXQgZm9ybWF0X29mX3N0cmluZ19mbXR0eSBzdHIgZm10dHkgPVxuICBsZXQgRm10X0VCQiBmbXQgPSBmbXRfZWJiX29mX3N0cmluZyBzdHIgaW5cbiAgdHJ5IEZvcm1hdCAodHlwZV9mb3JtYXQgZm10IGZtdHR5LCBzdHIpXG4gIHdpdGggVHlwZV9taXNtYXRjaCAtPlxuICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgIFwiYmFkIGlucHV0OiBmb3JtYXQgdHlwZSBtaXNtYXRjaCBiZXR3ZWVuICVTIGFuZCAlU1wiXG4gICAgICBzdHIgKHN0cmluZ19vZl9mbXR0eSBmbXR0eSlcblxuKCogQ29udmVydCBhIHN0cmluZyB0byBhIGZvcm1hdCBjb21wYXRpYmxlIHdpdGggYW4gb3RoZXIgZm9ybWF0LiAqKVxuKCogUmFpc2UgW0ZhaWx1cmVdIHdpdGggYW4gZXJyb3IgbWVzc2FnZSBpbiBjYXNlIG9mIHR5cGUgbWlzbWF0Y2guICopXG5sZXQgZm9ybWF0X29mX3N0cmluZ19mb3JtYXQgc3RyIChGb3JtYXQgKGZtdCcsIHN0cicpKSA9XG4gIGxldCBGbXRfRUJCIGZtdCA9IGZtdF9lYmJfb2Zfc3RyaW5nIHN0ciBpblxuICB0cnkgRm9ybWF0ICh0eXBlX2Zvcm1hdCBmbXQgKGZtdHR5X29mX2ZtdCBmbXQnKSwgc3RyKVxuICB3aXRoIFR5cGVfbWlzbWF0Y2ggLT5cbiAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICBcImJhZCBpbnB1dDogZm9ybWF0IHR5cGUgbWlzbWF0Y2ggYmV0d2VlbiAlUyBhbmQgJVNcIiBzdHIgc3RyJ1xuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBYYXZpZXIgTGVyb3kgYW5kIFBpZXJyZSBXZWlzLCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5vcGVuIENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljc1xub3BlbiBDYW1saW50ZXJuYWxGb3JtYXRcblxubGV0IGtmcHJpbnRmIGsgbyAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIG1ha2VfcHJpbnRmIChmdW4gYWNjIC0+IG91dHB1dF9hY2MgbyBhY2M7IGsgbykgRW5kX29mX2FjYyBmbXRcbmxldCBrYnByaW50ZiBrIGIgKEZvcm1hdCAoZm10LCBfKSkgPVxuICBtYWtlX3ByaW50ZiAoZnVuIGFjYyAtPiBidWZwdXRfYWNjIGIgYWNjOyBrIGIpIEVuZF9vZl9hY2MgZm10XG5sZXQgaWtmcHJpbnRmIGsgb2MgKEZvcm1hdCAoZm10LCBfKSkgPVxuICBtYWtlX2lwcmludGYgayBvYyBmbXRcbmxldCBpa2JwcmludGYgPSBpa2ZwcmludGZcblxubGV0IGZwcmludGYgb2MgZm10ID0ga2ZwcmludGYgaWdub3JlIG9jIGZtdFxubGV0IGJwcmludGYgYiBmbXQgPSBrYnByaW50ZiBpZ25vcmUgYiBmbXRcbmxldCBpZnByaW50ZiBvYyBmbXQgPSBpa2ZwcmludGYgaWdub3JlIG9jIGZtdFxubGV0IGlicHJpbnRmIGIgZm10ID0gaWticHJpbnRmIGlnbm9yZSBiIGZtdFxubGV0IHByaW50ZiBmbXQgPSBmcHJpbnRmIHN0ZG91dCBmbXRcbmxldCBlcHJpbnRmIGZtdCA9IGZwcmludGYgc3RkZXJyIGZtdFxuXG5sZXQga3NwcmludGYgayAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIGxldCBrJyBhY2MgPVxuICAgIGxldCBidWYgPSBCdWZmZXIuY3JlYXRlIDY0IGluXG4gICAgc3RycHV0X2FjYyBidWYgYWNjO1xuICAgIGsgKEJ1ZmZlci5jb250ZW50cyBidWYpIGluXG4gIG1ha2VfcHJpbnRmIGsnIEVuZF9vZl9hY2MgZm10XG5cbmxldCBzcHJpbnRmIGZtdCA9IGtzcHJpbnRmIChmdW4gcyAtPiBzKSBmbXRcblxubGV0IGtwcmludGYgPSBrc3ByaW50ZlxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgIERhbWllbiBEb2xpZ2V6LCBwcm9qZXQgUGFyYSwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlIGtleSA9IHN0cmluZ1xudHlwZSBkb2MgPSBzdHJpbmdcbnR5cGUgdXNhZ2VfbXNnID0gc3RyaW5nXG50eXBlIGFub25fZnVuID0gKHN0cmluZyAtPiB1bml0KVxuXG50eXBlIHNwZWMgPVxuICB8IFVuaXQgb2YgKHVuaXQgLT4gdW5pdCkgICAgICgqIENhbGwgdGhlIGZ1bmN0aW9uIHdpdGggdW5pdCBhcmd1bWVudCAqKVxuICB8IEJvb2wgb2YgKGJvb2wgLT4gdW5pdCkgICAgICgqIENhbGwgdGhlIGZ1bmN0aW9uIHdpdGggYSBib29sIGFyZ3VtZW50ICopXG4gIHwgU2V0IG9mIGJvb2wgcmVmICAgICAgICAgICAgKCogU2V0IHRoZSByZWZlcmVuY2UgdG8gdHJ1ZSAqKVxuICB8IENsZWFyIG9mIGJvb2wgcmVmICAgICAgICAgICgqIFNldCB0aGUgcmVmZXJlbmNlIHRvIGZhbHNlICopXG4gIHwgU3RyaW5nIG9mIChzdHJpbmcgLT4gdW5pdCkgKCogQ2FsbCB0aGUgZnVuY3Rpb24gd2l0aCBhIHN0cmluZyBhcmd1bWVudCAqKVxuICB8IFNldF9zdHJpbmcgb2Ygc3RyaW5nIHJlZiAgICgqIFNldCB0aGUgcmVmZXJlbmNlIHRvIHRoZSBzdHJpbmcgYXJndW1lbnQgKilcbiAgfCBJbnQgb2YgKGludCAtPiB1bml0KSAgICAgICAoKiBDYWxsIHRoZSBmdW5jdGlvbiB3aXRoIGFuIGludCBhcmd1bWVudCAqKVxuICB8IFNldF9pbnQgb2YgaW50IHJlZiAgICAgICAgICgqIFNldCB0aGUgcmVmZXJlbmNlIHRvIHRoZSBpbnQgYXJndW1lbnQgKilcbiAgfCBGbG9hdCBvZiAoZmxvYXQgLT4gdW5pdCkgICAoKiBDYWxsIHRoZSBmdW5jdGlvbiB3aXRoIGEgZmxvYXQgYXJndW1lbnQgKilcbiAgfCBTZXRfZmxvYXQgb2YgZmxvYXQgcmVmICAgICAoKiBTZXQgdGhlIHJlZmVyZW5jZSB0byB0aGUgZmxvYXQgYXJndW1lbnQgKilcbiAgfCBUdXBsZSBvZiBzcGVjIGxpc3QgICAgICAgICAoKiBUYWtlIHNldmVyYWwgYXJndW1lbnRzIGFjY29yZGluZyB0byB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGVjIGxpc3QgKilcbiAgfCBTeW1ib2wgb2Ygc3RyaW5nIGxpc3QgKiAoc3RyaW5nIC0+IHVuaXQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogVGFrZSBvbmUgb2YgdGhlIHN5bWJvbHMgYXMgYXJndW1lbnQgYW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbCB0aGUgZnVuY3Rpb24gd2l0aCB0aGUgc3ltYm9sLiAqKVxuICB8IFJlc3Qgb2YgKHN0cmluZyAtPiB1bml0KSAgICgqIFN0b3AgaW50ZXJwcmV0aW5nIGtleXdvcmRzIGFuZCBjYWxsIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHdpdGggZWFjaCByZW1haW5pbmcgYXJndW1lbnQgKilcbiAgfCBSZXN0X2FsbCBvZiAoc3RyaW5nIGxpc3QgLT4gdW5pdClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBTdG9wIGludGVycHJldGluZyBrZXl3b3JkcyBhbmQgY2FsbCB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiB3aXRoIGFsbCByZW1haW5pbmcgYXJndW1lbnRzLiAqKVxuICB8IEV4cGFuZCBvZiAoc3RyaW5nIC0+IHN0cmluZyBhcnJheSkgKCogSWYgdGhlIHJlbWFpbmluZyBhcmd1bWVudHMgdG8gcHJvY2Vzc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJlIG9mIHRoZSBmb3JtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbW1wiLWZvb1wiOyBcImFyZ1wiXSBAIHJlc3RdIHdoZXJlIFwiZm9vXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzIHJlZ2lzdGVyZWQgYXMgW0V4cGFuZCBmXSwgdGhlbiB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50cyBbZiBcImFyZ1wiIEAgcmVzdF0gYXJlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzZWQuIE9ubHkgYWxsb3dlZCBpblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3BhcnNlX2FuZF9leHBhbmRfYXJndl9keW5hbWljXS4gKilcblxuZXhjZXB0aW9uIEJhZCBvZiBzdHJpbmdcbmV4Y2VwdGlvbiBIZWxwIG9mIHN0cmluZ1xuXG50eXBlIGVycm9yID1cbiAgfCBVbmtub3duIG9mIHN0cmluZ1xuICB8IFdyb25nIG9mIHN0cmluZyAqIHN0cmluZyAqIHN0cmluZyAgKCogb3B0aW9uLCBhY3R1YWwsIGV4cGVjdGVkICopXG4gIHwgTWlzc2luZyBvZiBzdHJpbmdcbiAgfCBNZXNzYWdlIG9mIHN0cmluZ1xuXG5leGNlcHRpb24gU3RvcCBvZiBlcnJvciAoKiB1c2VkIGludGVybmFsbHkgKilcblxub3BlbiBQcmludGZcblxubGV0IHJlYyBhc3NvYzMgeCBsID1cbiAgbWF0Y2ggbCB3aXRoXG4gIHwgW10gLT4gcmFpc2UgTm90X2ZvdW5kXG4gIHwgKHkxLCB5MiwgXykgOjogXyB3aGVuIHkxID0geCAtPiB5MlxuICB8IF8gOjogdCAtPiBhc3NvYzMgeCB0XG5cblxubGV0IHNwbGl0IHMgPVxuICBsZXQgaSA9IFN0cmluZy5pbmRleCBzICc9JyBpblxuICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gIFN0cmluZy5zdWIgcyAwIGksIFN0cmluZy5zdWIgcyAoaSsxKSAobGVuLShpKzEpKVxuXG5cbmxldCBtYWtlX3N5bWxpc3QgcHJlZml4IHNlcCBzdWZmaXggbCA9XG4gIG1hdGNoIGwgd2l0aFxuICB8IFtdIC0+IFwiPG5vbmU+XCJcbiAgfCBoOjp0IC0+IChMaXN0LmZvbGRfbGVmdCAoZnVuIHggeSAtPiB4IF4gc2VwIF4geSkgKHByZWZpeCBeIGgpIHQpIF4gc3VmZml4XG5cblxubGV0IHByaW50X3NwZWMgYnVmIChrZXksIHNwZWMsIGRvYykgPVxuICBpZiBTdHJpbmcubGVuZ3RoIGRvYyA+IDAgdGhlblxuICAgIG1hdGNoIHNwZWMgd2l0aFxuICAgIHwgU3ltYm9sIChsLCBfKSAtPlxuICAgICAgICBicHJpbnRmIGJ1ZiBcIiAgJXMgJXMlc1xcblwiIGtleSAobWFrZV9zeW1saXN0IFwie1wiIFwifFwiIFwifVwiIGwpIGRvY1xuICAgIHwgXyAtPlxuICAgICAgICBicHJpbnRmIGJ1ZiBcIiAgJXMgJXNcXG5cIiBrZXkgZG9jXG5cblxubGV0IGhlbHBfYWN0aW9uICgpID0gcmFpc2UgKFN0b3AgKFVua25vd24gXCItaGVscFwiKSlcblxubGV0IGFkZF9oZWxwIHNwZWNsaXN0ID1cbiAgbGV0IGFkZDEgPVxuICAgIHRyeSBpZ25vcmUgKGFzc29jMyBcIi1oZWxwXCIgc3BlY2xpc3QpOyBbXVxuICAgIHdpdGggTm90X2ZvdW5kIC0+XG4gICAgICAgICAgICBbXCItaGVscFwiLCBVbml0IGhlbHBfYWN0aW9uLCBcIiBEaXNwbGF5IHRoaXMgbGlzdCBvZiBvcHRpb25zXCJdXG4gIGFuZCBhZGQyID1cbiAgICB0cnkgaWdub3JlIChhc3NvYzMgXCItLWhlbHBcIiBzcGVjbGlzdCk7IFtdXG4gICAgd2l0aCBOb3RfZm91bmQgLT5cbiAgICAgICAgICAgIFtcIi0taGVscFwiLCBVbml0IGhlbHBfYWN0aW9uLCBcIiBEaXNwbGF5IHRoaXMgbGlzdCBvZiBvcHRpb25zXCJdXG4gIGluXG4gIHNwZWNsaXN0IEAgKGFkZDEgQCBhZGQyKVxuXG5cbmxldCB1c2FnZV9iIGJ1ZiBzcGVjbGlzdCBlcnJtc2cgPVxuICBicHJpbnRmIGJ1ZiBcIiVzXFxuXCIgZXJybXNnO1xuICBMaXN0Lml0ZXIgKHByaW50X3NwZWMgYnVmKSAoYWRkX2hlbHAgc3BlY2xpc3QpXG5cblxubGV0IHVzYWdlX3N0cmluZyBzcGVjbGlzdCBlcnJtc2cgPVxuICBsZXQgYiA9IEJ1ZmZlci5jcmVhdGUgMjAwIGluXG4gIHVzYWdlX2IgYiBzcGVjbGlzdCBlcnJtc2c7XG4gIEJ1ZmZlci5jb250ZW50cyBiXG5cblxubGV0IHVzYWdlIHNwZWNsaXN0IGVycm1zZyA9XG4gIGVwcmludGYgXCIlc1wiICh1c2FnZV9zdHJpbmcgc3BlY2xpc3QgZXJybXNnKVxuXG5cbmxldCBjdXJyZW50ID0gcmVmIDBcblxubGV0IGJvb2xfb2Zfc3RyaW5nX29wdCB4ID1cbiAgdHJ5IFNvbWUgKGJvb2xfb2Zfc3RyaW5nIHgpXG4gIHdpdGggSW52YWxpZF9hcmd1bWVudCBfIC0+IE5vbmVcblxubGV0IGludF9vZl9zdHJpbmdfb3B0IHggPVxuICB0cnkgU29tZSAoaW50X29mX3N0cmluZyB4KVxuICB3aXRoIEZhaWx1cmUgXyAtPiBOb25lXG5cbmxldCBmbG9hdF9vZl9zdHJpbmdfb3B0IHggPVxuICB0cnkgU29tZSAoZmxvYXRfb2Zfc3RyaW5nIHgpXG4gIHdpdGggRmFpbHVyZSBfIC0+IE5vbmVcblxubGV0IHBhcnNlX2FuZF9leHBhbmRfYXJndl9keW5hbWljX2F1eCBhbGxvd19leHBhbmQgY3VycmVudCBhcmd2IHNwZWNsaXN0IGFub25mdW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJybXNnID1cbiAgbGV0IGluaXRwb3MgPSAhY3VycmVudCBpblxuICBsZXQgY29udmVydF9lcnJvciBlcnJvciA9XG4gICAgKCogY29udmVydCBhbiBpbnRlcm5hbCBlcnJvciB0byBhIEJhZC9IZWxwIGV4Y2VwdGlvblxuICAgICAgICpvciogYWRkIHRoZSBwcm9ncmFtIG5hbWUgYXMgYSBwcmVmaXggYW5kIHRoZSB1c2FnZSBtZXNzYWdlIGFzIGEgc3VmZml4XG4gICAgICAgdG8gYW4gdXNlci1yYWlzZWQgQmFkIGV4Y2VwdGlvbi5cbiAgICAqKVxuICAgIGxldCBiID0gQnVmZmVyLmNyZWF0ZSAyMDAgaW5cbiAgICBsZXQgcHJvZ25hbWUgPVxuICAgICAgaWYgaW5pdHBvcyA8IChBcnJheS5sZW5ndGggIWFyZ3YpIHRoZW4gIWFyZ3YuKGluaXRwb3MpIGVsc2UgXCIoPylcIiBpblxuICAgIGJlZ2luIG1hdGNoIGVycm9yIHdpdGhcbiAgICAgIHwgVW5rbm93biBcIi1oZWxwXCIgLT4gKClcbiAgICAgIHwgVW5rbm93biBcIi0taGVscFwiIC0+ICgpXG4gICAgICB8IFVua25vd24gcyAtPlxuICAgICAgICAgIGJwcmludGYgYiBcIiVzOiB1bmtub3duIG9wdGlvbiAnJXMnLlxcblwiIHByb2duYW1lIHNcbiAgICAgIHwgTWlzc2luZyBzIC0+XG4gICAgICAgICAgYnByaW50ZiBiIFwiJXM6IG9wdGlvbiAnJXMnIG5lZWRzIGFuIGFyZ3VtZW50LlxcblwiIHByb2duYW1lIHNcbiAgICAgIHwgV3JvbmcgKG9wdCwgYXJnLCBleHBlY3RlZCkgLT5cbiAgICAgICAgICBicHJpbnRmIGIgXCIlczogd3JvbmcgYXJndW1lbnQgJyVzJzsgb3B0aW9uICclcycgZXhwZWN0cyAlcy5cXG5cIlxuICAgICAgICAgICAgICAgICAgcHJvZ25hbWUgYXJnIG9wdCBleHBlY3RlZFxuICAgICAgfCBNZXNzYWdlIHMgLT4gKCogdXNlciBlcnJvciBtZXNzYWdlICopXG4gICAgICAgICAgYnByaW50ZiBiIFwiJXM6ICVzLlxcblwiIHByb2duYW1lIHNcbiAgICBlbmQ7XG4gICAgdXNhZ2VfYiBiICFzcGVjbGlzdCBlcnJtc2c7XG4gICAgaWYgZXJyb3IgPSBVbmtub3duIFwiLWhlbHBcIiB8fCBlcnJvciA9IFVua25vd24gXCItLWhlbHBcIlxuICAgIHRoZW4gSGVscCAoQnVmZmVyLmNvbnRlbnRzIGIpXG4gICAgZWxzZSBCYWQgKEJ1ZmZlci5jb250ZW50cyBiKVxuICBpblxuICBpbmNyIGN1cnJlbnQ7XG4gIHdoaWxlICFjdXJyZW50IDwgKEFycmF5Lmxlbmd0aCAhYXJndikgZG9cbiAgICBiZWdpbiB0cnlcbiAgICAgIGxldCBzID0gIWFyZ3YuKCFjdXJyZW50KSBpblxuICAgICAgaWYgU3RyaW5nLmxlbmd0aCBzID49IDEgJiYgcy5bMF0gPSAnLScgdGhlbiBiZWdpblxuICAgICAgICBsZXQgYWN0aW9uLCBmb2xsb3cgPVxuICAgICAgICAgIHRyeSBhc3NvYzMgcyAhc3BlY2xpc3QsIE5vbmVcbiAgICAgICAgICB3aXRoIE5vdF9mb3VuZCAtPlxuICAgICAgICAgIHRyeVxuICAgICAgICAgICAgbGV0IGtleXdvcmQsIGFyZyA9IHNwbGl0IHMgaW5cbiAgICAgICAgICAgIGFzc29jMyBrZXl3b3JkICFzcGVjbGlzdCwgU29tZSBhcmdcbiAgICAgICAgICB3aXRoIE5vdF9mb3VuZCAtPiByYWlzZSAoU3RvcCAoVW5rbm93biBzKSlcbiAgICAgICAgaW5cbiAgICAgICAgbGV0IG5vX2FyZyAoKSA9XG4gICAgICAgICAgbWF0Y2ggZm9sbG93IHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gKClcbiAgICAgICAgICB8IFNvbWUgYXJnIC0+IHJhaXNlIChTdG9wIChXcm9uZyAocywgYXJnLCBcIm5vIGFyZ3VtZW50XCIpKSkgaW5cbiAgICAgICAgbGV0IGdldF9hcmcgKCkgPVxuICAgICAgICAgIG1hdGNoIGZvbGxvdyB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgICAgIGlmICFjdXJyZW50ICsgMSA8IChBcnJheS5sZW5ndGggIWFyZ3YpIHRoZW4gIWFyZ3YuKCFjdXJyZW50ICsgMSlcbiAgICAgICAgICAgICAgZWxzZSByYWlzZSAoU3RvcCAoTWlzc2luZyBzKSlcbiAgICAgICAgICB8IFNvbWUgYXJnIC0+IGFyZ1xuICAgICAgICBpblxuICAgICAgICBsZXQgY29uc3VtZV9hcmcgKCkgPVxuICAgICAgICAgIG1hdGNoIGZvbGxvdyB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+IGluY3IgY3VycmVudFxuICAgICAgICAgIHwgU29tZSBfIC0+ICgpXG4gICAgICAgIGluXG4gICAgICAgIGxldCByZWMgdHJlYXRfYWN0aW9uID0gZnVuY3Rpb25cbiAgICAgICAgfCBVbml0IGYgLT4gbm9fYXJnICgpOyBmICgpO1xuICAgICAgICB8IEJvb2wgZiAtPlxuICAgICAgICAgICAgbGV0IGFyZyA9IGdldF9hcmcgKCkgaW5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIGJvb2xfb2Zfc3RyaW5nX29wdCBhcmcgd2l0aFxuICAgICAgICAgICAgfCBOb25lIC0+IHJhaXNlIChTdG9wIChXcm9uZyAocywgYXJnLCBcImEgYm9vbGVhblwiKSkpXG4gICAgICAgICAgICB8IFNvbWUgcyAtPiBmIHNcbiAgICAgICAgICAgIGVuZDtcbiAgICAgICAgICAgIGNvbnN1bWVfYXJnICgpO1xuICAgICAgICB8IFNldCByIC0+IG5vX2FyZyAoKTsgciA6PSB0cnVlO1xuICAgICAgICB8IENsZWFyIHIgLT4gbm9fYXJnICgpOyByIDo9IGZhbHNlO1xuICAgICAgICB8IFN0cmluZyBmIC0+XG4gICAgICAgICAgICBsZXQgYXJnID0gZ2V0X2FyZyAoKSBpblxuICAgICAgICAgICAgZiBhcmc7XG4gICAgICAgICAgICBjb25zdW1lX2FyZyAoKTtcbiAgICAgICAgfCBTeW1ib2wgKHN5bWIsIGYpIC0+XG4gICAgICAgICAgICBsZXQgYXJnID0gZ2V0X2FyZyAoKSBpblxuICAgICAgICAgICAgaWYgTGlzdC5tZW0gYXJnIHN5bWIgdGhlbiBiZWdpblxuICAgICAgICAgICAgICBmIGFyZztcbiAgICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgICAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgICAgICAgICByYWlzZSAoU3RvcCAoV3JvbmcgKHMsIGFyZywgXCJvbmUgb2Y6IFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBeIChtYWtlX3N5bWxpc3QgXCJcIiBcIiBcIiBcIlwiIHN5bWIpKSkpXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgfCBTZXRfc3RyaW5nIHIgLT5cbiAgICAgICAgICAgIHIgOj0gZ2V0X2FyZyAoKTtcbiAgICAgICAgICAgIGNvbnN1bWVfYXJnICgpO1xuICAgICAgICB8IEludCBmIC0+XG4gICAgICAgICAgICBsZXQgYXJnID0gZ2V0X2FyZyAoKSBpblxuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggaW50X29mX3N0cmluZ19vcHQgYXJnIHdpdGhcbiAgICAgICAgICAgIHwgTm9uZSAtPiByYWlzZSAoU3RvcCAoV3JvbmcgKHMsIGFyZywgXCJhbiBpbnRlZ2VyXCIpKSlcbiAgICAgICAgICAgIHwgU29tZSB4IC0+IGYgeFxuICAgICAgICAgICAgZW5kO1xuICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgIHwgU2V0X2ludCByIC0+XG4gICAgICAgICAgICBsZXQgYXJnID0gZ2V0X2FyZyAoKSBpblxuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggaW50X29mX3N0cmluZ19vcHQgYXJnIHdpdGhcbiAgICAgICAgICAgIHwgTm9uZSAtPiByYWlzZSAoU3RvcCAoV3JvbmcgKHMsIGFyZywgXCJhbiBpbnRlZ2VyXCIpKSlcbiAgICAgICAgICAgIHwgU29tZSB4IC0+IHIgOj0geFxuICAgICAgICAgICAgZW5kO1xuICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgIHwgRmxvYXQgZiAtPlxuICAgICAgICAgICAgbGV0IGFyZyA9IGdldF9hcmcgKCkgaW5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIGZsb2F0X29mX3N0cmluZ19vcHQgYXJnIHdpdGhcbiAgICAgICAgICAgIHwgTm9uZSAtPiByYWlzZSAoU3RvcCAoV3JvbmcgKHMsIGFyZywgXCJhIGZsb2F0XCIpKSlcbiAgICAgICAgICAgIHwgU29tZSB4IC0+IGYgeFxuICAgICAgICAgICAgZW5kO1xuICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgIHwgU2V0X2Zsb2F0IHIgLT5cbiAgICAgICAgICAgIGxldCBhcmcgPSBnZXRfYXJnICgpIGluXG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBmbG9hdF9vZl9zdHJpbmdfb3B0IGFyZyB3aXRoXG4gICAgICAgICAgICB8IE5vbmUgLT4gcmFpc2UgKFN0b3AgKFdyb25nIChzLCBhcmcsIFwiYSBmbG9hdFwiKSkpXG4gICAgICAgICAgICB8IFNvbWUgeCAtPiByIDo9IHhcbiAgICAgICAgICAgIGVuZDtcbiAgICAgICAgICAgIGNvbnN1bWVfYXJnICgpO1xuICAgICAgICB8IFR1cGxlIHNwZWNzIC0+XG4gICAgICAgICAgICBub19hcmcgKCk7XG4gICAgICAgICAgICBMaXN0Lml0ZXIgdHJlYXRfYWN0aW9uIHNwZWNzO1xuICAgICAgICB8IFJlc3QgZiAtPlxuICAgICAgICAgICAgbm9fYXJnICgpO1xuICAgICAgICAgICAgd2hpbGUgIWN1cnJlbnQgPCAoQXJyYXkubGVuZ3RoICFhcmd2KSAtIDEgZG9cbiAgICAgICAgICAgICAgZiAhYXJndi4oIWN1cnJlbnQgKyAxKTtcbiAgICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgICAgICBkb25lO1xuICAgICAgICB8IFJlc3RfYWxsIGYgLT5cbiAgICAgICAgICAgIG5vX2FyZyAoKTtcbiAgICAgICAgICAgIGxldCBhY2MgPSByZWYgW10gaW5cbiAgICAgICAgICAgIHdoaWxlICFjdXJyZW50IDwgQXJyYXkubGVuZ3RoICFhcmd2IC0gMSBkb1xuICAgICAgICAgICAgICBhY2MgOj0gIWFyZ3YuKCFjdXJyZW50ICsgMSkgOjogIWFjYztcbiAgICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgICAgICBkb25lO1xuICAgICAgICAgICAgZiAoTGlzdC5yZXYgIWFjYylcbiAgICAgICAgfCBFeHBhbmQgZiAtPlxuICAgICAgICAgICAgaWYgbm90IGFsbG93X2V4cGFuZCB0aGVuXG4gICAgICAgICAgICAgIHJhaXNlIChJbnZhbGlkX2FyZ3VtZW50IFwiQXJnLkV4cGFuZCBpcyBpcyBvbmx5IGFsbG93ZWQgd2l0aCBcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQXJnLnBhcnNlX2FuZF9leHBhbmRfYXJndl9keW5hbWljXCIpO1xuICAgICAgICAgICAgbGV0IGFyZyA9IGdldF9hcmcgKCkgaW5cbiAgICAgICAgICAgIGxldCBuZXdhcmcgPSBmIGFyZyBpblxuICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgICAgICBsZXQgYmVmb3JlID0gQXJyYXkuc3ViICFhcmd2IDAgKCFjdXJyZW50ICsgMSlcbiAgICAgICAgICAgIGFuZCBhZnRlciA9XG4gICAgICAgICAgICAgIEFycmF5LnN1YiAhYXJndiAoIWN1cnJlbnQgKyAxKVxuICAgICAgICAgICAgICAgICAgICAgICAgKChBcnJheS5sZW5ndGggIWFyZ3YpIC0gIWN1cnJlbnQgLSAxKSBpblxuICAgICAgICAgICAgYXJndjo9IEFycmF5LmNvbmNhdCBbYmVmb3JlO25ld2FyZzthZnRlcl07XG4gICAgICAgIGluXG4gICAgICAgIHRyZWF0X2FjdGlvbiBhY3Rpb24gZW5kXG4gICAgICBlbHNlIGFub25mdW4gc1xuICAgIHdpdGggfCBCYWQgbSAtPiByYWlzZSAoY29udmVydF9lcnJvciAoTWVzc2FnZSBtKSk7XG4gICAgICAgICB8IFN0b3AgZSAtPiByYWlzZSAoY29udmVydF9lcnJvciBlKTtcbiAgICBlbmQ7XG4gICAgaW5jciBjdXJyZW50XG4gIGRvbmVcblxubGV0IHBhcnNlX2FuZF9leHBhbmRfYXJndl9keW5hbWljIGN1cnJlbnQgYXJndiBzcGVjbGlzdCBhbm9uZnVuIGVycm1zZyA9XG4gIHBhcnNlX2FuZF9leHBhbmRfYXJndl9keW5hbWljX2F1eCB0cnVlIGN1cnJlbnQgYXJndiBzcGVjbGlzdCBhbm9uZnVuIGVycm1zZ1xuXG5sZXQgcGFyc2VfYXJndl9keW5hbWljID8oY3VycmVudD1jdXJyZW50KSBhcmd2IHNwZWNsaXN0IGFub25mdW4gZXJybXNnID1cbiAgcGFyc2VfYW5kX2V4cGFuZF9hcmd2X2R5bmFtaWNfYXV4IGZhbHNlIGN1cnJlbnQgKHJlZiBhcmd2KSBzcGVjbGlzdCBhbm9uZnVuXG4gICAgZXJybXNnXG5cblxubGV0IHBhcnNlX2FyZ3YgPyhjdXJyZW50PWN1cnJlbnQpIGFyZ3Ygc3BlY2xpc3QgYW5vbmZ1biBlcnJtc2cgPVxuICBwYXJzZV9hcmd2X2R5bmFtaWMgfmN1cnJlbnQ6Y3VycmVudCBhcmd2IChyZWYgc3BlY2xpc3QpIGFub25mdW4gZXJybXNnXG5cblxubGV0IHBhcnNlIGwgZiBtc2cgPVxuICB0cnlcbiAgICBwYXJzZV9hcmd2IFN5cy5hcmd2IGwgZiBtc2dcbiAgd2l0aFxuICB8IEJhZCBtc2cgLT4gZXByaW50ZiBcIiVzXCIgbXNnOyBleGl0IDJcbiAgfCBIZWxwIG1zZyAtPiBwcmludGYgXCIlc1wiIG1zZzsgZXhpdCAwXG5cblxubGV0IHBhcnNlX2R5bmFtaWMgbCBmIG1zZyA9XG4gIHRyeVxuICAgIHBhcnNlX2FyZ3ZfZHluYW1pYyBTeXMuYXJndiBsIGYgbXNnXG4gIHdpdGhcbiAgfCBCYWQgbXNnIC0+IGVwcmludGYgXCIlc1wiIG1zZzsgZXhpdCAyXG4gIHwgSGVscCBtc2cgLT4gcHJpbnRmIFwiJXNcIiBtc2c7IGV4aXQgMFxuXG5sZXQgcGFyc2VfZXhwYW5kIGwgZiBtc2cgPVxuICB0cnlcbiAgICBsZXQgYXJndiA9IHJlZiBTeXMuYXJndiBpblxuICAgIGxldCBzcGVjID0gcmVmIGwgaW5cbiAgICBsZXQgY3VycmVudCA9IHJlZiAoIWN1cnJlbnQpIGluXG4gICAgcGFyc2VfYW5kX2V4cGFuZF9hcmd2X2R5bmFtaWMgY3VycmVudCBhcmd2IHNwZWMgZiBtc2dcbiAgd2l0aFxuICB8IEJhZCBtc2cgLT4gZXByaW50ZiBcIiVzXCIgbXNnOyBleGl0IDJcbiAgfCBIZWxwIG1zZyAtPiBwcmludGYgXCIlc1wiIG1zZzsgZXhpdCAwXG5cblxubGV0IHNlY29uZF93b3JkIHMgPVxuICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gIGxldCByZWMgbG9vcCBuID1cbiAgICBpZiBuID49IGxlbiB0aGVuIGxlblxuICAgIGVsc2UgaWYgcy5bbl0gPSAnICcgdGhlbiBsb29wIChuKzEpXG4gICAgZWxzZSBuXG4gIGluXG4gIG1hdGNoIFN0cmluZy5pbmRleCBzICdcXHQnIHdpdGhcbiAgfCBuIC0+IGxvb3AgKG4rMSlcbiAgfCBleGNlcHRpb24gTm90X2ZvdW5kIC0+XG4gICAgICBiZWdpbiBtYXRjaCBTdHJpbmcuaW5kZXggcyAnICcgd2l0aFxuICAgICAgfCBuIC0+IGxvb3AgKG4rMSlcbiAgICAgIHwgZXhjZXB0aW9uIE5vdF9mb3VuZCAtPiBsZW5cbiAgICAgIGVuZFxuXG5cbmxldCBtYXhfYXJnX2xlbiBjdXIgKGt3ZCwgc3BlYywgZG9jKSA9XG4gIG1hdGNoIHNwZWMgd2l0aFxuICB8IFN5bWJvbCBfIC0+IEludC5tYXggY3VyIChTdHJpbmcubGVuZ3RoIGt3ZClcbiAgfCBfIC0+IEludC5tYXggY3VyIChTdHJpbmcubGVuZ3RoIGt3ZCArIHNlY29uZF93b3JkIGRvYylcblxuXG5sZXQgcmVwbGFjZV9sZWFkaW5nX3RhYiBzID1cbiAgbGV0IHNlZW4gPSByZWYgZmFsc2UgaW5cbiAgU3RyaW5nLm1hcCAoZnVuY3Rpb24gJ1xcdCcgd2hlbiBub3QgIXNlZW4gLT4gc2VlbiA6PSB0cnVlOyAnICcgfCBjIC0+IGMpIHNcblxubGV0IGFkZF9wYWRkaW5nIGxlbiBrc2QgPVxuICBtYXRjaCBrc2Qgd2l0aFxuICB8IChfLCBfLCBcIlwiKSAtPlxuICAgICAgKCogRG8gbm90IHBhZCB1bmRvY3VtZW50ZWQgb3B0aW9ucywgc28gdGhhdCB0aGV5IHN0aWxsIGRvbid0IHNob3cgdXAgd2hlblxuICAgICAgICogcnVuIHRocm91Z2ggW3VzYWdlXSBvciBbcGFyc2VdLiAqKVxuICAgICAga3NkXG4gIHwgKGt3ZCwgKFN5bWJvbCBfIGFzIHNwZWMpLCBtc2cpIC0+XG4gICAgICBsZXQgY3V0Y29sID0gc2Vjb25kX3dvcmQgbXNnIGluXG4gICAgICBsZXQgc3BhY2VzID0gU3RyaW5nLm1ha2UgKChJbnQubWF4IDAgKGxlbiAtIGN1dGNvbCkpICsgMykgJyAnIGluXG4gICAgICAoa3dkLCBzcGVjLCBcIlxcblwiIF4gc3BhY2VzIF4gcmVwbGFjZV9sZWFkaW5nX3RhYiBtc2cpXG4gIHwgKGt3ZCwgc3BlYywgbXNnKSAtPlxuICAgICAgbGV0IGN1dGNvbCA9IHNlY29uZF93b3JkIG1zZyBpblxuICAgICAgbGV0IGt3ZF9sZW4gPSBTdHJpbmcubGVuZ3RoIGt3ZCBpblxuICAgICAgbGV0IGRpZmYgPSBsZW4gLSBrd2RfbGVuIC0gY3V0Y29sIGluXG4gICAgICBpZiBkaWZmIDw9IDAgdGhlblxuICAgICAgICAoa3dkLCBzcGVjLCByZXBsYWNlX2xlYWRpbmdfdGFiIG1zZylcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IHNwYWNlcyA9IFN0cmluZy5tYWtlIGRpZmYgJyAnIGluXG4gICAgICAgIGxldCBwcmVmaXggPSBTdHJpbmcuc3ViIChyZXBsYWNlX2xlYWRpbmdfdGFiIG1zZykgMCBjdXRjb2wgaW5cbiAgICAgICAgbGV0IHN1ZmZpeCA9IFN0cmluZy5zdWIgbXNnIGN1dGNvbCAoU3RyaW5nLmxlbmd0aCBtc2cgLSBjdXRjb2wpIGluXG4gICAgICAgIChrd2QsIHNwZWMsIHByZWZpeCBeIHNwYWNlcyBeIHN1ZmZpeClcblxuXG5sZXQgYWxpZ24gPyhsaW1pdD1tYXhfaW50KSBzcGVjbGlzdCA9XG4gIGxldCBjb21wbGV0ZWQgPSBhZGRfaGVscCBzcGVjbGlzdCBpblxuICBsZXQgbGVuID0gTGlzdC5mb2xkX2xlZnQgbWF4X2FyZ19sZW4gMCBjb21wbGV0ZWQgaW5cbiAgbGV0IGxlbiA9IEludC5taW4gbGVuIGxpbWl0IGluXG4gIExpc3QubWFwIChhZGRfcGFkZGluZyBsZW4pIGNvbXBsZXRlZFxuXG5sZXQgdHJpbV9jciBzID1cbiAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggcyBpblxuICBpZiBsZW4gPiAwICYmIFN0cmluZy5nZXQgcyAobGVuIC0gMSkgPSAnXFxyJyB0aGVuXG4gICAgU3RyaW5nLnN1YiBzIDAgKGxlbiAtIDEpXG4gIGVsc2VcbiAgICBzXG5cbmxldCByZWFkX2F1eCB0cmltIHNlcCBmaWxlID1cbiAgbGV0IGljID0gb3Blbl9pbl9iaW4gZmlsZSBpblxuICBsZXQgYnVmID0gQnVmZmVyLmNyZWF0ZSAyMDAgaW5cbiAgbGV0IHdvcmRzID0gcmVmIFtdIGluXG4gIGxldCBzdGFzaCAoKSA9XG4gICAgbGV0IHdvcmQgPSBCdWZmZXIuY29udGVudHMgYnVmIGluXG4gICAgbGV0IHdvcmQgPSBpZiB0cmltIHRoZW4gdHJpbV9jciB3b3JkIGVsc2Ugd29yZCBpblxuICAgIHdvcmRzIDo9IHdvcmQgOjogIXdvcmRzO1xuICAgIEJ1ZmZlci5jbGVhciBidWZcbiAgaW5cbiAgYmVnaW5cbiAgICB0cnkgd2hpbGUgdHJ1ZSBkb1xuICAgICAgICBsZXQgYyA9IGlucHV0X2NoYXIgaWMgaW5cbiAgICAgICAgaWYgYyA9IHNlcCB0aGVuIHN0YXNoICgpIGVsc2UgQnVmZmVyLmFkZF9jaGFyIGJ1ZiBjXG4gICAgICBkb25lXG4gICAgd2l0aCBFbmRfb2ZfZmlsZSAtPiAoKVxuICBlbmQ7XG4gIGlmIEJ1ZmZlci5sZW5ndGggYnVmID4gMCB0aGVuIHN0YXNoICgpO1xuICBjbG9zZV9pbiBpYztcbiAgQXJyYXkub2ZfbGlzdCAoTGlzdC5yZXYgIXdvcmRzKVxuXG5sZXQgcmVhZF9hcmcgPSByZWFkX2F1eCB0cnVlICdcXG4nXG5cbmxldCByZWFkX2FyZzAgPSByZWFkX2F1eCBmYWxzZSAnXFx4MDAnXG5cbmxldCB3cml0ZV9hdXggc2VwIGZpbGUgYXJncyA9XG4gIGxldCBvYyA9IG9wZW5fb3V0X2JpbiBmaWxlIGluXG4gIEFycmF5Lml0ZXIgKGZ1biBzIC0+IGZwcmludGYgb2MgXCIlcyVjXCIgcyBzZXApIGFyZ3M7XG4gIGNsb3NlX291dCBvY1xuXG5sZXQgd3JpdGVfYXJnID0gd3JpdGVfYXV4ICdcXG4nXG5cbmxldCB3cml0ZV9hcmcwID0gd3JpdGVfYXV4ICdcXHgwMCdcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxub3BlbiBQcmludGZcblxudHlwZSB0ID0gZXhuID0gLi5cblxubGV0IHByaW50ZXJzID0gQXRvbWljLm1ha2UgW11cblxubGV0IGxvY2ZtdCA9IGZvcm1hdF9vZl9zdHJpbmcgXCJGaWxlIFxcXCIlc1xcXCIsIGxpbmUgJWQsIGNoYXJhY3RlcnMgJWQtJWQ6ICVzXCJcblxubGV0IGZpZWxkIHggaSA9XG4gIGxldCBmID0gT2JqLmZpZWxkIHggaSBpblxuICBpZiBub3QgKE9iai5pc19ibG9jayBmKSB0aGVuXG4gICAgc3ByaW50ZiBcIiVkXCIgKE9iai5tYWdpYyBmIDogaW50KSAgICAgICAgICAgKCogY2FuIGFsc28gYmUgYSBjaGFyICopXG4gIGVsc2UgaWYgT2JqLnRhZyBmID0gT2JqLnN0cmluZ190YWcgdGhlblxuICAgIHNwcmludGYgXCIlU1wiIChPYmoubWFnaWMgZiA6IHN0cmluZylcbiAgZWxzZSBpZiBPYmoudGFnIGYgPSBPYmouZG91YmxlX3RhZyB0aGVuXG4gICAgc3RyaW5nX29mX2Zsb2F0IChPYmoubWFnaWMgZiA6IGZsb2F0KVxuICBlbHNlXG4gICAgXCJfXCJcblxubGV0IHJlYyBvdGhlcl9maWVsZHMgeCBpID1cbiAgaWYgaSA+PSBPYmouc2l6ZSB4IHRoZW4gXCJcIlxuICBlbHNlIHNwcmludGYgXCIsICVzJXNcIiAoZmllbGQgeCBpKSAob3RoZXJfZmllbGRzIHggKGkrMSkpXG5cbmxldCBmaWVsZHMgeCA9XG4gIG1hdGNoIE9iai5zaXplIHggd2l0aFxuICB8IDAgLT4gXCJcIlxuICB8IDEgLT4gXCJcIlxuICB8IDIgLT4gc3ByaW50ZiBcIiglcylcIiAoZmllbGQgeCAxKVxuICB8IF8gLT4gc3ByaW50ZiBcIiglcyVzKVwiIChmaWVsZCB4IDEpIChvdGhlcl9maWVsZHMgeCAyKVxuXG5sZXQgdXNlX3ByaW50ZXJzIHggPVxuICBsZXQgcmVjIGNvbnYgPSBmdW5jdGlvblxuICAgIHwgaGQgOjogdGwgLT5cbiAgICAgICAgKG1hdGNoIGhkIHggd2l0aFxuICAgICAgICAgfCBOb25lIHwgZXhjZXB0aW9uIF8gLT4gY29udiB0bFxuICAgICAgICAgfCBTb21lIHMgLT4gU29tZSBzKVxuICAgIHwgW10gLT4gTm9uZSBpblxuICBjb252IChBdG9taWMuZ2V0IHByaW50ZXJzKVxuXG5sZXQgdG9fc3RyaW5nX2RlZmF1bHQgPSBmdW5jdGlvblxuICB8IE91dF9vZl9tZW1vcnkgLT4gXCJPdXQgb2YgbWVtb3J5XCJcbiAgfCBTdGFja19vdmVyZmxvdyAtPiBcIlN0YWNrIG92ZXJmbG93XCJcbiAgfCBNYXRjaF9mYWlsdXJlKGZpbGUsIGxpbmUsIGNoYXIpIC0+XG4gICAgICBzcHJpbnRmIGxvY2ZtdCBmaWxlIGxpbmUgY2hhciAoY2hhcis1KSBcIlBhdHRlcm4gbWF0Y2hpbmcgZmFpbGVkXCJcbiAgfCBBc3NlcnRfZmFpbHVyZShmaWxlLCBsaW5lLCBjaGFyKSAtPlxuICAgICAgc3ByaW50ZiBsb2NmbXQgZmlsZSBsaW5lIGNoYXIgKGNoYXIrNikgXCJBc3NlcnRpb24gZmFpbGVkXCJcbiAgfCBVbmRlZmluZWRfcmVjdXJzaXZlX21vZHVsZShmaWxlLCBsaW5lLCBjaGFyKSAtPlxuICAgICAgc3ByaW50ZiBsb2NmbXQgZmlsZSBsaW5lIGNoYXIgKGNoYXIrNikgXCJVbmRlZmluZWQgcmVjdXJzaXZlIG1vZHVsZVwiXG4gIHwgeCAtPlxuICAgICAgbGV0IHggPSBPYmoucmVwciB4IGluXG4gICAgICBpZiBPYmoudGFnIHggPD4gMCB0aGVuXG4gICAgICAgIChPYmoubWFnaWMgKE9iai5maWVsZCB4IDApIDogc3RyaW5nKVxuICAgICAgZWxzZVxuICAgICAgICBsZXQgY29uc3RydWN0b3IgPVxuICAgICAgICAgIChPYmoubWFnaWMgKE9iai5maWVsZCAoT2JqLmZpZWxkIHggMCkgMCkgOiBzdHJpbmcpIGluXG4gICAgICAgIGNvbnN0cnVjdG9yIF4gKGZpZWxkcyB4KVxuXG5sZXQgdG9fc3RyaW5nIGUgPVxuICBtYXRjaCB1c2VfcHJpbnRlcnMgZSB3aXRoXG4gIHwgU29tZSBzIC0+IHNcbiAgfCBOb25lIC0+IHRvX3N0cmluZ19kZWZhdWx0IGVcblxubGV0IHByaW50IGZjdCBhcmcgPVxuICB0cnlcbiAgICBmY3QgYXJnXG4gIHdpdGggeCAtPlxuICAgIGVwcmludGYgXCJVbmNhdWdodCBleGNlcHRpb246ICVzXFxuXCIgKHRvX3N0cmluZyB4KTtcbiAgICBmbHVzaCBzdGRlcnI7XG4gICAgcmFpc2UgeFxuXG5sZXQgY2F0Y2ggZmN0IGFyZyA9XG4gIHRyeVxuICAgIGZjdCBhcmdcbiAgd2l0aCB4IC0+XG4gICAgZmx1c2ggc3Rkb3V0O1xuICAgIGVwcmludGYgXCJVbmNhdWdodCBleGNlcHRpb246ICVzXFxuXCIgKHRvX3N0cmluZyB4KTtcbiAgICBleGl0IDJcblxudHlwZSByYXdfYmFja3RyYWNlX3Nsb3RcbnR5cGUgcmF3X2JhY2t0cmFjZV9lbnRyeSA9IHByaXZhdGUgaW50XG50eXBlIHJhd19iYWNrdHJhY2UgPSByYXdfYmFja3RyYWNlX2VudHJ5IGFycmF5XG5cbmxldCByYXdfYmFja3RyYWNlX2VudHJpZXMgYnQgPSBidFxuXG5leHRlcm5hbCBnZXRfcmF3X2JhY2t0cmFjZTpcbiAgdW5pdCAtPiByYXdfYmFja3RyYWNlID0gXCJjYW1sX2dldF9leGNlcHRpb25fcmF3X2JhY2t0cmFjZVwiXG5cbmV4dGVybmFsIHJhaXNlX3dpdGhfYmFja3RyYWNlOiBleG4gLT4gcmF3X2JhY2t0cmFjZSAtPiAnYVxuICA9IFwiJXJhaXNlX3dpdGhfYmFja3RyYWNlXCJcblxudHlwZSBiYWNrdHJhY2Vfc2xvdCA9XG4gIHwgS25vd25fbG9jYXRpb24gb2Yge1xuICAgICAgaXNfcmFpc2UgICAgOiBib29sO1xuICAgICAgZmlsZW5hbWUgICAgOiBzdHJpbmc7XG4gICAgICBsaW5lX251bWJlciA6IGludDtcbiAgICAgIHN0YXJ0X2NoYXIgIDogaW50O1xuICAgICAgZW5kX2NoYXIgICAgOiBpbnQ7XG4gICAgICBpc19pbmxpbmUgICA6IGJvb2w7XG4gICAgICBkZWZuYW1lICAgICA6IHN0cmluZztcbiAgICB9XG4gIHwgVW5rbm93bl9sb2NhdGlvbiBvZiB7XG4gICAgICBpc19yYWlzZSA6IGJvb2xcbiAgICB9XG5cbigqIHRvIGF2b2lkIHdhcm5pbmcgKilcbmxldCBfID0gW0tub3duX2xvY2F0aW9uIHsgaXNfcmFpc2UgPSBmYWxzZTsgZmlsZW5hbWUgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lX251bWJlciA9IDA7IHN0YXJ0X2NoYXIgPSAwOyBlbmRfY2hhciA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlzX2lubGluZSA9IGZhbHNlOyBkZWZuYW1lID0gXCJcIiB9O1xuICAgICAgICAgVW5rbm93bl9sb2NhdGlvbiB7IGlzX3JhaXNlID0gZmFsc2UgfV1cblxuZXh0ZXJuYWwgY29udmVydF9yYXdfYmFja3RyYWNlX3Nsb3Q6XG4gIHJhd19iYWNrdHJhY2Vfc2xvdCAtPiBiYWNrdHJhY2Vfc2xvdCA9IFwiY2FtbF9jb252ZXJ0X3Jhd19iYWNrdHJhY2Vfc2xvdFwiXG5cbmV4dGVybmFsIGNvbnZlcnRfcmF3X2JhY2t0cmFjZTpcbiAgcmF3X2JhY2t0cmFjZSAtPiBiYWNrdHJhY2Vfc2xvdCBhcnJheSA9IFwiY2FtbF9jb252ZXJ0X3Jhd19iYWNrdHJhY2VcIlxuXG5sZXQgY29udmVydF9yYXdfYmFja3RyYWNlIGJ0ID1cbiAgdHJ5IFNvbWUgKGNvbnZlcnRfcmF3X2JhY2t0cmFjZSBidClcbiAgd2l0aCBGYWlsdXJlIF8gLT4gTm9uZVxuXG5sZXQgZm9ybWF0X2JhY2t0cmFjZV9zbG90IHBvcyBzbG90ID1cbiAgbGV0IGluZm8gaXNfcmFpc2UgPVxuICAgIGlmIGlzX3JhaXNlIHRoZW5cbiAgICAgIGlmIHBvcyA9IDAgdGhlbiBcIlJhaXNlZCBhdFwiIGVsc2UgXCJSZS1yYWlzZWQgYXRcIlxuICAgIGVsc2VcbiAgICAgIGlmIHBvcyA9IDAgdGhlbiBcIlJhaXNlZCBieSBwcmltaXRpdmUgb3BlcmF0aW9uIGF0XCIgZWxzZSBcIkNhbGxlZCBmcm9tXCJcbiAgaW5cbiAgbWF0Y2ggc2xvdCB3aXRoXG4gIHwgVW5rbm93bl9sb2NhdGlvbiBsIC0+XG4gICAgICBpZiBsLmlzX3JhaXNlIHRoZW5cbiAgICAgICAgKCogY29tcGlsZXItaW5zZXJ0ZWQgcmUtcmFpc2UsIHNraXBwZWQgKikgTm9uZVxuICAgICAgZWxzZVxuICAgICAgICBTb21lIChzcHJpbnRmIFwiJXMgdW5rbm93biBsb2NhdGlvblwiIChpbmZvIGZhbHNlKSlcbiAgfCBLbm93bl9sb2NhdGlvbiBsIC0+XG4gICAgICBTb21lIChzcHJpbnRmIFwiJXMgJXMgaW4gZmlsZSBcXFwiJXNcXFwiJXMsIGxpbmUgJWQsIGNoYXJhY3RlcnMgJWQtJWRcIlxuICAgICAgICAgICAgICAoaW5mbyBsLmlzX3JhaXNlKSBsLmRlZm5hbWUgbC5maWxlbmFtZVxuICAgICAgICAgICAgICAoaWYgbC5pc19pbmxpbmUgdGhlbiBcIiAoaW5saW5lZClcIiBlbHNlIFwiXCIpXG4gICAgICAgICAgICAgIGwubGluZV9udW1iZXIgbC5zdGFydF9jaGFyIGwuZW5kX2NoYXIpXG5cbmxldCBwcmludF9leGNlcHRpb25fYmFja3RyYWNlIG91dGNoYW4gYmFja3RyYWNlID1cbiAgbWF0Y2ggYmFja3RyYWNlIHdpdGhcbiAgfCBOb25lIC0+XG4gICAgICBmcHJpbnRmIG91dGNoYW5cbiAgICAgICAgXCIoUHJvZ3JhbSBub3QgbGlua2VkIHdpdGggLWcsIGNhbm5vdCBwcmludCBzdGFjayBiYWNrdHJhY2UpXFxuXCJcbiAgfCBTb21lIGEgLT5cbiAgICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggYSAtIDEgZG9cbiAgICAgICAgbWF0Y2ggZm9ybWF0X2JhY2t0cmFjZV9zbG90IGkgYS4oaSkgd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPiAoKVxuICAgICAgICAgIHwgU29tZSBzdHIgLT4gZnByaW50ZiBvdXRjaGFuIFwiJXNcXG5cIiBzdHJcbiAgICAgIGRvbmVcblxubGV0IHByaW50X3Jhd19iYWNrdHJhY2Ugb3V0Y2hhbiByYXdfYmFja3RyYWNlID1cbiAgcHJpbnRfZXhjZXB0aW9uX2JhY2t0cmFjZSBvdXRjaGFuIChjb252ZXJ0X3Jhd19iYWNrdHJhY2UgcmF3X2JhY2t0cmFjZSlcblxuKCogY29uZnVzaW5nbHkgbmFtZWQ6IHByaW50cyB0aGUgZ2xvYmFsIGN1cnJlbnQgYmFja3RyYWNlICopXG5sZXQgcHJpbnRfYmFja3RyYWNlIG91dGNoYW4gPVxuICBwcmludF9yYXdfYmFja3RyYWNlIG91dGNoYW4gKGdldF9yYXdfYmFja3RyYWNlICgpKVxuXG5sZXQgYmFja3RyYWNlX3RvX3N0cmluZyBiYWNrdHJhY2UgPVxuICBtYXRjaCBiYWNrdHJhY2Ugd2l0aFxuICB8IE5vbmUgLT5cbiAgICAgXCIoUHJvZ3JhbSBub3QgbGlua2VkIHdpdGggLWcsIGNhbm5vdCBwcmludCBzdGFjayBiYWNrdHJhY2UpXFxuXCJcbiAgfCBTb21lIGEgLT5cbiAgICAgIGxldCBiID0gQnVmZmVyLmNyZWF0ZSAxMDI0IGluXG4gICAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGEgLSAxIGRvXG4gICAgICAgIG1hdGNoIGZvcm1hdF9iYWNrdHJhY2Vfc2xvdCBpIGEuKGkpIHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gKClcbiAgICAgICAgICB8IFNvbWUgc3RyIC0+IGJwcmludGYgYiBcIiVzXFxuXCIgc3RyXG4gICAgICBkb25lO1xuICAgICAgQnVmZmVyLmNvbnRlbnRzIGJcblxubGV0IHJhd19iYWNrdHJhY2VfdG9fc3RyaW5nIHJhd19iYWNrdHJhY2UgPVxuICBiYWNrdHJhY2VfdG9fc3RyaW5nIChjb252ZXJ0X3Jhd19iYWNrdHJhY2UgcmF3X2JhY2t0cmFjZSlcblxubGV0IGJhY2t0cmFjZV9zbG90X2lzX3JhaXNlID0gZnVuY3Rpb25cbiAgfCBLbm93bl9sb2NhdGlvbiBsIC0+IGwuaXNfcmFpc2VcbiAgfCBVbmtub3duX2xvY2F0aW9uIGwgLT4gbC5pc19yYWlzZVxuXG5sZXQgYmFja3RyYWNlX3Nsb3RfaXNfaW5saW5lID0gZnVuY3Rpb25cbiAgfCBLbm93bl9sb2NhdGlvbiBsIC0+IGwuaXNfaW5saW5lXG4gIHwgVW5rbm93bl9sb2NhdGlvbiBfIC0+IGZhbHNlXG5cbnR5cGUgbG9jYXRpb24gPSB7XG4gIGZpbGVuYW1lIDogc3RyaW5nO1xuICBsaW5lX251bWJlciA6IGludDtcbiAgc3RhcnRfY2hhciA6IGludDtcbiAgZW5kX2NoYXIgOiBpbnQ7XG59XG5cbmxldCBiYWNrdHJhY2Vfc2xvdF9sb2NhdGlvbiA9IGZ1bmN0aW9uXG4gIHwgVW5rbm93bl9sb2NhdGlvbiBfIC0+IE5vbmVcbiAgfCBLbm93bl9sb2NhdGlvbiBsIC0+XG4gICAgU29tZSB7XG4gICAgICBmaWxlbmFtZSAgICA9IGwuZmlsZW5hbWU7XG4gICAgICBsaW5lX251bWJlciA9IGwubGluZV9udW1iZXI7XG4gICAgICBzdGFydF9jaGFyICA9IGwuc3RhcnRfY2hhcjtcbiAgICAgIGVuZF9jaGFyICAgID0gbC5lbmRfY2hhcjtcbiAgICB9XG5cbmxldCBiYWNrdHJhY2Vfc2xvdF9kZWZuYW1lID0gZnVuY3Rpb25cbiAgfCBVbmtub3duX2xvY2F0aW9uIF9cbiAgfCBLbm93bl9sb2NhdGlvbiB7IGRlZm5hbWUgPSBcIlwiIH0gLT4gTm9uZVxuICB8IEtub3duX2xvY2F0aW9uIGwgLT4gU29tZSBsLmRlZm5hbWVcblxubGV0IGJhY2t0cmFjZV9zbG90cyByYXdfYmFja3RyYWNlID1cbiAgKCogVGhlIGRvY3VtZW50YXRpb24gb2YgdGhpcyBmdW5jdGlvbiBndWFyYW50ZWVzIHRoYXQgU29tZSBpc1xuICAgICByZXR1cm5lZCBvbmx5IGlmIGEgcGFydCBvZiB0aGUgdHJhY2UgaXMgdXNhYmxlLiBUaGlzIGdpdmVzIHVzXG4gICAgIGEgYml0IG1vcmUgd29yayB0aGFuIGp1c3QgY29udmVydF9yYXdfYmFja3RyYWNlLCBidXQgaXQgbWFrZXMgdGhlXG4gICAgIEFQSSBtb3JlIHVzZXItZnJpZW5kbHkgLS0gb3RoZXJ3aXNlIG1vc3QgdXNlcnMgd291bGQgaGF2ZSB0b1xuICAgICByZWltcGxlbWVudCB0aGUgXCJQcm9ncmFtIG5vdCBsaW5rZWQgd2l0aCAtZywgc29ycnlcIiBsb2dpY1xuICAgICB0aGVtc2VsdmVzLiAqKVxuICBtYXRjaCBjb252ZXJ0X3Jhd19iYWNrdHJhY2UgcmF3X2JhY2t0cmFjZSB3aXRoXG4gICAgfCBOb25lIC0+IE5vbmVcbiAgICB8IFNvbWUgYmFja3RyYWNlIC0+XG4gICAgICBsZXQgdXNhYmxlX3Nsb3QgPSBmdW5jdGlvblxuICAgICAgICB8IFVua25vd25fbG9jYXRpb24gXyAtPiBmYWxzZVxuICAgICAgICB8IEtub3duX2xvY2F0aW9uIF8gLT4gdHJ1ZSBpblxuICAgICAgbGV0IHJlYyBleGlzdHNfdXNhYmxlID0gZnVuY3Rpb25cbiAgICAgICAgfCAoLTEpIC0+IGZhbHNlXG4gICAgICAgIHwgaSAtPiB1c2FibGVfc2xvdCBiYWNrdHJhY2UuKGkpIHx8IGV4aXN0c191c2FibGUgKGkgLSAxKSBpblxuICAgICAgaWYgZXhpc3RzX3VzYWJsZSAoQXJyYXkubGVuZ3RoIGJhY2t0cmFjZSAtIDEpXG4gICAgICB0aGVuIFNvbWUgYmFja3RyYWNlXG4gICAgICBlbHNlIE5vbmVcblxubGV0IGJhY2t0cmFjZV9zbG90c19vZl9yYXdfZW50cnkgZW50cnkgPVxuICBiYWNrdHJhY2Vfc2xvdHMgW3wgZW50cnkgfF1cblxubW9kdWxlIFNsb3QgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gYmFja3RyYWNlX3Nsb3RcbiAgbGV0IGZvcm1hdCA9IGZvcm1hdF9iYWNrdHJhY2Vfc2xvdFxuICBsZXQgaXNfcmFpc2UgPSBiYWNrdHJhY2Vfc2xvdF9pc19yYWlzZVxuICBsZXQgaXNfaW5saW5lID0gYmFja3RyYWNlX3Nsb3RfaXNfaW5saW5lXG4gIGxldCBsb2NhdGlvbiA9IGJhY2t0cmFjZV9zbG90X2xvY2F0aW9uXG4gIGxldCBuYW1lID0gYmFja3RyYWNlX3Nsb3RfZGVmbmFtZVxuZW5kXG5cbmxldCByYXdfYmFja3RyYWNlX2xlbmd0aCBidCA9IEFycmF5Lmxlbmd0aCBidFxuXG5leHRlcm5hbCBnZXRfcmF3X2JhY2t0cmFjZV9zbG90IDpcbiAgcmF3X2JhY2t0cmFjZSAtPiBpbnQgLT4gcmF3X2JhY2t0cmFjZV9zbG90ID0gXCJjYW1sX3Jhd19iYWNrdHJhY2Vfc2xvdFwiXG5cbmV4dGVybmFsIGdldF9yYXdfYmFja3RyYWNlX25leHRfc2xvdCA6XG4gIHJhd19iYWNrdHJhY2Vfc2xvdCAtPiByYXdfYmFja3RyYWNlX3Nsb3Qgb3B0aW9uXG4gID0gXCJjYW1sX3Jhd19iYWNrdHJhY2VfbmV4dF9zbG90XCJcblxuKCogY29uZnVzaW5nbHkgbmFtZWQ6XG4gICByZXR1cm5zIHRoZSAqc3RyaW5nKiBjb3JyZXNwb25kaW5nIHRvIHRoZSBnbG9iYWwgY3VycmVudCBiYWNrdHJhY2UgKilcbmxldCBnZXRfYmFja3RyYWNlICgpID0gcmF3X2JhY2t0cmFjZV90b19zdHJpbmcgKGdldF9yYXdfYmFja3RyYWNlICgpKVxuXG5leHRlcm5hbCByZWNvcmRfYmFja3RyYWNlOiBib29sIC0+IHVuaXQgPSBcImNhbWxfcmVjb3JkX2JhY2t0cmFjZVwiXG5leHRlcm5hbCBiYWNrdHJhY2Vfc3RhdHVzOiB1bml0IC0+IGJvb2wgPSBcImNhbWxfYmFja3RyYWNlX3N0YXR1c1wiXG5cbmxldCByZWMgcmVnaXN0ZXJfcHJpbnRlciBmbiA9XG4gIGxldCBvbGRfcHJpbnRlcnMgPSBBdG9taWMuZ2V0IHByaW50ZXJzIGluXG4gIGxldCBuZXdfcHJpbnRlcnMgPSBmbiA6OiBvbGRfcHJpbnRlcnMgaW5cbiAgbGV0IHN1Y2Nlc3MgPSBBdG9taWMuY29tcGFyZV9hbmRfc2V0IHByaW50ZXJzIG9sZF9wcmludGVycyBuZXdfcHJpbnRlcnMgaW5cbiAgaWYgbm90IHN1Y2Nlc3MgdGhlbiByZWdpc3Rlcl9wcmludGVyIGZuXG5cbmV4dGVybmFsIGdldF9jYWxsc3RhY2s6IGludCAtPiByYXdfYmFja3RyYWNlID0gXCJjYW1sX2dldF9jdXJyZW50X2NhbGxzdGFja1wiXG5cbmxldCBleG5fc2xvdCB4ID1cbiAgbGV0IHggPSBPYmoucmVwciB4IGluXG4gIGlmIE9iai50YWcgeCA9IDAgdGhlbiBPYmouZmllbGQgeCAwIGVsc2UgeFxuXG5sZXQgZXhuX3Nsb3RfaWQgeCA9XG4gIGxldCBzbG90ID0gZXhuX3Nsb3QgeCBpblxuICAoT2JqLm9iaiAoT2JqLmZpZWxkIHNsb3QgMSkgOiBpbnQpXG5cbmxldCBleG5fc2xvdF9uYW1lIHggPVxuICBsZXQgc2xvdCA9IGV4bl9zbG90IHggaW5cbiAgKE9iai5vYmogKE9iai5maWVsZCBzbG90IDApIDogc3RyaW5nKVxuXG5leHRlcm5hbCBnZXRfZGVidWdfaW5mb19zdGF0dXMgOiB1bml0IC0+IGludCA9IFwiY2FtbF9tbF9kZWJ1Z19pbmZvX3N0YXR1c1wiXG5cbigqIERlc2NyaXB0aW9ucyBmb3IgZXJyb3JzIGluIHN0YXJ0dXAuaC4gU2VlIGFsc28gYmFja3RyYWNlLmMgKilcbmxldCBlcnJvcnMgPSBbfCBcIlwiO1xuICAoKiBGSUxFX05PVF9GT1VORCAqKVxuICBcIihDYW5ub3QgcHJpbnQgbG9jYXRpb25zOlxcbiBcXFxuICAgICAgYnl0ZWNvZGUgZXhlY3V0YWJsZSBwcm9ncmFtIGZpbGUgbm90IGZvdW5kKVwiO1xuICAoKiBCQURfQllURUNPREUgKilcbiAgXCIoQ2Fubm90IHByaW50IGxvY2F0aW9uczpcXG4gXFxcbiAgICAgIGJ5dGVjb2RlIGV4ZWN1dGFibGUgcHJvZ3JhbSBmaWxlIGFwcGVhcnMgdG8gYmUgY29ycnVwdClcIjtcbiAgKCogV1JPTkdfTUFHSUMgKilcbiAgXCIoQ2Fubm90IHByaW50IGxvY2F0aW9uczpcXG4gXFxcbiAgICAgIGJ5dGVjb2RlIGV4ZWN1dGFibGUgcHJvZ3JhbSBmaWxlIGhhcyB3cm9uZyBtYWdpYyBudW1iZXIpXCI7XG4gICgqIE5PX0ZEUyAqKVxuICBcIihDYW5ub3QgcHJpbnQgbG9jYXRpb25zOlxcbiBcXFxuICAgICAgYnl0ZWNvZGUgZXhlY3V0YWJsZSBwcm9ncmFtIGZpbGUgY2Fubm90IGJlIG9wZW5lZDtcXG4gXFxcbiAgICAgIC0tIHRvbyBtYW55IG9wZW4gZmlsZXMuIFRyeSBydW5uaW5nIHdpdGggT0NBTUxSVU5QQVJBTT1iPTIpXCJcbnxdXG5cbmxldCBkZWZhdWx0X3VuY2F1Z2h0X2V4Y2VwdGlvbl9oYW5kbGVyIGV4biByYXdfYmFja3RyYWNlID1cbiAgZXByaW50ZiBcIkZhdGFsIGVycm9yOiBleGNlcHRpb24gJXNcXG5cIiAodG9fc3RyaW5nIGV4bik7XG4gIHByaW50X3Jhd19iYWNrdHJhY2Ugc3RkZXJyIHJhd19iYWNrdHJhY2U7XG4gIGxldCBzdGF0dXMgPSBnZXRfZGVidWdfaW5mb19zdGF0dXMgKCkgaW5cbiAgaWYgc3RhdHVzIDwgMCB0aGVuXG4gICAgcHJlcnJfZW5kbGluZSBlcnJvcnMuKGFicyBzdGF0dXMpO1xuICBmbHVzaCBzdGRlcnJcblxubGV0IHVuY2F1Z2h0X2V4Y2VwdGlvbl9oYW5kbGVyID0gcmVmIGRlZmF1bHRfdW5jYXVnaHRfZXhjZXB0aW9uX2hhbmRsZXJcblxubGV0IHNldF91bmNhdWdodF9leGNlcHRpb25faGFuZGxlciBmbiA9IHVuY2F1Z2h0X2V4Y2VwdGlvbl9oYW5kbGVyIDo9IGZuXG5cbmxldCBlbXB0eV9iYWNrdHJhY2UgOiByYXdfYmFja3RyYWNlID0gW3wgfF1cblxubGV0IHRyeV9nZXRfcmF3X2JhY2t0cmFjZSAoKSA9XG4gIHRyeVxuICAgIGdldF9yYXdfYmFja3RyYWNlICgpXG4gIHdpdGggXyAoKiBPdXRfb2ZfbWVtb3J5PyAqKSAtPlxuICAgIGVtcHR5X2JhY2t0cmFjZVxuXG5sZXQgaGFuZGxlX3VuY2F1Z2h0X2V4Y2VwdGlvbicgZXhuIGRlYnVnZ2VyX2luX3VzZSA9XG4gIHRyeVxuICAgICgqIEdldCB0aGUgYmFja3RyYWNlIG5vdywgaW4gY2FzZSBvbmUgb2YgdGhlIFthdF9leGl0XSBmdW5jdGlvblxuICAgICAgIGRlc3Ryb3lzIGl0LiAqKVxuICAgIGxldCByYXdfYmFja3RyYWNlID1cbiAgICAgIGlmIGRlYnVnZ2VyX2luX3VzZSAoKiBTYW1lIHRlc3QgYXMgaW4gW3J1bnRpbWUvcHJpbnRleGMuY10gKikgdGhlblxuICAgICAgICBlbXB0eV9iYWNrdHJhY2VcbiAgICAgIGVsc2VcbiAgICAgICAgdHJ5X2dldF9yYXdfYmFja3RyYWNlICgpXG4gICAgaW5cbiAgICAodHJ5IFN0ZGxpYi5kb19hdF9leGl0ICgpIHdpdGggXyAtPiAoKSk7XG4gICAgdHJ5XG4gICAgICAhdW5jYXVnaHRfZXhjZXB0aW9uX2hhbmRsZXIgZXhuIHJhd19iYWNrdHJhY2VcbiAgICB3aXRoIGV4bicgLT5cbiAgICAgIGxldCByYXdfYmFja3RyYWNlJyA9IHRyeV9nZXRfcmF3X2JhY2t0cmFjZSAoKSBpblxuICAgICAgZXByaW50ZiBcIkZhdGFsIGVycm9yOiBleGNlcHRpb24gJXNcXG5cIiAodG9fc3RyaW5nIGV4bik7XG4gICAgICBwcmludF9yYXdfYmFja3RyYWNlIHN0ZGVyciByYXdfYmFja3RyYWNlO1xuICAgICAgZXByaW50ZiBcIkZhdGFsIGVycm9yIGluIHVuY2F1Z2h0IGV4Y2VwdGlvbiBoYW5kbGVyOiBleGNlcHRpb24gJXNcXG5cIlxuICAgICAgICAodG9fc3RyaW5nIGV4bicpO1xuICAgICAgcHJpbnRfcmF3X2JhY2t0cmFjZSBzdGRlcnIgcmF3X2JhY2t0cmFjZSc7XG4gICAgICBmbHVzaCBzdGRlcnJcbiAgd2l0aFxuICAgIHwgT3V0X29mX21lbW9yeSAtPlxuICAgICAgICBwcmVycl9lbmRsaW5lXG4gICAgICAgICAgXCJGYXRhbCBlcnJvcjogb3V0IG9mIG1lbW9yeSBpbiB1bmNhdWdodCBleGNlcHRpb24gaGFuZGxlclwiXG5cbigqIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGJ5IFtjYW1sX2ZhdGFsX3VuY2F1Z2h0X2V4Y2VwdGlvbl0gaW5cbiAgIFtydW50aW1lL3ByaW50ZXhjLmNdIHdoaWNoIGV4cGVjdHMgbm8gZXhjZXB0aW9uIGlzIHJhaXNlZC4gKilcbmxldCBoYW5kbGVfdW5jYXVnaHRfZXhjZXB0aW9uIGV4biBkZWJ1Z2dlcl9pbl91c2UgPVxuICB0cnlcbiAgICBoYW5kbGVfdW5jYXVnaHRfZXhjZXB0aW9uJyBleG4gZGVidWdnZXJfaW5fdXNlXG4gIHdpdGggXyAtPlxuICAgICgqIFRoZXJlIGlzIG5vdCBtdWNoIHdlIGNhbiBkbyBhdCB0aGlzIHBvaW50ICopXG4gICAgKClcblxuZXh0ZXJuYWwgcmVnaXN0ZXJfbmFtZWRfdmFsdWUgOiBzdHJpbmcgLT4gJ2EgLT4gdW5pdFxuICA9IFwiY2FtbF9yZWdpc3Rlcl9uYW1lZF92YWx1ZVwiXG5cbmxldCAoKSA9XG4gIHJlZ2lzdGVyX25hbWVkX3ZhbHVlIFwiUHJpbnRleGMuaGFuZGxlX3VuY2F1Z2h0X2V4Y2VwdGlvblwiXG4gICAgaGFuZGxlX3VuY2F1Z2h0X2V4Y2VwdGlvblxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgVGhlIE9DYW1sIHByb2dyYW1tZXJzICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxOCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5leHRlcm5hbCBpZCA6ICdhIC0+ICdhID0gXCIlaWRlbnRpdHlcIlxubGV0IGNvbnN0IGMgXyA9IGNcbmxldCBmbGlwIGYgeCB5ID0gZiB5IHhcbmxldCBuZWdhdGUgcCB2ID0gbm90IChwIHYpXG5cbmV4Y2VwdGlvbiBGaW5hbGx5X3JhaXNlZCBvZiBleG5cblxubGV0ICgpID0gUHJpbnRleGMucmVnaXN0ZXJfcHJpbnRlciBAQCBmdW5jdGlvblxufCBGaW5hbGx5X3JhaXNlZCBleG4gLT4gU29tZSAoXCJGdW4uRmluYWxseV9yYWlzZWQ6IFwiIF4gUHJpbnRleGMudG9fc3RyaW5nIGV4bilcbnwgXyAtPiBOb25lXG5cbmxldCBwcm90ZWN0IH4oZmluYWxseSA6IHVuaXQgLT4gdW5pdCkgd29yayA9XG4gIGxldCBmaW5hbGx5X25vX2V4biAoKSA9XG4gICAgdHJ5IGZpbmFsbHkgKCkgd2l0aCBlIC0+XG4gICAgICBsZXQgYnQgPSBQcmludGV4Yy5nZXRfcmF3X2JhY2t0cmFjZSAoKSBpblxuICAgICAgUHJpbnRleGMucmFpc2Vfd2l0aF9iYWNrdHJhY2UgKEZpbmFsbHlfcmFpc2VkIGUpIGJ0XG4gIGluXG4gIG1hdGNoIHdvcmsgKCkgd2l0aFxuICB8IHJlc3VsdCAtPiBmaW5hbGx5X25vX2V4biAoKSA7IHJlc3VsdFxuICB8IGV4Y2VwdGlvbiB3b3JrX2V4biAtPlxuICAgICAgbGV0IHdvcmtfYnQgPSBQcmludGV4Yy5nZXRfcmF3X2JhY2t0cmFjZSAoKSBpblxuICAgICAgZmluYWxseV9ub19leG4gKCkgO1xuICAgICAgUHJpbnRleGMucmFpc2Vfd2l0aF9iYWNrdHJhY2Ugd29ya19leG4gd29ya19idFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICBEYW1pZW4gRG9saWdleiwgcHJvamV0IFBhcmEsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICBKYWNxdWVzLUhlbnJpIEpvdXJkYW4sIHByb2pldCBHYWxsaXVtLCBJTlJJQSBQYXJpcyAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5Ni0yMDE2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgICAqKVxuKCogICAgIGV0IGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlIHN0YXQgPSB7XG4gIG1pbm9yX3dvcmRzIDogZmxvYXQ7XG4gIHByb21vdGVkX3dvcmRzIDogZmxvYXQ7XG4gIG1ham9yX3dvcmRzIDogZmxvYXQ7XG4gIG1pbm9yX2NvbGxlY3Rpb25zIDogaW50O1xuICBtYWpvcl9jb2xsZWN0aW9ucyA6IGludDtcbiAgaGVhcF93b3JkcyA6IGludDtcbiAgaGVhcF9jaHVua3MgOiBpbnQ7XG4gIGxpdmVfd29yZHMgOiBpbnQ7XG4gIGxpdmVfYmxvY2tzIDogaW50O1xuICBmcmVlX3dvcmRzIDogaW50O1xuICBmcmVlX2Jsb2NrcyA6IGludDtcbiAgbGFyZ2VzdF9mcmVlIDogaW50O1xuICBmcmFnbWVudHMgOiBpbnQ7XG4gIGNvbXBhY3Rpb25zIDogaW50O1xuICB0b3BfaGVhcF93b3JkcyA6IGludDtcbiAgc3RhY2tfc2l6ZSA6IGludDtcbiAgZm9yY2VkX21ham9yX2NvbGxlY3Rpb25zOiBpbnQ7XG59XG5cbnR5cGUgY29udHJvbCA9IHtcbiAgbXV0YWJsZSBtaW5vcl9oZWFwX3NpemUgOiBpbnQ7XG4gIG11dGFibGUgbWFqb3JfaGVhcF9pbmNyZW1lbnQgOiBpbnQ7XG4gIG11dGFibGUgc3BhY2Vfb3ZlcmhlYWQgOiBpbnQ7XG4gIG11dGFibGUgdmVyYm9zZSA6IGludDtcbiAgbXV0YWJsZSBtYXhfb3ZlcmhlYWQgOiBpbnQ7XG4gIG11dGFibGUgc3RhY2tfbGltaXQgOiBpbnQ7XG4gIG11dGFibGUgYWxsb2NhdGlvbl9wb2xpY3kgOiBpbnQ7XG4gIHdpbmRvd19zaXplIDogaW50O1xuICBjdXN0b21fbWFqb3JfcmF0aW8gOiBpbnQ7XG4gIGN1c3RvbV9taW5vcl9yYXRpbyA6IGludDtcbiAgY3VzdG9tX21pbm9yX21heF9zaXplIDogaW50O1xufVxuXG5leHRlcm5hbCBzdGF0IDogdW5pdCAtPiBzdGF0ID0gXCJjYW1sX2djX3N0YXRcIlxuZXh0ZXJuYWwgcXVpY2tfc3RhdCA6IHVuaXQgLT4gc3RhdCA9IFwiY2FtbF9nY19xdWlja19zdGF0XCJcbmV4dGVybmFsIGNvdW50ZXJzIDogdW5pdCAtPiAoZmxvYXQgKiBmbG9hdCAqIGZsb2F0KSA9IFwiY2FtbF9nY19jb3VudGVyc1wiXG5leHRlcm5hbCBtaW5vcl93b3JkcyA6IHVuaXQgLT4gKGZsb2F0IFtAdW5ib3hlZF0pXG4gID0gXCJjYW1sX2djX21pbm9yX3dvcmRzXCIgXCJjYW1sX2djX21pbm9yX3dvcmRzX3VuYm94ZWRcIlxuZXh0ZXJuYWwgZ2V0IDogdW5pdCAtPiBjb250cm9sID0gXCJjYW1sX2djX2dldFwiXG5leHRlcm5hbCBzZXQgOiBjb250cm9sIC0+IHVuaXQgPSBcImNhbWxfZ2Nfc2V0XCJcbmV4dGVybmFsIG1pbm9yIDogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2djX21pbm9yXCJcbmV4dGVybmFsIG1ham9yX3NsaWNlIDogaW50IC0+IGludCA9IFwiY2FtbF9nY19tYWpvcl9zbGljZVwiXG5leHRlcm5hbCBtYWpvciA6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9nY19tYWpvclwiXG5leHRlcm5hbCBmdWxsX21ham9yIDogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2djX2Z1bGxfbWFqb3JcIlxuZXh0ZXJuYWwgY29tcGFjdCA6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9nY19jb21wYWN0aW9uXCJcbmV4dGVybmFsIGdldF9taW5vcl9mcmVlIDogdW5pdCAtPiBpbnQgPSBcImNhbWxfZ2V0X21pbm9yX2ZyZWVcIlxuZXh0ZXJuYWwgZ2V0X2J1Y2tldCA6IGludCAtPiBpbnQgPSBcImNhbWxfZ2V0X21ham9yX2J1Y2tldFwiIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBnZXRfY3JlZGl0IDogdW5pdCAtPiBpbnQgPSBcImNhbWxfZ2V0X21ham9yX2NyZWRpdFwiIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBodWdlX2ZhbGxiYWNrX2NvdW50IDogdW5pdCAtPiBpbnQgPSBcImNhbWxfZ2NfaHVnZV9mYWxsYmFja19jb3VudFwiXG5leHRlcm5hbCBldmVudGxvZ19wYXVzZSA6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9ldmVudGxvZ19wYXVzZVwiXG5leHRlcm5hbCBldmVudGxvZ19yZXN1bWUgOiB1bml0IC0+IHVuaXQgPSBcImNhbWxfZXZlbnRsb2dfcmVzdW1lXCJcblxub3BlbiBQcmludGZcblxubGV0IHByaW50X3N0YXQgYyA9XG4gIGxldCBzdCA9IHN0YXQgKCkgaW5cbiAgZnByaW50ZiBjIFwibWlub3JfY29sbGVjdGlvbnM6ICAgICAgJWRcXG5cIiBzdC5taW5vcl9jb2xsZWN0aW9ucztcbiAgZnByaW50ZiBjIFwibWFqb3JfY29sbGVjdGlvbnM6ICAgICAgJWRcXG5cIiBzdC5tYWpvcl9jb2xsZWN0aW9ucztcbiAgZnByaW50ZiBjIFwiY29tcGFjdGlvbnM6ICAgICAgICAgICAgJWRcXG5cIiBzdC5jb21wYWN0aW9ucztcbiAgZnByaW50ZiBjIFwiZm9yY2VkX21ham9yX2NvbGxlY3Rpb25zOiAlZFxcblwiIHN0LmZvcmNlZF9tYWpvcl9jb2xsZWN0aW9ucztcbiAgZnByaW50ZiBjIFwiXFxuXCI7XG4gIGxldCBsMSA9IFN0cmluZy5sZW5ndGggKHNwcmludGYgXCIlLjBmXCIgc3QubWlub3Jfd29yZHMpIGluXG4gIGZwcmludGYgYyBcIm1pbm9yX3dvcmRzOiAgICAlKi4wZlxcblwiIGwxIHN0Lm1pbm9yX3dvcmRzO1xuICBmcHJpbnRmIGMgXCJwcm9tb3RlZF93b3JkczogJSouMGZcXG5cIiBsMSBzdC5wcm9tb3RlZF93b3JkcztcbiAgZnByaW50ZiBjIFwibWFqb3Jfd29yZHM6ICAgICUqLjBmXFxuXCIgbDEgc3QubWFqb3Jfd29yZHM7XG4gIGZwcmludGYgYyBcIlxcblwiO1xuICBsZXQgbDIgPSBTdHJpbmcubGVuZ3RoIChzcHJpbnRmIFwiJWRcIiBzdC50b3BfaGVhcF93b3JkcykgaW5cbiAgZnByaW50ZiBjIFwidG9wX2hlYXBfd29yZHM6ICUqZFxcblwiIGwyIHN0LnRvcF9oZWFwX3dvcmRzO1xuICBmcHJpbnRmIGMgXCJoZWFwX3dvcmRzOiAgICAgJSpkXFxuXCIgbDIgc3QuaGVhcF93b3JkcztcbiAgZnByaW50ZiBjIFwibGl2ZV93b3JkczogICAgICUqZFxcblwiIGwyIHN0LmxpdmVfd29yZHM7XG4gIGZwcmludGYgYyBcImZyZWVfd29yZHM6ICAgICAlKmRcXG5cIiBsMiBzdC5mcmVlX3dvcmRzO1xuICBmcHJpbnRmIGMgXCJsYXJnZXN0X2ZyZWU6ICAgJSpkXFxuXCIgbDIgc3QubGFyZ2VzdF9mcmVlO1xuICBmcHJpbnRmIGMgXCJmcmFnbWVudHM6ICAgICAgJSpkXFxuXCIgbDIgc3QuZnJhZ21lbnRzO1xuICBmcHJpbnRmIGMgXCJcXG5cIjtcbiAgZnByaW50ZiBjIFwibGl2ZV9ibG9ja3M6ICVkXFxuXCIgc3QubGl2ZV9ibG9ja3M7XG4gIGZwcmludGYgYyBcImZyZWVfYmxvY2tzOiAlZFxcblwiIHN0LmZyZWVfYmxvY2tzO1xuICBmcHJpbnRmIGMgXCJoZWFwX2NodW5rczogJWRcXG5cIiBzdC5oZWFwX2NodW5rc1xuXG5cbmxldCBhbGxvY2F0ZWRfYnl0ZXMgKCkgPVxuICBsZXQgKG1pLCBwcm8sIG1hKSA9IGNvdW50ZXJzICgpIGluXG4gIChtaSArLiBtYSAtLiBwcm8pICouIGZsb2F0X29mX2ludCAoU3lzLndvcmRfc2l6ZSAvIDgpXG5cblxuZXh0ZXJuYWwgZmluYWxpc2UgOiAoJ2EgLT4gdW5pdCkgLT4gJ2EgLT4gdW5pdCA9IFwiY2FtbF9maW5hbF9yZWdpc3RlclwiXG5leHRlcm5hbCBmaW5hbGlzZV9sYXN0IDogKHVuaXQgLT4gdW5pdCkgLT4gJ2EgLT4gdW5pdCA9XG4gIFwiY2FtbF9maW5hbF9yZWdpc3Rlcl9jYWxsZWRfd2l0aG91dF92YWx1ZVwiXG5leHRlcm5hbCBmaW5hbGlzZV9yZWxlYXNlIDogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2ZpbmFsX3JlbGVhc2VcIlxuXG5cbnR5cGUgYWxhcm0gPSBib29sIHJlZlxudHlwZSBhbGFybV9yZWMgPSB7YWN0aXZlIDogYWxhcm07IGYgOiB1bml0IC0+IHVuaXR9XG5cbmxldCByZWMgY2FsbF9hbGFybSBhcmVjID1cbiAgaWYgIShhcmVjLmFjdGl2ZSkgdGhlbiBiZWdpblxuICAgIGZpbmFsaXNlIGNhbGxfYWxhcm0gYXJlYztcbiAgICBhcmVjLmYgKCk7XG4gIGVuZFxuXG5cbmxldCBjcmVhdGVfYWxhcm0gZiA9XG4gIGxldCBhcmVjID0geyBhY3RpdmUgPSByZWYgdHJ1ZTsgZiA9IGYgfSBpblxuICBmaW5hbGlzZSBjYWxsX2FsYXJtIGFyZWM7XG4gIGFyZWMuYWN0aXZlXG5cblxubGV0IGRlbGV0ZV9hbGFybSBhID0gYSA6PSBmYWxzZVxuXG5tb2R1bGUgTWVtcHJvZiA9XG4gIHN0cnVjdFxuICAgIHR5cGUgYWxsb2NhdGlvbl9zb3VyY2UgPSBOb3JtYWwgfCBNYXJzaGFsIHwgQ3VzdG9tXG4gICAgdHlwZSBhbGxvY2F0aW9uID1cbiAgICAgIHsgbl9zYW1wbGVzIDogaW50O1xuICAgICAgICBzaXplIDogaW50O1xuICAgICAgICBzb3VyY2UgOiBhbGxvY2F0aW9uX3NvdXJjZTtcbiAgICAgICAgY2FsbHN0YWNrIDogUHJpbnRleGMucmF3X2JhY2t0cmFjZSB9XG5cbiAgICB0eXBlICgnbWlub3IsICdtYWpvcikgdHJhY2tlciA9IHtcbiAgICAgIGFsbG9jX21pbm9yOiBhbGxvY2F0aW9uIC0+ICdtaW5vciBvcHRpb247XG4gICAgICBhbGxvY19tYWpvcjogYWxsb2NhdGlvbiAtPiAnbWFqb3Igb3B0aW9uO1xuICAgICAgcHJvbW90ZTogJ21pbm9yIC0+ICdtYWpvciBvcHRpb247XG4gICAgICBkZWFsbG9jX21pbm9yOiAnbWlub3IgLT4gdW5pdDtcbiAgICAgIGRlYWxsb2NfbWFqb3I6ICdtYWpvciAtPiB1bml0O1xuICAgIH1cblxuICAgIGxldCBudWxsX3RyYWNrZXIgPSB7XG4gICAgICBhbGxvY19taW5vciA9IChmdW4gXyAtPiBOb25lKTtcbiAgICAgIGFsbG9jX21ham9yID0gKGZ1biBfIC0+IE5vbmUpO1xuICAgICAgcHJvbW90ZSA9IChmdW4gXyAtPiBOb25lKTtcbiAgICAgIGRlYWxsb2NfbWlub3IgPSAoZnVuIF8gLT4gKCkpO1xuICAgICAgZGVhbGxvY19tYWpvciA9IChmdW4gXyAtPiAoKSk7XG4gICAgfVxuXG4gICAgZXh0ZXJuYWwgY19zdGFydCA6XG4gICAgICBmbG9hdCAtPiBpbnQgLT4gKCdtaW5vciwgJ21ham9yKSB0cmFja2VyIC0+IHVuaXRcbiAgICAgID0gXCJjYW1sX21lbXByb2Zfc3RhcnRcIlxuXG4gICAgbGV0IHN0YXJ0XG4gICAgICB+c2FtcGxpbmdfcmF0ZVxuICAgICAgPyhjYWxsc3RhY2tfc2l6ZSA9IG1heF9pbnQpXG4gICAgICB0cmFja2VyID1cbiAgICAgIGNfc3RhcnQgc2FtcGxpbmdfcmF0ZSBjYWxsc3RhY2tfc2l6ZSB0cmFja2VyXG5cbiAgICBleHRlcm5hbCBzdG9wIDogdW5pdCAtPiB1bml0ID0gXCJjYW1sX21lbXByb2Zfc3RvcFwiXG4gIGVuZFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBNZXNzYWdlIGRpZ2VzdCAoTUQ1KSAqKVxuXG50eXBlIHQgPSBzdHJpbmdcblxubGV0IGNvbXBhcmUgPSBTdHJpbmcuY29tcGFyZVxubGV0IGVxdWFsID0gU3RyaW5nLmVxdWFsXG5cbmV4dGVybmFsIHVuc2FmZV9zdHJpbmc6IHN0cmluZyAtPiBpbnQgLT4gaW50IC0+IHQgPSBcImNhbWxfbWQ1X3N0cmluZ1wiXG5leHRlcm5hbCBjaGFubmVsOiBpbl9jaGFubmVsIC0+IGludCAtPiB0ID0gXCJjYW1sX21kNV9jaGFuXCJcblxubGV0IHN0cmluZyBzdHIgPVxuICB1bnNhZmVfc3RyaW5nIHN0ciAwIChTdHJpbmcubGVuZ3RoIHN0cilcblxubGV0IGJ5dGVzIGIgPSBzdHJpbmcgKEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgYilcblxubGV0IHN1YnN0cmluZyBzdHIgb2ZzIGxlbiA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBTdHJpbmcubGVuZ3RoIHN0ciAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiRGlnZXN0LnN1YnN0cmluZ1wiXG4gIGVsc2UgdW5zYWZlX3N0cmluZyBzdHIgb2ZzIGxlblxuXG5sZXQgc3ViYnl0ZXMgYiBvZnMgbGVuID0gc3Vic3RyaW5nIChCeXRlcy51bnNhZmVfdG9fc3RyaW5nIGIpIG9mcyBsZW5cblxubGV0IGZpbGUgZmlsZW5hbWUgPVxuICBsZXQgaWMgPSBvcGVuX2luX2JpbiBmaWxlbmFtZSBpblxuICBtYXRjaCBjaGFubmVsIGljICgtMSkgd2l0aFxuICAgIHwgZCAtPiBjbG9zZV9pbiBpYzsgZFxuICAgIHwgZXhjZXB0aW9uIGUgLT4gY2xvc2VfaW4gaWM7IHJhaXNlIGVcblxubGV0IG91dHB1dCBjaGFuIGRpZ2VzdCA9XG4gIG91dHB1dF9zdHJpbmcgY2hhbiBkaWdlc3RcblxubGV0IGlucHV0IGNoYW4gPSByZWFsbHlfaW5wdXRfc3RyaW5nIGNoYW4gMTZcblxubGV0IGNoYXJfaGV4IG4gPVxuICBDaGFyLnVuc2FmZV9jaHIgKG4gKyBpZiBuIDwgMTAgdGhlbiBDaGFyLmNvZGUgJzAnIGVsc2UgKENoYXIuY29kZSAnYScgLSAxMCkpXG5cbmxldCB0b19oZXggZCA9XG4gIGlmIFN0cmluZy5sZW5ndGggZCA8PiAxNiB0aGVuIGludmFsaWRfYXJnIFwiRGlnZXN0LnRvX2hleFwiO1xuICBsZXQgcmVzdWx0ID0gQnl0ZXMuY3JlYXRlIDMyIGluXG4gIGZvciBpID0gMCB0byAxNSBkb1xuICAgIGxldCB4ID0gQ2hhci5jb2RlIGQuW2ldIGluXG4gICAgQnl0ZXMudW5zYWZlX3NldCByZXN1bHQgKGkqMikgKGNoYXJfaGV4ICh4IGxzciA0KSk7XG4gICAgQnl0ZXMudW5zYWZlX3NldCByZXN1bHQgKGkqMisxKSAoY2hhcl9oZXggKHggbGFuZCAweDBmKSk7XG4gIGRvbmU7XG4gIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcmVzdWx0XG5cbmxldCBmcm9tX2hleCBzID1cbiAgaWYgU3RyaW5nLmxlbmd0aCBzIDw+IDMyIHRoZW4gaW52YWxpZF9hcmcgXCJEaWdlc3QuZnJvbV9oZXhcIjtcbiAgbGV0IGRpZ2l0IGMgPVxuICAgIG1hdGNoIGMgd2l0aFxuICAgIHwgJzAnLi4nOScgLT4gQ2hhci5jb2RlIGMgLSBDaGFyLmNvZGUgJzAnXG4gICAgfCAnQScuLidGJyAtPiBDaGFyLmNvZGUgYyAtIENoYXIuY29kZSAnQScgKyAxMFxuICAgIHwgJ2EnLi4nZicgLT4gQ2hhci5jb2RlIGMgLSBDaGFyLmNvZGUgJ2EnICsgMTBcbiAgICB8IF8gLT4gcmFpc2UgKEludmFsaWRfYXJndW1lbnQgXCJEaWdlc3QuZnJvbV9oZXhcIilcbiAgaW5cbiAgbGV0IGJ5dGUgaSA9IGRpZ2l0IHMuW2ldIGxzbCA0ICsgZGlnaXQgcy5baSsxXSBpblxuICBsZXQgcmVzdWx0ID0gQnl0ZXMuY3JlYXRlIDE2IGluXG4gIGZvciBpID0gMCB0byAxNSBkb1xuICAgIEJ5dGVzLnNldCByZXN1bHQgaSAoQ2hhci5jaHIgKGJ5dGUgKDIgKiBpKSkpO1xuICBkb25lO1xuICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHJlc3VsdFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICBEYW1pZW4gRG9saWdleiwgcHJvamV0IFBhcmEsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBQc2V1ZG8tcmFuZG9tIG51bWJlciBnZW5lcmF0b3JcbiAgIFRoaXMgaXMgYSBsYWdnZWQtRmlib25hY2NpIEYoNTUsIDI0LCArKSB3aXRoIGEgbW9kaWZpZWQgYWRkaXRpb25cbiAgIGZ1bmN0aW9uIHRvIGVuaGFuY2UgdGhlIG1peGluZyBvZiBiaXRzLlxuICAgSWYgd2UgdXNlIG5vcm1hbCBhZGRpdGlvbiwgdGhlIGxvdy1vcmRlciBiaXQgZmFpbHMgdGVzdHMgMSBhbmQgN1xuICAgb2YgdGhlIERpZWhhcmQgdGVzdCBzdWl0ZSwgYW5kIGJpdHMgMSBhbmQgMiBhbHNvIGZhaWwgdGVzdCA3LlxuICAgSWYgd2UgdXNlIG11bHRpcGxpY2F0aW9uIGFzIHN1Z2dlc3RlZCBieSBNYXJzYWdsaWEsIGl0IGRvZXNuJ3QgZmFyZVxuICAgbXVjaCBiZXR0ZXIuXG4gICBCeSBtaXhpbmcgdGhlIGJpdHMgb2Ygb25lIG9mIHRoZSBudW1iZXJzIGJlZm9yZSBhZGRpdGlvbiAoWE9SIHRoZVxuICAgNSBoaWdoLW9yZGVyIGJpdHMgaW50byB0aGUgbG93LW9yZGVyIGJpdHMpLCB3ZSBnZXQgYSBnZW5lcmF0b3IgdGhhdFxuICAgcGFzc2VzIGFsbCB0aGUgRGllaGFyZCB0ZXN0cy5cbiopXG5cbmV4dGVybmFsIHJhbmRvbV9zZWVkOiB1bml0IC0+IGludCBhcnJheSA9IFwiY2FtbF9zeXNfcmFuZG9tX3NlZWRcIlxuXG5tb2R1bGUgU3RhdGUgPSBzdHJ1Y3RcblxuICB0eXBlIHQgPSB7IHN0IDogaW50IGFycmF5OyBtdXRhYmxlIGlkeCA6IGludCB9XG5cbiAgbGV0IG5ld19zdGF0ZSAoKSA9IHsgc3QgPSBBcnJheS5tYWtlIDU1IDA7IGlkeCA9IDAgfVxuICBsZXQgYXNzaWduIHN0MSBzdDIgPVxuICAgIEFycmF5LmJsaXQgc3QyLnN0IDAgc3QxLnN0IDAgNTU7XG4gICAgc3QxLmlkeCA8LSBzdDIuaWR4XG5cblxuICBsZXQgZnVsbF9pbml0IHMgc2VlZCA9XG4gICAgbGV0IGNvbWJpbmUgYWNjdSB4ID0gRGlnZXN0LnN0cmluZyAoYWNjdSBeIEludC50b19zdHJpbmcgeCkgaW5cbiAgICBsZXQgZXh0cmFjdCBkID1cbiAgICAgIENoYXIuY29kZSBkLlswXSArIChDaGFyLmNvZGUgZC5bMV0gbHNsIDgpICsgKENoYXIuY29kZSBkLlsyXSBsc2wgMTYpXG4gICAgICArIChDaGFyLmNvZGUgZC5bM10gbHNsIDI0KVxuICAgIGluXG4gICAgbGV0IHNlZWQgPSBpZiBBcnJheS5sZW5ndGggc2VlZCA9IDAgdGhlbiBbfCAwIHxdIGVsc2Ugc2VlZCBpblxuICAgIGxldCBsID0gQXJyYXkubGVuZ3RoIHNlZWQgaW5cbiAgICBmb3IgaSA9IDAgdG8gNTQgZG9cbiAgICAgIHMuc3QuKGkpIDwtIGk7XG4gICAgZG9uZTtcbiAgICBsZXQgYWNjdSA9IHJlZiBcInhcIiBpblxuICAgIGZvciBpID0gMCB0byA1NCArIEludC5tYXggNTUgbCBkb1xuICAgICAgbGV0IGogPSBpIG1vZCA1NSBpblxuICAgICAgbGV0IGsgPSBpIG1vZCBsIGluXG4gICAgICBhY2N1IDo9IGNvbWJpbmUgIWFjY3Ugc2VlZC4oayk7XG4gICAgICBzLnN0LihqKSA8LSAocy5zdC4oaikgbHhvciBleHRyYWN0ICFhY2N1KSBsYW5kIDB4M0ZGRkZGRkY7ICAoKiBQUiM1NTc1ICopXG4gICAgZG9uZTtcbiAgICBzLmlkeCA8LSAwXG5cblxuICBsZXQgbWFrZSBzZWVkID1cbiAgICBsZXQgcmVzdWx0ID0gbmV3X3N0YXRlICgpIGluXG4gICAgZnVsbF9pbml0IHJlc3VsdCBzZWVkO1xuICAgIHJlc3VsdFxuXG5cbiAgbGV0IG1ha2Vfc2VsZl9pbml0ICgpID0gbWFrZSAocmFuZG9tX3NlZWQgKCkpXG5cbiAgbGV0IGNvcHkgcyA9XG4gICAgbGV0IHJlc3VsdCA9IG5ld19zdGF0ZSAoKSBpblxuICAgIGFzc2lnbiByZXN1bHQgcztcbiAgICByZXN1bHRcblxuXG4gICgqIFJldHVybnMgMzAgcmFuZG9tIGJpdHMgYXMgYW4gaW50ZWdlciAwIDw9IHggPCAxMDczNzQxODI0ICopXG4gIGxldCBiaXRzIHMgPVxuICAgIHMuaWR4IDwtIChzLmlkeCArIDEpIG1vZCA1NTtcbiAgICBsZXQgY3VydmFsID0gcy5zdC4ocy5pZHgpIGluXG4gICAgbGV0IG5ld3ZhbCA9IHMuc3QuKChzLmlkeCArIDI0KSBtb2QgNTUpXG4gICAgICAgICAgICAgICAgICsgKGN1cnZhbCBseG9yICgoY3VydmFsIGxzciAyNSkgbGFuZCAweDFGKSkgaW5cbiAgICBsZXQgbmV3dmFsMzAgPSBuZXd2YWwgbGFuZCAweDNGRkZGRkZGIGluICAoKiBQUiM1NTc1ICopXG4gICAgcy5zdC4ocy5pZHgpIDwtIG5ld3ZhbDMwO1xuICAgIG5ld3ZhbDMwXG5cblxuICBsZXQgcmVjIGludGF1eCBzIG4gPVxuICAgIGxldCByID0gYml0cyBzIGluXG4gICAgbGV0IHYgPSByIG1vZCBuIGluXG4gICAgaWYgciAtIHYgPiAweDNGRkZGRkZGIC0gbiArIDEgdGhlbiBpbnRhdXggcyBuIGVsc2UgdlxuXG4gIGxldCBpbnQgcyBib3VuZCA9XG4gICAgaWYgYm91bmQgPiAweDNGRkZGRkZGIHx8IGJvdW5kIDw9IDBcbiAgICB0aGVuIGludmFsaWRfYXJnIFwiUmFuZG9tLmludFwiXG4gICAgZWxzZSBpbnRhdXggcyBib3VuZFxuXG4gIGxldCByZWMgaW50NjNhdXggcyBuID1cbiAgICBsZXQgbWF4X2ludF8zMiA9ICgxIGxzbCAzMCkgKyAweDNGRkZGRkZGIGluICgqIDB4N0ZGRkZGRkYgKilcbiAgICBsZXQgYjEgPSBiaXRzIHMgaW5cbiAgICBsZXQgYjIgPSBiaXRzIHMgaW5cbiAgICBsZXQgKHIsIG1heF9pbnQpID1cbiAgICAgIGlmIG4gPD0gbWF4X2ludF8zMiB0aGVuXG4gICAgICAgICgqIDMxIHJhbmRvbSBiaXRzIG9uIGJvdGggNjQtYml0IE9DYW1sIGFuZCBKYXZhU2NyaXB0LlxuICAgICAgICAgICBVc2UgdXBwZXIgMTUgYml0cyBvZiBiMSBhbmQgMTYgYml0cyBvZiBiMi4gKilcbiAgICAgICAgbGV0IGJwb3MgPVxuICAgICAgICAgICgoKGIyIGxhbmQgMHgzRkZGQzAwMCkgbHNsIDEpIGxvciAoYjEgbHNyIDE1KSlcbiAgICAgICAgaW5cbiAgICAgICAgICAoYnBvcywgbWF4X2ludF8zMilcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IGIzID0gYml0cyBzIGluXG4gICAgICAgICgqIDYyIHJhbmRvbSBiaXRzIG9uIDY0LWJpdCBPQ2FtbDsgdW5yZWFjaGFibGUgb24gSmF2YVNjcmlwdC5cbiAgICAgICAgICAgVXNlIHVwcGVyIDIwIGJpdHMgb2YgYjEgYW5kIDIxIGJpdHMgb2YgYjIgYW5kIGIzLiAqKVxuICAgICAgICBsZXQgYnBvcyA9XG4gICAgICAgICAgKCgoKGIzIGxhbmQgMHgzRkZGRkUwMCkgbHNsIDEyKSBsb3IgKGIyIGxzciA5KSkgbHNsIDIwKVxuICAgICAgICAgICAgbG9yIChiMSBsc3IgMTApXG4gICAgICAgIGluXG4gICAgICAgICAgKGJwb3MsIG1heF9pbnQpXG4gICAgaW5cbiAgICBsZXQgdiA9IHIgbW9kIG4gaW5cbiAgICBpZiByIC0gdiA+IG1heF9pbnQgLSBuICsgMSB0aGVuIGludDYzYXV4IHMgbiBlbHNlIHZcblxuICBsZXQgZnVsbF9pbnQgcyBib3VuZCA9XG4gICAgaWYgYm91bmQgPD0gMCB0aGVuXG4gICAgICBpbnZhbGlkX2FyZyBcIlJhbmRvbS5mdWxsX2ludFwiXG4gICAgZWxzZSBpZiBib3VuZCA+IDB4M0ZGRkZGRkYgdGhlblxuICAgICAgaW50NjNhdXggcyBib3VuZFxuICAgIGVsc2VcbiAgICAgIGludGF1eCBzIGJvdW5kXG5cblxuICBsZXQgcmVjIGludDMyYXV4IHMgbiA9XG4gICAgbGV0IGIxID0gSW50MzIub2ZfaW50IChiaXRzIHMpIGluXG4gICAgbGV0IGIyID0gSW50MzIuc2hpZnRfbGVmdCAoSW50MzIub2ZfaW50IChiaXRzIHMgbGFuZCAxKSkgMzAgaW5cbiAgICBsZXQgciA9IEludDMyLmxvZ29yIGIxIGIyIGluXG4gICAgbGV0IHYgPSBJbnQzMi5yZW0gciBuIGluXG4gICAgaWYgSW50MzIuc3ViIHIgdiA+IEludDMyLmFkZCAoSW50MzIuc3ViIEludDMyLm1heF9pbnQgbikgMWxcbiAgICB0aGVuIGludDMyYXV4IHMgblxuICAgIGVsc2UgdlxuXG4gIGxldCBpbnQzMiBzIGJvdW5kID1cbiAgICBpZiBib3VuZCA8PSAwbFxuICAgIHRoZW4gaW52YWxpZF9hcmcgXCJSYW5kb20uaW50MzJcIlxuICAgIGVsc2UgaW50MzJhdXggcyBib3VuZFxuXG5cbiAgbGV0IHJlYyBpbnQ2NGF1eCBzIG4gPVxuICAgIGxldCBiMSA9IEludDY0Lm9mX2ludCAoYml0cyBzKSBpblxuICAgIGxldCBiMiA9IEludDY0LnNoaWZ0X2xlZnQgKEludDY0Lm9mX2ludCAoYml0cyBzKSkgMzAgaW5cbiAgICBsZXQgYjMgPSBJbnQ2NC5zaGlmdF9sZWZ0IChJbnQ2NC5vZl9pbnQgKGJpdHMgcyBsYW5kIDcpKSA2MCBpblxuICAgIGxldCByID0gSW50NjQubG9nb3IgYjEgKEludDY0LmxvZ29yIGIyIGIzKSBpblxuICAgIGxldCB2ID0gSW50NjQucmVtIHIgbiBpblxuICAgIGlmIEludDY0LnN1YiByIHYgPiBJbnQ2NC5hZGQgKEludDY0LnN1YiBJbnQ2NC5tYXhfaW50IG4pIDFMXG4gICAgdGhlbiBpbnQ2NGF1eCBzIG5cbiAgICBlbHNlIHZcblxuICBsZXQgaW50NjQgcyBib3VuZCA9XG4gICAgaWYgYm91bmQgPD0gMExcbiAgICB0aGVuIGludmFsaWRfYXJnIFwiUmFuZG9tLmludDY0XCJcbiAgICBlbHNlIGludDY0YXV4IHMgYm91bmRcblxuXG4gIGxldCBuYXRpdmVpbnQgPVxuICAgIGlmIE5hdGl2ZWludC5zaXplID0gMzJcbiAgICB0aGVuIGZ1biBzIGJvdW5kIC0+IE5hdGl2ZWludC5vZl9pbnQzMiAoaW50MzIgcyAoTmF0aXZlaW50LnRvX2ludDMyIGJvdW5kKSlcbiAgICBlbHNlIGZ1biBzIGJvdW5kIC0+IEludDY0LnRvX25hdGl2ZWludCAoaW50NjQgcyAoSW50NjQub2ZfbmF0aXZlaW50IGJvdW5kKSlcblxuXG4gICgqIFJldHVybnMgYSBmbG9hdCAwIDw9IHggPD0gMSB3aXRoIGF0IG1vc3QgNjAgYml0cyBvZiBwcmVjaXNpb24uICopXG4gIGxldCByYXdmbG9hdCBzID1cbiAgICBsZXQgc2NhbGUgPSAxMDczNzQxODI0LjAgICgqIDJeMzAgKilcbiAgICBhbmQgcjEgPSBTdGRsaWIuZmxvYXQgKGJpdHMgcylcbiAgICBhbmQgcjIgPSBTdGRsaWIuZmxvYXQgKGJpdHMgcylcbiAgICBpbiAocjEgLy4gc2NhbGUgKy4gcjIpIC8uIHNjYWxlXG5cblxuICBsZXQgZmxvYXQgcyBib3VuZCA9IHJhd2Zsb2F0IHMgKi4gYm91bmRcblxuICBsZXQgYm9vbCBzID0gKGJpdHMgcyBsYW5kIDEgPSAwKVxuXG4gIGxldCBiaXRzMzIgcyA9XG4gICAgbGV0IGIxID0gSW50MzIuKHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgKG9mX2ludCAoYml0cyBzKSkgMTQpIGluICAoKiAxNiBiaXRzICopXG4gICAgbGV0IGIyID0gSW50MzIuKHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgKG9mX2ludCAoYml0cyBzKSkgMTQpIGluICAoKiAxNiBiaXRzICopXG4gICAgSW50MzIuKGxvZ29yIGIxIChzaGlmdF9sZWZ0IGIyIDE2KSlcblxuICBsZXQgYml0czY0IHMgPVxuICAgIGxldCBiMSA9IEludDY0LihzaGlmdF9yaWdodF9sb2dpY2FsIChvZl9pbnQgKGJpdHMgcykpIDkpIGluICAoKiAyMSBiaXRzICopXG4gICAgbGV0IGIyID0gSW50NjQuKHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgKG9mX2ludCAoYml0cyBzKSkgOSkgaW4gICgqIDIxIGJpdHMgKilcbiAgICBsZXQgYjMgPSBJbnQ2NC4oc2hpZnRfcmlnaHRfbG9naWNhbCAob2ZfaW50IChiaXRzIHMpKSA4KSBpbiAgKCogMjIgYml0cyAqKVxuICAgIEludDY0Lihsb2dvciBiMSAobG9nb3IgKHNoaWZ0X2xlZnQgYjIgMjEpIChzaGlmdF9sZWZ0IGIzIDQyKSkpXG5cbiAgbGV0IG5hdGl2ZWJpdHMgPVxuICAgIGlmIE5hdGl2ZWludC5zaXplID0gMzJcbiAgICB0aGVuIGZ1biBzIC0+IE5hdGl2ZWludC5vZl9pbnQzMiAoYml0czMyIHMpXG4gICAgZWxzZSBmdW4gcyAtPiBJbnQ2NC50b19uYXRpdmVpbnQgKGJpdHM2NCBzKVxuXG5lbmRcblxuKCogVGhpcyBpcyB0aGUgc3RhdGUgeW91IGdldCB3aXRoIFtpbml0IDI3MTgyODE4XSBhbmQgdGhlbiBhcHBseWluZ1xuICAgdGhlIFwibGFuZCAweDNGRkZGRkZGXCIgZmlsdGVyIHRvIHRoZW0uICBTZWUgIzU1NzUsICM1NzkzLCAjNTk3Ny4gKilcbmxldCBkZWZhdWx0ID0ge1xuICBTdGF0ZS5zdCA9IFt8XG4gICAgICAweDNhZTI1MjJiOyAweDFkOGQ0NjM0OyAweDE1YjRmYWQwOyAweDE4YjE0YWNlOyAweDEyZjhhM2M0OyAweDNiMDg2YzQ3O1xuICAgICAgMHgxNmQ0NjdkNjsgMHgxMDFkOTFjNzsgMHgzMjFkZjE3NzsgMHgwMTc2YzE5MzsgMHgxZmY3MmJmMTsgMHgxZTg4OTEwOTtcbiAgICAgIDB4MGI0NjRiMTg7IDB4MmI4NmI5N2M7IDB4MDg5MWRhNDg7IDB4MDMxMzc0NjM7IDB4MDg1YWM1YTE7IDB4MTVkNjFmMmY7XG4gICAgICAweDNiY2VkMzU5OyAweDI5YzFjMTMyOyAweDNhODY3NjZlOyAweDM2NmQ4Yzg2OyAweDFmNWI2MjIyOyAweDNjZTFiNTlmO1xuICAgICAgMHgyZWJmNzhlMTsgMHgyN2NkMWI4NjsgMHgyNThmM2RjMzsgMHgzODlhODE5NDsgMHgwMmU0YzQ0YzsgMHgxOGM0M2Y3ZDtcbiAgICAgIDB4MGY2ZTUzNGY7IDB4MWU3ZGYzNTk7IDB4MDU1ZDBiN2U7IDB4MTBlODRlN2U7IDB4MTI2MTk4ZTQ7IDB4MGU3NzIyY2I7XG4gICAgICAweDFjYmVkZTI4OyAweDMzOTFiOTY0OyAweDNkNDBlOTJhOyAweDBjNTk5MzNkOyAweDBiOGNkMGI3OyAweDI0ZWZmZjFjO1xuICAgICAgMHgyODAzZmRhYTsgMHgwOGViYzcyZTsgMHgwZjUyMmUzMjsgMHgwNTM5OGVkYzsgMHgyMTQ0YTA0YzsgMHgwYWVmM2NiZDtcbiAgICAgIDB4MDFhZDQ3MTk7IDB4MzViOTNjZDY7IDB4MmE1NTlkNGY7IDB4MWU2ZmQ3Njg7IDB4MjZlMjdmMzY7IDB4MTg2ZjE4YzM7XG4gICAgICAweDJmYmY5NjdhO1xuICAgIHxdO1xuICBTdGF0ZS5pZHggPSAwO1xufVxuXG5sZXQgYml0cyAoKSA9IFN0YXRlLmJpdHMgZGVmYXVsdFxubGV0IGludCBib3VuZCA9IFN0YXRlLmludCBkZWZhdWx0IGJvdW5kXG5sZXQgZnVsbF9pbnQgYm91bmQgPSBTdGF0ZS5mdWxsX2ludCBkZWZhdWx0IGJvdW5kXG5sZXQgaW50MzIgYm91bmQgPSBTdGF0ZS5pbnQzMiBkZWZhdWx0IGJvdW5kXG5sZXQgbmF0aXZlaW50IGJvdW5kID0gU3RhdGUubmF0aXZlaW50IGRlZmF1bHQgYm91bmRcbmxldCBpbnQ2NCBib3VuZCA9IFN0YXRlLmludDY0IGRlZmF1bHQgYm91bmRcbmxldCBmbG9hdCBzY2FsZSA9IFN0YXRlLmZsb2F0IGRlZmF1bHQgc2NhbGVcbmxldCBib29sICgpID0gU3RhdGUuYm9vbCBkZWZhdWx0XG5sZXQgYml0czMyICgpID0gU3RhdGUuYml0czMyIGRlZmF1bHRcbmxldCBiaXRzNjQgKCkgPSBTdGF0ZS5iaXRzNjQgZGVmYXVsdFxubGV0IG5hdGl2ZWJpdHMgKCkgPSBTdGF0ZS5uYXRpdmViaXRzIGRlZmF1bHRcblxubGV0IGZ1bGxfaW5pdCBzZWVkID0gU3RhdGUuZnVsbF9pbml0IGRlZmF1bHQgc2VlZFxubGV0IGluaXQgc2VlZCA9IFN0YXRlLmZ1bGxfaW5pdCBkZWZhdWx0IFt8IHNlZWQgfF1cbmxldCBzZWxmX2luaXQgKCkgPSBmdWxsX2luaXQgKHJhbmRvbV9zZWVkKCkpXG5cbigqIE1hbmlwdWxhdGluZyB0aGUgY3VycmVudCBzdGF0ZS4gKilcblxubGV0IGdldF9zdGF0ZSAoKSA9IFN0YXRlLmNvcHkgZGVmYXVsdFxubGV0IHNldF9zdGF0ZSBzID0gU3RhdGUuYXNzaWduIGRlZmF1bHQgc1xuXG4oKioqKioqKioqKioqKioqKioqKipcblxuKCogVGVzdCBmdW5jdGlvbnMuICBOb3QgaW5jbHVkZWQgaW4gdGhlIGxpYnJhcnkuXG4gICBUaGUgW2NoaXNxdWFyZV0gZnVuY3Rpb24gc2hvdWxkIGJlIGNhbGxlZCB3aXRoIG4gPiAxMHIuXG4gICBJdCByZXR1cm5zIGEgdHJpcGxlIChsb3csIGFjdHVhbCwgaGlnaCkuXG4gICBJZiBsb3cgPD0gYWN0dWFsIDw9IGhpZ2gsIHRoZSBbZ10gZnVuY3Rpb24gcGFzc2VkIHRoZSB0ZXN0LFxuICAgb3RoZXJ3aXNlIGl0IGZhaWxlZC5cblxuICBTb21lIHJlc3VsdHM6XG5cbmluaXQgMjcxODI4MTg7IGNoaXNxdWFyZSBpbnQgMTAwMDAwIDEwMDBcbmluaXQgMjcxODI4MTg7IGNoaXNxdWFyZSBpbnQgMTAwMDAwIDEwMFxuaW5pdCAyNzE4MjgxODsgY2hpc3F1YXJlIGludCAxMDAwMDAgNTAwMFxuaW5pdCAyNzE4MjgxODsgY2hpc3F1YXJlIGludCAxMDAwMDAwIDEwMDBcbmluaXQgMjcxODI4MTg7IGNoaXNxdWFyZSBpbnQgMTAwMDAwIDEwMjRcbmluaXQgMjk5NzkyNjQzOyBjaGlzcXVhcmUgaW50IDEwMDAwMCAxMDI0XG5pbml0IDE0MTQyMTM2OyBjaGlzcXVhcmUgaW50IDEwMDAwMCAxMDI0XG5pbml0IDI3MTgyODE4OyBpbml0X2RpZmYgMTAyNDsgY2hpc3F1YXJlIGRpZmYgMTAwMDAwIDEwMjRcbmluaXQgMjcxODI4MTg7IGluaXRfZGlmZiAxMDA7IGNoaXNxdWFyZSBkaWZmIDEwMDAwMCAxMDBcbmluaXQgMjcxODI4MTg7IGluaXRfZGlmZjIgMTAyNDsgY2hpc3F1YXJlIGRpZmYyIDEwMDAwMCAxMDI0XG5pbml0IDI3MTgyODE4OyBpbml0X2RpZmYyIDEwMDsgY2hpc3F1YXJlIGRpZmYyIDEwMDAwMCAxMDBcbmluaXQgMTQxNDIxMzY7IGluaXRfZGlmZjIgMTAwOyBjaGlzcXVhcmUgZGlmZjIgMTAwMDAwIDEwMFxuaW5pdCAyOTk3OTI2NDM7IGluaXRfZGlmZjIgMTAwOyBjaGlzcXVhcmUgZGlmZjIgMTAwMDAwIDEwMFxuLSA6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCA9ICg5MzYuNzU0NDQ2Nzk2NjMyNDY1LCA5OTcuNSwgMTA2My4yNDU1NTMyMDMzNjc1NClcbiMgLSA6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCA9ICg4MC4sIDg5Ljc0MDAwMDAwMDAwNTIzODcsIDEyMC4pXG4jIC0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPSAoNDg1OC41Nzg2NDM3NjI2OSwgNTA0NS41LCA1MTQxLjQyMTM1NjIzNzMxKVxuIyAtIDogZmxvYXQgKiBmbG9hdCAqIGZsb2F0ID1cbig5MzYuNzU0NDQ2Nzk2NjMyNDY1LCA5NDQuODA1OTk5OTk5OTgyMzA1LCAxMDYzLjI0NTU1MzIwMzM2NzU0KVxuIyAtIDogZmxvYXQgKiBmbG9hdCAqIGZsb2F0ID0gKDk2MC4sIDEwMTkuMTk3NDQwMDAwMDAzNTUsIDEwODguKVxuIyAtIDogZmxvYXQgKiBmbG9hdCAqIGZsb2F0ID0gKDk2MC4sIDEwNTkuMzE3NzYwMDAwMDA1MzYsIDEwODguKVxuIyAtIDogZmxvYXQgKiBmbG9hdCAqIGZsb2F0ID0gKDk2MC4sIDEwMzkuOTg0NjM5OTk5OTk1MTIsIDEwODguKVxuIyAtIDogZmxvYXQgKiBmbG9hdCAqIGZsb2F0ID0gKDk2MC4sIDEwNTQuMzgyMDc5OTk5OTk1NzcsIDEwODguKVxuIyAtIDogZmxvYXQgKiBmbG9hdCAqIGZsb2F0ID0gKDgwLiwgOTAuMDk2MDAwMDAwMDA1LCAxMjAuKVxuIyAtIDogZmxvYXQgKiBmbG9hdCAqIGZsb2F0ID0gKDk2MC4sIDEwNzYuNzg3MjAwMDAwMDA2MTIsIDEwODguKVxuIyAtIDogZmxvYXQgKiBmbG9hdCAqIGZsb2F0ID0gKDgwLiwgODUuMTc2MDAwMDAwMDA2NzUyMSwgMTIwLilcbiMgLSA6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCA9ICg4MC4sIDg1LjIxNjAwMDAwMDAwMDM0OTIsIDEyMC4pXG4jIC0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPSAoODAuLCA4MC42MjIwMDAwMDAwMDMwMjY4LCAxMjAuKVxuXG4qKVxuXG4oKiBSZXR1cm4gdGhlIHN1bSBvZiB0aGUgc3F1YXJlcyBvZiB2W2kwLGkxWyAqKVxubGV0IHJlYyBzdW1zcSB2IGkwIGkxID1cbiAgaWYgaTAgPj0gaTEgdGhlbiAwLjBcbiAgZWxzZSBpZiBpMSA9IGkwICsgMSB0aGVuIFN0ZGxpYi5mbG9hdCB2LihpMCkgKi4gU3RkbGliLmZsb2F0IHYuKGkwKVxuICBlbHNlIHN1bXNxIHYgaTAgKChpMCtpMSkvMikgKy4gc3Vtc3EgdiAoKGkwK2kxKS8yKSBpMVxuXG5cbmxldCBjaGlzcXVhcmUgZyBuIHIgPVxuICBpZiBuIDw9IDEwICogciB0aGVuIGludmFsaWRfYXJnIFwiY2hpc3F1YXJlXCI7XG4gIGxldCBmID0gQXJyYXkubWFrZSByIDAgaW5cbiAgZm9yIGkgPSAxIHRvIG4gZG9cbiAgICBsZXQgdCA9IGcgciBpblxuICAgIGYuKHQpIDwtIGYuKHQpICsgMVxuICBkb25lO1xuICBsZXQgdCA9IHN1bXNxIGYgMCByXG4gIGFuZCByID0gU3RkbGliLmZsb2F0IHJcbiAgYW5kIG4gPSBTdGRsaWIuZmxvYXQgbiBpblxuICBsZXQgc3IgPSAyLjAgKi4gc3FydCByIGluXG4gIChyIC0uIHNyLCAgIChyICouIHQgLy4gbikgLS4gbiwgICByICsuIHNyKVxuXG5cbigqIFRoaXMgaXMgdG8gdGVzdCBmb3IgbGluZWFyIGRlcGVuZGVuY2llcyBiZXR3ZWVuIHN1Y2Nlc3NpdmUgcmFuZG9tIG51bWJlcnMuXG4qKVxubGV0IHN0ID0gcmVmIDBcbmxldCBpbml0X2RpZmYgciA9IHN0IDo9IGludCByXG5sZXQgZGlmZiByID1cbiAgbGV0IHgxID0gIXN0XG4gIGFuZCB4MiA9IGludCByXG4gIGluXG4gIHN0IDo9IHgyO1xuICBpZiB4MSA+PSB4MiB0aGVuXG4gICAgeDEgLSB4MlxuICBlbHNlXG4gICAgciArIHgxIC0geDJcblxuXG5sZXQgc3QxID0gcmVmIDBcbmFuZCBzdDIgPSByZWYgMFxuXG5cbigqIFRoaXMgaXMgdG8gdGVzdCBmb3IgcXVhZHJhdGljIGRlcGVuZGVuY2llcyBiZXR3ZWVuIHN1Y2Nlc3NpdmUgcmFuZG9tXG4gICBudW1iZXJzLlxuKilcbmxldCBpbml0X2RpZmYyIHIgPSBzdDEgOj0gaW50IHI7IHN0MiA6PSBpbnQgclxubGV0IGRpZmYyIHIgPVxuICBsZXQgeDEgPSAhc3QxXG4gIGFuZCB4MiA9ICFzdDJcbiAgYW5kIHgzID0gaW50IHJcbiAgaW5cbiAgc3QxIDo9IHgyO1xuICBzdDIgOj0geDM7XG4gICh4MyAtIHgyIC0geDIgKyB4MSArIDIqcikgbW9kIHJcblxuXG4qKioqKioqKioqKioqKioqKioqKilcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogSGFzaCB0YWJsZXMgKilcblxuKCogV2UgZG8gZHluYW1pYyBoYXNoaW5nLCBhbmQgcmVzaXplIHRoZSB0YWJsZSBhbmQgcmVoYXNoIHRoZSBlbGVtZW50c1xuICAgd2hlbiBidWNrZXRzIGJlY29tZSB0b28gbG9uZy4gKilcblxudHlwZSAoJ2EsICdiKSB0ID1cbiAgeyBtdXRhYmxlIHNpemU6IGludDsgICAgICAgICAgICAgICAgICAgICAgICAoKiBudW1iZXIgb2YgZW50cmllcyAqKVxuICAgIG11dGFibGUgZGF0YTogKCdhLCAnYikgYnVja2V0bGlzdCBhcnJheTsgICgqIHRoZSBidWNrZXRzICopXG4gICAgc2VlZDogaW50OyAgICAgICAgICAgICAgICAgICAgICAgICgqIGZvciByYW5kb21pemF0aW9uICopXG4gICAgbXV0YWJsZSBpbml0aWFsX3NpemU6IGludDsgICAgICAgICAgICAgICAgKCogaW5pdGlhbCBhcnJheSBzaXplICopXG4gIH1cblxuYW5kICgnYSwgJ2IpIGJ1Y2tldGxpc3QgPVxuICAgIEVtcHR5XG4gIHwgQ29ucyBvZiB7IG11dGFibGUga2V5OiAnYTtcbiAgICAgICAgICAgICAgbXV0YWJsZSBkYXRhOiAnYjtcbiAgICAgICAgICAgICAgbXV0YWJsZSBuZXh0OiAoJ2EsICdiKSBidWNrZXRsaXN0IH1cblxuKCogVGhlIHNpZ24gb2YgaW5pdGlhbF9zaXplIGVuY29kZXMgdGhlIGZhY3QgdGhhdCBhIHRyYXZlcnNhbCBpc1xuICAgb25nb2luZyBvciBub3QuXG5cbiAgIFRoaXMgZGlzYWJsZXMgdGhlIGVmZmljaWVudCBpbiBwbGFjZSBpbXBsZW1lbnRhdGlvbiBvZiByZXNpemluZy5cbiopXG5cbmxldCBvbmdvaW5nX3RyYXZlcnNhbCBoID1cbiAgT2JqLnNpemUgKE9iai5yZXByIGgpIDwgNCAoKiBjb21wYXRpYmlsaXR5IHdpdGggb2xkIGhhc2ggdGFibGVzICopXG4gIHx8IGguaW5pdGlhbF9zaXplIDwgMFxuXG5sZXQgZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoID1cbiAgaC5pbml0aWFsX3NpemUgPC0gLSBoLmluaXRpYWxfc2l6ZVxuXG4oKiBUbyBwaWNrIHJhbmRvbSBzZWVkcyBpZiByZXF1ZXN0ZWQgKilcblxubGV0IHJhbmRvbWl6ZWRfZGVmYXVsdCA9XG4gIGxldCBwYXJhbXMgPVxuICAgIHRyeSBTeXMuZ2V0ZW52IFwiT0NBTUxSVU5QQVJBTVwiIHdpdGggTm90X2ZvdW5kIC0+XG4gICAgdHJ5IFN5cy5nZXRlbnYgXCJDQU1MUlVOUEFSQU1cIiB3aXRoIE5vdF9mb3VuZCAtPiBcIlwiIGluXG4gIFN0cmluZy5jb250YWlucyBwYXJhbXMgJ1InXG5cbmxldCByYW5kb21pemVkID0gcmVmIHJhbmRvbWl6ZWRfZGVmYXVsdFxuXG5sZXQgcmFuZG9taXplICgpID0gcmFuZG9taXplZCA6PSB0cnVlXG5sZXQgaXNfcmFuZG9taXplZCAoKSA9ICFyYW5kb21pemVkXG5cbmxldCBwcm5nID0gbGF6eSAoUmFuZG9tLlN0YXRlLm1ha2Vfc2VsZl9pbml0KCkpXG5cbigqIEZ1bmN0aW9ucyB3aGljaCBhcHBlYXIgYmVmb3JlIHRoZSBmdW5jdG9yaWFsIGludGVyZmFjZSBtdXN0IGVpdGhlciBiZVxuICAgaW5kZXBlbmRlbnQgb2YgdGhlIGhhc2ggZnVuY3Rpb24gb3IgdGFrZSBpdCBhcyBhIHBhcmFtZXRlciAoc2VlICMyMjAyIGFuZFxuICAgY29kZSBiZWxvdyB0aGUgZnVuY3RvciBkZWZpbml0aW9ucy4gKilcblxuKCogQ3JlYXRpbmcgYSBmcmVzaCwgZW1wdHkgdGFibGUgKilcblxubGV0IHJlYyBwb3dlcl8yX2Fib3ZlIHggbiA9XG4gIGlmIHggPj0gbiB0aGVuIHhcbiAgZWxzZSBpZiB4ICogMiA+IFN5cy5tYXhfYXJyYXlfbGVuZ3RoIHRoZW4geFxuICBlbHNlIHBvd2VyXzJfYWJvdmUgKHggKiAyKSBuXG5cbmxldCBjcmVhdGUgPyhyYW5kb20gPSAhcmFuZG9taXplZCkgaW5pdGlhbF9zaXplID1cbiAgbGV0IHMgPSBwb3dlcl8yX2Fib3ZlIDE2IGluaXRpYWxfc2l6ZSBpblxuICBsZXQgc2VlZCA9IGlmIHJhbmRvbSB0aGVuIFJhbmRvbS5TdGF0ZS5iaXRzIChMYXp5LmZvcmNlIHBybmcpIGVsc2UgMCBpblxuICB7IGluaXRpYWxfc2l6ZSA9IHM7IHNpemUgPSAwOyBzZWVkID0gc2VlZDsgZGF0YSA9IEFycmF5Lm1ha2UgcyBFbXB0eSB9XG5cbmxldCBjbGVhciBoID1cbiAgaWYgaC5zaXplID4gMCB0aGVuIGJlZ2luXG4gICAgaC5zaXplIDwtIDA7XG4gICAgQXJyYXkuZmlsbCBoLmRhdGEgMCAoQXJyYXkubGVuZ3RoIGguZGF0YSkgRW1wdHlcbiAgZW5kXG5cbmxldCByZXNldCBoID1cbiAgbGV0IGxlbiA9IEFycmF5Lmxlbmd0aCBoLmRhdGEgaW5cbiAgaWYgT2JqLnNpemUgKE9iai5yZXByIGgpIDwgNCAoKiBjb21wYXRpYmlsaXR5IHdpdGggb2xkIGhhc2ggdGFibGVzICopXG4gICAgfHwgbGVuID0gYWJzIGguaW5pdGlhbF9zaXplIHRoZW5cbiAgICBjbGVhciBoXG4gIGVsc2UgYmVnaW5cbiAgICBoLnNpemUgPC0gMDtcbiAgICBoLmRhdGEgPC0gQXJyYXkubWFrZSAoYWJzIGguaW5pdGlhbF9zaXplKSBFbXB0eVxuICBlbmRcblxubGV0IGNvcHlfYnVja2V0bGlzdCA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT4gRW1wdHlcbiAgfCBDb25zIHtrZXk7IGRhdGE7IG5leHR9IC0+XG4gICAgICBsZXQgcmVjIGxvb3AgcHJlYyA9IGZ1bmN0aW9uXG4gICAgICAgIHwgRW1wdHkgLT4gKClcbiAgICAgICAgfCBDb25zIHtrZXk7IGRhdGE7IG5leHR9IC0+XG4gICAgICAgICAgICBsZXQgciA9IENvbnMge2tleTsgZGF0YTsgbmV4dH0gaW5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIHByZWMgd2l0aFxuICAgICAgICAgICAgfCBFbXB0eSAtPiBhc3NlcnQgZmFsc2VcbiAgICAgICAgICAgIHwgQ29ucyBwcmVjIC0+ICBwcmVjLm5leHQgPC0gclxuICAgICAgICAgICAgZW5kO1xuICAgICAgICAgICAgbG9vcCByIG5leHRcbiAgICAgIGluXG4gICAgICBsZXQgciA9IENvbnMge2tleTsgZGF0YTsgbmV4dH0gaW5cbiAgICAgIGxvb3AgciBuZXh0O1xuICAgICAgclxuXG5sZXQgY29weSBoID0geyBoIHdpdGggZGF0YSA9IEFycmF5Lm1hcCBjb3B5X2J1Y2tldGxpc3QgaC5kYXRhIH1cblxubGV0IGxlbmd0aCBoID0gaC5zaXplXG5cbmxldCBpbnNlcnRfYWxsX2J1Y2tldHMgaW5kZXhmdW4gaW5wbGFjZSBvZGF0YSBuZGF0YSA9XG4gIGxldCBuc2l6ZSA9IEFycmF5Lmxlbmd0aCBuZGF0YSBpblxuICBsZXQgbmRhdGFfdGFpbCA9IEFycmF5Lm1ha2UgbnNpemUgRW1wdHkgaW5cbiAgbGV0IHJlYyBpbnNlcnRfYnVja2V0ID0gZnVuY3Rpb25cbiAgICB8IEVtcHR5IC0+ICgpXG4gICAgfCBDb25zIHtrZXk7IGRhdGE7IG5leHR9IGFzIGNlbGwgLT5cbiAgICAgICAgbGV0IGNlbGwgPVxuICAgICAgICAgIGlmIGlucGxhY2UgdGhlbiBjZWxsXG4gICAgICAgICAgZWxzZSBDb25zIHtrZXk7IGRhdGE7IG5leHQgPSBFbXB0eX1cbiAgICAgICAgaW5cbiAgICAgICAgbGV0IG5pZHggPSBpbmRleGZ1biBrZXkgaW5cbiAgICAgICAgYmVnaW4gbWF0Y2ggbmRhdGFfdGFpbC4obmlkeCkgd2l0aFxuICAgICAgICB8IEVtcHR5IC0+IG5kYXRhLihuaWR4KSA8LSBjZWxsO1xuICAgICAgICB8IENvbnMgdGFpbCAtPiB0YWlsLm5leHQgPC0gY2VsbDtcbiAgICAgICAgZW5kO1xuICAgICAgICBuZGF0YV90YWlsLihuaWR4KSA8LSBjZWxsO1xuICAgICAgICBpbnNlcnRfYnVja2V0IG5leHRcbiAgaW5cbiAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCBvZGF0YSAtIDEgZG9cbiAgICBpbnNlcnRfYnVja2V0IG9kYXRhLihpKVxuICBkb25lO1xuICBpZiBpbnBsYWNlIHRoZW5cbiAgICBmb3IgaSA9IDAgdG8gbnNpemUgLSAxIGRvXG4gICAgICBtYXRjaCBuZGF0YV90YWlsLihpKSB3aXRoXG4gICAgICB8IEVtcHR5IC0+ICgpXG4gICAgICB8IENvbnMgdGFpbCAtPiB0YWlsLm5leHQgPC0gRW1wdHlcbiAgICBkb25lXG5cbmxldCByZXNpemUgaW5kZXhmdW4gaCA9XG4gIGxldCBvZGF0YSA9IGguZGF0YSBpblxuICBsZXQgb3NpemUgPSBBcnJheS5sZW5ndGggb2RhdGEgaW5cbiAgbGV0IG5zaXplID0gb3NpemUgKiAyIGluXG4gIGlmIG5zaXplIDwgU3lzLm1heF9hcnJheV9sZW5ndGggdGhlbiBiZWdpblxuICAgIGxldCBuZGF0YSA9IEFycmF5Lm1ha2UgbnNpemUgRW1wdHkgaW5cbiAgICBsZXQgaW5wbGFjZSA9IG5vdCAob25nb2luZ190cmF2ZXJzYWwgaCkgaW5cbiAgICBoLmRhdGEgPC0gbmRhdGE7ICAgICAgICAgICgqIHNvIHRoYXQgaW5kZXhmdW4gc2VlcyB0aGUgbmV3IGJ1Y2tldCBjb3VudCAqKVxuICAgIGluc2VydF9hbGxfYnVja2V0cyAoaW5kZXhmdW4gaCkgaW5wbGFjZSBvZGF0YSBuZGF0YVxuICBlbmRcblxubGV0IGl0ZXIgZiBoID1cbiAgbGV0IHJlYyBkb19idWNrZXQgPSBmdW5jdGlvblxuICAgIHwgRW1wdHkgLT5cbiAgICAgICAgKClcbiAgICB8IENvbnN7a2V5OyBkYXRhOyBuZXh0fSAtPlxuICAgICAgICBmIGtleSBkYXRhOyBkb19idWNrZXQgbmV4dCBpblxuICBsZXQgb2xkX3RyYXYgPSBvbmdvaW5nX3RyYXZlcnNhbCBoIGluXG4gIGlmIG5vdCBvbGRfdHJhdiB0aGVuIGZsaXBfb25nb2luZ190cmF2ZXJzYWwgaDtcbiAgdHJ5XG4gICAgbGV0IGQgPSBoLmRhdGEgaW5cbiAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGQgLSAxIGRvXG4gICAgICBkb19idWNrZXQgZC4oaSlcbiAgICBkb25lO1xuICAgIGlmIG5vdCBvbGRfdHJhdiB0aGVuIGZsaXBfb25nb2luZ190cmF2ZXJzYWwgaDtcbiAgd2l0aCBleG4gd2hlbiBub3Qgb2xkX3RyYXYgLT5cbiAgICBmbGlwX29uZ29pbmdfdHJhdmVyc2FsIGg7XG4gICAgcmFpc2UgZXhuXG5cbmxldCByZWMgZmlsdGVyX21hcF9pbnBsYWNlX2J1Y2tldCBmIGggaSBwcmVjID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPlxuICAgICAgYmVnaW4gbWF0Y2ggcHJlYyB3aXRoXG4gICAgICB8IEVtcHR5IC0+IGguZGF0YS4oaSkgPC0gRW1wdHlcbiAgICAgIHwgQ29ucyBjIC0+IGMubmV4dCA8LSBFbXB0eVxuICAgICAgZW5kXG4gIHwgKENvbnMgKHtrZXk7IGRhdGE7IG5leHR9IGFzIGMpKSBhcyBzbG90IC0+XG4gICAgICBiZWdpbiBtYXRjaCBmIGtleSBkYXRhIHdpdGhcbiAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgIGguc2l6ZSA8LSBoLnNpemUgLSAxO1xuICAgICAgICAgIGZpbHRlcl9tYXBfaW5wbGFjZV9idWNrZXQgZiBoIGkgcHJlYyBuZXh0XG4gICAgICB8IFNvbWUgZGF0YSAtPlxuICAgICAgICAgIGJlZ2luIG1hdGNoIHByZWMgd2l0aFxuICAgICAgICAgIHwgRW1wdHkgLT4gaC5kYXRhLihpKSA8LSBzbG90XG4gICAgICAgICAgfCBDb25zIGMgLT4gYy5uZXh0IDwtIHNsb3RcbiAgICAgICAgICBlbmQ7XG4gICAgICAgICAgYy5kYXRhIDwtIGRhdGE7XG4gICAgICAgICAgZmlsdGVyX21hcF9pbnBsYWNlX2J1Y2tldCBmIGggaSBzbG90IG5leHRcbiAgICAgIGVuZFxuXG5sZXQgZmlsdGVyX21hcF9pbnBsYWNlIGYgaCA9XG4gIGxldCBkID0gaC5kYXRhIGluXG4gIGxldCBvbGRfdHJhdiA9IG9uZ29pbmdfdHJhdmVyc2FsIGggaW5cbiAgaWYgbm90IG9sZF90cmF2IHRoZW4gZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoO1xuICB0cnlcbiAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGQgLSAxIGRvXG4gICAgICBmaWx0ZXJfbWFwX2lucGxhY2VfYnVja2V0IGYgaCBpIEVtcHR5IGguZGF0YS4oaSlcbiAgICBkb25lO1xuICAgIGlmIG5vdCBvbGRfdHJhdiB0aGVuIGZsaXBfb25nb2luZ190cmF2ZXJzYWwgaFxuICB3aXRoIGV4biB3aGVuIG5vdCBvbGRfdHJhdiAtPlxuICAgIGZsaXBfb25nb2luZ190cmF2ZXJzYWwgaDtcbiAgICByYWlzZSBleG5cblxubGV0IGZvbGQgZiBoIGluaXQgPVxuICBsZXQgcmVjIGRvX2J1Y2tldCBiIGFjY3UgPVxuICAgIG1hdGNoIGIgd2l0aFxuICAgICAgRW1wdHkgLT5cbiAgICAgICAgYWNjdVxuICAgIHwgQ29uc3trZXk7IGRhdGE7IG5leHR9IC0+XG4gICAgICAgIGRvX2J1Y2tldCBuZXh0IChmIGtleSBkYXRhIGFjY3UpIGluXG4gIGxldCBvbGRfdHJhdiA9IG9uZ29pbmdfdHJhdmVyc2FsIGggaW5cbiAgaWYgbm90IG9sZF90cmF2IHRoZW4gZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoO1xuICB0cnlcbiAgICBsZXQgZCA9IGguZGF0YSBpblxuICAgIGxldCBhY2N1ID0gcmVmIGluaXQgaW5cbiAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGQgLSAxIGRvXG4gICAgICBhY2N1IDo9IGRvX2J1Y2tldCBkLihpKSAhYWNjdVxuICAgIGRvbmU7XG4gICAgaWYgbm90IG9sZF90cmF2IHRoZW4gZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoO1xuICAgICFhY2N1XG4gIHdpdGggZXhuIHdoZW4gbm90IG9sZF90cmF2IC0+XG4gICAgZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoO1xuICAgIHJhaXNlIGV4blxuXG50eXBlIHN0YXRpc3RpY3MgPSB7XG4gIG51bV9iaW5kaW5nczogaW50O1xuICBudW1fYnVja2V0czogaW50O1xuICBtYXhfYnVja2V0X2xlbmd0aDogaW50O1xuICBidWNrZXRfaGlzdG9ncmFtOiBpbnQgYXJyYXlcbn1cblxubGV0IHJlYyBidWNrZXRfbGVuZ3RoIGFjY3UgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+IGFjY3VcbiAgfCBDb25ze25leHR9IC0+IGJ1Y2tldF9sZW5ndGggKGFjY3UgKyAxKSBuZXh0XG5cbmxldCBzdGF0cyBoID1cbiAgbGV0IG1ibCA9XG4gICAgQXJyYXkuZm9sZF9sZWZ0IChmdW4gbSBiIC0+IEludC5tYXggbSAoYnVja2V0X2xlbmd0aCAwIGIpKSAwIGguZGF0YSBpblxuICBsZXQgaGlzdG8gPSBBcnJheS5tYWtlIChtYmwgKyAxKSAwIGluXG4gIEFycmF5Lml0ZXJcbiAgICAoZnVuIGIgLT5cbiAgICAgIGxldCBsID0gYnVja2V0X2xlbmd0aCAwIGIgaW5cbiAgICAgIGhpc3RvLihsKSA8LSBoaXN0by4obCkgKyAxKVxuICAgIGguZGF0YTtcbiAgeyBudW1fYmluZGluZ3MgPSBoLnNpemU7XG4gICAgbnVtX2J1Y2tldHMgPSBBcnJheS5sZW5ndGggaC5kYXRhO1xuICAgIG1heF9idWNrZXRfbGVuZ3RoID0gbWJsO1xuICAgIGJ1Y2tldF9oaXN0b2dyYW0gPSBoaXN0byB9XG5cbigqKiB7MSBJdGVyYXRvcnN9ICopXG5cbmxldCB0b19zZXEgdGJsID1cbiAgKCogY2FwdHVyZSBjdXJyZW50IGFycmF5LCBzbyB0aGF0IGV2ZW4gaWYgdGhlIHRhYmxlIGlzIHJlc2l6ZWQgd2VcbiAgICAga2VlcCBpdGVyYXRpbmcgb24gdGhlIHNhbWUgYXJyYXkgKilcbiAgbGV0IHRibF9kYXRhID0gdGJsLmRhdGEgaW5cbiAgKCogc3RhdGU6IGluZGV4ICogbmV4dCBidWNrZXQgdG8gdHJhdmVyc2UgKilcbiAgbGV0IHJlYyBhdXggaSBidWNrICgpID0gbWF0Y2ggYnVjayB3aXRoXG4gICAgfCBFbXB0eSAtPlxuICAgICAgICBpZiBpID0gQXJyYXkubGVuZ3RoIHRibF9kYXRhXG4gICAgICAgIHRoZW4gU2VxLk5pbFxuICAgICAgICBlbHNlIGF1eChpKzEpIHRibF9kYXRhLihpKSAoKVxuICAgIHwgQ29ucyB7a2V5OyBkYXRhOyBuZXh0fSAtPlxuICAgICAgICBTZXEuQ29ucyAoKGtleSwgZGF0YSksIGF1eCBpIG5leHQpXG4gIGluXG4gIGF1eCAwIEVtcHR5XG5cbmxldCB0b19zZXFfa2V5cyBtID0gU2VxLm1hcCBmc3QgKHRvX3NlcSBtKVxuXG5sZXQgdG9fc2VxX3ZhbHVlcyBtID0gU2VxLm1hcCBzbmQgKHRvX3NlcSBtKVxuXG4oKiBGdW5jdG9yaWFsIGludGVyZmFjZSAqKVxuXG5tb2R1bGUgdHlwZSBIYXNoZWRUeXBlID1cbiAgc2lnXG4gICAgdHlwZSB0XG4gICAgdmFsIGVxdWFsOiB0IC0+IHQgLT4gYm9vbFxuICAgIHZhbCBoYXNoOiB0IC0+IGludFxuICBlbmRcblxubW9kdWxlIHR5cGUgU2VlZGVkSGFzaGVkVHlwZSA9XG4gIHNpZ1xuICAgIHR5cGUgdFxuICAgIHZhbCBlcXVhbDogdCAtPiB0IC0+IGJvb2xcbiAgICB2YWwgaGFzaDogaW50IC0+IHQgLT4gaW50XG4gIGVuZFxuXG5tb2R1bGUgdHlwZSBTID1cbiAgc2lnXG4gICAgdHlwZSBrZXlcbiAgICB0eXBlICEnYSB0XG4gICAgdmFsIGNyZWF0ZTogaW50IC0+ICdhIHRcbiAgICB2YWwgY2xlYXIgOiAnYSB0IC0+IHVuaXRcbiAgICB2YWwgcmVzZXQgOiAnYSB0IC0+IHVuaXRcbiAgICB2YWwgY29weTogJ2EgdCAtPiAnYSB0XG4gICAgdmFsIGFkZDogJ2EgdCAtPiBrZXkgLT4gJ2EgLT4gdW5pdFxuICAgIHZhbCByZW1vdmU6ICdhIHQgLT4ga2V5IC0+IHVuaXRcbiAgICB2YWwgZmluZDogJ2EgdCAtPiBrZXkgLT4gJ2FcbiAgICB2YWwgZmluZF9vcHQ6ICdhIHQgLT4ga2V5IC0+ICdhIG9wdGlvblxuICAgIHZhbCBmaW5kX2FsbDogJ2EgdCAtPiBrZXkgLT4gJ2EgbGlzdFxuICAgIHZhbCByZXBsYWNlIDogJ2EgdCAtPiBrZXkgLT4gJ2EgLT4gdW5pdFxuICAgIHZhbCBtZW0gOiAnYSB0IC0+IGtleSAtPiBib29sXG4gICAgdmFsIGl0ZXI6IChrZXkgLT4gJ2EgLT4gdW5pdCkgLT4gJ2EgdCAtPiB1bml0XG4gICAgdmFsIGZpbHRlcl9tYXBfaW5wbGFjZTogKGtleSAtPiAnYSAtPiAnYSBvcHRpb24pIC0+ICdhIHQgLT4gdW5pdFxuICAgIHZhbCBmb2xkOiAoa2V5IC0+ICdhIC0+ICdiIC0+ICdiKSAtPiAnYSB0IC0+ICdiIC0+ICdiXG4gICAgdmFsIGxlbmd0aDogJ2EgdCAtPiBpbnRcbiAgICB2YWwgc3RhdHM6ICdhIHQgLT4gc3RhdGlzdGljc1xuICAgIHZhbCB0b19zZXEgOiAnYSB0IC0+IChrZXkgKiAnYSkgU2VxLnRcbiAgICB2YWwgdG9fc2VxX2tleXMgOiBfIHQgLT4ga2V5IFNlcS50XG4gICAgdmFsIHRvX3NlcV92YWx1ZXMgOiAnYSB0IC0+ICdhIFNlcS50XG4gICAgdmFsIGFkZF9zZXEgOiAnYSB0IC0+IChrZXkgKiAnYSkgU2VxLnQgLT4gdW5pdFxuICAgIHZhbCByZXBsYWNlX3NlcSA6ICdhIHQgLT4gKGtleSAqICdhKSBTZXEudCAtPiB1bml0XG4gICAgdmFsIG9mX3NlcSA6IChrZXkgKiAnYSkgU2VxLnQgLT4gJ2EgdFxuICBlbmRcblxubW9kdWxlIHR5cGUgU2VlZGVkUyA9XG4gIHNpZ1xuICAgIHR5cGUga2V5XG4gICAgdHlwZSAhJ2EgdFxuICAgIHZhbCBjcmVhdGUgOiA/cmFuZG9tOmJvb2wgLT4gaW50IC0+ICdhIHRcbiAgICB2YWwgY2xlYXIgOiAnYSB0IC0+IHVuaXRcbiAgICB2YWwgcmVzZXQgOiAnYSB0IC0+IHVuaXRcbiAgICB2YWwgY29weSA6ICdhIHQgLT4gJ2EgdFxuICAgIHZhbCBhZGQgOiAnYSB0IC0+IGtleSAtPiAnYSAtPiB1bml0XG4gICAgdmFsIHJlbW92ZSA6ICdhIHQgLT4ga2V5IC0+IHVuaXRcbiAgICB2YWwgZmluZCA6ICdhIHQgLT4ga2V5IC0+ICdhXG4gICAgdmFsIGZpbmRfb3B0OiAnYSB0IC0+IGtleSAtPiAnYSBvcHRpb25cbiAgICB2YWwgZmluZF9hbGwgOiAnYSB0IC0+IGtleSAtPiAnYSBsaXN0XG4gICAgdmFsIHJlcGxhY2UgOiAnYSB0IC0+IGtleSAtPiAnYSAtPiB1bml0XG4gICAgdmFsIG1lbSA6ICdhIHQgLT4ga2V5IC0+IGJvb2xcbiAgICB2YWwgaXRlciA6IChrZXkgLT4gJ2EgLT4gdW5pdCkgLT4gJ2EgdCAtPiB1bml0XG4gICAgdmFsIGZpbHRlcl9tYXBfaW5wbGFjZTogKGtleSAtPiAnYSAtPiAnYSBvcHRpb24pIC0+ICdhIHQgLT4gdW5pdFxuICAgIHZhbCBmb2xkIDogKGtleSAtPiAnYSAtPiAnYiAtPiAnYikgLT4gJ2EgdCAtPiAnYiAtPiAnYlxuICAgIHZhbCBsZW5ndGggOiAnYSB0IC0+IGludFxuICAgIHZhbCBzdGF0czogJ2EgdCAtPiBzdGF0aXN0aWNzXG4gICAgdmFsIHRvX3NlcSA6ICdhIHQgLT4gKGtleSAqICdhKSBTZXEudFxuICAgIHZhbCB0b19zZXFfa2V5cyA6IF8gdCAtPiBrZXkgU2VxLnRcbiAgICB2YWwgdG9fc2VxX3ZhbHVlcyA6ICdhIHQgLT4gJ2EgU2VxLnRcbiAgICB2YWwgYWRkX3NlcSA6ICdhIHQgLT4gKGtleSAqICdhKSBTZXEudCAtPiB1bml0XG4gICAgdmFsIHJlcGxhY2Vfc2VxIDogJ2EgdCAtPiAoa2V5ICogJ2EpIFNlcS50IC0+IHVuaXRcbiAgICB2YWwgb2Zfc2VxIDogKGtleSAqICdhKSBTZXEudCAtPiAnYSB0XG4gIGVuZFxuXG5tb2R1bGUgTWFrZVNlZWRlZChIOiBTZWVkZWRIYXNoZWRUeXBlKTogKFNlZWRlZFMgd2l0aCB0eXBlIGtleSA9IEgudCkgPVxuICBzdHJ1Y3RcbiAgICB0eXBlIGtleSA9IEgudFxuICAgIHR5cGUgJ2EgaGFzaHRibCA9IChrZXksICdhKSB0XG4gICAgdHlwZSAnYSB0ID0gJ2EgaGFzaHRibFxuICAgIGxldCBjcmVhdGUgPSBjcmVhdGVcbiAgICBsZXQgY2xlYXIgPSBjbGVhclxuICAgIGxldCByZXNldCA9IHJlc2V0XG4gICAgbGV0IGNvcHkgPSBjb3B5XG5cbiAgICBsZXQga2V5X2luZGV4IGgga2V5ID1cbiAgICAgIChILmhhc2ggaC5zZWVkIGtleSkgbGFuZCAoQXJyYXkubGVuZ3RoIGguZGF0YSAtIDEpXG5cbiAgICBsZXQgYWRkIGgga2V5IGRhdGEgPVxuICAgICAgbGV0IGkgPSBrZXlfaW5kZXggaCBrZXkgaW5cbiAgICAgIGxldCBidWNrZXQgPSBDb25ze2tleTsgZGF0YTsgbmV4dD1oLmRhdGEuKGkpfSBpblxuICAgICAgaC5kYXRhLihpKSA8LSBidWNrZXQ7XG4gICAgICBoLnNpemUgPC0gaC5zaXplICsgMTtcbiAgICAgIGlmIGguc2l6ZSA+IEFycmF5Lmxlbmd0aCBoLmRhdGEgbHNsIDEgdGhlbiByZXNpemUga2V5X2luZGV4IGhcblxuICAgIGxldCByZWMgcmVtb3ZlX2J1Y2tldCBoIGkga2V5IHByZWMgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgICgpXG4gICAgICB8IChDb25zIHtrZXk9azsgbmV4dH0pIGFzIGMgLT5cbiAgICAgICAgICBpZiBILmVxdWFsIGsga2V5XG4gICAgICAgICAgdGhlbiBiZWdpblxuICAgICAgICAgICAgaC5zaXplIDwtIGguc2l6ZSAtIDE7XG4gICAgICAgICAgICBtYXRjaCBwcmVjIHdpdGhcbiAgICAgICAgICAgIHwgRW1wdHkgLT4gaC5kYXRhLihpKSA8LSBuZXh0XG4gICAgICAgICAgICB8IENvbnMgYyAtPiBjLm5leHQgPC0gbmV4dFxuICAgICAgICAgIGVuZFxuICAgICAgICAgIGVsc2UgcmVtb3ZlX2J1Y2tldCBoIGkga2V5IGMgbmV4dFxuXG4gICAgbGV0IHJlbW92ZSBoIGtleSA9XG4gICAgICBsZXQgaSA9IGtleV9pbmRleCBoIGtleSBpblxuICAgICAgcmVtb3ZlX2J1Y2tldCBoIGkga2V5IEVtcHR5IGguZGF0YS4oaSlcblxuICAgIGxldCByZWMgZmluZF9yZWMga2V5ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgQ29uc3trZXk9azsgZGF0YTsgbmV4dH0gLT5cbiAgICAgICAgICBpZiBILmVxdWFsIGtleSBrIHRoZW4gZGF0YSBlbHNlIGZpbmRfcmVjIGtleSBuZXh0XG5cbiAgICBsZXQgZmluZCBoIGtleSA9XG4gICAgICBtYXRjaCBoLmRhdGEuKGtleV9pbmRleCBoIGtleSkgd2l0aFxuICAgICAgfCBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgQ29uc3trZXk9azE7IGRhdGE9ZDE7IG5leHQ9bmV4dDF9IC0+XG4gICAgICAgICAgaWYgSC5lcXVhbCBrZXkgazEgdGhlbiBkMSBlbHNlXG4gICAgICAgICAgbWF0Y2ggbmV4dDEgd2l0aFxuICAgICAgICAgIHwgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICAgICAgfCBDb25ze2tleT1rMjsgZGF0YT1kMjsgbmV4dD1uZXh0Mn0gLT5cbiAgICAgICAgICAgICAgaWYgSC5lcXVhbCBrZXkgazIgdGhlbiBkMiBlbHNlXG4gICAgICAgICAgICAgIG1hdGNoIG5leHQyIHdpdGhcbiAgICAgICAgICAgICAgfCBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgICAgICAgICAgfCBDb25ze2tleT1rMzsgZGF0YT1kMzsgbmV4dD1uZXh0M30gLT5cbiAgICAgICAgICAgICAgICAgIGlmIEguZXF1YWwga2V5IGszIHRoZW4gZDMgZWxzZSBmaW5kX3JlYyBrZXkgbmV4dDNcblxuICAgIGxldCByZWMgZmluZF9yZWNfb3B0IGtleSA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgTm9uZVxuICAgICAgfCBDb25ze2tleT1rOyBkYXRhOyBuZXh0fSAtPlxuICAgICAgICAgIGlmIEguZXF1YWwga2V5IGsgdGhlbiBTb21lIGRhdGEgZWxzZSBmaW5kX3JlY19vcHQga2V5IG5leHRcblxuICAgIGxldCBmaW5kX29wdCBoIGtleSA9XG4gICAgICBtYXRjaCBoLmRhdGEuKGtleV9pbmRleCBoIGtleSkgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBOb25lXG4gICAgICB8IENvbnN7a2V5PWsxOyBkYXRhPWQxOyBuZXh0PW5leHQxfSAtPlxuICAgICAgICAgIGlmIEguZXF1YWwga2V5IGsxIHRoZW4gU29tZSBkMSBlbHNlXG4gICAgICAgICAgbWF0Y2ggbmV4dDEgd2l0aFxuICAgICAgICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgICAgICAgIHwgQ29uc3trZXk9azI7IGRhdGE9ZDI7IG5leHQ9bmV4dDJ9IC0+XG4gICAgICAgICAgICAgIGlmIEguZXF1YWwga2V5IGsyIHRoZW4gU29tZSBkMiBlbHNlXG4gICAgICAgICAgICAgIG1hdGNoIG5leHQyIHdpdGhcbiAgICAgICAgICAgICAgfCBFbXB0eSAtPiBOb25lXG4gICAgICAgICAgICAgIHwgQ29uc3trZXk9azM7IGRhdGE9ZDM7IG5leHQ9bmV4dDN9IC0+XG4gICAgICAgICAgICAgICAgICBpZiBILmVxdWFsIGtleSBrMyB0aGVuIFNvbWUgZDMgZWxzZSBmaW5kX3JlY19vcHQga2V5IG5leHQzXG5cbiAgICBsZXQgZmluZF9hbGwgaCBrZXkgPVxuICAgICAgbGV0IHJlYyBmaW5kX2luX2J1Y2tldCA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgW11cbiAgICAgIHwgQ29uc3trZXk9azsgZGF0YT1kOyBuZXh0fSAtPlxuICAgICAgICAgIGlmIEguZXF1YWwgayBrZXlcbiAgICAgICAgICB0aGVuIGQgOjogZmluZF9pbl9idWNrZXQgbmV4dFxuICAgICAgICAgIGVsc2UgZmluZF9pbl9idWNrZXQgbmV4dCBpblxuICAgICAgZmluZF9pbl9idWNrZXQgaC5kYXRhLihrZXlfaW5kZXggaCBrZXkpXG5cbiAgICBsZXQgcmVjIHJlcGxhY2VfYnVja2V0IGtleSBkYXRhID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICB0cnVlXG4gICAgICB8IENvbnMgKHtrZXk9azsgbmV4dH0gYXMgc2xvdCkgLT5cbiAgICAgICAgICBpZiBILmVxdWFsIGsga2V5XG4gICAgICAgICAgdGhlbiAoc2xvdC5rZXkgPC0ga2V5OyBzbG90LmRhdGEgPC0gZGF0YTsgZmFsc2UpXG4gICAgICAgICAgZWxzZSByZXBsYWNlX2J1Y2tldCBrZXkgZGF0YSBuZXh0XG5cbiAgICBsZXQgcmVwbGFjZSBoIGtleSBkYXRhID1cbiAgICAgIGxldCBpID0ga2V5X2luZGV4IGgga2V5IGluXG4gICAgICBsZXQgbCA9IGguZGF0YS4oaSkgaW5cbiAgICAgIGlmIHJlcGxhY2VfYnVja2V0IGtleSBkYXRhIGwgdGhlbiBiZWdpblxuICAgICAgICBoLmRhdGEuKGkpIDwtIENvbnN7a2V5OyBkYXRhOyBuZXh0PWx9O1xuICAgICAgICBoLnNpemUgPC0gaC5zaXplICsgMTtcbiAgICAgICAgaWYgaC5zaXplID4gQXJyYXkubGVuZ3RoIGguZGF0YSBsc2wgMSB0aGVuIHJlc2l6ZSBrZXlfaW5kZXggaFxuICAgICAgZW5kXG5cbiAgICBsZXQgbWVtIGgga2V5ID1cbiAgICAgIGxldCByZWMgbWVtX2luX2J1Y2tldCA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgZmFsc2VcbiAgICAgIHwgQ29uc3trZXk9azsgbmV4dH0gLT5cbiAgICAgICAgICBILmVxdWFsIGsga2V5IHx8IG1lbV9pbl9idWNrZXQgbmV4dCBpblxuICAgICAgbWVtX2luX2J1Y2tldCBoLmRhdGEuKGtleV9pbmRleCBoIGtleSlcblxuICAgIGxldCBhZGRfc2VxIHRibCBpID1cbiAgICAgIFNlcS5pdGVyIChmdW4gKGssdikgLT4gYWRkIHRibCBrIHYpIGlcblxuICAgIGxldCByZXBsYWNlX3NlcSB0YmwgaSA9XG4gICAgICBTZXEuaXRlciAoZnVuIChrLHYpIC0+IHJlcGxhY2UgdGJsIGsgdikgaVxuXG4gICAgbGV0IG9mX3NlcSBpID1cbiAgICAgIGxldCB0YmwgPSBjcmVhdGUgMTYgaW5cbiAgICAgIHJlcGxhY2Vfc2VxIHRibCBpO1xuICAgICAgdGJsXG5cbiAgICBsZXQgaXRlciA9IGl0ZXJcbiAgICBsZXQgZmlsdGVyX21hcF9pbnBsYWNlID0gZmlsdGVyX21hcF9pbnBsYWNlXG4gICAgbGV0IGZvbGQgPSBmb2xkXG4gICAgbGV0IGxlbmd0aCA9IGxlbmd0aFxuICAgIGxldCBzdGF0cyA9IHN0YXRzXG4gICAgbGV0IHRvX3NlcSA9IHRvX3NlcVxuICAgIGxldCB0b19zZXFfa2V5cyA9IHRvX3NlcV9rZXlzXG4gICAgbGV0IHRvX3NlcV92YWx1ZXMgPSB0b19zZXFfdmFsdWVzXG4gIGVuZFxuXG5tb2R1bGUgTWFrZShIOiBIYXNoZWRUeXBlKTogKFMgd2l0aCB0eXBlIGtleSA9IEgudCkgPVxuICBzdHJ1Y3RcbiAgICBpbmNsdWRlIE1ha2VTZWVkZWQoc3RydWN0XG4gICAgICAgIHR5cGUgdCA9IEgudFxuICAgICAgICBsZXQgZXF1YWwgPSBILmVxdWFsXG4gICAgICAgIGxldCBoYXNoIChfc2VlZDogaW50KSB4ID0gSC5oYXNoIHhcbiAgICAgIGVuZClcbiAgICBsZXQgY3JlYXRlIHN6ID0gY3JlYXRlIH5yYW5kb206ZmFsc2Ugc3pcbiAgICBsZXQgb2Zfc2VxIGkgPVxuICAgICAgbGV0IHRibCA9IGNyZWF0ZSAxNiBpblxuICAgICAgcmVwbGFjZV9zZXEgdGJsIGk7XG4gICAgICB0YmxcbiAgZW5kXG5cbigqIFBvbHltb3JwaGljIGhhc2ggZnVuY3Rpb24tYmFzZWQgdGFibGVzICopXG4oKiBDb2RlIGluY2x1ZGVkIGJlbG93IHRoZSBmdW5jdG9yaWFsIGludGVyZmFjZSB0byBndWFyZCBhZ2FpbnN0IGFjY2lkZW50YWxcbiAgIHVzZSAtIHNlZSAjMjIwMiAqKVxuXG5leHRlcm5hbCBzZWVkZWRfaGFzaF9wYXJhbSA6XG4gIGludCAtPiBpbnQgLT4gaW50IC0+ICdhIC0+IGludCA9IFwiY2FtbF9oYXNoXCIgW0BAbm9hbGxvY11cblxubGV0IGhhc2ggeCA9IHNlZWRlZF9oYXNoX3BhcmFtIDEwIDEwMCAwIHhcbmxldCBoYXNoX3BhcmFtIG4xIG4yIHggPSBzZWVkZWRfaGFzaF9wYXJhbSBuMSBuMiAwIHhcbmxldCBzZWVkZWRfaGFzaCBzZWVkIHggPSBzZWVkZWRfaGFzaF9wYXJhbSAxMCAxMDAgc2VlZCB4XG5cbmxldCBrZXlfaW5kZXggaCBrZXkgPVxuICBpZiBPYmouc2l6ZSAoT2JqLnJlcHIgaCkgPj0gNFxuICB0aGVuIChzZWVkZWRfaGFzaF9wYXJhbSAxMCAxMDAgaC5zZWVkIGtleSkgbGFuZCAoQXJyYXkubGVuZ3RoIGguZGF0YSAtIDEpXG4gIGVsc2UgaW52YWxpZF9hcmcgXCJIYXNodGJsOiB1bnN1cHBvcnRlZCBoYXNoIHRhYmxlIGZvcm1hdFwiXG5cbmxldCBhZGQgaCBrZXkgZGF0YSA9XG4gIGxldCBpID0ga2V5X2luZGV4IGgga2V5IGluXG4gIGxldCBidWNrZXQgPSBDb25ze2tleTsgZGF0YTsgbmV4dD1oLmRhdGEuKGkpfSBpblxuICBoLmRhdGEuKGkpIDwtIGJ1Y2tldDtcbiAgaC5zaXplIDwtIGguc2l6ZSArIDE7XG4gIGlmIGguc2l6ZSA+IEFycmF5Lmxlbmd0aCBoLmRhdGEgbHNsIDEgdGhlbiByZXNpemUga2V5X2luZGV4IGhcblxubGV0IHJlYyByZW1vdmVfYnVja2V0IGggaSBrZXkgcHJlYyA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT5cbiAgICAgICgpXG4gIHwgKENvbnMge2tleT1rOyBuZXh0fSkgYXMgYyAtPlxuICAgICAgaWYgY29tcGFyZSBrIGtleSA9IDBcbiAgICAgIHRoZW4gYmVnaW5cbiAgICAgICAgaC5zaXplIDwtIGguc2l6ZSAtIDE7XG4gICAgICAgIG1hdGNoIHByZWMgd2l0aFxuICAgICAgICB8IEVtcHR5IC0+IGguZGF0YS4oaSkgPC0gbmV4dFxuICAgICAgICB8IENvbnMgYyAtPiBjLm5leHQgPC0gbmV4dFxuICAgICAgZW5kXG4gICAgICBlbHNlIHJlbW92ZV9idWNrZXQgaCBpIGtleSBjIG5leHRcblxubGV0IHJlbW92ZSBoIGtleSA9XG4gIGxldCBpID0ga2V5X2luZGV4IGgga2V5IGluXG4gIHJlbW92ZV9idWNrZXQgaCBpIGtleSBFbXB0eSBoLmRhdGEuKGkpXG5cbmxldCByZWMgZmluZF9yZWMga2V5ID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPlxuICAgICAgcmFpc2UgTm90X2ZvdW5kXG4gIHwgQ29uc3trZXk9azsgZGF0YTsgbmV4dH0gLT5cbiAgICAgIGlmIGNvbXBhcmUga2V5IGsgPSAwIHRoZW4gZGF0YSBlbHNlIGZpbmRfcmVjIGtleSBuZXh0XG5cbmxldCBmaW5kIGgga2V5ID1cbiAgbWF0Y2ggaC5kYXRhLihrZXlfaW5kZXggaCBrZXkpIHdpdGhcbiAgfCBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgfCBDb25ze2tleT1rMTsgZGF0YT1kMTsgbmV4dD1uZXh0MX0gLT5cbiAgICAgIGlmIGNvbXBhcmUga2V5IGsxID0gMCB0aGVuIGQxIGVsc2VcbiAgICAgIG1hdGNoIG5leHQxIHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IENvbnN7a2V5PWsyOyBkYXRhPWQyOyBuZXh0PW5leHQyfSAtPlxuICAgICAgICAgIGlmIGNvbXBhcmUga2V5IGsyID0gMCB0aGVuIGQyIGVsc2VcbiAgICAgICAgICBtYXRjaCBuZXh0MiB3aXRoXG4gICAgICAgICAgfCBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgICAgICB8IENvbnN7a2V5PWszOyBkYXRhPWQzOyBuZXh0PW5leHQzfSAtPlxuICAgICAgICAgICAgICBpZiBjb21wYXJlIGtleSBrMyA9IDAgdGhlbiBkMyBlbHNlIGZpbmRfcmVjIGtleSBuZXh0M1xuXG5sZXQgcmVjIGZpbmRfcmVjX29wdCBrZXkgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+XG4gICAgICBOb25lXG4gIHwgQ29uc3trZXk9azsgZGF0YTsgbmV4dH0gLT5cbiAgICAgIGlmIGNvbXBhcmUga2V5IGsgPSAwIHRoZW4gU29tZSBkYXRhIGVsc2UgZmluZF9yZWNfb3B0IGtleSBuZXh0XG5cbmxldCBmaW5kX29wdCBoIGtleSA9XG4gIG1hdGNoIGguZGF0YS4oa2V5X2luZGV4IGgga2V5KSB3aXRoXG4gIHwgRW1wdHkgLT4gTm9uZVxuICB8IENvbnN7a2V5PWsxOyBkYXRhPWQxOyBuZXh0PW5leHQxfSAtPlxuICAgICAgaWYgY29tcGFyZSBrZXkgazEgPSAwIHRoZW4gU29tZSBkMSBlbHNlXG4gICAgICBtYXRjaCBuZXh0MSB3aXRoXG4gICAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICAgIHwgQ29uc3trZXk9azI7IGRhdGE9ZDI7IG5leHQ9bmV4dDJ9IC0+XG4gICAgICAgICAgaWYgY29tcGFyZSBrZXkgazIgPSAwIHRoZW4gU29tZSBkMiBlbHNlXG4gICAgICAgICAgbWF0Y2ggbmV4dDIgd2l0aFxuICAgICAgICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgICAgICAgIHwgQ29uc3trZXk9azM7IGRhdGE9ZDM7IG5leHQ9bmV4dDN9IC0+XG4gICAgICAgICAgICAgIGlmIGNvbXBhcmUga2V5IGszID0gMCB0aGVuIFNvbWUgZDMgZWxzZSBmaW5kX3JlY19vcHQga2V5IG5leHQzXG5cbmxldCBmaW5kX2FsbCBoIGtleSA9XG4gIGxldCByZWMgZmluZF9pbl9idWNrZXQgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+XG4gICAgICBbXVxuICB8IENvbnN7a2V5PWs7IGRhdGE7IG5leHR9IC0+XG4gICAgICBpZiBjb21wYXJlIGsga2V5ID0gMFxuICAgICAgdGhlbiBkYXRhIDo6IGZpbmRfaW5fYnVja2V0IG5leHRcbiAgICAgIGVsc2UgZmluZF9pbl9idWNrZXQgbmV4dCBpblxuICBmaW5kX2luX2J1Y2tldCBoLmRhdGEuKGtleV9pbmRleCBoIGtleSlcblxubGV0IHJlYyByZXBsYWNlX2J1Y2tldCBrZXkgZGF0YSA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT5cbiAgICAgIHRydWVcbiAgfCBDb25zICh7a2V5PWs7IG5leHR9IGFzIHNsb3QpIC0+XG4gICAgICBpZiBjb21wYXJlIGsga2V5ID0gMFxuICAgICAgdGhlbiAoc2xvdC5rZXkgPC0ga2V5OyBzbG90LmRhdGEgPC0gZGF0YTsgZmFsc2UpXG4gICAgICBlbHNlIHJlcGxhY2VfYnVja2V0IGtleSBkYXRhIG5leHRcblxubGV0IHJlcGxhY2UgaCBrZXkgZGF0YSA9XG4gIGxldCBpID0ga2V5X2luZGV4IGgga2V5IGluXG4gIGxldCBsID0gaC5kYXRhLihpKSBpblxuICBpZiByZXBsYWNlX2J1Y2tldCBrZXkgZGF0YSBsIHRoZW4gYmVnaW5cbiAgICBoLmRhdGEuKGkpIDwtIENvbnN7a2V5OyBkYXRhOyBuZXh0PWx9O1xuICAgIGguc2l6ZSA8LSBoLnNpemUgKyAxO1xuICAgIGlmIGguc2l6ZSA+IEFycmF5Lmxlbmd0aCBoLmRhdGEgbHNsIDEgdGhlbiByZXNpemUga2V5X2luZGV4IGhcbiAgZW5kXG5cbmxldCBtZW0gaCBrZXkgPVxuICBsZXQgcmVjIG1lbV9pbl9idWNrZXQgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+XG4gICAgICBmYWxzZVxuICB8IENvbnN7a2V5PWs7IG5leHR9IC0+XG4gICAgICBjb21wYXJlIGsga2V5ID0gMCB8fCBtZW1faW5fYnVja2V0IG5leHQgaW5cbiAgbWVtX2luX2J1Y2tldCBoLmRhdGEuKGtleV9pbmRleCBoIGtleSlcblxubGV0IGFkZF9zZXEgdGJsIGkgPVxuICBTZXEuaXRlciAoZnVuIChrLHYpIC0+IGFkZCB0YmwgayB2KSBpXG5cbmxldCByZXBsYWNlX3NlcSB0YmwgaSA9XG4gIFNlcS5pdGVyIChmdW4gKGssdikgLT4gcmVwbGFjZSB0YmwgayB2KSBpXG5cbmxldCBvZl9zZXEgaSA9XG4gIGxldCB0YmwgPSBjcmVhdGUgMTYgaW5cbiAgcmVwbGFjZV9zZXEgdGJsIGk7XG4gIHRibFxuXG5sZXQgcmVidWlsZCA/KHJhbmRvbSA9ICFyYW5kb21pemVkKSBoID1cbiAgbGV0IHMgPSBwb3dlcl8yX2Fib3ZlIDE2IChBcnJheS5sZW5ndGggaC5kYXRhKSBpblxuICBsZXQgc2VlZCA9XG4gICAgaWYgcmFuZG9tIHRoZW4gUmFuZG9tLlN0YXRlLmJpdHMgKExhenkuZm9yY2UgcHJuZylcbiAgICBlbHNlIGlmIE9iai5zaXplIChPYmoucmVwciBoKSA+PSA0IHRoZW4gaC5zZWVkXG4gICAgZWxzZSAwIGluXG4gIGxldCBoJyA9IHtcbiAgICBzaXplID0gaC5zaXplO1xuICAgIGRhdGEgPSBBcnJheS5tYWtlIHMgRW1wdHk7XG4gICAgc2VlZCA9IHNlZWQ7XG4gICAgaW5pdGlhbF9zaXplID0gaWYgT2JqLnNpemUgKE9iai5yZXByIGgpID49IDQgdGhlbiBoLmluaXRpYWxfc2l6ZSBlbHNlIHNcbiAgfSBpblxuICBpbnNlcnRfYWxsX2J1Y2tldHMgKGtleV9pbmRleCBoJykgZmFsc2UgaC5kYXRhIGgnLmRhdGE7XG4gIGgnXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBEYW1pZW4gRG9saWdleiwgcHJvamV0IFBhcmEsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk3IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqKiBXZWFrIGFycmF5IG9wZXJhdGlvbnMgKilcblxudHlwZSAhJ2EgdFxuXG5leHRlcm5hbCBjcmVhdGUgOiBpbnQgLT4gJ2EgdCA9IFwiY2FtbF93ZWFrX2NyZWF0ZVwiXG5cbmxldCBjcmVhdGUgbCA9XG4gIGlmIG5vdCAoMCA8PSBsICYmIGwgPD0gT2JqLkVwaGVtZXJvbi5tYXhfZXBoZV9sZW5ndGgpIHRoZW5cbiAgICBpbnZhbGlkX2FyZyhcIldlYWsuY3JlYXRlXCIpO1xuICBjcmVhdGUgbFxuXG4oKiogbnVtYmVyIG9mIGFkZGl0aW9uYWwgdmFsdWVzIGluIGEgd2VhayBwb2ludGVyICopXG5sZXQgYWRkaXRpb25hbF92YWx1ZXMgPSAyXG5cbmxldCBsZW5ndGggeCA9IE9iai5zaXplKE9iai5yZXByIHgpIC0gYWRkaXRpb25hbF92YWx1ZXNcblxubGV0IHJhaXNlX2lmX2ludmFsaWRfb2Zmc2V0IGUgbyBtc2cgPVxuICBpZiBub3QgKDAgPD0gbyAmJiBvIDwgbGVuZ3RoIGUpIHRoZW5cbiAgICBpbnZhbGlkX2FyZyhtc2cpXG5cbmV4dGVybmFsIHNldCcgOiAnYSB0IC0+IGludCAtPiAnYSAtPiB1bml0ID0gXCJjYW1sX2VwaGVfc2V0X2tleVwiXG5leHRlcm5hbCB1bnNldCA6ICdhIHQgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfZXBoZV91bnNldF9rZXlcIlxubGV0IHNldCBlIG8geCA9XG4gIHJhaXNlX2lmX2ludmFsaWRfb2Zmc2V0IGUgbyBcIldlYWsuc2V0XCI7XG4gIG1hdGNoIHggd2l0aFxuICB8IE5vbmUgLT4gdW5zZXQgZSBvXG4gIHwgU29tZSB4IC0+IHNldCcgZSBvIHhcblxuZXh0ZXJuYWwgZ2V0IDogJ2EgdCAtPiBpbnQgLT4gJ2Egb3B0aW9uID0gXCJjYW1sX3dlYWtfZ2V0XCJcbmxldCBnZXQgZSBvID1cbiAgcmFpc2VfaWZfaW52YWxpZF9vZmZzZXQgZSBvIFwiV2Vhay5nZXRcIjtcbiAgZ2V0IGUgb1xuXG5leHRlcm5hbCBnZXRfY29weSA6ICdhIHQgLT4gaW50IC0+ICdhIG9wdGlvbiA9IFwiY2FtbF93ZWFrX2dldF9jb3B5XCJcbmxldCBnZXRfY29weSBlIG8gPVxuICByYWlzZV9pZl9pbnZhbGlkX29mZnNldCBlIG8gXCJXZWFrLmdldF9jb3B5XCI7XG4gIGdldF9jb3B5IGUgb1xuXG5leHRlcm5hbCBjaGVjayA6ICdhIHQgLT4gaW50IC0+IGJvb2wgPSBcImNhbWxfd2Vha19jaGVja1wiXG5sZXQgY2hlY2sgZSBvID1cbiAgcmFpc2VfaWZfaW52YWxpZF9vZmZzZXQgZSBvIFwiV2Vhay5jaGVja1wiO1xuICBjaGVjayBlIG9cblxuZXh0ZXJuYWwgYmxpdCA6ICdhIHQgLT4gaW50IC0+ICdhIHQgLT4gaW50IC0+IGludCAtPiB1bml0ID0gXCJjYW1sX3dlYWtfYmxpdFwiXG5cbigqIGJsaXQ6IHNyYyBzcmNvZmYgZHN0IGRzdG9mZiBsZW4gKilcbmxldCBibGl0IGUxIG8xIGUyIG8yIGwgPVxuICBpZiBsIDwgMCB8fCBvMSA8IDAgfHwgbzEgPiBsZW5ndGggZTEgLSBsXG4gICAgIHx8IG8yIDwgMCB8fCBvMiA+IGxlbmd0aCBlMiAtIGxcbiAgdGhlbiBpbnZhbGlkX2FyZyBcIldlYWsuYmxpdFwiXG4gIGVsc2UgaWYgbCA8PiAwIHRoZW4gYmxpdCBlMSBvMSBlMiBvMiBsXG5cbmxldCBmaWxsIGFyIG9mcyBsZW4geCA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBsZW5ndGggYXIgLSBsZW5cbiAgdGhlbiByYWlzZSAoSW52YWxpZF9hcmd1bWVudCBcIldlYWsuZmlsbFwiKVxuICBlbHNlIGJlZ2luXG4gICAgZm9yIGkgPSBvZnMgdG8gKG9mcyArIGxlbiAtIDEpIGRvXG4gICAgICBzZXQgYXIgaSB4XG4gICAgZG9uZVxuICBlbmRcblxuXG4oKiogV2VhayBoYXNoIHRhYmxlcyAqKVxuXG5tb2R1bGUgdHlwZSBTID0gc2lnXG4gIHR5cGUgZGF0YVxuICB0eXBlIHRcbiAgdmFsIGNyZWF0ZSA6IGludCAtPiB0XG4gIHZhbCBjbGVhciA6IHQgLT4gdW5pdFxuICB2YWwgbWVyZ2UgOiB0IC0+IGRhdGEgLT4gZGF0YVxuICB2YWwgYWRkIDogdCAtPiBkYXRhIC0+IHVuaXRcbiAgdmFsIHJlbW92ZSA6IHQgLT4gZGF0YSAtPiB1bml0XG4gIHZhbCBmaW5kIDogdCAtPiBkYXRhIC0+IGRhdGFcbiAgdmFsIGZpbmRfb3B0IDogdCAtPiBkYXRhIC0+IGRhdGEgb3B0aW9uXG4gIHZhbCBmaW5kX2FsbCA6IHQgLT4gZGF0YSAtPiBkYXRhIGxpc3RcbiAgdmFsIG1lbSA6IHQgLT4gZGF0YSAtPiBib29sXG4gIHZhbCBpdGVyIDogKGRhdGEgLT4gdW5pdCkgLT4gdCAtPiB1bml0XG4gIHZhbCBmb2xkIDogKGRhdGEgLT4gJ2EgLT4gJ2EpIC0+IHQgLT4gJ2EgLT4gJ2FcbiAgdmFsIGNvdW50IDogdCAtPiBpbnRcbiAgdmFsIHN0YXRzIDogdCAtPiBpbnQgKiBpbnQgKiBpbnQgKiBpbnQgKiBpbnQgKiBpbnRcbmVuZFxuXG5tb2R1bGUgTWFrZSAoSCA6IEhhc2h0YmwuSGFzaGVkVHlwZSkgOiAoUyB3aXRoIHR5cGUgZGF0YSA9IEgudCkgPSBzdHJ1Y3RcblxuICB0eXBlICdhIHdlYWtfdCA9ICdhIHRcbiAgbGV0IHdlYWtfY3JlYXRlID0gY3JlYXRlXG4gIGxldCBlbXB0eWJ1Y2tldCA9IHdlYWtfY3JlYXRlIDBcblxuICB0eXBlIGRhdGEgPSBILnRcblxuICB0eXBlIHQgPSB7XG4gICAgbXV0YWJsZSB0YWJsZSA6IGRhdGEgd2Vha190IGFycmF5O1xuICAgIG11dGFibGUgaGFzaGVzIDogaW50IGFycmF5IGFycmF5O1xuICAgIG11dGFibGUgbGltaXQgOiBpbnQ7ICAgICAgICAgICAgICAgKCogYnVja2V0IHNpemUgbGltaXQgKilcbiAgICBtdXRhYmxlIG92ZXJzaXplIDogaW50OyAgICAgICAgICAgICgqIG51bWJlciBvZiBvdmVyc2l6ZSBidWNrZXRzICopXG4gICAgbXV0YWJsZSByb3ZlciA6IGludDsgICAgICAgICAgICAgICAoKiBmb3IgaW50ZXJuYWwgYm9va2tlZXBpbmcgKilcbiAgfVxuXG4gIGxldCBnZXRfaW5kZXggdCBoID0gKGggbGFuZCBtYXhfaW50KSBtb2QgKEFycmF5Lmxlbmd0aCB0LnRhYmxlKVxuXG4gIGxldCBsaW1pdCA9IDdcbiAgbGV0IG92ZXJfbGltaXQgPSAyXG5cbiAgbGV0IGNyZWF0ZSBzeiA9XG4gICAgbGV0IHN6ID0gaWYgc3ogPCA3IHRoZW4gNyBlbHNlIHN6IGluXG4gICAgbGV0IHN6ID0gaWYgc3ogPiBTeXMubWF4X2FycmF5X2xlbmd0aCB0aGVuIFN5cy5tYXhfYXJyYXlfbGVuZ3RoIGVsc2Ugc3ogaW5cbiAgICB7XG4gICAgICB0YWJsZSA9IEFycmF5Lm1ha2Ugc3ogZW1wdHlidWNrZXQ7XG4gICAgICBoYXNoZXMgPSBBcnJheS5tYWtlIHN6IFt8IHxdO1xuICAgICAgbGltaXQgPSBsaW1pdDtcbiAgICAgIG92ZXJzaXplID0gMDtcbiAgICAgIHJvdmVyID0gMDtcbiAgICB9XG5cbiAgbGV0IGNsZWFyIHQgPVxuICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggdC50YWJsZSAtIDEgZG9cbiAgICAgIHQudGFibGUuKGkpIDwtIGVtcHR5YnVja2V0O1xuICAgICAgdC5oYXNoZXMuKGkpIDwtIFt8IHxdO1xuICAgIGRvbmU7XG4gICAgdC5saW1pdCA8LSBsaW1pdDtcbiAgICB0Lm92ZXJzaXplIDwtIDBcblxuXG4gIGxldCBmb2xkIGYgdCBpbml0ID1cbiAgICBsZXQgcmVjIGZvbGRfYnVja2V0IGkgYiBhY2N1ID1cbiAgICAgIGlmIGkgPj0gbGVuZ3RoIGIgdGhlbiBhY2N1IGVsc2VcbiAgICAgIG1hdGNoIGdldCBiIGkgd2l0aFxuICAgICAgfCBTb21lIHYgLT4gZm9sZF9idWNrZXQgKGkrMSkgYiAoZiB2IGFjY3UpXG4gICAgICB8IE5vbmUgLT4gZm9sZF9idWNrZXQgKGkrMSkgYiBhY2N1XG4gICAgaW5cbiAgICBBcnJheS5mb2xkX3JpZ2h0IChmb2xkX2J1Y2tldCAwKSB0LnRhYmxlIGluaXRcblxuXG4gIGxldCBpdGVyIGYgdCA9XG4gICAgbGV0IHJlYyBpdGVyX2J1Y2tldCBpIGIgPVxuICAgICAgaWYgaSA+PSBsZW5ndGggYiB0aGVuICgpIGVsc2VcbiAgICAgIG1hdGNoIGdldCBiIGkgd2l0aFxuICAgICAgfCBTb21lIHYgLT4gZiB2OyBpdGVyX2J1Y2tldCAoaSsxKSBiXG4gICAgICB8IE5vbmUgLT4gaXRlcl9idWNrZXQgKGkrMSkgYlxuICAgIGluXG4gICAgQXJyYXkuaXRlciAoaXRlcl9idWNrZXQgMCkgdC50YWJsZVxuXG5cbiAgbGV0IGl0ZXJfd2VhayBmIHQgPVxuICAgIGxldCByZWMgaXRlcl9idWNrZXQgaSBqIGIgPVxuICAgICAgaWYgaSA+PSBsZW5ndGggYiB0aGVuICgpIGVsc2VcbiAgICAgIG1hdGNoIGNoZWNrIGIgaSB3aXRoXG4gICAgICB8IHRydWUgLT4gZiBiIHQuaGFzaGVzLihqKSBpOyBpdGVyX2J1Y2tldCAoaSsxKSBqIGJcbiAgICAgIHwgZmFsc2UgLT4gaXRlcl9idWNrZXQgKGkrMSkgaiBiXG4gICAgaW5cbiAgICBBcnJheS5pdGVyaSAoaXRlcl9idWNrZXQgMCkgdC50YWJsZVxuXG5cbiAgbGV0IHJlYyBjb3VudF9idWNrZXQgaSBiIGFjY3UgPVxuICAgIGlmIGkgPj0gbGVuZ3RoIGIgdGhlbiBhY2N1IGVsc2VcbiAgICBjb3VudF9idWNrZXQgKGkrMSkgYiAoYWNjdSArIChpZiBjaGVjayBiIGkgdGhlbiAxIGVsc2UgMCkpXG5cblxuICBsZXQgY291bnQgdCA9XG4gICAgQXJyYXkuZm9sZF9yaWdodCAoY291bnRfYnVja2V0IDApIHQudGFibGUgMFxuXG5cbiAgbGV0IG5leHRfc3ogbiA9IEludC5taW4gKDMgKiBuIC8gMiArIDMpIFN5cy5tYXhfYXJyYXlfbGVuZ3RoXG4gIGxldCBwcmV2X3N6IG4gPSAoKG4gLSAzKSAqIDIgKyAyKSAvIDNcblxuICBsZXQgdGVzdF9zaHJpbmtfYnVja2V0IHQgPVxuICAgIGxldCBidWNrZXQgPSB0LnRhYmxlLih0LnJvdmVyKSBpblxuICAgIGxldCBoYnVja2V0ID0gdC5oYXNoZXMuKHQucm92ZXIpIGluXG4gICAgbGV0IGxlbiA9IGxlbmd0aCBidWNrZXQgaW5cbiAgICBsZXQgcHJldl9sZW4gPSBwcmV2X3N6IGxlbiBpblxuICAgIGxldCBsaXZlID0gY291bnRfYnVja2V0IDAgYnVja2V0IDAgaW5cbiAgICBpZiBsaXZlIDw9IHByZXZfbGVuIHRoZW4gYmVnaW5cbiAgICAgIGxldCByZWMgbG9vcCBpIGogPVxuICAgICAgICBpZiBqID49IHByZXZfbGVuIHRoZW4gYmVnaW5cbiAgICAgICAgICBpZiBjaGVjayBidWNrZXQgaSB0aGVuIGxvb3AgKGkgKyAxKSBqXG4gICAgICAgICAgZWxzZSBpZiBjaGVjayBidWNrZXQgaiB0aGVuIGJlZ2luXG4gICAgICAgICAgICBibGl0IGJ1Y2tldCBqIGJ1Y2tldCBpIDE7XG4gICAgICAgICAgICBoYnVja2V0LihpKSA8LSBoYnVja2V0LihqKTtcbiAgICAgICAgICAgIGxvb3AgKGkgKyAxKSAoaiAtIDEpO1xuICAgICAgICAgIGVuZCBlbHNlIGxvb3AgaSAoaiAtIDEpO1xuICAgICAgICBlbmQ7XG4gICAgICBpblxuICAgICAgbG9vcCAwIChsZW5ndGggYnVja2V0IC0gMSk7XG4gICAgICBpZiBwcmV2X2xlbiA9IDAgdGhlbiBiZWdpblxuICAgICAgICB0LnRhYmxlLih0LnJvdmVyKSA8LSBlbXB0eWJ1Y2tldDtcbiAgICAgICAgdC5oYXNoZXMuKHQucm92ZXIpIDwtIFt8IHxdO1xuICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgbGV0IG5ld2J1Y2tldCA9IHdlYWtfY3JlYXRlIHByZXZfbGVuIGluXG4gICAgICAgIGJsaXQgYnVja2V0IDAgbmV3YnVja2V0IDAgcHJldl9sZW47XG4gICAgICAgIHQudGFibGUuKHQucm92ZXIpIDwtIG5ld2J1Y2tldDtcbiAgICAgICAgdC5oYXNoZXMuKHQucm92ZXIpIDwtIEFycmF5LnN1YiBoYnVja2V0IDAgcHJldl9sZW5cbiAgICAgIGVuZDtcbiAgICAgIGlmIGxlbiA+IHQubGltaXQgJiYgcHJldl9sZW4gPD0gdC5saW1pdCB0aGVuIHQub3ZlcnNpemUgPC0gdC5vdmVyc2l6ZSAtIDE7XG4gICAgZW5kO1xuICAgIHQucm92ZXIgPC0gKHQucm92ZXIgKyAxKSBtb2QgKEFycmF5Lmxlbmd0aCB0LnRhYmxlKVxuXG5cbiAgbGV0IHJlYyByZXNpemUgdCA9XG4gICAgbGV0IG9sZGxlbiA9IEFycmF5Lmxlbmd0aCB0LnRhYmxlIGluXG4gICAgbGV0IG5ld2xlbiA9IG5leHRfc3ogb2xkbGVuIGluXG4gICAgaWYgbmV3bGVuID4gb2xkbGVuIHRoZW4gYmVnaW5cbiAgICAgIGxldCBuZXd0ID0gY3JlYXRlIG5ld2xlbiBpblxuICAgICAgbGV0IGFkZF93ZWFrIG9iIG9oIG9pID1cbiAgICAgICAgbGV0IHNldHRlciBuYiBuaSBfID0gYmxpdCBvYiBvaSBuYiBuaSAxIGluXG4gICAgICAgIGxldCBoID0gb2guKG9pKSBpblxuICAgICAgICBhZGRfYXV4IG5ld3Qgc2V0dGVyIE5vbmUgaCAoZ2V0X2luZGV4IG5ld3QgaCk7XG4gICAgICBpblxuICAgICAgaXRlcl93ZWFrIGFkZF93ZWFrIHQ7XG4gICAgICB0LnRhYmxlIDwtIG5ld3QudGFibGU7XG4gICAgICB0Lmhhc2hlcyA8LSBuZXd0Lmhhc2hlcztcbiAgICAgIHQubGltaXQgPC0gbmV3dC5saW1pdDtcbiAgICAgIHQub3ZlcnNpemUgPC0gbmV3dC5vdmVyc2l6ZTtcbiAgICAgIHQucm92ZXIgPC0gdC5yb3ZlciBtb2QgQXJyYXkubGVuZ3RoIG5ld3QudGFibGU7XG4gICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgIHQubGltaXQgPC0gbWF4X2ludDsgICAgICAgICAgICAgKCogbWF4aW11bSBzaXplIGFscmVhZHkgcmVhY2hlZCAqKVxuICAgICAgdC5vdmVyc2l6ZSA8LSAwO1xuICAgIGVuZFxuXG4gIGFuZCBhZGRfYXV4IHQgc2V0dGVyIGQgaCBpbmRleCA9XG4gICAgbGV0IGJ1Y2tldCA9IHQudGFibGUuKGluZGV4KSBpblxuICAgIGxldCBoYXNoZXMgPSB0Lmhhc2hlcy4oaW5kZXgpIGluXG4gICAgbGV0IHN6ID0gbGVuZ3RoIGJ1Y2tldCBpblxuICAgIGxldCByZWMgbG9vcCBpID1cbiAgICAgIGlmIGkgPj0gc3ogdGhlbiBiZWdpblxuICAgICAgICBsZXQgbmV3c3ogPVxuICAgICAgICAgIEludC5taW4gKDMgKiBzeiAvIDIgKyAzKSAoU3lzLm1heF9hcnJheV9sZW5ndGggLSBhZGRpdGlvbmFsX3ZhbHVlcylcbiAgICAgICAgaW5cbiAgICAgICAgaWYgbmV3c3ogPD0gc3ogdGhlbiBmYWlsd2l0aCBcIldlYWsuTWFrZTogaGFzaCBidWNrZXQgY2Fubm90IGdyb3cgbW9yZVwiO1xuICAgICAgICBsZXQgbmV3YnVja2V0ID0gd2Vha19jcmVhdGUgbmV3c3ogaW5cbiAgICAgICAgbGV0IG5ld2hhc2hlcyA9IEFycmF5Lm1ha2UgbmV3c3ogMCBpblxuICAgICAgICBibGl0IGJ1Y2tldCAwIG5ld2J1Y2tldCAwIHN6O1xuICAgICAgICBBcnJheS5ibGl0IGhhc2hlcyAwIG5ld2hhc2hlcyAwIHN6O1xuICAgICAgICBzZXR0ZXIgbmV3YnVja2V0IHN6IGQ7XG4gICAgICAgIG5ld2hhc2hlcy4oc3opIDwtIGg7XG4gICAgICAgIHQudGFibGUuKGluZGV4KSA8LSBuZXdidWNrZXQ7XG4gICAgICAgIHQuaGFzaGVzLihpbmRleCkgPC0gbmV3aGFzaGVzO1xuICAgICAgICBpZiBzeiA8PSB0LmxpbWl0ICYmIG5ld3N6ID4gdC5saW1pdCB0aGVuIGJlZ2luXG4gICAgICAgICAgdC5vdmVyc2l6ZSA8LSB0Lm92ZXJzaXplICsgMTtcbiAgICAgICAgICBmb3IgX2kgPSAwIHRvIG92ZXJfbGltaXQgZG8gdGVzdF9zaHJpbmtfYnVja2V0IHQgZG9uZTtcbiAgICAgICAgZW5kO1xuICAgICAgICBpZiB0Lm92ZXJzaXplID4gQXJyYXkubGVuZ3RoIHQudGFibGUgLyBvdmVyX2xpbWl0IHRoZW4gcmVzaXplIHQ7XG4gICAgICBlbmQgZWxzZSBpZiBjaGVjayBidWNrZXQgaSB0aGVuIGJlZ2luXG4gICAgICAgIGxvb3AgKGkgKyAxKVxuICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgc2V0dGVyIGJ1Y2tldCBpIGQ7XG4gICAgICAgIGhhc2hlcy4oaSkgPC0gaDtcbiAgICAgIGVuZDtcbiAgICBpblxuICAgIGxvb3AgMFxuXG5cbiAgbGV0IGFkZCB0IGQgPVxuICAgIGxldCBoID0gSC5oYXNoIGQgaW5cbiAgICBhZGRfYXV4IHQgc2V0IChTb21lIGQpIGggKGdldF9pbmRleCB0IGgpXG5cblxuICBsZXQgZmluZF9vciB0IGQgaWZub3Rmb3VuZCA9XG4gICAgbGV0IGggPSBILmhhc2ggZCBpblxuICAgIGxldCBpbmRleCA9IGdldF9pbmRleCB0IGggaW5cbiAgICBsZXQgYnVja2V0ID0gdC50YWJsZS4oaW5kZXgpIGluXG4gICAgbGV0IGhhc2hlcyA9IHQuaGFzaGVzLihpbmRleCkgaW5cbiAgICBsZXQgc3ogPSBsZW5ndGggYnVja2V0IGluXG4gICAgbGV0IHJlYyBsb29wIGkgPVxuICAgICAgaWYgaSA+PSBzeiB0aGVuIGlmbm90Zm91bmQgaCBpbmRleFxuICAgICAgZWxzZSBpZiBoID0gaGFzaGVzLihpKSB0aGVuIGJlZ2luXG4gICAgICAgIG1hdGNoIGdldF9jb3B5IGJ1Y2tldCBpIHdpdGhcbiAgICAgICAgfCBTb21lIHYgd2hlbiBILmVxdWFsIHYgZFxuICAgICAgICAgICAtPiBiZWdpbiBtYXRjaCBnZXQgYnVja2V0IGkgd2l0aFxuICAgICAgICAgICAgICB8IFNvbWUgdiAtPiB2XG4gICAgICAgICAgICAgIHwgTm9uZSAtPiBsb29wIChpICsgMSlcbiAgICAgICAgICAgICAgZW5kXG4gICAgICAgIHwgXyAtPiBsb29wIChpICsgMSlcbiAgICAgIGVuZCBlbHNlIGxvb3AgKGkgKyAxKVxuICAgIGluXG4gICAgbG9vcCAwXG5cblxuICBsZXQgbWVyZ2UgdCBkID1cbiAgICBmaW5kX29yIHQgZCAoZnVuIGggaW5kZXggLT4gYWRkX2F1eCB0IHNldCAoU29tZSBkKSBoIGluZGV4OyBkKVxuXG5cbiAgbGV0IGZpbmQgdCBkID0gZmluZF9vciB0IGQgKGZ1biBfaCBfaW5kZXggLT4gcmFpc2UgTm90X2ZvdW5kKVxuXG4gIGxldCBmaW5kX29wdCB0IGQgPVxuICAgIGxldCBoID0gSC5oYXNoIGQgaW5cbiAgICBsZXQgaW5kZXggPSBnZXRfaW5kZXggdCBoIGluXG4gICAgbGV0IGJ1Y2tldCA9IHQudGFibGUuKGluZGV4KSBpblxuICAgIGxldCBoYXNoZXMgPSB0Lmhhc2hlcy4oaW5kZXgpIGluXG4gICAgbGV0IHN6ID0gbGVuZ3RoIGJ1Y2tldCBpblxuICAgIGxldCByZWMgbG9vcCBpID1cbiAgICAgIGlmIGkgPj0gc3ogdGhlbiBOb25lXG4gICAgICBlbHNlIGlmIGggPSBoYXNoZXMuKGkpIHRoZW4gYmVnaW5cbiAgICAgICAgbWF0Y2ggZ2V0X2NvcHkgYnVja2V0IGkgd2l0aFxuICAgICAgICB8IFNvbWUgdiB3aGVuIEguZXF1YWwgdiBkXG4gICAgICAgICAgIC0+IGJlZ2luIG1hdGNoIGdldCBidWNrZXQgaSB3aXRoXG4gICAgICAgICAgICAgIHwgU29tZSBfIGFzIHYgLT4gdlxuICAgICAgICAgICAgICB8IE5vbmUgLT4gbG9vcCAoaSArIDEpXG4gICAgICAgICAgICAgIGVuZFxuICAgICAgICB8IF8gLT4gbG9vcCAoaSArIDEpXG4gICAgICBlbmQgZWxzZSBsb29wIChpICsgMSlcbiAgICBpblxuICAgIGxvb3AgMFxuXG5cbiAgbGV0IGZpbmRfc2hhZG93IHQgZCBpZmZvdW5kIGlmbm90Zm91bmQgPVxuICAgIGxldCBoID0gSC5oYXNoIGQgaW5cbiAgICBsZXQgaW5kZXggPSBnZXRfaW5kZXggdCBoIGluXG4gICAgbGV0IGJ1Y2tldCA9IHQudGFibGUuKGluZGV4KSBpblxuICAgIGxldCBoYXNoZXMgPSB0Lmhhc2hlcy4oaW5kZXgpIGluXG4gICAgbGV0IHN6ID0gbGVuZ3RoIGJ1Y2tldCBpblxuICAgIGxldCByZWMgbG9vcCBpID1cbiAgICAgIGlmIGkgPj0gc3ogdGhlbiBpZm5vdGZvdW5kXG4gICAgICBlbHNlIGlmIGggPSBoYXNoZXMuKGkpIHRoZW4gYmVnaW5cbiAgICAgICAgbWF0Y2ggZ2V0X2NvcHkgYnVja2V0IGkgd2l0aFxuICAgICAgICB8IFNvbWUgdiB3aGVuIEguZXF1YWwgdiBkIC0+IGlmZm91bmQgYnVja2V0IGlcbiAgICAgICAgfCBfIC0+IGxvb3AgKGkgKyAxKVxuICAgICAgZW5kIGVsc2UgbG9vcCAoaSArIDEpXG4gICAgaW5cbiAgICBsb29wIDBcblxuXG4gIGxldCByZW1vdmUgdCBkID0gZmluZF9zaGFkb3cgdCBkIChmdW4gdyBpIC0+IHNldCB3IGkgTm9uZSkgKClcblxuXG4gIGxldCBtZW0gdCBkID0gZmluZF9zaGFkb3cgdCBkIChmdW4gX3cgX2kgLT4gdHJ1ZSkgZmFsc2VcblxuXG4gIGxldCBmaW5kX2FsbCB0IGQgPVxuICAgIGxldCBoID0gSC5oYXNoIGQgaW5cbiAgICBsZXQgaW5kZXggPSBnZXRfaW5kZXggdCBoIGluXG4gICAgbGV0IGJ1Y2tldCA9IHQudGFibGUuKGluZGV4KSBpblxuICAgIGxldCBoYXNoZXMgPSB0Lmhhc2hlcy4oaW5kZXgpIGluXG4gICAgbGV0IHN6ID0gbGVuZ3RoIGJ1Y2tldCBpblxuICAgIGxldCByZWMgbG9vcCBpIGFjY3UgPVxuICAgICAgaWYgaSA+PSBzeiB0aGVuIGFjY3VcbiAgICAgIGVsc2UgaWYgaCA9IGhhc2hlcy4oaSkgdGhlbiBiZWdpblxuICAgICAgICBtYXRjaCBnZXRfY29weSBidWNrZXQgaSB3aXRoXG4gICAgICAgIHwgU29tZSB2IHdoZW4gSC5lcXVhbCB2IGRcbiAgICAgICAgICAgLT4gYmVnaW4gbWF0Y2ggZ2V0IGJ1Y2tldCBpIHdpdGhcbiAgICAgICAgICAgICAgfCBTb21lIHYgLT4gbG9vcCAoaSArIDEpICh2IDo6IGFjY3UpXG4gICAgICAgICAgICAgIHwgTm9uZSAtPiBsb29wIChpICsgMSkgYWNjdVxuICAgICAgICAgICAgICBlbmRcbiAgICAgICAgfCBfIC0+IGxvb3AgKGkgKyAxKSBhY2N1XG4gICAgICBlbmQgZWxzZSBsb29wIChpICsgMSkgYWNjdVxuICAgIGluXG4gICAgbG9vcCAwIFtdXG5cblxuICBsZXQgc3RhdHMgdCA9XG4gICAgbGV0IGxlbiA9IEFycmF5Lmxlbmd0aCB0LnRhYmxlIGluXG4gICAgbGV0IGxlbnMgPSBBcnJheS5tYXAgbGVuZ3RoIHQudGFibGUgaW5cbiAgICBBcnJheS5zb3J0IGNvbXBhcmUgbGVucztcbiAgICBsZXQgdG90bGVuID0gQXJyYXkuZm9sZF9sZWZ0ICggKyApIDAgbGVucyBpblxuICAgIChsZW4sIGNvdW50IHQsIHRvdGxlbiwgbGVucy4oMCksIGxlbnMuKGxlbi8yKSwgbGVucy4obGVuLTEpKVxuXG5cbmVuZFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgUGllcnJlIFdlaXMsIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBBIHByZXR0eS1wcmludGluZyBmYWNpbGl0eSBhbmQgZGVmaW5pdGlvbiBvZiBmb3JtYXR0ZXJzIGZvciAncGFyYWxsZWwnXG4gICAoaS5lLiB1bnJlbGF0ZWQgb3IgaW5kZXBlbmRlbnQpIHByZXR0eS1wcmludGluZyBvbiBtdWx0aXBsZSBvdXQgY2hhbm5lbHMuICopXG5cbigqXG4gICBUaGUgcHJldHR5LXByaW50aW5nIGVuZ2luZSBpbnRlcm5hbCBkYXRhIHN0cnVjdHVyZXMuXG4qKVxuXG5sZXQgaWQgeCA9IHhcblxuKCogQSBkZXZvdGVkIHR5cGUgZm9yIHNpemVzIHRvIGF2b2lkIGNvbmZ1c2lvblxuICAgYmV0d2VlbiBzaXplcyBhbmQgbWVyZSBpbnRlZ2Vycy4gKilcbm1vZHVsZSBTaXplIDogc2lnXG4gIHR5cGUgdFxuXG4gIHZhbCB0b19pbnQgOiB0IC0+IGludFxuICB2YWwgb2ZfaW50IDogaW50IC0+IHRcbiAgdmFsIHplcm8gOiB0XG4gIHZhbCB1bmtub3duIDogdFxuICB2YWwgaXNfa25vd24gOiB0IC0+IGJvb2xcbmVuZCAgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gaW50XG5cbiAgbGV0IHRvX2ludCA9IGlkXG4gIGxldCBvZl9pbnQgPSBpZFxuICBsZXQgemVybyA9IDBcbiAgbGV0IHVua25vd24gPSAtMVxuICBsZXQgaXNfa25vd24gbiA9IG4gPj0gMFxuZW5kXG5cblxuXG4oKiBUaGUgcHJldHR5LXByaW50aW5nIGJveGVzIGRlZmluaXRpb246XG4gICBhIHByZXR0eS1wcmludGluZyBib3ggaXMgZWl0aGVyXG4gICAtIGhib3g6IGhvcml6b250YWwgYm94IChubyBsaW5lIHNwbGl0dGluZylcbiAgIC0gdmJveDogdmVydGljYWwgYm94IChldmVyeSBicmVhayBoaW50IHNwbGl0cyB0aGUgbGluZSlcbiAgIC0gaHZib3g6IGhvcml6b250YWwvdmVydGljYWwgYm94XG4gICAgICh0aGUgYm94IGJlaGF2ZXMgYXMgYW4gaG9yaXpvbnRhbCBib3ggaWYgaXQgZml0cyBvblxuICAgICAgdGhlIGN1cnJlbnQgbGluZSwgb3RoZXJ3aXNlIHRoZSBib3ggYmVoYXZlcyBhcyBhIHZlcnRpY2FsIGJveClcbiAgIC0gaG92Ym94OiBob3Jpem9udGFsIG9yIHZlcnRpY2FsIGNvbXBhY3RpbmcgYm94XG4gICAgICh0aGUgYm94IGlzIGNvbXBhY3RpbmcgbWF0ZXJpYWwsIHByaW50aW5nIGFzIG11Y2ggbWF0ZXJpYWwgYXMgcG9zc2libGVcbiAgICAgIG9uIGV2ZXJ5IGxpbmVzKVxuICAgLSBib3g6IGhvcml6b250YWwgb3IgdmVydGljYWwgY29tcGFjdGluZyBib3ggd2l0aCBlbmhhbmNlZCBib3ggc3RydWN0dXJlXG4gICAgICh0aGUgYm94IGJlaGF2ZXMgYXMgYW4gaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbCBib3ggYnV0IGJyZWFrIGhpbnRzIHNwbGl0XG4gICAgICB0aGUgbGluZSBpZiBzcGxpdHRpbmcgd291bGQgbW92ZSB0byB0aGUgbGVmdClcbiopXG50eXBlIGJveF90eXBlID0gQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzLmJsb2NrX3R5cGUgPVxuICB8IFBwX2hib3ggfCBQcF92Ym94IHwgUHBfaHZib3ggfCBQcF9ob3Zib3ggfCBQcF9ib3ggfCBQcF9maXRzXG5cblxuKCogVGhlIHByZXR0eS1wcmludGluZyB0b2tlbnMgZGVmaW5pdGlvbjpcbiAgIGFyZSBlaXRoZXIgdGV4dCB0byBwcmludCBvciBwcmV0dHkgcHJpbnRpbmdcbiAgIGVsZW1lbnRzIHRoYXQgZHJpdmUgaW5kZW50YXRpb24gYW5kIGxpbmUgc3BsaXR0aW5nLiAqKVxudHlwZSBwcF90b2tlbiA9XG4gIHwgUHBfdGV4dCBvZiBzdHJpbmcgICAgICAgICAgKCogbm9ybWFsIHRleHQgKilcbiAgfCBQcF9icmVhayBvZiB7ICAgICAgICAgICAgICAoKiBjb21wbGV0ZSBicmVhayAqKVxuICAgICAgZml0czogc3RyaW5nICogaW50ICogc3RyaW5nOyAgICgqIGxpbmUgaXMgbm90IHNwbGl0ICopXG4gICAgICBicmVha3M6IHN0cmluZyAqIGludCAqIHN0cmluZzsgKCogbGluZSBpcyBzcGxpdCAqKVxuICAgIH1cbiAgfCBQcF90YnJlYWsgb2YgaW50ICogaW50ICAgICAoKiBnbyB0byBuZXh0IHRhYnVsYXRpb24gKilcbiAgfCBQcF9zdGFiICAgICAgICAgICAgICAgICAgICAoKiBzZXQgYSB0YWJ1bGF0aW9uICopXG4gIHwgUHBfYmVnaW4gb2YgaW50ICogYm94X3R5cGUgKCogYmVnaW5uaW5nIG9mIGEgYm94ICopXG4gIHwgUHBfZW5kICAgICAgICAgICAgICAgICAgICAgKCogZW5kIG9mIGEgYm94ICopXG4gIHwgUHBfdGJlZ2luIG9mIHRib3ggICAgICAgICAgKCogYmVnaW5uaW5nIG9mIGEgdGFidWxhdGlvbiBib3ggKilcbiAgfCBQcF90ZW5kICAgICAgICAgICAgICAgICAgICAoKiBlbmQgb2YgYSB0YWJ1bGF0aW9uIGJveCAqKVxuICB8IFBwX25ld2xpbmUgICAgICAgICAgICAgICAgICgqIHRvIGZvcmNlIGEgbmV3bGluZSBpbnNpZGUgYSBib3ggKilcbiAgfCBQcF9pZl9uZXdsaW5lICAgICAgICAgICAgICAoKiB0byBkbyBzb21ldGhpbmcgb25seSBpZiB0aGlzIHZlcnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lIGhhcyBiZWVuIGJyb2tlbiAqKVxuICB8IFBwX29wZW5fdGFnIG9mIHN0YWcgICAgICAgICAoKiBvcGVuaW5nIGEgdGFnIG5hbWUgKilcbiAgfCBQcF9jbG9zZV90YWcgICAgICAgICAgICAgICAoKiBjbG9zaW5nIHRoZSBtb3N0IHJlY2VudGx5IG9wZW4gdGFnICopXG5cbmFuZCBzdGFnID0gLi5cblxuYW5kIHRib3ggPSBQcF90Ym94IG9mIGludCBsaXN0IHJlZiAgKCogVGFidWxhdGlvbiBib3ggKilcblxudHlwZSB0YWcgPSBzdHJpbmdcbnR5cGUgc3RhZyArPSBTdHJpbmdfdGFnIG9mIHRhZ1xuXG5cbigqIFRoZSBwcmV0dHktcHJpbnRlciBxdWV1ZTpcbiAgIHByZXR0eS1wcmludGluZyBtYXRlcmlhbCBpcyBub3Qgd3JpdHRlbiBpbiB0aGUgb3V0cHV0IGFzIHNvb24gYXMgZW1pdHRlZDtcbiAgIGluc3RlYWQsIHRoZSBtYXRlcmlhbCBpcyBzaW1wbHkgcmVjb3JkZWQgaW4gdGhlIHByZXR0eS1wcmludGVyIHF1ZXVlLFxuICAgdW50aWwgdGhlIGVuY2xvc2luZyBib3ggaGFzIGEga25vd24gY29tcHV0ZWQgc2l6ZSBhbmQgcHJvcGVyIHNwbGl0dGluZ1xuICAgZGVjaXNpb25zIGNhbiBiZSBtYWRlLlxuXG4gICBUaGUgcHJldHR5LXByaW50ZXIgcXVldWUgY29udGFpbnMgZm9ybWF0dGluZyBlbGVtZW50cyB0byBiZSBwcmludGVkLlxuICAgRWFjaCBmb3JtYXR0aW5nIGVsZW1lbnQgaXMgYSB0dXBsZSAoc2l6ZSwgdG9rZW4sIGxlbmd0aCksIHdoZXJlXG4gICAtIGxlbmd0aCBpcyB0aGUgZGVjbGFyZWQgbGVuZ3RoIG9mIHRoZSB0b2tlbixcbiAgIC0gc2l6ZSBpcyBlZmZlY3RpdmUgc2l6ZSBvZiB0aGUgdG9rZW4gd2hlbiBpdCBpcyBwcmludGVkXG4gICAgIChzaXplIGlzIHNldCB3aGVuIHRoZSBzaXplIG9mIHRoZSBib3ggaXMga25vd24sIHNvIHRoYXQgc2l6ZSBvZiBicmVha1xuICAgICAgaGludHMgYXJlIGRlZmluaXRpdmUpLiAqKVxudHlwZSBwcF9xdWV1ZV9lbGVtID0ge1xuICBtdXRhYmxlIHNpemUgOiBTaXplLnQ7XG4gIHRva2VuIDogcHBfdG9rZW47XG4gIGxlbmd0aCA6IGludDtcbn1cblxuXG4oKiBUaGUgcHJldHR5LXByaW50ZXIgcXVldWUgZGVmaW5pdGlvbi4gKilcbnR5cGUgcHBfcXVldWUgPSBwcF9xdWV1ZV9lbGVtIFF1ZXVlLnRcblxuKCogVGhlIHByZXR0eS1wcmludGVyIHNjYW5uaW5nIHN0YWNrLiAqKVxuXG4oKiBUaGUgcHJldHR5LXByaW50ZXIgc2Nhbm5pbmcgc3RhY2s6IHNjYW5uaW5nIGVsZW1lbnQgZGVmaW5pdGlvbi4gKilcbnR5cGUgcHBfc2Nhbl9lbGVtID0ge1xuICBsZWZ0X3RvdGFsIDogaW50OyAoKiBWYWx1ZSBvZiBwcF9sZWZ0X3RvdGFsIHdoZW4gdGhlIGVsZW1lbnQgd2FzIGVucXVldWVkLiAqKVxuICBxdWV1ZV9lbGVtIDogcHBfcXVldWVfZWxlbVxufVxuXG4oKiBUaGUgcHJldHR5LXByaW50ZXIgZm9ybWF0dGluZyBzdGFjazpcbiAgIHRoZSBmb3JtYXR0aW5nIHN0YWNrIGNvbnRhaW5zIHRoZSBkZXNjcmlwdGlvbiBvZiBhbGwgdGhlIGN1cnJlbnRseSBhY3RpdmVcbiAgIGJveGVzOyB0aGUgcHJldHR5LXByaW50ZXIgZm9ybWF0dGluZyBzdGFjayBpcyB1c2VkIHRvIHNwbGl0IHRoZSBsaW5lc1xuICAgd2hpbGUgcHJpbnRpbmcgdG9rZW5zLiAqKVxuXG4oKiBUaGUgcHJldHR5LXByaW50ZXIgZm9ybWF0dGluZyBzdGFjazogZm9ybWF0dGluZyBzdGFjayBlbGVtZW50IGRlZmluaXRpb24uXG4gICBFYWNoIHN0YWNrIGVsZW1lbnQgZGVzY3JpYmVzIGEgcHJldHR5LXByaW50aW5nIGJveC4gKilcbnR5cGUgcHBfZm9ybWF0X2VsZW0gPSB7IGJveF90eXBlIDogYm94X3R5cGU7IHdpZHRoIDogaW50IH1cblxuKCogVGhlIGZvcm1hdHRlciBkZWZpbml0aW9uLlxuICAgRWFjaCBmb3JtYXR0ZXIgdmFsdWUgaXMgYSBwcmV0dHktcHJpbnRlciBpbnN0YW5jZSB3aXRoIGFsbCBpdHNcbiAgIG1hY2hpbmVyeS4gKilcbnR5cGUgZm9ybWF0dGVyID0ge1xuICAoKiBUaGUgcHJldHR5LXByaW50ZXIgc2Nhbm5pbmcgc3RhY2suICopXG4gIHBwX3NjYW5fc3RhY2sgOiBwcF9zY2FuX2VsZW0gU3RhY2sudDtcbiAgKCogVGhlIHByZXR0eS1wcmludGVyIGZvcm1hdHRpbmcgc3RhY2suICopXG4gIHBwX2Zvcm1hdF9zdGFjayA6IHBwX2Zvcm1hdF9lbGVtIFN0YWNrLnQ7XG4gIHBwX3Rib3hfc3RhY2sgOiB0Ym94IFN0YWNrLnQ7XG4gICgqIFRoZSBwcmV0dHktcHJpbnRlciBzZW1hbnRpY3MgdGFnIHN0YWNrLiAqKVxuICBwcF90YWdfc3RhY2sgOiBzdGFnIFN0YWNrLnQ7XG4gIHBwX21hcmtfc3RhY2sgOiBzdGFnIFN0YWNrLnQ7XG4gICgqIFZhbHVlIG9mIHJpZ2h0IG1hcmdpbi4gKilcbiAgbXV0YWJsZSBwcF9tYXJnaW4gOiBpbnQ7XG4gICgqIE1pbmltYWwgc3BhY2UgbGVmdCBiZWZvcmUgbWFyZ2luLCB3aGVuIG9wZW5pbmcgYSBib3guICopXG4gIG11dGFibGUgcHBfbWluX3NwYWNlX2xlZnQgOiBpbnQ7XG4gICgqIE1heGltdW0gdmFsdWUgb2YgaW5kZW50YXRpb246XG4gICAgIG5vIGJveCBjYW4gYmUgb3BlbmVkIGZ1cnRoZXIuICopXG4gIG11dGFibGUgcHBfbWF4X2luZGVudCA6IGludDtcbiAgKCogU3BhY2UgcmVtYWluaW5nIG9uIHRoZSBjdXJyZW50IGxpbmUuICopXG4gIG11dGFibGUgcHBfc3BhY2VfbGVmdCA6IGludDtcbiAgKCogQ3VycmVudCB2YWx1ZSBvZiBpbmRlbnRhdGlvbi4gKilcbiAgbXV0YWJsZSBwcF9jdXJyZW50X2luZGVudCA6IGludDtcbiAgKCogVHJ1ZSB3aGVuIHRoZSBsaW5lIGhhcyBiZWVuIGJyb2tlbiBieSB0aGUgcHJldHR5LXByaW50ZXIuICopXG4gIG11dGFibGUgcHBfaXNfbmV3X2xpbmUgOiBib29sO1xuICAoKiBUb3RhbCB3aWR0aCBvZiB0b2tlbnMgYWxyZWFkeSBwcmludGVkLiAqKVxuICBtdXRhYmxlIHBwX2xlZnRfdG90YWwgOiBpbnQ7XG4gICgqIFRvdGFsIHdpZHRoIG9mIHRva2VucyBldmVyIHB1dCBpbiBxdWV1ZS4gKilcbiAgbXV0YWJsZSBwcF9yaWdodF90b3RhbCA6IGludDtcbiAgKCogQ3VycmVudCBudW1iZXIgb2Ygb3BlbiBib3hlcy4gKilcbiAgbXV0YWJsZSBwcF9jdXJyX2RlcHRoIDogaW50O1xuICAoKiBNYXhpbXVtIG51bWJlciBvZiBib3hlcyB3aGljaCBjYW4gYmUgc2ltdWx0YW5lb3VzbHkgb3Blbi4gKilcbiAgbXV0YWJsZSBwcF9tYXhfYm94ZXMgOiBpbnQ7XG4gICgqIEVsbGlwc2lzIHN0cmluZy4gKilcbiAgbXV0YWJsZSBwcF9lbGxpcHNpcyA6IHN0cmluZztcbiAgKCogT3V0cHV0IGZ1bmN0aW9uLiAqKVxuICBtdXRhYmxlIHBwX291dF9zdHJpbmcgOiBzdHJpbmcgLT4gaW50IC0+IGludCAtPiB1bml0O1xuICAoKiBGbHVzaGluZyBmdW5jdGlvbi4gKilcbiAgbXV0YWJsZSBwcF9vdXRfZmx1c2ggOiB1bml0IC0+IHVuaXQ7XG4gICgqIE91dHB1dCBvZiBuZXcgbGluZXMuICopXG4gIG11dGFibGUgcHBfb3V0X25ld2xpbmUgOiB1bml0IC0+IHVuaXQ7XG4gICgqIE91dHB1dCBvZiBicmVhayBoaW50cyBzcGFjZXMuICopXG4gIG11dGFibGUgcHBfb3V0X3NwYWNlcyA6IGludCAtPiB1bml0O1xuICAoKiBPdXRwdXQgb2YgaW5kZW50YXRpb24gb2YgbmV3IGxpbmVzLiAqKVxuICBtdXRhYmxlIHBwX291dF9pbmRlbnQgOiBpbnQgLT4gdW5pdDtcbiAgKCogQXJlIHRhZ3MgcHJpbnRlZCA/ICopXG4gIG11dGFibGUgcHBfcHJpbnRfdGFncyA6IGJvb2w7XG4gICgqIEFyZSB0YWdzIG1hcmtlZCA/ICopXG4gIG11dGFibGUgcHBfbWFya190YWdzIDogYm9vbDtcbiAgKCogRmluZCBvcGVuaW5nIGFuZCBjbG9zaW5nIG1hcmtlcnMgb2YgdGFncy4gKilcbiAgbXV0YWJsZSBwcF9tYXJrX29wZW5fdGFnIDogc3RhZyAtPiBzdHJpbmc7XG4gIG11dGFibGUgcHBfbWFya19jbG9zZV90YWcgOiBzdGFnIC0+IHN0cmluZztcbiAgbXV0YWJsZSBwcF9wcmludF9vcGVuX3RhZyA6IHN0YWcgLT4gdW5pdDtcbiAgbXV0YWJsZSBwcF9wcmludF9jbG9zZV90YWcgOiBzdGFnIC0+IHVuaXQ7XG4gICgqIFRoZSBwcmV0dHktcHJpbnRlciBxdWV1ZS4gKilcbiAgcHBfcXVldWUgOiBwcF9xdWV1ZTtcbn1cblxuXG4oKiBUaGUgZm9ybWF0dGVyIHNwZWNpZmljIHRhZyBoYW5kbGluZyBmdW5jdGlvbnMuICopXG50eXBlIGZvcm1hdHRlcl9zdGFnX2Z1bmN0aW9ucyA9IHtcbiAgbWFya19vcGVuX3N0YWcgOiBzdGFnIC0+IHN0cmluZztcbiAgbWFya19jbG9zZV9zdGFnIDogc3RhZyAtPiBzdHJpbmc7XG4gIHByaW50X29wZW5fc3RhZyA6IHN0YWcgLT4gdW5pdDtcbiAgcHJpbnRfY2xvc2Vfc3RhZyA6IHN0YWcgLT4gdW5pdDtcbn1cblxuXG4oKiBUaGUgZm9ybWF0dGVyIGZ1bmN0aW9ucyB0byBvdXRwdXQgbWF0ZXJpYWwuICopXG50eXBlIGZvcm1hdHRlcl9vdXRfZnVuY3Rpb25zID0ge1xuICBvdXRfc3RyaW5nIDogc3RyaW5nIC0+IGludCAtPiBpbnQgLT4gdW5pdDtcbiAgb3V0X2ZsdXNoIDogdW5pdCAtPiB1bml0O1xuICBvdXRfbmV3bGluZSA6IHVuaXQgLT4gdW5pdDtcbiAgb3V0X3NwYWNlcyA6IGludCAtPiB1bml0O1xuICBvdXRfaW5kZW50IDogaW50IC0+IHVuaXQ7XG59XG5cblxuKCpcblxuICBBdXhpbGlhcmllcyBhbmQgYmFzaWMgZnVuY3Rpb25zLlxuXG4qKVxuXG4oKiBFbnRlciBhIHRva2VuIGluIHRoZSBwcmV0dHktcHJpbnRlciBxdWV1ZS4gKilcbmxldCBwcF9lbnF1ZXVlIHN0YXRlIHRva2VuID1cbiAgc3RhdGUucHBfcmlnaHRfdG90YWwgPC0gc3RhdGUucHBfcmlnaHRfdG90YWwgKyB0b2tlbi5sZW5ndGg7XG4gIFF1ZXVlLmFkZCB0b2tlbiBzdGF0ZS5wcF9xdWV1ZVxuXG5cbmxldCBwcF9jbGVhcl9xdWV1ZSBzdGF0ZSA9XG4gIHN0YXRlLnBwX2xlZnRfdG90YWwgPC0gMTsgc3RhdGUucHBfcmlnaHRfdG90YWwgPC0gMTtcbiAgUXVldWUuY2xlYXIgc3RhdGUucHBfcXVldWVcblxuXG4oKiBQcF9pbmZpbml0eTogbGFyZ2UgdmFsdWUgZm9yIGRlZmF1bHQgdG9rZW5zIHNpemUuXG5cbiAgIFBwX2luZmluaXR5IGlzIGRvY3VtZW50ZWQgYXMgYmVpbmcgZ3JlYXRlciB0aGFuIDFlMTA7IHRvIGF2b2lkXG4gICBjb25mdXNpb24gYWJvdXQgdGhlIHdvcmQgJ2dyZWF0ZXInLCB3ZSBjaG9vc2UgcHBfaW5maW5pdHkgZ3JlYXRlclxuICAgdGhhbiAxZTEwICsgMTsgZm9yIGNvcnJlY3QgaGFuZGxpbmcgb2YgdGVzdHMgaW4gdGhlIGFsZ29yaXRobSxcbiAgIHBwX2luZmluaXR5IG11c3QgYmUgZXZlbiBvbmUgbW9yZSB0aGFuIDFlMTAgKyAxOyBsZXQncyBzdGFuZCBvbiB0aGVcbiAgIHNhZmUgc2lkZSBieSBjaG9vc2luZyAxLmUxMCsxMC5cblxuICAgUHBfaW5maW5pdHkgY291bGQgcHJvYmFibHkgYmUgMTA3Mzc0MTgyMyB0aGF0IGlzIDJeMzAgLSAxLCB0aGF0IGlzXG4gICB0aGUgbWluaW1hbCB1cHBlciBib3VuZCBmb3IgaW50ZWdlcnM7IG5vdyB0aGF0IG1heF9pbnQgaXMgZGVmaW5lZCxcbiAgIHRoaXMgbGltaXQgY291bGQgYWxzbyBiZSBkZWZpbmVkIGFzIG1heF9pbnQgLSAxLlxuXG4gICBIb3dldmVyLCBiZWZvcmUgc2V0dGluZyBwcF9pbmZpbml0eSB0byBzb21ldGhpbmcgYXJvdW5kIG1heF9pbnQsIHdlXG4gICBtdXN0IGNhcmVmdWxseSBkb3VibGUtY2hlY2sgYWxsIHRoZSBpbnRlZ2VyIGFyaXRobWV0aWMgb3BlcmF0aW9uc1xuICAgdGhhdCBpbnZvbHZlIHBwX2luZmluaXR5LCBzaW5jZSBhbnkgb3ZlcmZsb3cgd291bGQgd3JlY2sgaGF2b2MgdGhlXG4gICBwcmV0dHktcHJpbnRpbmcgYWxnb3JpdGhtJ3MgaW52YXJpYW50cy4gR2l2ZW4gdGhhdCB0aGlzIGFyaXRobWV0aWNcbiAgIGNvcnJlY3RuZXNzIGNoZWNrIGlzIGRpZmZpY3VsdCBhbmQgZXJyb3IgcHJvbmUgYW5kIGdpdmVuIHRoYXQgMWUxMFxuICAgKyAxIGlzIGluIHByYWN0aWNlIGxhcmdlIGVub3VnaCwgdGhlcmUgaXMgbm8gbmVlZCB0byBhdHRlbXB0IHRvIHNldFxuICAgcHBfaW5maW5pdHkgdG8gdGhlIHRoZW9yZXRpY2FsbHkgbWF4aW11bSBsaW1pdC4gSXQgaXMgbm90IHdvcnRoIHRoZVxuICAgYnVyZGVuICEgKilcbmxldCBwcF9pbmZpbml0eSA9IDEwMDAwMDAwMTBcblxuKCogT3V0cHV0IGZ1bmN0aW9ucyBmb3IgdGhlIGZvcm1hdHRlci4gKilcbmxldCBwcF9vdXRwdXRfc3RyaW5nIHN0YXRlIHMgPSBzdGF0ZS5wcF9vdXRfc3RyaW5nIHMgMCAoU3RyaW5nLmxlbmd0aCBzKVxuYW5kIHBwX291dHB1dF9uZXdsaW5lIHN0YXRlID0gc3RhdGUucHBfb3V0X25ld2xpbmUgKClcbmFuZCBwcF9vdXRwdXRfc3BhY2VzIHN0YXRlIG4gPSBzdGF0ZS5wcF9vdXRfc3BhY2VzIG5cbmFuZCBwcF9vdXRwdXRfaW5kZW50IHN0YXRlIG4gPSBzdGF0ZS5wcF9vdXRfaW5kZW50IG5cblxuKCogRm9ybWF0IGEgdGV4dHVhbCB0b2tlbiAqKVxubGV0IGZvcm1hdF9wcF90ZXh0IHN0YXRlIHNpemUgdGV4dCA9XG4gIHN0YXRlLnBwX3NwYWNlX2xlZnQgPC0gc3RhdGUucHBfc3BhY2VfbGVmdCAtIHNpemU7XG4gIHBwX291dHB1dF9zdHJpbmcgc3RhdGUgdGV4dDtcbiAgc3RhdGUucHBfaXNfbmV3X2xpbmUgPC0gZmFsc2VcblxuKCogRm9ybWF0IGEgc3RyaW5nIGJ5IGl0cyBsZW5ndGgsIGlmIG5vdCBlbXB0eSAqKVxubGV0IGZvcm1hdF9zdHJpbmcgc3RhdGUgcyA9XG4gIGlmIHMgPD4gXCJcIiB0aGVuIGZvcm1hdF9wcF90ZXh0IHN0YXRlIChTdHJpbmcubGVuZ3RoIHMpIHNcblxuKCogVG8gZm9ybWF0IGEgYnJlYWssIGluZGVudGluZyBhIG5ldyBsaW5lLiAqKVxubGV0IGJyZWFrX25ld19saW5lIHN0YXRlIChiZWZvcmUsIG9mZnNldCwgYWZ0ZXIpIHdpZHRoID1cbiAgZm9ybWF0X3N0cmluZyBzdGF0ZSBiZWZvcmU7XG4gIHBwX291dHB1dF9uZXdsaW5lIHN0YXRlO1xuICBzdGF0ZS5wcF9pc19uZXdfbGluZSA8LSB0cnVlO1xuICBsZXQgaW5kZW50ID0gc3RhdGUucHBfbWFyZ2luIC0gd2lkdGggKyBvZmZzZXQgaW5cbiAgKCogRG9uJ3QgaW5kZW50IG1vcmUgdGhhbiBwcF9tYXhfaW5kZW50LiAqKVxuICBsZXQgcmVhbF9pbmRlbnQgPSBJbnQubWluIHN0YXRlLnBwX21heF9pbmRlbnQgaW5kZW50IGluXG4gIHN0YXRlLnBwX2N1cnJlbnRfaW5kZW50IDwtIHJlYWxfaW5kZW50O1xuICBzdGF0ZS5wcF9zcGFjZV9sZWZ0IDwtIHN0YXRlLnBwX21hcmdpbiAtIHN0YXRlLnBwX2N1cnJlbnRfaW5kZW50O1xuICBwcF9vdXRwdXRfaW5kZW50IHN0YXRlIHN0YXRlLnBwX2N1cnJlbnRfaW5kZW50O1xuICBmb3JtYXRfc3RyaW5nIHN0YXRlIGFmdGVyXG5cblxuKCogVG8gZm9yY2UgYSBsaW5lIGJyZWFrIGluc2lkZSBhIGJveDogbm8gb2Zmc2V0IGlzIGFkZGVkLiAqKVxubGV0IGJyZWFrX2xpbmUgc3RhdGUgd2lkdGggPSBicmVha19uZXdfbGluZSBzdGF0ZSAoXCJcIiwgMCwgXCJcIikgd2lkdGhcblxuKCogVG8gZm9ybWF0IGEgYnJlYWsgdGhhdCBmaXRzIG9uIHRoZSBjdXJyZW50IGxpbmUuICopXG5sZXQgYnJlYWtfc2FtZV9saW5lIHN0YXRlIChiZWZvcmUsIHdpZHRoLCBhZnRlcikgPVxuICBmb3JtYXRfc3RyaW5nIHN0YXRlIGJlZm9yZTtcbiAgc3RhdGUucHBfc3BhY2VfbGVmdCA8LSBzdGF0ZS5wcF9zcGFjZV9sZWZ0IC0gd2lkdGg7XG4gIHBwX291dHB1dF9zcGFjZXMgc3RhdGUgd2lkdGg7XG4gIGZvcm1hdF9zdHJpbmcgc3RhdGUgYWZ0ZXJcblxuXG4oKiBUbyBpbmRlbnQgbm8gbW9yZSB0aGFuIHBwX21heF9pbmRlbnQsIGlmIG9uZSB0cmllcyB0byBvcGVuIGEgYm94XG4gICBiZXlvbmQgcHBfbWF4X2luZGVudCwgdGhlbiB0aGUgYm94IGlzIHJlamVjdGVkIG9uIHRoZSBsZWZ0XG4gICBieSBzaW11bGF0aW5nIGEgYnJlYWsuICopXG5sZXQgcHBfZm9yY2VfYnJlYWtfbGluZSBzdGF0ZSA9XG4gIG1hdGNoIFN0YWNrLnRvcF9vcHQgc3RhdGUucHBfZm9ybWF0X3N0YWNrIHdpdGhcbiAgfCBOb25lIC0+IHBwX291dHB1dF9uZXdsaW5lIHN0YXRlXG4gIHwgU29tZSB7IGJveF90eXBlOyB3aWR0aCB9IC0+XG4gICAgaWYgd2lkdGggPiBzdGF0ZS5wcF9zcGFjZV9sZWZ0IHRoZW5cbiAgICAgIG1hdGNoIGJveF90eXBlIHdpdGhcbiAgICAgIHwgUHBfZml0cyB8IFBwX2hib3ggLT4gKClcbiAgICAgIHwgUHBfdmJveCB8IFBwX2h2Ym94IHwgUHBfaG92Ym94IHwgUHBfYm94IC0+IGJyZWFrX2xpbmUgc3RhdGUgd2lkdGhcblxuXG4oKiBUbyBza2lwIGEgdG9rZW4sIGlmIHRoZSBwcmV2aW91cyBsaW5lIGhhcyBiZWVuIGJyb2tlbi4gKilcbmxldCBwcF9za2lwX3Rva2VuIHN0YXRlID1cbiAgbWF0Y2ggUXVldWUudGFrZV9vcHQgc3RhdGUucHBfcXVldWUgd2l0aFxuICB8IE5vbmUgLT4gKCkgKCogcHJpbnRfaWZfbmV3bGluZSBtdXN0IGhhdmUgYmVlbiB0aGUgbGFzdCBwcmludGluZyBjb21tYW5kICopXG4gIHwgU29tZSB7IHNpemU7IGxlbmd0aDsgXyB9IC0+XG4gICAgc3RhdGUucHBfbGVmdF90b3RhbCA8LSBzdGF0ZS5wcF9sZWZ0X3RvdGFsIC0gbGVuZ3RoO1xuICAgIHN0YXRlLnBwX3NwYWNlX2xlZnQgPC0gc3RhdGUucHBfc3BhY2VfbGVmdCArIFNpemUudG9faW50IHNpemVcblxuXG4oKlxuXG4gIFRoZSBtYWluIHByZXR0eSBwcmludGluZyBmdW5jdGlvbnMuXG5cbiopXG5cbigqIEZvcm1hdHRpbmcgYSB0b2tlbiB3aXRoIGEgZ2l2ZW4gc2l6ZS4gKilcbmxldCBmb3JtYXRfcHBfdG9rZW4gc3RhdGUgc2l6ZSA9IGZ1bmN0aW9uXG5cbiAgfCBQcF90ZXh0IHMgLT5cbiAgICBmb3JtYXRfcHBfdGV4dCBzdGF0ZSBzaXplIHNcblxuICB8IFBwX2JlZ2luIChvZmYsIHR5KSAtPlxuICAgIGxldCBpbnNlcnRpb25fcG9pbnQgPSBzdGF0ZS5wcF9tYXJnaW4gLSBzdGF0ZS5wcF9zcGFjZV9sZWZ0IGluXG4gICAgaWYgaW5zZXJ0aW9uX3BvaW50ID4gc3RhdGUucHBfbWF4X2luZGVudCB0aGVuXG4gICAgICAoKiBjYW4gbm90IG9wZW4gYSBib3ggcmlnaHQgdGhlcmUuICopXG4gICAgICBiZWdpbiBwcF9mb3JjZV9icmVha19saW5lIHN0YXRlIGVuZDtcbiAgICBsZXQgd2lkdGggPSBzdGF0ZS5wcF9zcGFjZV9sZWZ0IC0gb2ZmIGluXG4gICAgbGV0IGJveF90eXBlID1cbiAgICAgIG1hdGNoIHR5IHdpdGhcbiAgICAgIHwgUHBfdmJveCAtPiBQcF92Ym94XG4gICAgICB8IFBwX2hib3ggfCBQcF9odmJveCB8IFBwX2hvdmJveCB8IFBwX2JveCB8IFBwX2ZpdHMgLT5cbiAgICAgICAgaWYgc2l6ZSA+IHN0YXRlLnBwX3NwYWNlX2xlZnQgdGhlbiB0eSBlbHNlIFBwX2ZpdHMgaW5cbiAgICBTdGFjay5wdXNoIHsgYm94X3R5cGU7IHdpZHRoIH0gc3RhdGUucHBfZm9ybWF0X3N0YWNrXG5cbiAgfCBQcF9lbmQgLT5cbiAgICBTdGFjay5wb3Bfb3B0IHN0YXRlLnBwX2Zvcm1hdF9zdGFjayB8PiBpZ25vcmVcblxuICB8IFBwX3RiZWdpbiAoUHBfdGJveCBfIGFzIHRib3gpIC0+XG4gICAgU3RhY2sucHVzaCB0Ym94IHN0YXRlLnBwX3Rib3hfc3RhY2tcblxuICB8IFBwX3RlbmQgLT5cbiAgICBTdGFjay5wb3Bfb3B0IHN0YXRlLnBwX3Rib3hfc3RhY2sgfD4gaWdub3JlXG5cbiAgfCBQcF9zdGFiIC0+XG4gICAgYmVnaW4gbWF0Y2ggU3RhY2sudG9wX29wdCBzdGF0ZS5wcF90Ym94X3N0YWNrIHdpdGhcbiAgICB8IE5vbmUgLT4gKCkgKCogTm8gb3BlbiB0YWJ1bGF0aW9uIGJveC4gKilcbiAgICB8IFNvbWUgKFBwX3Rib3ggdGFicykgLT5cbiAgICAgIGxldCByZWMgYWRkX3RhYiBuID0gZnVuY3Rpb25cbiAgICAgICAgfCBbXSAtPiBbbl1cbiAgICAgICAgfCB4IDo6IGwgYXMgbHMgLT4gaWYgbiA8IHggdGhlbiBuIDo6IGxzIGVsc2UgeCA6OiBhZGRfdGFiIG4gbCBpblxuICAgICAgdGFicyA6PSBhZGRfdGFiIChzdGF0ZS5wcF9tYXJnaW4gLSBzdGF0ZS5wcF9zcGFjZV9sZWZ0KSAhdGFic1xuICAgIGVuZFxuXG4gIHwgUHBfdGJyZWFrIChuLCBvZmYpIC0+XG4gICAgbGV0IGluc2VydGlvbl9wb2ludCA9IHN0YXRlLnBwX21hcmdpbiAtIHN0YXRlLnBwX3NwYWNlX2xlZnQgaW5cbiAgICBiZWdpbiBtYXRjaCBTdGFjay50b3Bfb3B0IHN0YXRlLnBwX3Rib3hfc3RhY2sgd2l0aFxuICAgIHwgTm9uZSAtPiAoKSAoKiBObyBvcGVuIHRhYnVsYXRpb24gYm94LiAqKVxuICAgIHwgU29tZSAoUHBfdGJveCB0YWJzKSAtPlxuICAgICAgbGV0IHRhYiA9XG4gICAgICAgIG1hdGNoICF0YWJzIHdpdGhcbiAgICAgICAgfCBbXSAtPiBpbnNlcnRpb25fcG9pbnRcbiAgICAgICAgfCBmaXJzdCA6OiBfIC0+XG4gICAgICAgICAgbGV0IHJlYyBmaW5kID0gZnVuY3Rpb25cbiAgICAgICAgICAgIHwgaGVhZCA6OiB0YWlsIC0+XG4gICAgICAgICAgICAgIGlmIGhlYWQgPj0gaW5zZXJ0aW9uX3BvaW50IHRoZW4gaGVhZCBlbHNlIGZpbmQgdGFpbFxuICAgICAgICAgICAgfCBbXSAtPiBmaXJzdCBpblxuICAgICAgICAgIGZpbmQgIXRhYnMgaW5cbiAgICAgIGxldCBvZmZzZXQgPSB0YWIgLSBpbnNlcnRpb25fcG9pbnQgaW5cbiAgICAgIGlmIG9mZnNldCA+PSAwXG4gICAgICB0aGVuIGJyZWFrX3NhbWVfbGluZSBzdGF0ZSAoXCJcIiwgb2Zmc2V0ICsgbiwgXCJcIilcbiAgICAgIGVsc2UgYnJlYWtfbmV3X2xpbmUgc3RhdGUgKFwiXCIsIHRhYiArIG9mZiwgXCJcIikgc3RhdGUucHBfbWFyZ2luXG4gICAgZW5kXG5cbiAgfCBQcF9uZXdsaW5lIC0+XG4gICAgYmVnaW4gbWF0Y2ggU3RhY2sudG9wX29wdCBzdGF0ZS5wcF9mb3JtYXRfc3RhY2sgd2l0aFxuICAgIHwgTm9uZSAtPiBwcF9vdXRwdXRfbmV3bGluZSBzdGF0ZSAoKiBObyBvcGVuIGJveC4gKilcbiAgICB8IFNvbWUgeyB3aWR0aDsgX30gLT4gYnJlYWtfbGluZSBzdGF0ZSB3aWR0aFxuICAgIGVuZFxuXG4gIHwgUHBfaWZfbmV3bGluZSAtPlxuICAgIGlmIHN0YXRlLnBwX2N1cnJlbnRfaW5kZW50ICE9IHN0YXRlLnBwX21hcmdpbiAtIHN0YXRlLnBwX3NwYWNlX2xlZnRcbiAgICB0aGVuIHBwX3NraXBfdG9rZW4gc3RhdGVcblxuICB8IFBwX2JyZWFrIHsgZml0czsgYnJlYWtzIH0gLT5cbiAgICBsZXQgYmVmb3JlLCBvZmYsIF8gPSBicmVha3MgaW5cbiAgICBiZWdpbiBtYXRjaCBTdGFjay50b3Bfb3B0IHN0YXRlLnBwX2Zvcm1hdF9zdGFjayB3aXRoXG4gICAgfCBOb25lIC0+ICgpICgqIE5vIG9wZW4gYm94LiAqKVxuICAgIHwgU29tZSB7IGJveF90eXBlOyB3aWR0aCB9IC0+XG4gICAgICBiZWdpbiBtYXRjaCBib3hfdHlwZSB3aXRoXG4gICAgICB8IFBwX2hvdmJveCAtPlxuICAgICAgICBpZiBzaXplICsgU3RyaW5nLmxlbmd0aCBiZWZvcmUgPiBzdGF0ZS5wcF9zcGFjZV9sZWZ0XG4gICAgICAgIHRoZW4gYnJlYWtfbmV3X2xpbmUgc3RhdGUgYnJlYWtzIHdpZHRoXG4gICAgICAgIGVsc2UgYnJlYWtfc2FtZV9saW5lIHN0YXRlIGZpdHNcbiAgICAgIHwgUHBfYm94IC0+XG4gICAgICAgICgqIEhhdmUgdGhlIGxpbmUganVzdCBiZWVuIGJyb2tlbiBoZXJlID8gKilcbiAgICAgICAgaWYgc3RhdGUucHBfaXNfbmV3X2xpbmUgdGhlbiBicmVha19zYW1lX2xpbmUgc3RhdGUgZml0cyBlbHNlXG4gICAgICAgIGlmIHNpemUgKyBTdHJpbmcubGVuZ3RoIGJlZm9yZSA+IHN0YXRlLnBwX3NwYWNlX2xlZnRcbiAgICAgICAgICB0aGVuIGJyZWFrX25ld19saW5lIHN0YXRlIGJyZWFrcyB3aWR0aCBlbHNlXG4gICAgICAgICgqIGJyZWFrIHRoZSBsaW5lIGhlcmUgbGVhZHMgdG8gbmV3IGluZGVudGF0aW9uID8gKilcbiAgICAgICAgaWYgc3RhdGUucHBfY3VycmVudF9pbmRlbnQgPiBzdGF0ZS5wcF9tYXJnaW4gLSB3aWR0aCArIG9mZlxuICAgICAgICB0aGVuIGJyZWFrX25ld19saW5lIHN0YXRlIGJyZWFrcyB3aWR0aFxuICAgICAgICBlbHNlIGJyZWFrX3NhbWVfbGluZSBzdGF0ZSBmaXRzXG4gICAgICB8IFBwX2h2Ym94IC0+IGJyZWFrX25ld19saW5lIHN0YXRlIGJyZWFrcyB3aWR0aFxuICAgICAgfCBQcF9maXRzIC0+IGJyZWFrX3NhbWVfbGluZSBzdGF0ZSBmaXRzXG4gICAgICB8IFBwX3Zib3ggLT4gYnJlYWtfbmV3X2xpbmUgc3RhdGUgYnJlYWtzIHdpZHRoXG4gICAgICB8IFBwX2hib3ggLT4gYnJlYWtfc2FtZV9saW5lIHN0YXRlIGZpdHNcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICB8IFBwX29wZW5fdGFnIHRhZ19uYW1lIC0+XG4gICAgIGxldCBtYXJrZXIgPSBzdGF0ZS5wcF9tYXJrX29wZW5fdGFnIHRhZ19uYW1lIGluXG4gICAgIHBwX291dHB1dF9zdHJpbmcgc3RhdGUgbWFya2VyO1xuICAgICBTdGFjay5wdXNoIHRhZ19uYW1lIHN0YXRlLnBwX21hcmtfc3RhY2tcblxuICAgfCBQcF9jbG9zZV90YWcgLT5cbiAgICAgYmVnaW4gbWF0Y2ggU3RhY2sucG9wX29wdCBzdGF0ZS5wcF9tYXJrX3N0YWNrIHdpdGhcbiAgICAgfCBOb25lIC0+ICgpICgqIE5vIG1vcmUgdGFnIHRvIGNsb3NlLiAqKVxuICAgICB8IFNvbWUgdGFnX25hbWUgLT5cbiAgICAgICBsZXQgbWFya2VyID0gc3RhdGUucHBfbWFya19jbG9zZV90YWcgdGFnX25hbWUgaW5cbiAgICAgICBwcF9vdXRwdXRfc3RyaW5nIHN0YXRlIG1hcmtlclxuICAgICBlbmRcblxuXG4oKiBQcmludCBpZiB0b2tlbiBzaXplIGlzIGtub3duIGVsc2UgcHJpbnRpbmcgaXMgZGVsYXllZC5cbiAgIFByaW50aW5nIGlzIGRlbGF5ZWQgd2hlbiB0aGUgdGV4dCB3YWl0aW5nIGluIHRoZSBxdWV1ZSByZXF1aXJlc1xuICAgbW9yZSByb29tIHRvIGZvcm1hdCB0aGFuIGV4aXN0cyBvbiB0aGUgY3VycmVudCBsaW5lLiAqKVxubGV0IHJlYyBhZHZhbmNlX2xlZnQgc3RhdGUgPVxuICBtYXRjaCBRdWV1ZS5wZWVrX29wdCBzdGF0ZS5wcF9xdWV1ZSB3aXRoXG4gIHwgTm9uZSAtPiAoKSAoKiBObyB0b2tlbnMgdG8gcHJpbnQgKilcbiAgfCBTb21lIHsgc2l6ZTsgdG9rZW47IGxlbmd0aCB9IC0+XG4gICAgbGV0IHBlbmRpbmdfY291bnQgPSBzdGF0ZS5wcF9yaWdodF90b3RhbCAtIHN0YXRlLnBwX2xlZnRfdG90YWwgaW5cbiAgICBpZiBTaXplLmlzX2tub3duIHNpemUgfHwgcGVuZGluZ19jb3VudCA+PSBzdGF0ZS5wcF9zcGFjZV9sZWZ0IHRoZW4gYmVnaW5cbiAgICAgIFF1ZXVlLnRha2Ugc3RhdGUucHBfcXVldWUgfD4gaWdub3JlOyAoKiBOb3QgZW1wdHk6IHdlIHBlZWsgaW50byBpdCAqKVxuICAgICAgbGV0IHNpemUgPSBpZiBTaXplLmlzX2tub3duIHNpemUgdGhlbiBTaXplLnRvX2ludCBzaXplIGVsc2UgcHBfaW5maW5pdHkgaW5cbiAgICAgIGZvcm1hdF9wcF90b2tlbiBzdGF0ZSBzaXplIHRva2VuO1xuICAgICAgc3RhdGUucHBfbGVmdF90b3RhbCA8LSBsZW5ndGggKyBzdGF0ZS5wcF9sZWZ0X3RvdGFsO1xuICAgICAgKGFkdmFuY2VfbGVmdCBbQHRhaWxjYWxsXSkgc3RhdGVcbiAgICBlbmRcblxuXG4oKiBUbyBlbnF1ZXVlIGEgdG9rZW4gOiB0cnkgdG8gYWR2YW5jZS4gKilcbmxldCBlbnF1ZXVlX2FkdmFuY2Ugc3RhdGUgdG9rID0gcHBfZW5xdWV1ZSBzdGF0ZSB0b2s7IGFkdmFuY2VfbGVmdCBzdGF0ZVxuXG5cbigqIFRvIGVucXVldWUgc3RyaW5ncy4gKilcbmxldCBlbnF1ZXVlX3N0cmluZ19hcyBzdGF0ZSBzaXplIHMgPVxuICBlbnF1ZXVlX2FkdmFuY2Ugc3RhdGUgeyBzaXplOyB0b2tlbiA9IFBwX3RleHQgczsgbGVuZ3RoID0gU2l6ZS50b19pbnQgc2l6ZSB9XG5cblxubGV0IGVucXVldWVfc3RyaW5nIHN0YXRlIHMgPVxuICBlbnF1ZXVlX3N0cmluZ19hcyBzdGF0ZSAoU2l6ZS5vZl9pbnQgKFN0cmluZy5sZW5ndGggcykpIHNcblxuXG4oKiBSb3V0aW5lcyBmb3Igc2NhbiBzdGFja1xuICAgZGV0ZXJtaW5lIHNpemUgb2YgYm94ZXMuICopXG5cbigqIFRoZSBzY2FuX3N0YWNrIGlzIG5ldmVyIGVtcHR5LiAqKVxubGV0IGluaXRpYWxpemVfc2Nhbl9zdGFjayBzdGFjayA9XG4gIFN0YWNrLmNsZWFyIHN0YWNrO1xuICBsZXQgcXVldWVfZWxlbSA9IHsgc2l6ZSA9IFNpemUudW5rbm93bjsgdG9rZW4gPSBQcF90ZXh0IFwiXCI7IGxlbmd0aCA9IDAgfSBpblxuICBTdGFjay5wdXNoIHsgbGVmdF90b3RhbCA9IC0xOyBxdWV1ZV9lbGVtIH0gc3RhY2tcblxuKCogU2V0dGluZyB0aGUgc2l6ZSBvZiBib3hlcyBvbiBzY2FuIHN0YWNrOlxuICAgaWYgdHkgPSB0cnVlIHRoZW4gc2l6ZSBvZiBicmVhayBpcyBzZXQgZWxzZSBzaXplIG9mIGJveCBpcyBzZXQ7XG4gICBpbiBlYWNoIGNhc2UgcHBfc2Nhbl9zdGFjayBpcyBwb3BwZWQuXG5cbiAgIE5vdGU6XG4gICBQYXR0ZXJuIG1hdGNoaW5nIG9uIHNjYW4gc3RhY2sgaXMgZXhoYXVzdGl2ZSwgc2luY2Ugc2Nhbl9zdGFjayBpcyBuZXZlclxuICAgZW1wdHkuXG4gICBQYXR0ZXJuIG1hdGNoaW5nIG9uIHRva2VuIGluIHNjYW4gc3RhY2sgaXMgYWxzbyBleGhhdXN0aXZlLFxuICAgc2luY2Ugc2Nhbl9wdXNoIGlzIHVzZWQgb24gYnJlYWtzIGFuZCBvcGVuaW5nIG9mIGJveGVzLiAqKVxubGV0IHNldF9zaXplIHN0YXRlIHR5ID1cbiAgbWF0Y2ggU3RhY2sudG9wX29wdCBzdGF0ZS5wcF9zY2FuX3N0YWNrIHdpdGhcbiAgfCBOb25lIC0+ICgpICgqIHNjYW5fc3RhY2sgaXMgbmV2ZXIgZW1wdHkuICopXG4gIHwgU29tZSB7IGxlZnRfdG90YWw7IHF1ZXVlX2VsZW0gfSAtPlxuICAgIGxldCBzaXplID0gU2l6ZS50b19pbnQgcXVldWVfZWxlbS5zaXplIGluXG4gICAgKCogdGVzdCBpZiBzY2FuIHN0YWNrIGNvbnRhaW5zIGFueSBkYXRhIHRoYXQgaXMgbm90IG9ic29sZXRlLiAqKVxuICAgIGlmIGxlZnRfdG90YWwgPCBzdGF0ZS5wcF9sZWZ0X3RvdGFsIHRoZW5cbiAgICAgIGluaXRpYWxpemVfc2Nhbl9zdGFjayBzdGF0ZS5wcF9zY2FuX3N0YWNrXG4gICAgZWxzZVxuICAgICAgbWF0Y2ggcXVldWVfZWxlbS50b2tlbiB3aXRoXG4gICAgICB8IFBwX2JyZWFrIF8gfCBQcF90YnJlYWsgKF8sIF8pIC0+XG4gICAgICAgIGlmIHR5IHRoZW4gYmVnaW5cbiAgICAgICAgICBxdWV1ZV9lbGVtLnNpemUgPC0gU2l6ZS5vZl9pbnQgKHN0YXRlLnBwX3JpZ2h0X3RvdGFsICsgc2l6ZSk7XG4gICAgICAgICAgU3RhY2sucG9wX29wdCBzdGF0ZS5wcF9zY2FuX3N0YWNrIHw+IGlnbm9yZVxuICAgICAgICBlbmRcbiAgICAgIHwgUHBfYmVnaW4gKF8sIF8pIC0+XG4gICAgICAgIGlmIG5vdCB0eSB0aGVuIGJlZ2luXG4gICAgICAgICAgcXVldWVfZWxlbS5zaXplIDwtIFNpemUub2ZfaW50IChzdGF0ZS5wcF9yaWdodF90b3RhbCArIHNpemUpO1xuICAgICAgICAgIFN0YWNrLnBvcF9vcHQgc3RhdGUucHBfc2Nhbl9zdGFjayB8PiBpZ25vcmVcbiAgICAgICAgZW5kXG4gICAgICB8IFBwX3RleHQgXyB8IFBwX3N0YWIgfCBQcF90YmVnaW4gXyB8IFBwX3RlbmQgfCBQcF9lbmRcbiAgICAgIHwgUHBfbmV3bGluZSB8IFBwX2lmX25ld2xpbmUgfCBQcF9vcGVuX3RhZyBfIHwgUHBfY2xvc2VfdGFnIC0+XG4gICAgICAgICgpICgqIHNjYW5fcHVzaCBpcyBvbmx5IHVzZWQgZm9yIGJyZWFrcyBhbmQgYm94ZXMuICopXG5cblxuKCogUHVzaCBhIHRva2VuIG9uIHByZXR0eS1wcmludGVyIHNjYW5uaW5nIHN0YWNrLlxuICAgSWYgYiBpcyB0cnVlIHNldF9zaXplIGlzIGNhbGxlZC4gKilcbmxldCBzY2FuX3B1c2ggc3RhdGUgYiB0b2tlbiA9XG4gIHBwX2VucXVldWUgc3RhdGUgdG9rZW47XG4gIGlmIGIgdGhlbiBzZXRfc2l6ZSBzdGF0ZSB0cnVlO1xuICBsZXQgZWxlbSA9IHsgbGVmdF90b3RhbCA9IHN0YXRlLnBwX3JpZ2h0X3RvdGFsOyBxdWV1ZV9lbGVtID0gdG9rZW4gfSBpblxuICBTdGFjay5wdXNoIGVsZW0gc3RhdGUucHBfc2Nhbl9zdGFja1xuXG5cbigqIFRvIG9wZW4gYSBuZXcgYm94IDpcbiAgIHRoZSB1c2VyIG1heSBzZXQgdGhlIGRlcHRoIGJvdW5kIHBwX21heF9ib3hlc1xuICAgYW55IHRleHQgbmVzdGVkIGRlZXBlciBpcyBwcmludGVkIGFzIHRoZSBlbGxpcHNpcyBzdHJpbmcuICopXG5sZXQgcHBfb3Blbl9ib3hfZ2VuIHN0YXRlIGluZGVudCBicl90eSA9XG4gIHN0YXRlLnBwX2N1cnJfZGVwdGggPC0gc3RhdGUucHBfY3Vycl9kZXB0aCArIDE7XG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXMgdGhlblxuICAgIGxldCBzaXplID0gU2l6ZS5vZl9pbnQgKC0gc3RhdGUucHBfcmlnaHRfdG90YWwpIGluXG4gICAgbGV0IGVsZW0gPSB7IHNpemU7IHRva2VuID0gUHBfYmVnaW4gKGluZGVudCwgYnJfdHkpOyBsZW5ndGggPSAwIH0gaW5cbiAgICBzY2FuX3B1c2ggc3RhdGUgZmFsc2UgZWxlbSBlbHNlXG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPSBzdGF0ZS5wcF9tYXhfYm94ZXNcbiAgdGhlbiBlbnF1ZXVlX3N0cmluZyBzdGF0ZSBzdGF0ZS5wcF9lbGxpcHNpc1xuXG5cbigqIFRoZSBib3ggd2hpY2ggaXMgYWx3YXlzIG9wZW4uICopXG5sZXQgcHBfb3Blbl9zeXNfYm94IHN0YXRlID0gcHBfb3Blbl9ib3hfZ2VuIHN0YXRlIDAgUHBfaG92Ym94XG5cbigqIENsb3NlIGEgYm94LCBzZXR0aW5nIHNpemVzIG9mIGl0cyBzdWIgYm94ZXMuICopXG5sZXQgcHBfY2xvc2VfYm94IHN0YXRlICgpID1cbiAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA+IDEgdGhlblxuICBiZWdpblxuICAgIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXMgdGhlblxuICAgIGJlZ2luXG4gICAgICBwcF9lbnF1ZXVlIHN0YXRlIHsgc2l6ZSA9IFNpemUuemVybzsgdG9rZW4gPSBQcF9lbmQ7IGxlbmd0aCA9IDAgfTtcbiAgICAgIHNldF9zaXplIHN0YXRlIHRydWU7IHNldF9zaXplIHN0YXRlIGZhbHNlXG4gICAgZW5kO1xuICAgIHN0YXRlLnBwX2N1cnJfZGVwdGggPC0gc3RhdGUucHBfY3Vycl9kZXB0aCAtIDE7XG4gIGVuZFxuXG5cbigqIE9wZW4gYSB0YWcsIHB1c2hpbmcgaXQgb24gdGhlIHRhZyBzdGFjay4gKilcbmxldCBwcF9vcGVuX3N0YWcgc3RhdGUgdGFnX25hbWUgPVxuICBpZiBzdGF0ZS5wcF9wcmludF90YWdzIHRoZW5cbiAgYmVnaW5cbiAgICBTdGFjay5wdXNoIHRhZ19uYW1lIHN0YXRlLnBwX3RhZ19zdGFjaztcbiAgICBzdGF0ZS5wcF9wcmludF9vcGVuX3RhZyB0YWdfbmFtZVxuICBlbmQ7XG4gIGlmIHN0YXRlLnBwX21hcmtfdGFncyB0aGVuXG4gICAgbGV0IHRva2VuID0gUHBfb3Blbl90YWcgdGFnX25hbWUgaW5cbiAgICBwcF9lbnF1ZXVlIHN0YXRlIHsgc2l6ZSA9IFNpemUuemVybzsgdG9rZW47IGxlbmd0aCA9IDAgfVxuXG5cbigqIENsb3NlIGEgdGFnLCBwb3BwaW5nIGl0IGZyb20gdGhlIHRhZyBzdGFjay4gKilcbmxldCBwcF9jbG9zZV9zdGFnIHN0YXRlICgpID1cbiAgaWYgc3RhdGUucHBfbWFya190YWdzIHRoZW5cbiAgICBwcF9lbnF1ZXVlIHN0YXRlIHsgc2l6ZSA9IFNpemUuemVybzsgdG9rZW4gPSBQcF9jbG9zZV90YWc7IGxlbmd0aCA9IDAgfTtcbiAgaWYgc3RhdGUucHBfcHJpbnRfdGFncyB0aGVuXG4gICAgbWF0Y2ggU3RhY2sucG9wX29wdCBzdGF0ZS5wcF90YWdfc3RhY2sgd2l0aFxuICAgIHwgTm9uZSAtPiAoKSAoKiBObyBtb3JlIHRhZyB0byBjbG9zZS4gKilcbiAgICB8IFNvbWUgdGFnX25hbWUgLT5cbiAgICAgIHN0YXRlLnBwX3ByaW50X2Nsb3NlX3RhZyB0YWdfbmFtZVxuXG5sZXQgcHBfb3Blbl90YWcgc3RhdGUgcyA9IHBwX29wZW5fc3RhZyBzdGF0ZSAoU3RyaW5nX3RhZyBzKVxubGV0IHBwX2Nsb3NlX3RhZyBzdGF0ZSAoKSA9IHBwX2Nsb3NlX3N0YWcgc3RhdGUgKClcblxubGV0IHBwX3NldF9wcmludF90YWdzIHN0YXRlIGIgPSBzdGF0ZS5wcF9wcmludF90YWdzIDwtIGJcbmxldCBwcF9zZXRfbWFya190YWdzIHN0YXRlIGIgPSBzdGF0ZS5wcF9tYXJrX3RhZ3MgPC0gYlxubGV0IHBwX2dldF9wcmludF90YWdzIHN0YXRlICgpID0gc3RhdGUucHBfcHJpbnRfdGFnc1xubGV0IHBwX2dldF9tYXJrX3RhZ3Mgc3RhdGUgKCkgPSBzdGF0ZS5wcF9tYXJrX3RhZ3NcbmxldCBwcF9zZXRfdGFncyBzdGF0ZSBiID1cbiAgcHBfc2V0X3ByaW50X3RhZ3Mgc3RhdGUgYjsgcHBfc2V0X21hcmtfdGFncyBzdGF0ZSBiXG5cblxuKCogSGFuZGxpbmcgdGFnIGhhbmRsaW5nIGZ1bmN0aW9uczogZ2V0L3NldCBmdW5jdGlvbnMuICopXG5sZXQgcHBfZ2V0X2Zvcm1hdHRlcl9zdGFnX2Z1bmN0aW9ucyBzdGF0ZSAoKSA9IHtcbiAgbWFya19vcGVuX3N0YWcgPSBzdGF0ZS5wcF9tYXJrX29wZW5fdGFnO1xuICBtYXJrX2Nsb3NlX3N0YWcgPSBzdGF0ZS5wcF9tYXJrX2Nsb3NlX3RhZztcbiAgcHJpbnRfb3Blbl9zdGFnID0gc3RhdGUucHBfcHJpbnRfb3Blbl90YWc7XG4gIHByaW50X2Nsb3NlX3N0YWcgPSBzdGF0ZS5wcF9wcmludF9jbG9zZV90YWc7XG59XG5cblxubGV0IHBwX3NldF9mb3JtYXR0ZXJfc3RhZ19mdW5jdGlvbnMgc3RhdGUge1xuICAgICBtYXJrX29wZW5fc3RhZyA9IG1vdDtcbiAgICAgbWFya19jbG9zZV9zdGFnID0gbWN0O1xuICAgICBwcmludF9vcGVuX3N0YWcgPSBwb3Q7XG4gICAgIHByaW50X2Nsb3NlX3N0YWcgPSBwY3Q7XG4gIH0gPVxuICBzdGF0ZS5wcF9tYXJrX29wZW5fdGFnIDwtIG1vdDtcbiAgc3RhdGUucHBfbWFya19jbG9zZV90YWcgPC0gbWN0O1xuICBzdGF0ZS5wcF9wcmludF9vcGVuX3RhZyA8LSBwb3Q7XG4gIHN0YXRlLnBwX3ByaW50X2Nsb3NlX3RhZyA8LSBwY3RcblxuXG4oKiBJbml0aWFsaXplIHByZXR0eS1wcmludGVyLiAqKVxubGV0IHBwX3Jpbml0IHN0YXRlID1cbiAgcHBfY2xlYXJfcXVldWUgc3RhdGU7XG4gIGluaXRpYWxpemVfc2Nhbl9zdGFjayBzdGF0ZS5wcF9zY2FuX3N0YWNrO1xuICBTdGFjay5jbGVhciBzdGF0ZS5wcF9mb3JtYXRfc3RhY2s7XG4gIFN0YWNrLmNsZWFyIHN0YXRlLnBwX3Rib3hfc3RhY2s7XG4gIFN0YWNrLmNsZWFyIHN0YXRlLnBwX3RhZ19zdGFjaztcbiAgU3RhY2suY2xlYXIgc3RhdGUucHBfbWFya19zdGFjaztcbiAgc3RhdGUucHBfY3VycmVudF9pbmRlbnQgPC0gMDtcbiAgc3RhdGUucHBfY3Vycl9kZXB0aCA8LSAwO1xuICBzdGF0ZS5wcF9zcGFjZV9sZWZ0IDwtIHN0YXRlLnBwX21hcmdpbjtcbiAgcHBfb3Blbl9zeXNfYm94IHN0YXRlXG5cbmxldCBjbGVhcl90YWdfc3RhY2sgc3RhdGUgPVxuICBTdGFjay5pdGVyIChmdW4gXyAtPiBwcF9jbG9zZV90YWcgc3RhdGUgKCkpIHN0YXRlLnBwX3RhZ19zdGFja1xuXG5cbigqIEZsdXNoaW5nIHByZXR0eS1wcmludGVyIHF1ZXVlLiAqKVxubGV0IHBwX2ZsdXNoX3F1ZXVlIHN0YXRlIGIgPVxuICBjbGVhcl90YWdfc3RhY2sgc3RhdGU7XG4gIHdoaWxlIHN0YXRlLnBwX2N1cnJfZGVwdGggPiAxIGRvXG4gICAgcHBfY2xvc2VfYm94IHN0YXRlICgpXG4gIGRvbmU7XG4gIHN0YXRlLnBwX3JpZ2h0X3RvdGFsIDwtIHBwX2luZmluaXR5O1xuICBhZHZhbmNlX2xlZnQgc3RhdGU7XG4gIGlmIGIgdGhlbiBwcF9vdXRwdXRfbmV3bGluZSBzdGF0ZTtcbiAgcHBfcmluaXQgc3RhdGVcblxuKCpcblxuICBQcm9jZWR1cmVzIHRvIGZvcm1hdCB2YWx1ZXMgYW5kIHVzZSBib3hlcy5cblxuKilcblxuKCogVG8gZm9ybWF0IGEgc3RyaW5nLiAqKVxubGV0IHBwX3ByaW50X2FzX3NpemUgc3RhdGUgc2l6ZSBzID1cbiAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA8IHN0YXRlLnBwX21heF9ib3hlc1xuICB0aGVuIGVucXVldWVfc3RyaW5nX2FzIHN0YXRlIHNpemUgc1xuXG5cbmxldCBwcF9wcmludF9hcyBzdGF0ZSBpc2l6ZSBzID1cbiAgcHBfcHJpbnRfYXNfc2l6ZSBzdGF0ZSAoU2l6ZS5vZl9pbnQgaXNpemUpIHNcblxuXG5sZXQgcHBfcHJpbnRfc3RyaW5nIHN0YXRlIHMgPVxuICBwcF9wcmludF9hcyBzdGF0ZSAoU3RyaW5nLmxlbmd0aCBzKSBzXG5cbmxldCBwcF9wcmludF9ieXRlcyBzdGF0ZSBzID1cbiAgcHBfcHJpbnRfYXMgc3RhdGUgKEJ5dGVzLmxlbmd0aCBzKSAoQnl0ZXMudG9fc3RyaW5nIHMpXG5cbigqIFRvIGZvcm1hdCBhbiBpbnRlZ2VyLiAqKVxubGV0IHBwX3ByaW50X2ludCBzdGF0ZSBpID0gcHBfcHJpbnRfc3RyaW5nIHN0YXRlIChJbnQudG9fc3RyaW5nIGkpXG5cbigqIFRvIGZvcm1hdCBhIGZsb2F0LiAqKVxubGV0IHBwX3ByaW50X2Zsb2F0IHN0YXRlIGYgPSBwcF9wcmludF9zdHJpbmcgc3RhdGUgKHN0cmluZ19vZl9mbG9hdCBmKVxuXG4oKiBUbyBmb3JtYXQgYSBib29sZWFuLiAqKVxubGV0IHBwX3ByaW50X2Jvb2wgc3RhdGUgYiA9IHBwX3ByaW50X3N0cmluZyBzdGF0ZSAoc3RyaW5nX29mX2Jvb2wgYilcblxuKCogVG8gZm9ybWF0IGEgY2hhci4gKilcbmxldCBwcF9wcmludF9jaGFyIHN0YXRlIGMgPVxuICBwcF9wcmludF9hcyBzdGF0ZSAxIChTdHJpbmcubWFrZSAxIGMpXG5cblxuKCogT3BlbmluZyBib3hlcy4gKilcbmxldCBwcF9vcGVuX2hib3ggc3RhdGUgKCkgPSBwcF9vcGVuX2JveF9nZW4gc3RhdGUgMCBQcF9oYm94XG5hbmQgcHBfb3Blbl92Ym94IHN0YXRlIGluZGVudCA9IHBwX29wZW5fYm94X2dlbiBzdGF0ZSBpbmRlbnQgUHBfdmJveFxuXG5hbmQgcHBfb3Blbl9odmJveCBzdGF0ZSBpbmRlbnQgPSBwcF9vcGVuX2JveF9nZW4gc3RhdGUgaW5kZW50IFBwX2h2Ym94XG5hbmQgcHBfb3Blbl9ob3Zib3ggc3RhdGUgaW5kZW50ID0gcHBfb3Blbl9ib3hfZ2VuIHN0YXRlIGluZGVudCBQcF9ob3Zib3hcbmFuZCBwcF9vcGVuX2JveCBzdGF0ZSBpbmRlbnQgPSBwcF9vcGVuX2JveF9nZW4gc3RhdGUgaW5kZW50IFBwX2JveFxuXG5cbigqIFByaW50aW5nIHF1ZXVlZCB0ZXh0LlxuXG4gICBbcHBfcHJpbnRfZmx1c2hdIHByaW50cyBhbGwgcGVuZGluZyBpdGVtcyBpbiB0aGUgcHJldHR5LXByaW50ZXIgcXVldWUgYW5kXG4gICB0aGVuIGZsdXNoZXMgdGhlIGxvdyBsZXZlbCBvdXRwdXQgZGV2aWNlIG9mIHRoZSBmb3JtYXR0ZXIgdG8gYWN0dWFsbHlcbiAgIGRpc3BsYXkgcHJpbnRpbmcgbWF0ZXJpYWwuXG5cbiAgIFtwcF9wcmludF9uZXdsaW5lXSBiZWhhdmVzIGFzIFtwcF9wcmludF9mbHVzaF0gYWZ0ZXIgcHJpbnRpbmcgYW4gYWRkaXRpb25hbFxuICAgbmV3IGxpbmUuICopXG5sZXQgcHBfcHJpbnRfbmV3bGluZSBzdGF0ZSAoKSA9XG4gIHBwX2ZsdXNoX3F1ZXVlIHN0YXRlIHRydWU7IHN0YXRlLnBwX291dF9mbHVzaCAoKVxuYW5kIHBwX3ByaW50X2ZsdXNoIHN0YXRlICgpID1cbiAgcHBfZmx1c2hfcXVldWUgc3RhdGUgZmFsc2U7IHN0YXRlLnBwX291dF9mbHVzaCAoKVxuXG5cbigqIFRvIGdldCBhIG5ld2xpbmUgd2hlbiBvbmUgZG9lcyBub3Qgd2FudCB0byBjbG9zZSB0aGUgY3VycmVudCBib3guICopXG5sZXQgcHBfZm9yY2VfbmV3bGluZSBzdGF0ZSAoKSA9XG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXMgdGhlblxuICAgIGVucXVldWVfYWR2YW5jZSBzdGF0ZSB7IHNpemUgPSBTaXplLnplcm87IHRva2VuID0gUHBfbmV3bGluZTsgbGVuZ3RoID0gMCB9XG5cblxuKCogVG8gZm9ybWF0IHNvbWV0aGluZywgb25seSBpbiBjYXNlIHRoZSBsaW5lIGhhcyBqdXN0IGJlZW4gYnJva2VuLiAqKVxubGV0IHBwX3ByaW50X2lmX25ld2xpbmUgc3RhdGUgKCkgPVxuICBpZiBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwgc3RhdGUucHBfbWF4X2JveGVzIHRoZW5cbiAgICBlbnF1ZXVlX2FkdmFuY2Ugc3RhdGVcbiAgICAgIHsgc2l6ZSA9IFNpemUuemVybzsgdG9rZW4gPSBQcF9pZl9uZXdsaW5lOyBsZW5ndGggPSAwIH1cblxuXG4oKiBHZW5lcmFsaXplZCBicmVhayBoaW50IHRoYXQgYWxsb3dzIHByaW50aW5nIHN0cmluZ3MgYmVmb3JlL2FmdGVyXG4gICBzYW1lLWxpbmUgb2Zmc2V0ICh3aWR0aCkgb3IgbmV3LWxpbmUgb2Zmc2V0ICopXG5sZXQgcHBfcHJpbnRfY3VzdG9tX2JyZWFrIHN0YXRlIH5maXRzIH5icmVha3MgPVxuICBsZXQgYmVmb3JlLCB3aWR0aCwgYWZ0ZXIgPSBmaXRzIGluXG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXMgdGhlblxuICAgIGxldCBzaXplID0gU2l6ZS5vZl9pbnQgKC0gc3RhdGUucHBfcmlnaHRfdG90YWwpIGluXG4gICAgbGV0IHRva2VuID0gUHBfYnJlYWsgeyBmaXRzOyBicmVha3MgfSBpblxuICAgIGxldCBsZW5ndGggPSBTdHJpbmcubGVuZ3RoIGJlZm9yZSArIHdpZHRoICsgU3RyaW5nLmxlbmd0aCBhZnRlciBpblxuICAgIGxldCBlbGVtID0geyBzaXplOyB0b2tlbjsgbGVuZ3RoIH0gaW5cbiAgICBzY2FuX3B1c2ggc3RhdGUgdHJ1ZSBlbGVtXG5cbigqIFByaW50aW5nIGJyZWFrIGhpbnRzOlxuICAgQSBicmVhayBoaW50IGluZGljYXRlcyB3aGVyZSBhIGJveCBtYXkgYmUgYnJva2VuLlxuICAgSWYgbGluZSBpcyBicm9rZW4gdGhlbiBvZmZzZXQgaXMgYWRkZWQgdG8gdGhlIGluZGVudGF0aW9uIG9mIHRoZSBjdXJyZW50XG4gICBib3ggZWxzZSAodGhlIHZhbHVlIG9mKSB3aWR0aCBibGFua3MgYXJlIHByaW50ZWQuICopXG5sZXQgcHBfcHJpbnRfYnJlYWsgc3RhdGUgd2lkdGggb2Zmc2V0ID1cbiAgcHBfcHJpbnRfY3VzdG9tX2JyZWFrIHN0YXRlXG4gICAgfmZpdHM6KFwiXCIsIHdpZHRoLCBcIlwiKSB+YnJlYWtzOihcIlwiLCBvZmZzZXQsIFwiXCIpXG5cblxuKCogUHJpbnQgYSBzcGFjZSA6XG4gICBhIHNwYWNlIGlzIGEgYnJlYWsgaGludCB0aGF0IHByaW50cyBhIHNpbmdsZSBzcGFjZSBpZiB0aGUgYnJlYWsgZG9lcyBub3RcbiAgIHNwbGl0IHRoZSBsaW5lO1xuICAgYSBjdXQgaXMgYSBicmVhayBoaW50IHRoYXQgcHJpbnRzIG5vdGhpbmcgaWYgdGhlIGJyZWFrIGRvZXMgbm90IHNwbGl0IHRoZVxuICAgbGluZS4gKilcbmxldCBwcF9wcmludF9zcGFjZSBzdGF0ZSAoKSA9IHBwX3ByaW50X2JyZWFrIHN0YXRlIDEgMFxuYW5kIHBwX3ByaW50X2N1dCBzdGF0ZSAoKSA9IHBwX3ByaW50X2JyZWFrIHN0YXRlIDAgMFxuXG5cbigqIFRhYnVsYXRpb24gYm94ZXMuICopXG5sZXQgcHBfb3Blbl90Ym94IHN0YXRlICgpID1cbiAgc3RhdGUucHBfY3Vycl9kZXB0aCA8LSBzdGF0ZS5wcF9jdXJyX2RlcHRoICsgMTtcbiAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA8IHN0YXRlLnBwX21heF9ib3hlcyB0aGVuXG4gICAgbGV0IHNpemUgPSBTaXplLnplcm8gaW5cbiAgICBsZXQgZWxlbSA9IHsgc2l6ZTsgdG9rZW4gPSBQcF90YmVnaW4gKFBwX3Rib3ggKHJlZiBbXSkpOyBsZW5ndGggPSAwIH0gaW5cbiAgICBlbnF1ZXVlX2FkdmFuY2Ugc3RhdGUgZWxlbVxuXG5cbigqIENsb3NlIGEgdGFidWxhdGlvbiBib3guICopXG5sZXQgcHBfY2xvc2VfdGJveCBzdGF0ZSAoKSA9XG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPiAxIHRoZW5cbiAgYmVnaW5cbiAgIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXMgdGhlblxuICAgICBsZXQgZWxlbSA9IHsgc2l6ZSA9IFNpemUuemVybzsgdG9rZW4gPSBQcF90ZW5kOyBsZW5ndGggPSAwIH0gaW5cbiAgICAgZW5xdWV1ZV9hZHZhbmNlIHN0YXRlIGVsZW07XG4gICAgIHN0YXRlLnBwX2N1cnJfZGVwdGggPC0gc3RhdGUucHBfY3Vycl9kZXB0aCAtIDFcbiAgZW5kXG5cblxuKCogUHJpbnQgYSB0YWJ1bGF0aW9uIGJyZWFrLiAqKVxubGV0IHBwX3ByaW50X3RicmVhayBzdGF0ZSB3aWR0aCBvZmZzZXQgPVxuICBpZiBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwgc3RhdGUucHBfbWF4X2JveGVzIHRoZW5cbiAgICBsZXQgc2l6ZSA9IFNpemUub2ZfaW50ICgtIHN0YXRlLnBwX3JpZ2h0X3RvdGFsKSBpblxuICAgIGxldCBlbGVtID0geyBzaXplOyB0b2tlbiA9IFBwX3RicmVhayAod2lkdGgsIG9mZnNldCk7IGxlbmd0aCA9IHdpZHRoIH0gaW5cbiAgICBzY2FuX3B1c2ggc3RhdGUgdHJ1ZSBlbGVtXG5cblxubGV0IHBwX3ByaW50X3RhYiBzdGF0ZSAoKSA9IHBwX3ByaW50X3RicmVhayBzdGF0ZSAwIDBcblxubGV0IHBwX3NldF90YWIgc3RhdGUgKCkgPVxuICBpZiBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwgc3RhdGUucHBfbWF4X2JveGVzIHRoZW5cbiAgICBsZXQgZWxlbSA9IHsgc2l6ZSA9IFNpemUuemVybzsgdG9rZW4gPSBQcF9zdGFiOyBsZW5ndGggPSAwIH0gaW5cbiAgICBlbnF1ZXVlX2FkdmFuY2Ugc3RhdGUgZWxlbVxuXG5cbigqXG5cbiAgUHJvY2VkdXJlcyB0byBjb250cm9sIHRoZSBwcmV0dHktcHJpbnRlcnNcblxuKilcblxuKCogU2V0X21heF9ib3hlcy4gKilcbmxldCBwcF9zZXRfbWF4X2JveGVzIHN0YXRlIG4gPSBpZiBuID4gMSB0aGVuIHN0YXRlLnBwX21heF9ib3hlcyA8LSBuXG5cbigqIFRvIGtub3cgdGhlIGN1cnJlbnQgbWF4aW11bSBudW1iZXIgb2YgYm94ZXMgYWxsb3dlZC4gKilcbmxldCBwcF9nZXRfbWF4X2JveGVzIHN0YXRlICgpID0gc3RhdGUucHBfbWF4X2JveGVzXG5cbmxldCBwcF9vdmVyX21heF9ib3hlcyBzdGF0ZSAoKSA9IHN0YXRlLnBwX2N1cnJfZGVwdGggPSBzdGF0ZS5wcF9tYXhfYm94ZXNcblxuKCogRWxsaXBzaXMuICopXG5sZXQgcHBfc2V0X2VsbGlwc2lzX3RleHQgc3RhdGUgcyA9IHN0YXRlLnBwX2VsbGlwc2lzIDwtIHNcbmFuZCBwcF9nZXRfZWxsaXBzaXNfdGV4dCBzdGF0ZSAoKSA9IHN0YXRlLnBwX2VsbGlwc2lzXG5cblxuKCogVG8gc2V0IHRoZSBtYXJnaW4gb2YgcHJldHR5LXByaW50ZXIuICopXG5sZXQgcHBfbGltaXQgbiA9XG4gIGlmIG4gPCBwcF9pbmZpbml0eSB0aGVuIG4gZWxzZSBwcmVkIHBwX2luZmluaXR5XG5cblxuKCogSW50ZXJuYWwgcHJldHR5LXByaW50ZXIgZnVuY3Rpb25zLiAqKVxubGV0IHBwX3NldF9taW5fc3BhY2VfbGVmdCBzdGF0ZSBuID1cbiAgaWYgbiA+PSAxIHRoZW5cbiAgICBsZXQgbiA9IHBwX2xpbWl0IG4gaW5cbiAgICBzdGF0ZS5wcF9taW5fc3BhY2VfbGVmdCA8LSBuO1xuICAgIHN0YXRlLnBwX21heF9pbmRlbnQgPC0gc3RhdGUucHBfbWFyZ2luIC0gc3RhdGUucHBfbWluX3NwYWNlX2xlZnQ7XG4gICAgcHBfcmluaXQgc3RhdGVcblxuXG4oKiBJbml0aWFsbHksIHdlIGhhdmUgOlxuICAgcHBfbWF4X2luZGVudCA9IHBwX21hcmdpbiAtIHBwX21pbl9zcGFjZV9sZWZ0LCBhbmRcbiAgIHBwX3NwYWNlX2xlZnQgPSBwcF9tYXJnaW4uICopXG5sZXQgcHBfc2V0X21heF9pbmRlbnQgc3RhdGUgbiA9XG4gIGlmIG4gPiAxIHRoZW5cbiAgICBwcF9zZXRfbWluX3NwYWNlX2xlZnQgc3RhdGUgKHN0YXRlLnBwX21hcmdpbiAtIG4pXG5cblxubGV0IHBwX2dldF9tYXhfaW5kZW50IHN0YXRlICgpID0gc3RhdGUucHBfbWF4X2luZGVudFxuXG5sZXQgcHBfc2V0X21hcmdpbiBzdGF0ZSBuID1cbiAgaWYgbiA+PSAxIHRoZW5cbiAgICBsZXQgbiA9IHBwX2xpbWl0IG4gaW5cbiAgICBzdGF0ZS5wcF9tYXJnaW4gPC0gbjtcbiAgICBsZXQgbmV3X21heF9pbmRlbnQgPVxuICAgICAgKCogVHJ5IHRvIG1haW50YWluIG1heF9pbmRlbnQgdG8gaXRzIGFjdHVhbCB2YWx1ZS4gKilcbiAgICAgIGlmIHN0YXRlLnBwX21heF9pbmRlbnQgPD0gc3RhdGUucHBfbWFyZ2luXG4gICAgICB0aGVuIHN0YXRlLnBwX21heF9pbmRlbnQgZWxzZVxuICAgICAgKCogSWYgcG9zc2libGUgbWFpbnRhaW4gcHBfbWluX3NwYWNlX2xlZnQgdG8gaXRzIGFjdHVhbCB2YWx1ZSxcbiAgICAgICAgIGlmIHRoaXMgbGVhZHMgdG8gYSB0b28gc21hbGwgbWF4X2luZGVudCwgdGFrZSBoYWxmIG9mIHRoZVxuICAgICAgICAgbmV3IG1hcmdpbiwgaWYgaXQgaXMgZ3JlYXRlciB0aGFuIDEuICopXG4gICAgICAgSW50Lm1heCAoSW50Lm1heCAoc3RhdGUucHBfbWFyZ2luIC0gc3RhdGUucHBfbWluX3NwYWNlX2xlZnQpXG4gICAgICAgICAgICAgICAgKHN0YXRlLnBwX21hcmdpbiAvIDIpKSAxIGluXG4gICAgKCogUmVidWlsZCBpbnZhcmlhbnRzLiAqKVxuICAgIHBwX3NldF9tYXhfaW5kZW50IHN0YXRlIG5ld19tYXhfaW5kZW50XG5cblxuKCoqIEdlb21ldHJ5IGZ1bmN0aW9ucyBhbmQgdHlwZXMgKilcbnR5cGUgZ2VvbWV0cnkgPSB7IG1heF9pbmRlbnQ6aW50OyBtYXJnaW46IGludH1cblxubGV0IHZhbGlkYXRlX2dlb21ldHJ5IHttYXJnaW47IG1heF9pbmRlbnR9ID1cbiAgaWYgbWF4X2luZGVudCA8IDIgdGhlblxuICAgIEVycm9yIFwibWF4X2luZGVudCA8IDJcIlxuICBlbHNlIGlmIG1hcmdpbiA8PSBtYXhfaW5kZW50IHRoZW5cbiAgICBFcnJvciBcIm1hcmdpbiA8PSBtYXhfaW5kZW50XCJcbiAgZWxzZSBPayAoKVxuXG5sZXQgY2hlY2tfZ2VvbWV0cnkgZ2VvbWV0cnkgPVxuICBtYXRjaCB2YWxpZGF0ZV9nZW9tZXRyeSBnZW9tZXRyeSB3aXRoXG4gIHwgT2sgKCkgLT4gdHJ1ZVxuICB8IEVycm9yIF8gLT4gZmFsc2VcblxubGV0IHBwX2dldF9tYXJnaW4gc3RhdGUgKCkgPSBzdGF0ZS5wcF9tYXJnaW5cblxubGV0IHBwX3NldF9mdWxsX2dlb21ldHJ5IHN0YXRlIHttYXJnaW47IG1heF9pbmRlbnR9ID1cbiAgcHBfc2V0X21hcmdpbiBzdGF0ZSBtYXJnaW47XG4gIHBwX3NldF9tYXhfaW5kZW50IHN0YXRlIG1heF9pbmRlbnQ7XG4gICgpXG5cbmxldCBwcF9zZXRfZ2VvbWV0cnkgc3RhdGUgfm1heF9pbmRlbnQgfm1hcmdpbiA9XG4gIGxldCBnZW9tZXRyeSA9IHsgbWF4X2luZGVudDsgbWFyZ2luIH0gaW5cbiAgbWF0Y2ggdmFsaWRhdGVfZ2VvbWV0cnkgZ2VvbWV0cnkgd2l0aFxuICB8IEVycm9yIG1zZyAtPlxuICAgIHJhaXNlIChJbnZhbGlkX2FyZ3VtZW50IChcIkZvcm1hdC5wcF9zZXRfZ2VvbWV0cnk6IFwiIF4gbXNnKSlcbiAgfCBPayAoKSAtPlxuICAgIHBwX3NldF9mdWxsX2dlb21ldHJ5IHN0YXRlIGdlb21ldHJ5XG5cbmxldCBwcF9zYWZlX3NldF9nZW9tZXRyeSBzdGF0ZSB+bWF4X2luZGVudCB+bWFyZ2luID1cbiAgbGV0IGdlb21ldHJ5ID0geyBtYXhfaW5kZW50OyBtYXJnaW4gfSBpblxuICBtYXRjaCB2YWxpZGF0ZV9nZW9tZXRyeSBnZW9tZXRyeSB3aXRoXG4gIHwgRXJyb3IgX21zZyAtPlxuICAgICAoKVxuICB8IE9rICgpIC0+XG4gICAgcHBfc2V0X2Z1bGxfZ2VvbWV0cnkgc3RhdGUgZ2VvbWV0cnlcblxubGV0IHBwX2dldF9nZW9tZXRyeSBzdGF0ZSAoKSA9XG4gIHsgbWFyZ2luID0gcHBfZ2V0X21hcmdpbiBzdGF0ZSAoKTsgbWF4X2luZGVudCA9IHBwX2dldF9tYXhfaW5kZW50IHN0YXRlICgpIH1cblxubGV0IHBwX3VwZGF0ZV9nZW9tZXRyeSBzdGF0ZSB1cGRhdGUgPVxuICBsZXQgZ2VvbWV0cnkgPSBwcF9nZXRfZ2VvbWV0cnkgc3RhdGUgKCkgaW5cbiAgcHBfc2V0X2Z1bGxfZ2VvbWV0cnkgc3RhdGUgKHVwZGF0ZSBnZW9tZXRyeSlcblxuKCogU2V0dGluZyBhIGZvcm1hdHRlciBiYXNpYyBvdXRwdXQgZnVuY3Rpb25zLiAqKVxubGV0IHBwX3NldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyBzdGF0ZSB7XG4gICAgICBvdXRfc3RyaW5nID0gZjtcbiAgICAgIG91dF9mbHVzaCA9IGc7XG4gICAgICBvdXRfbmV3bGluZSA9IGg7XG4gICAgICBvdXRfc3BhY2VzID0gaTtcbiAgICAgIG91dF9pbmRlbnQgPSBqO1xuICAgIH0gPVxuICBzdGF0ZS5wcF9vdXRfc3RyaW5nIDwtIGY7XG4gIHN0YXRlLnBwX291dF9mbHVzaCA8LSBnO1xuICBzdGF0ZS5wcF9vdXRfbmV3bGluZSA8LSBoO1xuICBzdGF0ZS5wcF9vdXRfc3BhY2VzIDwtIGk7XG4gIHN0YXRlLnBwX291dF9pbmRlbnQgPC0galxuXG5sZXQgcHBfZ2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zIHN0YXRlICgpID0ge1xuICBvdXRfc3RyaW5nID0gc3RhdGUucHBfb3V0X3N0cmluZztcbiAgb3V0X2ZsdXNoID0gc3RhdGUucHBfb3V0X2ZsdXNoO1xuICBvdXRfbmV3bGluZSA9IHN0YXRlLnBwX291dF9uZXdsaW5lO1xuICBvdXRfc3BhY2VzID0gc3RhdGUucHBfb3V0X3NwYWNlcztcbiAgb3V0X2luZGVudCA9IHN0YXRlLnBwX291dF9pbmRlbnQ7XG59XG5cblxuKCogU2V0dGluZyBhIGZvcm1hdHRlciBiYXNpYyBzdHJpbmcgb3V0cHV0IGFuZCBmbHVzaCBmdW5jdGlvbnMuICopXG5sZXQgcHBfc2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIHN0YXRlIGYgZyA9XG4gIHN0YXRlLnBwX291dF9zdHJpbmcgPC0gZjsgc3RhdGUucHBfb3V0X2ZsdXNoIDwtIGdcblxubGV0IHBwX2dldF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyBzdGF0ZSAoKSA9XG4gIChzdGF0ZS5wcF9vdXRfc3RyaW5nLCBzdGF0ZS5wcF9vdXRfZmx1c2gpXG5cblxuKCogVGhlIGRlZmF1bHQgZnVuY3Rpb24gdG8gb3V0cHV0IG5ldyBsaW5lcy4gKilcbmxldCBkaXNwbGF5X25ld2xpbmUgc3RhdGUgKCkgPSBzdGF0ZS5wcF9vdXRfc3RyaW5nIFwiXFxuXCIgMCAgMVxuXG4oKiBUaGUgZGVmYXVsdCBmdW5jdGlvbiB0byBvdXRwdXQgc3BhY2VzLiAqKVxubGV0IGJsYW5rX2xpbmUgPSBTdHJpbmcubWFrZSA4MCAnICdcbmxldCByZWMgZGlzcGxheV9ibGFua3Mgc3RhdGUgbiA9XG4gIGlmIG4gPiAwIHRoZW5cbiAgaWYgbiA8PSA4MCB0aGVuIHN0YXRlLnBwX291dF9zdHJpbmcgYmxhbmtfbGluZSAwIG4gZWxzZVxuICBiZWdpblxuICAgIHN0YXRlLnBwX291dF9zdHJpbmcgYmxhbmtfbGluZSAwIDgwO1xuICAgIGRpc3BsYXlfYmxhbmtzIHN0YXRlIChuIC0gODApXG4gIGVuZFxuXG5cbigqIFRoZSBkZWZhdWx0IGZ1bmN0aW9uIHRvIG91dHB1dCBpbmRlbnRhdGlvbiBvZiBuZXcgbGluZXMuICopXG5sZXQgZGlzcGxheV9pbmRlbnQgPSBkaXNwbGF5X2JsYW5rc1xuXG4oKiBTZXR0aW5nIGEgZm9ybWF0dGVyIGJhc2ljIG91dHB1dCBmdW5jdGlvbnMgYXMgcHJpbnRpbmcgdG8gYSBnaXZlblxuICAgW1BlcnZhc2l2ZS5vdXRfY2hhbm5lbF0gdmFsdWUuICopXG5sZXQgcHBfc2V0X2Zvcm1hdHRlcl9vdXRfY2hhbm5lbCBzdGF0ZSBvYyA9XG4gIHN0YXRlLnBwX291dF9zdHJpbmcgPC0gb3V0cHV0X3N1YnN0cmluZyBvYztcbiAgc3RhdGUucHBfb3V0X2ZsdXNoIDwtIChmdW4gKCkgLT4gZmx1c2ggb2MpO1xuICBzdGF0ZS5wcF9vdXRfbmV3bGluZSA8LSBkaXNwbGF5X25ld2xpbmUgc3RhdGU7XG4gIHN0YXRlLnBwX291dF9zcGFjZXMgPC0gZGlzcGxheV9ibGFua3Mgc3RhdGU7XG4gIHN0YXRlLnBwX291dF9pbmRlbnQgPC0gZGlzcGxheV9pbmRlbnQgc3RhdGVcblxuKCpcblxuICBEZWZpbmluZyBzcGVjaWZpYyBmb3JtYXR0ZXJzXG5cbiopXG5cbmxldCBkZWZhdWx0X3BwX21hcmtfb3Blbl90YWcgPSBmdW5jdGlvblxuICB8IFN0cmluZ190YWcgcyAtPiBcIjxcIiBeIHMgXiBcIj5cIlxuICB8IF8gLT4gXCJcIlxubGV0IGRlZmF1bHRfcHBfbWFya19jbG9zZV90YWcgPSBmdW5jdGlvblxuICB8IFN0cmluZ190YWcgcyAtPiBcIjwvXCIgXiBzIF4gXCI+XCJcbiAgfCBfIC0+IFwiXCJcblxubGV0IGRlZmF1bHRfcHBfcHJpbnRfb3Blbl90YWcgPSBpZ25vcmVcbmxldCBkZWZhdWx0X3BwX3ByaW50X2Nsb3NlX3RhZyA9IGlnbm9yZVxuXG4oKiBCdWlsZGluZyBhIGZvcm1hdHRlciBnaXZlbiBpdHMgYmFzaWMgb3V0cHV0IGZ1bmN0aW9ucy5cbiAgIE90aGVyIGZpZWxkcyBnZXQgcmVhc29uYWJsZSBkZWZhdWx0IHZhbHVlcy4gKilcbmxldCBwcF9tYWtlX2Zvcm1hdHRlciBmIGcgaCBpIGogPVxuICAoKiBUaGUgaW5pdGlhbCBzdGF0ZSBvZiB0aGUgZm9ybWF0dGVyIGNvbnRhaW5zIGEgZHVtbXkgYm94LiAqKVxuICBsZXQgcHBfcXVldWUgPSBRdWV1ZS5jcmVhdGUgKCkgaW5cbiAgbGV0IHN5c190b2sgPVxuICAgIHsgc2l6ZSA9IFNpemUudW5rbm93bjsgdG9rZW4gPSBQcF9iZWdpbiAoMCwgUHBfaG92Ym94KTsgbGVuZ3RoID0gMCB9IGluXG4gIFF1ZXVlLmFkZCBzeXNfdG9rIHBwX3F1ZXVlO1xuICBsZXQgc2Nhbl9zdGFjayA9IFN0YWNrLmNyZWF0ZSAoKSBpblxuICBpbml0aWFsaXplX3NjYW5fc3RhY2sgc2Nhbl9zdGFjaztcbiAgU3RhY2sucHVzaCB7IGxlZnRfdG90YWwgPSAxOyBxdWV1ZV9lbGVtID0gc3lzX3RvayB9IHNjYW5fc3RhY2s7XG4gIGxldCBwcF9tYXJnaW4gPSA3OFxuICBhbmQgcHBfbWluX3NwYWNlX2xlZnQgPSAxMCBpblxuICB7XG4gICAgcHBfc2Nhbl9zdGFjayA9IHNjYW5fc3RhY2s7XG4gICAgcHBfZm9ybWF0X3N0YWNrID0gU3RhY2suY3JlYXRlICgpO1xuICAgIHBwX3Rib3hfc3RhY2sgPSBTdGFjay5jcmVhdGUgKCk7XG4gICAgcHBfdGFnX3N0YWNrID0gU3RhY2suY3JlYXRlICgpO1xuICAgIHBwX21hcmtfc3RhY2sgPSBTdGFjay5jcmVhdGUgKCk7XG4gICAgcHBfbWFyZ2luID0gcHBfbWFyZ2luO1xuICAgIHBwX21pbl9zcGFjZV9sZWZ0ID0gcHBfbWluX3NwYWNlX2xlZnQ7XG4gICAgcHBfbWF4X2luZGVudCA9IHBwX21hcmdpbiAtIHBwX21pbl9zcGFjZV9sZWZ0O1xuICAgIHBwX3NwYWNlX2xlZnQgPSBwcF9tYXJnaW47XG4gICAgcHBfY3VycmVudF9pbmRlbnQgPSAwO1xuICAgIHBwX2lzX25ld19saW5lID0gdHJ1ZTtcbiAgICBwcF9sZWZ0X3RvdGFsID0gMTtcbiAgICBwcF9yaWdodF90b3RhbCA9IDE7XG4gICAgcHBfY3Vycl9kZXB0aCA9IDE7XG4gICAgcHBfbWF4X2JveGVzID0gbWF4X2ludDtcbiAgICBwcF9lbGxpcHNpcyA9IFwiLlwiO1xuICAgIHBwX291dF9zdHJpbmcgPSBmO1xuICAgIHBwX291dF9mbHVzaCA9IGc7XG4gICAgcHBfb3V0X25ld2xpbmUgPSBoO1xuICAgIHBwX291dF9zcGFjZXMgPSBpO1xuICAgIHBwX291dF9pbmRlbnQgPSBqO1xuICAgIHBwX3ByaW50X3RhZ3MgPSBmYWxzZTtcbiAgICBwcF9tYXJrX3RhZ3MgPSBmYWxzZTtcbiAgICBwcF9tYXJrX29wZW5fdGFnID0gZGVmYXVsdF9wcF9tYXJrX29wZW5fdGFnO1xuICAgIHBwX21hcmtfY2xvc2VfdGFnID0gZGVmYXVsdF9wcF9tYXJrX2Nsb3NlX3RhZztcbiAgICBwcF9wcmludF9vcGVuX3RhZyA9IGRlZmF1bHRfcHBfcHJpbnRfb3Blbl90YWc7XG4gICAgcHBfcHJpbnRfY2xvc2VfdGFnID0gZGVmYXVsdF9wcF9wcmludF9jbG9zZV90YWc7XG4gICAgcHBfcXVldWUgPSBwcF9xdWV1ZTtcbiAgfVxuXG5cbigqIEJ1aWxkIGEgZm9ybWF0dGVyIG91dCBvZiBpdHMgb3V0IGZ1bmN0aW9ucy4gKilcbmxldCBmb3JtYXR0ZXJfb2Zfb3V0X2Z1bmN0aW9ucyBvdXRfZnVucyA9XG4gIHBwX21ha2VfZm9ybWF0dGVyXG4gICAgb3V0X2Z1bnMub3V0X3N0cmluZ1xuICAgIG91dF9mdW5zLm91dF9mbHVzaFxuICAgIG91dF9mdW5zLm91dF9uZXdsaW5lXG4gICAgb3V0X2Z1bnMub3V0X3NwYWNlc1xuICAgIG91dF9mdW5zLm91dF9pbmRlbnRcblxuXG4oKiBNYWtlIGEgZm9ybWF0dGVyIHdpdGggZGVmYXVsdCBmdW5jdGlvbnMgdG8gb3V0cHV0IHNwYWNlcyxcbiAgaW5kZW50YXRpb24sIGFuZCBuZXcgbGluZXMuICopXG5sZXQgbWFrZV9mb3JtYXR0ZXIgb3V0cHV0IGZsdXNoID1cbiAgbGV0IHBwZiA9IHBwX21ha2VfZm9ybWF0dGVyIG91dHB1dCBmbHVzaCBpZ25vcmUgaWdub3JlIGlnbm9yZSBpblxuICBwcGYucHBfb3V0X25ld2xpbmUgPC0gZGlzcGxheV9uZXdsaW5lIHBwZjtcbiAgcHBmLnBwX291dF9zcGFjZXMgPC0gZGlzcGxheV9ibGFua3MgcHBmO1xuICBwcGYucHBfb3V0X2luZGVudCA8LSBkaXNwbGF5X2luZGVudCBwcGY7XG4gIHBwZlxuXG5cbigqIE1ha2UgYSBmb3JtYXR0ZXIgd3JpdGluZyB0byBhIGdpdmVuIFtQZXJ2YXNpdmUub3V0X2NoYW5uZWxdIHZhbHVlLiAqKVxubGV0IGZvcm1hdHRlcl9vZl9vdXRfY2hhbm5lbCBvYyA9XG4gIG1ha2VfZm9ybWF0dGVyIChvdXRwdXRfc3Vic3RyaW5nIG9jKSAoZnVuICgpIC0+IGZsdXNoIG9jKVxuXG5cbigqIE1ha2UgYSBmb3JtYXR0ZXIgd3JpdGluZyB0byBhIGdpdmVuIFtCdWZmZXIudF0gdmFsdWUuICopXG5sZXQgZm9ybWF0dGVyX29mX2J1ZmZlciBiID1cbiAgbWFrZV9mb3JtYXR0ZXIgKEJ1ZmZlci5hZGRfc3Vic3RyaW5nIGIpIGlnbm9yZVxuXG5cbigqIEFsbG9jYXRpbmcgYnVmZmVyIGZvciBwcmV0dHktcHJpbnRpbmcgcHVycG9zZXMuXG4gICBEZWZhdWx0IGJ1ZmZlciBzaXplIGlzIHBwX2J1ZmZlcl9zaXplIG9yIDUxMi5cbiopXG5sZXQgcHBfYnVmZmVyX3NpemUgPSA1MTJcbmxldCBwcF9tYWtlX2J1ZmZlciAoKSA9IEJ1ZmZlci5jcmVhdGUgcHBfYnVmZmVyX3NpemVcblxuKCogVGhlIHN0YW5kYXJkIChzaGFyZWQpIGJ1ZmZlci4gKilcbmxldCBzdGRidWYgPSBwcF9tYWtlX2J1ZmZlciAoKVxuXG4oKiBQcmVkZWZpbmVkIGZvcm1hdHRlcnMgc3RhbmRhcmQgZm9ybWF0dGVyIHRvIHByaW50XG4gICB0byBbU3RkbGliLnN0ZG91dF0sIFtTdGRsaWIuc3RkZXJyXSwgYW5kIHshc3RkYnVmfS4gKilcbmxldCBzdGRfZm9ybWF0dGVyID0gZm9ybWF0dGVyX29mX291dF9jaGFubmVsIFN0ZGxpYi5zdGRvdXRcbmFuZCBlcnJfZm9ybWF0dGVyID0gZm9ybWF0dGVyX29mX291dF9jaGFubmVsIFN0ZGxpYi5zdGRlcnJcbmFuZCBzdHJfZm9ybWF0dGVyID0gZm9ybWF0dGVyX29mX2J1ZmZlciBzdGRidWZcblxuXG4oKiBbZmx1c2hfYnVmZmVyX2Zvcm1hdHRlciBidWYgcHBmXSBmbHVzaGVzIGZvcm1hdHRlciBbcHBmXSxcbiAgIHRoZW4gcmV0dXJucyB0aGUgY29udGVudHMgb2YgYnVmZmVyIFtidWZdIHRoYXQgaXMgcmVzZXQuXG4gICBGb3JtYXR0ZXIgW3BwZl0gaXMgc3VwcG9zZWQgdG8gcHJpbnQgdG8gYnVmZmVyIFtidWZdLCBvdGhlcndpc2UgdGhpc1xuICAgZnVuY3Rpb24gaXMgbm90IHJlYWxseSB1c2VmdWwuICopXG5sZXQgZmx1c2hfYnVmZmVyX2Zvcm1hdHRlciBidWYgcHBmID1cbiAgcHBfZmx1c2hfcXVldWUgcHBmIGZhbHNlO1xuICBsZXQgcyA9IEJ1ZmZlci5jb250ZW50cyBidWYgaW5cbiAgQnVmZmVyLnJlc2V0IGJ1ZjtcbiAgc1xuXG5cbigqIEZsdXNoIFtzdHJfZm9ybWF0dGVyXSBhbmQgZ2V0IHRoZSBjb250ZW50cyBvZiBbc3RkYnVmXS4gKilcbmxldCBmbHVzaF9zdHJfZm9ybWF0dGVyICgpID0gZmx1c2hfYnVmZmVyX2Zvcm1hdHRlciBzdGRidWYgc3RyX2Zvcm1hdHRlclxuXG4oKlxuICBTeW1ib2xpYyBwcmV0dHktcHJpbnRpbmdcbiopXG5cbigqXG4gIFN5bWJvbGljIHByZXR0eS1wcmludGluZyBpcyBwcmV0dHktcHJpbnRpbmcgd2l0aCBubyBsb3cgbGV2ZWwgb3V0cHV0LlxuXG4gIFdoZW4gdXNpbmcgYSBzeW1ib2xpYyBmb3JtYXR0ZXIsIGFsbCByZWd1bGFyIHByZXR0eS1wcmludGluZyBhY3Rpdml0aWVzXG4gIG9jY3VyIGJ1dCBvdXRwdXQgbWF0ZXJpYWwgaXMgc3ltYm9saWMgYW5kIHN0b3JlZCBpbiBhIGJ1ZmZlciBvZiBvdXRwdXRcbiAgaXRlbXMuIEF0IHRoZSBlbmQgb2YgcHJldHR5LXByaW50aW5nLCBmbHVzaGluZyB0aGUgb3V0cHV0IGJ1ZmZlciBhbGxvd3NcbiAgcG9zdC1wcm9jZXNzaW5nIG9mIHN5bWJvbGljIG91dHB1dCBiZWZvcmUgbG93IGxldmVsIG91dHB1dCBvcGVyYXRpb25zLlxuKilcblxudHlwZSBzeW1ib2xpY19vdXRwdXRfaXRlbSA9XG4gIHwgT3V0cHV0X2ZsdXNoXG4gIHwgT3V0cHV0X25ld2xpbmVcbiAgfCBPdXRwdXRfc3RyaW5nIG9mIHN0cmluZ1xuICB8IE91dHB1dF9zcGFjZXMgb2YgaW50XG4gIHwgT3V0cHV0X2luZGVudCBvZiBpbnRcblxudHlwZSBzeW1ib2xpY19vdXRwdXRfYnVmZmVyID0ge1xuICBtdXRhYmxlIHN5bWJvbGljX291dHB1dF9jb250ZW50cyA6IHN5bWJvbGljX291dHB1dF9pdGVtIGxpc3Q7XG59XG5cbmxldCBtYWtlX3N5bWJvbGljX291dHB1dF9idWZmZXIgKCkgPVxuICB7IHN5bWJvbGljX291dHB1dF9jb250ZW50cyA9IFtdIH1cblxubGV0IGNsZWFyX3N5bWJvbGljX291dHB1dF9idWZmZXIgc29iID1cbiAgc29iLnN5bWJvbGljX291dHB1dF9jb250ZW50cyA8LSBbXVxuXG5sZXQgZ2V0X3N5bWJvbGljX291dHB1dF9idWZmZXIgc29iID1cbiAgTGlzdC5yZXYgc29iLnN5bWJvbGljX291dHB1dF9jb250ZW50c1xuXG5sZXQgZmx1c2hfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciBzb2IgPVxuICBsZXQgaXRlbXMgPSBnZXRfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciBzb2IgaW5cbiAgY2xlYXJfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciBzb2I7XG4gIGl0ZW1zXG5cbmxldCBhZGRfc3ltYm9saWNfb3V0cHV0X2l0ZW0gc29iIGl0ZW0gPVxuICBzb2Iuc3ltYm9saWNfb3V0cHV0X2NvbnRlbnRzIDwtIGl0ZW0gOjogc29iLnN5bWJvbGljX291dHB1dF9jb250ZW50c1xuXG5sZXQgZm9ybWF0dGVyX29mX3N5bWJvbGljX291dHB1dF9idWZmZXIgc29iID1cbiAgbGV0IHN5bWJvbGljX2ZsdXNoIHNvYiAoKSA9XG4gICAgYWRkX3N5bWJvbGljX291dHB1dF9pdGVtIHNvYiBPdXRwdXRfZmx1c2hcbiAgYW5kIHN5bWJvbGljX25ld2xpbmUgc29iICgpID1cbiAgICBhZGRfc3ltYm9saWNfb3V0cHV0X2l0ZW0gc29iIE91dHB1dF9uZXdsaW5lXG4gIGFuZCBzeW1ib2xpY19zdHJpbmcgc29iIHMgaSBuID1cbiAgICBhZGRfc3ltYm9saWNfb3V0cHV0X2l0ZW0gc29iIChPdXRwdXRfc3RyaW5nIChTdHJpbmcuc3ViIHMgaSBuKSlcbiAgYW5kIHN5bWJvbGljX3NwYWNlcyBzb2IgbiA9XG4gICAgYWRkX3N5bWJvbGljX291dHB1dF9pdGVtIHNvYiAoT3V0cHV0X3NwYWNlcyBuKVxuICBhbmQgc3ltYm9saWNfaW5kZW50IHNvYiBuID1cbiAgICBhZGRfc3ltYm9saWNfb3V0cHV0X2l0ZW0gc29iIChPdXRwdXRfaW5kZW50IG4pIGluXG5cbiAgbGV0IGYgPSBzeW1ib2xpY19zdHJpbmcgc29iXG4gIGFuZCBnID0gc3ltYm9saWNfZmx1c2ggc29iXG4gIGFuZCBoID0gc3ltYm9saWNfbmV3bGluZSBzb2JcbiAgYW5kIGkgPSBzeW1ib2xpY19zcGFjZXMgc29iXG4gIGFuZCBqID0gc3ltYm9saWNfaW5kZW50IHNvYiBpblxuICBwcF9tYWtlX2Zvcm1hdHRlciBmIGcgaCBpIGpcblxuKCpcblxuICBCYXNpYyBmdW5jdGlvbnMgb24gdGhlICdzdGFuZGFyZCcgZm9ybWF0dGVyXG4gICh0aGUgZm9ybWF0dGVyIHRoYXQgcHJpbnRzIHRvIFtTdGRsaWIuc3Rkb3V0XSkuXG5cbiopXG5cbmxldCBvcGVuX2hib3ggPSBwcF9vcGVuX2hib3ggc3RkX2Zvcm1hdHRlclxuYW5kIG9wZW5fdmJveCA9IHBwX29wZW5fdmJveCBzdGRfZm9ybWF0dGVyXG5hbmQgb3Blbl9odmJveCA9IHBwX29wZW5faHZib3ggc3RkX2Zvcm1hdHRlclxuYW5kIG9wZW5faG92Ym94ID0gcHBfb3Blbl9ob3Zib3ggc3RkX2Zvcm1hdHRlclxuYW5kIG9wZW5fYm94ID0gcHBfb3Blbl9ib3ggc3RkX2Zvcm1hdHRlclxuYW5kIGNsb3NlX2JveCA9IHBwX2Nsb3NlX2JveCBzdGRfZm9ybWF0dGVyXG5hbmQgb3Blbl90YWcgPSBwcF9vcGVuX3RhZyBzdGRfZm9ybWF0dGVyXG5hbmQgY2xvc2VfdGFnID0gcHBfY2xvc2VfdGFnIHN0ZF9mb3JtYXR0ZXJcbmFuZCBvcGVuX3N0YWcgPSBwcF9vcGVuX3N0YWcgc3RkX2Zvcm1hdHRlclxuYW5kIGNsb3NlX3N0YWcgPSBwcF9jbG9zZV9zdGFnIHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF9hcyA9IHBwX3ByaW50X2FzIHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF9zdHJpbmcgPSBwcF9wcmludF9zdHJpbmcgc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X2J5dGVzID0gcHBfcHJpbnRfYnl0ZXMgc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X2ludCA9IHBwX3ByaW50X2ludCBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfZmxvYXQgPSBwcF9wcmludF9mbG9hdCBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfY2hhciA9IHBwX3ByaW50X2NoYXIgc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X2Jvb2wgPSBwcF9wcmludF9ib29sIHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF9icmVhayA9IHBwX3ByaW50X2JyZWFrIHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF9jdXQgPSBwcF9wcmludF9jdXQgc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X3NwYWNlID0gcHBfcHJpbnRfc3BhY2Ugc3RkX2Zvcm1hdHRlclxuYW5kIGZvcmNlX25ld2xpbmUgPSBwcF9mb3JjZV9uZXdsaW5lIHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF9mbHVzaCA9IHBwX3ByaW50X2ZsdXNoIHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF9uZXdsaW5lID0gcHBfcHJpbnRfbmV3bGluZSBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfaWZfbmV3bGluZSA9IHBwX3ByaW50X2lmX25ld2xpbmUgc3RkX2Zvcm1hdHRlclxuXG5hbmQgb3Blbl90Ym94ID0gcHBfb3Blbl90Ym94IHN0ZF9mb3JtYXR0ZXJcbmFuZCBjbG9zZV90Ym94ID0gcHBfY2xvc2VfdGJveCBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfdGJyZWFrID0gcHBfcHJpbnRfdGJyZWFrIHN0ZF9mb3JtYXR0ZXJcblxuYW5kIHNldF90YWIgPSBwcF9zZXRfdGFiIHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF90YWIgPSBwcF9wcmludF90YWIgc3RkX2Zvcm1hdHRlclxuXG5hbmQgc2V0X21hcmdpbiA9IHBwX3NldF9tYXJnaW4gc3RkX2Zvcm1hdHRlclxuYW5kIGdldF9tYXJnaW4gPSBwcF9nZXRfbWFyZ2luIHN0ZF9mb3JtYXR0ZXJcblxuYW5kIHNldF9tYXhfaW5kZW50ID0gcHBfc2V0X21heF9pbmRlbnQgc3RkX2Zvcm1hdHRlclxuYW5kIGdldF9tYXhfaW5kZW50ID0gcHBfZ2V0X21heF9pbmRlbnQgc3RkX2Zvcm1hdHRlclxuXG5hbmQgc2V0X2dlb21ldHJ5ID0gcHBfc2V0X2dlb21ldHJ5IHN0ZF9mb3JtYXR0ZXJcbmFuZCBzYWZlX3NldF9nZW9tZXRyeSA9IHBwX3NhZmVfc2V0X2dlb21ldHJ5IHN0ZF9mb3JtYXR0ZXJcbmFuZCBnZXRfZ2VvbWV0cnkgPSBwcF9nZXRfZ2VvbWV0cnkgc3RkX2Zvcm1hdHRlclxuYW5kIHVwZGF0ZV9nZW9tZXRyeSA9IHBwX3VwZGF0ZV9nZW9tZXRyeSBzdGRfZm9ybWF0dGVyXG5cbmFuZCBzZXRfbWF4X2JveGVzID0gcHBfc2V0X21heF9ib3hlcyBzdGRfZm9ybWF0dGVyXG5hbmQgZ2V0X21heF9ib3hlcyA9IHBwX2dldF9tYXhfYm94ZXMgc3RkX2Zvcm1hdHRlclxuYW5kIG92ZXJfbWF4X2JveGVzID0gcHBfb3Zlcl9tYXhfYm94ZXMgc3RkX2Zvcm1hdHRlclxuXG5hbmQgc2V0X2VsbGlwc2lzX3RleHQgPSBwcF9zZXRfZWxsaXBzaXNfdGV4dCBzdGRfZm9ybWF0dGVyXG5hbmQgZ2V0X2VsbGlwc2lzX3RleHQgPSBwcF9nZXRfZWxsaXBzaXNfdGV4dCBzdGRfZm9ybWF0dGVyXG5cbmFuZCBzZXRfZm9ybWF0dGVyX291dF9jaGFubmVsID1cbiAgcHBfc2V0X2Zvcm1hdHRlcl9vdXRfY2hhbm5lbCBzdGRfZm9ybWF0dGVyXG5cbmFuZCBzZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgPVxuICBwcF9zZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgc3RkX2Zvcm1hdHRlclxuYW5kIGdldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyA9XG4gIHBwX2dldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyBzdGRfZm9ybWF0dGVyXG5cbmFuZCBzZXRfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgPVxuICBwcF9zZXRfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgc3RkX2Zvcm1hdHRlclxuYW5kIGdldF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyA9XG4gIHBwX2dldF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyBzdGRfZm9ybWF0dGVyXG5cbmFuZCBzZXRfZm9ybWF0dGVyX3N0YWdfZnVuY3Rpb25zID1cbiAgcHBfc2V0X2Zvcm1hdHRlcl9zdGFnX2Z1bmN0aW9ucyBzdGRfZm9ybWF0dGVyXG5hbmQgZ2V0X2Zvcm1hdHRlcl9zdGFnX2Z1bmN0aW9ucyA9XG4gIHBwX2dldF9mb3JtYXR0ZXJfc3RhZ19mdW5jdGlvbnMgc3RkX2Zvcm1hdHRlclxuYW5kIHNldF9wcmludF90YWdzID1cbiAgcHBfc2V0X3ByaW50X3RhZ3Mgc3RkX2Zvcm1hdHRlclxuYW5kIGdldF9wcmludF90YWdzID1cbiAgcHBfZ2V0X3ByaW50X3RhZ3Mgc3RkX2Zvcm1hdHRlclxuYW5kIHNldF9tYXJrX3RhZ3MgPVxuICBwcF9zZXRfbWFya190YWdzIHN0ZF9mb3JtYXR0ZXJcbmFuZCBnZXRfbWFya190YWdzID1cbiAgcHBfZ2V0X21hcmtfdGFncyBzdGRfZm9ybWF0dGVyXG5hbmQgc2V0X3RhZ3MgPVxuICBwcF9zZXRfdGFncyBzdGRfZm9ybWF0dGVyXG5cblxuKCogQ29udmVuaWVuY2UgZnVuY3Rpb25zICopXG5cbigqIFRvIGZvcm1hdCBhIGxpc3QgKilcbmxldCByZWMgcHBfcHJpbnRfbGlzdCA/KHBwX3NlcCA9IHBwX3ByaW50X2N1dCkgcHBfdiBwcGYgPSBmdW5jdGlvblxuICB8IFtdIC0+ICgpXG4gIHwgW3ZdIC0+IHBwX3YgcHBmIHZcbiAgfCB2IDo6IHZzIC0+XG4gICAgcHBfdiBwcGYgdjtcbiAgICBwcF9zZXAgcHBmICgpO1xuICAgIHBwX3ByaW50X2xpc3QgfnBwX3NlcCBwcF92IHBwZiB2c1xuXG4oKiBUbyBmb3JtYXQgYSBzZXF1ZW5jZSAqKVxubGV0IHJlYyBwcF9wcmludF9zZXFfaW4gfnBwX3NlcCBwcF92IHBwZiBzZXEgPVxuICBtYXRjaCBzZXEgKCkgd2l0aFxuICB8IFNlcS5OaWwgLT4gKClcbiAgfCBTZXEuQ29ucyAodiwgc2VxKSAtPlxuICAgIHBwX3NlcCBwcGYgKCk7XG4gICAgcHBfdiBwcGYgdjtcbiAgICBwcF9wcmludF9zZXFfaW4gfnBwX3NlcCBwcF92IHBwZiBzZXFcblxubGV0IHBwX3ByaW50X3NlcSA/KHBwX3NlcCA9IHBwX3ByaW50X2N1dCkgcHBfdiBwcGYgc2VxID1cbiAgbWF0Y2ggc2VxICgpIHdpdGhcbiAgfCBTZXEuTmlsIC0+ICgpXG4gIHwgU2VxLkNvbnMgKHYsIHNlcSkgLT5cbiAgICBwcF92IHBwZiB2O1xuICAgIHBwX3ByaW50X3NlcV9pbiB+cHBfc2VwIHBwX3YgcHBmIHNlcVxuXG4oKiBUbyBmb3JtYXQgZnJlZS1mbG93aW5nIHRleHQgKilcbmxldCBwcF9wcmludF90ZXh0IHBwZiBzID1cbiAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggcyBpblxuICBsZXQgbGVmdCA9IHJlZiAwIGluXG4gIGxldCByaWdodCA9IHJlZiAwIGluXG4gIGxldCBmbHVzaCAoKSA9XG4gICAgcHBfcHJpbnRfc3RyaW5nIHBwZiAoU3RyaW5nLnN1YiBzICFsZWZ0ICghcmlnaHQgLSAhbGVmdCkpO1xuICAgIGluY3IgcmlnaHQ7IGxlZnQgOj0gIXJpZ2h0O1xuICBpblxuICB3aGlsZSAoIXJpZ2h0IDw+IGxlbikgZG9cbiAgICBtYXRjaCBzLlshcmlnaHRdIHdpdGhcbiAgICAgIHwgJ1xcbicgLT5cbiAgICAgICAgZmx1c2ggKCk7XG4gICAgICAgIHBwX2ZvcmNlX25ld2xpbmUgcHBmICgpXG4gICAgICB8ICcgJyAtPlxuICAgICAgICBmbHVzaCAoKTsgcHBfcHJpbnRfc3BhY2UgcHBmICgpXG4gICAgICAoKiB0aGVyZSBpcyBubyBzcGVjaWZpYyBzdXBwb3J0IGZvciAnXFx0J1xuICAgICAgICAgYXMgaXQgaXMgdW5jbGVhciB3aGF0IGEgcmlnaHQgc2VtYW50aWNzIHdvdWxkIGJlICopXG4gICAgICB8IF8gLT4gaW5jciByaWdodFxuICBkb25lO1xuICBpZiAhbGVmdCA8PiBsZW4gdGhlbiBmbHVzaCAoKVxuXG5sZXQgcHBfcHJpbnRfb3B0aW9uID8obm9uZSA9IGZ1biBfICgpIC0+ICgpKSBwcF92IHBwZiA9IGZ1bmN0aW9uXG58IE5vbmUgLT4gbm9uZSBwcGYgKClcbnwgU29tZSB2IC0+IHBwX3YgcHBmIHZcblxubGV0IHBwX3ByaW50X3Jlc3VsdCB+b2sgfmVycm9yIHBwZiA9IGZ1bmN0aW9uXG58IE9rIHYgLT4gb2sgcHBmIHZcbnwgRXJyb3IgZSAtPiBlcnJvciBwcGYgZVxuXG5sZXQgcHBfcHJpbnRfZWl0aGVyIH5sZWZ0IH5yaWdodCBwcGYgPSBmdW5jdGlvblxufCBFaXRoZXIuTGVmdCBsIC0+IGxlZnQgcHBmIGxcbnwgRWl0aGVyLlJpZ2h0IHIgLT4gcmlnaHQgcHBmIHJcblxuICgqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxubGV0IGNvbXB1dGVfdGFnIG91dHB1dCB0YWdfYWNjID1cbiAgbGV0IGJ1ZiA9IEJ1ZmZlci5jcmVhdGUgMTYgaW5cbiAgbGV0IHBwZiA9IGZvcm1hdHRlcl9vZl9idWZmZXIgYnVmIGluXG4gIG91dHB1dCBwcGYgdGFnX2FjYztcbiAgcHBfcHJpbnRfZmx1c2ggcHBmICgpO1xuICBsZXQgbGVuID0gQnVmZmVyLmxlbmd0aCBidWYgaW5cbiAgaWYgbGVuIDwgMiB0aGVuIEJ1ZmZlci5jb250ZW50cyBidWZcbiAgZWxzZSBCdWZmZXIuc3ViIGJ1ZiAxIChsZW4gLSAyKVxuXG4gKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbiAgRGVmaW5pbmcgY29udGludWF0aW9ucyB0byBiZSBwYXNzZWQgYXMgYXJndW1lbnRzIG9mXG4gIENhbWxpbnRlcm5hbEZvcm1hdC5tYWtlX3ByaW50Zi5cblxuICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxub3BlbiBDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3Ncbm9wZW4gQ2FtbGludGVybmFsRm9ybWF0XG5cbigqIEludGVycHJldCBhIGZvcm1hdHRpbmcgZW50aXR5IG9uIGEgZm9ybWF0dGVyLiAqKVxubGV0IG91dHB1dF9mb3JtYXR0aW5nX2xpdCBwcGYgZm10aW5nX2xpdCA9IG1hdGNoIGZtdGluZ19saXQgd2l0aFxuICB8IENsb3NlX2JveCAgICAgICAgICAgICAgICAgLT4gcHBfY2xvc2VfYm94IHBwZiAoKVxuICB8IENsb3NlX3RhZyAgICAgICAgICAgICAgICAgLT4gcHBfY2xvc2VfdGFnIHBwZiAoKVxuICB8IEJyZWFrIChfLCB3aWR0aCwgb2Zmc2V0KSAgLT4gcHBfcHJpbnRfYnJlYWsgcHBmIHdpZHRoIG9mZnNldFxuICB8IEZGbHVzaCAgICAgICAgICAgICAgICAgICAgLT4gcHBfcHJpbnRfZmx1c2ggcHBmICgpXG4gIHwgRm9yY2VfbmV3bGluZSAgICAgICAgICAgICAtPiBwcF9mb3JjZV9uZXdsaW5lIHBwZiAoKVxuICB8IEZsdXNoX25ld2xpbmUgICAgICAgICAgICAgLT4gcHBfcHJpbnRfbmV3bGluZSBwcGYgKClcbiAgfCBNYWdpY19zaXplIChfLCBfKSAgICAgICAgIC0+ICgpXG4gIHwgRXNjYXBlZF9hdCAgICAgICAgICAgICAgICAtPiBwcF9wcmludF9jaGFyIHBwZiAnQCdcbiAgfCBFc2NhcGVkX3BlcmNlbnQgICAgICAgICAgIC0+IHBwX3ByaW50X2NoYXIgcHBmICclJ1xuICB8IFNjYW5faW5kaWMgYyAgICAgICAgICAgICAgLT4gcHBfcHJpbnRfY2hhciBwcGYgJ0AnOyBwcF9wcmludF9jaGFyIHBwZiBjXG5cbigqIFJlY3Vyc2l2ZWx5IG91dHB1dCBhbiBcImFjY3VtdWxhdG9yXCIgY29udGFpbmluZyBhIHJldmVyc2VkIGxpc3Qgb2ZcbiAgIHByaW50aW5nIGVudGl0aWVzIChzdHJpbmcsIGNoYXIsIGZsdXMsIC4uLikgaW4gYW4gb3V0cHV0X3N0cmVhbS4gKilcbigqIERpZmZlciBmcm9tIFByaW50Zi5vdXRwdXRfYWNjIGJ5IHRoZSBpbnRlcnByZXRhdGlvbiBvZiBmb3JtYXR0aW5nLiAqKVxuKCogVXNlZCBhcyBhIGNvbnRpbnVhdGlvbiBvZiBDYW1saW50ZXJuYWxGb3JtYXQubWFrZV9wcmludGYuICopXG5sZXQgcmVjIG91dHB1dF9hY2MgcHBmIGFjYyA9IG1hdGNoIGFjYyB3aXRoXG4gIHwgQWNjX3N0cmluZ19saXRlcmFsIChBY2NfZm9ybWF0dGluZ19saXQgKHAsIE1hZ2ljX3NpemUgKF8sIHNpemUpKSwgcylcbiAgfCBBY2NfZGF0YV9zdHJpbmcgKEFjY19mb3JtYXR0aW5nX2xpdCAocCwgTWFnaWNfc2l6ZSAoXywgc2l6ZSkpLCBzKSAtPlxuICAgIG91dHB1dF9hY2MgcHBmIHA7XG4gICAgcHBfcHJpbnRfYXNfc2l6ZSBwcGYgKFNpemUub2ZfaW50IHNpemUpIHM7XG4gIHwgQWNjX2NoYXJfbGl0ZXJhbCAoQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBNYWdpY19zaXplIChfLCBzaXplKSksIGMpXG4gIHwgQWNjX2RhdGFfY2hhciAoQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBNYWdpY19zaXplIChfLCBzaXplKSksIGMpIC0+XG4gICAgb3V0cHV0X2FjYyBwcGYgcDtcbiAgICBwcF9wcmludF9hc19zaXplIHBwZiAoU2l6ZS5vZl9pbnQgc2l6ZSkgKFN0cmluZy5tYWtlIDEgYyk7XG4gIHwgQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBmKSAtPlxuICAgIG91dHB1dF9hY2MgcHBmIHA7XG4gICAgb3V0cHV0X2Zvcm1hdHRpbmdfbGl0IHBwZiBmO1xuICB8IEFjY19mb3JtYXR0aW5nX2dlbiAocCwgQWNjX29wZW5fdGFnIGFjYycpIC0+XG4gICAgb3V0cHV0X2FjYyBwcGYgcDtcbiAgICBwcF9vcGVuX3N0YWcgcHBmIChTdHJpbmdfdGFnIChjb21wdXRlX3RhZyBvdXRwdXRfYWNjIGFjYycpKVxuICB8IEFjY19mb3JtYXR0aW5nX2dlbiAocCwgQWNjX29wZW5fYm94IGFjYycpIC0+XG4gICAgb3V0cHV0X2FjYyBwcGYgcDtcbiAgICBsZXQgKGluZGVudCwgYnR5KSA9IG9wZW5fYm94X29mX3N0cmluZyAoY29tcHV0ZV90YWcgb3V0cHV0X2FjYyBhY2MnKSBpblxuICAgIHBwX29wZW5fYm94X2dlbiBwcGYgaW5kZW50IGJ0eVxuICB8IEFjY19zdHJpbmdfbGl0ZXJhbCAocCwgcylcbiAgfCBBY2NfZGF0YV9zdHJpbmcgKHAsIHMpICAgLT4gb3V0cHV0X2FjYyBwcGYgcDsgcHBfcHJpbnRfc3RyaW5nIHBwZiBzO1xuICB8IEFjY19jaGFyX2xpdGVyYWwgKHAsIGMpXG4gIHwgQWNjX2RhdGFfY2hhciAocCwgYykgICAgIC0+IG91dHB1dF9hY2MgcHBmIHA7IHBwX3ByaW50X2NoYXIgcHBmIGM7XG4gIHwgQWNjX2RlbGF5IChwLCBmKSAgICAgICAgIC0+IG91dHB1dF9hY2MgcHBmIHA7IGYgcHBmO1xuICB8IEFjY19mbHVzaCBwICAgICAgICAgICAgICAtPiBvdXRwdXRfYWNjIHBwZiBwOyBwcF9wcmludF9mbHVzaCBwcGYgKCk7XG4gIHwgQWNjX2ludmFsaWRfYXJnIChwLCBtc2cpIC0+IG91dHB1dF9hY2MgcHBmIHA7IGludmFsaWRfYXJnIG1zZztcbiAgfCBFbmRfb2ZfYWNjICAgICAgICAgICAgICAgLT4gKClcblxuKCogUmVjdXJzaXZlbHkgb3V0cHV0IGFuIFwiYWNjdW11bGF0b3JcIiBjb250YWluaW5nIGEgcmV2ZXJzZWQgbGlzdCBvZlxuICAgcHJpbnRpbmcgZW50aXRpZXMgKHN0cmluZywgY2hhciwgZmx1cywgLi4uKSBpbiBhIGJ1ZmZlci4gKilcbigqIERpZmZlciBmcm9tIFByaW50Zi5idWZwdXRfYWNjIGJ5IHRoZSBpbnRlcnByZXRhdGlvbiBvZiBmb3JtYXR0aW5nLiAqKVxuKCogVXNlZCBhcyBhIGNvbnRpbnVhdGlvbiBvZiBDYW1saW50ZXJuYWxGb3JtYXQubWFrZV9wcmludGYuICopXG5sZXQgcmVjIHN0cnB1dF9hY2MgcHBmIGFjYyA9IG1hdGNoIGFjYyB3aXRoXG4gIHwgQWNjX3N0cmluZ19saXRlcmFsIChBY2NfZm9ybWF0dGluZ19saXQgKHAsIE1hZ2ljX3NpemUgKF8sIHNpemUpKSwgcylcbiAgfCBBY2NfZGF0YV9zdHJpbmcgKEFjY19mb3JtYXR0aW5nX2xpdCAocCwgTWFnaWNfc2l6ZSAoXywgc2l6ZSkpLCBzKSAtPlxuICAgIHN0cnB1dF9hY2MgcHBmIHA7XG4gICAgcHBfcHJpbnRfYXNfc2l6ZSBwcGYgKFNpemUub2ZfaW50IHNpemUpIHM7XG4gIHwgQWNjX2NoYXJfbGl0ZXJhbCAoQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBNYWdpY19zaXplIChfLCBzaXplKSksIGMpXG4gIHwgQWNjX2RhdGFfY2hhciAoQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBNYWdpY19zaXplIChfLCBzaXplKSksIGMpIC0+XG4gICAgc3RycHV0X2FjYyBwcGYgcDtcbiAgICBwcF9wcmludF9hc19zaXplIHBwZiAoU2l6ZS5vZl9pbnQgc2l6ZSkgKFN0cmluZy5tYWtlIDEgYyk7XG4gIHwgQWNjX2RlbGF5IChBY2NfZm9ybWF0dGluZ19saXQgKHAsIE1hZ2ljX3NpemUgKF8sIHNpemUpKSwgZikgLT5cbiAgICBzdHJwdXRfYWNjIHBwZiBwO1xuICAgIHBwX3ByaW50X2FzX3NpemUgcHBmIChTaXplLm9mX2ludCBzaXplKSAoZiAoKSk7XG4gIHwgQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBmKSAtPlxuICAgIHN0cnB1dF9hY2MgcHBmIHA7XG4gICAgb3V0cHV0X2Zvcm1hdHRpbmdfbGl0IHBwZiBmO1xuICB8IEFjY19mb3JtYXR0aW5nX2dlbiAocCwgQWNjX29wZW5fdGFnIGFjYycpIC0+XG4gICAgc3RycHV0X2FjYyBwcGYgcDtcbiAgICBwcF9vcGVuX3N0YWcgcHBmIChTdHJpbmdfdGFnIChjb21wdXRlX3RhZyBzdHJwdXRfYWNjIGFjYycpKVxuICB8IEFjY19mb3JtYXR0aW5nX2dlbiAocCwgQWNjX29wZW5fYm94IGFjYycpIC0+XG4gICAgc3RycHV0X2FjYyBwcGYgcDtcbiAgICBsZXQgKGluZGVudCwgYnR5KSA9IG9wZW5fYm94X29mX3N0cmluZyAoY29tcHV0ZV90YWcgc3RycHV0X2FjYyBhY2MnKSBpblxuICAgIHBwX29wZW5fYm94X2dlbiBwcGYgaW5kZW50IGJ0eVxuICB8IEFjY19zdHJpbmdfbGl0ZXJhbCAocCwgcylcbiAgfCBBY2NfZGF0YV9zdHJpbmcgKHAsIHMpICAgLT4gc3RycHV0X2FjYyBwcGYgcDsgcHBfcHJpbnRfc3RyaW5nIHBwZiBzO1xuICB8IEFjY19jaGFyX2xpdGVyYWwgKHAsIGMpXG4gIHwgQWNjX2RhdGFfY2hhciAocCwgYykgICAgIC0+IHN0cnB1dF9hY2MgcHBmIHA7IHBwX3ByaW50X2NoYXIgcHBmIGM7XG4gIHwgQWNjX2RlbGF5IChwLCBmKSAgICAgICAgIC0+IHN0cnB1dF9hY2MgcHBmIHA7IHBwX3ByaW50X3N0cmluZyBwcGYgKGYgKCkpO1xuICB8IEFjY19mbHVzaCBwICAgICAgICAgICAgICAtPiBzdHJwdXRfYWNjIHBwZiBwOyBwcF9wcmludF9mbHVzaCBwcGYgKCk7XG4gIHwgQWNjX2ludmFsaWRfYXJnIChwLCBtc2cpIC0+IHN0cnB1dF9hY2MgcHBmIHA7IGludmFsaWRfYXJnIG1zZztcbiAgfCBFbmRfb2ZfYWNjICAgICAgICAgICAgICAgLT4gKClcblxuKCpcblxuICBEZWZpbmluZyBbZnByaW50Zl0gYW5kIHZhcmlvdXMgZmxhdm9ycyBvZiBbZnByaW50Zl0uXG5cbiopXG5cbmxldCBrZnByaW50ZiBrIHBwZiAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIG1ha2VfcHJpbnRmXG4gICAgKGZ1biBhY2MgLT4gb3V0cHV0X2FjYyBwcGYgYWNjOyBrIHBwZilcbiAgICBFbmRfb2ZfYWNjIGZtdFxuXG5hbmQgaWtmcHJpbnRmIGsgcHBmIChGb3JtYXQgKGZtdCwgXykpID1cbiAgbWFrZV9pcHJpbnRmIGsgcHBmIGZtdFxuXG5sZXQgaWZwcmludGYgX3BwZiAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIG1ha2VfaXByaW50ZiBpZ25vcmUgKCkgZm10XG5cbmxldCBmcHJpbnRmIHBwZiA9IGtmcHJpbnRmIGlnbm9yZSBwcGZcbmxldCBwcmludGYgZm10ID0gZnByaW50ZiBzdGRfZm9ybWF0dGVyIGZtdFxubGV0IGVwcmludGYgZm10ID0gZnByaW50ZiBlcnJfZm9ybWF0dGVyIGZtdFxuXG5sZXQga2RwcmludGYgayAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIG1ha2VfcHJpbnRmXG4gICAgKGZ1biBhY2MgLT4gayAoZnVuIHBwZiAtPiBvdXRwdXRfYWNjIHBwZiBhY2MpKVxuICAgIEVuZF9vZl9hY2MgZm10XG5cbmxldCBkcHJpbnRmIGZtdCA9IGtkcHJpbnRmIChmdW4gaSAtPiBpKSBmbXRcblxubGV0IGtzcHJpbnRmIGsgKEZvcm1hdCAoZm10LCBfKSkgPVxuICBsZXQgYiA9IHBwX21ha2VfYnVmZmVyICgpIGluXG4gIGxldCBwcGYgPSBmb3JtYXR0ZXJfb2ZfYnVmZmVyIGIgaW5cbiAgbGV0IGsgYWNjID1cbiAgICBzdHJwdXRfYWNjIHBwZiBhY2M7XG4gICAgayAoZmx1c2hfYnVmZmVyX2Zvcm1hdHRlciBiIHBwZikgaW5cbiAgbWFrZV9wcmludGYgayBFbmRfb2ZfYWNjIGZtdFxuXG5cbmxldCBzcHJpbnRmIGZtdCA9IGtzcHJpbnRmIGlkIGZtdFxuXG5sZXQga2FzcHJpbnRmIGsgKEZvcm1hdCAoZm10LCBfKSkgPVxuICBsZXQgYiA9IHBwX21ha2VfYnVmZmVyICgpIGluXG4gIGxldCBwcGYgPSBmb3JtYXR0ZXJfb2ZfYnVmZmVyIGIgaW5cbiAgbGV0IGsgYWNjID1cbiAgICBvdXRwdXRfYWNjIHBwZiBhY2M7XG4gICAgayAoZmx1c2hfYnVmZmVyX2Zvcm1hdHRlciBiIHBwZikgaW5cbiAgbWFrZV9wcmludGYgayBFbmRfb2ZfYWNjIGZtdFxuXG5cbmxldCBhc3ByaW50ZiBmbXQgPSBrYXNwcmludGYgaWQgZm10XG5cbigqIEZsdXNoaW5nIHN0YW5kYXJkIGZvcm1hdHRlcnMgYXQgZW5kIG9mIGV4ZWN1dGlvbi4gKilcblxubGV0IGZsdXNoX3N0YW5kYXJkX2Zvcm1hdHRlcnMgKCkgPVxuICBwcF9wcmludF9mbHVzaCBzdGRfZm9ybWF0dGVyICgpO1xuICBwcF9wcmludF9mbHVzaCBlcnJfZm9ybWF0dGVyICgpXG5cbmxldCAoKSA9IGF0X2V4aXQgZmx1c2hfc3RhbmRhcmRfZm9ybWF0dGVyc1xuXG4oKlxuXG4gIERlcHJlY2F0ZWQgc3R1ZmYuXG5cbiopXG5cbigqIERlcHJlY2F0ZWQgOiBzdWJzdW1lZCBieSBwcF9zZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgKilcbmxldCBwcF9zZXRfYWxsX2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIHN0YXRlXG4gICAgfm91dDpmIH5mbHVzaDpnIH5uZXdsaW5lOmggfnNwYWNlczppID1cbiAgcHBfc2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIHN0YXRlIGYgZztcbiAgc3RhdGUucHBfb3V0X25ld2xpbmUgPC0gaDtcbiAgc3RhdGUucHBfb3V0X3NwYWNlcyA8LSBpXG5cbigqIERlcHJlY2F0ZWQgOiBzdWJzdW1lZCBieSBwcF9nZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgKilcbmxldCBwcF9nZXRfYWxsX2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIHN0YXRlICgpID1cbiAgKHN0YXRlLnBwX291dF9zdHJpbmcsIHN0YXRlLnBwX291dF9mbHVzaCxcbiAgIHN0YXRlLnBwX291dF9uZXdsaW5lLCBzdGF0ZS5wcF9vdXRfc3BhY2VzKVxuXG5cbigqIERlcHJlY2F0ZWQgOiBzdWJzdW1lZCBieSBzZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgKilcbmxldCBzZXRfYWxsX2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zID1cbiAgcHBfc2V0X2FsbF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyBzdGRfZm9ybWF0dGVyXG5cblxuKCogRGVwcmVjYXRlZCA6IHN1YnN1bWVkIGJ5IGdldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyAqKVxubGV0IGdldF9hbGxfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgPVxuICBwcF9nZXRfYWxsX2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIHN0ZF9mb3JtYXR0ZXJcblxuXG4oKiBEZXByZWNhdGVkIDogZXJyb3IgcHJvbmUgZnVuY3Rpb24sIGRvIG5vdCB1c2UgaXQuXG4gICBUaGlzIGZ1bmN0aW9uIGlzIG5laXRoZXIgY29tcG9zaXRpb25hbCBub3IgaW5jcmVtZW50YWwsIHNpbmNlIGl0IGZsdXNoZXNcbiAgIHRoZSBwcmV0dHktcHJpbnRlciBxdWV1ZSBhdCBlYWNoIGNhbGwuXG4gICBUbyBnZXQgdGhlIHNhbWUgZnVuY3Rpb25hbGl0eSwgZGVmaW5lIGEgZm9ybWF0dGVyIG9mIHlvdXIgb3duIHdyaXRpbmcgdG9cbiAgIHRoZSBidWZmZXIgYXJndW1lbnQsIGFzIGluXG4gICBsZXQgcHBmID0gZm9ybWF0dGVyX29mX2J1ZmZlciBiXG4gICB0aGVuIHVzZSB7IWZwcmludGYgcHBmfSBhcyB1c3VhbC4gKilcbmxldCBicHJpbnRmIGIgKEZvcm1hdCAoZm10LCBfKSA6ICgnYSwgZm9ybWF0dGVyLCB1bml0KSBmb3JtYXQpID1cbiAgbGV0IHBwZiA9IGZvcm1hdHRlcl9vZl9idWZmZXIgYiBpblxuICBsZXQgayBhY2MgPSBvdXRwdXRfYWNjIHBwZiBhY2M7IHBwX2ZsdXNoX3F1ZXVlIHBwZiBmYWxzZSBpblxuICBtYWtlX3ByaW50ZiBrIEVuZF9vZl9hY2MgZm10XG5cblxuKCogRGVwcmVjYXRlZCA6IGFsaWFzIGZvciBrc3ByaW50Zi4gKilcbmxldCBrcHJpbnRmID0ga3NwcmludGZcblxuXG5cbigqIERlcHJlY2F0ZWQgdGFnIGZ1bmN0aW9ucyAqKVxuXG50eXBlIGZvcm1hdHRlcl90YWdfZnVuY3Rpb25zID0ge1xuICBtYXJrX29wZW5fdGFnIDogdGFnIC0+IHN0cmluZztcbiAgbWFya19jbG9zZV90YWcgOiB0YWcgLT4gc3RyaW5nO1xuICBwcmludF9vcGVuX3RhZyA6IHRhZyAtPiB1bml0O1xuICBwcmludF9jbG9zZV90YWcgOiB0YWcgLT4gdW5pdDtcbn1cblxuXG5sZXQgcHBfc2V0X2Zvcm1hdHRlcl90YWdfZnVuY3Rpb25zIHN0YXRlIHtcbiAgICAgbWFya19vcGVuX3RhZyA9IG1vdDtcbiAgICAgbWFya19jbG9zZV90YWcgPSBtY3Q7XG4gICAgIHByaW50X29wZW5fdGFnID0gcG90O1xuICAgICBwcmludF9jbG9zZV90YWcgPSBwY3Q7XG4gICB9ID1cbiAgbGV0IHN0cmluZ2lmeSBmIGUgPSBmdW5jdGlvbiBTdHJpbmdfdGFnIHMgLT4gZiBzIHwgXyAtPiBlIGluXG4gIHN0YXRlLnBwX21hcmtfb3Blbl90YWcgPC0gc3RyaW5naWZ5IG1vdCBcIlwiO1xuICBzdGF0ZS5wcF9tYXJrX2Nsb3NlX3RhZyA8LSBzdHJpbmdpZnkgbWN0IFwiXCI7XG4gIHN0YXRlLnBwX3ByaW50X29wZW5fdGFnIDwtIHN0cmluZ2lmeSBwb3QgKCk7XG4gIHN0YXRlLnBwX3ByaW50X2Nsb3NlX3RhZyA8LSBzdHJpbmdpZnkgcGN0ICgpXG5cbmxldCBwcF9nZXRfZm9ybWF0dGVyX3RhZ19mdW5jdGlvbnMgZm10ICgpID1cbiAgbGV0IGZ1bnMgPSBwcF9nZXRfZm9ybWF0dGVyX3N0YWdfZnVuY3Rpb25zIGZtdCAoKSBpblxuICBsZXQgbWFya19vcGVuX3RhZyBzID0gZnVucy5tYXJrX29wZW5fc3RhZyAoU3RyaW5nX3RhZyBzKSBpblxuICBsZXQgbWFya19jbG9zZV90YWcgcyA9IGZ1bnMubWFya19jbG9zZV9zdGFnIChTdHJpbmdfdGFnIHMpIGluXG4gIGxldCBwcmludF9vcGVuX3RhZyBzID0gZnVucy5wcmludF9vcGVuX3N0YWcgKFN0cmluZ190YWcgcykgaW5cbiAgbGV0IHByaW50X2Nsb3NlX3RhZyBzID0gZnVucy5wcmludF9jbG9zZV9zdGFnIChTdHJpbmdfdGFnIHMpIGluXG4gIHttYXJrX29wZW5fdGFnOyBtYXJrX2Nsb3NlX3RhZzsgcHJpbnRfb3Blbl90YWc7IHByaW50X2Nsb3NlX3RhZ31cblxubGV0IHNldF9mb3JtYXR0ZXJfdGFnX2Z1bmN0aW9ucyA9XG4gIHBwX3NldF9mb3JtYXR0ZXJfdGFnX2Z1bmN0aW9ucyBzdGRfZm9ybWF0dGVyXG5hbmQgZ2V0X2Zvcm1hdHRlcl90YWdfZnVuY3Rpb25zID1cbiAgcHBfZ2V0X2Zvcm1hdHRlcl90YWdfZnVuY3Rpb25zIHN0ZF9mb3JtYXR0ZXJcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFBpZXJyZSBXZWlzLCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMDIgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxub3BlbiBDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3Ncbm9wZW4gQ2FtbGludGVybmFsRm9ybWF0XG5cbigqIGFsaWFzIHRvIGF2b2lkIHdhcm5pbmcgZm9yIGFtYmlndWl0eSBiZXR3ZWVuXG4gICBTdGRsaWIuZm9ybWF0NlxuICAgYW5kIENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljcy5mb3JtYXQ2XG5cbiAgICh0aGUgZm9ybWVyIGlzIGluIGZhY3QgYW4gYWxpYXMgZm9yIHRoZSBsYXR0ZXIsXG4gICAgYnV0IHRoZSBhbWJpZ3VpdHkgd2FybmluZyBkb2Vzbid0IGNhcmUpXG4qKVxudHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiA9XG4gICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBTdGRsaWIuZm9ybWF0NlxuXG5cbigqIFRoZSBydW4tdGltZSBsaWJyYXJ5IGZvciBzY2FubmVycy4gKilcblxuKCogU2Nhbm5pbmcgYnVmZmVycy4gKilcbm1vZHVsZSB0eXBlIFNDQU5OSU5HID0gc2lnXG5cbiAgdHlwZSBpbl9jaGFubmVsXG5cbiAgdHlwZSBzY2FuYnVmID0gaW5fY2hhbm5lbFxuXG4gIHR5cGUgZmlsZV9uYW1lID0gc3RyaW5nXG5cbiAgdmFsIHN0ZGluIDogaW5fY2hhbm5lbFxuICAoKiBUaGUgc2Nhbm5pbmcgYnVmZmVyIHJlYWRpbmcgZnJvbSBbU3RkbGliLnN0ZGluXS5cbiAgICAgW3N0ZGliXSBpcyBlcXVpdmFsZW50IHRvIFtTY2FubmluZy5mcm9tX2NoYW5uZWwgU3RkbGliLnN0ZGluXS4gKilcblxuICB2YWwgc3RkaWIgOiBpbl9jaGFubmVsXG4gICgqIEFuIGFsaWFzIGZvciBbU2NhbmYuc3RkaW5dLCB0aGUgc2Nhbm5pbmcgYnVmZmVyIHJlYWRpbmcgZnJvbVxuICAgICBbU3RkbGliLnN0ZGluXS4gKilcblxuICB2YWwgbmV4dF9jaGFyIDogc2NhbmJ1ZiAtPiBjaGFyXG4gICgqIFtTY2FubmluZy5uZXh0X2NoYXIgaWJdIGFkdmFuY2UgdGhlIHNjYW5uaW5nIGJ1ZmZlciBmb3JcbiAgICAgb25lIGNoYXJhY3Rlci5cbiAgICAgSWYgbm8gbW9yZSBjaGFyYWN0ZXIgY2FuIGJlIHJlYWQsIHNldHMgYSBlbmQgb2YgZmlsZSBjb25kaXRpb24gYW5kXG4gICAgIHJldHVybnMgJ1xcMDAwJy4gKilcblxuICB2YWwgaW52YWxpZGF0ZV9jdXJyZW50X2NoYXIgOiBzY2FuYnVmIC0+IHVuaXRcbiAgKCogW1NjYW5uaW5nLmludmFsaWRhdGVfY3VycmVudF9jaGFyIGliXSBtYXJrIHRoZSBjdXJyZW50X2NoYXIgYXMgYWxyZWFkeVxuICAgICBzY2FubmVkLiAqKVxuXG4gIHZhbCBwZWVrX2NoYXIgOiBzY2FuYnVmIC0+IGNoYXJcbiAgKCogW1NjYW5uaW5nLnBlZWtfY2hhciBpYl0gcmV0dXJucyB0aGUgY3VycmVudCBjaGFyIGF2YWlsYWJsZSBpblxuICAgICB0aGUgYnVmZmVyIG9yIHJlYWRzIG9uZSBpZiBuZWNlc3NhcnkgKHdoZW4gdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGlzXG4gICAgIGFscmVhZHkgc2Nhbm5lZCkuXG4gICAgIElmIG5vIGNoYXJhY3RlciBjYW4gYmUgcmVhZCwgc2V0cyBhbiBlbmQgb2YgZmlsZSBjb25kaXRpb24gYW5kXG4gICAgIHJldHVybnMgJ1xcMDAwJy4gKilcblxuICB2YWwgY2hlY2tlZF9wZWVrX2NoYXIgOiBzY2FuYnVmIC0+IGNoYXJcbiAgKCogU2FtZSBhcyBbU2Nhbm5pbmcucGVla19jaGFyXSBhYm92ZSBidXQgYWx3YXlzIHJldHVybnMgYSB2YWxpZCBjaGFyIG9yXG4gICAgIGZhaWxzOiBpbnN0ZWFkIG9mIHJldHVybmluZyBhIG51bGwgY2hhciB3aGVuIHRoZSByZWFkaW5nIG1ldGhvZCBvZiB0aGVcbiAgICAgaW5wdXQgYnVmZmVyIGhhcyByZWFjaGVkIGFuIGVuZCBvZiBmaWxlLCB0aGUgZnVuY3Rpb24gcmFpc2VzIGV4Y2VwdGlvblxuICAgICBbRW5kX29mX2ZpbGVdLiAqKVxuXG4gIHZhbCBzdG9yZV9jaGFyIDogaW50IC0+IHNjYW5idWYgLT4gY2hhciAtPiBpbnRcbiAgKCogW1NjYW5uaW5nLnN0b3JlX2NoYXIgbGltIGliIGNdIGFkZHMgW2NdIHRvIHRoZSB0b2tlbiBidWZmZXJcbiAgICAgb2YgdGhlIHNjYW5uaW5nIGJ1ZmZlciBbaWJdLiBJdCBhbHNvIGFkdmFuY2VzIHRoZSBzY2FubmluZyBidWZmZXIgZm9yXG4gICAgIG9uZSBjaGFyYWN0ZXIgYW5kIHJldHVybnMgW2xpbSAtIDFdLCBpbmRpY2F0aW5nIHRoZSBuZXcgbGltaXQgZm9yIHRoZVxuICAgICBsZW5ndGggb2YgdGhlIGN1cnJlbnQgdG9rZW4uICopXG5cbiAgdmFsIHNraXBfY2hhciA6IGludCAtPiBzY2FuYnVmIC0+IGludFxuICAoKiBbU2Nhbm5pbmcuc2tpcF9jaGFyIGxpbSBpYl0gaWdub3JlcyB0aGUgY3VycmVudCBjaGFyYWN0ZXIuICopXG5cbiAgdmFsIGlnbm9yZV9jaGFyIDogaW50IC0+IHNjYW5idWYgLT4gaW50XG4gICgqIFtTY2FubmluZy5pZ25vcmVfY2hhciBpYiBsaW1dIGlnbm9yZXMgdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGFuZFxuICAgICBkZWNyZW1lbnRzIHRoZSBsaW1pdC4gKilcblxuICB2YWwgdG9rZW4gOiBzY2FuYnVmIC0+IHN0cmluZ1xuICAoKiBbU2Nhbm5pbmcudG9rZW4gaWJdIHJldHVybnMgdGhlIHN0cmluZyBzdG9yZWQgaW50byB0aGUgdG9rZW5cbiAgICAgYnVmZmVyIG9mIHRoZSBzY2FubmluZyBidWZmZXI6IGl0IHJldHVybnMgdGhlIHRva2VuIG1hdGNoZWQgYnkgdGhlXG4gICAgIGZvcm1hdC4gKilcblxuICB2YWwgcmVzZXRfdG9rZW4gOiBzY2FuYnVmIC0+IHVuaXRcbiAgKCogW1NjYW5uaW5nLnJlc2V0X3Rva2VuIGliXSByZXNldHMgdGhlIHRva2VuIGJ1ZmZlciBvZlxuICAgICB0aGUgZ2l2ZW4gc2Nhbm5pbmcgYnVmZmVyLiAqKVxuXG4gIHZhbCBjaGFyX2NvdW50IDogc2NhbmJ1ZiAtPiBpbnRcbiAgKCogW1NjYW5uaW5nLmNoYXJfY291bnQgaWJdIHJldHVybnMgdGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzXG4gICAgIHJlYWQgc28gZmFyIGZyb20gdGhlIGdpdmVuIGJ1ZmZlci4gKilcblxuICB2YWwgbGluZV9jb3VudCA6IHNjYW5idWYgLT4gaW50XG4gICgqIFtTY2FubmluZy5saW5lX2NvdW50IGliXSByZXR1cm5zIHRoZSBudW1iZXIgb2YgbmV3IGxpbmVcbiAgICAgY2hhcmFjdGVycyByZWFkIHNvIGZhciBmcm9tIHRoZSBnaXZlbiBidWZmZXIuICopXG5cbiAgdmFsIHRva2VuX2NvdW50IDogc2NhbmJ1ZiAtPiBpbnRcbiAgKCogW1NjYW5uaW5nLnRva2VuX2NvdW50IGliXSByZXR1cm5zIHRoZSBudW1iZXIgb2YgdG9rZW5zIHJlYWRcbiAgICAgc28gZmFyIGZyb20gW2liXS4gKilcblxuICB2YWwgZW9mIDogc2NhbmJ1ZiAtPiBib29sXG4gICgqIFtTY2FubmluZy5lb2YgaWJdIHJldHVybnMgdGhlIGVuZCBvZiBpbnB1dCBjb25kaXRpb25cbiAgICAgb2YgdGhlIGdpdmVuIGJ1ZmZlci4gKilcblxuICB2YWwgZW5kX29mX2lucHV0IDogc2NhbmJ1ZiAtPiBib29sXG4gICgqIFtTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWJdIHRlc3RzIHRoZSBlbmQgb2YgaW5wdXQgY29uZGl0aW9uXG4gICAgIG9mIHRoZSBnaXZlbiBidWZmZXIgKGlmIG5vIGNoYXIgaGFzIGV2ZXIgYmVlbiByZWFkLCBhbiBhdHRlbXB0IHRvXG4gICAgIHJlYWQgb25lIGlzIHBlcmZvcm1lZCkuICopXG5cbiAgdmFsIGJlZ2lubmluZ19vZl9pbnB1dCA6IHNjYW5idWYgLT4gYm9vbFxuICAoKiBbU2Nhbm5pbmcuYmVnaW5uaW5nX29mX2lucHV0IGliXSB0ZXN0cyB0aGUgYmVnaW5uaW5nIG9mIGlucHV0XG4gICAgIGNvbmRpdGlvbiBvZiB0aGUgZ2l2ZW4gYnVmZmVyLiAqKVxuXG4gIHZhbCBuYW1lX29mX2lucHV0IDogc2NhbmJ1ZiAtPiBzdHJpbmdcbiAgKCogW1NjYW5uaW5nLm5hbWVfb2ZfaW5wdXQgaWJdIHJldHVybnMgdGhlIG5hbWUgb2YgdGhlIGNoYXJhY3RlclxuICAgICBzb3VyY2UgZm9yIGlucHV0IGJ1ZmZlciBbaWJdLiAqKVxuXG4gIHZhbCBvcGVuX2luIDogZmlsZV9uYW1lIC0+IGluX2NoYW5uZWxcbiAgdmFsIG9wZW5faW5fYmluIDogZmlsZV9uYW1lIC0+IGluX2NoYW5uZWxcbiAgdmFsIGZyb21fZmlsZSA6IGZpbGVfbmFtZSAtPiBpbl9jaGFubmVsXG4gIHZhbCBmcm9tX2ZpbGVfYmluIDogZmlsZV9uYW1lIC0+IGluX2NoYW5uZWxcbiAgdmFsIGZyb21fc3RyaW5nIDogc3RyaW5nIC0+IGluX2NoYW5uZWxcbiAgdmFsIGZyb21fZnVuY3Rpb24gOiAodW5pdCAtPiBjaGFyKSAtPiBpbl9jaGFubmVsXG4gIHZhbCBmcm9tX2NoYW5uZWwgOiBTdGRsaWIuaW5fY2hhbm5lbCAtPiBpbl9jaGFubmVsXG5cbiAgdmFsIGNsb3NlX2luIDogaW5fY2hhbm5lbCAtPiB1bml0XG5cbiAgdmFsIG1lbW9fZnJvbV9jaGFubmVsIDogU3RkbGliLmluX2NoYW5uZWwgLT4gaW5fY2hhbm5lbFxuICAoKiBPYnNvbGV0ZS4gKilcblxuZW5kXG5cblxubW9kdWxlIFNjYW5uaW5nIDogU0NBTk5JTkcgPSBzdHJ1Y3RcblxuICAoKiBUaGUgcnVuLXRpbWUgbGlicmFyeSBmb3Igc2NhbmYuICopXG5cbiAgdHlwZSBmaWxlX25hbWUgPSBzdHJpbmdcblxuICB0eXBlIGluX2NoYW5uZWxfbmFtZSA9XG4gICAgfCBGcm9tX2NoYW5uZWwgb2YgU3RkbGliLmluX2NoYW5uZWxcbiAgICB8IEZyb21fZmlsZSBvZiBmaWxlX25hbWUgKiBTdGRsaWIuaW5fY2hhbm5lbFxuICAgIHwgRnJvbV9mdW5jdGlvblxuICAgIHwgRnJvbV9zdHJpbmdcblxuXG4gIHR5cGUgaW5fY2hhbm5lbCA9IHtcbiAgICBtdXRhYmxlIGljX2VvZiA6IGJvb2w7XG4gICAgbXV0YWJsZSBpY19jdXJyZW50X2NoYXIgOiBjaGFyO1xuICAgIG11dGFibGUgaWNfY3VycmVudF9jaGFyX2lzX3ZhbGlkIDogYm9vbDtcbiAgICBtdXRhYmxlIGljX2NoYXJfY291bnQgOiBpbnQ7XG4gICAgbXV0YWJsZSBpY19saW5lX2NvdW50IDogaW50O1xuICAgIG11dGFibGUgaWNfdG9rZW5fY291bnQgOiBpbnQ7XG4gICAgaWNfZ2V0X25leHRfY2hhciA6IHVuaXQgLT4gY2hhcjtcbiAgICBpY190b2tlbl9idWZmZXIgOiBCdWZmZXIudDtcbiAgICBpY19pbnB1dF9uYW1lIDogaW5fY2hhbm5lbF9uYW1lO1xuICB9XG5cblxuICB0eXBlIHNjYW5idWYgPSBpbl9jaGFubmVsXG5cbiAgbGV0IG51bGxfY2hhciA9ICdcXDAwMCdcblxuICAoKiBSZWFkcyBhIG5ldyBjaGFyYWN0ZXIgZnJvbSBpbnB1dCBidWZmZXIuXG4gICAgIE5leHRfY2hhciBuZXZlciBmYWlscywgZXZlbiBpbiBjYXNlIG9mIGVuZCBvZiBpbnB1dDpcbiAgICAgaXQgdGhlbiBzaW1wbHkgc2V0cyB0aGUgZW5kIG9mIGZpbGUgY29uZGl0aW9uLiAqKVxuICBsZXQgbmV4dF9jaGFyIGliID1cbiAgICB0cnlcbiAgICAgIGxldCBjID0gaWIuaWNfZ2V0X25leHRfY2hhciAoKSBpblxuICAgICAgaWIuaWNfY3VycmVudF9jaGFyIDwtIGM7XG4gICAgICBpYi5pY19jdXJyZW50X2NoYXJfaXNfdmFsaWQgPC0gdHJ1ZTtcbiAgICAgIGliLmljX2NoYXJfY291bnQgPC0gc3VjYyBpYi5pY19jaGFyX2NvdW50O1xuICAgICAgaWYgYyA9ICdcXG4nIHRoZW4gaWIuaWNfbGluZV9jb3VudCA8LSBzdWNjIGliLmljX2xpbmVfY291bnQ7XG4gICAgICBjIHdpdGhcbiAgICB8IEVuZF9vZl9maWxlIC0+XG4gICAgICBsZXQgYyA9IG51bGxfY2hhciBpblxuICAgICAgaWIuaWNfY3VycmVudF9jaGFyIDwtIGM7XG4gICAgICBpYi5pY19jdXJyZW50X2NoYXJfaXNfdmFsaWQgPC0gZmFsc2U7XG4gICAgICBpYi5pY19lb2YgPC0gdHJ1ZTtcbiAgICAgIGNcblxuXG4gIGxldCBwZWVrX2NoYXIgaWIgPVxuICAgIGlmIGliLmljX2N1cnJlbnRfY2hhcl9pc192YWxpZFxuICAgIHRoZW4gaWIuaWNfY3VycmVudF9jaGFyXG4gICAgZWxzZSBuZXh0X2NoYXIgaWJcblxuXG4gICgqIFJldHVybnMgYSB2YWxpZCBjdXJyZW50IGNoYXIgZm9yIHRoZSBpbnB1dCBidWZmZXIuIEluIHBhcnRpY3VsYXJcbiAgICAgbm8gaXJyZWxldmFudCBudWxsIGNoYXJhY3RlciAoYXMgc2V0IGJ5IFtuZXh0X2NoYXJdIGluIGNhc2Ugb2YgZW5kXG4gICAgIG9mIGlucHV0KSBpcyByZXR1cm5lZCwgc2luY2UgW0VuZF9vZl9maWxlXSBpcyByYWlzZWQgd2hlblxuICAgICBbbmV4dF9jaGFyXSBzZXRzIHRoZSBlbmQgb2YgZmlsZSBjb25kaXRpb24gd2hpbGUgdHJ5aW5nIHRvIHJlYWQgYVxuICAgICBuZXcgY2hhcmFjdGVyLiAqKVxuICBsZXQgY2hlY2tlZF9wZWVrX2NoYXIgaWIgPVxuICAgIGxldCBjID0gcGVla19jaGFyIGliIGluXG4gICAgaWYgaWIuaWNfZW9mIHRoZW4gcmFpc2UgRW5kX29mX2ZpbGU7XG4gICAgY1xuXG5cbiAgbGV0IGVuZF9vZl9pbnB1dCBpYiA9XG4gICAgaWdub3JlIChwZWVrX2NoYXIgaWIpO1xuICAgIGliLmljX2VvZlxuXG5cbiAgbGV0IGVvZiBpYiA9IGliLmljX2VvZlxuXG4gIGxldCBiZWdpbm5pbmdfb2ZfaW5wdXQgaWIgPSBpYi5pY19jaGFyX2NvdW50ID0gMFxuXG4gIGxldCBuYW1lX29mX2lucHV0IGliID1cbiAgICBtYXRjaCBpYi5pY19pbnB1dF9uYW1lIHdpdGhcbiAgICB8IEZyb21fY2hhbm5lbCBfaWMgLT4gXCJ1bm5hbWVkIFN0ZGxpYiBpbnB1dCBjaGFubmVsXCJcbiAgICB8IEZyb21fZmlsZSAoZm5hbWUsIF9pYykgLT4gZm5hbWVcbiAgICB8IEZyb21fZnVuY3Rpb24gLT4gXCJ1bm5hbWVkIGZ1bmN0aW9uXCJcbiAgICB8IEZyb21fc3RyaW5nIC0+IFwidW5uYW1lZCBjaGFyYWN0ZXIgc3RyaW5nXCJcblxuXG4gIGxldCBjaGFyX2NvdW50IGliID1cbiAgICBpZiBpYi5pY19jdXJyZW50X2NoYXJfaXNfdmFsaWRcbiAgICB0aGVuIGliLmljX2NoYXJfY291bnQgLSAxXG4gICAgZWxzZSBpYi5pY19jaGFyX2NvdW50XG5cblxuICBsZXQgbGluZV9jb3VudCBpYiA9IGliLmljX2xpbmVfY291bnRcblxuICBsZXQgcmVzZXRfdG9rZW4gaWIgPSBCdWZmZXIucmVzZXQgaWIuaWNfdG9rZW5fYnVmZmVyXG5cbiAgbGV0IGludmFsaWRhdGVfY3VycmVudF9jaGFyIGliID0gaWIuaWNfY3VycmVudF9jaGFyX2lzX3ZhbGlkIDwtIGZhbHNlXG5cbiAgbGV0IHRva2VuIGliID1cbiAgICBsZXQgdG9rZW5fYnVmZmVyID0gaWIuaWNfdG9rZW5fYnVmZmVyIGluXG4gICAgbGV0IHRvayA9IEJ1ZmZlci5jb250ZW50cyB0b2tlbl9idWZmZXIgaW5cbiAgICBCdWZmZXIuY2xlYXIgdG9rZW5fYnVmZmVyO1xuICAgIGliLmljX3Rva2VuX2NvdW50IDwtIHN1Y2MgaWIuaWNfdG9rZW5fY291bnQ7XG4gICAgdG9rXG5cblxuICBsZXQgdG9rZW5fY291bnQgaWIgPSBpYi5pY190b2tlbl9jb3VudFxuXG4gIGxldCBza2lwX2NoYXIgd2lkdGggaWIgPVxuICAgIGludmFsaWRhdGVfY3VycmVudF9jaGFyIGliO1xuICAgIHdpZHRoXG5cblxuICBsZXQgaWdub3JlX2NoYXIgd2lkdGggaWIgPSBza2lwX2NoYXIgKHdpZHRoIC0gMSkgaWJcblxuICBsZXQgc3RvcmVfY2hhciB3aWR0aCBpYiBjID1cbiAgICBCdWZmZXIuYWRkX2NoYXIgaWIuaWNfdG9rZW5fYnVmZmVyIGM7XG4gICAgaWdub3JlX2NoYXIgd2lkdGggaWJcblxuXG4gIGxldCBkZWZhdWx0X3Rva2VuX2J1ZmZlcl9zaXplID0gMTAyNFxuXG4gIGxldCBjcmVhdGUgaW5hbWUgbmV4dCA9IHtcbiAgICBpY19lb2YgPSBmYWxzZTtcbiAgICBpY19jdXJyZW50X2NoYXIgPSBudWxsX2NoYXI7XG4gICAgaWNfY3VycmVudF9jaGFyX2lzX3ZhbGlkID0gZmFsc2U7XG4gICAgaWNfY2hhcl9jb3VudCA9IDA7XG4gICAgaWNfbGluZV9jb3VudCA9IDA7XG4gICAgaWNfdG9rZW5fY291bnQgPSAwO1xuICAgIGljX2dldF9uZXh0X2NoYXIgPSBuZXh0O1xuICAgIGljX3Rva2VuX2J1ZmZlciA9IEJ1ZmZlci5jcmVhdGUgZGVmYXVsdF90b2tlbl9idWZmZXJfc2l6ZTtcbiAgICBpY19pbnB1dF9uYW1lID0gaW5hbWU7XG4gIH1cblxuXG4gIGxldCBmcm9tX3N0cmluZyBzID1cbiAgICBsZXQgaSA9IHJlZiAwIGluXG4gICAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggcyBpblxuICAgIGxldCBuZXh0ICgpID1cbiAgICAgIGlmICFpID49IGxlbiB0aGVuIHJhaXNlIEVuZF9vZl9maWxlIGVsc2VcbiAgICAgIGxldCBjID0gcy5bIWldIGluXG4gICAgICBpbmNyIGk7XG4gICAgICBjIGluXG4gICAgY3JlYXRlIEZyb21fc3RyaW5nIG5leHRcblxuXG4gIGxldCBmcm9tX2Z1bmN0aW9uID0gY3JlYXRlIEZyb21fZnVuY3Rpb25cblxuICAoKiBTY2FubmluZyBmcm9tIGFuIGlucHV0IGNoYW5uZWwuICopXG5cbiAgKCogUG9zaXRpb24gb2YgdGhlIHByb2JsZW06XG5cbiAgICAgV2UgY2Fubm90IHByZXZlbnQgdGhlIHNjYW5uaW5nIG1lY2hhbmlzbSB0byB1c2Ugb25lIGxvb2thaGVhZCBjaGFyYWN0ZXIsXG4gICAgIGlmIG5lZWRlZCBieSB0aGUgc2VtYW50aWNzIG9mIHRoZSBmb3JtYXQgc3RyaW5nIHNwZWNpZmljYXRpb25zIChlLmcuIGFcbiAgICAgdHJhaWxpbmcgJ3NraXAgc3BhY2UnIHNwZWNpZmljYXRpb24gaW4gdGhlIGZvcm1hdCBzdHJpbmcpOyBpbiB0aGlzIGNhc2UsXG4gICAgIHRoZSBtYW5kYXRvcnkgbG9va2FoZWFkIGNoYXJhY3RlciBpcyBpbmRlZWQgcmVhZCBmcm9tIHRoZSBpbnB1dCBhbmQgbm90XG4gICAgIHVzZWQgdG8gcmV0dXJuIHRoZSB0b2tlbiByZWFkLiBJdCBpcyB0aHVzIG1hbmRhdG9yeSB0byBiZSBhYmxlIHRvIHN0b3JlXG4gICAgIGFuIHVudXNlZCBsb29rYWhlYWQgY2hhcmFjdGVyIHNvbWV3aGVyZSB0byBnZXQgaXQgYXMgdGhlIGZpcnN0IGNoYXJhY3RlclxuICAgICBvZiB0aGUgbmV4dCBzY2FuLlxuXG4gICAgIFRvIGNpcmN1bXZlbnQgdGhpcyBwcm9ibGVtLCBhbGwgdGhlIHNjYW5uaW5nIGZ1bmN0aW9ucyBnZXQgYSBsb3cgbGV2ZWxcbiAgICAgaW5wdXQgYnVmZmVyIGFyZ3VtZW50IHdoZXJlIHRoZXkgc3RvcmUgdGhlIGxvb2thaGVhZCBjaGFyYWN0ZXIgd2hlblxuICAgICBuZWVkZWQ7IGFkZGl0aW9uYWxseSwgdGhlIGlucHV0IGJ1ZmZlciBpcyB0aGUgb25seSBzb3VyY2Ugb2YgY2hhcmFjdGVyIG9mXG4gICAgIGEgc2Nhbm5lci4gVGhlIFtzY2FuYnVmXSBpbnB1dCBidWZmZXJzIGFyZSBkZWZpbmVkIGluIG1vZHVsZSB7IVNjYW5uaW5nfS5cblxuICAgICBOb3cgd2UgdW5kZXJzdGFuZCB0aGF0IGl0IGlzIGV4dHJlbWVseSBpbXBvcnRhbnQgdGhhdCByZWxhdGVkIGFuZFxuICAgICBzdWNjZXNzaXZlIGNhbGxzIHRvIHNjYW5uZXJzIGluZGVlZCByZWFkIGZyb20gdGhlIHNhbWUgaW5wdXQgYnVmZmVyLlxuICAgICBJbiBlZmZlY3QsIGlmIGEgc2Nhbm5lciBbc2NhbjFdIGlzIHJlYWRpbmcgZnJvbSBbaWIxXSBhbmQgc3RvcmVzIGFuXG4gICAgIHVudXNlZCBsb29rYWhlYWQgY2hhcmFjdGVyIFtjMV0gaW50byBpdHMgaW5wdXQgYnVmZmVyIFtpYjFdLCB0aGVuXG4gICAgIGFub3RoZXIgc2Nhbm5lciBbc2NhbjJdIG5vdCByZWFkaW5nIGZyb20gdGhlIHNhbWUgYnVmZmVyIFtpYjFdIHdpbGwgbWlzc1xuICAgICB0aGUgY2hhcmFjdGVyIFtjMV0sIHNlZW1pbmdseSB2YW5pc2hlZCBpbiB0aGUgYWlyIGZyb20gdGhlIHBvaW50IG9mIHZpZXdcbiAgICAgb2YgW3NjYW4yXS5cblxuICAgICBUaGlzIG1lY2hhbmlzbSB3b3JrcyBwZXJmZWN0bHkgdG8gcmVhZCBmcm9tIHN0cmluZ3MsIGZyb20gZmlsZXMsIGFuZCBmcm9tXG4gICAgIGZ1bmN0aW9ucywgc2luY2UgaW4gdGhvc2UgY2FzZXMsIGFsbG9jYXRpbmcgdHdvIGJ1ZmZlcnMgcmVhZGluZyBmcm9tIHRoZVxuICAgICBzYW1lIHNvdXJjZSBpcyB1bm5hdHVyYWwuXG5cbiAgICAgU3RpbGwsIHRoZXJlIGlzIGEgZGlmZmljdWx0eSBpbiB0aGUgY2FzZSBvZiBzY2FubmluZyBmcm9tIGFuIGlucHV0XG4gICAgIGNoYW5uZWwuIEluIGVmZmVjdCwgd2hlbiBzY2FubmluZyBmcm9tIGFuIGlucHV0IGNoYW5uZWwgW2ljXSwgdGhpcyBjaGFubmVsXG4gICAgIG1heSBub3QgaGF2ZSBiZWVuIGFsbG9jYXRlZCBmcm9tIHdpdGhpbiB0aGlzIGxpYnJhcnkuIEhlbmNlLCBpdCBtYXkgYmVcbiAgICAgc2hhcmVkICh0d28gZnVuY3Rpb25zIG9mIHRoZSB1c2VyJ3MgcHJvZ3JhbSBtYXkgc3VjY2Vzc2l2ZWx5IHJlYWQgZnJvbVxuICAgICBbaWNdKS4gVGhpcyBpcyBoaWdobHkgZXJyb3IgcHJvbmUgc2luY2UsIG9uZSBvZiB0aGUgZnVuY3Rpb24gbWF5IHNlZWsgdGhlXG4gICAgIGlucHV0IGNoYW5uZWwsIHdoaWxlIHRoZSBvdGhlciBmdW5jdGlvbiBoYXMgc3RpbGwgYW4gdW51c2VkIGxvb2thaGVhZFxuICAgICBjaGFyYWN0ZXIgaW4gaXRzIGlucHV0IGJ1ZmZlci4gSW4gY29uY2x1c2lvbiwgeW91IHNob3VsZCBuZXZlciBtaXggZGlyZWN0XG4gICAgIGxvdyBsZXZlbCByZWFkaW5nIGFuZCBoaWdoIGxldmVsIHNjYW5uaW5nIGZyb20gdGhlIHNhbWUgaW5wdXQgY2hhbm5lbC5cblxuICAqKVxuXG4gICgqIFBlcmZvcm0gYnVmZmVyaXplZCBpbnB1dCB0byBpbXByb3ZlIGVmZmljaWVuY3kuICopXG4gIGxldCBmaWxlX2J1ZmZlcl9zaXplID0gcmVmIDEwMjRcblxuICAoKiBUaGUgc2Nhbm5lciBjbG9zZXMgdGhlIGlucHV0IGNoYW5uZWwgYXQgZW5kIG9mIGlucHV0LiAqKVxuICBsZXQgc2Nhbl9jbG9zZV9hdF9lbmQgaWMgPSBTdGRsaWIuY2xvc2VfaW4gaWM7IHJhaXNlIEVuZF9vZl9maWxlXG5cbiAgKCogVGhlIHNjYW5uZXIgZG9lcyBub3QgY2xvc2UgdGhlIGlucHV0IGNoYW5uZWwgYXQgZW5kIG9mIGlucHV0OlxuICAgICBpdCBqdXN0IHJhaXNlcyBbRW5kX29mX2ZpbGVdLiAqKVxuICBsZXQgc2Nhbl9yYWlzZV9hdF9lbmQgX2ljID0gcmFpc2UgRW5kX29mX2ZpbGVcblxuICBsZXQgZnJvbV9pYyBzY2FuX2Nsb3NlX2ljIGluYW1lIGljID1cbiAgICBsZXQgbGVuID0gIWZpbGVfYnVmZmVyX3NpemUgaW5cbiAgICBsZXQgYnVmID0gQnl0ZXMuY3JlYXRlIGxlbiBpblxuICAgIGxldCBpID0gcmVmIDAgaW5cbiAgICBsZXQgbGltID0gcmVmIDAgaW5cbiAgICBsZXQgZW9mID0gcmVmIGZhbHNlIGluXG4gICAgbGV0IG5leHQgKCkgPVxuICAgICAgaWYgIWkgPCAhbGltIHRoZW4gYmVnaW4gbGV0IGMgPSBCeXRlcy5nZXQgYnVmICFpIGluIGluY3IgaTsgYyBlbmQgZWxzZVxuICAgICAgaWYgIWVvZiB0aGVuIHJhaXNlIEVuZF9vZl9maWxlIGVsc2UgYmVnaW5cbiAgICAgICAgbGltIDo9IGlucHV0IGljIGJ1ZiAwIGxlbjtcbiAgICAgICAgaWYgIWxpbSA9IDAgdGhlbiBiZWdpbiBlb2YgOj0gdHJ1ZTsgc2Nhbl9jbG9zZV9pYyBpYyBlbmQgZWxzZSBiZWdpblxuICAgICAgICAgIGkgOj0gMTtcbiAgICAgICAgICBCeXRlcy5nZXQgYnVmIDBcbiAgICAgICAgZW5kXG4gICAgICBlbmQgaW5cbiAgICBjcmVhdGUgaW5hbWUgbmV4dFxuXG5cbiAgbGV0IGZyb21faWNfY2xvc2VfYXRfZW5kID0gZnJvbV9pYyBzY2FuX2Nsb3NlX2F0X2VuZFxuICBsZXQgZnJvbV9pY19yYWlzZV9hdF9lbmQgPSBmcm9tX2ljIHNjYW5fcmFpc2VfYXRfZW5kXG5cbiAgKCogVGhlIHNjYW5uaW5nIGJ1ZmZlciByZWFkaW5nIGZyb20gW1N0ZGxpYi5zdGRpbl0uXG4gICAgIE9uZSBjb3VsZCB0cnkgdG8gZGVmaW5lIFtzdGRpYl0gYXMgYSBzY2FubmluZyBidWZmZXIgcmVhZGluZyBhIGNoYXJhY3RlclxuICAgICBhdCBhIHRpbWUgKG5vIGJ1ZmZlcml6YXRpb24gYXQgYWxsKSwgYnV0IHVuZm9ydHVuYXRlbHkgdGhlIHRvcC1sZXZlbFxuICAgICBpbnRlcmFjdGlvbiB3b3VsZCBiZSB3cm9uZy4gVGhpcyBpcyBkdWUgdG8gc29tZSBraW5kIG9mXG4gICAgICdyYWNlIGNvbmRpdGlvbicgd2hlbiByZWFkaW5nIGZyb20gW1N0ZGxpYi5zdGRpbl0sXG4gICAgIHNpbmNlIHRoZSBpbnRlcmFjdGl2ZSBjb21waWxlciBhbmQgW1NjYW5mLnNjYW5mXSB3aWxsIHNpbXVsdGFuZW91c2x5XG4gICAgIHJlYWQgdGhlIG1hdGVyaWFsIHRoZXkgbmVlZCBmcm9tIFtTdGRsaWIuc3RkaW5dOyB0aGVuLCBjb25mdXNpb25cbiAgICAgd2lsbCByZXN1bHQgZnJvbSB3aGF0IHNob3VsZCBiZSByZWFkIGJ5IHRoZSB0b3AtbGV2ZWwgYW5kIHdoYXQgc2hvdWxkIGJlXG4gICAgIHJlYWQgYnkgW1NjYW5mLnNjYW5mXS5cbiAgICAgVGhpcyBpcyBldmVuIG1vcmUgY29tcGxpY2F0ZWQgYnkgdGhlIG9uZSBjaGFyYWN0ZXIgbG9va2FoZWFkIHRoYXRcbiAgICAgW1NjYW5mLnNjYW5mXSBpcyBzb21ldGltZXMgb2JsaWdlZCB0byBtYWludGFpbjogdGhlIGxvb2thaGVhZCBjaGFyYWN0ZXJcbiAgICAgd2lsbCBiZSBhdmFpbGFibGUgZm9yIHRoZSBuZXh0IFtTY2FuZi5zY2FuZl0gZW50cnksIHNlZW1pbmdseSBjb21pbmcgZnJvbVxuICAgICBub3doZXJlLlxuICAgICBBbHNvIG5vIFtFbmRfb2ZfZmlsZV0gaXMgcmFpc2VkIHdoZW4gcmVhZGluZyBmcm9tIHN0ZGluOiBpZiBub3QgZW5vdWdoXG4gICAgIGNoYXJhY3RlcnMgaGF2ZSBiZWVuIHJlYWQsIHdlIHNpbXBseSBhc2sgdG8gcmVhZCBtb3JlLiAqKVxuICBsZXQgc3RkaW4gPVxuICAgIGZyb21faWMgc2Nhbl9yYWlzZV9hdF9lbmRcbiAgICAgIChGcm9tX2ZpbGUgKFwiLVwiLCBTdGRsaWIuc3RkaW4pKSBTdGRsaWIuc3RkaW5cblxuXG4gIGxldCBzdGRpYiA9IHN0ZGluXG5cbiAgbGV0IG9wZW5faW5fZmlsZSBvcGVuX2luIGZuYW1lID1cbiAgICBtYXRjaCBmbmFtZSB3aXRoXG4gICAgfCBcIi1cIiAtPiBzdGRpblxuICAgIHwgZm5hbWUgLT5cbiAgICAgIGxldCBpYyA9IG9wZW5faW4gZm5hbWUgaW5cbiAgICAgIGZyb21faWNfY2xvc2VfYXRfZW5kIChGcm9tX2ZpbGUgKGZuYW1lLCBpYykpIGljXG5cblxuICBsZXQgb3Blbl9pbiA9IG9wZW5faW5fZmlsZSBTdGRsaWIub3Blbl9pblxuICBsZXQgb3Blbl9pbl9iaW4gPSBvcGVuX2luX2ZpbGUgU3RkbGliLm9wZW5faW5fYmluXG5cbiAgbGV0IGZyb21fZmlsZSA9IG9wZW5faW5cbiAgbGV0IGZyb21fZmlsZV9iaW4gPSBvcGVuX2luX2JpblxuXG4gIGxldCBmcm9tX2NoYW5uZWwgaWMgPVxuICAgIGZyb21faWNfcmFpc2VfYXRfZW5kIChGcm9tX2NoYW5uZWwgaWMpIGljXG5cblxuICBsZXQgY2xvc2VfaW4gaWIgPVxuICAgIG1hdGNoIGliLmljX2lucHV0X25hbWUgd2l0aFxuICAgIHwgRnJvbV9jaGFubmVsIGljIC0+XG4gICAgICBTdGRsaWIuY2xvc2VfaW4gaWNcbiAgICB8IEZyb21fZmlsZSAoX2ZuYW1lLCBpYykgLT4gU3RkbGliLmNsb3NlX2luIGljXG4gICAgfCBGcm9tX2Z1bmN0aW9uIHwgRnJvbV9zdHJpbmcgLT4gKClcblxuXG4gICgqXG4gICAgIE9ic29sZXRlOiBhIG1lbW8gW2Zyb21fY2hhbm5lbF0gdmVyc2lvbiB0byBidWlsZCBhIFtTY2FubmluZy5pbl9jaGFubmVsXVxuICAgICBzY2FubmluZyBidWZmZXIgb3V0IG9mIGEgW1N0ZGxpYi5pbl9jaGFubmVsXS5cbiAgICAgVGhpcyBmdW5jdGlvbiB3YXMgdXNlZCB0byB0cnkgdG8gcHJlc2VydmUgdGhlIHNjYW5uaW5nXG4gICAgIHNlbWFudGljcyBmb3IgdGhlIChub3cgb2Jzb2xldGUpIGZ1bmN0aW9uIFtmc2NhbmZdLlxuICAgICBHaXZlbiB0aGF0IGFsbCBzY2FubmVyIG11c3QgcmVhZCBmcm9tIGEgW1NjYW5uaW5nLmluX2NoYW5uZWxdIHNjYW5uaW5nXG4gICAgIGJ1ZmZlciwgW2ZzY2FuZl0gbXVzdCByZWFkIGZyb20gb25lIVxuICAgICBNb3JlIHByZWNpc2VseSwgZ2l2ZW4gW2ljXSwgYWxsIHN1Y2Nlc3NpdmUgY2FsbHMgW2ZzY2FuZiBpY10gbXVzdCByZWFkXG4gICAgIGZyb20gdGhlIHNhbWUgc2Nhbm5pbmcgYnVmZmVyLlxuICAgICBUaGlzIG9ibGlnZWQgdGhpcyBsaWJyYXJ5IHRvIGFsbG9jYXRlZCBzY2FubmluZyBidWZmZXJzIHRoYXQgd2VyZVxuICAgICBub3QgcHJvcGVybHkgZ2FyYmFnZSBjb2xsZWN0YWJsZSwgaGVuY2UgbGVhZGluZyB0byBtZW1vcnkgbGVha3MuXG4gICAgIElmIHlvdSBuZWVkIHRvIHJlYWQgZnJvbSBhIFtTdGRsaWIuaW5fY2hhbm5lbF0gaW5wdXQgY2hhbm5lbFxuICAgICBbaWNdLCBzaW1wbHkgZGVmaW5lIGEgW1NjYW5uaW5nLmluX2NoYW5uZWxdIGZvcm1hdHRlZCBpbnB1dCBjaGFubmVsIGFzIGluXG4gICAgIFtsZXQgaWIgPSBTY2FubmluZy5mcm9tX2NoYW5uZWwgaWNdLCB0aGVuIHVzZSBbU2NhbmYuYnNjYW5mIGliXSBhcyB1c3VhbC5cbiAgKilcbiAgbGV0IG1lbW9fZnJvbV9pYyA9XG4gICAgbGV0IG1lbW8gPSByZWYgW10gaW5cbiAgICAoZnVuIHNjYW5fY2xvc2VfaWMgaWMgLT5cbiAgICAgdHJ5IExpc3QuYXNzcSBpYyAhbWVtbyB3aXRoXG4gICAgIHwgTm90X2ZvdW5kIC0+XG4gICAgICAgbGV0IGliID1cbiAgICAgICAgIGZyb21faWMgc2Nhbl9jbG9zZV9pYyAoRnJvbV9jaGFubmVsIGljKSBpYyBpblxuICAgICAgIG1lbW8gOj0gKGljLCBpYikgOjogIW1lbW87XG4gICAgICAgaWIpXG5cblxuICAoKiBPYnNvbGV0ZTogc2VlIHshbWVtb19mcm9tX2ljfSBhYm92ZS4gKilcbiAgbGV0IG1lbW9fZnJvbV9jaGFubmVsID0gbWVtb19mcm9tX2ljIHNjYW5fcmFpc2VfYXRfZW5kXG5cbmVuZFxuXG5cbigqIEZvcm1hdHRlZCBpbnB1dCBmdW5jdGlvbnMuICopXG5cbnR5cGUgKCdhLCAnYiwgJ2MsICdkKSBzY2FubmVyID1cbiAgICAgKCdhLCBTY2FubmluZy5pbl9jaGFubmVsLCAnYiwgJ2MsICdhIC0+ICdkLCAnZCkgZm9ybWF0NiAtPiAnY1xuXG5cbigqIFJlcG9ydGluZyBlcnJvcnMuICopXG5leGNlcHRpb24gU2Nhbl9mYWlsdXJlIG9mIHN0cmluZ1xuXG5sZXQgYmFkX2lucHV0IHMgPSByYWlzZSAoU2Nhbl9mYWlsdXJlIHMpXG5cbmxldCBiYWRfaW5wdXRfZXNjYXBlIGMgPVxuICBiYWRfaW5wdXQgKFByaW50Zi5zcHJpbnRmIFwiaWxsZWdhbCBlc2NhcGUgY2hhcmFjdGVyICVDXCIgYylcblxuXG5sZXQgYmFkX3Rva2VuX2xlbmd0aCBtZXNzYWdlID1cbiAgYmFkX2lucHV0XG4gICAgKFByaW50Zi5zcHJpbnRmXG4gICAgICAgXCJzY2FubmluZyBvZiAlcyBmYWlsZWQ6IFxcXG4gICAgICAgIHRoZSBzcGVjaWZpZWQgbGVuZ3RoIHdhcyB0b28gc2hvcnQgZm9yIHRva2VuXCJcbiAgICAgICBtZXNzYWdlKVxuXG5cbmxldCBiYWRfZW5kX29mX2lucHV0IG1lc3NhZ2UgPVxuICBiYWRfaW5wdXRcbiAgICAoUHJpbnRmLnNwcmludGZcbiAgICAgICBcInNjYW5uaW5nIG9mICVzIGZhaWxlZDogXFxcbiAgICAgICAgcHJlbWF0dXJlIGVuZCBvZiBmaWxlIG9jY3VycmVkIGJlZm9yZSBlbmQgb2YgdG9rZW5cIlxuICAgICAgIG1lc3NhZ2UpXG5cblxubGV0IGJhZF9mbG9hdCAoKSA9XG4gIGJhZF9pbnB1dCBcIm5vIGRvdCBvciBleHBvbmVudCBwYXJ0IGZvdW5kIGluIGZsb2F0IHRva2VuXCJcblxuXG5sZXQgYmFkX2hleF9mbG9hdCAoKSA9XG4gIGJhZF9pbnB1dCBcIm5vdCBhIHZhbGlkIGZsb2F0IGluIGhleGFkZWNpbWFsIG5vdGF0aW9uXCJcblxuXG5sZXQgY2hhcmFjdGVyX21pc21hdGNoX2VyciBjIGNpID1cbiAgUHJpbnRmLnNwcmludGYgXCJsb29raW5nIGZvciAlQywgZm91bmQgJUNcIiBjIGNpXG5cblxubGV0IGNoYXJhY3Rlcl9taXNtYXRjaCBjIGNpID1cbiAgYmFkX2lucHV0IChjaGFyYWN0ZXJfbWlzbWF0Y2hfZXJyIGMgY2kpXG5cblxubGV0IHJlYyBza2lwX3doaXRlcyBpYiA9XG4gIGxldCBjID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gIGlmIG5vdCAoU2Nhbm5pbmcuZW9mIGliKSB0aGVuIGJlZ2luXG4gICAgbWF0Y2ggYyB3aXRoXG4gICAgfCAnICcgfCAnXFx0JyB8ICdcXG4nIHwgJ1xccicgLT5cbiAgICAgIFNjYW5uaW5nLmludmFsaWRhdGVfY3VycmVudF9jaGFyIGliOyBza2lwX3doaXRlcyBpYlxuICAgIHwgXyAtPiAoKVxuICBlbmRcblxuXG4oKiBDaGVja2luZyB0aGF0IFtjXSBpcyBpbmRlZWQgaW4gdGhlIGlucHV0LCB0aGVuIHNraXBzIGl0LlxuICAgSW4gdGhpcyBjYXNlLCB0aGUgY2hhcmFjdGVyIFtjXSBoYXMgYmVlbiBleHBsaWNpdGx5IHNwZWNpZmllZCBpbiB0aGVcbiAgIGZvcm1hdCBhcyBiZWluZyBtYW5kYXRvcnkgaW4gdGhlIGlucHV0OyBoZW5jZSB3ZSBzaG91bGQgZmFpbCB3aXRoXG4gICBbRW5kX29mX2ZpbGVdIGluIGNhc2Ugb2YgZW5kX29mX2lucHV0LlxuICAgKFJlbWVtYmVyIHRoYXQgW1NjYW5fZmFpbHVyZV0gaXMgcmFpc2VkIG9ubHkgd2hlbiAod2UgY2FuIHByb3ZlIGJ5XG4gICBldmlkZW5jZSkgdGhhdCB0aGUgaW5wdXQgZG9lcyBub3QgbWF0Y2ggdGhlIGZvcm1hdCBzdHJpbmcgZ2l2ZW4uIFdlIG11c3RcbiAgIHRodXMgZGlmZmVyZW50aWF0ZSBbRW5kX29mX2ZpbGVdIGFzIGFuIGVycm9yIGR1ZSB0byBsYWNrIG9mIGlucHV0LCBhbmRcbiAgIFtTY2FuX2ZhaWx1cmVdIHdoaWNoIGlzIGR1ZSB0byBwcm92YWJseSB3cm9uZyBpbnB1dC4gSSBhbSBub3Qgc3VyZSB0aGlzIGlzXG4gICB3b3J0aCB0aGUgYnVyZGVuOiBpdCBpcyBjb21wbGV4IGFuZCBzb21laG93IHN1YmxpbWluYWw7IHNob3VsZCBiZSBjbGVhcmVyXG4gICB0byBmYWlsIHdpdGggU2Nhbl9mYWlsdXJlIFwiTm90IGVub3VnaCBpbnB1dCB0byBjb21wbGV0ZSBzY2FubmluZ1wiISlcblxuICAgVGhhdCdzIHdoeSwgd2FpdGluZyBmb3IgYSBiZXR0ZXIgc29sdXRpb24sIHdlIHVzZSBjaGVja2VkX3BlZWtfY2hhciBoZXJlLlxuICAgV2UgYXJlIGFsc28gY2FyZWZ1bCB0byB0cmVhdCBcIlxcclxcblwiIGluIHRoZSBpbnB1dCBhcyBhbiBlbmQgb2YgbGluZSBtYXJrZXI6XG4gICBpdCBhbHdheXMgbWF0Y2hlcyBhICdcXG4nIHNwZWNpZmljYXRpb24gaW4gdGhlIGlucHV0IGZvcm1hdCBzdHJpbmcuICopXG5sZXQgcmVjIGNoZWNrX2NoYXIgaWIgYyA9XG4gIG1hdGNoIGMgd2l0aFxuICB8ICcgJyAtPiBza2lwX3doaXRlcyBpYlxuICB8ICdcXG4nIC0+IGNoZWNrX25ld2xpbmUgaWJcbiAgfCBjIC0+IGNoZWNrX3RoaXNfY2hhciBpYiBjXG5cbmFuZCBjaGVja190aGlzX2NoYXIgaWIgYyA9XG4gIGxldCBjaSA9IFNjYW5uaW5nLmNoZWNrZWRfcGVla19jaGFyIGliIGluXG4gIGlmIGNpID0gYyB0aGVuIFNjYW5uaW5nLmludmFsaWRhdGVfY3VycmVudF9jaGFyIGliIGVsc2VcbiAgY2hhcmFjdGVyX21pc21hdGNoIGMgY2lcblxuYW5kIGNoZWNrX25ld2xpbmUgaWIgPVxuICBsZXQgY2kgPSBTY2FubmluZy5jaGVja2VkX3BlZWtfY2hhciBpYiBpblxuICBtYXRjaCBjaSB3aXRoXG4gIHwgJ1xcbicgLT4gU2Nhbm5pbmcuaW52YWxpZGF0ZV9jdXJyZW50X2NoYXIgaWJcbiAgfCAnXFxyJyAtPiBTY2FubmluZy5pbnZhbGlkYXRlX2N1cnJlbnRfY2hhciBpYjsgY2hlY2tfdGhpc19jaGFyIGliICdcXG4nXG4gIHwgXyAtPiBjaGFyYWN0ZXJfbWlzbWF0Y2ggJ1xcbicgY2lcblxuXG4oKiBFeHRyYWN0aW5nIHRva2VucyBmcm9tIHRoZSBvdXRwdXQgdG9rZW4gYnVmZmVyLiAqKVxuXG5sZXQgdG9rZW5fY2hhciBpYiA9IChTY2FubmluZy50b2tlbiBpYikuWzBdXG5cbmxldCB0b2tlbl9zdHJpbmcgPSBTY2FubmluZy50b2tlblxuXG5sZXQgdG9rZW5fYm9vbCBpYiA9XG4gIG1hdGNoIFNjYW5uaW5nLnRva2VuIGliIHdpdGhcbiAgfCBcInRydWVcIiAtPiB0cnVlXG4gIHwgXCJmYWxzZVwiIC0+IGZhbHNlXG4gIHwgcyAtPiBiYWRfaW5wdXQgKFByaW50Zi5zcHJpbnRmIFwiaW52YWxpZCBib29sZWFuICclcydcIiBzKVxuXG5cbigqIFRoZSB0eXBlIG9mIGludGVnZXIgY29udmVyc2lvbnMuICopXG50eXBlIGludGVnZXJfY29udmVyc2lvbiA9XG4gIHwgQl9jb252ZXJzaW9uICgqIFVuc2lnbmVkIGJpbmFyeSBjb252ZXJzaW9uICopXG4gIHwgRF9jb252ZXJzaW9uICgqIFNpZ25lZCBkZWNpbWFsIGNvbnZlcnNpb24gKilcbiAgfCBJX2NvbnZlcnNpb24gKCogU2lnbmVkIGludGVnZXIgY29udmVyc2lvbiAqKVxuICB8IE9fY29udmVyc2lvbiAoKiBVbnNpZ25lZCBvY3RhbCBjb252ZXJzaW9uICopXG4gIHwgVV9jb252ZXJzaW9uICgqIFVuc2lnbmVkIGRlY2ltYWwgY29udmVyc2lvbiAqKVxuICB8IFhfY29udmVyc2lvbiAoKiBVbnNpZ25lZCBoZXhhZGVjaW1hbCBjb252ZXJzaW9uICopXG5cblxubGV0IGludGVnZXJfY29udmVyc2lvbl9vZl9jaGFyID0gZnVuY3Rpb25cbiAgfCAnYicgLT4gQl9jb252ZXJzaW9uXG4gIHwgJ2QnIC0+IERfY29udmVyc2lvblxuICB8ICdpJyAtPiBJX2NvbnZlcnNpb25cbiAgfCAnbycgLT4gT19jb252ZXJzaW9uXG4gIHwgJ3UnIC0+IFVfY29udmVyc2lvblxuICB8ICd4JyB8ICdYJyAtPiBYX2NvbnZlcnNpb25cbiAgfCBfIC0+IGFzc2VydCBmYWxzZVxuXG5cbigqIEV4dHJhY3QgYW4gaW50ZWdlciBsaXRlcmFsIHRva2VuLlxuICAgU2luY2UgdGhlIGZ1bmN0aW9ucyBTdGRsaWIuKmludCpfb2Zfc3RyaW5nIGRvIG5vdCBhY2NlcHQgYSBsZWFkaW5nICssXG4gICB3ZSBza2lwIGl0IGlmIG5lY2Vzc2FyeS4gKilcbmxldCB0b2tlbl9pbnRfbGl0ZXJhbCBjb252IGliID1cbiAgbGV0IHRvayA9XG4gICAgbWF0Y2ggY29udiB3aXRoXG4gICAgfCBEX2NvbnZlcnNpb24gfCBJX2NvbnZlcnNpb24gLT4gU2Nhbm5pbmcudG9rZW4gaWJcbiAgICB8IFVfY29udmVyc2lvbiAtPiBcIjB1XCIgXiBTY2FubmluZy50b2tlbiBpYlxuICAgIHwgT19jb252ZXJzaW9uIC0+IFwiMG9cIiBeIFNjYW5uaW5nLnRva2VuIGliXG4gICAgfCBYX2NvbnZlcnNpb24gLT4gXCIweFwiIF4gU2Nhbm5pbmcudG9rZW4gaWJcbiAgICB8IEJfY29udmVyc2lvbiAtPiBcIjBiXCIgXiBTY2FubmluZy50b2tlbiBpYiBpblxuICBsZXQgbCA9IFN0cmluZy5sZW5ndGggdG9rIGluXG4gIGlmIGwgPSAwIHx8IHRvay5bMF0gPD4gJysnIHRoZW4gdG9rIGVsc2UgU3RyaW5nLnN1YiB0b2sgMSAobCAtIDEpXG5cblxuKCogQWxsIHRoZSBmdW5jdGlvbnMgdGhhdCBjb252ZXJ0IGEgc3RyaW5nIHRvIGEgbnVtYmVyIHJhaXNlIHRoZSBleGNlcHRpb25cbiAgIEZhaWx1cmUgd2hlbiB0aGUgY29udmVyc2lvbiBpcyBub3QgcG9zc2libGUuXG4gICBUaGlzIGV4Y2VwdGlvbiBpcyB0aGVuIHRyYXBwZWQgaW4gW2tzY2FuZl0uICopXG5sZXQgdG9rZW5faW50IGNvbnYgaWIgPSBpbnRfb2Zfc3RyaW5nICh0b2tlbl9pbnRfbGl0ZXJhbCBjb252IGliKVxuXG5sZXQgdG9rZW5fZmxvYXQgaWIgPSBmbG9hdF9vZl9zdHJpbmcgKFNjYW5uaW5nLnRva2VuIGliKVxuXG4oKiBUbyBzY2FuIG5hdGl2ZSBpbnRzLCBpbnQzMiBhbmQgaW50NjQgaW50ZWdlcnMuXG4gICBXZSBjYW5ub3QgYWNjZXNzIHRvIGNvbnZlcnNpb25zIHRvL2Zyb20gc3RyaW5ncyBmb3IgdGhvc2UgdHlwZXMsXG4gICBOYXRpdmVpbnQub2Zfc3RyaW5nLCBJbnQzMi5vZl9zdHJpbmcsIGFuZCBJbnQ2NC5vZl9zdHJpbmcsXG4gICBzaW5jZSB0aG9zZSBtb2R1bGVzIGFyZSBub3QgYXZhaWxhYmxlIHRvIFtTY2FuZl0uXG4gICBIb3dldmVyLCB3ZSBjYW4gYmluZCBhbmQgdXNlIHRoZSBjb3JyZXNwb25kaW5nIHByaW1pdGl2ZXMgdGhhdCBhcmVcbiAgIGF2YWlsYWJsZSBpbiB0aGUgcnVudGltZS4gKilcbmV4dGVybmFsIG5hdGl2ZWludF9vZl9zdHJpbmcgOiBzdHJpbmcgLT4gbmF0aXZlaW50XG4gID0gXCJjYW1sX25hdGl2ZWludF9vZl9zdHJpbmdcIlxuXG5leHRlcm5hbCBpbnQzMl9vZl9zdHJpbmcgOiBzdHJpbmcgLT4gaW50MzJcbiAgPSBcImNhbWxfaW50MzJfb2Zfc3RyaW5nXCJcblxuZXh0ZXJuYWwgaW50NjRfb2Zfc3RyaW5nIDogc3RyaW5nIC0+IGludDY0XG4gID0gXCJjYW1sX2ludDY0X29mX3N0cmluZ1wiXG5cblxubGV0IHRva2VuX25hdGl2ZWludCBjb252IGliID0gbmF0aXZlaW50X29mX3N0cmluZyAodG9rZW5faW50X2xpdGVyYWwgY29udiBpYilcbmxldCB0b2tlbl9pbnQzMiBjb252IGliID0gaW50MzJfb2Zfc3RyaW5nICh0b2tlbl9pbnRfbGl0ZXJhbCBjb252IGliKVxubGV0IHRva2VuX2ludDY0IGNvbnYgaWIgPSBpbnQ2NF9vZl9zdHJpbmcgKHRva2VuX2ludF9saXRlcmFsIGNvbnYgaWIpXG5cbigqIFNjYW5uaW5nIG51bWJlcnMuICopXG5cbigqIERpZ2l0cyBzY2FubmluZyBmdW5jdGlvbnMgc3VwcG9zZSB0aGF0IG9uZSBjaGFyYWN0ZXIgaGFzIGJlZW4gY2hlY2tlZCBhbmRcbiAgIGlzIGF2YWlsYWJsZSwgc2luY2UgdGhleSByZXR1cm4gYXQgZW5kIG9mIGZpbGUgd2l0aCB0aGUgY3VycmVudGx5IGZvdW5kXG4gICB0b2tlbiBzZWxlY3RlZC5cblxuICAgUHV0IGl0IGluIGFub3RoZXIgd2F5LCB0aGUgZGlnaXRzIHNjYW5uaW5nIGZ1bmN0aW9ucyBzY2FuIGZvciBhIHBvc3NpYmx5XG4gICBlbXB0eSBzZXF1ZW5jZSBvZiBkaWdpdHMsIChoZW5jZSwgYSBzdWNjZXNzZnVsIHNjYW5uaW5nIGZyb20gb25lIG9mIHRob3NlXG4gICBmdW5jdGlvbnMgZG9lcyBub3QgaW1wbHkgdGhhdCB0aGUgdG9rZW4gaXMgYSB3ZWxsLWZvcm1lZCBudW1iZXI6IHRvIGdldCBhXG4gICB0cnVlIG51bWJlciwgaXQgaXMgbWFuZGF0b3J5IHRvIGNoZWNrIHRoYXQgYXQgbGVhc3Qgb25lIHZhbGlkIGRpZ2l0IGlzXG4gICBhdmFpbGFibGUgYmVmb3JlIGNhbGxpbmcgb25lIG9mIHRoZSBkaWdpdCBzY2FubmluZyBmdW5jdGlvbnMpLiAqKVxuXG4oKiBUaGUgZGVjaW1hbCBjYXNlIGlzIHRyZWF0ZWQgZXNwZWNpYWxseSBmb3Igb3B0aW1pemF0aW9uIHB1cnBvc2VzLiAqKVxubGV0IHJlYyBzY2FuX2RlY2ltYWxfZGlnaXRfc3RhciB3aWR0aCBpYiA9XG4gIGlmIHdpZHRoID0gMCB0aGVuIHdpZHRoIGVsc2VcbiAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgaWYgU2Nhbm5pbmcuZW9mIGliIHRoZW4gd2lkdGggZWxzZVxuICBtYXRjaCBjIHdpdGhcbiAgfCAnMCcgLi4gJzknIGFzIGMgLT5cbiAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICBzY2FuX2RlY2ltYWxfZGlnaXRfc3RhciB3aWR0aCBpYlxuICB8ICdfJyAtPlxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliIGluXG4gICAgc2Nhbl9kZWNpbWFsX2RpZ2l0X3N0YXIgd2lkdGggaWJcbiAgfCBfIC0+IHdpZHRoXG5cblxubGV0IHNjYW5fZGVjaW1hbF9kaWdpdF9wbHVzIHdpZHRoIGliID1cbiAgaWYgd2lkdGggPSAwIHRoZW4gYmFkX3Rva2VuX2xlbmd0aCBcImRlY2ltYWwgZGlnaXRzXCIgZWxzZVxuICBsZXQgYyA9IFNjYW5uaW5nLmNoZWNrZWRfcGVla19jaGFyIGliIGluXG4gIG1hdGNoIGMgd2l0aFxuICB8ICcwJyAuLiAnOScgLT5cbiAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICBzY2FuX2RlY2ltYWxfZGlnaXRfc3RhciB3aWR0aCBpYlxuICB8IGMgLT5cbiAgICBiYWRfaW5wdXQgKFByaW50Zi5zcHJpbnRmIFwiY2hhcmFjdGVyICVDIGlzIG5vdCBhIGRlY2ltYWwgZGlnaXRcIiBjKVxuXG5cbigqIFRvIHNjYW4gbnVtYmVycyBmcm9tIG90aGVyIGJhc2VzLCB3ZSB1c2UgYSBwcmVkaWNhdGUgYXJndW1lbnQgdG9cbiAgIHNjYW4gZGlnaXRzLiAqKVxubGV0IHNjYW5fZGlnaXRfc3RhciBkaWdpdHAgd2lkdGggaWIgPVxuICBsZXQgcmVjIHNjYW5fZGlnaXRzIHdpZHRoIGliID1cbiAgICBpZiB3aWR0aCA9IDAgdGhlbiB3aWR0aCBlbHNlXG4gICAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgICBpZiBTY2FubmluZy5lb2YgaWIgdGhlbiB3aWR0aCBlbHNlXG4gICAgbWF0Y2ggYyB3aXRoXG4gICAgfCBjIHdoZW4gZGlnaXRwIGMgLT5cbiAgICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgICAgc2Nhbl9kaWdpdHMgd2lkdGggaWJcbiAgICB8ICdfJyAtPlxuICAgICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuaWdub3JlX2NoYXIgd2lkdGggaWIgaW5cbiAgICAgIHNjYW5fZGlnaXRzIHdpZHRoIGliXG4gICAgfCBfIC0+IHdpZHRoIGluXG4gIHNjYW5fZGlnaXRzIHdpZHRoIGliXG5cblxubGV0IHNjYW5fZGlnaXRfcGx1cyBiYXNpcyBkaWdpdHAgd2lkdGggaWIgPVxuICAoKiBFbnN1cmUgd2UgaGF2ZSBnb3QgZW5vdWdoIHdpZHRoIGxlZnQsXG4gICAgIGFuZCByZWFkIGF0IGxlYXN0IG9uZSBkaWdpdC4gKilcbiAgaWYgd2lkdGggPSAwIHRoZW4gYmFkX3Rva2VuX2xlbmd0aCBcImRpZ2l0c1wiIGVsc2VcbiAgbGV0IGMgPSBTY2FubmluZy5jaGVja2VkX3BlZWtfY2hhciBpYiBpblxuICBpZiBkaWdpdHAgYyB0aGVuXG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgc2Nhbl9kaWdpdF9zdGFyIGRpZ2l0cCB3aWR0aCBpYlxuICBlbHNlXG4gICAgYmFkX2lucHV0IChQcmludGYuc3ByaW50ZiBcImNoYXJhY3RlciAlQyBpcyBub3QgYSB2YWxpZCAlcyBkaWdpdFwiIGMgYmFzaXMpXG5cblxubGV0IGlzX2JpbmFyeV9kaWdpdCA9IGZ1bmN0aW9uXG4gIHwgJzAnIC4uICcxJyAtPiB0cnVlXG4gIHwgXyAtPiBmYWxzZVxuXG5cbmxldCBzY2FuX2JpbmFyeV9pbnQgPSBzY2FuX2RpZ2l0X3BsdXMgXCJiaW5hcnlcIiBpc19iaW5hcnlfZGlnaXRcblxubGV0IGlzX29jdGFsX2RpZ2l0ID0gZnVuY3Rpb25cbiAgfCAnMCcgLi4gJzcnIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG5cblxubGV0IHNjYW5fb2N0YWxfaW50ID0gc2Nhbl9kaWdpdF9wbHVzIFwib2N0YWxcIiBpc19vY3RhbF9kaWdpdFxuXG5sZXQgaXNfaGV4YV9kaWdpdCA9IGZ1bmN0aW9uXG4gIHwgJzAnIC4uICc5JyB8ICdhJyAuLiAnZicgfCAnQScgLi4gJ0YnIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG5cblxubGV0IHNjYW5faGV4YWRlY2ltYWxfaW50ID0gc2Nhbl9kaWdpdF9wbHVzIFwiaGV4YWRlY2ltYWxcIiBpc19oZXhhX2RpZ2l0XG5cbigqIFNjYW4gYSBkZWNpbWFsIGludGVnZXIuICopXG5sZXQgc2Nhbl91bnNpZ25lZF9kZWNpbWFsX2ludCA9IHNjYW5fZGVjaW1hbF9kaWdpdF9wbHVzXG5cbmxldCBzY2FuX3NpZ24gd2lkdGggaWIgPVxuICBsZXQgYyA9IFNjYW5uaW5nLmNoZWNrZWRfcGVla19jaGFyIGliIGluXG4gIG1hdGNoIGMgd2l0aFxuICB8ICcrJyAtPiBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGNcbiAgfCAnLScgLT4gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjXG4gIHwgXyAtPiB3aWR0aFxuXG5cbmxldCBzY2FuX29wdGlvbmFsbHlfc2lnbmVkX2RlY2ltYWxfaW50IHdpZHRoIGliID1cbiAgbGV0IHdpZHRoID0gc2Nhbl9zaWduIHdpZHRoIGliIGluXG4gIHNjYW5fdW5zaWduZWRfZGVjaW1hbF9pbnQgd2lkdGggaWJcblxuXG4oKiBTY2FuIGFuIHVuc2lnbmVkIGludGVnZXIgdGhhdCBjb3VsZCBiZSBnaXZlbiBpbiBhbnkgKGNvbW1vbikgYmFzaXMuXG4gICBJZiBkaWdpdHMgYXJlIHByZWZpeGVkIGJ5IG9uZSBvZiAweCwgMFgsIDBvLCBvciAwYiwgdGhlIG51bWJlciBpc1xuICAgYXNzdW1lZCB0byBiZSB3cml0dGVuIHJlc3BlY3RpdmVseSBpbiBoZXhhZGVjaW1hbCwgaGV4YWRlY2ltYWwsXG4gICBvY3RhbCwgb3IgYmluYXJ5LiAqKVxubGV0IHNjYW5fdW5zaWduZWRfaW50IHdpZHRoIGliID1cbiAgbWF0Y2ggU2Nhbm5pbmcuY2hlY2tlZF9wZWVrX2NoYXIgaWIgd2l0aFxuICB8ICcwJyBhcyBjIC0+XG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgaWYgd2lkdGggPSAwIHRoZW4gd2lkdGggZWxzZVxuICAgIGxldCBjID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gICAgaWYgU2Nhbm5pbmcuZW9mIGliIHRoZW4gd2lkdGggZWxzZVxuICAgIGJlZ2luIG1hdGNoIGMgd2l0aFxuICAgIHwgJ3gnIHwgJ1gnIC0+IHNjYW5faGV4YWRlY2ltYWxfaW50IChTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMpIGliXG4gICAgfCAnbycgLT4gc2Nhbl9vY3RhbF9pbnQgKFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYykgaWJcbiAgICB8ICdiJyAtPiBzY2FuX2JpbmFyeV9pbnQgKFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYykgaWJcbiAgICB8IF8gLT4gc2Nhbl9kZWNpbWFsX2RpZ2l0X3N0YXIgd2lkdGggaWIgZW5kXG4gIHwgXyAtPiBzY2FuX3Vuc2lnbmVkX2RlY2ltYWxfaW50IHdpZHRoIGliXG5cblxubGV0IHNjYW5fb3B0aW9uYWxseV9zaWduZWRfaW50IHdpZHRoIGliID1cbiAgbGV0IHdpZHRoID0gc2Nhbl9zaWduIHdpZHRoIGliIGluXG4gIHNjYW5fdW5zaWduZWRfaW50IHdpZHRoIGliXG5cblxubGV0IHNjYW5faW50X2NvbnZlcnNpb24gY29udiB3aWR0aCBpYiA9XG4gIG1hdGNoIGNvbnYgd2l0aFxuICB8IEJfY29udmVyc2lvbiAtPiBzY2FuX2JpbmFyeV9pbnQgd2lkdGggaWJcbiAgfCBEX2NvbnZlcnNpb24gLT4gc2Nhbl9vcHRpb25hbGx5X3NpZ25lZF9kZWNpbWFsX2ludCB3aWR0aCBpYlxuICB8IElfY29udmVyc2lvbiAtPiBzY2FuX29wdGlvbmFsbHlfc2lnbmVkX2ludCB3aWR0aCBpYlxuICB8IE9fY29udmVyc2lvbiAtPiBzY2FuX29jdGFsX2ludCB3aWR0aCBpYlxuICB8IFVfY29udmVyc2lvbiAtPiBzY2FuX3Vuc2lnbmVkX2RlY2ltYWxfaW50IHdpZHRoIGliXG4gIHwgWF9jb252ZXJzaW9uIC0+IHNjYW5faGV4YWRlY2ltYWxfaW50IHdpZHRoIGliXG5cblxuKCogU2Nhbm5pbmcgZmxvYXRpbmcgcG9pbnQgbnVtYmVycy4gKilcblxuKCogRnJhY3Rpb25hbCBwYXJ0IGlzIG9wdGlvbmFsIGFuZCBjYW4gYmUgcmVkdWNlZCB0byAwIGRpZ2l0cy4gKilcbmxldCBzY2FuX2ZyYWN0aW9uYWxfcGFydCB3aWR0aCBpYiA9XG4gIGlmIHdpZHRoID0gMCB0aGVuIHdpZHRoIGVsc2VcbiAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgaWYgU2Nhbm5pbmcuZW9mIGliIHRoZW4gd2lkdGggZWxzZVxuICBtYXRjaCBjIHdpdGhcbiAgfCAnMCcgLi4gJzknIGFzIGMgLT5cbiAgICBzY2FuX2RlY2ltYWxfZGlnaXRfc3RhciAoU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjKSBpYlxuICB8IF8gLT4gd2lkdGhcblxuXG4oKiBFeHAgcGFydCBpcyBvcHRpb25hbCBhbmQgY2FuIGJlIHJlZHVjZWQgdG8gMCBkaWdpdHMuICopXG5sZXQgc2Nhbl9leHBvbmVudF9wYXJ0IHdpZHRoIGliID1cbiAgaWYgd2lkdGggPSAwIHRoZW4gd2lkdGggZWxzZVxuICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICBpZiBTY2FubmluZy5lb2YgaWIgdGhlbiB3aWR0aCBlbHNlXG4gIG1hdGNoIGMgd2l0aFxuICB8ICdlJyB8ICdFJyBhcyBjIC0+XG4gICAgc2Nhbl9vcHRpb25hbGx5X3NpZ25lZF9kZWNpbWFsX2ludCAoU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjKSBpYlxuICB8IF8gLT4gd2lkdGhcblxuXG4oKiBTY2FuIHRoZSBpbnRlZ2VyIHBhcnQgb2YgYSBmbG9hdGluZyBwb2ludCBudW1iZXIsIChub3QgdXNpbmcgdGhlXG4gICBPQ2FtbCBsZXhpY2FsIGNvbnZlbnRpb24gc2luY2UgdGhlIGludGVnZXIgcGFydCBjYW4gYmUgZW1wdHkpOlxuICAgYW4gb3B0aW9uYWwgc2lnbiwgZm9sbG93ZWQgYnkgYSBwb3NzaWJseSBlbXB0eSBzZXF1ZW5jZSBvZiBkZWNpbWFsXG4gICBkaWdpdHMgKGUuZy4gLS4xKS4gKilcbmxldCBzY2FuX2ludGVnZXJfcGFydCB3aWR0aCBpYiA9XG4gIGxldCB3aWR0aCA9IHNjYW5fc2lnbiB3aWR0aCBpYiBpblxuICBzY2FuX2RlY2ltYWxfZGlnaXRfc3RhciB3aWR0aCBpYlxuXG5cbigqXG4gICBGb3IgdGhlIHRpbWUgYmVpbmcgd2UgaGF2ZSAoYXMgZm91bmQgaW4gc2NhbmYubWxpKTpcbiAgIHRoZSBmaWVsZCB3aWR0aCBpcyBjb21wb3NlZCBvZiBhbiBvcHRpb25hbCBpbnRlZ2VyIGxpdGVyYWxcbiAgIGluZGljYXRpbmcgdGhlIG1heGltYWwgd2lkdGggb2YgdGhlIHRva2VuIHRvIHJlYWQuXG4gICBVbmZvcnR1bmF0ZWx5LCB0aGUgdHlwZS1jaGVja2VyIGxldCB0aGUgdXNlciB3cml0ZSBhbiBvcHRpb25hbCBwcmVjaXNpb24sXG4gICBzaW5jZSB0aGlzIGlzIHZhbGlkIGZvciBwcmludGYgZm9ybWF0IHN0cmluZ3MuXG5cbiAgIFRodXMsIHRoZSBuZXh0IHN0ZXAgZm9yIFNjYW5mIGlzIHRvIHN1cHBvcnQgYSBmdWxsIHdpZHRoIGFuZCBwcmVjaXNpb25cbiAgIGluZGljYXRpb24sIG1vcmUgb3IgbGVzcyBzaW1pbGFyIHRvIHRoZSBvbmUgZm9yIHByaW50ZiwgcG9zc2libHkgZXh0ZW5kZWRcbiAgIHRvIHRoZSBzcGVjaWZpY2F0aW9uIG9mIGEgW21heCwgbWluXSByYW5nZSBmb3IgdGhlIHdpZHRoIG9mIHRoZSB0b2tlbiByZWFkXG4gICBmb3Igc3RyaW5ncy4gU29tZXRoaW5nIGxpa2UgdGhlIGZvbGxvd2luZyBzcGVjIGZvciBzY2FuZi5tbGk6XG5cbiAgIFRoZSBvcHRpb25hbCBbd2lkdGhdIGlzIGFuIGludGVnZXIgaW5kaWNhdGluZyB0aGUgbWF4aW1hbFxuICAgd2lkdGggb2YgdGhlIHRva2VuIHJlYWQuIEZvciBpbnN0YW5jZSwgWyU2ZF0gcmVhZHMgYW4gaW50ZWdlcixcbiAgIGhhdmluZyBhdCBtb3N0IDYgY2hhcmFjdGVycy5cblxuICAgVGhlIG9wdGlvbmFsIFtwcmVjaXNpb25dIGlzIGEgZG90IFsuXSBmb2xsb3dlZCBieSBhbiBpbnRlZ2VyOlxuXG4gICAtIGluIHRoZSBmbG9hdGluZyBwb2ludCBudW1iZXIgY29udmVyc2lvbnMgKFslZl0sIFslZV0sIFslZ10sIFslRl0sIFslRV0sXG4gICBhbmQgWyVGXSBjb252ZXJzaW9ucywgdGhlIFtwcmVjaXNpb25dIGluZGljYXRlcyB0aGUgbWF4aW11bSBudW1iZXIgb2ZcbiAgIGRpZ2l0cyB0aGF0IG1heSBmb2xsb3cgdGhlIGRlY2ltYWwgcG9pbnQuIEZvciBpbnN0YW5jZSwgWyUuNGZdIHJlYWRzIGFcbiAgIFtmbG9hdF0gd2l0aCBhdCBtb3N0IDQgZnJhY3Rpb25hbCBkaWdpdHMsXG5cbiAgIC0gaW4gdGhlIHN0cmluZyBjb252ZXJzaW9ucyAoWyVzXSwgWyVTXSwgWyVcXFsgcmFuZ2UgXFxdXSksIGFuZCBpbiB0aGVcbiAgIGludGVnZXIgbnVtYmVyIGNvbnZlcnNpb25zIChbJWldLCBbJWRdLCBbJXVdLCBbJXhdLCBbJW9dLCBhbmQgdGhlaXJcbiAgIFtpbnQzMl0sIFtpbnQ2NF0sIGFuZCBbbmF0aXZlX2ludF0gY29ycmVzcG9uZGVudCksIHRoZSBbcHJlY2lzaW9uXVxuICAgaW5kaWNhdGVzIHRoZSByZXF1aXJlZCBtaW5pbXVtIHdpZHRoIG9mIHRoZSB0b2tlbiByZWFkLFxuXG4gICAtIG9uIGFsbCBvdGhlciBjb252ZXJzaW9ucywgdGhlIHdpZHRoIGFuZCBwcmVjaXNpb24gc3BlY2lmeSB0aGUgW21heCwgbWluXVxuICAgcmFuZ2UgZm9yIHRoZSB3aWR0aCBvZiB0aGUgdG9rZW4gcmVhZC5cbiopXG5sZXQgc2Nhbl9mbG9hdCB3aWR0aCBwcmVjaXNpb24gaWIgPVxuICBsZXQgd2lkdGggPSBzY2FuX2ludGVnZXJfcGFydCB3aWR0aCBpYiBpblxuICBpZiB3aWR0aCA9IDAgdGhlbiB3aWR0aCwgcHJlY2lzaW9uIGVsc2VcbiAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgaWYgU2Nhbm5pbmcuZW9mIGliIHRoZW4gd2lkdGgsIHByZWNpc2lvbiBlbHNlXG4gIG1hdGNoIGMgd2l0aFxuICB8ICcuJyAtPlxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgIGxldCBwcmVjaXNpb24gPSBJbnQubWluIHdpZHRoIHByZWNpc2lvbiBpblxuICAgIGxldCB3aWR0aCA9IHdpZHRoIC0gKHByZWNpc2lvbiAtIHNjYW5fZnJhY3Rpb25hbF9wYXJ0IHByZWNpc2lvbiBpYikgaW5cbiAgICBzY2FuX2V4cG9uZW50X3BhcnQgd2lkdGggaWIsIHByZWNpc2lvblxuICB8IF8gLT5cbiAgICBzY2FuX2V4cG9uZW50X3BhcnQgd2lkdGggaWIsIHByZWNpc2lvblxuXG5cbmxldCBjaGVja19jYXNlX2luc2Vuc2l0aXZlX3N0cmluZyB3aWR0aCBpYiBlcnJvciBzdHIgPVxuICBsZXQgbG93ZXJjYXNlIGMgPVxuICAgIG1hdGNoIGMgd2l0aFxuICAgIHwgJ0EnIC4uICdaJyAtPlxuICAgICAgY2hhcl9vZl9pbnQgKGludF9vZl9jaGFyIGMgLSBpbnRfb2ZfY2hhciAnQScgKyBpbnRfb2ZfY2hhciAnYScpXG4gICAgfCBfIC0+IGMgaW5cbiAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggc3RyIGluXG4gIGxldCB3aWR0aCA9IHJlZiB3aWR0aCBpblxuICBmb3IgaSA9IDAgdG8gbGVuIC0gMSBkb1xuICAgIGxldCBjID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gICAgaWYgbG93ZXJjYXNlIGMgPD4gbG93ZXJjYXNlIHN0ci5baV0gdGhlbiBlcnJvciAoKTtcbiAgICBpZiAhd2lkdGggPSAwIHRoZW4gZXJyb3IgKCk7XG4gICAgd2lkdGggOj0gU2Nhbm5pbmcuc3RvcmVfY2hhciAhd2lkdGggaWIgYztcbiAgZG9uZTtcbiAgIXdpZHRoXG5cblxubGV0IHNjYW5faGV4X2Zsb2F0IHdpZHRoIHByZWNpc2lvbiBpYiA9XG4gIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfaGV4X2Zsb2F0ICgpO1xuICBsZXQgd2lkdGggPSBzY2FuX3NpZ24gd2lkdGggaWIgaW5cbiAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9oZXhfZmxvYXQgKCk7XG4gIG1hdGNoIFNjYW5uaW5nLnBlZWtfY2hhciBpYiB3aXRoXG4gIHwgJzAnIGFzIGMgLT4gKFxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfaGV4X2Zsb2F0ICgpO1xuICAgIGxldCB3aWR0aCA9IGNoZWNrX2Nhc2VfaW5zZW5zaXRpdmVfc3RyaW5nIHdpZHRoIGliIGJhZF9oZXhfZmxvYXQgXCJ4XCIgaW5cbiAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gd2lkdGggZWxzZVxuICAgICAgbGV0IHdpZHRoID0gbWF0Y2ggU2Nhbm5pbmcucGVla19jaGFyIGliIHdpdGhcbiAgICAgICAgfCAnLicgfCAncCcgfCAnUCcgLT4gd2lkdGhcbiAgICAgICAgfCBfIC0+IHNjYW5faGV4YWRlY2ltYWxfaW50IHdpZHRoIGliIGluXG4gICAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gd2lkdGggZWxzZVxuICAgICAgICBsZXQgd2lkdGggPSBtYXRjaCBTY2FubmluZy5wZWVrX2NoYXIgaWIgd2l0aFxuICAgICAgICAgIHwgJy4nIGFzIGMgLT4gKFxuICAgICAgICAgICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgICAgICAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gd2lkdGggZWxzZVxuICAgICAgICAgICAgICBtYXRjaCBTY2FubmluZy5wZWVrX2NoYXIgaWIgd2l0aFxuICAgICAgICAgICAgICB8ICdwJyB8ICdQJyAtPiB3aWR0aFxuICAgICAgICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgICAgICBsZXQgcHJlY2lzaW9uID0gSW50Lm1pbiB3aWR0aCBwcmVjaXNpb24gaW5cbiAgICAgICAgICAgICAgICB3aWR0aCAtIChwcmVjaXNpb24gLSBzY2FuX2hleGFkZWNpbWFsX2ludCBwcmVjaXNpb24gaWIpXG4gICAgICAgICAgKVxuICAgICAgICAgIHwgXyAtPiB3aWR0aCBpblxuICAgICAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gd2lkdGggZWxzZVxuICAgICAgICAgIG1hdGNoIFNjYW5uaW5nLnBlZWtfY2hhciBpYiB3aXRoXG4gICAgICAgICAgfCAncCcgfCAnUCcgYXMgYyAtPlxuICAgICAgICAgICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgICAgICAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2hleF9mbG9hdCAoKTtcbiAgICAgICAgICAgIHNjYW5fb3B0aW9uYWxseV9zaWduZWRfZGVjaW1hbF9pbnQgd2lkdGggaWJcbiAgICAgICAgICB8IF8gLT4gd2lkdGhcbiAgKVxuICB8ICduJyB8ICdOJyBhcyBjIC0+XG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9oZXhfZmxvYXQgKCk7XG4gICAgY2hlY2tfY2FzZV9pbnNlbnNpdGl2ZV9zdHJpbmcgd2lkdGggaWIgYmFkX2hleF9mbG9hdCBcImFuXCJcbiAgfCAnaScgfCAnSScgYXMgYyAtPlxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfaGV4X2Zsb2F0ICgpO1xuICAgIGNoZWNrX2Nhc2VfaW5zZW5zaXRpdmVfc3RyaW5nIHdpZHRoIGliIGJhZF9oZXhfZmxvYXQgXCJuZmluaXR5XCJcbiAgfCBfIC0+IGJhZF9oZXhfZmxvYXQgKClcblxuXG5sZXQgc2Nhbl9jYW1sX2Zsb2F0X3Jlc3Qgd2lkdGggcHJlY2lzaW9uIGliID1cbiAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9mbG9hdCAoKTtcbiAgbGV0IHdpZHRoID0gc2Nhbl9kZWNpbWFsX2RpZ2l0X3N0YXIgd2lkdGggaWIgaW5cbiAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9mbG9hdCAoKTtcbiAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgbWF0Y2ggYyB3aXRoXG4gIHwgJy4nIC0+XG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgKCogVGhlIGVmZmVjdGl2ZSB3aWR0aCBhdmFpbGFibGUgZm9yIHNjYW5uaW5nIHRoZSBmcmFjdGlvbmFsIHBhcnQgaXNcbiAgICAgICB0aGUgbWluaW11bSBvZiBkZWNsYXJlZCBwcmVjaXNpb24gYW5kIHdpZHRoIGxlZnQuICopXG4gICAgbGV0IHByZWNpc2lvbiA9IEludC5taW4gd2lkdGggcHJlY2lzaW9uIGluXG4gICAgKCogQWZ0ZXIgc2Nhbm5pbmcgdGhlIGZyYWN0aW9uYWwgcGFydCB3aXRoIFtwcmVjaXNpb25dIHByb3Zpc2lvbmFsIHdpZHRoLFxuICAgICAgIFt3aWR0aF9wcmVjaXNpb25dIGlzIGxlZnQuICopXG4gICAgbGV0IHdpZHRoX3ByZWNpc2lvbiA9IHNjYW5fZnJhY3Rpb25hbF9wYXJ0IHByZWNpc2lvbiBpYiBpblxuICAgICgqIEhlbmNlLCBzY2FubmluZyB0aGUgZnJhY3Rpb25hbCBwYXJ0IHRvb2sgZXhhY3RseVxuICAgICAgIFtwcmVjaXNpb24gLSB3aWR0aF9wcmVjaXNpb25dIGNoYXJzLiAqKVxuICAgIGxldCBmcmFjX3dpZHRoID0gcHJlY2lzaW9uIC0gd2lkdGhfcHJlY2lzaW9uIGluXG4gICAgKCogQW5kIG5ldyBwcm92aXNpb25hbCB3aWR0aCBpcyBbd2lkdGggLSB3aWR0aF9wcmVjaXNpb24uICopXG4gICAgbGV0IHdpZHRoID0gd2lkdGggLSBmcmFjX3dpZHRoIGluXG4gICAgc2Nhbl9leHBvbmVudF9wYXJ0IHdpZHRoIGliXG4gIHwgJ2UnIHwgJ0UnIC0+XG4gICAgc2Nhbl9leHBvbmVudF9wYXJ0IHdpZHRoIGliXG4gIHwgXyAtPiBiYWRfZmxvYXQgKClcblxuXG5sZXQgc2Nhbl9jYW1sX2Zsb2F0IHdpZHRoIHByZWNpc2lvbiBpYiA9XG4gIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfZmxvYXQgKCk7XG4gIGxldCB3aWR0aCA9IHNjYW5fc2lnbiB3aWR0aCBpYiBpblxuICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2Zsb2F0ICgpO1xuICBtYXRjaCBTY2FubmluZy5wZWVrX2NoYXIgaWIgd2l0aFxuICB8ICcwJyBhcyBjIC0+IChcbiAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2Zsb2F0ICgpO1xuICAgIG1hdGNoIFNjYW5uaW5nLnBlZWtfY2hhciBpYiB3aXRoXG4gICAgfCAneCcgfCAnWCcgYXMgYyAtPiAoXG4gICAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfZmxvYXQgKCk7XG4gICAgICBsZXQgd2lkdGggPSBzY2FuX2hleGFkZWNpbWFsX2ludCB3aWR0aCBpYiBpblxuICAgICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9mbG9hdCAoKTtcbiAgICAgIGxldCB3aWR0aCA9IG1hdGNoIFNjYW5uaW5nLnBlZWtfY2hhciBpYiB3aXRoXG4gICAgICAgIHwgJy4nIGFzIGMgLT4gKFxuICAgICAgICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgICAgICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiB3aWR0aCBlbHNlXG4gICAgICAgICAgICBtYXRjaCBTY2FubmluZy5wZWVrX2NoYXIgaWIgd2l0aFxuICAgICAgICAgICAgfCAncCcgfCAnUCcgLT4gd2lkdGhcbiAgICAgICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgICBsZXQgcHJlY2lzaW9uID0gSW50Lm1pbiB3aWR0aCBwcmVjaXNpb24gaW5cbiAgICAgICAgICAgICAgd2lkdGggLSAocHJlY2lzaW9uIC0gc2Nhbl9oZXhhZGVjaW1hbF9pbnQgcHJlY2lzaW9uIGliKVxuICAgICAgICApXG4gICAgICAgIHwgJ3AnIHwgJ1AnIC0+IHdpZHRoXG4gICAgICAgIHwgXyAtPiBiYWRfZmxvYXQgKCkgaW5cbiAgICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiB3aWR0aCBlbHNlXG4gICAgICAgIG1hdGNoIFNjYW5uaW5nLnBlZWtfY2hhciBpYiB3aXRoXG4gICAgICAgIHwgJ3AnIHwgJ1AnIGFzIGMgLT5cbiAgICAgICAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICAgICAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2hleF9mbG9hdCAoKTtcbiAgICAgICAgICBzY2FuX29wdGlvbmFsbHlfc2lnbmVkX2RlY2ltYWxfaW50IHdpZHRoIGliXG4gICAgICAgIHwgXyAtPiB3aWR0aFxuICAgIClcbiAgICB8IF8gLT5cbiAgICAgIHNjYW5fY2FtbF9mbG9hdF9yZXN0IHdpZHRoIHByZWNpc2lvbiBpYlxuICApXG4gIHwgJzEnIC4uICc5JyBhcyBjIC0+XG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9mbG9hdCAoKTtcbiAgICBzY2FuX2NhbWxfZmxvYXRfcmVzdCB3aWR0aCBwcmVjaXNpb24gaWJcbigqIFNwZWNpYWwgY2FzZSBvZiBuYW4gYW5kIGluZmluaXR5OlxuICB8ICdpJyAtPlxuICB8ICduJyAtPlxuKilcbiAgfCBfIC0+IGJhZF9mbG9hdCAoKVxuXG5cbigqIFNjYW4gYSByZWd1bGFyIHN0cmluZzpcbiAgIHN0b3BzIHdoZW4gZW5jb3VudGVyaW5nIGEgc3BhY2UsIGlmIG5vIHNjYW5uaW5nIGluZGljYXRpb24gaGFzIGJlZW4gZ2l2ZW47XG4gICBvdGhlcndpc2UsIHN0b3BzIHdoZW4gZW5jb3VudGVyaW5nIHRoZSBjaGFyYWN0ZXJzIGluIHRoZSBzY2FubmluZ1xuICAgaW5kaWNhdGlvbiBbc3RwXS5cbiAgIEl0IGFsc28gc3RvcHMgYXQgZW5kIG9mIGZpbGUgb3Igd2hlbiB0aGUgbWF4aW11bSBudW1iZXIgb2YgY2hhcmFjdGVycyBoYXNcbiAgIGJlZW4gcmVhZC4gKilcbmxldCBzY2FuX3N0cmluZyBzdHAgd2lkdGggaWIgPVxuICBsZXQgcmVjIGxvb3Agd2lkdGggPVxuICAgIGlmIHdpZHRoID0gMCB0aGVuIHdpZHRoIGVsc2VcbiAgICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICAgIGlmIFNjYW5uaW5nLmVvZiBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgICAgIG1hdGNoIHN0cCB3aXRoXG4gICAgICB8IFNvbWUgYycgd2hlbiBjID0gYycgLT4gU2Nhbm5pbmcuc2tpcF9jaGFyIHdpZHRoIGliXG4gICAgICB8IFNvbWUgXyAtPiBsb29wIChTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMpXG4gICAgICB8IE5vbmUgLT5cbiAgICAgICAgbWF0Y2ggYyB3aXRoXG4gICAgICAgIHwgJyAnIHwgJ1xcdCcgfCAnXFxuJyB8ICdcXHInIC0+IHdpZHRoXG4gICAgICAgIHwgXyAtPiBsb29wIChTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMpIGluXG4gIGxvb3Agd2lkdGhcblxuXG4oKiBTY2FuIGEgY2hhcjogcGVlayBzdHJpY3RseSBvbmUgY2hhcmFjdGVyIGluIHRoZSBpbnB1dCwgd2hhdHNvZXZlci4gKilcbmxldCBzY2FuX2NoYXIgd2lkdGggaWIgPVxuICAoKiBUaGUgY2FzZSB3aWR0aCA9IDAgY291bGQgbm90IGhhcHBlbiBoZXJlLCBzaW5jZSBpdCBpcyB0ZXN0ZWQgYmVmb3JlXG4gICAgIGNhbGxpbmcgc2Nhbl9jaGFyLCBpbiB0aGUgbWFpbiBzY2FubmluZyBmdW5jdGlvbi5cbiAgICBpZiB3aWR0aCA9IDAgdGhlbiBiYWRfdG9rZW5fbGVuZ3RoIFwiYSBjaGFyYWN0ZXJcIiBlbHNlICopXG4gIFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgKFNjYW5uaW5nLmNoZWNrZWRfcGVla19jaGFyIGliKVxuXG5cbmxldCBjaGFyX2Zvcl9iYWNrc2xhc2ggPSBmdW5jdGlvblxuICB8ICduJyAtPiAnXFwwMTAnXG4gIHwgJ3InIC0+ICdcXDAxMydcbiAgfCAnYicgLT4gJ1xcMDA4J1xuICB8ICd0JyAtPiAnXFwwMDknXG4gIHwgYyAtPiBjXG5cblxuKCogVGhlIGludGVnZXIgdmFsdWUgY29ycmVzcG9uZGluZyB0byB0aGUgZmFjaWFsIHZhbHVlIG9mIGEgdmFsaWRcbiAgIGRlY2ltYWwgZGlnaXQgY2hhcmFjdGVyLiAqKVxubGV0IGRlY2ltYWxfdmFsdWVfb2ZfY2hhciBjID0gaW50X29mX2NoYXIgYyAtIGludF9vZl9jaGFyICcwJ1xuXG5sZXQgY2hhcl9mb3JfZGVjaW1hbF9jb2RlIGMwIGMxIGMyID1cbiAgbGV0IGMgPVxuICAgIDEwMCAqIGRlY2ltYWxfdmFsdWVfb2ZfY2hhciBjMCArXG4gICAgIDEwICogZGVjaW1hbF92YWx1ZV9vZl9jaGFyIGMxICtcbiAgICAgICAgICBkZWNpbWFsX3ZhbHVlX29mX2NoYXIgYzIgaW5cbiAgaWYgYyA8IDAgfHwgYyA+IDI1NSB0aGVuXG4gICAgYmFkX2lucHV0XG4gICAgICAoUHJpbnRmLnNwcmludGZcbiAgICAgICAgIFwiYmFkIGNoYXJhY3RlciBkZWNpbWFsIGVuY29kaW5nIFxcXFwlYyVjJWNcIiBjMCBjMSBjMikgZWxzZVxuICBjaGFyX29mX2ludCBjXG5cblxuKCogVGhlIGludGVnZXIgdmFsdWUgY29ycmVzcG9uZGluZyB0byB0aGUgZmFjaWFsIHZhbHVlIG9mIGEgdmFsaWRcbiAgIGhleGFkZWNpbWFsIGRpZ2l0IGNoYXJhY3Rlci4gKilcbmxldCBoZXhhZGVjaW1hbF92YWx1ZV9vZl9jaGFyIGMgPVxuICBsZXQgZCA9IGludF9vZl9jaGFyIGMgaW5cbiAgKCogQ291bGQgYWxzbyBiZTpcbiAgICBpZiBkIDw9IGludF9vZl9jaGFyICc5JyB0aGVuIGQgLSBpbnRfb2ZfY2hhciAnMCcgZWxzZVxuICAgIGlmIGQgPD0gaW50X29mX2NoYXIgJ0YnIHRoZW4gMTAgKyBkIC0gaW50X29mX2NoYXIgJ0EnIGVsc2VcbiAgICBpZiBkIDw9IGludF9vZl9jaGFyICdmJyB0aGVuIDEwICsgZCAtIGludF9vZl9jaGFyICdhJyBlbHNlIGFzc2VydCBmYWxzZVxuICAqKVxuICBpZiBkID49IGludF9vZl9jaGFyICdhJyB0aGVuXG4gICAgZCAtIDg3ICgqIDEwICsgaW50X29mX2NoYXIgYyAtIGludF9vZl9jaGFyICdhJyAqKSBlbHNlXG4gIGlmIGQgPj0gaW50X29mX2NoYXIgJ0EnIHRoZW5cbiAgICBkIC0gNTUgICgqIDEwICsgaW50X29mX2NoYXIgYyAtIGludF9vZl9jaGFyICdBJyAqKSBlbHNlXG4gICAgZCAtIGludF9vZl9jaGFyICcwJ1xuXG5cbmxldCBjaGFyX2Zvcl9oZXhhZGVjaW1hbF9jb2RlIGMxIGMyID1cbiAgbGV0IGMgPVxuICAgIDE2ICogaGV4YWRlY2ltYWxfdmFsdWVfb2ZfY2hhciBjMSArXG4gICAgICAgICBoZXhhZGVjaW1hbF92YWx1ZV9vZl9jaGFyIGMyIGluXG4gIGlmIGMgPCAwIHx8IGMgPiAyNTUgdGhlblxuICAgIGJhZF9pbnB1dFxuICAgICAgKFByaW50Zi5zcHJpbnRmIFwiYmFkIGNoYXJhY3RlciBoZXhhZGVjaW1hbCBlbmNvZGluZyBcXFxcJWMlY1wiIGMxIGMyKSBlbHNlXG4gIGNoYXJfb2ZfaW50IGNcblxuXG4oKiBDYWxsZWQgaW4gcGFydGljdWxhciB3aGVuIGVuY291bnRlcmluZyAnXFxcXCcgYXMgc3RhcnRlciBvZiBhIGNoYXIuXG4gICBTdG9wcyBiZWZvcmUgdGhlIGNvcnJlc3BvbmRpbmcgJ1xcJycuICopXG5sZXQgY2hlY2tfbmV4dF9jaGFyIG1lc3NhZ2Ugd2lkdGggaWIgPVxuICBpZiB3aWR0aCA9IDAgdGhlbiBiYWRfdG9rZW5fbGVuZ3RoIG1lc3NhZ2UgZWxzZVxuICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICBpZiBTY2FubmluZy5lb2YgaWIgdGhlbiBiYWRfZW5kX29mX2lucHV0IG1lc3NhZ2UgZWxzZVxuICBjXG5cblxubGV0IGNoZWNrX25leHRfY2hhcl9mb3JfY2hhciA9IGNoZWNrX25leHRfY2hhciBcImEgQ2hhclwiXG5sZXQgY2hlY2tfbmV4dF9jaGFyX2Zvcl9zdHJpbmcgPSBjaGVja19uZXh0X2NoYXIgXCJhIFN0cmluZ1wiXG5cbmxldCBzY2FuX2JhY2tzbGFzaF9jaGFyIHdpZHRoIGliID1cbiAgbWF0Y2ggY2hlY2tfbmV4dF9jaGFyX2Zvcl9jaGFyIHdpZHRoIGliIHdpdGhcbiAgfCAnXFxcXCcgfCAnXFwnJyB8ICdcXFwiJyB8ICduJyB8ICd0JyB8ICdiJyB8ICdyJyBhcyBjIC0+XG4gICAgU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiAoY2hhcl9mb3JfYmFja3NsYXNoIGMpXG4gIHwgJzAnIC4uICc5JyBhcyBjIC0+XG4gICAgbGV0IGdldF9kaWdpdCAoKSA9XG4gICAgICBsZXQgYyA9IFNjYW5uaW5nLm5leHRfY2hhciBpYiBpblxuICAgICAgbWF0Y2ggYyB3aXRoXG4gICAgICB8ICcwJyAuLiAnOScgYXMgYyAtPiBjXG4gICAgICB8IGMgLT4gYmFkX2lucHV0X2VzY2FwZSBjIGluXG4gICAgbGV0IGMwID0gYyBpblxuICAgIGxldCBjMSA9IGdldF9kaWdpdCAoKSBpblxuICAgIGxldCBjMiA9IGdldF9kaWdpdCAoKSBpblxuICAgIFNjYW5uaW5nLnN0b3JlX2NoYXIgKHdpZHRoIC0gMikgaWIgKGNoYXJfZm9yX2RlY2ltYWxfY29kZSBjMCBjMSBjMilcbiAgfCAneCcgLT5cbiAgICBsZXQgZ2V0X2RpZ2l0ICgpID1cbiAgICAgIGxldCBjID0gU2Nhbm5pbmcubmV4dF9jaGFyIGliIGluXG4gICAgICBtYXRjaCBjIHdpdGhcbiAgICAgIHwgJzAnIC4uICc5JyB8ICdBJyAuLiAnRicgfCAnYScgLi4gJ2YnIGFzIGMgLT4gY1xuICAgICAgfCBjIC0+IGJhZF9pbnB1dF9lc2NhcGUgYyBpblxuICAgIGxldCBjMSA9IGdldF9kaWdpdCAoKSBpblxuICAgIGxldCBjMiA9IGdldF9kaWdpdCAoKSBpblxuICAgIFNjYW5uaW5nLnN0b3JlX2NoYXIgKHdpZHRoIC0gMikgaWIgKGNoYXJfZm9yX2hleGFkZWNpbWFsX2NvZGUgYzEgYzIpXG4gIHwgYyAtPlxuICAgIGJhZF9pbnB1dF9lc2NhcGUgY1xuXG5cbigqIFNjYW4gYSBjaGFyYWN0ZXIgKGFuIE9DYW1sIHRva2VuKS4gKilcbmxldCBzY2FuX2NhbWxfY2hhciB3aWR0aCBpYiA9XG5cbiAgbGV0IHJlYyBmaW5kX3N0YXJ0IHdpZHRoID1cbiAgICBtYXRjaCBTY2FubmluZy5jaGVja2VkX3BlZWtfY2hhciBpYiB3aXRoXG4gICAgfCAnXFwnJyAtPiBmaW5kX2NoYXIgKFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliKVxuICAgIHwgYyAtPiBjaGFyYWN0ZXJfbWlzbWF0Y2ggJ1xcJycgY1xuXG4gIGFuZCBmaW5kX2NoYXIgd2lkdGggPVxuICAgIG1hdGNoIGNoZWNrX25leHRfY2hhcl9mb3JfY2hhciB3aWR0aCBpYiB3aXRoXG4gICAgfCAnXFxcXCcgLT5cbiAgICAgIGZpbmRfc3RvcCAoc2Nhbl9iYWNrc2xhc2hfY2hhciAoU2Nhbm5pbmcuaWdub3JlX2NoYXIgd2lkdGggaWIpIGliKVxuICAgIHwgYyAtPlxuICAgICAgZmluZF9zdG9wIChTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMpXG5cbiAgYW5kIGZpbmRfc3RvcCB3aWR0aCA9XG4gICAgbWF0Y2ggY2hlY2tfbmV4dF9jaGFyX2Zvcl9jaGFyIHdpZHRoIGliIHdpdGhcbiAgICB8ICdcXCcnIC0+IFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliXG4gICAgfCBjIC0+IGNoYXJhY3Rlcl9taXNtYXRjaCAnXFwnJyBjIGluXG5cbiAgZmluZF9zdGFydCB3aWR0aFxuXG5cbigqIFNjYW4gYSBkZWxpbWl0ZWQgc3RyaW5nIChhbiBPQ2FtbCB0b2tlbikuICopXG5sZXQgc2Nhbl9jYW1sX3N0cmluZyB3aWR0aCBpYiA9XG5cbiAgbGV0IHJlYyBmaW5kX3N0YXJ0IHdpZHRoID1cbiAgICBtYXRjaCBTY2FubmluZy5jaGVja2VkX3BlZWtfY2hhciBpYiB3aXRoXG4gICAgfCAnXFxcIicgLT4gZmluZF9zdG9wIChTY2FubmluZy5pZ25vcmVfY2hhciB3aWR0aCBpYilcbiAgICB8IGMgLT4gY2hhcmFjdGVyX21pc21hdGNoICdcXFwiJyBjXG5cbiAgYW5kIGZpbmRfc3RvcCB3aWR0aCA9XG4gICAgbWF0Y2ggY2hlY2tfbmV4dF9jaGFyX2Zvcl9zdHJpbmcgd2lkdGggaWIgd2l0aFxuICAgIHwgJ1xcXCInIC0+IFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliXG4gICAgfCAnXFxcXCcgLT4gc2Nhbl9iYWNrc2xhc2ggKFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliKVxuICAgIHwgYyAtPiBmaW5kX3N0b3AgKFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYylcblxuICBhbmQgc2Nhbl9iYWNrc2xhc2ggd2lkdGggPVxuICAgIG1hdGNoIGNoZWNrX25leHRfY2hhcl9mb3Jfc3RyaW5nIHdpZHRoIGliIHdpdGhcbiAgICB8ICdcXHInIC0+IHNraXBfbmV3bGluZSAoU2Nhbm5pbmcuaWdub3JlX2NoYXIgd2lkdGggaWIpXG4gICAgfCAnXFxuJyAtPiBza2lwX3NwYWNlcyAoU2Nhbm5pbmcuaWdub3JlX2NoYXIgd2lkdGggaWIpXG4gICAgfCBfIC0+IGZpbmRfc3RvcCAoc2Nhbl9iYWNrc2xhc2hfY2hhciB3aWR0aCBpYilcblxuICBhbmQgc2tpcF9uZXdsaW5lIHdpZHRoID1cbiAgICBtYXRjaCBjaGVja19uZXh0X2NoYXJfZm9yX3N0cmluZyB3aWR0aCBpYiB3aXRoXG4gICAgfCAnXFxuJyAtPiBza2lwX3NwYWNlcyAoU2Nhbm5pbmcuaWdub3JlX2NoYXIgd2lkdGggaWIpXG4gICAgfCBfIC0+IGZpbmRfc3RvcCAoU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiAnXFxyJylcblxuICBhbmQgc2tpcF9zcGFjZXMgd2lkdGggPVxuICAgIG1hdGNoIGNoZWNrX25leHRfY2hhcl9mb3Jfc3RyaW5nIHdpZHRoIGliIHdpdGhcbiAgICB8ICcgJyAtPiBza2lwX3NwYWNlcyAoU2Nhbm5pbmcuaWdub3JlX2NoYXIgd2lkdGggaWIpXG4gICAgfCBfIC0+IGZpbmRfc3RvcCB3aWR0aCBpblxuXG4gIGZpbmRfc3RhcnQgd2lkdGhcblxuXG4oKiBTY2FuIGEgYm9vbGVhbiAoYW4gT0NhbWwgdG9rZW4pLiAqKVxubGV0IHNjYW5fYm9vbCBpYiA9XG4gIGxldCBjID0gU2Nhbm5pbmcuY2hlY2tlZF9wZWVrX2NoYXIgaWIgaW5cbiAgbGV0IG0gPVxuICAgIG1hdGNoIGMgd2l0aFxuICAgIHwgJ3QnIC0+IDRcbiAgICB8ICdmJyAtPiA1XG4gICAgfCBjIC0+XG4gICAgICBiYWRfaW5wdXRcbiAgICAgICAgKFByaW50Zi5zcHJpbnRmIFwidGhlIGNoYXJhY3RlciAlQyBjYW5ub3Qgc3RhcnQgYSBib29sZWFuXCIgYykgaW5cbiAgc2Nhbl9zdHJpbmcgTm9uZSBtIGliXG5cblxuKCogU2NhbiBhIHN0cmluZyBjb250YWluaW5nIGVsZW1lbnRzIGluIGNoYXJfc2V0IGFuZCB0ZXJtaW5hdGVkIGJ5IHNjYW5faW5kaWNcbiAgIGlmIHByb3ZpZGVkLiAqKVxubGV0IHNjYW5fY2hhcnNfaW5fY2hhcl9zZXQgY2hhcl9zZXQgc2Nhbl9pbmRpYyB3aWR0aCBpYiA9XG4gIGxldCByZWMgc2Nhbl9jaGFycyBpIHN0cCA9XG4gICAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgICBpZiBpID4gMCAmJiBub3QgKFNjYW5uaW5nLmVvZiBpYikgJiZcbiAgICAgICBpc19pbl9jaGFyX3NldCBjaGFyX3NldCBjICYmXG4gICAgICAgaW50X29mX2NoYXIgYyA8PiBzdHAgdGhlblxuICAgICAgbGV0IF8gPSBTY2FubmluZy5zdG9yZV9jaGFyIG1heF9pbnQgaWIgYyBpblxuICAgICAgc2Nhbl9jaGFycyAoaSAtIDEpIHN0cCBpblxuICBtYXRjaCBzY2FuX2luZGljIHdpdGhcbiAgfCBOb25lIC0+IHNjYW5fY2hhcnMgd2lkdGggKC0xKTtcbiAgfCBTb21lIGMgLT5cbiAgICBzY2FuX2NoYXJzIHdpZHRoIChpbnRfb2ZfY2hhciBjKTtcbiAgICBpZiBub3QgKFNjYW5uaW5nLmVvZiBpYikgdGhlblxuICAgICAgbGV0IGNpID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gICAgICBpZiBjID0gY2lcbiAgICAgIHRoZW4gU2Nhbm5pbmcuaW52YWxpZGF0ZV9jdXJyZW50X2NoYXIgaWJcbiAgICAgIGVsc2UgY2hhcmFjdGVyX21pc21hdGNoIGMgY2lcblxuXG4oKiBUaGUgZ2xvYmFsIGVycm9yIHJlcG9ydCBmdW5jdGlvbiBmb3IgW1NjYW5mXS4gKilcbmxldCBzY2FuZl9iYWRfaW5wdXQgaWIgPSBmdW5jdGlvblxuICB8IFNjYW5fZmFpbHVyZSBzIHwgRmFpbHVyZSBzIC0+XG4gICAgbGV0IGkgPSBTY2FubmluZy5jaGFyX2NvdW50IGliIGluXG4gICAgYmFkX2lucHV0IChQcmludGYuc3ByaW50ZiBcInNjYW5mOiBiYWQgaW5wdXQgYXQgY2hhciBudW1iZXIgJWk6ICVzXCIgaSBzKVxuICB8IHggLT4gcmFpc2UgeFxuXG5cbigqIEdldCB0aGUgY29udGVudCBvZiBhIGNvdW50ZXIgZnJvbSBhbiBpbnB1dCBidWZmZXIuICopXG5sZXQgZ2V0X2NvdW50ZXIgaWIgY291bnRlciA9XG4gIG1hdGNoIGNvdW50ZXIgd2l0aFxuICB8IExpbmVfY291bnRlciAtPiBTY2FubmluZy5saW5lX2NvdW50IGliXG4gIHwgQ2hhcl9jb3VudGVyIC0+IFNjYW5uaW5nLmNoYXJfY291bnQgaWJcbiAgfCBUb2tlbl9jb3VudGVyIC0+IFNjYW5uaW5nLnRva2VuX2NvdW50IGliXG5cblxuKCogQ29tcHV0ZSB0aGUgd2lkdGggb2YgYSBwYWRkaW5nIG9wdGlvbiAoc2VlIFwiJTQye1wiIGFuZCBcIiUxMjMoXCIpLiAqKVxubGV0IHdpZHRoX29mX3BhZF9vcHQgcGFkX29wdCA9IG1hdGNoIHBhZF9vcHQgd2l0aFxuICB8IE5vbmUgLT4gbWF4X2ludFxuICB8IFNvbWUgd2lkdGggLT4gd2lkdGhcblxuXG5sZXQgc3RvcHBlcl9vZl9mb3JtYXR0aW5nX2xpdCBmbXRpbmcgPVxuICBpZiBmbXRpbmcgPSBFc2NhcGVkX3BlcmNlbnQgdGhlbiAnJScsIFwiXCIgZWxzZVxuICAgIGxldCBzdHIgPSBzdHJpbmdfb2ZfZm9ybWF0dGluZ19saXQgZm10aW5nIGluXG4gICAgbGV0IHN0cCA9IHN0ci5bMV0gaW5cbiAgICBsZXQgc3ViX3N0ciA9IFN0cmluZy5zdWIgc3RyIDIgKFN0cmluZy5sZW5ndGggc3RyIC0gMikgaW5cbiAgICBzdHAsIHN1Yl9zdHJcblxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogUmVhZGVyIG1hbmFnZW1lbnQgKilcblxuKCogQSBjYWxsIHRvIHRha2VfZm9ybWF0X3JlYWRlcnMgb24gYSBmb3JtYXQgaXMgZXZhbHVhdGVkIGludG8gZnVuY3Rpb25zXG4gICB0YWtpbmcgcmVhZGVycyBhcyBhcmd1bWVudHMgYW5kIGFnZ3JlZ2F0ZSB0aGVtIGludG8gYW4gaGV0ZXJvZ2VuZW91cyBsaXN0ICopXG4oKiBXaGVuIGFsbCByZWFkZXJzIGFyZSB0YWtlbiwgZmluYWxseSBwYXNzIHRoZSBsaXN0IG9mIHRoZSByZWFkZXJzIHRvIHRoZVxuICAgY29udGludWF0aW9uIGsuICopXG5sZXQgcmVjIHRha2VfZm9ybWF0X3JlYWRlcnMgOiB0eXBlIGEgYyBkIGUgZiAuXG4gICAgKChkLCBlKSBoZXRlcl9saXN0IC0+IGUpIC0+IChhLCBTY2FubmluZy5pbl9jaGFubmVsLCBjLCBkLCBlLCBmKSBmbXQgLT5cbiAgICBkID1cbmZ1biBrIGZtdCAtPiBtYXRjaCBmbXQgd2l0aFxuICB8IFJlYWRlciBmbXRfcmVzdCAtPlxuICAgIGZ1biByZWFkZXIgLT5cbiAgICAgIGxldCBuZXdfayByZWFkZXJzX3Jlc3QgPSBrIChDb25zIChyZWFkZXIsIHJlYWRlcnNfcmVzdCkpIGluXG4gICAgICB0YWtlX2Zvcm1hdF9yZWFkZXJzIG5ld19rIGZtdF9yZXN0XG4gIHwgQ2hhciByZXN0ICAgICAgICAgICAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBDYW1sX2NoYXIgcmVzdCAgICAgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IFN0cmluZyAoXywgcmVzdCkgICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgQ2FtbF9zdHJpbmcgKF8sIHJlc3QpICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBJbnQgKF8sIF8sIF8sIHJlc3QpICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IEludDMyIChfLCBfLCBfLCByZXN0KSAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgTmF0aXZlaW50IChfLCBfLCBfLCByZXN0KSAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBJbnQ2NCAoXywgXywgXywgcmVzdCkgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IEZsb2F0IChfLCBfLCBfLCByZXN0KSAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgQm9vbCAoXywgcmVzdCkgICAgICAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBBbHBoYSByZXN0ICAgICAgICAgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IFRoZXRhIHJlc3QgICAgICAgICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgRmx1c2ggcmVzdCAgICAgICAgICAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBTdHJpbmdfbGl0ZXJhbCAoXywgcmVzdCkgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IENoYXJfbGl0ZXJhbCAoXywgcmVzdCkgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgQ3VzdG9tIChfLCBfLCByZXN0KSAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcblxuICB8IFNjYW5fY2hhcl9zZXQgKF8sIF8sIHJlc3QpICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgU2Nhbl9nZXRfY291bnRlciAoXywgcmVzdCkgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBTY2FuX25leHRfY2hhciByZXN0ICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuXG4gIHwgRm9ybWF0dGluZ19saXQgKF8sIHJlc3QpICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBGb3JtYXR0aW5nX2dlbiAoT3Blbl90YWcgKEZvcm1hdCAoZm10LCBfKSksIHJlc3QpIC0+XG4gICAgICB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgKGNvbmNhdF9mbXQgZm10IHJlc3QpXG4gIHwgRm9ybWF0dGluZ19nZW4gKE9wZW5fYm94IChGb3JtYXQgKGZtdCwgXykpLCByZXN0KSAtPlxuICAgICAgdGFrZV9mb3JtYXRfcmVhZGVycyBrIChjb25jYXRfZm10IGZtdCByZXN0KVxuXG4gIHwgRm9ybWF0X2FyZyAoXywgXywgcmVzdCkgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBGb3JtYXRfc3Vic3QgKF8sIGZtdHR5LCByZXN0KSAgICAtPlxuICAgICB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgKGVyYXNlX3JlbCAoc3ltbSBmbXR0eSkpIHJlc3RcbiAgfCBJZ25vcmVkX3BhcmFtIChpZ24sIHJlc3QpICAgICAgICAtPiB0YWtlX2lnbm9yZWRfZm9ybWF0X3JlYWRlcnMgayBpZ24gcmVzdFxuXG4gIHwgRW5kX29mX2Zvcm1hdCAgICAgICAgICAgICAgICAgICAgLT4gayBOaWxcblxuKCogVGFrZSByZWFkZXJzIGFzc29jaWF0ZWQgdG8gYW4gZm10dHkgY29taW5nIGZyb20gYSBGb3JtYXRfc3Vic3QgXCIlKC4uLiUpXCIuICopXG5hbmQgdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyA6IHR5cGUgeCB5IGEgYyBkIGUgZiAuXG4gICAgKChkLCBlKSBoZXRlcl9saXN0IC0+IGUpIC0+IChhLCBTY2FubmluZy5pbl9jaGFubmVsLCBjLCBkLCB4LCB5KSBmbXR0eSAtPlxuICAgICAgKHksIFNjYW5uaW5nLmluX2NoYW5uZWwsIGMsIHgsIGUsIGYpIGZtdCAtPiBkID1cbmZ1biBrIGZtdHR5IGZtdCAtPiBtYXRjaCBmbXR0eSB3aXRoXG4gIHwgUmVhZGVyX3R5IGZtdF9yZXN0IC0+XG4gICAgZnVuIHJlYWRlciAtPlxuICAgICAgbGV0IG5ld19rIHJlYWRlcnNfcmVzdCA9IGsgKENvbnMgKHJlYWRlciwgcmVhZGVyc19yZXN0KSkgaW5cbiAgICAgIHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgbmV3X2sgZm10X3Jlc3QgZm10XG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgZm10X3Jlc3QgLT5cbiAgICBmdW4gcmVhZGVyIC0+XG4gICAgICBsZXQgbmV3X2sgcmVhZGVyc19yZXN0ID0gayAoQ29ucyAocmVhZGVyLCByZWFkZXJzX3Jlc3QpKSBpblxuICAgICAgdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBuZXdfayBmbXRfcmVzdCBmbXRcbiAgfCBDaGFyX3R5IHJlc3QgICAgICAgICAgICAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgU3RyaW5nX3R5IHJlc3QgICAgICAgICAgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IEludF90eSByZXN0ICAgICAgICAgICAgICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBJbnQzMl90eSByZXN0ICAgICAgICAgICAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgTmF0aXZlaW50X3R5IHJlc3QgICAgICAgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IEludDY0X3R5IHJlc3QgICAgICAgICAgICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBGbG9hdF90eSByZXN0ICAgICAgICAgICAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgQm9vbF90eSByZXN0ICAgICAgICAgICAgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IEFscGhhX3R5IHJlc3QgICAgICAgICAgICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBUaGV0YV90eSByZXN0ICAgICAgICAgICAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgQW55X3R5IHJlc3QgICAgICAgICAgICAgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IEZvcm1hdF9hcmdfdHkgKF8sIHJlc3QpICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBFbmRfb2ZfZm10dHkgICAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIGZtdFxuICB8IEZvcm1hdF9zdWJzdF90eSAodHkxLCB0eTIsIHJlc3QpIC0+XG4gICAgbGV0IHR5ID0gdHJhbnMgKHN5bW0gdHkxKSB0eTIgaW5cbiAgICB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgKGNvbmNhdF9mbXR0eSB0eSByZXN0KSBmbXRcblxuKCogVGFrZSByZWFkZXJzIGFzc29jaWF0ZWQgdG8gYW4gaWdub3JlZCBwYXJhbWV0ZXIuICopXG5hbmQgdGFrZV9pZ25vcmVkX2Zvcm1hdF9yZWFkZXJzIDogdHlwZSB4IHkgYSBjIGQgZSBmIC5cbiAgICAoKGQsIGUpIGhldGVyX2xpc3QgLT4gZSkgLT4gKGEsIFNjYW5uaW5nLmluX2NoYW5uZWwsIGMsIGQsIHgsIHkpIGlnbm9yZWQgLT5cbiAgICAgICh5LCBTY2FubmluZy5pbl9jaGFubmVsLCBjLCB4LCBlLCBmKSBmbXQgLT4gZCA9XG5mdW4gayBpZ24gZm10IC0+IG1hdGNoIGlnbiB3aXRoXG4gIHwgSWdub3JlZF9yZWFkZXIgLT5cbiAgICBmdW4gcmVhZGVyIC0+XG4gICAgICBsZXQgbmV3X2sgcmVhZGVyc19yZXN0ID0gayAoQ29ucyAocmVhZGVyLCByZWFkZXJzX3Jlc3QpKSBpblxuICAgICAgdGFrZV9mb3JtYXRfcmVhZGVycyBuZXdfayBmbXRcbiAgfCBJZ25vcmVkX2NoYXIgICAgICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX2NhbWxfY2hhciAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX3N0cmluZyBfICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX2NhbWxfc3RyaW5nIF8gICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX2ludCAoXywgXykgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX2ludDMyIChfLCBfKSAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX25hdGl2ZWludCAoXywgXykgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX2ludDY0IChfLCBfKSAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX2Zsb2F0IChfLCBfKSAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX2Jvb2wgXyAgICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX2Zvcm1hdF9hcmcgXyAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX2Zvcm1hdF9zdWJzdCAoXywgZm10dHkpIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayBmbXR0eSBmbXRcbiAgfCBJZ25vcmVkX3NjYW5fY2hhcl9zZXQgXyAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX3NjYW5fZ2V0X2NvdW50ZXIgXyAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX3NjYW5fbmV4dF9jaGFyICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKCogR2VuZXJpYyBzY2FubmluZyAqKVxuXG4oKiBNYWtlIGEgZ2VuZXJpYyBzY2FubmluZyBmdW5jdGlvbi4gKilcbigqIFNjYW4gYSBzdHJlYW0gYWNjb3JkaW5nIHRvIGEgZm9ybWF0IGFuZCByZWFkZXJzIG9idGFpbmVkIGJ5XG4gICB0YWtlX2Zvcm1hdF9yZWFkZXJzLCBhbmQgYWdncmVnYXRlIHNjYW5uZWQgdmFsdWVzIGludG8gYW5cbiAgIGhldGVyb2dlbmVvdXMgbGlzdC4gKilcbigqIFJldHVybiB0aGUgaGV0ZXJvZ2VuZW91cyBsaXN0IG9mIHNjYW5uZWQgdmFsdWVzLiAqKVxubGV0IHJlYyBtYWtlX3NjYW5mIDogdHlwZSBhIGMgZCBlIGYuXG4gICAgU2Nhbm5pbmcuaW5fY2hhbm5lbCAtPiAoYSwgU2Nhbm5pbmcuaW5fY2hhbm5lbCwgYywgZCwgZSwgZikgZm10IC0+XG4gICAgICAoZCwgZSkgaGV0ZXJfbGlzdCAtPiAoYSwgZikgaGV0ZXJfbGlzdCA9XG5mdW4gaWIgZm10IHJlYWRlcnMgLT4gbWF0Y2ggZm10IHdpdGhcbiAgfCBDaGFyIHJlc3QgLT5cbiAgICBsZXQgXyA9IHNjYW5fY2hhciAwIGliIGluXG4gICAgbGV0IGMgPSB0b2tlbl9jaGFyIGliIGluXG4gICAgQ29ucyAoYywgbWFrZV9zY2FuZiBpYiByZXN0IHJlYWRlcnMpXG4gIHwgQ2FtbF9jaGFyIHJlc3QgLT5cbiAgICBsZXQgXyA9IHNjYW5fY2FtbF9jaGFyIDAgaWIgaW5cbiAgICBsZXQgYyA9IHRva2VuX2NoYXIgaWIgaW5cbiAgICBDb25zIChjLCBtYWtlX3NjYW5mIGliIHJlc3QgcmVhZGVycylcblxuICB8IFN0cmluZyAocGFkLCBGb3JtYXR0aW5nX2xpdCAoZm10aW5nX2xpdCwgcmVzdCkpIC0+XG4gICAgbGV0IHN0cCwgc3RyID0gc3RvcHBlcl9vZl9mb3JtYXR0aW5nX2xpdCBmbXRpbmdfbGl0IGluXG4gICAgbGV0IHNjYW4gd2lkdGggXyBpYiA9IHNjYW5fc3RyaW5nIChTb21lIHN0cCkgd2lkdGggaWIgaW5cbiAgICBsZXQgc3RyX3Jlc3QgPSBTdHJpbmdfbGl0ZXJhbCAoc3RyLCByZXN0KSBpblxuICAgIHBhZF9wcmVjX3NjYW5mIGliIHN0cl9yZXN0IHJlYWRlcnMgcGFkIE5vX3ByZWNpc2lvbiBzY2FuIHRva2VuX3N0cmluZ1xuICB8IFN0cmluZyAocGFkLCBGb3JtYXR0aW5nX2dlbiAoT3Blbl90YWcgKEZvcm1hdCAoZm10JywgXykpLCByZXN0KSkgLT5cbiAgICBsZXQgc2NhbiB3aWR0aCBfIGliID0gc2Nhbl9zdHJpbmcgKFNvbWUgJ3snKSB3aWR0aCBpYiBpblxuICAgIHBhZF9wcmVjX3NjYW5mIGliIChjb25jYXRfZm10IGZtdCcgcmVzdCkgcmVhZGVycyBwYWQgTm9fcHJlY2lzaW9uIHNjYW5cbiAgICAgICAgICAgICAgICAgICB0b2tlbl9zdHJpbmdcbiAgfCBTdHJpbmcgKHBhZCwgRm9ybWF0dGluZ19nZW4gKE9wZW5fYm94IChGb3JtYXQgKGZtdCcsIF8pKSwgcmVzdCkpIC0+XG4gICAgbGV0IHNjYW4gd2lkdGggXyBpYiA9IHNjYW5fc3RyaW5nIChTb21lICdbJykgd2lkdGggaWIgaW5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiAoY29uY2F0X2ZtdCBmbXQnIHJlc3QpIHJlYWRlcnMgcGFkIE5vX3ByZWNpc2lvbiBzY2FuXG4gICAgICAgICAgICAgICAgICAgdG9rZW5fc3RyaW5nXG4gIHwgU3RyaW5nIChwYWQsIHJlc3QpIC0+XG4gICAgbGV0IHNjYW4gd2lkdGggXyBpYiA9IHNjYW5fc3RyaW5nIE5vbmUgd2lkdGggaWIgaW5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiByZXN0IHJlYWRlcnMgcGFkIE5vX3ByZWNpc2lvbiBzY2FuIHRva2VuX3N0cmluZ1xuXG4gIHwgQ2FtbF9zdHJpbmcgKHBhZCwgcmVzdCkgLT5cbiAgICBsZXQgc2NhbiB3aWR0aCBfIGliID0gc2Nhbl9jYW1sX3N0cmluZyB3aWR0aCBpYiBpblxuICAgIHBhZF9wcmVjX3NjYW5mIGliIHJlc3QgcmVhZGVycyBwYWQgTm9fcHJlY2lzaW9uIHNjYW4gdG9rZW5fc3RyaW5nXG4gIHwgSW50IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIGxldCBjID0gaW50ZWdlcl9jb252ZXJzaW9uX29mX2NoYXIgKGNoYXJfb2ZfaWNvbnYgaWNvbnYpIGluXG4gICAgbGV0IHNjYW4gd2lkdGggXyBpYiA9IHNjYW5faW50X2NvbnZlcnNpb24gYyB3aWR0aCBpYiBpblxuICAgIHBhZF9wcmVjX3NjYW5mIGliIHJlc3QgcmVhZGVycyBwYWQgcHJlYyBzY2FuICh0b2tlbl9pbnQgYylcbiAgfCBJbnQzMiAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBsZXQgYyA9IGludGVnZXJfY29udmVyc2lvbl9vZl9jaGFyIChjaGFyX29mX2ljb252IGljb252KSBpblxuICAgIGxldCBzY2FuIHdpZHRoIF8gaWIgPSBzY2FuX2ludF9jb252ZXJzaW9uIGMgd2lkdGggaWIgaW5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiByZXN0IHJlYWRlcnMgcGFkIHByZWMgc2NhbiAodG9rZW5faW50MzIgYylcbiAgfCBOYXRpdmVpbnQgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbGV0IGMgPSBpbnRlZ2VyX2NvbnZlcnNpb25fb2ZfY2hhciAoY2hhcl9vZl9pY29udiBpY29udikgaW5cbiAgICBsZXQgc2NhbiB3aWR0aCBfIGliID0gc2Nhbl9pbnRfY29udmVyc2lvbiBjIHdpZHRoIGliIGluXG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgcmVzdCByZWFkZXJzIHBhZCBwcmVjIHNjYW4gKHRva2VuX25hdGl2ZWludCBjKVxuICB8IEludDY0IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIGxldCBjID0gaW50ZWdlcl9jb252ZXJzaW9uX29mX2NoYXIgKGNoYXJfb2ZfaWNvbnYgaWNvbnYpIGluXG4gICAgbGV0IHNjYW4gd2lkdGggXyBpYiA9IHNjYW5faW50X2NvbnZlcnNpb24gYyB3aWR0aCBpYiBpblxuICAgIHBhZF9wcmVjX3NjYW5mIGliIHJlc3QgcmVhZGVycyBwYWQgcHJlYyBzY2FuICh0b2tlbl9pbnQ2NCBjKVxuICB8IEZsb2F0ICgoXywgKEZsb2F0X0YgfCBGbG9hdF9DRikpLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgcmVzdCByZWFkZXJzIHBhZCBwcmVjIHNjYW5fY2FtbF9mbG9hdCB0b2tlbl9mbG9hdFxuICB8IEZsb2F0ICgoXywgKEZsb2F0X2YgfCBGbG9hdF9lIHwgRmxvYXRfRSB8IEZsb2F0X2cgfCBGbG9hdF9HKSksXG4gICAgICAgICAgIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiByZXN0IHJlYWRlcnMgcGFkIHByZWMgc2Nhbl9mbG9hdCB0b2tlbl9mbG9hdFxuICB8IEZsb2F0ICgoXywgKEZsb2F0X2ggfCBGbG9hdF9IKSksIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiByZXN0IHJlYWRlcnMgcGFkIHByZWMgc2Nhbl9oZXhfZmxvYXQgdG9rZW5fZmxvYXRcbiAgfCBCb29sIChwYWQsIHJlc3QpIC0+XG4gICAgbGV0IHNjYW4gXyBfIGliID0gc2Nhbl9ib29sIGliIGluXG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgcmVzdCByZWFkZXJzIHBhZCBOb19wcmVjaXNpb24gc2NhbiB0b2tlbl9ib29sXG4gIHwgQWxwaGEgXyAtPlxuICAgIGludmFsaWRfYXJnIFwic2NhbmY6IGJhZCBjb252ZXJzaW9uIFxcXCIlYVxcXCJcIlxuICB8IFRoZXRhIF8gLT5cbiAgICBpbnZhbGlkX2FyZyBcInNjYW5mOiBiYWQgY29udmVyc2lvbiBcXFwiJXRcXFwiXCJcbiAgfCBDdXN0b20gXyAtPlxuICAgIGludmFsaWRfYXJnIFwic2NhbmY6IGJhZCBjb252ZXJzaW9uIFxcXCIlP1xcXCIgKGN1c3RvbSBjb252ZXJ0ZXIpXCJcbiAgfCBSZWFkZXIgZm10X3Jlc3QgLT5cbiAgICBiZWdpbiBtYXRjaCByZWFkZXJzIHdpdGhcbiAgICB8IENvbnMgKHJlYWRlciwgcmVhZGVyc19yZXN0KSAtPlxuICAgICAgICBsZXQgeCA9IHJlYWRlciBpYiBpblxuICAgICAgICBDb25zICh4LCBtYWtlX3NjYW5mIGliIGZtdF9yZXN0IHJlYWRlcnNfcmVzdClcbiAgICB8IE5pbCAtPlxuICAgICAgICBpbnZhbGlkX2FyZyBcInNjYW5mOiBtaXNzaW5nIHJlYWRlclwiXG4gICAgZW5kXG4gIHwgRmx1c2ggcmVzdCAtPlxuICAgIGlmIFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIG1ha2Vfc2NhbmYgaWIgcmVzdCByZWFkZXJzXG4gICAgZWxzZSBiYWRfaW5wdXQgXCJlbmQgb2YgaW5wdXQgbm90IGZvdW5kXCJcblxuICB8IFN0cmluZ19saXRlcmFsIChzdHIsIHJlc3QpIC0+XG4gICAgU3RyaW5nLml0ZXIgKGNoZWNrX2NoYXIgaWIpIHN0cjtcbiAgICBtYWtlX3NjYW5mIGliIHJlc3QgcmVhZGVyc1xuICB8IENoYXJfbGl0ZXJhbCAoY2hyLCByZXN0KSAtPlxuICAgIGNoZWNrX2NoYXIgaWIgY2hyO1xuICAgIG1ha2Vfc2NhbmYgaWIgcmVzdCByZWFkZXJzXG5cbiAgfCBGb3JtYXRfYXJnIChwYWRfb3B0LCBmbXR0eSwgcmVzdCkgLT5cbiAgICBsZXQgXyA9IHNjYW5fY2FtbF9zdHJpbmcgKHdpZHRoX29mX3BhZF9vcHQgcGFkX29wdCkgaWIgaW5cbiAgICBsZXQgcyA9IHRva2VuX3N0cmluZyBpYiBpblxuICAgIGxldCBmbXQgPVxuICAgICAgdHJ5IGZvcm1hdF9vZl9zdHJpbmdfZm10dHkgcyBmbXR0eVxuICAgICAgd2l0aCBGYWlsdXJlIG1zZyAtPiBiYWRfaW5wdXQgbXNnXG4gICAgaW5cbiAgICBDb25zIChmbXQsIG1ha2Vfc2NhbmYgaWIgcmVzdCByZWFkZXJzKVxuICB8IEZvcm1hdF9zdWJzdCAocGFkX29wdCwgZm10dHksIHJlc3QpIC0+XG4gICAgbGV0IF8gPSBzY2FuX2NhbWxfc3RyaW5nICh3aWR0aF9vZl9wYWRfb3B0IHBhZF9vcHQpIGliIGluXG4gICAgbGV0IHMgPSB0b2tlbl9zdHJpbmcgaWIgaW5cbiAgICBsZXQgZm10LCBmbXQnID1cbiAgICAgIHRyeVxuICAgICAgICBsZXQgRm10X0VCQiBmbXQgPSBmbXRfZWJiX29mX3N0cmluZyBzIGluXG4gICAgICAgIGxldCBGbXRfRUJCIGZtdCcgPSBmbXRfZWJiX29mX3N0cmluZyBzIGluXG4gICAgICAgICgqIFRPRE86IGZpbmQgYSB3YXkgdG8gYXZvaWQgcmVwYXJzaW5nIHR3aWNlICopXG5cbiAgICAgICAgKCogVE9ETzogdGhlc2UgdHlwZS1jaGVja3MgYmVsb3cgKmNhbiogZmFpbCBiZWNhdXNlIG9mIHR5cGVcbiAgICAgICAgICAgYW1iaWd1aXR5IGluIHByZXNlbmNlIG9mIGlnbm9yZWQtcmVhZGVyczogXCIlX3IlZFwiIGFuZCBcIiVkJV9yXCJcbiAgICAgICAgICAgYXJlIHR5cGVkIGluIHRoZSBzYW1lIHdheS5cblxuICAgICAgICAgICAjIFNjYW5mLnNzY2FuZiBcIlxcXCIlX3IlZFxcXCIzXCIgXCIlKCVkJV9yJSlcIiBpZ25vcmVcbiAgICAgICAgICAgICAoZnVuIGZtdCBuIC0+IHN0cmluZ19vZl9mb3JtYXQgZm10LCBuKVxuICAgICAgICAgICBFeGNlcHRpb246IENhbWxpbnRlcm5hbEZvcm1hdC5UeXBlX21pc21hdGNoLlxuXG4gICAgICAgICAgIFdlIHNob3VsZCBwcm9wZXJseSBjYXRjaCB0aGlzIGV4Y2VwdGlvbi5cbiAgICAgICAgKilcbiAgICAgICAgdHlwZV9mb3JtYXQgZm10IChlcmFzZV9yZWwgZm10dHkpLFxuICAgICAgICB0eXBlX2Zvcm1hdCBmbXQnIChlcmFzZV9yZWwgKHN5bW0gZm10dHkpKVxuICAgICAgd2l0aCBGYWlsdXJlIG1zZyAtPiBiYWRfaW5wdXQgbXNnXG4gICAgaW5cbiAgICBDb25zIChGb3JtYXQgKGZtdCwgcyksXG4gICAgICAgICAgbWFrZV9zY2FuZiBpYiAoY29uY2F0X2ZtdCBmbXQnIHJlc3QpIHJlYWRlcnMpXG5cbiAgfCBTY2FuX2NoYXJfc2V0ICh3aWR0aF9vcHQsIGNoYXJfc2V0LCBGb3JtYXR0aW5nX2xpdCAoZm10aW5nX2xpdCwgcmVzdCkpIC0+XG4gICAgbGV0IHN0cCwgc3RyID0gc3RvcHBlcl9vZl9mb3JtYXR0aW5nX2xpdCBmbXRpbmdfbGl0IGluXG4gICAgbGV0IHdpZHRoID0gd2lkdGhfb2ZfcGFkX29wdCB3aWR0aF9vcHQgaW5cbiAgICBzY2FuX2NoYXJzX2luX2NoYXJfc2V0IGNoYXJfc2V0IChTb21lIHN0cCkgd2lkdGggaWI7XG4gICAgbGV0IHMgPSB0b2tlbl9zdHJpbmcgaWIgaW5cbiAgICBsZXQgc3RyX3Jlc3QgPSBTdHJpbmdfbGl0ZXJhbCAoc3RyLCByZXN0KSBpblxuICAgIENvbnMgKHMsIG1ha2Vfc2NhbmYgaWIgc3RyX3Jlc3QgcmVhZGVycylcbiAgfCBTY2FuX2NoYXJfc2V0ICh3aWR0aF9vcHQsIGNoYXJfc2V0LCByZXN0KSAtPlxuICAgIGxldCB3aWR0aCA9IHdpZHRoX29mX3BhZF9vcHQgd2lkdGhfb3B0IGluXG4gICAgc2Nhbl9jaGFyc19pbl9jaGFyX3NldCBjaGFyX3NldCBOb25lIHdpZHRoIGliO1xuICAgIGxldCBzID0gdG9rZW5fc3RyaW5nIGliIGluXG4gICAgQ29ucyAocywgbWFrZV9zY2FuZiBpYiByZXN0IHJlYWRlcnMpXG4gIHwgU2Nhbl9nZXRfY291bnRlciAoY291bnRlciwgcmVzdCkgLT5cbiAgICBsZXQgY291bnQgPSBnZXRfY291bnRlciBpYiBjb3VudGVyIGluXG4gICAgQ29ucyAoY291bnQsIG1ha2Vfc2NhbmYgaWIgcmVzdCByZWFkZXJzKVxuICB8IFNjYW5fbmV4dF9jaGFyIHJlc3QgLT5cbiAgICBsZXQgYyA9IFNjYW5uaW5nLmNoZWNrZWRfcGVla19jaGFyIGliIGluXG4gICAgQ29ucyAoYywgbWFrZV9zY2FuZiBpYiByZXN0IHJlYWRlcnMpXG5cbiAgfCBGb3JtYXR0aW5nX2xpdCAoZm9ybWF0dGluZ19saXQsIHJlc3QpIC0+XG4gICAgU3RyaW5nLml0ZXIgKGNoZWNrX2NoYXIgaWIpIChzdHJpbmdfb2ZfZm9ybWF0dGluZ19saXQgZm9ybWF0dGluZ19saXQpO1xuICAgIG1ha2Vfc2NhbmYgaWIgcmVzdCByZWFkZXJzXG4gIHwgRm9ybWF0dGluZ19nZW4gKE9wZW5fdGFnIChGb3JtYXQgKGZtdCcsIF8pKSwgcmVzdCkgLT5cbiAgICBjaGVja19jaGFyIGliICdAJzsgY2hlY2tfY2hhciBpYiAneyc7XG4gICAgbWFrZV9zY2FuZiBpYiAoY29uY2F0X2ZtdCBmbXQnIHJlc3QpIHJlYWRlcnNcbiAgfCBGb3JtYXR0aW5nX2dlbiAoT3Blbl9ib3ggKEZvcm1hdCAoZm10JywgXykpLCByZXN0KSAtPlxuICAgIGNoZWNrX2NoYXIgaWIgJ0AnOyBjaGVja19jaGFyIGliICdbJztcbiAgICBtYWtlX3NjYW5mIGliIChjb25jYXRfZm10IGZtdCcgcmVzdCkgcmVhZGVyc1xuXG4gIHwgSWdub3JlZF9wYXJhbSAoaWduLCByZXN0KSAtPlxuICAgIGxldCBQYXJhbV9mb3JtYXRfRUJCIGZtdCcgPSBwYXJhbV9mb3JtYXRfb2ZfaWdub3JlZF9mb3JtYXQgaWduIHJlc3QgaW5cbiAgICBiZWdpbiBtYXRjaCBtYWtlX3NjYW5mIGliIGZtdCcgcmVhZGVycyB3aXRoXG4gICAgfCBDb25zIChfLCBhcmdfcmVzdCkgLT4gYXJnX3Jlc3RcbiAgICB8IE5pbCAtPiBhc3NlcnQgZmFsc2VcbiAgICBlbmRcblxuICB8IEVuZF9vZl9mb3JtYXQgLT5cbiAgICBOaWxcblxuKCogQ2FzZSBhbmFseXNpcyBvbiBwYWRkaW5nIGFuZCBwcmVjaXNpb24uICopXG4oKiBSZWplY3QgZm9ybWF0cyBjb250YWluaW5nIFwiJSpcIiBvciBcIiUuKlwiLiAqKVxuKCogUGFzcyBwYWRkaW5nIGFuZCBwcmVjaXNpb24gdG8gdGhlIGdlbmVyaWMgc2Nhbm5lciBgc2NhbicuICopXG5hbmQgcGFkX3ByZWNfc2NhbmYgOiB0eXBlIGEgYyBkIGUgZiB4IHkgeiB0IC5cbiAgICBTY2FubmluZy5pbl9jaGFubmVsIC0+IChhLCBTY2FubmluZy5pbl9jaGFubmVsLCBjLCBkLCBlLCBmKSBmbXQgLT5cbiAgICAgIChkLCBlKSBoZXRlcl9saXN0IC0+ICh4LCB5KSBwYWRkaW5nIC0+ICh5LCB6IC0+IGEpIHByZWNpc2lvbiAtPlxuICAgICAgKGludCAtPiBpbnQgLT4gU2Nhbm5pbmcuaW5fY2hhbm5lbCAtPiB0KSAtPlxuICAgICAgKFNjYW5uaW5nLmluX2NoYW5uZWwgLT4geikgLT5cbiAgICAgICh4LCBmKSBoZXRlcl9saXN0ID1cbmZ1biBpYiBmbXQgcmVhZGVycyBwYWQgcHJlYyBzY2FuIHRva2VuIC0+IG1hdGNoIHBhZCwgcHJlYyB3aXRoXG4gIHwgTm9fcGFkZGluZywgTm9fcHJlY2lzaW9uIC0+XG4gICAgbGV0IF8gPSBzY2FuIG1heF9pbnQgbWF4X2ludCBpYiBpblxuICAgIGxldCB4ID0gdG9rZW4gaWIgaW5cbiAgICBDb25zICh4LCBtYWtlX3NjYW5mIGliIGZtdCByZWFkZXJzKVxuICB8IE5vX3BhZGRpbmcsIExpdF9wcmVjaXNpb24gcCAtPlxuICAgIGxldCBfID0gc2NhbiBtYXhfaW50IHAgaWIgaW5cbiAgICBsZXQgeCA9IHRva2VuIGliIGluXG4gICAgQ29ucyAoeCwgbWFrZV9zY2FuZiBpYiBmbXQgcmVhZGVycylcbiAgfCBMaXRfcGFkZGluZyAoKFJpZ2h0IHwgWmVyb3MpLCB3KSwgTm9fcHJlY2lzaW9uIC0+XG4gICAgbGV0IF8gPSBzY2FuIHcgbWF4X2ludCBpYiBpblxuICAgIGxldCB4ID0gdG9rZW4gaWIgaW5cbiAgICBDb25zICh4LCBtYWtlX3NjYW5mIGliIGZtdCByZWFkZXJzKVxuICB8IExpdF9wYWRkaW5nICgoUmlnaHQgfCBaZXJvcyksIHcpLCBMaXRfcHJlY2lzaW9uIHAgLT5cbiAgICBsZXQgXyA9IHNjYW4gdyBwIGliIGluXG4gICAgbGV0IHggPSB0b2tlbiBpYiBpblxuICAgIENvbnMgKHgsIG1ha2Vfc2NhbmYgaWIgZm10IHJlYWRlcnMpXG4gIHwgTGl0X3BhZGRpbmcgKExlZnQsIF8pLCBfIC0+XG4gICAgaW52YWxpZF9hcmcgXCJzY2FuZjogYmFkIGNvbnZlcnNpb24gXFxcIiUtXFxcIlwiXG4gIHwgTGl0X3BhZGRpbmcgKChSaWdodCB8IFplcm9zKSwgXyksIEFyZ19wcmVjaXNpb24gLT5cbiAgICBpbnZhbGlkX2FyZyBcInNjYW5mOiBiYWQgY29udmVyc2lvbiBcXFwiJSpcXFwiXCJcbiAgfCBBcmdfcGFkZGluZyBfLCBfIC0+XG4gICAgaW52YWxpZF9hcmcgXCJzY2FuZjogYmFkIGNvbnZlcnNpb24gXFxcIiUqXFxcIlwiXG4gIHwgTm9fcGFkZGluZywgQXJnX3ByZWNpc2lvbiAtPlxuICAgIGludmFsaWRfYXJnIFwic2NhbmY6IGJhZCBjb252ZXJzaW9uIFxcXCIlKlxcXCJcIlxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgKCogRGVmaW5pbmcgW3NjYW5mXSBhbmQgdmFyaW91cyBmbGF2b3JzIG9mIFtzY2FuZl0gKilcblxudHlwZSAnYSBrc2NhbmZfcmVzdWx0ID0gQXJncyBvZiAnYSB8IEV4YyBvZiBleG5cblxubGV0IGtzY2FuZiBpYiBlZiAoRm9ybWF0IChmbXQsIHN0cikpID1cbiAgbGV0IHJlYyBhcHBseSA6IHR5cGUgYSBiIC4gYSAtPiAoYSwgYikgaGV0ZXJfbGlzdCAtPiBiID1cbiAgICBmdW4gZiBhcmdzIC0+IG1hdGNoIGFyZ3Mgd2l0aFxuICAgIHwgQ29ucyAoeCwgcikgLT4gYXBwbHkgKGYgeCkgclxuICAgIHwgTmlsIC0+IGZcbiAgaW5cbiAgbGV0IGsgcmVhZGVycyBmID1cbiAgICBTY2FubmluZy5yZXNldF90b2tlbiBpYjtcbiAgICBtYXRjaCB0cnkgQXJncyAobWFrZV9zY2FuZiBpYiBmbXQgcmVhZGVycykgd2l0aFxuICAgICAgfCAoU2Nhbl9mYWlsdXJlIF8gfCBGYWlsdXJlIF8gfCBFbmRfb2ZfZmlsZSkgYXMgZXhjIC0+IEV4YyBleGNcbiAgICAgIHwgSW52YWxpZF9hcmd1bWVudCBtc2cgLT5cbiAgICAgICAgaW52YWxpZF9hcmcgKG1zZyBeIFwiIGluIGZvcm1hdCBcXFwiXCIgXiBTdHJpbmcuZXNjYXBlZCBzdHIgXiBcIlxcXCJcIilcbiAgICB3aXRoXG4gICAgICB8IEFyZ3MgYXJncyAtPiBhcHBseSBmIGFyZ3NcbiAgICAgIHwgRXhjIGV4YyAtPiBlZiBpYiBleGNcbiAgaW5cbiAgdGFrZV9mb3JtYXRfcmVhZGVycyBrIGZtdFxuXG4oKioqKVxuXG5sZXQga2JzY2FuZiA9IGtzY2FuZlxubGV0IGJzY2FuZiBpYiBmbXQgPSBrYnNjYW5mIGliIHNjYW5mX2JhZF9pbnB1dCBmbXRcblxubGV0IGtzc2NhbmYgcyBlZiBmbXQgPSBrYnNjYW5mIChTY2FubmluZy5mcm9tX3N0cmluZyBzKSBlZiBmbXRcbmxldCBzc2NhbmYgcyBmbXQgPSBrYnNjYW5mIChTY2FubmluZy5mcm9tX3N0cmluZyBzKSBzY2FuZl9iYWRfaW5wdXQgZm10XG5cbmxldCBzY2FuZiBmbXQgPSBrc2NhbmYgU2Nhbm5pbmcuc3RkaWIgc2NhbmZfYmFkX2lucHV0IGZtdFxuXG4oKioqKVxuXG4oKiBTY2FubmluZyBmb3JtYXQgc3RyaW5ncy4gKilcbmxldCBic2NhbmZfZm9ybWF0IDpcbiAgU2Nhbm5pbmcuaW5fY2hhbm5lbCAtPiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiAtPlxuICAoKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgLT4gJ2cpIC0+ICdnID1cbiAgZnVuIGliIGZvcm1hdCBmIC0+XG4gICAgbGV0IF8gPSBzY2FuX2NhbWxfc3RyaW5nIG1heF9pbnQgaWIgaW5cbiAgICBsZXQgc3RyID0gdG9rZW5fc3RyaW5nIGliIGluXG4gICAgbGV0IGZtdCcgPVxuICAgICAgdHJ5IGZvcm1hdF9vZl9zdHJpbmdfZm9ybWF0IHN0ciBmb3JtYXRcbiAgICAgIHdpdGggRmFpbHVyZSBtc2cgLT4gYmFkX2lucHV0IG1zZyBpblxuICAgIGYgZm10J1xuXG5cbmxldCBzc2NhbmZfZm9ybWF0IDpcbiAgc3RyaW5nIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2IC0+XG4gICgoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiAtPiAnZykgLT4gJ2cgPVxuICBmdW4gcyBmb3JtYXQgZiAtPiBic2NhbmZfZm9ybWF0IChTY2FubmluZy5mcm9tX3N0cmluZyBzKSBmb3JtYXQgZlxuXG5cbmxldCBmb3JtYXRfZnJvbV9zdHJpbmcgcyBmbXQgPVxuICBzc2NhbmZfZm9ybWF0IChcIlxcXCJcIiBeIFN0cmluZy5lc2NhcGVkIHMgXiBcIlxcXCJcIikgZm10IChmdW4geCAtPiB4KVxuXG5cbmxldCB1bmVzY2FwZWQgcyA9XG4gIHNzY2FuZiAoXCJcXFwiXCIgXiBzIF4gXCJcXFwiXCIpIFwiJVMlIVwiIChmdW4geCAtPiB4KVxuXG5cbigqIERlcHJlY2F0ZWQgKilcbmxldCBrZnNjYW5mIGljIGVmIGZtdCA9IGtic2NhbmYgKFNjYW5uaW5nLm1lbW9fZnJvbV9jaGFubmVsIGljKSBlZiBmbXRcbmxldCBmc2NhbmYgaWMgZm10ID0ga3NjYW5mIChTY2FubmluZy5tZW1vX2Zyb21fY2hhbm5lbCBpYykgc2NhbmZfYmFkX2lucHV0IGZtdFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBSZWdpc3RlcmluZyBPQ2FtbCB2YWx1ZXMgd2l0aCB0aGUgQyBydW50aW1lIGZvciBsYXRlciBjYWxsYmFja3MgKilcblxuZXh0ZXJuYWwgcmVnaXN0ZXJfbmFtZWRfdmFsdWUgOiBzdHJpbmcgLT4gT2JqLnQgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfcmVnaXN0ZXJfbmFtZWRfdmFsdWVcIlxuXG5sZXQgcmVnaXN0ZXIgbmFtZSB2ID1cbiAgcmVnaXN0ZXJfbmFtZWRfdmFsdWUgbmFtZSAoT2JqLnJlcHIgdilcblxubGV0IHJlZ2lzdGVyX2V4Y2VwdGlvbiBuYW1lIChleG4gOiBleG4pID1cbiAgbGV0IGV4biA9IE9iai5yZXByIGV4biBpblxuICBsZXQgc2xvdCA9IGlmIE9iai50YWcgZXhuID0gT2JqLm9iamVjdF90YWcgdGhlbiBleG4gZWxzZSBPYmouZmllbGQgZXhuIDAgaW5cbiAgcmVnaXN0ZXJfbmFtZWRfdmFsdWUgbmFtZSBzbG90XG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICBKZXJvbWUgVm91aWxsb24sIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDAyIEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbm9wZW4gT2JqXG5cbigqKioqIE9iamVjdCByZXByZXNlbnRhdGlvbiAqKioqKVxuXG5leHRlcm5hbCBzZXRfaWQ6ICdhIC0+ICdhID0gXCJjYW1sX3NldF9vb19pZFwiIFtAQG5vYWxsb2NdXG5cbigqKioqIE9iamVjdCBjb3B5ICoqKiopXG5cbmxldCBjb3B5IG8gPVxuICBsZXQgbyA9IChPYmoub2JqIChPYmouZHVwIChPYmoucmVwciBvKSkpIGluXG4gIHNldF9pZCBvXG5cbigqKioqIENvbXByZXNzaW9uIG9wdGlvbnMgKioqKilcbigqIFBhcmFtZXRlcnMgKilcbnR5cGUgcGFyYW1zID0ge1xuICAgIG11dGFibGUgY29tcGFjdF90YWJsZSA6IGJvb2w7XG4gICAgbXV0YWJsZSBjb3B5X3BhcmVudCA6IGJvb2w7XG4gICAgbXV0YWJsZSBjbGVhbl93aGVuX2NvcHlpbmcgOiBib29sO1xuICAgIG11dGFibGUgcmV0cnlfY291bnQgOiBpbnQ7XG4gICAgbXV0YWJsZSBidWNrZXRfc21hbGxfc2l6ZSA6IGludFxuICB9XG5cbmxldCBwYXJhbXMgPSB7XG4gIGNvbXBhY3RfdGFibGUgPSB0cnVlO1xuICBjb3B5X3BhcmVudCA9IHRydWU7XG4gIGNsZWFuX3doZW5fY29weWluZyA9IHRydWU7XG4gIHJldHJ5X2NvdW50ID0gMztcbiAgYnVja2V0X3NtYWxsX3NpemUgPSAxNlxufVxuXG4oKioqKiBQYXJhbWV0ZXJzICoqKiopXG5cbmxldCBpbml0aWFsX29iamVjdF9zaXplID0gMlxuXG4oKioqKiBJdGVtcyAqKioqKVxuXG50eXBlIGl0ZW0gPSBEdW1teUEgfCBEdW1teUIgfCBEdW1teUMgb2YgaW50XG5sZXQgXyA9IFtEdW1teUE7IER1bW15QjsgRHVtbXlDIDBdICgqIHRvIGF2b2lkIHdhcm5pbmdzICopXG5cbmxldCBkdW1teV9pdGVtID0gKG1hZ2ljICgpIDogaXRlbSlcblxuKCoqKiogVHlwZXMgKioqKilcblxudHlwZSB0YWdcbnR5cGUgbGFiZWwgPSBpbnRcbnR5cGUgY2xvc3VyZSA9IGl0ZW1cbnR5cGUgdCA9IER1bW15QSB8IER1bW15QiB8IER1bW15QyBvZiBpbnRcbmxldCBfID0gW0R1bW15QTsgRHVtbXlCOyBEdW1teUMgMF0gKCogdG8gYXZvaWQgd2FybmluZ3MgKilcblxudHlwZSBvYmogPSB0IGFycmF5XG5leHRlcm5hbCByZXQgOiAob2JqIC0+ICdhKSAtPiBjbG9zdXJlID0gXCIlaWRlbnRpdHlcIlxuXG4oKioqKiBMYWJlbHMgKioqKilcblxubGV0IHB1YmxpY19tZXRob2RfbGFiZWwgcyA6IHRhZyA9XG4gIGxldCBhY2N1ID0gcmVmIDAgaW5cbiAgZm9yIGkgPSAwIHRvIFN0cmluZy5sZW5ndGggcyAtIDEgZG9cbiAgICBhY2N1IDo9IDIyMyAqICFhY2N1ICsgQ2hhci5jb2RlIHMuW2ldXG4gIGRvbmU7XG4gICgqIHJlZHVjZSB0byAzMSBiaXRzICopXG4gIGFjY3UgOj0gIWFjY3UgbGFuZCAoMSBsc2wgMzEgLSAxKTtcbiAgKCogbWFrZSBpdCBzaWduZWQgZm9yIDY0IGJpdHMgYXJjaGl0ZWN0dXJlcyAqKVxuICBsZXQgdGFnID0gaWYgIWFjY3UgPiAweDNGRkZGRkZGIHRoZW4gIWFjY3UgLSAoMSBsc2wgMzEpIGVsc2UgIWFjY3UgaW5cbiAgKCogUHJpbnRmLmVwcmludGYgXCIlcyA9ICVkXFxuXCIgcyB0YWc7IGZsdXNoIHN0ZGVycjsgKilcbiAgbWFnaWMgdGFnXG5cbigqKioqIFNwYXJzZSBhcnJheSAqKioqKVxuXG5tb2R1bGUgVmFycyA9XG4gIE1hcC5NYWtlKHN0cnVjdCB0eXBlIHQgPSBzdHJpbmcgbGV0IGNvbXBhcmUgKHg6dCkgeSA9IGNvbXBhcmUgeCB5IGVuZClcbnR5cGUgdmFycyA9IGludCBWYXJzLnRcblxubW9kdWxlIE1ldGhzID1cbiAgTWFwLk1ha2Uoc3RydWN0IHR5cGUgdCA9IHN0cmluZyBsZXQgY29tcGFyZSAoeDp0KSB5ID0gY29tcGFyZSB4IHkgZW5kKVxudHlwZSBtZXRocyA9IGxhYmVsIE1ldGhzLnRcbm1vZHVsZSBMYWJzID1cbiAgTWFwLk1ha2Uoc3RydWN0IHR5cGUgdCA9IGxhYmVsIGxldCBjb21wYXJlICh4OnQpIHkgPSBjb21wYXJlIHggeSBlbmQpXG50eXBlIGxhYnMgPSBib29sIExhYnMudFxuXG4oKiBUaGUgY29tcGlsZXIgYXNzdW1lcyB0aGF0IHRoZSBmaXJzdCBmaWVsZCBvZiB0aGlzIHN0cnVjdHVyZSBpcyBbc2l6ZV0uICopXG50eXBlIHRhYmxlID1cbiB7IG11dGFibGUgc2l6ZTogaW50O1xuICAgbXV0YWJsZSBtZXRob2RzOiBjbG9zdXJlIGFycmF5O1xuICAgbXV0YWJsZSBtZXRob2RzX2J5X25hbWU6IG1ldGhzO1xuICAgbXV0YWJsZSBtZXRob2RzX2J5X2xhYmVsOiBsYWJzO1xuICAgbXV0YWJsZSBwcmV2aW91c19zdGF0ZXM6XG4gICAgIChtZXRocyAqIGxhYnMgKiAobGFiZWwgKiBpdGVtKSBsaXN0ICogdmFycyAqXG4gICAgICBsYWJlbCBsaXN0ICogc3RyaW5nIGxpc3QpIGxpc3Q7XG4gICBtdXRhYmxlIGhpZGRlbl9tZXRoczogKGxhYmVsICogaXRlbSkgbGlzdDtcbiAgIG11dGFibGUgdmFyczogdmFycztcbiAgIG11dGFibGUgaW5pdGlhbGl6ZXJzOiAob2JqIC0+IHVuaXQpIGxpc3QgfVxuXG5sZXQgZHVtbXlfdGFibGUgPVxuICB7IG1ldGhvZHMgPSBbfCBkdW1teV9pdGVtIHxdO1xuICAgIG1ldGhvZHNfYnlfbmFtZSA9IE1ldGhzLmVtcHR5O1xuICAgIG1ldGhvZHNfYnlfbGFiZWwgPSBMYWJzLmVtcHR5O1xuICAgIHByZXZpb3VzX3N0YXRlcyA9IFtdO1xuICAgIGhpZGRlbl9tZXRocyA9IFtdO1xuICAgIHZhcnMgPSBWYXJzLmVtcHR5O1xuICAgIGluaXRpYWxpemVycyA9IFtdO1xuICAgIHNpemUgPSAwIH1cblxubGV0IHRhYmxlX2NvdW50ID0gcmVmIDBcblxuKCogZHVtbXlfbWV0IHNob3VsZCBiZSBhIHBvaW50ZXIsIHNvIHVzZSBhbiBhdG9tICopXG5sZXQgZHVtbXlfbWV0IDogaXRlbSA9IG9iaiAoT2JqLm5ld19ibG9jayAwIDApXG4oKiBpZiBkZWJ1Z2dpbmcgaXMgbmVlZGVkLCB0aGlzIGNvdWxkIGJlIGEgZ29vZCBpZGVhOiAqKVxuKCogbGV0IGR1bW15X21ldCAoKSA9IGZhaWx3aXRoIFwiVW5kZWZpbmVkIG1ldGhvZFwiICopXG5cbmxldCByZWMgZml0X3NpemUgbiA9XG4gIGlmIG4gPD0gMiB0aGVuIG4gZWxzZVxuICBmaXRfc2l6ZSAoKG4rMSkvMikgKiAyXG5cbmxldCBuZXdfdGFibGUgcHViX2xhYmVscyA9XG4gIGluY3IgdGFibGVfY291bnQ7XG4gIGxldCBsZW4gPSBBcnJheS5sZW5ndGggcHViX2xhYmVscyBpblxuICBsZXQgbWV0aG9kcyA9IEFycmF5Lm1ha2UgKGxlbioyKzIpIGR1bW15X21ldCBpblxuICBtZXRob2RzLigwKSA8LSBtYWdpYyBsZW47XG4gIG1ldGhvZHMuKDEpIDwtIG1hZ2ljIChmaXRfc2l6ZSBsZW4gKiBTeXMud29yZF9zaXplIC8gOCAtIDEpO1xuICBmb3IgaSA9IDAgdG8gbGVuIC0gMSBkbyBtZXRob2RzLihpKjIrMykgPC0gbWFnaWMgcHViX2xhYmVscy4oaSkgZG9uZTtcbiAgeyBtZXRob2RzID0gbWV0aG9kcztcbiAgICBtZXRob2RzX2J5X25hbWUgPSBNZXRocy5lbXB0eTtcbiAgICBtZXRob2RzX2J5X2xhYmVsID0gTGFicy5lbXB0eTtcbiAgICBwcmV2aW91c19zdGF0ZXMgPSBbXTtcbiAgICBoaWRkZW5fbWV0aHMgPSBbXTtcbiAgICB2YXJzID0gVmFycy5lbXB0eTtcbiAgICBpbml0aWFsaXplcnMgPSBbXTtcbiAgICBzaXplID0gaW5pdGlhbF9vYmplY3Rfc2l6ZSB9XG5cbmxldCByZXNpemUgYXJyYXkgbmV3X3NpemUgPVxuICBsZXQgb2xkX3NpemUgPSBBcnJheS5sZW5ndGggYXJyYXkubWV0aG9kcyBpblxuICBpZiBuZXdfc2l6ZSA+IG9sZF9zaXplIHRoZW4gYmVnaW5cbiAgICBsZXQgbmV3X2J1Y2sgPSBBcnJheS5tYWtlIG5ld19zaXplIGR1bW15X21ldCBpblxuICAgIEFycmF5LmJsaXQgYXJyYXkubWV0aG9kcyAwIG5ld19idWNrIDAgb2xkX3NpemU7XG4gICAgYXJyYXkubWV0aG9kcyA8LSBuZXdfYnVja1xuIGVuZFxuXG5sZXQgcHV0IGFycmF5IGxhYmVsIGVsZW1lbnQgPVxuICByZXNpemUgYXJyYXkgKGxhYmVsICsgMSk7XG4gIGFycmF5Lm1ldGhvZHMuKGxhYmVsKSA8LSBlbGVtZW50XG5cbigqKioqIENsYXNzZXMgKioqKilcblxubGV0IG1ldGhvZF9jb3VudCA9IHJlZiAwXG5sZXQgaW5zdF92YXJfY291bnQgPSByZWYgMFxuXG4oKiB0eXBlIHQgKilcbnR5cGUgbWV0aCA9IGl0ZW1cblxubGV0IG5ld19tZXRob2QgdGFibGUgPVxuICBsZXQgaW5kZXggPSBBcnJheS5sZW5ndGggdGFibGUubWV0aG9kcyBpblxuICByZXNpemUgdGFibGUgKGluZGV4ICsgMSk7XG4gIGluZGV4XG5cbmxldCBnZXRfbWV0aG9kX2xhYmVsIHRhYmxlIG5hbWUgPVxuICB0cnlcbiAgICBNZXRocy5maW5kIG5hbWUgdGFibGUubWV0aG9kc19ieV9uYW1lXG4gIHdpdGggTm90X2ZvdW5kIC0+XG4gICAgbGV0IGxhYmVsID0gbmV3X21ldGhvZCB0YWJsZSBpblxuICAgIHRhYmxlLm1ldGhvZHNfYnlfbmFtZSA8LSBNZXRocy5hZGQgbmFtZSBsYWJlbCB0YWJsZS5tZXRob2RzX2J5X25hbWU7XG4gICAgdGFibGUubWV0aG9kc19ieV9sYWJlbCA8LSBMYWJzLmFkZCBsYWJlbCB0cnVlIHRhYmxlLm1ldGhvZHNfYnlfbGFiZWw7XG4gICAgbGFiZWxcblxubGV0IGdldF9tZXRob2RfbGFiZWxzIHRhYmxlIG5hbWVzID1cbiAgQXJyYXkubWFwIChnZXRfbWV0aG9kX2xhYmVsIHRhYmxlKSBuYW1lc1xuXG5sZXQgc2V0X21ldGhvZCB0YWJsZSBsYWJlbCBlbGVtZW50ID1cbiAgaW5jciBtZXRob2RfY291bnQ7XG4gIGlmIExhYnMuZmluZCBsYWJlbCB0YWJsZS5tZXRob2RzX2J5X2xhYmVsIHRoZW5cbiAgICBwdXQgdGFibGUgbGFiZWwgZWxlbWVudFxuICBlbHNlXG4gICAgdGFibGUuaGlkZGVuX21ldGhzIDwtIChsYWJlbCwgZWxlbWVudCkgOjogdGFibGUuaGlkZGVuX21ldGhzXG5cbmxldCBnZXRfbWV0aG9kIHRhYmxlIGxhYmVsID1cbiAgdHJ5IExpc3QuYXNzb2MgbGFiZWwgdGFibGUuaGlkZGVuX21ldGhzXG4gIHdpdGggTm90X2ZvdW5kIC0+IHRhYmxlLm1ldGhvZHMuKGxhYmVsKVxuXG5sZXQgdG9fbGlzdCBhcnIgPVxuICBpZiBhcnIgPT0gbWFnaWMgMCB0aGVuIFtdIGVsc2UgQXJyYXkudG9fbGlzdCBhcnJcblxubGV0IG5hcnJvdyB0YWJsZSB2YXJzIHZpcnRfbWV0aHMgY29uY3JfbWV0aHMgPVxuICBsZXQgdmFycyA9IHRvX2xpc3QgdmFyc1xuICBhbmQgdmlydF9tZXRocyA9IHRvX2xpc3QgdmlydF9tZXRoc1xuICBhbmQgY29uY3JfbWV0aHMgPSB0b19saXN0IGNvbmNyX21ldGhzIGluXG4gIGxldCB2aXJ0X21ldGhfbGFicyA9IExpc3QubWFwIChnZXRfbWV0aG9kX2xhYmVsIHRhYmxlKSB2aXJ0X21ldGhzIGluXG4gIGxldCBjb25jcl9tZXRoX2xhYnMgPSBMaXN0Lm1hcCAoZ2V0X21ldGhvZF9sYWJlbCB0YWJsZSkgY29uY3JfbWV0aHMgaW5cbiAgdGFibGUucHJldmlvdXNfc3RhdGVzIDwtXG4gICAgICh0YWJsZS5tZXRob2RzX2J5X25hbWUsIHRhYmxlLm1ldGhvZHNfYnlfbGFiZWwsIHRhYmxlLmhpZGRlbl9tZXRocyxcbiAgICAgIHRhYmxlLnZhcnMsIHZpcnRfbWV0aF9sYWJzLCB2YXJzKVxuICAgICA6OiB0YWJsZS5wcmV2aW91c19zdGF0ZXM7XG4gIHRhYmxlLnZhcnMgPC1cbiAgICBWYXJzLmZvbGRcbiAgICAgIChmdW4gbGFiIGluZm8gdHZhcnMgLT5cbiAgICAgICAgaWYgTGlzdC5tZW0gbGFiIHZhcnMgdGhlbiBWYXJzLmFkZCBsYWIgaW5mbyB0dmFycyBlbHNlIHR2YXJzKVxuICAgICAgdGFibGUudmFycyBWYXJzLmVtcHR5O1xuICBsZXQgYnlfbmFtZSA9IHJlZiBNZXRocy5lbXB0eSBpblxuICBsZXQgYnlfbGFiZWwgPSByZWYgTGFicy5lbXB0eSBpblxuICBMaXN0Lml0ZXIyXG4gICAgKGZ1biBtZXQgbGFiZWwgLT5cbiAgICAgICBieV9uYW1lIDo9IE1ldGhzLmFkZCBtZXQgbGFiZWwgIWJ5X25hbWU7XG4gICAgICAgYnlfbGFiZWwgOj1cbiAgICAgICAgICBMYWJzLmFkZCBsYWJlbFxuICAgICAgICAgICAgKHRyeSBMYWJzLmZpbmQgbGFiZWwgdGFibGUubWV0aG9kc19ieV9sYWJlbCB3aXRoIE5vdF9mb3VuZCAtPiB0cnVlKVxuICAgICAgICAgICAgIWJ5X2xhYmVsKVxuICAgIGNvbmNyX21ldGhzIGNvbmNyX21ldGhfbGFicztcbiAgTGlzdC5pdGVyMlxuICAgIChmdW4gbWV0IGxhYmVsIC0+XG4gICAgICAgYnlfbmFtZSA6PSBNZXRocy5hZGQgbWV0IGxhYmVsICFieV9uYW1lO1xuICAgICAgIGJ5X2xhYmVsIDo9IExhYnMuYWRkIGxhYmVsIGZhbHNlICFieV9sYWJlbClcbiAgICB2aXJ0X21ldGhzIHZpcnRfbWV0aF9sYWJzO1xuICB0YWJsZS5tZXRob2RzX2J5X25hbWUgPC0gIWJ5X25hbWU7XG4gIHRhYmxlLm1ldGhvZHNfYnlfbGFiZWwgPC0gIWJ5X2xhYmVsO1xuICB0YWJsZS5oaWRkZW5fbWV0aHMgPC1cbiAgICAgTGlzdC5mb2xkX3JpZ2h0XG4gICAgICAgKGZ1biAoKGxhYiwgXykgYXMgbWV0KSBobSAtPlxuICAgICAgICAgIGlmIExpc3QubWVtIGxhYiB2aXJ0X21ldGhfbGFicyB0aGVuIGhtIGVsc2UgbWV0OjpobSlcbiAgICAgICB0YWJsZS5oaWRkZW5fbWV0aHNcbiAgICAgICBbXVxuXG5sZXQgd2lkZW4gdGFibGUgPVxuICBsZXQgKGJ5X25hbWUsIGJ5X2xhYmVsLCBzYXZlZF9oaWRkZW5fbWV0aHMsIHNhdmVkX3ZhcnMsIHZpcnRfbWV0aHMsIHZhcnMpID1cbiAgICBMaXN0LmhkIHRhYmxlLnByZXZpb3VzX3N0YXRlc1xuICBpblxuICB0YWJsZS5wcmV2aW91c19zdGF0ZXMgPC0gTGlzdC50bCB0YWJsZS5wcmV2aW91c19zdGF0ZXM7XG4gIHRhYmxlLnZhcnMgPC1cbiAgICAgTGlzdC5mb2xkX2xlZnRcbiAgICAgICAoZnVuIHMgdiAtPiBWYXJzLmFkZCB2IChWYXJzLmZpbmQgdiB0YWJsZS52YXJzKSBzKVxuICAgICAgIHNhdmVkX3ZhcnMgdmFycztcbiAgdGFibGUubWV0aG9kc19ieV9uYW1lIDwtIGJ5X25hbWU7XG4gIHRhYmxlLm1ldGhvZHNfYnlfbGFiZWwgPC0gYnlfbGFiZWw7XG4gIHRhYmxlLmhpZGRlbl9tZXRocyA8LVxuICAgICBMaXN0LmZvbGRfcmlnaHRcbiAgICAgICAoZnVuICgobGFiLCBfKSBhcyBtZXQpIGhtIC0+XG4gICAgICAgICAgaWYgTGlzdC5tZW0gbGFiIHZpcnRfbWV0aHMgdGhlbiBobSBlbHNlIG1ldDo6aG0pXG4gICAgICAgdGFibGUuaGlkZGVuX21ldGhzXG4gICAgICAgc2F2ZWRfaGlkZGVuX21ldGhzXG5cbmxldCBuZXdfc2xvdCB0YWJsZSA9XG4gIGxldCBpbmRleCA9IHRhYmxlLnNpemUgaW5cbiAgdGFibGUuc2l6ZSA8LSBpbmRleCArIDE7XG4gIGluZGV4XG5cbmxldCBuZXdfdmFyaWFibGUgdGFibGUgbmFtZSA9XG4gIHRyeSBWYXJzLmZpbmQgbmFtZSB0YWJsZS52YXJzXG4gIHdpdGggTm90X2ZvdW5kIC0+XG4gICAgbGV0IGluZGV4ID0gbmV3X3Nsb3QgdGFibGUgaW5cbiAgICBpZiBuYW1lIDw+IFwiXCIgdGhlbiB0YWJsZS52YXJzIDwtIFZhcnMuYWRkIG5hbWUgaW5kZXggdGFibGUudmFycztcbiAgICBpbmRleFxuXG5sZXQgdG9fYXJyYXkgYXJyID1cbiAgaWYgYXJyID0gT2JqLm1hZ2ljIDAgdGhlbiBbfHxdIGVsc2UgYXJyXG5cbmxldCBuZXdfbWV0aG9kc192YXJpYWJsZXMgdGFibGUgbWV0aHMgdmFscyA9XG4gIGxldCBtZXRocyA9IHRvX2FycmF5IG1ldGhzIGluXG4gIGxldCBubWV0aHMgPSBBcnJheS5sZW5ndGggbWV0aHMgYW5kIG52YWxzID0gQXJyYXkubGVuZ3RoIHZhbHMgaW5cbiAgbGV0IHJlcyA9IEFycmF5Lm1ha2UgKG5tZXRocyArIG52YWxzKSAwIGluXG4gIGZvciBpID0gMCB0byBubWV0aHMgLSAxIGRvXG4gICAgcmVzLihpKSA8LSBnZXRfbWV0aG9kX2xhYmVsIHRhYmxlIG1ldGhzLihpKVxuICBkb25lO1xuICBmb3IgaSA9IDAgdG8gbnZhbHMgLSAxIGRvXG4gICAgcmVzLihpK25tZXRocykgPC0gbmV3X3ZhcmlhYmxlIHRhYmxlIHZhbHMuKGkpXG4gIGRvbmU7XG4gIHJlc1xuXG5sZXQgZ2V0X3ZhcmlhYmxlIHRhYmxlIG5hbWUgPVxuICB0cnkgVmFycy5maW5kIG5hbWUgdGFibGUudmFycyB3aXRoIE5vdF9mb3VuZCAtPiBhc3NlcnQgZmFsc2VcblxubGV0IGdldF92YXJpYWJsZXMgdGFibGUgbmFtZXMgPVxuICBBcnJheS5tYXAgKGdldF92YXJpYWJsZSB0YWJsZSkgbmFtZXNcblxubGV0IGFkZF9pbml0aWFsaXplciB0YWJsZSBmID1cbiAgdGFibGUuaW5pdGlhbGl6ZXJzIDwtIGY6OnRhYmxlLmluaXRpYWxpemVyc1xuXG4oKlxubW9kdWxlIEtleXMgPVxuICBNYXAuTWFrZShzdHJ1Y3QgdHlwZSB0ID0gdGFnIGFycmF5IGxldCBjb21wYXJlICh4OnQpIHkgPSBjb21wYXJlIHggeSBlbmQpXG5sZXQga2V5X21hcCA9IHJlZiBLZXlzLmVtcHR5XG5sZXQgZ2V0X2tleSB0YWdzIDogaXRlbSA9XG4gIHRyeSBtYWdpYyAoS2V5cy5maW5kIHRhZ3MgIWtleV9tYXAgOiB0YWcgYXJyYXkpXG4gIHdpdGggTm90X2ZvdW5kIC0+XG4gICAga2V5X21hcCA6PSBLZXlzLmFkZCB0YWdzIHRhZ3MgIWtleV9tYXA7XG4gICAgbWFnaWMgdGFnc1xuKilcblxubGV0IGNyZWF0ZV90YWJsZSBwdWJsaWNfbWV0aG9kcyA9XG4gIGlmIHB1YmxpY19tZXRob2RzID09IG1hZ2ljIDAgdGhlbiBuZXdfdGFibGUgW3x8XSBlbHNlXG4gICgqIFtwdWJsaWNfbWV0aG9kc10gbXVzdCBiZSBpbiBhc2NlbmRpbmcgb3JkZXIgZm9yIGJ5dGVjb2RlICopXG4gIGxldCB0YWdzID0gQXJyYXkubWFwIHB1YmxpY19tZXRob2RfbGFiZWwgcHVibGljX21ldGhvZHMgaW5cbiAgbGV0IHRhYmxlID0gbmV3X3RhYmxlIHRhZ3MgaW5cbiAgQXJyYXkuaXRlcmlcbiAgICAoZnVuIGkgbWV0IC0+XG4gICAgICBsZXQgbGFiID0gaSoyKzIgaW5cbiAgICAgIHRhYmxlLm1ldGhvZHNfYnlfbmFtZSAgPC0gTWV0aHMuYWRkIG1ldCBsYWIgdGFibGUubWV0aG9kc19ieV9uYW1lO1xuICAgICAgdGFibGUubWV0aG9kc19ieV9sYWJlbCA8LSBMYWJzLmFkZCBsYWIgdHJ1ZSB0YWJsZS5tZXRob2RzX2J5X2xhYmVsKVxuICAgIHB1YmxpY19tZXRob2RzO1xuICB0YWJsZVxuXG5sZXQgaW5pdF9jbGFzcyB0YWJsZSA9XG4gIGluc3RfdmFyX2NvdW50IDo9ICFpbnN0X3Zhcl9jb3VudCArIHRhYmxlLnNpemUgLSAxO1xuICB0YWJsZS5pbml0aWFsaXplcnMgPC0gTGlzdC5yZXYgdGFibGUuaW5pdGlhbGl6ZXJzO1xuICByZXNpemUgdGFibGUgKDMgKyBtYWdpYyB0YWJsZS5tZXRob2RzLigxKSAqIDE2IC8gU3lzLndvcmRfc2l6ZSlcblxubGV0IGluaGVyaXRzIGNsYSB2YWxzIHZpcnRfbWV0aHMgY29uY3JfbWV0aHMgKF8sIHN1cGVyLCBfLCBlbnYpIHRvcCA9XG4gIG5hcnJvdyBjbGEgdmFscyB2aXJ0X21ldGhzIGNvbmNyX21ldGhzO1xuICBsZXQgaW5pdCA9XG4gICAgaWYgdG9wIHRoZW4gc3VwZXIgY2xhIGVudiBlbHNlIE9iai5yZXByIChzdXBlciBjbGEpIGluXG4gIHdpZGVuIGNsYTtcbiAgQXJyYXkuY29uY2F0XG4gICAgW1t8IHJlcHIgaW5pdCB8XTtcbiAgICAgbWFnaWMgKEFycmF5Lm1hcCAoZ2V0X3ZhcmlhYmxlIGNsYSkgKHRvX2FycmF5IHZhbHMpIDogaW50IGFycmF5KTtcbiAgICAgQXJyYXkubWFwXG4gICAgICAgKGZ1biBubSAtPiByZXByIChnZXRfbWV0aG9kIGNsYSAoZ2V0X21ldGhvZF9sYWJlbCBjbGEgbm0pIDogY2xvc3VyZSkpXG4gICAgICAgKHRvX2FycmF5IGNvbmNyX21ldGhzKSBdXG5cbmxldCBtYWtlX2NsYXNzIHB1Yl9tZXRocyBjbGFzc19pbml0ID1cbiAgbGV0IHRhYmxlID0gY3JlYXRlX3RhYmxlIHB1Yl9tZXRocyBpblxuICBsZXQgZW52X2luaXQgPSBjbGFzc19pbml0IHRhYmxlIGluXG4gIGluaXRfY2xhc3MgdGFibGU7XG4gIChlbnZfaW5pdCAoT2JqLnJlcHIgMCksIGNsYXNzX2luaXQsIGVudl9pbml0LCBPYmoucmVwciAwKVxuXG50eXBlIGluaXRfdGFibGUgPSB7IG11dGFibGUgZW52X2luaXQ6IHQ7IG11dGFibGUgY2xhc3NfaW5pdDogdGFibGUgLT4gdCB9XG5bQEB3YXJuaW5nIFwiLXVudXNlZC1maWVsZFwiXVxuXG5sZXQgbWFrZV9jbGFzc19zdG9yZSBwdWJfbWV0aHMgY2xhc3NfaW5pdCBpbml0X3RhYmxlID1cbiAgbGV0IHRhYmxlID0gY3JlYXRlX3RhYmxlIHB1Yl9tZXRocyBpblxuICBsZXQgZW52X2luaXQgPSBjbGFzc19pbml0IHRhYmxlIGluXG4gIGluaXRfY2xhc3MgdGFibGU7XG4gIGluaXRfdGFibGUuY2xhc3NfaW5pdCA8LSBjbGFzc19pbml0O1xuICBpbml0X3RhYmxlLmVudl9pbml0IDwtIGVudl9pbml0XG5cbmxldCBkdW1teV9jbGFzcyBsb2MgPVxuICBsZXQgdW5kZWYgPSBmdW4gXyAtPiByYWlzZSAoVW5kZWZpbmVkX3JlY3Vyc2l2ZV9tb2R1bGUgbG9jKSBpblxuICAoT2JqLm1hZ2ljIHVuZGVmLCB1bmRlZiwgdW5kZWYsIE9iai5yZXByIDApXG5cbigqKioqIE9iamVjdHMgKioqKilcblxubGV0IGNyZWF0ZV9vYmplY3QgdGFibGUgPVxuICAoKiBYWFggQXBwZWwgZGUgW29ial9ibG9ja10gfCBDYWxsIHRvIFtvYmpfYmxvY2tdICAqKVxuICBsZXQgb2JqID0gT2JqLm5ld19ibG9jayBPYmoub2JqZWN0X3RhZyB0YWJsZS5zaXplIGluXG4gICgqIFhYWCBBcHBlbCBkZSBbY2FtbF9tb2RpZnldIHwgQ2FsbCB0byBbY2FtbF9tb2RpZnldICopXG4gIE9iai5zZXRfZmllbGQgb2JqIDAgKE9iai5yZXByIHRhYmxlLm1ldGhvZHMpO1xuICBPYmoub2JqIChzZXRfaWQgb2JqKVxuXG5sZXQgY3JlYXRlX29iamVjdF9vcHQgb2JqXzAgdGFibGUgPVxuICBpZiAoT2JqLm1hZ2ljIG9ial8wIDogYm9vbCkgdGhlbiBvYmpfMCBlbHNlIGJlZ2luXG4gICAgKCogWFhYIEFwcGVsIGRlIFtvYmpfYmxvY2tdIHwgQ2FsbCB0byBbb2JqX2Jsb2NrXSAgKilcbiAgICBsZXQgb2JqID0gT2JqLm5ld19ibG9jayBPYmoub2JqZWN0X3RhZyB0YWJsZS5zaXplIGluXG4gICAgKCogWFhYIEFwcGVsIGRlIFtjYW1sX21vZGlmeV0gfCBDYWxsIHRvIFtjYW1sX21vZGlmeV0gKilcbiAgICBPYmouc2V0X2ZpZWxkIG9iaiAwIChPYmoucmVwciB0YWJsZS5tZXRob2RzKTtcbiAgICBPYmoub2JqIChzZXRfaWQgb2JqKVxuICBlbmRcblxubGV0IHJlYyBpdGVyX2Ygb2JqID1cbiAgZnVuY3Rpb25cbiAgICBbXSAgIC0+ICgpXG4gIHwgZjo6bCAtPiBmIG9iajsgaXRlcl9mIG9iaiBsXG5cbmxldCBydW5faW5pdGlhbGl6ZXJzIG9iaiB0YWJsZSA9XG4gIGxldCBpbml0cyA9IHRhYmxlLmluaXRpYWxpemVycyBpblxuICBpZiBpbml0cyA8PiBbXSB0aGVuXG4gICAgaXRlcl9mIG9iaiBpbml0c1xuXG5sZXQgcnVuX2luaXRpYWxpemVyc19vcHQgb2JqXzAgb2JqIHRhYmxlID1cbiAgaWYgKE9iai5tYWdpYyBvYmpfMCA6IGJvb2wpIHRoZW4gb2JqIGVsc2UgYmVnaW5cbiAgICBsZXQgaW5pdHMgPSB0YWJsZS5pbml0aWFsaXplcnMgaW5cbiAgICBpZiBpbml0cyA8PiBbXSB0aGVuIGl0ZXJfZiBvYmogaW5pdHM7XG4gICAgb2JqXG4gIGVuZFxuXG5sZXQgY3JlYXRlX29iamVjdF9hbmRfcnVuX2luaXRpYWxpemVycyBvYmpfMCB0YWJsZSA9XG4gIGlmIChPYmoubWFnaWMgb2JqXzAgOiBib29sKSB0aGVuIG9ial8wIGVsc2UgYmVnaW5cbiAgICBsZXQgb2JqID0gY3JlYXRlX29iamVjdCB0YWJsZSBpblxuICAgIHJ1bl9pbml0aWFsaXplcnMgb2JqIHRhYmxlO1xuICAgIG9ialxuICBlbmRcblxuKCogRXF1aXZhbGVudCBwcmltaXRpdmUgYmVsb3dcbmxldCBzZW5kc2VsZiBvYmogbGFiID1cbiAgKG1hZ2ljIG9iaiA6IChvYmogLT4gdCkgYXJyYXkgYXJyYXkpLigwKS4obGFiKSBvYmpcbiopXG5leHRlcm5hbCBzZW5kIDogb2JqIC0+IHRhZyAtPiAnYSA9IFwiJXNlbmRcIlxuZXh0ZXJuYWwgc2VuZGNhY2hlIDogb2JqIC0+IHRhZyAtPiB0IC0+IGludCAtPiAnYSA9IFwiJXNlbmRjYWNoZVwiXG5leHRlcm5hbCBzZW5kc2VsZiA6IG9iaiAtPiBsYWJlbCAtPiAnYSA9IFwiJXNlbmRzZWxmXCJcbmV4dGVybmFsIGdldF9wdWJsaWNfbWV0aG9kIDogb2JqIC0+IHRhZyAtPiBjbG9zdXJlXG4gICAgPSBcImNhbWxfZ2V0X3B1YmxpY19tZXRob2RcIiBbQEBub2FsbG9jXVxuXG4oKioqKiB0YWJsZSBjb2xsZWN0aW9uIGFjY2VzcyAqKioqKVxuXG50eXBlIHRhYmxlcyA9XG4gIHwgRW1wdHlcbiAgfCBDb25zIG9mIHtrZXkgOiBjbG9zdXJlOyBtdXRhYmxlIGRhdGE6IHRhYmxlczsgbXV0YWJsZSBuZXh0OiB0YWJsZXN9XG5cbmxldCBzZXRfZGF0YSB0YWJsZXMgdiA9IG1hdGNoIHRhYmxlcyB3aXRoXG4gIHwgRW1wdHkgLT4gYXNzZXJ0IGZhbHNlXG4gIHwgQ29ucyB0YWJsZXMgLT4gdGFibGVzLmRhdGEgPC0gdlxubGV0IHNldF9uZXh0IHRhYmxlcyB2ID0gbWF0Y2ggdGFibGVzIHdpdGhcbiAgfCBFbXB0eSAtPiBhc3NlcnQgZmFsc2VcbiAgfCBDb25zIHRhYmxlcyAtPiB0YWJsZXMubmV4dCA8LSB2XG5sZXQgZ2V0X2tleSA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT4gYXNzZXJ0IGZhbHNlXG4gIHwgQ29ucyB0YWJsZXMgLT4gdGFibGVzLmtleVxubGV0IGdldF9kYXRhID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPiBhc3NlcnQgZmFsc2VcbiAgfCBDb25zIHRhYmxlcyAtPiB0YWJsZXMuZGF0YVxubGV0IGdldF9uZXh0ID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPiBhc3NlcnQgZmFsc2VcbiAgfCBDb25zIHRhYmxlcyAtPiB0YWJsZXMubmV4dFxuXG5sZXQgYnVpbGRfcGF0aCBuIGtleXMgdGFibGVzID1cbiAgbGV0IHJlcyA9IENvbnMge2tleSA9IE9iai5tYWdpYyAwOyBkYXRhID0gRW1wdHk7IG5leHQgPSBFbXB0eX0gaW5cbiAgbGV0IHIgPSByZWYgcmVzIGluXG4gIGZvciBpID0gMCB0byBuIGRvXG4gICAgciA6PSBDb25zIHtrZXkgPSBrZXlzLihpKTsgZGF0YSA9ICFyOyBuZXh0ID0gRW1wdHl9XG4gIGRvbmU7XG4gIHNldF9kYXRhIHRhYmxlcyAhcjtcbiAgcmVzXG5cbmxldCByZWMgbG9va3VwX2tleXMgaSBrZXlzIHRhYmxlcyA9XG4gIGlmIGkgPCAwIHRoZW4gdGFibGVzIGVsc2VcbiAgbGV0IGtleSA9IGtleXMuKGkpIGluXG4gIGxldCByZWMgbG9va3VwX2tleSAodGFibGVzOnRhYmxlcykgPVxuICAgIGlmIGdldF9rZXkgdGFibGVzID09IGtleSB0aGVuXG4gICAgICBtYXRjaCBnZXRfZGF0YSB0YWJsZXMgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBhc3NlcnQgZmFsc2VcbiAgICAgIHwgQ29ucyBfIGFzIHRhYmxlc19kYXRhIC0+XG4gICAgICAgICAgbG9va3VwX2tleXMgKGktMSkga2V5cyB0YWJsZXNfZGF0YVxuICAgIGVsc2VcbiAgICAgIG1hdGNoIGdldF9uZXh0IHRhYmxlcyB3aXRoXG4gICAgICB8IENvbnMgXyBhcyBuZXh0IC0+IGxvb2t1cF9rZXkgbmV4dFxuICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgIGxldCBuZXh0IDogdGFibGVzID0gQ29ucyB7a2V5OyBkYXRhID0gRW1wdHk7IG5leHQgPSBFbXB0eX0gaW5cbiAgICAgICAgICBzZXRfbmV4dCB0YWJsZXMgbmV4dDtcbiAgICAgICAgICBidWlsZF9wYXRoIChpLTEpIGtleXMgbmV4dFxuICBpblxuICBsb29rdXBfa2V5IHRhYmxlc1xuXG5sZXQgbG9va3VwX3RhYmxlcyByb290IGtleXMgPVxuICBtYXRjaCBnZXRfZGF0YSByb290IHdpdGhcbiAgfCBDb25zIF8gYXMgcm9vdF9kYXRhIC0+XG4gICAgbG9va3VwX2tleXMgKEFycmF5Lmxlbmd0aCBrZXlzIC0gMSkga2V5cyByb290X2RhdGFcbiAgfCBFbXB0eSAtPlxuICAgIGJ1aWxkX3BhdGggKEFycmF5Lmxlbmd0aCBrZXlzIC0gMSkga2V5cyByb290XG5cbigqKioqIGJ1aWx0aW4gbWV0aG9kcyAqKioqKVxuXG5sZXQgZ2V0X2NvbnN0IHggPSByZXQgKGZ1biBfb2JqIC0+IHgpXG5sZXQgZ2V0X3ZhciBuICAgPSByZXQgKGZ1biBvYmogLT4gQXJyYXkudW5zYWZlX2dldCBvYmogbilcbmxldCBnZXRfZW52IGUgbiA9XG4gIHJldCAoZnVuIG9iaiAtPlxuICAgIEFycmF5LnVuc2FmZV9nZXQgKE9iai5tYWdpYyAoQXJyYXkudW5zYWZlX2dldCBvYmogZSkgOiBvYmopIG4pXG5sZXQgZ2V0X21ldGggbiAgPSByZXQgKGZ1biBvYmogLT4gc2VuZHNlbGYgb2JqIG4pXG5sZXQgc2V0X3ZhciBuICAgPSByZXQgKGZ1biBvYmogeCAtPiBBcnJheS51bnNhZmVfc2V0IG9iaiBuIHgpXG5sZXQgYXBwX2NvbnN0IGYgeCA9IHJldCAoZnVuIF9vYmogLT4gZiB4KVxubGV0IGFwcF92YXIgZiBuICAgPSByZXQgKGZ1biBvYmogLT4gZiAoQXJyYXkudW5zYWZlX2dldCBvYmogbikpXG5sZXQgYXBwX2VudiBmIGUgbiA9XG4gIHJldCAoZnVuIG9iaiAtPlxuICAgIGYgKEFycmF5LnVuc2FmZV9nZXQgKE9iai5tYWdpYyAoQXJyYXkudW5zYWZlX2dldCBvYmogZSkgOiBvYmopIG4pKVxubGV0IGFwcF9tZXRoIGYgbiAgPSByZXQgKGZ1biBvYmogLT4gZiAoc2VuZHNlbGYgb2JqIG4pKVxubGV0IGFwcF9jb25zdF9jb25zdCBmIHggeSA9IHJldCAoZnVuIF9vYmogLT4gZiB4IHkpXG5sZXQgYXBwX2NvbnN0X3ZhciBmIHggbiAgID0gcmV0IChmdW4gb2JqIC0+IGYgeCAoQXJyYXkudW5zYWZlX2dldCBvYmogbikpXG5sZXQgYXBwX2NvbnN0X21ldGggZiB4IG4gPSByZXQgKGZ1biBvYmogLT4gZiB4IChzZW5kc2VsZiBvYmogbikpXG5sZXQgYXBwX3Zhcl9jb25zdCBmIG4geCA9IHJldCAoZnVuIG9iaiAtPiBmIChBcnJheS51bnNhZmVfZ2V0IG9iaiBuKSB4KVxubGV0IGFwcF9tZXRoX2NvbnN0IGYgbiB4ID0gcmV0IChmdW4gb2JqIC0+IGYgKHNlbmRzZWxmIG9iaiBuKSB4KVxubGV0IGFwcF9jb25zdF9lbnYgZiB4IGUgbiA9XG4gIHJldCAoZnVuIG9iaiAtPlxuICAgIGYgeCAoQXJyYXkudW5zYWZlX2dldCAoT2JqLm1hZ2ljIChBcnJheS51bnNhZmVfZ2V0IG9iaiBlKSA6IG9iaikgbikpXG5sZXQgYXBwX2Vudl9jb25zdCBmIGUgbiB4ID1cbiAgcmV0IChmdW4gb2JqIC0+XG4gICAgZiAoQXJyYXkudW5zYWZlX2dldCAoT2JqLm1hZ2ljIChBcnJheS51bnNhZmVfZ2V0IG9iaiBlKSA6IG9iaikgbikgeClcbmxldCBtZXRoX2FwcF9jb25zdCBuIHggPSByZXQgKGZ1biBvYmogLT4gKHNlbmRzZWxmIG9iaiBuIDogXyAtPiBfKSB4KVxubGV0IG1ldGhfYXBwX3ZhciBuIG0gPVxuICByZXQgKGZ1biBvYmogLT4gKHNlbmRzZWxmIG9iaiBuIDogXyAtPiBfKSAoQXJyYXkudW5zYWZlX2dldCBvYmogbSkpXG5sZXQgbWV0aF9hcHBfZW52IG4gZSBtID1cbiAgcmV0IChmdW4gb2JqIC0+IChzZW5kc2VsZiBvYmogbiA6IF8gLT4gXylcbiAgICAgIChBcnJheS51bnNhZmVfZ2V0IChPYmoubWFnaWMgKEFycmF5LnVuc2FmZV9nZXQgb2JqIGUpIDogb2JqKSBtKSlcbmxldCBtZXRoX2FwcF9tZXRoIG4gbSA9XG4gIHJldCAoZnVuIG9iaiAtPiAoc2VuZHNlbGYgb2JqIG4gOiBfIC0+IF8pIChzZW5kc2VsZiBvYmogbSkpXG5sZXQgc2VuZF9jb25zdCBtIHggYyA9XG4gIHJldCAoZnVuIG9iaiAtPiBzZW5kY2FjaGUgeCBtIChBcnJheS51bnNhZmVfZ2V0IG9iaiAwKSBjKVxubGV0IHNlbmRfdmFyIG0gbiBjID1cbiAgcmV0IChmdW4gb2JqIC0+XG4gICAgc2VuZGNhY2hlIChPYmoubWFnaWMgKEFycmF5LnVuc2FmZV9nZXQgb2JqIG4pIDogb2JqKSBtXG4gICAgICAoQXJyYXkudW5zYWZlX2dldCBvYmogMCkgYylcbmxldCBzZW5kX2VudiBtIGUgbiBjID1cbiAgcmV0IChmdW4gb2JqIC0+XG4gICAgc2VuZGNhY2hlXG4gICAgICAoT2JqLm1hZ2ljIChBcnJheS51bnNhZmVfZ2V0XG4gICAgICAgICAgICAgICAgICAgIChPYmoubWFnaWMgKEFycmF5LnVuc2FmZV9nZXQgb2JqIGUpIDogb2JqKSBuKSA6IG9iailcbiAgICAgIG0gKEFycmF5LnVuc2FmZV9nZXQgb2JqIDApIGMpXG5sZXQgc2VuZF9tZXRoIG0gbiBjID1cbiAgcmV0IChmdW4gb2JqIC0+XG4gICAgc2VuZGNhY2hlIChzZW5kc2VsZiBvYmogbikgbSAoQXJyYXkudW5zYWZlX2dldCBvYmogMCkgYylcbmxldCBuZXdfY2FjaGUgdGFibGUgPVxuICBsZXQgbiA9IG5ld19tZXRob2QgdGFibGUgaW5cbiAgbGV0IG4gPVxuICAgIGlmIG4gbW9kIDIgPSAwIHx8IG4gPiAyICsgbWFnaWMgdGFibGUubWV0aG9kcy4oMSkgKiAxNiAvIFN5cy53b3JkX3NpemVcbiAgICB0aGVuIG4gZWxzZSBuZXdfbWV0aG9kIHRhYmxlXG4gIGluXG4gIHRhYmxlLm1ldGhvZHMuKG4pIDwtIE9iai5tYWdpYyAwO1xuICBuXG5cbnR5cGUgaW1wbCA9XG4gICAgR2V0Q29uc3RcbiAgfCBHZXRWYXJcbiAgfCBHZXRFbnZcbiAgfCBHZXRNZXRoXG4gIHwgU2V0VmFyXG4gIHwgQXBwQ29uc3RcbiAgfCBBcHBWYXJcbiAgfCBBcHBFbnZcbiAgfCBBcHBNZXRoXG4gIHwgQXBwQ29uc3RDb25zdFxuICB8IEFwcENvbnN0VmFyXG4gIHwgQXBwQ29uc3RFbnZcbiAgfCBBcHBDb25zdE1ldGhcbiAgfCBBcHBWYXJDb25zdFxuICB8IEFwcEVudkNvbnN0XG4gIHwgQXBwTWV0aENvbnN0XG4gIHwgTWV0aEFwcENvbnN0XG4gIHwgTWV0aEFwcFZhclxuICB8IE1ldGhBcHBFbnZcbiAgfCBNZXRoQXBwTWV0aFxuICB8IFNlbmRDb25zdFxuICB8IFNlbmRWYXJcbiAgfCBTZW5kRW52XG4gIHwgU2VuZE1ldGhcbiAgfCBDbG9zdXJlIG9mIGNsb3N1cmVcblxubGV0IG1ldGhvZF9pbXBsIHRhYmxlIGkgYXJyID1cbiAgbGV0IG5leHQgKCkgPSBpbmNyIGk7IG1hZ2ljIGFyci4oIWkpIGluXG4gIG1hdGNoIG5leHQoKSB3aXRoXG4gICAgR2V0Q29uc3QgLT4gbGV0IHggOiB0ID0gbmV4dCgpIGluIGdldF9jb25zdCB4XG4gIHwgR2V0VmFyICAgLT4gbGV0IG4gPSBuZXh0KCkgaW4gZ2V0X3ZhciBuXG4gIHwgR2V0RW52ICAgLT4gbGV0IGUgPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0KCkgaW4gZ2V0X2VudiBlIG5cbiAgfCBHZXRNZXRoICAtPiBsZXQgbiA9IG5leHQoKSBpbiBnZXRfbWV0aCBuXG4gIHwgU2V0VmFyICAgLT4gbGV0IG4gPSBuZXh0KCkgaW4gc2V0X3ZhciBuXG4gIHwgQXBwQ29uc3QgLT4gbGV0IGYgPSBuZXh0KCkgaW4gbGV0IHggPSBuZXh0KCkgaW4gYXBwX2NvbnN0IGYgeFxuICB8IEFwcFZhciAgIC0+IGxldCBmID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCAoKSBpbiBhcHBfdmFyIGYgblxuICB8IEFwcEVudiAgIC0+XG4gICAgICBsZXQgZiA9IG5leHQoKSBpbiAgbGV0IGUgPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0KCkgaW5cbiAgICAgIGFwcF9lbnYgZiBlIG5cbiAgfCBBcHBNZXRoICAtPiBsZXQgZiA9IG5leHQoKSBpbiBsZXQgbiA9IG5leHQgKCkgaW4gYXBwX21ldGggZiBuXG4gIHwgQXBwQ29uc3RDb25zdCAtPlxuICAgICAgbGV0IGYgPSBuZXh0KCkgaW4gbGV0IHggPSBuZXh0KCkgaW4gbGV0IHkgPSBuZXh0KCkgaW5cbiAgICAgIGFwcF9jb25zdF9jb25zdCBmIHggeVxuICB8IEFwcENvbnN0VmFyIC0+XG4gICAgICBsZXQgZiA9IG5leHQoKSBpbiBsZXQgeCA9IG5leHQoKSBpbiBsZXQgbiA9IG5leHQoKSBpblxuICAgICAgYXBwX2NvbnN0X3ZhciBmIHggblxuICB8IEFwcENvbnN0RW52IC0+XG4gICAgICBsZXQgZiA9IG5leHQoKSBpbiBsZXQgeCA9IG5leHQoKSBpbiBsZXQgZSA9IG5leHQgKCkgaW4gbGV0IG4gPSBuZXh0KCkgaW5cbiAgICAgIGFwcF9jb25zdF9lbnYgZiB4IGUgblxuICB8IEFwcENvbnN0TWV0aCAtPlxuICAgICAgbGV0IGYgPSBuZXh0KCkgaW4gbGV0IHggPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0KCkgaW5cbiAgICAgIGFwcF9jb25zdF9tZXRoIGYgeCBuXG4gIHwgQXBwVmFyQ29uc3QgLT5cbiAgICAgIGxldCBmID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCgpIGluIGxldCB4ID0gbmV4dCgpIGluXG4gICAgICBhcHBfdmFyX2NvbnN0IGYgbiB4XG4gIHwgQXBwRW52Q29uc3QgLT5cbiAgICAgIGxldCBmID0gbmV4dCgpIGluIGxldCBlID0gbmV4dCAoKSBpbiBsZXQgbiA9IG5leHQoKSBpbiBsZXQgeCA9IG5leHQoKSBpblxuICAgICAgYXBwX2Vudl9jb25zdCBmIGUgbiB4XG4gIHwgQXBwTWV0aENvbnN0IC0+XG4gICAgICBsZXQgZiA9IG5leHQoKSBpbiBsZXQgbiA9IG5leHQoKSBpbiBsZXQgeCA9IG5leHQoKSBpblxuICAgICAgYXBwX21ldGhfY29uc3QgZiBuIHhcbiAgfCBNZXRoQXBwQ29uc3QgLT5cbiAgICAgIGxldCBuID0gbmV4dCgpIGluIGxldCB4ID0gbmV4dCgpIGluIG1ldGhfYXBwX2NvbnN0IG4geFxuICB8IE1ldGhBcHBWYXIgLT5cbiAgICAgIGxldCBuID0gbmV4dCgpIGluIGxldCBtID0gbmV4dCgpIGluIG1ldGhfYXBwX3ZhciBuIG1cbiAgfCBNZXRoQXBwRW52IC0+XG4gICAgICBsZXQgbiA9IG5leHQoKSBpbiBsZXQgZSA9IG5leHQoKSBpbiBsZXQgbSA9IG5leHQoKSBpblxuICAgICAgbWV0aF9hcHBfZW52IG4gZSBtXG4gIHwgTWV0aEFwcE1ldGggLT5cbiAgICAgIGxldCBuID0gbmV4dCgpIGluIGxldCBtID0gbmV4dCgpIGluIG1ldGhfYXBwX21ldGggbiBtXG4gIHwgU2VuZENvbnN0IC0+XG4gICAgICBsZXQgbSA9IG5leHQoKSBpbiBsZXQgeCA9IG5leHQoKSBpbiBzZW5kX2NvbnN0IG0geCAobmV3X2NhY2hlIHRhYmxlKVxuICB8IFNlbmRWYXIgLT5cbiAgICAgIGxldCBtID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCAoKSBpbiBzZW5kX3ZhciBtIG4gKG5ld19jYWNoZSB0YWJsZSlcbiAgfCBTZW5kRW52IC0+XG4gICAgICBsZXQgbSA9IG5leHQoKSBpbiBsZXQgZSA9IG5leHQoKSBpbiBsZXQgbiA9IG5leHQoKSBpblxuICAgICAgc2VuZF9lbnYgbSBlIG4gKG5ld19jYWNoZSB0YWJsZSlcbiAgfCBTZW5kTWV0aCAtPlxuICAgICAgbGV0IG0gPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0ICgpIGluIHNlbmRfbWV0aCBtIG4gKG5ld19jYWNoZSB0YWJsZSlcbiAgfCBDbG9zdXJlIF8gYXMgY2xvIC0+IG1hZ2ljIGNsb1xuXG5sZXQgc2V0X21ldGhvZHMgdGFibGUgbWV0aG9kcyA9XG4gIGxldCBsZW4gPSBBcnJheS5sZW5ndGggbWV0aG9kcyBpbiBsZXQgaSA9IHJlZiAwIGluXG4gIHdoaWxlICFpIDwgbGVuIGRvXG4gICAgbGV0IGxhYmVsID0gbWV0aG9kcy4oIWkpIGluIGxldCBjbG8gPSBtZXRob2RfaW1wbCB0YWJsZSBpIG1ldGhvZHMgaW5cbiAgICBzZXRfbWV0aG9kIHRhYmxlIGxhYmVsIGNsbztcbiAgICBpbmNyIGlcbiAgZG9uZVxuXG4oKioqKiBTdGF0aXN0aWNzICoqKiopXG5cbnR5cGUgc3RhdHMgPVxuICB7IGNsYXNzZXM6IGludDsgbWV0aG9kczogaW50OyBpbnN0X3ZhcnM6IGludDsgfVxuXG5sZXQgc3RhdHMgKCkgPVxuICB7IGNsYXNzZXMgPSAhdGFibGVfY291bnQ7XG4gICAgbWV0aG9kcyA9ICFtZXRob2RfY291bnQ7IGluc3RfdmFycyA9ICFpbnN0X3Zhcl9jb3VudDsgfVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAwNCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlIHNoYXBlID1cbiAgfCBGdW5jdGlvblxuICB8IExhenlcbiAgfCBDbGFzc1xuICB8IE1vZHVsZSBvZiBzaGFwZSBhcnJheVxuICB8IFZhbHVlIG9mIE9iai50XG5cbmxldCByZWMgaW5pdF9tb2RfZmllbGQgbW9kdSBpIGxvYyBzaGFwZSA9XG4gIGxldCBpbml0ID1cbiAgICBtYXRjaCBzaGFwZSB3aXRoXG4gICAgfCBGdW5jdGlvbiAtPlxuICAgICAgIGxldCByZWMgZm4gKHggOiAnYSkgPVxuICAgICAgICAgbGV0IGZuJyA6ICdhIC0+ICdiID0gT2JqLm9iaiAoT2JqLmZpZWxkIG1vZHUgaSkgaW5cbiAgICAgICAgIGlmIGZuID09IGZuJyB0aGVuXG4gICAgICAgICAgIHJhaXNlIChVbmRlZmluZWRfcmVjdXJzaXZlX21vZHVsZSBsb2MpXG4gICAgICAgICBlbHNlXG4gICAgICAgICAgIGZuJyB4IGluXG4gICAgICAgT2JqLnJlcHIgZm5cbiAgICB8IExhenkgLT5cbiAgICAgICBsZXQgcmVjIGwgPVxuICAgICAgICAgbGF6eSAoXG4gICAgICAgICAgIGxldCBsJyA9IE9iai5vYmogKE9iai5maWVsZCBtb2R1IGkpIGluXG4gICAgICAgICAgIGlmIGwgPT0gbCcgdGhlblxuICAgICAgICAgICAgIHJhaXNlIChVbmRlZmluZWRfcmVjdXJzaXZlX21vZHVsZSBsb2MpXG4gICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICBMYXp5LmZvcmNlIGwnKSBpblxuICAgICAgIE9iai5yZXByIGxcbiAgICB8IENsYXNzIC0+XG4gICAgICAgT2JqLnJlcHIgKENhbWxpbnRlcm5hbE9PLmR1bW15X2NsYXNzIGxvYylcbiAgICB8IE1vZHVsZSBjb21wcyAtPlxuICAgICAgIE9iai5yZXByIChpbml0X21vZF9ibG9jayBsb2MgY29tcHMpXG4gICAgfCBWYWx1ZSB2IC0+IHZcbiAgaW5cbiAgT2JqLnNldF9maWVsZCBtb2R1IGkgaW5pdFxuXG5hbmQgaW5pdF9tb2RfYmxvY2sgbG9jIGNvbXBzID1cbiAgbGV0IGxlbmd0aCA9IEFycmF5Lmxlbmd0aCBjb21wcyBpblxuICBsZXQgbW9kdSA9IE9iai5uZXdfYmxvY2sgMCBsZW5ndGggaW5cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCAtIDEgZG9cbiAgICBpbml0X21vZF9maWVsZCBtb2R1IGkgbG9jIGNvbXBzLihpKVxuICBkb25lO1xuICBtb2R1XG5cbmxldCBpbml0X21vZCBsb2Mgc2hhcGUgPVxuICBtYXRjaCBzaGFwZSB3aXRoXG4gIHwgTW9kdWxlIGNvbXBzIC0+XG4gICAgIE9iai5yZXByIChpbml0X21vZF9ibG9jayBsb2MgY29tcHMpXG4gIHwgXyAtPiBmYWlsd2l0aCBcIkNhbWxpbnRlcm5hbE1vZC5pbml0X21vZDogbm90IGEgbW9kdWxlXCJcblxubGV0IHJlYyB1cGRhdGVfbW9kX2ZpZWxkIG1vZHUgaSBzaGFwZSBuID1cbiAgbWF0Y2ggc2hhcGUgd2l0aFxuICB8IEZ1bmN0aW9uIHwgTGF6eSAtPlxuICAgICBPYmouc2V0X2ZpZWxkIG1vZHUgaSBuXG4gIHwgVmFsdWUgXyAtPlxuICAgICAoKSAoKiB0aGUgdmFsdWUgaXMgYWxyZWFkeSB0aGVyZSAqKVxuICB8IENsYXNzIC0+XG4gICAgIGFzc2VydCAoT2JqLnRhZyBuID0gMCAmJiBPYmouc2l6ZSBuID0gNCk7XG4gICAgIGxldCBjbCA9IE9iai5maWVsZCBtb2R1IGkgaW5cbiAgICAgZm9yIGogPSAwIHRvIDMgZG9cbiAgICAgICBPYmouc2V0X2ZpZWxkIGNsIGogKE9iai5maWVsZCBuIGopXG4gICAgIGRvbmVcbiAgfCBNb2R1bGUgY29tcHMgLT5cbiAgICAgdXBkYXRlX21vZF9ibG9jayBjb21wcyAoT2JqLmZpZWxkIG1vZHUgaSkgblxuXG5hbmQgdXBkYXRlX21vZF9ibG9jayBjb21wcyBvIG4gPVxuICBhc3NlcnQgKE9iai50YWcgbiA9IDAgJiYgT2JqLnNpemUgbiA+PSBBcnJheS5sZW5ndGggY29tcHMpO1xuICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGNvbXBzIC0gMSBkb1xuICAgIHVwZGF0ZV9tb2RfZmllbGQgbyBpIGNvbXBzLihpKSAoT2JqLmZpZWxkIG4gaSlcbiAgZG9uZVxuXG5sZXQgdXBkYXRlX21vZCBzaGFwZSBvIG4gPVxuICBtYXRjaCBzaGFwZSB3aXRoXG4gIHwgTW9kdWxlIGNvbXBzIC0+XG4gICAgIHVwZGF0ZV9tb2RfYmxvY2sgY29tcHMgbyBuXG4gIHwgXyAtPiBmYWlsd2l0aCBcIkNhbWxpbnRlcm5hbE1vZC51cGRhdGVfbW9kOiBub3QgYSBtb2R1bGVcIlxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5bQEBAb2NhbWwud2FybmluZyBcIi0zXCJdICgqIGlnbm9yZSBkZXByZWNhdGlvbiB3YXJuaW5nIGFib3V0IG1vZHVsZSBTdHJlYW0gKilcblxudHlwZSB0b2tlbiA9XG4gICAgS3dkIG9mIHN0cmluZ1xuICB8IElkZW50IG9mIHN0cmluZ1xuICB8IEludCBvZiBpbnRcbiAgfCBGbG9hdCBvZiBmbG9hdFxuICB8IFN0cmluZyBvZiBzdHJpbmdcbiAgfCBDaGFyIG9mIGNoYXJcblxuKCogVGhlIHN0cmluZyBidWZmZXJpbmcgbWFjaGluZXJ5ICopXG5cbmxldCBpbml0aWFsX2J1ZmZlciA9IEJ5dGVzLmNyZWF0ZSAzMlxuXG5sZXQgYnVmZmVyID0gcmVmIGluaXRpYWxfYnVmZmVyXG5sZXQgYnVmcG9zID0gcmVmIDBcblxubGV0IHJlc2V0X2J1ZmZlciAoKSA9IGJ1ZmZlciA6PSBpbml0aWFsX2J1ZmZlcjsgYnVmcG9zIDo9IDBcblxubGV0IHN0b3JlIGMgPVxuICBpZiAhYnVmcG9zID49IEJ5dGVzLmxlbmd0aCAhYnVmZmVyIHRoZW4gYmVnaW5cbiAgICBsZXQgbmV3YnVmZmVyID0gQnl0ZXMuY3JlYXRlICgyICogIWJ1ZnBvcykgaW5cbiAgICBCeXRlcy5ibGl0ICFidWZmZXIgMCBuZXdidWZmZXIgMCAhYnVmcG9zO1xuICAgIGJ1ZmZlciA6PSBuZXdidWZmZXJcbiAgZW5kO1xuICBCeXRlcy5zZXQgIWJ1ZmZlciAhYnVmcG9zIGM7XG4gIGluY3IgYnVmcG9zXG5cbmxldCBnZXRfc3RyaW5nICgpID1cbiAgbGV0IHMgPSBCeXRlcy5zdWJfc3RyaW5nICFidWZmZXIgMCAhYnVmcG9zIGluIGJ1ZmZlciA6PSBpbml0aWFsX2J1ZmZlcjsgc1xuXG4oKiBUaGUgbGV4ZXIgKilcblxubGV0IG1ha2VfbGV4ZXIga2V5d29yZHMgPVxuICBsZXQga3dkX3RhYmxlID0gSGFzaHRibC5jcmVhdGUgMTcgaW5cbiAgTGlzdC5pdGVyIChmdW4gcyAtPiBIYXNodGJsLmFkZCBrd2RfdGFibGUgcyAoS3dkIHMpKSBrZXl3b3JkcztcbiAgbGV0IGlkZW50X29yX2tleXdvcmQgaWQgPVxuICAgIHRyeSBIYXNodGJsLmZpbmQga3dkX3RhYmxlIGlkIHdpdGhcbiAgICAgIE5vdF9mb3VuZCAtPiBJZGVudCBpZFxuICBhbmQga2V5d29yZF9vcl9lcnJvciBjID1cbiAgICBsZXQgcyA9IFN0cmluZy5tYWtlIDEgYyBpblxuICAgIHRyeSBIYXNodGJsLmZpbmQga3dkX3RhYmxlIHMgd2l0aFxuICAgICAgTm90X2ZvdW5kIC0+IHJhaXNlIChTdHJlYW0uRXJyb3IgKFwiSWxsZWdhbCBjaGFyYWN0ZXIgXCIgXiBzKSlcbiAgaW5cbiAgbGV0IHJlYyBuZXh0X3Rva2VuIChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWUgKCcgJyB8ICdcXDAxMCcgfCAnXFwwMTMnIHwgJ1xcMDA5JyB8ICdcXDAyNicgfCAnXFwwMTInKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187IG5leHRfdG9rZW4gc3RybV9fXG4gICAgfCBTb21lICgnQScuLidaJyB8ICdhJy4uJ3onIHwgJ18nIHwgJ1xcMTkyJy4uJ1xcMjU1JyBhcyBjKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187XG4gICAgICAgIGxldCBzID0gc3RybV9fIGluIHJlc2V0X2J1ZmZlciAoKTsgc3RvcmUgYzsgaWRlbnQgc1xuICAgIHwgU29tZVxuICAgICAgICAoJyEnIHwgJyUnIHwgJyYnIHwgJyQnIHwgJyMnIHwgJysnIHwgJy8nIHwgJzonIHwgJzwnIHwgJz0nIHwgJz4nIHxcbiAgICAgICAgICc/JyB8ICdAJyB8ICdcXFxcJyB8ICd+JyB8ICdeJyB8ICd8JyB8ICcqJyBhcyBjKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187XG4gICAgICAgIGxldCBzID0gc3RybV9fIGluIHJlc2V0X2J1ZmZlciAoKTsgc3RvcmUgYzsgaWRlbnQyIHNcbiAgICB8IFNvbWUgKCcwJy4uJzknIGFzIGMpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXztcbiAgICAgICAgbGV0IHMgPSBzdHJtX18gaW4gcmVzZXRfYnVmZmVyICgpOyBzdG9yZSBjOyBudW1iZXIgc1xuICAgIHwgU29tZSAnXFwnJyAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187XG4gICAgICAgIGxldCBjID1cbiAgICAgICAgICB0cnkgY2hhciBzdHJtX18gd2l0aFxuICAgICAgICAgICAgU3RyZWFtLkZhaWx1cmUgLT4gcmFpc2UgKFN0cmVhbS5FcnJvciBcIlwiKVxuICAgICAgICBpblxuICAgICAgICBiZWdpbiBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgICAgIFNvbWUgJ1xcJycgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBTb21lIChDaGFyIGMpXG4gICAgICAgIHwgXyAtPiByYWlzZSAoU3RyZWFtLkVycm9yIFwiXCIpXG4gICAgICAgIGVuZFxuICAgIHwgU29tZSAnXFxcIicgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fO1xuICAgICAgICBsZXQgcyA9IHN0cm1fXyBpbiByZXNldF9idWZmZXIgKCk7IFNvbWUgKFN0cmluZyAoc3RyaW5nIHMpKVxuICAgIHwgU29tZSAnLScgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBuZWdfbnVtYmVyIHN0cm1fX1xuICAgIHwgU29tZSAnKCcgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBtYXliZV9jb21tZW50IHN0cm1fX1xuICAgIHwgU29tZSBjIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgU29tZSAoa2V5d29yZF9vcl9lcnJvciBjKVxuICAgIHwgXyAtPiBOb25lXG4gIGFuZCBpZGVudCAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lXG4gICAgICAgICgnQScuLidaJyB8ICdhJy4uJ3onIHwgJ1xcMTkyJy4uJ1xcMjU1JyB8ICcwJy4uJzknIHwgJ18nIHwgJ1xcJycgYXMgYykgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fOyBsZXQgcyA9IHN0cm1fXyBpbiBzdG9yZSBjOyBpZGVudCBzXG4gICAgfCBfIC0+IFNvbWUgKGlkZW50X29yX2tleXdvcmQgKGdldF9zdHJpbmcgKCkpKVxuICBhbmQgaWRlbnQyIChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWVcbiAgICAgICAgKCchJyB8ICclJyB8ICcmJyB8ICckJyB8ICcjJyB8ICcrJyB8ICctJyB8ICcvJyB8ICc6JyB8ICc8JyB8ICc9JyB8XG4gICAgICAgICAnPicgfCAnPycgfCAnQCcgfCAnXFxcXCcgfCAnficgfCAnXicgfCAnfCcgfCAnKicgYXMgYykgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fOyBsZXQgcyA9IHN0cm1fXyBpbiBzdG9yZSBjOyBpZGVudDIgc1xuICAgIHwgXyAtPiBTb21lIChpZGVudF9vcl9rZXl3b3JkIChnZXRfc3RyaW5nICgpKSlcbiAgYW5kIG5lZ19udW1iZXIgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZSAoJzAnLi4nOScgYXMgYykgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fO1xuICAgICAgICBsZXQgcyA9IHN0cm1fXyBpbiByZXNldF9idWZmZXIgKCk7IHN0b3JlICctJzsgc3RvcmUgYzsgbnVtYmVyIHNcbiAgICB8IF8gLT4gbGV0IHMgPSBzdHJtX18gaW4gcmVzZXRfYnVmZmVyICgpOyBzdG9yZSAnLSc7IGlkZW50MiBzXG4gIGFuZCBudW1iZXIgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZSAoJzAnLi4nOScgYXMgYykgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fOyBsZXQgcyA9IHN0cm1fXyBpbiBzdG9yZSBjOyBudW1iZXIgc1xuICAgIHwgU29tZSAnLicgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fOyBsZXQgcyA9IHN0cm1fXyBpbiBzdG9yZSAnLic7IGRlY2ltYWxfcGFydCBzXG4gICAgfCBTb21lICgnZScgfCAnRScpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXzsgbGV0IHMgPSBzdHJtX18gaW4gc3RvcmUgJ0UnOyBleHBvbmVudF9wYXJ0IHNcbiAgICB8IF8gLT4gU29tZSAoSW50IChpbnRfb2Zfc3RyaW5nIChnZXRfc3RyaW5nICgpKSkpXG4gIGFuZCBkZWNpbWFsX3BhcnQgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZSAoJzAnLi4nOScgYXMgYykgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fOyBsZXQgcyA9IHN0cm1fXyBpbiBzdG9yZSBjOyBkZWNpbWFsX3BhcnQgc1xuICAgIHwgU29tZSAoJ2UnIHwgJ0UnKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187IGxldCBzID0gc3RybV9fIGluIHN0b3JlICdFJzsgZXhwb25lbnRfcGFydCBzXG4gICAgfCBfIC0+IFNvbWUgKEZsb2F0IChmbG9hdF9vZl9zdHJpbmcgKGdldF9zdHJpbmcgKCkpKSlcbiAgYW5kIGV4cG9uZW50X3BhcnQgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZSAoJysnIHwgJy0nIGFzIGMpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXzsgbGV0IHMgPSBzdHJtX18gaW4gc3RvcmUgYzsgZW5kX2V4cG9uZW50X3BhcnQgc1xuICAgIHwgXyAtPiBlbmRfZXhwb25lbnRfcGFydCBzdHJtX19cbiAgYW5kIGVuZF9leHBvbmVudF9wYXJ0IChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWUgKCcwJy4uJzknIGFzIGMpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXzsgbGV0IHMgPSBzdHJtX18gaW4gc3RvcmUgYzsgZW5kX2V4cG9uZW50X3BhcnQgc1xuICAgIHwgXyAtPiBTb21lIChGbG9hdCAoZmxvYXRfb2Zfc3RyaW5nIChnZXRfc3RyaW5nICgpKSkpXG4gIGFuZCBzdHJpbmcgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZSAnXFxcIicgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBnZXRfc3RyaW5nICgpXG4gICAgfCBTb21lICdcXFxcJyAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187XG4gICAgICAgIGxldCBjID1cbiAgICAgICAgICB0cnkgZXNjYXBlIHN0cm1fXyB3aXRoXG4gICAgICAgICAgICBTdHJlYW0uRmFpbHVyZSAtPiByYWlzZSAoU3RyZWFtLkVycm9yIFwiXCIpXG4gICAgICAgIGluXG4gICAgICAgIGxldCBzID0gc3RybV9fIGluIHN0b3JlIGM7IHN0cmluZyBzXG4gICAgfCBTb21lIGMgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBsZXQgcyA9IHN0cm1fXyBpbiBzdG9yZSBjOyBzdHJpbmcgc1xuICAgIHwgXyAtPiByYWlzZSBTdHJlYW0uRmFpbHVyZVxuICBhbmQgY2hhciAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICdcXFxcJyAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187XG4gICAgICAgIGJlZ2luIHRyeSBlc2NhcGUgc3RybV9fIHdpdGhcbiAgICAgICAgICBTdHJlYW0uRmFpbHVyZSAtPiByYWlzZSAoU3RyZWFtLkVycm9yIFwiXCIpXG4gICAgICAgIGVuZFxuICAgIHwgU29tZSBjIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgY1xuICAgIHwgXyAtPiByYWlzZSBTdHJlYW0uRmFpbHVyZVxuICBhbmQgZXNjYXBlIChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWUgJ24nIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgJ1xcbidcbiAgICB8IFNvbWUgJ3InIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgJ1xccidcbiAgICB8IFNvbWUgJ3QnIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgJ1xcdCdcbiAgICB8IFNvbWUgKCcwJy4uJzknIGFzIGMxKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187XG4gICAgICAgIGJlZ2luIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICAgICAgU29tZSAoJzAnLi4nOScgYXMgYzIpIC0+XG4gICAgICAgICAgICBTdHJlYW0uanVuayBzdHJtX187XG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgICAgICAgICBTb21lICgnMCcuLic5JyBhcyBjMykgLT5cbiAgICAgICAgICAgICAgICBTdHJlYW0uanVuayBzdHJtX187XG4gICAgICAgICAgICAgICAgQ2hhci5jaHJcbiAgICAgICAgICAgICAgICAgICgoQ2hhci5jb2RlIGMxIC0gNDgpICogMTAwICsgKENoYXIuY29kZSBjMiAtIDQ4KSAqIDEwICtcbiAgICAgICAgICAgICAgICAgICAgIChDaGFyLmNvZGUgYzMgLSA0OCkpXG4gICAgICAgICAgICB8IF8gLT4gcmFpc2UgKFN0cmVhbS5FcnJvciBcIlwiKVxuICAgICAgICAgICAgZW5kXG4gICAgICAgIHwgXyAtPiByYWlzZSAoU3RyZWFtLkVycm9yIFwiXCIpXG4gICAgICAgIGVuZFxuICAgIHwgU29tZSBjIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgY1xuICAgIHwgXyAtPiByYWlzZSBTdHJlYW0uRmFpbHVyZVxuICBhbmQgbWF5YmVfY29tbWVudCAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICcqJyAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187IGxldCBzID0gc3RybV9fIGluIGNvbW1lbnQgczsgbmV4dF90b2tlbiBzXG4gICAgfCBfIC0+IFNvbWUgKGtleXdvcmRfb3JfZXJyb3IgJygnKVxuICBhbmQgY29tbWVudCAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICcoJyAtPiBTdHJlYW0uanVuayBzdHJtX187IG1heWJlX25lc3RlZF9jb21tZW50IHN0cm1fX1xuICAgIHwgU29tZSAnKicgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBtYXliZV9lbmRfY29tbWVudCBzdHJtX19cbiAgICB8IFNvbWUgXyAtPiBTdHJlYW0uanVuayBzdHJtX187IGNvbW1lbnQgc3RybV9fXG4gICAgfCBfIC0+IHJhaXNlIFN0cmVhbS5GYWlsdXJlXG4gIGFuZCBtYXliZV9uZXN0ZWRfY29tbWVudCAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICcqJyAtPiBTdHJlYW0uanVuayBzdHJtX187IGxldCBzID0gc3RybV9fIGluIGNvbW1lbnQgczsgY29tbWVudCBzXG4gICAgfCBTb21lIF8gLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBjb21tZW50IHN0cm1fX1xuICAgIHwgXyAtPiByYWlzZSBTdHJlYW0uRmFpbHVyZVxuICBhbmQgbWF5YmVfZW5kX2NvbW1lbnQgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZSAnKScgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyAoKVxuICAgIHwgU29tZSAnKicgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBtYXliZV9lbmRfY29tbWVudCBzdHJtX19cbiAgICB8IFNvbWUgXyAtPiBTdHJlYW0uanVuayBzdHJtX187IGNvbW1lbnQgc3RybV9fXG4gICAgfCBfIC0+IHJhaXNlIFN0cmVhbS5GYWlsdXJlXG4gIGluXG4gIGZ1biBpbnB1dCAtPiBTdHJlYW0uZnJvbSAoZnVuIF9jb3VudCAtPiBuZXh0X3Rva2VuIGlucHV0KVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgRGFtaWVuIERvbGlnZXosIHByb2pldCBQYXJhLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NyBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5bQEBAb2NhbWwud2FybmluZyBcIi0zMlwiXVxuXG5tb2R1bGUgdHlwZSBTZWVkZWRTID0gc2lnXG5cbiAgdHlwZSBrZXlcbiAgdHlwZSAhJ2EgdFxuICB2YWwgY3JlYXRlIDogP3JhbmRvbSAoKnRod2FydCB0b29scy9zeW5jX3N0ZGxpYl9kb2NzKikgOiBib29sIC0+IGludCAtPiAnYSB0XG4gIHZhbCBjbGVhciA6ICdhIHQgLT4gdW5pdFxuICB2YWwgcmVzZXQgOiAnYSB0IC0+IHVuaXRcbiAgdmFsIGNvcHkgOiAnYSB0IC0+ICdhIHRcbiAgdmFsIGFkZCA6ICdhIHQgLT4ga2V5IC0+ICdhIC0+IHVuaXRcbiAgdmFsIHJlbW92ZSA6ICdhIHQgLT4ga2V5IC0+IHVuaXRcbiAgdmFsIGZpbmQgOiAnYSB0IC0+IGtleSAtPiAnYVxuICB2YWwgZmluZF9vcHQgOiAnYSB0IC0+IGtleSAtPiAnYSBvcHRpb25cbiAgdmFsIGZpbmRfYWxsIDogJ2EgdCAtPiBrZXkgLT4gJ2EgbGlzdFxuICB2YWwgcmVwbGFjZSA6ICdhIHQgLT4ga2V5IC0+ICdhIC0+IHVuaXRcbiAgdmFsIG1lbSA6ICdhIHQgLT4ga2V5IC0+IGJvb2xcbiAgdmFsIGl0ZXIgOiAoa2V5IC0+ICdhIC0+IHVuaXQpIC0+ICdhIHQgLT4gdW5pdFxuICAgIFtAQGFsZXJ0IG9sZF9lcGhlbWVyb25fYXBpIFwiVGhpcyBmdW5jdGlvbiB3b24ndCBiZSBhdmFpbGFibGUgaW4gNS4wXCJdXG4gIHZhbCBmaWx0ZXJfbWFwX2lucGxhY2UgOiAoa2V5IC0+ICdhIC0+ICdhIG9wdGlvbikgLT4gJ2EgdCAtPiB1bml0XG4gICAgW0BAYWxlcnQgb2xkX2VwaGVtZXJvbl9hcGkgXCJUaGlzIGZ1bmN0aW9uIHdvbid0IGJlIGF2YWlsYWJsZSBpbiA1LjBcIl1cbiAgdmFsIGZvbGQgOiAoa2V5IC0+ICdhIC0+ICdiIC0+ICdiKSAtPiAnYSB0IC0+ICdiIC0+ICdiXG4gICAgW0BAYWxlcnQgb2xkX2VwaGVtZXJvbl9hcGkgXCJUaGlzIGZ1bmN0aW9uIHdvbid0IGJlIGF2YWlsYWJsZSBpbiA1LjBcIl1cbiAgdmFsIGxlbmd0aCA6ICdhIHQgLT4gaW50XG4gIHZhbCBzdGF0cyA6ICdhIHQgLT4gSGFzaHRibC5zdGF0aXN0aWNzXG4gIHZhbCB0b19zZXEgOiAnYSB0IC0+IChrZXkgKiAnYSkgU2VxLnRcbiAgICBbQEBhbGVydCBvbGRfZXBoZW1lcm9uX2FwaSBcIlRoaXMgZnVuY3Rpb24gd29uJ3QgYmUgYXZhaWxhYmxlIGluIDUuMFwiXVxuICB2YWwgdG9fc2VxX2tleXMgOiBfIHQgLT4ga2V5IFNlcS50XG4gICAgW0BAYWxlcnQgb2xkX2VwaGVtZXJvbl9hcGkgXCJUaGlzIGZ1bmN0aW9uIHdvbid0IGJlIGF2YWlsYWJsZSBpbiA1LjBcIl1cbiAgdmFsIHRvX3NlcV92YWx1ZXMgOiAnYSB0IC0+ICdhIFNlcS50XG4gICAgW0BAYWxlcnQgb2xkX2VwaGVtZXJvbl9hcGkgXCJUaGlzIGZ1bmN0aW9uIHdvbid0IGJlIGF2YWlsYWJsZSBpbiA1LjBcIl1cbiAgdmFsIGFkZF9zZXEgOiAnYSB0IC0+IChrZXkgKiAnYSkgU2VxLnQgLT4gdW5pdFxuICB2YWwgcmVwbGFjZV9zZXEgOiAnYSB0IC0+IChrZXkgKiAnYSkgU2VxLnQgLT4gdW5pdFxuICB2YWwgb2Zfc2VxIDogKGtleSAqICdhKSBTZXEudCAtPiAnYSB0XG4gIHZhbCBjbGVhbjogJ2EgdCAtPiB1bml0XG4gIHZhbCBzdGF0c19hbGl2ZTogJ2EgdCAtPiBIYXNodGJsLnN0YXRpc3RpY3NcbiAgICAoKiogc2FtZSBhcyB7IXN0YXRzfSBidXQgb25seSBjb3VudCB0aGUgYWxpdmUgYmluZGluZ3MgKilcbmVuZFxuXG5tb2R1bGUgdHlwZSBTID0gc2lnXG5cbiAgdHlwZSBrZXlcbiAgdHlwZSAhJ2EgdFxuICB2YWwgY3JlYXRlIDogaW50IC0+ICdhIHRcbiAgdmFsIGNsZWFyIDogJ2EgdCAtPiB1bml0XG4gIHZhbCByZXNldCA6ICdhIHQgLT4gdW5pdFxuICB2YWwgY29weSA6ICdhIHQgLT4gJ2EgdFxuICB2YWwgYWRkIDogJ2EgdCAtPiBrZXkgLT4gJ2EgLT4gdW5pdFxuICB2YWwgcmVtb3ZlIDogJ2EgdCAtPiBrZXkgLT4gdW5pdFxuICB2YWwgZmluZCA6ICdhIHQgLT4ga2V5IC0+ICdhXG4gIHZhbCBmaW5kX29wdCA6ICdhIHQgLT4ga2V5IC0+ICdhIG9wdGlvblxuICB2YWwgZmluZF9hbGwgOiAnYSB0IC0+IGtleSAtPiAnYSBsaXN0XG4gIHZhbCByZXBsYWNlIDogJ2EgdCAtPiBrZXkgLT4gJ2EgLT4gdW5pdFxuICB2YWwgbWVtIDogJ2EgdCAtPiBrZXkgLT4gYm9vbFxuICB2YWwgaXRlciA6IChrZXkgLT4gJ2EgLT4gdW5pdCkgLT4gJ2EgdCAtPiB1bml0XG4gICAgW0BAYWxlcnQgb2xkX2VwaGVtZXJvbl9hcGkgXCJUaGlzIGZ1bmN0aW9uIHdvbid0IGJlIGF2YWlsYWJsZSBpbiA1LjBcIl1cbiAgdmFsIGZpbHRlcl9tYXBfaW5wbGFjZSA6IChrZXkgLT4gJ2EgLT4gJ2Egb3B0aW9uKSAtPiAnYSB0IC0+IHVuaXRcbiAgICBbQEBhbGVydCBvbGRfZXBoZW1lcm9uX2FwaSBcIlRoaXMgZnVuY3Rpb24gd29uJ3QgYmUgYXZhaWxhYmxlIGluIDUuMFwiXVxuICB2YWwgZm9sZCA6IChrZXkgLT4gJ2EgLT4gJ2IgLT4gJ2IpIC0+ICdhIHQgLT4gJ2IgLT4gJ2JcbiAgICBbQEBhbGVydCBvbGRfZXBoZW1lcm9uX2FwaSBcIlRoaXMgZnVuY3Rpb24gd29uJ3QgYmUgYXZhaWxhYmxlIGluIDUuMFwiXVxuICB2YWwgbGVuZ3RoIDogJ2EgdCAtPiBpbnRcbiAgdmFsIHN0YXRzIDogJ2EgdCAtPiBIYXNodGJsLnN0YXRpc3RpY3NcbiAgdmFsIHRvX3NlcSA6ICdhIHQgLT4gKGtleSAqICdhKSBTZXEudFxuICAgIFtAQGFsZXJ0IG9sZF9lcGhlbWVyb25fYXBpIFwiVGhpcyBmdW5jdGlvbiB3b24ndCBiZSBhdmFpbGFibGUgaW4gNS4wXCJdXG4gIHZhbCB0b19zZXFfa2V5cyA6IF8gdCAtPiBrZXkgU2VxLnRcbiAgICBbQEBhbGVydCBvbGRfZXBoZW1lcm9uX2FwaSBcIlRoaXMgZnVuY3Rpb24gd29uJ3QgYmUgYXZhaWxhYmxlIGluIDUuMFwiXVxuICB2YWwgdG9fc2VxX3ZhbHVlcyA6ICdhIHQgLT4gJ2EgU2VxLnRcbiAgICBbQEBhbGVydCBvbGRfZXBoZW1lcm9uX2FwaSBcIlRoaXMgZnVuY3Rpb24gd29uJ3QgYmUgYXZhaWxhYmxlIGluIDUuMFwiXVxuICB2YWwgYWRkX3NlcSA6ICdhIHQgLT4gKGtleSAqICdhKSBTZXEudCAtPiB1bml0XG4gIHZhbCByZXBsYWNlX3NlcSA6ICdhIHQgLT4gKGtleSAqICdhKSBTZXEudCAtPiB1bml0XG4gIHZhbCBvZl9zZXEgOiAoa2V5ICogJ2EpIFNlcS50IC0+ICdhIHRcbiAgdmFsIGNsZWFuOiAnYSB0IC0+IHVuaXRcbiAgdmFsIHN0YXRzX2FsaXZlOiAnYSB0IC0+IEhhc2h0Ymwuc3RhdGlzdGljc1xuICAgICgqKiBzYW1lIGFzIHshc3RhdHN9IGJ1dCBvbmx5IGNvdW50IHRoZSBhbGl2ZSBiaW5kaW5ncyAqKVxuZW5kXG5cbm1vZHVsZSBHZW5IYXNoVGFibGUgPSBzdHJ1Y3RcblxuICB0eXBlIGVxdWFsID1cbiAgfCBFVHJ1ZSB8IEVGYWxzZVxuICB8IEVEZWFkICgqKiB0aGUgZ2FyYmFnZSBjb2xsZWN0b3IgcmVjbGFpbWVkIHRoZSBkYXRhICopXG5cbiAgbW9kdWxlIE1ha2VTZWVkZWQoSDogc2lnXG4gICAgdHlwZSB0XG4gICAgdHlwZSAnYSBjb250YWluZXJcbiAgICB2YWwgY3JlYXRlOiB0IC0+ICdhIC0+ICdhIGNvbnRhaW5lclxuICAgIHZhbCBoYXNoOiBpbnQgLT4gdCAtPiBpbnRcbiAgICB2YWwgZXF1YWw6ICdhIGNvbnRhaW5lciAtPiB0IC0+IGVxdWFsXG4gICAgdmFsIGdldF9kYXRhOiAnYSBjb250YWluZXIgLT4gJ2Egb3B0aW9uXG4gICAgdmFsIGdldF9rZXk6ICdhIGNvbnRhaW5lciAtPiB0IG9wdGlvblxuICAgIHZhbCBzZXRfa2V5X2RhdGE6ICdhIGNvbnRhaW5lciAtPiB0IC0+ICdhIC0+IHVuaXRcbiAgICB2YWwgY2hlY2tfa2V5OiAnYSBjb250YWluZXIgLT4gYm9vbFxuICBlbmQpIDogU2VlZGVkUyB3aXRoIHR5cGUga2V5ID0gSC50XG4gID0gc3RydWN0XG5cbiAgICB0eXBlICdhIHQgPVxuICAgICAgeyBtdXRhYmxlIHNpemU6IGludDsgICAgICAgICAgICAgICAgICAoKiBudW1iZXIgb2YgZW50cmllcyAqKVxuICAgICAgICBtdXRhYmxlIGRhdGE6ICdhIGJ1Y2tldGxpc3QgYXJyYXk7ICAoKiB0aGUgYnVja2V0cyAqKVxuICAgICAgICBzZWVkOiBpbnQ7ICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBmb3IgcmFuZG9taXphdGlvbiAqKVxuICAgICAgICBpbml0aWFsX3NpemU6IGludDsgICAgICAgICAgICAgICAgICAoKiBpbml0aWFsIGFycmF5IHNpemUgKilcbiAgICAgIH1cblxuICAgIGFuZCAnYSBidWNrZXRsaXN0ID1cbiAgICB8IEVtcHR5XG4gICAgfCBDb25zIG9mIGludCAoKiBoYXNoIG9mIHRoZSBrZXkgKikgKiAnYSBILmNvbnRhaW5lciAqICdhIGJ1Y2tldGxpc3RcblxuICAgICgqKiB0aGUgaGFzaCBvZiB0aGUga2V5IGlzIGtlcHQgaW4gb3JkZXIgdG8gdGVzdCB0aGUgZXF1YWxpdHkgb2YgdGhlIGhhc2hcbiAgICAgIGJlZm9yZSB0aGUga2V5LiBTYW1lIHJlYXNvbiBhcyBmb3IgV2Vhay5NYWtlICopXG5cbiAgICB0eXBlIGtleSA9IEgudFxuXG4gICAgbGV0IHJlYyBwb3dlcl8yX2Fib3ZlIHggbiA9XG4gICAgICBpZiB4ID49IG4gdGhlbiB4XG4gICAgICBlbHNlIGlmIHggKiAyID4gU3lzLm1heF9hcnJheV9sZW5ndGggdGhlbiB4XG4gICAgICBlbHNlIHBvd2VyXzJfYWJvdmUgKHggKiAyKSBuXG5cbiAgICBsZXQgcHJuZyA9IGxhenkgKFJhbmRvbS5TdGF0ZS5tYWtlX3NlbGZfaW5pdCgpKVxuXG4gICAgbGV0IGNyZWF0ZSA/KHJhbmRvbSA9IChIYXNodGJsLmlzX3JhbmRvbWl6ZWQgKCkpKSBpbml0aWFsX3NpemUgPVxuICAgICAgbGV0IHMgPSBwb3dlcl8yX2Fib3ZlIDE2IGluaXRpYWxfc2l6ZSBpblxuICAgICAgbGV0IHNlZWQgPSBpZiByYW5kb20gdGhlbiBSYW5kb20uU3RhdGUuYml0cyAoTGF6eS5mb3JjZSBwcm5nKSBlbHNlIDAgaW5cbiAgICAgIHsgaW5pdGlhbF9zaXplID0gczsgc2l6ZSA9IDA7IHNlZWQgPSBzZWVkOyBkYXRhID0gQXJyYXkubWFrZSBzIEVtcHR5IH1cblxuICAgIGxldCBjbGVhciBoID1cbiAgICAgIGguc2l6ZSA8LSAwO1xuICAgICAgbGV0IGxlbiA9IEFycmF5Lmxlbmd0aCBoLmRhdGEgaW5cbiAgICAgIGZvciBpID0gMCB0byBsZW4gLSAxIGRvXG4gICAgICAgIGguZGF0YS4oaSkgPC0gRW1wdHlcbiAgICAgIGRvbmVcblxuICAgIGxldCByZXNldCBoID1cbiAgICAgIGxldCBsZW4gPSBBcnJheS5sZW5ndGggaC5kYXRhIGluXG4gICAgICBpZiBsZW4gPSBoLmluaXRpYWxfc2l6ZSB0aGVuXG4gICAgICAgIGNsZWFyIGhcbiAgICAgIGVsc2UgYmVnaW5cbiAgICAgICAgaC5zaXplIDwtIDA7XG4gICAgICAgIGguZGF0YSA8LSBBcnJheS5tYWtlIGguaW5pdGlhbF9zaXplIEVtcHR5XG4gICAgICBlbmRcblxuICAgIGxldCBjb3B5IGggPSB7IGggd2l0aCBkYXRhID0gQXJyYXkuY29weSBoLmRhdGEgfVxuXG4gICAgbGV0IGtleV9pbmRleCBoIGhrZXkgPVxuICAgICAgaGtleSBsYW5kIChBcnJheS5sZW5ndGggaC5kYXRhIC0gMSlcblxuICAgIGxldCBjbGVhbiBoID1cbiAgICAgIGxldCByZWMgZG9fYnVja2V0ID0gZnVuY3Rpb25cbiAgICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgICAgRW1wdHlcbiAgICAgICAgfCBDb25zKF8sIGMsIHJlc3QpIHdoZW4gbm90IChILmNoZWNrX2tleSBjKSAtPlxuICAgICAgICAgICAgaC5zaXplIDwtIGguc2l6ZSAtIDE7XG4gICAgICAgICAgICBkb19idWNrZXQgcmVzdFxuICAgICAgICB8IENvbnMoaGtleSwgYywgcmVzdCkgLT5cbiAgICAgICAgICAgIENvbnMoaGtleSwgYywgZG9fYnVja2V0IHJlc3QpXG4gICAgICBpblxuICAgICAgbGV0IGQgPSBoLmRhdGEgaW5cbiAgICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggZCAtIDEgZG9cbiAgICAgICAgZC4oaSkgPC0gZG9fYnVja2V0IGQuKGkpXG4gICAgICBkb25lXG5cbiAgICAoKiogcmVzaXplIGlzIHRoZSBvbmx5IGZ1bmN0aW9uIHRvIGRvIHRoZSBhY3R1YWwgY2xlYW5pbmcgb2YgZGVhZCBrZXlzXG4gICAgICAgIChyZW1vdmUgZG9lcyBpdCBqdXN0IGJlY2F1c2UgaXQgY291bGQpLlxuXG4gICAgICAgIFRoZSBnb2FsIGlzIHRvOlxuXG4gICAgICAgIC0gbm90IHJlc2l6ZSBpbmZpbml0ZWx5IHdoZW4gdGhlIGFjdHVhbCBudW1iZXIgb2YgYWxpdmUga2V5cyBpc1xuICAgICAgICBib3VuZGVkIGJ1dCBrZXlzIGFyZSBjb250aW51b3VzbHkgYWRkZWQuIFRoYXQgd291bGQgaGFwcGVuIGlmXG4gICAgICAgIHRoaXMgZnVuY3Rpb24gYWx3YXlzIHJlc2l6ZS5cbiAgICAgICAgLSBub3QgY2FsbCB0aGlzIGZ1bmN0aW9uIGFmdGVyIGVhY2ggYWRkaXRpb24sIHRoYXQgd291bGQgaGFwcGVuIGlmIHRoaXNcbiAgICAgICAgZnVuY3Rpb24gZG9uJ3QgcmVzaXplIGV2ZW4gd2hlbiBvbmx5IG9uZSBrZXkgaXMgZGVhZC5cblxuICAgICAgICBTbyB0aGUgYWxnb3JpdGhtOlxuICAgICAgICAtIGNsZWFuIHRoZSBrZXlzIGJlZm9yZSByZXNpemluZ1xuICAgICAgICAtIGlmIHRoZSBudW1iZXIgb2YgcmVtYWluaW5nIGtleXMgaXMgbGVzcyB0aGFuIGhhbGYgdGhlIHNpemUgb2YgdGhlXG4gICAgICAgIGFycmF5LCBkb24ndCByZXNpemUuXG4gICAgICAgIC0gaWYgaXQgaXMgbW9yZSwgcmVzaXplLlxuXG4gICAgICAgIFRoZSBzZWNvbmQgcHJvYmxlbSByZW1haW5zIGlmIHRoZSB0YWJsZSByZWFjaGVzIHshU3lzLm1heF9hcnJheV9sZW5ndGh9LlxuXG4gICAgKilcbiAgICBsZXQgcmVzaXplIGggPVxuICAgICAgbGV0IG9kYXRhID0gaC5kYXRhIGluXG4gICAgICBsZXQgb3NpemUgPSBBcnJheS5sZW5ndGggb2RhdGEgaW5cbiAgICAgIGxldCBuc2l6ZSA9IG9zaXplICogMiBpblxuICAgICAgY2xlYW4gaDtcbiAgICAgIGlmIG5zaXplIDwgU3lzLm1heF9hcnJheV9sZW5ndGggJiYgaC5zaXplID49IG9zaXplIGxzciAxIHRoZW4gYmVnaW5cbiAgICAgICAgbGV0IG5kYXRhID0gQXJyYXkubWFrZSBuc2l6ZSBFbXB0eSBpblxuICAgICAgICBoLmRhdGEgPC0gbmRhdGE7ICAgICAgICgqIHNvIHRoYXQga2V5X2luZGV4IHNlZXMgdGhlIG5ldyBidWNrZXQgY291bnQgKilcbiAgICAgICAgbGV0IHJlYyBpbnNlcnRfYnVja2V0ID0gZnVuY3Rpb25cbiAgICAgICAgICAgIEVtcHR5IC0+ICgpXG4gICAgICAgICAgfCBDb25zKGhrZXksIGRhdGEsIHJlc3QpIC0+XG4gICAgICAgICAgICAgIGluc2VydF9idWNrZXQgcmVzdDsgKCogcHJlc2VydmUgb3JpZ2luYWwgb3JkZXIgb2YgZWxlbWVudHMgKilcbiAgICAgICAgICAgICAgbGV0IG5pZHggPSBrZXlfaW5kZXggaCBoa2V5IGluXG4gICAgICAgICAgICAgIG5kYXRhLihuaWR4KSA8LSBDb25zKGhrZXksIGRhdGEsIG5kYXRhLihuaWR4KSkgaW5cbiAgICAgICAgZm9yIGkgPSAwIHRvIG9zaXplIC0gMSBkb1xuICAgICAgICAgIGluc2VydF9idWNrZXQgb2RhdGEuKGkpXG4gICAgICAgIGRvbmVcbiAgICAgIGVuZFxuXG4gICAgbGV0IGFkZCBoIGtleSBpbmZvID1cbiAgICAgIGxldCBoa2V5ID0gSC5oYXNoIGguc2VlZCBrZXkgaW5cbiAgICAgIGxldCBpID0ga2V5X2luZGV4IGggaGtleSBpblxuICAgICAgbGV0IGNvbnRhaW5lciA9IEguY3JlYXRlIGtleSBpbmZvIGluXG4gICAgICBsZXQgYnVja2V0ID0gQ29ucyhoa2V5LCBjb250YWluZXIsIGguZGF0YS4oaSkpIGluXG4gICAgICBoLmRhdGEuKGkpIDwtIGJ1Y2tldDtcbiAgICAgIGguc2l6ZSA8LSBoLnNpemUgKyAxO1xuICAgICAgaWYgaC5zaXplID4gQXJyYXkubGVuZ3RoIGguZGF0YSBsc2wgMSB0aGVuIHJlc2l6ZSBoXG5cbiAgICBsZXQgcmVtb3ZlIGgga2V5ID1cbiAgICAgIGxldCBoa2V5ID0gSC5oYXNoIGguc2VlZCBrZXkgaW5cbiAgICAgIGxldCByZWMgcmVtb3ZlX2J1Y2tldCA9IGZ1bmN0aW9uXG4gICAgICAgIHwgRW1wdHkgLT4gRW1wdHlcbiAgICAgICAgfCBDb25zKGhrLCBjLCBuZXh0KSB3aGVuIGhrZXkgPSBoayAtPlxuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggSC5lcXVhbCBjIGtleSB3aXRoXG4gICAgICAgICAgICB8IEVUcnVlIC0+IGguc2l6ZSA8LSBoLnNpemUgLSAxOyBuZXh0XG4gICAgICAgICAgICB8IEVGYWxzZSAtPiBDb25zKGhrLCBjLCByZW1vdmVfYnVja2V0IG5leHQpXG4gICAgICAgICAgICB8IEVEZWFkIC0+XG4gICAgICAgICAgICAgICAgKCogVGhlIGRlYWQga2V5IGlzIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZC4gSXQgaXMgYWNjZXB0YWJsZVxuICAgICAgICAgICAgICAgICAgICBmb3IgdGhpcyBmdW5jdGlvbiBzaW5jZSBpdCBhbHJlYWR5IHJlbW92ZXMgYSBiaW5kaW5nICopXG4gICAgICAgICAgICAgICAgaC5zaXplIDwtIGguc2l6ZSAtIDE7XG4gICAgICAgICAgICAgICAgcmVtb3ZlX2J1Y2tldCBuZXh0XG4gICAgICAgICAgICBlbmRcbiAgICAgICAgfCBDb25zKGhrLGMsbmV4dCkgLT4gQ29ucyhoaywgYywgcmVtb3ZlX2J1Y2tldCBuZXh0KSBpblxuICAgICAgbGV0IGkgPSBrZXlfaW5kZXggaCBoa2V5IGluXG4gICAgICBoLmRhdGEuKGkpIDwtIHJlbW92ZV9idWNrZXQgaC5kYXRhLihpKVxuXG4gICAgKCoqIHshZmluZH0gZG9uJ3QgcmVtb3ZlIGRlYWQga2V5cyBiZWNhdXNlIGl0IHdvdWxkIGJlIHN1cnByaXNpbmcgZm9yXG4gICAgICAgIHRoZSB1c2VyIHRoYXQgYSByZWFkLW9ubHkgZnVuY3Rpb24gbXV0YXRlcyB0aGUgc3RhdGUgKGVnLiBjb25jdXJyZW50XG4gICAgICAgIGFjY2VzcykuIFNhbWUgZm9yIHshaXRlcn0sIHshZm9sZH0sIHshbWVtfS5cbiAgICAqKVxuICAgIGxldCByZWMgZmluZF9yZWMga2V5IGhrZXkgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgIHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBDb25zKGhrLCBjLCByZXN0KSB3aGVuIGhrZXkgPSBoayAgLT5cbiAgICAgICAgICBiZWdpbiBtYXRjaCBILmVxdWFsIGMga2V5IHdpdGhcbiAgICAgICAgICB8IEVUcnVlIC0+XG4gICAgICAgICAgICAgIGJlZ2luIG1hdGNoIEguZ2V0X2RhdGEgYyB3aXRoXG4gICAgICAgICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgICAgICAgICAgKCogVGhpcyBjYXNlIGlzIG5vdCBpbXBvc3NpYmxlIGJlY2F1c2UgdGhlIGdjIGNhbiBydW4gYmV0d2VlblxuICAgICAgICAgICAgICAgICAgICAgIEguZXF1YWwgYW5kIEguZ2V0X2RhdGEgKilcbiAgICAgICAgICAgICAgICAgIGZpbmRfcmVjIGtleSBoa2V5IHJlc3RcbiAgICAgICAgICAgICAgfCBTb21lIGQgLT4gZFxuICAgICAgICAgICAgICBlbmRcbiAgICAgICAgICB8IEVGYWxzZSAtPiBmaW5kX3JlYyBrZXkgaGtleSByZXN0XG4gICAgICAgICAgfCBFRGVhZCAtPlxuICAgICAgICAgICAgICBmaW5kX3JlYyBrZXkgaGtleSByZXN0XG4gICAgICAgICAgZW5kXG4gICAgICB8IENvbnMoXywgXywgcmVzdCkgLT5cbiAgICAgICAgICBmaW5kX3JlYyBrZXkgaGtleSByZXN0XG5cbiAgICBsZXQgZmluZCBoIGtleSA9XG4gICAgICBsZXQgaGtleSA9IEguaGFzaCBoLnNlZWQga2V5IGluXG4gICAgICAoKiBUT0RPIGlubGluZSAzIGl0ZXJhdGlvbnMgKilcbiAgICAgIGZpbmRfcmVjIGtleSBoa2V5IChoLmRhdGEuKGtleV9pbmRleCBoIGhrZXkpKVxuXG4gICAgbGV0IHJlYyBmaW5kX3JlY19vcHQga2V5IGhrZXkgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgIE5vbmVcbiAgICAgIHwgQ29ucyhoaywgYywgcmVzdCkgd2hlbiBoa2V5ID0gaGsgIC0+XG4gICAgICAgICAgYmVnaW4gbWF0Y2ggSC5lcXVhbCBjIGtleSB3aXRoXG4gICAgICAgICAgfCBFVHJ1ZSAtPlxuICAgICAgICAgICAgICBiZWdpbiBtYXRjaCBILmdldF9kYXRhIGMgd2l0aFxuICAgICAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgICAgICAgICgqIFRoaXMgY2FzZSBpcyBub3QgaW1wb3NzaWJsZSBiZWNhdXNlIHRoZSBnYyBjYW4gcnVuIGJldHdlZW5cbiAgICAgICAgICAgICAgICAgICAgICBILmVxdWFsIGFuZCBILmdldF9kYXRhICopXG4gICAgICAgICAgICAgICAgICBmaW5kX3JlY19vcHQga2V5IGhrZXkgcmVzdFxuICAgICAgICAgICAgICB8IFNvbWUgXyBhcyBkIC0+IGRcbiAgICAgICAgICAgICAgZW5kXG4gICAgICAgICAgfCBFRmFsc2UgLT4gZmluZF9yZWNfb3B0IGtleSBoa2V5IHJlc3RcbiAgICAgICAgICB8IEVEZWFkIC0+XG4gICAgICAgICAgICAgIGZpbmRfcmVjX29wdCBrZXkgaGtleSByZXN0XG4gICAgICAgICAgZW5kXG4gICAgICB8IENvbnMoXywgXywgcmVzdCkgLT5cbiAgICAgICAgICBmaW5kX3JlY19vcHQga2V5IGhrZXkgcmVzdFxuXG4gICAgbGV0IGZpbmRfb3B0IGgga2V5ID1cbiAgICAgIGxldCBoa2V5ID0gSC5oYXNoIGguc2VlZCBrZXkgaW5cbiAgICAgICgqIFRPRE8gaW5saW5lIDMgaXRlcmF0aW9ucyAqKVxuICAgICAgZmluZF9yZWNfb3B0IGtleSBoa2V5IChoLmRhdGEuKGtleV9pbmRleCBoIGhrZXkpKVxuXG4gICAgbGV0IGZpbmRfYWxsIGgga2V5ID1cbiAgICAgIGxldCBoa2V5ID0gSC5oYXNoIGguc2VlZCBrZXkgaW5cbiAgICAgIGxldCByZWMgZmluZF9pbl9idWNrZXQgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiBbXVxuICAgICAgfCBDb25zKGhrLCBjLCByZXN0KSB3aGVuIGhrZXkgPSBoayAgLT5cbiAgICAgICAgICBiZWdpbiBtYXRjaCBILmVxdWFsIGMga2V5IHdpdGhcbiAgICAgICAgICB8IEVUcnVlIC0+IGJlZ2luIG1hdGNoIEguZ2V0X2RhdGEgYyB3aXRoXG4gICAgICAgICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgICAgICAgICAgZmluZF9pbl9idWNrZXQgcmVzdFxuICAgICAgICAgICAgICB8IFNvbWUgZCAtPiBkOjpmaW5kX2luX2J1Y2tldCByZXN0XG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICB8IEVGYWxzZSAtPiBmaW5kX2luX2J1Y2tldCByZXN0XG4gICAgICAgICAgfCBFRGVhZCAtPlxuICAgICAgICAgICAgICBmaW5kX2luX2J1Y2tldCByZXN0XG4gICAgICAgICAgZW5kXG4gICAgICB8IENvbnMoXywgXywgcmVzdCkgLT5cbiAgICAgICAgICBmaW5kX2luX2J1Y2tldCByZXN0IGluXG4gICAgICBmaW5kX2luX2J1Y2tldCBoLmRhdGEuKGtleV9pbmRleCBoIGhrZXkpXG5cblxuICAgIGxldCByZXBsYWNlIGgga2V5IGluZm8gPVxuICAgICAgbGV0IGhrZXkgPSBILmhhc2ggaC5zZWVkIGtleSBpblxuICAgICAgbGV0IHJlYyByZXBsYWNlX2J1Y2tldCA9IGZ1bmN0aW9uXG4gICAgICAgIHwgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICAgIHwgQ29ucyhoaywgYywgbmV4dCkgd2hlbiBoa2V5ID0gaGsgLT5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIEguZXF1YWwgYyBrZXkgd2l0aFxuICAgICAgICAgICAgfCBFVHJ1ZSAtPiBILnNldF9rZXlfZGF0YSBjIGtleSBpbmZvXG4gICAgICAgICAgICB8IEVGYWxzZSB8IEVEZWFkIC0+IHJlcGxhY2VfYnVja2V0IG5leHRcbiAgICAgICAgICAgIGVuZFxuICAgICAgICB8IENvbnMoXyxfLG5leHQpIC0+IHJlcGxhY2VfYnVja2V0IG5leHRcbiAgICAgIGluXG4gICAgICBsZXQgaSA9IGtleV9pbmRleCBoIGhrZXkgaW5cbiAgICAgIGxldCBsID0gaC5kYXRhLihpKSBpblxuICAgICAgdHJ5XG4gICAgICAgIHJlcGxhY2VfYnVja2V0IGxcbiAgICAgIHdpdGggTm90X2ZvdW5kIC0+XG4gICAgICAgIGxldCBjb250YWluZXIgPSBILmNyZWF0ZSBrZXkgaW5mbyBpblxuICAgICAgICBoLmRhdGEuKGkpIDwtIENvbnMoaGtleSwgY29udGFpbmVyLCBsKTtcbiAgICAgICAgaC5zaXplIDwtIGguc2l6ZSArIDE7XG4gICAgICAgIGlmIGguc2l6ZSA+IEFycmF5Lmxlbmd0aCBoLmRhdGEgbHNsIDEgdGhlbiByZXNpemUgaFxuXG4gICAgbGV0IG1lbSBoIGtleSA9XG4gICAgICBsZXQgaGtleSA9IEguaGFzaCBoLnNlZWQga2V5IGluXG4gICAgICBsZXQgcmVjIG1lbV9pbl9idWNrZXQgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgIGZhbHNlXG4gICAgICB8IENvbnMoaGssIGMsIHJlc3QpIHdoZW4gaGsgPSBoa2V5IC0+XG4gICAgICAgICAgYmVnaW4gbWF0Y2ggSC5lcXVhbCBjIGtleSB3aXRoXG4gICAgICAgICAgfCBFVHJ1ZSAtPiB0cnVlXG4gICAgICAgICAgfCBFRmFsc2UgfCBFRGVhZCAtPiBtZW1faW5fYnVja2V0IHJlc3RcbiAgICAgICAgICBlbmRcbiAgICAgIHwgQ29ucyhfaGssIF9jLCByZXN0KSAtPiBtZW1faW5fYnVja2V0IHJlc3QgaW5cbiAgICAgIG1lbV9pbl9idWNrZXQgaC5kYXRhLihrZXlfaW5kZXggaCBoa2V5KVxuXG4gICAgbGV0IGl0ZXIgZiBoID1cbiAgICAgIGxldCByZWMgZG9fYnVja2V0ID0gZnVuY3Rpb25cbiAgICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgICAgKClcbiAgICAgICAgfCBDb25zKF8sIGMsIHJlc3QpIC0+XG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBILmdldF9rZXkgYywgSC5nZXRfZGF0YSBjIHdpdGhcbiAgICAgICAgICAgIHwgTm9uZSwgXyB8IF8sIE5vbmUgLT4gKClcbiAgICAgICAgICAgIHwgU29tZSBrLCBTb21lIGQgLT4gZiBrIGRcbiAgICAgICAgICAgIGVuZDsgZG9fYnVja2V0IHJlc3QgaW5cbiAgICAgIGxldCBkID0gaC5kYXRhIGluXG4gICAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGQgLSAxIGRvXG4gICAgICAgIGRvX2J1Y2tldCBkLihpKVxuICAgICAgZG9uZVxuXG4gICAgbGV0IGZvbGQgZiBoIGluaXQgPVxuICAgICAgbGV0IHJlYyBkb19idWNrZXQgYiBhY2N1ID1cbiAgICAgICAgbWF0Y2ggYiB3aXRoXG4gICAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICAgIGFjY3VcbiAgICAgICAgfCBDb25zKF8sIGMsIHJlc3QpIC0+XG4gICAgICAgICAgICBsZXQgYWNjdSA9IGJlZ2luIG1hdGNoIEguZ2V0X2tleSBjLCBILmdldF9kYXRhIGMgd2l0aFxuICAgICAgICAgICAgICB8IE5vbmUsIF8gfCBfLCBOb25lIC0+IGFjY3VcbiAgICAgICAgICAgICAgfCBTb21lIGssIFNvbWUgZCAtPiBmIGsgZCBhY2N1XG4gICAgICAgICAgICBlbmQgaW5cbiAgICAgICAgICAgIGRvX2J1Y2tldCByZXN0IGFjY3UgIGluXG4gICAgICBsZXQgZCA9IGguZGF0YSBpblxuICAgICAgbGV0IGFjY3UgPSByZWYgaW5pdCBpblxuICAgICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCBkIC0gMSBkb1xuICAgICAgICBhY2N1IDo9IGRvX2J1Y2tldCBkLihpKSAhYWNjdVxuICAgICAgZG9uZTtcbiAgICAgICFhY2N1XG5cbiAgICBsZXQgZmlsdGVyX21hcF9pbnBsYWNlIGYgaCA9XG4gICAgICBsZXQgcmVjIGRvX2J1Y2tldCA9IGZ1bmN0aW9uXG4gICAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICAgIEVtcHR5XG4gICAgICAgIHwgQ29ucyhoaywgYywgcmVzdCkgLT5cbiAgICAgICAgICAgIG1hdGNoIEguZ2V0X2tleSBjLCBILmdldF9kYXRhIGMgd2l0aFxuICAgICAgICAgICAgfCBOb25lLCBfIHwgXywgTm9uZSAtPlxuICAgICAgICAgICAgICAgIGRvX2J1Y2tldCByZXN0XG4gICAgICAgICAgICB8IFNvbWUgaywgU29tZSBkIC0+XG4gICAgICAgICAgICAgICAgbWF0Y2ggZiBrIGQgd2l0aFxuICAgICAgICAgICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgICAgICAgICAgICBkb19idWNrZXQgcmVzdFxuICAgICAgICAgICAgICAgIHwgU29tZSBuZXdfZCAtPlxuICAgICAgICAgICAgICAgICAgICBILnNldF9rZXlfZGF0YSBjIGsgbmV3X2Q7XG4gICAgICAgICAgICAgICAgICAgIENvbnMoaGssIGMsIGRvX2J1Y2tldCByZXN0KVxuICAgICAgaW5cbiAgICAgIGxldCBkID0gaC5kYXRhIGluXG4gICAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGQgLSAxIGRvXG4gICAgICAgIGQuKGkpIDwtIGRvX2J1Y2tldCBkLihpKVxuICAgICAgZG9uZVxuXG4gICAgbGV0IGxlbmd0aCBoID0gaC5zaXplXG5cbiAgICBsZXQgcmVjIGJ1Y2tldF9sZW5ndGggYWNjdSA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+IGFjY3VcbiAgICAgIHwgQ29ucyhfLCBfLCByZXN0KSAtPiBidWNrZXRfbGVuZ3RoIChhY2N1ICsgMSkgcmVzdFxuXG4gICAgbGV0IHN0YXRzIGggPVxuICAgICAgbGV0IG1ibCA9XG4gICAgICAgIEFycmF5LmZvbGRfbGVmdCAoZnVuIG0gYiAtPiBJbnQubWF4IG0gKGJ1Y2tldF9sZW5ndGggMCBiKSkgMCBoLmRhdGEgaW5cbiAgICAgIGxldCBoaXN0byA9IEFycmF5Lm1ha2UgKG1ibCArIDEpIDAgaW5cbiAgICAgIEFycmF5Lml0ZXJcbiAgICAgICAgKGZ1biBiIC0+XG4gICAgICAgICAgIGxldCBsID0gYnVja2V0X2xlbmd0aCAwIGIgaW5cbiAgICAgICAgICAgaGlzdG8uKGwpIDwtIGhpc3RvLihsKSArIDEpXG4gICAgICAgIGguZGF0YTtcbiAgICAgIHsgSGFzaHRibC5udW1fYmluZGluZ3MgPSBoLnNpemU7XG4gICAgICAgIG51bV9idWNrZXRzID0gQXJyYXkubGVuZ3RoIGguZGF0YTtcbiAgICAgICAgbWF4X2J1Y2tldF9sZW5ndGggPSBtYmw7XG4gICAgICAgIGJ1Y2tldF9oaXN0b2dyYW0gPSBoaXN0byB9XG5cbiAgICBsZXQgcmVjIGJ1Y2tldF9sZW5ndGhfYWxpdmUgYWNjdSA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+IGFjY3VcbiAgICAgIHwgQ29ucyhfLCBjLCByZXN0KSB3aGVuIEguY2hlY2tfa2V5IGMgLT5cbiAgICAgICAgICBidWNrZXRfbGVuZ3RoX2FsaXZlIChhY2N1ICsgMSkgcmVzdFxuICAgICAgfCBDb25zKF8sIF8sIHJlc3QpIC0+IGJ1Y2tldF9sZW5ndGhfYWxpdmUgYWNjdSByZXN0XG5cbiAgICBsZXQgc3RhdHNfYWxpdmUgaCA9XG4gICAgICBsZXQgc2l6ZSA9IHJlZiAwIGluXG4gICAgICBsZXQgbWJsID1cbiAgICAgICAgQXJyYXkuZm9sZF9sZWZ0XG4gICAgICAgICAgKGZ1biBtIGIgLT4gSW50Lm1heCBtIChidWNrZXRfbGVuZ3RoX2FsaXZlIDAgYikpIDAgaC5kYXRhXG4gICAgICBpblxuICAgICAgbGV0IGhpc3RvID0gQXJyYXkubWFrZSAobWJsICsgMSkgMCBpblxuICAgICAgQXJyYXkuaXRlclxuICAgICAgICAoZnVuIGIgLT5cbiAgICAgICAgICAgbGV0IGwgPSBidWNrZXRfbGVuZ3RoX2FsaXZlIDAgYiBpblxuICAgICAgICAgICBzaXplIDo9ICFzaXplICsgbDtcbiAgICAgICAgICAgaGlzdG8uKGwpIDwtIGhpc3RvLihsKSArIDEpXG4gICAgICAgIGguZGF0YTtcbiAgICAgIHsgSGFzaHRibC5udW1fYmluZGluZ3MgPSAhc2l6ZTtcbiAgICAgICAgbnVtX2J1Y2tldHMgPSBBcnJheS5sZW5ndGggaC5kYXRhO1xuICAgICAgICBtYXhfYnVja2V0X2xlbmd0aCA9IG1ibDtcbiAgICAgICAgYnVja2V0X2hpc3RvZ3JhbSA9IGhpc3RvIH1cblxuICAgIGxldCB0b19zZXEgdGJsID1cbiAgICAgICgqIGNhcHR1cmUgY3VycmVudCBhcnJheSwgc28gdGhhdCBldmVuIGlmIHRoZSB0YWJsZSBpcyByZXNpemVkIHdlXG4gICAgICAgICBrZWVwIGl0ZXJhdGluZyBvbiB0aGUgc2FtZSBhcnJheSAqKVxuICAgICAgbGV0IHRibF9kYXRhID0gdGJsLmRhdGEgaW5cbiAgICAgICgqIHN0YXRlOiBpbmRleCAqIG5leHQgYnVja2V0IHRvIHRyYXZlcnNlICopXG4gICAgICBsZXQgcmVjIGF1eCBpIGJ1Y2sgKCkgPSBtYXRjaCBidWNrIHdpdGhcbiAgICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgICAgaWYgaSA9IEFycmF5Lmxlbmd0aCB0YmxfZGF0YVxuICAgICAgICAgICAgdGhlbiBTZXEuTmlsXG4gICAgICAgICAgICBlbHNlIGF1eChpKzEpIHRibF9kYXRhLihpKSAoKVxuICAgICAgICB8IENvbnMgKF8sIGMsIG5leHQpIC0+XG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBILmdldF9rZXkgYywgSC5nZXRfZGF0YSBjIHdpdGhcbiAgICAgICAgICAgICAgfCBOb25lLCBfIHwgXywgTm9uZSAtPiBhdXggaSBuZXh0ICgpXG4gICAgICAgICAgICAgIHwgU29tZSBrZXksIFNvbWUgZGF0YSAtPlxuICAgICAgICAgICAgICAgICAgU2VxLkNvbnMgKChrZXksIGRhdGEpLCBhdXggaSBuZXh0KVxuICAgICAgICAgICAgZW5kXG4gICAgICBpblxuICAgICAgYXV4IDAgRW1wdHlcblxuICAgIGxldCB0b19zZXFfa2V5cyBtID0gU2VxLm1hcCBmc3QgKHRvX3NlcSBtKVxuXG4gICAgbGV0IHRvX3NlcV92YWx1ZXMgbSA9IFNlcS5tYXAgc25kICh0b19zZXEgbSlcblxuICAgIGxldCBhZGRfc2VxIHRibCBpID1cbiAgICAgIFNlcS5pdGVyIChmdW4gKGssdikgLT4gYWRkIHRibCBrIHYpIGlcblxuICAgIGxldCByZXBsYWNlX3NlcSB0YmwgaSA9XG4gICAgICBTZXEuaXRlciAoZnVuIChrLHYpIC0+IHJlcGxhY2UgdGJsIGsgdikgaVxuXG4gICAgbGV0IG9mX3NlcSBpID1cbiAgICAgIGxldCB0YmwgPSBjcmVhdGUgMTYgaW5cbiAgICAgIHJlcGxhY2Vfc2VxIHRibCBpO1xuICAgICAgdGJsXG5cbiAgZW5kXG5lbmRcblxubW9kdWxlIE9iakVwaCA9IE9iai5FcGhlbWVyb25cblxubGV0IF9vYmpfb3B0IDogT2JqLnQgb3B0aW9uIC0+ICdhIG9wdGlvbiA9IGZ1biB4IC0+XG4gIG1hdGNoIHggd2l0aFxuICB8IE5vbmUgLT4geFxuICB8IFNvbWUgdiAtPiBTb21lIChPYmoub2JqIHYpXG5cbigqKiBUaGUgcHJldmlvdXMgZnVuY3Rpb24gaXMgdHlwZWQgc28gdGhpcyBvbmUgaXMgYWxzbyBjb3JyZWN0ICopXG5sZXQgb2JqX29wdCA6IE9iai50IG9wdGlvbiAtPiAnYSBvcHRpb24gPSBmdW4geCAtPiBPYmoubWFnaWMgeFxuXG5cbm1vZHVsZSBLMSA9IHN0cnVjdFxuICB0eXBlICgnaywnZCkgdCA9IE9iakVwaC50XG5cbiAgbGV0IGNyZWF0ZSAoKSA6ICgnaywnZCkgdCA9IE9iakVwaC5jcmVhdGUgMVxuXG4gIGxldCBnZXRfa2V5ICh0OignaywnZCkgdCkgOiAnayBvcHRpb24gPSBvYmpfb3B0IChPYmpFcGguZ2V0X2tleSB0IDApXG4gIGxldCBnZXRfa2V5X2NvcHkgKHQ6KCdrLCdkKSB0KSA6ICdrIG9wdGlvbiA9IG9ial9vcHQgKE9iakVwaC5nZXRfa2V5X2NvcHkgdCAwKVxuICBsZXQgc2V0X2tleSAodDooJ2ssJ2QpIHQpIChrOidrKSA6IHVuaXQgPSBPYmpFcGguc2V0X2tleSB0IDAgKE9iai5yZXByIGspXG4gIGxldCB1bnNldF9rZXkgKHQ6KCdrLCdkKSB0KSA6IHVuaXQgPSBPYmpFcGgudW5zZXRfa2V5IHQgMFxuICBsZXQgY2hlY2tfa2V5ICh0OignaywnZCkgdCkgOiBib29sID0gT2JqRXBoLmNoZWNrX2tleSB0IDBcblxuICBsZXQgYmxpdF9rZXkgKHQxOignaywnZCkgdCkgKHQyOignaywnZCkgdCk6IHVuaXQgPVxuICAgIE9iakVwaC5ibGl0X2tleSB0MSAwIHQyIDAgMVxuXG4gIGxldCBnZXRfZGF0YSAodDooJ2ssJ2QpIHQpIDogJ2Qgb3B0aW9uID0gb2JqX29wdCAoT2JqRXBoLmdldF9kYXRhIHQpXG4gIGxldCBnZXRfZGF0YV9jb3B5ICh0OignaywnZCkgdCkgOiAnZCBvcHRpb24gPSBvYmpfb3B0IChPYmpFcGguZ2V0X2RhdGFfY29weSB0KVxuICBsZXQgc2V0X2RhdGEgKHQ6KCdrLCdkKSB0KSAoZDonZCkgOiB1bml0ID0gT2JqRXBoLnNldF9kYXRhIHQgKE9iai5yZXByIGQpXG4gIGxldCB1bnNldF9kYXRhICh0OignaywnZCkgdCkgOiB1bml0ID0gT2JqRXBoLnVuc2V0X2RhdGEgdFxuICBsZXQgY2hlY2tfZGF0YSAodDooJ2ssJ2QpIHQpIDogYm9vbCA9IE9iakVwaC5jaGVja19kYXRhIHRcbiAgbGV0IGJsaXRfZGF0YSAodDE6KF8sJ2QpIHQpICh0MjooXywnZCkgdCkgOiB1bml0ID0gT2JqRXBoLmJsaXRfZGF0YSB0MSB0MlxuXG4gIGxldCBtYWtlIGtleSBkYXRhID1cbiAgICBsZXQgZXBoID0gY3JlYXRlICgpIGluXG4gICAgc2V0X2RhdGEgZXBoIGRhdGE7XG4gICAgc2V0X2tleSBlcGgga2V5O1xuICAgIGVwaFxuXG4gIGxldCBxdWVyeSBlcGgga2V5ID1cbiAgICBtYXRjaCBnZXRfa2V5IGVwaCB3aXRoXG4gICAgfCBOb25lIC0+IE5vbmVcbiAgICB8IFNvbWUgayB3aGVuIGsgPT0ga2V5IC0+IGdldF9kYXRhIGVwaFxuICAgIHwgU29tZSBfIC0+IE5vbmVcblxuICBtb2R1bGUgTWFrZVNlZWRlZCAoSDpIYXNodGJsLlNlZWRlZEhhc2hlZFR5cGUpID1cbiAgICBHZW5IYXNoVGFibGUuTWFrZVNlZWRlZChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgY29udGFpbmVyID0gKEgudCwnYSkgdFxuICAgICAgdHlwZSB0ID0gSC50XG4gICAgICBsZXQgY3JlYXRlIGsgZCA9XG4gICAgICAgIGxldCBjID0gY3JlYXRlICgpIGluXG4gICAgICAgIHNldF9kYXRhIGMgZDtcbiAgICAgICAgc2V0X2tleSBjIGs7XG4gICAgICAgIGNcbiAgICAgIGxldCBoYXNoID0gSC5oYXNoXG4gICAgICBsZXQgZXF1YWwgYyBrID1cbiAgICAgICAgKCogeyFnZXRfa2V5X2NvcHl9IGlzIG5vdCB1c2VkIGJlY2F1c2UgdGhlIGVxdWFsaXR5IG9mIHRoZSB1c2VyIGNhbiBiZVxuICAgICAgICAgICAgdGhlIHBoeXNpY2FsIGVxdWFsaXR5ICopXG4gICAgICAgIG1hdGNoIGdldF9rZXkgYyB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiBHZW5IYXNoVGFibGUuRURlYWRcbiAgICAgICAgfCBTb21lIGsnIC0+XG4gICAgICAgICAgICBpZiBILmVxdWFsIGsgaycgdGhlbiBHZW5IYXNoVGFibGUuRVRydWUgZWxzZSBHZW5IYXNoVGFibGUuRUZhbHNlXG4gICAgICBsZXQgZ2V0X2RhdGEgPSBnZXRfZGF0YVxuICAgICAgbGV0IGdldF9rZXkgPSBnZXRfa2V5XG4gICAgICBsZXQgc2V0X2tleV9kYXRhIGMgayBkID1cbiAgICAgICAgdW5zZXRfZGF0YSBjO1xuICAgICAgICBzZXRfa2V5IGMgaztcbiAgICAgICAgc2V0X2RhdGEgYyBkXG4gICAgICBsZXQgY2hlY2tfa2V5ID0gY2hlY2tfa2V5XG4gICAgZW5kKVxuXG4gIG1vZHVsZSBNYWtlKEg6IEhhc2h0YmwuSGFzaGVkVHlwZSk6IChTIHdpdGggdHlwZSBrZXkgPSBILnQpID1cbiAgc3RydWN0XG4gICAgaW5jbHVkZSBNYWtlU2VlZGVkKHN0cnVjdFxuICAgICAgICB0eXBlIHQgPSBILnRcbiAgICAgICAgbGV0IGVxdWFsID0gSC5lcXVhbFxuICAgICAgICBsZXQgaGFzaCAoX3NlZWQ6IGludCkgeCA9IEguaGFzaCB4XG4gICAgICBlbmQpXG4gICAgbGV0IGNyZWF0ZSBzeiA9IGNyZWF0ZSB+cmFuZG9tOmZhbHNlIHN6XG4gICAgbGV0IG9mX3NlcSBpID1cbiAgICAgIGxldCB0YmwgPSBjcmVhdGUgMTYgaW5cbiAgICAgIHJlcGxhY2Vfc2VxIHRibCBpO1xuICAgICAgdGJsXG4gIGVuZFxuXG4gIG1vZHVsZSBCdWNrZXQgPSBzdHJ1Y3RcblxuICAgIHR5cGUgbm9ucmVjICgnaywgJ2QpIHQgPSAoJ2ssICdkKSB0IGxpc3QgcmVmXG4gICAgbGV0IGsxX21ha2UgPSBtYWtlXG4gICAgbGV0IG1ha2UgKCkgPSByZWYgW11cbiAgICBsZXQgYWRkIGIgayBkID0gYiA6PSBrMV9tYWtlIGsgZCA6OiAhYlxuXG4gICAgbGV0IHRlc3Rfa2V5IGsgZSA9XG4gICAgICBtYXRjaCBnZXRfa2V5IGUgd2l0aFxuICAgICAgfCBTb21lIHggd2hlbiB4ID09IGsgLT4gdHJ1ZVxuICAgICAgfCBfIC0+IGZhbHNlXG5cbiAgICBsZXQgcmVtb3ZlIGIgayA9XG4gICAgICBsZXQgcmVjIGxvb3AgbCBhY2MgPVxuICAgICAgICBtYXRjaCBsIHdpdGhcbiAgICAgICAgfCBbXSAtPiAoKVxuICAgICAgICB8IGggOjogdCB3aGVuIHRlc3Rfa2V5IGsgaCAtPiBiIDo9IExpc3QucmV2X2FwcGVuZCBhY2MgdFxuICAgICAgICB8IGggOjogdCAtPiBsb29wIHQgKGggOjogYWNjKVxuICAgICAgaW5cbiAgICAgIGxvb3AgIWIgW11cblxuICAgIGxldCBmaW5kIGIgayA9XG4gICAgICBtYXRjaCBMaXN0LmZpbmRfb3B0ICh0ZXN0X2tleSBrKSAhYiB3aXRoXG4gICAgICB8IFNvbWUgZSAtPiBnZXRfZGF0YSBlXG4gICAgICB8IE5vbmUgLT4gTm9uZVxuXG4gICAgbGV0IGxlbmd0aCBiID0gTGlzdC5sZW5ndGggIWJcbiAgICBsZXQgY2xlYXIgYiA9IGIgOj0gW11cblxuICBlbmRcblxuZW5kXG5cbm1vZHVsZSBLMiA9IHN0cnVjdFxuICB0eXBlICgnazEsICdrMiwgJ2QpIHQgPSBPYmpFcGgudFxuXG4gIGxldCBjcmVhdGUgKCkgOiAoJ2sxLCdrMiwnZCkgdCA9IE9iakVwaC5jcmVhdGUgMlxuXG4gIGxldCBnZXRfa2V5MSAodDooJ2sxLCdrMiwnZCkgdCkgOiAnazEgb3B0aW9uID0gb2JqX29wdCAoT2JqRXBoLmdldF9rZXkgdCAwKVxuICBsZXQgZ2V0X2tleTFfY29weSAodDooJ2sxLCdrMiwnZCkgdCkgOiAnazEgb3B0aW9uID1cbiAgICBvYmpfb3B0IChPYmpFcGguZ2V0X2tleV9jb3B5IHQgMClcbiAgbGV0IHNldF9rZXkxICh0OignazEsJ2syLCdkKSB0KSAoazonazEpIDogdW5pdCA9XG4gICAgT2JqRXBoLnNldF9rZXkgdCAwIChPYmoucmVwciBrKVxuICBsZXQgdW5zZXRfa2V5MSAodDooJ2sxLCdrMiwnZCkgdCkgOiB1bml0ID0gT2JqRXBoLnVuc2V0X2tleSB0IDBcbiAgbGV0IGNoZWNrX2tleTEgKHQ6KCdrMSwnazIsJ2QpIHQpIDogYm9vbCA9IE9iakVwaC5jaGVja19rZXkgdCAwXG5cbiAgbGV0IGdldF9rZXkyICh0OignazEsJ2syLCdkKSB0KSA6ICdrMiBvcHRpb24gPSBvYmpfb3B0IChPYmpFcGguZ2V0X2tleSB0IDEpXG4gIGxldCBnZXRfa2V5Ml9jb3B5ICh0OignazEsJ2syLCdkKSB0KSA6ICdrMiBvcHRpb24gPVxuICAgIG9ial9vcHQgKE9iakVwaC5nZXRfa2V5X2NvcHkgdCAxKVxuICBsZXQgc2V0X2tleTIgKHQ6KCdrMSwnazIsJ2QpIHQpIChrOidrMikgOiB1bml0ID1cbiAgICBPYmpFcGguc2V0X2tleSB0IDEgKE9iai5yZXByIGspXG4gIGxldCB1bnNldF9rZXkyICh0OignazEsJ2syLCdkKSB0KSA6IHVuaXQgPSBPYmpFcGgudW5zZXRfa2V5IHQgMVxuICBsZXQgY2hlY2tfa2V5MiAodDooJ2sxLCdrMiwnZCkgdCkgOiBib29sID0gT2JqRXBoLmNoZWNrX2tleSB0IDFcblxuXG4gIGxldCBibGl0X2tleTEgKHQxOignazEsXyxfKSB0KSAodDI6KCdrMSxfLF8pIHQpIDogdW5pdCA9XG4gICAgT2JqRXBoLmJsaXRfa2V5IHQxIDAgdDIgMCAxXG4gIGxldCBibGl0X2tleTIgKHQxOihfLCdrMixfKSB0KSAodDI6KF8sJ2syLF8pIHQpIDogdW5pdCA9XG4gICAgT2JqRXBoLmJsaXRfa2V5IHQxIDEgdDIgMSAxXG4gIGxldCBibGl0X2tleTEyICh0MTooJ2sxLCdrMixfKSB0KSAodDI6KCdrMSwnazIsXykgdCkgOiB1bml0ID1cbiAgICBPYmpFcGguYmxpdF9rZXkgdDEgMCB0MiAwIDJcblxuICBsZXQgZ2V0X2RhdGEgKHQ6KCdrMSwnazIsJ2QpIHQpIDogJ2Qgb3B0aW9uID0gb2JqX29wdCAoT2JqRXBoLmdldF9kYXRhIHQpXG4gIGxldCBnZXRfZGF0YV9jb3B5ICh0OignazEsJ2syLCdkKSB0KSA6ICdkIG9wdGlvbiA9XG4gICAgb2JqX29wdCAoT2JqRXBoLmdldF9kYXRhX2NvcHkgdClcbiAgbGV0IHNldF9kYXRhICh0OignazEsJ2syLCdkKSB0KSAoZDonZCkgOiB1bml0ID1cbiAgICBPYmpFcGguc2V0X2RhdGEgdCAoT2JqLnJlcHIgZClcbiAgbGV0IHVuc2V0X2RhdGEgKHQ6KCdrMSwnazIsJ2QpIHQpIDogdW5pdCA9IE9iakVwaC51bnNldF9kYXRhIHRcbiAgbGV0IGNoZWNrX2RhdGEgKHQ6KCdrMSwnazIsJ2QpIHQpIDogYm9vbCA9IE9iakVwaC5jaGVja19kYXRhIHRcbiAgbGV0IGJsaXRfZGF0YSAodDE6KF8sXywnZCkgdCkgKHQyOihfLF8sJ2QpIHQpIDogdW5pdCA9IE9iakVwaC5ibGl0X2RhdGEgdDEgdDJcblxuICBsZXQgbWFrZSBrZXkxIGtleTIgZGF0YSA9XG4gICAgbGV0IGVwaCA9IGNyZWF0ZSAoKSBpblxuICAgIHNldF9kYXRhIGVwaCBkYXRhO1xuICAgIHNldF9rZXkxIGVwaCBrZXkxO1xuICAgIHNldF9rZXkyIGVwaCBrZXkyO1xuICAgIGlnbm9yZSAoU3lzLm9wYXF1ZV9pZGVudGl0eSBrZXkxKTtcbiAgICBlcGhcblxuICBsZXQgcXVlcnkgZXBoIGtleTEga2V5MiA9XG4gICAgbWF0Y2ggZ2V0X2tleTEgZXBoIHdpdGhcbiAgICB8IE5vbmUgLT4gTm9uZVxuICAgIHwgU29tZSBrIHdoZW4gayA9PSBrZXkxIC0+XG4gICAgICAgIGJlZ2luIG1hdGNoIGdldF9rZXkyIGVwaCB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiBOb25lXG4gICAgICAgIHwgU29tZSBrIHdoZW4gayA9PSBrZXkyIC0+IGdldF9kYXRhIGVwaFxuICAgICAgICB8IFNvbWUgXyAtPiBOb25lXG4gICAgICAgIGVuZFxuICAgIHwgU29tZSBfIC0+IE5vbmVcblxuICBtb2R1bGUgTWFrZVNlZWRlZFxuICAgICAgKEgxOkhhc2h0YmwuU2VlZGVkSGFzaGVkVHlwZSlcbiAgICAgIChIMjpIYXNodGJsLlNlZWRlZEhhc2hlZFR5cGUpID1cbiAgICBHZW5IYXNoVGFibGUuTWFrZVNlZWRlZChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgY29udGFpbmVyID0gKEgxLnQsSDIudCwnYSkgdFxuICAgICAgdHlwZSB0ID0gSDEudCAqIEgyLnRcbiAgICAgIGxldCBjcmVhdGUgKGsxLGsyKSBkID1cbiAgICAgICAgbGV0IGMgPSBjcmVhdGUgKCkgaW5cbiAgICAgICAgc2V0X2RhdGEgYyBkO1xuICAgICAgICBzZXRfa2V5MSBjIGsxOyBzZXRfa2V5MiBjIGsyO1xuICAgICAgICBjXG4gICAgICBsZXQgaGFzaCBzZWVkIChrMSxrMikgPVxuICAgICAgICBIMS5oYXNoIHNlZWQgazEgKyBIMi5oYXNoIHNlZWQgazIgKiA2NTU5OVxuICAgICAgbGV0IGVxdWFsIGMgKGsxLGsyKSA9XG4gICAgICAgIG1hdGNoIGdldF9rZXkxIGMsIGdldF9rZXkyIGMgd2l0aFxuICAgICAgICB8IE5vbmUsIF8gfCBfICwgTm9uZSAtPiBHZW5IYXNoVGFibGUuRURlYWRcbiAgICAgICAgfCBTb21lIGsxJywgU29tZSBrMicgLT5cbiAgICAgICAgICAgIGlmIEgxLmVxdWFsIGsxIGsxJyAmJiBIMi5lcXVhbCBrMiBrMidcbiAgICAgICAgICAgIHRoZW4gR2VuSGFzaFRhYmxlLkVUcnVlIGVsc2UgR2VuSGFzaFRhYmxlLkVGYWxzZVxuICAgICAgbGV0IGdldF9kYXRhID0gZ2V0X2RhdGFcbiAgICAgIGxldCBnZXRfa2V5IGMgPVxuICAgICAgICBtYXRjaCBnZXRfa2V5MSBjLCBnZXRfa2V5MiBjIHdpdGhcbiAgICAgICAgfCBOb25lLCBfIHwgXyAsIE5vbmUgLT4gTm9uZVxuICAgICAgICB8IFNvbWUgazEnLCBTb21lIGsyJyAtPiBTb21lIChrMScsIGsyJylcbiAgICAgIGxldCBzZXRfa2V5X2RhdGEgYyAoazEsazIpIGQgPVxuICAgICAgICB1bnNldF9kYXRhIGM7XG4gICAgICAgIHNldF9rZXkxIGMgazE7IHNldF9rZXkyIGMgazI7XG4gICAgICAgIHNldF9kYXRhIGMgZFxuICAgICAgbGV0IGNoZWNrX2tleSBjID0gY2hlY2tfa2V5MSBjICYmIGNoZWNrX2tleTIgY1xuICAgIGVuZClcblxuICBtb2R1bGUgTWFrZShIMTogSGFzaHRibC5IYXNoZWRUeXBlKShIMjogSGFzaHRibC5IYXNoZWRUeXBlKTpcbiAgICAoUyB3aXRoIHR5cGUga2V5ID0gSDEudCAqIEgyLnQpID1cbiAgc3RydWN0XG4gICAgaW5jbHVkZSBNYWtlU2VlZGVkXG4gICAgICAgIChzdHJ1Y3RcbiAgICAgICAgICB0eXBlIHQgPSBIMS50XG4gICAgICAgICAgbGV0IGVxdWFsID0gSDEuZXF1YWxcbiAgICAgICAgICBsZXQgaGFzaCAoX3NlZWQ6IGludCkgeCA9IEgxLmhhc2ggeFxuICAgICAgICBlbmQpXG4gICAgICAgIChzdHJ1Y3RcbiAgICAgICAgICB0eXBlIHQgPSBIMi50XG4gICAgICAgICAgbGV0IGVxdWFsID0gSDIuZXF1YWxcbiAgICAgICAgICBsZXQgaGFzaCAoX3NlZWQ6IGludCkgeCA9IEgyLmhhc2ggeFxuICAgICAgICBlbmQpXG4gICAgbGV0IGNyZWF0ZSBzeiA9IGNyZWF0ZSB+cmFuZG9tOmZhbHNlIHN6XG4gICAgbGV0IG9mX3NlcSBpID1cbiAgICAgIGxldCB0YmwgPSBjcmVhdGUgMTYgaW5cbiAgICAgIHJlcGxhY2Vfc2VxIHRibCBpO1xuICAgICAgdGJsXG4gIGVuZFxuXG4gIG1vZHVsZSBCdWNrZXQgPSBzdHJ1Y3RcblxuICAgIHR5cGUgbm9ucmVjICgnazEsICdrMiwgJ2QpIHQgPSAoJ2sxLCAnazIsICdkKSB0IGxpc3QgcmVmXG4gICAgbGV0IGsyX21ha2UgPSBtYWtlXG4gICAgbGV0IG1ha2UgKCkgPSByZWYgW11cbiAgICBsZXQgYWRkIGIgazEgazIgZCA9IGIgOj0gazJfbWFrZSBrMSBrMiBkIDo6ICFiXG5cbiAgICBsZXQgdGVzdF9rZXlzIGsxIGsyIGUgPVxuICAgICAgbWF0Y2ggZ2V0X2tleTEgZSwgZ2V0X2tleTIgZSB3aXRoXG4gICAgICB8IFNvbWUgeDEsIFNvbWUgeDIgd2hlbiB4MSA9PSBrMSAmJiB4MiA9PSBrMiAtPiB0cnVlXG4gICAgICB8IF8gLT4gZmFsc2VcblxuICAgIGxldCByZW1vdmUgYiBrMSBrMiA9XG4gICAgICBsZXQgcmVjIGxvb3AgbCBhY2MgPVxuICAgICAgICBtYXRjaCBsIHdpdGhcbiAgICAgICAgfCBbXSAtPiAoKVxuICAgICAgICB8IGggOjogdCB3aGVuIHRlc3Rfa2V5cyBrMSBrMiBoIC0+IGIgOj0gTGlzdC5yZXZfYXBwZW5kIGFjYyB0XG4gICAgICAgIHwgaCA6OiB0IC0+IGxvb3AgdCAoaCA6OiBhY2MpXG4gICAgICBpblxuICAgICAgbG9vcCAhYiBbXVxuXG4gICAgbGV0IGZpbmQgYiBrMSBrMiA9XG4gICAgICBtYXRjaCBMaXN0LmZpbmRfb3B0ICh0ZXN0X2tleXMgazEgazIpICFiIHdpdGhcbiAgICAgIHwgU29tZSBlIC0+IGdldF9kYXRhIGVcbiAgICAgIHwgTm9uZSAtPiBOb25lXG5cbiAgICBsZXQgbGVuZ3RoIGIgPSBMaXN0Lmxlbmd0aCAhYlxuICAgIGxldCBjbGVhciBiID0gYiA6PSBbXVxuXG4gIGVuZFxuXG5lbmRcblxubW9kdWxlIEtuID0gc3RydWN0XG4gIHR5cGUgKCdrLCdkKSB0ID0gT2JqRXBoLnRcblxuICBsZXQgY3JlYXRlIG4gOiAoJ2ssJ2QpIHQgPSBPYmpFcGguY3JlYXRlIG5cbiAgbGV0IGxlbmd0aCAoazooJ2ssJ2QpIHQpIDogaW50ID0gT2JqRXBoLmxlbmd0aCBrXG5cbiAgbGV0IGdldF9rZXkgKHQ6KCdrLCdkKSB0KSAobjppbnQpIDogJ2sgb3B0aW9uID0gb2JqX29wdCAoT2JqRXBoLmdldF9rZXkgdCBuKVxuICBsZXQgZ2V0X2tleV9jb3B5ICh0OignaywnZCkgdCkgKG46aW50KSA6ICdrIG9wdGlvbiA9XG4gICAgb2JqX29wdCAoT2JqRXBoLmdldF9rZXlfY29weSB0IG4pXG4gIGxldCBzZXRfa2V5ICh0OignaywnZCkgdCkgKG46aW50KSAoazonaykgOiB1bml0ID1cbiAgICBPYmpFcGguc2V0X2tleSB0IG4gKE9iai5yZXByIGspXG4gIGxldCB1bnNldF9rZXkgKHQ6KCdrLCdkKSB0KSAobjppbnQpIDogdW5pdCA9IE9iakVwaC51bnNldF9rZXkgdCBuXG4gIGxldCBjaGVja19rZXkgKHQ6KCdrLCdkKSB0KSAobjppbnQpIDogYm9vbCA9IE9iakVwaC5jaGVja19rZXkgdCBuXG5cbiAgbGV0IGJsaXRfa2V5ICh0MTooJ2ssJ2QpIHQpIChvMTppbnQpICh0MjooJ2ssJ2QpIHQpIChvMjppbnQpIChsOmludCkgOiB1bml0ID1cbiAgICBPYmpFcGguYmxpdF9rZXkgdDEgbzEgdDIgbzIgbFxuXG4gIGxldCBnZXRfZGF0YSAodDooJ2ssJ2QpIHQpIDogJ2Qgb3B0aW9uID0gb2JqX29wdCAoT2JqRXBoLmdldF9kYXRhIHQpXG4gIGxldCBnZXRfZGF0YV9jb3B5ICh0OignaywnZCkgdCkgOiAnZCBvcHRpb24gPSBvYmpfb3B0IChPYmpFcGguZ2V0X2RhdGFfY29weSB0KVxuICBsZXQgc2V0X2RhdGEgKHQ6KCdrLCdkKSB0KSAoZDonZCkgOiB1bml0ID0gT2JqRXBoLnNldF9kYXRhIHQgKE9iai5yZXByIGQpXG4gIGxldCB1bnNldF9kYXRhICh0OignaywnZCkgdCkgOiB1bml0ID0gT2JqRXBoLnVuc2V0X2RhdGEgdFxuICBsZXQgY2hlY2tfZGF0YSAodDooJ2ssJ2QpIHQpIDogYm9vbCA9IE9iakVwaC5jaGVja19kYXRhIHRcbiAgbGV0IGJsaXRfZGF0YSAodDE6KF8sJ2QpIHQpICh0MjooXywnZCkgdCkgOiB1bml0ID0gT2JqRXBoLmJsaXRfZGF0YSB0MSB0MlxuXG4gIGxldCBtYWtlIGtleXMgZGF0YSA9XG4gICAgbGV0IGwgPSBBcnJheS5sZW5ndGgga2V5cyBpblxuICAgIGxldCBlcGggPSBjcmVhdGUgbCBpblxuICAgIHNldF9kYXRhIGVwaCBkYXRhO1xuICAgIGZvciBpID0gMCB0byBsIC0gMSBkbyBzZXRfa2V5IGVwaCBpIGtleXMuKGkpIGRvbmU7XG4gICAgZXBoXG5cbiAgbGV0IHF1ZXJ5IGVwaCBrZXlzID1cbiAgICBsZXQgbCA9IGxlbmd0aCBlcGggaW5cbiAgICB0cnlcbiAgICAgIGlmIGwgPD4gQXJyYXkubGVuZ3RoIGtleXMgdGhlbiByYWlzZSBFeGl0O1xuICAgICAgZm9yIGkgPSAwIHRvIGwgLSAxIGRvXG4gICAgICAgIG1hdGNoIGdldF9rZXkgZXBoIGkgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gcmFpc2UgRXhpdFxuICAgICAgICB8IFNvbWUgayB3aGVuIGsgPT0ga2V5cy4oaSkgLT4gKClcbiAgICAgICAgfCBTb21lIF8gLT4gcmFpc2UgRXhpdFxuICAgICAgZG9uZTtcbiAgICAgIGdldF9kYXRhIGVwaFxuICAgIHdpdGggRXhpdCAtPiBOb25lXG5cbiAgbW9kdWxlIE1ha2VTZWVkZWQgKEg6SGFzaHRibC5TZWVkZWRIYXNoZWRUeXBlKSA9XG4gICAgR2VuSGFzaFRhYmxlLk1ha2VTZWVkZWQoc3RydWN0XG4gICAgICB0eXBlICdhIGNvbnRhaW5lciA9IChILnQsJ2EpIHRcbiAgICAgIHR5cGUgdCA9IEgudCBhcnJheVxuICAgICAgbGV0IGNyZWF0ZSBrIGQgPVxuICAgICAgICBsZXQgYyA9IGNyZWF0ZSAoQXJyYXkubGVuZ3RoIGspIGluXG4gICAgICAgIHNldF9kYXRhIGMgZDtcbiAgICAgICAgZm9yIGk9MCB0byBBcnJheS5sZW5ndGggayAtMSBkb1xuICAgICAgICAgIHNldF9rZXkgYyBpIGsuKGkpO1xuICAgICAgICBkb25lO1xuICAgICAgICBjXG4gICAgICBsZXQgaGFzaCBzZWVkIGsgPVxuICAgICAgICBsZXQgaCA9IHJlZiAwIGluXG4gICAgICAgIGZvciBpPTAgdG8gQXJyYXkubGVuZ3RoIGsgLTEgZG9cbiAgICAgICAgICBoIDo9IEguaGFzaCBzZWVkIGsuKGkpICogNjU1OTkgKyAhaDtcbiAgICAgICAgZG9uZTtcbiAgICAgICAgIWhcbiAgICAgIGxldCBlcXVhbCBjIGsgPVxuICAgICAgICBsZXQgbGVuICA9IEFycmF5Lmxlbmd0aCBrIGluXG4gICAgICAgIGxldCBsZW4nID0gbGVuZ3RoIGMgaW5cbiAgICAgICAgaWYgbGVuICE9IGxlbicgdGhlbiBHZW5IYXNoVGFibGUuRUZhbHNlXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBsZXQgcmVjIGVxdWFsX2FycmF5IGsgYyBpID1cbiAgICAgICAgICAgIGlmIGkgPCAwIHRoZW4gR2VuSGFzaFRhYmxlLkVUcnVlXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIG1hdGNoIGdldF9rZXkgYyBpIHdpdGhcbiAgICAgICAgICAgICAgfCBOb25lIC0+IEdlbkhhc2hUYWJsZS5FRGVhZFxuICAgICAgICAgICAgICB8IFNvbWUga2kgLT5cbiAgICAgICAgICAgICAgICAgIGlmIEguZXF1YWwgay4oaSkga2lcbiAgICAgICAgICAgICAgICAgIHRoZW4gZXF1YWxfYXJyYXkgayBjIChpLTEpXG4gICAgICAgICAgICAgICAgICBlbHNlIEdlbkhhc2hUYWJsZS5FRmFsc2VcbiAgICAgICAgICBpblxuICAgICAgICAgIGVxdWFsX2FycmF5IGsgYyAobGVuLTEpXG4gICAgICBsZXQgZ2V0X2RhdGEgPSBnZXRfZGF0YVxuICAgICAgbGV0IGdldF9rZXkgYyA9XG4gICAgICAgIGxldCBsZW4gPSBsZW5ndGggYyBpblxuICAgICAgICBpZiBsZW4gPSAwIHRoZW4gU29tZSBbfHxdXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBtYXRjaCBnZXRfa2V5IGMgMCB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+IE5vbmVcbiAgICAgICAgICB8IFNvbWUgazAgLT5cbiAgICAgICAgICAgICAgbGV0IHJlYyBmaWxsIGEgaSA9XG4gICAgICAgICAgICAgICAgaWYgaSA8IDEgdGhlbiBTb21lIGFcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICBtYXRjaCBnZXRfa2V5IGMgaSB3aXRoXG4gICAgICAgICAgICAgICAgICB8IE5vbmUgLT4gTm9uZVxuICAgICAgICAgICAgICAgICAgfCBTb21lIGtpIC0+XG4gICAgICAgICAgICAgICAgICAgICAgYS4oaSkgPC0ga2k7XG4gICAgICAgICAgICAgICAgICAgICAgZmlsbCBhIChpLTEpXG4gICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgIGxldCBhID0gQXJyYXkubWFrZSBsZW4gazAgaW5cbiAgICAgICAgICAgICAgZmlsbCBhIChsZW4tMSlcbiAgICAgIGxldCBzZXRfa2V5X2RhdGEgYyBrIGQgPVxuICAgICAgICB1bnNldF9kYXRhIGM7XG4gICAgICAgIGZvciBpPTAgdG8gQXJyYXkubGVuZ3RoIGsgLTEgZG9cbiAgICAgICAgICBzZXRfa2V5IGMgaSBrLihpKTtcbiAgICAgICAgZG9uZTtcbiAgICAgICAgc2V0X2RhdGEgYyBkXG4gICAgICBsZXQgY2hlY2tfa2V5IGMgPVxuICAgICAgICBsZXQgcmVjIGNoZWNrIGMgaSA9XG4gICAgICAgICAgaSA8IDAgfHwgKGNoZWNrX2tleSBjIGkgJiYgY2hlY2sgYyAoaS0xKSkgaW5cbiAgICAgICAgY2hlY2sgYyAobGVuZ3RoIGMgLSAxKVxuICAgIGVuZClcblxuICBtb2R1bGUgTWFrZShIOiBIYXNodGJsLkhhc2hlZFR5cGUpOiAoUyB3aXRoIHR5cGUga2V5ID0gSC50IGFycmF5KSA9XG4gIHN0cnVjdFxuICAgIGluY2x1ZGUgTWFrZVNlZWRlZChzdHJ1Y3RcbiAgICAgICAgdHlwZSB0ID0gSC50XG4gICAgICAgIGxldCBlcXVhbCA9IEguZXF1YWxcbiAgICAgICAgbGV0IGhhc2ggKF9zZWVkOiBpbnQpIHggPSBILmhhc2ggeFxuICAgICAgZW5kKVxuICAgIGxldCBjcmVhdGUgc3ogPSBjcmVhdGUgfnJhbmRvbTpmYWxzZSBzelxuICAgIGxldCBvZl9zZXEgaSA9XG4gICAgICBsZXQgdGJsID0gY3JlYXRlIDE2IGluXG4gICAgICByZXBsYWNlX3NlcSB0YmwgaTtcbiAgICAgIHRibFxuICBlbmRcblxuICBtb2R1bGUgQnVja2V0ID0gc3RydWN0XG5cbiAgICB0eXBlIG5vbnJlYyAoJ2ssICdkKSB0ID0gKCdrLCAnZCkgdCBsaXN0IHJlZlxuICAgIGxldCBrbl9tYWtlID0gbWFrZVxuICAgIGxldCBtYWtlICgpID0gcmVmIFtdXG4gICAgbGV0IGFkZCBiIGsgZCA9IGIgOj0ga25fbWFrZSBrIGQgOjogIWJcblxuICAgIGxldCB0ZXN0X2tleXMgayBlID1cbiAgICAgIHRyeVxuICAgICAgICBpZiBsZW5ndGggZSA8PiBBcnJheS5sZW5ndGggayB0aGVuIHJhaXNlIEV4aXQ7XG4gICAgICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggayAtIDEgZG9cbiAgICAgICAgICBtYXRjaCBnZXRfa2V5IGUgaSB3aXRoXG4gICAgICAgICAgfCBTb21lIHggd2hlbiB4ID09IGsuKGkpIC0+ICgpXG4gICAgICAgICAgfCBfIC0+IHJhaXNlIEV4aXRcbiAgICAgICAgZG9uZTtcbiAgICAgICAgdHJ1ZVxuICAgICAgd2l0aCBFeGl0IC0+IGZhbHNlXG5cbiAgICBsZXQgcmVtb3ZlIGIgayA9XG4gICAgICBsZXQgcmVjIGxvb3AgbCBhY2MgPVxuICAgICAgICBtYXRjaCBsIHdpdGhcbiAgICAgICAgfCBbXSAtPiAoKVxuICAgICAgICB8IGggOjogdCB3aGVuIHRlc3Rfa2V5cyBrIGggLT4gYiA6PSBMaXN0LnJldl9hcHBlbmQgYWNjIHRcbiAgICAgICAgfCBoIDo6IHQgLT4gbG9vcCB0IChoIDo6IGFjYylcbiAgICAgIGluXG4gICAgICBsb29wICFiIFtdXG5cbiAgICBsZXQgZmluZCBiIGsgPVxuICAgICAgbWF0Y2ggTGlzdC5maW5kX29wdCAodGVzdF9rZXlzIGspICFiIHdpdGhcbiAgICAgIHwgU29tZSBlIC0+IGdldF9kYXRhIGVcbiAgICAgIHwgTm9uZSAtPiBOb25lXG5cbiAgICBsZXQgbGVuZ3RoIGIgPSBMaXN0Lmxlbmd0aCAhYlxuICAgIGxldCBjbGVhciBiID0gYiA6PSBbXVxuXG4gIGVuZFxuXG5lbmRcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICBYYXZpZXIgTGVyb3kgYW5kIERhbWllbiBEb2xpZ2V6LCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxubGV0IGdlbmVyaWNfcXVvdGUgcXVvdGVxdW90ZSBzID1cbiAgbGV0IGwgPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgbGV0IGIgPSBCdWZmZXIuY3JlYXRlIChsICsgMjApIGluXG4gIEJ1ZmZlci5hZGRfY2hhciBiICdcXCcnO1xuICBmb3IgaSA9IDAgdG8gbCAtIDEgZG9cbiAgICBpZiBzLltpXSA9ICdcXCcnXG4gICAgdGhlbiBCdWZmZXIuYWRkX3N0cmluZyBiIHF1b3RlcXVvdGVcbiAgICBlbHNlIEJ1ZmZlci5hZGRfY2hhciBiICBzLltpXVxuICBkb25lO1xuICBCdWZmZXIuYWRkX2NoYXIgYiAnXFwnJztcbiAgQnVmZmVyLmNvbnRlbnRzIGJcblxuKCogVGhpcyBmdW5jdGlvbiBpbXBsZW1lbnRzIHRoZSBPcGVuIEdyb3VwIHNwZWNpZmljYXRpb24gZm91bmQgaGVyZTpcbiAgW1sxXV0gaHR0cDovL3B1YnMub3Blbmdyb3VwLm9yZy9vbmxpbmVwdWJzLzk2OTk5MTk3OTkvdXRpbGl0aWVzL2Jhc2VuYW1lLmh0bWxcbiAgSW4gc3RlcCAxIG9mIFtbMV1dLCB3ZSBjaG9vc2UgdG8gcmV0dXJuIFwiLlwiIGZvciBlbXB0eSBpbnB1dC5cbiAgICAoZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBwcmV2aW91cyB2ZXJzaW9ucyBvZiBPQ2FtbClcbiAgSW4gc3RlcCAyLCB3ZSBjaG9vc2UgdG8gcHJvY2VzcyBcIi8vXCIgbm9ybWFsbHkuXG4gIFN0ZXAgNiBpcyBub3QgaW1wbGVtZW50ZWQ6IHdlIGNvbnNpZGVyIHRoYXQgdGhlIFtzdWZmaXhdIG9wZXJhbmQgaXNcbiAgICBhbHdheXMgYWJzZW50LiAgU3VmZml4ZXMgYXJlIGhhbmRsZWQgYnkgW2Nob3Bfc3VmZml4XSBhbmQgW2Nob3BfZXh0ZW5zaW9uXS5cbiopXG5sZXQgZ2VuZXJpY19iYXNlbmFtZSBpc19kaXJfc2VwIGN1cnJlbnRfZGlyX25hbWUgbmFtZSA9XG4gIGxldCByZWMgZmluZF9lbmQgbiA9XG4gICAgaWYgbiA8IDAgdGhlbiBTdHJpbmcuc3ViIG5hbWUgMCAxXG4gICAgZWxzZSBpZiBpc19kaXJfc2VwIG5hbWUgbiB0aGVuIGZpbmRfZW5kIChuIC0gMSlcbiAgICBlbHNlIGZpbmRfYmVnIG4gKG4gKyAxKVxuICBhbmQgZmluZF9iZWcgbiBwID1cbiAgICBpZiBuIDwgMCB0aGVuIFN0cmluZy5zdWIgbmFtZSAwIHBcbiAgICBlbHNlIGlmIGlzX2Rpcl9zZXAgbmFtZSBuIHRoZW4gU3RyaW5nLnN1YiBuYW1lIChuICsgMSkgKHAgLSBuIC0gMSlcbiAgICBlbHNlIGZpbmRfYmVnIChuIC0gMSkgcFxuICBpblxuICBpZiBuYW1lID0gXCJcIlxuICB0aGVuIGN1cnJlbnRfZGlyX25hbWVcbiAgZWxzZSBmaW5kX2VuZCAoU3RyaW5nLmxlbmd0aCBuYW1lIC0gMSlcblxuKCogVGhpcyBmdW5jdGlvbiBpbXBsZW1lbnRzIHRoZSBPcGVuIEdyb3VwIHNwZWNpZmljYXRpb24gZm91bmQgaGVyZTpcbiAgW1syXV0gaHR0cDovL3B1YnMub3Blbmdyb3VwLm9yZy9vbmxpbmVwdWJzLzk2OTk5MTk3OTkvdXRpbGl0aWVzL2Rpcm5hbWUuaHRtbFxuICBJbiBzdGVwIDYgb2YgW1syXV0sIHdlIGNob29zZSB0byBwcm9jZXNzIFwiLy9cIiBub3JtYWxseS5cbiopXG5sZXQgZ2VuZXJpY19kaXJuYW1lIGlzX2Rpcl9zZXAgY3VycmVudF9kaXJfbmFtZSBuYW1lID1cbiAgbGV0IHJlYyB0cmFpbGluZ19zZXAgbiA9XG4gICAgaWYgbiA8IDAgdGhlbiBTdHJpbmcuc3ViIG5hbWUgMCAxXG4gICAgZWxzZSBpZiBpc19kaXJfc2VwIG5hbWUgbiB0aGVuIHRyYWlsaW5nX3NlcCAobiAtIDEpXG4gICAgZWxzZSBiYXNlIG5cbiAgYW5kIGJhc2UgbiA9XG4gICAgaWYgbiA8IDAgdGhlbiBjdXJyZW50X2Rpcl9uYW1lXG4gICAgZWxzZSBpZiBpc19kaXJfc2VwIG5hbWUgbiB0aGVuIGludGVybWVkaWF0ZV9zZXAgblxuICAgIGVsc2UgYmFzZSAobiAtIDEpXG4gIGFuZCBpbnRlcm1lZGlhdGVfc2VwIG4gPVxuICAgIGlmIG4gPCAwIHRoZW4gU3RyaW5nLnN1YiBuYW1lIDAgMVxuICAgIGVsc2UgaWYgaXNfZGlyX3NlcCBuYW1lIG4gdGhlbiBpbnRlcm1lZGlhdGVfc2VwIChuIC0gMSlcbiAgICBlbHNlIFN0cmluZy5zdWIgbmFtZSAwIChuICsgMSlcbiAgaW5cbiAgaWYgbmFtZSA9IFwiXCJcbiAgdGhlbiBjdXJyZW50X2Rpcl9uYW1lXG4gIGVsc2UgdHJhaWxpbmdfc2VwIChTdHJpbmcubGVuZ3RoIG5hbWUgLSAxKVxuXG5tb2R1bGUgdHlwZSBTWVNERVBTID0gc2lnXG4gIHZhbCBudWxsIDogc3RyaW5nXG4gIHZhbCBjdXJyZW50X2Rpcl9uYW1lIDogc3RyaW5nXG4gIHZhbCBwYXJlbnRfZGlyX25hbWUgOiBzdHJpbmdcbiAgdmFsIGRpcl9zZXAgOiBzdHJpbmdcbiAgdmFsIGlzX2Rpcl9zZXAgOiBzdHJpbmcgLT4gaW50IC0+IGJvb2xcbiAgdmFsIGlzX3JlbGF0aXZlIDogc3RyaW5nIC0+IGJvb2xcbiAgdmFsIGlzX2ltcGxpY2l0IDogc3RyaW5nIC0+IGJvb2xcbiAgdmFsIGNoZWNrX3N1ZmZpeCA6IHN0cmluZyAtPiBzdHJpbmcgLT4gYm9vbFxuICB2YWwgY2hvcF9zdWZmaXhfb3B0IDogc3VmZml4OnN0cmluZyAtPiBzdHJpbmcgLT4gc3RyaW5nIG9wdGlvblxuICB2YWwgdGVtcF9kaXJfbmFtZSA6IHN0cmluZ1xuICB2YWwgcXVvdGUgOiBzdHJpbmcgLT4gc3RyaW5nXG4gIHZhbCBxdW90ZV9jb21tYW5kIDpcbiAgICBzdHJpbmcgLT4gP3N0ZGluOiBzdHJpbmcgLT4gP3N0ZG91dDogc3RyaW5nIC0+ID9zdGRlcnI6IHN0cmluZ1xuICAgICAgICAgICAtPiBzdHJpbmcgbGlzdCAtPiBzdHJpbmdcbiAgdmFsIGJhc2VuYW1lIDogc3RyaW5nIC0+IHN0cmluZ1xuICB2YWwgZGlybmFtZSA6IHN0cmluZyAtPiBzdHJpbmdcbmVuZFxuXG5tb2R1bGUgVW5peCA6IFNZU0RFUFMgPSBzdHJ1Y3RcbiAgbGV0IG51bGwgPSBcIi9kZXYvbnVsbFwiXG4gIGxldCBjdXJyZW50X2Rpcl9uYW1lID0gXCIuXCJcbiAgbGV0IHBhcmVudF9kaXJfbmFtZSA9IFwiLi5cIlxuICBsZXQgZGlyX3NlcCA9IFwiL1wiXG4gIGxldCBpc19kaXJfc2VwIHMgaSA9IHMuW2ldID0gJy8nXG4gIGxldCBpc19yZWxhdGl2ZSBuID0gU3RyaW5nLmxlbmd0aCBuIDwgMSB8fCBuLlswXSA8PiAnLydcbiAgbGV0IGlzX2ltcGxpY2l0IG4gPVxuICAgIGlzX3JlbGF0aXZlIG5cbiAgICAmJiAoU3RyaW5nLmxlbmd0aCBuIDwgMiB8fCBTdHJpbmcuc3ViIG4gMCAyIDw+IFwiLi9cIilcbiAgICAmJiAoU3RyaW5nLmxlbmd0aCBuIDwgMyB8fCBTdHJpbmcuc3ViIG4gMCAzIDw+IFwiLi4vXCIpXG4gIGxldCBjaGVja19zdWZmaXggbmFtZSBzdWZmID1cbiAgICBTdHJpbmcuZW5kc193aXRoIH5zdWZmaXg6c3VmZiBuYW1lXG5cbiAgbGV0IGNob3Bfc3VmZml4X29wdCB+c3VmZml4IGZpbGVuYW1lID1cbiAgICBsZXQgbGVuX3MgPSBTdHJpbmcubGVuZ3RoIHN1ZmZpeCBhbmQgbGVuX2YgPSBTdHJpbmcubGVuZ3RoIGZpbGVuYW1lIGluXG4gICAgaWYgbGVuX2YgPj0gbGVuX3MgdGhlblxuICAgICAgbGV0IHIgPSBTdHJpbmcuc3ViIGZpbGVuYW1lIChsZW5fZiAtIGxlbl9zKSBsZW5fcyBpblxuICAgICAgaWYgciA9IHN1ZmZpeCB0aGVuXG4gICAgICAgIFNvbWUgKFN0cmluZy5zdWIgZmlsZW5hbWUgMCAobGVuX2YgLSBsZW5fcykpXG4gICAgICBlbHNlXG4gICAgICAgIE5vbmVcbiAgICBlbHNlXG4gICAgICBOb25lXG5cbiAgbGV0IHRlbXBfZGlyX25hbWUgPVxuICAgIHRyeSBTeXMuZ2V0ZW52IFwiVE1QRElSXCIgd2l0aCBOb3RfZm91bmQgLT4gXCIvdG1wXCJcbiAgbGV0IHF1b3RlID0gZ2VuZXJpY19xdW90ZSBcIidcXFxcJydcIlxuICBsZXQgcXVvdGVfY29tbWFuZCBjbWQgP3N0ZGluID9zdGRvdXQgP3N0ZGVyciBhcmdzID1cbiAgICBTdHJpbmcuY29uY2F0IFwiIFwiIChMaXN0Lm1hcCBxdW90ZSAoY21kIDo6IGFyZ3MpKVxuICAgIF4gKG1hdGNoIHN0ZGluICB3aXRoIE5vbmUgLT4gXCJcIiB8IFNvbWUgZiAtPiBcIiA8XCIgXiBxdW90ZSBmKVxuICAgIF4gKG1hdGNoIHN0ZG91dCB3aXRoIE5vbmUgLT4gXCJcIiB8IFNvbWUgZiAtPiBcIiA+XCIgXiBxdW90ZSBmKVxuICAgIF4gKG1hdGNoIHN0ZGVyciB3aXRoIE5vbmUgLT4gXCJcIiB8IFNvbWUgZiAtPiBpZiBzdGRlcnIgPSBzdGRvdXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZW4gXCIgMj4mMVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIFwiIDI+XCIgXiBxdW90ZSBmKVxuICBsZXQgYmFzZW5hbWUgPSBnZW5lcmljX2Jhc2VuYW1lIGlzX2Rpcl9zZXAgY3VycmVudF9kaXJfbmFtZVxuICBsZXQgZGlybmFtZSA9IGdlbmVyaWNfZGlybmFtZSBpc19kaXJfc2VwIGN1cnJlbnRfZGlyX25hbWVcbmVuZFxuXG5tb2R1bGUgV2luMzIgOiBTWVNERVBTID0gc3RydWN0XG4gIGxldCBudWxsID0gXCJOVUxcIlxuICBsZXQgY3VycmVudF9kaXJfbmFtZSA9IFwiLlwiXG4gIGxldCBwYXJlbnRfZGlyX25hbWUgPSBcIi4uXCJcbiAgbGV0IGRpcl9zZXAgPSBcIlxcXFxcIlxuICBsZXQgaXNfZGlyX3NlcCBzIGkgPSBsZXQgYyA9IHMuW2ldIGluIGMgPSAnLycgfHwgYyA9ICdcXFxcJyB8fCBjID0gJzonXG4gIGxldCBpc19yZWxhdGl2ZSBuID1cbiAgICAoU3RyaW5nLmxlbmd0aCBuIDwgMSB8fCBuLlswXSA8PiAnLycpXG4gICAgJiYgKFN0cmluZy5sZW5ndGggbiA8IDEgfHwgbi5bMF0gPD4gJ1xcXFwnKVxuICAgICYmIChTdHJpbmcubGVuZ3RoIG4gPCAyIHx8IG4uWzFdIDw+ICc6JylcbiAgbGV0IGlzX2ltcGxpY2l0IG4gPVxuICAgIGlzX3JlbGF0aXZlIG5cbiAgICAmJiAoU3RyaW5nLmxlbmd0aCBuIDwgMiB8fCBTdHJpbmcuc3ViIG4gMCAyIDw+IFwiLi9cIilcbiAgICAmJiAoU3RyaW5nLmxlbmd0aCBuIDwgMiB8fCBTdHJpbmcuc3ViIG4gMCAyIDw+IFwiLlxcXFxcIilcbiAgICAmJiAoU3RyaW5nLmxlbmd0aCBuIDwgMyB8fCBTdHJpbmcuc3ViIG4gMCAzIDw+IFwiLi4vXCIpXG4gICAgJiYgKFN0cmluZy5sZW5ndGggbiA8IDMgfHwgU3RyaW5nLnN1YiBuIDAgMyA8PiBcIi4uXFxcXFwiKVxuICBsZXQgY2hlY2tfc3VmZml4IG5hbWUgc3VmZiA9XG4gICBTdHJpbmcubGVuZ3RoIG5hbWUgPj0gU3RyaW5nLmxlbmd0aCBzdWZmICYmXG4gICAobGV0IHMgPSBTdHJpbmcuc3ViIG5hbWUgKFN0cmluZy5sZW5ndGggbmFtZSAtIFN0cmluZy5sZW5ndGggc3VmZilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoU3RyaW5nLmxlbmd0aCBzdWZmKSBpblxuICAgIFN0cmluZy5sb3dlcmNhc2VfYXNjaWkgcyA9IFN0cmluZy5sb3dlcmNhc2VfYXNjaWkgc3VmZilcblxuICBsZXQgY2hvcF9zdWZmaXhfb3B0IH5zdWZmaXggZmlsZW5hbWUgPVxuICAgIGxldCBsZW5fcyA9IFN0cmluZy5sZW5ndGggc3VmZml4IGFuZCBsZW5fZiA9IFN0cmluZy5sZW5ndGggZmlsZW5hbWUgaW5cbiAgICBpZiBsZW5fZiA+PSBsZW5fcyB0aGVuXG4gICAgICBsZXQgciA9IFN0cmluZy5zdWIgZmlsZW5hbWUgKGxlbl9mIC0gbGVuX3MpIGxlbl9zIGluXG4gICAgICBpZiBTdHJpbmcubG93ZXJjYXNlX2FzY2lpIHIgPSBTdHJpbmcubG93ZXJjYXNlX2FzY2lpIHN1ZmZpeCB0aGVuXG4gICAgICAgIFNvbWUgKFN0cmluZy5zdWIgZmlsZW5hbWUgMCAobGVuX2YgLSBsZW5fcykpXG4gICAgICBlbHNlXG4gICAgICAgIE5vbmVcbiAgICBlbHNlXG4gICAgICBOb25lXG5cblxuICBsZXQgdGVtcF9kaXJfbmFtZSA9XG4gICAgdHJ5IFN5cy5nZXRlbnYgXCJURU1QXCIgd2l0aCBOb3RfZm91bmQgLT4gXCIuXCJcbiAgbGV0IHF1b3RlIHMgPVxuICAgIGxldCBsID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gICAgbGV0IGIgPSBCdWZmZXIuY3JlYXRlIChsICsgMjApIGluXG4gICAgQnVmZmVyLmFkZF9jaGFyIGIgJ1xcXCInO1xuICAgIGxldCByZWMgbG9vcCBpID1cbiAgICAgIGlmIGkgPSBsIHRoZW4gQnVmZmVyLmFkZF9jaGFyIGIgJ1xcXCInIGVsc2VcbiAgICAgIG1hdGNoIHMuW2ldIHdpdGhcbiAgICAgIHwgJ1xcXCInIC0+IGxvb3BfYnMgMCBpO1xuICAgICAgfCAnXFxcXCcgLT4gbG9vcF9icyAwIGk7XG4gICAgICB8IGMgICAgLT4gQnVmZmVyLmFkZF9jaGFyIGIgYzsgbG9vcCAoaSsxKTtcbiAgICBhbmQgbG9vcF9icyBuIGkgPVxuICAgICAgaWYgaSA9IGwgdGhlbiBiZWdpblxuICAgICAgICBCdWZmZXIuYWRkX2NoYXIgYiAnXFxcIic7XG4gICAgICAgIGFkZF9icyBuO1xuICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgbWF0Y2ggcy5baV0gd2l0aFxuICAgICAgICB8ICdcXFwiJyAtPiBhZGRfYnMgKDIqbisxKTsgQnVmZmVyLmFkZF9jaGFyIGIgJ1xcXCInOyBsb29wIChpKzEpO1xuICAgICAgICB8ICdcXFxcJyAtPiBsb29wX2JzIChuKzEpIChpKzEpO1xuICAgICAgICB8IF8gICAgLT4gYWRkX2JzIG47IGxvb3AgaVxuICAgICAgZW5kXG4gICAgYW5kIGFkZF9icyBuID0gZm9yIF9qID0gMSB0byBuIGRvIEJ1ZmZlci5hZGRfY2hhciBiICdcXFxcJzsgZG9uZVxuICAgIGluXG4gICAgbG9vcCAwO1xuICAgIEJ1ZmZlci5jb250ZW50cyBiXG4oKlxuUXVvdGluZyBjb21tYW5kcyBmb3IgZXhlY3V0aW9uIGJ5IGNtZC5leGUgaXMgZGlmZmljdWx0LlxuMS0gRWFjaCBhcmd1bWVudCBpcyBmaXJzdCBxdW90ZWQgdXNpbmcgdGhlIFwicXVvdGVcIiBmdW5jdGlvbiBhYm92ZSwgdG9cbiAgIHByb3RlY3QgaXQgYWdhaW5zdCB0aGUgcHJvY2Vzc2luZyBwZXJmb3JtZWQgYnkgdGhlIEMgcnVudGltZSBzeXN0ZW0sXG4gICB0aGVuIGNtZC5leGUncyBzcGVjaWFsIGNoYXJhY3RlcnMgYXJlIGVzY2FwZWQgd2l0aCAnXicsIHVzaW5nXG4gICB0aGUgXCJxdW90ZV9jbWRcIiBmdW5jdGlvbiBiZWxvdy4gIEZvciBtb3JlIGRldGFpbHMsIHNlZVxuICAgaHR0cHM6Ly9ibG9ncy5tc2RuLm1pY3Jvc29mdC5jb20vdHdpc3R5bGl0dGxlcGFzc2FnZXNhbGxhbGlrZS8yMDExLzA0LzIzXG4yLSBUaGUgY29tbWFuZCBhbmQgdGhlIHJlZGlyZWN0aW9uIGZpbGVzLCBpZiBhbnksIG11c3QgYmUgZG91YmxlLXF1b3RlZFxuICAgaW4gY2FzZSB0aGV5IGNvbnRhaW4gc3BhY2VzLiAgVGhpcyBxdW90aW5nIGlzIGludGVycHJldGVkIGJ5IGNtZC5leGUsXG4gICBub3QgYnkgdGhlIEMgcnVudGltZSBzeXN0ZW0sIGhlbmNlIHRoZSBcInF1b3RlXCIgZnVuY3Rpb24gYWJvdmVcbiAgIGNhbm5vdCBiZSB1c2VkLiAgVGhlIHR3byBjaGFyYWN0ZXJzIHdlIGRvbid0IGtub3cgaG93IHRvIHF1b3RlXG4gICBpbnNpZGUgYSBkb3VibGUtcXVvdGVkIGNtZC5leGUgc3RyaW5nIGFyZSBkb3VibGUtcXVvdGUgYW5kIHBlcmNlbnQuXG4gICBXZSBqdXN0IGZhaWwgaWYgdGhlIGNvbW1hbmQgbmFtZSBvciB0aGUgcmVkaXJlY3Rpb24gZmlsZSBuYW1lc1xuICAgY29udGFpbiBhIGRvdWJsZSBxdW90ZSAobm90IGFsbG93ZWQgaW4gV2luZG93cyBmaWxlIG5hbWVzLCBhbnl3YXkpXG4gICBvciBhIHBlcmNlbnQuICBTZWUgZnVuY3Rpb24gXCJxdW90ZV9jbWRfZmlsZW5hbWVcIiBiZWxvdy5cbjMtIFRoZSB3aG9sZSBzdHJpbmcgcGFzc2VkIHRvIFN5cy5jb21tYW5kIGlzIHRoZW4gZW5jbG9zZWQgaW4gZG91YmxlXG4gICBxdW90ZXMsIHdoaWNoIGFyZSBpbW1lZGlhdGVseSBzdHJpcHBlZCBieSBjbWQuZXhlLiAgT3RoZXJ3aXNlLFxuICAgc29tZSBvZiB0aGUgZG91YmxlIHF1b3RlcyBmcm9tIHN0ZXAgMiBhYm92ZSBjYW4gYmUgbWlzcGFyc2VkLlxuICAgU2VlIGUuZy4gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzk5NjUxNDFcbiopXG4gIGxldCBxdW90ZV9jbWQgcyA9XG4gICAgbGV0IGIgPSBCdWZmZXIuY3JlYXRlIChTdHJpbmcubGVuZ3RoIHMgKyAyMCkgaW5cbiAgICBTdHJpbmcuaXRlclxuICAgICAgKGZ1biBjIC0+XG4gICAgICAgIG1hdGNoIGMgd2l0aFxuICAgICAgICB8ICcoJyB8ICcpJyB8ICchJyB8ICdeJyB8ICclJyB8ICdcXFwiJyB8ICc8JyB8ICc+JyB8ICcmJyB8ICd8JyAtPlxuICAgICAgICAgICAgQnVmZmVyLmFkZF9jaGFyIGIgJ14nOyBCdWZmZXIuYWRkX2NoYXIgYiBjXG4gICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgQnVmZmVyLmFkZF9jaGFyIGIgYylcbiAgICAgIHM7XG4gICAgQnVmZmVyLmNvbnRlbnRzIGJcbiAgbGV0IHF1b3RlX2NtZF9maWxlbmFtZSBmID1cbiAgICBpZiBTdHJpbmcuY29udGFpbnMgZiAnXFxcIicgfHwgU3RyaW5nLmNvbnRhaW5zIGYgJyUnIHRoZW5cbiAgICAgIGZhaWx3aXRoIChcIkZpbGVuYW1lLnF1b3RlX2NvbW1hbmQ6IGJhZCBmaWxlIG5hbWUgXCIgXiBmKVxuICAgIGVsc2UgaWYgU3RyaW5nLmNvbnRhaW5zIGYgJyAnIHRoZW5cbiAgICAgIFwiXFxcIlwiIF4gZiBeIFwiXFxcIlwiXG4gICAgZWxzZVxuICAgICAgZlxuICAoKiBSZWRpcmVjdGlvbnMgaW4gY21kLmV4ZTogc2VlIGh0dHBzOi8vc3M2NC5jb20vbnQvc3ludGF4LXJlZGlyZWN0aW9uLmh0bWxcbiAgICAgYW5kIGh0dHBzOi8vZG9jcy5taWNyb3NvZnQuY29tL2VuLXVzL3ByZXZpb3VzLXZlcnNpb25zL3dpbmRvd3MvaXQtcHJvL3dpbmRvd3MteHAvYmI0OTA5ODIodj10ZWNobmV0LjEwKVxuICAqKVxuICBsZXQgcXVvdGVfY29tbWFuZCBjbWQgP3N0ZGluID9zdGRvdXQgP3N0ZGVyciBhcmdzID1cbiAgICBTdHJpbmcuY29uY2F0IFwiXCIgW1xuICAgICAgXCJcXFwiXCI7XG4gICAgICBxdW90ZV9jbWRfZmlsZW5hbWUgY21kO1xuICAgICAgXCIgXCI7XG4gICAgICBxdW90ZV9jbWQgKFN0cmluZy5jb25jYXQgXCIgXCIgKExpc3QubWFwIHF1b3RlIGFyZ3MpKTtcbiAgICAgIChtYXRjaCBzdGRpbiAgd2l0aCBOb25lIC0+IFwiXCIgfCBTb21lIGYgLT4gXCIgPFwiIF4gcXVvdGVfY21kX2ZpbGVuYW1lIGYpO1xuICAgICAgKG1hdGNoIHN0ZG91dCB3aXRoIE5vbmUgLT4gXCJcIiB8IFNvbWUgZiAtPiBcIiA+XCIgXiBxdW90ZV9jbWRfZmlsZW5hbWUgZik7XG4gICAgICAobWF0Y2ggc3RkZXJyIHdpdGggTm9uZSAtPiBcIlwiIHwgU29tZSBmIC0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgc3RkZXJyID0gc3Rkb3V0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlbiBcIiAyPiYxXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIFwiIDI+XCIgXiBxdW90ZV9jbWRfZmlsZW5hbWUgZik7XG4gICAgICBcIlxcXCJcIlxuICAgIF1cbiAgbGV0IGhhc19kcml2ZSBzID1cbiAgICBsZXQgaXNfbGV0dGVyID0gZnVuY3Rpb25cbiAgICAgIHwgJ0EnIC4uICdaJyB8ICdhJyAuLiAneicgLT4gdHJ1ZVxuICAgICAgfCBfIC0+IGZhbHNlXG4gICAgaW5cbiAgICBTdHJpbmcubGVuZ3RoIHMgPj0gMiAmJiBpc19sZXR0ZXIgcy5bMF0gJiYgcy5bMV0gPSAnOidcbiAgbGV0IGRyaXZlX2FuZF9wYXRoIHMgPVxuICAgIGlmIGhhc19kcml2ZSBzXG4gICAgdGhlbiAoU3RyaW5nLnN1YiBzIDAgMiwgU3RyaW5nLnN1YiBzIDIgKFN0cmluZy5sZW5ndGggcyAtIDIpKVxuICAgIGVsc2UgKFwiXCIsIHMpXG4gIGxldCBkaXJuYW1lIHMgPVxuICAgIGxldCAoZHJpdmUsIHBhdGgpID0gZHJpdmVfYW5kX3BhdGggcyBpblxuICAgIGxldCBkaXIgPSBnZW5lcmljX2Rpcm5hbWUgaXNfZGlyX3NlcCBjdXJyZW50X2Rpcl9uYW1lIHBhdGggaW5cbiAgICBkcml2ZSBeIGRpclxuICBsZXQgYmFzZW5hbWUgcyA9XG4gICAgbGV0IChfZHJpdmUsIHBhdGgpID0gZHJpdmVfYW5kX3BhdGggcyBpblxuICAgIGdlbmVyaWNfYmFzZW5hbWUgaXNfZGlyX3NlcCBjdXJyZW50X2Rpcl9uYW1lIHBhdGhcbmVuZFxuXG5tb2R1bGUgQ3lnd2luIDogU1lTREVQUyA9IHN0cnVjdFxuICBsZXQgbnVsbCA9IFwiL2Rldi9udWxsXCJcbiAgbGV0IGN1cnJlbnRfZGlyX25hbWUgPSBcIi5cIlxuICBsZXQgcGFyZW50X2Rpcl9uYW1lID0gXCIuLlwiXG4gIGxldCBkaXJfc2VwID0gXCIvXCJcbiAgbGV0IGlzX2Rpcl9zZXAgPSBXaW4zMi5pc19kaXJfc2VwXG4gIGxldCBpc19yZWxhdGl2ZSA9IFdpbjMyLmlzX3JlbGF0aXZlXG4gIGxldCBpc19pbXBsaWNpdCA9IFdpbjMyLmlzX2ltcGxpY2l0XG4gIGxldCBjaGVja19zdWZmaXggPSBXaW4zMi5jaGVja19zdWZmaXhcbiAgbGV0IGNob3Bfc3VmZml4X29wdCA9IFdpbjMyLmNob3Bfc3VmZml4X29wdFxuICBsZXQgdGVtcF9kaXJfbmFtZSA9IFVuaXgudGVtcF9kaXJfbmFtZVxuICBsZXQgcXVvdGUgPSBVbml4LnF1b3RlXG4gIGxldCBxdW90ZV9jb21tYW5kID0gVW5peC5xdW90ZV9jb21tYW5kXG4gIGxldCBiYXNlbmFtZSA9IGdlbmVyaWNfYmFzZW5hbWUgaXNfZGlyX3NlcCBjdXJyZW50X2Rpcl9uYW1lXG4gIGxldCBkaXJuYW1lID0gZ2VuZXJpY19kaXJuYW1lIGlzX2Rpcl9zZXAgY3VycmVudF9kaXJfbmFtZVxuZW5kXG5cbm1vZHVsZSBTeXNkZXBzID1cbiAgKHZhbCAobWF0Y2ggU3lzLm9zX3R5cGUgd2l0aFxuICAgICAgIHwgXCJXaW4zMlwiIC0+IChtb2R1bGUgV2luMzI6IFNZU0RFUFMpXG4gICAgICAgfCBcIkN5Z3dpblwiIC0+IChtb2R1bGUgQ3lnd2luOiBTWVNERVBTKVxuICAgICAgIHwgXyAtPiAobW9kdWxlIFVuaXg6IFNZU0RFUFMpKSlcblxuaW5jbHVkZSBTeXNkZXBzXG5cbmxldCBjb25jYXQgZGlybmFtZSBmaWxlbmFtZSA9XG4gIGxldCBsID0gU3RyaW5nLmxlbmd0aCBkaXJuYW1lIGluXG4gIGlmIGwgPSAwIHx8IGlzX2Rpcl9zZXAgZGlybmFtZSAobC0xKVxuICB0aGVuIGRpcm5hbWUgXiBmaWxlbmFtZVxuICBlbHNlIGRpcm5hbWUgXiBkaXJfc2VwIF4gZmlsZW5hbWVcblxubGV0IGNob3Bfc3VmZml4IG5hbWUgc3VmZiA9XG4gIGlmIGNoZWNrX3N1ZmZpeCBuYW1lIHN1ZmZcbiAgdGhlbiBTdHJpbmcuc3ViIG5hbWUgMCAoU3RyaW5nLmxlbmd0aCBuYW1lIC0gU3RyaW5nLmxlbmd0aCBzdWZmKVxuICBlbHNlIGludmFsaWRfYXJnIFwiRmlsZW5hbWUuY2hvcF9zdWZmaXhcIlxuXG5sZXQgZXh0ZW5zaW9uX2xlbiBuYW1lID1cbiAgbGV0IHJlYyBjaGVjayBpMCBpID1cbiAgICBpZiBpIDwgMCB8fCBpc19kaXJfc2VwIG5hbWUgaSB0aGVuIDBcbiAgICBlbHNlIGlmIG5hbWUuW2ldID0gJy4nIHRoZW4gY2hlY2sgaTAgKGkgLSAxKVxuICAgIGVsc2UgU3RyaW5nLmxlbmd0aCBuYW1lIC0gaTBcbiAgaW5cbiAgbGV0IHJlYyBzZWFyY2hfZG90IGkgPVxuICAgIGlmIGkgPCAwIHx8IGlzX2Rpcl9zZXAgbmFtZSBpIHRoZW4gMFxuICAgIGVsc2UgaWYgbmFtZS5baV0gPSAnLicgdGhlbiBjaGVjayBpIChpIC0gMSlcbiAgICBlbHNlIHNlYXJjaF9kb3QgKGkgLSAxKVxuICBpblxuICBzZWFyY2hfZG90IChTdHJpbmcubGVuZ3RoIG5hbWUgLSAxKVxuXG5sZXQgZXh0ZW5zaW9uIG5hbWUgPVxuICBsZXQgbCA9IGV4dGVuc2lvbl9sZW4gbmFtZSBpblxuICBpZiBsID0gMCB0aGVuIFwiXCIgZWxzZSBTdHJpbmcuc3ViIG5hbWUgKFN0cmluZy5sZW5ndGggbmFtZSAtIGwpIGxcblxubGV0IGNob3BfZXh0ZW5zaW9uIG5hbWUgPVxuICBsZXQgbCA9IGV4dGVuc2lvbl9sZW4gbmFtZSBpblxuICBpZiBsID0gMCB0aGVuIGludmFsaWRfYXJnIFwiRmlsZW5hbWUuY2hvcF9leHRlbnNpb25cIlxuICBlbHNlIFN0cmluZy5zdWIgbmFtZSAwIChTdHJpbmcubGVuZ3RoIG5hbWUgLSBsKVxuXG5sZXQgcmVtb3ZlX2V4dGVuc2lvbiBuYW1lID1cbiAgbGV0IGwgPSBleHRlbnNpb25fbGVuIG5hbWUgaW5cbiAgaWYgbCA9IDAgdGhlbiBuYW1lIGVsc2UgU3RyaW5nLnN1YiBuYW1lIDAgKFN0cmluZy5sZW5ndGggbmFtZSAtIGwpXG5cbmV4dGVybmFsIG9wZW5fZGVzYzogc3RyaW5nIC0+IG9wZW5fZmxhZyBsaXN0IC0+IGludCAtPiBpbnQgPSBcImNhbWxfc3lzX29wZW5cIlxuZXh0ZXJuYWwgY2xvc2VfZGVzYzogaW50IC0+IHVuaXQgPSBcImNhbWxfc3lzX2Nsb3NlXCJcblxubGV0IHBybmcgPSBsYXp5KFJhbmRvbS5TdGF0ZS5tYWtlX3NlbGZfaW5pdCAoKSlcblxubGV0IHRlbXBfZmlsZV9uYW1lIHRlbXBfZGlyIHByZWZpeCBzdWZmaXggPVxuICBsZXQgcm5kID0gKFJhbmRvbS5TdGF0ZS5iaXRzIChMYXp5LmZvcmNlIHBybmcpKSBsYW5kIDB4RkZGRkZGIGluXG4gIGNvbmNhdCB0ZW1wX2RpciAoUHJpbnRmLnNwcmludGYgXCIlcyUwNnglc1wiIHByZWZpeCBybmQgc3VmZml4KVxuXG5cbmxldCBjdXJyZW50X3RlbXBfZGlyX25hbWUgPSByZWYgdGVtcF9kaXJfbmFtZVxuXG5sZXQgc2V0X3RlbXBfZGlyX25hbWUgcyA9IGN1cnJlbnRfdGVtcF9kaXJfbmFtZSA6PSBzXG5sZXQgZ2V0X3RlbXBfZGlyX25hbWUgKCkgPSAhY3VycmVudF90ZW1wX2Rpcl9uYW1lXG5cbmxldCB0ZW1wX2ZpbGUgPyh0ZW1wX2RpciA9ICFjdXJyZW50X3RlbXBfZGlyX25hbWUpIHByZWZpeCBzdWZmaXggPVxuICBsZXQgcmVjIHRyeV9uYW1lIGNvdW50ZXIgPVxuICAgIGxldCBuYW1lID0gdGVtcF9maWxlX25hbWUgdGVtcF9kaXIgcHJlZml4IHN1ZmZpeCBpblxuICAgIHRyeVxuICAgICAgY2xvc2VfZGVzYyhvcGVuX2Rlc2MgbmFtZSBbT3Blbl93cm9ubHk7IE9wZW5fY3JlYXQ7IE9wZW5fZXhjbF0gMG82MDApO1xuICAgICAgbmFtZVxuICAgIHdpdGggU3lzX2Vycm9yIF8gYXMgZSAtPlxuICAgICAgaWYgY291bnRlciA+PSAxMDAwIHRoZW4gcmFpc2UgZSBlbHNlIHRyeV9uYW1lIChjb3VudGVyICsgMSlcbiAgaW4gdHJ5X25hbWUgMFxuXG5sZXQgb3Blbl90ZW1wX2ZpbGUgPyhtb2RlID0gW09wZW5fdGV4dF0pID8ocGVybXMgPSAwbzYwMClcbiAgICAgICAgICAgICAgICAgICA/KHRlbXBfZGlyID0gIWN1cnJlbnRfdGVtcF9kaXJfbmFtZSkgcHJlZml4IHN1ZmZpeCA9XG4gIGxldCByZWMgdHJ5X25hbWUgY291bnRlciA9XG4gICAgbGV0IG5hbWUgPSB0ZW1wX2ZpbGVfbmFtZSB0ZW1wX2RpciBwcmVmaXggc3VmZml4IGluXG4gICAgdHJ5XG4gICAgICAobmFtZSxcbiAgICAgICBvcGVuX291dF9nZW4gKE9wZW5fd3Jvbmx5OjpPcGVuX2NyZWF0OjpPcGVuX2V4Y2w6Om1vZGUpIHBlcm1zIG5hbWUpXG4gICAgd2l0aCBTeXNfZXJyb3IgXyBhcyBlIC0+XG4gICAgICBpZiBjb3VudGVyID49IDEwMDAgdGhlbiByYWlzZSBlIGVsc2UgdHJ5X25hbWUgKGNvdW50ZXIgKyAxKVxuICBpbiB0cnlfbmFtZSAwXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDAyIEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIENvbXBsZXggbnVtYmVycyAqKVxuXG50eXBlIHQgPSB7IHJlOiBmbG9hdDsgaW06IGZsb2F0IH1cblxubGV0IHplcm8gPSB7IHJlID0gMC4wOyBpbSA9IDAuMCB9XG5sZXQgb25lID0geyByZSA9IDEuMDsgaW0gPSAwLjAgfVxubGV0IGkgPSB7IHJlID0gMC4wOyBpbSA9IDEuMCB9XG5cbmxldCBhZGQgeCB5ID0geyByZSA9IHgucmUgKy4geS5yZTsgaW0gPSB4LmltICsuIHkuaW0gfVxuXG5sZXQgc3ViIHggeSA9IHsgcmUgPSB4LnJlIC0uIHkucmU7IGltID0geC5pbSAtLiB5LmltIH1cblxubGV0IG5lZyB4ID0geyByZSA9IC0uIHgucmU7IGltID0gLS4geC5pbSB9XG5cbmxldCBjb25qIHggPSB7IHJlID0geC5yZTsgaW0gPSAtLiB4LmltIH1cblxubGV0IG11bCB4IHkgPSB7IHJlID0geC5yZSAqLiB5LnJlIC0uIHguaW0gKi4geS5pbTtcbiAgICAgICAgICAgICAgICBpbSA9IHgucmUgKi4geS5pbSArLiB4LmltICouIHkucmUgfVxuXG5sZXQgZGl2IHggeSA9XG4gIGlmIGFic19mbG9hdCB5LnJlID49IGFic19mbG9hdCB5LmltIHRoZW5cbiAgICBsZXQgciA9IHkuaW0gLy4geS5yZSBpblxuICAgIGxldCBkID0geS5yZSArLiByICouIHkuaW0gaW5cbiAgICB7IHJlID0gKHgucmUgKy4gciAqLiB4LmltKSAvLiBkO1xuICAgICAgaW0gPSAoeC5pbSAtLiByICouIHgucmUpIC8uIGQgfVxuICBlbHNlXG4gICAgbGV0IHIgPSB5LnJlIC8uIHkuaW0gaW5cbiAgICBsZXQgZCA9IHkuaW0gKy4gciAqLiB5LnJlIGluXG4gICAgeyByZSA9IChyICouIHgucmUgKy4geC5pbSkgLy4gZDtcbiAgICAgIGltID0gKHIgKi4geC5pbSAtLiB4LnJlKSAvLiBkIH1cblxubGV0IGludiB4ID0gZGl2IG9uZSB4XG5cbmxldCBub3JtMiB4ID0geC5yZSAqLiB4LnJlICsuIHguaW0gKi4geC5pbVxuXG5sZXQgbm9ybSB4ID1cbiAgKCogV2F0Y2ggb3V0IGZvciBvdmVyZmxvdyBpbiBjb21wdXRpbmcgcmVeMiArIGltXjIgKilcbiAgbGV0IHIgPSBhYnNfZmxvYXQgeC5yZSBhbmQgaSA9IGFic19mbG9hdCB4LmltIGluXG4gIGlmIHIgPSAwLjAgdGhlbiBpXG4gIGVsc2UgaWYgaSA9IDAuMCB0aGVuIHJcbiAgZWxzZSBpZiByID49IGkgdGhlblxuICAgIGxldCBxID0gaSAvLiByIGluIHIgKi4gc3FydCgxLjAgKy4gcSAqLiBxKVxuICBlbHNlXG4gICAgbGV0IHEgPSByIC8uIGkgaW4gaSAqLiBzcXJ0KDEuMCArLiBxICouIHEpXG5cbmxldCBhcmcgeCA9IGF0YW4yIHguaW0geC5yZVxuXG5sZXQgcG9sYXIgbiBhID0geyByZSA9IGNvcyBhICouIG47IGltID0gc2luIGEgKi4gbiB9XG5cbmxldCBzcXJ0IHggPVxuICBpZiB4LnJlID0gMC4wICYmIHguaW0gPSAwLjAgdGhlbiB7IHJlID0gMC4wOyBpbSA9IDAuMCB9XG4gIGVsc2UgYmVnaW5cbiAgICBsZXQgciA9IGFic19mbG9hdCB4LnJlIGFuZCBpID0gYWJzX2Zsb2F0IHguaW0gaW5cbiAgICBsZXQgdyA9XG4gICAgICBpZiByID49IGkgdGhlbiBiZWdpblxuICAgICAgICBsZXQgcSA9IGkgLy4gciBpblxuICAgICAgICBzcXJ0KHIpICouIHNxcnQoMC41ICouICgxLjAgKy4gc3FydCgxLjAgKy4gcSAqLiBxKSkpXG4gICAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgICBsZXQgcSA9IHIgLy4gaSBpblxuICAgICAgICBzcXJ0KGkpICouIHNxcnQoMC41ICouIChxICsuIHNxcnQoMS4wICsuIHEgKi4gcSkpKVxuICAgICAgZW5kIGluXG4gICAgaWYgeC5yZSA+PSAwLjBcbiAgICB0aGVuIHsgcmUgPSB3OyAgaW0gPSAwLjUgKi4geC5pbSAvLiB3IH1cbiAgICBlbHNlIHsgcmUgPSAwLjUgKi4gaSAvLiB3OyAgaW0gPSBpZiB4LmltID49IDAuMCB0aGVuIHcgZWxzZSAtLiB3IH1cbiAgZW5kXG5cbmxldCBleHAgeCA9XG4gIGxldCBlID0gZXhwIHgucmUgaW4geyByZSA9IGUgKi4gY29zIHguaW07IGltID0gZSAqLiBzaW4geC5pbSB9XG5cbmxldCBsb2cgeCA9IHsgcmUgPSBsb2cgKG5vcm0geCk7IGltID0gYXRhbjIgeC5pbSB4LnJlIH1cblxubGV0IHBvdyB4IHkgPSBleHAgKG11bCB5IChsb2cgeCkpXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgTWFudWVsIFNlcnJhbm8gZXQgWGF2aWVyIExlcm95LCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDAwIEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIE1vZHVsZSBbQmlnYXJyYXldOiBsYXJnZSwgbXVsdGktZGltZW5zaW9uYWwsIG51bWVyaWNhbCBhcnJheXMgKilcblxuKCogVGhlc2UgdHlwZXMgaW4gbXVzdCBiZSBrZXB0IGluIHN5bmMgd2l0aCB0aGUgdGFibGVzIGluXG4gICAuLi90eXBpbmcvdHlwZW9wdC5tbCAqKVxuXG50eXBlIGZsb2F0MzJfZWx0ID0gRmxvYXQzMl9lbHRcbnR5cGUgZmxvYXQ2NF9lbHQgPSBGbG9hdDY0X2VsdFxudHlwZSBpbnQ4X3NpZ25lZF9lbHQgPSBJbnQ4X3NpZ25lZF9lbHRcbnR5cGUgaW50OF91bnNpZ25lZF9lbHQgPSBJbnQ4X3Vuc2lnbmVkX2VsdFxudHlwZSBpbnQxNl9zaWduZWRfZWx0ID0gSW50MTZfc2lnbmVkX2VsdFxudHlwZSBpbnQxNl91bnNpZ25lZF9lbHQgPSBJbnQxNl91bnNpZ25lZF9lbHRcbnR5cGUgaW50MzJfZWx0ID0gSW50MzJfZWx0XG50eXBlIGludDY0X2VsdCA9IEludDY0X2VsdFxudHlwZSBpbnRfZWx0ID0gSW50X2VsdFxudHlwZSBuYXRpdmVpbnRfZWx0ID0gTmF0aXZlaW50X2VsdFxudHlwZSBjb21wbGV4MzJfZWx0ID0gQ29tcGxleDMyX2VsdFxudHlwZSBjb21wbGV4NjRfZWx0ID0gQ29tcGxleDY0X2VsdFxuXG50eXBlICgnYSwgJ2IpIGtpbmQgPVxuICAgIEZsb2F0MzIgOiAoZmxvYXQsIGZsb2F0MzJfZWx0KSBraW5kXG4gIHwgRmxvYXQ2NCA6IChmbG9hdCwgZmxvYXQ2NF9lbHQpIGtpbmRcbiAgfCBJbnQ4X3NpZ25lZCA6IChpbnQsIGludDhfc2lnbmVkX2VsdCkga2luZFxuICB8IEludDhfdW5zaWduZWQgOiAoaW50LCBpbnQ4X3Vuc2lnbmVkX2VsdCkga2luZFxuICB8IEludDE2X3NpZ25lZCA6IChpbnQsIGludDE2X3NpZ25lZF9lbHQpIGtpbmRcbiAgfCBJbnQxNl91bnNpZ25lZCA6IChpbnQsIGludDE2X3Vuc2lnbmVkX2VsdCkga2luZFxuICB8IEludDMyIDogKGludDMyLCBpbnQzMl9lbHQpIGtpbmRcbiAgfCBJbnQ2NCA6IChpbnQ2NCwgaW50NjRfZWx0KSBraW5kXG4gIHwgSW50IDogKGludCwgaW50X2VsdCkga2luZFxuICB8IE5hdGl2ZWludCA6IChuYXRpdmVpbnQsIG5hdGl2ZWludF9lbHQpIGtpbmRcbiAgfCBDb21wbGV4MzIgOiAoQ29tcGxleC50LCBjb21wbGV4MzJfZWx0KSBraW5kXG4gIHwgQ29tcGxleDY0IDogKENvbXBsZXgudCwgY29tcGxleDY0X2VsdCkga2luZFxuICB8IENoYXIgOiAoY2hhciwgaW50OF91bnNpZ25lZF9lbHQpIGtpbmRcblxudHlwZSBjX2xheW91dCA9IENfbGF5b3V0X3R5cFxudHlwZSBmb3J0cmFuX2xheW91dCA9IEZvcnRyYW5fbGF5b3V0X3R5cCAoKiopXG5cbnR5cGUgJ2EgbGF5b3V0ID1cbiAgICBDX2xheW91dDogY19sYXlvdXQgbGF5b3V0XG4gIHwgRm9ydHJhbl9sYXlvdXQ6IGZvcnRyYW5fbGF5b3V0IGxheW91dFxuXG4oKiBLZWVwIHRob3NlIGNvbnN0YW50cyBpbiBzeW5jIHdpdGggdGhlIGNhbWxfYmFfa2luZCBlbnVtZXJhdGlvblxuICAgaW4gYmlnYXJyYXkuaCAqKVxuXG5sZXQgZmxvYXQzMiA9IEZsb2F0MzJcbmxldCBmbG9hdDY0ID0gRmxvYXQ2NFxubGV0IGludDhfc2lnbmVkID0gSW50OF9zaWduZWRcbmxldCBpbnQ4X3Vuc2lnbmVkID0gSW50OF91bnNpZ25lZFxubGV0IGludDE2X3NpZ25lZCA9IEludDE2X3NpZ25lZFxubGV0IGludDE2X3Vuc2lnbmVkID0gSW50MTZfdW5zaWduZWRcbmxldCBpbnQzMiA9IEludDMyXG5sZXQgaW50NjQgPSBJbnQ2NFxubGV0IGludCA9IEludFxubGV0IG5hdGl2ZWludCA9IE5hdGl2ZWludFxubGV0IGNvbXBsZXgzMiA9IENvbXBsZXgzMlxubGV0IGNvbXBsZXg2NCA9IENvbXBsZXg2NFxubGV0IGNoYXIgPSBDaGFyXG5cbmxldCBraW5kX3NpemVfaW5fYnl0ZXMgOiB0eXBlIGEgYi4gKGEsIGIpIGtpbmQgLT4gaW50ID0gZnVuY3Rpb25cbiAgfCBGbG9hdDMyIC0+IDRcbiAgfCBGbG9hdDY0IC0+IDhcbiAgfCBJbnQ4X3NpZ25lZCAtPiAxXG4gIHwgSW50OF91bnNpZ25lZCAtPiAxXG4gIHwgSW50MTZfc2lnbmVkIC0+IDJcbiAgfCBJbnQxNl91bnNpZ25lZCAtPiAyXG4gIHwgSW50MzIgLT4gNFxuICB8IEludDY0IC0+IDhcbiAgfCBJbnQgLT4gU3lzLndvcmRfc2l6ZSAvIDhcbiAgfCBOYXRpdmVpbnQgLT4gU3lzLndvcmRfc2l6ZSAvIDhcbiAgfCBDb21wbGV4MzIgLT4gOFxuICB8IENvbXBsZXg2NCAtPiAxNlxuICB8IENoYXIgLT4gMVxuXG4oKiBLZWVwIHRob3NlIGNvbnN0YW50cyBpbiBzeW5jIHdpdGggdGhlIGNhbWxfYmFfbGF5b3V0IGVudW1lcmF0aW9uXG4gICBpbiBiaWdhcnJheS5oICopXG5cbmxldCBjX2xheW91dCA9IENfbGF5b3V0XG5sZXQgZm9ydHJhbl9sYXlvdXQgPSBGb3J0cmFuX2xheW91dFxuXG5tb2R1bGUgR2VuYXJyYXkgPSBzdHJ1Y3RcbiAgdHlwZSAoISdhLCAhJ2IsICEnYykgdFxuICBleHRlcm5hbCBjcmVhdGU6ICgnYSwgJ2IpIGtpbmQgLT4gJ2MgbGF5b3V0IC0+IGludCBhcnJheSAtPiAoJ2EsICdiLCAnYykgdFxuICAgICA9IFwiY2FtbF9iYV9jcmVhdGVcIlxuICBleHRlcm5hbCBnZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCBhcnJheSAtPiAnYVxuICAgICA9IFwiY2FtbF9iYV9nZXRfZ2VuZXJpY1wiXG4gIGV4dGVybmFsIHNldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IGFycmF5IC0+ICdhIC0+IHVuaXRcbiAgICAgPSBcImNhbWxfYmFfc2V0X2dlbmVyaWNcIlxuXG4gIGxldCByZWMgY2xvb3AgYXJyIGlkeCBmIGNvbCBtYXggPVxuICAgIGlmIGNvbCA9IEFycmF5Lmxlbmd0aCBpZHggdGhlbiBzZXQgYXJyIGlkeCAoZiBpZHgpXG4gICAgZWxzZSBmb3IgaiA9IDAgdG8gcHJlZCBtYXguKGNvbCkgZG9cbiAgICAgICAgICAgaWR4Lihjb2wpIDwtIGo7XG4gICAgICAgICAgIGNsb29wIGFyciBpZHggZiAoc3VjYyBjb2wpIG1heFxuICAgICAgICAgZG9uZVxuICBsZXQgcmVjIGZsb29wIGFyciBpZHggZiBjb2wgbWF4ID1cbiAgICBpZiBjb2wgPCAwIHRoZW4gc2V0IGFyciBpZHggKGYgaWR4KVxuICAgIGVsc2UgZm9yIGogPSAxIHRvIG1heC4oY29sKSBkb1xuICAgICAgICAgICBpZHguKGNvbCkgPC0gajtcbiAgICAgICAgICAgZmxvb3AgYXJyIGlkeCBmIChwcmVkIGNvbCkgbWF4XG4gICAgICAgICBkb25lXG4gIGxldCBpbml0ICh0eXBlIHQpIGtpbmQgKGxheW91dCA6IHQgbGF5b3V0KSBkaW1zIGYgPVxuICAgIGxldCBhcnIgPSBjcmVhdGUga2luZCBsYXlvdXQgZGltcyBpblxuICAgIG1hdGNoIEFycmF5Lmxlbmd0aCBkaW1zLCBsYXlvdXQgd2l0aFxuICAgIHwgMCwgXyAtPiBhcnJcbiAgICB8IGRsZW4sIENfbGF5b3V0IC0+IGNsb29wIGFyciAoQXJyYXkubWFrZSBkbGVuIDApIGYgMCBkaW1zOyBhcnJcbiAgICB8IGRsZW4sIEZvcnRyYW5fbGF5b3V0IC0+IGZsb29wIGFyciAoQXJyYXkubWFrZSBkbGVuIDEpIGYgKHByZWQgZGxlbikgZGltcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyclxuXG4gIGV4dGVybmFsIG51bV9kaW1zOiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgPSBcImNhbWxfYmFfbnVtX2RpbXNcIlxuICBleHRlcm5hbCBudGhfZGltOiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gaW50ID0gXCJjYW1sX2JhX2RpbVwiXG4gIGxldCBkaW1zIGEgPVxuICAgIGxldCBuID0gbnVtX2RpbXMgYSBpblxuICAgIGxldCBkID0gQXJyYXkubWFrZSBuIDAgaW5cbiAgICBmb3IgaSA9IDAgdG8gbi0xIGRvIGQuKGkpIDwtIG50aF9kaW0gYSBpIGRvbmU7XG4gICAgZFxuXG4gIGV4dGVybmFsIGtpbmQ6ICgnYSwgJ2IsICdjKSB0IC0+ICgnYSwgJ2IpIGtpbmQgPSBcImNhbWxfYmFfa2luZFwiXG4gIGV4dGVybmFsIGxheW91dDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2MgbGF5b3V0ID0gXCJjYW1sX2JhX2xheW91dFwiXG4gIGV4dGVybmFsIGNoYW5nZV9sYXlvdXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICdkIGxheW91dCAtPiAoJ2EsICdiLCAnZCkgdFxuICAgICA9IFwiY2FtbF9iYV9jaGFuZ2VfbGF5b3V0XCJcblxuICBsZXQgc2l6ZV9pbl9ieXRlcyBhcnIgPVxuICAgIChraW5kX3NpemVfaW5fYnl0ZXMgKGtpbmQgYXJyKSkgKiAoQXJyYXkuZm9sZF9sZWZ0ICggKiApIDEgKGRpbXMgYXJyKSlcblxuICBleHRlcm5hbCBzdWJfbGVmdDogKCdhLCAnYiwgY19sYXlvdXQpIHQgLT4gaW50IC0+IGludCAtPiAoJ2EsICdiLCBjX2xheW91dCkgdFxuICAgICA9IFwiY2FtbF9iYV9zdWJcIlxuICBleHRlcm5hbCBzdWJfcmlnaHQ6ICgnYSwgJ2IsIGZvcnRyYW5fbGF5b3V0KSB0IC0+IGludCAtPiBpbnQgLT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgKCdhLCAnYiwgZm9ydHJhbl9sYXlvdXQpIHRcbiAgICAgPSBcImNhbWxfYmFfc3ViXCJcbiAgZXh0ZXJuYWwgc2xpY2VfbGVmdDogKCdhLCAnYiwgY19sYXlvdXQpIHQgLT4gaW50IGFycmF5IC0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICgnYSwgJ2IsIGNfbGF5b3V0KSB0XG4gICAgID0gXCJjYW1sX2JhX3NsaWNlXCJcbiAgZXh0ZXJuYWwgc2xpY2VfcmlnaHQ6ICgnYSwgJ2IsIGZvcnRyYW5fbGF5b3V0KSB0IC0+IGludCBhcnJheSAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAoJ2EsICdiLCBmb3J0cmFuX2xheW91dCkgdFxuICAgICA9IFwiY2FtbF9iYV9zbGljZVwiXG4gIGV4dGVybmFsIGJsaXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICgnYSwgJ2IsICdjKSB0IC0+IHVuaXRcbiAgICAgPSBcImNhbWxfYmFfYmxpdFwiXG4gIGV4dGVybmFsIGZpbGw6ICgnYSwgJ2IsICdjKSB0IC0+ICdhIC0+IHVuaXQgPSBcImNhbWxfYmFfZmlsbFwiXG5lbmRcblxubW9kdWxlIEFycmF5MCA9IHN0cnVjdFxuICB0eXBlICghJ2EsICEnYiwgISdjKSB0ID0gKCdhLCAnYiwgJ2MpIEdlbmFycmF5LnRcbiAgbGV0IGNyZWF0ZSBraW5kIGxheW91dCA9XG4gICAgR2VuYXJyYXkuY3JlYXRlIGtpbmQgbGF5b3V0IFt8fF1cbiAgbGV0IGdldCBhcnIgPSBHZW5hcnJheS5nZXQgYXJyIFt8fF1cbiAgbGV0IHNldCBhcnIgPSBHZW5hcnJheS5zZXQgYXJyIFt8fF1cbiAgZXh0ZXJuYWwga2luZDogKCdhLCAnYiwgJ2MpIHQgLT4gKCdhLCAnYikga2luZCA9IFwiY2FtbF9iYV9raW5kXCJcbiAgZXh0ZXJuYWwgbGF5b3V0OiAoJ2EsICdiLCAnYykgdCAtPiAnYyBsYXlvdXQgPSBcImNhbWxfYmFfbGF5b3V0XCJcblxuICBleHRlcm5hbCBjaGFuZ2VfbGF5b3V0OiAoJ2EsICdiLCAnYykgdCAtPiAnZCBsYXlvdXQgLT4gKCdhLCAnYiwgJ2QpIHRcbiAgICA9IFwiY2FtbF9iYV9jaGFuZ2VfbGF5b3V0XCJcblxuICBsZXQgc2l6ZV9pbl9ieXRlcyBhcnIgPSBraW5kX3NpemVfaW5fYnl0ZXMgKGtpbmQgYXJyKVxuXG4gIGV4dGVybmFsIGJsaXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICgnYSwgJ2IsICdjKSB0IC0+IHVuaXQgPSBcImNhbWxfYmFfYmxpdFwiXG4gIGV4dGVybmFsIGZpbGw6ICgnYSwgJ2IsICdjKSB0IC0+ICdhIC0+IHVuaXQgPSBcImNhbWxfYmFfZmlsbFwiXG5cbiAgbGV0IG9mX3ZhbHVlIGtpbmQgbGF5b3V0IHYgPVxuICAgIGxldCBhID0gY3JlYXRlIGtpbmQgbGF5b3V0IGluXG4gICAgc2V0IGEgdjtcbiAgICBhXG4gIGxldCBpbml0ID0gb2ZfdmFsdWVcbmVuZFxuXG5tb2R1bGUgQXJyYXkxID0gc3RydWN0XG4gIHR5cGUgKCEnYSwgISdiLCAhJ2MpIHQgPSAoJ2EsICdiLCAnYykgR2VuYXJyYXkudFxuICBsZXQgY3JlYXRlIGtpbmQgbGF5b3V0IGRpbSA9XG4gICAgR2VuYXJyYXkuY3JlYXRlIGtpbmQgbGF5b3V0IFt8ZGltfF1cbiAgZXh0ZXJuYWwgZ2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gJ2EgPSBcIiVjYW1sX2JhX3JlZl8xXCJcbiAgZXh0ZXJuYWwgc2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gJ2EgLT4gdW5pdCA9IFwiJWNhbWxfYmFfc2V0XzFcIlxuICBleHRlcm5hbCB1bnNhZmVfZ2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gJ2EgPSBcIiVjYW1sX2JhX3Vuc2FmZV9yZWZfMVwiXG4gIGV4dGVybmFsIHVuc2FmZV9zZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiAnYSAtPiB1bml0XG4gICAgID0gXCIlY2FtbF9iYV91bnNhZmVfc2V0XzFcIlxuICBleHRlcm5hbCBkaW06ICgnYSwgJ2IsICdjKSB0IC0+IGludCA9IFwiJWNhbWxfYmFfZGltXzFcIlxuICBleHRlcm5hbCBraW5kOiAoJ2EsICdiLCAnYykgdCAtPiAoJ2EsICdiKSBraW5kID0gXCJjYW1sX2JhX2tpbmRcIlxuICBleHRlcm5hbCBsYXlvdXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICdjIGxheW91dCA9IFwiY2FtbF9iYV9sYXlvdXRcIlxuXG4gIGV4dGVybmFsIGNoYW5nZV9sYXlvdXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICdkIGxheW91dCAtPiAoJ2EsICdiLCAnZCkgdFxuICAgID0gXCJjYW1sX2JhX2NoYW5nZV9sYXlvdXRcIlxuXG4gIGxldCBzaXplX2luX2J5dGVzIGFyciA9XG4gICAgKGtpbmRfc2l6ZV9pbl9ieXRlcyAoa2luZCBhcnIpKSAqIChkaW0gYXJyKVxuXG4gIGV4dGVybmFsIHN1YjogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+IGludCAtPiAoJ2EsICdiLCAnYykgdCA9IFwiY2FtbF9iYV9zdWJcIlxuICBsZXQgc2xpY2UgKHR5cGUgdCkgKGEgOiAoXywgXywgdCkgR2VuYXJyYXkudCkgbiA9XG4gICAgbWF0Y2ggbGF5b3V0IGEgd2l0aFxuICAgIHwgQ19sYXlvdXQgLT4gKEdlbmFycmF5LnNsaWNlX2xlZnQgYSBbfG58XSA6IChfLCBfLCB0KSBHZW5hcnJheS50KVxuICAgIHwgRm9ydHJhbl9sYXlvdXQgLT4gKEdlbmFycmF5LnNsaWNlX3JpZ2h0IGEgW3xufF06IChfLCBfLCB0KSBHZW5hcnJheS50KVxuICBleHRlcm5hbCBibGl0OiAoJ2EsICdiLCAnYykgdCAtPiAoJ2EsICdiLCAnYykgdCAtPiB1bml0ID0gXCJjYW1sX2JhX2JsaXRcIlxuICBleHRlcm5hbCBmaWxsOiAoJ2EsICdiLCAnYykgdCAtPiAnYSAtPiB1bml0ID0gXCJjYW1sX2JhX2ZpbGxcIlxuICBsZXQgY19pbml0IGFyciBkaW0gZiA9XG4gICAgZm9yIGkgPSAwIHRvIHByZWQgZGltIGRvIHVuc2FmZV9zZXQgYXJyIGkgKGYgaSkgZG9uZVxuICBsZXQgZm9ydHJhbl9pbml0IGFyciBkaW0gZiA9XG4gICAgZm9yIGkgPSAxIHRvIGRpbSBkbyB1bnNhZmVfc2V0IGFyciBpIChmIGkpIGRvbmVcbiAgbGV0IGluaXQgKHR5cGUgdCkga2luZCAobGF5b3V0IDogdCBsYXlvdXQpIGRpbSBmID1cbiAgICBsZXQgYXJyID0gY3JlYXRlIGtpbmQgbGF5b3V0IGRpbSBpblxuICAgIG1hdGNoIGxheW91dCB3aXRoXG4gICAgfCBDX2xheW91dCAtPiBjX2luaXQgYXJyIGRpbSBmOyBhcnJcbiAgICB8IEZvcnRyYW5fbGF5b3V0IC0+IGZvcnRyYW5faW5pdCBhcnIgZGltIGY7IGFyclxuICBsZXQgb2ZfYXJyYXkgKHR5cGUgdCkga2luZCAobGF5b3V0OiB0IGxheW91dCkgZGF0YSA9XG4gICAgbGV0IGJhID0gY3JlYXRlIGtpbmQgbGF5b3V0IChBcnJheS5sZW5ndGggZGF0YSkgaW5cbiAgICBsZXQgb2ZzID1cbiAgICAgIG1hdGNoIGxheW91dCB3aXRoXG4gICAgICAgIENfbGF5b3V0IC0+IDBcbiAgICAgIHwgRm9ydHJhbl9sYXlvdXQgLT4gMVxuICAgIGluXG4gICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCBkYXRhIC0gMSBkbyB1bnNhZmVfc2V0IGJhIChpICsgb2ZzKSBkYXRhLihpKSBkb25lO1xuICAgIGJhXG5lbmRcblxubW9kdWxlIEFycmF5MiA9IHN0cnVjdFxuICB0eXBlICghJ2EsICEnYiwgISdjKSB0ID0gKCdhLCAnYiwgJ2MpIEdlbmFycmF5LnRcbiAgbGV0IGNyZWF0ZSBraW5kIGxheW91dCBkaW0xIGRpbTIgPVxuICAgIEdlbmFycmF5LmNyZWF0ZSBraW5kIGxheW91dCBbfGRpbTE7IGRpbTJ8XVxuICBleHRlcm5hbCBnZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiBpbnQgLT4gJ2EgPSBcIiVjYW1sX2JhX3JlZl8yXCJcbiAgZXh0ZXJuYWwgc2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gaW50IC0+ICdhIC0+IHVuaXQgPSBcIiVjYW1sX2JhX3NldF8yXCJcbiAgZXh0ZXJuYWwgdW5zYWZlX2dldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+IGludCAtPiAnYVxuICAgICA9IFwiJWNhbWxfYmFfdW5zYWZlX3JlZl8yXCJcbiAgZXh0ZXJuYWwgdW5zYWZlX3NldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+IGludCAtPiAnYSAtPiB1bml0XG4gICAgID0gXCIlY2FtbF9iYV91bnNhZmVfc2V0XzJcIlxuICBleHRlcm5hbCBkaW0xOiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgPSBcIiVjYW1sX2JhX2RpbV8xXCJcbiAgZXh0ZXJuYWwgZGltMjogKCdhLCAnYiwgJ2MpIHQgLT4gaW50ID0gXCIlY2FtbF9iYV9kaW1fMlwiXG4gIGV4dGVybmFsIGtpbmQ6ICgnYSwgJ2IsICdjKSB0IC0+ICgnYSwgJ2IpIGtpbmQgPSBcImNhbWxfYmFfa2luZFwiXG4gIGV4dGVybmFsIGxheW91dDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2MgbGF5b3V0ID0gXCJjYW1sX2JhX2xheW91dFwiXG5cbiAgZXh0ZXJuYWwgY2hhbmdlX2xheW91dDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2QgbGF5b3V0IC0+ICgnYSwgJ2IsICdkKSB0XG4gICAgPSBcImNhbWxfYmFfY2hhbmdlX2xheW91dFwiXG5cbiAgbGV0IHNpemVfaW5fYnl0ZXMgYXJyID1cbiAgICAoa2luZF9zaXplX2luX2J5dGVzIChraW5kIGFycikpICogKGRpbTEgYXJyKSAqIChkaW0yIGFycilcblxuICBleHRlcm5hbCBzdWJfbGVmdDogKCdhLCAnYiwgY19sYXlvdXQpIHQgLT4gaW50IC0+IGludCAtPiAoJ2EsICdiLCBjX2xheW91dCkgdFxuICAgICA9IFwiY2FtbF9iYV9zdWJcIlxuICBleHRlcm5hbCBzdWJfcmlnaHQ6XG4gICAgKCdhLCAnYiwgZm9ydHJhbl9sYXlvdXQpIHQgLT4gaW50IC0+IGludCAtPiAoJ2EsICdiLCBmb3J0cmFuX2xheW91dCkgdFxuICAgICA9IFwiY2FtbF9iYV9zdWJcIlxuICBsZXQgc2xpY2VfbGVmdCBhIG4gPSBHZW5hcnJheS5zbGljZV9sZWZ0IGEgW3xufF1cbiAgbGV0IHNsaWNlX3JpZ2h0IGEgbiA9IEdlbmFycmF5LnNsaWNlX3JpZ2h0IGEgW3xufF1cbiAgZXh0ZXJuYWwgYmxpdDogKCdhLCAnYiwgJ2MpIHQgLT4gKCdhLCAnYiwgJ2MpIHQgLT4gdW5pdCA9IFwiY2FtbF9iYV9ibGl0XCJcbiAgZXh0ZXJuYWwgZmlsbDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2EgLT4gdW5pdCA9IFwiY2FtbF9iYV9maWxsXCJcbiAgbGV0IGNfaW5pdCBhcnIgZGltMSBkaW0yIGYgPVxuICAgIGZvciBpID0gMCB0byBwcmVkIGRpbTEgZG9cbiAgICAgIGZvciBqID0gMCB0byBwcmVkIGRpbTIgZG9cbiAgICAgICAgdW5zYWZlX3NldCBhcnIgaSBqIChmIGkgailcbiAgICAgIGRvbmVcbiAgICBkb25lXG4gIGxldCBmb3J0cmFuX2luaXQgYXJyIGRpbTEgZGltMiBmID1cbiAgICBmb3IgaiA9IDEgdG8gZGltMiBkb1xuICAgICAgZm9yIGkgPSAxIHRvIGRpbTEgZG9cbiAgICAgICAgdW5zYWZlX3NldCBhcnIgaSBqIChmIGkgailcbiAgICAgIGRvbmVcbiAgICBkb25lXG4gIGxldCBpbml0ICh0eXBlIHQpIGtpbmQgKGxheW91dCA6IHQgbGF5b3V0KSBkaW0xIGRpbTIgZiA9XG4gICAgbGV0IGFyciA9IGNyZWF0ZSBraW5kIGxheW91dCBkaW0xIGRpbTIgaW5cbiAgICBtYXRjaCBsYXlvdXQgd2l0aFxuICAgIHwgQ19sYXlvdXQgLT4gY19pbml0IGFyciBkaW0xIGRpbTIgZjsgYXJyXG4gICAgfCBGb3J0cmFuX2xheW91dCAtPiBmb3J0cmFuX2luaXQgYXJyIGRpbTEgZGltMiBmOyBhcnJcbiAgbGV0IG9mX2FycmF5ICh0eXBlIHQpIGtpbmQgKGxheW91dDogdCBsYXlvdXQpIGRhdGEgPVxuICAgIGxldCBkaW0xID0gQXJyYXkubGVuZ3RoIGRhdGEgaW5cbiAgICBsZXQgZGltMiA9IGlmIGRpbTEgPSAwIHRoZW4gMCBlbHNlIEFycmF5Lmxlbmd0aCBkYXRhLigwKSBpblxuICAgIGxldCBiYSA9IGNyZWF0ZSBraW5kIGxheW91dCBkaW0xIGRpbTIgaW5cbiAgICBsZXQgb2ZzID1cbiAgICAgIG1hdGNoIGxheW91dCB3aXRoXG4gICAgICAgIENfbGF5b3V0IC0+IDBcbiAgICAgIHwgRm9ydHJhbl9sYXlvdXQgLT4gMVxuICAgIGluXG4gICAgZm9yIGkgPSAwIHRvIGRpbTEgLSAxIGRvXG4gICAgICBsZXQgcm93ID0gZGF0YS4oaSkgaW5cbiAgICAgIGlmIEFycmF5Lmxlbmd0aCByb3cgPD4gZGltMiB0aGVuXG4gICAgICAgIGludmFsaWRfYXJnKFwiQmlnYXJyYXkuQXJyYXkyLm9mX2FycmF5OiBub24tcmVjdGFuZ3VsYXIgZGF0YVwiKTtcbiAgICAgIGZvciBqID0gMCB0byBkaW0yIC0gMSBkb1xuICAgICAgICB1bnNhZmVfc2V0IGJhIChpICsgb2ZzKSAoaiArIG9mcykgcm93LihqKVxuICAgICAgZG9uZVxuICAgIGRvbmU7XG4gICAgYmFcbmVuZFxuXG5tb2R1bGUgQXJyYXkzID0gc3RydWN0XG4gIHR5cGUgKCEnYSwgISdiLCAhJ2MpIHQgPSAoJ2EsICdiLCAnYykgR2VuYXJyYXkudFxuICBsZXQgY3JlYXRlIGtpbmQgbGF5b3V0IGRpbTEgZGltMiBkaW0zID1cbiAgICBHZW5hcnJheS5jcmVhdGUga2luZCBsYXlvdXQgW3xkaW0xOyBkaW0yOyBkaW0zfF1cbiAgZXh0ZXJuYWwgZ2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gaW50IC0+IGludCAtPiAnYSA9IFwiJWNhbWxfYmFfcmVmXzNcIlxuICBleHRlcm5hbCBzZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiBpbnQgLT4gaW50IC0+ICdhIC0+IHVuaXRcbiAgICAgPSBcIiVjYW1sX2JhX3NldF8zXCJcbiAgZXh0ZXJuYWwgdW5zYWZlX2dldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+IGludCAtPiBpbnQgLT4gJ2FcbiAgICAgPSBcIiVjYW1sX2JhX3Vuc2FmZV9yZWZfM1wiXG4gIGV4dGVybmFsIHVuc2FmZV9zZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiBpbnQgLT4gaW50IC0+ICdhIC0+IHVuaXRcbiAgICAgPSBcIiVjYW1sX2JhX3Vuc2FmZV9zZXRfM1wiXG4gIGV4dGVybmFsIGRpbTE6ICgnYSwgJ2IsICdjKSB0IC0+IGludCA9IFwiJWNhbWxfYmFfZGltXzFcIlxuICBleHRlcm5hbCBkaW0yOiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgPSBcIiVjYW1sX2JhX2RpbV8yXCJcbiAgZXh0ZXJuYWwgZGltMzogKCdhLCAnYiwgJ2MpIHQgLT4gaW50ID0gXCIlY2FtbF9iYV9kaW1fM1wiXG4gIGV4dGVybmFsIGtpbmQ6ICgnYSwgJ2IsICdjKSB0IC0+ICgnYSwgJ2IpIGtpbmQgPSBcImNhbWxfYmFfa2luZFwiXG4gIGV4dGVybmFsIGxheW91dDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2MgbGF5b3V0ID0gXCJjYW1sX2JhX2xheW91dFwiXG5cbiAgZXh0ZXJuYWwgY2hhbmdlX2xheW91dDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2QgbGF5b3V0IC0+ICgnYSwgJ2IsICdkKSB0XG4gICAgPSBcImNhbWxfYmFfY2hhbmdlX2xheW91dFwiXG5cbiAgbGV0IHNpemVfaW5fYnl0ZXMgYXJyID1cbiAgICAoa2luZF9zaXplX2luX2J5dGVzIChraW5kIGFycikpICogKGRpbTEgYXJyKSAqIChkaW0yIGFycikgKiAoZGltMyBhcnIpXG5cbiAgZXh0ZXJuYWwgc3ViX2xlZnQ6ICgnYSwgJ2IsIGNfbGF5b3V0KSB0IC0+IGludCAtPiBpbnQgLT4gKCdhLCAnYiwgY19sYXlvdXQpIHRcbiAgICAgPSBcImNhbWxfYmFfc3ViXCJcbiAgZXh0ZXJuYWwgc3ViX3JpZ2h0OlxuICAgICAoJ2EsICdiLCBmb3J0cmFuX2xheW91dCkgdCAtPiBpbnQgLT4gaW50IC0+ICgnYSwgJ2IsIGZvcnRyYW5fbGF5b3V0KSB0XG4gICAgID0gXCJjYW1sX2JhX3N1YlwiXG4gIGxldCBzbGljZV9sZWZ0XzEgYSBuIG0gPSBHZW5hcnJheS5zbGljZV9sZWZ0IGEgW3xuOyBtfF1cbiAgbGV0IHNsaWNlX3JpZ2h0XzEgYSBuIG0gPSBHZW5hcnJheS5zbGljZV9yaWdodCBhIFt8bjsgbXxdXG4gIGxldCBzbGljZV9sZWZ0XzIgYSBuID0gR2VuYXJyYXkuc2xpY2VfbGVmdCBhIFt8bnxdXG4gIGxldCBzbGljZV9yaWdodF8yIGEgbiA9IEdlbmFycmF5LnNsaWNlX3JpZ2h0IGEgW3xufF1cbiAgZXh0ZXJuYWwgYmxpdDogKCdhLCAnYiwgJ2MpIHQgLT4gKCdhLCAnYiwgJ2MpIHQgLT4gdW5pdCA9IFwiY2FtbF9iYV9ibGl0XCJcbiAgZXh0ZXJuYWwgZmlsbDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2EgLT4gdW5pdCA9IFwiY2FtbF9iYV9maWxsXCJcbiAgbGV0IGNfaW5pdCBhcnIgZGltMSBkaW0yIGRpbTMgZiA9XG4gICAgZm9yIGkgPSAwIHRvIHByZWQgZGltMSBkb1xuICAgICAgZm9yIGogPSAwIHRvIHByZWQgZGltMiBkb1xuICAgICAgICBmb3IgayA9IDAgdG8gcHJlZCBkaW0zIGRvXG4gICAgICAgICAgdW5zYWZlX3NldCBhcnIgaSBqIGsgKGYgaSBqIGspXG4gICAgICAgIGRvbmVcbiAgICAgIGRvbmVcbiAgICBkb25lXG4gIGxldCBmb3J0cmFuX2luaXQgYXJyIGRpbTEgZGltMiBkaW0zIGYgPVxuICAgIGZvciBrID0gMSB0byBkaW0zIGRvXG4gICAgICBmb3IgaiA9IDEgdG8gZGltMiBkb1xuICAgICAgICBmb3IgaSA9IDEgdG8gZGltMSBkb1xuICAgICAgICAgIHVuc2FmZV9zZXQgYXJyIGkgaiBrIChmIGkgaiBrKVxuICAgICAgICBkb25lXG4gICAgICBkb25lXG4gICAgZG9uZVxuICBsZXQgaW5pdCAodHlwZSB0KSBraW5kIChsYXlvdXQgOiB0IGxheW91dCkgZGltMSBkaW0yIGRpbTMgZiA9XG4gICAgbGV0IGFyciA9IGNyZWF0ZSBraW5kIGxheW91dCBkaW0xIGRpbTIgZGltMyBpblxuICAgIG1hdGNoIGxheW91dCB3aXRoXG4gICAgfCBDX2xheW91dCAtPiBjX2luaXQgYXJyIGRpbTEgZGltMiBkaW0zIGY7IGFyclxuICAgIHwgRm9ydHJhbl9sYXlvdXQgLT4gZm9ydHJhbl9pbml0IGFyciBkaW0xIGRpbTIgZGltMyBmOyBhcnJcbiAgbGV0IG9mX2FycmF5ICh0eXBlIHQpIGtpbmQgKGxheW91dDogdCBsYXlvdXQpIGRhdGEgPVxuICAgIGxldCBkaW0xID0gQXJyYXkubGVuZ3RoIGRhdGEgaW5cbiAgICBsZXQgZGltMiA9IGlmIGRpbTEgPSAwIHRoZW4gMCBlbHNlIEFycmF5Lmxlbmd0aCBkYXRhLigwKSBpblxuICAgIGxldCBkaW0zID0gaWYgZGltMiA9IDAgdGhlbiAwIGVsc2UgQXJyYXkubGVuZ3RoIGRhdGEuKDApLigwKSBpblxuICAgIGxldCBiYSA9IGNyZWF0ZSBraW5kIGxheW91dCBkaW0xIGRpbTIgZGltMyBpblxuICAgIGxldCBvZnMgPVxuICAgICAgbWF0Y2ggbGF5b3V0IHdpdGhcbiAgICAgICAgQ19sYXlvdXQgLT4gMFxuICAgICAgfCBGb3J0cmFuX2xheW91dCAtPiAxXG4gICAgaW5cbiAgICBmb3IgaSA9IDAgdG8gZGltMSAtIDEgZG9cbiAgICAgIGxldCByb3cgPSBkYXRhLihpKSBpblxuICAgICAgaWYgQXJyYXkubGVuZ3RoIHJvdyA8PiBkaW0yIHRoZW5cbiAgICAgICAgaW52YWxpZF9hcmcoXCJCaWdhcnJheS5BcnJheTMub2ZfYXJyYXk6IG5vbi1jdWJpYyBkYXRhXCIpO1xuICAgICAgZm9yIGogPSAwIHRvIGRpbTIgLSAxIGRvXG4gICAgICAgIGxldCBjb2wgPSByb3cuKGopIGluXG4gICAgICAgIGlmIEFycmF5Lmxlbmd0aCBjb2wgPD4gZGltMyB0aGVuXG4gICAgICAgICAgaW52YWxpZF9hcmcoXCJCaWdhcnJheS5BcnJheTMub2ZfYXJyYXk6IG5vbi1jdWJpYyBkYXRhXCIpO1xuICAgICAgICBmb3IgayA9IDAgdG8gZGltMyAtIDEgZG9cbiAgICAgICAgICB1bnNhZmVfc2V0IGJhIChpICsgb2ZzKSAoaiArIG9mcykgKGsgKyBvZnMpIGNvbC4oaylcbiAgICAgICAgZG9uZVxuICAgICAgZG9uZVxuICAgIGRvbmU7XG4gICAgYmFcbmVuZFxuXG5leHRlcm5hbCBnZW5hcnJheV9vZl9hcnJheTA6ICgnYSwgJ2IsICdjKSBBcnJheTAudCAtPiAoJ2EsICdiLCAnYykgR2VuYXJyYXkudFxuICAgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCBnZW5hcnJheV9vZl9hcnJheTE6ICgnYSwgJ2IsICdjKSBBcnJheTEudCAtPiAoJ2EsICdiLCAnYykgR2VuYXJyYXkudFxuICAgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCBnZW5hcnJheV9vZl9hcnJheTI6ICgnYSwgJ2IsICdjKSBBcnJheTIudCAtPiAoJ2EsICdiLCAnYykgR2VuYXJyYXkudFxuICAgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCBnZW5hcnJheV9vZl9hcnJheTM6ICgnYSwgJ2IsICdjKSBBcnJheTMudCAtPiAoJ2EsICdiLCAnYykgR2VuYXJyYXkudFxuICAgPSBcIiVpZGVudGl0eVwiXG5sZXQgYXJyYXkwX29mX2dlbmFycmF5IGEgPVxuICBpZiBHZW5hcnJheS5udW1fZGltcyBhID0gMCB0aGVuIGFcbiAgZWxzZSBpbnZhbGlkX2FyZyBcIkJpZ2FycmF5LmFycmF5MF9vZl9nZW5hcnJheVwiXG5sZXQgYXJyYXkxX29mX2dlbmFycmF5IGEgPVxuICBpZiBHZW5hcnJheS5udW1fZGltcyBhID0gMSB0aGVuIGFcbiAgZWxzZSBpbnZhbGlkX2FyZyBcIkJpZ2FycmF5LmFycmF5MV9vZl9nZW5hcnJheVwiXG5sZXQgYXJyYXkyX29mX2dlbmFycmF5IGEgPVxuICBpZiBHZW5hcnJheS5udW1fZGltcyBhID0gMiB0aGVuIGFcbiAgZWxzZSBpbnZhbGlkX2FyZyBcIkJpZ2FycmF5LmFycmF5Ml9vZl9nZW5hcnJheVwiXG5sZXQgYXJyYXkzX29mX2dlbmFycmF5IGEgPVxuICBpZiBHZW5hcnJheS5udW1fZGltcyBhID0gMyB0aGVuIGFcbiAgZWxzZSBpbnZhbGlkX2FyZyBcIkJpZ2FycmF5LmFycmF5M19vZl9nZW5hcnJheVwiXG5cbmV4dGVybmFsIHJlc2hhcGU6XG4gICAoJ2EsICdiLCAnYykgR2VuYXJyYXkudCAtPiBpbnQgYXJyYXkgLT4gKCdhLCAnYiwgJ2MpIEdlbmFycmF5LnRcbiAgID0gXCJjYW1sX2JhX3Jlc2hhcGVcIlxubGV0IHJlc2hhcGVfMCBhID0gcmVzaGFwZSBhIFt8fF1cbmxldCByZXNoYXBlXzEgYSBkaW0xID0gcmVzaGFwZSBhIFt8ZGltMXxdXG5sZXQgcmVzaGFwZV8yIGEgZGltMSBkaW0yID0gcmVzaGFwZSBhIFt8ZGltMTtkaW0yfF1cbmxldCByZXNoYXBlXzMgYSBkaW0xIGRpbTIgZGltMyA9IHJlc2hhcGUgYSBbfGRpbTE7ZGltMjtkaW0zfF1cblxuKCogRm9yY2UgY2FtbF9iYV9nZXRfezEsMiwzLE59IHRvIGJlIGxpbmtlZCBpbiwgc2luY2Ugd2UgZG9uJ3QgcmVmZXJcbiAgIHRvIHRob3NlIHByaW1pdGl2ZXMgZGlyZWN0bHkgaW4gdGhpcyBmaWxlICopXG5cbmxldCBfID1cbiAgbGV0IF8gPSBHZW5hcnJheS5nZXQgaW5cbiAgbGV0IF8gPSBBcnJheTEuZ2V0IGluXG4gIGxldCBfID0gQXJyYXkyLmdldCBpblxuICBsZXQgXyA9IEFycmF5My5nZXQgaW5cbiAgKClcblxuW0BAQG9jYW1sLndhcm5pbmcgXCItMzJcIl1cbmV4dGVybmFsIGdldDE6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9iYV9nZXRfMVwiXG5leHRlcm5hbCBnZXQyOiB1bml0IC0+IHVuaXQgPSBcImNhbWxfYmFfZ2V0XzJcIlxuZXh0ZXJuYWwgZ2V0MzogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2JhX2dldF8zXCJcbmV4dGVybmFsIHNldDE6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9iYV9zZXRfMVwiXG5leHRlcm5hbCBzZXQyOiB1bml0IC0+IHVuaXQgPSBcImNhbWxfYmFfc2V0XzJcIlxuZXh0ZXJuYWwgc2V0MzogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2JhX3NldF8zXCJcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMjEgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxudHlwZSB0ID0gaW5fY2hhbm5lbFxuXG50eXBlIG9wZW5fZmxhZyA9IFN0ZGxpYi5vcGVuX2ZsYWcgPVxuICB8IE9wZW5fcmRvbmx5XG4gIHwgT3Blbl93cm9ubHlcbiAgfCBPcGVuX2FwcGVuZFxuICB8IE9wZW5fY3JlYXRcbiAgfCBPcGVuX3RydW5jXG4gIHwgT3Blbl9leGNsXG4gIHwgT3Blbl9iaW5hcnlcbiAgfCBPcGVuX3RleHRcbiAgfCBPcGVuX25vbmJsb2NrXG5cbmxldCBzdGRpbiA9IFN0ZGxpYi5zdGRpblxubGV0IG9wZW5fYmluID0gU3RkbGliLm9wZW5faW5fYmluXG5sZXQgb3Blbl90ZXh0ID0gU3RkbGliLm9wZW5faW5cbmxldCBvcGVuX2dlbiA9IFN0ZGxpYi5vcGVuX2luX2dlblxuXG5sZXQgd2l0aF9vcGVuIG9wZW5mdW4gcyBmID1cbiAgbGV0IGljID0gb3BlbmZ1biBzIGluXG4gIEZ1bi5wcm90ZWN0IH5maW5hbGx5OihmdW4gKCkgLT4gU3RkbGliLmNsb3NlX2luX25vZXJyIGljKVxuICAgIChmdW4gKCkgLT4gZiBpYylcblxubGV0IHdpdGhfb3Blbl9iaW4gcyBmID1cbiAgd2l0aF9vcGVuIFN0ZGxpYi5vcGVuX2luX2JpbiBzIGZcblxubGV0IHdpdGhfb3Blbl90ZXh0IHMgZiA9XG4gIHdpdGhfb3BlbiBTdGRsaWIub3Blbl9pbiBzIGZcblxubGV0IHdpdGhfb3Blbl9nZW4gZmxhZ3MgcGVybSBzIGYgPVxuICB3aXRoX29wZW4gKFN0ZGxpYi5vcGVuX2luX2dlbiBmbGFncyBwZXJtKSBzIGZcblxubGV0IHNlZWsgPSBTdGRsaWIuTGFyZ2VGaWxlLnNlZWtfaW5cbmxldCBwb3MgPSBTdGRsaWIuTGFyZ2VGaWxlLnBvc19pblxubGV0IGxlbmd0aCA9IFN0ZGxpYi5MYXJnZUZpbGUuaW5fY2hhbm5lbF9sZW5ndGhcbmxldCBjbG9zZSA9IFN0ZGxpYi5jbG9zZV9pblxubGV0IGNsb3NlX25vZXJyID0gU3RkbGliLmNsb3NlX2luX25vZXJyXG5cbmxldCBpbnB1dF9jaGFyIGljID1cbiAgbWF0Y2ggU3RkbGliLmlucHV0X2NoYXIgaWMgd2l0aFxuICB8IGMgLT4gU29tZSBjXG4gIHwgZXhjZXB0aW9uIEVuZF9vZl9maWxlIC0+IE5vbmVcblxubGV0IGlucHV0X2J5dGUgaWMgPVxuICBtYXRjaCBTdGRsaWIuaW5wdXRfYnl0ZSBpYyB3aXRoXG4gIHwgbiAtPiBTb21lIG5cbiAgfCBleGNlcHRpb24gRW5kX29mX2ZpbGUgLT4gTm9uZVxuXG5sZXQgaW5wdXRfbGluZSBpYyA9XG4gIG1hdGNoIFN0ZGxpYi5pbnB1dF9saW5lIGljIHdpdGhcbiAgfCBzIC0+IFNvbWUgc1xuICB8IGV4Y2VwdGlvbiBFbmRfb2ZfZmlsZSAtPiBOb25lXG5cbmxldCBpbnB1dCA9IFN0ZGxpYi5pbnB1dFxuXG5sZXQgcmVhbGx5X2lucHV0IGljIGJ1ZiBwb3MgbGVuID1cbiAgbWF0Y2ggU3RkbGliLnJlYWxseV9pbnB1dCBpYyBidWYgcG9zIGxlbiB3aXRoXG4gIHwgKCkgLT4gU29tZSAoKVxuICB8IGV4Y2VwdGlvbiBFbmRfb2ZfZmlsZSAtPiBOb25lXG5cbmxldCByZWFsbHlfaW5wdXRfc3RyaW5nIGljIGxlbiA9XG4gIG1hdGNoIFN0ZGxpYi5yZWFsbHlfaW5wdXRfc3RyaW5nIGljIGxlbiB3aXRoXG4gIHwgcyAtPiBTb21lIHNcbiAgfCBleGNlcHRpb24gRW5kX29mX2ZpbGUgLT4gTm9uZVxuXG4oKiBSZWFkIHVwIHRvIFtsZW5dIGJ5dGVzIGludG8gW2J1Zl0sIHN0YXJ0aW5nIGF0IFtvZnNdLiBSZXR1cm4gdG90YWwgYnl0ZXNcbiAgIHJlYWQuICopXG5sZXQgcmVhZF91cHRvIGljIGJ1ZiBvZnMgbGVuID1cbiAgbGV0IHJlYyBsb29wIG9mcyBsZW4gPVxuICAgIGlmIGxlbiA9IDAgdGhlbiBvZnNcbiAgICBlbHNlIGJlZ2luXG4gICAgICBsZXQgciA9IFN0ZGxpYi5pbnB1dCBpYyBidWYgb2ZzIGxlbiBpblxuICAgICAgaWYgciA9IDAgdGhlblxuICAgICAgICBvZnNcbiAgICAgIGVsc2VcbiAgICAgICAgbG9vcCAob2ZzICsgcikgKGxlbiAtIHIpXG4gICAgZW5kXG4gIGluXG4gIGxvb3Agb2ZzIGxlbiAtIG9mc1xuXG4oKiBCZXN0IGVmZm9ydCBhdHRlbXB0IHRvIHJldHVybiBhIGJ1ZmZlciB3aXRoID49IChvZnMgKyBuKSBieXRlcyBvZiBzdG9yYWdlLFxuICAgYW5kIHN1Y2ggdGhhdCBpdCBjb2luY2lkZXMgd2l0aCBbYnVmXSBhdCBpbmRpY2VzIDwgW29mc10uXG5cbiAgIFRoZSByZXR1cm5lZCBidWZmZXIgaXMgZXF1YWwgdG8gW2J1Zl0gaXRzZWxmIGlmIGl0IGFscmVhZHkgaGFzIHN1ZmZpY2llbnRcbiAgIGZyZWUgc3BhY2UuXG5cbiAgIFRoZSByZXR1cm5lZCBidWZmZXIgbWF5IGhhdmUgKmZld2VyKiB0aGFuIFtvZnMgKyBuXSBieXRlcyBvZiBzdG9yYWdlIGlmIHRoaXNcbiAgIG51bWJlciBpcyA+IFtTeXMubWF4X3N0cmluZ19sZW5ndGhdLiBIb3dldmVyIHRoZSByZXR1cm5lZCBidWZmZXIgd2lsbFxuICAgKmFsd2F5cyogaGF2ZSA+IFtvZnNdIGJ5dGVzIG9mIHN0b3JhZ2UuIEluIHRoZSBsaW1pdGluZyBjYXNlIHdoZW4gW29mcyA9IGxlblxuICAgPSBTeXMubWF4X3N0cmluZ19sZW5ndGhdIChzbyB0aGF0IGl0IGlzIG5vdCBwb3NzaWJsZSB0byByZXNpemUgdGhlIGJ1ZmZlciBhdFxuICAgYWxsKSwgYW4gZXhjZXB0aW9uIGlzIHJhaXNlZC4gKilcblxubGV0IGVuc3VyZSBidWYgb2ZzIG4gPVxuICBsZXQgbGVuID0gQnl0ZXMubGVuZ3RoIGJ1ZiBpblxuICBpZiBsZW4gPj0gb2ZzICsgbiB0aGVuIGJ1ZlxuICBlbHNlIGJlZ2luXG4gICAgbGV0IG5ld19sZW4gPSByZWYgbGVuIGluXG4gICAgd2hpbGUgIW5ld19sZW4gPCBvZnMgKyBuIGRvXG4gICAgICBuZXdfbGVuIDo9IDIgKiAhbmV3X2xlbiArIDFcbiAgICBkb25lO1xuICAgIGxldCBuZXdfbGVuID0gIW5ld19sZW4gaW5cbiAgICBsZXQgbmV3X2xlbiA9XG4gICAgICBpZiBuZXdfbGVuIDw9IFN5cy5tYXhfc3RyaW5nX2xlbmd0aCB0aGVuXG4gICAgICAgIG5ld19sZW5cbiAgICAgIGVsc2UgaWYgb2ZzIDwgU3lzLm1heF9zdHJpbmdfbGVuZ3RoIHRoZW5cbiAgICAgICAgU3lzLm1heF9zdHJpbmdfbGVuZ3RoXG4gICAgICBlbHNlXG4gICAgICAgIGZhaWx3aXRoIFwiSW5fY2hhbm5lbC5pbnB1dF9hbGw6IGNoYW5uZWwgY29udGVudCBcXFxuICAgICAgICAgICAgICAgICAgaXMgbGFyZ2VyIHRoYW4gbWF4aW11bSBzdHJpbmcgbGVuZ3RoXCJcbiAgICBpblxuICAgIGxldCBuZXdfYnVmID0gQnl0ZXMuY3JlYXRlIG5ld19sZW4gaW5cbiAgICBCeXRlcy5ibGl0IGJ1ZiAwIG5ld19idWYgMCBvZnM7XG4gICAgbmV3X2J1ZlxuICBlbmRcblxubGV0IGlucHV0X2FsbCBpYyA9XG4gIGxldCBjaHVua19zaXplID0gNjU1MzYgaW4gKCogSU9fQlVGRkVSX1NJWkUgKilcbiAgbGV0IGluaXRpYWxfc2l6ZSA9XG4gICAgdHJ5XG4gICAgICBTdGRsaWIuaW5fY2hhbm5lbF9sZW5ndGggaWMgLSBTdGRsaWIucG9zX2luIGljXG4gICAgd2l0aCBTeXNfZXJyb3IgXyAtPlxuICAgICAgLTFcbiAgaW5cbiAgbGV0IGluaXRpYWxfc2l6ZSA9IGlmIGluaXRpYWxfc2l6ZSA8IDAgdGhlbiBjaHVua19zaXplIGVsc2UgaW5pdGlhbF9zaXplIGluXG4gIGxldCBpbml0aWFsX3NpemUgPVxuICAgIGlmIGluaXRpYWxfc2l6ZSA8PSBTeXMubWF4X3N0cmluZ19sZW5ndGggdGhlblxuICAgICAgaW5pdGlhbF9zaXplXG4gICAgZWxzZVxuICAgICAgU3lzLm1heF9zdHJpbmdfbGVuZ3RoXG4gIGluXG4gIGxldCBidWYgPSBCeXRlcy5jcmVhdGUgaW5pdGlhbF9zaXplIGluXG4gIGxldCBucmVhZCA9IHJlYWRfdXB0byBpYyBidWYgMCBpbml0aWFsX3NpemUgaW5cbiAgaWYgbnJlYWQgPCBpbml0aWFsX3NpemUgdGhlbiAoKiBFT0YgcmVhY2hlZCwgYnVmZmVyIHBhcnRpYWxseSBmaWxsZWQgKilcbiAgICBCeXRlcy5zdWJfc3RyaW5nIGJ1ZiAwIG5yZWFkXG4gIGVsc2UgYmVnaW4gKCogbnJlYWQgPSBpbml0aWFsX3NpemUsIG1heWJlIEVPRiByZWFjaGVkICopXG4gICAgbWF0Y2ggU3RkbGliLmlucHV0X2NoYXIgaWMgd2l0aFxuICAgIHwgZXhjZXB0aW9uIEVuZF9vZl9maWxlIC0+XG4gICAgICAgICgqIEVPRiByZWFjaGVkLCBidWZmZXIgaXMgY29tcGxldGVseSBmaWxsZWQgKilcbiAgICAgICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBidWZcbiAgICB8IGMgLT5cbiAgICAgICAgKCogRU9GIG5vdCByZWFjaGVkICopXG4gICAgICAgIGxldCByZWMgbG9vcCBidWYgb2ZzID1cbiAgICAgICAgICBsZXQgYnVmID0gZW5zdXJlIGJ1ZiBvZnMgY2h1bmtfc2l6ZSBpblxuICAgICAgICAgIGxldCByZW0gPSBCeXRlcy5sZW5ndGggYnVmIC0gb2ZzIGluXG4gICAgICAgICAgKCogW3JlbV0gY2FuIGJlIDwgW2NodW5rX3NpemVdIGlmIGJ1ZmZlciBzaXplIGNsb3NlIHRvXG4gICAgICAgICAgICAgW1N5cy5tYXhfc3RyaW5nX2xlbmd0aF0gKilcbiAgICAgICAgICBsZXQgciA9IHJlYWRfdXB0byBpYyBidWYgb2ZzIHJlbSBpblxuICAgICAgICAgIGlmIHIgPCByZW0gdGhlbiAoKiBFT0YgcmVhY2hlZCAqKVxuICAgICAgICAgICAgQnl0ZXMuc3ViX3N0cmluZyBidWYgMCAob2ZzICsgcilcbiAgICAgICAgICBlbHNlICgqIHIgPSByZW0gKilcbiAgICAgICAgICAgIGxvb3AgYnVmIChvZnMgKyByZW0pXG4gICAgICAgIGluXG4gICAgICAgIGxldCBidWYgPSBlbnN1cmUgYnVmIG5yZWFkIChjaHVua19zaXplICsgMSkgaW5cbiAgICAgICAgQnl0ZXMuc2V0IGJ1ZiBucmVhZCBjO1xuICAgICAgICBsb29wIGJ1ZiAobnJlYWQgKyAxKVxuICBlbmRcblxubGV0IHNldF9iaW5hcnlfbW9kZSA9IFN0ZGxpYi5zZXRfYmluYXJ5X21vZGVfaW5cbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMjEgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxudHlwZSB0ID0gb3V0X2NoYW5uZWxcblxudHlwZSBvcGVuX2ZsYWcgPSBTdGRsaWIub3Blbl9mbGFnID1cbiAgfCBPcGVuX3Jkb25seVxuICB8IE9wZW5fd3Jvbmx5XG4gIHwgT3Blbl9hcHBlbmRcbiAgfCBPcGVuX2NyZWF0XG4gIHwgT3Blbl90cnVuY1xuICB8IE9wZW5fZXhjbFxuICB8IE9wZW5fYmluYXJ5XG4gIHwgT3Blbl90ZXh0XG4gIHwgT3Blbl9ub25ibG9ja1xuXG5sZXQgc3Rkb3V0ID0gU3RkbGliLnN0ZG91dFxubGV0IHN0ZGVyciA9IFN0ZGxpYi5zdGRlcnJcbmxldCBvcGVuX2JpbiA9IFN0ZGxpYi5vcGVuX291dF9iaW5cbmxldCBvcGVuX3RleHQgPSBTdGRsaWIub3Blbl9vdXRcbmxldCBvcGVuX2dlbiA9IFN0ZGxpYi5vcGVuX291dF9nZW5cblxubGV0IHdpdGhfb3BlbiBvcGVuZnVuIHMgZiA9XG4gIGxldCBvYyA9IG9wZW5mdW4gcyBpblxuICBGdW4ucHJvdGVjdCB+ZmluYWxseTooZnVuICgpIC0+IFN0ZGxpYi5jbG9zZV9vdXRfbm9lcnIgb2MpXG4gICAgKGZ1biAoKSAtPiBmIG9jKVxuXG5sZXQgd2l0aF9vcGVuX2JpbiBzIGYgPVxuICB3aXRoX29wZW4gU3RkbGliLm9wZW5fb3V0X2JpbiBzIGZcblxubGV0IHdpdGhfb3Blbl90ZXh0IHMgZiA9XG4gIHdpdGhfb3BlbiBTdGRsaWIub3Blbl9vdXQgcyBmXG5cbmxldCB3aXRoX29wZW5fZ2VuIGZsYWdzIHBlcm0gcyBmID1cbiAgd2l0aF9vcGVuIChTdGRsaWIub3Blbl9vdXRfZ2VuIGZsYWdzIHBlcm0pIHMgZlxuXG5sZXQgc2VlayA9IFN0ZGxpYi5MYXJnZUZpbGUuc2Vla19vdXRcbmxldCBwb3MgPSBTdGRsaWIuTGFyZ2VGaWxlLnBvc19vdXRcbmxldCBsZW5ndGggPSBTdGRsaWIuTGFyZ2VGaWxlLm91dF9jaGFubmVsX2xlbmd0aFxubGV0IGNsb3NlID0gU3RkbGliLmNsb3NlX291dFxubGV0IGNsb3NlX25vZXJyID0gU3RkbGliLmNsb3NlX291dF9ub2VyclxubGV0IGZsdXNoID0gU3RkbGliLmZsdXNoXG5sZXQgZmx1c2hfYWxsID0gU3RkbGliLmZsdXNoX2FsbFxubGV0IG91dHB1dF9jaGFyID0gU3RkbGliLm91dHB1dF9jaGFyXG5sZXQgb3V0cHV0X2J5dGUgPSBTdGRsaWIub3V0cHV0X2J5dGVcbmxldCBvdXRwdXRfc3RyaW5nID0gU3RkbGliLm91dHB1dF9zdHJpbmdcbmxldCBvdXRwdXRfYnl0ZXMgPSBTdGRsaWIub3V0cHV0X2J5dGVzXG5sZXQgb3V0cHV0ID0gU3RkbGliLm91dHB1dFxubGV0IG91dHB1dF9zdWJzdHJpbmcgPSBTdGRsaWIub3V0cHV0X3N1YnN0cmluZ1xubGV0IHNldF9iaW5hcnlfbW9kZSA9IFN0ZGxpYi5zZXRfYmluYXJ5X21vZGVfb3V0XG5cbmV4dGVybmFsIHNldF9idWZmZXJlZCA6IHQgLT4gYm9vbCAtPiB1bml0ID0gXCJjYW1sX21sX3NldF9idWZmZXJlZFwiXG5cbmV4dGVybmFsIGlzX2J1ZmZlcmVkIDogdCAtPiBib29sID0gXCJjYW1sX21sX2lzX2J1ZmZlcmVkXCJcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgIENvcHlyaWdodCAyMDIyIE9DYW1sUHJvICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICBBbGwgcmlnaHRzIHJlc2VydmVkLiBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSAgKilcbigqICBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlIHNwZWNpYWwgICAgICAgKilcbigqICBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxubW9kdWxlIFYxID0gc3RydWN0XG5cbiAgbGV0IHZhbGlkX2NhbnZhc19zaXplICh3aWR0aCwgaGVpZ2h0KSA9XG4gICAgMCA8IHdpZHRoICYmIHdpZHRoIDw9IDMyNzY3ICYmIDAgPCBoZWlnaHQgJiYgaGVpZ2h0IDw9IDMyNzY3XG5cbiAgbW9kdWxlIEV4Y2VwdGlvbiA9IHN0cnVjdFxuXG4gICAgZXhjZXB0aW9uIE5vdF9pbml0aWFsaXplZFxuICAgIGV4Y2VwdGlvbiBGaWxlX25vdF9mb3VuZCBvZiBzdHJpbmdcbiAgICBleGNlcHRpb24gUmVhZF9wbmdfZmFpbGVkIG9mIHN0cmluZ1xuICAgIGV4Y2VwdGlvbiBXcml0ZV9wbmdfZmFpbGVkIG9mIHN0cmluZ1xuXG4gICAgbGV0ICgpID1cbiAgICAgIENhbGxiYWNrLnJlZ2lzdGVyX2V4Y2VwdGlvbiBcIk5vdF9pbml0aWFsaXplZFwiIE5vdF9pbml0aWFsaXplZDtcbiAgICAgIENhbGxiYWNrLnJlZ2lzdGVyX2V4Y2VwdGlvbiBcIkZpbGVfbm90X2ZvdW5kXCIgKEZpbGVfbm90X2ZvdW5kIFwiXCIpO1xuICAgICAgQ2FsbGJhY2sucmVnaXN0ZXJfZXhjZXB0aW9uIFwiUmVhZF9wbmdfZmFpbGVkXCIgKFJlYWRfcG5nX2ZhaWxlZCBcIlwiKTtcbiAgICAgIENhbGxiYWNrLnJlZ2lzdGVyX2V4Y2VwdGlvbiBcIldyaXRlX3BuZ19mYWlsZWRcIiAoV3JpdGVfcG5nX2ZhaWxlZCBcIlwiKVxuXG4gIGVuZFxuXG4gIG1vZHVsZSBDb25zdCA9IHN0cnVjdFxuXG4gICAgbGV0IHBpID0gICAgICAgMy4xNDE1OTI2NTM1ODk3OTMyMzg0NlxuICAgIGxldCBwaV8yID0gICAgIDEuNTcwNzk2MzI2Nzk0ODk2NjE5MjNcbiAgICBsZXQgcGlfNCA9ICAgICAwLjc4NTM5ODE2MzM5NzQ0ODMwOTYxNlxuICAgIGxldCBwaV84ID0gICAgIDAuMzkyNjk5MDgxNjk4NzI0MTU0ODA4XG5cbiAgICBsZXQgaW52X3BpID0gICAwLjMxODMwOTg4NjE4Mzc5MDY3MTUzOFxuICAgIGxldCBpbnZfcGlfMiA9IDAuNjM2NjE5NzcyMzY3NTgxMzQzMDc2XG4gICAgbGV0IGludl9waV80ID0gMS4yNzMyMzk1NDQ3MzUxNjI2ODYxNVxuICAgIGxldCBpbnZfcGlfOCA9IDIuNTQ2NDc5MDg5NDcwMzI1MzcyMzBcblxuICAgIGxldCBlID0gICAgICAgIDIuNzE4MjgxODI4NDU5MDQ1MjM1MzZcbiAgICBsZXQgaW52X2UgPSAgICAwLjM2Nzg3OTQ0MTE3MTQ0MjMyMTU5NlxuXG4gICAgbGV0IGxvZzJfZSA9ICAgMS40NDI2OTUwNDA4ODg5NjM0MDczNlxuICAgIGxldCBsb2cxMF9lID0gIDAuNDM0Mjk0NDgxOTAzMjUxODI3NjUxXG5cbiAgICBsZXQgbG5fMiA9ICAgICAwLjY5MzE0NzE4MDU1OTk0NTMwOTQxN1xuICAgIGxldCBsbl8xMCA9ICAgIDIuMzAyNTg1MDkyOTk0MDQ1Njg0MDJcblxuICBlbmRcblxuICBtb2R1bGUgVmVjdG9yID0gc3RydWN0XG5cbiAgICB0eXBlIHQgPSAoZmxvYXQgKiBmbG9hdClcblxuICAgIGxldCB6ZXJvID1cbiAgICAgICgwLjAsIDAuMClcblxuICAgIGxldCB1bml0ID1cbiAgICAgICgxLjAsIDEuMClcblxuICAgIGxldCBhZGQgKHgxLCB5MSkgKHgyLCB5MikgPVxuICAgICAgeDEgKy4geDIsIHkxICsuIHkyXG5cbiAgICBsZXQgc3ViICh4MSwgeTEpICh4MiwgeTIpID1cbiAgICAgIHgxIC0uIHgyLCB5MSAtLiB5MlxuXG4gICAgbGV0IG11bCAoeCwgeSkgayA9XG4gICAgICB4ICouIGssIHkgKi4ga1xuXG4gICAgbGV0IGRvdCAoeDEsIHkxKSAoeDIsIHkyKSA9XG4gICAgICB4MSAqLiB4MiArLiB5MSAqLiB5MlxuXG4gICAgbGV0IG5vcm0gKHgsIHkpID1cbiAgICAgIHNxcnQgKHggKi4geCArLiB5ICouIHkpXG5cbiAgZW5kXG5cbiAgbW9kdWxlIFRyYW5zZm9ybSA9IHN0cnVjdFxuXG4gICAgdHlwZSB0ID0ge1xuICAgICAgYSA6IGZsb2F0O1xuICAgICAgYiA6IGZsb2F0O1xuICAgICAgYyA6IGZsb2F0O1xuICAgICAgZCA6IGZsb2F0O1xuICAgICAgZSA6IGZsb2F0O1xuICAgICAgZiA6IGZsb2F0O1xuICAgIH1cblxuICAgIGxldCBpZCA9IHsgYSA9IDEuMDsgYiA9IDAuMDtcbiAgICAgICAgICAgICAgIGMgPSAwLjA7IGQgPSAxLjA7XG4gICAgICAgICAgICAgICBlID0gMC4wOyBmID0gMC4wIH1cblxuICAgIGxldCBjcmVhdGUgKGEsIGIsIGMsIGQsIGUsIGYpID1cbiAgICAgIHsgYTsgYjsgYzsgZDsgZTsgZiB9XG5cbiAgICBsZXQgbXVsIHQxIHQyID1cbiAgICAgIHsgYSA9IHQxLmEgKi4gdDIuYSArLiB0MS5jICouIHQyLmI7XG4gICAgICAgIGIgPSB0MS5iICouIHQyLmEgKy4gdDEuZCAqLiB0Mi5iO1xuICAgICAgICBjID0gdDEuYSAqLiB0Mi5jICsuIHQxLmMgKi4gdDIuZDtcbiAgICAgICAgZCA9IHQxLmIgKi4gdDIuYyArLiB0MS5kICouIHQyLmQ7XG4gICAgICAgIGUgPSB0MS5lICsuIHQxLmEgKi4gdDIuZSArLiB0MS5jICouIHQyLmY7XG4gICAgICAgIGYgPSB0MS5mICsuIHQxLmIgKi4gdDIuZSArLiB0MS5kICouIHQyLmYgfVxuXG4gICAgbGV0IHRyYW5zbGF0ZSB0ICh4LCB5KSA9XG4gICAgICB7IHQgd2l0aFxuICAgICAgICBlID0geCAqLiB0LmEgKy4geSAqLiB0LmM7XG4gICAgICAgIGYgPSB4ICouIHQuYiArLiB5ICouIHQuZCB9XG5cbiAgICBsZXQgc2NhbGUgdCAoeCx5KSA9XG4gICAgICB7IHQgd2l0aFxuICAgICAgICBhID0gdC5hICouIHg7IGIgPSB0LmIgKi4geDtcbiAgICAgICAgYyA9IHQuYyAqLiB5OyBkID0gdC5kICouIHkgfVxuXG4gICAgbGV0IHNoZWFyIHQgKHgsIHkpID1cbiAgICAgIHsgdCB3aXRoXG4gICAgICAgIGEgPSB0LmEgKy4gdC5jICouIHk7IGIgPSB0LmIgKy4gdC5kICouIHk7XG4gICAgICAgIGMgPSB0LmMgKy4gdC5hICouIHg7IGQgPSB0LmQgKy4gdC5iICouIHggfVxuXG4gICAgbGV0IHJvdGF0ZSB0IGEgPVxuICAgICAgbGV0IGNvc19hID0gY29zICgtLiBhKSBpblxuICAgICAgbGV0IHNpbl9hID0gc2luICgtLiBhKSBpblxuICAgICAgeyB0IHdpdGhcbiAgICAgICAgYSA9IHQuYSAqLiBjb3NfYSAtLiB0LmMgKi4gc2luX2E7XG4gICAgICAgIGIgPSB0LmIgKi4gY29zX2EgLS4gdC5kICouIHNpbl9hO1xuICAgICAgICBjID0gdC5jICouIGNvc19hICsuIHQuYSAqLiBzaW5fYTtcbiAgICAgICAgZCA9IHQuZCAqLiBjb3NfYSArLiB0LmIgKi4gc2luX2EgfVxuXG4gICAgbGV0IGludmVyc2UgdCA9XG4gICAgICBsZXQgZGV0ID0gdC5hICouIHQuZCAtLiB0LmIgKi4gdC5jIGluXG4gICAgICBpZiBkZXQgPSAwLjAgdGhlblxuICAgICAgICBpbnZhbGlkX2FyZyBcIlRyYW5zZm9ybS5pbnZlcnNlOiB0aGUgbWF0cml4IGlzIG5vdCBpbnZlcnNpYmxlXCI7XG4gICAgICBsZXQgaW52ZGV0ID0gMS4wIC8uIGRldCBpblxuICAgICAgeyBhID0gICAgdC5kICouIGludmRldDsgYiA9IC0uIHQuYiAqLiBpbnZkZXQ7XG4gICAgICAgIGMgPSAtLiB0LmMgKi4gaW52ZGV0OyBkID0gICAgdC5hICouIGludmRldDtcbiAgICAgICAgZSA9ICh0LmMgKi4gdC5mIC0uIHQuZCAqLiB0LmUpICouIGludmRldDtcbiAgICAgICAgZiA9ICh0LmIgKi4gdC5lIC0uIHQuYSAqLiB0LmYpICouIGludmRldCB9XG5cbiAgZW5kXG5cbiAgbW9kdWxlIFBvaW50ID0gc3RydWN0XG5cbiAgICB0eXBlIHQgPSAoZmxvYXQgKiBmbG9hdClcblxuICAgIGxldCBvZl9pbnRzICh4LCB5KSA9XG4gICAgICAoZmxvYXRfb2ZfaW50IHgsIGZsb2F0X29mX2ludCB5KVxuXG4gICAgbGV0IHN1YiAoeDEsIHkxKSAoeDIsIHkyKSA9XG4gICAgICB4MSAtLiB4MiwgeTEgLS4geTJcblxuICAgIGxldCB0cmFuc2xhdGUgKHgsIHkpIH5ieTooYSwgYikgPVxuICAgICAgKHggKy4gYSwgeSArLiBiKVxuXG4gICAgbGV0IHJvdGF0ZSAoeCwgeSkgfmFyb3VuZDooY3gsIGN5KSB+dGhldGEgPVxuICAgICAgKCh4IC0uIGN4KSAqLiAoY29zICgtLiB0aGV0YSkpICsuICh5IC0uIGN5KSAqLiAoc2luICgtLiB0aGV0YSkpICsuIGN4LFxuICAgICAgICh5IC0uIGN5KSAqLiAoY29zICgtLiB0aGV0YSkpIC0uICh4IC0uIGN4KSAqLiAoc2luICgtLiB0aGV0YSkpICsuIGN5KVxuXG4gICAgbGV0IHRyYW5zZm9ybSAoeCwgeSkgdCA9XG4gICAgICBsZXQgb3BlbiBUcmFuc2Zvcm0gaW5cbiAgICAgICh4ICouIHQuYSArLiB5ICouIHQuYyArLiB0LmUsXG4gICAgICAgeCAqLiB0LmIgKy4geSAqLiB0LmQgKy4gdC5mKVxuXG4gICAgbGV0IGJhcnljZW50ZXIgYSAoeDEsIHkxKSBiICh4MiwgeTIpID1cbiAgICAgIGxldCBzdW1fYWIgPSBhICsuIGIgaW5cbiAgICAgIGlmIHN1bV9hYiA9IDAuMCB0aGVuXG4gICAgICAgIGludmFsaWRfYXJnIFwiUG9pbnQuYmFyeWNlbnRlcjogYSArIGIgbXVzdCBiZSBub24tbnVsXCI7XG4gICAgICAoYSAqLiB4MSArLiBiICouIHgyKSAvLiBzdW1fYWIsXG4gICAgICAoYSAqLiB5MSArLiBiICouIHkyKSAvLiBzdW1fYWJcblxuICAgIGxldCBkaXN0YW5jZSAoeDEsIHkxKSAoeDIsIHkyKSA9XG4gICAgICBzcXJ0ICgoeDIgLS4geDEpICoqIDIuMCArLiAoeTIgLS4geTEpICoqIDIuMClcblxuICBlbmRcblxuICBtb2R1bGUgQ29sb3IgPSBzdHJ1Y3RcblxuICAgIHR5cGUgdCA9IEludDMyLnRcblxuICAgIGxldCBjbGlwXzggaSA9XG4gICAgICBpZiBpIDwgMCB0aGVuIDBcbiAgICAgIGVsc2UgaWYgaSA+IDB4RkYgdGhlbiAweEZGXG4gICAgICBlbHNlIGlcblxuICAgIGxldCBvZl9yZ2IgciBnIGIgPVxuICAgICAgSW50MzIuYWRkIDB4RkYwMDAwMDBsXG4gICAgICAgIChJbnQzMi5vZl9pbnQgKGNsaXBfOCByIGxzbCAxNiArIGNsaXBfOCBnIGxzbCA4ICsgY2xpcF84IGIpKVxuXG4gICAgbGV0IHRvX3JnYiBjID1cbiAgICAgIEludDMyLih0b19pbnQgKGxvZ2FuZCAoc2hpZnRfcmlnaHRfbG9naWNhbCBjIDE2KSAweEZGbCkpLFxuICAgICAgSW50MzIuKHRvX2ludCAobG9nYW5kIChzaGlmdF9yaWdodF9sb2dpY2FsIGMgOCkgMHhGRmwpKSxcbiAgICAgIEludDMyLih0b19pbnQgKGxvZ2FuZCBjIDB4RkZsKSlcblxuICAgIGxldCBvZl9hcmdiIGEgciBnIGIgPVxuICAgICAgSW50MzIuYWRkXG4gICAgICAgIChJbnQzMi5zaGlmdF9sZWZ0IChJbnQzMi5vZl9pbnQgKGNsaXBfOCBhKSkgMjQpXG4gICAgICAgIChJbnQzMi5vZl9pbnQgKGNsaXBfOCByIGxzbCAxNiArIGNsaXBfOCBnIGxzbCA4ICsgY2xpcF84IGIpKVxuXG4gICAgbGV0IHRvX2FyZ2IgYyA9XG4gICAgICBJbnQzMi4odG9faW50IChzaGlmdF9yaWdodF9sb2dpY2FsIGMgMjQpKSxcbiAgICAgIEludDMyLih0b19pbnQgKGxvZ2FuZCAoc2hpZnRfcmlnaHRfbG9naWNhbCBjIDE2KSAweEZGbCkpLFxuICAgICAgSW50MzIuKHRvX2ludCAobG9nYW5kIChzaGlmdF9yaWdodF9sb2dpY2FsIGMgOCkgMHhGRmwpKSxcbiAgICAgIEludDMyLih0b19pbnQgKGxvZ2FuZCBjIDB4RkZsKSlcblxuICAgIGxldCBvZl9pbnQgaSA9XG4gICAgICBpZiBpIDwgMCB0aGVuIDBsXG4gICAgICBlbHNlIGlmIGkgPiAweDAwRkZGRkZGIHRoZW4gMHhGRkZGRkZGRmxcbiAgICAgIGVsc2UgSW50MzIuYWRkIDB4RkYwMDAwMDBsIChJbnQzMi5vZl9pbnQgaSlcblxuICAgIGxldCB0b19pbnQgYyA9XG4gICAgICBJbnQzMi4odG9faW50IChsb2dhbmQgYyAweDAwRkZGRkZGbCkpXG5cbiAgICBsZXQgb2ZfaW50MzIgaSA9XG4gICAgICBpXG5cbiAgICBsZXQgdG9faW50MzIgYyA9XG4gICAgICBjXG5cbiAgICBtb2R1bGUgU3RyaW5nTWFwID0gTWFwLk1ha2UoU3RyaW5nKVxuICAgIGxldCBjb2xvcnMgPSByZWYgU3RyaW5nTWFwLmVtcHR5XG4gICAgbGV0IGRlZmluZV9jb2xvciBuYW1lIGMgPVxuICAgICAgY29sb3JzIDo9IFN0cmluZ01hcC5hZGQgKFN0cmluZy5sb3dlcmNhc2VfYXNjaWkgbmFtZSkgYyAhY29sb3JzO1xuICAgICAgY1xuXG4gICAgbGV0IHRyYW5zcEJsYWNrID0gZGVmaW5lX2NvbG9yIFwidHJhbnNwYXJlbnRfYmxhY2tcIiAweDAwMDAwMDAwbFxuICAgIGxldCB0cmFuc3BXaGl0ZSA9IGRlZmluZV9jb2xvciBcInRyYW5zcGFyZW50X3doaXRlXCIgMHgwMEZGRkZGRmxcbiAgICBsZXQgYmxhY2sgPSBkZWZpbmVfY29sb3IgXCJibGFja1wiIDB4RkYwMDAwMDBsXG4gICAgbGV0IHdoaXRlID0gZGVmaW5lX2NvbG9yIFwid2hpdGVcIiAweEZGRkZGRkZGbFxuICAgIGxldCBibHVlID0gZGVmaW5lX2NvbG9yIFwiYmx1ZVwiIDB4RkYwMDAwRkZsXG4gICAgbGV0IGN5YW4gPSBkZWZpbmVfY29sb3IgXCJjeWFuXCIgMHhGRjAwRkZGRmxcbiAgICBsZXQgZ3JlZW4gPSBkZWZpbmVfY29sb3IgXCJncmVlblwiIDB4RkYwMDgwMDBsXG4gICAgbGV0IGxpbWUgPSBkZWZpbmVfY29sb3IgXCJsaW1lXCIgMHhGRjAwRkYwMGxcbiAgICBsZXQgb3JhbmdlID0gZGVmaW5lX2NvbG9yIFwib3JhbmdlXCIgMHhGRkZGQTUwMGxcbiAgICBsZXQgcGluayA9IGRlZmluZV9jb2xvciBcInBpbmtcIiAweEZGRkZDMENCbFxuICAgIGxldCByZWQgPSBkZWZpbmVfY29sb3IgXCJyZWRcIiAweEZGRkYwMDAwbFxuXG4gICAgbGV0IG9mX3N0cmluZyBzID1cbiAgICAgIGlmIFN0cmluZy5sZW5ndGggcyA8IDEgdGhlblxuICAgICAgICBibGFja1xuICAgICAgZWxzZSBpZiBzLlswXSA9ICcjJyB0aGVuXG4gICAgICAgIGxldCBzID0gXCIweFwiIF4gKFN0cmluZy5zdWIgcyAxIChTdHJpbmcubGVuZ3RoIHMgLSAxKSkgaW5cbiAgICAgICAgb2ZfaW50IChpbnRfb2Zfc3RyaW5nIHMpXG4gICAgICBlbHNlXG4gICAgICAgIHRyeSBTdHJpbmdNYXAuZmluZCAoU3RyaW5nLmxvd2VyY2FzZV9hc2NpaSBzKSAhY29sb3JzXG4gICAgICAgIHdpdGggTm90X2ZvdW5kIC0+IGJsYWNrXG5cbiAgZW5kXG5cbiAgbW9kdWxlIEZvbnQgPSBzdHJ1Y3RcblxuICAgIHR5cGUgc2l6ZSA9IGZsb2F0XG5cbiAgICB0eXBlIHNsYW50ID1cbiAgICAgIHwgUm9tYW5cbiAgICAgIHwgSXRhbGljXG4gICAgICB8IE9ibGlxdWVcblxuICAgIHR5cGUgd2VpZ2h0ID0gaW50XG5cbiAgICBsZXQgdGhpbiAgICAgICA9ICAxMDBcbiAgICBsZXQgZXh0cmFMaWdodCA9ICAyMDBcbiAgICBsZXQgbGlnaHQgICAgICA9ICAzMDBcbiAgICAoKmxldCBzZW1pTGlnaHQgID0gIDMxNSAqKVxuICAgICgqbGV0IGJvb2sgICAgICAgPSAgMzcwICopXG4gICAgbGV0IHJlZ3VsYXIgICAgPSAgNDAwXG4gICAgbGV0IG1lZGl1bSAgICAgPSAgNTAwXG4gICAgbGV0IHNlbWlCb2xkICAgPSAgNjAwXG4gICAgbGV0IGJvbGQgICAgICAgPSAgNzAwXG4gICAgbGV0IGV4dHJhQm9sZCAgPSAgODAwXG4gICAgbGV0IGJsYWNrICAgICAgPSAgOTAwXG4gICAgKCpsZXQgZXh0cmFCbGFjayA9IDEwMDAgKilcblxuICBlbmRcblxuICB0eXBlIGNhbnZhc1xuXG4gIHR5cGUgaW1hZ2VfZGF0YSA9XG4gICAgKGludCwgQmlnYXJyYXkuaW50OF91bnNpZ25lZF9lbHQsIEJpZ2FycmF5LmNfbGF5b3V0KSBCaWdhcnJheS5BcnJheTMudFxuXG4gIG1vZHVsZSBQZW5kaW5nID0gc3RydWN0XG5cbiAgICB0eXBlIHQgPVxuICAgICAgfCBJbWFnZURhdGEgOlxuICAgICAgICAgIGltYWdlX2RhdGEgUmVhY3QuZXZlbnQgKlxuICAgICAgICAgICAgKD9zdGVwOlJlYWN0LnN0ZXAgLT4gaW1hZ2VfZGF0YSAtPiB1bml0KSAqIGltYWdlX2RhdGEgLT4gdFxuICAgICAgfCBDYW52YXMgOlxuICAgICAgICAgIGNhbnZhcyBSZWFjdC5ldmVudCAqXG4gICAgICAgICAgICAoP3N0ZXA6UmVhY3Quc3RlcCAtPiBjYW52YXMgLT4gdW5pdCkgKiBjYW52YXMgLT4gdFxuXG4gICAgbGV0IGxpc3QgOiB0IGxpc3QgcmVmID0gcmVmIFtdXG5cbiAgICBsZXQgYWRkX2ltYWdlX2RhdGEgZXZlbnQgc2VuZF9ldmVudCBjID1cbiAgICAgIGxpc3QgOj0gSW1hZ2VEYXRhIChldmVudCwgc2VuZF9ldmVudCwgYykgOjogIWxpc3RcblxuICAgIGxldCBhZGRfY2FudmFzIGV2ZW50IHNlbmRfZXZlbnQgYyA9XG4gICAgICBsaXN0IDo9IENhbnZhcyAoZXZlbnQsIHNlbmRfZXZlbnQsIGMpIDo6ICFsaXN0XG5cbiAgICBsZXQgcHJvY2VzcyAoKSA9XG4gICAgICBtYXRjaCAhbGlzdCB3aXRoXG4gICAgICB8IFtdIC0+ICgpXG4gICAgICB8IGwgLT5cbiAgICAgICAgICBsaXN0IDo9IFtdO1xuICAgICAgICAgIExpc3QuaXRlciAoZnVuY3Rpb25cbiAgICAgICAgICAgICAgfCBJbWFnZURhdGEgKGV2ZW50LCBzZW5kX2V2ZW50LCBpZCkgLT5cbiAgICAgICAgICAgICAgICAgIHNlbmRfZXZlbnQgP3N0ZXA6Tm9uZSBpZDtcbiAgICAgICAgICAgICAgICAgIFJlYWN0LkUuc3RvcCBldmVudFxuICAgICAgICAgICAgICB8IENhbnZhcyAoZXZlbnQsIHNlbmRfZXZlbnQsIGMpIC0+XG4gICAgICAgICAgICAgICAgICBzZW5kX2V2ZW50ID9zdGVwOk5vbmUgYztcbiAgICAgICAgICAgICAgICAgIFJlYWN0LkUuc3RvcCBldmVudFxuICAgICAgICAgICAgKSAoTGlzdC5yZXYgbClcblxuICBlbmRcblxuICBtb2R1bGUgSW1hZ2VEYXRhID0gc3RydWN0XG5cbiAgICB0eXBlIHQgPSBpbWFnZV9kYXRhXG5cbiAgICBsZXQgY3JlYXRlICh3aWR0aCwgaGVpZ2h0KSA9XG4gICAgICBpZiBub3QgKHZhbGlkX2NhbnZhc19zaXplICh3aWR0aCwgaGVpZ2h0KSkgdGhlblxuICAgICAgICBpbnZhbGlkX2FyZyBcIkltYWdlRGF0YS5jcmVhdGU6IGludmFsaWQgaW1hZ2UgZGltZW5zaW9uc1wiO1xuICAgICAgbGV0IGEgPSBCaWdhcnJheS5BcnJheTMuY3JlYXRlIEJpZ2FycmF5LmludDhfdW5zaWduZWRcbiAgICAgICAgICAgICAgICBCaWdhcnJheS5jX2xheW91dCBoZWlnaHQgd2lkdGggNCBpblxuICAgICAgQmlnYXJyYXkuQXJyYXkzLmZpbGwgYSAwO1xuICAgICAgYVxuXG4gICAgZXh0ZXJuYWwgY3JlYXRlRnJvbVBOR19pbnRlcm5hbCA6IHN0cmluZyAtPiAodCAtPiB1bml0KSAtPiB1bml0XG4gICAgICA9IFwibWxfY2FudmFzX2ltYWdlX2RhdGFfY3JlYXRlX2Zyb21fcG5nXCJcblxuICAgIGxldCBjcmVhdGVGcm9tUE5HIGZpbGVuYW1lIDogdCBSZWFjdC5ldmVudCA9XG4gICAgICBsZXQgZXZlbnQsIHNlbmRfZXZlbnQgPSBSZWFjdC5FLmNyZWF0ZSAoKSBpblxuICAgICAgY3JlYXRlRnJvbVBOR19pbnRlcm5hbCBmaWxlbmFtZVxuICAgICAgICAoZnVuIGlkIC0+IFBlbmRpbmcuYWRkX2ltYWdlX2RhdGEgZXZlbnQgc2VuZF9ldmVudCBpZCk7XG4gICAgICBldmVudFxuXG4gICAgZXh0ZXJuYWwgZ2V0U2l6ZSA6IHQgLT4gKGludCAqIGludClcbiAgICAgID0gXCJtbF9jYW52YXNfaW1hZ2VfZGF0YV9nZXRfc2l6ZVwiXG5cbiAgICBleHRlcm5hbCBmaWxsIDogdCAtPiBDb2xvci50IC0+IHVuaXRcbiAgICAgID0gXCJtbF9jYW52YXNfaW1hZ2VfZGF0YV9maWxsXCJcblxuICAgIGV4dGVybmFsIHN1YiA6IHQgLT4gcG9zOihpbnQgKiBpbnQpIC0+IHNpemU6KGludCAqIGludCkgLT4gdFxuICAgICAgPSBcIm1sX2NhbnZhc19pbWFnZV9kYXRhX3N1YlwiXG5cbiAgICBleHRlcm5hbCBibGl0IDpcbiAgICAgIGRzdDp0IC0+IGRwb3M6KGludCAqIGludCkgLT5cbiAgICAgIHNyYzp0IC0+IHNwb3M6KGludCAqIGludCkgLT4gc2l6ZTooaW50ICogaW50KSAtPiB1bml0XG4gICAgICA9IFwibWxfY2FudmFzX2ltYWdlX2RhdGFfYmxpdFwiXG5cbiAgICBleHRlcm5hbCBnZXRQaXhlbCA6IHQgLT4gKGludCAqIGludCkgLT4gQ29sb3IudFxuICAgICAgPSBcIm1sX2NhbnZhc19pbWFnZV9kYXRhX2dldF9waXhlbFwiXG5cbiAgICBleHRlcm5hbCBwdXRQaXhlbCA6IHQgLT4gKGludCAqIGludCkgLT4gQ29sb3IudCAtPiB1bml0XG4gICAgICA9IFwibWxfY2FudmFzX2ltYWdlX2RhdGFfcHV0X3BpeGVsXCJcblxuICAgIGV4dGVybmFsIGltcG9ydFBOR19pbnRlcm5hbCA6XG4gICAgICB0IC0+IHBvczooaW50ICogaW50KSAtPiBzdHJpbmcgLT4gKHQgLT4gdW5pdCkgLT4gdW5pdFxuICAgICAgPSBcIm1sX2NhbnZhc19pbWFnZV9kYXRhX2ltcG9ydF9wbmdcIlxuXG4gICAgbGV0IGltcG9ydFBORyBpZCB+cG9zIGZpbGVuYW1lIDogdCBSZWFjdC5ldmVudCA9XG4gICAgICBsZXQgZXZlbnQsIHNlbmRfZXZlbnQgPSBSZWFjdC5FLmNyZWF0ZSAoKSBpblxuICAgICAgaW1wb3J0UE5HX2ludGVybmFsIGlkIH5wb3MgZmlsZW5hbWVcbiAgICAgICAgKGZ1biBpZCAtPiBQZW5kaW5nLmFkZF9pbWFnZV9kYXRhIGV2ZW50IHNlbmRfZXZlbnQgaWQpO1xuICAgICAgZXZlbnRcblxuICAgIGV4dGVybmFsIGV4cG9ydFBORyA6IHQgLT4gc3RyaW5nIC0+IHVuaXRcbiAgICAgID0gXCJtbF9jYW52YXNfaW1hZ2VfZGF0YV9leHBvcnRfcG5nXCJcblxuICAgIHR5cGUgdF9yZXByID0gaW1hZ2VfZGF0YVxuXG4gICAgbGV0IG9mX2JpZ2FycmF5IChiYSA6IHRfcmVwcikgPVxuICAgICAgaWYgbm90ICh2YWxpZF9jYW52YXNfc2l6ZSAoQmlnYXJyYXkuQXJyYXkzLmRpbTIgYmEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBCaWdhcnJheS5BcnJheTMuZGltMSBiYSkpIHRoZW5cbiAgICAgICAgaW52YWxpZF9hcmcgXCJJbWFnZURhdGEub2ZfYmlnYXJyYXk6IGludmFsaWQgaW1hZ2UgZGltZW5zaW9uc1wiO1xuXG4gICAgICBpZiBCaWdhcnJheS5BcnJheTMuZGltMyBiYSA8PiA0IHRoZW5cbiAgICAgICAgaW52YWxpZF9hcmcgXCJJbWFnZURhdGEub2ZfYmlnYXJyYXk6IHRoaXJkIGRpbWVuc2lvbiBtdXN0IGJlIDRcIjtcbiAgICAgIGJhXG5cbiAgICBleHRlcm5hbCB0b19iaWdhcnJheSA6IHQgLT4gdF9yZXByID0gXCIlaWRlbnRpdHlcIlxuXG4gIGVuZFxuXG4gIG1vZHVsZSBHcmFkaWVudCA9IHN0cnVjdFxuXG4gICAgdHlwZSB0XG5cbiAgICBleHRlcm5hbCBjcmVhdGVMaW5lYXIgOiBwb3MxOlBvaW50LnQgLT4gcG9zMjpQb2ludC50IC0+IHRcbiAgICAgID0gXCJtbF9jYW52YXNfZ3JhZGllbnRfY3JlYXRlX2xpbmVhclwiXG5cbiAgICBleHRlcm5hbCBjcmVhdGVSYWRpYWwgOlxuICAgICAgY2VudGVyMTpQb2ludC50IC0+IHJhZDE6ZmxvYXQgLT4gY2VudGVyMjpQb2ludC50IC0+IHJhZDI6ZmxvYXQgLT4gdFxuICAgICAgPSBcIm1sX2NhbnZhc19ncmFkaWVudF9jcmVhdGVfcmFkaWFsXCJcblxuICAgIGV4dGVybmFsIGNyZWF0ZUNvbmljIDogY2VudGVyOlBvaW50LnQgLT4gYW5nbGU6ZmxvYXQgLT4gdFxuICAgICAgPSBcIm1sX2NhbnZhc19ncmFkaWVudF9jcmVhdGVfY29uaWNcIlxuXG4gICAgZXh0ZXJuYWwgYWRkQ29sb3JTdG9wIDogdCAtPiBDb2xvci50IC0+IGZsb2F0IC0+IHVuaXRcbiAgICAgID0gXCJtbF9jYW52YXNfZ3JhZGllbnRfYWRkX2NvbG9yX3N0b3BcIlxuXG4gIGVuZFxuXG4gIG1vZHVsZSBQYXR0ZXJuID0gc3RydWN0XG5cbiAgICB0eXBlIHRcblxuICAgIHR5cGUgcmVwZWF0ID1cbiAgICAgIHwgTm9SZXBlYXRcbiAgICAgIHwgUmVwZWF0WFxuICAgICAgfCBSZXBlYXRZXG4gICAgICB8IFJlcGVhdFhZXG5cbiAgICBleHRlcm5hbCBjcmVhdGUgOiBJbWFnZURhdGEudCAtPiByZXBlYXQgLT4gdFxuICAgICAgPSBcIm1sX2NhbnZhc19wYXR0ZXJuX2NyZWF0ZVwiXG5cbiAgZW5kXG5cbiAgbW9kdWxlIFBhdGggPSBzdHJ1Y3RcblxuICAgIHR5cGUgdFxuXG4gICAgZXh0ZXJuYWwgY3JlYXRlIDogdW5pdCAtPiB0XG4gICAgICA9IFwibWxfY2FudmFzX3BhdGhfY3JlYXRlXCJcblxuICAgIGV4dGVybmFsIGNsb3NlIDogdCAtPiB1bml0XG4gICAgICA9IFwibWxfY2FudmFzX3BhdGhfY2xvc2VcIlxuXG4gICAgZXh0ZXJuYWwgbW92ZVRvIDogdCAtPiBQb2ludC50IC0+IHVuaXRcbiAgICAgID0gXCJtbF9jYW52YXNfcGF0aF9tb3ZlX3RvXCJcblxuICAgIGV4dGVybmFsIGxpbmVUbyA6IHQgLT4gUG9pbnQudCAtPiB1bml0XG4gICAgICA9IFwibWxfY2FudmFzX3BhdGhfbGluZV90b1wiXG5cbiAgICBleHRlcm5hbCBhcmMgOlxuICAgICAgdCAtPiBjZW50ZXI6UG9pbnQudCAtPiByYWRpdXM6ZmxvYXQgLT5cbiAgICAgIHRoZXRhMTpmbG9hdCAtPiB0aGV0YTI6ZmxvYXQgLT4gY2N3OmJvb2wgLT4gdW5pdFxuICAgICAgPSBcIm1sX2NhbnZhc19wYXRoX2FyY1wiIFwibWxfY2FudmFzX3BhdGhfYXJjX25cIlxuXG4gICAgZXh0ZXJuYWwgYXJjVG8gOiB0IC0+IHAxOlBvaW50LnQgLT4gcDI6UG9pbnQudCAtPiByYWRpdXM6ZmxvYXQgLT4gdW5pdFxuICAgICAgPSBcIm1sX2NhbnZhc19wYXRoX2FyY190b1wiXG5cbiAgICBleHRlcm5hbCBxdWFkcmF0aWNDdXJ2ZVRvIDogdCAtPiBjcDpQb2ludC50IC0+IHA6UG9pbnQudCAtPiB1bml0XG4gICAgICA9IFwibWxfY2FudmFzX3BhdGhfcXVhZHJhdGljX2N1cnZlX3RvXCJcblxuICAgIGV4dGVybmFsIGJlemllckN1cnZlVG8gOlxuICAgICAgdCAtPiBjcDE6UG9pbnQudCAtPiBjcDI6UG9pbnQudCAtPiBwOlBvaW50LnQgLT4gdW5pdFxuICAgICAgPSBcIm1sX2NhbnZhc19wYXRoX2Jlemllcl9jdXJ2ZV90b1wiXG5cbiAgICBleHRlcm5hbCByZWN0IDogdCAtPiBwb3M6UG9pbnQudCAtPiBzaXplOlZlY3Rvci50IC0+IHVuaXRcbiAgICAgID0gXCJtbF9jYW52YXNfcGF0aF9yZWN0XCJcblxuICAgIGV4dGVybmFsIGVsbGlwc2UgOlxuICAgICAgdCAtPiBjZW50ZXI6UG9pbnQudCAtPiByYWRpdXM6VmVjdG9yLnQgLT5cbiAgICAgIHJvdGF0aW9uOmZsb2F0IC0+IHRoZXRhMTpmbG9hdCAtPiB0aGV0YTI6ZmxvYXQgLT4gY2N3OmJvb2wgLT4gdW5pdFxuICAgICAgPSBcIm1sX2NhbnZhc19wYXRoX2VsbGlwc2VcIiBcIm1sX2NhbnZhc19wYXRoX2VsbGlwc2VfblwiXG5cbiAgICBleHRlcm5hbCBhZGQgOiB0IC0+IHQgLT4gdW5pdFxuICAgICAgPSBcIm1sX2NhbnZhc19wYXRoX2FkZFwiXG5cbiAgICBleHRlcm5hbCBhZGRUcmFuc2Zvcm1lZCA6IHQgLT4gdCAtPiBUcmFuc2Zvcm0udCAtPiB1bml0XG4gICAgICA9IFwibWxfY2FudmFzX3BhdGhfYWRkX3RyYW5zZm9ybWVkXCJcblxuICBlbmRcblxuICBtb2R1bGUgSm9pbiA9IHN0cnVjdFxuXG4gICAgdHlwZSB0ID1cbiAgICAgIHwgUm91bmRcbiAgICAgIHwgTWl0ZXJcbiAgICAgIHwgQmV2ZWxcblxuICBlbmRcblxuICBtb2R1bGUgQ2FwID0gc3RydWN0XG5cbiAgICB0eXBlIHQgPVxuICAgICAgfCBCdXR0XG4gICAgICB8IFNxdWFyZVxuICAgICAgfCBSb3VuZFxuXG4gIGVuZFxuXG4gIG1vZHVsZSBTdHlsZSA9IHN0cnVjdFxuXG4gICAgdHlwZSB0ID1cbiAgICAgIHwgQ29sb3Igb2YgQ29sb3IudFxuICAgICAgfCBHcmFkaWVudCBvZiBHcmFkaWVudC50XG4gICAgICB8IFBhdHRlcm4gb2YgUGF0dGVybi50XG5cbiAgZW5kXG5cbiAgbW9kdWxlIENvbXBvc2l0ZU9wID0gc3RydWN0XG5cbiAgICB0eXBlIHQgPVxuICAgICAgfCBTb3VyY2VPdmVyXG4gICAgICB8IFNvdXJjZUluXG4gICAgICB8IFNvdXJjZU91dFxuICAgICAgfCBTb3VyY2VBdG9wXG4gICAgICB8IERlc3RpbmF0aW9uT3ZlclxuICAgICAgfCBEZXN0aW5hdGlvbkluXG4gICAgICB8IERlc3RpbmF0aW9uT3V0XG4gICAgICB8IERlc3RpbmF0aW9uQXRvcFxuICAgICAgfCBMaWdodGVyXG4gICAgICB8IENvcHlcbiAgICAgIHwgWE9SXG4gICAgICB8IE11bHRpcGx5XG4gICAgICB8IFNjcmVlblxuICAgICAgfCBPdmVybGF5XG4gICAgICB8IERhcmtlblxuICAgICAgfCBMaWdodGVuXG4gICAgICB8IENvbG9yRG9kZ2VcbiAgICAgIHwgQ29sb3JCdXJuXG4gICAgICB8IEhhcmRMaWdodFxuICAgICAgfCBTb2Z0TGlnaHRcbiAgICAgIHwgRGlmZmVyZW5jZVxuICAgICAgfCBFeGNsdXNpb25cbiAgICAgIHwgSHVlXG4gICAgICB8IFNhdHVyYXRpb25cbiAgICAgIHwgQ29sb3JcbiAgICAgIHwgTHVtaW5vc2l0eVxuXG4gIGVuZFxuXG4gIG1vZHVsZSBDYW52YXMgPSBzdHJ1Y3RcblxuICAgIHR5cGUgdCA9IGNhbnZhc1xuXG4gICAgKCogQ29tcGFyaXNvbiBhbmQgaGFzaCBmdW5jdGlvbnMgKilcblxuICAgIGxldCAoKSA9XG4gICAgICBDYWxsYmFjay5yZWdpc3RlciBcIkhhc2h0YmwuaGFzaFwiIEhhc2h0YmwuaGFzaFxuXG4gICAgZXh0ZXJuYWwgY29tcGFyZSA6IHQgLT4gdCAtPiBpbnRcbiAgICAgID0gXCJtbF9jYW52YXNfY29tcGFyZVwiXG5cbiAgICBleHRlcm5hbCBoYXNoIDogdCAtPiBpbnRcbiAgICAgID0gXCJtbF9jYW52YXNfaGFzaFwiXG5cblxuICAgICgqIENyZWF0aW9uICopXG5cbiAgICBleHRlcm5hbCBjcmVhdGVPbnNjcmVlbiA6XG4gICAgICA/YXV0b2NvbW1pdDpib29sIC0+ID9kZWNvcmF0ZWQ6Ym9vbCAtPiA/cmVzaXplYWJsZTpib29sIC0+XG4gICAgICA/bWluaW1pemU6Ym9vbCAtPiA/bWF4aW1pemU6Ym9vbCAtPiA/Y2xvc2U6Ym9vbCAtPiA/dGl0bGU6c3RyaW5nIC0+XG4gICAgICA/dGFyZ2V0OnN0cmluZyAtPiA/cG9zOihpbnQgKiBpbnQpIC0+IHNpemU6KGludCAqIGludCkgLT4gdW5pdCAtPiB0XG4gICAgICA9IFwibWxfY2FudmFzX2NyZWF0ZV9vbnNjcmVlblwiIFwibWxfY2FudmFzX2NyZWF0ZV9vbnNjcmVlbl9uXCJcblxuICAgIGV4dGVybmFsIGNyZWF0ZU9mZnNjcmVlbiA6IHNpemU6KGludCAqIGludCkgLT4gdW5pdCAtPiB0XG4gICAgICA9IFwibWxfY2FudmFzX2NyZWF0ZV9vZmZzY3JlZW5cIlxuXG4gICAgZXh0ZXJuYWwgY3JlYXRlT2Zmc2NyZWVuRnJvbUltYWdlRGF0YSA6IEltYWdlRGF0YS50IC0+IHRcbiAgICAgID0gXCJtbF9jYW52YXNfY3JlYXRlX29mZnNjcmVlbl9mcm9tX2ltYWdlX2RhdGFcIlxuXG4gICAgZXh0ZXJuYWwgY3JlYXRlT2Zmc2NyZWVuRnJvbVBOR19pbnRlcm5hbCA6IHN0cmluZyAtPiAodCAtPiB1bml0KSAtPiB1bml0XG4gICAgICA9IFwibWxfY2FudmFzX2NyZWF0ZV9vZmZzY3JlZW5fZnJvbV9wbmdcIlxuXG4gICAgbGV0IGNyZWF0ZU9mZnNjcmVlbkZyb21QTkcgZmlsZW5hbWUgOiB0IFJlYWN0LmV2ZW50ID1cbiAgICAgIGxldCBldmVudCwgc2VuZF9ldmVudCA9IFJlYWN0LkUuY3JlYXRlICgpIGluXG4gICAgICBjcmVhdGVPZmZzY3JlZW5Gcm9tUE5HX2ludGVybmFsIGZpbGVuYW1lXG4gICAgICAgIChmdW4gYyAtPiBQZW5kaW5nLmFkZF9jYW52YXMgZXZlbnQgc2VuZF9ldmVudCBjKTtcbiAgICAgIGV2ZW50XG5cbiAgICAoKiBWaXNpYmlsaXR5ICopXG5cbiAgICBleHRlcm5hbCBzaG93IDogdCAtPiB1bml0XG4gICAgICA9IFwibWxfY2FudmFzX3Nob3dcIlxuXG4gICAgZXh0ZXJuYWwgaGlkZSA6IHQgLT4gdW5pdFxuICAgICAgPSBcIm1sX2NhbnZhc19oaWRlXCJcblxuICAgIGV4dGVybmFsIGNsb3NlIDogdCAtPiB1bml0XG4gICAgICA9IFwibWxfY2FudmFzX2Nsb3NlXCJcblxuICAgICgqIFJlbmRlcmluZyAqKVxuXG4gICAgZXh0ZXJuYWwgY29tbWl0IDogdCAtPiB1bml0XG4gICAgICA9IFwibWxfY2FudmFzX2NvbW1pdFwiXG5cbiAgICAoKiBDb25maWd1cmF0aW9uICopXG5cbiAgICBleHRlcm5hbCBnZXRJZCA6IHQgLT4gaW50XG4gICAgICA9IFwibWxfY2FudmFzX2dldF9pZFwiXG5cbiAgICBleHRlcm5hbCBnZXRTaXplIDogdCAtPiAoaW50ICogaW50KVxuICAgICAgPSBcIm1sX2NhbnZhc19nZXRfc2l6ZVwiXG5cbiAgICBleHRlcm5hbCBzZXRTaXplIDogdCAtPiAoaW50ICogaW50KSAtPiB1bml0XG4gICAgICA9IFwibWxfY2FudmFzX3NldF9zaXplXCJcblxuICAgIGV4dGVybmFsIGdldFBvc2l0aW9uIDogdCAtPiAoaW50ICogaW50KVxuICAgICAgPSBcIm1sX2NhbnZhc19nZXRfcG9zaXRpb25cIlxuXG4gICAgZXh0ZXJuYWwgc2V0UG9zaXRpb24gOiB0IC0+IChpbnQgKiBpbnQpIC0+IHVuaXRcbiAgICAgID0gXCJtbF9jYW52YXNfc2V0X3Bvc2l0aW9uXCJcblxuICAgICgqIFN0YXRlICopXG5cbiAgICBleHRlcm5hbCBzYXZlIDogdCAtPiB1bml0XG4gICAgICA9IFwibWxfY2FudmFzX3NhdmVcIlxuXG4gICAgZXh0ZXJuYWwgcmVzdG9yZSA6IHQgLT4gdW5pdFxuICAgICAgPSBcIm1sX2NhbnZhc19yZXN0b3JlXCJcblxuICAgICgqIFRyYW5zZm9ybWF0aW9ucyAqKVxuICAgIGV4dGVybmFsIHNldFRyYW5zZm9ybSA6IHQgLT4gVHJhbnNmb3JtLnQgLT4gdW5pdFxuICAgICAgPSBcIm1sX2NhbnZhc19zZXRfdHJhbnNmb3JtXCJcblxuICAgIGV4dGVybmFsIHRyYW5zZm9ybSA6IHQgLT4gVHJhbnNmb3JtLnQgLT4gdW5pdFxuICAgICAgPSBcIm1sX2NhbnZhc190cmFuc2Zvcm1cIlxuXG4gICAgZXh0ZXJuYWwgdHJhbnNsYXRlIDogdCAtPiBWZWN0b3IudCAtPiB1bml0XG4gICAgICA9IFwibWxfY2FudmFzX3RyYW5zbGF0ZVwiXG5cbiAgICBleHRlcm5hbCBzY2FsZSA6IHQgLT4gVmVjdG9yLnQgLT4gdW5pdFxuICAgICAgPSBcIm1sX2NhbnZhc19zY2FsZVwiXG5cbiAgICBleHRlcm5hbCBzaGVhciA6IHQgLT4gVmVjdG9yLnQgLT4gdW5pdFxuICAgICAgPSBcIm1sX2NhbnZhc19zaGVhclwiXG5cbiAgICBleHRlcm5hbCByb3RhdGUgOiB0IC0+IGZsb2F0IC0+IHVuaXRcbiAgICAgID0gXCJtbF9jYW52YXNfcm90YXRlXCJcblxuICAgICgqIFN0eWxlIC8gY29uZmlnICopXG5cbiAgICBleHRlcm5hbCBnZXRMaW5lV2lkdGggOiB0IC0+IGZsb2F0XG4gICAgICA9IFwibWxfY2FudmFzX2dldF9saW5lX3dpZHRoXCJcblxuICAgIGV4dGVybmFsIHNldExpbmVXaWR0aCA6IHQgLT4gZmxvYXQgLT4gdW5pdFxuICAgICAgPSBcIm1sX2NhbnZhc19zZXRfbGluZV93aWR0aFwiXG5cbiAgICBleHRlcm5hbCBnZXRMaW5lSm9pbiA6IHQgLT4gSm9pbi50XG4gICAgICA9IFwibWxfY2FudmFzX2dldF9saW5lX2pvaW5cIlxuXG4gICAgZXh0ZXJuYWwgc2V0TGluZUpvaW4gOiB0IC0+IEpvaW4udCAtPiB1bml0XG4gICAgICA9IFwibWxfY2FudmFzX3NldF9saW5lX2pvaW5cIlxuXG4gICAgZXh0ZXJuYWwgZ2V0TGluZUNhcCA6IHQgLT4gQ2FwLnRcbiAgICAgID0gXCJtbF9jYW52YXNfZ2V0X2xpbmVfY2FwXCJcblxuICAgIGV4dGVybmFsIHNldExpbmVDYXAgOiB0IC0+IENhcC50IC0+IHVuaXRcbiAgICAgID0gXCJtbF9jYW52YXNfc2V0X2xpbmVfY2FwXCJcblxuICAgIGV4dGVybmFsIGdldE1pdGVyTGltaXQgOiB0IC0+IGZsb2F0XG4gICAgICA9IFwibWxfY2FudmFzX2dldF9taXRlcl9saW1pdFwiXG5cbiAgICBleHRlcm5hbCBzZXRNaXRlckxpbWl0IDogdCAtPiBmbG9hdCAtPiB1bml0XG4gICAgICA9IFwibWxfY2FudmFzX3NldF9taXRlcl9saW1pdFwiXG5cbiAgICBleHRlcm5hbCBnZXRMaW5lRGFzaE9mZnNldCA6IHQgLT4gZmxvYXRcbiAgICAgID0gXCJtbF9jYW52YXNfZ2V0X2xpbmVfZGFzaF9vZmZzZXRcIlxuXG4gICAgZXh0ZXJuYWwgc2V0TGluZURhc2hPZmZzZXQgOiB0IC0+IGZsb2F0IC0+IHVuaXRcbiAgICAgID0gXCJtbF9jYW52YXNfc2V0X2xpbmVfZGFzaF9vZmZzZXRcIlxuXG4gICAgZXh0ZXJuYWwgZ2V0TGluZURhc2ggOiB0IC0+IGZsb2F0IGFycmF5XG4gICAgICA9IFwibWxfY2FudmFzX2dldF9saW5lX2Rhc2hcIlxuXG4gICAgZXh0ZXJuYWwgc2V0TGluZURhc2ggOiB0IC0+IGZsb2F0IGFycmF5IC0+IHVuaXRcbiAgICAgID0gXCJtbF9jYW52YXNfc2V0X2xpbmVfZGFzaFwiXG5cbiAgICBleHRlcm5hbCBnZXRTdHJva2VDb2xvciA6IHQgLT4gQ29sb3IudFxuICAgICAgPSBcIm1sX2NhbnZhc19nZXRfc3Ryb2tlX2NvbG9yXCJcblxuICAgIGV4dGVybmFsIHNldFN0cm9rZUNvbG9yIDogdCAtPiBDb2xvci50IC0+IHVuaXRcbiAgICAgID0gXCJtbF9jYW52YXNfc2V0X3N0cm9rZV9jb2xvclwiXG5cbiAgICBleHRlcm5hbCBzZXRTdHJva2VHcmFkaWVudCA6IHQgLT4gR3JhZGllbnQudCAtPiB1bml0XG4gICAgICA9IFwibWxfY2FudmFzX3NldF9zdHJva2VfZ3JhZGllbnRcIlxuXG4gICAgZXh0ZXJuYWwgc2V0U3Ryb2tlUGF0dGVybiA6IHQgLT4gUGF0dGVybi50IC0+IHVuaXRcbiAgICAgID0gXCJtbF9jYW52YXNfc2V0X3N0cm9rZV9wYXR0ZXJuXCJcblxuICAgIGV4dGVybmFsIGdldFN0cm9rZVN0eWxlIDogdCAtPiBTdHlsZS50XG4gICAgICA9IFwibWxfY2FudmFzX2dldF9zdHJva2Vfc3R5bGVcIlxuXG4gICAgZXh0ZXJuYWwgc2V0U3Ryb2tlU3R5bGUgOiB0IC0+IFN0eWxlLnQgLT4gdW5pdFxuICAgICAgPSBcIm1sX2NhbnZhc19zZXRfc3Ryb2tlX3N0eWxlXCJcblxuICAgIGV4dGVybmFsIGdldEZpbGxDb2xvciA6IHQgLT4gQ29sb3IudFxuICAgICAgPSBcIm1sX2NhbnZhc19nZXRfZmlsbF9jb2xvclwiXG5cbiAgICBleHRlcm5hbCBzZXRGaWxsQ29sb3IgOiB0IC0+IENvbG9yLnQgLT4gdW5pdFxuICAgICAgPSBcIm1sX2NhbnZhc19zZXRfZmlsbF9jb2xvclwiXG5cbiAgICBleHRlcm5hbCBzZXRGaWxsR3JhZGllbnQgOiB0IC0+IEdyYWRpZW50LnQgLT4gdW5pdFxuICAgICAgPSBcIm1sX2NhbnZhc19zZXRfZmlsbF9ncmFkaWVudFwiXG5cbiAgICBleHRlcm5hbCBzZXRGaWxsUGF0dGVybiA6IHQgLT4gUGF0dGVybi50IC0+IHVuaXRcbiAgICAgID0gXCJtbF9jYW52YXNfc2V0X2ZpbGxfcGF0dGVyblwiXG5cbiAgICBleHRlcm5hbCBnZXRGaWxsU3R5bGUgOiB0IC0+IFN0eWxlLnRcbiAgICAgID0gXCJtbF9jYW52YXNfZ2V0X2ZpbGxfc3R5bGVcIlxuXG4gICAgZXh0ZXJuYWwgc2V0RmlsbFN0eWxlIDogdCAtPiBTdHlsZS50IC0+IHVuaXRcbiAgICAgID0gXCJtbF9jYW52YXNfc2V0X2ZpbGxfc3R5bGVcIlxuXG4gICAgZXh0ZXJuYWwgZ2V0R2xvYmFsQWxwaGEgOiB0IC0+IGZsb2F0XG4gICAgICA9IFwibWxfY2FudmFzX2dldF9nbG9iYWxfYWxwaGFcIlxuXG4gICAgZXh0ZXJuYWwgc2V0R2xvYmFsQWxwaGEgOiB0IC0+IGZsb2F0IC0+IHVuaXRcbiAgICAgID0gXCJtbF9jYW52YXNfc2V0X2dsb2JhbF9hbHBoYVwiXG5cbiAgICBleHRlcm5hbCBnZXRHbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gOiB0IC0+IENvbXBvc2l0ZU9wLnRcbiAgICAgID0gXCJtbF9jYW52YXNfZ2V0X2dsb2JhbF9jb21wb3NpdGVfb3BlcmF0aW9uXCJcblxuICAgIGV4dGVybmFsIHNldEdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA6IHQgLT4gQ29tcG9zaXRlT3AudCAtPiB1bml0XG4gICAgICA9IFwibWxfY2FudmFzX3NldF9nbG9iYWxfY29tcG9zaXRlX29wZXJhdGlvblwiXG5cbiAgICBleHRlcm5hbCBnZXRTaGFkb3dDb2xvciA6IHQgLT4gQ29sb3IudFxuICAgICAgPSBcIm1sX2NhbnZhc19nZXRfc2hhZG93X2NvbG9yXCJcblxuICAgIGV4dGVybmFsIHNldFNoYWRvd0NvbG9yIDogdCAtPiBDb2xvci50IC0+IHVuaXRcbiAgICAgID0gXCJtbF9jYW52YXNfc2V0X3NoYWRvd19jb2xvclwiXG5cbiAgICBleHRlcm5hbCBnZXRTaGFkb3dCbHVyIDogdCAtPiBmbG9hdFxuICAgICAgPSBcIm1sX2NhbnZhc19nZXRfc2hhZG93X2JsdXJcIlxuXG4gICAgZXh0ZXJuYWwgc2V0U2hhZG93Qmx1ciA6IHQgLT4gZmxvYXQgLT4gdW5pdFxuICAgICAgPSBcIm1sX2NhbnZhc19zZXRfc2hhZG93X2JsdXJcIlxuXG4gICAgZXh0ZXJuYWwgZ2V0U2hhZG93T2Zmc2V0IDogdCAtPiBWZWN0b3IudFxuICAgICAgPSBcIm1sX2NhbnZhc19nZXRfc2hhZG93X29mZnNldFwiXG5cbiAgICBleHRlcm5hbCBzZXRTaGFkb3dPZmZzZXQgOiB0IC0+IFZlY3Rvci50IC0+IHVuaXRcbiAgICAgID0gXCJtbF9jYW52YXNfc2V0X3NoYWRvd19vZmZzZXRcIlxuXG4gICAgZXh0ZXJuYWwgc2V0Rm9udCA6XG4gICAgICB0IC0+IHN0cmluZyAtPiBzaXplOkZvbnQuc2l6ZSAtPiBzbGFudDpGb250LnNsYW50IC0+XG4gICAgICB3ZWlnaHQ6Rm9udC53ZWlnaHQgLT4gdW5pdFxuICAgICAgPSBcIm1sX2NhbnZhc19zZXRfZm9udFwiXG5cbiAgICAoKiBQYXRocyAqKVxuXG4gICAgZXh0ZXJuYWwgY2xlYXJQYXRoIDogdCAtPiB1bml0XG4gICAgICA9IFwibWxfY2FudmFzX2NsZWFyX3BhdGhcIlxuXG4gICAgZXh0ZXJuYWwgY2xvc2VQYXRoIDogdCAtPiB1bml0XG4gICAgICA9IFwibWxfY2FudmFzX2Nsb3NlX3BhdGhcIlxuXG4gICAgZXh0ZXJuYWwgbW92ZVRvIDogdCAtPiBQb2ludC50IC0+IHVuaXRcbiAgICAgID0gXCJtbF9jYW52YXNfbW92ZV90b1wiXG5cbiAgICBleHRlcm5hbCBsaW5lVG8gOiB0IC0+IFBvaW50LnQgLT4gdW5pdFxuICAgICAgPSBcIm1sX2NhbnZhc19saW5lX3RvXCJcblxuICAgIGV4dGVybmFsIGFyYyA6XG4gICAgICB0IC0+IGNlbnRlcjpQb2ludC50IC0+IHJhZGl1czpmbG9hdCAtPlxuICAgICAgdGhldGExOmZsb2F0IC0+IHRoZXRhMjpmbG9hdCAtPiBjY3c6Ym9vbCAtPiB1bml0XG4gICAgICA9IFwibWxfY2FudmFzX2FyY1wiIFwibWxfY2FudmFzX2FyY19uXCJcblxuICAgIGV4dGVybmFsIGFyY1RvIDogdCAtPiBwMTpQb2ludC50IC0+IHAyOlBvaW50LnQgLT4gcmFkaXVzOmZsb2F0IC0+IHVuaXRcbiAgICAgID0gXCJtbF9jYW52YXNfYXJjX3RvXCJcblxuICAgIGV4dGVybmFsIHF1YWRyYXRpY0N1cnZlVG8gOiB0IC0+IGNwOlBvaW50LnQgLT4gcDpQb2ludC50IC0+IHVuaXRcbiAgICAgID0gXCJtbF9jYW52YXNfcXVhZHJhdGljX2N1cnZlX3RvXCJcblxuICAgIGV4dGVybmFsIGJlemllckN1cnZlVG8gOlxuICAgICAgdCAtPiBjcDE6UG9pbnQudCAtPiBjcDI6UG9pbnQudCAtPiBwOlBvaW50LnQgLT4gdW5pdFxuICAgICAgPSBcIm1sX2NhbnZhc19iZXppZXJfY3VydmVfdG9cIlxuXG4gICAgZXh0ZXJuYWwgcmVjdCA6IHQgLT4gcG9zOlBvaW50LnQgLT4gc2l6ZTpWZWN0b3IudCAtPiB1bml0XG4gICAgICA9IFwibWxfY2FudmFzX3JlY3RcIlxuXG4gICAgZXh0ZXJuYWwgZWxsaXBzZSA6XG4gICAgICB0IC0+IGNlbnRlcjpQb2ludC50IC0+IHJhZGl1czpWZWN0b3IudCAtPlxuICAgICAgcm90YXRpb246ZmxvYXQgLT4gdGhldGExOmZsb2F0IC0+IHRoZXRhMjpmbG9hdCAtPiBjY3c6Ym9vbCAtPiB1bml0XG4gICAgICA9IFwibWxfY2FudmFzX2VsbGlwc2VcIiBcIm1sX2NhbnZhc19lbGxpcHNlX25cIlxuXG4gICAgZXh0ZXJuYWwgZmlsbCA6IHQgLT4gbm9uemVybzpib29sIC0+IHVuaXRcbiAgICAgID0gXCJtbF9jYW52YXNfZmlsbFwiXG5cbiAgICBleHRlcm5hbCBmaWxsUGF0aCA6IHQgLT4gUGF0aC50IC0+IG5vbnplcm86Ym9vbCAtPiB1bml0XG4gICAgICA9IFwibWxfY2FudmFzX2ZpbGxfcGF0aFwiXG5cbiAgICBleHRlcm5hbCBzdHJva2UgOiB0IC0+IHVuaXRcbiAgICAgID0gXCJtbF9jYW52YXNfc3Ryb2tlXCJcblxuICAgIGV4dGVybmFsIHN0cm9rZVBhdGggOiB0IC0+IFBhdGgudCAtPiB1bml0XG4gICAgICA9IFwibWxfY2FudmFzX3N0cm9rZV9wYXRoXCJcblxuICAgIGV4dGVybmFsIGNsaXAgOiB0IC0+IG5vbnplcm86Ym9vbCAtPiB1bml0XG4gICAgICA9IFwibWxfY2FudmFzX2NsaXBcIlxuXG4gICAgZXh0ZXJuYWwgY2xpcFBhdGggOiB0IC0+IFBhdGgudCAtPiBub256ZXJvOmJvb2wgLT4gdW5pdFxuICAgICAgPSBcIm1sX2NhbnZhc19jbGlwX3BhdGhcIlxuXG4gICAgKCogSW1tZWRpYXRlIGRyYXdpbmcgKilcblxuICAgIGV4dGVybmFsIGZpbGxSZWN0IDogdCAtPiBwb3M6UG9pbnQudCAtPiBzaXplOlZlY3Rvci50IC0+IHVuaXRcbiAgICAgID0gXCJtbF9jYW52YXNfZmlsbF9yZWN0XCJcblxuICAgIGV4dGVybmFsIHN0cm9rZVJlY3QgOiB0IC0+IHBvczpQb2ludC50IC0+IHNpemU6VmVjdG9yLnQgLT4gdW5pdFxuICAgICAgPSBcIm1sX2NhbnZhc19zdHJva2VfcmVjdFwiXG5cbiAgICBleHRlcm5hbCBmaWxsVGV4dCA6IHQgLT4gc3RyaW5nIC0+IFBvaW50LnQgLT4gdW5pdFxuICAgICAgPSBcIm1sX2NhbnZhc19maWxsX3RleHRcIlxuXG4gICAgZXh0ZXJuYWwgc3Ryb2tlVGV4dCA6IHQgLT4gc3RyaW5nIC0+IFBvaW50LnQgLT4gdW5pdFxuICAgICAgPSBcIm1sX2NhbnZhc19zdHJva2VfdGV4dFwiXG5cbiAgICBleHRlcm5hbCBibGl0IDpcbiAgICAgIGRzdDp0IC0+IGRwb3M6KGludCAqIGludCkgLT5cbiAgICAgIHNyYzp0IC0+IHNwb3M6KGludCAqIGludCkgLT4gc2l6ZTooaW50ICogaW50KSAtPiB1bml0XG4gICAgICA9IFwibWxfY2FudmFzX2JsaXRcIlxuXG4gICAgKCogRGlyZWN0IHBpeGVsIGFjY2VzcyAqKVxuXG4gICAgZXh0ZXJuYWwgZ2V0UGl4ZWwgOiB0IC0+IChpbnQgKiBpbnQpIC0+IENvbG9yLnRcbiAgICAgID0gXCJtbF9jYW52YXNfZ2V0X3BpeGVsXCJcblxuICAgIGV4dGVybmFsIHB1dFBpeGVsIDogdCAtPiAoaW50ICogaW50KSAtPiBDb2xvci50IC0+IHVuaXRcbiAgICAgID0gXCJtbF9jYW52YXNfcHV0X3BpeGVsXCJcblxuICAgIGV4dGVybmFsIGdldEltYWdlRGF0YSA6XG4gICAgICB0IC0+IHBvczooaW50ICogaW50KSAtPiBzaXplOihpbnQgKiBpbnQpIC0+IEltYWdlRGF0YS50XG4gICAgICA9IFwibWxfY2FudmFzX2dldF9pbWFnZV9kYXRhXCJcblxuICAgIGV4dGVybmFsIHB1dEltYWdlRGF0YSA6XG4gICAgICB0IC0+IGRwb3M6KGludCAqIGludCkgLT4gSW1hZ2VEYXRhLnQgLT5cbiAgICAgIHNwb3M6KGludCAqIGludCkgLT4gc2l6ZTooaW50ICogaW50KSAtPiB1bml0XG4gICAgICA9IFwibWxfY2FudmFzX3B1dF9pbWFnZV9kYXRhXCJcblxuICAgIGV4dGVybmFsIGltcG9ydFBOR19pbnRlcm5hbCA6XG4gICAgICB0IC0+IHBvczooaW50ICogaW50KSAtPiBzdHJpbmcgLT4gKHQgLT4gdW5pdCkgLT4gdW5pdFxuICAgICAgPSBcIm1sX2NhbnZhc19pbXBvcnRfcG5nXCJcblxuICAgIGxldCBpbXBvcnRQTkcgKGMgOiB0KSB+cG9zIGZpbGVuYW1lIDogdCBSZWFjdC5ldmVudCA9XG4gICAgICBsZXQgZXZlbnQsIHNlbmRfZXZlbnQgPSBSZWFjdC5FLmNyZWF0ZSAoKSBpblxuICAgICAgaW1wb3J0UE5HX2ludGVybmFsIGMgfnBvcyBmaWxlbmFtZVxuICAgICAgICAoZnVuIGMgLT4gUGVuZGluZy5hZGRfY2FudmFzIGV2ZW50IHNlbmRfZXZlbnQgYyk7XG4gICAgICBldmVudFxuXG4gICAgZXh0ZXJuYWwgZXhwb3J0UE5HIDogdCAtPiBzdHJpbmcgLT4gdW5pdFxuICAgICAgPSBcIm1sX2NhbnZhc19leHBvcnRfcG5nXCJcblxuICBlbmRcblxuICBtb2R1bGUgRXZlbnQgPSBzdHJ1Y3RcblxuICAgIHR5cGUgdGltZXN0YW1wID0gSW50NjQudFxuXG4gICAgdHlwZSAnYSBjYW52YXNfZXZlbnQgPSB7XG4gICAgICBjYW52YXM6IENhbnZhcy50O1xuICAgICAgdGltZXN0YW1wOiB0aW1lc3RhbXA7XG4gICAgICBkYXRhOiAnYTtcbiAgICB9XG5cbiAgICB0eXBlIHBvc2l0aW9uID0gaW50ICogaW50XG5cbiAgICB0eXBlIHNpemUgPSBpbnQgKiBpbnRcblxuICAgIHR5cGUga2V5ID1cbiAgICAgICgqIEZ1bmN0aW9uICopXG4gICAgICB8IEtleUVzY2FwZVxuICAgICAgfCBLZXlGMVxuICAgICAgfCBLZXlGMlxuICAgICAgfCBLZXlGM1xuICAgICAgfCBLZXlGNFxuICAgICAgfCBLZXlGNVxuICAgICAgfCBLZXlGNlxuICAgICAgfCBLZXlGN1xuICAgICAgfCBLZXlGOFxuICAgICAgfCBLZXlGOVxuICAgICAgfCBLZXlGMTBcbiAgICAgIHwgS2V5RjExXG4gICAgICB8IEtleUYxMlxuICAgICAgfCBLZXlQcmludFNjcmVlbiAoKiBhYnNlbnQgZnJvbSBNYWMgS2V5Ym9hcmRzICopXG4gICAgICB8IEtleVNjcm9sbExvY2sgKCogYWJzZW50IGZyb20gTWFjIEtleWJvYXJkcyAqKVxuICAgICAgfCBLZXlQYXVzZSAoKiBhYnNlbnQgZnJvbSBNYWMgS2V5Ym9hcmRzICopXG5cbiAgICAgICgqIEFscGhhbnVtZXJpYywgZmlyc3Qgcm93ICopXG4gICAgICB8IEtleUdyYXZlVGlsZGVcbiAgICAgIHwgS2V5MUV4Y2xhbWF0aW9uXG4gICAgICB8IEtleTJBdFxuICAgICAgfCBLZXkzTnVtYmVyXG4gICAgICB8IEtleTREb2xsYXJcbiAgICAgIHwgS2V5NVBlcmNlbnRcbiAgICAgIHwgS2V5NkNhcmV0XG4gICAgICB8IEtleTdBbXBlcnNhbmRcbiAgICAgIHwgS2V5OEFzdGVyaXNrXG4gICAgICB8IEtleTlMUGFyZW50aGVzaXNcbiAgICAgIHwgS2V5MFJQYXJlbnRoZXNpc1xuICAgICAgfCBLZXlNaW51c1VuZGVyc2NscmVcbiAgICAgIHwgS2V5RXF1YWxQbHVzXG4gICAgICB8IEtleUJhY2tzcGFjZVxuXG4gICAgICAoKiBBbHBoYW51bWVyaWMsIHNlY29uZCByb3cgKilcbiAgICAgIHwgS2V5VGFiXG4gICAgICB8IEtleVFcbiAgICAgIHwgS2V5V1xuICAgICAgfCBLZXlFXG4gICAgICB8IEtleVJcbiAgICAgIHwgS2V5VFxuICAgICAgfCBLZXlZXG4gICAgICB8IEtleVVcbiAgICAgIHwgS2V5SVxuICAgICAgfCBLZXlPXG4gICAgICB8IEtleVBcbiAgICAgIHwgS2V5TEJyYWNrZXRDdXJseVxuICAgICAgfCBLZXlSQnJhY2tldEN1cmx5XG4gICAgICB8IEtleUJhY2tzbGFzaFBpcGUgKCogcmVwbGFjZWQgYnkgS2V5Tm9uVVNOdW1iZXJUaWxkZSBvbiBJU08gS0IgKilcblxuICAgICAgKCogQWxwaGFudW1lcmljLCB0aGlyZCByb3cgKilcbiAgICAgIHwgS2V5Q2Fwc0xvY2tcbiAgICAgIHwgS2V5QVxuICAgICAgfCBLZXlTXG4gICAgICB8IEtleURcbiAgICAgIHwgS2V5RlxuICAgICAgfCBLZXlHXG4gICAgICB8IEtleUhcbiAgICAgIHwgS2V5SlxuICAgICAgfCBLZXlLXG4gICAgICB8IEtleUxcbiAgICAgIHwgS2V5U2VtaWNvbG9uQ29sb25cbiAgICAgIHwgS2V5UXVvdGVEb3VibGVxdW90ZVxuICAgICAgfCBLZXlOb25VU051bWJlclRpbGRlICgqIGV4dHJhIGtleSBsZWZ0IG9mIFJldHVybiBvbiBJU08gS0IgKilcbiAgICAgICgqIGFsdGhvdWdoIGdlbmVyYWxseSBtYXBwZWQgdG8gS2V5QmFja3NsYXNoUGlwZSAqKVxuICAgICAgfCBLZXlSZXR1cm5cblxuICAgICAgKCogQWxwaGFudW1lcmljLCBmb3VydGggcm93ICopXG4gICAgICB8IEtleUxTaGlmdFxuICAgICAgfCBLZXlOb25VU0JhY2tzbGFzaFBpcGUgKCogZXh0cmEga2V5IHJpZ2h0IG9mIExTaGlmdCBvbiBJU08gS0IgKilcbiAgICAgIHwgS2V5WlxuICAgICAgfCBLZXlYXG4gICAgICB8IEtleUNcbiAgICAgIHwgS2V5VlxuICAgICAgfCBLZXlCXG4gICAgICB8IEtleU5cbiAgICAgIHwgS2V5TVxuICAgICAgfCBLZXlDb21tYUxlc3NcbiAgICAgIHwgS2V5UGVyaW9kR3JlYXRlclxuICAgICAgfCBLZXlTbGFzaFF1ZXN0aW9uXG4gICAgICB8IEtleVJTaGlmdFxuXG4gICAgICAoKiBBbHBoYW51bWVyaWMsIGZpZnRoIHJvdyAqKVxuICAgICAgfCBLZXlMQ29udHJvbFxuICAgICAgfCBLZXlMTWV0YSAoKiBsZWZ0IFdpbmRvd3MgLyBDb21tYW5kIGtleSAqKVxuICAgICAgfCBLZXlMQWx0XG4gICAgICB8IEtleVNwYWNlYmFyXG4gICAgICB8IEtleVJBbHRcbiAgICAgIHwgS2V5Uk1ldGEgKCogcmlnaHQgV2luZG93cyAvIENvbW1hbmQga2V5ICopXG4gICAgICB8IEtleU1lbnVcbiAgICAgIHwgS2V5UkNvbnRyb2xcblxuICAgICAgKCogQ29udHJvbCBwYWQgKilcbiAgICAgIHwgS2V5SW5zZXJ0ICgqIHJlcGxhY2VkIGJ5IGEgRm4ga2V5IG9uIE1hYyAod2l0aCBhIGRpZmZlcmVudCBjb2RlKSAqKVxuICAgICAgfCBLZXlIb21lXG4gICAgICB8IEtleVBhZ2VVcFxuICAgICAgfCBLZXlEZWxldGVGb3J3YXJkXG4gICAgICB8IEtleUVlbmRcbiAgICAgIHwgS2V5UGFnZURvd25cblxuICAgICAgKCogQXJyb3cgcGFkICopXG4gICAgICB8IEtleVVwQXJyb3dcbiAgICAgIHwgS2V5TGVmdEFycm93XG4gICAgICB8IEtleURvd25BcnJvd1xuICAgICAgfCBLZXlSaWdodEFycm93XG5cbiAgICAgICgqIE51bWVyaWMgcGFkICopXG4gICAgICB8IEtleVBhZE51bWxvY2tDbGVhciAoKiBvbiBNYWMsIENsZWFyIHJlcGxhY2VzIE51bUxvY2sgKilcbiAgICAgIHwgS2V5UGFkRXF1YWxzICgqIG9uIE1hYyBrZXlib2FyZHMgb25seSAqKVxuICAgICAgfCBLZXlQYWREaXZpZGVcbiAgICAgIHwgS2V5UGFkTXVsdGlwbHlcbiAgICAgIHwgS2V5UGFkTWludXNcbiAgICAgIHwgS2V5UGFkN0hvbWVcbiAgICAgIHwgS2V5UGFkOFVwQXJyb3dcbiAgICAgIHwgS2V5UGFkOVBhZ2VVcFxuICAgICAgfCBLZXlQYWRQbHVzXG4gICAgICB8IEtleVBhZDRMZWZ0QXJyb3dcbiAgICAgIHwgS2V5UGFkNVxuICAgICAgfCBLZXlQYWQ2UmlnaHRBcnJvd1xuICAgICAgfCBLZXlQYWRDb21tYSAoKiBzcGVjaWZpYyB0byBCcmF6aWxpYW4ga2V5Ym9hcmRzICopXG4gICAgICB8IEtleVBhZDFFbmRcbiAgICAgIHwgS2V5UGFkMkRvd25BcnJvd1xuICAgICAgfCBLZXlQYWQzUGFnZURvd25cbiAgICAgIHwgS2V5UGFkMEluc2VydFxuICAgICAgfCBLZXlQYWREZWNpbWFsRGVsZXRlXG4gICAgICB8IEtleVBhZEVudGVyXG5cbiAgICAgICgqIEV4dHJhIGZ1bmN0aW9uIGtleXMgKilcbiAgICAgIHwgS2V5RjEzXG4gICAgICB8IEtleUYxNFxuICAgICAgfCBLZXlGMTVcbiAgICAgIHwgS2V5RjE2XG4gICAgICB8IEtleUYxN1xuICAgICAgfCBLZXlGMThcbiAgICAgIHwgS2V5RjE5XG4gICAgICB8IEtleUYyMFxuICAgICAgfCBLZXlGMjFcbiAgICAgIHwgS2V5RjIyXG4gICAgICB8IEtleUYyM1xuICAgICAgfCBLZXlGMjRcblxuICAgICAgKCogSW50ZXJuYXRpb25hbCAmIExBTkcga2V5cyAqKVxuICAgICAgfCBLZXlJbnRlcm5hdGlvbmFsMSAoKiBleHRyYSBrZXkgbGVmdCBvZiBSU2hpZnQgb24gSklTIGFuZCBCcmF6aWxpYW4gS0IgKilcbiAgICAgIHwgS2V5SW50ZXJuYXRpb25hbDIgKCogS2F0YWthbmEvSGlyYWdhbmEga2V5IHJpZ2h0IG9mIFNwYWNlIG9uIEpJUyBLQiAqKVxuICAgICAgfCBLZXlJbnRlcm5hdGlvbmFsMyAoKiBleHRyYSBrZXkgbGVmdCBvZiBCYWNrc3BhY2Ugb24gSklTIEtCICopXG4gICAgICB8IEtleUludGVybmF0aW9uYWw0ICgqIEhlbmthbiBrZXkgcmlnaHQgb2YgU3BhY2Ugb24gSklTIEtCICopXG4gICAgICB8IEtleUludGVybmF0aW9uYWw1ICgqIE11aGVua2FuIGtleSBsZWZ0IG9mIFNwYWNlIG9uIEpJUyBLQiAqKVxuICAgICAgfCBLZXlJbnRlcm5hdGlvbmFsNiAoKiBLYW5tYSAoY29tbWEpIGtleSByaWdodCBvZiBLUDAgb24gSklTIEtCICopXG4gICAgICB8IEtleUludGVybmF0aW9uYWw3ICgqIERvdWJsZS1CeXRlL1NpbmdsZS1CeXRlIHRvZ2dsZSBrZXkgKilcbiAgICAgIHwgS2V5SW50ZXJuYXRpb25hbDggKCogVW5kZWZpbmVkICopXG4gICAgICB8IEtleUludGVybmF0aW9uYWw5ICgqIFVuZGVmaW5lZCAqKVxuICAgICAgfCBLZXlMYW5nMSAoKiBIYW5ndWwvRW5nbGlzaCB0b2dnbGUga2V5IChLb3JlYW4pICopXG4gICAgICB8IEtleUxhbmcyICgqIEhhbmphIGNvbnZlcnNpb24ga2V5IChLb3JlYW4pICopXG4gICAgICB8IEtleUxhbmczICgqIEthdGFrYW5hIGtleSAoSmFwYW5lc2UpICopXG4gICAgICB8IEtleUxhbmc0ICgqIEhpcmFnYW5hIGtleSAoSmFwYW5lc2UpICopXG4gICAgICB8IEtleUxhbmQ1ICgqIFplbmtha3UvSGFua2FrdSBrZXkgKEphcGFuZXNlKSAqKVxuXG4gICAgICAoKiBFeHRlbnNpb25zICopXG4gICAgICB8IEtleUhlbHBcbiAgICAgIHwgS2V5TXV0ZVxuICAgICAgfCBLZXlWb2x1bWVVcFxuICAgICAgfCBLZXlWb2x1bWVEb3duXG5cbiAgICB0eXBlIGZsYWdzID0ge1xuICAgICAgZmxhZ19zaGlmdCA6IGJvb2w7XG4gICAgICBmbGFnX2FsdCA6IGJvb2w7XG4gICAgICBmbGFnX2NvbnRyb2wgOiBib29sO1xuICAgICAgZmxhZ19tZXRhIDogYm9vbDtcbiAgICAgIGZsYWdfY2Fwc2xvY2sgOiBib29sO1xuICAgICAgZmxhZ19udW1sb2NrIDogYm9vbDtcbiAgICAgIGZsYWdfZGVhZCA6IGJvb2w7XG4gICAgfVxuXG4gICAgdHlwZSBrZXlfZGF0YSA9IHtcbiAgICAgIGtleToga2V5O1xuICAgICAgY2hhcjogVWNoYXIudDtcbiAgICAgIGZsYWdzOiBmbGFncztcbiAgICB9XG5cbiAgICB0eXBlIGJ1dHRvbiA9XG4gICAgICB8IEJ1dHRvbk5vbmVcbiAgICAgIHwgQnV0dG9uTGVmdFxuICAgICAgfCBCdXR0b25NaWRkbGVcbiAgICAgIHwgQnV0dG9uUmlnaHRcbiAgICAgIHwgQnV0dG9uV2hlZWxVcFxuICAgICAgfCBCdXR0b25XaGVlbERvd25cblxuICAgIHR5cGUgYnV0dG9uX2RhdGEgPSB7XG4gICAgICBwb3NpdGlvbjogcG9zaXRpb247XG4gICAgICBidXR0b246IGJ1dHRvbjtcbiAgICB9XG5cbiAgICB0eXBlICdhIGV2ID0gJ2EgUmVhY3QuZXZlbnQgKiAoP3N0ZXA6UmVhY3Quc3RlcCAtPiAnYSAtPiB1bml0KVxuXG4gICAgbGV0IGZyYW1lLCBzZW5kX2ZyYW1lID1cbiAgICAgIChSZWFjdC5FLmNyZWF0ZSAoKSA6IHVuaXQgY2FudmFzX2V2ZW50IGV2KVxuICAgIGxldCBmb2N1c19pbiwgc2VuZF9mb2N1c19pbiA9XG4gICAgICAoUmVhY3QuRS5jcmVhdGUgKCkgOiB1bml0IGNhbnZhc19ldmVudCBldilcbiAgICBsZXQgZm9jdXNfb3V0LCBzZW5kX2ZvY3VzX291dCA9XG4gICAgICAoUmVhY3QuRS5jcmVhdGUgKCkgOiB1bml0IGNhbnZhc19ldmVudCBldilcbiAgICBsZXQgcmVzaXplLCBzZW5kX3Jlc2l6ZSA9XG4gICAgICAoUmVhY3QuRS5jcmVhdGUgKCkgOiBzaXplIGNhbnZhc19ldmVudCBldilcbiAgICBsZXQgbW92ZSwgc2VuZF9tb3ZlID1cbiAgICAgIChSZWFjdC5FLmNyZWF0ZSAoKSA6IHBvc2l0aW9uIGNhbnZhc19ldmVudCBldilcbiAgICBsZXQgY2xvc2UsIHNlbmRfY2xvc2UgPVxuICAgICAgKFJlYWN0LkUuY3JlYXRlICgpIDogdW5pdCBjYW52YXNfZXZlbnQgZXYpXG4gICAgbGV0IGtleV9kb3duLCBzZW5kX2tleV9kb3duID1cbiAgICAgIChSZWFjdC5FLmNyZWF0ZSAoKSA6IGtleV9kYXRhIGNhbnZhc19ldmVudCBldilcbiAgICBsZXQga2V5X3VwLCBzZW5kX2tleV91cCA9XG4gICAgICAoUmVhY3QuRS5jcmVhdGUgKCkgOiBrZXlfZGF0YSBjYW52YXNfZXZlbnQgZXYpXG4gICAgbGV0IGJ1dHRvbl9kb3duLCBzZW5kX2J1dHRvbl9kb3duID1cbiAgICAgIChSZWFjdC5FLmNyZWF0ZSAoKSA6IGJ1dHRvbl9kYXRhIGNhbnZhc19ldmVudCBldilcbiAgICBsZXQgYnV0dG9uX3VwLCBzZW5kX2J1dHRvbl91cCA9XG4gICAgICAoUmVhY3QuRS5jcmVhdGUgKCkgOiBidXR0b25fZGF0YSBjYW52YXNfZXZlbnQgZXYpXG4gICAgbGV0IG1vdXNlX21vdmUsIHNlbmRfbW91c2VfbW92ZSA9XG4gICAgICAoUmVhY3QuRS5jcmVhdGUgKCkgOiBwb3NpdGlvbiBjYW52YXNfZXZlbnQgZXYpXG4gICAgKCogbGV0IGJhY2tlbmRfc3RvcCwgc2VuZF9iYWNrZW5kX3N0b3AgPVxuICAgICAgIChSZWFjdC5FLmNyZWF0ZSAoKSA6IGJhY2tlbmRfc3RvcF9ldmVudCBldikgKilcblxuICAgIGxldCBldmVudF90aW1lc3RhbXAsIHNldF9ldmVudF90aW1lc3RhbXAgPVxuICAgICAgUmVhY3QuUy5jcmVhdGUgMExcblxuICAgIGV4dGVybmFsIGludF9vZl9rZXkgOiBrZXkgLT4gaW50XG4gICAgICA9IFwibWxfY2FudmFzX2ludF9vZl9rZXlcIlxuXG4gICAgZXh0ZXJuYWwga2V5X29mX2ludCA6IGludCAtPiBrZXlcbiAgICAgID0gXCJtbF9jYW52YXNfa2V5X29mX2ludFwiXG5cbiAgZW5kXG5cbiAgbW9kdWxlIEludGVybmFsRXZlbnQgPSBzdHJ1Y3RcblxuICAgICgqIFdlIGRlY2xhcmUgY29uc3RydWN0b3JzIHRoYXQgYXJlIG9ubHkgdXNlZCBmcm9tIHRoZSBDIGNvZGUgKilcbiAgICBbQEBAd2FybmluZyBcIi0zN1wiXVxuXG4gICAgb3BlbiBFdmVudFxuXG4gICAgdHlwZSBmcmFtZV9jeWNsZV9ldmVudCA9IHtcbiAgICAgIHRpbWVzdGFtcDogdGltZXN0YW1wO1xuICAgIH1cblxuICAgIHR5cGUgZnJhbWVfZXZlbnQgPSB7XG4gICAgICBjYW52YXM6IENhbnZhcy50O1xuICAgICAgdGltZXN0YW1wOiB0aW1lc3RhbXA7XG4gICAgfVxuXG4gICAgdHlwZSBmb2N1c19kaXJlY3Rpb24gPVxuICAgICAgfCBPdXRcbiAgICAgIHwgSW5cblxuICAgIHR5cGUgY2FudmFzX2ZvY3VzZWRfZXZlbnQgPSB7XG4gICAgICBjYW52YXM6IENhbnZhcy50O1xuICAgICAgdGltZXN0YW1wOiB0aW1lc3RhbXA7XG4gICAgICBmb2N1czogZm9jdXNfZGlyZWN0aW9uO1xuICAgIH1cblxuICAgIHR5cGUgY2FudmFzX3Jlc2l6ZWRfZXZlbnQgPSB7XG4gICAgICBjYW52YXM6IENhbnZhcy50O1xuICAgICAgdGltZXN0YW1wOiB0aW1lc3RhbXA7XG4gICAgICBzaXplOiBpbnQgKiBpbnQ7XG4gICAgfVxuXG4gICAgdHlwZSBjYW52YXNfbW92ZWRfZXZlbnQgPSB7XG4gICAgICBjYW52YXM6IENhbnZhcy50O1xuICAgICAgdGltZXN0YW1wOiB0aW1lc3RhbXA7XG4gICAgICBwb3NpdGlvbjogaW50ICogaW50O1xuICAgIH1cblxuICAgIHR5cGUgY2FudmFzX2Nsb3NlZF9ldmVudCA9IHtcbiAgICAgIGNhbnZhczogQ2FudmFzLnQ7XG4gICAgICB0aW1lc3RhbXA6IHRpbWVzdGFtcDtcbiAgICB9XG5cbiAgICB0eXBlIHN0YXRlID1cbiAgICAgIHwgVXBcbiAgICAgIHwgRG93blxuXG4gICAgdHlwZSBrZXlfYWN0aW9uX2V2ZW50ID0ge1xuICAgICAgY2FudmFzOiBDYW52YXMudDtcbiAgICAgIHRpbWVzdGFtcDogdGltZXN0YW1wO1xuICAgICAga2V5OiBrZXk7XG4gICAgICBjaGFyOiBVY2hhci50O1xuICAgICAgZmxhZ3M6IGZsYWdzO1xuICAgICAgc3RhdGU6IHN0YXRlO1xuICAgIH1cblxuICAgIHR5cGUgYnV0dG9uX2FjdGlvbl9ldmVudCA9IHtcbiAgICAgIGNhbnZhczogQ2FudmFzLnQ7XG4gICAgICB0aW1lc3RhbXA6IHRpbWVzdGFtcDtcbiAgICAgIHBvc2l0aW9uOiBpbnQgKiBpbnQ7XG4gICAgICBidXR0b246IGJ1dHRvbjtcbiAgICAgIHN0YXRlOiBzdGF0ZTtcbiAgICB9XG5cbiAgICB0eXBlIG1vdXNlX21vdmVfZXZlbnQgPSB7XG4gICAgICBjYW52YXM6IENhbnZhcy50O1xuICAgICAgdGltZXN0YW1wOiB0aW1lc3RhbXA7XG4gICAgICBwb3NpdGlvbjogaW50ICogaW50O1xuICAgIH1cblxuICAgIHR5cGUgdCA9XG4gICAgICB8IEZyYW1lQ3ljbGUgb2YgZnJhbWVfY3ljbGVfZXZlbnRcbiAgICAgIHwgRnJhbWUgb2YgZnJhbWVfZXZlbnRcbiAgICAgIHwgQ2FudmFzRm9jdXNlZCBvZiBjYW52YXNfZm9jdXNlZF9ldmVudFxuICAgICAgfCBDYW52YXNSZXNpemVkIG9mIGNhbnZhc19yZXNpemVkX2V2ZW50XG4gICAgICB8IENhbnZhc01vdmVkIG9mIGNhbnZhc19tb3ZlZF9ldmVudFxuICAgICAgfCBDYW52YXNDbG9zZWQgb2YgY2FudmFzX2Nsb3NlZF9ldmVudFxuICAgICAgfCBLZXlBY3Rpb24gb2Yga2V5X2FjdGlvbl9ldmVudFxuICAgICAgfCBCdXR0b25BY3Rpb24gb2YgYnV0dG9uX2FjdGlvbl9ldmVudFxuICAgICAgfCBNb3VzZU1vdmUgb2YgbW91c2VfbW92ZV9ldmVudFxuXG4gIGVuZFxuXG4gIG1vZHVsZSBCYWNrZW5kID0gc3RydWN0XG5cbiAgICBleHRlcm5hbCBpbml0IDogdW5pdCAtPiB1bml0XG4gICAgICA9IFwibWxfY2FudmFzX2luaXRcIlxuXG4gICAgZXh0ZXJuYWwgcnVuX2ludGVybmFsIDpcbiAgICAgIChJbnRlcm5hbEV2ZW50LnQgLT4gdW5pdCkgLT4gKHVuaXQgLT4gJ2R1bW15MSkgLT4gJ2R1bW15MlxuICAgICAgPSBcIm1sX2NhbnZhc19ydW5cIlxuXG4gICAgZXh0ZXJuYWwgc3RvcCA6IHVuaXQgLT4gdW5pdFxuICAgICAgPSBcIm1sX2NhbnZhc19zdG9wXCJcblxuICAgIGV4dGVybmFsIGdldEN1cnJlbnRUaW1lc3RhbXAgOiB1bml0IC0+IEV2ZW50LnRpbWVzdGFtcFxuICAgICAgPSBcIm1sX2NhbnZhc19nZXRfY3VycmVudF90aW1lc3RhbXBcIlxuXG4gICAgZXh0ZXJuYWwgZ2V0Q2FudmFzIDogaW50IC0+IENhbnZhcy50XG4gICAgICA9IFwibWxfY2FudmFzX2dldF9jYW52YXNcIlxuXG4gICAgbGV0IHJ1biBrID1cbiAgICAgIGxldCBvcGVuIEludGVybmFsRXZlbnQgaW5cbiAgICAgIGxldCBvcGVuIEV2ZW50IGluXG4gICAgICBsZXQgaCBlID1cbiAgICAgICAgKG1hdGNoIGUgd2l0aFxuICAgICAgICB8IEZyYW1lQ3ljbGUgeyB0aW1lc3RhbXAgfSAtPlxuICAgICAgICAgICAgKCogSW50ZXJuYWwgdXNhZ2UgKilcbiAgICAgICAgICAgICgpXG4gICAgICAgIHwgRnJhbWUgeyBjYW52YXM7IHRpbWVzdGFtcCB9IC0+XG4gICAgICAgICAgICBsZXQgZSA9IHsgY2FudmFzOyB0aW1lc3RhbXA7IGRhdGEgPSAoKSB9IGluXG4gICAgICAgICAgICBzZXRfZXZlbnRfdGltZXN0YW1wIGUudGltZXN0YW1wOyBzZW5kX2ZyYW1lIGVcbiAgICAgICAgfCBDYW52YXNGb2N1c2VkIHsgY2FudmFzOyB0aW1lc3RhbXA7IGZvY3VzID0gSW4gfSAtPlxuICAgICAgICAgICAgbGV0IGUgPSB7IGNhbnZhczsgdGltZXN0YW1wOyBkYXRhID0gKCkgfSBpblxuICAgICAgICAgICAgc2V0X2V2ZW50X3RpbWVzdGFtcCBlLnRpbWVzdGFtcDsgc2VuZF9mb2N1c19pbiBlXG4gICAgICAgIHwgQ2FudmFzRm9jdXNlZCB7IGNhbnZhczsgdGltZXN0YW1wOyBmb2N1cyA9IE91dCB9IC0+XG4gICAgICAgICAgICBsZXQgZSA9IHsgY2FudmFzOyB0aW1lc3RhbXA7IGRhdGEgPSAoKSB9IGluXG4gICAgICAgICAgICBzZXRfZXZlbnRfdGltZXN0YW1wIGUudGltZXN0YW1wOyBzZW5kX2ZvY3VzX291dCBlXG4gICAgICAgIHwgQ2FudmFzUmVzaXplZCB7IGNhbnZhczsgdGltZXN0YW1wOyBzaXplIH0gLT5cbiAgICAgICAgICAgIGxldCBlID0geyBjYW52YXM7IHRpbWVzdGFtcDsgZGF0YSA9IHNpemUgfSBpblxuICAgICAgICAgICAgc2V0X2V2ZW50X3RpbWVzdGFtcCBlLnRpbWVzdGFtcDsgc2VuZF9yZXNpemUgZVxuICAgICAgICB8IENhbnZhc01vdmVkIHsgY2FudmFzOyB0aW1lc3RhbXA7IHBvc2l0aW9uIH0gLT5cbiAgICAgICAgICAgIGxldCBlID0geyBjYW52YXM7IHRpbWVzdGFtcDsgZGF0YSA9IHBvc2l0aW9uIH0gaW5cbiAgICAgICAgICAgIHNldF9ldmVudF90aW1lc3RhbXAgZS50aW1lc3RhbXA7IHNlbmRfbW92ZSBlXG4gICAgICAgIHwgQ2FudmFzQ2xvc2VkIHsgY2FudmFzOyB0aW1lc3RhbXAgfSAtPlxuICAgICAgICAgICAgbGV0IGUgPSB7IGNhbnZhczsgdGltZXN0YW1wOyBkYXRhID0gKCkgfSBpblxuICAgICAgICAgICAgc2V0X2V2ZW50X3RpbWVzdGFtcCBlLnRpbWVzdGFtcDsgc2VuZF9jbG9zZSBlXG4gICAgICAgIHwgS2V5QWN0aW9uIHsgY2FudmFzOyB0aW1lc3RhbXA7IGtleTsgY2hhcjsgZmxhZ3M7IHN0YXRlID0gRG93biB9IC0+XG4gICAgICAgICAgICBsZXQgZSA9IHsgY2FudmFzOyB0aW1lc3RhbXA7IGRhdGEgPSB7IGtleTsgY2hhcjsgZmxhZ3MgfSB9IGluXG4gICAgICAgICAgICBzZXRfZXZlbnRfdGltZXN0YW1wIGUudGltZXN0YW1wOyBzZW5kX2tleV9kb3duIGVcbiAgICAgICAgfCBLZXlBY3Rpb24geyBjYW52YXM7IHRpbWVzdGFtcDsga2V5OyBjaGFyOyBmbGFnczsgc3RhdGUgPSBVcCB9IC0+XG4gICAgICAgICAgICBsZXQgZSA9IHsgY2FudmFzOyB0aW1lc3RhbXA7IGRhdGEgPSB7IGtleTsgY2hhcjsgZmxhZ3MgfSB9IGluXG4gICAgICAgICAgICBzZXRfZXZlbnRfdGltZXN0YW1wIGUudGltZXN0YW1wOyBzZW5kX2tleV91cCBlXG4gICAgICAgIHwgQnV0dG9uQWN0aW9uIHsgY2FudmFzOyB0aW1lc3RhbXA7IHBvc2l0aW9uOyBidXR0b247IHN0YXRlID0gRG93biB9IC0+XG4gICAgICAgICAgICBsZXQgZSA9IHsgY2FudmFzOyB0aW1lc3RhbXA7IGRhdGEgPSB7IHBvc2l0aW9uOyBidXR0b24gfSB9IGluXG4gICAgICAgICAgICBzZXRfZXZlbnRfdGltZXN0YW1wIGUudGltZXN0YW1wOyBzZW5kX2J1dHRvbl9kb3duIGVcbiAgICAgICAgfCBCdXR0b25BY3Rpb24geyBjYW52YXM7IHRpbWVzdGFtcDsgcG9zaXRpb247IGJ1dHRvbjsgc3RhdGUgPSBVcCB9IC0+XG4gICAgICAgICAgICBsZXQgZSA9IHsgY2FudmFzOyB0aW1lc3RhbXA7IGRhdGEgPSB7IHBvc2l0aW9uOyBidXR0b24gfSB9IGluXG4gICAgICAgICAgICBzZXRfZXZlbnRfdGltZXN0YW1wIGUudGltZXN0YW1wOyBzZW5kX2J1dHRvbl91cCBlXG4gICAgICAgIHwgTW91c2VNb3ZlIHsgY2FudmFzOyB0aW1lc3RhbXA7IHBvc2l0aW9uIH0gLT5cbiAgICAgICAgICAgIGxldCBlID0geyBjYW52YXM7IHRpbWVzdGFtcDsgZGF0YSA9IHBvc2l0aW9uIH0gaW5cbiAgICAgICAgICAgIHNldF9ldmVudF90aW1lc3RhbXAgZS50aW1lc3RhbXA7IHNlbmRfbW91c2VfbW92ZSBlKTtcbiAgICAgICAgUGVuZGluZy5wcm9jZXNzICgpXG4gICAgICBpblxuICAgICAgcnVuX2ludGVybmFsIGgga1xuICBlbmRcblxuZW5kXG4iLCJcbm9wZW4gT2NhbWxDYW52YXMuVjFcblxubGV0ICgpID1cblxuICBCYWNrZW5kLmluaXQgKCk7XG5cbiAgbGV0IGMgPSBDYW52YXMuY3JlYXRlT25zY3JlZW4gfnRpdGxlOlwiSGVsbG8gd29ybGRcIlxuICAgICAgICAgICAgfnBvczooMzAwLCAyMDApIH5zaXplOig4MDAsIDUwMCkgKCkgaW5cblxuICBDYW52YXMuc2V0RmlsbENvbG9yIGMgQ29sb3Iub3JhbmdlO1xuICBDYW52YXMuZmlsbFJlY3QgYyB+cG9zOigwLjAsIDAuMCkgfnNpemU6KDgwMC4wLCA1MDAuMCk7XG5cbiAgQ2FudmFzLnNldFN0cm9rZUNvbG9yIGMgQ29sb3IuYmx1ZTtcbiAgQ2FudmFzLnNldExpbmVXaWR0aCBjIDEwLjA7XG4gIENhbnZhcy5tb3ZlVG8gYyAoNTAuMCwgNTAuMCk7XG4gIENhbnZhcy5saW5lVG8gYyAoNzUwLjAsIDUwLjApO1xuICBDYW52YXMubGluZVRvIGMgKDc1MC4wLCA0NTAuMCk7XG4gIENhbnZhcy5saW5lVG8gYyAoNTAuMCwgNDUwLjApO1xuICBDYW52YXMuY2xvc2VQYXRoIGM7XG4gIENhbnZhcy5zdHJva2UgYztcblxuICBDYW52YXMuY2xlYXJQYXRoIGM7XG4gIENhbnZhcy5tb3ZlVG8gYyAoMTUwLjAsIDM1MC4wKTtcbiAgQ2FudmFzLmJlemllckN1cnZlVG8gYyB+Y3AxOigzNTAuMCwgLTEwMC4wKVxuICAgIH5jcDI6KDQ1MC4wLCA2MDAuMCkgfnA6KDY1MC4wLCAxNTAuMCk7XG4gIENhbnZhcy5zdHJva2UgYztcblxuICBDYW52YXMuc2hvdyBjO1xuXG4gIGxldCBlMSA9XG4gICAgUmVhY3QuRS5tYXAgKGZ1biB7IEV2ZW50LmNhbnZhcyA9IF87IHRpbWVzdGFtcCA9IF87IGRhdGEgPSAoKSB9IC0+XG4gICAgICAgIEJhY2tlbmQuc3RvcCAoKVxuICAgICAgKSBFdmVudC5jbG9zZVxuICBpblxuXG4gIGxldCBlMiA9XG4gICAgUmVhY3QuRS5tYXAgKGZ1biB7IEV2ZW50LmNhbnZhcyA9IF87IHRpbWVzdGFtcCA9IF87XG4gICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSB7IEV2ZW50LmtleTsgY2hhciA9IF87IGZsYWdzID0gXyB9IH0gLT5cbiAgICAgICAgaWYga2V5ID0gS2V5RXNjYXBlIHRoZW5cbiAgICAgICAgICBCYWNrZW5kLnN0b3AgKClcbiAgICAgICkgRXZlbnQua2V5X2Rvd25cbiAgaW5cblxuICBCYWNrZW5kLnJ1biAoZnVuICgpIC0+IGlnbm9yZSBlMTsgaWdub3JlIGUyKVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBFbnN1cmUgdGhhdCBbYXRfZXhpdF0gZnVuY3Rpb25zIGFyZSBjYWxsZWQgYXQgdGhlIGVuZCBvZiBldmVyeSBwcm9ncmFtICopXG5cbmxldCBfID0gZG9fYXRfZXhpdCgpXG4iXX0=
